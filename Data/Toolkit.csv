ID,已采,已发,pid,content,title,date,view,comment,thumbs,userid,type,PageUrl
1,1,0,7,"
                    
<h2>编辑器&amp;Mac</h2>
<p>1、编辑器的使用<code>vs code</code></p>
<ul><li>插件</li></ul>
<ol><li>git辅助工具，可查看代码的书写者：<code>Git Blame</code>
</li></ol>
<p>2、 Mac工具使用</p>
<ul><li>强大终端  <a href=""https://www.iterm2.com/"" rel=""nofollow noreferrer"">item2</a>
</li></ul>
<p>3、在 macOS 中完美配置文件名大小写敏感（解决git默认对大小写不敏感问题）<a href=""https://zhuanlan.zhihu.com/p/35908178"" rel=""nofollow noreferrer"">解决git大小写不敏感</a></p>
<h2>知识篇</h2>
<h2>一、git使用</h2>
<ul>
<li>一般企业中使用代码管理工具Git开发时都是通过拉分支进行功能细致开发，所以掌握git的分支操作时必要的</li>
<li>使用Git下载指定分支命令为：<code>git clone -b 分支名仓库地址</code>
</li>
<li>
<p><strong>初始开发git操作流程</strong></p>
<ul>
<li>本地创建公钥<code>ssh-keygen -t rsa -C ""邮箱""</code>并配置</li>
<li>克隆最新主分支项目代码<code>git clone 地址</code>
</li>
<li>创建本地分支<code>git branch 分支名</code>
</li>
<li>查看本地分支<code>git branch</code>
</li>
<li>查看远程分支<code>git branch -a</code>
</li>
<li>切换分支<code>git checkout 分支名</code>(一般修改未提交则无法切换，大小写问题经常会有，可强制切换<code>git checkout 分支名 -f</code>非必须慎用)</li>
<li>将本地分支推送到远程分支<code>git push &lt;远程仓库&gt; &lt;本地分支&gt;:&lt;远程分支&gt;</code>
</li>
</ul>
</li>
</ul>
<hr>
<h3>必备知识点</h3>
<ul><li><strong>概念：</strong></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/bVFcx8?w=800&amp;h=227"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ol>
<li>
<strong>Remote:</strong>远程主仓库；</li>
<li>
<strong>Repository：</strong>本地仓库；</li>
<li>
<strong>Index：</strong>Git追踪树,暂存区；</li>
<li>
<strong>workspace：</strong>本地工作区（即你编辑器的代码）</li>
</ol>
<ul><li>一般操作流程：《工作区》-&gt; <code>git status</code>查看状态 -&gt; <code>git add .</code>将所有修改加入暂存区-&gt; <code>git commit -m ""提交描述""</code>将代码提交到本地仓库-&gt;<code>git push</code>将本地仓库代码更新到远程仓库</li></ul>
<hr>
<h3>一、git remote</h3>
<ul><li>为远程仓库指定别名，以便于管理远程主机，默认只有一个时为origin</li></ul>
<ol>
<li>查看主机名：<code>git remote</code>
</li>
<li>
<p>查看主机名即网址：<code>git remote -v</code></p>
<ul><li>默认克隆远程仓库到本地时，远程主机为origin，如需指定别名可使用<code>git clone -o &lt;别名&gt; &lt;远程git地址&gt; </code>
</li></ul>
</li>
<li>查看主机的详细信息<code>git remote show &lt;主机名&gt;</code>
</li>
<li>添加远程主机<code>git remote add &lt;主机名&gt; &lt;网址&gt;</code>
</li>
<li>删除远程主机<code>git remote rm &lt;主机名&gt;</code>
</li>
<li>修改远程主机的别名：<code>git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code>
</li>
</ol>
<hr>
<h3>二、git fetch</h3>
<ul><li>将某个远程主机的更新，全部/分支 取回本地（此时之更新了Repository）它取回的代码对你本地的开发代码没有影响，如需彻底更新需合并或使用<code>git pull</code>
</li></ul>
<ol>
<li>远程主机的更新，全部取回本地<code>git fetch &lt;远程主机名&gt;</code>；</li>
<li>将远程仓库特定分支更新到本地<code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code>
</li>
</ol>
<ul><li>如果需要将更新拉取但本地工作代码需要合并到本地某一分支<code>git merge &lt;被合并的远程分支&gt;</code>或者在此基础上创建出新分支并切换<code>git checkout -b &lt;分支名&gt; &lt;在此分支上创建&gt;</code>
</li></ul>
<hr>
<h3>三、git pull</h3>
<ul><li>拉取远程主机某分支的更新，再与本地的指定分支合并（相当与fetch加上了合并分支功能的操作）</li></ul>
<ol>
<li>拉取远程某分支并与本地某一分支合并（没有则默认会创建）：<code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>
</li>
<li>如果远程分支是与当前所在分支合并，则冒号后面的部分可以省略：<code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;</code>
</li>
<li>如果当前分支与远程分支存在追踪关系,则可以省略远程分支名：<code>git pull &lt;远程主机名&gt;</code>
</li>
<li>如果当前分支只有一个追踪分支，则远程主机名都可以省略：<code>git pull</code>
</li>
</ol>
<h3>三、git push</h3>
<ul><li>将本地分支的更新，推送到远程主机，其命令格式与<code>git pull</code>相似</li></ul>
<ol>
<li>将本地分支推送到远程分支：<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>
</li>
<li>
<p>如果省略远程分支名，则默认为将本地分支推送到与之关联的远程分支：(一般设置本地分支和与之关联的远程分支同名，防止混淆)<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;</code></p>
<ul><li>如果对应的远程分支不存在，则会被创建（m默认与本地分支同名）</li></ul>
</li>
<li>如果省略本地分支名，则表示删除指定的远程分支，这等同于推送一个空的本地分支到对应远程分支：<code>git push origin :&lt;远程分支&gt;</code> 等同于 <code>git push origin --delete &lt;远程分支&gt;</code>
</li>
<li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略<code>git push origin</code>
</li>
<li>如果当前分支只有一个追踪分支，那么主机名也可以省略：<code>git push</code>
</li>
<li>如果当前分支与多个主机存在追踪关系(使用场景相对来说较少)，可以使用-u指定默认推送主机<code>git push -u origin &lt;主机名&gt;</code>设置时候需推送便可以直接使用<code>git push</code>
</li>
<li>将本地的所有分支都推送到远程主机:<code>git push --all origin</code>
</li>
<li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。如果一定要推送，可以使用<code>--force</code>选项(谨慎使用，除非你非常确认):<code>git push --force origin</code>
</li>
</ol>
<ul><li>
<strong>注意</strong>:分支推送顺序的格式为<strong>&lt;来源地&gt;:&lt;目的地&gt;</strong>，所以<code>git pull</code>格式：<strong>&lt;远程分支&gt;:&lt;本地分支&gt;</strong>，<code>git push</code>格式为：<strong>&lt;本地分支&gt;:&lt;远程分支&gt;</strong>。</li></ul>
<hr>
<h3>四、分支操作</h3>
<ol>
<li>创建本地分支：<code>git branch test</code>:(创建名为test的本地分支)</li>
<li>切换分支：<code>git checkout test</code>:(切换到test分支)</li>
<li>创建并切换分支<code>git branch -b test</code>:(相当于以上两条命令的合并)</li>
<li>查看本地分支：<code>git branch</code>
</li>
<li>查看远程仓库所有分支：<code>git branch -a</code>
</li>
<li>删除本地分支：<code>git branch -d test</code>:(删除本地test分支)</li>
<li>分支合并：<code>git merge master</code>:(将master分支合并到当前分支)</li>
</ol>
<ul><li><strong>分支关联：</strong></li></ul>
<ol><li>查看当前的本地分支与远程分支的关联关系:<code>git branch -vv</code>
</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWnw?w=2066&amp;h=312"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<ol><li>把当前本地分支与远程origin的某分支进行关联处理(通过 --set-upstream-to 命令):<code>git branch --set-upstream-to=origin/feature/clear-server-eslint-error_180713</code>
</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWon?w=2476&amp;h=652"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<ul><li><strong>分支差异查看</strong></li></ul>
<ol>
<li>查看本地当前分支与远程某一分支的差异：<code>git diff origin/feature/reserve-3.4</code>
</li>
<li>查看本地特定分支与远程分支的差异：<code>git diff master  origin/feature/reserve-3.4 </code>(查看本地master分支与远程feature/reserve-3.4分支的差异，如图)</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWoZ?w=1482&amp;h=670"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<hr>
<h3>五、修改撤销</h3>
<ol>
<li>
<code>git checkout -- &lt;文件名&gt;</code>：丢弃工作区的修改，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</li>
<li>
<code>git reset HEAD &lt;文件名&gt;</code>：把暂存区的修改撤销掉（unstage），重新放回工作区。</li>
<li>
<p><code>git reset --hard commit_id</code>:git版本回退，回退到特定的commit_id版本</p>
<ul>
<li>流程：</li>
<li>
<code>git log</code>查看提交历史，以便确定要回退到哪个版本(commit 之后的即为ID);</li>
</ul>
</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWlD?w=1380&amp;h=472"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<ul>
<li>
<code>git reset --hard commit_id</code>:回退到commit_id版本；</li>
<li>
<p><code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本;</p>
<ul><li>更新远程代码到本地<br>git fetch origin master(分支)<br>git pull  // 将fetch下来的代码pull到本地<br>git diff master origin/master // 查看本地分支代码和远程仓库的差异</li></ul>
</li>
</ul>
<h3>六、配置</h3>
<ul>
<li>
<code>git config -l </code>// 陈列出所有的git配置项</li>
<li>
<code>git config core.ignorecase false</code> //配置git不忽略大小写（默认忽略）参照(git 大小写)</li>
</ul>
<blockquote>
<strong>“积跬步、行千里”</strong>—— 持续更新中~，喜欢留下个赞哦！</blockquote>
<ul>
<li>
<p>往期经典好文：</p>
<ol>
<li><a href=""https://segmentfault.com/a/1190000015162142"" rel=""nofollow noreferrer"">JavaScript经典面试题汇总</a></li>
<li><a href=""https://segmentfault.com/a/1190000015268943"" rel=""nofollow noreferrer"">我的前端面试日记</a></li>
</ol>
</li>
<li>
<p>相关好文推荐：</p>
<ol><li><a href=""https://segmentfault.com/a/1190000015017908"" rel=""nofollow noreferrer"">http报文详解</a></li></ol>
</li>
</ul>

                ", 团队合作必备的Git操作,1531977670,564,1,323,1,1,https://segmentfault.com/a/1190000015676846
2,1,0,7,"
                    
<h1>EWA (微信小程序增强开发工具)</h1>
<p>Enhanced Wechat App Development Toolkit (微信小程序增强开发工具)</p>
<p>项目地址：<a href=""https://github.com/lyfeyaj/ewa"" rel=""nofollow noreferrer"">https://github.com/lyfeyaj/ewa</a>，欢迎试用 ~</p>
<p>喜欢么？或者对您有用？ <a href=""https://github.com/lyfeyaj/ewa"" rel=""nofollow noreferrer"">☞ 立即去 ⭐️ Star ⭐️ 一下 ☞</a></p>
<h2>为什么开发这个工具？</h2>
<p>厌倦了不停的对比 <a href=""https://github.com/Tencent/wepy"" rel=""nofollow noreferrer"">wepy</a> 或者 <a href=""https://github.com/Meituan-Dianping/mpvue"" rel=""nofollow noreferrer"">mpvue</a> 的特性，间歇性的踩雷，以及 <code>code once, run everywhere</code> 的幻想。只想给小程序开发插上效率的翅膀 ~</p>
<h2>功能特性</h2>
<ol>
<li>async/await 支持</li>
<li>Javascript ES2017 语法</li>
<li>原生小程序所有功能</li>
<li>微信接口 Promise 化</li>
<li>支持安装 NPM 包</li>
<li>支持 SCSS 以及 小于 16k 的 background-image</li>
<li>支持 source map, 方便调试</li>
<li>添加新页面或新组件无需重启编译</li>
<li>允许自定义编译流程</li>
</ol>
<p>更多特性正在赶来 ... 敬请期待 👇</p>
<ul>
<li>LESS 支持</li>
<li>可跨项目复用的小程序组件或页面（通过NPM包管理）</li>
<li>Redux 支持</li>
<li>Mixin 支持</li>
</ul>
<h2>安装</h2>
<p>需要 node 版本 &gt;= 8</p>
<pre><code class=""bash"">npm i -g ewa-cli 或者 yarn global add ewa-cli</code></pre>
<h2>如何使用</h2>
<h3>创建新项目</h3>
<pre><code class=""bash"">ewa new your_project_name</code></pre>
<h3>集成到现有小程序项目，仅支持小程序原生开发项目转换</h3>
<p><strong><em>注意：使用此方法，请务必对项目代码做好备份！！！</em></strong></p>
<pre><code class=""bash"">cd your_project_dir &amp;&amp; ewa init</code></pre>
<h3>启动</h3>
<p>运行 <code>npm start</code> 即可启动实时编译</p>
<p>运行 <code>npm run build</code> 即可编译线上版本（相比实时编译而言，去除了 source map 并增加了代码压缩混淆等，体积更小）</p>
<p>上述命令运行成功后，可以看到本地多了个 <code>dist</code> 目录，这个目录里就是生成的小程序相关代码。</p>
<p>使用<a href=""https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html"" rel=""nofollow noreferrer"">微信开发者工具</a>选择 <code>dist</code> 目录打开，即可预览项目</p>
<h3>目录结构</h3>
<pre><code>├── .ewa                         特殊占位目录，用于检查是否为 ewa 项目
├── dist                         小程序运行代码目录（该目录由ewa的start 或者 build指令自动编译生成，请不要直接修改该目录下的文件）
├── node_modules                 外部依赖库
├── src                          代码编写的目录（该目录为使用ewa后的开发目录）
│   ├── components               小程序组件目录
│   ├── pages                    小程序页面目录
│   │   ├── index
│   │   │   ├── index.js
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   └── logs
│   │       ├── logs.js
│   │       ├── logs.json
│   │       ├── logs.wxml
│   │       └── logs.wxss
│   ├── templates                小程序模版目录
│   ├── utils
│   │   └── util.js
│   ├── app.js                   小程序入口文件
│   ├── app.json                 小程序全局配置文件
│   ├── app.wxss                 小程序全局样式文件
│   └── project.config.json      微信开发者工具小程序项目配置文件
├── ewa.config.js                ewa 配置文件
├── .gitignore
├── .eslintrc.js                 eslint 配置
└── package.json</code></pre>
<h2>微信接口 Promise 化</h2>
<pre><code class=""javascript"">const { wx } = require('ewa');

Page({
  async onLoad() {
    let { data } = await wx.request({ url: 'http://your_api_endpoint' });
  }
})</code></pre>
<h2>配置</h2>
<p>ewa 通过 <code>ewa.config.js</code> 来支持个性化配置。如下所示：</p>
<pre><code class=""javascript"">// ewa.config.js

module.exports = {
  // 公用代码库 (node_modules 打包生成的文件)名称，默认为 vendors.js
  commonModuleName: 'vendors.js',

  // 通用模块匹配模式，默认为 /[\\/]node_modules[\\/]/
  commonModulePattern: /[\\/]node_modules[\\/]/,

  // 是否简化路径，作用于 page 和 component，如 index/index.wxml=&gt; index.wxml，默认为 false
  simplifyPath: false,

  // 文件夹快捷引用
  aliasDirs: [
    'apis',
    'assets',
    'constants',
    'utils'
  ],

  // 需要拷贝的文件类型
  copyFileTypes: [
    'png',
    'jpeg',
    'jpg',
    'gif',
    'svg',
    'ico'
  ],

  // webpack loader 规则
  rules: [],

  // webpack 插件
  plugins: [],

  // 嫌不够灵活？直接修改 webpack 配置
  webpack: function(config) {
    return config;
  }
};</code></pre>
<h2>常见问题 &amp; Tips</h2>
<ol>
<li>wxss 中可以直接编写 scss 样式代码</li>
<li>可以使用 <code>@</code> 来代替<strong>源代码根目录</strong>来引入代码或样式，如 <code>const utils = require('@/utils/util')</code>
</li>
</ol>

                ", 一款小程序增强开发工具 - EWA,1531977672,380,1,290,1,1,https://segmentfault.com/a/1190000015653494
3,1,0,7,"
                    
<p>前段时间（端午节期间）折腾电脑，用虚拟机安装<code>mac 10.13</code>，但安装包太大，6.5G。<br>顺便放下我安装时参考的链接，说不定有人也想安装<code>mac</code>试试，不过我试验的是安装后比较卡。<a href=""https://blog.csdn.net/icarus666/article/details/79536388"" rel=""nofollow noreferrer"">验证在vm12下安装os 10.13的可行性（同适用 os 10.12.6）</a><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015638800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""虚拟机安装codemac/code后截图.png"" title=""虚拟机安装codemac/code后截图.png""></span></p>
<p>文件在百度网盘中，但大家都知道百度云管家下载限制下载速度，按照限制的下载速度，不知道要下载到猴年马月。</p>
<h3>
<code>Proxyee-down</code> 百度网盘下载神器</h3>
<p>于是我发现了一款百度网盘下载神器【<code>Proxyee-down</code>】（支持<code>Win/Mac/Linux</code>的百度云文件下载工具），据说下载速度不止2M/s，可以跑到20M/s。当然也跟所在网络环境有关。总之要比官方百度云管家下载速度要快。<br><a href=""https://pan.lanzou.com/b203390"" rel=""nofollow noreferrer"">下载地址（根据不同系统安装不同版本）</a><br>项目开源，安装教程等相关都可以在这个链接里找到。我就不附图了。<br><a href=""https://github.com/proxyee-down-org/proxyee-down"" rel=""nofollow noreferrer""><code>proxyee-down</code>项目地址</a></p>
<h3>云盘万能钥匙 插件</h3>
<p>既然推荐了百度网盘下载工具，那就再推荐 云盘万能钥匙这个插件。<br><a href=""http://www.ypsuperkey.com/"" rel=""nofollow noreferrer"">云盘万能钥匙官网</a><br><a href=""https://chrome.google.com/webstore/detail/%E4%BA%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/anlllmnpjodopgbkbpnghnjlelnogfjc?hl=zh-CN"" rel=""nofollow noreferrer"">谷歌应用商店安装地址</a><br>官方是这样推荐的。<br>1.自动识别并填写提取密码，懒癌患者的福音<br>2.每当点击一个分享链接，却提示我分享已失效时，我的内心是崩溃的<br>3.尊重个人隐私<br>可以根据不同浏览器下载安装不同版本插件。不科学上网也可以下载安装。如何科学上网就自行百度研究了。简要推荐一个插件<code>skyZIP-Proxy</code>。<br><a href=""http://www.ypsuperkey.com/helps/add-ypsuperkey-to-chrome"" rel=""nofollow noreferrer"">在谷歌浏览器中离线安装、卸载和更新云盘万能钥匙</a></p>
<p>可能谷歌浏览器版本太高，以前直接拖拽到扩展中心安装的方案是无效的。具体如何离线安装可以参看这篇文章<a href=""https://www.jianshu.com/p/12ca04c61fc6"" rel=""nofollow noreferrer"">如何在谷歌浏览器中安装.crx扩展名的离线Chrome插件？</a>，也可以参看上文推荐【在谷歌浏览器中安装、卸载和更新云盘万能钥匙】文章。<br>不过还是简单说下离线安装步骤：把下载下<code>YPSuperKey-For-Chrome-Only.crx</code>文件，（如果没有扩展名，那设置显示）改成<code>YPSuperKey-For-Chrome-Only.zip</code>，然后用好压等工具解压出来。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015638801"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""YPSuperKey-For-Chrome-Only文件夹.png"" title=""YPSuperKey-For-Chrome-Only文件夹.png""></span></p>
<p>打开<code>chrome</code>浏览器，按图所示，依次打开【更多工具】 -  【扩展程序】 - 勾选【开发者模式】【加载已解压的扩展程序】，选择刚刚的文件夹，安装这个插件成功了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015638802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""【更多工具】 -  【扩展程序】.png"" title=""【更多工具】 -  【扩展程序】.png""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015638803"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""开发模式 - 加载已解压的扩展程序.png"" title=""开发模式 - 加载已解压的扩展程序.png""></span></p>
<h3>
<code>ghostery</code> 隐私广告拦截工具 插件</h3>
<p>说到隐私，推荐这个插件，能够屏蔽网站统计收集用户信息。<br><a href=""https://chrome.google.com/webstore/detail/ghostery-%E2%80%93-privacy-ad-blo/mlomiejdfkolichcflejclcbmpeaniij"" rel=""nofollow noreferrer"">应用商店下载安装</a></p>
<h3>二维码生成 插件</h3>
<p>有时需要手机上访问电脑浏览器上某个地址，直接输入太长，不现实。这时候这个插件就很有用了。<br><a href=""https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg"" rel=""nofollow noreferrer"">应用商店下载安装地址</a></p>
<h3>云盘精灵，一个更好的网盘搜索引擎</h3>
<p><a href=""https://www.yunpanjingling.com/"" rel=""nofollow noreferrer"">云盘精灵官网</a> 这网站有时需要科学上网访问。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015638804"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""搜索罗小川chuan的结果，之前写的文章配套资源.png"" title=""搜索罗小川chuan的结果，之前写的文章配套资源.png""></span></p>
<p>官方是这样推荐的。</p>
<ol>
<li>基于【云盘万能钥匙】收录的海量数据</li>
<li>支持搜索带提取密码的分享资源</li>
<li>资源链接失效时立即移除出搜索数据库</li>
<li>简洁清新的界面设计（没有低俗的广告）</li>
</ol>
<h3>
<code>adblock-plus</code> 屏蔽广告插件。</h3>
<p>说到广告啊。我用<code>chrome</code>  <code>adblock-plus</code>插件 <br><a href=""https://chrome.google.com/weipibstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb"" rel=""nofollow noreferrer"">应用商店安装地址</a><br>屏蔽各种网站广告。</p>
<h3>网页截图插件 <code>fireShot</code> , 系统截图<code>PicPick</code>软件</h3>
<p><a href=""https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg"" rel=""nofollow noreferrer"">应用商店下载地址</a><br>有时需要截取整个网页，这个插件可以做到。<br>跳出网站，系统截图我推荐<code>PicPick</code>软件。<br><a href=""https://picpick.app/"" rel=""nofollow noreferrer""><code>PicPick</code>官网</a><br>说到截图顺带提下，win系统下，按<code>PrintScreen</code>键截取整个屏幕、按<code>Alt</code>键+<code>PrintScreen</code>键截取活动窗口、按<code>Win键+</code>PrintScreen<code>键截取整个屏幕，并保存在【图片】 - 【屏幕截图】 中，一般是</code>C:Users{你的用户名}PicturesScreenshots<code>中。（PS:这个按Win键+</code>PrintScreen`键，我也是前不久才发现，真是活到老，学到老。）</p>
<h3>鼠标手势插件 <code>crxMouse</code> 插件</h3>
<p>鼠标右击画一些手势，可以操作浏览器，控制前进、后退，关闭，翻页等。很好用。<br><a href=""https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo"" rel=""nofollow noreferrer"">应用商店地址</a></p>
<h3>
<code>OneTab</code>  插件，节省内存，减轻标签页混乱现象</h3>
<p><a href=""https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall"" rel=""nofollow noreferrer"">应用商店下载安装地址</a><br>官方是这样推荐的：节省高达95％的内存，并减轻标签页混乱现象<br>有时打开很多页面，没有及时关闭，就占用挺大内存，这个插件可以一键收起。以后再打开。当然还有更多功能。</p>
<h3>
<code>octotree</code> 树形结构 查看<code>github</code>项目</h3>
<p><a href=""https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US"" rel=""nofollow noreferrer"">应用商店下载安装地址</a><br><a href=""https://github.com/buunguyen/octotree"" rel=""nofollow noreferrer"">github项目地址</a></p>
<h3>
<code>Octo Mate</code>, 增强你的 <code>github</code> 体验</h3>
<p>能一键下载文件和目录形式查看文档等。<br><a href=""https://chrome.google.com/webstore/detail/octo-mate/baggcehellihkglakjnmnhpnjmkbmpkf"" rel=""nofollow noreferrer"">应用商店下载安装地址</a></p>
<h3>一键管理 扩展 插件</h3>
<p>安装了那么多插件，不常用的可以先停用，这个插件可以一键管理这些插件。<br><a href=""https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86/kfjmkgngkgpgjdoealkmmajmmhpnffoj"" rel=""nofollow noreferrer"">应用商店下载安装地址</a></p>
<h3>小结</h3>
<p>当然我安装了很多插件和软件，先推荐这些给大家，后续有时间再更新。还有更多好玩实用的插件和软件等着我们去发掘。<br>写到这里好久之前写过这样一篇文章<a href=""https://www.jianshu.com/p/93d9fbb9ad92"" rel=""nofollow noreferrer"">提高效率的电脑技巧及软件</a>，可以看看。<br>本着<strong>学我所学，为我所用，服务他人</strong>的宗旨^_^，这篇文章主要推荐了：<br>1、<code>Proxyee-down</code> 百度网盘下载神器<br>2、云盘万能钥匙 插件<br>3、<code>ghostery</code> 隐私广告拦截工具 插件<br>4、二维码生成 插件<br>5、云盘精灵，一个更好的网盘搜索引擎<br>6、<code>adblock-plus</code> 屏蔽广告插件。<br>7、网页截图插件 <code>fireShot</code> , 系统截图<code>PicPick</code>软件<br>8、鼠标手势插件 <code>crxMouse</code> 插件<br>9、<code>OneTab</code>  插件，节省内存，减轻标签页混乱现象<br>10、<code>Octotree</code> 树形结构 查看<code>github</code>项目<br>11、<code>Octo Mate</code>, 增强 <code>github</code> 体验<br>12、一键管理 扩展 插件</p>
<p>文章同时发布在我的个人博客上：<a href=""http://lxchuan12.github.io/2018/07/14/20180714-some%20baiduyunpan-and%20chrome%20crx/"" rel=""nofollow noreferrer"">分享百度网盘下载搜索神器和一些实用浏览器插件</a></p>

                ", 分享百度网盘下载搜索神器和一些实用浏览器插件,1531977673,389,1,366,1,1,https://segmentfault.com/a/1190000015638797
4,1,0,7,"
                    
<h2>art-dialog-vue —— 经典、优雅的网页对话框控件</h2>
<h3>优点</h3>
<ol>
<li>支持普通与 12 方向气泡状对话框</li>
<li>支持 ARIA 标准</li>
<li>面向未来：基于 HTML5 Dialog 的 API</li>
<li>支持标准与模态对话框</li>
<li>丰富且友好的编程接口</li>
<li>能自适应内容尺寸</li>
</ol>
<h3>安装</h3>
<pre><code> npm install art-dialog-vue //插件文件在plugin目录下</code></pre>
<h3>url引入</h3>
<pre><code>&lt;script src=""plugin/dist/static/css/dialog.min.css""&gt;&lt;/script&gt;
&lt;script src=""plugin/dist/static/js/dialog.js""&gt;&lt;/script&gt;
&lt;script&gt;
    Vue.use(Dialog.default)//使用插件,注意以url引入时use的参数是Dialog.default
&lt;/script&gt;</code></pre>
<h3>模块化引入</h3>
<pre><code>import Dialog from 'art-dialog-vue' //esm
const Dialog = require('art-dialog-vue').default //RequireJS，非esm形式要加.default
Vue.use(Dialog)//使用插件</code></pre>
<h3>基本使用</h3>
<pre><code>const d = Vue.dialog({
    title: 'art-dialog-vue',
    content: {
              template: '&lt;div&gt;{{name}}，欢迎使用&lt;/div&gt;',
              data() {
                  return {
                      name: 'hello'
                }
              }
    },
    button: [
     {
         id: '1',
         value: '确定',
         callcack() {      
            //do something                                      
            return false;//返回false 表示弹窗不关闭
        }
     },
     {
         id: '2',
         value: '取消',
         callcack() {      
            //do something                                      
            return false;//返回false 表示弹窗不关闭
        }
     },
    ]
});
d.show();</code></pre>
<p>详细使用文档请参考：<a href=""https://leeseean.github.io/vue-dialog-API/"" rel=""nofollow noreferrer"">https://leeseean.github.io/vu...</a>，项目github地址：<a href=""https://github.com/leeseean/vue-dialog"" rel=""nofollow noreferrer"">https://github.com/leeseean/v...</a>（求star）</p>

                ", 基于vue.js的dialog插件art-dialog-vue2.0发布,1531977674,492,1,346,1,1,https://segmentfault.com/a/1190000015599611
5,1,0,7,"
                    
<h1>背景</h1>
<p>前阵子老美的Audit要求各个开发组截图各自repository的Sonar Analysis Report，我跑去Sonarqube一看。。。好家伙！全是红灯，简直惨不忍睹</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAmb?w=1310&amp;h=1204"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>当然这其中有历史问题，因为我们是半路接管的欧美team的code，很多issue都是old code所遗留的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAmA?w=500&amp;h=327"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>不逃避责任，其中也有一部分是我们后续提交的新代码造成的，通过项目2年来的日积月累，issue多的有点积重难返，sonarqube虽然在每次jenkins build都会生成report，但是我们却没有把它作为build成功失败的一个硬指标。只要build成功通过QA测试就好了嘛！管他娘的sonar quality gate</p>
<h1>结果</h1>
<p>为了出一份体面漂亮的report给audit，我不得不快马加鞭的checkout -b quick_fix_sonar_issues, 花了一整天的功夫把block和critical的issue降到了阈值以下。</p>
<p><strong>临阵磨枪的我体会到了以下3个痛点</strong></p>
<ol>
<li>有些Sonar能检测出来的issue，确实能规避一些产品上的潜在bug</li>
<li>有些同事在code中犯的错误真的很低级，但是人工code review中很难被发现，不是我的锅，我现在却在为同事擦屁股。</li>
<li>虽然快速fix了issue，但是code的owner并不是我，我有可能为了迎合sonar的rule而产生了潜在的新的issue，而和owner去一一check又增加了很多沟通成本，另外owner很有可能已经离职了</li>
</ol>
<h1>思考</h1>
<p>囧则思变！如何改进我们的开发流程？在代码开发阶段就能让Sonar分析出问题？强制owner必须解决完issue才能提交代码？<br>嗯！是时候对目前存在弊端的开发流程进行改进了！</p>
<h3>老的开发流程</h3>
<p>先介绍下目前的基础设施：</p>
<ul>
<li>通过GitHub来管理source</li>
<li>通过Github Pull Request来实现Code Review（以前用gerrit但是我以UI太丑为由号召开发们拒绝使用）</li>
<li>通过Jenkins来实现持续集成</li>
<li>通过Sonarqube来实现代码分析（形同虚设）</li>
</ul>
<p>老的流程：</p>
<ol>
<li>当一个新feature来临时</li>
<li>owner从master（受保护的）分支checkout 一个feature_dev_branch做开发</li>
<li>开发完成后，提交pull request（PR）请求合并到master</li>
<li>技术leader对PR进行code review并approve后，feature_dev_branch合并到master。</li>
<li>Merge触发触发Jenkins自动build，Jenkins触发Sonarqube scan产生report（仅仅生成report）</li>
<li>Build成功则进行package的deploy以及后续Automation Testing等流程</li>
<li>交付QA测试</li>
</ol>
<h3>改进后的开发流程：</h3>
<ol>
<li>当一个新feature来临时</li>
<li>owner从master （受保护的）分支checkout 一个feature_dev_branch做开发</li>
<li>开发完成后，提交pull request（PR）请求合并到master</li>
<li><strong>PR自动触发Jenkins，Jenkins触发Sonar分析本次提交的new code</strong></li>
<li><strong>Sonar将report和issue以comments的方式写到Github PR里，并作为硬性的check point</strong></li>
<li><strong>Owner对PR进行反复commit直至通过Sonar的分析</strong></li>
<li>技术leader对PR进行code review并approve后，feature_dev_branch合并到master。</li>
<li>Merge触发触发Jenkins自动build，Jenkins触发Sonarqube scan产生report（仅仅生成report）</li>
<li>Build成功则进行package的deploy以及后续Automation Testing等流程</li>
<li>交付QA测试</li>
</ol>
<p>加了3步，使得new code通过sonar检测成为一个硬性指标，把issue扼杀在萌芽中，把锅甩在最前面</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAtz?w=1564&amp;h=1276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAtq?w=1552&amp;h=1272"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAzt?w=1706&amp;h=822"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>哇！！！太Cool了！</h1>
<h2>跟我一步步完成Jenkins和Sonar的配置</h2>
<p>什么？你竟然不知道Jenkins是个啥？！那你操个哪门子的心去优化开发流程，好好搬你的砖，写你的bug！<br>咳咳！建议你转发本文给负责devops的同事，请他吃饭让他帮忙配置</p>
<h4>Jenkins需要一个plugin，叫做github pull request builder</h4>
<p>它的作用是生成在Jenkins和Github之间生成webhook，似的PR可以自动触发Jenkins的Build</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAuI?w=2090&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>稍微配置下这个插件，画红线的地方很重要</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAvu?w=2594&amp;h=1184"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>Jenkins还需要一个plugin，叫做SonarQube Scanner</h4>
<p>它的作用是让Jenkins去触发Sonar的分析</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAwl?w=2436&amp;h=556"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>稍微配置下这个插件，画红线的地方很重要</h4>
<p>没听说的Sonar？没有现成的Sonar Server? 额，继续请devops吃饭吧...</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAxr?w=1920&amp;h=868"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAw5?w=1846&amp;h=1114"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>Sonarqube里（注意是Sonarqube里，不是Jenkins里）也需要安装一个plugin，名字叫 Github</h4>
<p>它的作用是 当Sonar检测完毕后，把生成的report和issue的分析以comments的方式写回到Github的PR中</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAxG?w=2796&amp;h=608"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>稍微配置下这个插件，画红线的地方很重要</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAxN?w=1546&amp;h=934"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>接下去就是配置Jenkins的project了</h4>
<p>废话不多，只贴关键配置，红线部分很重要</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAxR?w=1850&amp;h=1014"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAyl?w=1852&amp;h=940"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>Advanced里可以勾上这一条（虽然是Dangerous），因为我们Github是企业版，所以能提PR的人是有权限控制的，如果是用官网的github管理代码请慎用这个选项，建议使用黑白名单来控制触发的条件。<br><span class=""img-wrap""><img data-src=""/img/bVbdAyo?w=1142&amp;h=70"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>以下是Sonar的配置，很重要，注意analysis mode只能选择preview，preview mode不会真正的在Sonar上生成report哦。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdAzd?w=2118&amp;h=978"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>写在最后</h1>
<p>Jenkins的安装，Sonar的安装啥的，教程我就不放link了，这种大路教程一搜一大堆（我个人建议你用docker安装）<br>作为一个开发，我觉得这些基本的，能提升工作效率的工具还是要掌握一下的，并不是说只有devops才会用到这些工具，谁不喜欢偷懒呢，这些都是偷懒的好帮手。</p>
<p>截止发稿时，这个流程还存在一些些小bug，比如preview mode的sonar分析不能跟sonar中quality gate进行结合，sonar js不能分析parse有问题的js文件等等，还显得不够完美，我们也在通过其它的workaround来100%实现理想中的开发流程，如果你有好的建议欢迎留言。</p>

                ", 多人协同开发如何保证代码质量！看看这篇《理想中的Jenkins+Sonar+Github代码质量管理》,1531977675,348,1,826,1,1,https://segmentfault.com/a/1190000015592863
6,1,0,7,"
                    
<p>SAPI是一个及其精简的Restful API输出工具，诞生的背景是基于目前微服务开发接口，很多中小型项目开发人员在对接口测试时不仅需要使用JUnit等进行业务接口测试，还需要对API进行自测。所以SAPI很好的解决了开发人员需要一个一个参数的往接口测试工具填写调试的反复过程。</p>
<p>目前SAPI只需要开发人员引入stater后再启动类加入一行文件即可。下面我们直接看看使用时是什么样的。</p>
<p>1.<a href=""https://github.com/xiaour/spring.boot.sapi.starter/releases"" rel=""nofollow noreferrer"">下载并打包Jar</a>后配置好POM</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaour&lt;/groupId&gt;
   &lt;artifactId&gt;xiaour.springboot.sapi.starter&lt;/artifactId&gt;
   &lt;version&gt;1.0&lt;/version&gt;
   &lt;scope&gt;system&lt;/scope&gt;
   &lt;systemPath&gt;${project.basedir}/libs/xiaour.springboot.sapi.starter-1.0.jar&lt;/systemPath&gt;
&lt;/dependency&gt;
</code></pre>
<p>2.启动类加入注解Sapi和ServletComponentScan</p>
<pre><code>@Sapi(controllers = {""com.example.demo.ctrl"",""com.example.demo.ctrl2""})
@ServletComponentScan(basePackages = {""com.github.xiaour.api_scanner.servlet""})
@ComponentScan
@SpringBootApplication
public class DemoApplication {

   public static void main(String[] args) {
      SpringApplication.run(DemoApplication.class, args);
   }
}
</code></pre>
<p>这里说明一下Sapi的controllers是当前项目中需要被输入API的Controller路径，有多个的话配置多个即可。ServletComponentScan中的com.github.xiaour.api_scanner.servlet路径不要忽略。到这里我们的配置几乎就全部完成了。怎么样？是不是相当简单了。</p>
<p>3.如何使用Sapi？</p>
<p>启动项目后在浏览器打开地址 <a href=""http://127.0.0.1"" rel=""nofollow noreferrer"">http://127.0.0.1</a>:{服务端口}/{若有项目路径}/sapi 即可打开Sapi的接口列表页面；每个接口上都有一个绿色的运行按钮，点击运行按钮就会弹出接口详细内容页面（如下图）。点击Send就可以调试接口了。<br><span class=""img-wrap""><img data-src=""/img/bVbdakC?w=2008&amp;h=1272"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>好啦，各位可以立即使用sapi了，祝各位使用愉快</p>
<p>也欢迎大家访问<a href=""https://github.com/xiaour/spring.boot.sapi.starter"" rel=""nofollow noreferrer"">我的Git托管项目</a>或Star</p>

                ", SAPI 基于Spring极度简单的Restful API工具,1531977677,200,1,958,1,1,https://segmentfault.com/a/1190000015492016
7,1,0,7,"
                    <ul>
<li>
<p>把文件存入本地暂存区：</p>
<ul>
<li>把新建文件、修改过的文件存入本地暂存区：<code>git add .</code>
</li>
<li>把修改过的文件、删除的文件存入本地暂存区：<code>git add -u</code>
</li>
<li>把新建文件、修改过的文件、删除的文件存入本地暂存区: <code>git add -A</code>，相当于上两条之和</li>
</ul>
</li>
<li>将本地暂存区的文件推送到本地库：<code>git commit -m '修改提示'</code>
</li>
<li>查看当前 git 状态：<code>git status</code>
</li>
<li>从 github 上克隆项目: <code>git clone &lt;github url&gt;</code>
</li>
<li>
<p>将本地库文件的修改推送到绑定的 github: <code>git push</code></p>
<ul><li>
<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; </code><br>  比如我要将本地的wy分支推送到远程wy分支，使用： <br><code>git push origin wy:wy</code><br>  如果省略远程分支名，则表示将本地分支推送到与之存在""追踪关系""的远程分支（通常同名），如果该远程分支不存在，则会被新建。</li></ul>
</li>
<li>将远程库文件拉取到本地仓库： <code>git pull</code>
</li>
<li>
<p>分支：</p>
<ul>
<li>创建的新的分支：<code>git branch &lt;branch-name&gt;</code>
</li>
<li>
<p>查看分支：<code>git branch</code></p>
<ul><li>在 git bash 中用此命令，按键盘下键查看未显示部分，输入 <code>q</code> 退出</li></ul>
</li>
<li>切换分支： <code>git checkout &lt;branch-name&gt;</code>
</li>
<li>合并分支：<code>git merge origin/&lt;branch-name&gt; </code>合并之前要先切换到合并的目标分支上</li>
<li>删除分支：<code>git branch -d &lt;branch-name&gt;</code>
</li>
</ul>
</li>
<li>
<p>版本回退：</p>
<ul>
<li>
<p><code>git log</code> 会显示最近的三个版本，head 指针指向最近的版本，输入 <code>q</code> 可以退出<code>git log</code></p>
<ul><li>加上<code>--pretty=oneline </code>会简化信息</li></ul>
</li>
<li>
<p>版本回退：</p>
<ul>
<li>
<code>git reset --hard HEAD^ </code>回退到上一个版本，上上是<code>HEAD^^</code>，往上一百个是<code>HEAD~100</code>
</li>
<li>直接回退到commit-id所对应版本，<code>git reset --hard commit-id</code>
</li>
</ul>
</li>
<li>
<code>git reflog </code>可以查看git 的历史操作</li>
</ul>
</li>
<li>git 更改远程仓库地址：<code>git remote set-url origin &lt;新的url&gt;</code>
</li>
<li>
<p>本地仓库整体上传到远程仓库</p>
<ol>
<li>首先在github新建一个仓库（最好不要初始化README.md，因为远程仓库和本地仓库不一样，首先要<code>git pull</code>同步，经常出问题...）。</li>
<li>将本地仓库与远程仓库连起来：<br><code>git remote add origin git@github.com:yourname/仓库名.git</code>
</li>
<li><code>git push -u origin master</code></li>
</ol>
</li>
</ul>
                ", Git常用命令(持续更新),1531977678,546,1,825,1,1,https://segmentfault.com/a/1190000015489808
8,1,0,7,"
                    
<blockquote>随着团队的变大，最近在开发过程中，越来越感觉到commit log的重要性。之前的时候，团队内有人写中文log，有人写英文log；有人写的还算清晰，有人一笔更新bug就概括全貌。这些良莠不齐的commit log充斥在我们的项目中，不仅影响了查阅的效果，还会对code review产生负面的影响。因此，本文是意图从commit log的书写规范入手，并提供相应的解决方案。</blockquote>
<p><strong>注意</strong>：2016年1月6日，阮一峰老师写了一篇《<a href=""http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"" rel=""nofollow noreferrer"">Commit message 和 Change log 编写指南</a>》，本文主要来源于这篇文章，只是针对我们的团队，进行了一些改造和简化，以及对一些阮老师没有提及的细小之处进行了指出。</p>
<h2>1. 书写规范</h2>
<p>经过一番调研，因为我们是小团队，需要快速迭代，容易上手，所以对阮老师提到的commit log规范进行了<strong>简化</strong>，具体如下：</p>
<pre><code>&lt;type&gt;: &lt;subject&gt;
&lt;body&gt;</code></pre>
<h3>1.1 type</h3>
<p>提交 commit 的类型，包括以下几种</p>
<ul>
<li><strong>feat: 新功能</strong></li>
<li><strong>fix: 修复问题</strong></li>
<li>docs: 修改文档</li>
<li>style: 修改代码格式，不影响代码逻辑</li>
<li>refactor: 重构代码，理论上不影响现有功能</li>
<li><strong>perf: 提升性能</strong></li>
<li>test: 增加修改测试用例</li>
<li><strong>revert: 回退，建议直接使用Github Desktop回退，而不是使用命令</strong></li>
</ul>
<h3>1.2 subject</h3>
<p>用一句话清楚的描述这次提交做了什么。书写要遵循以下四种规则：</p>
<ul><li>
<strong>格式尽量使用谓宾，使用谓宾不通顺时，可以使用主谓</strong>，例如：</li></ul>
<blockquote>谓宾：修复xxxx<br>主谓：中间件支持xxxx</blockquote>
<ul>
<li>
<strong>除了名称之外，描述尽可能使用中文</strong>，方便不同开发者理解</li>
<li><strong>结尾不加句号</strong></li>
<li><strong>描述控制在20个汉字以内</strong></li>
</ul>
<h3>1.3 body</h3>
<p>对本地提交的详细描述，<strong>不建议</strong>。我们建议多次少量提交，而不是一次巨量的提交，有助于revert和code review，也对灾难存储有容灾。</p>
<h2>2. 撰写工具</h2>
<p>有工具辅助，一定比手写好，这里我们使用Commitizen这个库。<br>安装命令：</p>
<pre><code class=""javascript"">cd 项目目录
npm install -g commitizen
commitizen init cz-conventional-changelog --save --save-exact
// 项目做些更改之后
git add .
git cz</code></pre>
<p>安装完毕之后，使用git cz来代替git commit命令即可，新的commit log提交界面会如下所示：<br><span class=""img-wrap""><img data-src=""/img/bV8IzM?w=922&amp;h=295"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>写完了之后的commit log如下图所示：<br><span class=""img-wrap""><img data-src=""/img/bV8Izu?w=840&amp;h=398"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>是不是比之前的commit log看起来清晰很多？</strong><br><strong>注意：</strong><br>git bash在windows下不能通过箭头符号上下移动选择，这时候我们可以下载<a href=""http://cmder.net/"" rel=""nofollow noreferrer"">Cmder</a>来作为我们的命令行工具。</p>
<h2>2. 使用问题</h2>
<p><strong>1. commit log 我用20个字描述不清楚怎么办？</strong><br>我们期望尽可能多次的提交，一个feature提交一次，不要出现积攒多个feature提交情况，既不有利于code review，也不有利于代码revert</p>
<p><strong>2. 为什么不使用强制验证手段来限制commit log的格式？</strong><br>尽管没有使用自动化验证的手段（阮老师的文章中提到了，可以自行查看），但是<strong>如果不符合书写逻辑的话，code reviewer不应该让其merge request到dev分支中</strong>。这一块我觉得<a href=""https://www.zhihu.com/question/21209619"" rel=""nofollow noreferrer"">天猪说的很有道理</a>，通过人工的手段去实现这种验证，这也是为了大家养成一个良好的代码习惯。</p>
<h2>参考文档：</h2>
<ol>
<li>《<a href=""http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"" rel=""nofollow noreferrer"">Commit message 和 Change log 编写指南</a>》</li>
<li>《<a href=""https://eggjs.org/zh-cn/contributing.html"" rel=""nofollow noreferrer"">代码贡献规范</a>》</li>
</ol>

                ", Git Commit Log的小型团队最佳实践,1531977679,233,1,954,1,1,https://segmentfault.com/a/1190000015434246
9,1,0,7,"
                    
<p><a href=""https://zendev.com/2018/06/19/react-usage-beating-vue-angular.html"" rel=""nofollow noreferrer"">原文地址</a><br>上周在JS圈中发生了意见相当重磅的事件。Vue的star数超过了React。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcKM4?w=1238&amp;h=290"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>使用一个叫做<a href=""http://www.timqian.com/star-history/"" rel=""nofollow noreferrer"">Star History</a>的工具，我们可以看到：React的大佬地位被迅速蹿升的Vue给取代了！</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcKPP?w=3264&amp;h=2044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""star-history.png"" title=""star-history.png""></span></p>
<p>每当一个流行框架出现时，总能引发那个框架“真的”更受欢迎，那个框架更强大的争论！</p>
<h3>纸面繁荣和实际使用</h3>
<p>请不要会错意，近来我用Vue比react多得多。我很喜欢Vue！但是github的star更多反映的是一个项目“潮不潮”而非实际使用。<br>一个明显的例子就是比较一下流行的Apache服务与一个相对浮夸的JS项目。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcKSY?w=1196&amp;h=288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>为了更好地衡量Vue与React。我们需要使用其他方法来衡量项目的实际使用。</p>
<h3>使用NPM下载量来衡量使用情况</h3>
<p>虽然并不存在完美的指标，很多方式都可以安装使用这些项目，但NPM可以作为一个衡量标准来评价JS包安装情况。<br>如果我们查看<code>Vue</code>和<code>React</code>各自核心包的安装统计，就能够给我们一个实际使用的评判标准。<br>所以我们需要借助一个叫做<a href=""https://npm-stat.com/"" rel=""nofollow noreferrer"">npm-stat.com</a>的网站！该网站可以生成从2015年起的NPM包的历史下载图像</p>
<h3>数据显示React还是龙头老大</h3>
<p>回溯近两年的数据，与Github star数形成对比的是，通过NPM包的下载量来衡量。React在使用率方面还是业界大佬。<br><span class=""img-wrap""><img data-src=""/img/bVbcK1f?w=3980&amp;h=1628"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""react-vue-two-years.png"" title=""react-vue-two-years.png""></span><br>这并非是Vue在这方面表现不佳。从曲线上看Vue相对于自身增长迅速，但是与React相比还是有很大的差距！</p>
<h3>加入angular后</h3>
<p>虽然上周讨论都集中在React和Vue中，但我们还是看看“三巨头”中的另一位：Angular吧！<br>我想你也知道Angular的社区大概可分为两个阵营：""Angular"" 和  ""Angular2""。我们分别处理两者。<br>在github的star上：<br><span class=""img-wrap""><img data-src=""/img/bVbcK5I?w=3348&amp;h=1888"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""all-4-star-history.png"" title=""all-4-star-history.png""></span></p>
<p>图中可以看到，最初Angular傲视React和Vue，不过，2016年中被React在“星星之力”上反超，在2017年又被Vue比下去了。虽然在2016年9月推出的第二版本正在追赶，但他仍处于第四的位置。</p>
<h3>Angula的下载情况</h3>
<p>当我们关注两个版本的使用情况而非“星星之力”时，你可以发现另一个版本的故事。<br><span class=""img-wrap""><img data-src=""/img/bVbcK6U?w=3956&amp;h=1540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""all-4-npm-stat.png"" title=""all-4-npm-stat.png""></span></p>
<p>在实用方面，自发布以来新版的Angular立即从Vue 和 老Angular的围剿中杀了出来，尽管没有追上React，但也一直处在第二的位置。<br>在此期间，Vue从2016年9月大约是新老angular的三分之一，到了2018年3月成了新angular的一半。</p>
<h3>结论：React依旧王者，Vue势头难当</h3>
<p>通过深入NPM下载统计，纵使Vue以强劲势头疯狂“吸星”，但React在JS框架界依旧是一个庞然大物。并以每个月近1000万的下载量增长着。</p>
<p>不过，粉丝们，大可不必为你们的爱豆Vue沮丧。Vue真以其他主流框架不可企及的速度增长着。也将逐渐缩小与React和Angular之间的距离。</p>

                ", star不代表一切。React：嘿Vue和Angular！就问你们怕不怕！！,1531977680,336,1,199,1,1,https://segmentfault.com/a/1190000015395185
10,1,0,7,"
                    
<h2>前言</h2>
<p>vue-devtools是一款用来调试vue应用的插件，它能大大地提高vue的调试效率。近期在折腾vue时想使用这款开发利器，结果踩到许多坑，在这里分享给大家。</p>
<h2>安装方法</h2>
<p>按照官方的文档，vue-devtools有两种安装方法，一种是自己手动去克隆它的源码，然后在谷歌浏览器的扩展管理里打开开发者模式，加载已解压的扩展程序。<a href=""https://github.com/vuejs/vue-devtools"" rel=""nofollow noreferrer"">这里是文档</a><br>如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCSS?w=1210&amp;h=168"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>另一种方法就是翻墙去谷歌商店下载了，这个程序员都懂的（就是爱折腾）,不过也有一些网站可以直接下载谷歌商店的绝大部分插件，例如 <a href=""http://www.cnplugins.com/"" rel=""nofollow noreferrer"">http://www.cnplugins.com/</a>、 <br><a href=""https://www.crx4chrome.com/"" rel=""nofollow noreferrer"">https://www.crx4chrome.com/</a></p>
<h2>踩到的坑</h2>
<p>一开始安装的时候想着试试去手动安装，于是按着文档做了一遍，发现出现一些问题</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCTO?w=882&amp;h=554"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>然后我想先不管，看能不能用吧，结果谷歌开发者工具里并没有出现vue调试面板，上网查了一下发现是引入vue文件出错了：<strong>引入压缩版（即生产版）的vue文件是不会出现出现vue调试面板的</strong>，当时我是这样引入的:</p>
<pre><code class=""js"">&lt;script src=""https://cdn.bootcss.com/vue/2.5.16/vue.min.js""&gt;&lt;/script&gt;</code></pre>
<p>后来改成未压缩版的（即开发版）：</p>
<pre><code>&lt;script src=""https://cdn.bootcss.com/vue/2.5.16/vue.js""&gt;&lt;/script&gt;</code></pre>
<p>结果发现调试面板出现了！，点开一下发现下面一片空白，我。。。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCUt?w=862&amp;h=569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>于是我试着又安装了一次，发现还是卡在<code>npm run build</code>上，此时的我果断放弃手动安装，然后去谷歌商店下载安装，安装完了后发现点击vue插件图标出现一个提示</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCUL?w=188&amp;h=82"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>查找资料后发现只要修改manifest.json的<code>persistent</code>改为true就可以了,这里怎么找到已安装插件的目录呢？在这里我们打开谷歌的<code>设置=&gt;更多工具=&gt;扩展程序</code>,或者直接在地址栏输入<code>chrome://extensions/</code>，找到已经安装好的vue-devtools，复制那串ID，如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCVz?w=1109&amp;h=277"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>因为谷歌浏览器安装好的插件都会存在<strong>以插件的id来命名的文件夹里</strong>，所以我们直接在磁盘搜索那串ID（我承认这的确很慢。。），所以还是用<strong>everything</strong>吧，文件太多直接搜就行啦，这里是<a href=""http://www.voidtools.com/"" rel=""nofollow noreferrer"">下载地址</a>,如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCV2?w=851&amp;h=244"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>第一个就是啦，几乎秒出。<br>然后打开该文件夹，找到manifest.json</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCWa?w=429&amp;h=307"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>修改里面的<code>persistent</code>改为true就可以了</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCUM?w=432&amp;h=190"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>但是需要注意的是，再写vue项目是，引入的vue.js要是<strong>未压缩</strong>的才会出现vue-devtools的调试面板</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCUX?w=573&amp;h=648"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>如果你是引用的是压缩版的vue，调试面板是不会出现的</strong>，此时点击vue插件还回提示</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcCU4?w=337&amp;h=154"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>意思是<strong>Devtools检查不可用，因为它处于生产模式，或者由作者明确禁用。</strong><br>如果要使用压缩版的vue.js的话，在vue文件中加上</p>
<pre><code class=""js"">Vue.config.devtools = true;</code></pre>
<p>这样，vue-devtools调试面板又出来了😄</p>
<h2>总结：</h2>
<ul>
<li>安装完vue-devtools后需要把manifest.json里面的<code>persistent</code>改为true</li>
<li>需要引入未压缩版的<code>vue.js</code>vue-devtools的调试面板才会出现</li>
<li>如果引入的是压缩版的vue.js,需要在vue文件中加上<code>Vue.config.devtools = true;</code>
</li>
</ul>

                ", 谈谈我vue-devtools安装过程中踩到的坑,1531977682,448,1,569,1,1,https://segmentfault.com/a/1190000015363628
11,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVbcw1Y?w=1200&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>微软斥资75亿美元收购以后，鉴于微软和开源竞争的历史，很多开发者都感到惊恐。毕竟，互联网上最大的一块可以自由的净土被微软染指，宝宝不开森。如果你真的担心微软会对Github有所动作，那么这里我列举了16个替代品。</p>
<h2>1. <a href=""https://bitbucket.org/"" rel=""nofollow noreferrer"">Bitbucket</a>
</h2>
<blockquote>Bitbucket是Atlassian公司提供的一个基于web的版本库托管服务，支持Mercurial和Git版本控制系统。Bitbucket既提供免费帐号，也提供商业付费方案。免费帐号可使用的私有版本库不限数量，但最多可支持5名用户（截至2010年9月）。--摘自维基百科</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVbb8gK?w=331&amp;h=152"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>和Github的区别(<a href=""https://wenku.baidu.com/view/628fb3afcd22bcd126fff705cc17552707225ed4.html"" rel=""nofollow noreferrer"">资讯来源</a>)：</p>
<ul>
<li>Bitbucket提供无限的免费私人仓库，而Github对此是收费的。在两家服务里，公开仓库是无限且免费的，并且不限制贡献者的数量。</li>
<li>Bitbucket在私人仓库上主要提供一共5人一个免费账户，而Github更加关注其公开仓库，因此它有自己的界限。尽管它们提供许多相似的代码托管特性，Github关注于开源，而Bitbucket看起来更加关注企业开发者。</li>
<li>Bitbucket只显示了一个简单的搜索界面。而GitHub却展示了目前最流行的代码仓以及最受欢迎的主题，更不用说它为开发者提供项目专辑和公开的工作台功能。</li>
</ul>
<h2>2. <a href=""https://about.gitlab.com/"" rel=""nofollow noreferrer"">GitLab</a>
</h2>
<blockquote>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 -- 摘自百度百科</blockquote>
<p>你可以直接使用SaaS服务，也可以本地搭建一套GitLab系统。</p>
<p>根据cnBeta新闻，在GitHub新闻发布之后GitLab收到了超过14300个独立访问者，这些开发者在GitLab.com上开设了超过10万个新的存储库。<br><span class=""img-wrap""><img data-src=""/img/bVbb8gJ?w=630&amp;h=441"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbb8gq?w=640&amp;h=326"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Github更加面向开源，gitlab面向企业：</p>
<ul>
<li>可以在GitLab上面创建私人的免费仓库；</li>
<li>允许免费设置仓库权限；</li>
<li>允许用户选择分享一个project的部分代码；</li>
<li>允许用户设置project的获取权限，进一步的提升安全性；</li>
<li>可以设置获取到团队整体的改进进度；</li>
<li>通过innersourcing让不在权限范围内的人访问不到该资源。</li>
</ul>
<h2>3. <a href=""https://gogs.io/"" rel=""nofollow noreferrer"">Gogs</a>
</h2>
<blockquote>一款极易搭建的自助 Git 服务。Gogs 项目代码 100% 开源并可无条件免费使用。所有的源代码均通过 MIT 授权协议 托管在 GitHub 上。</blockquote>
<p>Github stars数超过2.5w，有如下特点：</p>
<ul>
<li>易安装: 您除了可以根据操作系统平台下载 二进制运行，还可以通过 Docker 或 Vagrant，以及 包管理 安装。</li>
<li>跨平台: 任何 Go 语言 支持的平台都可以运行 Gogs，包括 Windows、Mac、Linux 以及 ARM。</li>
<li>轻量级: 一个廉价的树莓派的配置足以满足 Gogs 的最低系统硬件要求。有些用户甚至还将 Gogs 运行在 NAS 设备上。</li>
</ul>
<h2>4. <a href=""https://beanstalkapp.com/"" rel=""nofollow noreferrer"">Beanstalk</a>
</h2>
<blockquote>Git、SVN代码托管网站，支持代码Review，集成FTP、Shell、Heroku、第三方聊天报警等等、</blockquote>
<h2>5. <a href=""https://aws.amazon.com/cn/getting-started/projects/migrate-git-repository/"" rel=""nofollow noreferrer"">AWS CodeCommit</a>
</h2>
<blockquote>CodeCommit是类似于Github的源代码托管服务，完全兼容git。</blockquote>
<p>AWS CodeCommit是付费服务。使用AWS CodeCommit托管项目的费用取决于您账户中每月的活跃用户数量。每个月可以有5位活动用户利用您的账户免费试用AWS CodeCommit，这是在限制范围内的，如果活动用户超过5位，则每月需要为每位活动用户支付1USD。没有预付费用，也无需订立合约。具体请查看价格页面: <a href=""https://aws.amazon.com/cn/getting-started/projects/migrate-git-repository/services-costs/"" rel=""nofollow noreferrer"">定价</a></p>
<h2>6. <a href=""https://gitbucket.github.io/"" rel=""nofollow noreferrer"">GitBucket</a>
</h2>
<blockquote>A Git platform powered by Scala with easy installation, high extensibility &amp; GitHub API compatibility</blockquote>
<p>由Scala驱动的Git项目管理平台，完全兼容Github API。可以自行部署到本地。使用方便，只需下载并运行<code>java -jar gitbucket.war</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbb8gp?w=899&amp;h=542"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>7. <a href=""https://www.jetbrains.com/upsource/"" rel=""nofollow noreferrer"">Upsource</a>
</h2>
<p>来自知乎孙昱的评论：</p>
<blockquote>在为公司寻找Code Review工具时，Upsource依托JetBrains这一强大的品牌，自然而然成为我重点考察的工具。简言之，Upsource是专注于代码浏览和审查这两项功能的。优点：1. 不提供云解决方案，而是将服务部署在自家公司的服务器上，这样访问速度不再成问题；2. 容易上手操作，不像Phabricator那样功能多而复杂；3. 专注于代码浏览与审查，这两个是代码库该有的核心功能；缺点：1. 免费方案只能支持10个人，实在太少了，不过可以安装多个示例，这样虽然麻烦但可以绕开限制；2. 配置起来并不容易，需要摸索；</blockquote>
<p>来自知乎高凡凡高的评论：</p>
<blockquote>在用Upsource之前我大概试用过十来个其它类似的工具。有在线版的，有本地部署的，有专注于code review的，也有大而全的(phabricator)。综合考察之后我选择了Upsource，目前的使用体验：非常好用，有可能是最好的code review工具，没有之一（单纯从code review角度评判）</blockquote>
<h2>8. <a href=""https://rhodecode.com/"" rel=""nofollow noreferrer"">RhodeCode</a>
</h2>
<p>企业级的开源代码管理工具，安全。<br><span class=""img-wrap""><img data-src=""/img/bVbb8go?w=2042&amp;h=806"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>9. <a href=""https://bintray.com/"" rel=""nofollow noreferrer"">BinTray</a>
</h2>
<p>方便将jar、二进制文件发布到服务器。支持Maven、Gradle、Yum、Apt。<br><span class=""img-wrap""><img data-src=""/img/bVbb8gn?w=908&amp;h=248"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>10. <a href=""https://github.com/sitaramc/gitolite"" rel=""nofollow noreferrer"">Gitolite</a>
</h2>
<p>可以本地部署的Git代码管理工具，提供了非常到位的权限管理等等功能。</p>
<h2>11 <a href=""https://gitea.io/zh-CN/"" rel=""nofollow noreferrer"">Gitea</a>
</h2>
<blockquote>Gitea 是一个开源社区驱动的 Gogs 克隆, 是一个轻量级的代码托管解决方案，后端采用 Go 编写，采用 MIT 许可证.</blockquote>
<h2>12. <a href=""https://www.perforce.com/"" rel=""nofollow noreferrer"">Perforce</a>
</h2>
<p>非常适合企业级使用，很强大，很健壮。</p>
<h2>13. <a href=""http://gitblit.com/"" rel=""nofollow noreferrer"">Gitblit</a>
</h2>
<p>Gitblit是一个项目多人开发代码管理工具</p>
<h2>14. <a href=""https://fossil-scm.org/index.html/doc/tip/www/index.wiki"" rel=""nofollow noreferrer"">Fossil</a>
</h2>
<blockquote>Fossil是一个像Git和Mercurial一样的分布式版本控制系统。Fossil也支持分布式错误跟踪和分布式维基。它简单，可靠性高，分布式软件配置管理。</blockquote>
<h2>15. <a href=""https://onedev.io/"" rel=""nofollow noreferrer"">OneDev</a>
</h2>
<p>提供了像IDE一样的代码浏览的git项目管理工具，支持代码搜索，查询commit等等。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbb8gm?w=1760&amp;h=464"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>16. <a href=""http://allura.apache.org/"" rel=""nofollow noreferrer"">Apache Allura</a>
</h2>
<blockquote>Apache Allura 是一个开源、可扩展的基于 Web 的集成了软件工具和协作软件开发的平台。最开始由 SourceForge 在 2009 年推出用来管理源码仓库、Bug 报告、讨论和 Wiki 页面、博客等功能。该项目在 2012年6月贡献给 Apache 基金会。</blockquote>
<p>当然，国内还有好些个代码托管网站，我想大家都知道，这里我就不列举了。</p>
<h2>关于Fundebug</h2>
<p>Fundebug专注于JavaScript、微信小程序、小游戏BUG监控，自从2016年双十一正式上线，Fundebug已经服务了一年半时间，累计处理了5亿+错误事件，得到了众多知名用户的认可。代码要托管，有bug要监控，debug就用<a href=""https://www.fundebug.com"" rel=""nofollow noreferrer"">fundebug</a>！</p>

                ", Github被微软收购，这里整理了16个替代品,1531977683,487,1,235,1,1,https://segmentfault.com/a/1190000015340949
12,1,0,7,"
                    
<h1>gitflow开发流程学习（第一部分）</h1>
<p>gitflow 流程是非常专业而且标准的 git 处理流程，因为要学习其核心思想和应用，故有此文章系列，本文章系列会分为两部分，第一部分学习基本的内容和基础的流程，第二部分会学习其他流程和hotfix，release 和 tag 之类的高级用法。</p>
<h1>一、gitflow 的分支学习</h1>
<p>项目中长期存在的两个分支：</p>
<ul>
<li>master：主分支，负责记录上线版本的迭代，该分支代码与线上代码是完全一致的。</li>
<li>develop：开发分支，该分支记录相对稳定的版本，所有的feature分支和bugfix分支都从该分支创建。</li>
</ul>
<blockquote>在 gitlab 里面可以设置这2个分支的权限是受保护的，只允许某些人才能进行操作。</blockquote>
<p>其它分支为短期分支，其完成功能开发之后需要删除：</p>
<ul>
<li>
<code>feature/*</code>：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 develop 分支，之后删除该分支。</li>
<li>
<code>bugfix/*</code>：bug修复分支，用于修复不紧急的bug，普通bug均需要创建bugfix分支开发，开发完成自测没问题后合并到 develop 分支后，删除该分支。</li>
<li>
<code>release/*</code>：发布分支，用于代码上线准备，该分支从develop分支创建，创建之后由测试同学发布到测试环境进行测试，测试过程中发现bug需要开发人员在该release分支上进行bug修复，所有bug修复完后，在上线之前，需要合并该release分支到master分支和develop分支。</li>
<li>
<code>hotfix/*</code>：紧急bug修复分支，该分支只有在紧急情况下使用，从master分支创建，用于紧急修复线上bug，修复完成后，需要合并该分支到master分支以便上线，同时需要再合并到develop分支。</li>
</ul>
<p>标准的流程如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoK3?w=570&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoK6?w=614&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>因为这些图涉及的流程太多，一下子很难接受，所以需要逐个分解来学习。</p>
<h1>二、真实应用案例学习理解</h1>
<p>项目背景：有一群人共同开发一个 blog 系统。</p>
<p>需要角色：</p>
<ul>
<li>开发人员（负责代码开发，包含新功能，修复 bug）</li>
<li>开发人员leader（负责代码 review，审核代码，合并代码到 develop 和 master 分支）</li>
<li>测试人员（测试检查功能或者 bug 修复是否正常）</li>
<li>部署人员（将代码发布到线上环境）</li>
</ul>
<p>项目人员：</p>
<ul>
<li>开发人员： a、b</li>
<li>开发leader：c</li>
<li>测试人员： d</li>
<li>部署人员：e</li>
</ul>
<p>项目分工：</p>
<ul>
<li>a 负责 articles 文章模块，b 负责 login 登录模块</li>
<li>c 负责审核和合并代码（代码 review和合并代码到 develop 和 master 分支）， a 和 b 开发的模块代码</li>
<li>d 需要等模块开发完毕后，才能进行测试</li>
<li>测试正常的情况下，e 才会执行部署</li>
</ul>
<h2>（一）基本开发流程</h2>
<p>首先学习一个基本的流程，类似下图，但是本次暂时不涉及 tag 处理：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoLe?w=614&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>先创建一个服务端代码仓库，用 gitlab 来管理这个仓库，名字叫做 blog-project，仓库地址是<code>git@xxx服务器地址/blog-project.git</code>。</p>
<p>项目刚开始，分支并不需要那么多，在代码仓库里只需要建两个分支即可：</p>
<pre><code class=""js"">// 远程服务器上代码
master  // 默认主分支（受保护）
develop // 开发分支（受保护）</code></pre>
<p>备注：</p>
<ul>
<li>master 和 develop 分支是受保护分支，除了个别人员，例如 leader 外无法操作。</li>
<li>因为我们使用的 gitlab，项目一开始可以暂时手工操作项目的初始化信息，所以直接在界面建立分支，后期可以不使用界面创建分支。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoLi?w=1049&amp;h=602"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>开发者 clone 这个库下来到本地：</p>
<pre><code class=""js"">// git 命令
git clone git@xxx服务器地址/blog-project.git

// clone 后每个人的本地仓库都如下：
master  // 默认主分支
develop // 开发分支</code></pre>
<p>备注：</p>
<ul>
<li>所有相关参与的开发者都要 clone 这个库。</li>
<li>部署人员和测试人员按需 clone。</li>
</ul>
<p>项目正式开始后，我们需要分工开发，有以下两种情况我们会遇到：</p>
<ol>
<li>
<p>人手充足，时间充足，各自功能都能归到各人头上，并且能够很好的开发完成。</p>
<ol>
<li>a 单独负责<code>feature/articles</code>功能。</li>
<li>b 单独负责<code>feature/login</code>功能。</li>
</ol>
</li>
<li>人手不足，时间不充足，各自的功能可能需要各人混合开发，使用共享分支合力完成开发。<br>1.<code>feature/login</code>和<code>feature/articles</code>功能都成为共享分支，所有人都参与开发</li>
</ol>
<h3>1. 针对第一种情况：开发者 clone 远端代码仓库后，不同的开发者进入不同的分支进行开发：</h3>
<pre><code class=""js"">// 开发者 a 执行 git 命令
// 创建feature/articles 功能分支，并直接切换到该分支上进行开发
git checkout -b feature/articles

// 开发者 b 执行 git 命令
// 创建feature/login 功能分支，并直接切换到该分支上进行开发
git checkout -b feature/login</code></pre>
<p>那么现在开发者 a 和 b 本地的代码库如下：</p>
<pre><code class=""js"">// 开发者 a 
master  // 默认主分支
develop // 开发分支
feature/articles // 功能分支 articles 模块

// 开发者 b
master  // 默认主分支
develop // 开发分支
feature/login // 功能分支 login 模块</code></pre>
<p>备注：</p>
<ul>
<li>因为 clone 整个项目，所以 master 和 develop 分支也会存在于本地，但因为受保护，所以无法提交。</li>
<li>feature 相关分支是从 develop 分支拉取的，基点在当前的 develop head 位置。</li>
<li>各自开发者不同的feature 功能分支，互不干涉。</li>
</ul>
<p>开发完成后各自提交代码到远端代码仓库：</p>
<pre><code class=""js"">// 开发者 a
git add . // 添加当前目录所有文件的改动到本地 git 仓库
git commit --m ""Add user API"" // 需要按照 commit 规范，这个只是样例
git push origin feature/articles // 

// 开发者 b
git add . // 添加当前目录所有文件的改动到本地 git 仓库
git commit --m ""Add user API"" // 需要按照 commit 规范，这个只是样例
git push origin feature/login </code></pre>
<p>备注：</p>
<ul>
<li>需要注意的是 commit 需要按照一定的规范来做，这些对整个项目都比较好，文章后面会徐徐道来。</li>
<li>上例只是描述一个基本过程，开发代码可能会多次添加add和提交 push，这里只是做一个示范。</li>
<li>
<p><code>git add</code>  是添加文件到本地git仓库缓冲区，换句话来说，是将有改动的文件放在本地的 git 代码仓库中，以便记录版本和提交版本。</p>
<ul><li>上例只是描述一个基本过程，但是在开发的过程中，可能只需要添加某个文件，不需要添交所有文件</li></ul>
</li>
</ul>
<h3>2. 针对第二种情况：开发者 clone 远端代码仓库后，不同的开发者进入相同的分支进行开发（共享分支）：</h3>
<pre><code class=""js"">// 开发者 a 执行命令，切换到相应到分支
git fetch  // 取回远端所有分支（branch）的更新
git checkout feature/articles // a 切换到feature/articles分支
git pull origin feature/articles // 拉取远端feature/articles分支的所有更新到本地代码
git checkout feature/login // a 切换到feature/login分支
git pull origin feature/login // 拉取远端feature/login分支的所有更新到本地代码

// 开发者 a 的本地代码
master  // 默认主分支
develop // 开发分支
feature/articles // 功能分支 articles 模块
feature/login // 功能分支 login 模块</code></pre>
<pre><code class=""js"">// 开发者 b 执行命令，切换到相应到分支
git fetch  // 取回远端所有分支（branch）的更新
git checkout feature/articles // b 切换到feature/articles分支
git pull origin feature/articles // 拉取远端feature/articles分支的所有更新到本地代码
git checkout feature/login // b 切换到feature/login分支
git pull origin feature/login // 拉取远端feature/login分支的所有更新到本地代码

// 开发者 b 的本地代码
master  // 默认主分支
develop // 开发分支
feature/articles // 功能分支 articles 模块
feature/login // 功能分支 login 模块</code></pre>
<p>解释：</p>
<ul>
<li>这里<code>feature/articles</code> 分支和<code>feature/login</code>分支都会由开发者 a 或者 b 同时开发，因为是在共享分支开发，所有有可能会有共享冲突的问题， 在代码开发之前， 应先更新好本地代码仓库，可以减少冲突的发生。</li>
<li>在共享分支开发的时候，有很多机会发生代码合并冲突的，这个时候 git 会提醒开发者进行合和解决冲突（<code>git merge conflict</code>）</li>
</ul>
<p>备注：</p>
<ul><li>
<p>这里先使用 fetch 的用意在这里：与<code>git pull</code>相比<code>git fetch</code>相当于是从远程获取最新版本到本地，但不会自动merge。如果需要有选择的合并<code>git fetch</code>是更好的选择。</p>
<ul>
<li>由于<code>git pull</code>把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。</li>
<li>将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。</li>
<li>单独进行下载和合并是一个好的做法，你可以先看看区别（diff），然后再决定是否和本地代码合并。而且分开来做，可以清晰的区别开本地分支和远程分支，方便选择使用。所以尽量少用<code>git pull</code>，多用<code>git fetch</code>和<code>merge</code>。</li>
</ul>
</li></ul>
<h3>3. 最终顺利完成某个功能开发</h3>
<p>开发者本地进行来基本的测试验证，确认功能满足需求，并且没有大的问题，然后会由开发者 leader 在 gitlab 上进行分支合并：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoLl?w=1193&amp;h=1202"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>由开发者 leader   c 来进行合并，将<code>feature/articles</code>  和 <code>feature/login</code>  分支合并到 develop 分支，合并完成后删除源分支（<code>feature/articles</code>  和 <code>feature/login</code>）。</p>
<p>至此使用基本流程完成开发。</p>
<h1>三、备忘学习Commit规范和合并冲突解决</h1>
<h2>（一）关于合并冲突解决</h2>
<ul>
<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li>
<li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li>
<li>最简单的编辑冲突的办法，就是直接编辑冲突了的文件（test.txt），把冲突标记删掉，把冲突解决正确。</li>
</ul>
<blockquote>发生冲突的地方不止 pull 还有 merge 和 rebase，只要发生合并的地方就可能会有冲突的发生。</blockquote>
<p>以下例子以 <code>git pull</code> 来样例:</p>
<pre><code class=""js"">// git pull 拉取代码的时候发生冲突了
git pull XXXXX

// 报错提示
Auto-merging test.txt
CONFLICT (content): Merge conflict in test.txt
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
<pre><code class=""js"">// 冲突文件 test.txt 内容
a123
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
b789
=======
b45678910
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6853e5ff961e684d3a6c02d4d06183b5ff330dcc
c</code></pre>
<p>解释：</p>
<ul>
<li>这个地方的提示意思是在文件 test.txt 内容中，在 a123和 c 之间有一个地方发生了冲突，有一部分是我修改的内容，有一部分是别人修改的内容。</li>
<li>
<p>其中：冲突标记<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>与<code>=======</code>之间的内容是我的修改，<code>=======</code>与<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容是别人的修改。</p>
<ul>
<li>如果保留我的修改，那么删掉别人的修改即可。</li>
<li>反之亦然。</li>
<li>如果各取一半，那么你可以将他们全部提取出来，删掉不需要的，改掉不符合的，然后再放回去。</li>
</ul>
</li>
</ul>
<p>备注：</p>
<ul><li>如果无法确认是否有冲突，也不想执行一次 pull来触发检查，可以使用<code>git status</code>命令查看。</li></ul>
<pre><code class=""js"">// 执行 git 命令
git status

// 输出提示
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use ""git push"" to publish your local commits)
// 你可以放弃合并，git merge --abort 选项会尝试恢复到你运行合并前的状态。
You have unmerged paths.
  (fix conflicts and run ""git commit"")
  (use ""git merge --abort"" to abort the merge)

Unmerged paths:
  (use ""git add &lt;file&gt;..."" to mark resolution)
// 冲突的文件
    both modified:   readme.txt

no changes added to commit (use ""git add"" and/or ""git commit -a"")</code></pre>
<ul><li>你可以通过 <code>git diff --base</code>来查看文件在两边是如何改动的。</li></ul>
<pre><code class=""js"">// 执行 git 命令
git diff --base -b  // -b 是为了去除空白内容

// 输出信息
* Unmerged path hello.rb
// 结果为git格式的diff。
// 进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
// ""---""表示变动前的文件，""+++""表示变动后的文件。
--- a/hello.rb
+++ b/hello.rb
// 前面的""-1,7""分成三个部分：减号表示第一个文件（即f1），""1""表示第1行，""7""表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，""+1,8""表示变动后，成为第二个文件从第1行开始的连续9行
@@ -1,7 +1,8 @@
// 文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
<ul><li>
<p>如果有强烈意愿只保留自己的代码的情况下也是可以的：</p>
<ul><li>使用<code>gitpush origin master --force</code>或<code>gitpush origin master -f</code>。但是这种方式存在覆盖掉其他人提交的危险，当确定不会影响到其他人提交的情况下可以使用，比如使用<code>gitcommit –amend</code>修改提交日志等情况。</li></ul>
</li></ul>
<h2>（二）Commit规范</h2>
<p>为什么需要 commit 规范？主要是为了看清楚每次 commit 的内容，清楚知道 commit 变动的地方，从而方便排错和控制代码。</p>
<h3>1. commit 的原则：</h3>
<ul>
<li>提交时的粒度是一个小功能点或者一个 bug fix，这样进行恢复等的操作时能够将「误伤」减到最低。</li>
<li>用一句简练的话写在第一行，然后空一行稍微详细阐述该提交所增加或修改的地方。</li>
<li>不要每提交一次就推送一次，多积攒几个提交后一次性推送，这样可以避免在进行一次提交后发现代码中还有小错误。</li>
<li>commit 规范的内容规则如下：</li>
</ul>
<pre><code class=""js"">// 提交类型
feat: 添加新特性
fix: 修复bug
docs: 仅仅修改了文档
style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑
refactor: 代码重构，没有加新功能或者修复bug
perf: 增加代码进行性能测试
test: 增加测试用例
chore: 改变构建流程、或者增加依赖库、工具等

// 提交范围 scope
scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。

// 提交的subject内容
subject是 commit 目的的简短描述，不超过50个字符。
以动词开头，使用第一人称现在时，比如change，而不是changed或changes
第一个字母小写，结尾不加句号（.）

// 提交的 body 内容
Body 部分是对本次 commit 的详细描述，可以分成多行。</code></pre>
<h3>2. 一个标准且优美的 git 提交记录图应该是这样的：</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoLo?w=993&amp;h=871"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>3. 要实现规范的 commit 则需要安装一些工具来简化操作：</h3>
<ul>
<li>
<code>npm install -g commitizen</code> 这个是一个格式化commit message的工具。</li>
<li>
<code>npm install -g conventional-changelog-cli</code> 这个是生成changelog的工具，changelog 是为了将这些格式化的 commit message 生成一个 <code>CHANGELOG.md</code>文件的，这个文件可以规范看到提交的内容（如上图一个标准且优美的 git 提交记录图）。</li>
</ul>
<h3>4. 执行过程：</h3>
<pre><code class=""js"">// 执行git 命令
git cz 

// 输出  
cz-cli@2.10.1, cz-conventional-changelog@2.1.0

Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.
// 提示输入你的 commit类型，他会弹出提示给你选择
? Select the type of change that you're committing: fix:      A bug fix
// 提示输入你的 scope类型，没有可以跳过
? What is the scope of this change (e.g. component or file name)? (press enter to skip)
 test
// 提示输入你的 subject，即标题
? Write a short, imperative tense description of the change:
 我来测试这个 commit 格式
// 提示输入你的 body 内容，就是详细信息
? Provide a longer description of the change: (press enter to skip)
 详细
? Are there any breaking changes? No
// 当你有使用 issues 的时候就会关联到 issues
? Does this change affect any open issues? No
[master a4fd22c] fix(test): 我来测试这个 commit 格式
 3 files changed, 14 insertions(+), 1 deletion(-)</code></pre>
<p>提交记录会变成这样（使用 <code>git log</code> 命令可以查看）：</p>
<pre><code class=""js"">// 输出结果是
fix(test): 我来测试这个 commit 格式
详细</code></pre>
<p>至于 <code>CHANGELOG.md</code>内容则如下：</p>
<pre><code class=""js"">&lt;a name=""1.0.0""&gt;&lt;/a&gt;
# 1.0.0 (2017-03-05)
### Bug Fixes
* fixed ([a9c3110](https://192.168.2.107/zpu/hello-koa/commits/a9c3110))
### Features
* add something ([53becaa](https://192.168.2.107/zpu/hello-koa/commits/53becaa))</code></pre>
<p>解析 md 文件之后，会很清晰的知道每个版本或者提交都负责了那些内容，类似这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbcoLp?w=700&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>本文参考到的资料地址：</p>
<ul>
<li><a href=""https://github.com/mylxsw/growing-up/blob/master/doc/%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9FGIT%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%96%B0%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97.md"" rel=""nofollow noreferrer"">growing-up/研发团队GIT开发流程新人学习指南.md at master · mylxsw/growing-up · GitHub</a></li>
<li><a href=""https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-centralized.md"" rel=""nofollow noreferrer"">translations/workflow-centralized.md at master · oldratlee/translations · GitHub</a></li>
<li><a href=""http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"" rel=""nofollow noreferrer"">Commit message 和 Change log 编写指南 - 阮一峰的网络日志</a></li>
<li><a href=""http://www.open-open.com/lib/view/open1328069889514.html"" rel=""nofollow noreferrer"">Git详解之三 Git分支  - OPEN 开发经验库</a></li>
<li><a href=""http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html"" rel=""nofollow noreferrer"">git多人协作开发流程(以blog为例) - Limboy’s HQ</a></li>
<li><a href=""https://www.jianshu.com/p/038ccb3518f2"" rel=""nofollow noreferrer"">Gitlab的使用（内含Git命令大全） - 简书</a></li>
<li><a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000"" rel=""nofollow noreferrer"">https://www.liaoxuefeng.com/w...</a></li>
<li><a href=""https://www.oschina.net/translate/git-fetch-and-merge?lang=chs&amp;page=2#"" rel=""nofollow noreferrer"">Git 少用 Pull 多用 Fetch 和 Merge - 技术翻译 - 开源中国社区</a></li>
<li><a href=""http://www.cnblogs.com/wxishang1991/p/5445735.html"" rel=""nofollow noreferrer"">Git中pull对比fetch和merge - AndroidM - 博客园</a></li>
<li><a href=""https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6"" rel=""nofollow noreferrer"">Git - 高级合并</a></li>
<li><a href=""http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html"" rel=""nofollow noreferrer"">读懂diff - 阮一峰的网络日志</a></li>
</ul>
<p>文章转自 <a href=""https://www.godblessyuan.com/2018/06/gitflow%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89.html"" rel=""nofollow noreferrer"">gitflow 开发流程学习（第一部分）</a></p>

                ", gitflow开发流程学习（第一部分）,1531977684,348,1,330,1,1,https://segmentfault.com/a/1190000015309119
13,1,0,7,"
                    
<h3>前言</h3>
<p>入职满一个月了，目前我们组是使用gitlab合作开发，在这里总结了一下git的使用流程。这一套流程是我目前自己在用的，感觉还不错。</p>
<h3>初始化仓库</h3>
<pre><code>git clone + URL //创建本地仓库

git checkout origin/dev -b dev //拉取远程dev分支到本地dev分支

git checkout -b ningliu //新建自己的本地分支ningliu（ningliu是我的名字）

git push --set-upstream origin ningliu //把自己的本地分支同步到远端分支

git checkout ningliu //确保在自己的本地分支操作

</code></pre>
<h3>每次修改完代码</h3>
<pre><code>git add . //把自己的修改推送到本地index区

git commit -m ""这里写提交的信息哦"" //把自己的修改推送到head区，并附加提交信息
</code></pre>
<p>备注：不理解index区和head区等基本概念的推荐阅读 <a href=""http://www.bootcss.com/p/git-guide/"" rel=""nofollow noreferrer"">git - 简易指南</a>。 这篇文章足够了解基本概念了。</p>
<h3>重头戏：更新到远端仓库</h3>
<p>我是将以下代码保存成<code>git.sh</code>文件，放在项目根目录下，每次运行<code>sh git.sh</code>即可自动实现以下命令。</p>
<pre><code>#!/bin/sh

if [ $? -ne 0 ]; then
exit 1
fi

MAIN=""dev""
# 将变量 ME 的值改为自己的分支名
ME=""branch_name""

git push # 把本地自己分支的修改推送到远端自己分支
git pull # 拉取远端自己分支的更新
git merge origin/${MAIN} # 把远端dev分支合并到本地自己分支
git push # 把本地自己分支的修改推送到远端自己分支

git checkout ${MAIN} # 切换到本地dev分支
git pull # 拉取远端dev分支的更新
git merge ${ME} # 把本地自己分支合并到本地dev分支
git push # 把本地dev分支的修改推送到远端dev分支

git checkout ${ME} # 切换回自己的本地分支
</code></pre>
<p>每行命令我已经加上了注释。总之这几行命令实现了本地和远端自己的分支、本地和远端的dev分支的同步。前四行是实现自己分支的最新化，后四行是实现dev分支的最新化。</p>
<p>如果同步过程中遇到冲突，再自行解决。</p>
<h3>总结</h3>
<p>这是我目前最顺手的git工作流程，如果有更好的实践，欢迎大家一起讨论。</p>

                ", 个人最顺手的git工作流程,1531977686,203,1,699,1,1,https://segmentfault.com/a/1190000015290004
14,1,0,7,"
                    
<h2><span class=""img-wrap""><img data-src=""/img/remote/1460000015245489?w=530&amp;h=153"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></h2>
<h3>发生背景：</h3>
<p>    随着现在国内的社交软件用户群体的不断扩大，商家打广告的方式（套路）也越来越多了，每次走在大街上都可以看到商家打出来广告牌，""朋友圈点赞超过30享受六折优惠""。在上一次和女盆友出去万达吃个晚饭，终于我们也被这个活动诱惑了一下下，作为口袋钱不多又想好好吃一顿的大三狗，看看望着桌子上一大盆烤鱼，还在犹豫要不要点一份小龙虾的女朋友，还是选择了拍照发朋友圈然后挨个去群里叫亲朋好友点赞，麻烦了一堆好友，真是不好意思。  <br>    吃饱喝足，两个人扶着腰走在路上炫'腹'、还是女盆友的提醒说，你不是会小程序吗，能不能写一个点赞的小程序来用。哎、还真是，我自己撸一个也是阔以的，说不定还能给其他人用。</p>
<h3>程序分解</h3>
<h4>分析了一下小程序要的功能：</h4>
<pre><code> 1. 主要功能：点赞（想要多少赞就要多少赞）  
 2. 微信朋友圈部分功能    </code></pre>
<h4>项目结构</h4>
<p>感觉这个小程序比较适合想要练手小程序和WeUI的盆友，所以细讲一点</p>
<pre><code>├── assets 小程序所需的images icon                 
├── pages   页面目录          
|   ├── welcome 欢迎页面      
|   ├── index   内容发布操作页面
|   ├── mian   '朋友圈' 
├── style   页面的样式 及weui
└── app.js  小程序逻辑 全局参数
└── app.wxss 小程序公共样式
└── app.json   项目的配置</code></pre>
<p>需要注意的地方：微信朋友圈发布一张图片和多张图片图片宽高比例不一样</p>
<h4>欢迎页面Welcome</h4>
<ul>
<li>欢迎页的动画我很喜欢，在设计的时候也想了试了比较久，也许是这一个小程序的最养眼的地方<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015245490?w=560&amp;h=314"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span><br>不好意思啦，就这张GIF显示的效果比较让人满意，得麻烦您想象一下竖屏的画面啦</li>
<li>这个气泡动画都是由代码 + <code>svg</code>图生成  其实只要你想到就非常简单</li>
</ul>
<p><strong>结构部分：</strong></p>
<pre><code class=""html"">// 我页面上设置了10气泡
&lt;view class=""container""&gt;
  &lt;view class=""zan animation {{rotate?'biubiu':''}}"" bindtap=""onTap""&gt;&lt;/view&gt;
  &lt;ul class=""bg-bubbles {{rotate?'biubiu':''}}""&gt;
    &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/view&gt;</code></pre>
<p><strong>部分样式：</strong></p>
<pre><code class=""css"">.animation{
  -webkit-animation: rotate 2s linear;
  animation: rotate 2s linear;
}
.biubiu{
  -webkit-transform:rotate(720deg) scale(2,2);
  transform:rotate(720deg) scale(0,0); 
  -webkit-transition:all 2s ease-in-out;
  transition:all 2s ease-in-out;
}

.bg-bubbles {
//整个背景占满全屏
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.bg-bubbles li {
  position: absolute;
  bottom: -160rpx; // 让气泡从页面底部冒出的效果
  width: 40rpx;
  height: 40rpx;
  /* background-color: rgba(255,255,255,0.15); */
  list-style: none;
  // 使用自定义动画使气泡渐现、上升和翻滚
  animation: square 15s infinite;
  transition-timing-function: linear;
  overflow: hidden;
}
li image{
  width: 100%;
  height: 100%;
}
//给每个气泡通过left 设置在不同的点 这里只展示一个节点操作
.bg-bubbles li:nth-child(2) {
  left: 20%;
  width: 90rpx;
  height: 90rpx;
//设置不同气泡的动画执行时间 和出现时间
  animation-delay: 2s;
  animation-duration: 7s;
  background-image: url('svgPath'); //保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域
  // 让每一个气泡图片完整展示
  background-size: cover;
}

// 两个自定义动画实现页面显示动画效果
@keyframes square {
  0% {
    opacity: 0.5;
    transform: translateY(0rpx) rotate(45deg);
  }
  25% {
    opacity: 0.75;
    transform: translateY(-800rpx) rotate(90deg);
  }
  50% {
    opacity: 1;
    transform: translateY(-1200rpx) rotate(135deg);
  }
  100% {
    opacity: 0;
    transform: translateY(-1000rpx) rotate(180deg);
  }
}

@keyframes rotate{
    //就不贴那么多 占位置
}</code></pre>
<p>再回过头去看看，只要想清楚了实现起来并没有那么复杂</p>
<blockquote>在<code>welcome</code>页面的js文件中 页面跳转可以由点击和自动跳转，因为自动跳转设置在页面<code>onLoad</code>事件的定时器中，所以在点击跳转之后，应该将<code>onLoad</code>中的定时器进行清除操作</blockquote>
<h3>内容发布页Index</h3>
<blockquote>发布页就像正常发布朋友圈一样，说说内容、图片、位置基本内容不能少<br>因为我们是点赞小程序，所以可以将点赞和评论操作放在本页，当然在朋友圈页面也有提供点赞的按钮</blockquote>
<p><strong>页面布局效果和操作：</strong><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015245491"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""发布页面"" title=""发布页面""></span><br>这个页面大部分使用了WeUI的组件编写主要用到的组件有：</p>
<blockquote>主要是表单组件，实际上我们这个页面大部分在做表单处理：<br><code> weui-cells</code> 表单<br><code> uploader</code> 图片上传</blockquote>
<pre><code>`slider` 滑动按钮  </code></pre>
<p><code> picker</code> 从底部弹起的滚动选择器 支持多种选择器，通过<code>mode</code>分别<br><code>button</code> 按钮  </p>
<p>整个页面可以理解为：将一切你想要在'朋友圈'展示的内容设置好 -&gt;通过 wx.setStorageSync()写入缓存里进行数据传递到即将展示的内容页面  <br><strong>值得一说：</strong><br>长按图片删除</p>
<pre><code>  deleteTap(e) {
    var imgList = this.data.images;
    const index = e.currentTarget.dataset.item;
    // 通过spilce()对数组中的元素删除 通过MVVM模式 再setData 对图片实现长按删除
    imgList.splice(index, 1); 
    wx.showModal({
      title: '温馨提示',
      content: '确定要删除吗',
      showCancel: false,
      confirmText: '确定',
      success:(response)=&gt;{
        this.setData({
          images:imgList
        });
      }
    });
  }</code></pre>
<h3>朋友圈 Main</h3>
<p>使用了一下朋友的手机录了个屏（不小心暴露了老哥的珍藏表情包） 因为他的昵称是透明的，所以在页面上昵称那一块是空缺的<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015245492?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""多张"" title=""多张""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015245493?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一张图片时"" title=""一张图片时""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015245494?w=374&amp;h=586"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""完整页面展示"" title=""完整页面展示""></span><br>在内容页面中，值得注意的就是微信朋友圈的图片的显示，单张图和多张图图片的显示宽高比不一样，从效果图中可以看出，在实际实现中可以通过判断要展示的图片数组的长度进行三元运算判断选择使用哪一种展示样式</p>
<blockquote>content_info.images.length &gt;1?'image_item':'image_item3_4'</blockquote>
<p><strong>实现：</strong></p>
<pre><code>// 使用了九宫格布局
 &lt;view class=""weui-grids images_list""&gt;
      &lt;block wx:for=""{{content_info.images}}"" wx:key=""{{index}}""&gt;
        &lt;view class=""weui-grid {{content_info.images.length &gt;1?'image_item':'image_item3_4'}}"" hover-class=""weui-grid_active""&gt;
          &lt;image data-id=""{{index}}"" mode=""aspectFill"" src=""{{item.path}}"" bindtap=""preImgTap"" /&gt;
       &lt;/view&gt;
     &lt;/block&gt;
  &lt;/view&gt;</code></pre>
<p>微信的WeUI框架中包含了常用的九宫格布局 通过weui-grids 类名使用，我也是再自己手写完九宫格的样式以后才无意中在文档里瞥到了，这一瞥差点吐血（又白折腾一阵），还是给大家贴上原来的九宫格布局代码：</p>
<pre><code>        .grid {
            padding: 40rpx 0;
            margin-left: auto;
            margin-right: auto;
            max-width: 660rpx;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* 自建九宫格最方便的写法 width: 33.33333%; */

        .grid .item {
            float: left;
            box-sizing: border-box;
            width: 33.33333%;
            padding-left: 4%;
            padding-right: 4%;
            margin-bottom: 40rpx;
            overflow: hidden;
        }</code></pre>
<p><strong>点赞按钮：</strong></p>
<p>点赞的人名都是我所能想到的人名以及角色名，可把边上的人都写了一遍</p>
<blockquote>点赞的操作因为程序功能的需要做成了点一下加一个点赞人数  <br>因为在onload中已经通过发布页面(index)的slider确定了点赞的人数，</blockquote>
<pre><code>//点赞按钮点击一下增加一个人即一个昵称
 addThumb(){
    let thumbs = this.data.content_info.thumbs;
    thumbs = thumbs +1;
    this.data.content_info.thumbs = thumbs;
    let nickNames = app.globalData.nickNames;
    const temp = [];
    for (let i = 0; i &lt; thumbs-1; i++) {
      temp.push(nickNames[i]);
    }
    //为了解决昵称最后一个逗号问题，直接粗暴的在最后添加一项
    temp.push('佚名');
    this.setData({
      nickNames: temp
    })
  }</code></pre>
<p>使用到的API：</p>
<pre><code>//图片预览
wx.previewImage({
      current: `${path}`,//当前显示的图片路径
      urls: [...urls]//要预览的所有图片
    })</code></pre>
<p>随手的一个小程序，但是功能还是可以的，符合小程序用完即走的原则，上线是不可能的，界面和功能混淆了微信的官方服务功能<span class=""img-wrap""><img data-src=""/img/remote/1460000015245495?w=50&amp;h=50"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span>，不过我留了一个体验版在手机里，美滋滋。比较适合想要练手小程序和<code> weui </code>的童鞋<br>全部的代码还请移步<a href=""https://github.com/HeiLiu/thumbsUp"" rel=""nofollow noreferrer"">我的github</a>,欢迎<code>star</code>和<code>fork</code>。最后朋友圈页面的评论按钮功能后面会继续实现，想要实现的朋友可以参考我的思路：</p>
<blockquote>页面上设置input onfocus 默认隐藏，自动获取焦点-&gt;点击评论按钮再显示  <br>获取iput的value 通过数据绑定的效果 绑定到评论数据中，页面刷新</blockquote>
<h3>写在后面</h3>
<ol>
<li>在使用你不知道或不熟悉的API或组件之前先看看文档，事半功倍</li>
<li>小程序在模拟器上实现一些复杂功能和界面效果时，及时在移动设备上进行效果查看，        避免移动端上达不到预期效果，<code>ios</code>和<code>android</code>有时候在样式的显示上有时也会有不同</li>
<li>前端路漫漫，与君共勉之。<span class=""img-wrap""><img data-src=""/img/remote/1460000015245496?w=48&amp;h=48"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""舔屏"" title=""舔屏""></span>
</li>
</ol>

                ", 【轻松集赞】写了个涉嫌混淆微信官方服务的小程序,1531977687,360,1,289,1,1,https://segmentfault.com/a/1190000015245486
15,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015238794"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>一场说走就走的旅行开始啦</h1>
<hr>
<p>随着小程序的大热，作为一个程序猿，我也开始接触并且大概了解了一个制作小程序的一些过程，为了提高自己的动手能力，于是乎，我开始来仿写携程的小程序，来实现一些基本功能，在仿写的过程中，也遇到了一些难题，也有了一点收获，希望可以通过这篇文章与大家共同交流，共同进步。</p>
<h1>前言</h1>
<hr>
<p>为了更好的开发，我们需要准备我们需要的工具：</p>
<ul>
<li>
<em>Vscode</em>：这里主要用来具体代码的编写</li>
<li>
<em>微信开发者工具</em>：通过这个看效果图</li>
<li>
<em>EasyMock</em>: 通过这个网站可以伪造一些数据来供我们使用，非常方便。这个是我的<a href=""https://www.easy-mock.com/mock/5b1266782c0adb523338b0f7/ctrip#!method=get"" rel=""nofollow noreferrer"">数据接口</a>
</li>
</ul>
<h1>具体实现</h1>
<hr>
<h3>功能效果如下</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015238795"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>查询功能的实现</h3>
<p>1.首先需要在查询之前获取输入的所在城市以及到的城市，以及时间的选择，通过这些条件去筛选，所以需要在点击查询按钮的时候绑定一个时间，需要携带参数去进行查询</p>
<pre><code>&lt;navigator class=""search""  url=""/pages/trainBuyContent/trainBuyContent?from={{from}}&amp;to={{to}}&amp;trainTime={{startDate}}""&gt;查询&lt;/navigator&gt;</code></pre>
<p>2.需要到跳转的页面接收参数通过onload事件的options获取</p>
<pre><code>    var from = options.from;
    var to = options.to;
    var trainTime = options.trainTime;</code></pre>
<p>3.最重要的是筛选出相关数据，这里需要一个for循环的判断语句，在请求数据地址URL的时候，通过for循环和if语句找出相对应的数据文件里面所对应的json数据。</p>
<pre><code>wx.request({
      url: API_BASE,
      success: (res) =&gt; {
        for(var i=0;i&lt;res.data.data.trainList.length;i++){
          if (from == res.data.data.trainList[i].from &amp;&amp; to == res.data.data.trainList[i].to &amp;&amp; trainTime == res.data.data.trainList[i].trainTime){
            temp.push(res.data.data.trainList[i]);
          }
        }
        this.setData({
          searchedList:temp
        })
      }
    })</code></pre>
<p>4.这时候再在页面通过for循环输出就可以了</p>
<pre><code>wx:for=""{{searchedList}}""
wx:key=""{{item.id}}""
temp.push(res.data.data.trainList[i]);
this.setData({
          searchedList:temp
        })</code></pre>
<p>`<br>*小程序页面传值的方式：1.url传值2.本地储存3.全局的app对象<br>`</p>
<h3>订单查询的实现</h3>
<h5>这里我采用了全局的app对象保存</h5>
<p>1.先获取全局对象，然后在点击确定购买的success回调函数的时，去获取所有的信息，以一个json格式去获取</p>
<pre><code>const app = getApp();
var trainedList = app.globalData.trainedList;
var trainItem = {
          from: this.data.from, 
          to: this.data.to,  
          trainNum: this.data.trainNum,
          trainTime: this.data.trainTime,
          totalPrice: this.data.totalPrice
        };
trainedList.push(trainItem);</code></pre>
<p>2.然后在相应的页面去获取这个全局的数组</p>
<pre><code>onLoad: function (options) {
    this.setData({
      trainedList: app.globalData.trainedList
    })
    
  },</code></pre>
<p>3.通过一个for循环让其输出在页面</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015238796"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>其他功能</h3>
<p>还有一部分功能未能展示或者未完善，请大家见谅。</p>
<h3>源码地址</h3>
<p>GitHub地址：<a href=""https://github.com/yrq1429/yrq_js_fullstack/tree/master/wxapp/Ctrip"" rel=""nofollow noreferrer"">https://github.com/yrq1429/yrq_js_fullstack/tree/master/wxapp/Ctrip</a></p>
<h1>小总结</h1>
<p>第一次发表文章有点小慌张，写的不好希望大家谅解，说实话，在我看来，这次所写的东西确实有点'糙'，但还是很开心自己能坚持写下来，功能方面以后会继续完善，希望能得到各位大佬们的意见和建议，没啥说的，继续努力吧，路漫漫其修远兮，Just do it!</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015238797"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 携程小程序初体验,1531977688,475,1,642,1,1,https://segmentfault.com/a/1190000015238791
16,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVbb1YB?w=759&amp;h=538"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>前言</h2>
<p>Android Architecture Components（AAC）首次发布与2017 GoogleI/O大会，经过近一年的维护，现在Google团队已经发布了稳定版（v1.1.1）。能够更好的帮助我们来构建自己的App应用，如果你还没有了解ACC现在时间刚刚好，来不及解释，赶紧上车吧。</p>
<p>ACC是一个架构组件，它能帮忙我们更好的来管理我们的App，方便我们的开发。它能帮助我们的App更好的存储数据、管理生命周期、进行模块化、避免常见的错误、减少样板文件的编写。</p>
<p>ACC主要由4个单一组件组成，分别为：Room、LiveData、Lifecycle与ViewModel。它们每一个都是独立存在的组件，我们可以单独使用其中几个，又或者可以将它们全部整合到一起。所以对于ACC它提供了更好的使用灵活性，方便我们集成到我们的App中。</p>
<p>今天主要是对ACC其中的Room组件进行分析。Room是一个稳健的SQL对象映射库，用来帮助我们快速的实现数据本地存储。至于为何要使用本地数据库，自然是当用户无网络或者网络差的时候，能够更好的提高用户对我们App的体验。</p>
<h2>添加依赖</h2>
<p>在使用Room之前，我们还是要在项目中对其进行依赖添加。<br>首先在你的项目的根目录下的build.gradle中添加google()库，代码如下：</p>
<pre><code>allprojects {
    repositories {
        jcenter()
        google()
    }
}</code></pre>
<p>之后打开你的App或者module中的build.gradle文件，在dependencies中添加如下代码：</p>
<pre><code>dependencies {
    def room_version = ""1.1.0"" // or, for latest rc, use ""1.1.1-rc1""
 
    implementation ""android.arch.persistence.room:runtime:$room_version""
    annotationProcessor ""android.arch.persistence.room:compiler:$room_version""
 
    // optional - RxJava support for Room
    implementation ""android.arch.persistence.room:rxjava2:$room_version""
 
    // optional - Guava support for Room, including Optional and ListenableFuture
    implementation ""android.arch.persistence.room:guava:$room_version""
 
    // Test helpers
    testImplementation ""android.arch.persistence.room:testing:$room_version""
}</code></pre>
<h2>Room</h2>
<p>上面的依赖添加完成后，接下来我们可以正式使用Room。在Android App中进行本地数据的存储都是使用SQLite，当我们使用原生的SQLite进行本地数据库的编写时，我们不仅要定义数据库结构，还要创建SQLiteHelper，编写一连串的SQL语句。这样代码量与复杂度不断上升，这不是我们想要的。而Room正好可以帮助我们减少代码、简化复杂度。</p>
<p>对于Room的使用主要由三部分构成：</p>
<ol>
<li>Entity：标识数据库中的表结构</li>
<li>DAO： 标识提供获取数据库表中的数据方法</li>
<li>Database：标识所需要创建的数据库</li>
</ol>
<p>以上三部分在代码中都是通过注释来实现，从而达到代码的精简。</p>
<h3>Entity</h3>
<p>Entity作用在model上，即我们与数据表中的字段所匹配的model类。现在我们来建立一个联系人相关的model，对于正常的model建立如下：</p>
<pre><code>data class ContactsModel(val id: Int, val name: String, val phone: String)</code></pre>
<p>现在我们要把ContactsModel映射到数据库中的一种表，只需进行如下操作：</p>
<pre><code>@Entity(tableName = ""contacts"")
data class ContactsModel(
        @PrimaryKey
        @ColumnInfo(name = ""contacts_id"")
        val id: Int,
        @ColumnInfo(name = ""name"")
        val name: String,
        @ColumnInfo(name = ""phone"")
        val phone: String
)</code></pre>
<p>首先我们在ContactsModel中添加@Entity注释，表明它将映射成一种表。在Entity中可以通过使用tableName来为该表命名，这里将其命名未contacts。</p>
<p>除此之外，使用@ColumnInfo来标明表中的字段，@PrimaryKey来标明表的主键。其中@ColumnInfo也可以通过(name = ""name"")来命名字段名。当然还有别的注释例如外键的标明：@ForeignKey</p>
<h3>DAO</h3>
<p>数据库表建好了，现在是提供操作数据表中的数据的方法。</p>
<pre><code>@Dao
interface ContactsDao {
 
    @Query(""SELECT * FROM contacts"")
    fun getAllContacts(): List&lt;ContactsModel&gt;
 
    @Query(""SELECT * FROM contacts WHERE contacts_id = :id"")
    fun getContactsById(id: Int): LiveData&lt;ContactsModel&gt;
 
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertContacts(contactsModel: ContactsModel)
 
    @Query(""UPDATE contacts SET name = :name AND phone = :phone WHERE contacts_id = :id"")
    fun updateContacts(id: Int, name: String, phone: String)
 
    @Query(""DELETE FROM contacts WHERE contacts_id = :id"")
    fun deleteContacts(id: Int)</code></pre>
<p>这里我们只需创建一个接口，通过@Dao来标明它是提供操作数据表的方法集。要注意它必须为interface，在接口中我们只需定义接口方法即可。与平常的接口方法定义不同的是，我们必须在每一个接口方法上通过注释来标明该方法的作用。</p>
<p>例如getAllContacts()方法，我们为了让它实现获取contacts表中的所有数据，我们需要在其方法中添加@Query注释，由于是查询方法，自然是使用Query，如果是插入方法就是Insert(第三个方法)。其次()中的内容就是正常的查询语句。这里是获取所有的Contacts，所以我们使用</p>
<pre><code>@Query(""SELECT * FROM contacts"")</code></pre>
<p>对于有参数的sql语句编写，可以查看第二个方法，参数值只需在对应的方法参数名前加入:前缀，这就是传参的格式。</p>
<pre><code>@Query(""SELECT * FROM contacts WHERE contacts_id = :id"")
fun getContactsById(id: Int): LiveData&lt;ContactsModel&gt;</code></pre>
<p>Room就是这么简单，通过定义接口与接口方法的形式，再结合注释来简化代码量与复杂度。当然最终Room会根据注释，编译器会帮我们实现这些接口方法。我们可以build项目，然后我们就可以搜索到ContactsDao_Impl类，这个读者可以自行尝试。本质是ContactsDao_Impl实现了ContactsDao接口。</p>
<blockquote>Room的强大之一是：它可以在编译时检测你的SQL语句是否编写正确，如果编写错误将导致编译失败。这样就可以避免App在运行时导致崩溃。这个读者可以自行测试一下。</blockquote>
<h3>Database</h3>
<p>现在数据表有了，对表的操作方法也有了，最后就差数据库来保存各个数据表了。Talk is cheap. Show me the code。</p>
<pre><code>@Database(entities = arrayOf(ContactsModel::class), version = 1)
abstract class ContactsDataBase : RoomDatabase() {
 
    abstract fun contactsDao(): ContactsDao
 
    companion object {
        private var instance: ContactsDataBase? = null
        fun getInstance(context: Context): ContactsDataBase {
            if (instance == null) {
                instance = Room.databaseBuilder(context.applicationContext,
                        ContactsDataBase::class.java,
                        ""contacts.db"").build()
            }
            return instance as ContactsDataBase
        }
    }
}</code></pre>
<p>没错，还是使用注释，这里我们定义ContactsDataBase抽象类，让它继承RoomDatabase抽象类。当然也是同@Database来标明它是一个数据库。它接收两个参数，分别为entities与version，前者接收的类型是Class[]数组，内容为对于表的Class；后者是int的数据库版本号。</p>
<p>在ContactsDataBase中还需定义一个抽象方法，让它返回由@Dao注释的ContactsDao，即提供获取数据表的方法。本质的为数据库暴露操作数据表的入口。至于它的具体方法实现也可以通过build来查看对应的自动生成文件ContactsDataBase_Impl类。</p>
<p>因为contactsDao是数据库的唯一入口，避免每次对数据库进行操作时都创建ContactsDataBase实例，如上代码我们可以使用单例模式来减少实例频繁创建的开销。</p>
<h3>使用</h3>
<p>经过上面的Entity、DAO与Database的创建，现在我们已经有了完整的本地数据库结构。接下来我们来看史上最简数据库使用的调用代码：</p>
<pre><code>private val mContactsDao by lazy { ContactsDataBase.getInstance(application).contactsDao() }
 
fun getContactsById(id: Int): LiveData&lt;ContactsModel&gt; = mContactsDao.getContactsById(id)</code></pre>
<p>你没看错只需两行代码，我们就能获取数据库中Contacts表中的所用数据。</p>
<p>第一行代码我们获取了ContactsDao实例，该实例包含操作数据表的所以方法。而第二行代码就是调用ContactsDao中的操作方法。返回我们所需的数据。</p>
<p>在第二行代码，细心的你们可能会发现它返回了LiveData&lt;ContactsModel&gt;类型数据。它是ACC的另一强大组件，这也是Room的另一强大之处，它可以直接返回LiveData数据类型，完美与LiveData结合。至于LiveData的作用，敬请关注下一篇文章<code>Android Architecture Components Part2:LiveData</code></p>
<h2>总结</h2>
<p>如果你的App使用了Room，那么你的App本地数据获取架构将会是这样的</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbb1YE?w=657&amp;h=553"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>最后文章中的代码都可以在<a href=""https://github.com/idisfkj/android-api-analysis"" rel=""nofollow noreferrer"">Github</a>中获取到。使用时请将分支切换到<code>feat_architecture_components</code></p>
<h2>相关文章</h2>
<p><a href=""https://segmentfault.com/a/1190000015283274"" rel=""nofollow noreferrer"">Android Architecture Components Part2:LiveData</a><br><a href=""https://segmentfault.com/a/1190000015311725"" rel=""nofollow noreferrer"">Android Architecture Components Part3:Lifecycle</a><br><a href=""https://segmentfault.com/a/1190000015368849"" rel=""nofollow noreferrer"">Android Architecture Components Part4:ViewModel</a></p>
<h2>关注</h2>
<p><a href=""https://idisfkj.github.io/archives/"" rel=""nofollow noreferrer"">私人博客</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaAg9?w=430&amp;h=430"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", Android Architecture Components Part1:Room,1531977689,496,1,257,1,1,https://segmentfault.com/a/1190000015221533
17,1,0,7,"
                    
<h2>写作背景</h2>
<p>笔者前年开始撰写的<a href=""https://github.com/chyingp/nodejs-learning-guide"" rel=""nofollow noreferrer"">《Node.js学习笔记》</a> github star 数突破了1000，算是个里程碑吧。</p>
<p>从第一次提交（2016.11.03）到现在，1年半过去了。突然有些感慨，想要写点东西，谈谈这期间的收获、心路历程，以及如何学习Node.js。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbUnn?w=956&amp;h=110"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbUno?w=1094&amp;h=362"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>心路历程</h2>
<p>笔者一直有做技术笔记的习惯，前几年零零散散的也写了不少Node.js的东西，只不过都存在evernote里。写着写着，觉得有必要系统地整理下，于是就有了这个项目。</p>
<p>粗略统计了下，总共提交了约60篇教程，以及<a href=""https://github.com/chyingp/nodejs-learning-guide/tree/master/examples"" rel=""nofollow noreferrer"">将近300个范例脚本</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbUnp?w=1630&amp;h=310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>大部分的commit都集中2016年11、12月份，以及2017年上半年。这段时间其实项目组挺忙的，经常一周6天班，同时在两三个项目间来回切换。</p>
<p>写作的过程挺枯燥的，也有点累人，尤其经常只能抽大半夜或周末的时间来码字，经常写技术文章的同学应该能体会。不管怎么说，一路坚持了下来，感觉还是有不少收获。</p>
<p>1、技术积累。最初存在evernote里的只是零星的笔记，经过整理校对、进一步的思考以及延展性学习，零散的知识点逐渐串联成体系化的知识面。这比单单记住了数百个Node.js的API，以及枯燥的配置项更有用。</p>
<p>2、知识分享。写作的过程中，不少同样正在学习Node.js的同学或通过QQ，或通过私信表达了感谢。对笔者来说，这其实比star数的增加更有意义。</p>
<p>3、技术焦虑有所缓解。众所周知，前端领域变化太快，身处其中的从业者压力非常大，这也是前不久著名的“老子学不动了”的梗突然刷屏的原因。深入学习、思考，掌握学习的方法和规律，能够一定程度上缓解技术焦虑症。</p>
<p>4、意外收获。这期间，收到阿里云栖社区（专家博主）、腾讯云+社区的入驻邀请，多家知名出版社的撰稿邀请，在线教育平台(如慕课)的开课邀请等。</p>
<h2>如何学习Node.js</h2>
<p>2年前在SegmentFault社区上有人问过类似的问题<a href=""https://segmentfault.com/q/1010000006807385/a-1020000006811209"" rel=""nofollow noreferrer"">《关于nodejs的学习？》</a>，当时简单地回答了下。</p>
<ol>
<li>实践是最好的学习方式，如果能把所学用到实际中去，效率比光学不练要高上很多。</li>
<li>遇到问题，学会使用google、stackoverflow、官方文档。</li>
<li>学习node的障碍，大部分时候不是node本身，而是相关领域知识。</li>
</ol>
<p>实践出真知，这点无需强调。遇到技术问题善用搜索引擎，也算是圈内共识了（初学者需要加强这方面意识）。</p>
<p>其实最难的是第3点，分辨你所遇到的问题。</p>
<p>举个例子，比如现在想学习 <a href=""https://nodejs.org/api/https.html"" rel=""nofollow noreferrer"">https</a> 这个模块，不少初学者会显得一筹莫展，常见的问题有：</p>
<ol>
<li>问题一：https、http、net 模块长得好像，API也差不多，它们之间是什么关系？</li>
<li>问题二：配置项里有一项是证书，这是个干嘛的？照着指引配好证书了，为什么浏览器会报错？</li>
<li>问题三：server本地跑得好好的，怎么部署到云服务器上就访问不了，明明可以ping通，端口也启动了，为什么提示拒绝访问？</li>
</ol>
<p>正式回答问题前，先祭出一张网络分层架构图，请读者把它牢记在心。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbUnq?w=698&amp;h=474"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>互联网基于分层架构实现，包括应用层、传输层、网络层、链路层、物理层。其中，前端开发者比较熟悉的是应用层（HTTP协议），如果想学习Node服务端编程，那么，至少需要对传输层（TCP）、网络层（IP）也有一定的了解。</p>
<p>对于网络的每个层次，Node.js基本都有对应的模块，比如https、http、net(TCP)、tls/crypto等。</p>
<p>前面列举的几个问题，都是对网络知识、服务器知识了解的欠缺导致的，而不是于Node.js的API有多复杂、难以理解。</p>
<p>这里直接回答问题：</p>
<ol>
<li>问题一：http为应用层模块，主要按照特定协议编解码数据；net为传输层模块，主要负责传输编码后的应用层数据；https是个综合模块（涵盖了http/tls/crypto等），主要用于确保数据安全性；该用哪个模块应该很清楚了。</li>
<li>问题二：安全证书是PKI体系的重要一环，主要用于身份校验。本地调试用的证书如果是自己签署的话，浏览器会视为不安全并报错，可以参考 《<a href=""https://www.chyingp.com/posts/what-is-https/"" rel=""nofollow noreferrer"">HTTPS科普扫描帖</a>》。</li>
<li>问题三：这种情况大概率是请求被防火墙拦截。ping走的是ICMP协议，由操作系统内核处理，能够ping通不代表TCP连接就能够建立成功，可以参考 《<a href=""https://www.chyingp.com/posts/understanding-ping/"" rel=""nofollow noreferrer"">ping的使用与实现原理剖析</a>》</li>
</ol>
<h2>写在后面</h2>
<p>编写《Node.js学习笔记》的过程收获了不少，也有不少感触，这里就不过多碎碎念。对于“如何学习Node.js”这个问题，其实有挺多东西想写，篇幅所限，后面的文章详细展开。</p>
<h2>相关链接</h2>
<p><a href=""https://github.com/chyingp/nodejs-learning-guide"" rel=""nofollow noreferrer"">Nodejs学习笔记</a><br><a href=""http://www.chyingp.com"" rel=""nofollow noreferrer"">笔者个人博客</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbUnr?w=300&amp;h=390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 一点感悟：《Node.js学习笔记》star数突破1000+,1531977691,498,1,519,1,1,https://segmentfault.com/a/1190000015192313
18,1,0,7,"
                    
<p>应该有很多小伙伴平时的文件、资源都会放到百度网盘上面，或者从别人网盘上找到各种资源，但是当你下载的时候你就发现百度云是以这种速度龟速下载。对，每秒几十 KB，小的文件还好，如果稍微大点的软件，就得先去玩一天，慢慢等着了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044026"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>反正我已经懒得喷百度了，封了很多第三方下载工具，意思就是让你开 VIP，而我又不想开，因为并不常用百度云下载，索性就去网上搜罗一些工具，刚好发现了这样一款优秀的全速下载工具。多亏有我们的开源社区以及广大网友啊，又想到了新方式。这里我就分享这款优秀的下载工具，让你告别下载缓慢的烦恼。</p>
<p>废话不多说，先上图，看效果。可以看到下载速度接近 3MB 每秒，这个速度是依赖你现有网络的，我的网络不太快，所以也是接近全速下载了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044027"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>这个工具的名字是 proxyee-down，是在 GitHub 上发现的，工具的地址是 </p>
<p><a href=""https://github.com/proxyee-down-org/proxyee-down"" rel=""nofollow noreferrer"">https://github.com/proxyee-do...</a></p>
<p>上面有安装教程，以及问题解答，一般看这个教程就能搞定了，如果还有问题，可以加他们的 qq 群，以上地址里面都有。</p>
<p>考虑到这个步骤有一些坑，尤其是没有技术背景的看文档可能还是有点困难，我这里把我的步骤讲一下，希望能够尽可能帮助到大家少走弯路。PS：我的系统是 Mac OS，浏览器是 Chrome，不是这个系统和浏览器的仅做参考，可以去上面安装教程里面找到对应的其他系统安装方式。</p>
<p>步骤：</p>
<h4>1、下载这个工具</h4>
<p>地址： <a href=""https://pan.baidu.com/s/1fgBnWJ0gl6ZkneGkVDIEfQ#list/path=%2F"" rel=""nofollow noreferrer"">https://pan.baidu.com/s/1fgBn...</a> 提取码: d92x</p>
<p>里面有对应的版本，不同的操作系统下载对应的就好了，<code>proxyee-down-x.xx-mac.zip</code>, 现在最新的是 2.54，比如我下载的是 <code>proxyee-down-2.54-mac.zip</code></p>
<h4>2、解压并运行</h4>
<p>讲刚才下载好的 <code>proxyee-down-2.54-mac.zip</code> 解压到任意目录，双击 start 运行软件，由于安装证书和切换代理需要 root 权限，所以在运行软件会提示输入用户密码，输入完按回车确认即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044028"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>启动成功之后会弹出成功提示，同时启动了这个工具。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044029"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>同时电脑上会有如下的这个工具图标，点开证书目录，其实就是刚才目录里面的 <code>proxyee-down-2.54/main/ssl/ca.crt</code> </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044030"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>双击安装证书，添加可信任。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044031"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h4>3、打开你想下载的百度网盘链接</h4>
<p>你会发现多出来一个 proxyee-down，如果没有出现，检查以上步骤是不是有问题，最后还是不出现，去该工具地址看常见问题列表  <code> https://github.com/proxyee-down-org/proxyee-down/blob/master/.guide/FAQ.md</code>，看是否你那边需要装浏览器插件，如果装了还是有问题，可以去 qq 群问问题，或者留言给我。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044032"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h4>4、选中你要下载的文件，点下载按钮</h4>
<p>点了下载按钮之后就会跳转到这个工具，会有个弹出框，如下图，选择你的下载路径，点击创建，就开始下载啦。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015044033"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>这样你就告别百度云的龟速下载了。</p>
<p>写在后面：如果觉得这个工具不错，希望可以给作者赞赏支持一下，毕竟是别人的付出，虽然是开源的，也希望我们能够支持一下，这样能够增加别人继续把这个事情做下去、做好的信念，如果像我一样比较穷的，至少可以点个 star，这样就能让更多人的人关注这个项目。当然，百度常年为我们提供免费的网盘服务，也是需要支持的，感觉价钱还可以的话，或者嫌教程麻烦的话，还是买 VIP 就好了。</p>
<p>如果觉得内容还不错，可以关注一下我哦 <br>微信公众号：志哥 （ID: zhige-me） <br>期待与你相遇，一同成长前行！<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015315799"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""微信公众号：志哥 (ID: zhige-me)"" title=""微信公众号：志哥 (ID: zhige-me)""></span></p>

                ", 如何把百度网盘下载速度提高 100 倍，我推荐这个下载工具,1531977692,125,1,303,1,1,https://segmentfault.com/a/1190000015044021
19,1,0,7,"
                    
<p>抽时间翻译了下纯英文的 awesome-git 仓库，Github 上也提交了第一个有意义的 PR (pull request)，奈何一个月过去，该项目作者有了新的 commit 却也没有回复我的 PR，只好另立新库，以作产出。</p>
<blockquote>P.S: 从作者的 Github 主页看出是香港朋友，突然想起了脸书上看到的“繁简之争”，逃...</blockquote>
<p>项目开源在 <a href=""https://github.com/hylerrix/awesome-git"" rel=""nofollow noreferrer"">https://github.com/hylerrix/a...</a>，以下是原文~</p>
<hr>
<p><a href=""https://github.com/sindresorhus/awesome/"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000014980261"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a></p>
<hr>
<p>收集一些有关 Git 的工具、资源清单列表。</p>
<h2>加入我们</h2>
<p>如果你有其他有趣的 Git 工具/项目/资源推荐，欢迎提交 Pull Request 请求到本仓库中。</p>
<h2>目录</h2>
<ul>
<li><p><a href=""#awesome-git"" rel=""nofollow noreferrer"">Awesome Git</a></p></li>
<li><ul><li><a href=""#"" rel=""nofollow noreferrer"">教程</a></li></ul></li>
<ul>
<li><a href=""#"" rel=""nofollow noreferrer"">客户端</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">第三方代码托管平台</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">自建代码托管平台</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">工作流</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">钩子管理策略</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">工具</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">拓展</a></li>
<li><a href=""#"" rel=""nofollow noreferrer"">开源协议</a></li>
</ul>
</ul>
<h2>教程</h2>
<p><em>畅游互联网，我们可以找到很多 Git 学习资料。</em></p>
<ul>
<li>
<a href=""https://github.com/k88hudson/git-flight-rules"" rel=""nofollow noreferrer"">Flight rules for Git</a> - 该教程在你遇到 Git 错误的时候有效地指导你。</li>
<li>
<a href=""https://try.github.io/"" rel=""nofollow noreferrer"">Try Git</a> - 利用 15 分钟时间，在该网站提供的伪终端上实践 Git 操作。</li>
<li>
<a href=""https://www.atlassian.com/git/tutorials/"" rel=""nofollow noreferrer"">Atlassian Git Tutorial</a> - 这是一系列关于 Git 的综合教程。</li>
<li>
<a href=""https://lostechies.com/joshuaflanagan/2010/09/03/use-gitk-to-understand-git/"" rel=""nofollow noreferrer"">Use gitk to understand git</a> - 使用可视化工具 gitk 来学习 Git 的重要知识(Commit，SHA，Branch，Merge，Rebase 等)。</li>
<li>
<a href=""https://www.git-tower.com/learn/"" rel=""nofollow noreferrer"">Learn Version Control with Git</a> - 来自 Tower 制造商 fournova Software 的免费电子书，该系列与付费视频课程相关。</li>
<li>
<a href=""https://git-scm.com/book/"" rel=""nofollow noreferrer"">Pro Git</a> - 免费、较为权威的 Git 电子书，采用 CC BY-SA 3.0 协议对外授权使用。</li>
<li>
<a href=""https://schacon.github.io/gitbook/"" rel=""nofollow noreferrer"">The Git Community Book</a> - 由 Git 社区数十人维护编写的 Git 教程(译者注：此链接已被上一条所列教程归并)。</li>
<li>
<a href=""http://chimera.labs.oreilly.com/books/1230000000561"" rel=""nofollow noreferrer"">Git Pocket Guide</a> - O'Reilly 出版商出版的一本关于 Git 的简明书籍。</li>
<li>
<a href=""https://www.codeschool.com/courses/git-real/"" rel=""nofollow noreferrer"">Git Real: Code School</a> - 来自 Code School 的付费培训课程。</li>
<li>
<a href=""http://pcottle.github.io/learnGitBranching/"" rel=""nofollow noreferrer"">Git Branching</a> - 以可视化的方式深入理解 Git 分支。</li>
<li>
<a href=""https://www.manning.com/books/learn-git-in-a-month-of-lunches"" rel=""nofollow noreferrer"">Learn Git in a Month of Lunches</a> - Manning Publications 出版的 Git 教程。</li>
<li>
<a href=""http://www-cs-students.stanford.edu/~blynn/gitmagic/index.html"" rel=""nofollow noreferrer"">Git Magic</a> - 免费在线看的 Git ""魔法""指南。</li>
<li>
<a href=""https://jwiegley.github.io/git-from-the-bottom-up/"" rel=""nofollow noreferrer"">Git from the bottom up</a> - 有关 Git 的一系列精彩文章。</li>
<li>
<a href=""https://github.com/jlord/git-it-electron"" rel=""nofollow noreferrer"">Git-it</a> - 在 Mac、Linux 或 Windows 客户端上学习 Git。</li>
<li>
<a href=""http://githowto.com"" rel=""nofollow noreferrer"">Git How To</a> - 跟着教程一步一步的学习 Git</li>
<li>
<a href=""http://vooban.com/en/tips-articles-geek-stuff/migrating-to-git-lfs-for-developing-deep-learning-applications-with-large-files/"" rel=""nofollow noreferrer"">Migrating to Git LFS</a> - 在已存仓库上使用 Git LFS 来更好地管理大型文件。</li>
<li>
<a href=""http://onlywei.github.io/explain-git-with-d3/"" rel=""nofollow noreferrer"">Explain Git with D3</a> - 使用 D3.js 可视化库来展现几个基本的 Git 概念：commit，branch，checkout，reset，revert，merge，rebase，fetch，pull，push，tag。</li>
<li>
<a href=""https://appendto.com/2015/06/making-sense-of-git-a-visual-perspective/"" rel=""nofollow noreferrer"">Making Sense of Git – A Visual Perspective</a> - 从时间轴和层级的角度来看 Git 命令。</li>
</ul>
<h2>客户端</h2>
<p><em>Git 客户端被各大电脑及手机平台广泛支持着。</em></p>
<ul>
<li>
<a href=""https://tortoisegit.org/"" rel=""nofollow noreferrer"">TortoiseGit</a> - Windows 平台上的一个易于使用的 Git 客户端，并被完美集成在 Windows 资源管理器上。</li>
<li>
<a href=""https://desktop.github.com/"" rel=""nofollow noreferrer"">GitHub Desktop</a> - Github 官方出品的 Git 客户端，可与 GitHub 和 GitHub Enterprise 无缝协作。</li>
<li>
<a href=""https://www.sourcetreeapp.com/"" rel=""nofollow noreferrer"">SourceTree</a> - 较为知名的免费 Git 客户端，只能运行在 Windows 和 Mac 平台上。</li>
<li>
<a href=""http://www.git-tower.com/"" rel=""nofollow noreferrer"">Tower</a> - 较为知名的收费 Git 客户端，只能运行在 Windows 和 Mac 平台上。</li>
<li>
<a href=""http://www.syntevo.com/smartgit/"" rel=""nofollow noreferrer"">SmartGit</a> - 一个商业的 SCM 跨平台客户端，完美支持 Git，SVN 和 Mercurial，可运行在 Windows，Mac 和 Linux 上。</li>
<li>
<a href=""http://rabbitvcs.org/"" rel=""nofollow noreferrer"">RabbitVCS</a> - TortoiseSVN 版本控制系统的图形工具，集成了 Nautilus 和 Thunar（译者注：这里的翻译意思尚不明确）。</li>
<li>
<a href=""https://wiki.gnome.org/Apps/Gitg/"" rel=""nofollow noreferrer"">gitg</a> - 一个开源的 GTK+ Git 客户端。</li>
<li>
<a href=""http://git-cola.github.io/"" rel=""nofollow noreferrer"">git-cola</a> - 一个跨平台的 Git 客户端。</li>
<li>
<a href=""https://github.com/sheimi/SGit"" rel=""nofollow noreferrer"">SGit</a> - 为 Android 4.x 量身定制的 Git 客户端。</li>
<li>
<a href=""https://github.com/FredrikNoren/ungit"" rel=""nofollow noreferrer"">Ungit</a> - 使用最便捷的方式学习 Git，你可以在任何地方任何环境使用它（译者注：该项目包括 npm 安装以及 Atom、VS Code 的插件形式）。</li>
<li>
<a href=""https://www.gitkraken.com/"" rel=""nofollow noreferrer"">GitKraken</a> - 一个基于 Electron 的跨平台 Git 客户端，同时支持免费版和高级付费版。</li>
<li>
<a href=""http://gitup.co"" rel=""nofollow noreferrer"">GitUp</a> - 一个干净、简介的 Git 客户端，只能运行在 MacOS 系统上。</li>
<li>
<a href=""https://gitextensions.github.io/"" rel=""nofollow noreferrer"">GitExtensions</a> - 这是一个 Visual Studio 2010-2015 的拓展插件，和一个独立的 Git 存储库工具。</li>
<li>
<a href=""https://workingcopyapp.com"" rel=""nofollow noreferrer"">WorkingCopy</a> - IOS 平台上的一个强大的 Git 客户端，除需内置付费解锁 push 功能外其它功能均免费使用。</li>
</ul>
<h2>第三方代码托管平台</h2>
<p><em>我们拥有很多不同的选择来托管项目的源代码。</em></p>
<ul>
<li>
<a href=""http://github.com/"" rel=""nofollow noreferrer"">GitHub</a> - 事实上的首选 Git 托管平台，与大多数外部服务完美整合。</li>
<li>
<a href=""http://bitbucket.org/"" rel=""nofollow noreferrer"">BitBucket</a> - 因在其中可建立免费的私人仓库而闻名（最多支持 5 人协作）。</li>
<li>
<a href=""https://www.codeplex.com/"" rel=""nofollow noreferrer"">CodePlex</a> - 微软的项目托管平台，上面有很多 SP/C# OSS 项目。</li>
<li>
<a href=""https://www.fogcreek.com/kiln/"" rel=""nofollow noreferrer"">Kiln</a> - 付费的 Git 仓库托管平台。</li>
<li>
<a href=""https://about.gitlab.com/gitlab-com/"" rel=""nofollow noreferrer"">GitLab.com</a> - 由 GitLab EE 提供服务的免费 Git 仓库托管服务，每个人都可以建立无限的仓库并和任意数量的合作者协作。</li>
<li>
<a href=""https://aws.amazon.com/codecommit/"" rel=""nofollow noreferrer"">AWS CodeCommit</a> - Amazon Web Service 在其高可用性基础设施上提供的 SaaS 服务，轻松地托管安全且高度可扩展的私有 Git 仓库。</li>
<li>
<a href=""https://codeplane.com/"" rel=""nofollow noreferrer"">Codeplane</a> - 一个没有贡献者数量限制的付费代码托管平台。</li>
<li>
<a href=""https://deveo.com/"" rel=""nofollow noreferrer"">Deveo</a> - 一个同时支持 Git, Subversion, Mercurial 和 WebDAV 的付费代码托管平台。</li>
</ul>
<h2>自建代码托管平台</h2>
<p><em>或许你需要使用自己搭建一套代码托管服务平台。</em></p>
<ul>
<li>
<a href=""http://gitolite.com/gitolite/"" rel=""nofollow noreferrer"">Gitolite</a> - 拥有细粒度访问控制机制的简易托管平台。</li>
<li>
<a href=""https://enterprise.github.com/"" rel=""nofollow noreferrer"">GitHub Enterprise</a> - Github 提供的自建代码托管平台解决方案。</li>
<li>
<a href=""https://www.atlassian.com/software/bitbucket/server"" rel=""nofollow noreferrer"">Bitbucket Server</a> - Atlassian 提供的自建代码托管平台，与 JIRA 和其他 Atlassian 产品良好集成。</li>
<li>
<a href=""https://gitlab.com/"" rel=""nofollow noreferrer"">GitLab CE/EE</a> - 一个受欢迎的 Git 自建托管平台，提供 CE 免费版和 EE 付费版。</li>
<li>
<a href=""https://www.jetbrains.com/upsource"" rel=""nofollow noreferrer"">Upsource</a> - Jetbrains 旗下托管服务平台，10 个协作者以内免费使用，与 YouTrack 和 TeamCity 良好的整合。</li>
<li>
<a href=""https://github.com/takezoe/gitbucket/"" rel=""nofollow noreferrer"">GitBucket</a> - 一个仿照 Github，使用 Scala 编写的自建代码托管平台。</li>
<li>
<a href=""http://gogs.io/"" rel=""nofollow noreferrer"">Gogs</a> - 一个使用 GO 语言编写的自建代码托管平台。</li>
<li>
<a href=""http://gitblit.com/"" rel=""nofollow noreferrer"">GitBlit</a> - 用于管理，查看和服务 Git 仓库的纯 Java 堆栈。</li>
<li>
<a href=""https://allura.apache.org/"" rel=""nofollow noreferrer"">Apache Allura</a> - 一个代码托管服务的开源实现。</li>
<li>
<a href=""https://www.phacility.com/"" rel=""nofollow noreferrer"">Phabricator</a> - 一整套强大的 Git 工具来帮助公司构建更高质量的软件。</li>
<li>
<a href=""https://rhodecode.com/"" rel=""nofollow noreferrer"">RhodeCode CE/EE</a> - 一个提供企业级源代码管理的平台。</li>
</ul>
<h2>工作流</h2>
<p><em>使用廉价的分支策略可以让人们采用除经典集中式工作流程以外的工作流程。</em></p>
<ul>
<li><a href=""https://git-scm.com/book/it/v2/Distributed-Git-Distributed-Workflows"" rel=""nofollow noreferrer"">Pro Git - Distributed Workflows</a></li>
<li><a href=""https://www.atlassian.com/git/tutorials/comparing-workflows"" rel=""nofollow noreferrer"">Atlassian Git Tutorial - Comparing Workflows</a></li>
<li>
<a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer"">Gitflow</a> - 最知名的 Git 工作流。</li>
<li>
<a href=""http://scottchacon.com/2011/08/31/github-flow.html"" rel=""nofollow noreferrer"">GitHub flow</a> - 一个只需要 master 分支的简易 Git 工作流。</li>
<li><a href=""https://about.gitlab.com/2014/09/29/gitlab-flow/"" rel=""nofollow noreferrer"">GitLab flow</a></li>
<li><a href=""https://gist.github.com/djspiewak/9f2f91085607a4859a66"" rel=""nofollow noreferrer"">Git DMZ Flow</a></li>
</ul>
<h2>钩子管理策略</h2>
<p><em>Git 在提交/推送短语中提供挂钩，允许其与代码质量检查工具和持续集成（CI）集成。</em></p>
<ul>
<li>
<a href=""http://pre-commit.com/"" rel=""nofollow noreferrer"">pre-commit</a> - 一个用于管理和维护的多语言预提交钩子的框架，由 Yelp 团队打造，广泛支持多种编程语言。</li>
<li>
<a href=""https://github.com/brigade/overcommit/"" rel=""nofollow noreferrer"">Overcommit</a> - 一个用 Ruby 编写的可扩展 Git 钩子管理器。</li>
<li>
<a href=""https://github.com/icefox/git-hooks/"" rel=""nofollow noreferrer"">git-hooks</a> - 一个管理项目、用户和全局 Git 钩子的工具。</li>
<li>
<a href=""https://github.com/dirk/quickhook/"" rel=""nofollow noreferrer"">quickhook</a> - 一个自称比 Git Hooks 更快的钩子库。</li>
<li>
<a href=""https://github.com/typicode/husky"" rel=""nofollow noreferrer"">husky</a> - 为 Node.js 打造的 Git 钩子，可在 package.json 中进行配置。</li>
<li>更多资源可参考 <a href=""https://githooks.com/"" rel=""nofollow noreferrer"">https://githooks.com/</a>
</li>
</ul>
<h2>工具</h2>
<p><em>这里有各种日常 Git 操作工具。</em></p>
<ul>
<li>
<a href=""https://github.com/stevemao/awesome-git-addons"" rel=""nofollow noreferrer"">awesome-git-addons</a> - 这里列出了超过 20 个 Git 插件，包括所有可用命令。</li>
<li>
<a href=""https://myrepos.branchable.com/"" rel=""nofollow noreferrer"">myrepos</a> - 一个管理多个版本控制库的工具。</li>
<li>
<a href=""http://fabioz.github.io/mu-repo/"" rel=""nofollow noreferrer"">mu-repo</a> - 一个管理多个 Git 仓库的工具。</li>
<li>
<a href=""http://mixu.net/gr/"" rel=""nofollow noreferrer"">gr</a> - 一个管理多个 Git 仓库的工具。</li>
<li>
<a href=""https://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow noreferrer"">BFG Repo-Cleaner</a> - 一个更简单、更快捷的替代 git-filter-branch 的方法库，用于清理 Git 存储库历史记录中的错误数据。</li>
<li>
<a href=""https://github.com/github/gitignore"" rel=""nofollow noreferrer"">GitIgnore Collection</a> - 该项目为各种编程语言收集其专属的 .gitignore 文件。</li>
<li>
<a href=""http://etckeeper.branchable.com/"" rel=""nofollow noreferrer"">etckeeper</a> - 一个让 /etc 存储在 Git 仓库中的工具集合。</li>
<li>
<a href=""https://github.com/tj/git-extras"" rel=""nofollow noreferrer"">git-extras</a> – 集成各种常见 Git 命令的命令行工具集。</li>
<li>
<a href=""https://github.com/unixorn/git-extra-commands"" rel=""nofollow noreferrer"">git-extra-commands</a> - 另一个有用的 Git 命令工具集。</li>
<li>
<a href=""https://github.com/nickolasburr/git-follow"" rel=""nofollow noreferrer"">git-follow</a> - 一个用于跟踪整个 Git 仓库历史记录中文件生命周期变化的工具。</li>
<li>
<a href=""https://github.com/michenriksen/gitrob"" rel=""nofollow noreferrer"">Gitrob</a> - 一个用于查找 GitHub 上公开可用文件中存在的敏感信息的命令行工具。</li>
<li>
<a href=""https://www.presslabs.com/gitfs/"" rel=""nofollow noreferrer"">gitFS</a> - 与 Git 完全集成的 FUSE 文件系统。</li>
<li>
<a href=""http://gitless.com/"" rel=""nofollow noreferrer"">Gitless</a> - Git 的实验版本，其改变了 Git 的一些基本概念。</li>
<li>
<a href=""https://github.com/motemen/ghq"" rel=""nofollow noreferrer"">ghq</a> — 便捷的管理远程仓库。</li>
<li>
<a href=""https://github.com/magicmonty/bash-git-prompt"" rel=""nofollow noreferrer"">bash-git-prompt</a> - 为 Git 用户提供丰富而又有趣的 bash 提示。</li>
</ul>
<h2>拓展</h2>
<p><em>Git 专为源代码管理而诞生，但是人们扩展了这个想法，并将版本控制推向了更多的领域。</em></p>
<ul>
<li>
<a href=""https://git-lfs.github.com/"" rel=""nofollow noreferrer"">Git Large File Storage</a> - 由 GitHub 支持的大文件版本化实用解决方案。</li>
<li>
<a href=""https://github.com/Microsoft/GVFS"" rel=""nofollow noreferrer"">Git Virtual File System or GVFS</a> - 以管理非常大的 Git 存储库，同时保持大多数操作的速度和效率的解决方案，由微软推进。</li>
<li>
<a href=""https://git-annex.branchable.com/"" rel=""nofollow noreferrer"">git-annex</a> - 可以通过 <a href=""https://git-annex.branchable.com/assistant/"" rel=""nofollow noreferrer"">git-annex assistant</a> 创建一个同步文件夹，来像操作一个正常的 Git 仓库一样来管理机器上的大型二进制文件。</li>
</ul>
<h2>开源协议</h2>
<p><a>MIT LICENSE</a></p>
<hr>
<blockquote>
<ul>
<li>Hello，我是韩亦乐，现任本科软工男一枚。软件工程专业的一路学习中，我有很多感悟，也享受持续分享的过程。如果想了解更多或能及时收到我的最新文章，欢迎订阅我的个人微信号：韩亦乐。<a href=""http://www.jianshu.com/u/ecbf49bf207b"" rel=""nofollow noreferrer"">我的简书个人主页</a>中，有我的订阅号二维码和 <a href=""https://github.com/hylerrix"" rel=""nofollow noreferrer"">Github 主页地址</a>；<a href=""https://www.zhihu.com/people/hylerrix/activities"" rel=""nofollow noreferrer"">我的知乎主页</a> 中也会坚持产出，欢迎关注。</li>
<li>本文内部编号经由<a href=""https://github.com/hylerrix/FSD-Debris/issues"" rel=""nofollow noreferrer"">我的 Github 相关仓库</a>统一管理；本文可能发布在多个平台但仅在上述仓库中长期维护；本文同时采用<a href=""https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"" rel=""nofollow noreferrer"">【知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议】</a>进行许可。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011417996"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
</blockquote>

                ", awesome-git 中文版，收集常用 Git 教程、工具 の 资源库,1531977693,480,1,978,1,1,https://segmentfault.com/a/1190000014980256
20,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858621"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""alarm-clock-art-background-1037993.jpg"" title=""alarm-clock-art-background-1037993.jpg""></span></p>
<h1>前言</h1>
<p>首先标题党一下，其实这篇文章主要是记录我的第二个过 <code>1K star</code> 的项目 <a href=""https://github.com/crossoverJie/Java-Interview"" rel=""nofollow noreferrer"">Java-Interview</a>，顺便分享下其中的过程及经验。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858622"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""4.png"" title=""4.png""></span></p>
<h1>需求选择</h1>
<h2><a href=""https://github.com/crossoverJie/Java-Interview"" rel=""nofollow noreferrer"">Java-Interview</a></h2>
<p>之所以要做这个项目主要是当时我正在面阿里的两个部门，非常幸运的是技术面都过了。其中的过程真是让我受益匪浅更是印象深刻，所以就想把期间的问题记录下来，加上自己的理解希望能对其他朋友起到帮助。</p>
<p>正好那段时间也是传说中的<code>金三银四</code>，所以无形中也叫顺势而为吧😏。</p>
<h2><a href=""https://github.com/crossoverJie/SSM"" rel=""nofollow noreferrer"">SSM</a></h2>
<p>这个项目的历史就比较悠久了，我看了下第一次提交差不多是两年前。</p>
<p>从这个名字也可以看出当初还是一个刚入行没多久的小菜鸟，因为之前在学 Java 的时候真的走了很多冤枉路，所以从头开始记录到现在整个过程所学到的东西，踩过的坑。</p>
<p>由于是面向小白，入门简单，上手较快也取的了一定的关注。</p>
<p>其实从这两个项目可以看出选择一个<strong>方向是很重要的</strong>。</p>
<p>以及该项目解决了什么问题，长期的规划，受众是哪些都要考虑清楚(怎么有点像做产品😅，其实这就是你自己的产品)。</p>
<p>比如这两个项目的目标：</p>
<ul>
<li>Java-Interview：持续更新面试问题，希望能让面试者知其然也知其所以然。</li>
<li>SSM：博主从小白到现在实际开发所遇到的问题记录，以及实战经验，现在逐渐会分享一些难点以及底层。受众大多是小白。</li>
</ul>
<h1>文档很重要</h1>
<p>既然项目做出来是给人用的，那文档就显得至关重要了。</p>
<p>就像日常和前端怼接口时，有一个标准的文档输出比在白板上折腾半天要高的多。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858623?w=1958&amp;h=1276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""C0DA2F29-C334-46BC-8BED-14CD6B6C5349.png"" title=""C0DA2F29-C334-46BC-8BED-14CD6B6C5349.png""></span></p>
<p>其实仔细观察 GitHub 上热门的项目，会发现他们的文档几乎都有一些共同结构：</p>
<ul>
<li>简单描述项目是干什么的。</li>
<li>快速启动。</li>
<li>最近更新。</li>
<li>Q/A 答疑。</li>
<li>项目截图。</li>
</ul>
<p>主要目的就是要简单易读，快速上手。</p>
<p>然后把一些复杂的如系统设计、开发指南等可以放到 wiki 中。</p>
<blockquote>切记不要什么东西都往 README.MD 中写，保持一个简洁的文档可以加分哦。</blockquote>
<p>当然也可以在首页加入一些徽章如：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858624?w=840&amp;h=108"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""3.png"" title=""3.png""></span></p>
<p>也能起到一些积极作用。</p>
<h1>积极推荐</h1>
<p>代码质量这个就不多说了，这应该是最基本的要求。</p>
<p>俗话说：酒香不怕巷子深。</p>
<p>但对于做开源项目来说就不太适应了，当你幸辛苦苦做了一个自认为很不错的项目，结果一年过去了都无人问津，这不免会有点打击积极性。</p>
<p>所以适当的自我推荐就很有必要了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858625"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""7D819139-647F-43E3-9DB2-AB80A3E6BC7B.png"" title=""7D819139-647F-43E3-9DB2-AB80A3E6BC7B.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858626?w=704&amp;h=822"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1.jpg"" title=""1.jpg""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014858627"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2.png"" title=""2.png""></span></p>
<p>上图是我博客、项目的主要流量来源。</p>
<p>下面是我自身体验比较优质的推荐渠道：</p>
<ul>
<li>
<a href=""https://toutiao.io/u/257810/"" rel=""nofollow noreferrer"">开发者头条</a>：由于截图的时候没有新发文章，之前那篇<a href=""https://toutiao.io/posts/zavy6s"" rel=""nofollow noreferrer"">秒杀架构实践</a>发了之后博客 80% 的流量都是从头条过来的，而且质量很高，不得不点个赞。</li>
<li>
<a href=""http://ifeve.com/author/crossoverjie/"" rel=""nofollow noreferrer"">并发编程网</a>: 并发编程网是由阿里大牛清英(买了那本《并发编程的艺术》就被圈粉了)创办的，其中的文章质量普遍较高(导致也会有一点写作门槛)。由于网站的流量也比较高，只要你的文章质量不错肯定会得到好处。</li>
<li>
<a href=""https://juejin.im/user/576d4aaf7db2a20054ea4544"" rel=""nofollow noreferrer"">掘金</a>：掘金这两年也比较火，是专门做开发者内容的，也是网站流量不错。</li>
<li>
<a href=""https://my.oschina.net/crossoverjie/blog"" rel=""nofollow noreferrer"">开源中国</a>：开源中国的博客也不错，自己也有代码托管，但我还是更喜欢用 GitHub，一般上了编辑推荐都会有不错的访问量。</li>
<li>
<a href=""https://www.v2ex.com/member/crossoverJie"" rel=""nofollow noreferrer"">V2EX</a>：大名鼎鼎的 V 站，其实受众较少，正因为如此也形成了独有的文化，因此也是我每天比逛(摸鱼)的网站，由于受众大多是开发者所以也能得到很多有用的反馈。</li>
<li>大佬推荐：最快捷的方式其实就是口口相传，其中当然是大佬的效率最高。之前有个<a href=""http://www.ityouknow.com/"" rel=""nofollow noreferrer"">纯洁的微笑</a>、<a href=""http://blog.didispace.com/"" rel=""nofollow noreferrer"">程序猿DD</a> 都投过稿，也能带来不错的流量。</li>
<li>
<a href=""https://www.jianshu.com/u/e2d07947c112"" rel=""nofollow noreferrer"">简书</a>:本来不想推荐简书的（之前的事件以及现在鸡汤太多），但是流量还可以，现在就纯粹当做博客备份的工具了。</li>
</ul>
<blockquote>坚持下来之后会发现：只要自己坚持、保证质量最后会形成自己的阅读圈子，到后面甚至会有其他朋友主动来找你分享，这些都是自我提升的过程。</blockquote>
<h1>不忘初心</h1>
<p>当初做的第一个开源项目就是 <a href=""https://github.com/crossoverJie/SSM"" rel=""nofollow noreferrer"">SSM</a>，完全受够学习时找资料的痛苦，也得到了很多人的帮助，所以才有了该项目。</p>
<p>平时工作中或多或少都会用到开源项目，其实我们大部分人也写不出 Spring、Guava 这样的项目，只是再这过程中可以参与进去，收获也是非常丰富的。</p>
<p>两年前参与开源到现在有收到面试邀请、物质奖励这些都是正面积极的，可以鼓励我们接着做下去。</p>
<p>但最多的还是在这过程中结识了很多朋友，技术能力提升也很明显，这些都是保持自我可持续发展的必要条件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5jmz?w=430&amp;h=430"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 1K star+ 的项目是如何炼成的？,1531977694,447,1,396,1,1,https://segmentfault.com/a/1190000014858616
21,1,0,7,"
                    
<p>如何更优雅的使用 Git？</p>
<h2>写好 commit message</h2>
<p>Git 每次提交代码，都要写 Commit message，否则提交不了。我们不光得写 Commit message 而且还应该写的清晰明了，说明本次提交的目的。</p>
<pre><code class=""bash"">$ git commit -m ""提交信息""</code></pre>
<p>在编辑器中写commit message</p>
<pre><code class=""bash"">$ git commit</code></pre>
<p>写好 Commit message 好处多多：</p>
<p>1、统一团队Git commit 日志风格</p>
<p>2、方便日后 Reviewing Code</p>
<p>3、帮助我们写好 Changelog </p>
<p>4、能很好的提升项目整体质量</p>
<h2><strong>Commit 提交规范</strong></h2>
<p>业界比较推崇 Angular 的 commit 规范  <a href=""http://suo.im/4rsYee"" rel=""nofollow noreferrer"">http://suo.im/4rsYee</a></p>
<p>Commit message 包括三个部分：Header，Body 和 Footer。完整格式如下：</p>
<pre><code class=""html"">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;</code></pre>
<p><strong>1) type</strong></p>
<p>提交 commit 的类型，包括以下几种</p>
<p>- feat: 新功能</p>
<p>- fix: 修复问题</p>
<p>- docs: 修改文档</p>
<p>- style: 修改代码格式，不影响代码逻辑</p>
<p>- refactor: 重构代码，理论上不影响现有功能</p>
<p>- perf: 提升性能</p>
<p>- test: 增加修改测试用例</p>
<p>- chore: 修改工具相关（包括但不限于文档、代码生成等）</p>
<p><strong>2) scope</strong></p>
<p>修改文件的范围，比如：视图层、控制层、docs、config, plugin</p>
<p><strong>3) subject</strong></p>
<p>- subject 是 commit 目的的简短描述（用一句话清楚的描述这次提交做了什么），不超过50个字符</p>
<p><strong>4) body</strong></p>
<p>- 补充 subject 添加详细说明，可以分成多行，适当增加原因、目的等相关因素，也可不写</p>
<p>5 ) footer</p>
<p>- 当有非兼容修改(Breaking Change)时必须在这里描述清楚</p>
<p>- 关闭issue或是链接到相关文档，如 Closes #1, Closes #2, #3</p>
<h2>使用 commitzen</h2>
<p>commitzen 这个工具可以帮助我们写出规范的 Commit message。</p>
<p>GitHub：<a href=""https://github.com/commitizen/cz-cli"" rel=""nofollow noreferrer"">https://github.com/commitizen...</a></p>
<p><strong><span class=""img-wrap""><img data-src=""/img/remote/1460000014776959?w=557&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></strong></p>
<p>使用npm 全局安装</p>
<pre><code class=""bash"">$ npm install -g commitizen</code></pre>
<p>在项目中使用 angular 的 commit 规范</p>
<pre><code class=""bash"">$ commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre>
<p>然后我们就可以愉快的使用 git cz 代替 git commit 命令了。当然我们也可也将其加到npm script 中</p>
<pre><code class=""javascript"">""script"": {
    ""commit"": ""git cz""
}</code></pre>
<p>然后直接使用npm run commit</p>
<h2>使用 gitmoji</h2>
<p>gitmoji 和 commitzen的作用都是帮助我们写出规范的commit message，不过gitmoji有更好玩的 moji表情。（ 用moji来表示type ）</p>
<p>GitHub：<a href=""https://github.com/carloscuesta/gitmoji-cli"" rel=""nofollow noreferrer"">https://github.com/carloscues...</a></p>
<p>安装使用</p>
<pre><code class=""bash""># 安装
$ npm i -g gitmoji-cli
# 使用
$ gitmoji -c</code></pre>
<p>挑选个符合场景的moji 提交本次更改</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014776960?w=1548&amp;h=918"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>使用Git hooks</h2>
<p>与其他版本控制系统一样，当某些重要事件发生时，Git 可以调用自定义脚本，Git 有很多钩子可以用来调用脚本自定义 Git。在 .git -&gt; hooks 目录下可以看到示例。 例如：pre-commit就是在代码提交之前做些事情。如果你打开了 hooks 目录里面的 <code>*.sample</code> 文件，你可以看见里面写的shell脚本。但是我想用 Js 写 hooks 咋办？husky、pre-commit就能满足你。</p>
<p>现在我们想实现一个提交代码时使用 Eslint 进行代码检查的功能</p>
<p><strong>先来看pre-commit</strong></p>
<p>GitHub：<a href=""https://github.com/observing/pre-commit"" rel=""nofollow noreferrer"">https://github.com/observing/...</a></p>
<pre><code># 下载安装
npm install --save-dev pre-commit</code></pre>
<p>在package.json 中配置pre-commit</p>
<pre><code>""scripts"": {    
   ""lint"": ""eslint [options] [file|dir|glob]*"",
},
""pre-commit"": [    
   ""lint"",
]</code></pre>
<p>现在提交代码试试</p>
<pre><code>git commit -m 'Keep calm and commit'</code></pre>
<p><strong>再试试 husky</strong></p>
<p>GitHub：<a href=""https://github.com/typicode/husky"" rel=""nofollow noreferrer"">https://github.com/typicode/h...</a></p>
<p>开始还是下载，不过这儿我们用的是 @next 版，使用方法与正式版略有不同。</p>
<pre><code>npm install husky@next --save-dev</code></pre>
<p>和 pre-commit 一样，还是在package.json中配置。但是处理pre-commit钩子它还可以做的更多。</p>
<pre><code class=""json"">// package.json
{
  ""scripts"": {
    ""lint"": ""eslint [options] [file|dir|glob]*"",
  },
  ""husky"": {
    ""hooks"": {
      ""pre-commit"": ""npm lint"",
      ""pre-push"": ""...""
    }
  }
}</code></pre>
<p>本文介绍了如何规范的编写Commit message，以及使用commentzen与gitmoji这两个工具来帮助我们写出规范的Commit message。最后介绍了下Git hooks，并通过 husky 或是 pre-commit 与 Eslint结合使用来构建一个代码检测工作流。当然，你还可以做的更多。</p>
<p>本文完</p>
<p>欢迎可以关注我的公众号，一起玩耍。有技术干货也有扯淡乱谈，关注回复[888] 领取惊喜</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014479649"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>左手代码右手砖，抛砖引玉</p>

                ", 更优雅的使用 Git,1531977695,551,1,780,1,1,https://segmentfault.com/a/1190000014776954
22,1,0,7,"
                    
<h2>git管理项目</h2>
<h4>1). 创建本地仓库（创建.gitignore配置文件）</h4>
<pre><code>git init
git add *
git commit -m ""xxx""
</code></pre>
<h4>2). 创建github远程仓库</h4>
<pre><code>New Repository 指定名称创建
</code></pre>
<h4>3). 将本地仓库推送到远程仓库</h4>
<pre><code>git remote add origin https://github.com/######.git 关联远程仓库
git push origin master
</code></pre>
<h4>4). push本地的更新</h4>
<pre><code>
git add *
git commit -m ""xxx""
git push origin master
</code></pre>
<h4>5). 克隆github上的项目:</h4>
<pre><code>git clone https://github.com/######.git

</code></pre>
<h4>6). pull远程的更新</h4>
<pre><code>git pull origin master
</code></pre>
<h4>7). 撤消本地修改</h4>
<pre><code>git status  查看变化
git checkout -- xxx文件  撤消指定文件的修改

</code></pre>
<h2>工作中用的 (重点常规操作)</h2>
<pre><code>   git init
   git status                红色
   git add .
   git status                绿色
   git commit -m """"
   
   git pull http://…………………   第一次使用需要这一步
   
   git branch                创建本地分支 （###：分支名）
   git branch                查看本地分支
   git checkout              切换本地分支
   git push origin           推送到分支
   
   
   git checkout master       切换到主分支
   git merge ###             把 ### 分支合并到 master
   git branch                查看一次
</code></pre>
<p>以上希望对大家有所帮助，同时也祝福这个我喜欢的女孩，一点一点的进步。</p>
<blockquote>愿你成为终身学习者</blockquote>

                ", 来自我的女神的git用法总结，希望对大家有所收获！,1531977696,490,1,870,1,1,https://segmentfault.com/a/1190000014762306
23,1,0,7,"
                    
<h2>前言</h2>
<p>在业务开发过程中，我们经常会重复使用<strong>日期格式化</strong>、<strong>cookie 操作</strong>、<strong>模板</strong>、<strong>浏览器判断</strong>、<strong>类型判断</strong>等功能。为了避免不同项目之间进行复制粘贴，可以将这些常用的函数封装到一起并发布 npm 包。在将近三年的前端开发工作中，笔者将自己平时用到的工具库统统封装到了一个项目中 <a href=""https://github.com/liriliri/licia"" rel=""nofollow noreferrer"">Licia</a>。目前所包含模块已达三百个，基本可以满足前端的日常工发需求。如果你对该项目感兴趣，欢迎试用并帮忙持续改进:)</p>
<h2>使用方法</h2>
<h3>一、安装 npm 包</h3>
<p>首先安装 npm 包到本地。</p>
<pre><code class=""bash"">npm i licia --save</code></pre>
<p>安装完之后，你就可以直接在项目中引用模块了，就像使用 lodash 一样。</p>
<pre><code class=""javascript"">var uuid = require('licia/uuid');

console.log(uuid()); // -&gt; 0e3b84af-f911-4a55-b78a-cedf6f0bd815</code></pre>
<h3>二、使用打包工具</h3>
<p>该项目自带打包工具 <a href=""https://github.com/liriliri/eustia"" rel=""nofollow noreferrer"">eustia</a>，可以通过配置文件或命令行扫描源码自动生成项目专用的工具库。</p>
<pre><code class=""bash"">npm i eustia -g</code></pre>
<p>假设你想html文件中使用trim方法，先直接在代码中使用：</p>
<pre><code class=""html"">&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=""utf-8""/&gt;
    &lt;title&gt;Eustia&lt;/title&gt;
    &lt;script src=""util.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
    var projectName = _.trim(' Eustia ');
    // Some code...
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>然后跑下命令：</p>
<pre><code class=""bash"">eustia build</code></pre>
<p>该工具会扫描你的html代码并生成一个util.js(默认文件名)文件，大功告成！</p>
<p>PS: 之前做的手机调试工具 <a href=""https://eruda.liriliri.io/"" rel=""nofollow noreferrer"">eruda</a> 源码里的 <a href=""https://github.com/liriliri/eruda/blob/master/src/lib/util.js"" rel=""nofollow noreferrer"">util.js</a> 就是使用该工具生成的:)</p>
<h3>三、使用在线工具生成 util 库</h3>
<p>你可以直接访问 <a href=""https://eustia.liriliri.io/builder.html"" rel=""nofollow noreferrer"">https://eustia.liriliri.io/builder.html</a> 在输入框输入需要的工具函数（以逗号分隔），然后点击下载 util.js 文件并将该文件放入项目中去即可。</p>
<h2>支持模块汇总</h2>
<p>因字数限制，这里只简单列出函数及其功能介绍，详细的用法请访问 <a href=""https://eustia.liriliri.io/module.html"" rel=""nofollow noreferrer"">https://eustia.liriliri.io/module.html</a> 查看。</p>
<ol>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-"" rel=""nofollow noreferrer"">$</a>: jQuery like style dom manipulator.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-attr"" rel=""nofollow noreferrer"">$attr</a>: Element attribute manipulation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-class"" rel=""nofollow noreferrer"">$class</a>: Element class manipulations.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-css"" rel=""nofollow noreferrer"">$css</a>: Element css manipulation.</li>
<li>[$data](https://eustia.liriliri.io/module.html#dollar-data): Wrapper of $attr, adds data- prefix to keys.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-event"" rel=""nofollow noreferrer"">$event</a>: bind events to certain dom elements.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-insert"" rel=""nofollow noreferrer"">$insert</a>: Insert html on different position.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-offset"" rel=""nofollow noreferrer"">$offset</a>: Get the position of the element in document.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-property"" rel=""nofollow noreferrer"">$property</a>: Element property html, text, val getter and setter.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-remove"" rel=""nofollow noreferrer"">$remove</a>: Remove the set of matched elements from the DOM.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-safeEls"" rel=""nofollow noreferrer"">$safeEls</a>: Convert value into an array, if it's a string, do querySelector.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dollar-show"" rel=""nofollow noreferrer"">$show</a>: Show elements.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Blob"" rel=""nofollow noreferrer"">Blob</a>: Use Blob when available, otherwise BlobBuilder.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Class"" rel=""nofollow noreferrer"">Class</a>: Create JavaScript class.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Color"" rel=""nofollow noreferrer"">Color</a>: Color converter.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Dispatcher"" rel=""nofollow noreferrer"">Dispatcher</a>: Flux dispatcher.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Emitter"" rel=""nofollow noreferrer"">Emitter</a>: Event emitter class which provides observer pattern.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Enum"" rel=""nofollow noreferrer"">Enum</a>: Enum type implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#JsonTransformer"" rel=""nofollow noreferrer"">JsonTransformer</a>: Json to json transformer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#LinkedList"" rel=""nofollow noreferrer"">LinkedList</a>: Doubly-linked list implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#LocalStore"" rel=""nofollow noreferrer"">LocalStore</a>: LocalStorage wrapper.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Logger"" rel=""nofollow noreferrer"">Logger</a>: Simple logger with level filter.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#MutationObserver"" rel=""nofollow noreferrer"">MutationObserver</a>: Safe MutationObserver, does nothing if MutationObserver is not supported.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Promise"" rel=""nofollow noreferrer"">Promise</a>: Lightweight Promise implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Queue"" rel=""nofollow noreferrer"">Queue</a>: Queue data structure.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ReduceStore"" rel=""nofollow noreferrer"">ReduceStore</a>: Simplified redux like state container.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Select"" rel=""nofollow noreferrer"">Select</a>: Simple wrapper of querySelectorAll to make dom selection easier.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#SessionStore"" rel=""nofollow noreferrer"">SessionStore</a>: SessionStorage wrapper.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Stack"" rel=""nofollow noreferrer"">Stack</a>: Stack data structure.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#State"" rel=""nofollow noreferrer"">State</a>: Simple state machine.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Store"" rel=""nofollow noreferrer"">Store</a>: Memory storage.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Tween"" rel=""nofollow noreferrer"">Tween</a>: Tween engine for JavaScript animations.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Url"" rel=""nofollow noreferrer"">Url</a>: Simple url manipulator.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#Validator"" rel=""nofollow noreferrer"">Validator</a>: Object values validation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#abbrev"" rel=""nofollow noreferrer"">abbrev</a>: Calculate the set of unique abbreviations for a given set of strings.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#after"" rel=""nofollow noreferrer"">after</a>: Create a function that invokes once it's called n or more times.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ajax"" rel=""nofollow noreferrer"">ajax</a>: Perform an asynchronous HTTP request.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#allKeys"" rel=""nofollow noreferrer"">allKeys</a>: Retrieve all the names of object's own and inherited properties.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#arrToMap"" rel=""nofollow noreferrer"">arrToMap</a>: Make an object map using array of strings.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#atob"" rel=""nofollow noreferrer"">atob</a>: Use Buffer to emulate atob when running in node.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#average"" rel=""nofollow noreferrer"">average</a>: Get average value of given numbers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#base64"" rel=""nofollow noreferrer"">base64</a>: Basic base64 encoding and decoding.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#before"" rel=""nofollow noreferrer"">before</a>: Create a function that invokes less than n times.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#bind"" rel=""nofollow noreferrer"">bind</a>: Create a function bound to a given object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#btoa"" rel=""nofollow noreferrer"">btoa</a>: Use Buffer to emulate btoa when running in node.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#bubbleSort"" rel=""nofollow noreferrer"">bubbleSort</a>: Bubble sort implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#callbackify"" rel=""nofollow noreferrer"">callbackify</a>: Convert a function that returns a Promise to a function following the error-first callback style.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#camelCase"" rel=""nofollow noreferrer"">camelCase</a>: Convert string to ""camelCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#capitalize"" rel=""nofollow noreferrer"">capitalize</a>: Convert the first character to upper case and the remaining to lower case.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#castPath"" rel=""nofollow noreferrer"">castPath</a>: Cast value into a property path array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#centerAlign"" rel=""nofollow noreferrer"">centerAlign</a>: Center align text in a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#char"" rel=""nofollow noreferrer"">char</a>: Return string representing a character whose Unicode code point is the given integer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#chunk"" rel=""nofollow noreferrer"">chunk</a>: Split array into groups the length of given size.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#clamp"" rel=""nofollow noreferrer"">clamp</a>: Clamp number within the inclusive lower and upper bounds.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#className"" rel=""nofollow noreferrer"">className</a>: Utility for conditionally joining class names.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#clone"" rel=""nofollow noreferrer"">clone</a>: Create a shallow-copied clone of the provided plain object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#cloneDeep"" rel=""nofollow noreferrer"">cloneDeep</a>: Recursively clone value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#cmpVersion"" rel=""nofollow noreferrer"">cmpVersion</a>: Compare version strings.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#compact"" rel=""nofollow noreferrer"">compact</a>: Return a copy of the array with all falsy values removed.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#compose"" rel=""nofollow noreferrer"">compose</a>: Compose a list of functions.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#compressImg"" rel=""nofollow noreferrer"">compressImg</a>: Compress image using canvas.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#concat"" rel=""nofollow noreferrer"">concat</a>: Concat multiple arrays into a single array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#contain"" rel=""nofollow noreferrer"">contain</a>: Check if the value is present in the list.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#convertBase"" rel=""nofollow noreferrer"">convertBase</a>: Convert base of a number.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#cookie"" rel=""nofollow noreferrer"">cookie</a>: Simple api for handling browser cookies.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#copy"" rel=""nofollow noreferrer"">copy</a>: Copy text to clipboard using document.execCommand.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#createAssigner"" rel=""nofollow noreferrer"">createAssigner</a>: Used to create extend, extendOwn and defaults.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#createUrl"" rel=""nofollow noreferrer"">createUrl</a>: CreateObjectURL wrapper.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#cssSupports"" rel=""nofollow noreferrer"">cssSupports</a>: Check if browser supports a given CSS feature.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#curry"" rel=""nofollow noreferrer"">curry</a>: Function currying.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dateFormat"" rel=""nofollow noreferrer"">dateFormat</a>: Simple but extremely useful date format function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#debounce"" rel=""nofollow noreferrer"">debounce</a>: Return a new debounced version of the passed function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#debug"" rel=""nofollow noreferrer"">debug</a>: A tiny JavaScript debugging utility.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#decodeUriComponent"" rel=""nofollow noreferrer"">decodeUriComponent</a>: Better decodeURIComponent that does not throw if input is invalid.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#defaults"" rel=""nofollow noreferrer"">defaults</a>: Fill in undefined properties in object with the first value present in the following list of defaults objects.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#define"" rel=""nofollow noreferrer"">define</a>: Define a module, should be used along with use.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#defineProp"" rel=""nofollow noreferrer"">defineProp</a>: Shortcut for Object.defineProperty(defineProperties).</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#delay"" rel=""nofollow noreferrer"">delay</a>: Invoke function after certain milliseconds.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#delegate"" rel=""nofollow noreferrer"">delegate</a>: Event delegation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#detectBrowser"" rel=""nofollow noreferrer"">detectBrowser</a>: Detect browser info using ua.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#detectOs"" rel=""nofollow noreferrer"">detectOs</a>: Detect operating system using ua.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#difference"" rel=""nofollow noreferrer"">difference</a>: Create an array of unique array values not included in the other given array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#dotCase"" rel=""nofollow noreferrer"">dotCase</a>: Convert string to ""dotCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#download"" rel=""nofollow noreferrer"">download</a>: Trigger a file download on client side.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#each"" rel=""nofollow noreferrer"">each</a>: Iterate over elements of collection and invokes iteratee for each element.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#easing"" rel=""nofollow noreferrer"">easing</a>: Easing functions adapted from <a href=""http://jqueryui.com/"" rel=""nofollow noreferrer"">http://jqueryui.com/</a>
</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#endWith"" rel=""nofollow noreferrer"">endWith</a>: Check if string ends with the given target string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#escape"" rel=""nofollow noreferrer"">escape</a>: Escapes a string for insertion into HTML, replacing &amp;, &lt;, &gt;, "", `, and ' characters.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#escapeJsStr"" rel=""nofollow noreferrer"">escapeJsStr</a>: Escape string to be a valid JavaScript string literal between quotes.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#escapeRegExp"" rel=""nofollow noreferrer"">escapeRegExp</a>: Escape special chars to be used as literals in RegExp constructors.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#evalCss"" rel=""nofollow noreferrer"">evalCss</a>: Load css into page.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#evalJs"" rel=""nofollow noreferrer"">evalJs</a>: Execute js in given context.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#every"" rel=""nofollow noreferrer"">every</a>: Check if predicate return truthy for all elements.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#extend"" rel=""nofollow noreferrer"">extend</a>: Copy all of the properties in the source objects over to the destination object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#extendDeep"" rel=""nofollow noreferrer"">extendDeep</a>: Recursive object extending.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#extendOwn"" rel=""nofollow noreferrer"">extendOwn</a>: Like extend, but only copies own properties over to the destination object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#extractBlockCmts"" rel=""nofollow noreferrer"">extractBlockCmts</a>: Extract block comments from source code.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#extractUrls"" rel=""nofollow noreferrer"">extractUrls</a>: Extract urls from plain text.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fetch"" rel=""nofollow noreferrer"">fetch</a>: Turn XMLHttpRequest into promise like.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fibonacci"" rel=""nofollow noreferrer"">fibonacci</a>: Calculate fibonacci number.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fileSize"" rel=""nofollow noreferrer"">fileSize</a>: Turn bytes into human readable file size.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fill"" rel=""nofollow noreferrer"">fill</a>: Fill elements of array with value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#filter"" rel=""nofollow noreferrer"">filter</a>: Iterates over elements of collection, returning an array of all the values that pass a truth test.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#find"" rel=""nofollow noreferrer"">find</a>: Find the first value that passes a truth test in a collection.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#findIdx"" rel=""nofollow noreferrer"">findIdx</a>: Return the first index where the predicate truth test passes.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#findKey"" rel=""nofollow noreferrer"">findKey</a>: Return the first key where the predicate truth test passes.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#findLastIdx"" rel=""nofollow noreferrer"">findLastIdx</a>: Return the last index where the predicate truth test passes.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#flatten"" rel=""nofollow noreferrer"">flatten</a>: Recursively flatten an array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fnParams"" rel=""nofollow noreferrer"">fnParams</a>: Get a function parameter's names.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#format"" rel=""nofollow noreferrer"">format</a>: Format string in a printf-like format.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#fraction"" rel=""nofollow noreferrer"">fraction</a>: Convert number to fraction.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#freeze"" rel=""nofollow noreferrer"">freeze</a>: Shortcut for Object.freeze.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#freezeDeep"" rel=""nofollow noreferrer"">freezeDeep</a>: Recursively use Object.freeze.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#gcd"" rel=""nofollow noreferrer"">gcd</a>: Compute the greatest common divisor using Euclid's algorithm.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#getUrlParam"" rel=""nofollow noreferrer"">getUrlParam</a>: Get url param.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#has"" rel=""nofollow noreferrer"">has</a>: Checks if key is a direct property.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#hotkey"" rel=""nofollow noreferrer"">hotkey</a>: Capture keyboard input to trigger given events.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#hslToRgb"" rel=""nofollow noreferrer"">hslToRgb</a>: Convert hsl to rgb.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#identity"" rel=""nofollow noreferrer"">identity</a>: Return the first argument given.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#idxOf"" rel=""nofollow noreferrer"">idxOf</a>: Get the index at which the first occurrence of value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#indent"" rel=""nofollow noreferrer"">indent</a>: Indent each line in a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#inherits"" rel=""nofollow noreferrer"">inherits</a>: Inherit the prototype methods from one constructor into another.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#insertionSort"" rel=""nofollow noreferrer"">insertionSort</a>: Insertion sort implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#intersect"" rel=""nofollow noreferrer"">intersect</a>: Compute the list of values that are the intersection of all the arrays.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#intersectRange"" rel=""nofollow noreferrer"">intersectRange</a>: Intersect two ranges.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#invert"" rel=""nofollow noreferrer"">invert</a>: Create an object composed of the inverted keys and values of object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isAbsoluteUrl"" rel=""nofollow noreferrer"">isAbsoluteUrl</a>: Check if an url is absolute.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isArgs"" rel=""nofollow noreferrer"">isArgs</a>: Check if value is classified as an arguments object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isArr"" rel=""nofollow noreferrer"">isArr</a>: Check if value is an <code>Array</code> object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isArrBuffer"" rel=""nofollow noreferrer"">isArrBuffer</a>: Check if value is an ArrayBuffer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isArrLike"" rel=""nofollow noreferrer"">isArrLike</a>: Check if value is array-like.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isBlob"" rel=""nofollow noreferrer"">isBlob</a>: Check if value is a Blob.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isBool"" rel=""nofollow noreferrer"">isBool</a>: Check if value is a boolean primitive.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isBrowser"" rel=""nofollow noreferrer"">isBrowser</a>: Check if running in a browser.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isBuffer"" rel=""nofollow noreferrer"">isBuffer</a>: Check if value is a buffer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isClose"" rel=""nofollow noreferrer"">isClose</a>: Check if values are close(almost equal) to each other.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isDataUrl"" rel=""nofollow noreferrer"">isDataUrl</a>: Check if a string is a valid data url.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isDate"" rel=""nofollow noreferrer"">isDate</a>: Check if value is classified as a Date object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isEl"" rel=""nofollow noreferrer"">isEl</a>: Check if value is a DOM element.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isEmail"" rel=""nofollow noreferrer"">isEmail</a>: Loosely validate an email address.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isEmpty"" rel=""nofollow noreferrer"">isEmpty</a>: Check if value is an empty object or array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isEqual"" rel=""nofollow noreferrer"">isEqual</a>: Performs an optimized deep comparison between the two objects, to determine if they should be considered equal.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isErr"" rel=""nofollow noreferrer"">isErr</a>: Check if value is an error.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isEven"" rel=""nofollow noreferrer"">isEven</a>: Check if number is even.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isFile"" rel=""nofollow noreferrer"">isFile</a>: Check if value is a file.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isFinite"" rel=""nofollow noreferrer"">isFinite</a>: Check if value is a finite primitive number.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isFn"" rel=""nofollow noreferrer"">isFn</a>: Check if value is a function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isGeneratorFn"" rel=""nofollow noreferrer"">isGeneratorFn</a>: Check if value is a generator function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isInt"" rel=""nofollow noreferrer"">isInt</a>: Checks if value is classified as a Integer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isJson"" rel=""nofollow noreferrer"">isJson</a>: Check if value is a valid JSON.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isLeapYear"" rel=""nofollow noreferrer"">isLeapYear</a>: Check if a year is a leap year.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isMatch"" rel=""nofollow noreferrer"">isMatch</a>: Check if keys and values in src are contained in obj.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isMiniProgram"" rel=""nofollow noreferrer"">isMiniProgram</a>: Check if running in wechat mini program.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isMobile"" rel=""nofollow noreferrer"">isMobile</a>: Check whether client is using a mobile browser using ua.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNaN"" rel=""nofollow noreferrer"">isNaN</a>: Check if value is an NaN.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNative"" rel=""nofollow noreferrer"">isNative</a>: Check if value is a native function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNil"" rel=""nofollow noreferrer"">isNil</a>: Check if value is null or undefined, the same as value == null.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNode"" rel=""nofollow noreferrer"">isNode</a>: Check if running in node.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNull"" rel=""nofollow noreferrer"">isNull</a>: Check if value is an Null.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNum"" rel=""nofollow noreferrer"">isNum</a>: Check if value is classified as a Number primitive or object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isNumeric"" rel=""nofollow noreferrer"">isNumeric</a>: Check if value is numeric.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isObj"" rel=""nofollow noreferrer"">isObj</a>: Check if value is the language type of Object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isOdd"" rel=""nofollow noreferrer"">isOdd</a>: Check if number is odd.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isPlainObj"" rel=""nofollow noreferrer"">isPlainObj</a>: Check if value is an object created by Object constructor.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isPrimitive"" rel=""nofollow noreferrer"">isPrimitive</a>: Check if value is string, number, boolean or null.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isPromise"" rel=""nofollow noreferrer"">isPromise</a>: Check if value looks like a promise.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isRegExp"" rel=""nofollow noreferrer"">isRegExp</a>: Check if value is a regular expression.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isRelative"" rel=""nofollow noreferrer"">isRelative</a>: Check if path appears to be relative.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isRetina"" rel=""nofollow noreferrer"">isRetina</a>: Determine if running on a high DPR device or not.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isStr"" rel=""nofollow noreferrer"">isStr</a>: Check if value is a string primitive.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isStream"" rel=""nofollow noreferrer"">isStream</a>: Check if value is a Node.js stream.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isTypedArr"" rel=""nofollow noreferrer"">isTypedArr</a>: Check if value is a typed array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isUndef"" rel=""nofollow noreferrer"">isUndef</a>: Check if value is undefined.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isUrl"" rel=""nofollow noreferrer"">isUrl</a>: Loosely validate an url.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#isWindows"" rel=""nofollow noreferrer"">isWindows</a>: Check if platform is windows.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#jsonp"" rel=""nofollow noreferrer"">jsonp</a>: A simple jsonp implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#kebabCase"" rel=""nofollow noreferrer"">kebabCase</a>: Convert string to ""kebabCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#keyCode"" rel=""nofollow noreferrer"">keyCode</a>: Key codes and key names conversion.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#keys"" rel=""nofollow noreferrer"">keys</a>: Create an array of the own enumerable property names of object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#last"" rel=""nofollow noreferrer"">last</a>: Get the last element of array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#lazyRequire"" rel=""nofollow noreferrer"">lazyRequire</a>: Require modules lazily.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#linkify"" rel=""nofollow noreferrer"">linkify</a>: Hyperlink urls in a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#loadCss"" rel=""nofollow noreferrer"">loadCss</a>: Inject link tag into page with given href value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#loadImg"" rel=""nofollow noreferrer"">loadImg</a>: Load image with given src.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#loadJs"" rel=""nofollow noreferrer"">loadJs</a>: Inject script tag into page with given src value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#longest"" rel=""nofollow noreferrer"">longest</a>: Get the longest item in an array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#lowerCase"" rel=""nofollow noreferrer"">lowerCase</a>: Convert string to lower case.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#lpad"" rel=""nofollow noreferrer"">lpad</a>: Pad string on the left side if it's shorter than length.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ltrim"" rel=""nofollow noreferrer"">ltrim</a>: Remove chars or white-spaces from beginning of string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#map"" rel=""nofollow noreferrer"">map</a>: Create an array of values by running each element in collection through iteratee.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#mapObj"" rel=""nofollow noreferrer"">mapObj</a>: Map for objects.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#matcher"" rel=""nofollow noreferrer"">matcher</a>: Return a predicate function that checks if attrs are contained in an object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#max"" rel=""nofollow noreferrer"">max</a>: Get maximum value of given numbers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#memStorage"" rel=""nofollow noreferrer"">memStorage</a>: Memory-backed implementation of the Web Storage API.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#memoize"" rel=""nofollow noreferrer"">memoize</a>: Memoize a given function by caching the computed result.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#meta"" rel=""nofollow noreferrer"">meta</a>: Document meta manipulation, turn name and content into key value pairs.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#methods"" rel=""nofollow noreferrer"">methods</a>: Return a sorted list of the names of every method in an object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#min"" rel=""nofollow noreferrer"">min</a>: Get minimum value of given numbers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#mkdir"" rel=""nofollow noreferrer"">mkdir</a>: Recursively create directories.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#moment"" rel=""nofollow noreferrer"">moment</a>: Tiny moment.js like implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ms"" rel=""nofollow noreferrer"">ms</a>: Convert time string formats to milliseconds.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#negate"" rel=""nofollow noreferrer"">negate</a>: Create a function that negates the result of the predicate function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#nextTick"" rel=""nofollow noreferrer"">nextTick</a>: Next tick for both node and browser.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#noop"" rel=""nofollow noreferrer"">noop</a>: A no-operation function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#normalizePath"" rel=""nofollow noreferrer"">normalizePath</a>: Normalize file path slashes.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#now"" rel=""nofollow noreferrer"">now</a>: Gets the number of milliseconds that have elapsed since the Unix epoch.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#objToStr"" rel=""nofollow noreferrer"">objToStr</a>: Alias of Object.prototype.toString.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#omit"" rel=""nofollow noreferrer"">omit</a>: Opposite of pick.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#once"" rel=""nofollow noreferrer"">once</a>: Create a function that invokes once.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#optimizeCb"" rel=""nofollow noreferrer"">optimizeCb</a>: Used for function context binding.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#orientation"" rel=""nofollow noreferrer"">orientation</a>: Screen orientation helper.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#pad"" rel=""nofollow noreferrer"">pad</a>: Pad string on the left and right sides if it's shorter than length.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#pairs"" rel=""nofollow noreferrer"">pairs</a>: Convert an object into a list of [key, value] pairs.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#parallel"" rel=""nofollow noreferrer"">parallel</a>: Run an array of functions in parallel.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#parseArgs"" rel=""nofollow noreferrer"">parseArgs</a>: Parse command line argument options, the same as minimist.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#partial"" rel=""nofollow noreferrer"">partial</a>: Partially apply a function by filling in given arguments.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#pascalCase"" rel=""nofollow noreferrer"">pascalCase</a>: Convert string to ""pascalCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#perfNow"" rel=""nofollow noreferrer"">perfNow</a>: High resolution time up to microsecond precision.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#pick"" rel=""nofollow noreferrer"">pick</a>: Return a filtered copy of an object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#pluck"" rel=""nofollow noreferrer"">pluck</a>: Extract a list of property values.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#precision"" rel=""nofollow noreferrer"">precision</a>: Find decimal precision of a given number.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#prefix"" rel=""nofollow noreferrer"">prefix</a>: Add vendor prefixes to a CSS attribute.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#promisify"" rel=""nofollow noreferrer"">promisify</a>: Convert callback based functions into Promises.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#property"" rel=""nofollow noreferrer"">property</a>: Return a function that will itself return the key property of any passed-in object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#query"" rel=""nofollow noreferrer"">query</a>: Parse and stringify url query strings.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#raf"" rel=""nofollow noreferrer"">raf</a>: Shortcut for requestAnimationFrame.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#random"" rel=""nofollow noreferrer"">random</a>: Produces a random number between min and max(inclusive).</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#randomBytes"" rel=""nofollow noreferrer"">randomBytes</a>: Random bytes generator.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#range"" rel=""nofollow noreferrer"">range</a>: Create flexibly-numbered lists of integers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ready"" rel=""nofollow noreferrer"">ready</a>: Invoke callback when dom is ready, similar to jQuery ready.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#reduce"" rel=""nofollow noreferrer"">reduce</a>: Turn a list of values into a single value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#reject"" rel=""nofollow noreferrer"">reject</a>: Opposite of filter.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#remove"" rel=""nofollow noreferrer"">remove</a>: Remove all elements from array that predicate returns truthy for and return an array of the removed elements.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#repeat"" rel=""nofollow noreferrer"">repeat</a>: Repeat string n-times.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#restArgs"" rel=""nofollow noreferrer"">restArgs</a>: This accumulates the arguments passed into an array, after a given index.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#rgbToHsl"" rel=""nofollow noreferrer"">rgbToHsl</a>: Convert rgb to hsl.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#rmCookie"" rel=""nofollow noreferrer"">rmCookie</a>: Loop through all possible path and domain to remove cookie.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#rmdir"" rel=""nofollow noreferrer"">rmdir</a>: Recursively remove directories.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#root"" rel=""nofollow noreferrer"">root</a>: Root object reference, <code>global</code> in nodeJs, <code>window</code> in browser.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#rpad"" rel=""nofollow noreferrer"">rpad</a>: Pad string on the right side if it's shorter than length.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#rtrim"" rel=""nofollow noreferrer"">rtrim</a>: Remove chars or white-spaces from end of string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#safeCb"" rel=""nofollow noreferrer"">safeCb</a>: Create callback based on input value.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#safeDel"" rel=""nofollow noreferrer"">safeDel</a>: Delete object property.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#safeGet"" rel=""nofollow noreferrer"">safeGet</a>: Get object property, don't throw undefined error.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#safeSet"" rel=""nofollow noreferrer"">safeSet</a>: Set value at path of object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#safeStorage"" rel=""nofollow noreferrer"">safeStorage</a>: Use storage safely in safari private browsing and older browsers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#sample"" rel=""nofollow noreferrer"">sample</a>: Sample random values from a collection.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#scrollTo"" rel=""nofollow noreferrer"">scrollTo</a>: Scroll to a target with animation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#selectionSort"" rel=""nofollow noreferrer"">selectionSort</a>: Selection sort implementation.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#shuffle"" rel=""nofollow noreferrer"">shuffle</a>: Randomize the order of the elements in a given array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#size"" rel=""nofollow noreferrer"">size</a>: Get size of object, length of array like object or the number of keys.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#slice"" rel=""nofollow noreferrer"">slice</a>: Create slice of source array or array-like object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#snakeCase"" rel=""nofollow noreferrer"">snakeCase</a>: Convert string to ""snakeCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#some"" rel=""nofollow noreferrer"">some</a>: Check if predicate return truthy for any element.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#spaceCase"" rel=""nofollow noreferrer"">spaceCase</a>: Convert string to ""spaceCase"".</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#splitCase"" rel=""nofollow noreferrer"">splitCase</a>: Split different string case to an array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#splitPath"" rel=""nofollow noreferrer"">splitPath</a>: Split path into device, dir, name and ext.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#startWith"" rel=""nofollow noreferrer"">startWith</a>: Check if string starts with the given target string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#strHash"" rel=""nofollow noreferrer"">strHash</a>: String hash function using djb2.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#stringify"" rel=""nofollow noreferrer"">stringify</a>: JSON stringify with support for circular object, function etc.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#stripAnsi"" rel=""nofollow noreferrer"">stripAnsi</a>: Strip ansi codes from a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#stripCmt"" rel=""nofollow noreferrer"">stripCmt</a>: Strip comments from source code.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#stripColor"" rel=""nofollow noreferrer"">stripColor</a>: Strip ansi color codes from a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#stripHtmlTag"" rel=""nofollow noreferrer"">stripHtmlTag</a>: Strip html tags from a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#sum"" rel=""nofollow noreferrer"">sum</a>: Compute sum of given numbers.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#template"" rel=""nofollow noreferrer"">template</a>: Compile JavaScript template into function that can be evaluated for rendering.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#throttle"" rel=""nofollow noreferrer"">throttle</a>: Return a new throttled version of the passed function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#through"" rel=""nofollow noreferrer"">through</a>: Tiny wrapper of stream Transform.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#timeAgo"" rel=""nofollow noreferrer"">timeAgo</a>: Format datetime with <em>*</em> time ago statement.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#timeTaken"" rel=""nofollow noreferrer"">timeTaken</a>: Get execution time of a function.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toArr"" rel=""nofollow noreferrer"">toArr</a>: Convert value to an array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toBool"" rel=""nofollow noreferrer"">toBool</a>: Convert value to a boolean.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toDate"" rel=""nofollow noreferrer"">toDate</a>: Convert value to a Date.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toEl"" rel=""nofollow noreferrer"">toEl</a>: Convert html string to dom elements.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toInt"" rel=""nofollow noreferrer"">toInt</a>: Convert value to an integer.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toNum"" rel=""nofollow noreferrer"">toNum</a>: Convert value to a number.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toSrc"" rel=""nofollow noreferrer"">toSrc</a>: Convert function to its source code.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#toStr"" rel=""nofollow noreferrer"">toStr</a>: Convert value to a string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#topoSort"" rel=""nofollow noreferrer"">topoSort</a>: Topological sorting algorithm.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#trigger"" rel=""nofollow noreferrer"">trigger</a>: Trigger browser events.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#trim"" rel=""nofollow noreferrer"">trim</a>: Remove chars or white-spaces from beginning end of string.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#tryIt"" rel=""nofollow noreferrer"">tryIt</a>: Run function in a try catch.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#type"" rel=""nofollow noreferrer"">type</a>: Determine the internal JavaScript [[Class]] of an object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#ucs2"" rel=""nofollow noreferrer"">ucs2</a>: UCS-2 encoding and decoding.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#unescape"" rel=""nofollow noreferrer"">unescape</a>: Convert HTML entities back, the inverse of escape.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#union"" rel=""nofollow noreferrer"">union</a>: Create an array of unique values, in order, from all given arrays.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#uniqId"" rel=""nofollow noreferrer"">uniqId</a>: Generate a globally-unique id.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#unique"" rel=""nofollow noreferrer"">unique</a>: Create duplicate-free version of an array.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#unzip"" rel=""nofollow noreferrer"">unzip</a>: Opposite of zip.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#upperCase"" rel=""nofollow noreferrer"">upperCase</a>: Convert string to upper case.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#upperFirst"" rel=""nofollow noreferrer"">upperFirst</a>: Convert the first character of string to upper case.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#use"" rel=""nofollow noreferrer"">use</a>: Use modules that is created by define.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#utf8"" rel=""nofollow noreferrer"">utf8</a>: UTF-8 encoding and decoding.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#uuid"" rel=""nofollow noreferrer"">uuid</a>: RFC4122 version 4 compliant uuid generator.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#values"" rel=""nofollow noreferrer"">values</a>: Create an array of the own enumerable property values of object.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#viewportScale"" rel=""nofollow noreferrer"">viewportScale</a>: Get viewport scale.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#waterfall"" rel=""nofollow noreferrer"">waterfall</a>: Run an array of functions in series.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#workerize"" rel=""nofollow noreferrer"">workerize</a>: Move a stand-alone function to a worker thread.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#wrap"" rel=""nofollow noreferrer"">wrap</a>: Wrap the function inside a wrapper function, passing it as the first argument.</li>
<li>
<a href=""https://eustia.liriliri.io/module.html#zip"" rel=""nofollow noreferrer"">zip</a>: Merge together the values of each of the arrays with the values at the corresponding position.</li>
</ol>

                ", Licia：最全最实用的 JavaScript 工具库,1531977698,329,1,875,1,1,https://segmentfault.com/a/1190000014747781
24,1,0,7,"
                    
<p><strong>如果对您有帮助，请一定帮忙点个star，让我有更大的动力继续分享，如果您要转载，务必补上我的github地址，谢谢兄dei</strong><br>原发布于个人github仓库：<a href=""https://github.com/screetBloom/wecat.js"" rel=""nofollow noreferrer"">https://github.com/screetBloom/wecat.js</a></p>
<p>vue毫不疑问是我们写框架时借鉴的核心，<strong>但是据我观察，其实很多人是不会读这种成熟的库、框架的</strong>，所以在这里先和大家说一下如何读vue</p>
<h2>科学读vue，授人以渔？element UI为什么取名element？</h2>
<p>接下来我们会具体的回答这两个问题。<br>毫无疑问，任何东西在刚起步的时候都是非常简单，当然也包括Vue，而且一开始的代码更能清晰的展示出来最一开始作者的思路      <br><br><br>我相信当你读vue源代码的时候，肯定也遇到过和我一样的问题，vue从2014年中后期大规模被使用以来，历时4年了。目前高度解耦的代码我是感觉很不好读的，很多时候我们都是看别人的博客和理解来读vue源码，不仅片面还都喜欢互相抄袭       <br>其实，我们自己也是可以尝试完全靠自己来理解vue的，不用去看某些人云亦云的博客     <br>然而当我们尝试去读源码，当我们打开<a href=""https://github.com/vuejs/vue"" rel=""nofollow noreferrer"">vue.js</a>,你会看到<br><span class=""img-wrap""><img data-src=""http://7xl4c6.com1.z0.glb.clouddn.com/FiaRUXW8uTUs_m8UQL1yNyKozBwu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vue的github主页"" title=""vue的github主页""></span><br><br><br>这里你会发现，即使你选""0.10""的branches，希望获取早期版本源码，那里面的代码也已经是中后期很系统的代码了，<strong>那么如何从最最最初期的代码读起呢？</strong>        <br>这个时候我们想到了commit，只要尤雨溪推代码，每次commit都会被记录下来，而在github上如何在当前仓库展示特定的某次commit呢？比如第一次的commit        <br>这个我先和大家说一下，github保存commit时是用的40位的hash值来标志某一次commit，呈现在浏览器上的url是这样子的：</p>
<pre><code class=""bahs"">https://github.com/vuejs/vue/tree/83fac017f96f34c92c3578796a7ddb443d4e1f17
// 也可以用7位hash来访问，如
https://github.com/vuejs/vue/tree/83fac01</code></pre>
<p>url格式是：仓库地址+'/tree/hash值'，那么我们只要获得commit的hash值，就可以读到vue从第一个提交到现在的所有版本的代码，不会有任何遗漏        <br>其实上述的url就是vue第一次提交的源代码，我们看图，注意标注的第一次提交：<br><span class=""img-wrap""><img data-src=""http://7xl4c6.com1.z0.glb.clouddn.com/FnMSjLvqUx99YYk4Jy2k3L5VUhkn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vue的第一次提交"" title=""vue的第一次提交""></span><br><strong>那么现在的问题就来了，如何获取到每一次vue项目提交的commit的hash值呢？既然是github，很明显的需要借助git命令</strong>        <br>方法如下：</p>
<ul>
<li>git clone下来</li>
<li>在项目目录打开 控制台，输入“git log --oneline --decorate --graph --all”，来查看所有commit，你会发现有非常多的commit，远远大于github上统计的数字。可以输入10万直接翻到最后一个“83fac017”，那我们现在开始看看历史上的第一个版本的hash，然后在浏览器中输入<a href=""https://github.com/vuejs/vue/tree/83fac017"" rel=""nofollow noreferrer"">https://github.com/vuejs/vue/...</a> 在github上查看</li>
<li>查看对应的head 的hash值，修改tree后面的值访问即可，我们找几个提交的代码来看看(test目录都是测试代码，可以不看)</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://7xl4c6.com1.z0.glb.clouddn.com/FsWUczxuJLMhHpG7qW9NbcEvv7xx"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""查看hash"" title=""查看hash""></span></p>
<pre><code class=""bash"">// 看看第一次提交的代码，目录结构有好几个，但是主要代码就main.js里的一句
module.exports = 123
// 我们再看看第三次提交的代码，很明显的src目录里已经有了三个文件directives.js、filters.js、main.js；这部分可以自己去看
// 我们重点看一下目录'explorations/getset.html'
var app = new Element('test', {
    msg: 'hello'
})</code></pre>
<p><strong>有没有想到饿了吗前端为什么将自己的UI组件库取名""element UI""</strong>,猜的不错的话，一方面应该是致敬vue；<br>从中我们也很明显看得出来，他们很早以前就知道这个方法来查看vue的历史版本，但是遗憾的是，网上很少有""授人以鱼不如授人以渔""的做法，没人去说如何合理的去看源代码，大量充斥的都是对源码理解的相互抄袭      <br><strong>到这里，如何科学的读vue就结束了，读vue使用这种方法，读react呢？还有以后读各种库呢？</strong></p>
<p><strong>再次希望，如果对您有帮助，请一定帮忙点个star，让我有更大的动力继续分享，<a href=""https://github.com/screetBloom/wecat.js"" rel=""nofollow noreferrer"">https://github.com/screetBloom/wecat.js</a></strong></p>

                ", 详细介绍如何科学的读vue - 授人以渔,1531977699,155,1,869,1,1,https://segmentfault.com/a/1190000014680930
25,1,0,7,"
                    
<h2>参考资料</h2>
<p>本文内容参考了<a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰老师的博文</a>，并做了适当整理，方便大家查阅。</p>
<h2>常用命令</h2>
<h3>仓库初始化 - <code>git init</code>
</h3>
<pre><code class=""bash"">git init</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649354?w=1034&amp;h=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我们新建一个文本文件<code>readme.txt</code></p>
<pre><code class=""bash"">Git is a distributed version control system.
Git is free software.</code></pre>
<h3>将文件添加到仓库中 - <code>git add</code>
</h3>
<pre><code class=""bash"">git add .</code></pre>
<h3>将文件提交到仓库 - <code>git commit</code>
</h3>
<pre><code class=""bash"">git commit -m ""wrote a readme file""</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649355?w=994&amp;h=168"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>查看仓库状态 - <code>git status</code>
</h3>
<pre><code class=""bash"">git status</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649356?w=1086&amp;h=334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>对比文件区别 - <code>git diff</code>
</h3>
<p>对文件内容进行简单修改并保存，这时还未提交（<code>commit</code>）到仓库，如果这时我们希望对比一下自从上次提交后，该文件发生了哪些变化，可以用<code>git diff</code>命令实现。</p>
<pre><code class=""bash"">git diff readme.txt</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649357?w=664&amp;h=272"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>
<strong>注：</strong><code>diff</code>比较的是当前未提交（<code>commit</code>）的版本跟上一个版本之间的差别。一旦<code>commit</code>到仓库，就无法比较了。</blockquote>
<h3>查看日志 - <code>git log</code>
</h3>
<pre><code class=""bash"">git log</code></pre>
<p>我们通过<code>git log</code>命令可以清楚地看到之前提交的版本。这里的一大串数字叫<code>commit id</code>。我们可以清楚地看到当前<code>HEAD</code>即是当前位置（<code>append GPL</code>）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649358?w=926&amp;h=578"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>回退版本 - <code>git reset</code>
</h3>
<p>当前所处的位置为<code>HEAD</code>，如果我们希望回退到上一步（即<code>add distribute</code>），可以用<code>HEAD^</code>来表示。上两步是<code>HEAD^^</code>，以此类推。</p>
<pre><code class=""bash"">git reset --hard HEAD^</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649359?w=788&amp;h=86"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>查看文件，内容已经更改回版本2了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649360?w=648&amp;h=110"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此时我们再用<code>git log</code>查看历史记录：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649361?w=926&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>发现<code>版本3</code>已经不见了，这时如果想再回复回去还有办法么？答案当然是肯定的，只要你记得<code>commit id</code>，随时可以用以下命令穿梭回去。</p>
<pre><code class=""bash"">git reset --hard acc1d</code></pre>
<blockquote>注：这里的<strong><code>acc1d</code></strong>是<code>commit id</code>的前几位，不需要写全，git会自动匹配。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649362?w=766&amp;h=236"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再次<code>git log</code>查看一下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649363?w=940&amp;h=586"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>查看所有历史记录 - <code>git reflog</code>
</h3>
<p>如果你忘记了之前的<code>commit id</code>也不要紧，可以用过<code>git reflog</code>来查找。</p>
<pre><code class=""bash"">git reflog</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649364?w=1024&amp;h=378"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>撤销工作区修改 - <code>git checkout -- filename</code>
</h3>
<p>假设现在我们又修改了文件内容。<br><strong>readme.txt</strong></p>
<pre><code class=""xml"">Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.</code></pre>
<p>这时我们保存了，但还没有提交到缓冲区。用<code>git status</code>查看，git提示文件已修改。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649365?w=1114&amp;h=320"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这时，我们可以用<code>git checkout -- filename</code>撤销修改就回到和版本库一模一样的状态。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649366?w=864&amp;h=280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>结论：</blockquote>
<ul>
<li>如果文件还没被提交到缓冲区，<code>git checkout -- filename</code>撤销修改就回到和版本库一模一样的状态；</li>
<li>如果文件已经被提交到缓冲区，<code>git checkout -- filename</code>撤销修改就回到添加到暂存区后的状态；</li>
</ul>
<blockquote>注：<code>git checkout -- filename</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令。</blockquote>
<h3>撤销缓冲区修改 - <code>git reset</code>
</h3>
<p><code>git reset HEAD filename</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649367?w=1076&amp;h=708"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这时如果还想撤销缓存区的修改，同样运行<code>git checkout -- filename</code>即可。</p>
<h3>删除文件 - <code>git rm filename</code>
</h3>
<p>当你删除了本地文件后，可能有两种情况：</p>
<ul>
<li>你确认要删除该文件，无论本地还是代码库；</li>
<li>本地误操作，想要从代码库回复；</li>
</ul>
<p>如果是第一种情况，可以用如下命令：</p>
<pre><code class=""bash"">git rm test.txt</code></pre>
<p>再用<code>git commit</code>把正式提交删除即可。</p>
<pre><code class=""bash"">git commit -m ""delete test.txt""</code></pre>
<p>如果是第二种情况，可以简单地用<code>git checkout</code>命令回退。</p>
<pre><code class=""bash"">git checkout -- test.txt</code></pre>
<h2>远端仓库</h2>
<h3>将本地仓库关联到远程仓库 - <code>git remote add origin [your repo url]</code>
</h3>
<p>在Github上新建一个仓库，例如：<code>learngit</code></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649368?w=2046&amp;h=1410"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Github会提示你可以将本地的仓库（目录）跟新建的仓库关联起来。<br>这里的<code>https://github.com/wfg2513148/learngit.git</code>是刚刚创建的仓库，<code>origin</code>是远程仓库默认的名字，一般看到<code>origin</code>字样就知道是远程库。</p>
<pre><code class=""bash"">git remote add origin https://github.com/wfg2513148/learngit.git
git push -u origin master</code></pre>
<pre><code class=""bash"">~/Desktop/learngit(master) » git push -u origin master
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (9/9), 820 bytes | 820.00 KiB/s, done.
Total 9 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), done.
To github.com:wfg2513148/learngit.git
 * [new branch]      master -&gt; master
Branch 'master' set up to track remote branch 'master' from 'origin'.</code></pre>
<blockquote>
<strong>注：</strong>当时在推送到远端仓库时遇到了以下异常：</blockquote>
<pre><code class=""bash"">~/Desktop/learngit(master) » git push -u origin master
ERROR: Repository not found.
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.</code></pre>
<p>可以尝试以下方法解决：</p>
<h3>重新生成ssh-key并绑定到Github上</h3>
<p>运行<code>ssh-keygen -t rsa -C ""wfgdlut@gmail.com""</code> 需要替换成你自己的Github账号邮箱。</p>
<pre><code class=""bash"">~/Desktop/learngit(master) » ssh-keygen -t rsa -C ""wfgdlut@gmail.com""
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/kwang/.ssh/id_rsa):
/Users/kwang/.ssh/id_rsa already exists.
Overwrite (y/n)? y
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/kwang/.ssh/id_rsa.
Your public key has been saved in /Users/kwang/.ssh/id_rsa.pub.</code></pre>
<p>查看生成好的公钥文件内容，本例中的为<code>/Users/kwang/.ssh/id_rsa.pub</code>。</p>
<p>将公钥内容原封不动的添加到Github上（<code>Settings -&gt; SSH and GPG keys -&gt; New SSH key</code>）<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649369?w=1002&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如果还是报错，继续以下步骤。</p>
<h3>显式指定远端仓库路径 - <code>git remote set-url origin [your repo url]</code>
</h3>
<p>用<code>git remote set-url origin [YOUR REPO]</code> 明确指定远端仓库，再次推送，应该就可以了。</p>
<pre><code class=""bash"">git remote set-url origin git@github.com:wfg2513148/learngit.git</code></pre>
<h3>克隆远端仓库 - <code>git clone [your repo url]</code>
</h3>
<pre><code class=""bash"">git clone git@github.com:wfg2513148/gitskills.git</code></pre>
<h2>分支</h2>
<h3>创建新分支 - <code>git checkout -b [new branch name]</code>
</h3>
<pre><code class=""bash"">git checkout -b dev</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649370?w=750&amp;h=252"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>
<code>-b</code>参数表示创建完立刻切换，相当于执行了以下两条命令：</blockquote>
<pre><code class=""bash"">git branch dev
git checkout dev</code></pre>
<h3>查看分支 - <code>git branch</code>
</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649370?w=750&amp;h=252"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>切换分支 - <code>git branch [branch name]</code>
</h3>
<pre><code class=""bash"">git branch master</code></pre>
<h3>合并分支</h3>
<h4>Fast-forward模式 - <code>git merge [branch name merged]</code>
</h4>
<p>当前我们处在master分支，现在想把dev分支合并到master分支上</p>
<pre><code class=""bash"">git merge dev</code></pre>
<p>可以看到，当前合并模式是<code>Fast-forward</code>，即快进模式，合并速度非常快。Git分支合并还有其他的模式。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649371?w=716&amp;h=192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>留痕模式 - <code>git merge --no-ff -m ""no-ff merge"" [branch name merged]</code>
</h4>
<p>我们可以使用<code>--no-ff</code>参数来合并，这样会保留合并历史分支的痕迹。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649372?w=1040&amp;h=162"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，<code>dev</code>分支的信息被保留下来了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649373?w=952&amp;h=426"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>删除分支</h3>
<h4>正常删除分支 - <code>git branch -d [branch name]</code>
</h4>
<pre><code class=""bash"">git branch -d feture1</code></pre>
<h4>强行删除分支 - <code>`</code>git branch -D [branch name]`</h4>
<pre><code class=""bash"">git branch -D feture1</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649374?w=692&amp;h=98"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>临时分支</h3>
<h4>创建临时分支 - <code>git stash</code>
</h4>
<p>有时候我们手头的工作还没做完，代码还没有提交（<code>add &amp; commit</code>），但临时有其他事情要做，需要切换分支。这时候可以使用临时分支把当前工作进展储存起来，以便有空的时候“恢复”回来。</p>
<pre><code class=""bash"">git stash</code></pre>
<p>可以看到当前工作情况已经被储存起来了，这时候可以放心地切换分支了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649375?w=1072&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>查看所有临时分支 - <code>git stash list</code>
</h4>
<pre><code class=""bash"">git stash list</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649376?w=526&amp;h=70"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>恢复临时分支内容 - <code>git stash apply</code>
</h4>
<p>当紧急工作做完后，重新切换回<code>dev</code>分支，取回临时分支中的工作。</p>
<pre><code class=""bash"">git stash apply</code></pre>
<blockquote>注：<code>git stash apply</code>仅仅恢复临时分支的内容，并不会主动删除stash。需要用<code>git stash drop</code>来删除。</blockquote>
<h4>删除临时分支 - <code>git stash drop</code>
</h4>
<pre><code class=""bash"">git stash drop</code></pre>
<h4>恢复同时删除临时分支 - <code>git stash pop</code>
</h4>
<pre><code class=""bash"">git stash pop</code></pre>
<h3>多人协作</h3>
<h4>查看远端分支 - <code>git remote</code>
</h4>
<pre><code class=""bash"">git remote</code></pre>
<p>远端仓库默认名称是<code>origin</code><br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649377?w=550&amp;h=102"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>查看远端分支详情 - <code>git remote -v</code>
</h4>
<pre><code class=""bash"">git remote -v</code></pre>
<p>根据当前访问权限，可以看到<code>fetch</code>抓取地址以及<code>push</code>推送地址。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649378?w=822&amp;h=132"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>推送分支 - <code>git push origin master</code>
</h4>
<blockquote>
<p>注: 这里的<code>origin master</code>代表要将本地内容推送到远端仓库（<code>origin</code>）的 <code>master</code> 分支上。</p>
<p>并不是所有的本地分支都要推送到远端的，推送原则：</p>
<ul>
<li>
<code>master</code>主干分支，应该时刻与远端保持同步；</li>
<li>
<code>dev</code>开发分支，也要保持与远端同步；</li>
<li>
<code>bug</code>分支，可以保持在本地即可；</li>
<li>
<code>feature</code>特性分支，是否要推送取决于你是否要跟他人协作；</li>
</ul>
</blockquote>
<h4>拉取分支</h4>
<p>远端仓库</p>
<pre><code class=""bash"">git clone git@github.com:wfg2513148/gitskills.git</code></pre>
<p>这时当我们查看分支时，值能看到本地的<code>master</code>分支</p>
<pre><code class=""bash"">git branch</code></pre>
<p>在本地创建远端分支</p>
<pre><code class=""bash"">git checkout -b dev origin/dev</code></pre>
<p>如果在提交的时候报冲突（其他人已经提交了），可以先用<code>git pull</code>抓取最新的代码，在本地合并后再推送。</p>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，说明本地分支和远端分支没有链接起来，这时候可以用以下语句完成链接：</p>
<pre><code class=""bash"">git branch --set-upstream branch-name origin/branch-name</code></pre>
<h2>标签管理</h2>
<h3>创建标签</h3>
<p>标签的作用就是方便快速切换分支，创建标签也很简单，直接<code>git tag v1.0</code>就可以生成一个标签。</p>
<pre><code class=""bash"">git tag v1.0</code></pre>
<h3>查看所有标签</h3>
<pre><code class=""bash"">git tag</code></pre>
<h3>补打标签</h3>
<p>先查出要打标签的<code>commit id</code>，再运行命令补打标签。</p>
<pre><code class=""bash"">git log --pretty=oneline --abbrev-commit</code></pre>
<p>比如我们希望对<code>conflict fiexed</code>补打标签，找到对应的commit id是<code>20adf59</code><br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649379?w=958&amp;h=278"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>补打标签：</p>
<pre><code class=""bash"">git tag v0.9 20adf59</code></pre>
<p>再次查看标签：</p>
<pre><code class=""bash"">git tag</code></pre>
<p>可以看到标签并不是按照时间顺序显示的。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649380?w=100&amp;h=68"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>通过<code>git show &lt;tagname&gt;</code>进一步查看标签内容</p>
<pre><code class=""bash"">git show v0.9</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649381?w=894&amp;h=224"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以用<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p>
<pre><code class=""bash"">git tag -a v0.1 -m ""version 0.1 released"" 53fe235</code></pre>
<p>再次查看标签详情<code>git tag v0.1</code>：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014649382?w=858&amp;h=682"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>删除标签</h3>
<pre><code class=""bash"">git tag -d v0.1</code></pre>
<h3>推送标签到远端分支</h3>
<pre><code class=""bash"">git push origin v1.0</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649383?w=950&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>一次性推送全部尚未推送的标签</h3>
<pre><code class=""bash"">git push origin --tags</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649384?w=898&amp;h=212"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>删除远端标签</h3>
<p>如果标签已经推送到远端，需要先删除本地标签：</p>
<pre><code class=""bash"">git tag -d v0.9</code></pre>
<p>然后再删除远端标签，格式如下：</p>
<pre><code class=""bash"">git push origin :refs/tags/v0.9</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014649385?w=906&amp;h=252"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>结语</h2>
<p>本文作为个人学习Git的参考资料，会不断丰富内容，也希望能够对大家有帮助。</p>

                ", Git学习笔记 - 钢钢更新,1531977700,501,1,673,1,1,https://segmentfault.com/a/1190000014649349
26,1,0,7,"
                    
<p>作为一个程序员，搭建一个个人博客几乎是所有人的需求，一来比较酷，二来也可以记录自己的学习和生活总结。但如果你不是全栈工程师，实现这个需求还是有点麻烦。后端搭建一套现有的前端框架及前端写API都还是有一定门槛的，当然，如果你是大牛当我没说，哈哈哈！</p>
<p>下面，我将介绍一个特别简单的方法，甚至不用写代码，执行几个命令就可以搭建一个博客，就算你不是程序员，也是So easy。那就是：fork<a href=""https://github.com/simbawus/blog"" rel=""nofollow noreferrer"">我的博客</a>。为什么说fork我的博客就可以搭建一个博客呢？博客重要的是有内容，并且可以随时更新，而不是一个静态页。这就要用到本文的核心：<a href=""https://developer.github.com/v4/"" rel=""nofollow noreferrer"">GitHub GraphQL API</a>，这是github提供的一个开放式的API。我们只需要将文章用Markdown写好后，放到博客项目Issues里面，然后通过这个api，获取我们的写的文章，再前端渲染，就可以啦！！是不是特别棒，都不要写API，也不用考虑文章存哪。下面我来介绍如何实现：</p>
<h2>获取access token</h2>
<p>请求GitHub GraphQL API，首先需要按照以下步骤在github申请一个access token：</p>
<blockquote>右上角个人头像 &gt; Settings &gt; Developer settings &gt; Personal access tokens &gt; Generate new token</blockquote>
<p>然后在Token description 写好关于这个token的描述，在<strong>Select scopes</strong>选择相应的权限，这里只需要user &gt;  read:user 就可以，点击<strong>Generate token</strong>按钮后会跳转到token列表页，这时需要马上把这个token记录下来，因为这是敏感数据，刷新后就没有了，不然得重新申请。</p>
<h2>项目搭建</h2>
<p>建议大家直接Fork我的项目 <a href=""https://github.com/simbawus/blog"" rel=""nofollow noreferrer"">simbawus/blog</a>，再修改相应配置，这样可以免去开发的成本，并且这个项目会持续更新，配置修改及启动可查看我项目的README。当然也可以fork后进行二次开发。也十分鼓励大家从零开始开发，也顺便练练手。</p>
<h2>获取GraphQL API数据</h2>
<p>关于GraphQL的介绍，可查看我些的这篇文章<a href=""https://github.com/simbawus/blog/issues/10"" rel=""nofollow noreferrer"">前端应该知道的GraphQL</a>。</p>
<p><a href=""https://developer.github.com/v4/"" rel=""nofollow noreferrer"">GitHub GraphQL API</a>的文档并没有使用示例，如果之前没用过GraphQL API，还是有点懵的，下面我举三个常见的例子说明下，具体可以看我博客代码，别忘了Star噢～。</p>
<h4>获取标签及相关issues</h4>
<p>通常，我们会在博客首页设计一个有分类的文章列表，这就要求在发布Issue时需要选择对应的label。先看<a href=""https://developer.github.com/v4/object/label/"" rel=""nofollow noreferrer"">官方label文档</a>：</p>
<p>Connections 里面有issues，所以在查询labels的同时，还可以查询issues。先列出要传输的数据data，核心也在这：</p>
<pre><code class=""javascript"">data = {
  query: `query {
    repository(owner:""simbawus"", name: ""blog"") {
      issues(orderBy:{field: UPDATED_AT, direction: DESC} , labels: null, first: 10, after: ${page}) {
        edges{
          cursor
          node{
            title
            updatedAt
            bodyText
            number
          }
        }
      }
      labels(first: 100){
        nodes{
          name
        }
      }
    }
  }`
};</code></pre>
<p><code>repository</code>代表查询指定的仓库，括号里的参数owner代表这个仓库的所有者，name代表仓库名称。<code>issues</code>表示要查询的issue列表，里面的参数表示这个列表的条件：<code>orderBy</code>为排序方式，根据更新时间UPDATED_AT和倒序DESC来，<code>labels</code>为null，说明查询的是所有issues，<code>first</code>表示一次查询返回的issues数量，<code>after</code>传上一个issue的id，可用来分页，最终这次请求拿到的数据结构如下，完整的请浏览器查看：</p>
<pre><code class=""json"">{
  ""data"": {
    ""repository"": {
      ""issues"": {
        ""edges"": {
          ""0"": {
            ""cursor"": ""Y3Vyc29yOnYyOpK5MjAxOC0wNC0yNlQxMDoyNjoxNiswODowMM4S8hYL"",
            ""node"": {
              ""bodyText"": ""作为一个程序员..."",
              ""number"": ""11"",
              ""title"": ""如何利用GitHub GraphQL API开发个人博客？"",
              ""updatedAt"": ""2018-04-22T03:46:34Z"",
            }
          }
        }
      },
      ""labels"": {
        ""nodes"": {
          ""0"": {
            ""name"": ""JavaScript""
          }
        }
      }
    }
  }
}</code></pre>
<h4>搜索</h4>
<p>search这个connections的文档写的让我一脸懵逼，摸索了好久才写出来，大家可以试着按<a href=""https://developer.github.com/v4/query/#connections"" rel=""nofollow noreferrer"">官网文档</a>写一下。</p>
<pre><code class=""javascript"">let data = {
  query: `query {
      search(query:""${keyWords} repo:simbawus/blog"", type: ISSUE, first: 10) {
        issueCount
        edges{
          cursor
          node{
            ... on Issue {
              title
              number
              bodyText
              updatedAt
            }
          }
        }
      }
    }`
};</code></pre>
<p>search的query参数类型为String!，表示一个非空的字符串，怎么也想不到要这么写才行吧？<code>query:""${keyWords} repo:simbawus/blog""</code>。node 这个fields的文档，看的也是二脸懵逼，还好想到es6的扩展符。</p>
<h4>详情</h4>
<p>最重要的是文章内容这部分了，传输数据比较简单：</p>
<pre><code class=""javascript"">let data = {
  query: `query {
    repository(owner:""simbawus"", name: ""blog"") {
      issue(number: ${articleId}) {
        title
        updatedAt
        bodyHTML
      }
    }
  }`
};</code></pre>
<p>请求直接返回一段HTML，问题是如何处理这段HTML，格式化并且高亮文章里面的代码。这里我用的是React的<code>dangerouslySetInnerHTML</code>和github的css库<code>github-markdown-css</code>，核心代码如下：</p>
<pre><code class=""javascript"">import 'github-markdown-css';
class ArticlePage extends React.Component {
  _renderHTML() {
    return { __html: this.state.bodyHTML };
  }
  render() {
    return ( 
      &lt;div  className = 'markdown-body'
            dangerouslySetInnerHTML = { this._renderHTML() } &gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>结合GitHub GraphQL API开发个人博客的核心内容基本就这么多了，具体代码欢迎查看github：<a href=""https://github.com/simbawus/blog"" rel=""nofollow noreferrer"">simbawus/blog</a>，一起踩坑。</p>
<h2>欢迎讨论，点个赞再走吧～</h2>
<p>文章同步于以下社区，可以选一个关注我噢 ｡◕‿◕｡</p>
<p><a href=""http://www.simbawu.com/blog"" rel=""nofollow noreferrer"">simbawu</a> | <a href=""https://github.com/simbawus/blog/issues"" rel=""nofollow noreferrer"">github</a> | <a href=""https://segmentfault.com/u/simbawu/articles"" rel=""nofollow noreferrer"">segmentfault</a> | <a href=""https://www.zhihu.com/people/wusb/posts"" rel=""nofollow noreferrer"">知乎</a> | <a href=""https://www.jianshu.com/u/54986e6d5fa7"" rel=""nofollow noreferrer"">简书</a> | <a href=""https://juejin.im/user/59cd9cb8518825745c637de0/activities"" rel=""nofollow noreferrer"">掘金</a></p>

                ", 如何利用GitHub GraphQL API开发个人博客？,1531977701,232,1,577,1,1,https://segmentfault.com/a/1190000014613391
27,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014578850"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""file"" title=""file""></span></p>
<p>在这篇文章中，我将推广一下大约一年前我介绍过的一些项目（公私皆有）中使用的开发模型，它们的结果都非常成功。有段时间我非常想写出来分享一下，但是我至今才抽出时间来。我不会言及任何项目细节，仅讨论分支策略和发布管理。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014578851"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""file"" title=""file""></span></p>
<h2>为何使用 git？ </h2>
<p>关于 Git 和集中式源码版本控制系统的优缺点对比讨论, <a href=""http://whygitisbetterthanx.com/"" rel=""nofollow noreferrer"">见</a> 此 <a href=""http://git.or.cz/gitwiki/GitSvnComparsion"" rel=""nofollow noreferrer"">web</a>。这里有很多精彩激烈的论战。作为一名开发者，现在我更偏好使用 Git 。Git 真的改变了开发者关于合并和分支的认知。我来自传统的 CVS/Subversion 世界，合并/分支是件恐怖的事情 （「小心合并冲突，它们会反噬你！」），而且大家偶尔才会做这件事。</p>
<p>但是使用 Git，这些操作就显得轻而易举，它们会成为你 <em>日常</em> 工作流的核心部分。例如，在 CVS/Subversion <a href=""http://svnbook.red-bean.com/"" rel=""nofollow noreferrer"">手册</a>中，分支和合并直到最后章节才首次出现（仅供高级用户参考），但是在 <a href=""http://book.git-scm.com/"" rel=""nofollow noreferrer"">每个</a> <a href=""http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git"" rel=""nofollow noreferrer"">Git</a> <a href=""http://github.com/progit/progit"" rel=""nofollow noreferrer"">手册</a>中，第三章就覆盖到了（基本上）。</p>
<p>因为具有简单和可重复的基因，分支和合并不再是什么值得担心的问题了。版本控制工具应该专注于分支/合并，而非其他事情。</p>
<p>关于工具的了解已经够了，那么我们就开始进入开发模型了。这个我要介绍的开发模型，不过是每个团队成员进入软件开发流程之前必须遵循的规范。</p>
<h2>去中心化和中心化 </h2>
<p>基于一个「真正」中心库的这种分支模型可以让我们很好的协同工作。注意这个库仅仅是被认为一个中心库（因为 GIT 在技术角度并没有中心库这一说法）。我们将此仓库命名为 <code>origin</code>，因为这名字被 Git 用户熟知。</p>
<p>!</p>
<p>所有开发者都从 <code>origin</code> 库拉取或向其推送代码。在中心化的推送-拉取关系之外，开发者也可以从其他的开发者库拉取代码更改。例如，为了开发一个大型功能，有多位开发者组成一个开发小组，在功能完成之前，开发过程不必推送至 <code>origin</code> 库。在上面的图中就有 Alice 和 Bob， Alice 和 David，还有 Clair 和 David 之间组成的小组。</p>
<p>技术层面，Alice 要在本地库加一个远程 Git 分支并命名为 <code>bob</code>，指向 Bob 的仓库。其他人也一样。</p>
<h2>主分支 </h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014578853"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""file"" title=""file""></span></p>
<p>git 的核心在开发模式上受到了现有模式的极大启发，中心仓库在整个生命周期保持了两个主要的分支：</p>
<ul>
<li><code>master</code></li>
<li><code>develop</code></li>
</ul>
<p>每个 Git 用户都对在 <code>origin</code> 的  <code>master</code> 分支很熟悉。 跟 <code>master</code> 分支并行的是另一个称为 <code>develop</code> 的分支。</p>
<p> 我们称 <code>origin/master</code> 为主分支，这个分支源码的 <code>HEAD</code> 一直指向 <em>可用于生产环境</em> 的状态。</p>
<p>我们称 <code>origin/develop</code> 为主分支，这个分支源码的 <code>HEAD</code> 总是反映下一个版本的最新开发状况。有些人称这个分支为 ""整合分支"" 。所有的每日自动构建都是从这儿构建的。</p>
<p>当 <code>develop</code> 分支上的源代码达到一个稳定点并准备发布时， 所有的更改都应该以某种方式合并回 <code>master</code> 分支， 然后使用发行版本进行标注。 接下来将从细节上讨论这是如何完成的。</p>
<p>因此， 每次将变更合并回 <code>master</code>分支时， 这是一个 <em>根据定义</em> 的新产品发布。 我们趋向于对此非常严格，因此理论上来讲， 我们可以在每次提交到 <code>master</code> 分支时， 使用一个 Git 钩子脚本来自动完成构建和发行我们的软件到生产服务器。</p>
<h2>辅助分支 </h2>
<p>在讨论完 <code>master</code> 分支和 <code>develop</code> 分支后，将要讨论的多样化的辅助分支，支持成员间并行开发， 轻松跟踪功能开发、生产版本发布、还能快速修复生产环境中产生的 Bug 。和主分支不同的是，辅助分支只有有限的生命周期，通常在完成使命后会被删除。</p>
<p>可能用到的辅助分支分类有：</p>
<ul>
<li>功能分支</li>
<li>发布分支</li>
<li>修复 Bug 分支</li>
</ul>
<p>每个分支都有特殊的用途。这些分支的来源分支和他们要合并回的分支都有严格的定义。在后面我们再具体讨论。</p>
<p>技术上，辅助分支都没有特殊含义。我们就是根据具体使用功能对辅助分支进行分类。辅助分支和普通的 Git 分支没有区别。</p>
<h3>功能分支 </h3>
<p>!</p>
<p>功能分支可能源自于：</p>
<p><code>develop</code> 分支</p>
<p>功能分支必须合并回：</p>
<p><code>develop</code> 分支</p>
<p>功能分支命名惯例：</p>
<p>任何名字都可以，但不能包含 <code>master</code>， <code>develop</code>， <code>release-*</code>， 或者 <code>hotfix-*</code> 。</p>
<p>功能分支（或称为特性分支）是被用来开发新功能的，这些新功能是要即将上线或更长时间后发布的。功能分支创建后开始开发时，之后将要合并的时间点是不知道的。功能分支的精髓是伴随开发过程一直存在，但是肯定会被合并回 <code>develop</code> （在下一个预期的发布版本中清晰的添加新功能 ) 或被丢弃 (万一实验不尽如人意）。</p>
<p>功能分支通常存在开发人员的仓库中，不会出现在 <code>origin</code> 仓库。</p>
<h4>创建一个功能分支 </h4>
<p>当我们开始写一个新的功能时，请从  <code>develop</code>  分支中切换出来</p>
<pre><code>$ git checkout -b myfeature develop
Switched to a new branch ""myfeature""</code></pre>
<h4>在开发中加入已经完成的功能 </h4>
<p>完成的功能可能被合并进入 <code>develop</code> 分支中，以确保他们会被添加到即将发布的版本中去</p>
<pre><code>$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557
(Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05e9557).
$ git push origin develop</code></pre>
<p><code>--no-ff</code> 标记将会在分支合并的时候在创建一个新的提交对象，即使这次合并可以使用 fast-forwark方法进行提交。这就可以避免丢失功能分支的历史信息并且可以把所有的功能在叠加在一起提交上去，请看图片对比：</p>
<p>!</p>
<p>在后一种情况中，从 Git 历史中是无法查看到是哪几个提交对象在一起实现了一个功能 -——您必须手动读取所有日志消息。还原整个功能（即一组完整的提交）在后一种情况下是真的让人很头疼的事情，但是如果使用使用 <code>--no-ff</code> 标志，就可以很容易完成这个任务的。</p>
<p>当然啦，它虽然创作更多的空的提交对象，但是增益却远远大于成本。</p>
<h3>发布分支 </h3>
<p>该分支可能源自于：</p>
<p><code>develop</code> 分支</p>
<p>必须合并到：</p>
<p><code>develop</code> 和 <code>master</code> 分支</p>
<p>分支命名习惯：</p>
<p><code>release-*</code></p>
<p>发布分支（Release branches） 支持新产品发布的准备。 它们允许在最后一刻追求细节。此外，它们允许小错误修复以及为发布准备元数据（版本号，构建日期等）。通过在发布分支上做的这些工作， <code>develop</code> 分支被清除以接收下一个大版本的功能特性。</p>
<p>从 <code>develop</code> 分支检出一个新发布分支的重要时刻就是当开发（基本上）反映了新版预期状态的时候。 至少，在那时，所有以『即将构建的发布版』（ release-to-be-built ）为目标的功能特性必须合并回 <code>develop</code> 分支。 针对未来版本的所有功能则可能不会 —— 它们必须等到发布分支检出以后才可以这么做。</p>
<p>正是在发布分支的开始，即将发布的版本才会被分配一个版本号 —— 一个前所未有的版本号。直到那一刻，<code>develop</code> 分支才反映了『下一版』的变更，但在发布分支开始前，对于『下一版』最终会是 0.3 版还是 1.0 版仍然是不明确的。该决定是在发布分支开始时进行的，并且由项目关于版本号碰撞的规则来执行。</p>
<h4>创建一个发布分支 </h4>
<p>发布分支源于 <code>develop</code> 分支。举个栗子，假设我们当前发布的产品版本为 1.1.5 ，并且即将发布一个新的大版本。  <code>develop</code> 分支已经为『下一版』做好了准备，我们决定把版本号改成 1.2（而不是 1.1.6 或者 2.0）。那么，我们要做的只是检出发布分支并给它一个可以反映版本号的名字：</p>
<pre><code>$ git checkout -b release-1.2 develop
Switched to a new branch ""release-1.2""
$ ./bump-version.sh 1.2
Files modified successfully, version bumped to 1.2.
$ git commit -a -m ""Bumped version number to 1.2""
[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
<p>在创建完新分支并切换到该分支后，我们需要碰撞版本号。在这个例子里， <code>bump-version.sh</code> 是一个虚构的脚本文件，用以改变工作副本中的一些文件来反映新版本。（当然也可以手动啦，重点是 <strong>那些</strong> 改变的文件）然后，碰撞后的版本号就被提交了。</p>
<p>直到确定会推出发布版的这段时间里，新分支都会一直存在。在此期间，bug 修复可能会应用到这个分支上（而不是 <code>develop</code> 分支）。 严禁在此分支添加大的新功能特性。 这些分支必须合并回 <code>develop</code> 分支，然后，等待下一个大版本的到来。</p>
<h4>完成并发布你的分支 </h4>
<p>当你真的准备好要发布分支的时候，还需要执行一些别的操作。首先，发行版必须合并进 <code>master</code> 分支中（一定确保每次提交到 <code>master</code> 分支的都是最新的版本）。接下来，请一定标记对 <code>master</code> 分支的更新记录，用于以后查看该版本时进行参考。最后， 发布新分支所做的更改需要重新合并为 <code>develop</code> 分支，以确保以后的版本也修复了这些错误。</p>
<p>Git 中的执行以下两个步骤：</p>
<pre><code>$ git checkout master
Switched to branch 'master'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2</code></pre>
<p>至此，这个版本已经完成修改，并且用作将来的参考版本。</p>
<blockquote>
<strong>注：</strong> 你可能还想要使用 <code>-s</code> 或者 <code>-u &lt;key&gt;</code> 来加密签名。</blockquote>
<p>为了保持发布分支所做的更改一致，我们需要将这些更改合并到 <code>develop</code> 分支中。在 Git 中执行：</p>
<pre><code>$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)</code></pre>
<p>这一步可能会导致合并冲突（可能是因为我们已经更改了版本号）。如果是这样，尝试修复它并再次提交。</p>
<p>现在我们已经完成了所有步骤，发布分支可以被删除了，因为我们不再需要它了：</p>
<pre><code>$ git branch -d release-1.2
Deleted branch release-1.2 (was ff452fe).</code></pre>
<h3>热修复分支 </h3>
<p>!</p>
<p>分支可能来自于：</p>
<p><code>master</code></p>
<p>必须合并到：</p>
<p><code>develop</code> 和 <code>master</code></p>
<p>分支命名惯例：</p>
<p><code>hotfix-*</code></p>
<p>热修复（hotfix）分支和发布（release）分支很像，因为它们都意味着即将有新的生产版本发布，尽管不是意料之中的。它们产生的原因是现有的生产版本出现了不受欢迎的情况，从而必须立即起作用。当生产版本中的一个严重的 bug 必须马上被修复，热修复分支可能从 master 分支上用于标记生产版本的对应标签上创建分支。</p>
<p>其本质是当有人准备对生产版本进行快速修复时，团队成员（在 <code>develop</code> 分支）可以继续工作。</p>
<h4>创建修复 bug 分支 </h4>
<p>修复 bug 分支创建于 <code>master</code> 分支。 例如，1.2版本是当前生产环境的版本并且有 bug 。但是 <code>develop</code> 分支上的修改还不够稳定。这时我们可以创建一个修复 bug 分支来解决这个问题：</p>
<pre><code>$ git checkout -b hotfix-1.2.1 master
Switched to a new branch ""hotfix-1.2.1""
$ ./bump-version.sh 1.2.1
Files modified successfully, version bumped to 1.2.1.
$ git commit -a -m ""Bumped version number to 1.2.1""
[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
<p>不要忘记在关闭分支后更新版本号！</p>
<p>然后，修复 bug ，一次提交或多次分开提交。</p>
<pre><code>$ git commit -m ""Fixed severe production problem""
[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)</code></pre>
<p><strong>完成一个修复 bug 分支</strong></p>
<p>当完成一个修复 bug 分支之后，bug 分支需要合并到 <code>master</code> 和 <code>develop</code> 分支上，以保证在下一版本中也包含该 bug 修复。 这与完成发布分支完全相似。</p>
<p>首先，更新 <code>master</code> 并对这次发布打上 tag 。</p>
<pre><code>$ git checkout master
Switched to branch 'master'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2.1</code></pre>
<p><strong>注:</strong> 你可能还想要使用 <code>-s</code> 或者 <code>-u &lt;key&gt;</code> 来加密签名。</p>
<p>然后，在 <code>develop</code> 分支里包含 bug 修复分支的改动：</p>
<pre><code>$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)</code></pre>
<p>对于上面的规则，有一点是例外的： <strong>当发布分支已经存在时， bug 修复分支的改动应该合并到该发布分支，而不是 <code>develop</code> 分支</strong>。当发布分支完成的时候， 把 bug 修复分支反向合并到发布分支中，最终也会导致 bug 修复被合并到 <code>develop</code> 分支中去。（如果 <code>develop</code> 分支中的工作马上就要这个 bug 修复的改动并且不能等待发布分支完成，那么现在你也可以安全地将 bug 修复合并到 <code>develop</code> 分支中去。）<br>最后，移除临时分支：</p>
<pre><code>$ git branch -d hotfix-1.2.1
Deleted branch hotfix-1.2.1 (was abbe5d6).</code></pre>
<h2>小结 </h2>
<p>虽然这种分支模式目前看来已经不是什么新鲜事了，但这篇文章开头的 「大图」已经证明，这种模式对我们的项目实实在在的是非常有用。它形成了一个优雅并且更加容易理解的模型，并且能加强团队中成员们对于分支和其释放过程的理解。</p>
<p>这里提供给大家上面大图更加清晰的 PDF 版本，建议把它打印出来挂在墙上膜拜并且以便开发过程中快速查看。</p>
<p><strong>更新：</strong> 如果有人需要这张图片： 这里附上下载文件 <a href=""http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip"" rel=""nofollow noreferrer"">gitflow-model.src.key</a> </p>
<p><a href=""http://nvie.com/files/Git-branching-model.pdf"" rel=""nofollow noreferrer"">Git 分支模型.pdf 下载</a></p>
<blockquote>更多现代化 PHP 知识，请前往 <a href=""https://laravel-china.org/topics/9992"" rel=""nofollow noreferrer"">Laravel / PHP 知识社区</a>
</blockquote>

                ", 一个成功的 Git 分支模型（适用于商业应用开发）,1531977703,504,1,126,1,1,https://segmentfault.com/a/1190000014578845
28,1,0,7,"
                    
<p>自去年第一次发布开源库 <a href=""https://github.com/scwang90/SmartRefreshLayout"" rel=""nofollow noreferrer"">SmartRefreshLayout</a> 以来，深刻的感受到了开源的乐趣。<br>所以打算以后开发过程中把一些自己实现的实用开源库也开源出来，供大家使用、讨论、升级。<br>MultiWaveHeader 便是第二个发布的开源库！先来看看下面的展示效果吧。</p>
<h2>Demo</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014496357?w=300&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><a href=""https://github.com/scwang90/MultiWaveHeader/raw/master/art/app-debug.apk"" rel=""nofollow noreferrer"">下载 APK-Demo</a></p>
<p>项目地址：<br><a href=""https://github.com/scwang90/MultiWaveHeader"" rel=""nofollow noreferrer"">github.com/MultiWaveHeader</a></p>
<h2>特性</h2>
<p>MultiWaveHeader 是一个可以高度定制每一条水波、且随意增加水波数量的 Android 水波开源库。<br>从而通过使用者自己的创意定制，可以使用在不同的页面场景。<br>目前 github 能搜索到的比较流行的水波开源库，如：<a href=""https://github.com/tangqi92/WaveLoadingView"" rel=""nofollow noreferrer"">tangqi92/WaveLoadingView</a>、<a href=""https://github.com/john990/WaveView"" rel=""nofollow noreferrer"">john990/WaveView</a>、<a href=""https://github.com/gelitenight/WaveView"" rel=""nofollow noreferrer"">gelitenight/WaveView</a> 等目前看起来对水波本身的可定制程度不高，都是固定两条水波。</p>
<h2>控制台</h2>
<h3>方向</h3>
<table>
<thead><tr>
<th align=""center"">顶部</th>
<th align=""center"">底部</th>
</tr></thead>
<tbody><tr>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000014496358?w=300&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></td>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000014496359?w=300&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></td>
<td> </td>
</tr></tbody>
</table>
<h3>数量</h3>
<table>
<thead><tr>
<th align=""center"">一对</th>
<th align=""center"">单一</th>
</tr></thead>
<tbody><tr>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000014496360?w=300&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></td>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000014496361?w=300&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></td>
<td> </td>
</tr></tbody>
</table>
<h2>使用</h2>
<h3>1.在 build.gradle 中添加依赖</h3>
<pre><code>compile 'com.scwang.wave:MultiWaveHeader:1.0.0-alpha-1'</code></pre>
<h3>2.在XML布局文件中添加 MultiWaveHeader</h3>
<pre><code class=""xml"">&lt;com.scwang.wave.MultiWaveHeader
    android:id=""@+id/waveHeader""
    android:layout_width=""match_parent""
    android:layout_height=""200dp""&gt;</code></pre>
<h2>属性</h2>
<h3>可以配置一些基本的属性.</h3>
<h4>java</h4>
<pre><code class=""java"">    MultiWaveHeader waveHeader = findViewById(R.id.waveHeader);

    waveHeader.setStartColor(R.color.colorPrimary);
    waveHeader.setCloseColor(R.color.colorPrimaryDark);
    waveHeader.setColorAlpha(.5f);

    waveHeader.setWaveHeight(50);
    waveHeader.setGradientAngle(360);
    waveHeader.setProgress(.8f);
    waveHeader.setVelocity(1f);
    waveHeader.setScaleY(-1f);

    waveHeader.setWaves(""PairWave"");

    waveHeader.start();
    waveHeader.stop();
    waveHeader.isRunning();</code></pre>
<h4>xml</h4>
<pre><code class=""xml"">    &lt;com.scwang.wave.MultiWaveHeader
        android:id=""@+id/waveHeader""
        android:layout_width=""match_parent""
        android:layout_height=""200dp""
        android:scaleY=""-1""
        app:mwhVelocity=""1""
        app:mwhProgress=""1""
        app:mwhRunning=""true""
        app:mwhGradientAngle=""45""
        app:mwhWaveHeight=""50dp""
        app:mwhColorAlpha=""0.45""
        app:mwhStartColor=""@color/colorPrimaryDark""
        app:mwhCloseColor=""@color/colorPrimaryLight""
        app:mwhWaves=""MultiWave""&gt;</code></pre>
<h2>精准定制</h2>
<p>MultiWaveHeader 可以精准定制每一条水波的参数：偏移量、拉伸量、运动速度和方向。</p>
<h3>java</h3>
<pre><code class=""java"">    MultiWaveHeader waveHeader = findViewById(R.id.waveHeader);


    String[] waves = new String[]{
        ""70,25,1.4,1.4,-26"",//wave-1:offsetX(dp),offsetY(dp),scaleX,scaleY,velocity(dp/s)
        ""100,5,1.4,1.2,15"",
        ""420,0,1.15,1,-10"",//wave-3:水平偏移(dp),竖直偏移(dp),水平拉伸,竖直拉伸,速度(dp/s)
        ""520,10,1.7,1.5,20"",
        ""220,0,1,1,-15"",
    };
    waveHeader.setWaves(TextUtils.join("" "", Arrays.asList(waves)));// custom
    waveHeader.setWaves(""PairWave"");// default two waves
    waveHeader.setWaves(""MultiWave"");// default five waves
</code></pre>
<h3>xml</h3>
<pre><code class=""xml"">    &lt;com.scwang.wave.MultiWaveHeader
        android:id=""@+id/waveHeader""
        android:layout_width=""match_parent""
        android:layout_height=""200dp""
        app:mwhWaves=""PairWave""
        app:mwhWaves=""MultiWave""
        app:mwhWaves=""
            70,25,1.4,1.4,-26
            100,5,1.4,1.2,15
            420,0,1.15,1,-10
            520,10,1.7,1.5,20
            220,0,1,1,-15""&gt;</code></pre>

                ", Android 炫酷的多重水波纹 MultiWaveHeader,1531977704,504,1,276,1,1,https://segmentfault.com/a/1190000014496352
29,1,0,7,"
                    
<p>此文章是笔者在github使用中的一些技巧性的总结，并非<a href=""https://segmentfault.com/a/1190000004606816"" rel=""nofollow noreferrer"">git入门与实践</a>，发表分享。</p>
<h6>入门推荐</h6>
<ul>
<li><a href=""https://git-scm.com/book/zh/v2"" rel=""nofollow noreferrer"">Git --everything-is-loca 官方文档</a></li>
<li><a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">Git教程-廖雪峰</a></li>
</ul>
<h2>github帮助文档</h2>
<ul>
<li>
<a href=""https://help.github.com/"" rel=""nofollow noreferrer"">官方网站</a> / <a href=""https://github.com/waylau/github-help"" rel=""nofollow noreferrer"">基础中文翻译</a>
</li>
<li><a href=""https://github.com/phodal/github"" rel=""nofollow noreferrer"">GitHub 漫游指南 by phodal</a></li>
<li><a href=""https://github.com/happypeter/gitbeijing"" rel=""nofollow noreferrer"">github 图解教程，献给曾经的北京 Git 用户组 http://gitbeijing.com</a></li>
<li><a href=""https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md#%E8%B4%A1%E7%8C%AE%E8%80%85%E6%8C%87%E5%8D%97"" rel=""nofollow noreferrer"">GitHub秘籍</a></li>
<li><a href=""http://www.imooc.com/learn/390"" rel=""nofollow noreferrer"">版本控制入门 – 搬进 Github</a></li>
<li><a href=""https://github.com/gotgit/gotgithub"" rel=""nofollow noreferrer"">GotGitHub: an open source E-book about GitHub in Chinese</a></li>
<li>
<a href=""https://github.com/geeeeeeeeek/git-recipes"" rel=""nofollow noreferrer"">git-recipes</a> - 高质量的Git中文教程</li>
</ul>
<h2>github flavord markdown语法介绍</h2>
<ul>
<li><a href=""https://github.com/guodongxiaren/README"" rel=""nofollow noreferrer"">guodongxiaren/README README文件语法解读</a></li>
<li><a href=""https://github.com/ruanyf/document-style-guide"" rel=""nofollow noreferrer"">中文技术文档的写作规范 by ruanyifeng</a></li>
<li><a href=""https://github.com/caiyongji/emoji-list"" rel=""nofollow noreferrer"">emoji-list/ github支持的emojj表情</a></li>
</ul>
<h5>栗子</h5>
<ul><li><a href=""https://github.com/xiaoyueyue165/smart/blob/dev/docs/markdown.md"" rel=""nofollow noreferrer"">markdown.md</a></li></ul>
<h2>github上传大文件</h2>
<p>用于上传单个文件大于100M失败时使用</p>
<ul><li><a href=""https://github.com/git-lfs/git-lfs"" rel=""nofollow noreferrer"">git-lfs</a></li></ul>
<h2>github.io添加项目展示</h2>
<p>在自己的github项目上添加<code>gh-pages</code>分支，并保证里面有需要展示的代码，以<code>index.html</code>作为入口就ok，可以展示项目了</p>
<h5>栗子</h5>
<ul>
<li>项目地址： <a href=""https://github.com/xiaoyueyue165/vip"" rel=""nofollow noreferrer"">vip</a>
</li>
<li>在线访问：<a href=""https://xiaoyueyue165.github.io/vip/%E5%94%AF%E5%93%81%E4%BC%9A%E9%A6%96%E9%A1%B5/"" rel=""nofollow noreferrer"">https://xiaoyueyue165.github....</a>
</li>
</ul>
<h2>github修改项目语言显示</h2>
<p>在项目根目录添加文件名为<code>.gitattributes</code>的文本文件，写入:</p>
<pre><code class=""js"">*.js linguist-language=Scala
*.css linguist-language=Scala
*.html linguist-language=Scala</code></pre>
<p>意思就是将.js、css、html当作Scala语言来统计,简单粗暴</p>
<h5>栗子</h5>
<p>将展示的语言变为<code>javascript</code></p>
<ul><li><a href=""https://github.com/xiaoyueyue165/King-of-glory"" rel=""nofollow noreferrer"">King-of-glory</a></li></ul>
<h2>github网站加载超时响应不完全的解决方法</h2>
<p>1.修改  C:WindowsSystem32driversetc  中的hosts文件，将下面一段话添加到hosts文件中：</p>
<pre><code># GitHub Start 
192.30.253.113 github.com 
8.7.198.45 gist.github.com 
151.101.228.133 assets-cdn.github.com 
151.101.72.133 raw.githubusercontent.com 
151.101.72.133 gist.githubusercontent.com 
151.101.72.133 cloud.githubusercontent.com 
151.101.0.133 camo.githubusercontent.com 
151.101.228.133 avatars0.githubusercontent.com 
151.101.228.133 avatars1.githubusercontent.com 
151.101.228.133 avatars2.githubusercontent.com 
151.101.228.133 avatars3.githubusercontent.com 
151.101.228.133 avatars4.githubusercontent.com 
151.101.228.133 avatars5.githubusercontent.com 
151.101.228.133 avatars6.githubusercontent.com 
151.101.228.133 avatars7.githubusercontent.com 
151.101.228.133 avatars8.githubusercontent.com 
# GitHub End</code></pre>
<p>2.修改hosts文件，直接通过IP访问github的CDN fastly.net，不用域名解析。</p>
<p>通过 www.ipaddress.com  这个网站查询github.global.ssl.fastly.net的IP地址，然后在hosts中增加一条。</p>
<pre><code>#fix github cdn problem because of GFW
185.31.17.184  github.global.ssl.fastly.net</code></pre>
<p>3.ping 网址链接，检测列表里的TTL值最小的IP输入到hosts里，如下修改<br><a href=""http://tool.chinaz.com/dns"" rel=""nofollow noreferrer"">Dns检测|Dns查询 - 站长工具</a></p>
<pre><code class=""bash"">    # github
    192.30.253.113  github.com
    151.101.228.133 assets-cdn.github.com
    192.30.255.116  api.github.com
    151.101.0.133 camo.githubusercontent.com 
    151.101.76.133  avatars0.githubusercontent.com
    151.101.24.133 avatars2.githubusercontent.com</code></pre>
<h2>在公司的局域网使用git或github 设置代理</h2>
<p>github上可以使用https进行访问。</p>
<pre><code class=""bash"">    $ git config --global http.proxy http://web-proxy.oa.com:8080</code></pre>
<blockquote>但是这样可以clone了。但是如果要push代码，那就麻烦了。每次都需要输入密码。</blockquote>
<h6>参考</h6>
<ul><li><a href=""http://www.cnblogs.com/lihaiping/p/4728993.html#commentform"" rel=""nofollow noreferrer"">http://www.cnblogs.com/lihaip...</a></li></ul>
<h2>git push免密码</h2>
<p>每次提交代码时需要输入用户名密码，则说明你在从仓库中clone代码时使用的是HTTPS的key进行拉取代码。而使用SSH key拉取代码时，则不需要。</p>
<p>1.创建文件 <code>.git-credentials</code> 存储GIT用户名和密码</p>
<pre><code class=""bash"">     # 创建
      touch .git-credentials
     # 在vim中打开 
      vim .git-credentials
     # 文件内容 
      https://{username}:{password}@github.com </code></pre>
<p>2.长期存储密码,进入git bash终端， 输入如下命令:</p>
<pre><code class=""bash"">    git config --global credential.helper store</code></pre>
<p>经过这样操作后就可以<code>免密登录</code>了</p>
<p><strong>注意事项</strong><br>文件结构要与下面的<code>git commit log</code>配置一样，3个配置文件保持这样的目录结构，并在同级目录下</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014495653?w=829&amp;h=312"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>git commit log</h2>
<p>优雅的提交，为 git 设置 commit template, 每次 git commit 的时候在 vim 中带出, 时刻提醒自己:</p>
<p>1.修改 ~/.gitconfig, 添加:</p>
<pre><code class=""bash"">[commit]
template = ~/.gitmessage</code></pre>
<p>2.新建 ~/.gitmessage</p>
<pre><code class=""bash"">  touch .gitmessage</code></pre>
<p><strong>内容可以如下:</strong></p>
<pre><code class=""bash"">* 简短的描述干了什么？
What: 

* 我为什么要这么做？
Why:

* 我是怎么做的？这么做会有什么副作用？
How:
</code></pre>
<p>or</p>
<pre><code class=""bash"">* Head
  * type: feat, fix, docs, style, refactor, test, chore
  * scope:影响范围，可省略
  * subject:简短的提交信息
* Body
  * what：详细做了什么
  * why：为什么这样做
  * how：有什么后果
* Footer
       相关链接
</code></pre>
<table>
<thead><tr>
<th>名称</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>type</td>
<td>commit 的类型</td>
</tr>
<tr>
<td>feat</td>
<td>新特性</td>
</tr>
<tr>
<td>fix</td>
<td>修改问题</td>
</tr>
<tr>
<td>refactor</td>
<td>代码重构</td>
</tr>
<tr>
<td>docs</td>
<td>文档修改</td>
</tr>
<tr>
<td>style</td>
<td>代码格式修改, 注意不是 css 修改</td>
</tr>
<tr>
<td>test</td>
<td>测试用例修改</td>
</tr>
<tr>
<td>chore</td>
<td>其他修改, 比如构建流程, 依赖管理.</td>
</tr>
<tr>
<td>scope</td>
<td>commit 影响的范围, 比如: route, component, utils, build...</td>
</tr>
<tr>
<td>subject</td>
<td>commit 的概述, 建议符合 50/72 formatting</td>
</tr>
<tr>
<td>body</td>
<td>commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting</td>
</tr>
<tr>
<td>footer</td>
<td>一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</td>
</tr>
</tbody>
</table>
<h6>参考</h6>
<ul>
<li><a href=""https://zhuanlan.zhihu.com/p/34223150"" rel=""nofollow noreferrer"">https://zhuanlan.zhihu.com/p/...</a></li>
<li><a href=""https://zhuanlan.zhihu.com/p/26791124"" rel=""nofollow noreferrer"">https://zhuanlan.zhihu.com/p/...</a></li>
<li><a href=""https://www.oschina.net/news/69705/git-commit-message-and-changelog-guide"" rel=""nofollow noreferrer"">https://www.oschina.net/news/...</a></li>
</ul>
<p>3.在vscode中使用<code>git commit log</code>模板</p>
<h5>官方自定义</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014501607?w=528&amp;h=370"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>这条消息是笔者在<a href=""https://github.com/Microsoft/vscode"" rel=""nofollow noreferrer"">vscode</a>提交的<code>issues</code>答案，与上面的配置完全一致，配置的时候注意<code>关闭重启vscode</code>就没有问题了。</p>
<ul><li><a href=""https://www.github.com/Microsoft/vscode/issues/39048"" rel=""nofollow noreferrer"">https://www.github.com/Micros...</a></li></ul>
<h5>模板设置好后</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014501608?w=687&amp;h=371"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>Commit an issues</h2>
<ul>
<li>
<code>package</code> version:l</li>
<li>
<code>node</code> version:</li>
<li>
<code>npm</code> (or <code>yarn</code>) version:</li>
</ul>
<p>Relevant code or config</p>
<p>What you did:</p>
<p>What happened:</p>
<p>&lt;!-- Please provide the full error message/screenshots/anything --&gt;</p>
<p>Reproduction repository:</p>
<p>&lt;!--<br>If possible, please create a repository that reproduces the issue with the<br>minimal amount of code possible.<br>--&gt;</p>
<p>Problem description:</p>
<p>Suggested solution:</p>
<h2>Fork 工作流中的 Pull Request</h2>
<p>待完成</p>
<h6>参考</h6>
<ul>
<li><a href=""https://github.com/geeeeeeeeek/git-recipes/wiki/3.3-%E5%88%9B%E5%BB%BA-Pull-Request"" rel=""nofollow noreferrer"">https://github.com/geeeeeeeee...</a></li>
<li><a href=""https://help.github.com/articles/creating-a-pull-request/"" rel=""nofollow noreferrer"">https://help.github.com/artic...</a></li>
</ul>
<h2>github上fork的项目如何保持同步</h2>
<p>1.将自己主页fork的项目clone到本地</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355482?w=1012&amp;h=197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此时，若我们查看项目的远程信息，发现结果都是关于我自己主页的，origin是分支名称：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355483?w=685&amp;h=95"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>2.为项目添加远程分支：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355484?w=674&amp;h=58"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>其中 upstream是远程分支名，后面的链接是原作者的仓库地址，此时再重新查看项目的远程信息，发现多了upstream的信息，是刚刚添加的原作者的仓库。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355485?w=684&amp;h=133"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ol><li>如果远程项目进行了更新，我们需要从upstream分支进行拉取，这样本地的代码就和原作者的代码同步了。</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355486?w=689&amp;h=241"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ol><li>将本地代码提交到自己主页的分支，即origin上了，这样，我自己主页的项目就和原作者的项目进行了同步。</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355487?w=795&amp;h=201"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>5.确认更新</p>
<p>使用小乌龟对比一下当前版本与上一个版本的差异，会看到变更了两个文件：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355488?w=468&amp;h=477"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我们打开其中一个<code>book.md</code>文件进行查看，会看到最新版本比上一个版本删除了一行文字。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355489?w=1271&amp;h=593"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再到github上面查看，可以看到刚才发起的merge从远程项目中合并更改的记录。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015355490?w=1010&amp;h=601"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>git 使用错误记录</h2>
<p><strong>git 推送出现 ""fatal: The remote end hung up unexpectedly""</strong></p>
<p>原因：上传的文件过大<br>解决办法：在项目.<code>git</code>文件夹下寻找<code>config</code>文件，添加如下代码：</p>
<pre><code class=""bash"">[http]
postBuffer = 524288000</code></pre>
<h5>参考</h5>
<ul><li><a href=""https://blog.csdn.net/zcmain/article/details/76855595"" rel=""nofollow noreferrer"">https://blog.csdn.net/zcmain/...</a></li></ul>
<h2>附录</h2>
<h3>博客</h3>
<p>初次发布于我个人博客上面<br><a href=""https://github.com/xiaoyueyue165/blog/issues/2"" rel=""nofollow noreferrer"">git+Github的正确姿势</a>，github，欢迎star和follow，谢谢！</p>

                ", git+Github的正确姿势,1531977705,275,1,746,1,1,https://segmentfault.com/a/1190000014492017
30,1,0,7,"
                    
<h2>git 操作规范</h2>
<h3>一、 创建与合并分支</h3>
<p><strong>1、 从master分支创建dev分支并切换到dev分支</strong></p>
<pre><code>git checkout master

git checkout -b dev

</code></pre>
<p>其中，git checkout -b dev 等价于:</p>
<pre><code>
git branch dev

git checkout dev
</code></pre>
<p>（1）</p>
<pre><code>git branch </code></pre>
<p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</p>
<p>（2）</p>
<pre><code>git  branch  -a </code></pre>
<p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</p>
<p><strong>2、修改代码、提交代码（当前的操作是在dev分支上进行）</strong></p>
<pre><code>git add a.html

git commit -m ""提交文件a.html""

</code></pre>
<p><strong>3、分支合并(将dev合并到master)</strong></p>
<pre><code>git checkout master 

git merge dev
</code></pre>
<p><strong>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)</strong></p>
<pre><code>git branch -d dev
</code></pre>
<p><strong>5、删除后，查看分支(此时看不到dev分支了)</strong></p>
<pre><code> 
git branch
</code></pre>
<p><strong>6、总结 ：工作中经常从master创建新的分支，具体操作如下</strong></p>
<pre><code>master创建新分支：

git checkout master

git checkout -b  issues1234

git push origin issues1234

git add ..

git commit -m ""***""

git push origin issues1234
</code></pre>
<blockquote>注意：将本地分支branch1推到远端的branch2操作步骤：</blockquote>
<pre><code>    git push origin branch1:branch2
</code></pre>
<p><strong>7、删除分支：</strong></p>
<pre><code>git branch -D   issues1234  //本地强制删除分支issues1234

git push origin  :issues1234  //推到远程

</code></pre>
<h3>二、 解决冲突</h3>
<p><strong>1、发生冲突的文件</strong></p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre>
<p>其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。</p>
<p>在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；<br>=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p>
<p>如果保留自己的代码，将别人的代码删掉即可。</p>
<p><strong>2、冲突解决后提交</strong></p>
<pre><code>git status

git add ***

git commit -m ""fix conflict""

git push origin 分支名
</code></pre>
<h3>三、Bug分支</h3>
<p><strong>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用</strong></p>
<pre><code>
git stash
</code></pre>
<p><strong>2、恢复储藏的代码</strong></p>
<pre><code>git stash pop //恢复的同时把stash内容删掉
</code></pre>
<p>或者</p>
<p><span class=""img-wrap""><img data-src=""/img/bV9xPT?w=499&amp;h=48"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<pre><code>//通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：
git stash apply stash@{0}


git stash apply  //恢复stash，但是stash内容并不删除

git stash drop //在上面操作的基础上，以此来删除stash


注： git stash list //查看全部的stash列表
</code></pre>
<p><strong>3、将stash空间清空</strong></p>
<pre><code>git stash clear
</code></pre>
<p><strong>4、git stash pop 和 git stash apply 区别</strong></p>
<pre><code>原来git stash pop stash@{id}命令会在执行后将对应的stash id 从stash list里删除，
而 git stash apply stash@{id} 命令则会继续保存stash id。
</code></pre>
<h3>四、版本回退</h3>
<p><strong>1、回退至上一个版本</strong></p>
<pre><code>git reset --hard HEAD 
</code></pre>
<p><strong>2、回退至指定版本</strong></p>
<pre><code>git reset --hard  版本号
</code></pre>
<p><strong>3、查看以往版本号(本地的commit)</strong></p>
<pre><code>git reflog
</code></pre>
<p><strong>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)</strong></p>
<pre><code>git log
</code></pre>
<h3>五、撤销修改</h3>
<p><strong>1、撤销修改</strong></p>
<pre><code>
git  checkout -- a.html
</code></pre>
<blockquote>分两种情况分析：</blockquote>
<pre><code>①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。

②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态
</code></pre>
<p>注：一旦执行了git commit -m ""<em>*</em>""，就不能再使用上面的命令回退。</p>
<p><strong>2、撤销新建文件</strong></p>
<p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p>
<pre><code>git clean -f ../aa.html
</code></pre>
<p><strong>3、撤销新建文件夹</strong></p>
<p>比如新建一个文件夹""demo""，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p>
<pre><code>git clean -df ./demo
  
</code></pre>
<h3>六、对于已经push的版本，进行回退</h3>
<p><strong>1、第一步：</strong></p>
<pre><code>git reset --hard 版本号 //本地回退到指定的版本
</code></pre>
<p><strong>2、第二步：</strong></p>
<pre><code>git push  -f origin dev    //将远程的也回退到指定版本

</code></pre>
<h3>七、本地同步远程删除的分支</h3>
<pre><code>git fetch origin -p  //用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了
</code></pre>
<h3>八、删除掉没有与远程分支对应的本地分支</h3>
<p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：</p>
<pre><code>git fetch -p
</code></pre>
<h3>九、查看远程库的一些信息，及与本地分支的信息</h3>
<pre><code>
 git remote show origin 

</code></pre>
<h3>十、标签管理</h3>
<p><strong>1、给当前分支最新commit打标签</strong></p>
<pre><code>git tag v1.0.0
</code></pre>
<p><strong>2、比如现在周五，要给周一某个commit打标签，应执行以下步骤：</strong></p>
<p><code>（1）、查看log日志，找到相应的commit版本号</code></p>
<pre><code>git log --pretty=oneline --abbrev-commit
</code></pre>
<p>//显示如下commit，比如我想在 ""34372b05""这个commit打标签<br>44d2e20b fix bug<br>34372b05 fix bug<br>29554931 fix bug</p>
<p><code>（2）、给指定的commit打标签</code></p>
<pre><code>git tag v1.0.0 34372b05

</code></pre>
<p><code>（3）、创建的标签只存在本地，推至远程</code></p>
<pre><code>
git push origin v1.0.0
</code></pre>
<p><code>（4）、一次性推送未推至远程的本地标签</code></p>
<pre><code>
git push origin --tags
</code></pre>
<p><code>（5）、查询所有标签</code></p>
<pre><code>
git tag
</code></pre>
<p><code>（6）、查询标签详细信息</code></p>
<pre><code>git show v1.0.0
</code></pre>
<p><code>（7）、删除本地标签</code></p>
<pre><code>git tag -d v1.0.0
</code></pre>
<p><code>（8）、删除远程标签</code></p>
<pre><code>
//先从本地删除
git tag -d v1.0.0

//然后从远程删除
git push origin :refs/tags/v1.0.0

//最后可以在gitlab上查看是否真正的删除了标签
</code></pre>
<p><strong>3、创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong></p>
<pre><code>
//git   tag   -a   版本号   -m    说明信息   commit版本号
git tag -a v1.0.0 -m ""version 1.0.0 released"" 34372b05(commit版本号)    

//查看标签详细信息
git show v1.0.0    
</code></pre>

                ", git 操作规范,1531977706,474,1,200,1,1,https://segmentfault.com/a/1190000014461898
31,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV8leu?w=2700&amp;h=1500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>作为一名Web开发者，CSS是必备技能之一，我一直以为自己对CSS的掌握已经够用了，直到读Lea Verou的《CSS揭秘》时，我发现自己充其量就算个会打CS的选手，书中针对我们常见的网页设计难题从不同的角度提出了多种实用又优雅的解决方案，在这里强烈的推荐给每一位从事前端相关的开发者，相信你一定会有所收获。</p>
<p>为了以后可以更爽的复制粘贴，笔者把自己的收获和工作中常用的一些CSS小样式总结成这份文档，一共包含43个CSS的小样式（持续更新…）。文档还有很多不足的地方，还请各位多多指教，如果觉得对你有一点帮助，欢迎大家一起来完善?~</p>
<h2>What's included</h2>
<h3>边框与背景</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/translucent-borders"" rel=""nofollow noreferrer"">半透明边框</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/multiple-borders"" rel=""nofollow noreferrer"">多重边框</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/inner-rounding"" rel=""nofollow noreferrer"">边框内圆角</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/extended-bg-position"" rel=""nofollow noreferrer"">背景定位</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/stripes-background"" rel=""nofollow noreferrer"">条纹背景</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/one-pixel-line"" rel=""nofollow noreferrer"">1px 线/边</a></li>
</ul>
<h3>常见形状</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/ellipse"" rel=""nofollow noreferrer"">圆与椭圆</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/parallelogram"" rel=""nofollow noreferrer"">平行四边形</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/bevel-corners"" rel=""nofollow noreferrer"">切角效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/pie-chart"" rel=""nofollow noreferrer"">简易饼图</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/poptip"" rel=""nofollow noreferrer"">提示气泡</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/polygon"" rel=""nofollow noreferrer"">其他多边形</a></li>
</ul>
<h3>视觉效果</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/single-projection"" rel=""nofollow noreferrer"">常见投影</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/irregular-projection"" rel=""nofollow noreferrer"">不规则投影</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/frosted-glass"" rel=""nofollow noreferrer"">毛玻璃效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/zebra-stripes"" rel=""nofollow noreferrer"">斑马条纹</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/text-effects"" rel=""nofollow noreferrer"">文字特效</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/circular-text"" rel=""nofollow noreferrer"">环形文字</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/line-breaks"" rel=""nofollow noreferrer"">插入换行</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/image-slider"" rel=""nofollow noreferrer"">图片对比控件</a></li>
</ul>
<h3>用户体验</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/mouse-cursor"" rel=""nofollow noreferrer"">选择合适的鼠标光标</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/extend-hit-area"" rel=""nofollow noreferrer"">扩大可点击区域</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/custom-checkbox"" rel=""nofollow noreferrer"">自定义复选框</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/custom-radio"" rel=""nofollow noreferrer"">自定义单选框</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/input-align"" rel=""nofollow noreferrer"">输入框完美居中</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/shadow-weaken-background"" rel=""nofollow noreferrer"">通过阴影弱化背景</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/blurry-weaken-background"" rel=""nofollow noreferrer"">通过模糊弱化背景</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/text-underline"" rel=""nofollow noreferrer"">自定义文字下划线</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/scrollbar"" rel=""nofollow noreferrer"">自定义scroll滚动条</a></li>
</ul>
<h3>结构布局</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/fluid-fixed"" rel=""nofollow noreferrer"">全背景等宽内容居中</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/sticky-footer"" rel=""nofollow noreferrer"">绝对底部</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/centering-known"" rel=""nofollow noreferrer"">水平垂直居中</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/holy-grail-layout?v=1"" rel=""nofollow noreferrer"">圣杯布局</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/double-wing-layout?v=1"" rel=""nofollow noreferrer"">双飞翼布局</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/class-order-layout"" rel=""nofollow noreferrer"">类订单布局</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/flexbox-layout"" rel=""nofollow noreferrer"">Flex 布局</a></li>
</ul>
<h3>动画过渡</h3>
<ul>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/bounce"" rel=""nofollow noreferrer"">弹跳效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/elastic"" rel=""nofollow noreferrer"">弹性过度</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/blink"" rel=""nofollow noreferrer"">闪烁效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/typing"" rel=""nofollow noreferrer"">打字效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/shake"" rel=""nofollow noreferrer"">抖动效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/smooth"" rel=""nofollow noreferrer"">无缝平滑效果</a></li>
<li><a href=""https://lhammer.cn/You-need-to-know-css/#/circular-smooth"" rel=""nofollow noreferrer"">延轨迹平滑效果</a></li>
</ul>
<p>文档中代码支持实时调试预览，若有疑问或者建议请直接在文档下方留言，如果你有更有趣更实用的技巧，欢迎PR~</p>
<p>文档：<a href=""https://lhammer.cn/You-need-to-know-css/#/"" rel=""nofollow noreferrer"">You-need-to-know-css</a></p>
<p>Github：<a href=""https://github.com/l-hammer/You-need-to-know-css"" rel=""nofollow noreferrer"">LHammer/You-need-to-know-css</a></p>

                ", ?Web开发者需要知道的CSS Tricks,1531977707,493,1,678,1,1,https://segmentfault.com/a/1190000014416211
32,1,0,7,"
                    
<h1>Hubble</h1>
<blockquote>
<span class=""emoji emoji-telescope""></span> Travle through GitHub Stars' history</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014246019"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Screenshot"" title=""Screenshot""></span></p>
<p>Hubble (<a href=""https://hubble.js.org"" rel=""nofollow noreferrer"">hubble.js.org</a>) 是一个查看 GitHub Star 的工具，它可以查询一个仓库的 Star 历史，并以图表的形式展现出来。<br>最近，Hubble 新增了一项功能：统计你今年获得了多少颗 Star，这对于习惯做年度目标和总结的同学来说将会是非常便利的功能，快来试试看吧！</p>
<h3>链接</h3>
<ul>
<li><a href=""https://hubble.js.org"" rel=""nofollow noreferrer"">Hubble · Travel through GitHub Stars' history</a></li>
<li>源码：<a href=""https://github.com/SevenOutman/Hubble"" rel=""nofollow noreferrer"">GitHub · SevenOutman/Hubble</a>，别忘了 Star 一下该项目，Follow 一下作者哦~！</li>
</ul>

                ", 你的 GitHub 今年得了几颗星星？,1531977709,108,1,253,1,1,https://segmentfault.com/a/1190000014246014
33,1,0,7,"
                    
<p>为什么使用 git 和 git flow，这篇文章 <a href=""https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md#23-gitflow%E5%B7%A5%E4%BD%9C%E6%B5%81"" rel=""nofollow noreferrer"">深入理解学习Git工作流</a> 的内容相信能够给你一个完整的答案。</p>
<ul>
<li>我们以使用SVN的工作流来使用git有什么不妥？</li>
<li>git 方便的branch在哪里，团队多人如何协作？冲突了怎么办？如何进行发布控制？</li>
<li>经典的master-发布、develop-主开发、hotfix-不过修复如何避免代码不经过验证上线？</li>
<li>如何在github上面与他人一起协作，star-fork-pull request是怎样的流程？</li>
</ul>
<p>这篇文章分为两部分，一部分引用 <a href=""https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md#23-gitflow%E5%B7%A5%E4%BD%9C%E6%B5%81"" rel=""nofollow noreferrer"">深入理解学习Git工作流</a> 文章中的 git flow 工作流内容，一部分是使用 SourceTree 中的 git flow 工具来实现可视化的 git flow 流程管理，避免我们在使用 git 命令时遇到的坑。而且 SourceTree 的所有可视化操作都会展示相应的执行命令。</p>
<blockquote><a href=""https://segmentfault.com/a/1190000013810310"" rel=""nofollow noreferrer"">SourceTree Win10 安装过程及配置</a></blockquote>
<h2>
<code>Gitflow</code> 工作流</h2>
<p><code>Gitflow</code>工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810444"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Workflows: Gitflow Cycle"" title=""Git Workflows: Gitflow Cycle""></span></p>
<p>这节介绍的<a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer""><code>Gitflow</code>工作流</a>借鉴自在<a href=""http://nvie.com/"" rel=""nofollow noreferrer"">nvie</a>的<em>Vincent Driessen</em>。</p>
<p><code>Gitflow</code>工作流定义了一个围绕项目发布的严格分支模型。虽然比<a>功能分支工作流</a>复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p>
<p><code>Gitflow</code>工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个明确的角色，并定义分支之间如何和什么时候进行交互。<br>除了使用功能分支，在做准备、维护和记录发布时，也定义了各自的分支。<br>当然你可以用上功能分支工作流所有的好处：<code>Pull Requests</code>、隔离实验性开发和更高效的协作。</p>
<h3>2.3.1 工作方式</h3>
<p><code>Gitflow</code>工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并<code>push</code>分支到要中央仓库中。</p>
<h3>2.3.2 历史分支</h3>
<p>相对于使用仅有的一个<code>master</code>分支，<code>Gitflow</code>工作流使用两个分支来记录项目的历史。<code>master</code>分支存储了正式发布的历史，而<code>develop</code>分支作为功能的集成分支。<br>这样也方便<code>master</code>分支上的所有提交分配一个版本号。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810445?w=614&amp;h=148"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>剩下要说明的问题围绕着这2个分支的区别展开。</p>
<h3>2.3.3 功能分支</h3>
<p>每个新功能位于一个自己的分支，这样可以<a href=""https://www.atlassian.com/git/tutorial/remote-repositories#!push"" rel=""nofollow noreferrer""><code>push</code>到中央仓库以备份和协作</a>。<br>但功能分支不是从<code>master</code>分支上拉出新分支，而是使用<code>develop</code>分支作为父分支。当新功能完成时，<a href=""https://www.atlassian.com/git/tutorial/git-branches#!merge"" rel=""nofollow noreferrer"">合并回<code>develop</code>分支</a>。<br>新功能提交应该从不直接与<code>master</code>分支交互。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810446?w=614&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>注意，从各种含义和目的上来看，功能分支加上<code>develop</code>分支就是功能分支工作流的用法。但<code>Gitflow</code>工作流没有在这里止步。</p>
<h3>2.3.4 发布分支</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810447?w=614&amp;h=320"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一旦<code>develop</code>分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从<code>develop</code>分支上<code>checkout</code>一个发布分支。<br>新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——<br>这个分支只应该做<code>Bug</code>修复、文档生成和其它面向发布任务。<br>一旦对外发布的工作都完成了，发布分支合并到<code>master</code>分支并分配一个版本号打好<code>Tag</code>。<br>另外，这些从新建发布分支以来的做的修改要合并回<code>develop</code>分支。</p>
<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。<br>这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。</p>
<p>常用的分支约定：</p>
<pre><code>用于新建发布分支的分支: develop
用于合并的分支: master
分支命名: release-* 或 release/*</code></pre>
<h3>2.3.5 维护分支</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810448"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>维护分支或说是热修复（<code>hotfix</code>）分支用于给产品发布版本（<code>production releases</code>）快速生成补丁，这是唯一可以直接从<code>master</code>分支<code>fork</code>出来的分支。<br>修复完成，修改应该马上合并回<code>master</code>分支和<code>develop</code>分支（当前的发布分支），<code>master</code>分支应该用新的版本号打好<code>Tag</code>。</p>
<p>为<code>Bug</code>修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。<br>你可以把维护分支想成是一个直接在<code>master</code>分支上处理的临时发布。</p>
<h3>2.3.6 示例</h3>
<p>下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。</p>
<h4>创建开发分支</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810449?w=236&amp;h=146"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>第一步为<code>master</code>分支配套一个<code>develop</code>分支。简单来做可以<a href=""https://www.atlassian.com/git/tutorial/git-branches#!branch"" rel=""nofollow noreferrer"">本地创建一个空的<code>develop</code>分支</a>，<code>push</code>到服务器上：</p>
<pre><code class=""bash"">git branch develop
git push -u origin develop</code></pre>
<p>以后这个分支将会包含了项目的全部历史，而<code>master</code>分支将只包含了部分历史。其它开发者这时应该<a href=""https://www.atlassian.com/git/tutorial/git-basics#!clone"" rel=""nofollow noreferrer"">克隆中央仓库</a>，建好<code>develop</code>分支的跟踪分支：</p>
<pre><code class=""bash"">git clone ssh://user@host/path/to/repo.git
git checkout -b develop origin/develop</code></pre>
<p>现在每个开发都有了这些历史分支的本地拷贝。</p>
<h4>小红和小明开始开发新功能</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810450?w=236&amp;h=234"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于<code>master</code>分支，而是应该<a href=""https://www.atlassian.com/git/tutorial/git-branches#!checkout"" rel=""nofollow noreferrer"">基于<code>develop</code>分支</a>：</p>
<pre><code class=""bash"">git checkout -b some-feature develop</code></pre>
<p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p>
<pre><code class=""bash"">git status
git add &lt;some-file&gt;
git commit</code></pre>
<h4>小红完成功能开发</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810451?w=236&amp;h=104"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>添加了提交后，小红觉得她的功能OK了。如果团队使用<code>Pull Requests</code>，这时候可以发起一个用于合并到<code>develop</code>分支。<br>否则她可以直接合并到她本地的<code>develop</code>分支后<code>push</code>到中央仓库：</p>
<pre><code class=""bash"">git pull origin develop
git checkout develop
git merge some-feature
git push
git branch -d some-feature</code></pre>
<p>第一条命令在合并功能前确保<code>develop</code>分支是最新的。注意，功能决不应该直接合并到<code>master</code>分支。<br>冲突解决方法和<a>集中式工作流</a>一样。</p>
<h4>小红开始准备发布</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810452?w=236&amp;h=144"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。<br>像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</p>
<pre><code class=""bash"">git checkout -b release-0.1 develop</code></pre>
<p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p>
<p>只要小红创建这个分支并<code>push</code>到中央仓库，这个发布就是功能冻结的。任何不在<code>develop</code>分支中的新功能都推到下个发布循环中。</p>
<h4>小红完成发布</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810453?w=236&amp;h=235"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一旦准备好了对外发布，小红合并修改到<code>master</code>分支和<code>develop</code>分支上，删除发布分支。合并回<code>develop</code>分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。<br>另外，如果小红的团队要求<code>Code Review</code>，这是一个发起<code>Pull Request</code>的理想时机。</p>
<pre><code class=""bash"">git checkout master
git merge release-0.1
git push
git checkout develop
git merge release-0.1
git push
git branch -d release-0.1</code></pre>
<p>发布分支是作为功能开发（<code>develop</code>分支）和对外发布（<code>master</code>分支）间的缓冲。只要有合并到<code>master</code>分支，就应该打好<code>Tag</code>以方便跟踪。</p>
<pre><code class=""bash"">git tag -a 0.1 -m ""Initial public release"" master
git push --tags</code></pre>
<p><code>Git</code>有提供各种勾子（<code>hook</code>），即仓库有事件发生时触发执行的脚本。<br>可以配置一个勾子，在你<code>push</code>中央仓库的<code>master</code>分支时，自动构建好版本，并对外发布。</p>
<h4>最终用户发现<code>Bug</code>
</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013810454?w=236&amp;h=125"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>对外版本发布后，小红小明一起开发下一版本的新功能，直到有最终用户开了一个<code>Ticket</code>抱怨当前版本的一个<code>Bug</code>。<br>为了处理<code>Bug</code>，小红（或小明）从<code>master</code>分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回<code>master</code>分支：</p>
<pre><code class=""bash"">git checkout -b issue-#001 master
# Fix the bug
git checkout master
git merge issue-#001
git push</code></pre>
<p>就像发布分支，维护分支中新加这些重要修改需要包含到<code>develop</code>分支中，所以小红要执行一个合并操作。然后就可以安全地<a href=""https://www.atlassian.com/git/tutorial/git-branches#!branch"" rel=""nofollow noreferrer"">删除这个分支</a>了：</p>
<pre><code class=""bash"">git checkout develop
git merge issue-#001
git push
git branch -d issue-#001</code></pre>
<p>到了这里，但愿你对<a>集中式工作流</a>、<a>功能分支工作流</a>和<code>Gitflow</code>工作流已经感觉很舒适了。<br>你应该也牢固的掌握了本地仓库的潜能，<code>push</code>/<code>pull</code>模式和<code>Git</code>健壮的分支和合并模型。</p>
<p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用<code>Git</code>不可违逆的条例。<br>所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让<code>Git</code>为你所用。</p>
<hr>
<h2>SourceTree 实现 git flow</h2>
<p>通过文章《<a href=""https://segmentfault.com/a/1190000013810310#articleHeader2"" rel=""nofollow noreferrer"">SourceTree Win10 安装过程及配置</a>》 正确安装 SourceTree 以及管理示例源码，界面如下。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56QN?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>初始化 Git flow</h3>
<p>点击右上角的 “Git 工作流” ，初次会提示我们 “使用 Git Flow 来初始化此仓库”，已经帮助我们预定义好了一些配置，我们只需要点击 “确定” 按钮即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56Ut?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点击“确定”按钮后，我们会发现 SourceTree 为我们自动创建了 <code>develop</code> 分支，并且切换到了 <code>develop</code> 分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56Uz?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>Git flow: 建立新功能</h3>
<p>继续点击右上角的 “Git 工作流” ，这次会提示我们选择具体的下一个流程动作，这里我们演示一个 “建立新的功能” 流程。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56UL?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点击 “建议新的功能” ，会让我们对即将要开发的功能进行命名（名称请使用英文），这里我们输入 <code>simple-git-flow</code>，点击确定按钮，会自动帮助我们创建 <code>feature/simple-git-flow</code> 分支，并切换到该分支上。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56U1?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>同时我们也能看到 SourceTree 帮助我们执行了什么命令来达到这样的效果。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56U9?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>已经自动切换到 <code>feature/simple-git-flow</code> 分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56Vj?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>提交代码</h3>
<p>此时我们可以在分支上开发我们的新功能，可以在分支上管理代码，而不影响到其他同事的开发工作。</p>
<p>为了简单演示，我们修改下 <code>readme.md</code> 的内容如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56VS?w=1086&amp;h=693"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在 SourceTree 界面，我们需要在 <code>未暂存文件</code> 区域选中 <code>readme.md</code> 并点击 <code>暂存所选</code> 按钮，此时 <code>readme.md</code> 文件会进入到 <code>已暂存文件</code> 区域。只有 <code>已暂存文件</code> 的文件会进行 <code>提交操作</code> 。</p>
<p>在下方的空白区域输入本次提交的说明：<code>a simple git flow</code> 后点击提交按钮，就会提交源码。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56V2?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如下图所示：可以看到刚刚提交的代码记录</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56WO?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>完成新功能开发</h3>
<p>经过不断的代码完善，并且经过单元测试后，代码已经完成后，此时就可以完成 <code>新功能的开发</code> ，继续点击 <code>Git 工作流</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bV56Xv?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点击 “完成功能”，默认会如下图所示，在正常的开发流程下，我们不需要更改任何设置，直接点击确定即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56Xx?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>SourceTree 展示所执行的命令及结果。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56XA?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>完成后，我们会发现 <code>feature/simple-git-flow</code> 分支已经不见了，同时在 <code>develop</code> 分支上多了一个  <code>a simple git flow</code> 的提交信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV56XI?w=1201&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>至此整个 “建议新功能” 的 git flow 流程就完毕了。</p>
<h2>总结</h2>
<p>实际开发过程中，会遇到各种情况，无法通过简短的文章来说明所有的情况，具体需要在实践过程中不断学习。</p>
<p>再次总结下为什么要使用 SourceTree</p>
<ol>
<li>降低入门门槛。很多应届生并不知道版本管理工具和 git，通过可视化工具，可以避免初学者在使用过程中因为不熟悉命令而产生的问题。</li>
<li>使用 SourceTree 的所有操作，都会展示响应的执行命令，也能让初学者了解到具体的操作是通过什么命令来实现的。</li>
<li>在完全不熟悉命令的情况下，也可以通过 SourceTree 来参与团队协作开发。</li>
</ol>
<p>并且在我们的 Centos 服务器部署中，我们使用 docker 来管理版本和发布，也基本用不到复杂的 git 命令，对于初学者的快速入门 SourceTree 足够了。</p>

                ", SourceTree 实现 git flow 流程,1531977710,309,1,942,1,1,https://segmentfault.com/a/1190000013810338
34,1,0,7,"
                    
<p>相信大家或多或少都在工作中用过svn,git之类的版本控制工具。不过，svn和git都是怎样存储数据的？svn和git存储数据有什么差别呢？</p>
<h2>版本管理的进化史</h2>
<p>1.本地化版本管理-rcs</p>
<blockquote>他的原理就是在客户端本地保存并管理文件布丁。因为所有的版本信息都在客户端本地，所以他的缺点也是显而易见的：多人无法协同合作。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bV6YsF?w=346&amp;h=295"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.集中化版本管理-svn</p>
<blockquote>他的原理是有一个集中的管理服务器，在该服务器保存了所有的文件修订版本。所有人都可以聪这个服务器存取文件。当然，它相对于上一个本地化版本管理，已经解决了多人无法协同合作的问题。但是，服务器一旦宕机或者发生故障，则版本信息就会不安全了，这样其实没有太大的保障性。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bV6YtU?w=402&amp;h=279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.分布式版本管理-git</p>
<blockquote>他的核心原理是去中心化。就像下图所示，它不仅会在服务器保存版本信息。客户端不仅提取了最新版本文件快照，还会把代码仓库完整镜像下来。用户可以在无网的情况下，随意在本地进行版本提交。上面提到的集中化版本管理就没有这样的优势。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bV6Ytw?w=300&amp;h=359"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>svn存储及git存储的差别</h2>
<p>如下两图分别是svn及git存储的原理图。<br>a.svn存储存储的是文件的差异化。如图中，版本2和版本1。文件A和文件C有修改，则在版本2的时候存储该两文件变化的部分。不管文件存储了多少次，都是一份原始文件+多份差异文件的累积。<br>b.git存储存储的是文件快照。所谓的文件快照类似与文件本身，不过git会进行压缩等操作。如图中，在版本2和版本1。文件A和文件C有修改，则在版本2的时候会重新存储已经变化的文件，而不是变化部分。实际上，git在版本管理的时候记录的是指针。文件有变化时，会新建指针指向新的文件。而文件B没有变化，则还是原始版本的指针指向原来的文件。这里的原理会在稍后部分进行详细解析。<br>当然，git这样存储文件，而不是diff。当我们需要查看某个版本时，只要加载对应的文件即可，不需要再merge。是一种以空间换时间的策略。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Yzc?w=606&amp;h=234"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bV6Yzy?w=618&amp;h=236"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Git提交对象</h2>
<p>git的每一次提交都会有3个blob文件，一个树对象，一个提交对象，如下图所示。<br>树对象（绿色部分）存储目录结构及blob文件的索引。可以看到树对象里面有3个blob标示，分别对应5b1d3/911e7/cba0a三个blob文件。而提交对象指向树对象的指针及所有的提交信息。下图的提交对象98ca9里有一个tree的标示指向了92ec2，当然它还包含了作者等等提交信息。<br><span class=""img-wrap""><img data-src=""/img/bV6YHr?w=464&amp;h=257"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>而很多次的提交则会有很多次上述的提交对象，他们之间是怎样连接的呢。其实在提交对象里面还有一个parent的标示。如下图所示，34ac2的parent是98ca9。但是因为98ca9是首次提交则parent属性是空。<br><span class=""img-wrap""><img data-src=""/img/bV6YJk?w=661&amp;h=219"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Git分支管理</h2>
<p>如下图所示。其实，git每次的提交不仅仅会有上面说的提交对象的概念，在提交对象之上，还会有分支的概念。git默认会有一个master分支。如下图所示，我们也可以新建一个v1.0的分支。但是，现在有两个分支，我们怎么知道我们在哪个分支工作呢。其实有一个HEAD的指针，该指针指向哪个分支，目前的工作分支就是哪个。如果我们需要切换分支，用git checkout xxx即可。<br><span class=""img-wrap""><img data-src=""/img/bV6YWg?w=707&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>关于git的工作区域，文件类型，具体的指令，开发流程等等，将在另外一片文章详细介绍～</p>

                ", 版本管理进化,1531977711,520,1,716,1,1,https://segmentfault.com/a/1190000014018553
35,1,0,7,"
                    
<h1>Git服务器搭建与使用</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013999837?w=220&amp;h=92"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git服务器搭建与使用1"" title=""Git服务器搭建与使用1""></span></p>
<h2>前言</h2>
<blockquote>
<strong>Git</strong>是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。官网请戳<a href=""https://www.git-scm.com"" rel=""nofollow noreferrer"">https://www.git-scm.com</a>。<br>常用的有几家Git服务提供商</blockquote>
<ul>
<li>
<a href=""https://www.github.com"" rel=""nofollow noreferrer"">GitHub</a>，全球最大的代(tong)码(xing)托(jiao)管(you)平台，社区文化好，大牛多，公有库免费，私有库收费</li>
<li>
<a href=""https://www.gitee.com/"" rel=""nofollow noreferrer"">Gitee</a>，OSChina家的产品，现在国内挺多人用的，公有库、私有库都免费</li>
<li>
<a href=""https://www.coding.net/"" rel=""nofollow noreferrer"">Coding</a>，公有库、私有库都免费，提供企业版（收费）服务，除了提供代码托管服务，还能发布任务，有点像是Gitee和Tower的结合体</li>
</ul>
<h2>环境准备</h2>
<ul>
<li>服务器，使用<a href=""https://www.aliyun.com/"" rel=""nofollow noreferrer"">阿里云</a>，操作系统，<code>CentOS 7</code>
</li>
<li>客户端，安装Git Client，参考官网的<a href=""https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git"" rel=""nofollow noreferrer"">安装指引</a>
</li>
</ul>
<h2>1 安装Git</h2>
<pre><code>yum install git</code></pre>
<h2>2 配置用户</h2>
<p>创建一个用户git，该用户只是用来进行git相关操作</p>
<pre><code>groupadd git
useradd git -d /home/git -g git</code></pre>
<h2>3 Git-协议</h2>
<blockquote>Git 可以使用四种协议来传输数据：本地协议（Local）、HTTP协议、SSH（Secure Shell）协议、Git 协议。各种协议的优劣详见<a href=""https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE"" rel=""nofollow noreferrer"">这里</a>
</blockquote>
<h3>3.1 SSH协议</h3>
<p>查看公钥鉴权文件是否存在</p>
<pre><code>cat /home/git/.ssh/authorized_keys</code></pre>
<p>如果不存在的话，新建一个</p>
<pre><code>cd /home/git/
mkdir .ssh
chmod 755 .ssh
touch .ssh/authorized_keys
chmod 644 .ssh/authorized_keys</code></pre>
<h3><a id=""3.2"">3.2 生成并配置密钥对</a></h3>
<p>生成一个密钥对</p>
<pre><code>ssh-keygen -t rsa -C ""fallshum""</code></pre>
<p>这里会提示我们，是否修改路径，是否输入密码，使用默认，一路Enter往下走就行</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
1d:f1:b6:c9:42:2b:ab:1d:43:5a:72:fc:31:aa:38:9d fallshum
The key's randomart image is:
+--[ RSA 2048]----+
|          .      |
|           o     |
|          o o    |
|       . o = o   |
|      . S * +    |
|       * = +     |
|     ...= .      |
|    ..E+ o       |
|    ..o .        |
+-----------------+
</code></pre>
<p>把生成的公钥写入<code>/home/git/.ssh/authorized_keys</code>，并查看</p>
<pre><code>cat /root/.ssh/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys
cat /home/git/.ssh/authorized_keys</code></pre>
<p>把私钥放到客户端的.ssh目录下，先获取刚才生成的私钥</p>
<pre><code>cat /root/.ssh/id_rsa</code></pre>
<p>可以看到类似这样的一个私钥，复制出来</p>
<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAxtF2MFhb0xbOn2ngtHvWJTM1bW4V/IIBTKzCzTUg9S6tfTqZ
bzVS0qouNWJEOF+phW42Ban5bE9YrpqD3wG36w1fKntGVGXeGkdjiByxzW4wtZpv
gzn9d0o03JlpY3nciwqePfvkykaXDP8Kzg+JolMpxzuc3t4JEMa4nphC1sGrfWeS
IVIY6JxDqhemEkKIfncH44OLg9VslJgx0bL5hKQlkaiAkkI+qfX1XDzISmz6xnif
pzxz9Zwu9/j9GBgBxuD3T5AhnVj5gqjEt7Y4n/V6b/b78KAY9CJDy/nP+oXc4xmF
tdenMH6ZThOdmzwfaQGC4NSJXRK+9Rk8/8JSnQIDAQABAoIBADPERinAV+hWf+Yy
Azf7Jn75HmgnycG9d+km8nHL65DrXnDE2T6De9UuSmnL9EdZYSJE1/wRjcgNwOF1
ifB+2gxxpt3Ay0ceXv4oqFnAXutGTZh7ZZ2dc8mjoK/voeksyafKU/l/pMqmJp5T
qdSNZyDE1pPxiZ7d4S5lD5z7uCuCPELG8ZwGVjFY2xtcaIqfy0kPr5SDmkLDrktI
6Mxo2YFlae8tqvgud9LKZt9R5ubxyftgHf80bVJXVOvKNhN5UYNWssJ6FBt23jjb
pAK6oASATYyITC4a5leqR7vWW3m/wvYiHslouS0vmaxhdOdb4JUafLevmHtYlBZ3
8aGhM2ECgYEA6JQKDijObACWU6DCDKdadq2l0l3RSHOvncStIex/kM9vOgXHZ88d
DNEJB7l639t+Kv956uDr6WY7se7b5H+UVR4Wf8iTe9uexsJLiA/+LMBWEiY/qmE1
3lk4vHwYPWynmEyu/+ZtlNgQzHn0npvktgPCV1Hr/PcXzuxkvnbS+MMCgYEA2tcT
Cb9EJvhcKg/xUzidFtf5SSRu8yezxi+0gydOccuqm8j5jF9jXUZ4IASPpZH3zJRQ
x0SJuOfhhQevuyLI+HD6n3nVEAKc42xSuOYmLrErrbTOHIkwErhtcC05b79EdAbM
JObyA51O2jYCaY/VEny5cSLyYzATbhFn67p10R8CgYAtOdxatISva83PpUsWutRU
j5/XMHcp55UW0M/58Ms9lZjDZ6xG+3dirqNa5S6HqV73bYZ/rg0x7bdd+ly4Kjbl
9lvZrV9Ajoxpig61/qYmfaA/F0D6GL0o56CoxljQWPieHQtKp7xXXUym9nAjB52J
52E7KasCHep7SmysvN55kQKBgELCpAswL0FYOP2X+X3y4nFql6EJnVNOhFhsizwL
jLHIeRanXAHHw89bxR+3ZH8VJaxifrYboYwoKTNlIeYL+ZVZGgv2pdoJggUbMa04
gONzpyiJ5Ortqx2655/2G/SMO/zNag/D6IbTwY9uNJQxjcXjCMuL5rf9nZ/RbYuL
SY/vAoGAGkb/uKGnAhQc+ihcZaZAdZytOTFfEs5692J1rBAhisx1gDCEdkgOp1kH
2mHBwOexAvegb7MUzoRTw5cNYfYCmhkgQg+qOdLDSLvaFGSMNtkdftMif9E88oJ4
9mIblJfi2+GzpBee/I3RP+gxbLa+a83iw7TwQGLjssnjJ2QOsu4=
-----END RSA PRIVATE KEY-----</code></pre>
<p>如果是在windows下，进入<code>C:\Users\myname\.ssh</code>,路径里面的<code>myname</code>是windows登录用户名，然后创建一个文本文档，把私钥复制进去，再把文件名改为<code>id_rsa</code>，不要<code>.txt</code>的后缀</p>
<h2>4 初始化Git仓库</h2>
<p>初始化一个仓库，将仓库的owner改为刚才创建的用户git，这样用户git就能操作这个仓库了</p>
<pre><code>cd /home/git/
git init --bare fallshum.git
chown -R git:git fallshum.git/</code></pre>
<h2>5 客户端克隆仓库</h2>
<p>客户端打开Git Bash，clone服务端仓库</p>
<pre><code>git clone git@192.168.1.1:/home/git/fallshum.git</code></pre>
<p>只要看到<code>Checking connectivity... done</code>就说明OK了</p>
<h2>6 禁用shell登录</h2>
<p>如果有需要禁用shell登录的话，执行</p>
<pre><code>usermod -s /sbin/nologin git</code></pre>
<p>禁用之后，可能出现错误提示<code>fatal: protocol error: bad line length character: This</code><br>原因及解决办法参考<a href=""https://stackoverflow.com/questions/22314298/git-push-results-in-fatal-protocol-error-bad-line-length-character-this"" rel=""nofollow noreferrer"">这里</a><br>重新开启，执行</p>
<pre><code>usermod -s /bin/bash git</code></pre>
<h2>7 多key管理</h2>
<p>ssh在客户端连接服务端的时候，默认使用<code>~/.ssh/id_rsa</code>私钥文件。当我们需要连接多个服务端的时候，需要进行多key配置。首先，通过上面<a href=""#3.2"" rel=""nofollow noreferrer"">步骤3.2</a>操作，生成了两个密钥对，分别将两个公钥放到对应<code>服务器</code>的<code>~/.ssh/authorized_keys</code>里面。将私钥文件放到<code>客户端</code>的<code>~/.ssh/</code>目录下，给两个不同的命名，比如<code>aliyun_rsa、tengxunyun_rsa</code>，<br>在<code>.ssh</code>目录下新建<code>config</code>文件，配置如下</p>
<pre><code># 配置文件参数
# Host 一个自定义名称，比如叫做aliyun，那么clone仓库的时候，就要用git clone git@aliyun:/home/git/fallshum.git
# HostName 实际要连接的主机地址
# PreferredAuthentications 配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等
# IdentityFile 指明要使用的identityFile路径，也就是私钥的地址
# User 用户名

# aliyun
Host aliyun
HostName 192.168.1.1
PreferredAuthentications publickey
IdentityFile ~/.ssh/aliyun_rsa
User fallshum

# tengxunyun
Host tengxunyun
HostName 192.168.1.1
PreferredAuthentications publickey
IdentityFile ~/.ssh/tengxunyun_rsa
User fallshum</code></pre>
<p>配置完成之后，可以在<code>客户端</code>用如下指令检验ssh是否配置成功</p>
<pre><code>ssh git@aliyun</code></pre>
<p>登录成功<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013999838"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git服务器搭建与使用2"" title=""Git服务器搭建与使用2""></span><br><code>exit</code>退出<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013999839"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git服务器搭建与使用3"" title=""Git服务器搭建与使用3""></span></p>
<p>成功连接上，我们再分别尝试一下clone</p>
<pre><code>git clone git@aliyun:/home/git/aliyun.git
git clone git@tengxunyun:/home/git/tengxunyun.git</code></pre>
<p>都成功了<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013999840"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git服务器搭建与使用4"" title=""Git服务器搭建与使用4""></span></p>

                ", Git私服搭建与使用,1531977712,533,1,317,1,1,https://segmentfault.com/a/1190000013999832
36,1,0,7,"
                    
<h3>0. 前言</h3>
<p>最近有个项目比较赶，于是决定8个人一起并行完成，单独把项目拿出来用gitea管理，每人分一个模块开发，对应每人开一个个人分支,一个<code>develop</code>分支和一个<code>master</code>分支，效果不错，从中也帮助自己重新温习了一下git的使用，小记一下git相关知识点。</p>
<h3>1. 安装和使用</h3>
<ul>
<li>
<p>在MAC上，安装homebrew，然后通过<a href=""https://brew.sh/index_zh-cn"" rel=""nofollow noreferrer"">homebrew</a> 安装Git。</p>
<blockquote>在MAC上另一种安装方法，从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</blockquote>
</li>
<li>在Windows上，下载<a href=""http://rj.baidu.com/soft/detail/40642.html"" rel=""nofollow noreferrer"">安装包</a>，默认下一步，安装完成即可。</li>
<li>
<p>安装完后自报家门</p>
<pre><code>$ git config --global user.name ""wuwhs""
$ git config --global user.email ""email@example.com""</code></pre>
</li>
<li>
<p>创建版本库<br>初始化一个Git仓库，使用<code>git init</code>命令。添加文件到Git仓库，分两步：</p>
<ol>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>第二步，使用命令<code>git commit</code>，完成。</li>
</ol>
</li>
</ul>
<h3>2. 时光穿梭</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013997325?w=458&amp;h=234"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本，<code>git log --pretty=oneline --abbrev-commit</code>在一行显示缩写提交号。</li>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li>
<li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li>
</ul>
<h3>3. 远程仓库</h3>
<ul>
<li>创建SSH Key。<code>$ ssh-keygen -t rsa -C ""youremail@example.com""</code>。</li>
<li>登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</li>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>。</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容。</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</li>
<li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li>
</ul>
<h3>4. 分支管理</h3>
<ul>
<li>Git鼓励大量使用分支。</li>
<li>查看分支：<code>git branch</code>。</li>
<li>创建分支：<code>git branch &lt;name&gt;</code>。</li>
<li>切换分支：<code>git checkout &lt;name&gt;</code>。</li>
<li>创建+切换到当前分支：<code>git checkout -b &lt;name&gt;</code>。</li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code>。</li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code>。</li>
<li>当Git无法自动合并分支时，就必须首先剞劂冲突，解决冲突后，再提交，合并完成用<code>git log --graph</code>命令可以看到分支合并图。</li>
<li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fash-forward</code>合并就看不出来曾经做过合并。</li>
<li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash list</code>查看历史stash，一是用<code>git stash apply</code>恢复，但恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</li>
<li>查看远程库信息，使用<code>git remote -v</code>。</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果失败，先用<code>git pull</code>抓取远程的新提交。</li>
<li>再本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致。</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h3>5. 标签</h3>
<ul>
<li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>,也可以指定一个commit id。</li>
<li>
<code>git tag -a &lt;tagname&gt; -m ""balabala...""</code>可以指定标签信息。</li>
<li>
<code>git tag -s &lt;tagname&gt; -m ""balabala...""</code>可以用PGP签名标签。</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签。</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签。</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签。</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h3>6. 举个应用栗子</h3>
<ol>
<li>
<p>最初在远程创建项目仓库有<code>master</code>和<code>develp</code>分支，参与开发人员先在自己一个文件夹下，调出<code>git Bash</code>，然后输入命令<code>git clone URL</code>把仓库<code>clone</code>下来</p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www (master)
$ git clone git@github.com:wuwhs/demo.git
Cloning into 'demo'...
Warning: Permanently added the RSA host key for IP address '13.229.188.59' to the list of known hosts.
warning: You appear to have cloned an empty repository.
Checking connectivity... done.
</code></pre>
</li>
<li>
<p><code>cd demo</code>进入<code>clone</code>下载的目录里，用<code>git branch develop</code>在本地创建一个对应的<code>develop</code>分支</p>
<pre><code>$ cd demo

MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)
$ git branch
*master
MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)
$ git branch develop

MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)
$ git branch
develop   
*master</code></pre>
<p>再次用<code>git branch</code>查看已经新建了一个<code>develop</code>分支</p>
</li>
<li>
<p><code>git checkout develop</code>切换到当前<code>develop</code>分支</p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)
$ git checkout develop
Switched to branch 'develop'</code></pre>
</li>
<li>
<p>用<code>git pull origin develop:develop</code>，即：<code>git pull origin &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>，当本地和远程分支名相同时，可以简写成一个，也就是<code>git pull origin develop</code>，拉取远程<code>develop</code>分支完成，然后开发人员就可以在这个分支上工作了</p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git pull origin develop:develop
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wuwhs/demo
   7ff2cb0..7ab2842  develop    -&gt; develop
   7ff2cb0..7ab2842  develop    -&gt; origin/develop
warning: fetch updated the current branch head.
fast-forwarding your working tree from
commit 7ff2cb0627be357fa15db4e38e1bfe8fc820b8ec.
Already up-to-date.</code></pre>
</li>
<li>
<p>当一天了工作完成，要提交到远程分支，首先要拉取一下别人提交的代码，防止版本冲突</p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wuwhs/demo
   f848dc7..d696375  develop    -&gt; origin/develop
Updating f848dc7..d696375
Fast-forward
 demo.txt | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
<p>PS：直接偷懒<code>pull</code>可能会出现没有找到<code>tracking</code>的分支</p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

git branch --set-upstream-to=origin/&lt;branch&gt; develop</code></pre>
<p>这时候要手动添加一下对应分支依赖<code>git branch --set-upstream-to=origin/&lt;branch&gt; develop</code></p>
<pre><code> MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git branch --set-upstream-to=origin/develop develop
Branch develop set up to track remote branch develop from origin.

MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wuwhs/demo
   f848dc7..d696375  develop    -&gt; origin/develop
Updating f848dc7..d696375
Fast-forward
 demo.txt | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</li>
<li>
<p>将本地分支提交到对应远程分支上，<code>git push origin develop:develop</code>，即：<code>git push origin &lt;远程主机&gt;&lt;本地分支名&gt;:&lt;远程分支名&gt;</code>，如果名称一样可以简写，也就是<code>git push origin develop</code></p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git push origin develop:develop
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (9/9), 759 bytes | 0 bytes/s, done.
Total 9 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), done.
To git@github.com:wuwhs/demo.git
   d696375..3c00c0c  develop -&gt; develop
</code></pre>
</li>
<li>
<p>项目测试OK了，本地分支合并到<code>master</code>分支上，要用到<code>git merge &lt;branch&gt;</code></p>
<pre><code>MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)
$ git checkout master
Switched to branch 'master'

MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)
$ git merge develop
Updating c4d0377..3c00c0c
Fast-forward
 demo.txt | 9 +++++++++
 1 file changed, 9 insertions(+)</code></pre>
</li>
</ol>
<p>常用的操作就以上七步了，当然会有不同情形的应用。</p>
<h3>7. 附录：git-cheat-sheet</h3>
<p>一般而言，常用的就是以上那些命令，有人专门的整理了一份比较全一点的文档git-cheat-sheet，方便查阅。</p>
<h4>配置</h4>
<p>列出当前配置：</p>
<pre><code>$ git config --list</code></pre>
<p>列出repository配置：</p>
<pre><code>$ git config --local --list</code></pre>
<p>列出全局配置：</p>
<pre><code>$ git config --global --list</code></pre>
<p>列出系统配置：</p>
<pre><code>$ git config --system --list</code></pre>
<p>设置用户名：</p>
<pre><code>$ git config --global user.name ""[firstname lastname]""</code></pre>
<p>设置用户邮箱：</p>
<pre><code>$ git config --global user.email ""[valid-email]""</code></pre>
<p>设置git命令输出为彩色：</p>
<pre><code>$ git config --global color.ui auto</code></pre>
<p>设置git使用的文本编辑器设：</p>
<pre><code>$ git config --global core.editor vi</code></pre>
<h4>配置文件</h4>
<p>Repository配置对应的配置文件路径[--local]：</p>
<pre><code>&lt;repo&gt;/.git/config</code></pre>
<p>用户全局配置对应的配置文件路径[--global]：</p>
<pre><code>~/.gitconfig</code></pre>
<p>系统配置对应的配置文件路径[--local]：</p>
<pre><code>/etc/gitconfig</code></pre>
<h4>创建</h4>
<p>复制一个已创建的仓库:</p>
<pre><code># 通过 SSH
$ git clone ssh://user@domain.com/repo.git</code></pre>
<pre><code>#通过 HTTP
$ git clone http://domain.com/user/repo.git</code></pre>
<p>创建一个新的本地仓库:</p>
<pre><code>$ git init</code></pre>
<h4>本地修改</h4>
<p>显示工作路径下已修改的文件：</p>
<pre><code>$ git status</code></pre>
<p>显示与上次提交版本文件的不同：</p>
<pre><code>$ git diff</code></pre>
<p>把当前所有修改添加到下次提交中：</p>
<pre><code>$ git add .</code></pre>
<p>把对某个文件的修改添加到下次提交中：</p>
<pre><code>$ git add -p &lt;file&gt;</code></pre>
<p>提交本地的所有修改：</p>
<pre><code>$ git commit -a</code></pre>
<p>提交之前已标记的变化：</p>
<pre><code>$ git commit</code></pre>
<p>附加消息提交：</p>
<pre><code>$ git commit -m 'message here'</code></pre>
<p>提交，并将提交时间设置为之前的某个日期:</p>
<pre><code>git commit --date=""`date --date='n day ago'`"" -am ""Commit Message""</code></pre>
<p>修改上次提交<br>（请勿修改已发布的提交记录!）</p>
<pre><code>$ git commit --amend</code></pre>
<p>修改上次提交的committer date：</p>
<pre><code>GIT_COMMITTER_DATE=""date"" git commit --amend</code></pre>
<p>修改上次提交的author date：</p>
<pre><code>git commit --amend --date=""date""</code></pre>
<p>把当前分支中未提交的修改移动到其他分支：</p>
<pre><code>git stash
git checkout branch2
git stash pop</code></pre>
<p>将 stashed changes 应用到当前分支：</p>
<pre><code>git stash apply</code></pre>
<p>删除最新一次的 stashed changes：</p>
<pre><code>git stash drop</code></pre>
<h4>搜索</h4>
<p>从当前目录的所有文件中查找文本内容：</p>
<pre><code>$ git grep ""Hello""</code></pre>
<p>在某一版本中搜索文本：</p>
<pre><code>$ git grep ""Hello"" v2.5</code></pre>
<h4>提交历史</h4>
<p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</p>
<pre><code>$ git log</code></pre>
<p>显示所有提交（仅显示提交的hash和message）：</p>
<pre><code>$ git log --oneline</code></pre>
<p>显示某个用户的所有提交：</p>
<pre><code>$ git log --author=""username""</code></pre>
<p>显示某个文件的所有修改：</p>
<pre><code>$ git log -p &lt;file&gt;</code></pre>
<p>仅显示远端分支与远端分支提交记录的差集：</p>
<pre><code>$ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right</code></pre>
<p>谁，在什么时间，修改了文件的什么内容：</p>
<pre><code>$ git blame &lt;file&gt;</code></pre>
<p>显示reflog：</p>
<pre><code>$ git reflog show</code></pre>
<p>删除reflog：</p>
<pre><code>$ git reflog delete</code></pre>
<h4>分支与标签</h4>
<p>列出所有的分支：</p>
<pre><code>$ git branch</code></pre>
<p>列出所有的远端分支：</p>
<pre><code>$ git branch -r</code></pre>
<p>切换分支：</p>
<pre><code>$ git checkout &lt;branch&gt;</code></pre>
<p>创建并切换到新分支:</p>
<pre><code>$ git checkout -b &lt;branch&gt;</code></pre>
<p>基于当前分支创建新分支：</p>
<pre><code>$ git branch &lt;new-branch&gt;</code></pre>
<p>基于远程分支创建新的可追溯的分支：</p>
<pre><code>$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</code></pre>
<p>删除本地分支:</p>
<pre><code>$ git branch -d &lt;branch&gt;</code></pre>
<p>强制删除一个本地分支：<br>将会丢失未合并的修改！</p>
<pre><code>$ git branch -D &lt;branch&gt;</code></pre>
<p>给当前版本打标签：</p>
<pre><code>$ git tag &lt;tag-name&gt;</code></pre>
<p>给当前版本打标签并附加消息：</p>
<pre><code>$ git tag -a &lt;tag-name&gt;</code></pre>
<h4>更新与发布</h4>
<p>列出当前配置的远程端：</p>
<pre><code>$ git remote -v</code></pre>
<p>显示远程端的信息：</p>
<pre><code>$ git remote show &lt;remote&gt;</code></pre>
<p>添加新的远程端：</p>
<pre><code>$ git remote add &lt;remote&gt; &lt;url&gt;</code></pre>
<p>下载远程端版本，但不合并到HEAD中：</p>
<pre><code>$ git fetch &lt;remote&gt;</code></pre>
<p>下载远程端版本，并自动与HEAD版本合并：</p>
<pre><code>$ git remote pull &lt;remote&gt; &lt;url&gt;</code></pre>
<p>将远程端版本合并到本地版本中：</p>
<pre><code>$ git pull origin master</code></pre>
<p>以rebase方式将远端分支与本地合并：</p>
<pre><code>git pull --rebase &lt;remote&gt; &lt;branch&gt;</code></pre>
<p>将本地版本发布到远程端：</p>
<pre><code>$ git push remote &lt;remote&gt; &lt;branch&gt;</code></pre>
<p>删除远程端分支：</p>
<pre><code>$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)
# or
git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</code></pre>
<p>发布标签:</p>
<pre><code>$ git push --tags</code></pre>
<p>合并与重置(Rebase)<br>将分支合并到当前HEAD中：</p>
<pre><code>$ git merge &lt;branch&gt;</code></pre>
<p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!</p>
<pre><code>$ git rebase &lt;branch&gt;</code></pre>
<p>退出重置:</p>
<pre><code>$ git rebase --abort</code></pre>
<p>解决冲突后继续重置：</p>
<pre><code>$ git rebase --continue</code></pre>
<p>使用配置好的merge tool 解决冲突：</p>
<pre><code>$ git mergetool</code></pre>
<p>在编辑器中手动解决冲突后，标记文件为已解决冲突：</p>
<pre><code>$ git add &lt;resolved-file&gt;
$ git rm &lt;resolved-file&gt;</code></pre>
<p>合并提交：</p>
<pre><code>$ git rebase -i &lt;commit-just-before-first&gt;</code></pre>
<p>把上面的内容替换为下面的内容：</p>
<p>原内容：</p>
<pre><code>pick &lt;commit_id&gt;
pick &lt;commit_id2&gt;
pick &lt;commit_id3&gt;</code></pre>
<p>替换为：</p>
<pre><code>pick &lt;commit_id&gt;
squash &lt;commit_id2&gt;
squash &lt;commit_id3&gt;</code></pre>
<h4>撤销</h4>
<p>放弃工作目录下的所有修改：</p>
<pre><code>$ git reset --hard HEAD</code></pre>
<p>移除缓存区的所有文件（i.e. 撤销上次git add）:</p>
<pre><code>$ git reset HEAD</code></pre>
<p>放弃某个文件的所有本地修改：</p>
<pre><code>$ git checkout HEAD &lt;file&gt;</code></pre>
<p>重置一个提交（通过创建一个截然不同的新提交）</p>
<pre><code>$ git revert &lt;commit&gt;</code></pre>
<p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</p>
<pre><code>$ git reset --hard &lt;commit&gt;</code></pre>
<p>用远端分支强制覆盖本地分支：</p>
<pre><code>git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</code></pre>
<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</p>
<pre><code>$ git reset &lt;commit&gt;</code></pre>
<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</p>
<pre><code>$ git reset --keep &lt;commit&gt;</code></pre>
<p>删除添加.gitignore文件前错误提交的文件：</p>
<pre><code>$ git rm -r --cached .
$ git add .
$ git commit -m ""remove xyz file""</code></pre>
<p>完~</p>
<p>可参考文章：</p>
<ol>
<li><a href=""http://rogerdudler.github.io/git-guide/"" rel=""nofollow noreferrer"">git-guide</a></li>
<li><a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰git教程</a></li>
<li><a href=""https://www.git-scm.com/"" rel=""nofollow noreferrer"">git-scm</a></li>
<li><a href=""https://blog.csdn.net/github_37515447/article/details/56840610"" rel=""nofollow noreferrer"">Git Cheat Sheet 中文版</a></li>
</ol>

                ", Git简记,1531977714,187,1,454,1,1,https://segmentfault.com/a/1190000013997320
37,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014011338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>分享一些超好用插件，打造一个不一样的 GitHub、浏览器、编辑器。</p>
<h2>一、谷歌浏览器插件</h2>
<ul>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/gocklaboggjfkolaknpbhddbaopcepfp?utm_source=chrome-app-launcher-info-dialog"" rel=""nofollow noreferrer"">谷歌访问助手【强烈推荐】</a></strong> - 一键安装，无需其他配置，即可访问谷歌。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco"" rel=""nofollow noreferrer"">扩展管理器（Extension Manager）【强烈推荐】</a></strong> - 一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo"" rel=""nofollow noreferrer"">Tampermonkey【强烈推荐】</a></strong> - 插件中的超级插件，不解释，最受欢迎的用户脚本管理器，拥有超过1000万用户。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/clickclean/ghgabhipcejejjmhhchfonmamedcbeod"" rel=""nofollow noreferrer"">Click&amp;Clean【强烈推荐】</a></strong> - 很方便的浏览器的缓存、下载文件、内存、cookie、插件等各种管理。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/checker-plus-for-gmail/oeopbcgkkoapgobdbedcemjljbihmemj"" rel=""nofollow noreferrer"">Checker Plus for Gmail™【强烈推荐】</a></strong> - 方便地接受邮件通知、查看、收听或删除邮件，并且支持多账户，语音播放。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall"" rel=""nofollow noreferrer"">OneTab【强烈推荐】</a></strong> - 当您发现自己有太多的标签页时，单击OneTab图标，将所有标签页转换成一个列表。当您需要再次访问这些标签页时，可以单独或全部恢复它们。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm"" rel=""nofollow noreferrer"">ElasticSearch Head【强烈推荐】</a></strong> - 界面化管理大名鼎鼎全文搜索引擎 <a href=""https://www.elastic.co/products/elasticsearch"" rel=""nofollow noreferrer"">ElasticSearch</a>的数据。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/imtranslator-translator-d/noaijdpnepcgjemiklgfkcfbkokogabh"" rel=""nofollow noreferrer"">ImTranslator: 翻译，字典，声音</a></strong> - 由于<a href=""https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad?utm_source=chrome-ntp-icon"" rel=""nofollow noreferrer"">划词翻译</a>的谷歌翻译接口不能用了。找了这个做替代。发现比划词翻译还好用。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh"" rel=""nofollow noreferrer"">Infinity新标签页(Pro)【强烈推荐】</a></strong> - 可能是Chrome浏览器上最好用的新标签页。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad"" rel=""nofollow noreferrer"">WEB前端助手(FeHelper)【强烈推荐】</a></strong> - FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成与解码、编码规范检测、页面性能检测、页面取色、Ajax接口调试。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd"" rel=""nofollow noreferrer"">LastPass: Free Password Manager【强烈推荐】</a></strong> - LastPass 密码管理器,保存你的密码,让你安全访问任何计算机和移动设备。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/qpush-push-text-and-links/eccidpbmllnjfhhnjhaaopeeldnlokbi"" rel=""nofollow noreferrer"">QPush - 从电脑快推文字到手机</a></strong> - QPush 是从电脑推送文字到 iPhone 上最方便的小工具，可以轻松推送文字或网页。只要三秒钟，推送超顺手!</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/send-anywherefile-transfe/amjmjholfoknokffkiolahocokcaecnc"" rel=""nofollow noreferrer"">Send Anywhere</a></strong> - 发送和分享大文件。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll"" rel=""nofollow noreferrer"">简悦 - SimpRead【强烈推荐】</a></strong> - 让你瞬间进入沉浸式阅读的 Chrome 扩展，类似 Safari 的阅读模式。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll"" rel=""nofollow noreferrer"">壹伴 · 小插件</a></strong> - 简单好用的公众号效率工具。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/tidy-bookmarks/bennikkpnelmfdiijpdclfincmnoabae"" rel=""nofollow noreferrer"">Tidy Bookmarks</a></strong> - 对比了很多书签管理插件，最终选择了这个。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb"" rel=""nofollow noreferrer"">Adblock Plus【强烈推荐】</a></strong> - 最受欢迎的广告拦截软件。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/download-in-idm-internet/lmpemnebipihbcadlafaidjibohhfocn"" rel=""nofollow noreferrer"">Download in IDM</a></strong> - 大名鼎鼎的<a href=""http://www.internetdownloadmanager.com/"" rel=""nofollow noreferrer""><em>idm</em>(internet download manager)</a>的下载插件，需要安装idm。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg"" rel=""nofollow noreferrer"">Wappalyzer【强烈推荐】</a></strong> - 探测当前网页所使用的类库、框架和服务器环境。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/library-sniffer-for-googl/fhhdlnnepfjhlhilgmeepgkhjmhhhjkh"" rel=""nofollow noreferrer"">Library Sniffer for Google Chrome</a></strong> - 另一个探测当前网页所使用的类库、框架和服务器环境，个人喜欢 Wappalyzer。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/builtwith-technology-prof/dapjbgnjinbpoindlpdmhochffioedbn"" rel=""nofollow noreferrer"">BuiltWith Technology Profiler【强烈推荐】</a></strong> -  探测当前网页所有信息，相比 Wappalyzer 和 Library Sniffer for Google Chrome 探测的信息更为多。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk"" rel=""nofollow noreferrer"">Lighthouse</a></strong> - Lighthouse是一款开源的自动化工具，用于改善Web应用程序的性能，质量和正确性，优化网站性能。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/image-downloader/cnpniohnfphhjihaiiggeabnkjhpaldj"" rel=""nofollow noreferrer"">Image Downloader</a></strong> - 浏览并下载网页上的图像。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb"" rel=""nofollow noreferrer"">Vimium【强烈推荐】</a></strong> - 像 vim 一样操作浏览器。装逼神器。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/context-menu-search/ocpcmghnefmdhljkoiapafejjohldoga"" rel=""nofollow noreferrer"">Context Menu Search</a></strong> - 使用右键菜单在不同的搜索引擎中搜索选定的文本。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb"" rel=""nofollow noreferrer"">Google 翻译</a></strong> - 浏览网页时可轻松查看翻译版本。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US"" rel=""nofollow noreferrer"">Octotree【强烈推荐】</a></strong> - 树形结构化显示 GitHub 上的项目代码，更方便查看代码。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/gitcodetree/inaaldjpdbkaodlmdcplgpoibohcmmlj"" rel=""nofollow noreferrer"">GitCodeTree</a></strong> - 树形结构化显示码云上的项目代码，更方便查看代码。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg"" rel=""nofollow noreferrer"">The Great Suspender</a></strong> - 谷歌浏览器是很耗内存的，该插件会自动挂起长时间未使用的网页，来释放系统资源。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo"" rel=""nofollow noreferrer"">Postman Interceptor【强烈推荐】</a></strong> - 大名鼎鼎的 Postman。用来测试接口。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/boomerang-soap-rest-clien/eipdnjedkpcnlmmdfdkgfpljanehloah"" rel=""nofollow noreferrer"">Boomerang - SOAP &amp; REST Client</a></strong> - 另一个接口测试插件，无缝集成并测试SOAP和REST服务。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/apizza/kpkajnbnadgmiekpbpjekjmoomkdhiio"" rel=""nofollow noreferrer"">apizza</a></strong> - 体验类似 postman。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/similarweb-traffic-rank-w/hoklmmgfnpapgjgcpechhaamimifchmp"" rel=""nofollow noreferrer"">SimilarWeb - 网站流量来源和排名【强烈推荐】</a></strong> - 查看网站参与、流量来源和网站排名信息。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/insightio-for-github/pmhfgjjhhomfplgmbalncpcohgeijonh"" rel=""nofollow noreferrer"">Insight.io for Github</a></strong> - 像IDE一样智能的查看 GitHub 上项目代码。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/sourcegraph-for-github/dgjhfomjieaadpoljlnidmbgkdffpack"" rel=""nofollow noreferrer"">Sourcegraph for GitHub【强烈推荐】</a></strong> - 提供GitHub IDE的强大功能：跳转到代码，PR和差异的定义和悬停工具提示。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/porter-plug/lngoojfoglemfpbeiomhgheccpdheilp"" rel=""nofollow noreferrer"">Porter Plug</a></strong> - 使用Porter.io的嵌入式回购新闻和图表提升Github体验。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/axure-rp-extension-for-ch/dogkpdfcklifaemcdfbildhcofnopogp"" rel=""nofollow noreferrer"">Axure RP Extension for Chrome</a></strong> - 可以从Google Chrome浏览器本地查看 Axure RP 原型。</li>
<li>
<strong><a href=""https://github.com/listen1/listen1_chrome_extension/releases"" rel=""nofollow noreferrer"">Listen 1【强烈推荐】</a></strong> - 集成QQ、网易、虾米三大音乐平台平台听歌插件，程序员专属音乐播放器，良心作品。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/website-ip/ghbmhlgniedlklkpimlibbaoomlpacmk"" rel=""nofollow noreferrer"">Website IP</a></strong> - 将当前网站的IP显示在右下角，便于本地开发网站调试。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk"" rel=""nofollow noreferrer"">GitHub Hovercard【强烈推荐】</a></strong> - 使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。同性交友利器！</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/awesome-autocomplete-for/djkfdjpoelphhdclfjhnffmnlnoknfnd"" rel=""nofollow noreferrer"">Awesome Autocomplete for GitHub【强烈推荐】</a></strong> - 将即时搜索功能添加到 GitHub 的搜索栏。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj"" rel=""nofollow noreferrer"">JSON-handle</a></strong> - JSON 美化插件。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/marxico/kidnkfckhbdkfgbicccmdggmpgogehop?utm_source=chrome-app-launcher-info-dialog"" rel=""nofollow noreferrer"">马克飞象【强烈推荐】</a></strong> - 强大的Markdown离线编辑器，专为印象笔记打造。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/vysor/gidgenkbbabolejbgbpnhbimgjbffefm?utm_source=chrome-app-launcher-info-dialog"" rel=""nofollow noreferrer"">Vysor</a></strong> - 在浏览器上操作 Android 手机。</li>
<li>
<strong><a href=""https://chrome.google.com/webstore/detail/drawio-desktop/pebppomjfocnoigkeepgbmcifnnlndla?utm_source=chrome-app-launcher-info-dialog"" rel=""nofollow noreferrer"">Draw.io Desktop【强烈推荐】</a></strong> - Draw.io是一个完全免费的图表编辑器，画流程图特别方便，强烈推荐！！！。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013996063"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>二、Sublime Text 插件</h2>
<ul>
<li>
<strong>Alignment</strong><br>使用说明：Alignment是一个代码格式化插件，它可以使多行代码中的等号对齐，也可以调整多行代码为一个缩进级别。<br>快捷键：ctrl+shift+alt+a</li>
<li>
<strong>AutoFileName</strong><br>使用说明：文件名自动补全，根据路径自动提示该路径下的文件</li>
<li>
<strong>BracketHighlighter</strong><br>使用说明：BracketHighlighter插件是用来匹配相对的符号，然后高亮显示，比如{ }、[ ]、"" ""等符号的对应高亮显</li>
<li>
<strong>ConvertToUTF8</strong><br>使用说明：自动转为UTF-8编码类型</li>
<li>
<strong>DeleteBlankLines</strong><br>使用说明：选中需要批量删除空行的部分，Ctrl + Alt + Backspace，选中部分的所有空行就都被删除了<br>快捷键：ctrl+alt+backspace</li>
<li>
<strong>DocBlockr</strong><br>使用说明：生成js ,php 等语言函数注释,只需要在函数上面输入<code>/**</code> ,然后按tab 就会自动生成注释模板</li>
<li>
<strong>Emmet</strong><br>使用说明：它让编写 HTML 代码变得简单。<br>Emmet用法参见<a href=""http://www.cnblogs.com/jesse131/p/4978966.html"" rel=""nofollow noreferrer"">Emmet插件使用方法总结</a>
</li>
<li>
<strong>HTML-CSS-JS Prettify</strong><br>使用说明：快速格式化html css js<br>快捷键：ctrl+shift+h</li>
<li>
<strong>jQuery</strong><br>使用说明：会出现jquery提示</li>
<li>
<strong>LESS</strong><br>使用说明：支持less语法高亮</li>
<li>
<strong>SCSS</strong><br>使用说明：支持SCSS语法高亮</li>
<li>
<strong>SideBarEnhancements</strong><br>使用说明：SideBarEnhancements 是一款很实用的右键菜单增强插件，有以 diff 形式显示未保存的修改、在文件管理器中显示该文件、复制文件路径、在侧边栏中定位该文件等功能，也有基础的诸如新建文件/目录，编辑，打开/运行，显示，在选择中/上级目录/项目中查找，剪切，复制，粘贴，重命名，删除，刷新等常见功能。</li>
<li>
<strong>sublime tmpl</strong><br>使用说明：按指定快捷键生成模板。<br>快捷键：<br>ctrl+alt+h 新建html模板文件<br>ctrl+alt+j 新建javascript模板文件<br>ctrl+alt+c 新建css模板文件<br>ctrl+alt+p 新建php模板文件<br>ctrl+alt+r 新建ruby模板文件<br>ctrl+alt+shift+p 新建python模板文件</li>
<li>
<strong>SublimeCodeInte</strong><br>使用说明：Sublime​Code​Intel 是一个代码提示、补全插件，支持 JavaScript、Mason、XBL、XUL、RHTML、SCSS、Python、HTML、Ruby、Python3、XML、Sass、XSLT、Django、HTML5、Perl、CSS、Twig、Less、Smarty、Node.js、Tcl、TemplateToolkit 和 PHP 等语言，是 Sublime Text 自带代码提示功能的很好扩展。</li>
<li>
<strong>SublimeLinter</strong><br>使用说明：它可以帮你找出错误或编写不规范的代码  需要安装nodejs,jshint,csslint</li>
<li>
<strong>SublimeLinter-csslint</strong><br>使用说明：对错误的css代码在状态栏进行提示，</li>
<li>
<strong>SublimeLinter-jshint</strong><br>使用说明：对错误的javascript代码在状态栏进行提示，</li>
<li>
<strong>View In Browser</strong><br>快捷键：ctrl+alt+v<br>使用说明：sublime以本地服务器方式打开网页<br>为了使用插件，你需要建立一个sublime-project文件，点击Project-&gt;Edit Project<br>粘贴以下代码(这是我的相关配置),并保存到user目录下</li>
</ul>
<pre><code class=""json"">{
    ""folders"":
    [
        {
            ""path"": ""D:\\wamp\\www""
        }
    ],
    ""settings"":
    {
        ""sublime-view-in-browser"":
        {
            ""baseUrl"": ""http://localhost""
            ""basePath"": ""D:\\wamp\\www"",   //本地虚拟主机根目录
        }
    }
}</code></pre>
<ul>
<li>
<strong>MarkdownEditing</strong><br>使用说明：它支持Markdown语法高亮显示。</li>
<li>
<strong>OmniMarkupPreviewer</strong><br>使用说明：用来在浏览器中预览markdown 编辑的效果<br>快捷键：ctrl+alt+o</li>
<li>
<strong>Compact​Expand​Css</strong><br>使用说明：css横竖向排列切换<br>快捷键：<br>ctrl+alt[横向排列<br>ctrl+alt]竖向排列</li>
<li>
<strong>Codelf</strong><br>下载地址：<a href=""https://github.com/unbug/codelf/archive/st-0.0.3.zip"" rel=""nofollow noreferrer"">Codelf for Sublime Text</a><br>使用说明：变量命名神器Codelf通过搜索在线开源平台的项目源码帮开发者给变量命名 ，有了它再也不用为了命名而绞尽脑汁了<br>快捷键：鼠标右键，选择Codelf</li>
<li>
<strong>CodeFormatter</strong><br>使用说明：代码格式化插件，主要用于PHP代码的格式化，要求php5.6及以上<br>快捷键：ctrl+alt+s</li>
<li><strong>sublime git</strong></li>
<li><strong>YUI compress</strong></li>
<li><strong>livestyle</strong></li>
<li><strong>GBKEncoding support 中文支持</strong></li>
<li><strong>Terminal</strong></li>
</ul>
<h2>三、Phpstorm 插件</h2>
<ul>
<li>
<strong><a href=""https://plugins.jetbrains.com/plugin/7219-symfony-plugin"" rel=""nofollow noreferrer"">Symfony Plugin</a></strong> - 支持 Symfony 2,3,4 ...</li>
<li>
<strong>Laravel Plugin</strong> - 支持 Laravel</li>
<li>
<strong>.env files support</strong> - 支持.env 文件</li>
<li>
<strong>BashSupport</strong> - 支持 Bash</li>
<li>
<strong>EditorConfig</strong> - 支持 EditorConfig 标准</li>
<li>
<strong>Handlebars/Mustache</strong> - 支持 Handlebars、Mustache</li>
<li>
<strong>Ideolog</strong> - 有好的插件 .log 文件</li>
<li>
<strong>Material Theme UI</strong> - Material Theme 主题</li>
<li>
<strong>.ignore</strong> - 友好的查看 .ignore 文件</li>
<li>
<strong>NodeJS</strong> - 集成 Node.js</li>
<li>
<strong>Markdown support</strong> - 支持 Markdown</li>
<li>
<strong>IdeaVim</strong> - 支持 Vim</li>
<li>
<strong>LiveEdit</strong> - 可以实时编辑 HTML/CSS/JavaScript</li>
<li>
<strong>Markdown Navigator</strong> - 支持 Markdown</li>
<li>
<strong>PHP composer.json support</strong> - 支持 composer.json 文件</li>
<li>
<strong>Php Inspections (EA Extended)</strong> - PHP 的静态代码分析工具</li>
<li>
<strong>Nyan Progress Bar</strong> - 改变进度条样式</li>
<li>
<strong>Grep Console</strong> - Grep 控制台</li>
<li>
<strong>String Manipulation</strong> - 有好的操作字符串</li>
<li>
<strong>CodeGlance</strong> - 类似于 Sublime 中的代码小地图</li>
<li>
<strong>Styled Components</strong> - 利用标记的模板文字和 CSS 的强大功能，样式化组件允许您编写实际的 CSS 代码来设置组件样式</li>
</ul>
<h2>四、油猴脚本</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013996065"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>4.1 脚本网站</h3>
<ul>
<li>
<strong>OpenUserJS</strong><br><a href=""https://openuserjs.org/"" rel=""nofollow noreferrer"">OpenUserJS</a> 继 GreasyFork 之后开始创办。它由 Sizzle McTwizzle 创建,同样地,在其储存库中也拥有大量的脚本资源。</li>
<li>
<strong>GreasyFork</strong><br><a href=""https://greasyfork.org/"" rel=""nofollow noreferrer"">GreasyFork</a> 或许是最受欢迎的后起之秀了。它由 Jason Barnabe 创建,Jason Barnabe 同时也是 <a href=""https://userstyles.org/"" rel=""nofollow noreferrer"">Stylish</a> 网站的创办者,在其储存库中有大量的脚本资源。</li>
<li>
<strong>Userscripts.org</strong><br>Userscripts.org 一直以来都是用户脚本的常用来源,但现在这个网站已经不再更新了。你可以在这个网址找到历 史资源 <a href=""http://userscripts-mirror.org"" rel=""nofollow noreferrer"">http://userscripts-mirror.org</a>。</li>
</ul>
<hr>
<h3>4.2 自用的脚本</h3>
<ul>
<li>
<strong><a>Userscript+</a></strong> - 显示当前网站所有可用的油猴脚本。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/22590-%E4%B8%80%E9%94%AE%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD"" rel=""nofollow noreferrer"">一键离线下载</a></strong> - 一键自动将磁链、bt种子或其他下载资源离线下载至网盘。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/37058-%E5%85%A8%E7%BD%91%E9%9F%B3%E4%B9%90%E4%B8%80%E9%94%AE%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD-%E4%B8%80%E9%94%AE%E6%90%9C%E7%B4%A2-%E5%9C%A8%E7%BA%BF%E8%AF%95%E5%90%AC-%E6%9C%80%E6%96%B0%E4%BF%AE%E5%A4%8D%E7%89%882018-3-10%E6%99%9A%E6%9B%B4%E6%96%B0"" rel=""nofollow noreferrer"">全网音乐一键免费下载 一键搜索 在线试听</a></strong> - 全网音乐在线试听 一键免费下载 一键搜索 提供多站合一 音乐试听 音乐下载 音乐搜索解决方案，网易云音乐，QQ音乐，酷狗音乐，酷我音乐，虾米音乐，百度音乐，蜻蜓FM，荔枝FM，喜马拉雅。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/10718-json-formatter"" rel=""nofollow noreferrer"">JSON formatter</a></strong> - 美化 JSON 数据。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/15562-github-dark-script"" rel=""nofollow noreferrer"">GitHub Dark Script</a></strong> - 设置 GItHub 黑色主题。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/27530-%E7%A0%B4%E8%A7%A3vip%E4%BC%9A%E5%91%98%E8%A7%86%E9%A2%91%E9%9B%86%E5%90%88"" rel=""nofollow noreferrer"">破解VIP会员视频集合</a></strong> - 一键破解[优酷|腾讯|乐视|爱奇艺|芒果|AB站|音悦台]等VIP或会员视频。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/31642-%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2-%E4%BC%98%E5%8C%96"" rel=""nofollow noreferrer"">百度搜索 - 优化</a></strong> - 1、屏蔽百度推广 2、关闭百度广告联盟信息收集 3、绑定快捷键 4、布局调整 5、居中单列(可选)** 6、居中双列(可选)。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/39776-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B"" rel=""nofollow noreferrer"">百度网盘直接下载</a></strong> -  网盘内和分享链接页面均显示[高速下载]按钮，支持百度企业网盘。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/7678-wikipedia-inline-article-viewer"" rel=""nofollow noreferrer"">Wikipedia Inline Article Viewer</a></strong> - 鼠标停在维基百科页面上的链接上，会自动加载连接内容。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/2600-%E8%B7%B3%E8%BF%87%E7%BD%91%E7%AB%99%E7%AD%89%E5%BE%85-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%8A%E7%99%BB%E5%BD%95"" rel=""nofollow noreferrer"">跳过网站等待、验证码及登录</a></strong> - 移除各类网站验证码、登录、倒计时及更多!</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/12909-google-baidu-switcher-all-in-one"" rel=""nofollow noreferrer"">Google &amp; baidu Switcher (ALL in One)</a></strong> - 分别在百度和google的搜索结果页面增加搜索跳转按钮。</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/34479-%E7%9B%AE%E5%BD%95%E6%A0%91%E5%AF%BC%E8%88%AA"" rel=""nofollow noreferrer"">目录树导航</a></strong> - 目录树导航 - 显示文章目录大纲导航</li>
<li>
<strong><a href=""https://greasyfork.org/zh-CN/scripts/28497-remove-web-limits-modified"" rel=""nofollow noreferrer"">网页限制解除</a></strong> - 通杀大部分网站，可以解除禁止复制、剪切、选择文本、右键菜单的限制。</li>
<li>
<strong><a href=""https://openuserjs.org/scripts/xthexder/Wide_Github"" rel=""nofollow noreferrer"">Wide Github</a></strong> - 将所有github存储库页面更改为全宽显示，<a href=""https://chrome.google.com/webstore/detail/wide-github/kaalofacklcidaampbokdplbklpeldpj"" rel=""nofollow noreferrer"">插件版</a>。</li>
<li>
<strong><a href=""https://openuserjs.org/scripts/52cik/GitHub_%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6"" rel=""nofollow noreferrer"">GitHub 汉化插件</a></strong> - 汉化 GitHub 界面的部分菜单及内容。</li>
</ul>
<h2>五、相关链接</h2>
<ul>
<li><a href=""https://plugins.jetbrains.com/phpstorm"" rel=""nofollow noreferrer"">PhpStorm Plugins</a></li>
<li><a href=""https://packagecontrol.io/"" rel=""nofollow noreferrer"">Package Control</a></li>
<li>
<a href=""https://github.com/Jesse121/Sublime_Plugins"" rel=""nofollow noreferrer"">Sublime_Plugins</a>，by Jesse121</li>
</ul>
<hr>
<p>本文为<strong>琯琯</strong>原创文章,转载无需和我联系,但请注明来自<strong><a href=""https://guanguans.cn/"" rel=""nofollow noreferrer"">琯琯博客</a> <a href=""https://guanguans.cn"" rel=""nofollow noreferrer"">https://guanguans.cn</a></strong></p>

                ", 超好用的谷歌浏览器、Sublime Text、Phpstorm、油猴插件合集,1531977715,440,1,564,1,1,https://segmentfault.com/a/1190000013996058
38,1,0,7,"
                    
<blockquote>Vant 是有赞前端团队维护的移动端 Vue 组件库，提供了一整套 UI 基础组件和业务组件。通过 Vant 可以快速搭建出风格统一的页面，提升开发效率。</blockquote>
<h2>一、关于 Vant 1.0</h2>
<p>距离 Vant <a href=""https://juejin.im/post/59cb19d95188257e84671938"" rel=""nofollow noreferrer"">首次发布</a>刚好过去了半年时间，在这半年时间里 Vant 团队广泛吸纳社区的反馈和建议，持续对组件进行打磨、优化，使得 Vant 逐渐成长为一个轻量、可靠的移动端 Vue 组件库。</p>
<p>在这个时间点上我们决定发布 Vant 的 1.0 正式版，希望未来有更多小伙伴能够参与到 Vant 的开发和使用中来。</p>
<p>GitHub 地址：<a href=""https://github.com/youzan/vant"" rel=""nofollow noreferrer"">github.com/youzan/vant</a></p>
<hr>
<h2>二、现有组件</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013854033?w=2238&amp;h=2198"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<hr>
<h2>三、开发理念</h2>
<h3>轻量化</h3>
<p>作为移动端组件库，<code>Vant</code> 一直将轻量化作为核心开发理念。为了平衡日益丰富的功能和轻量化之间的矛盾关系，我们尝试了很多的优化方式，包括支持组件按需加载、公共模块复用、组件编译流程优化等。</p>
<p>在应用一系列的优化手段之后，目前 <code>Vant</code> 的组件平均体积仅有 8.8KB，Uglify + Gzip 后约 1KB。作为对比，<code>mint-ui</code> 的组件平均体积为 15.2KB，某些组件库的组件平均体积甚至在 25KB 以上。</p>
<p><code>Vant</code> 之所以能保持如此小的组件体积，主要归功于我们独特的组件编译方式。目前主流的组件编译方式是通过 webpack 搭配 vue-loader 对每个组件进行编译，为每个组件生成一个打包后 JS 文件。这样的做法会产生大量的冗余代码，比如 webpack 内置的模块化代码、vue-loader 内置的 normalize 函数、重复引入的 babel helper 等等，而我们不希望在组件的编译结果中引入这些冗余代码。</p>
<p>一开始我们尝试通过使用 rollup 和 rollup-plugin-vue 去解决上述的问题，但很快我们就发现了更为直接的方式，即通过官方提供的 vue-template-compiler 和 babel 对组件进行编译，这样的方式简单纯粹，编译出的代码非常干净，细节在此不做赘述，有兴趣的同学可以看下 Vant 中<a href=""https://github.com/youzan/vant/tree/dev/build/bin"" rel=""nofollow noreferrer"">构建部分的源码</a>。</p>
<h3>快速迭代</h3>
<p>另外一个很重要的理念是快速迭代。有赞前端团队几十个工程师每天都在用的就是现在你看到的 GitHub 上这个版本，我们并没有一个所谓的“内部版”。同时，出于对自己名誉的珍视，我们不是简单地把它开源了事，而是把它当做一款技术产品去维护，不单单自己用的爽，也要让别人好用，因此我们会保持对社区需求的快速响应、对 bug 及时跟进并修复。</p>
<p>迄今为止项目 commit 总数超过 1600 次，解决 issue 300 个，合并 Pull Request 400 个，发布 90 次，基本上保持了一周 1 ~ 2 次的发布节奏。这里面包含了很多社区开发者的付出，感谢他们对 <code>Vant</code> 作出的贡献~ 在未来我们也会继续保持这样的开发节奏，为社区输出更好的开源产品。</p>
<h3>生态化</h3>
<p>除了提供组件以外，我们也在为丰富 <code>Vant</code> 的开发生态做很多尝试，希望能覆盖各个场景下的开发需求，为大家提供便利。下面是我们现有的一些生态或能力：</p>
<ul>
<li>基于 vue-cli 的脚手架 <code>vue-cli-template-vant</code>
</li>
<li>支持 <code>nuxt</code> 服务器端渲染</li>
<li>支持 <code>Typescript</code> 类型检测</li>
<li>支持 <code>i18n</code> 多语言定制</li>
<li>支持通过 <code>postcss</code> 插件进行主题定制</li>
<li>官方 Demo 仓库 - <a href=""https://github.com/youzan/vant-demo"" rel=""nofollow noreferrer"">vant-demo</a>
</li>
<li>基于相同视觉规范的小程序组件库 - <a href=""https://github.com/youzan/zanui-weapp"" rel=""nofollow noreferrer"">zanui-weapp</a>
</li>
<li>开源社区的移动商城示例项目 - <a href=""https://github.com/qianzhaoy/vant--mobile-mall"" rel=""nofollow noreferrer"">vant--mobile-mall</a>
</li>
</ul>
<p>在生态化方面我们还有很多需要补齐的方面，比如提供对 rem 的支持、vscode 代码提示插件等，这些将会是我们 18 年尝试的方向。</p>
<hr>
<h2>四、最后</h2>
<p>开源项目的进步离不开社区的贡献，非常感谢过去对 <code>Vant</code> 提出 PR 和意见的所有人，尤其感谢社区 <a href=""https://github.com/chuangbo"" rel=""nofollow noreferrer"">@chuangbo</a>、<a href=""https://github.com/qianzhaoy"" rel=""nofollow noreferrer"">@qianzhaoyan</a>、<a href=""https://github.com/GeoffZhu"" rel=""nofollow noreferrer"">@GeoffZhu</a> 等同学的付出。希望未来能有更多的同学加入到 <code>Vant</code> 的开发中来。如果你对有赞的前端团队感兴趣，也欢迎加入我们一起玩耍~ </p>
<p><span class=""img-wrap""><img data-src=""/img/bV50Mk?w=640&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Vant 1.0 正式发布：轻量、可靠的移动端 Vue 组件库,1531977716,193,1,183,1,1,https://segmentfault.com/a/1190000013886565
39,1,0,7,"
                    
<hr>
<p>关注痞子衡专栏公众号，第一时候获得嵌入式技术文章推送，让痞子衡带你玩转嵌入式。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013485274?w=220&amp;h=220"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>　　大家好，我是痞子衡，是正经搞技术的痞子。本系列痞子衡给大家讲的是<strong>Git命令汇编</strong>，共12篇文章，循序渐进地介绍Git操作的完整过程。  </p>
<p>　　在开始Git课程之前，需要先跟大家普及2个重要概念（四度空间、四种状态），后续课程都是围绕这两个重要概念展开的。</p>
<h3>四度空间</h3>
<p>　　第一个重要概念是Git的四度空间。在Git仓库目录下的文件改动（增删改操作）共有如下4个空间来记录/存储，Git命令就是用于将文件改动切换到不同的空间来记录。</p>
<blockquote><ul>
<li>Workspace：工作区</li>
<li>Index / Stage / Cached：暂存区</li>
<li>Repository：本地仓库</li>
<li>Remote：远程仓库</li>
</ul></blockquote>
<p>　　如果你只是Git的轻度用户，原则上只需要记住如下图所示的7个Git命令就可以了。这7个命令可以帮你将文件改动记录到任意Git空间。  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000013882575?w=806&amp;h=244"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>四种状态</h3>
<p>　　前面讲了Git有四度空间，而单就文件改动状态层面而言，Git空间内的文件也有4种状态（需要注意的是文件状态并不是与Git空间一一对应的），这是Git第二个重要概念。</p>
<blockquote><ul>
<li>Untracked：新增的文件的状态，未受Git管理，记录在工作区</li>
<li>Modified：受Git管理过的文件的改动状态（包括改动内容、删除文件），记录在工作区</li>
<li>Staged：将记录在工作区的文件变动状态通知了Git，记录在暂存区</li>
<li>Unmodified：受Git管理中的文件状态（没有变动），记录在本地仓库/远程仓库</li>
</ul></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013882576?w=627&amp;h=279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>正文十二篇</h3>
<p>　　知道了2个Git重要概念，我们便可以开始Git的命令学习，痞子衡课程使用的Git版本是2.16.2，共十二节课，Enjoy it！  </p>
<p><a href=""http://www.cnblogs.com/henjay724/p/8525512.html"" rel=""nofollow noreferrer"">第一本Git命令教程（1）- 准备(init/config/gitignore)</a><br><a href=""http://www.cnblogs.com/henjay724/p/8525957.html"" rel=""nofollow noreferrer"">第一本Git命令教程（2）- 连接(remote/clone)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8537277.html"" rel=""nofollow noreferrer"">第一本Git命令教程（3）- 变动(status/diff)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8541981.html"" rel=""nofollow noreferrer"">第一本Git命令教程（4）- 转移(add/rm/mv)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8543292.html"" rel=""nofollow noreferrer"">第一本Git命令教程（5）- 提交(commit/format-patch/am)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8593034.html"" rel=""nofollow noreferrer"">第一本Git命令教程（6）- 日志(log/reflog/gitk)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（7）- 清理(revert/reset/stash/clean)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（8）- 分支(branch/checkout)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（9）- 更新(pull/fetch)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（10）- 整合(cherry-pick/merge/rebase)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（11）- 推送(push)</a>  <br><a href=""http://www.cnblogs.com/henjay724/p/8525497.html"" rel=""nofollow noreferrer"">第一本Git命令教程（12）- 发布(tag/archive)</a></p>
<h3>参考资料</h3>
<p><a href=""https://git-scm.com/docs"" rel=""nofollow noreferrer"">Git命令官方手册</a>  <br><a href=""https://backlog.com/git-tutorial/cn/"" rel=""nofollow noreferrer"">猴子都能懂的GIT入门</a><br><a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰的Git完整教程</a>  <br><a href=""https://blog.coding.net/blog/git-from-the-inside-out"" rel=""nofollow noreferrer"">Mary Rose Cook的深入浅出Git</a><br><a href=""https://www.cnblogs.com/syp172654682/p/7689328.html"" rel=""nofollow noreferrer"">深入浅出Git教程（转载）</a><br><a href=""http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html"" rel=""nofollow noreferrer"">阮一峰的Git命令清单</a>  <br><a href=""http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html"" rel=""nofollow noreferrer"">景春雷的Git命令脑图</a>  <br><a href=""https://www.cnblogs.com/ptqueen/p/6723147.html"" rel=""nofollow noreferrer"">InMicro的Git文件状态</a><br><a href=""https://segmentfault.com/a/1190000011673663"" rel=""nofollow noreferrer"">精进吧Aaron的常用Git命令</a></p>

                ", 做你的第一本Git教程(十二篇) ,1531977718,534,1,587,1,1,https://segmentfault.com/a/1190000013882570
40,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV6aHV?w=1280&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>社区优秀文章</h2>
<ul>
<li>
<a href=""https://laravel-china.org/articles/6035/laravel55-developing-api-combat"" rel=""nofollow noreferrer"">Laravel 5.5+passport 放弃 dingo 开发 API 实战，让 API 开发更省心</a> - 自造车轮。</li>
<li>
<a href=""https://laravel-china.org/articles/5069/the-api-document-artifact-swagger-is-introduced-and-used-in-the-php-project"" rel=""nofollow noreferrer"">API 文档神器 Swagger 介绍及在 PHP 项目中使用</a> - API 文档撰写方案</li>
<li><a href=""https://laravel-china.org/topics/7457/recommend-8-extension-packages-that-the-laravel-api-project-must-use"" rel=""nofollow noreferrer"">推荐 Laravel API 项目必须使用的 8 个扩展包</a></li>
<li><a href=""https://laravel-china.org/articles/7264/using-jwu-auth-to-build-front-and-back-end-user-authentication-and-painless-refresh-access-token"" rel=""nofollow noreferrer"">使用 Jwt-Auth 实现 API 用户认证以及无痛刷新访问令牌</a></li>
<li><a href=""https://laravel-china.org/topics/610/tell-me-about-a-recent-app-backend-project-done-with-laravel"" rel=""nofollow noreferrer"">讲讲我最近用 Laravel 做的一个 App 后端项目</a></li>
<li><a href=""https://laravel-china.org/articles/5548/laravel-passport-api-authentication-use-summary"" rel=""nofollow noreferrer"">Laravel Passport API 认证使用小结</a></li>
<li><a href=""https://laravel-china.org/articles/7048/a-summary-of-the-design-of-restful-api"" rel=""nofollow noreferrer"">关于 RESTful API 设计的总结</a></li>
<li><a href=""https://laravel-china.org/articles/6976/laravel-55-uses-passport-to-implement-auth-authentication"" rel=""nofollow noreferrer"">Laravel 5.5 使用 Passport 实现 Auth 认证</a></li>
<li><a href=""https://laravel-china.org/topics/7528/use-the-api-resource-function-of-laravel-to-build-your-api"" rel=""nofollow noreferrer"">使用 Laravel 的 API 资源功能来构建你的 API</a></li>
<li><a href=""https://laravel-china.org/articles/7482/a-single-laravel-project-simultaneously-configuring-different-domain-names-apidomain-user-interface-and-admindomain-administrator"" rel=""nofollow noreferrer"">单个 Laravel 项目同时配置不同域名 api.domain（用户端接口） 和 admin.domain（管理员端）</a></li>
<li><a href=""https://laravel-china.org/articles/6236/multi-field-login-common-solution"" rel=""nofollow noreferrer"">多字段登录通用解决方案</a></li>
<li><a href=""https://laravel-china.org/topics/3904/laravel-do-api-server-vuejsiview-do-spa-a-new-demo"" rel=""nofollow noreferrer"">Laravel 做 API 服务端，VueJS+iView 做 SPA，给新手一个 Demo</a></li>
<li><a href=""https://laravel-china.org/articles/8115/using-graphql-one-in-laravel-get-data"" rel=""nofollow noreferrer"">在 Laravel 中使用 GraphQL 一【获取数据】</a></li>
<li><a href=""https://laravel-china.org/articles/8380/some-of-the-experiences-of-laravel-developing-restful-api"" rel=""nofollow noreferrer"">Laravel 开发 RESTful API 的一些心得</a></li>
<li><a href=""https://laravel-china.org/articles/3785/understanding-of-rest"" rel=""nofollow noreferrer"">对 REST 的理解</a></li>
<li><a href=""https://laravel-china.org/topics/1792/build-a-restful-service-with-oauth2-verification-with-laravel"" rel=""nofollow noreferrer"">用 Laravel 搭建带 OAuth2 验证的 RESTful 服务</a></li>
<li><a href=""https://laravel-china.org/topics/7625/dynamically-hide-the-api-field-in-laravel"" rel=""nofollow noreferrer"">在 Laravel 中动态隐藏 API 字段</a></li>
<li>
<p><a href=""https://laravel-china.org/topics/206/deploying-https-and-security-tuning-under-nginx"" rel=""nofollow noreferrer"">Nginx 下部署 HTTPS 与安全调优</a></p>
<blockquote>一套安全的 API 方案，第一步要做的事情就是部署 HTTPS</blockquote>
</li>
<li>
<p>[[译] 2018 PHP 应用程序安全设计指北](<a href=""https://laravel-china.org/articles/7235/2018-php-application-security-design)"" rel=""nofollow noreferrer"">https://laravel-china.org/art...</a></p>
<blockquote>安全必读。</blockquote>
</li>
</ul>
<h2>开发 API 必读文章</h2>
<ul>
<li>
<a href=""http://codeplanet.io/principles-good-restful-api-design/"" rel=""nofollow noreferrer"">Principles of good RESTful API Design</a>（译：<a href=""http://www.cnblogs.com/moonz-wu/p/4211626.html"" rel=""nofollow noreferrer"">好 RESTful API 的设计原则</a> ）简单易懂，条理清晰，推荐</li>
<li>
<a href=""http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api"" rel=""nofollow noreferrer"">Best Practices for Designing a Pragmatic RESTful API</a>（译：<a href=""http://blog.jobbole.com/41233"" rel=""nofollow noreferrer"">RESTful 最佳实践</a> <a href=""http://www.oschina.net/translate/best-practices-for-a-pragmatic-restful-api"" rel=""nofollow noreferrer"">译文2</a>）有实际的案例 <a href=""http://dev.enchant.com/api/v1"" rel=""nofollow noreferrer"">Enchant</a>
</li>
<li>
<a href=""https://github.com/interagent/http-api-design"" rel=""nofollow noreferrer"">HTTP API Design Guide</a>（译：<a href=""https://github.com/cocoajin/http-api-design-ZH_CN"" rel=""nofollow noreferrer"">HTTP API 设计指南</a>）</li>
<li><a href=""https://bourgeois.me/rest/"" rel=""nofollow noreferrer"">Some REST best practices</a></li>
<li>
<a href=""http://www.ruanyifeng.com/blog/2011/09/restful.html"" rel=""nofollow noreferrer"">理解 RESTful 架构</a> - 阮一峰 简单了解什么是 RESTFul</li>
<li>
<a href=""http://www.ruanyifeng.com/blog/2014/05/restful_api.html"" rel=""nofollow noreferrer"">RESTful API 设计指南</a> - 阮一峰</li>
<li>
<a href=""http://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"" rel=""nofollow noreferrer"">Restful API 的设计规范</a> 实战经验的总结，具有较强的启发意义</li>
<li>
<a href=""http://zhuanlan.zhihu.com/prattle/20034107"" rel=""nofollow noreferrer"">撰写安全合格的REST API</a> 利用好 HTTP 协议所具备的特征</li>
<li>
<a href=""https://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/"" rel=""nofollow noreferrer"">Web 服务编程，REST 与 SOAP</a> REST 与传统的面向服务的接口设计的区别，启发性强</li>
<li>
<a href=""http://www.ibm.com/developerworks/cn/web/1103_chenyan_restapi/"" rel=""nofollow noreferrer"">最佳实践：更好的设计你的 REST API</a> 了解 REST 实现缓存的过程</li>
<li><a href=""https://restful-api-design.readthedocs.org/en/latest/"" rel=""nofollow noreferrer"">Thoughts on RESTful API Design</a></li>
<li>
<a href=""http://www.restapitutorial.com/"" rel=""nofollow noreferrer"">REST API Tutorial</a> 全方位介绍 REST</li>
<li><a href=""https://github.com/bolasblack/http-api-guide"" rel=""nofollow noreferrer"">HTTP 接口设计指北</a></li>
<li>
<a href=""https://pages.apigee.com/web-api-design-website-h-ebook-registration.html"" rel=""nofollow noreferrer"">Web API Design</a> 接口就是开发人员提供的""界面""，用户体验在接口设计上同样重要，在线查看 <a href=""https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf"" rel=""nofollow noreferrer"">2012 版</a>、<a href=""https://pages.apigee.com/rs/351-WXY-166/images/ebook-2013-03-wad.pdf"" rel=""nofollow noreferrer"">2013 版</a>
</li>
<li>
<a href=""http://yuedu.baidu.com/ebook/780324fbf121dd36a32d8269"" rel=""nofollow noreferrer"">架构风格与基于网络应用软件的架构设计</a> 原汁原味的博士论文，由李锟翻译，有经验的同学可以挑战一下</li>
<li>
<a href=""https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md"" rel=""nofollow noreferrer"">Microsoft REST API Guidelines</a> 微软官方的 REST API 设计指南，值得参考</li>
<li>
<a href=""http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html"" rel=""nofollow noreferrer"">理解 HTTP 幂等性</a> 讲得很清楚，推荐</li>
<li>
<a href=""http://www.cppblog.com/jb8164/archive/2008/08/15/58949.html"" rel=""nofollow noreferrer"">浅析远程过程调用 RPC</a> 告诉你什么是 RPC</li>
<li>
<a href=""https://httpstatuses.com/"" rel=""nofollow noreferrer"">httpstatuses</a> 一眼看完所有常用的 HTTP 状态码，还可以看详细含义</li>
<li>
<a href=""http://jsonapi.org/"" rel=""nofollow noreferrer"">json-api</a> 对 API 应该如何利用好 JSON 的一些建议</li>
<li>
<a href=""http://www.json.org/json-zh.html"" rel=""nofollow noreferrer"">介绍 JSON</a> 无论如何都应该读一遍</li>
<li>
<a href=""http://clojure-liberator.github.io/liberator/doc/decisions.html"" rel=""nofollow noreferrer"">decision-graph.svg</a> 一张大图展示整个 REST API 的验证过程，及各种状态码出现的时机</li>
</ul>
<h2>现成 API 例子</h2>
<ul>
<li>
<a href=""https://developer.github.com/v3/"" rel=""nofollow noreferrer"">Github API v3</a> 被很多人参考和引用，比如对分页的处理方法、接口版本的设计等等</li>
<li>
<a href=""https://documentation.mailgun.com/"" rel=""nofollow noreferrer"">Mailgun Documentation</a> 邮件服务 REST API</li>
<li><a href=""http://dev.enchant.com/api/v1"" rel=""nofollow noreferrer"">Enchant REST API</a></li>
<li>
<a href=""https://developers.coinbase.com/api/v2"" rel=""nofollow noreferrer"">Coinbase</a> API 设计的挺好的，包括官网提供的接口客户端，都是具有参考意义的</li>
<li><a href=""http://www.opennms.org/wiki/"" rel=""nofollow noreferrer"">OpenNMS Wiki ReST API</a></li>
<li>
<a href=""https://leancloud.cn/docs/rest_api.html"" rel=""nofollow noreferrer"">REST API 使用详解</a> Lean Cloud 中讲解 REST API 的使用，还集成 <a href=""https://swagger.io/swagger-ui/"" rel=""nofollow noreferrer"">Swagger UI</a> 在线调试工具，<a href=""https://leancloud.cn/dashboard/apionline/index.html"" rel=""nofollow noreferrer"">点击查看</a>。</li>
</ul>
<h2>调试工具</h2>
<ul>
<li>
<a href=""https://www.sprintapi.com/dhcs.html"" rel=""nofollow noreferrer"">DHC (aka Dev HTTP Client)</a> Chrome 插件，简单易用，可分类管理，界面友好</li>
<li>
<a href=""http://www.telerik.com/fiddler"" rel=""nofollow noreferrer"">Fiddler2</a> Windows 下抓包必备，捕捉每一次 REST 请求和响应的详细内容</li>
<li>
<a href=""https://www.charlesproxy.com/"" rel=""nofollow noreferrer"">Charles Proxy</a> Mac 下抓包必备</li>
<li>
<a href=""https://www.getpostman.com/"" rel=""nofollow noreferrer"">Postman</a> 功能齐全的 API 请求工具</li>
</ul>
<h2>Laravel API 课程</h2>
<p>社区有一门实战课程 <a href=""https://laravel-china.org/topics/7657"" rel=""nofollow noreferrer"">《Laravel 教程实战高级 - 构架 API 服务器》</a> ，主要专注于 App 和 SPA 后端 API 服务器实战开发。手把手带你构建一个设计合理的 RESTful API 服务器。本课程涉及的技术话题有：</p>
<ul>
<li>RESTFul 的概念及 Github Api 设计分解；</li>
<li>DingoApi 的介绍及安装；</li>
<li>PostMan 的介绍及使用；</li>
<li>用户认证 —— 手机注册、登录、退出；</li>
<li>第三方认证 —— 微信登录、JWT的使用；</li>
<li>用户信息 —— 获取个人信息、上传图片接口、修改个人信息；</li>
<li>话题接口 —— 发布、修改、删除、列表；</li>
<li>话题回复接口 —— 发布、修改、删除、列表；</li>
<li>权限控制 —— 权限列表，角色列表；</li>
<li>资源推荐接口、活跃用户接口；</li>
<li>接口本地化处理；</li>
<li>API 接口错误代码机制；</li>
<li>APNS 消息推送服务器端介绍及实现；</li>
<li>API 测试 —— 单元测试、集成测试、黑盒测试；</li>
<li>快速完成 API 文档；</li>
<li>Passport / OAuth 2.0 认证。</li>
</ul>
<blockquote>原文见：<a href=""https://laravel-china.org/docs/dingo-api/2.0.0/recommended-reading"" rel=""nofollow noreferrer"">https://laravel-china.org/doc...</a>
</blockquote>

                ", PHP / Laravel API 开发推荐阅读清单,1531977719,508,1,472,1,1,https://segmentfault.com/a/1190000013825159
41,1,0,7,"
                    
<p>这里介绍两种方法：</p>
<ul>
<li>手动创建</li>
<li>gitlab(web方式)</li>
</ul>
<h1>手动创建</h1>
<pre><code>$ ps -ef | grep sshd // 可查看是否安装SSH服务
# 如果没有安装SSH服务,可通过如下命令安装.
$ sudo apt-get install openssh-server openssh-client
</code></pre>
<p>centos 戳这里 <a href=""http://blog.csdn.net/mengyoufengyu/article/details/72855524"" rel=""nofollow noreferrer"">centos7安装ssh服务</a></p>
<h3>安装git （服务器上）</h3>
<pre><code>$ sudo apt-get install git
# 老一点的Ubuntu,需要改为 
$ sudo apt-get install git-core</code></pre>
<h3>添加git用户,并设置密码</h3>
<pre><code>$ sudo useradd git -m
$ sudo passwd git</code></pre>
<h3>创建证书登录(本地电脑上)</h3>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。<br>如果本机没有公钥,可以通过执行以下命令:</p>
<pre><code>ssh-keygen -t rsa -C ""your email address""   //即可以当前用户目录.ssh下生成公钥文件. 
$ ssh-copy-id -i ~/.ssh/id_rsa.pub  git@118.24.153.55  //上传公钥到服务器  这个ip是我的腾讯服务器  请换成你自己的</code></pre>
<p>首次上传公钥会在服务器git用户目录下创建 .ssh/authorized.keys文件.<br>如果是手动复制公钥,需要自己创建 .ssh/authorized.keys 文件. 注意保证git用户权限.</p>
<h3>禁止git用户shell登录. 编辑/etc/passwd文件,找到:</h3>
<pre><code>git:x:1001:1003::/home/git:/bin/sh</code></pre>
<p>修改为:</p>
<pre><code>git:x:1001:1003::/home/git:/usr/bin/git-shell</code></pre>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<h3>初始化仓库,并设置权限.</h3>
<pre><code>$ sudo mkdir /rep   //在根目录新建文件夹  
$ cd /rep           //进入该文件夹  
$ sudo git init --bare project.git  //初始化空仓库  
$ sudo chown -R git:git project.git //修改文件夹权限</code></pre>
<p>在当前目录下会生成一个project.git目录.</p>
<h3>测试仓库(本地电脑)</h3>
<pre><code>$ git clone git@118.24.153.55:/rep/project.git
$ cd project.git
$ echo ""Hello world"" &gt;&gt; index.html
$ git add index.html
$ git push</code></pre>
<p>实际过程：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5t7f?w=1224&amp;h=1027"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bV5t7h?w=1206&amp;h=484"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bV5t7i?w=705&amp;h=501"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h1>gitlab(web方式)</h1>
<h3>安装</h3>
<p>官方有<a href=""https://about.gitlab.com/downloads/"" rel=""nofollow noreferrer"">安装包</a>下载和官方<a href=""https://about.gitlab.com/installation/"" rel=""nofollow noreferrer"">安装指南</a>. 官方不推荐一键安装包,特别是Bitnami 的一键安装包....虽然Bitnami的安装包确实非常容易安装.<br>那我们就按照官方的步骤来安装.环境还是我们上面的那台服务器.</p>
<ul><li>安装依赖</li></ul>
<pre><code>sudo apt-get install curl ca-certificates postfix</code></pre>
<p>安装到postfix时会跳出选择框,一切默认选择就好了.</p>
<ul><li>如果你的网速足够快的话可以按以下方式:</li></ul>
<pre><code>curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash
sudo apt-get install gitlab-ce</code></pre>
<p>貌似这个要几个小时,非常慢.那我们直接下载适合自己版本的安装文件.我的服务器是Ubuntu 12.4 64位. <a href=""https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/precise/gitlab-ce_7.13.4-ce.0_amd64.deb"" rel=""nofollow noreferrer"">ubuntu/precise</a> 下载地址.然后执行:</p>
<pre><code>sudo dpkg -i gitlab-ce_7.13.4-ce.0_amd64.deb</code></pre>
<ul><li>配置</li></ul>
<p>修改/etc/gitlab/gitlab.rb 文件external_url项为服务器IP.如:</p>
<pre><code>external_url 'http://118.24.153.55'</code></pre>
<p>然后重新加载配置并启动:</p>
<pre><code>sudo gitlab-ctl reconfigure</code></pre>
<p>这个过程有点长. <code>sudo gitlab-ctl status</code> 可查看是否安装成功.</p>
<p>在浏览器输入服务器IP地址.出现如下.首次登录需要重置密码.</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5t66?w=948&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bV5t67?w=731&amp;h=423"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>如果新注册一个用户,需要验证邮箱才能登录,可以修改配置文件,配置好邮件服务器.</p>
<h1>参考</h1>
<p><a href=""https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md"" rel=""nofollow noreferrer"">gitlab文档</a><br><a href=""https://jackhu.top/article/55cb516a3592e7a921ae5902"" rel=""nofollow noreferrer"">Git服务器搭建</a></p>

                ", Git服务器搭建,1531977720,556,1,157,1,1,https://segmentfault.com/a/1190000013661389
42,1,0,7,"
                    
<h2>写在前面</h2>
<p>本文为hexo搭建个人博客系列教程的第三篇，主要内容为网站的SEO以及站点访问加速，前两篇分别为<a href=""https://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2--%E5%9F%BA%E7%A1%80%E7%AF%87/"" rel=""nofollow noreferrer"">基础篇</a>以及<a href=""https://alvabill.ml/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-NexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"" rel=""nofollow noreferrer"">主题优化篇</a>，由于网站是基于hexo的Next主题，所以建议读者按系列教程的步骤来配置，不过本文中的大部分配置是可以各类网站通用的，所以依旧具备极大的参考价值。</p>
<h2>正文</h2>
<h3>站点收录</h3>
<p>一般来说你的网站搭建好后依旧是无法在各大搜索引擎中搜到的，具体可以通过在搜索引擎输入<code>site:你的域名</code>验证。<br>所以你需要提交你的站点到各大搜索引擎：</p>
<ul>
<li><a href=""https://ziyuan.baidu.com/linksubmit/url"" rel=""nofollow noreferrer"">百度提交入口</a></li>
<li><a href=""https://www.google.com/webmasters/tools/home?hl=zh-CN"" rel=""nofollow noreferrer"">Google提交入口</a></li>
</ul>
<blockquote>github禁止百度爬虫，所以使用coding pages才能被百度收录！！（博主为github/coding同步配置，所以并未验证）</blockquote>
<h4>百度收录</h4>
<p>在<a href=""https://ziyuan.baidu.com/linksubmit/url"" rel=""nofollow noreferrer"">百度站长</a>处提交你的站点后进行网站所以权验证，一般有三种方法：文件验证、HTML标签验证和CNAME验证。</p>
<h5>文件验证</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660278?w=1231&amp;h=888"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一般网站如上图步骤配置，基于hexo的站点则：<br>1 需要先下载验证文件，将下载的文件放到<code>站点根目录/source</code>文件下<br>2 在<strong>站点配置文件</strong>中找到<code>skip_render:</code>修改：</p>
<pre><code class=""yml"">skip_render:
  - README.md
  - CNAME
  - baidu_verify_XXXXXXXXXX.html #下载的文件名</code></pre>
<p>3 <code>hexo g -d</code>重新渲染部署网站<br>4 点击百度站长文件验证步骤3，确认验证</p>
<h5>HTML标签验证</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660279?w=1234&amp;h=808"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>1 把图中马赛克部分的<code>token</code>复制下来<br>2 打开<strong>主题配置文件</strong>，搜索<code>site_verification</code>，修改：</p>
<pre><code class=""yml""># Google Webmaster tools verification setting
# See: https://www.google.com/webmasters/
google_site_verification:

baidu_site_verification:{your token}</code></pre>
<p>3 保存重新渲染部署网站即可</p>
<h5>CNAME验证</h5>
<p>对于已经绑定域名的站点，这种方式最简单！</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660280?w=1195&amp;h=783"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660281?w=1367&amp;h=134"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>主机记录填入马赛克部分（<code>token</code>），保存即可。</p>
<h4>google收录</h4>
<p>推荐HTML标签验证，具体同百度收录部分。</p>

<hr>
<h3>添加站点地图sitemap</h3>
<p>安装<code>hexo</code>的<code>sitemap</code>网站地图生成插件:</p>
<pre><code class=""bash"">$ npm install hexo-generator-sitemap --save
$ npm install hexo-generator-baidu-sitemap --save</code></pre>
<p>在<strong>站点配置文件</strong>中添加如下代码:</p>
<pre><code class=""yml"">sitemap:
  path: sitemap.xml
baidusitemap: 
  path: baidusitemap.xml</code></pre>
<p>配置成功后，会生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。<br>百度站长管理--&gt;链接提交：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660282?w=1287&amp;h=649"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Google站长管理--&gt;站点地图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660283?w=1621&amp;h=378"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>百度主动推送</h3>
<p>安装主动推送插件：</p>
<pre><code class=""bash"">$ npm install hexo-baidu-url-submit --save</code></pre>
<p>在<strong>站点配置文件</strong>中添加以下内容：</p>
<pre><code class=""yml"">baidu_url_submit:
  count: 3 ## 比如3，代表提交最新的三个链接
  host: alvabill.ml ## 在百度站长平台中注册的域名
  token: {your token} ## 请注意这是您的秘钥，请不要发布在公众仓库里!
  path: baidu_urls.txt ## 文本文档的地址，新链接会保存在此文本文档里</code></pre>
<p><code>token</code>位置：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660284?w=1227&amp;h=564"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>另外在<strong>站点配置文件</strong>中确认<code>url</code>值是否为百度站长平台注册的域名，然后添加一个新的deploy的类型：</p>
<pre><code class=""yml"">deploy:
- type: baidu_url_submitter  ##新添加
- type: git
  repository: git@git.coding.net:Alvabill/Alvabill.git
  branch: master</code></pre>
<p>把<strong>主题配置文件</strong>中的<code>baidu_push</code>设置为<code>true</code>，重新渲染部署即可。</p>

<hr>
<h3>SEO</h3>
<h4>更改首页标题格式</h4>
<p>打开<code>\themes\next\layout\index.swig</code>文件，找到以下代码：</p>
<pre><code>{% block title %} 
    ...
{% endblock %}</code></pre>
<p>把它改成：</p>
<pre><code>{% block title %}
  {{ theme.keywords }} - {{ config.title }} - {{ theme.description }}
{% endblock %}</code></pre>
<h4>修改文章链接</h4>
<p>hexo默认文章链接太长，不利于SEO，建议修改为<code>domain/postname</code>的形式:</p>
<pre><code class=""yml"">#permalink: :year/:month/:day/:title/
permalink: :title/</code></pre>

<hr>
<h3>七牛云存储图片</h3>
<p>进入<a href=""https://www.qiniu.com/"" rel=""nofollow noreferrer"">七牛官网</a>注册账号<br>进入管理控制台，新建对象存储空间：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660285?w=1881&amp;h=869"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660286?w=1910&amp;h=764"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图片上传和使用：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013660287?w=1772&amp;h=881"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>博客中的图片可以通过别的Markdown编辑平台（例如小书匠）即时上传到绑定的七牛云上边，加速站点的同时方便博客迁移。</blockquote>

<hr>
<h3>更改默认Google字体库</h3>
<p>用国内的CDN库来替代主题中的google字体库，到<strong>站点配置文件</strong>中设置默认字体库：</p>
<pre><code>host: fonts.useso.com</code></pre>
<h2>后记</h2>
<p>很折腾不过也还是收获满满，期间了解到了网上非常多的资源站点以及插件站点，开启了一种新的项目思路，可以说这期间的折腾都非常值得的了，而且做这么一个博客网站除了赏心悦目外最要紧的是，起到了一个很好的督促写作的功能，也象征着个人的博客生涯正式开启，说到写博客吧，一是记录二是分享，更多的还是希望和更多的人交流，希望在这个互联网时代和大家多交流学习共同进步，学无止境，继续加油。</p>

                ", hexo搭建个人博客--SEO和站点加速,1531977721,482,1,648,1,1,https://segmentfault.com/a/1190000013660273
43,1,0,7,"
                    
<p>webpack是现代前端开发中最火的模块打包工具，只需要通过简单的配置，便可以完成模块的加载和打包。那它是怎么做到通过对一些插件的配置，便可以轻松实现对代码的构建呢？</p>
<h3>webpack的配置</h3>
<pre><code class=""javascript"">const path = require('path');
module.exports = {
  entry: ""./app/entry"", // string | object | array
  // Webpack打包的入口
  output: {  // 定义webpack如何输出的选项
    path: path.resolve(__dirname, ""dist""), // string
    // 所有输出文件的目标路径
    filename: ""[chunkhash].js"", // string
    // 「入口(entry chunk)」文件命名模版
    publicPath: ""/assets/"", // string
    // 构建文件的输出目录
    /* 其它高级配置 */
  },
  module: {  // 模块相关配置
    rules: [ // 配置模块loaders，解析规则
      {
        test: /\.jsx?$/,  // RegExp | string
        include: [ // 和test一样，必须匹配选项
          path.resolve(__dirname, ""app"")
        ],
        exclude: [ // 必不匹配选项（优先级高于test和include）
          path.resolve(__dirname, ""app/demo-files"")
        ],
        loader: ""babel-loader"", // 模块上下文解析
        options: { // loader的可选项
          presets: [""es2015""]
        },
      },
  },
  resolve: { //  解析模块的可选项
    modules: [ // 模块的查找目录
      ""node_modules"",
      path.resolve(__dirname, ""app"")
    ],
    extensions: ["".js"", "".json"", "".jsx"", "".css""], // 用到的文件的扩展
    alias: { // 模块别名列表
      ""module"": ""new-module""
      },
  },
  devtool: ""source-map"", // enum
  // 为浏览器开发者工具添加元数据增强调试
  plugins: [ // 附加插件列表
    // ...
  ],
}</code></pre>
<p>从上面我们可以看到，webpack配置中需要理解几个核心的概念<code>Entry</code> 、<code>Output</code>、<code>Loaders</code> 、<code>Plugins</code>、 <code>Chunk</code></p>
<ul>
<li>Entry：指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库</li>
<li>Output：告诉webpack如何命名输出的文件以及输出的目录</li>
<li>Loaders：由于webpack只能处理javascript，所以我们需要对一些非js文件处理成webpack能够处理的模块，比如sass文件</li>
<li>Plugins：<code>Loaders</code>将各类型的文件处理成webpack能够处理的模块，<code>plugins</code>有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。比如对js文件进行压缩优化的<code>UglifyJsPlugin</code>插件</li>
<li>Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用<code>CommonsChunkPlugin</code>将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中<code>CommonsChunkPlugin</code>被废弃，使用<code>SplitChunksPlugin</code>
</li>
</ul>
<h3>webpack详解</h3>
<p>读到这里，或许你对webpack有一个大概的了解，那webpack 是怎么运行的呢？我们都知道，webpack是高度复杂抽象的插件集合，理解webpack的运行机制，对于我们日常定位构建错误以及写一些插件处理构建任务有很大的帮助。</p>
<h4>不得不说的tapable</h4>
<p>webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是<a href=""https://github.com/webpack/tapable"" rel=""nofollow noreferrer"">Tapable</a>，webpack中最核心的负责编译的<code>Compiler</code>和负责创建bundles的<code>Compilation</code>都是Tapable的实例。在Tapable1.0之前，也就是webpack3及其以前使用的Tapable，提供了包括</p>
<ul>
<li>
<code>plugin(name:string, handler:function)</code>注册插件到Tapable对象中</li>
<li>
<code>apply(…pluginInstances: (AnyPlugin|function)[])</code>调用插件的定义，将事件监听器注册到Tapable实例注册表中</li>
<li>
<code>applyPlugins*(name:string, …)</code>多种策略细致地控制事件的触发，包括<code>applyPluginsAsync</code>、<code>applyPluginsParallel</code>等方法实现对事件触发的控制，实现</li>
</ul>
<p>（1）多个事件连续顺序执行<br>（2）并行执行<br>（3）异步执行<br>（4）一个接一个地执行插件，前面的输出是后一个插件的输入的瀑布流执行顺序<br>（5）在允许时停止执行插件，即某个插件返回了一个<code>undefined</code>的值，即退出执行<br>我们可以看到，Tapable就像nodejs中<code>EventEmitter</code>,提供对事件的注册<code>on</code>和触发<code>emit</code>,理解它很重要，看个栗子：比如我们来写一个插件</p>
<pre><code class=""javascript"">function CustomPlugin() {}
CustomPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', pluginFunction);
}</code></pre>
<p>在webpack的生命周期中会适时的执行</p>
<pre><code class=""javascript"">this.apply*(""emit"",options)</code></pre>
<p>当然上面提到的Tapable都是1.0版本之前的，如果想深入学习，可以查看<a href=""https://segmentfault.com/a/1190000008060440"" rel=""nofollow noreferrer"">Tapable 和 事件流</a><br>那1.0的Tapable又是什么样的呢？1.0版本发生了巨大的改变，不再是此前的通过<code>plugin</code>注册事件，通过<code>applyPlugins*</code>触发事件调用，那1.0的Tapable是什么呢？</p>
<blockquote>暴露出很多的钩子，可以使用它们为插件创建钩子函数</blockquote>
<pre><code class=""javascript"">const {
    SyncHook,
    SyncBailHook,
    SyncWaterfallHook,
    SyncLoopHook,
    AsyncParallelHook,
    AsyncParallelBailHook,
    AsyncSeriesHook,
    AsyncSeriesBailHook,
    AsyncSeriesWaterfallHook
 } = require(""tapable"");</code></pre>
<p>我们来看看 怎么使用。</p>
<pre><code class=""javascript"">class Order {
    constructor() {
        this.hooks = { //hooks
            goods: new SyncHook(['goodsId', 'number']),
            consumer: new AsyncParallelHook(['userId', 'orderId'])
        }
    }

    queryGoods(goodsId, number) {
        this.hooks.goods.call(goodsId, number);
    }

    consumerInfoPromise(userId, orderId) {
        this.hooks.consumer.promise(userId, orderId).then(() =&gt; {
            //TODO
        })
    }

    consumerInfoAsync(userId, orderId) {
        this.hooks.consumer.callAsync(userId, orderId, (err, data) =&gt; {
            //TODO
        })
    }
}</code></pre>
<p>对于所有的hook的构造函数均接受一个可选的string类型的数组</p>
<pre><code class=""javascript"">const hook = new SyncHook([""arg1"", ""arg2"", ""arg3""]);</code></pre>
<pre><code class=""javascript"">// 调用tap方法注册一个consument
order.hooks.goods.tap('QueryPlugin', (goodsId, number) =&gt; {
    return fetchGoods(goodsId, number);
})
// 再添加一个
order.hooks.goods.tap('LoggerPlugin', (goodsId, number) =&gt; {
    logger(goodsId, number);
})

// 调用
order.queryGoods('10000000', 1)</code></pre>
<p>对于一个 <code>SyncHook</code>,我们通过<code>tap</code>来添加消费者，通过<code>call</code>来触发钩子的顺序执行。</p>
<p>对于一个非<code>sync*</code>类型的钩子，即<code>async*</code>类型的钩子，我们还可以通过其它方式注册消费者和调用</p>
<pre><code class=""javascript"">// 注册一个sync 钩子
order.hooks.consumer.tap('LoggerPlugin', (userId, orderId) =&gt; {
   logger(userId, orderId);
})

order.hooks.consumer.tapAsync('LoginCheckPlugin', (userId, orderId, callback) =&gt; {
    LoginCheck(userId, callback);
})

order.hooks.consumer.tapPromise('PayPlugin', (userId, orderId) =&gt; {
    return Promise.resolve();
})

// 调用
// 返回Promise
order.consumerInfoPromise('user007', '1024');

//回调函数
order.consumerInfoAsync('user007', '1024')</code></pre>
<p>通过上面的栗子，你可能已经大致了解了<code>Tapable</code>的用法，它的用法</p>
<ul>
<li>插件注册数量</li>
<li>插件注册的类型（sync, async, promise）</li>
<li>调用的方式（sync, async, promise）</li>
<li>实例钩子的时候参数数量</li>
<li>是否使用了<code>interception</code>
</li>
</ul>
<h4>Tapable详解</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013657047"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Alt text"" title=""Alt text""></span><br>对于<code>Sync*</code>类型的钩子来说。</p>
<ul>
<li>注册在该钩子下面的插件的执行顺序都是顺序执行。</li>
<li>只能使用<code>tap</code>注册，不能使用<code>tapPromise</code>和<code>tapAsync</code>注册</li>
</ul>
<pre><code class=""javascript"">// 所有的钩子都继承于Hook
class Sync* extends Hook { 
    tapAsync() { // Sync*类型的钩子不支持tapAsync
        throw new Error(""tapAsync is not supported on a Sync*"");
    }
    tapPromise() {// Sync*类型的钩子不支持tapPromise
        throw new Error(""tapPromise is not supported on a Sync*"");
    }
    compile(options) { // 编译代码来按照一定的策略执行Plugin
        factory.setup(this, options);
        return factory.create(options);
    }
}</code></pre>
<p>对于<code>Async*</code>类型钩子</p>
<ul><li>支持<code>tap</code>、<code>tapPromise</code>、<code>tapAsync</code>注册</li></ul>
<pre><code class=""javascript"">class AsyncParallelHook extends Hook {
    constructor(args) {
        super(args);
        this.call = this._call = undefined;
    }

    compile(options) {
        factory.setup(this, options);
        return factory.create(options);
    }
}</code></pre>
<pre><code class=""javascript"">class Hook {
    constructor(args) {
        if(!Array.isArray(args)) args = [];
        this._args = args; // 实例钩子的时候的string类型的数组
        this.taps = []; // 消费者
        this.interceptors = []; // interceptors
        this.call = this._call =  // 以sync类型方式来调用钩子
        this._createCompileDelegate(""call"", ""sync"");
        this.promise = 
        this._promise = // 以promise方式
        this._createCompileDelegate(""promise"", ""promise"");
        this.callAsync = 
        this._callAsync = // 以async类型方式来调用
        this._createCompileDelegate(""callAsync"", ""async"");
        this._x = undefined; // 
    }

    _createCall(type) {
        return this.compile({
            taps: this.taps,
            interceptors: this.interceptors,
            args: this._args,
            type: type
        });
    }

    _createCompileDelegate(name, type) {
        const lazyCompileHook = (...args) =&gt; {
            this[name] = this._createCall(type);
            return this[name](...args);
        };
        return lazyCompileHook;
    }
    // 调用tap 类型注册
    tap(options, fn) {
        // ...
        options = Object.assign({ type: ""sync"", fn: fn }, options);
        // ...
        this._insert(options);  // 添加到 this.taps中
    }
    // 注册 async类型的钩子
    tapAsync(options, fn) {
        // ...
        options = Object.assign({ type: ""async"", fn: fn }, options);
        // ...
        this._insert(options); // 添加到 this.taps中
    }
    注册 promise类型钩子
    tapPromise(options, fn) {
        // ...
        options = Object.assign({ type: ""promise"", fn: fn }, options);
        // ...
        this._insert(options); // 添加到 this.taps中
    }
    
}</code></pre>
<p>每次都是调用<code>tap</code>、<code>tapSync</code>、<code>tapPromise</code>注册不同类型的插件钩子，通过调用<code>call</code>、<code>callAsync</code> 、<code>promise</code>方式调用。其实调用的时候为了按照一定的执行策略执行，调用<code>compile</code>方法快速编译出一个方法来执行这些插件。</p>
<pre><code class=""javascript"">const factory = new Sync*CodeFactory();
class Sync* extends Hook { 
    // ...
    compile(options) { // 编译代码来按照一定的策略执行Plugin
        factory.setup(this, options);
        return factory.create(options);
    }
}

class Sync*CodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err) =&gt; onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}</code></pre>
<p><code>compile</code>中调用<code>HookCodeFactory#create</code>方法编译生成执行代码。</p>
<pre><code class=""javascript"">
class HookCodeFactory {
    constructor(config) {
        this.config = config;
        this.options = undefined;
    }

    create(options) {
        this.init(options);
        switch(this.options.type) {
            case ""sync"":  // 编译生成sync, 结果直接返回
                return new Function(this.args(), 
                ""\""use strict\"";\n"" + this.header() + this.content({
                    // ...
                    onResult: result =&gt; `return ${result};\n`,
                    // ...
                }));
            case ""async"": // async类型, 异步执行，最后将调用插件执行结果来调用callback,
                return new Function(this.args({
                    after: ""_callback""
                }), ""\""use strict\"";\n"" + this.header() + this.content({
                    // ...
                    onResult: result =&gt; `_callback(null, ${result});\n`,
                    onDone: () =&gt; ""_callback();\n""
                }));
            case ""promise"": // 返回promise类型，将结果放在resolve中
                // ...
                code += ""return new Promise((_resolve, _reject) =&gt; {\n"";
                code += ""var _sync = true;\n"";
                code += this.header();
                code += this.content({
                    // ...
                    onResult: result =&gt; `_resolve(${result});\n`,
                    onDone: () =&gt; ""_resolve();\n""
                });
                // ...
                return new Function(this.args(), code);
        }
    }
    // callTap 就是执行一些插件，并将结果返回
    callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = """";
        let hasTapCached = false;
        // ...
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
        const tap = this.options.taps[tapIndex];
        switch(tap.type) {
            case ""sync"":
                // ...
                if(onResult) {
                    code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                        before: tap.context ? ""_context"" : undefined
                    })});\n`;
                } else {
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? ""_context"" : undefined
                    })});\n`;
                }
                
                if(onResult) { // 结果透传
                    code += onResult(`_result${tapIndex}`);
                }
                if(onDone) { // 通知插件执行完毕，可以执行下一个插件
                    code += onDone();
                }
                break;
            case ""async"": //异步执行，插件运行完后再将结果通过执行callback透传
                let cbCode = """";
                if(onResult)
                    cbCode += `(_err${tapIndex}, _result${tapIndex}) =&gt; {\n`;
                else
                    cbCode += `_err${tapIndex} =&gt; {\n`;
                cbCode += `if(_err${tapIndex}) {\n`;
                cbCode += onError(`_err${tapIndex}`);
                cbCode += ""} else {\n"";
                if(onResult) {
                    cbCode += onResult(`_result${tapIndex}`);
                }
                
                cbCode += ""}\n"";
                cbCode += ""}"";
                code += `_fn${tapIndex}(${this.args({
                    before: tap.context ? ""_context"" : undefined,
                    after: cbCode //cbCode将结果透传
                })});\n`;
                break;
            case ""promise"": // _fn${tapIndex} 就是第tapIndex 个插件，它必须是个Promise类型的插件
                code += `var _hasResult${tapIndex} = false;\n`;
                code += `_fn${tapIndex}(${this.args({
                    before: tap.context ? ""_context"" : undefined
                })}).then(_result${tapIndex} =&gt; {\n`;
                code += `_hasResult${tapIndex} = true;\n`;
                if(onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
            // ...
                break;
        }
        return code;
    }
    // 按照插件的注册顺序，按照顺序递归调用执行插件
    callTapsSeries({ onError, onResult, onDone, rethrowIfPossible }) {
        // ...
        const firstAsync = this.options.taps.findIndex(t =&gt; t.type !== ""sync"");
        const next = i =&gt; {
            // ...
            const done = () =&gt; next(i + 1);
            // ...
            return this.callTap(i, {
                // ...
                onResult: onResult &amp;&amp; ((result) =&gt; {
                    return onResult(i, result, done, doneBreak);
                }),
                // ...
            });
        };
        return next(0);
    }

    callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        
        const syncOnly = this.options.taps.every(t =&gt; t.type === ""sync"");
        let code = """";
        if(!syncOnly) {
            code += ""var _looper = () =&gt; {\n"";
            code += ""var _loopAsync = false;\n"";
        }
        code += ""var _loop;\n"";
        code += ""do {\n"";
        code += ""_loop = false;\n"";
        // ...
        code += this.callTapsSeries({
            // ...
            onResult: (i, result, next, doneBreak) =&gt; { // 一旦某个插件返回不为undefined,  即一只调用某个插件执行，如果为undefined,开始调用下一个
                let code = """";
                code += `if(${result} !== undefined) {\n`;
                code += ""_loop = true;\n"";
                if(!syncOnly)
                    code += ""if(_loopAsync) _looper();\n"";
                code += doneBreak(true);
                code += `} else {\n`;
                code += next();
                code += `}\n`;
                return code;
            },
            // ...
        })
        code += ""} while(_loop);\n"";
        // ...
        return code;
    }
    // 并行调用插件执行
    callTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run) =&gt; run() }) {
        // ...
        // 遍历注册都所有插件，并调用
        for(let i = 0; i &lt; this.options.taps.length; i++) {
            // ...
            code += ""if(_counter &lt;= 0) break;\n"";
            code += onTap(i, () =&gt; this.callTap(i, {
                // ...
                onResult: onResult &amp;&amp; ((result) =&gt; {
                    let code = """";
                    code += ""if(_counter &gt; 0) {\n"";
                    code += onResult(i, result, done, doneBreak);
                    code += ""}\n"";
                    return code;
                }),
                // ...
            }), done, doneBreak);
        }
        // ...
        return code;
    }
}</code></pre>
<p>在<code>HookCodeFactory#create</code>中调用到<code>content</code>方法，此方法将按照此钩子的执行策略，调用不同的方法来执行编译 生成最终的代码。</p>
<ul><li>SyncHook中调用<code>callTapsSeries</code>编译生成最终执行插件的函数，<code>callTapsSeries</code>做的就是将插件列表中插件按照注册顺序遍历执行。</li></ul>
<pre><code class=""javascript"">class SyncHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err) =&gt; onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}</code></pre>
<ul><li>SyncBailHook中当一旦某个返回值结果不为<code>undefined</code>便结束执行列表中的插件</li></ul>
<pre><code class=""javascript""> class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            // ...
            onResult: (i, result, next) =&gt; `if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
            // ...
        });
    }
}</code></pre>
<ul><li>SyncWaterfallHook中上一个插件执行结果当作下一个插件的入参</li></ul>
<pre><code class=""javascript"">class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            // ...
            onResult: (i, result, next) =&gt; {
                let code = """";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: () =&gt; onResult(this._args[0]),
        });
    }
}</code></pre>
<ul><li>AsyncParallelHook调用<code>callTapsParallel</code>并行执行插件</li></ul>
<pre><code class=""javascript"">class AsyncParallelHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsParallel({
            onError: (i, err, done, doneBreak) =&gt; onError(err) + doneBreak(true),
            onDone
        });
    }
}</code></pre>
<h3>webpack流程篇</h3>
<p>本文关于webpack 的流程讲解是基于webpack4的。</p>
<h4>webpack 入口文件</h4>
<p>从webpack项目的package.json文件中我们找到了入口执行函数，在函数中引入webpack，那么入口将会是<code>lib/webpack.js</code>,而如果在shell中执行，那么将会走到<code>./bin/webpack.js</code>,我们就以<code>lib/webpack.js</code>为入口开始吧！</p>
<pre><code class=""json"">{
  ""name"": ""webpack"",
  ""version"": ""4.1.1"",
  ...
  ""main"": ""lib/webpack.js"",
  ""web"": ""lib/webpack.web.js"",
  ""bin"": ""./bin/webpack.js"",
  ...
  }</code></pre>
<h4>webpack入口</h4>
<pre><code class=""javascript"">const webpack = (options, callback) =&gt; {
    // ...
    // 验证options正确性
    // 预处理options
    options = new WebpackOptionsDefaulter().process(options); // webpack4的默认配置
    compiler = new Compiler(options.context); // 实例Compiler
    // ...
    // 若options.watch === true &amp;&amp; callback 则开启watch线程
    compiler.watch(watchOptions, callback);
    compiler.run(callback);
    return compiler;
};</code></pre>
<p>webpack 的入口文件其实就实例了<code>Compiler</code>并调用了<code>run</code>方法开启了编译，webpack的编译都按照下面的钩子调用顺序执行。</p>
<ul>
<li>before-run 清除缓存</li>
<li>run 注册缓存数据钩子</li>
<li>before-compile</li>
<li>compile 开始编译</li>
<li>make 从入口分析依赖以及间接依赖模块，创建模块对象</li>
<li>build-module 模块构建</li>
<li>seal 构建结果封装， 不可再更改</li>
<li>after-compile 完成构建，缓存数据</li>
<li>emit 输出到dist目录</li>
</ul>
<h4>编译&amp;构建流程</h4>
<p>webpack中负责构建和编译都是<code>Compilation</code></p>
<pre><code class=""javascript"">class Compilation extends Tapable {
    constructor(compiler) {
        super();
        this.hooks = {
            // hooks
        };
        // ...
        this.compiler = compiler;
        // ...
        // template
        this.mainTemplate = new MainTemplate(this.outputOptions);
        this.chunkTemplate = new ChunkTemplate(this.outputOptions);
        this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(
            this.outputOptions
        );
        this.runtimeTemplate = new RuntimeTemplate(
            this.outputOptions,
            this.requestShortener
        );
        this.moduleTemplates = {
            javascript: new ModuleTemplate(this.runtimeTemplate),
            webassembly: new ModuleTemplate(this.runtimeTemplate)
        };

        // 构建生成的资源
        this.chunks = [];
        this.chunkGroups = [];
        this.modules = [];
        this.additionalChunkAssets = [];
        this.assets = {};
        this.children = [];
        // ...
    }
    // 
    buildModule(module, optional, origin, dependencies, thisCallback) {
        // ...
        // 调用module.build方法进行编译代码，build中 其实是利用acorn编译生成AST
        this.hooks.buildModule.call(module);
        module.build(/**param*/);
    }
    // 将模块添加到列表中，并编译模块
    _addModuleChain(context, dependency, onModule, callback) {
            // ...
            // moduleFactory.create创建模块，这里会先利用loader处理文件，然后生成模块对象
            moduleFactory.create(
                {
                    contextInfo: {
                        issuer: """",
                        compiler: this.compiler.name
                    },
                    context: context,
                    dependencies: [dependency]
                },
                (err, module) =&gt; {
                    const addModuleResult = this.addModule(module);
                    module = addModuleResult.module;
                    onModule(module);
                    dependency.module = module;
                    
                    // ...
                    // 调用buildModule编译模块
                    this.buildModule(module, false, null, null, err =&gt; {});
                }
        });
    }
    // 添加入口模块，开始编译&amp;构建
    addEntry(context, entry, name, callback) {
        // ...
        this._addModuleChain( // 调用_addModuleChain添加模块
            context,
            entry,
            module =&gt; {
                this.entries.push(module);
            },
            // ...
        );
    }

    
    seal(callback) {
        this.hooks.seal.call();

        // ...
        const chunk = this.addChunk(name);
        const entrypoint = new Entrypoint(name);
        entrypoint.setRuntimeChunk(chunk);
        entrypoint.addOrigin(null, name, preparedEntrypoint.request);
        this.namedChunkGroups.set(name, entrypoint);
        this.entrypoints.set(name, entrypoint);
        this.chunkGroups.push(entrypoint);

        GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);
        GraphHelpers.connectChunkAndModule(chunk, module);

        chunk.entryModule = module;
        chunk.name = name;

         // ...
        this.hooks.beforeHash.call();
        this.createHash();
        this.hooks.afterHash.call();
        this.hooks.beforeModuleAssets.call();
        this.createModuleAssets();
        if (this.hooks.shouldGenerateChunkAssets.call() !== false) {
            this.hooks.beforeChunkAssets.call();
            this.createChunkAssets();
        }
        // ...
    }


    createHash() {
        // ...
    }
    
    // 生成 assets 资源并 保存到 Compilation.assets 中 给webpack写插件的时候会用到
    createModuleAssets() {
        for (let i = 0; i &lt; this.modules.length; i++) {
            const module = this.modules[i];
            if (module.buildInfo.assets) {
                for (const assetName of Object.keys(module.buildInfo.assets)) {
                    const fileName = this.getPath(assetName);
                    this.assets[fileName] = module.buildInfo.assets[assetName]; 
                    this.hooks.moduleAsset.call(module, fileName);
                }
            }
        }
    }

    createChunkAssets() {
     // ...
    }
}</code></pre>
<p>在webpack <code>make</code>钩子中, <code>tapAsync</code>注册了一个<code>DllEntryPlugin</code>, 就是将入口模块通过调用<code>compilation.addEntry</code>方法将所有的入口模块添加到编译构建队列中，开启编译流程。</p>
<pre><code class=""javascript"">compiler.hooks.make.tapAsync(""DllEntryPlugin"", (compilation, callback) =&gt; {
        compilation.addEntry(
            this.context,
            new DllEntryDependency(
                this.entries.map((e, idx) =&gt; {
                    const dep = new SingleEntryDependency(e);
                    dep.loc = `${this.name}:${idx}`;
                    return dep;
                }),
                this.name
            ),
            // ...
        );
    });</code></pre>
<p>随后在<code>addEntry</code> 中调用<code>_addModuleChain</code>开始编译。在<code>_addModuleChain</code>首先会生成模块，最后构建。</p>
<pre><code class=""javascript"">class NormalModuleFactory extends Tapable {
    // ...
    create(data, callback) {
        // ...
        this.hooks.beforeResolve.callAsync(
            {
                contextInfo,
                resolveOptions,
                context,
                request,
                dependencies
            },
            (err, result) =&gt; {
                if (err) return callback(err);

                // Ignored
                if (!result) return callback();
                // factory 钩子会触发 resolver 钩子执行，而resolver钩子中会利用acorn 处理js生成AST，再利用acorn处理前，会使用loader加载文件
                const factory = this.hooks.factory.call(null);

                factory(result, (err, module) =&gt; {
                    if (err) return callback(err);

                    if (module &amp;&amp; this.cachePredicate(module)) {
                        for (const d of dependencies) {
                            d.__NormalModuleFactoryCache = module;
                        }
                    }

                    callback(null, module);
                });
            }
        );
    }
}</code></pre>
<p>在编译完成后，调用<code>compilation.seal</code>方法封闭，生成资源，这些资源保存在<code>compilation.assets</code>, <code>compilation.chunk</code>, 在给webpack写插件的时候会用到</p>
<pre><code class=""javascript"">class Compiler extends Tapable {
    constructor(context) {
        super();
        this.hooks = {
            beforeRun: new AsyncSeriesHook([""compilation""]),
            run: new AsyncSeriesHook([""compilation""]),
            emit: new AsyncSeriesHook([""compilation""]),
            afterEmit: new AsyncSeriesHook([""compilation""]),
            compilation: new SyncHook([""compilation"", ""params""]),
            beforeCompile: new AsyncSeriesHook([""params""]),
            compile: new SyncHook([""params""]),
            make: new AsyncParallelHook([""compilation""]),
            afterCompile: new AsyncSeriesHook([""compilation""]),
            // other hooks
        };
        // ...
    }

    run(callback) {
        const startTime = Date.now();

        const onCompiled = (err, compilation) =&gt; {
            // ...

            this.emitAssets(compilation, err =&gt; {
                if (err) return callback(err);

                if (compilation.hooks.needAdditionalPass.call()) {
                    compilation.needAdditionalPass = true;

                    const stats = new Stats(compilation);
                    stats.startTime = startTime;
                    stats.endTime = Date.now();
                    this.hooks.done.callAsync(stats, err =&gt; {
                        if (err) return callback(err);

                        this.hooks.additionalPass.callAsync(err =&gt; {
                            if (err) return callback(err);
                            this.compile(onCompiled);
                        });
                    });
                    return;
                }
                // ...
            });
        };

        this.hooks.beforeRun.callAsync(this, err =&gt; {
            if (err) return callback(err);
            this.hooks.run.callAsync(this, err =&gt; {
                if (err) return callback(err);

                this.readRecords(err =&gt; {
                    if (err) return callback(err);

                    this.compile(onCompiled);
                });
            });
        });
    }
    // 输出文件到构建目录
    emitAssets(compilation, callback) {
        // ...
        this.hooks.emit.callAsync(compilation, err =&gt; {
            if (err) return callback(err);
            outputPath = compilation.getPath(this.outputPath);
            this.outputFileSystem.mkdirp(outputPath, emitFiles);
        });
    }
    
    newCompilationParams() {
        const params = {
            normalModuleFactory: this.createNormalModuleFactory(),
            contextModuleFactory: this.createContextModuleFactory(),
            compilationDependencies: new Set()
        };
        return params;
    }

    compile(callback) {
        const params = this.newCompilationParams();
        this.hooks.beforeCompile.callAsync(params, err =&gt; {
            if (err) return callback(err);
            this.hooks.compile.call(params);
            const compilation = this.newCompilation(params);

            this.hooks.make.callAsync(compilation, err =&gt; {
                if (err) return callback(err);
                compilation.finish();
                // make 钩子执行后，调用seal生成资源
                compilation.seal(err =&gt; {
                    if (err) return callback(err);
                    this.hooks.afterCompile.callAsync(compilation, err =&gt; {
                        if (err) return callback(err);
                        // emit, 生成最终文件
                        return callback(null, compilation);
                    });
                });
            });
        });
    }
}</code></pre>
<h4>最后输出</h4>
<p>在<code>seal</code>执行后，便会调用<code>emit</code>钩子，根据webpack config文件的output配置的path属性，将文件输出到指定的path.</p>
<h3>最后</h3>
<p>腾讯IVWEB团队的工程化解决方案<a href=""https://github.com/feflow/feflow"" rel=""nofollow noreferrer"">feflow</a>已经开源：Github主页：<a href=""https://github.com/feflow/feflow"" rel=""nofollow noreferrer"">https://github.com/feflow/feflow</a></p>
<p>如果对您的团队或者项目有帮助，请给个Star支持一下哈～</p>

                ", webpack详解,1531977722,452,1,704,1,1,https://segmentfault.com/a/1190000013657042
44,1,0,7,"
                    
<h1>chrome插件-推荐，好用，不错，必备</h1>
<p>俗话说chrome没有插件只有四成能力，可见插件才是chrome的牛逼之处。</p>
<pre><code>前提：要想直接使用Google的应用商店需要先本地添加：

谷歌访问助手插件：（下载地址）http://www.ggfwzs.com</code></pre>
<hr>
<h3>大众常用的插件列表如下：</h3>
<blockquote>1、扩展管理器：Extension Manager</blockquote>
<pre><code>相对比较简洁的一款管理工具：能管理你下载的所有插件，在下载前先搞它，方便管理。</code></pre>
<blockquote>2、广告拦截：AdBlock</blockquote>
<pre><code>拦截广告还可以。平时看网站比较规矩所以基本用不上，你懂的。</code></pre>
<blockquote>3、多点高亮查找：Multi-highlight</blockquote>
<pre><code>空格输入多个关键词，每个关键词都能以不同的颜色显示！</code></pre>
<blockquote>4、稍后阅读：Save to Pocket</blockquote>
<pre><code>个人用这个比较习惯，其他的太麻烦，这个比较简单。“轻便”是我对插件的态度。
任何一个网页，你只要鼠标右键 --&gt; Save To Pocket.即可完成收藏。</code></pre>
<blockquote>5、一键收纳所有Chrome标签：OneTab</blockquote>
<pre><code>开了很多网页，舍不得关，不关又太多占地方，消耗机器内存，用这个神器吧。
一键把你所有的标签收容，一键把所有标签都恢复，总之方便实用，不要太爱它。</code></pre>
<blockquote>6、翻译在哪：划词翻译</blockquote>
<pre><code>界面和名字low了点，支持谷歌，百度，有道，必应四大翻译引擎。
个人感觉mac比windows下好用。还是蛮轻便的。</code></pre>
<blockquote>7、截图&amp;录屏：网页截图:注释&amp;录屏</blockquote>
<pre><code>还是那句话，名字low了点，但是接地气，就跟它的功能一样。个人感觉比FireShot好用多了。
操作都差不多，FireShot东西太少了。还是这个好。</code></pre>
<blockquote>8、维基百科：Wikiwand: Wikipedia Modernized</blockquote>
<pre><code>骚年，除了百度百科，不妨在参考下维基百科，与世界接轨很重要。
老司机传授：如果想看英语你只管用。
如果想看中文：记得在插件里设置语种：Chinese [随便找个wiki文章打开就能切换语种]</code></pre>
<blockquote>9、桌面似的任务管理:Momentum</blockquote>
<pre><code>装逼利器！当你New Tab的时候，每次都有不同的背景，有时钟，还有你当天的任务列表。
总之还有很多功能，你可以自己探索，功能很强大。Focus，Quote,Todo,天气等等。
开启天气的话，记得允许定位。然后在右上角：写个：北京 试试。</code></pre>
<blockquote>10、另一款任务清单：滴答清单</blockquote>
<pre><code>如果觉得Momentum的任务清单过于简单，那么可以选择这个。有点像APP的感觉。
整体用起来还不错。还能登陆，保持同步。</code></pre>
<blockquote>11、图片自动放大：Imagus</blockquote>
<pre><code>鼠标停留几秒，就能跟淘宝的那种看大图一个意思。个人感觉像鸡肋，查看图片细节有用。</code></pre>
<hr>
<h3>程序员哥哥们的利器（一）</h3>
<blockquote>1、json工具：JSON-handle</blockquote>
<pre><code>写代码的屌丝一般都会用的那玩意。我喜欢绚的，“咔咔咔”的那玩意儿。</code></pre>
<blockquote>2、网页CSS提取：CSS Peeper</blockquote>
<pre><code>咱就喜欢这种认真搞插件的，相当不错的插件，有爱，符合时代。</code></pre>
<blockquote>3、把富文本弄成Markdown形式：Markdown Here</blockquote>
<pre><code>如果你真这么蛋疼，就用吧。要是我我才不会先弄成富文本，在转换成富文本。</code></pre>
<blockquote>4、github三神器之一：Octotree</blockquote>
<pre><code>三神器里的利剑了，屌丝码农们如果没用过，赶紧的吧。</code></pre>
<blockquote>5、分析网站的编程语言：Wappalyzer</blockquote>
<pre><code>不知道有用没用，如果你遇见不错的网站，可以看看他们都用了什么技术
通过这个小插件能看出来。就这点作用了吧。</code></pre>
<blockquote>6、vue神器：Vue.js devtools</blockquote>
<pre><code>这个不用多说了吧，搞vue的都知道。</code></pre>
<blockquote>7、测量网页元素的px和位置：Page Ruler</blockquote>
<pre><code>还不错，比较适合搞ps的或者产品经理吧。反正就是测量工具。</code></pre>
<blockquote>8、模拟请求：postman</blockquote>
<pre><code>个人感觉鸡肋，我直接下载的客户端，windows和mac都有。
不喜欢用客户端的可以用这个。</code></pre>
<blockquote>附录：Chrome清除 DNS 缓存 ；遇见有时候本应该打开的网页无法打开时使用。</blockquote>
<p>打开 Chrome 浏览器，在输入网址的地方输入 <code>chrome://net-internals/#dns</code>.<br>然后点击红色条右上角的下拉按键，点击 <code>Clear cache</code> 和 <code>Flush sockets</code> 两项即可清除，视频演示如下：</p>

                ", chrome常用插件-前端-后端-产品,1531977724,503,1,228,1,1,https://segmentfault.com/a/1190000013339953
45,1,0,7,"
                    
<p>由于你没有进行过特别的设定，所以<code>git</code>不管它是往<code>github</code>上传还是往你公司的服务器上传，都会以一个完全相同的身份上传，这有时候会造成困扰，比如说这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV3TF3?w=1235&amp;h=909"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>但其实这是我公司的服务器，我不想让它以<code>fengerzh</code>的身份上传，我想只有在我往<code>github</code>上传的时候才以<code>fengerzh</code>上传，而我往公司服务器上传的时候就以<code>zhangjing</code>的身份上传，那该怎么做呢？</p>
<p>最直接的方法是在你<code>git clone</code>下来的仓库里，有一个<code>.git</code>文件夹，<code>.git</code>文件夹里有一个<code>config</code>文件，在这个文件里写上</p>
<pre><code>[user]
    email = zhangjing@mydomain.com
    name = zhangjing</code></pre>
<p>就行了。</p>
<p>但问题是我有几十个仓库，不能一个一个设吧，而且万一我忘记了怎么办？所以我们需要有一些自动化的小工具来帮助我们完成这件事情。</p>
<p>首先，你要先建立这么一个文件夹：</p>
<pre><code>mkdir -p ~/.git-templates/hooks</code></pre>
<p>然后你要告诉<code>git</code>这个文件夹就是你的模板文件夹：</p>
<pre><code>git config --global init.templatedir ~/.git-templates</code></pre>
<p>再然后，你在这个文件夹里放上一个钩子文件：</p>
<pre><code>vi ~/.git-templates/hooks/post-checkout</code></pre>
<p>这个钩子文件的内容就是下面这样：</p>
<pre><code>#!/bin/bash

function warn {
  echo -e ""\n$1 Email and author not initialized in local config!""
}

email=""$(git config --local user.email)""
name=""$(git config --local user.name)""

if [[ $1 != ""0000000000000000000000000000000000000000"" || -n $email || -n $name ]]; then
  exit 0
fi

remote=""$([[ $(git remote | wc -l) -eq 1 ]] &amp;&amp; git remote || git remote | grep ""^origin$"")""

if [[ -z $remote ]]; then
  warn ""Failed to detect remote.""
  exit 0
fi

url=""$(git config --local remote.${remote}.url)""

if [[ ! -f ~/.git-clone-init ]]; then
cat &lt;&lt; INPUT &gt; ~/.git-clone-init
#!/bin/bash
case ""\$url"" in
  *@github.com:*    ) email=""""; name="""";;
  *//github.com/*   ) email=""""; name="""";;
esac
INPUT
  warn ""\nMissing file ~/.git-clone-init. Template created...""
  exit 0
fi
. ~/.git-clone-init

if [[ -z $name || -z $email ]]; then
  warn ""Failed to detect identity using ~/.git-clone-init.""
  exit 0
fi

git config --local user.email ""$email""
git config --local user.name ""$name""

echo -e ""\nIdentity set to $name &lt;$email&gt;""</code></pre>
<p>切记，一定要赋予这个文件可执行权限，否则你的钩子工作不起来：</p>
<pre><code>chmod +x ~/.git-templates/hooks/post-checkout</code></pre>
<p>接下来，你还要再建立另一个文件：</p>
<pre><code>vi ~/.git-clone-init</code></pre>
<p>这个文件的内容是像下面这样：</p>
<pre><code>case ""$url"" in
  *@github.com:*  ) email=""buzz.zhang@gmail.com"";    name=""fengerzh"";;
  *//github.com/* ) email=""buzz.zhang@gmail.com"";    name=""fengerzh"";;
  *@mydomain.com:*    ) email=""zhangjing@mydomain.com""; name=""zhangjing"";;
  *//mydomain.com/*   ) email=""zhangjing@mydomain.com""; name=""zhangjing"";;
esac</code></pre>
<p>在这里，我们指明了如果仓库来源是<code>github</code>的话我们用哪个用户，如果仓库来源是公司服务器的话又该用哪个用户。</p>
<p>做完了这些事，我们来重新<code>git clone</code>一下我们的仓库看看吧：</p>
<pre><code>$ git clone ssh://git@mydomain.com/source/ys.git
Cloning into 'ys'...
remote: Counting objects: 1003, done.
remote: Compressing objects: 100% (591/591), done.
remote: Total 1003 (delta 476), reused 506 (delta 221)
Receiving objects: 100% (1003/1003), 691.97 KiB | 1.71 MiB/s, done.
Resolving deltas: 100% (476/476), done.

Identity set to zhangjing &lt;zhangjing@mydomain.com&gt;</code></pre>
<p>可以看到，已经设置成功了。再来看一下克隆之后生成的配置文件吧：</p>
<pre><code>$ cat ys/.git/config
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote ""origin""]
    url = ssh://git@mydomain.com/source/ys.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch ""master""]
    remote = origin
    merge = refs/heads/master
[user]
    email = zhangjing@mydomain.com
    name = zhangjing</code></pre>
<p>在这里我们看到文件末尾自动增加了两行关于身份的配置，有了这两行，我们再也不用担心<code>push</code>的时候弄错身份了。</p>
<p>整个原理其实就是利用了<code>git</code>的三个特性：<strong>初始模板</strong>、<strong>钩子函数</strong>和<strong>本地配置</strong>。在初始模板里我们设定好了一个钩子函数，这样只要一执行克隆操作，首先<code>git</code>会把我们的模板文件里的钩子函数复制到本地仓库里，然后开始执行这个钩子函数，最后根据<code>URL</code>地址设置我们的本地配置。</p>
<p>以上这些代码其实并不是我写的，而是来源于一个<code>github</code>项目，感兴趣的同学可以去<a href=""https://github.com/DrVanScott/git-clone-init"" rel=""nofollow noreferrer"">这里</a>参观学习。</p>

                ", 让你的git拥有不同身份,1531977725,538,1,949,1,1,https://segmentfault.com/a/1190000013283182
46,1,0,7,"
                    
<h1>分享一些实用的软件工具</h1>
<p>PS：也可以分享自己常用的软件给大家，<a href=""https://github.com/guoxiaoxu/Guo-Software-Tools"" rel=""nofollow noreferrer"">这里会同步更新</a></p>
<h3>kindle(必备)</h3>
<p>放几个azw3资源站点：有能力建议购买正版,不要看PDF格式的，可以是mobi。<br><a href=""http://mebook.cc/"" rel=""nofollow noreferrer"">我的小书屋</a><br><a href=""https://book.shuyuzhe.com/"" rel=""nofollow noreferrer"">书语者</a></p>
<p>1、<a href=""http://download.cnet.com/My-WiFi-Router/3000-18508_4-76086273.html"" rel=""nofollow noreferrer"">My WIFI Router</a><br>无线热点、无广告、设置自启。赶快卸载国产类吧，尝试下这个。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013288025?w=965&amp;h=622"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>2、<a href=""http://download.cnet.com/Nitro-PDF-Reader-64-bit/3000-10743_4-75206289.html"" rel=""nofollow noreferrer"">Nitro PDF Reader</a></p>
<p>3、<a href=""http://www.eagleget.com/download/"" rel=""nofollow noreferrer"">EagleGet</a>终于可以卸载迅雷精简版了。<br>配合<a href=""https://tampermonkey.net/"" rel=""nofollow noreferrer"">Tampermonkey</a> 和<a href=""https://greasyfork.org/zh-CN/scripts/13638-%E7%99%BE%E5%BA%A6%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD"" rel=""nofollow noreferrer"">百度盘直接下载</a> 这个网站有很多脚本可用。</p>
<p>4、<a href=""http://download.cnet.com/qBittorrent/3000-2196_4-75587054.html"" rel=""nofollow noreferrer"">qBittorrent</a>下载种子必备，可以达到10M/s</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013294785?w=1200&amp;h=900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>5、<a href=""https://chrome.google.com/webstore/detail/githunt/khpcnaokfebphakjgdgpinmglconplhp?utm_source=chrome-ntp-icon"" rel=""nofollow noreferrer"">Githunt</a></p>
<p>好想分享自己的书签给大家，无奈没整理全。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013295553?w=1508&amp;h=1724"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>5、<a href=""http://download.cnet.com/windows/"" rel=""nofollow noreferrer"">网站在这里</a>，大家去找自己顺手的。</p>
<h2>1、ALTRun(国产启动神器)</h2>
<p>ALTRun是由网友 ET民工个人独立开发的一款快速启动软件，小巧绿色，简单易用。精致简洁的操作界面、精巧灵动的智能匹配、疾如雷电的响应速度和行云流水般畅快淋漓的操控体验的完美结合，足以令人爱不释手。<br></p>
<h2>2、LD(<a href=""https://github.com/getlantern/forum"" rel=""nofollow noreferrer"">科学++网</a>)</h2>
<p>速度绝对刚刚的，YouTube1080P妥妥的，2K微卡。支持Android、IOS、Ubuntu、macOS。其他Linux系统可以使用Chome浏览器插件：SpeedplusV+N。Centos安装请参考这篇文件：<a href=""https://github.com/guoxiaoxu/install-lantern"" rel=""nofollow noreferrer"">https://github.com/guoxiaoxu/...</a></p>
<h2>3、<a href=""https://networx.en.softonic.com/"" rel=""nofollow noreferrer"">networx</a>(流量监控)</h2>
<p>屏蔽某雷自动上传文件，屏蔽某些自动联网的软件。PS：最好卸载各种国产杀毒软件，使用Avast，强大到可以杀掉浏览器脚本。卸载方式：先删除安装目录，在启动avastclear.exe。最好在安全模式下进行。</p>
<h2>4、<a href=""https://gifcam.en.softonic.com/"" rel=""nofollow noreferrer"">GifCam</a>
</h2>
<p>看名字就知道，不做介绍。谁用谁知道。</p>
<h2>5、<a href=""https://zh.snipaste.com/"" rel=""nofollow noreferrer"">Snipaste</a>
</h2>
<p>好用的截图软件，F1截图，F3取消。</p>
<h2>6、<a href=""https://www.resilio.com/individuals/"" rel=""nofollow noreferrer"">Resilio-Sync</a>
</h2>
<p>其可在局域网、互联网上通过安全的、分布式的P2P技术在不同设备之间同步文件。支持各终端，据说在国内和谐了？因为一个人。</p>
<h2>7、<a href=""https://github.com/oldj/SwitchHosts"" rel=""nofollow noreferrer"">SwitchHosts</a>
</h2>
<p>快捷切换hosts的小工具，非常好用。</p>
<h2>8、<a href=""https://www.vandyke.com/products/securecrt/"" rel=""nofollow noreferrer"">SecureCRT</a>
</h2>
<p>SecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。非常方便，按下ALT+P可以实现拖拽上传文件。</p>
<h2>9、<a href=""https://github.com/rest-client/rest-client"" rel=""nofollow noreferrer"">restclient</a>
</h2>
<p>用Ruby封装的访问HTTP和REST client的gem，其中HTTP访问动词(get, put, post, delete) ... 使用RestClient可以完成多部件的发送。</p>
<h2>10、<a href=""https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer"" rel=""nofollow noreferrer"">ProcessExplorer</a>
</h2>
<p>由Sysinternals开发的Windows系统和应用程序监视工具，目前已并入微软旗下。不仅结合了Filemon（文件监视器）和Regmon（注册表监视器）两个工具的功能，还增加了多项重要的增强功能。</p>
<h2>11、<a href=""https://atom.io/"" rel=""nofollow noreferrer"">atom</a>
</h2>
<p>强大到没朋友，各种插件，并且开源。因为Atom比较吃内存，介意卸载没必要的插件。响应速度才能提上来，电脑软件装多了也会卡，各司其职。推介插件：Git Plus、atom-ide-ui、markdown-preview-plus、simplified-chinese-menu、atomic-chrome。</p>
<h2>13、<a href=""https://www.sublimetext.com/3"" rel=""nofollow noreferrer"">sublime text 3</a>
</h2>
<p>世界上最好的编辑器器之一，堪称神器。和上面结合起来，堪称完美。</p>
<h2>14、<a href=""http://www.oldapps.com/zh-cn/everything_search.php?old_everything_search=14940"" rel=""nofollow noreferrer"">Search Everything</a>
</h2>
<p>注意：不要使用新版本，旧版本只要你输入，就会有结果。比win自带的强大一万倍。还有一点不要强迫症的乱更新软件，新版本未必都是好的。顺手就好。</p>
<h2>15、网易云音乐</h2>
<p>这个取决于个人喜好，没装的，尝试用几天。我相信你觉得会卸载其他的。说起卸载，我希望大家卸载一些国产的垃圾软件、用国外的代替。你会发现广告少多了，速度起来了。同样的软件，在play商店下载，功能比国内多而且没广告 。</p>
<h2>16、迅雷极速版</h2>
<p>速度没有限制，更具版本而定，连接不给力。结合Tampermonkey插件，爽歪歪、、、</p>
<h1>Chrome插件篇(太多好用的了)</h1>
<h2>31、Earth View from Google Earth(强烈推介)</h2>
<p>效果如下： <br><br><span class=""img-wrap""><img data-src=""/img/remote/1460000013259491?w=1920&amp;h=1023"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>32、Click&amp;Clean</h2>
<p>当浏览器关闭时，这款应用程序删除你的浏览历史,防止他人跟踪你的网上活动。</p>
<h2>33、Tampermonkey(<a href=""https://greasyfork.org/zh-CN"" rel=""nofollow noreferrer"">脚本地址</a>)</h2>
<p>我想大家都用过，最常用的还是网盘助手，一键清除新浪微博。建议：希望大家不要把生命中重要的时间浪费在刷微博，微信。多去关注下Twitter的世界，太多大神。顺便可以跟着川普学英语，看别人怼他。</p>
<h2>34、Insight.io for Github</h2>
<p>每个程序员必备，</p>
<h2>35、划词翻译</h2>
<p>真的非常方便</p>
<h2>36、LastPass</h2>
<p>非常好用。哈哈</p>
<h2>37、<a href=""https://chrome.google.com/webstore/search/jsonviewer?utm_source=chrome-ntp-icon"" rel=""nofollow noreferrer"">JsonViewer</a>
</h2>
<p>JSONView是一款非常棒的查看JSON格式数据的Chrome扩展。</p>
<h2>38、Grammarly for Chrome</h2>
<p>英语写作的这个插件很有用，自动判断语法，点击修改。</p>
<h2>39、Adblock for Youtube™ 、AdShield</h2>
<p>上面两个都不错，结合起来效果完美。</p>
<h2>40、ColorZilla</h2>
<p>前端的朋友必备，设计师、后端的也需要。找到具体颜色数值并且测量它们的不同。</p>
<h2>41、Death Clock</h2>
<p>死亡倒计时，强迫自己珍惜每一分，每一秒。</p>
<h2>42、新的隐身窗口</h2>
<p>隐私很重要，我们的搜索记录会被记录下来。可以使用隐身窗口。</p>
<h2>43、IntelliJ IDEA</h2>
<p>很智能，适应了之后感觉非常不错。</p>
<h2>43、ImTranslator: 翻译，字典，声音</h2>
<p>非常不错，尤其读API的时候，</p>
<h2>44、cVim</h2>
<p>我把浏览器，两个编辑器都换成了命令行模式，减少用鼠标的次数。浏览网页非常流畅。建议使用！</p>
<h2>45、Malwarebytes</h2>
<p>清除系统的间谍软件，用了之后夏一跳，赶紧卸载了迅雷极速版，只用精简版。</p>
<h2>46、Fences</h2>
<p>自定义桌面，之前设置的像一个台阶，现在分格放，只有鼠标路过才显示。效果如下：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013259492?w=719&amp;h=276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>47、MPC-BE x64</h2>
<p>一个好用的播放器，因为自己换来LG入门级4K，播放效果非常好。</p>
<h1>PS：可以给笔记本外接一个显示器，效率提高了不少。</h1>
<h1>PS:先分享到这里，后续慢慢补充。</h1>

                ", 分享一些实用的软件工具,1531977726,188,1,473,1,1,https://segmentfault.com/a/1190000013259486
47,1,0,7,"
                    
<p>因为结合了开发中可能遇到的场景，篇幅较长，不过我觉得很有助于你理解 git 的运作机制，而不是死记硬背命令。</p>
<p>HEAD指针 始终指向的是当前分支的最新版本号，HEAD^, HEAD^^, ^ 的个数 n 或 HEAD~n，n 代表前 n 个版本号。</p>
<p>在项目中直接使用 linux rm 只会删除工作区的文件，git rm 同在删除工作区文件的同时删除 stage 中的，或使用 git rm --cached 只删除 stage 中的。</p>
<p>一些基本的操作</p>
<pre><code>#全局配置
git config --global user.name ""your username""
git config --global user.email youremail@email.com
git config --global color.ui true

#
mkdir git_proj &amp; cd git_proj
git init
echo ""# readme.md"" &gt;&gt; README.md
git add README.md
git commit -m ""readme commit""
# 添加远程仓库 并给它取个别名 origin
git remote add origin git@github.com:username/repositoryName.git
# 将本地仓库推送至 origin 的 master 分支并与此分支关联（-u 的作用，后期不必在使用）
git push -u origin master

# 从远程仓库 origin 的 master 分支获取最新源码并下载到 tmp 分支
git fetch origin master:tmp
# 比对 tmp 分支于 master 分支做了哪些改动
git diff master tmp
# 合并 tmp 分支到 master 分支
git merge tmp

# clone copy 一个完整的远端仓库到本地
git clone git@github.com:username/repositoryName.git

# pull 获取 origin 的 master 分支并直接和当前分支合并
# 所以可能会发生冲突
git pull origin master


</code></pre>
<h2>checkout</h2>
<p>checkout 命令有两个主要作用：切换分支 和 回滚文件到当前的 stage 版本 或 repository 版本<br>1、切换分支</p>
<pre><code># 切换到 new_branch 分支
git checkout new_branch
# 创建并切换到 new_branch 分支
git checkout -b new_branch</code></pre>
<p>2、回滚工作区的文件到最新 stage 版本 或 repository 版本，即从 stage 或 repository 中检出最新版本</p>
<pre><code># -- 是文件标示符 表名后面的参数为文件 避免产生切换 branch 的歧义
git checkout -- &lt;filename&gt;
</code></pre>
<p>回滚时会先检查 stage 中是否有对应的文件，如果没有才会使用 repository 中最新的版本。而当对某文件进行了多次修改和 add 操作后，使用 checkout 我们只能将文件回滚到最新一次的 add 的版本。<br>但在某些场景下我们可能想回滚到 repository 中的最新版本，怎么做呢？配合 reset 命令的可以很容易做到。<br>先给出命令：</p>
<pre><code>git reset HEAD &lt;filename&gt; &amp; git checkout -- &lt;filename&gt;
</code></pre>
<p>这样就可以将工作区的 filename 回滚到 repository 中的最新版本了。具体原理我们将在实例中详细的讲解。</p>
<h2>reset</h2>
<p>git 的 reset 命令比较绕，需要耐心的理解。简单来说，reset 有三种重置级别，我们需要准确理解每个级别的作用。</p>
<p>soft：回退版本号。作用于 repository</p>
<p>mixed：回退版本号，重置 stage。作用于 repository 和 stage</p>
<p>hard ：回退版本号，重置 stage，重置工作区源码。作用于 repository，stage 和 workspace</p>
<p>我们简单展示下 repository 的版本号，我们以此为 demo 分别尝试三个级别的 reset</p>
<pre><code>git log

version D (HEAD) &lt;-- HEAD指针
version C (HEAD^)
version B (HEAD^^)
version A (HEAD~3)
</code></pre>
<p>命令格式：</p>
<pre><code>git reset [--soft|--mixed|--hard] version_no &lt;filename&gt;
</code></pre>
<p>--soft：只是单纯的移动 repository 的 HEAD指针 到制定版本号。stage 和工作区没有任何变化。</p>
<pre><code># 将 HEAD 指针回滚至上一版本 使用 git log 你会发现提交日志退回到了上一版本号
git reset --soft HEAD^
#版本号现状
version C &lt;-- HEAD指针
version B
version A
</code></pre>
<hr>
<p>--mixed：默认选项，移动 repository 的 HEAD指针 到指定版本号，同时用此版本重置 stage 区，所以可能会让工作区的某些文件处于 unstage 状态（当工作区的文件与 repository 中的版本不一致时）。注意，这里是可以指定文件的。soft 本身和文件无关，hard 则是不能单独指定文件，只能全部重置。</p>
<pre><code># HEAD指针 还是指向 HEAD 
git reset HEAD^2 &lt;filename&gt;
#版本号现状
version B &lt;-- HEAD指针
version A
</code></pre>
<p>HEAD指针 指向 version B，并且 stage 已经被 version B 的文件重置，工作区则不受影响。</p>
<p>这里有个很实用的小技巧：</p>
<pre><code>git reset version_no &lt;filename&gt; &amp; git checkout -- &lt;filename&gt;
</code></pre>
<p>这两个命令组合在一起可以让工作区的指定文件回滚到 repository 中对应的 version_no 版本。<br>如果 version_no 是 HEAD 的话那就可以回滚文件到最新一次的提交。</p>
<hr>
<p>--hard：谨慎使用！！！移动 repository 的 HEAD指针 到指定版本号，同时用此版本重置 stage 区 和 工作区源码。这里要特别注意，工作区的源码也会被覆盖重置掉，你的修改会全部丢失。简单来说就是将代码彻底恢复到指定版本。hard 是没办法指定文件的，要么回滚，要么全回滚。</p>
<pre><code># HEAD指针 还是指向 HEAD 
git reset --hard HEAD^3
#版本号现状
version A &lt;-- HEAD指针
</code></pre>
<p>此时，HEAD指针 指向 version A，并且 stage 和 工作区的文件已经被 version A 的文件重置。整个项目的状态完全回到提交 version A 时按下回车键的那一刻。</p>
<h2>rm</h2>
<p>git rm 不同于直接使用 rm，git rm 会删除工作区 和 stage 区的内容。注意：这里你没办法再使用 git checkout -- &lt;filename&gt; 来回滚操作了，因为工作区也没有 filename 文件了，没办法与 repository 做关联，只能使用 git reset HEAD &lt;filename&gt; 来重置 stage 中的此文件，然后 git checkout -- &lt;filename&gt;</p>
<pre><code>git rm [--cached] [-r] [-f] &lt;filename&gt;
</code></pre>
<p>这里就提示一点，只想把 stage 中的文件删除掉让文件脱离 git 的管理，可以使用</p>
<pre><code>git rm --cached &lt;filename&gt;
</code></pre>
<p>此时工作区的 filename 并不会被删除，但状态会被改为 untracked，同时 stage 会记录下 filename 的状态为删除，提交的话版本库将新增一个 filename 被删除掉的版本。<br>删除 stage 中的文件和使用 reset命令 重置 stage 中的文件是有区别的，删除会让文件状态更改为 untracked，而重置会让文件状态更改为 unstage（如果工作区和 stage 文件内容不一致）。</p>
<p>小实例场景：</p>
<p>1、回滚工作区某文件到指定的 repository 版本</p>
<p>工作中，我们可能会针对某文件做多次修改和 add 到 stage 的操作，而后发现思路完全错了，需要重新设计开发。</p>
<p>比如文件 foo 的 A版 我提交了一次后，又进行了 B版 和 C版 的两次修改并 add 到了 stage 区。第三次修改后 D版 我发现一开始思路就错了，需要重新设计。那此时直接使用 git checkout -- foo 是拿不到最初的 A版 的，因为 stage 区还存放着 foo 的 C版。此时我们便可以使用 git reset HEAD foo 命令，repository 最新版本号中存放着 foo 的 A版，命令会在不移动 HEAD 的前提下，使用 foo A版 去重置 stage 区。命令执行后 stage 区的 foo 文件已经是 A版 了。我们再使用  git checkout -- foo 便可以将工作区的 foo D版 回滚至 A 版。即：</p>
<pre><code>
git reset HEAD foo &amp; git checkout -- foo
</code></pre>
<p>HEAD 代表当前版本，所以 HEAD指针 不会移动。同时 stage 区会被 repository 的当前版本的 filename 重置，也就说 stage 区 存放的 filename 与 repository 中相同了。此时我们再使用 git checkout -- &lt;filename&gt; 便可以回滚工作区的 filename 到 repository 的当前版本。其实就是利用 reset --mixed 会重置 stage 区，然后 checkout 会将 stage 区的文件检出到工作目录。当然，reset 很灵活，可以回滚任意指定的版本。</p>
<p>其实如果只是回滚至当前版本的话，还有个命令能实现相同的功能</p>
<pre><code>git rm --cached &lt;filename&gt; &amp; git checkout -- &lt;filename&gt;
</code></pre>
<p>git rm --cached &lt;filename&gt; 会将 stage 中的此文件删除，文件状态会变为 untracked，然后 checkout 时发现 stage 中木有此文件，故会去 repository 的当前版本中检出此文件。</p>
<h2>diff</h2>
<p>git diff -- &lt;filename&gt;              工作区  比较 暂存区<br>git diff --cached -- &lt;filename&gt;     暂存区  比较 本地库当前版本<br>git diff HEAD~N -- &lt;filename&gt;       工作区  比较 本地库第N个版本<br>git diff HEAD HEAD^ -- &lt;filename&gt;   HEAD   比较 HEAD^<br>git diff master tmp -- &lt;filename&gt;   master 比较 tmp<br>git diff SHA1 SHA2 -- &lt;filename&gt;    比较两个历史版本之间的差异</p>
<p>还没结束...未完成...待更新....</p>

                ", git 必须要熟练掌握的命令,1531977727,468,1,579,1,1,https://segmentfault.com/a/1190000013241889
48,1,0,7,"
                    
<p>无所事事实在无聊，那么就推荐几个在用的工具好了。<br>1.虚拟接口<br>介绍： 在项目中经常遇到页面写太快，后端的小伙伴奶水不足的情况。所以就需要现在推荐的这款，虚拟接口，可自定义返回数据，在没有接口的情况下可以先行开发页面哦。<br>连接: <a href=""https://easy-mock.com/"" rel=""nofollow noreferrer"">地址</a></p>
<p>2.虚拟图片<br>介绍: 在项目中经常遇到页面写太快，设计的小伙伴奶水不足的情况。(额……有点熟悉……)所以就需要这款虚拟图片啦，可以通过url选择图片尺寸，在手中没图的时候，简直不要太好用2333<br>连接:<a href=""http://via.placeholder.com/160x160"" rel=""nofollow noreferrer"">地址</a><br>修改url后面的参数就可以获得相印大小的图片哟</p>
<p>3.caniuse<br>介绍: 在项目中经常遇到页面写太快，忘记考虑兼容的问题，2333.这时候就需要用到我们这款can i use了。一键查兼容，简直不要太方便。<br>连接: <a href=""https://caniuse.com/#"" rel=""nofollow noreferrer"">地址</a></p>
<p>4.真机调试<br>介绍： 在项目中经常遇到页面写太快，而导致在手机端各种无法调节的bug。这时候就需要我们的真机调试工具啦，深入查看你的页面有什么问题，一目了然，简直不要太爽。顺便说一下像我这种没有mac的穷苦大众，一般在用spy-debugger。比较适合移动端开发的小朋友啦。<br>连接: <a href=""http://expelliarmus923.github.io/2017/03/31/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95/"" rel=""nofollow noreferrer"">地址</a></p>
<p>5.冷熊简历<br>介绍： 在项目中经常遇到离职离的太快，而导致没有好好准备简历的bug。这时候就需要我们的冷熊简历啦（刚刚看翟路佳老师的讲堂get到，嗯，试了一下感觉很好用啊，简洁大方而又不失尴尬，呸，不失方便，真的是很方便，word什么的可以一边去了），在线随时调整，可以保存成pdf,还有作者对于简历内容的一些提醒与建议，年后跳槽必备呀有木有<br>连接: <a href=""http://cv.ftqq.com/"" rel=""nofollow noreferrer"">地址</a></p>
<p>6.postman<br>介绍：一个调试接口的工具，挺好用的。最近才发现实在是很惭愧了。<br>更新时间: 2018-04-18<br>链接: <a href=""https://www.getpostman.com/"" rel=""nofollow noreferrer"">链接描述</a></p>
<p>7.还有一些乱七八糟的经常用的工具比较常见就不写出来啦，列举一下就是jsrun啦,json解析啦,color选择器啦之类的，百度一些就有很多的啦。最重要还是页面不要写太快哈哈哈，或许就一个工具都不需要用了哦</p>

                ", 推荐几个我在用的开发工具（前端或者一些其他什么东西）,1531977728,460,1,749,1,1,https://segmentfault.com/a/1190000013145136
49,1,0,7,"
                    
<p>相信各位github资深玩家们都有自己基于 <code>github pages</code> 搭建的个人站点。官方推荐的静态站点生成器是 <code>Jekyll</code>，关于 <code>Jekyll</code> 的使用感兴趣的各位请自行 google，这里就不赘述了。本文主要介绍下基于 <code>Create-React-App</code> 搭建个人博客的相关实践，可能更适合做前端开发的伙伴。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013026811"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github pages"" title=""github pages""></span></p>
<p><code>github pages</code> 是 <code>github</code> 推出的静态站点服务，主要的用途在于使用你在 <code>github</code> 仓库中的代码构建你自己的静态站点，为用户提供 <code>github.io</code> 二级域名，您也可以通过添加DNS的 <code>CNAME</code> 记录来绑定自己的域名。</p>
<p><code>github pages</code> 最简单粗暴的方法就是直接往 github 上方静态页面了，创建一个名为 <code>[您的github账号名].github.io</code> 的github仓库，将您的index.html页面代码扔进master分支，就可以直接通过 <code>https://[您的github账号名].github.io</code> 访问到您的站点了。</p>
<p>对于一个简单的个人博客站点来说，存在以下基本功能特性：</p>
<ul>
<li>文章的新增、编辑、一键发布</li>
<li>文章的分类、归档</li>
<li>风格良好的博客样式</li>
<li>评论、SEO等等功能</li>
</ul>
<p>下面介绍基于React如何实现一个简单的静态博客。</p>
<h2>1. 创建一个 React 项目</h2>
<p>使用 Create-React-App（以下简称CRA） 的generator创建一个React前端项目骨架。对此项目进行一定改造以方便我们日常的开发和使用习惯：</p>
<ul>
<li>
<p>使用<code>react-app-rewired</code>来调整CRA中webpack的配置</p>
<ul><li>对CRA的webpack配置感兴趣的童鞋可以看看<a href=""https://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/"" rel=""nofollow noreferrer"">这篇文章</a>
</li></ul>
</li>
<li>使用<code>core-js</code>对浏览器版本进行向下兼容</li>
<li>通过编写不同的React容器组件（container）来实现不同的页面，通过统一的json结构来配置应用的页面路由</li>
<li>使用蚂蚁金服的<code>antd</code>设计语言（React组件）快速实现业务UI</li>
<li>使用<code>axios</code>实现前后端的数据请求</li>
</ul>
<p>个人改造后的项目代码在<a href=""https://github.com/parksben/react-spa-app"" rel=""nofollow noreferrer"">这里</a>，您可以直接fork或者down下来使用。</p>
<h2>2. 使用 markdown 搞定你的文章</h2>
<h3>2.1 用于新建文章的交互式命令行（基于 inquirer）</h3>
<p>一般的静态博客系统（如gatsby），会给用户提供一个用于创建新文章的交互式命令行，效果大致如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013026812"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""readline"" title=""readline""></span></p>
<p>类似功能可以使用nodejs中<a href=""https://nodejs.org/dist/latest-v8.x/docs/api/readline.html"" rel=""nofollow noreferrer"">readline模块</a>的原生方法来实现。这里推荐一个第三方工具：<a href=""https://github.com/SBoudrias/Inquirer.js"" rel=""nofollow noreferrer"">inquirer</a>，本质上是对readline模块进行了增强，提供了很多实用的方法用于交互式命令行开发，实现的用户界面（命令行）也比较友好。</p>
<p>对于上面GIF示例的功能，其代码实现如下：</p>
<pre><code class=""js"">// newPost.js

const inquirer = require('inquirer');
const moment = require('moment');

const questions = [
  {
    type: 'input',
    name: 'post_name',
    message: '请输入您的文章别名（用于创建文章目录，仅限英文，单词间用短横杠‘-’连接）：',
    validate: value =&gt; {
      if (/(\.|\*|\?|\\|\/)/gi.test(value)) {
        return '文章别名不得包含特殊符号（.*?\\/），请重新输入↑↑';
      }

      if (/(([A-z]+-)+)?[A-z]+/gi.test(value)) {
        return true;
      }

      return '文章别名不合法，请重新输入↑↑';
    },
    filter: value =&gt; value.replace(/\s+/gi, '-'),
  },
  {
    type: 'input',
    name: 'create_at',
    message: '请输入文章的发布时间（或者按回车键使用默认值）：',
    default: () =&gt; {
      return moment().format('YYYY-MM-DDThh:mm:ss');
    },
    validate: value =&gt; {
      if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d/gi.test(value)) {
        return true;
      }

      return '时间格式不合法，请重新输入↑↑';
    },
  },
];

inquirer
  .prompt(questions)
  .then(answers =&gt; {
    // 获取用户输入
    const { post_name, create_at } = answers;
  
    /* 此处做一些命令行反馈和过程性的工作 */
    /* （如：提示用户输入是否合法、创建文章对应的目录和文件等等） */
  })
  .catch(err =&gt; {
    /* 异常处理 */
  });</code></pre>
<p>如是，将此node脚本添加到项目<code>package.json</code>的<code>scripts</code>中（如：<code>new-post: ""node newPost.js""</code>），即可通过<code>npm run</code>命令执行。</p>
<h3>2.2 md 转 html（基于 react-markdown）</h3>
<p>为使用markdown文档来编辑、存储博客的文章内容，需要将md文档转换为react的JSX对象以渲染到网页中。在此推荐使用<a href=""https://github.com/rexxars/react-markdown"" rel=""nofollow noreferrer"">react-markdown</a>，功能很6，作者维护得也比较勤。</p>
<p>使用方式如下：</p>
<pre><code class=""js"">import ReactMarkdown from 'react-markdown';

&lt;ReactMarkdown source={'# 这是文章标题\n\n'} /&gt;
// &lt;h1&gt;这是文章标题&lt;/h1&gt;</code></pre>
<h3>2.3 代码块的语法高亮</h3>
<p>react-markdown提供了一个renderers属性，用户可以传入一系列renderer组件来自定义文章中一些内容的渲染方式（有兴趣的童鞋可以看下包作者对<a href=""https://github.com/rexxars/react-markdown/blob/master/src/renderers.js"" rel=""nofollow noreferrer"">默认renderer的实现</a>）。</p>
<p>如：自定义md中图片的渲染方式（用法如下）。</p>
<pre><code class=""js"">// 传入renderer的方式
&lt;ReactMarkdown
  source={'[md文本内容]'}
  renderers={{
    image: ImageRenderer,
  }}
/&gt;</code></pre>
<pre><code class=""js"">// ImageRenderer的实现

import React, { Component } from 'react';
import PropTypes from 'prop-types';

class ImageRenderer extends Component {
  static propTypes = {
    src: PropTypes.string.isRequired,
  };

  render() {
    return (
      &lt;img
        className=""post-content-image""
        src={this.props.src}
        alt={this.props.src}
      /&gt;
    );
  }
}

export default ImageRenderer;</code></pre>
<p>与此类似，我们可以通过传入一个自定义的renderer来实现文章中代码块的语法高亮。名为<code>CodeBlock</code>的renderer实现如下：</p>
<pre><code class=""js"">import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { highlight, languages } from 'prismjs';
import ReactHtmlParser from 'react-html-parser';
import 'prismjs/themes/prism.css';

export class HtmlComponent extends Component {
  static propTypes = {
    html: PropTypes.string.isRequired,
  };

  render() {
    return ReactHtmlParser(this.props.html);
  }
}

export class CodeBlock extends Component {
  static propTypes = {
    literal: PropTypes.string.isRequired,
    language: PropTypes.string.isRequired,
  };

  render() {
    const html = highlight(this.props.literal, languages[this.props.language]);
    const cls = `language-${this.props.language}`;

    return (
      &lt;pre className={cls}&gt;
        &lt;code className={cls}&gt;
          &lt;HtmlComponent html={html} /&gt;
        &lt;/code&gt;
      &lt;/pre&gt;
    );
  }
}

export default CodeBlock;</code></pre>
<p>此处用到了<a href=""http://prismjs.com/"" rel=""nofollow noreferrer"">prismjs</a>和<a href=""https://github.com/wrakky/react-html-parser"" rel=""nofollow noreferrer"">react-html-parser</a>两个npm包，前者用于将代码文本转化为html文本，后者用于将html文本转化为React的JSX对象以传入React组件（这样做比直接使用<a href=""https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml"" rel=""nofollow noreferrer"">dangerouslySetInnerHTML</a>属性更安全些）。</p>
<h2>3. 文章分类</h2>
<p>一个友好的站点肯定少不了导航菜单（或文章的分类菜单），本人的实现方式是直接使用文章的“标签”来进行分类统计，并生成站点的顶部导航，效果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013026813"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""nav-top"" title=""nav-top""></span></p>
<p>为此，需要撰写一定的脚本实现文章的分类统计和打包，个人的实现方式是将统计结果和文章内容各自打包为json文件，通过前端组件请求数据并加载。</p>
<p>导航栏组件的具体实现如下：</p>
<pre><code class=""js"">import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link } from 'react-router-dom';
import { Dropdown, Menu, Icon } from 'antd';
import { randomId } from 'utils';
import './style.css';

export class Header extends Component {
  static propTypes = {
    data: PropTypes.array,
    activeTag: PropTypes.string,
  };

  static defaultProps = {
    data: [{ tag: '前端', count: 5 }],
    activeTag: '',
  };

  constructor(props) {
    super(props);
    this.navTotal = 6;
  }

  renderMore() {
    if (this.props.data.length &lt;= this.navTotal) {
      return false;
    }

    const subNavItems = this.props.data.slice(this.navTotal).map(t =&gt;
      &lt;Menu.Item key={`sub_nav_${randomId()}`}&gt;
        &lt;Link
          to={t.linkTo || `/tag/${t.tag}`}
          className={`ant-dropdown-link ${this.props.activeTag === t.tag
            ? 'active'
            : ''}`}
          key={`nav_top_${randomId()}`}&gt;
          {t.tag}（{t.count}）
        &lt;/Link&gt;
      &lt;/Menu.Item&gt;
    );

    const SubNav = (
      &lt;Menu&gt;
        {subNavItems}
      &lt;/Menu&gt;
    );

    const DropDownBtn = (
      &lt;Dropdown overlay={SubNav} key={`nav_top_${randomId()}`}&gt;
        &lt;div className=""header-nav-item""&gt;
          更多分类 &lt;Icon type=""down"" /&gt;
        &lt;/div&gt;
      &lt;/Dropdown&gt;
    );

    return DropDownBtn;
  }

  renderTop5() {
    const items = this.props.data.slice(0, this.navTotal - 1).map(t =&gt;
      &lt;Link
        className={`header-nav-item ${this.props.activeTag === t.tag
          ? 'active'
          : ''}`}
        to={t.linkTo || `/tag/${t.tag}`}
        key={`nav_top_${randomId()}`}&gt;
        {!t.linkTo ? `${t.tag}（${t.count}）` : t.tag}
      &lt;/Link&gt;
    );

    return (
      &lt;div className=""header-nav""&gt;
        {items}
        {this.renderMore()}
      &lt;/div&gt;
    );
  }

  render = () =&gt; this.renderTop5();
}

export default Header;</code></pre>
<p>大家可以根据实际需要实现自己的文章打包方式（这里就不奉上我的脚本了?）。</p>
<h2>4. 更多功能</h2>
<p>对于个人博客来说，到这里为止还有很多功能没有实现，这里偷个懒，奉上一些相关的链接吧：</p>
<h3>4.1 关于文章评论</h3>
<ul>
<li><a href=""http://www.forestofhorizon.com/notesofstudy/2015/12/01/adding-disqus-to-github-pages/"" rel=""nofollow noreferrer"">在github pagess中加入Disqus评论系统</a></li>
<li><a href=""https://imsun.net/posts/gitment-introduction/"" rel=""nofollow noreferrer"">使用 GitHub Issues 搭建评论系统</a></li>
</ul>
<h3>4.2 关于文章结构树</h3>
<ul>
<li><a href=""https://github.com/hollodotme/TreeMDown"" rel=""nofollow noreferrer"">TreeMDown</a></li>
<li><a href=""https://github.com/hughsk/markdown-tree"" rel=""nofollow noreferrer"">markdown-tree</a></li>
</ul>
<p>我最近应该会实现一个React用途的markdown树组件，大家不妨期待下☺️</p>
<h2>5. 发布你的个人静态站点</h2>
<h3>5.1 部署到 github pages（基于 gh-pages）</h3>
<p>CRA针对github pages用途专门推荐了一个包：<a href=""https://github.com/tschaub/gh-pages"" rel=""nofollow noreferrer"">gh-pages</a>，使用方法如下：</p>
<p>（1）修改项目的<code>package.json</code>文件，添加homepage属性：</p>
<pre><code>""homepage"": ""https://parksben.github.io"",</code></pre>
<p>（2）项目安装<code>gh-pages</code>依赖后修改，在<code>package.json</code>中添加如下配置：</p>
<pre><code>  ""scripts"": {
+   ""predeploy"": ""npm run build"",
+   ""deploy"": ""gh-pages -d build"",
    ""start"": ""react-scripts start"",
    ""build"": ""react-scripts build"",</code></pre>
<p>（3）将本地代码上传到github博客仓库的某个分支（只要不是master分支就行），然后执行：</p>
<pre><code>yarn deploy</code></pre>
<p>gh-pages会将CRA项目build到仓库的master分支，然后，你就可以访问你的站点了（有关 CRA 项目部署到 github pages 的详细描述可以看<a href=""https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#github-pages"" rel=""nofollow noreferrer"">这里</a>）。</p>
<h3>5.2 如何兼容 React 的客户端路由（一种比较 hack 的方法）</h3>
<p>单页面应用一般需要设置服务端路由，将应用的所有页面路径都重定向到index.html，而github pages并没有这样的默认设置。</p>
<p>因而，当你使用React的客户端路由（React的createBrowserHistory方法创建前端路由）时，除根路径以外的页面，github都会返回自己的404页面。</p>
<p>为此，CRA项目提供了一种比较hack的方法来支持React的客户端路由（通过操作window.history来强行匹配url）。也算是一种奇技淫巧吧☺️。</p>
<p>（1）在CRA项目的public目录下添加一个<code>404.html</code>，其内容如下：</p>
<pre><code class=""html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;title&gt;矮大紧的日常 | parksben's blog&lt;/title&gt;
    &lt;script type=""text/javascript""&gt;
      var segmentCount = 0;
      var l = window.location;
      l.replace(
        l.protocol + '//' + l.hostname + (l.port ? ':' + l.port : '') +
        l.pathname.split('/').slice(0, 1 + segmentCount).join('/') + '/?p=/' +
        l.pathname.slice(1).split('/').slice(segmentCount).join('/').replace(/&amp;/g, '~and~') +
        (l.search ? '&amp;q=' + l.search.slice(1).replace(/&amp;/g, '~and~') : '') +
        l.hash
      );
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>（2）在<code>index.html</code>的head中添加如下代码：</p>
<pre><code class=""html"">&lt;script type=""text/javascript""&gt;
  (function(l) {
    if (l.search) {
      var q = {};
      l.search.slice(1).split('&amp;').forEach(function(v) {
        var a = v.split('=');
        q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&amp;');
      });
      if (q.p !== undefined) {
        window.history.replaceState(null, null,
          l.pathname.slice(0, -1) + (q.p || '') +
          (q.q ? ('?' + q.q) : '') +
          l.hash
        );
      }
    }
  }(window.location))
&lt;/script&gt;</code></pre>
<p>大功告成，你的github站点支持React的客户端路由了。</p>
<p>除此之外，也可以改为使用<code>createHashHistory</code>方法来创建客户端路由，这样前端路由就与服务端路由没多大关系了，不过url里面一串hash毕竟不够优雅。</p>
<p>有兴趣了解奇技淫巧的童鞋，可以点<a href=""https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#notes-on-client-side-routing"" rel=""nofollow noreferrer"">这里</a>。</p>
<h3>5.3 部署到自己的服务</h3>
<p>与CRA项目的生产环境部署方式一样：</p>
<ul>
<li>线上执行 yarn build 命令，站点的所有静态资源将打包到 build 目录下</li>
<li>将你的站点的入口配置到 build 目录下</li>
</ul>
<h2>6. 项目参考（源码奉上）</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013038227"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""parksben.github.io"" title=""parksben.github.io""></span></p>
<p>这是<a href=""https://parksben.github.io/"" rel=""nofollow noreferrer"">我的github博客</a>（基于上述过程实现的静态站点），感兴趣的伙伴可以<a href=""https://github.com/parksben/parksben.github.io"" rel=""nofollow noreferrer"">点击这里</a>查看项目源码，觉得有用也可以fork或star一下下。</p>

                ", 快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践,1531977730,574,1,199,1,1,https://segmentfault.com/a/1190000013026806
50,1,0,7,"
                    
<h2>git中使用ssh key</h2>
<blockquote>git中clone项目有两种方式：https和ssh<br>https：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码<br>ssh：clone项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。SSH在push的时候，是不需要输入用户名的，如果配置SSH Key的时候设置了密码，则需要输入密码，否则是不需要输入密码的</blockquote>
<h3>git中使用SSH Key的步骤：</h3>
<p>1.检查电脑是否存在SSH Key</p>
<pre><code>cd ~/.ssh
ls
如果存在id_rsa.pub或id_
dsa.pub文件，说明文件已经存在，跳过创建SSH Key步骤</code></pre>
<p>2.创建SSH Key</p>
<pre><code>ssh -keygen -t rasa -C “your_email@example.com”</code></pre>
<p>3.查看SSH Key</p>
<pre><code>cat ~/.ssh/id_rsa.pub</code></pre>
<p>4.将查看的SSH Key赋值到git中设置好</p>
<p>5.测试SSH Key</p>
<pre><code>ssh -T git@git.oschina.net 
出现Welcome to xxx就可以了</code></pre>
<p><a href=""https://xuyuan923.github.io/2014/11/04/github-gitlab-ssh/"" rel=""nofollow noreferrer"">github/gitlab同时管理多个ssh key</a></p>
<hr>
<h2>git管理代码</h2>
<p>思考：</p>
<ol>
<li>工作区与暂存区</li>
<li>关联本地和远程的仓库</li>
<li>分支管理</li>
<li>标签管理</li>
<li>版本回退</li>
<li>忽略文件</li>
</ol>
<h3>工作区与暂存区</h3>
<p>工作区 work <br>暂存区 index/stage</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013228598"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<pre><code>git checkout file 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件，已添加到暂存区的改动以及新文件都不会受到影响。
git fetch origin &amp; git reset —hard origin/master 丢去你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它
</code></pre>
<h3>关联本地和远程的仓库</h3>
<p>step1: 新建本地仓库</p>
<pre><code>mkdir learn-git
cd learn-git
git init</code></pre>
<p>step2: 推送到远程仓库</p>
<blockquote>在github上新建一个空的仓库，默认设置<br>github告诉我们可以从这个仓库克隆出新的仓库，也可以把已有的本地仓库与之关联，然后把本地仓库的内容推送到github仓库上</blockquote>
<pre><code>git remote add origin https://github.com/Liuhui11/learn-git.git 本地仓库关联远程仓库
git remote remove origin 取消关联</code></pre>
<pre><code>git push -u origin master 将本地仓库推送到远程仓库</code></pre>
<p>报错: src refspec master does not match any</p>
<p>原因：空仓库不能提交上去</p>
<p>解决：</p>
<pre><code>touch README
git commit -m ‘first commit’
git push -u origin master</code></pre>
<h3>分支管理</h3>
<blockquote>分支管理策略：<br>master分支：稳定、仅用来发布新版本，平时不能在上面干活<br>dev分支：不稳定、干活的地方，发布新版本时合并到master上<br>个人开发的分支：每个人都有自己的分支，最终要往dev上合并<br>合并分支时，加上—no-ff参数可使用普通模式合并，合并后的历史有分支，能看出来曾经做过合并；而fast forward合并就看不出来曾经做过合并<p>bug分支：<br>git stash 将当前工作现场储存起来，等以后恢复现场后继续工作<br>git stash apply 恢复之前的工作现场<br>git stash list<br>git stash drop 删除stash内容<br>git stash apply stash@{0} 恢复到指定的stash</p>
<p>feature分支：<br>为新功能创建分支<br>git branch -D feature-vulcan 强行删除分支</p>
<p>多人协作：<br>git remote -v 查看远程库的信息<br>master分支是主分支，因此时刻与远程同步<br>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步<br>bug分支只用于在本地修复bug，就没必要推到远程了<br>feature分支是否推到远程，取决于你是否和你的小伙伴在上面开发</p>
</blockquote>
<pre><code>git branch dev 新建
git branch -d dev 删除
git merge dev 合并
git branch -a 查看
git checkout dev 切换</code></pre>
<h3>标签管理</h3>
<pre><code>git tag v1.0 创建标签，默认标签是打在最新提交的commit上的
git tag 查看标签
git tag -a &lt;tagname&gt; -m ""blablabla..."" 指定标签信息
git tag -s &lt;tagname&gt; -m ""blablabla..."" 用PGP签名标签

找到历史提交的commit id打标签:
1.git log --pretty=oneline --abbrev-commit 
2.git tag v1.0 commit-id

git tag -d v1.0 删除标签
git push origin &lt;tagname&gt; 推送指定标签
git push origin --tags 一次性推送全部尚未推送到远程的本地标签
git tag -d v0.9 &amp; git push origin :refs/tags/v0.9 删除远程标签</code></pre>
<h3>版本回退</h3>
<pre><code>git log／git log --pretty=oneline 查看commit的历史记录
git reset —hard HEAD^ 回退到上一个版本，或者通过commit id来回退到指定版本
git reflog 记录你的每一次命令，包括未来的版本 找到之前版本的commit id可以返回到最新的版本</code></pre>
<h3>忽略文件</h3>
<pre><code>git add -f file 强制添加文件，即使被忽略了
git check-ignore -v file 查看文件不能被提交是哪个规则写的
https://github.com/github/gitignore 在线自动生成忽略文件

忽略已经被追踪的文件
git rm --cached file

更新.gitignore忽略掉目标文件
git add .
git commit -m 
或者：git update-index --assume-unchanged logs/*.log
</code></pre>

                ", 工作总结-git的使用,1531977731,168,1,993,1,1,https://segmentfault.com/a/1190000012921057
51,1,0,7,"
                    
<blockquote>承接前一篇《<a href=""https://segmentfault.com/a/1190000012904063"" rel=""nofollow noreferrer"">做一个合格的前端，gulp自动化构建工具入门教程</a>》故而整理了如下gulp插件资源大全。<br>**【我的新作观点网：<a href=""http://www.guandn.com"" rel=""nofollow noreferrer"">http://www.guandn.com</a> (观点网是一个猎获新奇、收获知识、重在独立思考的网站)。<br>PS：接下来我会逐一开源观点网开发过程中的前后端技术，如：lucene全文索引、自定义富文本编辑器、图片上传压缩水印等等。】**</blockquote>
<p>之前我也整理过一篇《<a href=""https://segmentfault.com/a/1190000006735651"" rel=""nofollow noreferrer"">javascript功能插件大集合</a>》,有小伙伴留言说”<strong>能有链接就好了</strong>“，因此这次整理gulp相关资料的时候，特意录入了插件地址，方便小伙伴们查找学习。</p>
<p><strong>通用资源</strong><br><a href=""https://gulpjs.com/"" rel=""nofollow noreferrer"">官网</a><br><a href=""https://github.com/gulpjs/gulp"" rel=""nofollow noreferrer"">Github库</a><br><a href=""http://gulpjs.com/plugins/"" rel=""nofollow noreferrer"">插件注册</a><br><a href=""https://www.npmjs.com/package/gulp"" rel=""nofollow noreferrer"">NPM模块</a><br><a href=""https://github.com/gulpjs/plugins/blob/master/src/blackList.json"" rel=""nofollow noreferrer"">插件黑名单</a></p>
<p><strong>官方文档</strong><br><a href=""https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md"" rel=""nofollow noreferrer"">快速开始</a><br><a href=""https://github.com/gulpjs/gulp/blob/master/docs/API.md"" rel=""nofollow noreferrer"">API文档</a><br><a href=""https://github.com/gulpjs/gulp/tree/master/docs#articles"" rel=""nofollow noreferrer"">CLI 文档</a><br><a href=""https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/README.md"" rel=""nofollow noreferrer"">开始写一个插件</a><br><a href=""https://github.com/gulpjs/gulp/tree/master/docs/recipes"" rel=""nofollow noreferrer"">使用诀窍</a></p>
<p><strong>组织</strong><br><a href=""http://stackoverflow.com/questions/tagged/gulp"" rel=""nofollow noreferrer"">StackOverflow</a><br><a href=""https://twitter.com/gulpjs"" rel=""nofollow noreferrer"">Twitter</a></p>
<p><strong>Gulp入门</strong><br><a href=""https://www.smashingmagazine.com/2014/06/building-with-gulp/"" rel=""nofollow noreferrer"">使用Gulp构建前端工程</a><br><a href=""https://scotch.io/tutorials/automate-your-tasks-easily-with-gulp-js"" rel=""nofollow noreferrer"">通过Gulp.js轻松自动化构建你的前端工程</a><br><a href=""https://medium.com/@contrahacks/gulp-3828e8126466"" rel=""nofollow noreferrer"">Gulp，让前端工程可视化</a><br><a href=""http://stefanimhoff.de/tag/gulp/"" rel=""nofollow noreferrer"">Gulp.js是什么？</a><br><a href=""http://blog.johnnyreilly.com/2015/02/using-gulp-in-asp-net-instead-of-web-optimization.html"" rel=""nofollow noreferrer"">使用Gulp在你的HTML中直接插入Scripts和Styles标签</a><br><a href=""http://denbuzze.com/post/5-lessons-learned-using-gulpjs/"" rel=""nofollow noreferrer"">5节课学会使用Gulp.js</a><br><a href=""http://lab.brightnorth.co.uk/2014/08/13/automating-linkage-how-i-learned-to-stop-worrying-and-love-the-build/"" rel=""nofollow noreferrer"">我是怎样摆脱前端工程的困扰的？</a><br><a href=""https://www.codementor.io/development-process/tutorial/how-to-set-up-gulp-beginner-guide#/"" rel=""nofollow noreferrer"">第一次开始Gulp Task</a><br><a href=""http://blog.overzealous.com/post/74121048393/why-you-shouldnt-create-a-gulp-plugin-or-how-to"" rel=""nofollow noreferrer"">为什么你不自己写一个Gulp插件？</a><br><a href=""http://blog.rangle.io/angular-gulp-bestpractices/"" rel=""nofollow noreferrer"">6个最好的从根本改善你的开发经验的Gulp实战练习</a><br><a href=""https://css-tricks.com/gulp-for-beginners/"" rel=""nofollow noreferrer"">Gulp初学者教程</a></p>
<p><strong>Gulp 4 入门</strong><br><a href=""https://blog.wearewizards.io/migrating-to-gulp-4-by-example"" rel=""nofollow noreferrer"">迁移到Gulp 4的例子</a><br><a href=""http://fettblog.eu/gulp-4-parallel-and-series/"" rel=""nofollow noreferrer"">Gulp 4: 新的task执行系统 - gulp.parallel 和 gulp.series</a></p>
<p><strong>Gulp with Browserify</strong><br><a href=""https://medium.com/@sogko/gulp-browserify-the-gulp-y-way-bb359b3f9623"" rel=""nofollow noreferrer"">Gulp + Browserify, the Gulp-y Way</a><br><a href=""https://viget.com/extend/gulp-browserify-starter-faq"" rel=""nofollow noreferrer"">Gulp + Browserify</a><br><a href=""https://github.com/gulpjs/gulp/blob/master/docs/recipes/fast-browserify-builds-with-watchify.md"" rel=""nofollow noreferrer"">快速构建Browserify和Watchify</a></p>
<p><strong>Gulp with Angular</strong><br><a href=""http://blog.jhades.org/what-every-angular-project-likely-needs-and-a-gulp-build-to-provide-it/"" rel=""nofollow noreferrer"">Angular工程需要什么 - Gulp能提供什么</a></p>
<p><strong>Gulp with Angular and Browserify</strong><br><a href=""http://omarfouad.com/blog/2015/03/21/advanced-angularjs-structure-with-gulp-node-and-browserify/"" rel=""nofollow noreferrer"">使用 Gulp, Node and Browserify构建先进的 AngularJS工程结构</a></p>
<p>Gulp with React and Browserify<br><a href=""https://hacks.mozilla.org/2014/08/browserify-and-gulp-with-react/"" rel=""nofollow noreferrer"">Browserify、Gulp 和 React</a><br><a href=""http://pomax.github.io/1420592591221/taking-react-to-the-next-level-mixins-gulp-and-browserify"" rel=""nofollow noreferrer"">Taking React to the Next Level: Mixins, Gulp, and Browserify</a></p>
<p>Gulp with Ember<br><a href=""http://www.sitepoint.com/improving-ember-js-workflow-using-gulp-js/"" rel=""nofollow noreferrer"">使用Gulp.js改进你的Ember.js工作流</a></p>
<p><strong>其他资源</strong><br><a href=""https://github.com/osscafe/gulp-cheatsheet"" rel=""nofollow noreferrer"">Gulp 备忘录</a><br><a href=""https://github.com/johnpapa/gulp-patterns"" rel=""nofollow noreferrer"">Gulp清单</a></p>
<p><strong>gulp插件部分</strong></p>
<p><strong>一、编译</strong><br><a href=""https://github.com/dlmanning/gulp-sass"" rel=""nofollow noreferrer"">gulp-sass</a> - 通过 libsass将Sass编译成 CSS<br><a href=""https://github.com/sindresorhus/gulp-ruby-sass"" rel=""nofollow noreferrer"">gulp-ruby-sass</a> - 通过 Ruby Sass将Sass编译成CSS<br><a href=""https://github.com/appleboy/gulp-compass"" rel=""nofollow noreferrer"">gulp-compass</a> - 通过 Ruby Sass和CompassSass编译成CSS<br><a href=""https://github.com/plus3network/gulp-less"" rel=""nofollow noreferrer"">gulp-less</a> - Less编译成 CSS.<br><a href=""https://github.com/stevelacy/gulp-stylus"" rel=""nofollow noreferrer"">gulp-stylus</a> - Stylus 编译成 CSS.<br><a href=""https://github.com/postcss/gulp-postcss"" rel=""nofollow noreferrer"">gulp-postcss</a> - Pipe CSS 通过 PostCSS processors with a single parse.<br><a href=""https://github.com/contra/gulp-coffee"" rel=""nofollow noreferrer"">gulp-coffee</a> - Coffeescript 编译成 JavaScript.<br><a href=""https://github.com/ivogabe/gulp-typescript"" rel=""nofollow noreferrer"">gulp-typescript</a> - TypeScript编译成JavaScript.<br><a href=""https://github.com/sindresorhus/gulp-react"" rel=""nofollow noreferrer"">gulp-react</a> - Facebook React JSX 模板编译成JavaScript.<br><a href=""https://github.com/shama/webpack-stream"" rel=""nofollow noreferrer"">webpack-stream</a> - 将webpack集成在Gulp中使用。<br><a href=""https://github.com/babel/gulp-babel"" rel=""nofollow noreferrer"">gulp-babel</a> - ES6编译成ES5 通过 babel.<br><a href=""https://github.com/sindresorhus/gulp-traceur"" rel=""nofollow noreferrer"">gulp-traceur</a> - ES6编译成ES5 通过 Traceur.<br><a href=""https://github.com/sindresorhus/gulp-regenerator"" rel=""nofollow noreferrer"">gulp-regenerator</a> - ES6编译成ES5 通过 Regenerator.<br><a href=""https://github.com/sindresorhus/gulp-myth"" rel=""nofollow noreferrer"">gulp-myth</a> - Myth - a polyfill for future versions of the CSS spec.</p>
<p><strong>二、合并</strong><br><a href=""https://github.com/contra/gulp-concat"" rel=""nofollow noreferrer"">gulp-concat</a> - 合并文件.</p>
<p><strong>三、压缩</strong><br><a href=""https://github.com/scniro/gulp-clean-css"" rel=""nofollow noreferrer"">gulp-clean-css</a> - 压缩 CSS 通过 clean-css.<br><a href=""https://github.com/ben-eb/gulp-csso"" rel=""nofollow noreferrer"">gulp-csso</a> - 压缩 CSS 通过 CSSO.<br><a href=""https://github.com/terinjokes/gulp-uglify"" rel=""nofollow noreferrer"">gulp-uglify</a> - 压缩 JavaScript 通过 UglifyJS2.<br><a href=""https://github.com/jonschlinkert/gulp-htmlmin"" rel=""nofollow noreferrer"">gulp-htmlmin</a> - 压缩 HTML 通过 html-minifier.<br><a href=""https://github.com/murphydanger/gulp-minify-html"" rel=""nofollow noreferrer"">gulp-minify-html</a> - 压缩 HTML 通过 Minimize.<br><a href=""https://github.com/sindresorhus/gulp-imagemin"" rel=""nofollow noreferrer"">gulp-imagemin</a> - 压缩 PNG, JPEG, GIF and SVG 图片 通过 imagemin.<br><a href=""https://github.com/ben-eb/gulp-svgmin"" rel=""nofollow noreferrer"">gulp-svgmin</a> - 通过Gulp压缩 SVG 文件</p>
<p><strong>四、优化</strong><br><a href=""https://github.com/ben-eb/gulp-uncss"" rel=""nofollow noreferrer"">gulp-uncss</a> - 移除未使用的CSS选择器通过 UnCSS.<br><a href=""https://github.com/zckrs/gulp-css-base64"" rel=""nofollow noreferrer"">gulp-css-base64</a> - 将CSS文件中所有的资源(有url()声明的)变成base64-encoded 数据的URI字符串<br><a href=""https://github.com/akoenig/gulp-svg2png"" rel=""nofollow noreferrer"">gulp-svg2png</a> - 将SVGs转换成PNGs<br><a href=""https://github.com/mahnunchik/gulp-responsive"" rel=""nofollow noreferrer"">gulp-responsive</a> - 生成不同尺寸的图片<br><a href=""https://github.com/w0rm/gulp-svgstore"" rel=""nofollow noreferrer"">gulp-svgstore</a> -将svg files 合并成一个通过 元素<br><a href=""https://github.com/nfroidure/gulp-iconfont"" rel=""nofollow noreferrer"">gulp-iconfont</a> - 通过SVG icons创建 icon fonts</p>
<p><strong>五、资源注入</strong><br><a href=""https://github.com/jonkemp/gulp-useref"" rel=""nofollow noreferrer"">gulp-useref</a> - 解析HTML文件中特殊标签里面的script或style标签，合并成一个script或css文件，并替换。<br><a href=""https://github.com/klei/gulp-inject"" rel=""nofollow noreferrer"">gulp-inject</a> - 将指定的css或js文件以标签的形式插入到HTML中的指定标志内。<br><a href=""https://github.com/lazd/gulp-handlebars"" rel=""nofollow noreferrer"">wiredep</a> - 将Bower依赖自动注入HTML文件中。</p>
<p><strong>六、模板</strong><br><a href=""https://github.com/miickel/gulp-angular-templatecache"" rel=""nofollow noreferrer"">gulp-angular-templatecache</a> - 在$templateCache中联系并注册AngularJS模板<br><a href=""https://github.com/phated/gulp-jade"" rel=""nofollow noreferrer"">gulp-jade</a> - Jade 转换成 HTML.<br><a href=""https://github.com/lazd/gulp-handlebars"" rel=""nofollow noreferrer"">gulp-handlebars</a> - Handlebars模板转换成 JavaScript.<br><a href=""https://github.com/shannonmoeller/gulp-hb"" rel=""nofollow noreferrer"">gulp-hb</a> - Handlebars 模板转换成 HTML.<br><a href=""https://github.com/sindresorhus/gulp-nunjucks"" rel=""nofollow noreferrer"">gulp-nunjucks</a> - Nunjucks模板转换成JavaScript.<br><a href=""https://github.com/sindresorhus/gulp-dust"" rel=""nofollow noreferrer"">gulp-dustjs</a> - Dust模板转换成JavaScript.<br><a href=""https://github.com/e-jigsaw/gulp-riot"" rel=""nofollow noreferrer"">gulp-riot</a> - Riot模板转换成JavaScript.<br><a href=""https://github.com/sindresorhus/gulp-markdown"" rel=""nofollow noreferrer"">gulp-markdown</a> - Markdown → HTML.<br><a href=""https://github.com/sindresorhus/gulp-template"" rel=""nofollow noreferrer"">gulp-template</a> - Lodash 模板转换成JavaScript.<br><a href=""https://github.com/colynb/gulp-swig"" rel=""nofollow noreferrer"">gulp-swig</a> - Swig模板转换成HTML.<br><a href=""https://github.com/denysdovhan/gulp-remark"" rel=""nofollow noreferrer"">gulp-remark</a> - Gulp plugin for [remark]的Gulp插件(<a href=""https://github.com/wooorm/remark)"" rel=""nofollow noreferrer"">https://github.com/wooorm/rem...</a> 通过插件处理markdown</p>
<p><strong>七、代码校验</strong><br><a href=""https://www.npmjs.com/package/gulp-csslint"" rel=""nofollow noreferrer"">gulp-csslint</a> - 通过CSSLint自动校验CSS.<br><a href=""https://github.com/bezoerb/gulp-htmlhint"" rel=""nofollow noreferrer"">gulp-htmlhint</a> - 通过HTMLHint校验HTML.<br><a href=""https://github.com/spalger/gulp-jshint"" rel=""nofollow noreferrer"">gulp-jshint</a> - 通过JSHint发现错误和潜在的问题.<br><a href=""https://github.com/jscs-dev/gulp-jscs"" rel=""nofollow noreferrer"">gulp-jscs</a> - 通过jscs检查JavaScript代码风格.<br><a href=""https://github.com/janraasch/gulp-coffeelint"" rel=""nofollow noreferrer"">gulp-coffeelint</a> - 一种用来保证CoffeeScript代码风格统一的检查。<br><a href=""https://github.com/panuhorsmalahti/gulp-tslint"" rel=""nofollow noreferrer"">gulp-tslint</a> - gulp的TypeScript代码校验插件.<br><a href=""https://github.com/adametry/gulp-eslint"" rel=""nofollow noreferrer"">gulp-eslint</a> - ECMAScript/JavaScript代码校验.<br><a href=""https://github.com/callumacrae/gulp-w3cjs"" rel=""nofollow noreferrer"">gulp-w3cjs</a> - 通过w3cjs检验HTML.<br><a href=""https://github.com/lesshint/gulp-lesshint"" rel=""nofollow noreferrer"">gulp-lesshint</a> - 通过lesshint校验LESS.</p>
<p><strong>八、实时加载</strong><br><a href=""https://github.com/BrowserSync/browser-sync"" rel=""nofollow noreferrer"">browser-sync</a> - 保证多个浏览器或设备网页同步显示 (recipes).<br><a href=""https://github.com/vohof/gulp-livereload"" rel=""nofollow noreferrer"">gulp-livereload</a> - Gulp的实时加载插件.</p>
<p><strong>九、缓存</strong><br><a href=""https://github.com/sindresorhus/gulp-changed"" rel=""nofollow noreferrer"">gulp-changed</a> - 仅让发生改变的文件通过.<br><a href=""https://github.com/contra/gulp-cached"" rel=""nofollow noreferrer"">gulp-cached</a> - 一个简单的文件内存缓存.<br><a href=""https://github.com/ahaurw01/gulp-remember"" rel=""nofollow noreferrer"">gulp-remember</a> - 记忆并回收通过了的文件.<br><a href=""https://github.com/tschaub/gulp-newer"" rel=""nofollow noreferrer"">gulp-newer</a> - 只让新的源码通过.</p>
<p><strong>十、流控制</strong><br><a href=""https://github.com/grncdr/merge-stream"" rel=""nofollow noreferrer"">merge-stream</a> - 合并多个流到一个插入的流.<br><a href=""https://github.com/nfroidure/StreamQueue"" rel=""nofollow noreferrer"">streamqueue</a> - 逐渐输入队列的流.<br><a href=""https://github.com/OverZealous/run-sequence"" rel=""nofollow noreferrer"">run-sequence</a> - 按要求运行一些依赖的Gulptask.<br><a href=""https://github.com/robrich/gulp-if"" rel=""nofollow noreferrer"">gulp-if</a> - 按照条件运行task.</p>
<p><strong>十一、日志</strong><br><a href=""https://github.com/mikaelbr/gulp-notify"" rel=""nofollow noreferrer"">gulp-notify</a> - Gulp的通知插件.<br><a href=""https://github.com/sindresorhus/gulp-size"" rel=""nofollow noreferrer"">gulp-size</a> - 显示你的项目的大小.<br><a href=""https://github.com/sindresorhus/gulp-debug"" rel=""nofollow noreferrer"">gulp-debug</a> - 通过调试文件流来观察那些文件通过了你的Gulp管道.</p>
<p><strong>十二、测试</strong><br><a href=""https://github.com/sindresorhus/gulp-mocha"" rel=""nofollow noreferrer"">gulp-mocha</a> - 运行Mocha测试用例.<br><a href=""https://github.com/sindresorhus/gulp-jasmine"" rel=""nofollow noreferrer"">gulp-jasmine</a> - 在Node.js中运行Jasmine 2 测试用例.<br><a href=""https://github.com/mllrsohn/gulp-protractor"" rel=""nofollow noreferrer"">gulp-protractor</a> - 为Protractor测试用例包裹Gulp.<br><a href=""https://github.com/dylanb/gulp-coverage"" rel=""nofollow noreferrer"">gulp-coverage</a> - 为Node.js覆盖相对于运行的测试运行独立的报告.<br><a href=""https://github.com/karma-runner/gulp-karma"" rel=""nofollow noreferrer"">gulp-karma</a> - 通过Gulp运行Karma测试用例.<br><a href=""https://github.com/sindresorhus/gulp-ava"" rel=""nofollow noreferrer"">gulp-ava</a>- 通过Gulp运行AVA 测试用例.</p>
<p><strong>十三、其他插件</strong><br><a href=""https://github.com/gulpjs/gulp-util"" rel=""nofollow noreferrer"">gulp-util</a> - 包含一系列有用插件.<br><a href=""https://github.com/floatdrop/gulp-plumber"" rel=""nofollow noreferrer"">gulp-plumber</a> - 防止错误引起管道中断Prevent pipe breaking caused by errors.<br><a href=""https://github.com/jackfranklin/gulp-load-plugins"" rel=""nofollow noreferrer"">gulp-load-plugins</a> - 自动加载Gulp插件.<br><a href=""https://github.com/ck86/main-bower-files"" rel=""nofollow noreferrer"">main-bower-files</a> - 构建时自动获取bower库的文件.<br><a href=""https://github.com/postcss/autoprefixer"" rel=""nofollow noreferrer"">autoprefixer</a> - 解析CSS且根据规则添加浏览器兼容性前缀.<br><a href=""https://github.com/floridoo/gulp-sourcemaps"" rel=""nofollow noreferrer"">gulp-sourcemaps</a> - 提供source map支持.<br><a href=""https://github.com/lazd/gulp-replace"" rel=""nofollow noreferrer"">gulp-replace</a> - Gulp的一个字符串替换插件.<br><a href=""https://github.com/hparra/gulp-rename"" rel=""nofollow noreferrer"">gulp-rename</a> - 轻松重命名文件.<br><a href=""https://github.com/sindresorhus/gulp-rev"" rel=""nofollow noreferrer"">gulp-rev</a> - 在静态文件名的后面添加hash值，如: unicorn.css → unicorn-d41d8cd98f.css.<br><a href=""https://github.com/sindresorhus/del"" rel=""nofollow noreferrer"">del</a> - 使用globs删除文件/文件夹.<br><a href=""https://github.com/robrich/gulp-exec"" rel=""nofollow noreferrer"">gulp-exec</a> - 运行一个shell命令.<br><a href=""https://github.com/sindresorhus/gulp-strip-debug"" rel=""nofollow noreferrer"">gulp-strip-debug</a> - 除去javascript代码中的console,alert,debugger声明.<br><a href=""https://github.com/unlight/gulp-cssimport"" rel=""nofollow noreferrer"">gulp-cssimport</a> - 解析CSS文件，找到imports,将连接文件替换成imort声明.<br><a href=""https://github.com/jonkemp/gulp-inline-css"" rel=""nofollow noreferrer"">gulp-inline-css</a> - 将HTML中的css属性放到style标签中.<br><a href=""https://github.com/shinnn/gulp-gh-pages"" rel=""nofollow noreferrer"">gulp-gh-pages</a> - 将内容发布到GiHub有页面.<br><a href=""https://github.com/Kagami/gulp-ng-annotate"" rel=""nofollow noreferrer"">gulp-ng-annotate</a> - 通过ng-annotate添加Angular依赖注入.<br><a href=""https://github.com/stevelacy/gulp-bump"" rel=""nofollow noreferrer"">gulp-bump</a> - 通过Gulp Bump任何semvar JSON版本.<br><a href=""https://github.com/coderhaoxin/gulp-file-include"" rel=""nofollow noreferrer"">gulp-file-include</a> - 通过Gulp Include文件.<br><a href=""https://github.com/sindresorhus/gulp-zip"" rel=""nofollow noreferrer"">gulp-zip</a> - 以ZIP格式压缩文件.<br><a href=""https://github.com/stevelacy/gulp-git"" rel=""nofollow noreferrer"">gulp-git</a> - 通过Gulp运行git命令.<br><a href=""https://github.com/sindresorhus/gulp-filter"" rel=""nofollow noreferrer"">gulp-filter</a> - 使用globbing过滤文件.<br><a href=""https://github.com/jas/gulp-preprocess"" rel=""nofollow noreferrer"">gulp-preprocess</a> - 基于自定义内容或环境配置预处理文件.</p>
<p><strong>脚手架</strong></p>
<p><strong>一、模板</strong><br><a href=""https://github.com/google/web-starter-kit"" rel=""nofollow noreferrer"">web-starter-kit</a> - Google的Web Starter Kit.<br><a href=""https://github.com/sindresorhus/gulp-plugin-boilerplate"" rel=""nofollow noreferrer"">gulp-plugin-boilerplate</a> - 创建Gulp插件的开始模板.<br><a href=""https://github.com/polymerelements/polymer-starter-kit"" rel=""nofollow noreferrer"">polymer-starter-kit</a> -Polymer 1.0 应用的起点.<br><a href=""https://github.com/este/este"" rel=""nofollow noreferrer"">este</a> - 同构的web应用最全面的React/Flux开发栈和开始模板.<br><a href=""https://github.com/mrmrs/mnml"" rel=""nofollow noreferrer"">mnml</a> - 开发响应式HTML5/Sass项目的最小开始模板.<br><a href=""https://github.com/cferdinandi/kraken"" rel=""nofollow noreferrer"">kraken</a> 一个轻量级的、移动端优先的前端开发开始模板.<br><a href=""https://github.com/jakemmarsh/angularjs-gulp-browserify-boilerplate"" rel=""nofollow noreferrer"">angularjs-gulp-browserify-boilerplate</a> - 一个使用AngularJS, Sass, gulp, 和 Browserify技术的开始模板.<br><a href=""https://github.com/poeticninja/hapi-ninja"" rel=""nofollow noreferrer"">hapi-ninja</a> - 一个使用Node.js, Hapi, and Swig技术的开始模板.<br><a href=""https://github.com/rappasoft/laravel-5-boilerplate"" rel=""nofollow noreferrer"">laravel-5-boilerplate</a> - 一个Laravel 5 开始模板.<br><a href=""https://github.com/wbkd/react-starterkit"" rel=""nofollow noreferrer"">react-starterkit</a> - 包含react-router, Reflux, jest, webpack, gulp and Stylus的React开始模板.</p>
<p><strong>二、Yeoman生成器</strong><br><a href=""https://github.com/yeoman/generator-gulp-webapp"" rel=""nofollow noreferrer"">generator-gulp-webapp</a> - A 一个流行的web应用的gulp生成器.<br><a href=""https://github.com/Swiip/generator-gulp-angular"" rel=""nofollow noreferrer"">generator-gulp-angular</a> - 使用Gulp的AngularJS 的Yeoman生成器.<br><a href=""https://github.com/randylien/generator-react-gulp-browserify"" rel=""nofollow noreferrer"">generator-react-gulp-browserify</a> - 一个React库的Yeoman生成器，包含gulp, Browserify, Browsersync and Bootstrap.<br><a href=""https://github.com/youngmountain/generator-node-gulp"" rel=""nofollow noreferrer"">generator-node-gulp</a> - 一个Node.js模块生成器，包含gulp和 Mocha.<br><a href=""https://github.com/niallobrien/generator-gulp-bootstrap"" rel=""nofollow noreferrer"">generator-gulp-bootstrap</a> - 一个包含Bootstrap, gulp 和libsass的Yeoman生成器·.<br><a href=""https://github.com/jgoux/generator-angulpify"" rel=""nofollow noreferrer"">generator-angulpify</a> - 一个包含AngularJS, gulp和Browserify的Yeoman生成器.<br><a href=""https://github.com/tmaximini/generator-ionic-gulp"" rel=""nofollow noreferrer"">generator-ionic-gulp</a> - 一个Ionic工厂的Yeoman生成器.<br><a href=""https://github.com/sindresorhus/generator-gulp-plugin-boilerplate"" rel=""nofollow noreferrer"">generator-gulp-plugin-boilerplate</a> -一个输出 gulp plugin boilerplate的脚手架.<br><a href=""https://github.com/sondr3/generator-jekyllized"" rel=""nofollow noreferrer"">generator-jekyllized</a> - 一个包含gulp, Sass, AutoPrefixer,资源优化，缓存等的Jekyll工作流.</p>
<p><strong>三、其他</strong><br><a href=""https://github.com/laravel/elixir"" rel=""nofollow noreferrer"">elixir</a> - 一个为你的应用定义基本的gulp任务的干净、灵活的API.<br><a href=""https://github.com/sindresorhus/gulp-app"" rel=""nofollow noreferrer"">gulp-app</a> - 将Gulp作为一个应用(OS X).<br><a href=""https://github.com/Lostmyname/lmn-gulp-tasks"" rel=""nofollow noreferrer"">lmn-gulp-tasks</a> - gulp任务的单元测试示例.<br><a href=""http://gulp-cookery.github.io/gulp-chef/"" rel=""nofollow noreferrer"">gulp-chef</a> - 一个优雅的、简单的重复使用gulp task的方法.</p>

                ", 做一个合格的前端，gulp资源大集合,1531977733,396,1,480,1,1,https://segmentfault.com/a/1190000012910261
52,1,0,7,"
                    
<h2>项目1.0版本源码</h2>
<p><a href=""https://github.com/wephone/MeiZhuoRPC/tree/1.0"" rel=""nofollow noreferrer"">https://github.com/wephone/Me...</a></p>
<hr>
<p>在<a href=""https://segmentfault.com/a/1190000012870365"" rel=""nofollow noreferrer"">上一博文</a>中 跟大家讲了RPC的实现思路 思路毕竟只是思路 那么这篇就带着源码给大家讲解下实现过程中的各个具体问题</p>
<h4>读懂本篇需要的基本知识 若尚未清晰请自行了解后再阅读本文</h4>
<ul>
<li>java动态代理</li>
<li>netty框架的基本使用</li>
<li>spring的基本配置</li>
</ul>
<h2>最终项目的使用如下</h2>
<pre><code>/**
 *调用端代码及spring配置
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={""file:src/test/java/rpcTest/ClientContext.xml""})
public class Client {

    @Test
    public void start(){
        Service service= (Service) RPC.call(Service.class);
        System.out.println(""测试Integer,Double类型传参与返回String对象:""+service.stringMethodIntegerArgsTest(233,666.66));
        //输出string233666.66
    }

}

/**
 *Service抽象及其实现
 *调用与实现端共同依赖Service
 */
public interface Service {
    String stringMethodIntegerArgsTest(Integer a,Double b);
}
/**
 * ServiceImpl实现端对接口的具体实现
*/
public class ServiceImpl implements Service {
    @Override
    public String stringMethodIntegerArgsTest(Integer a, Double b) {
        return ""String""+a+b;
    }
}</code></pre>
<p>1.0版本分3个包</p>
<ul>
<li>Client 调用端</li>
<li>Server 实现端</li>
<li>Core 核心方法</li>
</ul>
<h4>首先看这句代码</h4>
<p>调用端只需如此调用 <br>定义接口 传入接口类类型  后面调用的接口内的方法 全部是由实现端实现</p>
<pre><code>Service service= (Service) RPC.call(Service.class);</code></pre>
<p>这句的作用其实就是生成调用端的动态代理</p>
<pre><code>/**
     * 暴露调用端使用的静态方法 为抽象接口生成动态代理对象
     * TODO 考虑后面优化不在使用时仍需强转
     * @param cls 抽象接口的类类型
     * @return 接口生成的动态代理对象
     */
    public static Object call(Class cls){
        RPCProxyHandler handler=new RPCProxyHandler();
        Object proxyObj=Proxy.newProxyInstance(cls.getClassLoader(),new Class&lt;?&gt;[]{cls},handler);
        return proxyObj;
    }</code></pre>
<p>RPCProxyHandler为动态代理的方法被调用后的回调方法 每个方法被调用时都会执行这个invoke</p>
<pre><code>/**
     * 代理抽象接口调用的方法
     * 发送方法信息给服务端 加锁等待服务端返回
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        RPCRequest request=new RPCRequest();
        request.setRequestID(buildRequestID(method.getName()));
        request.setClassName(method.getDeclaringClass().getName());//返回表示声明由此 Method 对象表示的方法的类或接口的Class对象
        request.setMethodName(method.getName());
//        request.setParameterTypes(method.getParameterTypes());//返回形参类型
        request.setParameters(args);//输入的实参
        RPCRequestNet.requestLockMap.put(request.getRequestID(),request);
        RPCRequestNet.connect().send(request);
        //调用用结束后移除对应的condition映射关系
        RPCRequestNet.requestLockMap.remove(request.getRequestID());
        return request.getResult();//目标方法的返回结果
    }</code></pre>
<p>也就是收集对应调用的接口的信息 然后send给实现端<br>那么这个requestLockMap又是作何作用的呢</p>
<ul>
<li>由于我们的<strong>网络调用都是异步</strong>的</li>
<li>但是<strong>RPC调用都要做到同步</strong> 等待这个远程调用方法完全返回后再继续执行</li>
<li>所以将每个请求的<strong>request对象作为对象锁</strong> 每个请求发送后加锁 等到网络异步调用返回后再释放所</li>
<li>生成每个请求的ID 这里我用随机数加时间戳</li>
<li>
<strong>将请求ID和请求对象维护在静态全局的一个map</strong>中 实现端通过ID来对应是哪个请求</li>
<li>异步调用返回后 通过ID notify唤醒对应请求对象的线程</li>
</ul>
<p>netty异步返回的调用 释放对象锁</p>
<pre><code>@Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        String responseJson= (String) msg;
        RPCResponse response= (RPCResponse) RPC.responseDecode(responseJson);
        synchronized (RPCRequestNet.requestLockMap.get(response.getRequestID())) {
            //唤醒在该对象锁上wait的线程
            RPCRequest request= (RPCRequest) RPCRequestNet.requestLockMap.get(response.getRequestID());
            request.setResult(response.getResult());
            request.notifyAll();
        }
    }</code></pre>
<p>接下来是RPCRequestNet.connect().send(request);方法<br>connect方法其实是单例模式返回RPCRequestNet实例<br>RPCRequestNet构造方法是使用netty对实现端进行TCP链接<br>send方法如下</p>
<pre><code>try {
            //判断连接是否已完成 只在连接启动时会产生阻塞
            if (RPCRequestHandler.channelCtx==null){
                connectlock.lock();
                //挂起等待连接成功
                System.out.println(""正在等待连接实现端"");
                connectCondition.await();
                connectlock.unlock();
            }
            //编解码对象为json 发送请求
            String requestJson= null;
            try {
                requestJson = RPC.requestEncode(request);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
            ByteBuf requestBuf= Unpooled.copiedBuffer(requestJson.getBytes());
            RPCRequestHandler.channelCtx.writeAndFlush(requestBuf);
            System.out.println(""调用""+request.getRequestID()+""已发送"");
            //挂起等待实现端处理完毕返回 TODO 后续配置超时时间
            synchronized (request) {
                //放弃对象锁 并阻塞等待notify
                request.wait();
            }
            System.out.println(""调用""+request.getRequestID()+""接收完毕"");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }</code></pre>
<p>condition和lock同样是为了同步等待异步IO返回用的<br>send方法基本是编解码json后发送给实现端</p>
<h3>调用端基本实现综上所述 代理 发送 同步锁</h3>
<hr>
<h3>下面是服务端的使用和实现</h3>
<pre><code>/**
 *实现端代码及spring配置
 */
 @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(locations={""file:src/test/java/rpcTest/ServerContext.xml""})
 public class Server {
 
     @Test
     public void start(){
         //启动spring后才可启动 防止容器尚未加载完毕
         RPC.start();
     }
 }</code></pre>
<p>出了配置spring之外 实现端就一句 RPC.start()<br>其实就是启动netty服务器<br>服务端的处理客户端信息回调如下</p>
<pre><code>@Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws IOException {
        String requestJson= (String) msg;
        System.out.println(""receive request:""+requestJson);
        RPCRequest request= RPC.requestDeocde(requestJson);
        Object result=InvokeServiceUtil.invoke(request);
        //netty的write方法并没有直接写入通道(为避免多次唤醒多路复用选择器)
        //而是把待发送的消息放到缓冲数组中，flush方法再全部写到通道中
//        ctx.write(resp);
        //记得加分隔符 不然客户端一直不会处理
        RPCResponse response=new RPCResponse();
        response.setRequestID(request.getRequestID());
        response.setResult(result);
        String respStr=RPC.responseEncode(response);
        ByteBuf responseBuf= Unpooled.copiedBuffer(respStr.getBytes());
        ctx.writeAndFlush(responseBuf);
    }</code></pre>
<p>主要是编解码json 反射对应的方法 我们看看反射的工具类</p>
<pre><code>/**
     * 反射调用相应实现类并结果
     * @param request
     * @return
     */
    public static Object invoke(RPCRequest request){
        Object result=null;//内部变量必须赋值 全局变量才不用
        //实现类名
        String implClassName= RPC.getServerConfig().getServerImplMap().get(request.getClassName());
        try {
            Class implClass=Class.forName(implClassName);
            Object[] parameters=request.getParameters();
            int parameterNums=request.getParameters().length;
            Class[] parameterTypes=new Class[parameterNums];
            for (int i = 0; i &lt;parameterNums ; i++) {
                parameterTypes[i]=parameters[i].getClass();
            }
            Method method=implClass.getDeclaredMethod(request.getMethodName(),parameterTypes);
            Object implObj=implClass.newInstance();
            result=method.invoke(implObj,parameters);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return result;
    }</code></pre>
<p>解析Parameters getClass获取他们的类类型 反射调用对应的方法</p>
<h2>这里需要注意一个点</h2>
<ul>
<li>本文最初采用Gson处理json  但<strong>gson默认会把int类型转为double类型</strong>  例如2变为2.0 不适用本场景 我也不想去专门适配</li>
<li>所以换用了jackson</li>
<li>常见json处理框架 反序列化为对象时  int,long等基本类型都会变成他们的包装类Integer Long</li>
<li>所以<strong>本例程中 远程调度接口方法的形参不可以使用int等基本类型</strong>
</li>
<li>否则method.invoke(implObj,parameters);会找不到对应的方法报错</li>
<li>因为parameters已经是包装类了 而method还是int这些基本类 所以找不到对应方法</li>
</ul>
<hr>
<p>最后是借助spring配置基础配置<br>我写了两个类 ServerConfig ClientConfig 作为调用端和服务端的配置 <br>只需<strong>在spring中配置这两个bean</strong> 并启动IOC容器即可</p>
<p>调用端</p>
<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;beans xmlns=""http://www.springframework.org/schema/beans""
       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
       xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd""&gt;
    &lt;bean class=""org.meizhuo.rpc.client.ClientConfig""&gt;
        &lt;property name=""host"" value=""127.0.0.1""&gt;&lt;/property&gt;
        &lt;property name=""port"" value=""9999""&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>实现端</p>
<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
 &lt;beans xmlns=""http://www.springframework.org/schema/beans""
        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
        xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd""&gt;
     &lt;bean class=""org.meizhuo.rpc.server.ServerConfig""&gt;
         &lt;property name=""port"" value=""9999""&gt;&lt;/property&gt;
         &lt;property name=""serverImplMap""&gt;
             &lt;map&gt;
                 &lt;!--配置对应的抽象接口及其实现--&gt;
                 &lt;entry key=""rpcTest.Service"" value=""rpcTest.ServiceImpl""&gt;&lt;/entry&gt;
             &lt;/map&gt;
         &lt;/property&gt;
     &lt;/bean&gt;
 &lt;/beans&gt;</code></pre>
<h3>最后有个小问题</h3>
<p>我们的框架是作为一个依赖包引入的 我们不可能在我们的框架中读取对应的spring xml<br>这样完全是去了框架的灵活性 <br>那我们怎么在<strong>运行过程中获得我们所处于的IOC容器</strong> 已获得我们的正确配置信息呢<br>答案是spring提供的<strong>ApplicationContextAware</strong>接口</p>
<pre><code>/**
 * Created by wephone on 17-12-26.
 */
public class ClientConfig implements ApplicationContextAware {

    private String host;
    private int port;
    //调用超时时间
    private long overtime;

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public long getOvertime() {
        return overtime;
    }

    public void setOvertime(long overtime) {
        this.overtime = overtime;
    }

    /**
     * 加载Spring配置文件时，如果Spring配置文件中所定义的Bean类
     * 如果该类实现了ApplicationContextAware接口
     * 那么在加载Spring配置文件时，会自动调用ApplicationContextAware接口中的
     * @param applicationContext
     * @throws BeansException
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        RPC.clientContext=applicationContext;
    }
}</code></pre>
<p>这样我们在RPC类内部就维护了一个静态IOC容器的context<br>只需如此获取配置<br>RPC.getServerConfig().getPort()</p>
<pre><code> public static ServerConfig getServerConfig(){
        return serverContext.getBean(ServerConfig.class);
    }</code></pre>
<h3>就这样 这个RPC框架的核心部分 已经讲述完毕了</h3>
<p>本例程仅为1.0版本<br>后续博客中 会加入异常处理 zookeeper支持 负载均衡策略等<br><a href=""http://blog.csdn.net/we_phone/article/details/78993394"" rel=""nofollow noreferrer"">博客:zookeeper支持</a><br>欢迎持续关注 欢迎star 提issue</p>

                ", RPC框架原理及从零实现系列博客(二):11个类实现简单RPC框架,1531977734,337,1,743,1,1,https://segmentfault.com/a/1190000012903221
53,1,0,7,"
                    
<h1>组件介绍</h1>
<p>OOMDetector是手Q自研的IOS内存监控组件，腾讯内部目前已有多个App接入了OOMDetector，它主要有以下两个功能：</p>
<ul>
<li>爆内存堆栈统计：负责记录进程内存分配堆栈和内存块大小，在爆内存时Dump堆栈数据到磁盘</li>
<li>内存泄漏检测：检测内存泄漏，目前支持Malloc内存块和OC对象的泄漏检测</li>
</ul>
<p>OOMDetector可以快速帮助开发者发现和定位App爆内存问题和内存泄漏，组件目前已经在Github开源，源码地址：<a href=""https://github.com/Tencent/OOMDetector"" rel=""nofollow noreferrer"">https://github.com/Tencent/OO...</a>。</p>
<h1>背景</h1>
<p>目前业内已有一些比较的IOS内存分析工具，下面逐个介绍这些工具的功能以及它们在使用上的不足。</p>
<h2>Allocation</h2>
<p>作为IOS开发，我们都很熟悉苹果官方提供的Allocation内存分析工具，在开发调试阶段，可以用Allocation详细分析App各模块内存占用。Allocation对App的内存监控比较全面，能监控到所有堆内存以及部分VM内存分配。虽然Allocation的功能比较强大，但是它也有比较明显的使用局限性，主要表现为以下两点：</p>
<ul>
<li>无法独立在App运行，只能在调试阶段连接Mac使用</li>
<li>性能较差，大型App开启后容易引发卡死</li>
</ul>
<p>这两点限制决定了Allocation只适合于在开发阶段辅助分析代码中存在的内存问题，而无法直接对线上用户的问题进行监控和定位。</p>
<h2>FBAllocationTracker</h2>
<p>FBAllocationTracker是Facebook开源的内存分析工具，它的原理是用 Method Swizzling替换原本的alloc方法，这样可以在App运行时记录所有OC实例的分配信息，帮助App在运行阶段发现一些OC对象的异常增长问题。相比Allocation，FBAllocationTracker对App性能影响较低，可以在App中独立运行。但是这个工具也有比较明显的缺陷：</p>
<ul>
<li>监控范围不够全面，只能监控OC对象，不能监控C++对象和malloc内存块以及VM内存</li>
<li>没有内存对象分配的堆栈信息，对于开发者来说很难只通过对象的类型和数量定位到内存增长的原因</li>
</ul>
<p>综上所述，FBAllocationTracker虽然能独立在App中运行，但是监控的内存范围太小，同时记录的对象信息也过于简单，对于分析内存问题帮助十分有限。</p>
<p>内存问题一直是手Q的关注重点，为了保证线上大盘用户的内存质量，我们希望有一款工具能够帮助监控和定位线上用户的内存问题。基于这样的背景，我们团队自研了OOMDetector组件。OOMDetector通过Hook系统底层的内存分配方法，能够记录到进程所有内存分配的堆栈信息，同时组件能够在对性能流畅度影响不大的情况下能够保证在App中独立运行，可以方便用于分析和监控线上用户的内存问题（爆内存或者内存泄漏问题）。</p>
<h1>组件原理</h1>
<h2>爆内存堆栈统计</h2>
<p><strong>爆内存堆栈监控原理</strong></p>
<p>爆内存堆栈监控的实现原理如图1所示，通过Hook IOS系统底层内存分配的相关方法（包括malloc_zone相关的堆内存分配以及vm_allocate对应的VM内存分配方法），跟踪并记录进程中每个对象内存的分配信息，包括分配堆栈、累计分配次数、累计分配内存等，这些信息也会被缓存到进程内存中。在内存触顶的时候，组件会定时Dump这些堆栈信息到本地磁盘，这样如果程序爆内存了，就可以将爆内存前Dump的堆栈数据上报到后台服务器进行分析。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825291?w=572&amp;h=288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图1 爆内存监控原理</p>
<p><strong>性能挑战</strong></p>
<p>App的内存分配方法的调用频率非常高，在大型App中可能高达10W/次每秒。要Hook这类方法对组件的性能来说是极大的挑战，因为如果组件本身耗时的话就很容易导致App卡顿甚至卡死。在OOMDetector中，我们对Hook方法代码的执行效率进行了严格控制，也采取了一些策略对Hook方法中耗时较多的堆栈回溯和锁等待进行了优化：</p>
<ul><li>优化堆栈回溯方法</li></ul>
<p>对于堆栈回溯，系统提供了backtrace_symbols方法可以直接获取堆栈信息，但是这个方法特别耗时。所以我们根据堆栈的回溯原理实现了更高效的堆栈回溯方法，优化后的方法在运行时只会获取堆栈函数的地址信息，在回写磁盘的时候再根据动态库的地址范围拼装成如图2所示堆栈格式（类似Crash堆栈），后台服务器利用atos命令和符号表文件就可以还原出对应的堆栈内容。通过这种方式可以把耗时较高的符号还原工作放到服务器端，客户端只需要执行耗时较少的堆栈函数地址回溯操作，优化后的堆栈回溯方法耗时低于1us。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825292?w=369&amp;h=245"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图2 堆栈格式</p>
<ul><li>优化锁等待耗时</li></ul>
<p>对于多线程的内存分配，为了保证线程安全，堆栈数据的插入操作必须要上锁。对于这种高频调用的方法，锁的性能是我们最关心的指标。IOS开发中NSLock和@synchronized是比较常用的，那么这两种锁的性能如何呢？</p>
<p>我们通过测试代码对IOS中常用的锁进行了测试，总结了图2所示的各种锁的性能比较图，根据图3的测试结果，NSLock和@synchronized的性能要低于pthread_mutex，性能最好的是自旋锁OSSpinLock。</p>
<p>自旋锁的原理是，如果自旋锁已经被别的执行单元保持，调用者就一直循环等待锁的释放。相比互斥锁而言，自旋锁不会引起调用者休眠，节省了线程休眠的状态切换，所以有更高的效率，但代价是增加了cpu的使用率。对于我们的场景，因为需要上锁部分的代码执行耗时较少，采用OSSpinLock的自旋锁并不会显著增加cpu的使用率，所以我们优先考虑锁的效率采用了OSSpinLock的方案。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825293?w=640&amp;h=417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图3 各种锁的性能比较</p>
<p><strong>堆栈聚类和压缩</strong></p>
<p>之前提到，我们的Hook方法会缓存每个内存分配的堆栈数据。假设App的内存块个数为25W，堆栈平均深度20行，每个堆栈地址采用8字节的整型数据存储，那么25W个堆栈数据将占用40M的内存空间。显然这样的内存增长对于任何App都是不可承受的，所以我们需要对组件的内存占用进行优化。</p>
<p>我们分析爆内存问题时候，只需要分析那些内存占用较大的堆栈，基本不用关心那些内存占用较小的堆栈。所以我们的优化思路也很明确：只保留内存占用较大的堆栈。要完成这个工作就必须对内存中所有堆栈先进行聚类合并，统计出每个堆栈累计的内存值。</p>
<p>具体的优化策略如图4所示，对于每个记录到的分配堆栈，首先通过md5算法将堆栈数据压缩为16字节的md5，通过md5值进行聚类，缓存中只保留16字节的md5数据，只有当某个堆栈的累计内存超过一定阀值时，才会保留原始堆栈信息，这样因为超过阀值的堆栈数量有限，堆栈原始信息占用的空间几乎就可以忽略不计了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825294?w=562&amp;h=267"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图4 堆栈聚类和压缩原理</p>
<p>采用两种方式可以将堆栈降低到优化前的1/40左右，优化后的组件内存基本不会对App的内存造成太大影响。</p>
<p><strong>数据Dump方案</strong></p>
<p>前面提到，在内存触顶后要将内存中的堆栈数据定时Dump到磁盘中，常规的方案是IO接口直接把数据写入到磁盘。因为数据Dump的频率较高，频繁的IO操作会导致程序卡顿。因为数据Dump的操作是非常高频的，所以我们采用了效率更高的mmap方式。</p>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间。实现这样的直接映射关系后，写文件的过程进程不会有额外的文件的数据拷贝操作，避免了内核空间和用户空间的频繁切换，如图5所示。根据我们的代码实测，向mmap映射空间写数据的性能与直接写内存一致，效率远高于IO操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825295?w=488&amp;h=324"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图5 内存映射原理</p>
<p>那么mmap的回写时机是怎样的？根据官方文档描述，主要有如下时机：</p>
<ul>
<li>系统内存不足时</li>
<li>进程crash时</li>
<li>主动调用 msync时</li>
</ul>
<p>mmap 在内存不足时会主动进行回写操作，这样的机制也保证我们的监控组件能在程序爆内存前将缓存中的数据回写到磁盘，从这一点看采用mmap的方式相比常规IO操作也有更强可靠性。</p>
<p><strong>内存泄漏检测</strong></p>
<p>除了爆内存堆栈监控，OOMDetector还集成了内存泄漏检测功能，能够检测Malloc内存块和OC对象的“无主内存泄漏”。所谓“无主内存泄漏”是指内存块在进程内已经没有引用却无法正常释放的内存块。</p>
<p>按照之前介绍的方案，OOMDetector可以记录到每一个对象的分配堆栈信息，要从这些对象中找出 “泄漏对象”，我们需要知道在程序可访问的进程内存空间中，是否有“指针变量”指向对应的内存块，那些在整个进程内存空间都没有指针指向的内存块，就是我们要找的泄漏内存块。如图2所示，在IOS系统中，可能包含指针变量的内存区域有堆内存、栈内存、全局数据区和寄存器，OOMDetector 通过对这些区域遍历扫描即可找到所有可能的“指针变量”，整个扫描流程结束后都没有“指针变量”指向的内存块即是泄漏内存块。</p>
<p>为了避免内存访问冲突，扫描过程需要挂起所有线程，整个过程会卡住程序1-2秒。因为扫描过程较为耗时，这个功能目前主要用于App的测试阶段，与自动化测试结合可快速高效的发现泄漏问题。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825296?w=858&amp;h=472"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图6 内存泄漏检测原理</p>
<h1>展望</h1>
<p>开源只是开始，我们后续仍会不断对OOMDetector组件进行改进，也欢迎大家对组件多提意见。如果你的IOS应用也在受到内存问题困扰或者你也对IOS内存监控技术感兴趣，那么来了解下我们的组件吧！</p>

                ", 【腾讯开源】iOS爆内存问题解决方案-OOMDetector组件,1531977735,239,1,229,1,1,https://segmentfault.com/a/1190000012825286
54,1,0,7,"
                    <p><a href=""https://wdd.js.org/2017-my-star-collection.html"" rel=""nofollow noreferrer"">阅读原文</a></p>
                ", 回首2017: 你其实是一个收集贝壳的孩子,1531977736,583,1,309,1,1,https://segmentfault.com/a/1190000012622179
55,1,0,7,"
                    
<h1>前言</h1>
<p>最原始的软件开发流程是，在本地搭建好环境，进行开发测试，然后去服务器上搭建环境，手动上传代码，运行测试，然后启动服务。实际上，近些年来出现了很多的工具，使得这些步骤可以自动化，大大降低人工出错的概率，提高生产效率。下面，我就把GitLab+Jenkins+Rsync+PM2实现的Node项目的持续集成以及自动部署的实验过程记录下来。</p>
<h1>搭建环境</h1>
<p>需要两台服务器作为演示,A主要进行代码管理、构建和分发，B主要运行实际应用。我这边系统使用的是Debian系的。</p>
<h2>服务器A</h2>
<h3>GitLab</h3>
<p>准备工作：</p>
<pre><code>apt-get update
apt-get install curl openssh-server ca-certificates postfix
</code></pre>
<p>安装postfix的时候，选internet site，之后的 system mail name 填写你的服务器的IP地址。</p>
<p>准备好后开始安装：</p>
<pre><code>curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash
apt-get install gitlab-ee
</code></pre>
<p>如果 apt 下载很慢可以手动下载 <code>https://packages.gitlab.com/gitlab/gitlab-ee/packages/ubuntu/trusty/gitlab-ee_10.2.2-ee.0_amd64.deb</code> 然后用 <code>dpkg -i</code> 的方式安装。装了这个过后 NGINX, Postgres, Redis 就都装好了。</p>
<p>配置：</p>
<p>GitLab默认会占用80、8080和9090端口，Jenkins默认也会使用8080端口，所以将GitLab的默认端口为60200、60201、60202（你可以随意定制）</p>
<p><code>vim /etc/gitlab/gitlab.rb</code> 修改</p>
<pre><code>external_url 'http://&lt;你的服务器ip&gt;:60200'
unicorn['port'] = 60201
prometheus['listen_address'] = 'localhost:60202'
</code></pre>
<p>注意不能有多余空格。<code>gitlab-ctl reconfigure</code>生效配置，<code>gitlab-ctl start</code>启动。<br>如果要想发邮件的话还要配置第三方邮件 <code>vim /etc/gitlab/gitlab.rb</code></p>
<pre><code>gitlab_rails['smtp_enable'] = true 
gitlab_rails['smtp_address'] = ""smtp.exmail.qq.com""
gitlab_rails['smtp_port'] = 465
gitlab_rails['smtp_user_name'] = ""***#**""
gitlab_rails['smtp_password'] = ""**************""
gitlab_rails['smtp_domain'] = ""qq.com""
gitlab_rails['smtp_authentication'] = :login 
gitlab_rails['smtp_enable_starttls_auto'] = true
gitlab_rails['smtp_tls'] = true
gitlab_rails['gitlab_email_from'] = ""***#**""
user[""git_user_email""] = ""***#**""
</code></pre>
<p>然后生效重启，打开<code>http://&lt;你的服务器IP&gt;:60200</code>访问，</p>
<h3>Jenkins</h3>
<p>准备工作：</p>
<pre><code>wget --no-cookies --no-check-certificate --header ""Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie"" ""http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.tar.gz""
tar xzvf jdk-8u151-linux-x64.tar.gz -C /usr/local/  
vim /etc/profile #(加入环境变量)
    export JAVA_HOME=/usr/local/jdk1.8.0_151
    export PATH=$JAVA_HOME/bin:$PATH
</code></pre>
<p>退出，<code>source /etc/profile</code> 生效，用 <code>java -version</code> 验证是否装好java。</p>
<p>开始安装：</p>
<p><code>curl -O http://mirrors.jenkins.io/war-stable/latest/jenkins.war</code> 下载Jenkins，<br><code>nohup java -jar  jenkins.war --httpPort=60203 &amp;</code> 后台启动并指定端口。<br>至此，Jenkins安装成功，可以用浏览器打开 <code>http://&lt;你的服务器ip&gt;:60203</code> <br>然后安装必要的插件（会提示你），依次点击 “系统管理” “管理插件”。<br>切换到“可选插件”，分别搜索“GitLab Plugin”和“Git Plugin”,然后点击“直接安装”。如果在“可选插件”里没有搜到，可能自带安装了</p>
<h3>Node</h3>
<pre><code>apt-get update
apt-get install -y build-essential curl
curl -sL https://deb.nodesource.com/setup_8.x | bash 
apt-get install -y nodejs
node -v
v8.9.2
npm -v
5.5.1
</code></pre>
<h3>Rsync</h3>
<p>这个服务器主要使用Rsync来发布文件，所以不需要特殊配置，一般Linux都默认安装了，如果没有,则使用 <code>apt-get install rsync</code>。然后配置Rsync密码</p>
<pre><code>echo ""123"" &gt;&gt; /etc/rsync.password
chmod -R 600 /etc/rsync.password
</code></pre>
<h2>服务器B</h2>
<h3>Node</h3>
<p>如A</p>
<h3>PM2</h3>
<pre><code>npm install -g pm2
pm2 -v
2.8.0
</code></pre>
<h3>Rsync</h3>
<p>为了安全性不要直接使用ssh账号密码或者公钥私钥，而是构建Rsync服务。<code>vim /etc/rsyncd.conf</code>，修改配置，下面的配置只是一个示例，生产环境还要更安全的策略。</p>
<pre><code>##rsyncd.conf start##
uid = root
gid = root
use chroot = yes
max connections = 200
timeout = 300
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsyncd.log
ignore errors
read only = false
list = false
hosts allow = * 
hosts deny =10.0.8.9
auth users = backuser
secrets file = /etc/rsync.password
[webapp]
path = /var/webapp/</code></pre>
<p>上面的的路径path不存在则需要创建 <code>mkdir /var/webapp</code>  <br><code>echo ""backuser:123"" &gt;&gt; /etc/rsync.password</code> 添加账号和密码，密码要与客户端（A）一直<br><code>chmod -R 600 /etc/rsync.password </code> 修改权限<br><code>rsync --daemon</code> 以守护进程方式来启动rsync服务<br><code>chkconfig rsync on </code>将此服务设置成为开机自启动</p>
<h1>应用开发</h1>
<p>用express开发一个 hello world 作为演示，在本地工程目录</p>
<pre><code>npm init #(按照提示输入参数)
npm install express --save  #（安装express）
</code></pre>
<p>然后创建app.js</p>
<pre><code>var express = require('express');
var app = express();

app.get('/', function (req, res) {
  res.send('Hello World!');
});

var server = app.listen(3000, function () {
  var host = server.address().address;
  var port = server.address().port;

  console.log('Example app listening at http://%s:%s', host, port);
});
</code></pre>
<p><code>node app.js</code> 运行，然后<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:3000/ 会得到 hello world</p>
<p>新建app.json</p>
<pre><code>{
    ""apps"" : [
        {
            ""name""        : ""app"",
            ""script""      : ""app.js"",
            ""log_date_format""  : ""YYYY-MM-DD HH:mm:SS"",
            ""env"": {
                ""NODE_ENV"": ""production""
            },
            ""watch"" : [
                ""app.js"",
                ""router"",
                ""util""
            ],
            ""ignore_watch"" : [
                ""logs"",
                ""node_modules"",
                ""test""
            ]
        }
    ]
}
</code></pre>
<p>将代码上传至服务器B，然后 <code>pm2 start app.json</code> 运行 即可在浏览器访问 <a href=""http://B-ip"" rel=""nofollow noreferrer"">http://B-ip</a>:3000 得到 hello world</p>
<h1>持续集成和自动部署</h1>
<h2>配置 Gitlab</h2>
<p>首次登陆的密码是会提示你去服务器找，用户是root，然后修改你的用户账号信息，添加你自己常用的电脑上的git公钥。<br>创建一个新项目 webapp ，创建好过后项目会显示该项目对应的用户信息（会提示你修改）</p>
<pre><code>Git global setup

git config --global user.name ""MageekChiu""
git config --global user.email ""mageekchiu@mail.**.cn""
</code></pre>
<p>在本地项目目录下，新建 .gitignore 文件（window 要用 命令行 rename才可以）</p>
<pre><code>### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

node_modules/
</code></pre>
<p>然后执行</p>
<pre><code>git init
git remote add origin git@A-ip:root/webapp.git
git add .
git commit -m ""Initial commit""
git push -u origin master
</code></pre>
<p>即可提交服务器仓库，以后每次修改都要</p>
<pre><code>git add .
git commit -m ""修改备注""

</code></pre>
<h2>配置 jenkins</h2>
<p><strong>首先配置GitLab插件：</strong><br>打开GitLab，点击“setting”——“Account”，复制“Private token”，或者应该首先生成personal access token。<br>打开Jenkins，点击“系统管理”——“系统设置”，点击“配置”下拉框，点击“Gitlab”选项配置GitLab<br>Connection Name 随便，如 gitlab，“Git Host URL”填GitLab的访问地址，<br>然后Credentials点“Add”——“jenkins”，在弹出框里，“kind”选择“GitLab API Token”，将先前复制的“Private token”粘贴到“API token”输入框中，然后点击“Add”，添加后，Credentials选择刚刚新建的gitlab，<br>最后点击“test connection”,看到“Success”就成功了。然后点击页面底下的“apply”,再点击“save”</p>
<p><strong>然后配置Git插件：</strong><br>需要注意的是装Jenkins的机器上一定要装git: <code>apt-get install git</code> 这样Jenkins才能去 gitlab 拉取文件。<br>打开Jenkins，点击“系统管理”——“系统设置”，点击“配置”下拉框，选择“Git plugin”选项，设置Git插件的全局配置，填入上面的 global setting 如 <code>global user.name</code>等，然后点击“apply”——“save” </p>
<p><strong>生成访问Gitlab的ssh秘钥：</strong><br>打开GitLab，点击右上角的“setting”—— SSH Keys，就可以进入到添加界面。<br>在jenkins所在服务器上生成密钥</p>
<pre><code>ssh-keygen -t rsa -C ""root@&lt;你服务器的ip地址&gt;"" -b 4096
ssh-keygen -t rsa -C ""root@"" -b 4096</code></pre>
<p>全部按 Enter 使用默认值，这会生成一对公钥和私钥。打开公钥复制到gitlab的添加界面，然后点击“add key”，并记住私钥的存放路径。</p>
<p><strong>创建一个Jenkins Job：</strong><br>直接点新建，“item name”可以随便起，然后点击“构建一个自由风格的软件项目”，点击“OK”，至此，创建一个Job成功了。然后配置这个job，选择“源码管理”，选择“Git”,然后去GitLab中复制项目地址，粘贴到“Repository URL”,然后点击“credentials”后面的“Add”按钮<br>在弹出页面里面：<br>  ● Kind 选择 SSH Username with private key<br>  ● Username 填 root<br>  ● PrivateKey 选择 From a file on jenkins master ，然后将服务器的 私钥的存放路径（/root/.ssh/id_rsa ） 粘贴进去<br>然后点击“Add”，在“credentials”里选择我们刚刚创建的认证方式。如果没报错，说明成功了，点击页面底部的“apply”。如果出错了，会在“Repository URL”和“Credentials”之间显示红色的错误信息。</p>
<p>选择 构建触发器：<br>选择 Build when a change is pushed to GitLab. 记住这个 GitLab CI Service URL ，点击高级<br>Secret token 那一行下面 点击 generate。记住这个token <br>选择 构建：<br>选择 execute shell</p>
<pre><code>npm install 
WEB_SERVER_IP=B的ip
PROJECT=webapp/
rsync -arqz --delete-before $WORKSPACE/ $WEB_SERVER_IP::$PROJECT --exclude "".git"" --password-file=/etc/rsync.password 
</code></pre>
<p>这一段代码的主要目的是构建，并分发代码，如果有多个应用服务器就要分发到多个服务器上。</p>
<p><strong>配置gitab的webhook:</strong><br>点击webapp 项目下面的setting的integrations 输入刚才的 GitLab CI Service URL 和 Secret Token<br>然后点击add webhook ,再测试一下选择 push events 如果显示Hook executed successfully: HTTP 200 即成功，然后在jenkins里面查看是有一次构建记录的。</p>
<p>这样jenkins就会在代码发生变化时自动拉取代码到本地，构建，然后用rsync分发给各个应用服务器，结合PM2的watch功能实现自动发现代码更新并重启的功能，达到自动部署的目的</p>
<h1>最终效果测试</h1>
<p>修改代码，把<code>hello world</code>改为<code>hello gitlab+enkins</code>然后 add、commit、push 。在A上面gitlab有提交记录，jenkins有构建记录，在B上面用 pm2 ls 发现项目是restart了，浏览器查看也变成hello gitlab+enkins 了。<br>尝试成功！<br>虽然这个配置比较麻烦，但是持续集成和自动部署的带来的好处是更大的：代码有版本管理，可以快速迭代、快速回滚，同时保持高质量、自动多机部署防止人工错误，每次构建都有记录，构建幂等......</p>
<h1>参考</h1>
<p><a href=""http://blog.csdn.net/ruangong1203/article/details/73065410"" rel=""nofollow noreferrer"">http://blog.csdn.net/ruangong...</a></p>
<p><a href=""http://mageek.cn/archives/45/"" rel=""nofollow noreferrer"">原文 mageek</a></p>
<h1>后记</h1>
<p>这个过程已经比较自动化了，但是还是有太多的环境搭建过程，比如webapp一般都会用到mysql、redis、MongoDB等等，一个更自动化的过程应该引入docker，这方面以后有机会再尝试。</p>

                ", GitLab+Jenkins+Rsync+PM2实现Node项目的持续集成与自动部署,1531977737,270,1,969,1,1,https://segmentfault.com/a/1190000012509128
56,1,0,7,"
                    
<p>下面通过三种方法来搭建公司私有npm仓库，每种方式都有自己的优势。</p>
<blockquote>Node.js &gt;= 6.11.3，我的Node版本：node v8.2.1  <br>Linux or OSX，我的系统版本：CentOS Linux release 7.2.1511 (Core)</blockquote>
<p><a href=""https://github.com/jaywcjlove/handbook/blob/master/CentOS/%E5%9C%A85%E5%88%86%E9%92%9F%E5%86%85%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%A7%81%E6%9C%89npm%E4%BB%93%E5%BA%93.md"" rel=""nofollow noreferrer"">教程归档在我的Github中欢迎修正和Star</a></p>
<h2>cnpm搭建</h2>
<h3>安装</h3>
<pre><code class=""bash"">npm install -g --build-from-source cnpmjs.org cnpm sqlite3
# 如果报错或者警告通过下面方式安装
npm install -g --unsafe-perm --verbose --build-from-source cnpmjs.org cnpm sqlite3</code></pre>
<p>如果安装不流畅通过下面形式安装：</p>
<pre><code class=""bash"">npm install -g --build-from-source \
  --registry=https://registry.npm.taobao.org \
  --disturl=https://npm.taobao.org/mirrors/node \
  cnpmjs.org cnpm sqlite3</code></pre>
<p>如果报警告或者安装错误，请添加参数<code>--unsafe-perm --verbose</code></p>
<h3>启动并配置服务</h3>
<blockquote>管理员：<code>myname,othername</code>  <br>范围：<code>my-company-name,other-name</code>  <br>默认端口：7001-registry, 7002-web</blockquote>
<p>启动服务</p>
<pre><code class=""bash"">$ nohup cnpmjs.org start --admins='myname,othername' \
  --scopes='@my-company-name,@other-name' &amp;</code></pre>
<h3>设置注册地址</h3>
<p>将cnpm默认注册地址更改为私有注册地址</p>
<pre><code class=""bash"">cnpm set registry http://localhost:7001</code></pre>
<h3>登录cnpm</h3>
<pre><code class=""bash"">$ cnpm login
Username: myname
Password: ***
Email: (this IS public) test@test.com</code></pre>
<h3>包上传到私有仓库</h3>
<p>新建项目</p>
<pre><code>$ cd /tmp
$ mkdir helloworld &amp;&amp; cd helloworld
$ cnpm init
name: (helloworld) @my-company-name/helloworld
version: (1.0.0)

{
  ""name"": ""@my-company-name/helloworld"",
  ""version"": ""1.0.0"",
  ""description"": ""my first scoped package"",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1""
  },
  ""author"": """",
  ""license"": ""ISC""
}</code></pre>
<p>上传到私有仓库</p>
<pre><code class=""bash"">$ cnpm publish
+ @my-company-name/helloworld@1.0.0</code></pre>
<h3>查看预览包</h3>
<p>浏览器中预览</p>
<pre><code class=""bash"">open http://localhost:7002/@my-company-name/helloworld</code></pre>
<p>使用<code>cnpm</code>预览</p>
<pre><code>cnpm info</code></pre>
<h3>安装</h3>
<p>所有公共包都可直接使用<code>cnpm</code>安装</p>
<pre><code class=""bash"">cnpm install hotkeys-js</code></pre>
<h2>通过verdaccio搭建</h2>
<p><a href=""https://github.com/verdaccio/verdaccio"" rel=""nofollow noreferrer"">verdaccio</a> 是一个轻量级的私有npm代理注册。（<a href=""https://github.com/rlidwka/sinopia"" rel=""nofollow noreferrer"">sinopia</a> fork）</p>
<h3>安装</h3>
<pre><code class=""bash""># 使用 npm 安装
npm install -g npm

# 使用 yarn 安装
yarn global add verdaccio</code></pre>
<h3>启动服务</h3>
<pre><code class=""bash"">verdaccio &gt;&gt; verdaccio.log 2&gt;&amp;1 &amp; # 后台启动并写入日志

# Verdaccio doesn't need superuser privileges. Don't run it under root.
# warn --- config file  - /root/.config/verdaccio/config.yaml
# warn --- http address - http://localhost:4873/ - verdaccio/2.3.6

verdaccio --listen 4000 --config ./config.yaml # 指定配置启动</code></pre>
<h3>添加用户/登录</h3>
<pre><code class=""bash"">npm adduser --registry  http://localhost:4873</code></pre>
<h3>上传私有包</h3>
<pre><code class=""bash"">npm publish --registry http://localhost:4873</code></pre>
<h3>本地配置注册地址</h3>
<pre><code class=""bash"">npm config list -l # 查看默认配置
# 将默认地址 https://registry.npmjs.org/ 改成私有地址
npm set registry http://localhost:4873
# 如果您使用HTTPS，请添加适当的CA信息
#（“null”表示从操作系统获取CA列表）
$ npm set ca null</code></pre>
<h2>Git仓库当私有npm</h2>
<p>这个方法得益于，npm提供的的丰富安装方法。通过下面方法安装：</p>
<pre><code class=""bash"">npm i -S git+ssh://git@git.showgold.cn:npm/hello.git

npm install -S git+ssh://git@github.com:npm/npm.git#v1.0.27
npm install -S git+ssh://git@github.com:npm/npm#semver:^5.0
npm install -S git+https://isaacs@github.com/npm/npm.git
npm install -S git://github.com/npm/npm.git#v1.0.27</code></pre>
<p>⚠️ 上面安装需要注意：你的工程一定是在某一个组下面建立，方便管理，在生成你的包的时候<code>package.json</code>中的<code>name</code>一定要带上范围</p>
<h3>建立一个私有模块</h3>
<pre><code class=""bash""># 假设你建立了一个Git仓库，先克隆下来
git clone http://git.your-inc.com/companyfe/hello-private.git

# 生成 `package.json` 配置, 注意限定 `@scope` 范围
npm init --scope=companyfe
# 提交到仓库
git push origin master</code></pre>
<p>⚠️ 将得到如下依赖，注意：</p>
<blockquote>
<code>name</code>字段必须限定范围，一般为 GitLab group 的名字, 例如 <code>@companyfe</code>, 那么 <code>name</code> 为: <code>@companyfe/hello-private</code>。  <br><code>private</code> 设为 <code>true</code> 防止将私有模块上传到公网上去，需要手动设置一下。</blockquote>
<pre><code class=""json"">{
  ""name"": ""@companyfe/hello-private"",
  ""version"": ""1.0.1"",
  ""description"": """",
  ""main"": ""index.js"",
  ""private"":true,
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1""
  },
  ""author"": ""kenny wang &lt;wowohoo@qq.com&gt; (http://wangchujiang.com)"",
  ""license"": ""ISC""
}</code></pre>
<h3>安装使用私有模块</h3>
<p>跟安装开源的模块一样, 使用 <code>npm install</code> 安装依赖即可. 私有模块会安装在 <code>@scope</code> 的子文件夹中, 例如: <code>node_modules/@companyfe/hello-private</code>.</p>
<pre><code class=""bash""># 基础安装
npm i -S git+ssh://git@git.your-inc.com/companyfe/hello-private.git
# 带版本信息的，必须通过 git 打 tag
npm i -S git+ssh://git@git.your-inc.com/companyfe/hello-private.git#v1.2.0</code></pre>
<p>将得到如下依赖</p>
<pre><code class=""json"">{
  ""name"": ""helloworld"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1""
  },
  ""dependencies"": {
    ""@companyfe/hello-private"": ""git+ssh://git@git.your-inc.com/companyfe/hello-private.git#v1.2.0""
  },
  ""author"": ""kenny wang &lt;wowohoo@qq.com&gt; (http://wangchujiang.com)"",
  ""license"": ""ISC""
}</code></pre>
<p>使用私有模块</p>
<pre><code class=""js"">var hello = require('@companyfe/hello-private');</code></pre>
<h3>优劣势</h3>
<p>不好的地方是，使用 <code>npm update</code> 是无法更新私有模块，想更新只能重新安装一次。好处是不用搭建服务。</p>
<h2>参考资料</h2>
<ul><li><a href=""https://docs.npmjs.com/misc/registry#can-i-run-my-own-private-registry"" rel=""nofollow noreferrer"">Can I run my own private registry?</a></li></ul>

                ", 在5分钟内搭建企业内部私有npm仓库,1531977739,137,1,608,1,1,https://segmentfault.com/a/1190000012483764
57,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481176?w=1920&amp;h=1440"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<h3>前提</h3>
<p>为什么会再次写这篇博客？请看下图：<br>&lt;!-- more --&gt;</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481177?w=1061&amp;h=971"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>这是我博客搜索引擎的主要关键字。为什么会有这些关键字呢？</p>
<p>我猜估计是曾经写了几篇关于搭建博客的文章，被搜索引擎收入了，所以搜索引擎才会将这些流量引导至我的博客，文章如下：</p>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E5%88%A9%E7%94%A8Github%20Page%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"" rel=""nofollow noreferrer"">利用Github Page 搭建个人博客网站</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/"" rel=""nofollow noreferrer"">Hexo + yilia 主题实现文章目录</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/"" rel=""nofollow noreferrer"">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p>
<p>那还有这么多人搜索这些关键字？说明碰到问题的还有不少，所以才有了这篇文章的诞生！</p>
<h3>问题解答</h3>
<p><strong>1、hexo  yilia 文章目录</strong></p>
<p>这个我以前写过一篇文章：<a href=""http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/"" rel=""nofollow noreferrer"">Hexo + yilia 主题实现文章目录</a>    那篇文章写了我那个版本的 yilia 怎么添加文章目录的，但是好像新版本的 yilia 已经自带了这个文章目录功能。所以如果你是使用的新版本的 yilia ，请不要做任何修改！但是前几天有人给我发了个图片，又好像有点区别，如果实在有不同的话，请加群 528776268 找我要我那个主题版本的所有配置文件。再次说明，我前端也不是很擅长，我写那篇文章也是参考其他博客的修改，所以无能为力了。有什么问题，建议直接在 yilia 主题的 GitHub 去找作者聊！</p>
<p><strong>2、Hexo  yilia  随笔</strong></p>
<p>随笔如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481178?w=254&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>对此想说的就是，“随笔”  其实就是文章的一个 tags(标签)，如果你想把文章作为随笔的话，请在文章的首部写个 tags  为 “随笔”   的标签。如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481179?w=1243&amp;h=261"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>注意：-  后面有个空格。</p>
<p><strong>3、yilia 主题分类实现</strong></p>
<p>如果要有多个标签，可以如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481180?w=1115&amp;h=147"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p><strong>4、hexo yilia 设置文章显示长度，不展开全文</strong></p>
<p>yilia 主题中可以用 <code>&lt;!-- more --&gt;</code>  截取文章的显示长度，如果你想在哪截取文章，就在那行使用该字符。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481181?w=1278&amp;h=458"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p><strong>5、yilia 添加阅读量</strong></p>
<p>我添加的是 “不蒜子” 计数，它可以区分 pv/uv 的统计方式，统计更精准，满足更多需求。有这个需求的可以去查找下博客怎么添加。（网上有很多这方面的博客）</p>
<p><strong>6、yilia 主题使用 “畅言” 评论系统</strong></p>
<p>参见我以前的文章：  <a href=""http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/"" rel=""nofollow noreferrer"">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p>
<p><strong>7、hexo yilia 引入音乐</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481182?w=1755&amp;h=730"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<pre><code class=""html"">&lt;iframe frameborder=""no"" border=""0"" marginwidth=""0"" marginheight=""0"" width=330 height=86 src=""填写音乐链接地址""&gt;&lt;/iframe&gt;</code></pre>
<p>如下图，可以在网易云音乐里搜到你想要引入的音乐，然后点击如下的 “生成外链播放器” 即可：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481183?w=1408&amp;h=792"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481184?w=1264&amp;h=853"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p><strong>8、hexo yilia 引入视频</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481185?w=1590&amp;h=761"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>hexo  支持 html 语法的，所以可以如上图这样引入视频！</p>
<p><strong>9、hexo  yilia  相册</strong></p>
<p>这个抱歉，我自己也没做这方面的功能，暂时不太清楚怎么实现。不过有文章写怎么实现，大家可以搜索下！</p>
<p><strong>10、hexo  yilia  怎么写文章</strong></p>
<p>我一般写文章就是先用本地 markdown 编辑器写好后，然后放在 hexo 的 <code>source/_posts</code> 目录下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012481186"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<h3>结尾</h3>
<p>好了，大概就这些问题，我也一一解答了，希望搭建博客的你可以看到这篇文章，让你少走点弯路，如果你也遇到过这些问题，还请你能分享下文章，让更多人避免入坑！</p>
<p>本文地址是：<a href=""http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia"" rel=""nofollow noreferrer"">Hexo + yilia 搭建博客可能会遇到的所有疑问</a>  本文原创，转载请注明原创地址。</p>
<h3>最后</h3>
<p><a href=""http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia</a>  这个链接是让推酷爬虫吞掉的，哈哈！</p>

                ", Hexo + yilia 搭建博客可能会遇到的所有疑问,1531977740,295,1,676,1,1,https://segmentfault.com/a/1190000012481171
58,1,0,7,"
                    
<p>最近一直在搞基础的东西，弄了一个持续更新的github笔记，可以去看看，诚意之作（本来就是写给自己看的……）链接地址：<a href=""https://qiqihaobenben.github.io/Front-End-Basics/"" rel=""nofollow noreferrer"">Front-End-Basics</a>  </p>
<p>此篇文章的地址：<a href=""https://qiqihaobenben.github.io/Front-End-Basics/JavaScript/utility/module"" rel=""nofollow noreferrer"">JavaScript的模块</a>  </p>
<p>基础笔记的github地址：<a href=""https://github.com/qiqihaobenben/Front-End-Basics"" rel=""nofollow noreferrer"">https://github.com/qiqihaobenben/Front-End-Basics</a> ,可以watch,也可以star。</p>
<hr>
<p>正文开始</p>
<hr>
<h2>JavaScript的模块</h2>
<h3>介绍</h3>
<p>模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。</p>
<h4>模块的优点</h4>
<ol>
<li>
<strong>可维护性。</strong>  因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。</li>
<li>
<strong>命名空间。</strong> 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。</li>
<li>
<strong>重用代码。</strong> 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。</li>
</ol>
<h3>CommonJS</h3>
<p>CommonJS 最开始是 Mozilla 的工程师于 2009 年开始的一个项目，它的目的是让浏览器之外的 JavaScript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。  </p>
<p>在 CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。  </p>
<p>需要注意的是，CommonJS 规范的主要适用场景是服务器端编程，所以采用同步加载模块的策略。如果我们依赖3个模块，代码会一个一个依次加载它们。  </p>
<p>该模块实现方案主要包含 require 与 module 这两个关键字，其允许某个模块对外暴露部分接口并且由其他模块导入使用。</p>
<pre><code>//sayModule.js
function SayModule () {
    this.hello = function () {
        console.log('hello');
    };

    this.goodbye = function () {
        console.log('goodbye');
    };
}

module.exports = SayModule;

//main.js 引入sayModule.js
var Say = require('./sayModule.js');
var sayer = new Say();
sayer.hello(); //hello</code></pre>
<p>作为一个服务器端的解决方案，CommonJS 需要一个兼容的脚本加载器作为前提条件。该脚本加载器必须支持名为 require 和 module.exports 的函数，它们将模块相互导入导出。</p>
<h4><code>Node.js</code></h4>
<p>Node 从 CommonJS 的一些创意中，创造出自己的模块化实现。由于Node 在服务端的流行，Node 的模块形式被（不正确地）称为 CommonJS。</p>
<p>Node.js模块可以分为两大类，一类是核心模块，另一类是文件模块。  <br><strong>核心模块</strong> 就是Node.js标准的API中提供的模块，如fs、http、net等，这些都是由Node.js官方提供的模块，编译成了二进制代码，可以直接通过require获取核心模块，例如require('fs')，核心模块拥有最高的加载优先级，如果有模块与核心模块命名冲突，Node.js总是会加载核心模块。  <br><strong>文件模块</strong> 是存储为单独的文件（或文件夹）的模块，可能是JavaScript代码、JSON或编译好的C/C++代码。在不显式指定文件模块扩展名的时候，Node.js会分别试图加上.js、.json、.node(编译好的C/C++代码)。</p>
<blockquote>加载方式</blockquote>
<ul><li>按路径加载模块</li></ul>
<p>如果require参数以""/""开头，那么就以绝对路径的方式查找模块名称，如果参数以""./""、""../""开头，那么则是以相对路径的方式来查找模块。</p>
<ul><li>通过查找node_modules目录加载模块</li></ul>
<p>如果require参数不以""/""、""./""、""../""开头，而该模块又不是核心模块，那么就要通过查找node_modules加载模块了。我们使用的npm获取的包通常就是以这种方式加载的。</p>
<blockquote>加载缓存</blockquote>
<p>Node.js模块不会被重复加载，这是因为Node.js通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。  <br><em>注意：</em> Node.js是根据实际文件名缓存的，而不是require()提供的参数缓存的，也就是说即使你分别通过require('express')和require('./node_modules/express')加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。  </p>
<p>Node.js 中的模块在加载之后是以单例化运行，并且遵循值传递原则：如果是一个对象，就相当于这个对象的引用。</p>
<blockquote>模块载入过程</blockquote>
<p>加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p>
<pre><code>例如运行： node app.js

Module.runMain = function () {
    // Load the main module--the command line argument.
    Module._load(process.argv[1], null, true);
};

//_load静态方法在分析文件名之后执行
var module = new Module(id, parent);

//并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载。
module.load(filename);</code></pre>
<p>具体说一下上文提到了文件模块的三类模块,这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法，具体的加载方法在下文<code>require.extensions</code>中会介绍。</p>
<ul>
<li>
<code>.js</code> 通过fs模块同步读取js文件并编译执行。</li>
<li>
<code>.node</code> 通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>
<li>
<code>.json</code> 读取文件，调用JSON.parse解析加载。</li>
</ul>
<p>接下来详细描述js后缀的编译过程。Node.js在编译js文件的过程中实际完成的步骤有对js文件内容进行头尾包装。以app.js为例，包装之后的app.js将会变成以下形式：</p>
<pre><code>//circle.js
var PI = Math.PI;
exports.area = function (r) {
    return PI * r * r;
};
exports.circumference = function (r) {
    return 2 * PI * r;
};

//app.js
var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is ' + circle.area(4));

//app包装后
(function (exports, require, module, __filename, __dirname) {
    var circle = require('./circle.js');
    console.log('The area of a circle of radius 4 is ' + circle.area(4));
});

//这段代码会通过vm原生模块的runInThisContext方法执行（类似eval，只是具有明确上下文，不污染全局），返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。</code></pre>
<p>这就是为什么require并没有定义在app.js 文件中，但是这个方法却存在的原因。从Node.js的API文档中可以看到还有<code>__filename</code>、<code>__dirname</code>、<code>module</code>、<code>exports</code>几个没有定义但是却存在的变量。其中<code>__filename</code>和<code>__dirname</code>在查找文件路径的过程中分析得到后传入的。<code>module</code>变量是这个模块对象自身，<code>exports</code>是在module的构造函数中初始化的一个空对象（{}，而不是null）。  <br>在这个主文件中，可以通过require方法去引入其余的模块。而其实这个require方法实际调用的就是module._load方法。  <br>load方法在载入、编译、缓存了module后，返回module的exports对象。这就是circle.js文件中只有定义在exports对象上的方法才能被外部调用的原因。  </p>
<p><strong>以上所描述的模块载入机制均定义在lib/module.js中。</strong></p>
<blockquote>require 函数</blockquote>
<p>require 引入的对象主要是函数。当 Node 调用 require() 函数，并且传递一个文件路径给它的时候，Node 会经历如下几个步骤：</p>
<ul>
<li>Resolving：找到文件的绝对路径；</li>
<li>Loading：判断文件内容类型；</li>
<li>Wrapping：打包，给这个文件赋予一个私有作用范围。这是使 require 和 module 模块在本地引用的一种方法；</li>
<li>Evaluating：VM 对加载的代码进行处理的地方；</li>
<li>Caching：当再次需要用这个文件的时候，不需要重复一遍上面步骤。</li>
</ul>
<blockquote>require.extensions 来查看对三种文件的支持情况</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bV0sHs?w=800&amp;h=443"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>可以清晰地看到 Node 对每种扩展名所使用的函数及其操作：对 .js 文件使用 module._compile；对 .json 文件使用 JSON.parse；对 .node 文件使用 process.dlopen。  </p>
<p><em>文件查找策略</em></p>
<ul><li>从文件模块缓存中加载</li></ul>
<p>尽管原生模块与文件模块的优先级不同，但是优先级最高的是从文件模块的缓存中加载已经存在的模块。</p>
<ul><li>从原生模块加载</li></ul>
<p>原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个<code>http</code>、<code>http.js</code>、<code>http.node</code>、<code>http.json</code>文件，<code>require(“http”)</code>都不会从这些文件中加载，而是从原生模块中加载。  <br>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>
<ul><li>从文件加载</li></ul>
<p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前面说过是调用load方法。 <br>··</p>
<pre><code>当 Node 遇到 require(X) 时，按下面的顺序处理。

（1）如果 X 是内置模块（比如 require('http'）) 
　　a. 返回该模块。 
　　b. 不再继续执行。

（2）如果 X 以 ""./"" 或者 ""/"" 或者 ""../"" 开头 
　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 
　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
        X
        X.js
        X.json
        X.node

　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
        X/package.json（main字段）
        X/index.js
        X/index.json
        X/index.node

（3）如果 X 不带路径 
　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。 
　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。

（4） 抛出 ""not found""</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0sHG?w=479&amp;h=601"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><br></p>
<blockquote>模块循环依赖</blockquote>
<pre><code>//创建两个文件，module1.js 和 module2.js，并且让它们相互引用
// module1.js
exports.a = 1;
require('./module2');
exports.b = 2;
exports.c = 3;

// module2.js
const Module1 = require('./module1');
console.log('Module1 is partially loaded here', Module1);

//执行 node module2.js 打印：Module1 is partially loaded here {a:1,b:2,c:3}
//执行 node module1.js 打印：Module1 is partially loaded here {a:1}</code></pre>
<p>在 module1 完全加载之前需要先加载 module2，而 module2 的加载又需要 module1。这种状态下，我们从 exports 对象中能得到的就是在发生循环依赖之前的这部分。上面代码中，只有 a 属性被引入，因为 b 和 c 都需要在引入 module2 之后才能加载进来。</p>
<p>Node 使这个问题简单化，在一个模块加载期间开始创建 exports 对象。如果它需要引入其他模块，并且有循环依赖，那么只能部分引入，也就是只能引入发生循环依赖之前所定义的这部分。</p>
<h3>AMD</h3>
<p>AMD 是 Asynchronous Module Definition 的简称，即“异步模块定义”，是从 CommonJS 讨论中诞生的。AMD 优先照顾浏览器的模块加载场景，使用了异步加载和回调的方式。  </p>
<p>AMD 和 CommonJS 一样需要脚本加载器，尽管 AMD 只需要对 define 方法的支持。define 方法需要三个参数：模块名称，模块运行的依赖数组，所有依赖都可用之后执行的函数（该函数按照依赖声明的顺序，接收依赖作为参数）。只有函数参数是必须的。define 既是一种引用模块的方式，也是定义模块的方式。</p>
<pre><code>// file lib/sayModule.js
define(function (){
    return {
        sayHello: function () {
            console.log('hello');
        }
    };
});

//file main.js
define(['./lib/sayModule'], function (say){
    say.sayHello(); //hello
})</code></pre>
<p>main.js 作为整个应用的入口模块，我们使用 define 关键字声明了该模块以及外部依赖(没有生命模块名称)；当我们执行该模块代码时，也就是执行 define 函数的第二个参数中定义的函数功能，其会在框架将所有的其他依赖模块加载完毕后被执行。这种延迟代码执行的技术也就保证了依赖的并发加载。</p>
<h4><code>RequireJS</code></h4>
<p>RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范,通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。</p>
<pre><code>&lt;script data-main='scripts/main' src='scripts/require.js'&gt;&lt;/script&gt;
//scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。</code></pre>
<p>defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。  <br><strong>1、独立模块 不依赖其他模块。直接定义</strong></p>
<pre><code>define({
    methodOne: function (){},
    methodTwo: function (){}
});

//等价于

define(function (){
    return {
        methodOne: function (){},
        methodTwo: function (){}
    };
});</code></pre>
<p><strong>2、非独立模块，对其他模块有依赖</strong></p>
<pre><code>define([ 'moduleOne', 'moduleTwo' ], function(mOne, mTwo){
    ...
});

//或者

define( function( require ){
    var mOne = require( 'moduleOne' ),
        mTwo = require( 'moduleTwo' );
    ...
});</code></pre>
<p>如上代码， define中有依赖模块数组的 和 没有依赖模块数组用require加载 这两种定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。</p>
<h3>CMD</h3>
<p>CMD（Common Module Definition），在CMD中，一个模块就是一个文件。  </p>
<p>全局函数define，用来定义模块。  <br>参数 factory  可以是一个函数，也可以为对象或者字符串。  <br>当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。  </p>
<p><em>定义JSON数据模块：</em></p>
<pre><code>define({ ""foo"": ""bar"" });</code></pre>
<p><em>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。</em></p>
<pre><code>define( function(require, exports, module) { 
    // 模块代码
});</code></pre>
<h4><code>SeaJS</code></h4>
<p><strong>sea.js 核心特征：</strong></p>
<ol>
<li>遵循CMD规范，与NodeJS般的书写模块代码。</li>
<li>依赖自动加载，配置清晰简洁。</li>
</ol>
<p><code>seajs.use</code>用来在页面中加载一个或者多个模块</p>
<pre><code>
 // 加载一个模块 
seajs.use('./a');

// 加载模块，加载完成时执行回调
seajs.use('./a'，function(a){
    a.doSomething();
});

// 加载多个模块执行回调
seajs.use(['./a','./b']，function(a , b){
    a.doSomething();
    b.doSomething();
});</code></pre>
<blockquote>
<code>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。</code>  <br>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。  <p><code>为什么说是执行时机处理不同？</code>  <br>同样都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。  <br>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>
</blockquote>
<h3>UMD</h3>
<p>统一模块定义（UMD：Universal Module Definition ）就是将 AMD 和 CommonJS 合在一起的一种尝试，常见的做法是将CommonJS 语法包裹在兼容 AMD 的代码中。</p>
<pre><code>(function(define) {
    define(function () {
        return {
            sayHello: function () {
                console.log('hello');
            }
        };
    });
}(
    typeof module === 'object' &amp;&amp; module.exports &amp;&amp; typeof define !== 'function' ?
    function (factory) { module.exports = factory(); } :
    define
));</code></pre>
<p>该模式的核心思想在于所谓的 IIFE（Immediately Invoked Function Expression），该函数会根据环境来判断需要的参数类别</p>
<h3>ES6模块(module)</h3>
<h4>严格模式 </h4>
<p>ES6 的模块自动采用严格模式，不管有没有在模块头部加上""use strict"";。  <br>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用arguments.callee</li>
<li>不能使用arguments.caller</li>
<li>禁止this指向全局对象</li>
<li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
<li>增加了保留字（比如protected、static和interface）</li>
</ul>
<h4>模块Module</h4>
<p>一个模块，就是一个对其他模块暴露自己的属性或者方法的文件。</p>
<h4>导出Export</h4>
<p>作为一个模块，它可以选择性地给其他模块暴露（提供）自己的属性和方法，供其他模块使用。</p>
<pre><code>// profile.js
export var firstName = 'qiqi';
export var lastName = 'haobenben';
export var year = 1992;

//等价于

var firstName = 'qiqi';
var lastName = 'haobenben';
var year = 1992;
export {firstName, lastName, year}
</code></pre>
<p><code>1、 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</code></p>
<pre><code>function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};

//上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</code></pre>
<p><code>2、 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</code></p>
<pre><code>// 报错
export 1;

// 报错
var m = 1;
export m;

//上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。

/ 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

// 写法三
var n = 1;
export {n as m};

//上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</code></pre>
<p><code>3、最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，接下来说的import命令也是如此。</code></p>
<pre><code>function foo() {
  export default 'bar' // SyntaxError
}
foo()</code></pre>
<h4>导入import</h4>
<p>作为一个模块，可以根据需要，引入其他模块的提供的属性或者方法，供自己模块使用。  </p>
<p><code>1、 import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</code></p>
<pre><code>import { lastName as surename } from './profile';</code></pre>
<p><code>2、import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</code>  </p>
<p><code>3、注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</code></p>
<pre><code>foo();

import { foo } from 'my_module';

//上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。</code></pre>
<p><code>4、由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</code></p>
<pre><code>/ 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}</code></pre>
<p><code>5、最后，import语句会执行所加载的模块，因此可以有下面的写法。</code></p>
<pre><code>import 'lodash';
//上面代码仅仅执行lodash模块，但是不输入任何值。</code></pre>
<h3>默认导出(export default)</h3>
<p>每个模块支持我们导出<code>一个</code>没有名字的变量，使用关键语句export default来实现.</p>
<pre><code>export default function(){
            console.log(""I am default Fn"");
        }
//使用export default关键字对外导出一个匿名函数，导入这个模块的时候，可以为这个匿名函数取任意的名字

//取任意名字均可
import sayDefault from ""./module-B.js"";
sayDefault();
//结果：I am default Fn</code></pre>
<p><code>1、默认输出和正常输出的比较</code></p>
<pre><code>// 第一组
export default function diff() { // 输出
  // ...
}

import diff from 'diff'; // 输入

// 第二组
export function diff() { // 输出
  // ...
};

import {diff} from 'diff'; // 输入

//上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</code></pre>
<blockquote>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</blockquote>
<p><br></p>
<p><code>2、因为export default本质是将该命令后面的值，赋给default变量以后再默认，所以直接将一个值写在export default之后。</code></p>
<pre><code>/ 正确
export default 42;

// 报错
export 42;

//上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。</code></pre>
<p><code>3、如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</code></p>
<pre><code>import _, { each } from 'lodash';

//对应上面代码的export语句如下
export default function (){
    //...
}
export function each (obj, iterator, context){
    //...
}</code></pre>
<h3>export 与 import 的复合写法</h3>
<p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<pre><code>export { foo, bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
export { foo, bar };

/ 接口改名
export { foo as myFoo } from 'my_module';

// 整体输出
export * from 'my_module';</code></pre>
<blockquote>注意事项  <br>1、声明的变量，对外都是只读的。但是导出的是对象类型的值，就可修改。  <br>2、导入不存在的变量，值为undefined。</blockquote>
<h4>ES6 中的循环引用</h4>
<p>ES6 中，imports 是 exprts 的只读视图，直白一点就是，imports 都指向 exports 原本的数据，比如：</p>
<pre><code>//------ lib.js ------
export let counter = 3;
export function incCounter() {
    counter++;
}

//------ main.js ------
import { counter, incCounter } from './lib';

// The imported value `counter` is live
console.log(counter); // 3
incCounter();
console.log(counter); // 4

// The imported value can’t be changed
counter++; // TypeError</code></pre>
<p>因此在 ES6 中处理循环引用特别简单，看下面这段代码：</p>
<pre><code>//------ a.js ------
import {bar} from 'b'; // (1)
export function foo() {
  bar(); // (2)
}

//------ b.js ------
import {foo} from 'a'; // (3)
export function bar() {
  if (Math.random()) {
    foo(); // (4)
  }
}</code></pre>
<p>假设先加载模块 a，在模块 a 加载完成之后，bar 间接性地指向的是模块 b 中的 bar。无论是加载完成的 imports 还是未完成的 imports，imports 和 exports 之间都有一个间接的联系，所以总是可以正常工作。</p>
<h4>实例</h4>
<pre><code>//---module-B.js文件---
//导出变量：name
export var name = ""cfangxu"";

moduleA模块代码：
//导入 模块B的属性 name    
import { name } from ""./module-B.js"";   
console.log(name)
//打印结果：cfangxu</code></pre>
<p><em>批量导出</em></p>
<pre><code>//属性name
var name = ""cfangxu"";
//属性age
var age  = 26;
//方法 say
var say = function(){
            console.log(""say hello"");
         }
//批量导出
export {name,age,say}</code></pre>
<p><em>批量导入</em></p>
<pre><code>//导入 模块B的属性
import { name,age,say } from ""./module-B.js"";
console.log(name)
//打印结果：cfangxu
console.log(age)
//打印结果：26
say()
//打印结果：say hello</code></pre>
<p><em>重命名导入变量</em></p>
<pre><code>import {name as myName} from './module-B.js';
console.log(myName) //cfangxu</code></pre>
<p><em>整体导入</em></p>
<pre><code>/使用*实现整体导入
import * as obj from ""./module-B.js"";

console.log(obj.name)
//结果：""cfangxu""
console.log(obj.age)
//结果：26
obj.say();
//结果：say hello
</code></pre>
<h3>推荐资料</h3>
<ul>
<li><a href=""http://blog.chinaunix.net/uid-26672038-id-4112229.html"" rel=""nofollow noreferrer""> JavaSript模块规范 - AMD规范与CMD规范介绍 </a></li>
<li><a href=""https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226355&amp;idx=1&amp;sn=aedf47d5a3be53f6c7d5562977624861&amp;chksm=bd4959778a3ed06198cbb746067393cd0f189612f4fc577417e0741df3a2b620373ea025978b&amp;scene=21#wechat_redirect"" rel=""nofollow noreferrer"">JavaScript 模块演化简史</a></li>
<li><a href=""http://www.ruanyifeng.com/blog/2015/05/require.html"" rel=""nofollow noreferrer"">require() 源码解读</a></li>
<li><a href=""https://segmentfault.com/a/1190000009060866#articleHeader0"" rel=""nofollow noreferrer"">在 Node.js 中引入模块：你所需要知道的一切都在这里</a></li>
<li><a href=""http://www.infoq.com/cn/articles/nodejs-module-mechanism#"" rel=""nofollow noreferrer"">深入浅出Node.js（三）：深入Node.js的模块机制</a></li>
</ul>

                ", 很全很全的JavaScript的模块讲解,1531977741,102,1,296,1,1,https://segmentfault.com/a/1190000012464333
59,1,0,7,"
                    
<h2>迷你版</h2>
<p>迷你版即0.3.0版。<br><br>0.2.0版没加新功能，只增加eadme内容和修正package.json上的一些错误。<br><br>0.3.0同样没加新功能，但是却是非常重要的。<br><br>这个版本国际化默认只支持英文和中文。初始化是英文。如果想支持全部118种语言，需要引入<a href=""https://github.com/hongmaoxiao/now/tree/master/dist/nowjs.locale.js"" rel=""nofollow noreferrer"">nowjs.locale.js</a>或者压缩版<a href=""https://github.com/hongmaoxiao/now/tree/master/dist/nowjs.min.locale.js"" rel=""nofollow noreferrer"">nowjs.locale.min.js</a>。<br></p>
<h2>版本大小比较</h2>
<pre><code>~/learn/ljs/now master
❯ ll -h dist | grep js$
-rw-rw-r-- 1 mao mao  66K 12月  5 00:37 nowjs.js
-rw-rw-r-- 1 mao mao 355K 12月  5 00:37 nowjs.locale.js
-rw-rw-r-- 1 mao mao 212K 12月  5 00:37 nowjs.locale.min.js
-rw-rw-r-- 1 mao mao  32K 12月  5 00:37 nowjs.min.js</code></pre>
<p>可以看出，<code>nowjs.js</code>比<code>nowjs.locale.js</code>小289kb，降低81.4%。<code>nowjs.min.js</code>比<code>nowjs.locale.min.js</code>减小180kb，降低84.9%。相当可观。完全可以放心在生产环境中使用而不担心加载速度问题。</p>
<h2>结语</h2>
<p>准备把min版加到cdn中。<br><br>还有很多可以优化的地方:</p>
<ol>
<li>调整<code>format</code>的写法。</li>
<li>降低代码冗余。</li>
<li>优化文件组织方式。</li>
<li>增加一些新的功能等等。</li>
</ol>
<p>有人给我点赞我很开心，现在已经有5个赞了（哈哈哈，我无耻的自己点了一个）。<br><br><strong>最后还是放个链接<a href=""https://github.com/hongmaoxiao/now"" rel=""nofollow noreferrer"">github地址</a>，<a href=""https://www.npmjs.com/package/now.js"" rel=""nofollow noreferrer"">npm地址</a>。</strong></p>

                ", now.js 迷你版发布,1531977743,599,1,407,1,1,https://segmentfault.com/a/1190000012283117
60,1,0,7,"
                    
<h2>now.js是什么</h2>
<p><code>now.js</code>是一个javascript的时间操作小工具，类似<a href=""https://github.com/date-fns/date-fns"" rel=""nofollow noreferrer"">date-fns</a>和<a href=""https://github.com/moment/moment"" rel=""nofollow noreferrer"">moment</a>。</p>
<h2>长啥样</h2>
<p>简单的把示例放这，更多用法请到<a href=""https://github.com/hongmaoxiao/now"" rel=""nofollow noreferrer"">github</a>去发现。</p>
<pre><code class=""javascript"">import Now from 'now.js'; // for node(browser do not need this)

now = new Now()

now.format() // ""2017-11-20T22:23:00+08:00""
now.format('YYYY-MM-DD HH:mm:ss.SSS') // ""2017-11-20 22:23:00.285""
now.format(""dddd, MMMM Do YYYY, h:mm:ss a"") // ""Monday, November 20th 2017, 10:23:00 pm""

now.locale('zh-cn') // support 118 languages
now.format(""dddd, MMMM Do YYYY, h:mm:ss a"") // ""星期一, 十一月 20日 2017, 10:23:00 晚上""
now.elapse() // ""10 天前""
// same as
now.timeAgo() // ""10 天前""

// monday
now.monday() // ""2017-11-20 00:00:00""

// isMonday
now.isMonday() // true

// isBefore
now.isBefore(new Date(2020, 10, 11)) // true

// isLeapYear
now.isLeapYear() // false
now.isLeapYear(2008) // true

// between
now.between(new Date(2008, 10, 10), new Date(2018, 10, 10)) // true

// UTC
now.UTC().format() // ""2017-11-20T22:23:00+00:00""

now.beginningOfMinute()   // ""2017-11-20 22:23:00""
now.beginningOfHour()     // ""2017-11-20 22:00:00""
now.beginningOfDay()      // ""2017-11-20 00:00:00""
now.beginningOfWeek()     // ""2017-11-19 00:00:00""
now.firstDayMonday = true // Set Monday as first day, default is Sunday
now.beginningOfWeek()     // ""2017-11-20 00:00:00""
now.beginningOfMonth()    // ""2017-11-01 00:00:00""
now.beginningOfQuarter()  // ""2017-10-01 00:00:00""
now.beginningOfYear()     // ""2017-01-01 00:00:00""

now.endOfMinute()         // ""2017-11-20 22:23:59.999""
now.endOfHour()           // ""2017-11-20 22:59:59.999""
now.endOfDay()            // ""2017-11-20 23:59:59.999""
now.endOfWeek()           // ""2017-11-25 23:59:59.999""
now.firstDayMonday = true // Set Monday as first day, default is Sunday
now.endOfWeek()           // ""2017-11-26 23:59:59.999""
now.endOfMonth()          // ""2017-11-30 23:59:59.999""
now.endOfQuarter()        // ""2017-12-31 23:59:59.999""
now.endOfYear()           // ""2017-12-31 23:59:59.999""

All the above functions return String type. You can pass 'self' to return Now instance:

var beginningOfMinute = now.beginningOfMinute('self') // return Now instance
beginningOfMinute.format('ddd, Ah') // ""Mon, PM10""
beginningOfMinute.format('LLLL') // ""Monday, November 20, 2017 10:23 PM""
beginningOfMinute.isMonday() // true
</code></pre>
<h2>为什么要写这个库</h2>
<p>因为学习<a href=""https://github.com/jashkenas/underscore"" rel=""nofollow noreferrer"">underscore</a>源码的过程中，感觉无聊。想写个库调剂一下，当做学习的机会。<br><br>我是照着<code>underscore</code>源码一个个commit敲的.代码放在<a href=""https://github.com/hongmaoxiao/underscore_source"" rel=""nofollow noreferrer"">这里</a>，刚看了一眼，有668次commit，两个月，敲到了1.4.3版本，可能还没到一半。<br><br>敲久了有点无聊。想动手写一个库作为调剂。碰巧之前做防健忘短信提醒的时候是用go写的后台，用了<a href=""https://github.com/jinzhu/gorm"" rel=""nofollow noreferrer"">gorm</a>，在作者<code>jinzhu</code>的github主页上发现了<a href=""https://github.com/jinzhu/now"" rel=""nofollow noreferrer"">now</a>，是一个go的时间帮助库，觉得很有意思。clone之，学之。<br><br>偷了<code>now</code>的思想。造一个javascript版的就显得很容易。很快我就写完了除了<code>Parse </code>和<code>MustParse </code>之外的所有方法。跟原库对比一下。觉得now.js就是个玩具。这不怪我，javascript对时间处理的支持远不如go。比如go原生支持<code>format</code>、字符串解析成时间以及<code>Duration</code>等等。<br><br>想着加上<code>format</code>。该怎么去写？立马就想到的方法是平时经常写的根据不同条件做字符串拼接。确实是个方法。但得多少switch case才能涵盖所有情况，想想都可怕。显然这是最蠢也是工作量最大的方法。<br><br>不会，那就借鉴别人的。github上发现了date-fns和moment，支持i18n国际化。</p>
<p>date-fns:</p>
<pre><code class=""javascript"">import { formatRelative } from 'date-fns'
import { es, ru } from 'date-fns/esm/locale'

formatRelative(subDays(new Date(), 3), new Date(), { locale: es })
//=&gt; ""el viernes pasado a las 19:26""

formatRelative(subDays(new Date(), 3), new Date(), { locale: ru })
//=&gt; ""в прошлую пятницу в 19:26""</code></pre>
<p>moment:</p>
<pre><code class=""javascript"">moment.locale('fr');
moment(1316116057189).fromNow(); // il y a une heure
moment.locale('en');
moment(1316116057189).fromNow(); // an hour ago</code></pre>
<p>我的审美告诉我应该选择moment，调用一次locale()，这之后的format都是基于该locale的。当然它也还支持每次单独指定locale的:</p>
<pre><code class=""javascript"">moment.duration(1, ""minutes"").locale(""en"").humanize(); // a minute
moment.duration(1, ""minutes"").locale(""fr"").humanize(); // une minute
moment.duration(1, ""minutes"").locale(""es"").humanize(); // un minuto</code></pre>
<p>进一步学习发现moment的format和i18n国际化高度耦合。要用它的i18n意味着基本上也得用它的format。当然i18n也不是核心的moment库作者写的，他们也精通不了那么多国家的语言，那都是github上许许多多人贡献的。开源就有这好处。看下LICENCE是MIT的，代码可用，抄。<br><br>now.js也是MIT协议的，负罪感少了点(其实MIT协议是相当宽松的，就算你拿它代码去商业化也是没有问题的)。况且我写库的主要目的是为了学习。<br><br>开干！虽说是抄，毕竟代码要整合到我的库，直接复制粘贴是不行的。所有的代码细节未必都需要全知道，但看懂整体运行的逻辑是必须的，下点功夫，整合成功，开源。</p>
<h2>思维脑图</h2>
<p><strong>moment:</strong><br><br><span class=""img-wrap""><img data-src=""https://fengxiaomao.com/upload/moment.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当然，moment的东西不止上图这些，我只取了一部分来画。<br><br><br><strong>now.js:</strong><br><br><span class=""img-wrap""><img data-src=""https://fengxiaomao.com/upload/now.js.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>now.js的Duration和moment的不一样，现在还不支持单独使用，只是给内部方法<code>elapse</code>使用，以后可能会支持单独使用。</p>
<h2>对比</h2>
<ol>
<li>moment是大而全，now.js是刚够用。</li>
<li>moment的parse相当强大，now.js就暂时不支持了，只支持和<code>new Date(args)</code>相同的<code>args</code>参数类型。不过<code>format</code>应该都基本上和moment的一样，不过测试用例现在还没有写太全，如果谁用了并且发现bug，可以到<a href=""https://github.com/hongmaoxiao/now"" rel=""nofollow noreferrer"">github</a>去提issues。不胜感激。<br>
</li>
<li>moment是页面一加载的时候会把所有的i18n都初始化了，这点我个人认为不好，加载时间长，网络情况不好的时候，差不多需要10秒我才能在devtool上调试（当然这也包括官网加载的其他很多东西）。now.js只加载默认的，需要的时候按需加载。</li>
<li>moment做什么操作前都要检测一下date是否合法的（isvalid）。now.js在parse的时候如果不合法就直接抛出错误，以免后续没玩没了的检测。当然这可能损失了用户友好性，但是对减少代码量是很有帮助的。</li>
</ol>
<h2>结语</h2>
<p>这个库不是我一个人写的，是许多开源工作者共同完成的。感谢moment的所有开源贡献者，我从中学习了很多东西。后续还会继续研究moment的代码细节，偷偷它的思想。<br><br><br><strong>写代码什么最重要？思想最重要！</strong></p>

                ", now.js 0.1.0 发布了,1531977744,191,1,338,1,1,https://segmentfault.com/a/1190000012270796
61,1,0,7,"
                    
<h2>前端学习笔记篇之git那些事</h2>
<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。学习前端，离不开Git的使用，面试时也是一个常考的话题，在日常开发中，也困扰我们许久，下面就让我们一起走进它~</p>
<p>我将从以下几点进行介绍,准备好走进Git的世界了嘛~<span class=""img-wrap""><img data-src=""/img/bVZA6P?w=54&amp;h=51"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ul>
<li>高频词汇的含义</li>
<li>git常用指令</li>
<li>几种常见git操作流程</li>
</ul>
<hr>
<h2>高频词汇的介绍</h2>
<p>git操作博大精深，细节很多，对于日常开发的我们而言，熟识几条常用的操作便可解决日常问题。对于初学者而言了解git基本词汇的含义和git的工作原理还是很有必要的，这样对解决git操作中的“bug”也非常有帮助。</p>
<ul>
<li>remote：指存放在远程的一个计算机，在一般指GitHub服务器。</li>
<li>clone：指克隆，将github上的项目克隆（也可以说是复制）到自己的电脑上。</li>
<li>origin：指远程的代码仓库（自己的仓库），即源文件。</li>
<li>upstream：指上游，fork别人项目的地址，别人的项目就是你的上游，即上一层源文件。</li>
<li>master：指主分支。</li>
<li>pull：指拉代码，把你Github上的远程仓库拉到本地计算机上。</li>
<li>push：指提交代码，把你本机上的项目提交到Github上的远程仓库。</li>
</ul>
<p><strong>特别注意：</strong><strong>本地的 .git文件是指本地仓库，.git目录下存放着所有文件的版本和关联信息，该目录在默认条件下是隐藏的。</strong></p>
<hr>
<h2>git常用指令的用法</h2>
<p><strong>1.源文件：</strong></p>
<ul>
<li>git remote -v ：指查看远程关联的仓库，包括源文件和上一层源文件。</li>
<li>git remote add origin + 网址：指添加一个源文件。</li>
<li>git remote add upstream + 网址：指添加一个上一层源文件，即fork项目的源文件。</li>
<li>git remote remove origin/upstream + 网址：指删除一个源文件或上一层源文件。</li>
</ul>
<p><strong>2.初始化：</strong></p>
<ul>
<li>git clone + 网址：指把网址中对应的项目克隆到自己本机上。</li>
<li>git init：指初始化.git文件，里面没有链接信息，初始化后要重新建立与远程仓库的关联。</li>
<li>git pull upstream master：指把获得原项目更新。</li>
</ul>
<p><strong>3.提交：</strong></p>
<ul>
<li>git add + 文件名：指把修改的某个文件添加到暂存区（指.git仓库）；</li>
<li>git add . :指把所有的修改文件添加到暂存区；</li>
<li>git commit -m ""认真写为什么要做这次提交""：便于日后查阅和他人理解；</li>
<li>git push -u origin master:指把暂存区的文件提交到github中。</li>
<li>git log：指查看提交的历史记录。</li>
<li>dir：查看该文件的子目录。</li>
</ul>
<p><strong>4.分支：</strong></p>
<ul>
<li>git status：查看所有情况；</li>
<li>git branch：指查看分支信息；</li>
<li>git branch + 分支名：指创建新的分支；</li>
<li>git checkout + 分支名：指切换分支。</li>
</ul>
<p>看到这里大家是不是已经有点晕呢 <span class=""img-wrap""><img data-src=""/img/bVZA6U?w=70&amp;h=52"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>下面用一张图对git的常用命令总结一下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZoOL?w=720&amp;h=489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<hr>
<h2>几种常见的git流程</h2>
<p><strong>前提：只有进入到相应的文件目录后才能对git进行相关的操作。</strong></p>
<p>相关文件夹命令行操作：</p>
<ul>
<li>cd + 文件名：进入该文件目录下</li>
<li>cd ../ :返回到上级目录</li>
<li>dir：查看当前文件下的所有子文件</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVZA1K?w=1243&amp;h=372"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>情况一：新建一个项目并建立关联</strong></p>
<p>1.先在github上创建一个新仓库</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZATl?w=699&amp;h=224"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVZATx?w=789&amp;h=635"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点右边红框里的按钮复制仓库地址：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZAUJ?w=993&amp;h=279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>2.在本地VSCode的workplace下点击右键Git Bash Here打开</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZAT5?w=573&amp;h=223"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.git clone + 仓库地址，把仓库里的文件克隆到本机上。<br><span class=""img-wrap""><img data-src=""/img/bVZAVW?w=937&amp;h=141"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>此时在本地就新建了一个wxapp_font_reading_class1文件夹</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZAV7?w=399&amp;h=57"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>4.git remote -v 查看文件关联</p>
<p><span class=""img-wrap""><img data-src=""/img/bVZAWd?w=1266&amp;h=113"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>情况二：fork别人的项目到本机上</strong></p>
<ol>
<li>在workplace下新建一个新的文件夹；</li>
<li>右键该文件夹，点击Git Bash Here 打开；</li>
<li>
<p>依次输入：</p>
<pre><code>   （1）git init（初始化该文件夹）
   （2）git remote add upstream + fork文件地址（与fork的项目关联）
   （3）git pull upstream  master（把fork的项目拉到本机上）
</code></pre>
</li>
<li>在新建文件夹下创建了fork的文件。</li>
</ol>
<p><strong>情况三：如何和fork的项目保持同步更新</strong></p>
<ul>
<li>
<p>与fork的项目建立了关联</p>
<pre><code>   输入""git pull upstream master""就可实现代码更新</code></pre>
</li>
<li>
<p>未与fork的项目建立关联</p>
<pre><code>1）先建立项目关联
   git remote add upstream + fork文件地址
   git remote -v 查看项目关联
       
2）再实现代码更新
   git pull upstream master 把项目拉到本机上
</code></pre>
</li>
</ul>
<p><strong>情况四：git别人的项目，但是不通过fork形式的流程</strong></p>
<p>以增加wxapp-starter文件的实例来说明:</p>
<ul>
<li>在github上新建一个""wxapp-starter""仓库</li>
<li>git clone + 别人项目的链接</li>
<li>git remote remove origin （删除别人origin的链接）</li>
<li>remove .git（删除wxapp-starter文件里的.git 文件）</li>
<li>git init （初始化 .git文件）</li>
<li>git remote add origin + 自己仓库的地址（在 .git 中增加自己的origin的链接）</li>
<li>git pull origin master（与自己的项目同步）</li>
</ul>
<p><strong>情况五：git提交的通用过程（每次修改代码后都要进行的操作）</strong></p>
<ol>
<li>git status （查看当前文件的修改状态）；</li>
<li>git add 某文件（添加某个修改文件）/ git add .(添加文件所有修改文件)；</li>
<li>git commit -m ""注释""（提交文件并备注）；</li>
<li>git push -u origin master（把暂存区的文件发送到github上）</li>
</ol>
<p>以es6文件为例进行提交：<br><span class=""img-wrap""><img data-src=""/img/bVZA2R?w=1144&amp;h=369"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVZA2W?w=971&amp;h=404"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>关于git操作的分享就告一段落啦，后续会有更多其他内容，欢迎大家一起交流学习哟(＾Ｕ＾)ノ</p>
<p>相关链接：<a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">git教程（廖雪峰）</a></p>

                ", 困扰你的Git操作？,1531977746,131,1,269,1,1,https://segmentfault.com/a/1190000012258322
62,1,0,7,"
                    
<p>原文链接：<a href=""http://dwz.cn/6V2UZg"" rel=""nofollow noreferrer"">VS Code上手与超实用插件安利</a></p>
<p><strong>工欲善其事必先利其器</strong></p>
<blockquote>Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作</blockquote>
<p><strong>微软有 Visual Studio这个宇宙最强IDE，Visual Studio Code 自然也不会弱<em>(宇宙最强编辑器)</em></strong></p>
<p>说到代码编辑器，我们有必要提一提<a href=""https://www.sublimetext.com/"" rel=""nofollow noreferrer"">Sublime Text</a>还有<a href=""https://atom.io/"" rel=""nofollow noreferrer"">Atom</a>。在开始使用VS Code之前Sublime Text一直是我的主力编辑器，和<a href=""https://www.jetbrains.com/webstorm/"" rel=""nofollow noreferrer"">WebStorm</a> <em>（最强端前端开发工具）</em> 一起用。由于这篇文章主要介绍VS Code下面就简单概括下这几个：</p>
<p>Sublime Text：在我的日常使用中都挺满意，快速，稳定。唯一不爽是证书购买(虽然可以一直无限制使用)，没有开源</p>
<p>Atom：你们用着真不卡吗？还是我电脑配置太差，不过UI真的好看</p>
<p>VS code：微软开源，比sublime开源，比atom更快，比webstorm更轻，值得一提的是它用的壳是GitHub开源的Electron。</p>
<h2>主要功能</h2>
<p>Visual Studio Code首先是一个编辑器，它包含了高效的源代码编辑所需的功能<em>(最为一个编辑器，主要功能当然是代码编辑了)</em> 我们主要还是看看特色功能。</p>
<h3>智能感知 Intellisense</h3>
<p>智能感知是各种代码编辑功能的总称，包括代码完成，参数信息，快速信息和成员列表。智能感知功能也被称为“代码补全”，“内容帮助”和“代码提示”，这是一个现代编辑器最基本的自我修养了。</p>
<p>VS Code原生就支持JavaScript，TypeScript，JSON，HTML，CSS，Less和Sass的Intellisense，真正的强大之处在于，可以安装语言扩展来配置更丰富的IntelliSense<em>（几乎包括所有主流语言）</em></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155954?w=777&amp;h=305"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""intellisense"" title=""intellisense""></span></p>
<h3>内置 Git</h3>
<p>VS Code 内置了一个 Git GUI，支持最常用 Git 命令，这使得您可以很容易地看到您在项目中所做的更改。当然了，你可以通过扩展 让他更强大。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155955?w=768&amp;h=267"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""scm"" title=""scm""></span></p>
<h3>调试 Debugging</h3>
<p>VS Code对<a href=""https://nodejs.org/"" rel=""nofollow noreferrer"">Node.js</a>运行时提供了内置的调试支持，并且可以调试JavaScript，TypeScript和任何其他被转换为JavaScript的语言。对于调试其他语言和运行环境时，我们也可以通过扩展来解决。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155956?w=750&amp;h=421"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""debug"" title=""debug""></span></p>
<h3>终端命令行工具 Terminal</h3>
<p>在VS Code中提供了一个功能齐全的集成终端，这非常方便，因为您不必切换窗口或更改现有终端的状态就可以快速执行命令</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155957?w=619&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""integrated-terminal"" title=""integrated-terminal""></span></p>
<h3>扩展市场 Extensio</h3>
<p>对于强大的插件市场来说，它自带的功能只是和开始而已。随着VS Code的流行，基本上你能找到所有你想要的插件<em>(实在找不到你还可以自己开发)</em>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155958?w=1482&amp;h=791"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""extensions"" title=""extensions""></span></p>
<p>更多请查阅<a href=""https://code.visualstudio.com/docs"" rel=""nofollow noreferrer"">https://code.visualstudio.com/docs</a></p>
<h2>开始上手</h2>
<p>关于VS Code的使用也很简单</p>
<ul>
<li>下载安装：去到它的官网<a href=""https://code.visualstudio.com/"" rel=""nofollow noreferrer"">https://code.visualstudio.com/</a>，下载对应版本，然后按照提示一直下一步就好</li>
<li>基本使用：在你安装好后，就可以看到有用的用户欢迎指引界面</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVZatg?w=2560&amp;h=1600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vscode"" title=""vscode""></span></p>
<p>你可以在学习栏点击各项，迅速上手这个编辑器÷。下面主要就是推荐一些好用插件了，</p>
<h3>插件安装方式</h3>
<p>关于插件的安装，在看了<code>界面概述</code>后也应该是知道怎么安装了：</p>
<ul>
<li>直接在扩展管理中键入你要下载的扩展名称或者关键字搜索下载</li>
<li>使用快捷键<code>⇧+⌘+P</code>，打开命令面板，输入如下命令即可</li>
</ul>
<pre><code class=""javascript"">ext install 扩展名</code></pre>
<ul><li>还可以从插件主页直接点击下载，他会唤起VS Code自动下载</li></ul>
<h2>基本配置</h2>
<p>关于VS Code的各项设置，都在一个JSON文件中，左边是默认设置，右边是我们自己的设置，分为用户设置和工作区设置，我们只需要在右边我们编辑设置并保存即可。工作区设置后各项设置会保存在<code>.vscode</code>文件夹下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155959"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""default-settings"" title=""default-settings""></span></p>
<p>新安装一个编辑/IDE，最先干的就是调字体<em>(vscode 中可以直接按⌘加加号/减号调节字体)</em>，调颜色等外观配置了吧。</p>
<h3>主题推荐</h3>
<p>VS Code已经自带了很多个好看的主题，比如说我一直用的<a href=""http://ethanschoonover.com/solarized"" rel=""nofollow noreferrer"">Solarized Dark</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155960?w=700&amp;h=305"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""themes"" title=""themes""></span></p>
<p>这里我再推荐几个不错的，</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme"" rel=""nofollow noreferrer""><strong>One Dark Pro</strong></a>：  Atom 标志性的主题</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155961?w=2272&amp;h=1760"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""One Dark Pro"" title=""One Dark Pro""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=akamud.vscode-theme-onedark"" rel=""nofollow noreferrer""><strong>Atom One Dark Theme</strong></a>： 另一个基于 <a href=""https://github.com/atom/one-dark-syntax"" rel=""nofollow noreferrer"">One Dark</a> 的主题</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155962?w=1078&amp;h=650"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Atom One Dark Theme"" title=""Atom One Dark Theme""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula"" rel=""nofollow noreferrer""><strong>Dracula Official</strong></a>：超好看</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155963?w=1718&amp;h=1166"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Dracula Official"" title=""Dracula Official""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme"" rel=""nofollow noreferrer""><strong>Material Theme</strong></a> 一个简单而又干净的主题，有很多配置选项用于颜色配置<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012155964?w=1300&amp;h=956"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Material Theme"" title=""Material Theme""></span></p>
<p>单单安装了主题还不够，我们还要好看的图标来足视觉体验：</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons#overview"" rel=""nofollow noreferrer""><strong>vscode icons</strong></a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155965?w=800&amp;h=600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vscode icons"" title=""vscode icons""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme"" rel=""nofollow noreferrer""><strong>Material Icon Theme</strong></a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155966?w=1125&amp;h=1867"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Material Icon Theme"" title=""Material Icon Theme""></span></p>
<p>更多好看主题请浏览<a href=""https://marketplace.visualstudio.com/search?target=VSCode&amp;category=Themes&amp;sortBy=Downloads"" rel=""nofollow noreferrer"">https://marketplace.visualstudio.com/search?target=VSCode&amp;category=Themes</a></p>
<h2>实用插件</h2>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize"" rel=""nofollow noreferrer""><strong>filesize</strong></a>：在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense"" rel=""nofollow noreferrer""><strong>Path Intellisense</strong></a>：文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155967"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Path Intellisense"" title=""Path Intellisense""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader"" rel=""nofollow noreferrer""><strong>vscode-fileheader</strong></a>：顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012155968?w=921&amp;h=510"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""fileheader"" title=""fileheader""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens"" rel=""nofollow noreferrer""><strong>Git Lens</strong></a>：查看详细的git记录,内置功能很多<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012155969"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Lens "" title=""Git Lens ""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory"" rel=""nofollow noreferrer""><strong>Git History (git log)</strong></a>：一个好用的Git 历史查看工具<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012155970?w=859&amp;h=795"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""**Git History**"" title=""**Git History**""></span><br><a href=""https://marketplace.visualstudio.com/items?itemName=eg2.vscode-npm-script"" rel=""nofollow noreferrer""><strong>npm</strong></a>: 可以直接在vscode执行npm的一些命令</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155971?w=600&amp;h=142"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""**npm**"" title=""**npm**""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense"" rel=""nofollow noreferrer""><strong>Npm Intellisense</strong></a>：NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012155972?w=931&amp;h=281"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""**Npm Intellisense**"" title=""**Npm Intellisense**""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome"" rel=""nofollow noreferrer""><strong>Debugger for Chrome</strong></a>：让 vscode 映射 chrome 的 debug功能，静态页面都可以用 vscode 来打断点调试<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012155973?w=1458&amp;h=890"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""**Debugger for Chrome**"" title=""**Debugger for Chrome**""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets"" rel=""nofollow noreferrer""><strong>JavaScript (ES6) code snippets</strong></a>：常用的类声明、ES 模块声明、CMD 模块导入等</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint"" rel=""nofollow noreferrer""><strong>ESLint</strong></a>：代码语法检查</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify"" rel=""nofollow noreferrer""><strong>Beautify</strong></a>：格式化代码的工具</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=coderfee.open-html-in-browser"" rel=""nofollow noreferrer""><strong>open-in-browser</strong></a>： 在浏览器中预览HTM文件</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets"" rel=""nofollow noreferrer""><strong>HTML Snippets</strong></a>：各种 HTML 标签片段</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion"" rel=""nofollow noreferrer""><strong>IntelliSense for CSS class names</strong></a>：CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示</p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=joelday.docthis"" rel=""nofollow noreferrer""><strong>Document This</strong></a>： js 的注释模板<span class=""img-wrap""><img data-src=""/img/remote/1460000012155974?w=1422&amp;h=1078"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Document This"" title=""Document This""></span></p>
<p><a href=""https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync"" rel=""nofollow noreferrer""><strong>Settings Sync</strong></a>：同步你得设置和插件</p>
<h2>结语</h2>
<p>我们从外观配置开始到插件推荐结束，到此基本上你就能打造出一个有自己风格强大编辑器，开发效率自然也是很高。你有什么好用的插件？欢迎留言交流！让更多的人知道。</p>
<p>同时，建议移步官网看看<a href=""https://code.visualstudio.com/"" rel=""nofollow noreferrer"">https://code.visualstudio.com/</a>，那儿有更全更细的文档，有助于我们更好的使用它。</p>
<p>欢迎关注微信公众号：<br><span class=""img-wrap""><img data-src=""/img/bVZatm?w=615&amp;h=345"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""15fed02d4c85462d"" title=""15fed02d4c85462d""></span></p>

                ", VS Code上手与超实用插件安利,1531977748,277,1,140,1,1,https://segmentfault.com/a/1190000012155949
63,1,0,7,"
                    
<h2>如何搭建个人博客?</h2>
<p>这是我的个人网站： <a>www.weaci.cn</a></p>
<h3>准备</h3>
<p>需要做到以下三点：</p>
<p><strong>1.<a href=""https://git-for-windows.github.io/"" rel=""nofollow noreferrer"">安装git</a></strong></p>
<hr>
<p>如果官方网速太慢的话，也可以移步<a href=""https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit"" rel=""nofollow noreferrer"">百度云镜像</a><br>下载安装即可。<br>安装完毕之后，如果你的菜单里出现了git bash（一个类似于命令行窗口的东西）的话，那么恭喜你，你已经成功安装啦！</p>
<p>安装完毕后，我们先不要着急，在窗口分别输入以后两行代码：</p>
<pre><code> $ git config --global user.name ""你的账号名"" 

 $ git config --global user.email ""你的邮箱名"" 
</code></pre>
<p>这样，你的gitbash就能连接到你的远程git上啦。</p>
<p><strong>2.[安装node.js]()</strong></p>
<hr>
<pre><code>node -v
</code></pre>
<p>查看是否安装node.js成功</p>
<p><strong>3.安装hexo</strong></p>
<hr>
<p>我们可以通过执行以下命令来</p>
<pre><code> npm install -g hexo
</code></pre>
<p>或者可以用Facebook的包管理工具yarn来执行</p>
<pre><code>  npm install -g yarn 
</code></pre>
<p>比较坑爹的是yarn也需要通过npm来安装</p>
<pre><code> hexo -v</code></pre>
<p>查看是否安装成功</p>
<p>cd进入一个空的文件夹，执行：</p>
<pre><code>hexo init
</code></pre>
<p>初始化命令，执行后在本地可以看到一些文件,到了这步，建立博客所有需要的文件都已经准备好了</p>
<p>怎么样，是不是已将迫不及待了呢试着在输入</p>
<pre><code>hexo server </code></pre>
<p>或者简写成：</p>
<pre><code> hexo s
</code></pre>
<p>打开你的浏览器输入<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:4000 就可以看到属于你的第一个个人博客了。</p>
<h3>配置github</h3>
<hr>
<p>建立Repository</p>
<p>建立与你用户名对应的仓库，仓库名为<strong>username.github.io</strong></p>
<p>打开hexo文件夹里的_config.yml</p>
<pre><code>vim _config.yml
</code></pre>
<p>翻到最下面，将代码改成：</p>
<pre><code>deploy:

 type: git

 repo: https://github.com/username/username.github.io

 branch: master
</code></pre>
<p>然后执行命令：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
<p>在你对博客进行修改后可以通过执行：</p>
<pre><code>hexo clean</code></pre>
<p>清理缓存</p>
<pre><code>hexo generate</code></pre>
<p>生成静态网页</p>
<pre><code>hexo deploy</code></pre>
<p>提交</p>
<p>可以简写成：</p>
<pre><code>hexo g -d

</code></pre>
<p>现在我们就可以通过username.github.io来访问你的博客啦。</p>
<h3>hexo主题</h3>
<hr>
<p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。</p>
<p>Hexo 安装主题的方式非常简单，只需要将主题文件放置于站点目录的 themes 目录下，然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p>
<p>下载 NexT 主题：</p>
<ul>
<li>
<p>进入博客根目录/themes/, 执行</p>
<p>$git clone <a href=""https://github.com/iissnan/hexo-theme-next.git"" rel=""nofollow noreferrer"">https://github.com/iissnan/he...</a></p>
</li>
<li><p>或者直接进入上面的链接，在项目主页download zip文件，然后解压到博客根目录/themes/ 文件夹</p></li>
</ul>
<h3>启用主题</h3>
<hr>
<p>克隆/下载 完成后，打开 站点配置文件，找到 theme 字段，并将其值更改为 next 。</p>
<p>验证主题是否启用</p>
<p>运行 hexo s --debug ，并访问 <a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:4000 ，确保站点正确运行。</p>
<h3>绑定域名</h3>
<hr>
<p>如果有自己的域名的话，我们可以直接通过域名来上你的个人博客，如果没有的话可以到<a href=""https://dnspod.cloud.tencent.com/act/double11"" rel=""nofollow noreferrer"">腾讯云</a>上购买一个，现在最低只要一块钱。</p>
<p>在你的博客根目录/_config.yml下修改</p>
<pre><code># Site
title: myblog # 博客名
subtitle: it is my blog # 副标题
description:  # 站点描述
author:  # 作者名
language: zh-Hans # 语言设置
timezone: 


# URL
## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'
url: yoursite # 博客所要绑定的域名，没有则不填
root: /
permalink: :year/:month/:day/:title/
permalink_defaults:

</code></pre>
<ul>
<li><p>添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名</p></li>
<li><p>点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址：username.github.io</p></li>
</ul>
<h3>提交到百度</h3>
<hr>
<p>打开百度搜索 site：your site</p>
<p>点击提交网址，设置好站点属性之后，我们选择第三种验证方式<strong>CNAME验证</strong></p>
<p>第一步：你要有自己的域名并使用CNAME解析</p>
<p>第二步：如图添加一条新的CNAME解析：记录类型是CNAME，主机记录是百度给你的一串字符，记录值是ziyuan.baidu.com，其他默认</p>
<p><strong>好了，到这里我们就大功告成了，如有不足，请不吝指出，谢谢</strong></p>

                ", 如何搭建自己的个人博客（推荐）,1531977750,437,1,471,1,1,https://segmentfault.com/a/1190000012042243
64,1,0,7,"
                    
<p>关于Git的用法我们已经写七篇文章，介绍了Git的不少用法，这些足以应付工作中90%的需求了，剩下的10%就需要小伙伴们在工作中自己慢慢总结了，我这里再给小伙伴们推荐一点Git学习资料，为我们的Git系列画上一个句号。</p>
<h2>书</h2>
<p>推荐两本个人觉得很不错的书：  </p>
<p>1.《GitHub入门与实践》  <br>2.《Pro Git》  </p>
<p>《GitHub入门与实践》秉承了日系技术书刊一贯的“手把手教学”风格，作者用亲切的语言，简明扼要的介绍，配以生动详实的示例一步步讲解GitHub和Git的使用方法。《Pro Git》作为Git官方推荐书籍，《Pro Git》值得Git初学者和爱好者认真阅读一遍。</p>
<h2>网站</h2>
<p>1.<a href=""https://learngitbranching.js.org"" rel=""nofollow noreferrer"">https://learngitbranching.js.org</a>  </p>
<p>链接是一个git学习网站，我们可以直接在上面练习git命令。</p>
<h2>博客</h2>
<p>推荐本公号前面的几篇Git教程:</p>
<hr>
<p>1.<a href=""https://mp.weixin.qq.com/s/3RheAJ9LYKK5BnVr331h5A"" rel=""nofollow noreferrer"">Git概述</a>  <br>2.<a href=""https://mp.weixin.qq.com/s/S1T4wy3srmLvXgIjvpVEwg"" rel=""nofollow noreferrer"">Git基本操作</a>  <br>3.<a href=""https://mp.weixin.qq.com/s/WiLnRQfDVITHMYzGl9pAzQ"" rel=""nofollow noreferrer"">Git中的各种后悔药</a>  <br>4.<a href=""https://mp.weixin.qq.com/s/9OZY7x9DSyRO7T56TyDJ8Q"" rel=""nofollow noreferrer"">Git分支管理</a>  <br>5.<a href=""https://mp.weixin.qq.com/s/x5bRe4QBMoVFKv5jNl9iRw"" rel=""nofollow noreferrer"">Git关联远程仓库</a>  <br>6.<a href=""https://mp.weixin.qq.com/s/S5rrBQoWwof7n3ZRTrZGWQ"" rel=""nofollow noreferrer"">Git工作区储藏兼谈分支管理中的一个小问题</a>  <br>7.<a href=""https://mp.weixin.qq.com/s/Jwr4fjCw7MBUD-CalVXhZQ"" rel=""nofollow noreferrer"">Git标签管理</a></p>
<hr>
<p>更多JavaEE和Git资料请关注公众号：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVUERD?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 推荐一波Git学习资料,1531977751,193,1,311,1,1,https://segmentfault.com/a/1190000012012164
65,1,0,7,"
                    
<p>我们可以针对某一次的提交打上一个标签，有点类似于给某次提交取个别名，比如1.0版本发布时打个标签叫v1.0,2.0版本发布时打个标签叫v2.0，因为每次版本提交的结果都是一连串的哈希码，不容易记忆，打上v1.0,v2.0这些具有某种含义的标签后，可以方便我们进行版本管理。   </p>
<p>本文是Git系列的第七篇，了解前面的文章有助于更好的理解本文：</p>
<hr>
<p>1.<a href=""https://mp.weixin.qq.com/s/3RheAJ9LYKK5BnVr331h5A"" rel=""nofollow noreferrer"">Git概述</a>  <br>2.<a href=""https://mp.weixin.qq.com/s/S1T4wy3srmLvXgIjvpVEwg"" rel=""nofollow noreferrer"">Git基本操作</a>  <br>3.<a href=""https://mp.weixin.qq.com/s/WiLnRQfDVITHMYzGl9pAzQ"" rel=""nofollow noreferrer"">Git中的各种后悔药</a>  <br>4.<a href=""https://mp.weixin.qq.com/s/9OZY7x9DSyRO7T56TyDJ8Q"" rel=""nofollow noreferrer"">Git分支管理</a>  <br>5.<a href=""https://mp.weixin.qq.com/s/x5bRe4QBMoVFKv5jNl9iRw"" rel=""nofollow noreferrer"">Git关联远程仓库</a>  <br>6.<a href=""https://mp.weixin.qq.com/s/S5rrBQoWwof7n3ZRTrZGWQ"" rel=""nofollow noreferrer"">Git工作区储藏兼谈分支管理中的一个小问题</a></p>
<hr>
<h2>轻量级标签</h2>
<p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。  </p>
<p>首先我们可以通过如下命令来查看当前仓库中的所有标签：</p>
<pre><code>$ git tag</code></pre>
<p>打标签的方式很简单，直接通过<code>git tag &lt;tagname&gt;</code>来完成即可，如下命令：</p>
<pre><code>$ git tag v1</code></pre>
<p>表示创建了一个名为v1的tag，这个tag默认是创建在最新一次的commit上的，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuKw?w=416&amp;h=94"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们可以利用<code>git show &lt;tagname&gt;</code>来查看标签对应的版本信息，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuKB?w=478&amp;h=264"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们可以通过<code>$ git tag -d &lt;tagname&gt;</code>命令删除一个标签：</p>
<pre><code>$ git tag -d v1</code></pre>
<p>如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuK8?w=415&amp;h=120"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果我想给历史上的某次commit打一个标签呢?我们可以通过如下命令<code>git tag &lt;tagname&gt; &lt;commitversion&gt;</code>,如下：</p>
<pre><code>$ git tag v0.0 7d519</code></pre>
<p>表示给commit的哈希码为7d519的那一次commit打上一个标签，如下图：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuLw?w=476&amp;h=252"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>含附注的标签</h2>
<p>而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。  </p>
<p>打一个含附注的标签很简单，使用<code>git tag -a &lt;tagname&gt; -m &lt;msg&gt;</code>命令,如下：</p>
<pre><code>$ git tag -a v0.0 -m ""文件初次建立"" 7d519</code></pre>
<p>如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuLG?w=478&amp;h=342"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果不加最后的版本号参数，表示给最新的一次commit打标签。</p>
<h2>签署标签</h2>
<p>说到签署标签我们得先介绍一下GPG：</p>
<blockquote><p>GPG是加密软件，可以使用GPG生成的公钥在网上安全的传播你的文件、代码。为什么说安全的？以Google所开发的repo为例，repo即采用GPG验证的方式，每个里程碑tag都带有GPG加密验证，假如在里程碑v1.12.3处你想要做修改，修改完后将这个tag删除，然后又创建同名tag指向你的修改点，这必然是可以的。但是，在你再次clone你修改后的项目时，你会发现，你对此里程碑tag的改变不被认可，验证失败，导致你的修改在这里无法正常实现。这就是GPG验证的作用，这样就能够保证项目作者（私钥持有者）所制定的里程碑别人将无法修改。那么，就可以说，作者的代码是安全传播的。为什么会有这种需求？一个项目从开发到发布，再到后期的更新迭代，一定会存在若干的稳定版本与开发版本（存在不稳定因素）。作为项目发起者、持有者，有权定义他（们）所认可的稳定版本，这个稳定版本，将不允许其他开发者进行改动。还以Google的repo项目为例，项目所有者定义项目开发过程中的点A为稳定版v1.12.3，那么用户在下载v1.12.3版本后，使用的肯定是A点所生成的项目、产品，就算其他开发者能够在本地对v1.12.3进行重新指定，指定到他们修改后的B点，但是最终修改后的版本给用户用的时候，会出现GPG签名验证不通过的问题，也就是说这样的修改是不生效的。</p></blockquote>
<p>----摘自&lt;<a href=""http://blog.csdn.net/killmice/article/details/30748077"" rel=""nofollow noreferrer"">带GPG签名的Git tag</a>&gt;一文   </p>
<p>使用签署标签我们先要生成GPG Key，生成命令如下：</p>
<pre><code>$ gpg --gen-key</code></pre>
<p>能默认的就直接按回车默认，不能默认的就根据提示输入相应的值，这里的都很简单，不再赘述。完了之后，就可以通过如下命令来打标签了：</p>
<pre><code>$ git tag -s v0.0 -u ""laowang"" -m ""文件初次建立"" 7d519</code></pre>
<p>就把上面的-a换成-s，然后添加-u参数，-u参数的值是我们在生成GPG Key的时候配置的name属性的值，注意-u参数不可以写错，否则标签会创建失败，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuLI?w=491&amp;h=153"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如上图，-u参数写错时，标签创建失败。</p>
<h2>标签推送到远程仓库</h2>
<p>git push命令并不会把tag提交到远程仓库中去，需要我们手动提交，如下：</p>
<pre><code>$ git push origin v0.0</code></pre>
<p>表示将v0.0标签提交到远程仓库，也可以通过<code>$ git push origin --tags</code>提交所有的tag到远程仓库，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuLP?w=587&amp;h=264"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>此时别人调用git pull更新代码之后，就能看到我们的tag。如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYuLT?w=612&amp;h=281"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Ok，Git标签管理我们先说这么多。有问题欢迎留言讨论。  </p>
<p>参考资料：  </p>
<p>1.《GitHub入门与实践》  <br>2.《Pro Git》  </p>
<p>更多JavaEE和Git资料请关注公众号：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVUERD?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Git标签管理,1531977753,583,1,249,1,1,https://segmentfault.com/a/1190000011995630
66,1,0,7,"
                    
<p>关于子仓库或者说是仓库共用，git官方推荐的工具是git subtree。 我自己也用了一段时间的git subtree，感觉比git submodule好用，但是也有一些缺点，在可接受的范围内。<br>所以对于仓库共用，在git subtree 与 git submodule之中选择的话，我推荐git subtree。</p>
<h1>git subtree是什么？为什么使用git subtree</h1>
<p>git subtree 可以实现一个仓库作为其他仓库的子仓库。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012002154?w=1134&amp;h=495"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>使用git subtree 有以下几个原因：</p>
<ul>
<li><p>旧版本的git也支持(最老版本可以到 v1.5.2).</p></li>
<li><p>git subtree与git submodule不同，它不增加任何像<code>.gitmodule</code>这样的新的元数据文件.</p></li>
<li><p>git subtree对于项目中的其他成员透明，意味着可以不知道git subtree的存在.</p></li>
</ul>
<p>当然，git subtree也有它的缺点，但是这些缺点还在可以接受的范围内：</p>
<ul>
<li><p>必须学习新的指令(如：git subtree).</p></li>
<li><p>子仓库的更新与推送指令相对复杂。</p></li>
</ul>
<h1>git subtree 的使用</h1>
<p>git subtree的主要命令有：</p>
<pre><code class=""sh"">git subtree add   --prefix=&lt;prefix&gt; &lt;commit&gt;
git subtree add   --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;
git subtree pull  --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;
git subtree push  --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;
git subtree merge --prefix=&lt;prefix&gt; &lt;commit&gt;
git subtree split --prefix=&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</code></pre>
<h2>准备</h2>
<p>我们先准备一个仓库叫photoshop，一个仓库叫libpng，然后我们希望把libpng作为photoshop的子仓库。<br>photoshop的路径为<code>https://github.com/test/photoshop.git</code>，仓库里的文件有：</p>
<pre><code>photoshop
    |
    |-- photoshop.c
    |-- photoshop.h
    |-- main.c
    \-- README.md</code></pre>
<p>libPNG的路径为<code>https://github.com/test/libpng.git</code>，仓库里的文件有：</p>
<pre><code>libpng
    |
    |-- libpng.c
    |-- libpng.h
    \-- README.md</code></pre>
<p>以下操作均位于父仓库的根目录中。</p>
<h2>在父仓库中新增子仓库</h2>
<p>我们执行以下命令把libpng添加到photoshop中：</p>
<pre><code class=""sh"">git subtree add --prefix=sub/libpng https://github.com/test/libpng.git master --squash</code></pre>
<p>(<code>--squash</code>参数表示不拉取历史信息，而只生成一条commit信息。)</p>
<p>执行<code>git status</code>可以看到提示新增两条commit：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012002155?w=471&amp;h=68"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p><code>git log</code>查看详细修改：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000012002156?w=561&amp;h=191"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>执行<code>git push</code>把修改推送到远端photoshop仓库，现在本地仓库与远端仓库的目录结构为：</p>
<pre><code>photoshop
    |
    |-- sub/
    |   |
    |   \--libpng/
    |       |
    |       |-- libpng.c
    |       |-- libpng.h
    |       \-- README.md
    |
    |-- photoshop.c
    |-- photoshop.h
    |-- main.c
    \-- README.md</code></pre>
<p>注意，现在的photoshop仓库对于其他项目人员来说，可以不需要知道libpng是一个子仓库。什么意思呢？<br>当你<code>git clone</code>或者<code>git pull</code>的时候，你拉取到的是整个photoshop(包括libpng在内，libpng就相当于photoshop里的一个普通目录)；当你修改了libpng里的内容后执行<code>git push</code>，你将会把修改push到photoshop上。<br>也就是说photoshop仓库下的libpng与其他文件无异。</p>
<h2>从源仓库拉取更新</h2>
<p>如果源libpng仓库更新了，photoshop里的libpng如何拉取更新？使用<code>git subtree pull</code>，例如：</p>
<pre><code class=""sh"">git subtree pull --prefix=sub/libpng https://github.com/test/libpng.git master --squash</code></pre>
<h2>推送修改到源仓库</h2>
<p>如果在photoshop仓库里修改了libpng，然后想把这个修改推送到源libpng仓库呢？使用<code>git subtree push</code>，例如：</p>
<pre><code class=""sh"">git subtree push --prefix=sub/libpng https://github.com/test/libpng.git master</code></pre>
<h2>简化git subtree命令</h2>
<p>我们已经知道了git subtree 的命令的基本用法，但是上述几个命令还是显得有点复杂，特别是子仓库的源仓库地址，特别不方便记忆。<br>这里我们把子仓库的地址作为一个remote，方便记忆：</p>
<pre><code class=""sh"">git remote add -f libpng https://github.com/test/libpng.git</code></pre>
<p>然后可以这样来使用git subtree命令：</p>
<pre><code class=""sh"">git subtree add --prefix=sub/libpng libpng master --squash
git subtree pull --prefix=sub/libpng libpng master --squash
git subtree push --prefix=sub/libpng libpng master</code></pre>
<h1>更多</h1>
<ul>
<li><p><a href=""http://blog.wangjinle.com/posts/fd56adc47e2516b6.html"" rel=""nofollow noreferrer"">git 学习汇总</a></p></li>
<li><p><a href=""https://www.atlassian.com/blog/git/alternatives-to-git-submodule-git-subtree"" rel=""nofollow noreferrer"">Git subtree: the alternative to Git submodule</a></p></li>
<li><p><a href=""https://legacy-developer.atlassian.com/blog/2015/05/the-power-of-git-subtree/"" rel=""nofollow noreferrer"">The power of Git subtree</a></p></li>
</ul>

                ", git subtree教程,1531977754,307,1,958,1,1,https://segmentfault.com/a/1190000012002151
67,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVYmF0?w=640&amp;h=442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>自己打造一把趁手的武器，高效率完成前端业务代码。</p></blockquote>
<h1>前言</h1>
<p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p>
<p>这里，笔者已经封装并发布了自己的武器库 <a href=""https://github.com/proYang/outils"" rel=""nofollow noreferrer"">outils</a>，如果你对本项目感兴趣，欢迎<a href=""https://github.com/proYang/outils"" rel=""nofollow noreferrer""> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p>
<h1>常用函数汇总</h1>
<p>这里先分类整理下，之前项目中多次用到的工具函数。</p>
<h2>1.Array</h2>
<h3>1.1 arrayEqual</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 判断两个数组是否相等
 * @param {Array} arr1 
 * @param {Array} arr2 
 * @return {Boolean}
 */
function arrayEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1.length != arr2.length) return false;
    for (var i = 0; i &lt; arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}</code></pre>
<h2>2.Class</h2>
<h3>2.1 addClass</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   为元素添加class
 * @param  {HTMLElement} ele 
 * @param  {String} cls 
 */

var hasClass = require('./hasClass');

function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
        ele.className += ' ' + cls;
    }
}</code></pre>
<h3>2.2 hasClass</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 判断元素是否有某个class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 * @return {Boolean}
 */
function hasClass(ele, cls) {
    return (new RegExp('(\\s|^)' + cls + '(\\s|$)')).test(ele.className);
}</code></pre>
<h3>2.3 removeClass</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 为元素移除class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 */

var hasClass = require('./hasClass');

function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        ele.className = ele.className.replace(reg, ' ');
    }
}</code></pre>
<h2>3.Cookie</h2>
<h3>3.1 getCookie</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 根据name读取cookie
 * @param  {String} name 
 * @return {String}
 */
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, """").split(';');
    for (var i = 0; i &lt; arr.length; i++) {
        var tempArr = arr[i].split('=');
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return '';
}</code></pre>
<h3>3.2 removeCookie</h3>
<pre><code class=""javascript"">var setCookie = require('./setCookie');
/**
 * 
 * @desc 根据name删除cookie
 * @param  {String} name 
 */
function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, '1', -1);
}</code></pre>
<h3>3.3 setCookie</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc  设置Cookie
 * @param {String} name 
 * @param {String} value 
 * @param {Number} days 
 */
function setCookie(name, value, days) {
    var date = new Date();
    date.setDate(date.getDate() + days);
    document.cookie = name + '=' + value + ';expires=' + date;
}</code></pre>
<h2>4.Device</h2>
<h3>4.1 getExplore</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 获取浏览器类型和版本
 * @return {String} 
 */
function getExplore() {
    var sys = {},
        ua = navigator.userAgent.toLowerCase(),
        s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:
        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :
        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :
        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :
        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :
        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :
        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;
    // 根据关系进行判断
    if (sys.ie) return ('IE: ' + sys.ie)
    if (sys.edge) return ('EDGE: ' + sys.edge)
    if (sys.firefox) return ('Firefox: ' + sys.firefox)
    if (sys.chrome) return ('Chrome: ' + sys.chrome)
    if (sys.opera) return ('Opera: ' + sys.opera)
    if (sys.safari) return ('Safari: ' + sys.safari)
    return 'Unkonwn'
}</code></pre>
<h3>4.2 getOS</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 获取操作系统类型
 * @return {String} 
 */
function getOS() {
    var userAgent = 'navigator' in window &amp;&amp; 'userAgent' in navigator &amp;&amp; navigator.userAgent.toLowerCase() || '';
    var vendor = 'navigator' in window &amp;&amp; 'vendor' in navigator &amp;&amp; navigator.vendor.toLowerCase() || '';
    var appVersion = 'navigator' in window &amp;&amp; 'appVersion' in navigator &amp;&amp; navigator.appVersion.toLowerCase() || '';

    if (/mac/i.test(appVersion)) return 'MacOSX'
    if (/win/i.test(appVersion)) return 'windows'
    if (/linux/i.test(appVersion)) return 'linux'
    if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) 'ios'
    if (/android/i.test(userAgent)) return 'android'
    if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return 'windowsPhone'
}</code></pre>
<h2>5.Dom</h2>
<h3>5.1 getScrollTop</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 获取滚动条距顶部的距离
 */
function getScrollTop() {
    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
}</code></pre>
<h3>5.2 offset</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()
 * @param {HTMLElement} ele 
 * @returns { {left: number, top: number} }
 */
function offset(ele) {
    var pos = {
        left: 0,
        top: 0
    };
    while (ele) {
        pos.left += ele.offsetLeft;
        pos.top += ele.offsetTop;
        ele = ele.offsetParent;
    };
    return pos;
}</code></pre>
<h3>5.3 scrollTo</h3>
<pre><code class=""javascript"">var getScrollTop = require('./getScrollTop');
var setScrollTop = require('./setScrollTop');
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
})();
/**
 * 
 * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置
 * @param {Number} to 
 * @param {Number} duration 
 */
function scrollTo(to, duration) {
    if (duration &lt; 0) {
        setScrollTop(to);
        return
    }
    var diff = to - getScrollTop();
    if (diff === 0) return
    var step = diff / duration * 10;
    requestAnimationFrame(
        function () {
            if (Math.abs(step) &gt; Math.abs(diff)) {
                setScrollTop(getScrollTop() + diff);
                return;
            }
            setScrollTop(getScrollTop() + step);
            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {
                return;
            }
            scrollTo(to, duration - 16);
        });
}</code></pre>
<h3>5.4 setScrollTop</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 设置滚动条距顶部的距离
 */
function setScrollTop(value) {
    window.scrollTo(0, value);
    return value;
}</code></pre>
<h2>6.Keycode</h2>
<h3>6.1 getKeyName</h3>
<pre><code class=""javascript"">var keyCodeMap = {
    8: 'Backspace',
    9: 'Tab',
    13: 'Enter',
    16: 'Shift',
    17: 'Ctrl',
    18: 'Alt',
    19: 'Pause',
    20: 'Caps Lock',
    27: 'Escape',
    32: 'Space',
    33: 'Page Up',
    34: 'Page Down',
    35: 'End',
    36: 'Home',
    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',
    42: 'Print Screen',
    45: 'Insert',
    46: 'Delete',

    48: '0',
    49: '1',
    50: '2',
    51: '3',
    52: '4',
    53: '5',
    54: '6',
    55: '7',
    56: '8',
    57: '9',

    65: 'A',
    66: 'B',
    67: 'C',
    68: 'D',
    69: 'E',
    70: 'F',
    71: 'G',
    72: 'H',
    73: 'I',
    74: 'J',
    75: 'K',
    76: 'L',
    77: 'M',
    78: 'N',
    79: 'O',
    80: 'P',
    81: 'Q',
    82: 'R',
    83: 'S',
    84: 'T',
    85: 'U',
    86: 'V',
    87: 'W',
    88: 'X',
    89: 'Y',
    90: 'Z',

    91: 'Windows',
    93: 'Right Click',

    96: 'Numpad 0',
    97: 'Numpad 1',
    98: 'Numpad 2',
    99: 'Numpad 3',
    100: 'Numpad 4',
    101: 'Numpad 5',
    102: 'Numpad 6',
    103: 'Numpad 7',
    104: 'Numpad 8',
    105: 'Numpad 9',
    106: 'Numpad *',
    107: 'Numpad +',
    109: 'Numpad -',
    110: 'Numpad .',
    111: 'Numpad /',

    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',

    144: 'Num Lock',
    145: 'Scroll Lock',
    182: 'My Computer',
    183: 'My Calculator',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
};
/**
 * @desc 根据keycode获得键名
 * @param  {Number} keycode 
 * @return {String}
 */
function getKeyName(keycode) {
    if (keyCodeMap[keycode]) {
        return keyCodeMap[keycode];
    } else {
        console.log('Unknow Key(Key Code:' + keycode + ')');
        return '';
    }
};</code></pre>
<h2>7.Object</h2>
<h3>7.1 deepClone</h3>
<pre><code class=""javascript"">/**
 * @desc 深拷贝，支持常见类型
 * @param {Any} values
 */
function deepClone(values) {
    var copy;

    // Handle the 3 simple types, and null or undefined
    if (null == values || ""object"" != typeof values) return values;

    // Handle Date
    if (values instanceof Date) {
        copy = new Date();
        copy.setTime(values.getTime());
        return copy;
    }

    // Handle Array
    if (values instanceof Array) {
        copy = [];
        for (var i = 0, len = values.length; i &lt; len; i++) {
            copy[i] = deepClone(values[i]);
        }
        return copy;
    }

    // Handle Object
    if (values instanceof Object) {
        copy = {};
        for (var attr in values) {
            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);
        }
        return copy;
    }

    throw new Error(""Unable to copy values! Its type isn't supported."");
}</code></pre>
<h3>7.2 isEmptyObject</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   判断`obj`是否为空
 * @param  {Object} obj
 * @return {Boolean}
 */
function isEmptyObject(obj) {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj))
        return false
    return !Object.keys(obj).length
}</code></pre>
<h2>8.Random</h2>
<h3>8.1 randomColor</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 随机生成颜色
 * @return {String} 
 */
function randomColor() {
    return '#' + ('00000' + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);
}</code></pre>
<h3>8.2 randomNum </h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 生成指定范围随机数
 * @param  {Number} min 
 * @param  {Number} max 
 * @return {Number} 
 */
function randomNum(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}</code></pre>
<h2>9.Regexp</h2>
<h3>9.1 isEmail</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   判断是否为邮箱地址
 * @param  {String}  str
 * @return {Boolean} 
 */
function isEmail(str) {
    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);
}</code></pre>
<h3>9.2 isIdCard</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc  判断是否为身份证号
 * @param  {String|Number} str 
 * @return {Boolean}
 */
function isIdCard(str) {
    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)
}</code></pre>
<h3>9.3 isPhoneNum</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   判断是否为手机号
 * @param  {String|Number} str 
 * @return {Boolean} 
 */
function isPhoneNum(str) {
    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)
}</code></pre>
<h3>9.4 isUrl</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   判断是否为URL地址
 * @param  {String} str 
 * @return {Boolean}
 */
function isUrl(str) {
    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);
}</code></pre>
<h2>10.String</h2>
<h3>10.1 digitUppercase</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   现金额转大写
 * @param  {Number} n 
 * @return {String}
 */
function digitUppercase(n) {
    var fraction = ['角', '分'];
    var digit = [
        '零', '壹', '贰', '叁', '肆',
        '伍', '陆', '柒', '捌', '玖'
    ];
    var unit = [
        ['元', '万', '亿'],
        ['', '拾', '佰', '仟']
    ];
    var head = n &lt; 0 ? '欠' : '';
    n = Math.abs(n);
    var s = '';
    for (var i = 0; i &lt; fraction.length; i++) {
        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, '');
    }
    s = s || '整';
    n = Math.floor(n);
    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {
        var p = '';
        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {
            p = digit[n % 10] + unit[1][j] + p;
            n = Math.floor(n / 10);
        }
        s = p.replace(/(零.)*零$/, '').replace(/^$/, '零') + unit[0][i] + s;
    }
    return head + s.replace(/(零.)*零元/, '元')
        .replace(/(零.)+/g, '零')
        .replace(/^整$/, '零元整');
};</code></pre>
<h2>11.Support</h2>
<h3>11.1 isSupportWebP</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc 判断浏览器是否支持webP格式图片
 * @return {Boolean} 
 */
function isSupportWebP() {
    return !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;
}</code></pre>
<h2>12.Time</h2>
<h3>12.1 formatPassTime</h3>
<pre><code class=""javascript"">/**
 * @desc   格式化${startTime}距现在的已过时间
 * @param  {Date} startTime 
 * @return {String}
 */
function formatPassTime(startTime) {
    var currentTime = Date.parse(new Date()),
        time = currentTime - startTime,
        day = parseInt(time / (1000 * 60 * 60 * 24)),
        hour = parseInt(time / (1000 * 60 * 60)),
        min = parseInt(time / (1000 * 60)),
        month = parseInt(day / 30),
        year = parseInt(month / 12);
    if (year) return year + ""年前""
    if (month) return month + ""个月前""
    if (day) return day + ""天前""
    if (hour) return hour + ""小时前""
    if (min) return min + ""分钟前""
    else return '刚刚'
}</code></pre>
<h3>12.2 formatRemainTime</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   格式化现在距${endTime}的剩余时间
 * @param  {Date} endTime  
 * @return {String}
 */
function formatRemainTime(endTime) {
    var startDate = new Date(); //开始时间
    var endDate = new Date(endTime); //结束时间
    var t = endDate.getTime() - startDate.getTime(); //时间差
    var d = 0,
        h = 0,
        m = 0,
        s = 0;
    if (t &gt;= 0) {
        d = Math.floor(t / 1000 / 3600 / 24);
        h = Math.floor(t / 1000 / 60 / 60 % 24);
        m = Math.floor(t / 1000 / 60 % 60);
        s = Math.floor(t / 1000 % 60);
    }
    return d + ""天 "" + h + ""小时 "" + m + ""分钟 "" + s + ""秒"";
}</code></pre>
<h2>13.Url</h2>
<h3>13.1 parseQueryString</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   url参数转对象
 * @param  {String} url  default: window.location.href
 * @return {Object} 
 */
function parseQueryString(url) {
    url = url == null ? window.location.href : url
    var search = url.substring(url.lastIndexOf('?') + 1)
    if (!search) {
        return {}
    }
    return JSON.parse('{""' + decodeURIComponent(search).replace(/""/g, '\\""').replace(/&amp;/g, '"",""').replace(/=/g, '"":""') + '""}')
}</code></pre>
<h3>13.2 stringfyQueryString</h3>
<pre><code class=""javascript"">/**
 * 
 * @desc   对象序列化
 * @param  {Object} obj 
 * @return {String}
 */
function stringfyQueryString(obj) {
    if (!obj) return '';
    var pairs = [];

    for (var key in obj) {
        var value = obj[key];

        if (value instanceof Array) {
            for (var i = 0; i &lt; value.length; ++i) {
                pairs.push(encodeURIComponent(key + '[' + i + ']') + '=' + encodeURIComponent(value[i]));
            }
            continue;
        }

        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
    }

    return pairs.join('&amp;');
}</code></pre>
<h2>14.Function</h2>
<h3>14.1 throttle</h3>
<pre><code class=""javascript"">/**
 * @desc   函数节流。
 * 适用于限制`resize`和`scroll`等函数的调用频率
 *
 * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}   noTrailing     可选，默认为false。
 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。
 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.
 *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）
 * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                    执行去节流功能时，调用`callback`。
 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。
 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。
 *
 * @return {Function}  新的节流函数
 */
function throttle(delay, noTrailing, callback, debounceMode) {

    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeoutID;

    // Keep track of the last time `callback` was executed.
    var lastExec = 0;

    // `noTrailing` defaults to falsy.
    if (typeof noTrailing !== 'boolean') {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {

        var self = this;
        var elapsed = Number(new Date()) - lastExec;
        var args = arguments;

        // Execute `callback` and update the `lastExec` timestamp.
        function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
        }

        // If `debounceMode` is true (at begin) this is used to clear the flag
        // to allow future `callback` executions.
        function clear() {
            timeoutID = undefined;
        }

        if (debounceMode &amp;&amp; !timeoutID) {
            // Since `wrapper` is being called for the first time and
            // `debounceMode` is true (at begin), execute `callback`.
            exec();
        }

        // Clear any existing timeout.
        if (timeoutID) {
            clearTimeout(timeoutID);
        }

        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {
            // In throttle mode, if `delay` time has been exceeded, execute
            // `callback`.
            exec();

        } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been
            // exceeded, schedule `callback` to execute `delay` ms after most
            // recent execution.
            //
            // If `debounceMode` is true (at begin), schedule `clear` to execute
            // after `delay` ms.
            //
            // If `debounceMode` is false (at end), schedule `callback` to
            // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }

    }

    // Return the wrapper function.
    return wrapper;

};</code></pre>
<h3>14.2 debounce</h3>
<pre><code class=""javascript"">/**
 * @desc 函数防抖 
 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，
 * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。
 * @example 适用场景：如在线编辑的自动存储防抖。
 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}  atBegin       可选，默认为false。
 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。
                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行
 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                  执行去抖动功能时，，调用`callback`。
 *
 * @return {Function} 新的防抖函数。
 */
var throttle = require('./throttle');
function debounce(delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};</code></pre>
<h1>封装</h1>
<p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p>
<p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持<strong>按需引入</strong>吧</p>
<h2>1.目录结构说明</h2>
<pre><code>│  .babelrc
│  .gitignore
│  .travis.yml
│  LICENSE
│  package.json
│  README.md
│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载
│  setScrollTop.js
│  stringfyQueryString.js
│   ...
│   ...
│  
├─min
│      outils.min.js  // 所有函数统一打包生成的全量压缩包
│      
├─script  // 本项目开发脚本目录
│      build.js  // 打包构建脚本
│      test.js  // 测试脚本
│      webpack.conf.js  // webpack打包配置文件
│      
├─src // 源码目录
│  │  index.js  // webpack入口文件
│  │  
│  ├─array
│  │      
│  ├─class
│  │      
│  ├─cookie
│  │      
│  ├─device
│  │      
│  ├─dom
│  │      
│  ├─keycode
│  │      
│  ├─object
│  │      
│  ├─random
│  │      
│  ├─regexp
│  │      
│  ├─string
│  │      
│  ├─support
│  │      
│  ├─time
│  │      
│  └─url
│          
└─test // 测试用例目录
    │  array.test.js
    │  class.test.js
    │  cookie.test.js
    │  device.test.js
    │  dom.test.js
    │  index.html
    │  keycode.test.js
    │  object.test.js
    │  random.test.js
    │  regexp.test.js
    │  string.test.js
    │  support.test.js
    │  time.test.js
    │  url.test.js
    │  
    └─_lib // 测试所用到的第三方库
            mocha.css
            mocha.js
            power-assert.js </code></pre>
<h2>2.构建脚本</h2>
<p>这里主要说明一下项目中<a href=""https://github.com/proYang/outils/blob/master/script/build.js"" rel=""nofollow noreferrer""> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p>
<pre><code class=""javascript"">    ......
    ......
    // 删除旧的全量压缩包
    rm(path.resolve(rootPath, 'min', `${pkg.name}.min.js`), err =&gt; {
        if (err) throw (err)
        webpack(config, function (err, stats) {
            if (err) throw (err)
            building.stop()
            process.stdout.write(stats.toString({
                colors: true,
                modules: false,
                children: false,
                chunks: false,
                chunkModules: false
            }) + '\n\n')
            resolve()
            console.log(chalk.cyan('  Build complete.\n'))
        })
    })
    ......
    ......</code></pre>
<p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require('outils/&lt;方法名&gt;')</code>即可，缩短引入的路径，也算是提高点效率。</p>
<pre><code class=""javascript"">// 替换模块文件
    ......
    ......
    // 先删除根目录中之前的函数模块
    rm('*.js', err =&gt; {
        if (err) throw (err)
        let folderList = fs.readdirSync(path.resolve(rootPath, 'src'))
        folderList.forEach((item, index) =&gt; {
            // 拷贝`src`下面一层目录的所有`js`文件至根目录
            copy(`src/${item}/*.js`, rootPath, function (err, files) {
                if (err) throw err;
                if (index === folderList.length - 1) {
                    console.log(chalk.cyan('  Copy complete.\n'))
                    copying.stop()
                }
            })
        })
    })
    ......
    ......</code></pre>
<h2>3.书写测试用例</h2>
<p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p>
<p>但是因为时间关系，本项目暂时通过项目中的<a href=""https://github.com/proYang/outils/blob/master/script/test.js"" rel=""nofollow noreferrer""> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p>
<p>这里给大家推荐一个好用的断言库<a href=""https://www.npmjs.com/package/power-assert"" rel=""nofollow noreferrer""> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p>
<p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p>
<blockquote><p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href=""https://travis-ci.org/"" rel=""nofollow noreferrer""> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href=""https://github.com/proYang/outils/blob/master/.travis.yml"" rel=""nofollow noreferrer""> .travis.yml </a>和<code>karma</code>的配置文件<a href=""https://github.com/proYang/outils/blob/master/script/karma.conf.js"" rel=""nofollow noreferrer""> karma.conf.js </a>。</p></blockquote>
<h1>发布</h1>
<p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href=""https://github.com/proYang/outils/"" rel=""nofollow noreferrer"">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p>
<h3>1.添加自己的函数</h3>
<p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p>
<pre><code class=""javascript"">/**
 * 
 * @desc   判断是否NaN
 * @param  {Any} value 
 * @return {Boolean}
 */
function isNaN(value) {    
    return value !== value;
};

modules.export = isNaN
</code></pre>
<p>然后记得在<code>src/index.js</code>文件中暴露<code>isNaN</code>函数</p>
<h3>2.单元测试</h3>
<p>在<code>test</code>文件新建测试用例</p>
<pre><code class=""javascript"">describe('#isNaN()', function () {
    it(`outils.isNaN(NaN) should return true`, function () {
        assert(outils.isNaN(NaN))
    })
    it(`outils.isNaN('value') should return false`, function () {
        assert.notEqual(outils.isNaN(NaN))
    })
})</code></pre>
<p><del>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</del></p>
<h3>3.测试并打包</h3>
<p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p>
<h3>4.发布到<code>npm</code>
</h3>
<p>在<a href=""https://www.npmjs.com/"" rel=""nofollow noreferrer""> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。  <br>注意：向<code>npm</code>发包，要把镜像源切到<a href=""https://www.npmjs.com/"" rel=""nofollow noreferrer""> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p>
<h1>使用</h1>
<h3>1.浏览器</h3>
<p>直接下载<code>min</code>目录下的<a href=""https://github.com/proYang/outils/blob/master/min/outils.min.js"" rel=""nofollow noreferrer""> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p>
<pre><code class=""html"">  &lt;script src=""outils.min.js""&gt;&lt;/script&gt;
  &lt;script&gt;
      var OS = outils.getOS()
  &lt;/script&gt;</code></pre>
<p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href=""https://github.com/proYang/outils/releases"" rel=""nofollow noreferrer""> github Release </a>页面下载对应版本号的代码。</p>
<h3>2.Webpack、RequireJS、SeaJS等模块加载器</h3>
<p>先使用<code>npm</code>安装<code>outils</code>。</p>
<pre><code class=""bash"">$ npm install --save-dev outils</code></pre>
<pre><code class=""javascript"">// 完整引入
const outils = require('outils')
const OS = outils.getOS()</code></pre>
<p><strong>推荐使用方法</strong></p>
<pre><code class=""javascript"">// 按需引入require('outils/&lt;方法名&gt;')
const getOS = require('outils/getOS')
const OS = getOS()</code></pre>
<p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p>
<pre><code class=""javascript"">import getOS from 'outils/getOS'
// 或
import { getOS } from ""outils"";
</code></pre>
<h1>总结</h1>
<p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href=""https://github.com/proYang/outils/issues"" rel=""nofollow noreferrer""> Github Issues </a>交流，如果觉得不错，欢迎<a href=""https://github.com/proYang/outils"" rel=""nofollow noreferrer""> star </a>本项目。</p>
<p>当然，更好的建议是<a href=""https://github.com/proYang/outils"" rel=""nofollow noreferrer""> fork </a>本项目，或者直接新建自己的项目，添加自己 <strong>想要的</strong> 、<strong>常用的</strong> 、<strong>记不住的</strong> 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p>
<p>工欲善其事必先利其器。有了属于自己的这把利器，希望加班也会变成奢望。O(∩_∩)O哈哈~</p>

                ", 打造自己的JavaScript武器库,1531977756,522,1,219,1,1,https://segmentfault.com/a/1190000011966867
68,1,0,7,"
                    
<p>虽然<code>git</code>诞生距今已有<code>12</code>年之久，网上各种关于<code>git</code>的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于<code>git</code>的理解，并且可能生编硬造了一些不完全符合<code>git</code>说法的词语。目的只是为了让<code>git</code>通俗化，使初学者也能大概了解如何快速上手<code>git</code>。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支<code>master</code>的情况，虽然这种作法并不符合<code>git</code>规范，但是现实情况中绝大部分用户是直接在<code>master</code>分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签<code>tag</code>的操作，只讲在最简单的主分支上如何回退。</p>
<h1>基本概念</h1>
<h2>3个步骤</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVYnEY?w=943&amp;h=177"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>正常情况下，我们的工作流就是<code>3</code>个步骤，对应上图中的<code>3</code>个箭头线：</p>
<pre><code>git add .
git commit -m ""comment""
git push</code></pre>
<ol>
<li><p><code>git add .</code>把所有文件放入<code>暂存区</code>；</p></li>
<li><p><code>git commit</code>把所有文件从<code>暂存区</code>提交进<code>本地仓库</code>；</p></li>
<li><p><code>git push</code>把所有文件从<code>本地仓库</code>推送进<code>远程仓库</code>。</p></li>
</ol>
<h2>4个区</h2>
<p><code>git</code>之所以令人费解，主要是它相比于<code>svn</code>等等传统的版本管理工具，多引入了一个<strong>暂存区</strong>(<code>Stage</code>)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么<code>4</code>个区就够了：</p>
<ul>
<li><p>工作区(<code>Working Area</code>)</p></li>
<li><p>暂存区(<code>Stage</code>)</p></li>
<li><p>本地仓库(<code>Local Repository</code>)</p></li>
<li><p>远程仓库(<code>Remote Repository</code>)</p></li>
</ul>
<h2>5种状态</h2>
<p>以上<code>4</code>个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是<code>5</code>种状态。以下我们把这<code>5</code>种状态分别命名为：</p>
<ul>
<li><p>未修改(<code>Origin</code>)</p></li>
<li><p>已修改(<code>Modified</code>)</p></li>
<li><p>已暂存(<code>Staged</code>)</p></li>
<li><p>已提交(<code>Committed</code>)</p></li>
<li><p>已推送(<code>Pushed</code>)</p></li>
</ul>
<h1>检查修改</h1>
<p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这<code>3</code>个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是<code>diff</code>，只是参数有所不同。</p>
<h2>已修改，未暂存</h2>
<pre><code>git diff</code></pre>
<p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做<code>git add .</code>之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYnIM?w=558&amp;h=287"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>我们在文件开头的第<code>2</code>行胡乱加了<code>4</code>个数字<code>1234</code>，存盘，这时文件进入了<code>已修改</code>状态，但是还没有进入<code>暂存区</code>，我们运行<code>git diff</code>，结果如下：</p>
<pre><code>diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---</code></pre>
<p><code>git diff</code>的结果告诉我们哪些文件已经做了哪些修改。</p>
<h2>已暂存，未提交</h2>
<pre><code>git diff --cached</code></pre>
<p>现在我们把修改放入<code>暂存区</code>看一下。先执行<code>git add .</code>，然后执行<code>git diff</code>，你会发现没有任何结果：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYnKj?w=376&amp;h=63"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这说明<code>git diff</code>这个命令只检查我们的<code>工作区</code>和<code>暂存区</code>之间的差异，如果我们想看到<code>暂存区</code>和<code>本地仓库</code>之间的差异，就需要加一个参数<code>git diff --cached</code>：</p>
<pre><code>diff --git a/index.md b/index.md
index 73ff1ba..1066758 100644
--- a/index.md
+++ b/index.md
@@ -1,5 +1,5 @@
 ---
-layout: main
+1234layout: main
 color: black
 ---</code></pre>
<p>这时候我们看到的差异是<code>暂存区</code>和<code>本地仓库</code>之间的差异。</p>
<h2>已提交，未推送</h2>
<pre><code>git diff master origin/master</code></pre>
<p>现在，我们把修改从<code>暂存区</code>提交到<code>本地仓库</code>，再看一下差异。先执行<code>git commit</code>，然后再执行<code>git diff --cached</code>，没有差异，执行<code>git diff master origin/master</code>，可以看到差异：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYnKY?w=527&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>在这里，<code>master</code>就是你的<code>本地仓库</code>，而<code>origin/master</code>就是你的<code>远程仓库</code>，<code>master</code>是主分支的意思，因为我们都在主分支上工作，所以这里两边都是<code>master</code>，而<code>origin</code>就代表远程。</p>
<h1>撤销修改</h1>
<p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p>
<h2>已修改，未暂存</h2>
<p>如果我们只是在编辑器里修改了文件，但还没有执行<code>git add .</code>，这时候我们的文件还在<code>工作区</code>，并没有进入<code>暂存区</code>，我们可以用：</p>
<pre><code>git checkout .</code></pre>
<p>或者</p>
<pre><code>git reset --hard</code></pre>
<p>来进行撤销操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYnLO?w=441&amp;h=257"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>可以看到，在执行完<code>git checkout .</code>之后，修改已被撤销，<code>git diff</code>没有任何内容了。</p>
<blockquote><p><strong>一对反义词</strong><br><code>git add .</code>的反义词是<code>git checkout .</code>。做完修改之后，如果你想向前走一步，让修改进入<code>暂存区</code>，就执行<code>git add .</code>，如果你想向后退一步，撤销刚才的修改，就执行<code>git checkout .</code>。</p></blockquote>
<h2>已暂存，未提交</h2>
<p>你已经执行了<code>git add .</code>，但还没有执行<code>git commit -m ""comment""</code>。这时候你意识到了错误，想要撤销，你可以执行：</p>
<pre><code>git reset
git checkout .</code></pre>
<p>或者</p>
<pre><code>git reset --hard</code></pre>
<p><code>git reset</code>只是把修改退回到了<code>git add .</code>之前的状态，也就是说文件本身还处于<code>已修改未暂存</code>状态，你如果想退回<code>未修改</code>状态，还需要执行<code>git checkout .</code>。</p>
<p>或许你已经注意到了，以上两个步骤都可以用同一个命令<code>git reset --hard</code>来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到<code>未修改</code>的状态。</p>
<h2>已提交，未推送</h2>
<p>你的手太快，你既执行了<code>git add .</code>，又执行了<code>git commit</code>，这时候你的代码已经进入了你的<code>本地仓库</code>，然而你后悔了，怎么办？不要着急，还有办法。</p>
<pre><code>git reset --hard origin/master</code></pre>
<p>还是这个<code>git reset --hard</code>命令，只不过这次多了一个参数<code>origin/master</code>，正如我们上面讲过的，<code>origin/master</code>代表<code>远程仓库</code>，既然你已经污染了你的<code>本地仓库</code>，那么就从<code>远程仓库</code>把代码取回来吧。</p>
<h2>已推送</h2>
<p>很不幸，你的手实在是太快了，你既<code>git add</code>了，又<code>git commit</code>了，并且还<code>git push</code>了，这时你的代码已经进入<code>远程仓库</code>。如果你想恢复的话，还好，由于你的<code>本地仓库</code>和<code>远程仓库</code>是等价的，你只需要先恢复<code>本地仓库</code>，再强制<code>push</code>到<code>远程仓库</code>就好了：</p>
<pre><code>git reset --hard HEAD^
git push -f</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVYnWc?w=486&amp;h=157"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>总结</h1>
<p>以上<code>4</code>种状态的撤销我们都用到了同一个命令<code>git reset --hard</code>，前<code>2</code>种状态的用法甚至完全一样，所以只要掌握了<code>git reset --hard</code>这个命令的用法，从此你再也不用担心提交错误了。</p>
<h1>更多参考</h1>
<ul><li><p>独孤求败：<a href=""https://segmentfault.com/a/1190000011910766"" rel=""nofollow noreferrer"">Git中的各种后悔药</a></p></li></ul>

                ", Git的4个阶段的撤销更改,1531977758,538,1,299,1,1,https://segmentfault.com/a/1190000011969554
69,1,0,7,"
                    
<p>Svn中也有分支管理，但是很low，Git的分支管理非常强大，本文先不去说分支管理内部到底怎么做的，我们先来看看Git中最基本的分支管理操作。   </p>
<p>本文是Git系列的第四篇，了解前面的文章有助于更好的理解本文：</p>
<hr>
<p>1.<a href=""https://mp.weixin.qq.com/s/3RheAJ9LYKK5BnVr331h5A"" rel=""nofollow noreferrer"">Git概述</a>  <br>2.<a href=""https://mp.weixin.qq.com/s/S1T4wy3srmLvXgIjvpVEwg"" rel=""nofollow noreferrer"">Git基本操作</a>  <br>3.<a href=""https://mp.weixin.qq.com/s/WiLnRQfDVITHMYzGl9pAzQ"" rel=""nofollow noreferrer"">Git中的各种后悔药</a></p>
<hr>
<h2>分支的必要性</h2>
<p>小伙伴们都知道，我们在完成一个项目时，不可能是“单线程”开发的，很多时候任务是并行的，举个栗子：项目2.0版本上线了，现在要着手开发3.0版本，同时2.0版本可能还有一些bug需要修复，这些bug修复之后我们可能还会发2.1，2.2，2.3这些版本，我们不可能等所有bug都修复完了再去开发3.0版本，修复2.0的bug和开发3.0的新功能是两个并行的任务，这个时候我们3.0的功能开发直接在master分支上进行肯定不合适，我们要保证有一个稳定，可以随时发版本的分支存在（一般情况下这个角色由master分支来扮演），此时我们就可以灵活的使用Git中的分支管理功能：  </p>
<p>1.创建一个长期分支用来开发3.0功能，假设这个分支的名字就叫v3，我们在v3上添加新功能，并不断测试，当v3稳定后，将v3合并到master分支上。   <br>2.创建一个特性分支用来修复2.0的bug，一旦bug修复成功，就将该分支合并到master上，一旦发现新bug，就立马再创建分支进行修复，修复成功之后再合并。  </p>
<p>以上两个步骤同步进行，这在Svn中简直是不可想象的，因为Svn的分支管理太low，而Git能够让我们做到随心所欲的创建、合并和删除分支。</p>
<h2>查看分支</h2>
<p>我们可以通过<code>git branch</code>命令来查看当前仓库有哪些分支，而我们处于哪一个分支中，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc69?w=319&amp;h=56"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这里显示当前仓库只有一个master分支，这是git默认创建出来的，master前面的*表示我们当前处于这一个分支中。</p>
<h2>分支创建和切换</h2>
<p>我们可以利用<code>git branch &lt;分支名&gt;</code>命令来创建一个分支，然后利用<code>git checkout &lt;分支名&gt;</code>来切换分支，如下：   <br><span class=""img-wrap""><img data-src=""/img/bVYc7k?w=341&amp;h=199"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果小伙伴觉得这样太麻烦，可以通过<code>git checkout -b &lt;分支名&gt;</code>来一步到位，创建并切换分支，如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc7A?w=301&amp;h=190"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>也可以通过<code>git checkout -</code>命令来切换回上一个分支，如下：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc7D?w=307&amp;h=125"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>分支合并</h2>
<p>现在我切换到fa分支中，由于fa分支是从master分支中创建出来的，所以此时fa分支的内容和master分支的内容是一致的，然后我在fa分支中向git01.txt文件添加一行内容并提交，此时fa分支中的git01.txt和master分支中git01.txt的内容就不相同了，具体操作如下：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc7N?w=564&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>上图展示了此时master分支和fa分支的不同，现在我通过<code>git merge --no-ff &lt;分支名&gt;</code>命令将fa分支合并到master分支上。其中--no-ff表示强行关闭fast-forward方式，fast-forward方式表示当条件允许时，git直接把HEAD指针指向合并分支的头，完成合并，这种方式合并速度快，但是在整个过程中没有创建commit，所以如果当我们删除掉这个分支时就再也找不回来了，因此在这里我们将之关闭。  </p>
<p>想要合并分支，我们先切换到master分支上，然后执行<code>git merge --no-ff fa</code>命令即可完成分支合并，如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8f?w=564&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>合并成功后，我们看到master分支上的git01.txt上已经有了fa分支中的内容了。</p>
<h2>以图表方式查看分支</h2>
<p>我们可以通过<code>git log --graph</code>命令来直观的查看分支的创建和合并等操作，如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8m?w=543&amp;h=635"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>分支衍合</h2>
<p>所谓的分支衍合其实也是分支合并的一种方式，下面我们就来看看这个分支衍合到底是什么样的。现在我的master分支的内容和fa分支的内容是保持一致的，fa是从master中创建出来的，如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8v?w=189&amp;h=182"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>现在我向fa和master中各自做一次提交，如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8z?w=256&amp;h=265"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>此时我们执行如下两条命令将两个分支合并：</p>
<pre><code>$ git checkout fa
$ git rebase master</code></pre>
<p>rebase命令在执行的过程中会首先把fa中的每个commit取消，并且将之保存为临时patch，再将fa分支更新为最新的master分支，然后再把那些临时的patch应用到fa上，此时fa分支将指向新创建的commit上，那些老的commit将会被丢弃，这些被丢弃的commit在执行git gc命令时会被删除。合并后的分支如下图：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8A?w=398&amp;h=256"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>上面的<code>git rebase master</code>命令在执行的过程中有可能会发生冲突，发生冲突时我们有两种方案，一种直接退回到之前的状态，另一种就是解决冲突继续提交。</p>
<h3>退回到之前的状态</h3>
<p>我们可以通过如下命令来回到之前的状态：</p>
<pre><code>$ git rebase --abort</code></pre>
<h3>解决冲突</h3>
<p>不过大多数情况下我们都是要解决冲突的，解决之后继续提交。此时我们用编辑器打开冲突的文件，看到的内容可能是这样的：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8P?w=322&amp;h=128"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>======上面的是HEAD中的内容，下面的是要合并的内容，根据自己的需求编辑文件，编辑完成之后，通过如下两条命令继续完成合并：</p>
<pre><code>$ git add git01.txt
$ git rebase --continue</code></pre>
<p>如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYc8V?w=516&amp;h=130"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>冲突解决</h2>
<p>我们前面提到了在分支衍合时出现冲突的解决方案，其实普通的合并也有可能出冲突，出现冲突很正常，解决就是了，git merge合并分支时如果出现冲突还是先重新编辑冲突文件，编辑完成之后，再执行git add 和git commit即可。  </p>
<p>好了，分支管理我们就先说这么多，有问题欢迎留言讨论。   </p>
<p>参考资料：  </p>
<p>1.《GitHub入门与实践》  <br>2.《Pro Git》  </p>
<p>更多JavaEE和Git资料请关注公众号：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVUERD?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Git分支管理,1531977760,455,1,420,1,1,https://segmentfault.com/a/1190000011927868
70,1,0,7,"
                    
<p>笔者也是今早刚刚接触git，使用git还处在小白阶段，通过各种查阅资料，终于学会了怎么提交项目到Github，接下来笔者会用简单易懂的语言加上图片跟大家一起聊聊怎样，<strong><em>轻轻松松</em></strong>把项目提交到Github上，这一次也当作笔者的一次提升。</p>
<blockquote><p><strong><em>该篇文章，就不涉及git和Github的概念，更多的知识可以到官网中学习</em></strong><br><a href=""https://git-scm.com/"" rel=""nofollow noreferrer"">git官网</a><br><a href=""https://github.com/"" rel=""nofollow noreferrer"">Github官网</a></p></blockquote>
<p><strong>进入正题</strong>，运用git提交项目你需要先有一个git工具（<a href=""https://git-scm.com/"" rel=""nofollow noreferrer"">git官网</a>）在官网中下载，选择设备相应操作系统即可：</p>
<blockquote><h4>git工具下载安装</h4></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVYb80?w=1417&amp;h=953"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>下载完成之后进行安装，安装完成之后，出现以下效果说明安装成功：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYb9Z?w=419&amp;h=564"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>接下来打开 <strong><em>Git Bash Here</em></strong></p>
<pre><code>ssh-keygen -C ""你的邮箱地址"" -t rsa
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVYccq?w=745&amp;h=449"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>连续敲Enter三次在用户目录中出现了<code>.ssh</code>文件</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcdi?w=852&amp;h=911"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>将<code>.ssh</code>文件中的<code>id_rsa.pub</code>里面的所有内容复制下来，git配置完成，开始下一步</p>
<blockquote><h4>Github 配置</h4></blockquote>
<p><strong><em>Begin：</em></strong></p>
<p>现在就需要刚刚复制的内容，准备好 出发！</p>
<p>打开Github官网，登陆以后点击头像会出现一个按钮<code>Setting</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcfO?w=280&amp;h=417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>进入SSH KEYS设置</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcfW?w=402&amp;h=679"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>起个名字将之前复制的<code>id_rsa.pub</code>里面的内容粘贴到<code>key</code>点击<code>Add SSH key</code> </p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcgi?w=930&amp;h=485"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>测试是否连接成功，若和下图一致，说明连接成功</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcjS?w=715&amp;h=117"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>创建一个库，准备工作就已经完成</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcig?w=1072&amp;h=812"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><h4>滴滴~马上就要开车了</h4></blockquote>
<p>你所乘坐的汽车马上就要开车了，请大家准备号git和项目,马上开车！</p>
<p>当你点击创建按钮，将会出现一个这样的界面，按照上面的操作你就可以完成提交项目</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYciu?w=1198&amp;h=279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong><em>Begin：</em></strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYciN?w=716&amp;h=126"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>其中<code>add .</code>添加当前目录下所有文件</p>
<p><span class=""img-wrap""><img data-src=""/img/bVYciR?w=538&amp;h=50"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcj2?w=789&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYckr?w=564&amp;h=32"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>最后一步，见证奇迹的时刻。</p>
<p>输入：<code>git push -u origin master</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcl5?w=664&amp;h=153"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVYcmD?w=1324&amp;h=316"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>End..</p>
<p>按照这样的步骤就可以完成项目提交到Github，谢谢！</p>

                ", 轻轻松松把项目上传到GitHub,1531977761,225,1,308,1,1,https://segmentfault.com/a/1190000011924880
71,1,0,7,"
                    
<p>Git强大的撤销、版本回退功能，让我们在开发的过程中能够随意的回到任何一个时间点的状态，本文我们就来看看Git中的各种后悔药!   </p>
<p>本文是Git系列的第三篇，了解前面的文章有助于更好的理解本文：</p>
<hr>
<p>1.<a href=""https://mp.weixin.qq.com/s/3RheAJ9LYKK5BnVr331h5A"" rel=""nofollow noreferrer"">Git概述</a>  <br>2.<a href=""https://mp.weixin.qq.com/s/S1T4wy3srmLvXgIjvpVEwg"" rel=""nofollow noreferrer"">Git基本操作</a></p>
<hr>
<p>本文将从如下三个方面介绍Git中的后悔药：</p>
<blockquote><p>1.工作区的代码想撤销  <br>2.add到暂存区的代码想撤销  <br>3.提交到本地仓库的代码想撤销</p></blockquote>
<p>提交到远程仓库的后悔药我们统一都在关联远程仓库一文中讲解，敬请期待。</p>
<h2>工作区的代码想撤销</h2>
<p>可能有一天我正在写代码，写了很久发现写错了，想恢复到一开始的状态，一个笨办法就是把刚刚写的代码一行一行的删除，不过这种方式成本太高，我们可以通过<code>git checkout -- &lt;file&gt;</code>命令来撤销工作区的代码修改。如下图：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8Gz?w=550&amp;h=287"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>首先我们执行了git status命令，发现工作区是干净的，然后执行了cat命令，发现文件只有两行内容，然后通过vi编辑器向文件中添加一行，保存并退出，退出来之后又执行了git status命令，此时工作区的状态已经发生变化，然后我们执行了git checkout -- git01.txt命令，表示撤销之前的操作，让git01.txt恢复到之前的状态，该命令执行成功之后，我们再执行cat命令发现文件内容已经恢复了，此时再执行git status，状态也恢复了。</p>
<h2>add到暂存区的代码想撤销</h2>
<p>如果想要撤销，但是代码已经提交到暂存区了，不用担心，也能撤销，分两个步骤：  </p>
<p>1.将暂存区的代码撤销到工作区  <br>2.将工作区的代码撤销(具体操作和'工作区的代码想撤销'一致)  </p>
<p>将暂存区的代码撤销，我们可以使用<code>git reset HEAD</code>命令来实现。如下图：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8GD?w=550&amp;h=287"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这里的代码都比较简单，核心的过程就是先执行<code>git reset HEAD</code>命令，从暂存区撤销，剩下的操作参考'工作区的代码想撤销'一节。</p>
<h2>提交到本地仓库的代码想撤销</h2>
<p>同样的，提交到本地仓库的代码一样也可以撤销，我们可以利用<code>git reset --hard &lt;版本号&gt;</code>命令来实现版本回退，该命令中的版本号有几种不同的写法：</p>
<blockquote><p>1.可以使用HEAD^来描述版本，一个^表示前一个版本，两个^^表示前两个版本，以此类推。   <br>2.也可以使用数字来代替^，比如说前100个版本可以写作HEAD~100。  <br>3.也可以直接写版本号，表示跳转到某一个版本处。我们每次提交成功后，都会生成一个哈希码作为版本号，所以这里我们也可以直接填版本号，哈希码很长，但是我们不用全部输入，只需要输入前面几个字符即可，就能识别出来。</p></blockquote>
<p>看下面一系列的操作：<br>1.通过git log查看当前提交日志：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8GI?w=345&amp;h=275"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.通过git reset HEAD^^向前回退两个版本：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8GK?w=336&amp;h=170"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.查看日志，发现最后一次提交的版本号是695ce1fe,利用git reset --hard 695ce1fe命令回到回退之前的状态：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8GQ?w=329&amp;h=168"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4.通过git reset --hard HEAD~1回到上一个版本：  </p>
<p><span class=""img-wrap""><img data-src=""/img/bVX8GR?w=325&amp;h=178"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>好了，Git中的后悔药我们就先介绍到这里，有问题欢迎留言讨论。   </p>
<p>参考资料：  </p>
<p>1.《GitHub入门与实践》  <br>2.《Pro Git》  </p>
<p>更多JavaEE和Git资料请关注公众号：   </p>
<p><span class=""img-wrap""><img data-src=""/img/bVUERD?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Git中的各种后悔药,1531977763,126,1,287,1,1,https://segmentfault.com/a/1190000011910766
72,1,0,7,"
                    
<p>假如我们需要把自己写的 node.js 服务程序部署到云主机上，请问这样的开发任务该如何实现呢？可以使用免费的 heroku 云服务。下面是使用 heroku 平台部署 node.js 程序的步骤：</p>
<p>总共有七个步骤，具体操作步骤如下：  </p>
<p>一、注册 heroku 网站账户</p>
<p>注意：</p>
<ul>
<li>访问网址：<a href=""https://www.heroku.com/"" rel=""nofollow noreferrer"">https://www.heroku.com/</a>
</li>
<li>需要用翻墙软件，注册过程需要验证注册用户不是机器人，需要点击一个界面上的验证控件，这个验证控件用的是 google 的一个插件，所以不翻墙，这个验证通不过，完成不了注册。</li>
<li>注册邮箱最好是 gmail 邮箱，如果没有 gmail 邮箱可以注册一个，同样需要翻墙。如果是 QQ 邮箱，会提示 QQ 邮箱会屏蔽注册的确认邮件。</li>
</ul>
<p>二、安装下载 heroku-cli 工具</p>
<p>注意：</p>
<ul>
<li>需要切换到 root 用户，再执行安装命令</li>
<li>
<code>heroku -v</code> 命令来验证程序安装是否成功，如果安装成功会在控制台打印出程序的版本信息</li>
<li>
<code>heroku --help</code> 命令会列出 heroku 支持的所有子命令</li>
</ul>
<pre><code class=""bash"">su
npm install -g heroku-cli
heroku -v
heroku --help</code></pre>
<p>三、准备待部署的服务程序</p>
<pre><code class=""bash"">mkdir app-dir
npm init</code></pre>
<p>修改代码，确保代码在本地测试通过。</p>
<p>注意：</p>
<ul>
<li>主脚本程序文件名最好是 index.js</li>
<li>程序需要有 package.json 配置文件</li>
<li>package.json 文件中需要有 <code>npm start</code> 脚本，<code>npm start</code> 脚本就是 linux 命令，一般是 <code>node index.js</code>，表示如何运行服务程序</li>
<li>如果程序中 createServer 创建 web 服务，需要监听端口，需要把监听端口的代码，做如下修改：</li>
</ul>
<pre><code class=""javascript"">.listen(8080);      // 源代码
.listen(process.env.PORT || 8080);    // 修改后的代码</code></pre>
<p>什么原因呢？因为很多人的 web 服务程序都被部署到同一个服务器上，可能大家写的端口号都是 8080，那样就是出现端口冲突，只有第一个被部署的程序能工作，其他人的程序都因为端口冲突而无法运行。这样，云端系统为了避免端口冲突，自动分配给每个部署的应用程序分配了一个端口号，这个端口号就放到 PORT 环境变量中，用 <code>process.env.PORT</code> 代码来调出这个端口号。因为，自己的测试环境没有 PORT 环境变量，所以后面或运算 8080，可以保证本地测试时，代码能正常运行。</p>
<p>四、用 heroku-cli 工具创建应用</p>
<pre><code class=""bash"">heroku login
heroku create app-name</code></pre>
<p>注意：</p>
<ul>
<li>heroku login，需要输入用户名和口令，就是第一个步骤注册的</li>
<li>app-name 可以省略，托管平台会分配一个随机的字符串，保证 app-name 命名不会冲突</li>
<li>当然，也可以自己指定 app-name，尽量不要用 www 或者 blog 之类的名称，一般都会冲突</li>
<li>创建应用过程中，需要输入登录 heroku.com 网站的用户名和密码，在第一步已经注册</li>
<li>
<p>提示信息很重要：</p>
<ul>
<li>提示了网站发布后，访问的地址：<a href=""https://app-name.herokuapp.com/"" rel=""nofollow noreferrer"">https://app-name.herokuapp.com/</a>
</li>
<li>提示了 Git 上传代码的地址：<a href=""https://git.heroku.com/app-name.git"" rel=""nofollow noreferrer"">https://git.heroku.com/app-na...</a>
</li>
</ul>
</li>
</ul>
<p>五、Git 推送代码到远程仓库</p>
<pre><code class=""bash"">git init
git add .
git commit -m ""first commit""
git remote add origin https://git.heroku.com/app-name.git
git remote -v
git push -u origin master</code></pre>
<p>注意：</p>
<ul><li>Git 工具推送代码成功后，有输出信息，远程托管主机会做一系列工作，包括：创建运行环境、安装必要的依赖库、压缩程序，启动服务，等</li></ul>
<p>六、访问和测试 web 服务程序</p>
<pre><code class=""bash"">curl https://app-name.herokuapp.com/</code></pre>
<p>如果在 heroku 上部署的是 RESTful node.js 后台程序，愿意的话可以把前端页面部署到 GitHub 上，如何部署前端页面，请看一下 <a href=""https://ke.qq.com/course/225248#tuin=1859dd2b"" rel=""nofollow noreferrer"">GitHub 开源之旅第一季的课程</a>，这里就不再赘述了。注意一下，在部署前端页面之前，需要修改一下前端页面的代码，确保能够正确访问 RESTful API。</p>
<p>七、使用云服务管理后台</p>
<p>前提是需要翻墙，登录 heroku 网站。主要是查看服务器运行的日志信息，这里就不再多说了。</p>
<p><strong>总结</strong></p>
<p>因为用的是 heroku 的免费服务，可以使用的功能比较有限。另外，就是我们部署的服务程序，如果隔一段时间没有访问，服务进程会被杀掉。当接到下一个请求时，服务程序会被再次唤醒，当然，这样会导致第一次服务程序响应的比较慢。</p>

                ", 在 heroku 平台部署 node.js 程序,1531977765,357,1,809,1,1,https://segmentfault.com/a/1190000011863937
73,1,0,7,"
                    
<p>以我的小经验来看，软件萌新写出来的代码大多“无法直视”。具体现象包括空格和换行符乱用、文件夹和变量的命名多使用拼音等。坐不住的我，便想到了通过 ESLint 配置文件来规范实验室的 JavaScript 代码规范的 Idea。</p>
<p>于是巧遇前实验室毕业学长曾经发布的 npm 包——<a href=""https://github.com/mennghao/creatshare-project-quick-init"" rel=""nofollow noreferrer"">creatshare-project-quick-init</a>。安装好这个包，我们便可以在空文件夹下生成一个项目的基础骨架。</p>
<p><a href=""https://www.npmjs.com/package/creatshare-app-init"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-f96e77fb26a49852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a></p>
<pre><code>dist  //发布目录，用于生产环境
src   //开发目录，开发时所需资源
|----dist  //测试环境目录
|     |----static
|             |----css  //编译打包后的css资源
|             |----js   //打包压缩后的js资源
|             |----imgs //测试环境图片资源
|----less  //开发所需less代码
|----js    //开发所需js代码
|    |----lib //库或框架资源
|----imgs  //开发所需图片资源
index.html    //开发页面
gulpfile.js
package.json
README.md</code></pre>
<p><strong><em>What a good idea~!</em></strong></p>
<p>在学长的这个包中，主要构建了 gulp 配置，less 和测试文件的骨架。虽然再无更多内容，但这份构建基础骨架的灵感还是被我愉快的收走了——学前端的人很多，但大多都太缺工程化意识了。于是，这个灵感成为了不错突破口。</p>
<p>creatshare-app-init 脚手架孕育而生。</p>
<h1>0</h1>
<p>通过这篇文章，你能了解到：</p>
<ul>
<li>如何用 NodeJS 编写命令行工具？</li>
<li>如何发布自己的 npm 包？</li>
<li>笔者与 creatshare-app-init 的故事？</li>
</ul>
<p>在本文中，或多或少出现过以下关键字，我的解释是：</p>
<ul>
<li>轮子：该词在前端开发日常用语中，表示一个基于原生代码实现，但并没有对前端行业产生积极意义的模块。虽然它的出现方便了一些人的使用，但更多的加大了我们的学习成本。</li>
<li>项目：该词在前端领域常指一个服务于用户的软件立项。</li>
<li>模块：<code>creatshare-app-init</code> 就是一个模块，是开发前端项目中的一个子集。正如汽车的各个部件一样，多个模块合理组装起来才是一辆汽车。</li>
</ul>
<h1>1</h1>
<p>尝试解析源码，第一步，从模块根目录下的 <code>package.json</code> 来看。</p>
<pre><code>""dependencies"": {
    ""commander"": ""^2.11.0""
},
""devDependencies"": {
    ""babel-plugin-transform-runtime"": ""^6.23.0"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-stage-2"": ""^6.24.1"",
    ""babel-runtime"": ""^6.26.0"",
    ""eslint-config-standard"": ""^10.2.1"",
    ""eslint-plugin-import"": ""^2.8.0"",
    ""eslint-plugin-node"": ""^5.2.1"",
    ""eslint-plugin-promise"": ""^3.6.0"",
    ""eslint-plugin-standard"": ""^3.0.1""
}</code></pre>
<p>如上，<code>dependencies</code> 声明了模块上线时的依赖，<code>devDependencies</code> 声明了模块开发时的依赖。该模块在上线时，即 npm 包被用户用到时，只需要 <code>commander</code> 库。<code>commander</code> 库是 NodeJS 命令行接口开发的优选解决方案，受启发于 Ruby 的 commander。在解析 <code>bin/index.js</code> 源码时将详细拓展。</p>
<pre><code>""name"": ""creatshare-app-init"",
""version"": ""2.1.0"",
""description"": ""CreatShare 实验室前端项目初始化工具"",
""bin"": {
  ""cs"": ""bin/index.js""
},
""scripts"": {
  ""compile"": ""babel src/ -d lib/"",
  ""prepublish"": ""npm run compile"",
  ""eslint"": ""eslint src bin"",
  ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1""
},</code></pre>
<p>上面一段是 <code>package.json</code> 最开头的内容，字段详情如下：</p>
<ul>
<li>
<code>name</code> 字段：声明模块名称。特殊注意该字段不允许大写字母及空格的出现，且其与 <code>version</code> 字段形成了 npm 模块的唯一标识符。</li>
<li>
<code>version</code> 字段：声明模块当前版本号。这里每当使用 <code>npm publish</code> 将模块发布到 npm 仓库中时，版本号都需要手动自增。</li>
<li>
<code>description</code> 字段：对模块进行描述，同时有助于被检索。</li>
<li>
<code>bin</code> 字段：npm 本身是通过 bin 属性配置一个或多个可解析到 PATH 路径下的可执行模块。模块若被全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接；模块若被局部安装，软连接会配置在项目内的 <code>./node_modules/.bin/</code>目录下。</li>
<li>
<code>script</code> 字段：定义模块的脚本配置。如，当我们在模块目录下使用 <code>npm run compile</code> 时，将自动执行 <code>babel src/ -d lib/</code> 命令，进行 ECMAScript6 代码的转译。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-d75bd4916fafc450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>2</h1>
<p>刚刚提到 <code>package.json</code> 配置文件下的 <code>bin</code> 字段声明了 npm 在生成软连接时的配置。这就便是用户在安装好这个目录后，可以随时使用 <code>cs</code> 命令的出处。</p>
<p>我们又提到了该模块在非开发环境下只需用到 <code>commander</code> 模块，这个模块是 NodeJS 命令行接口开发的优选解决方案。</p>
<p>基于这俩点，我们就从 <code>bin</code> 字段所指向的 <code>bin/index.js</code> 聊起。</p>
<pre><code>#!/usr/bin/env node

var program = require('commander')
var cs = require('../lib/cs')

program
  .allowUnknownOption()
  .version('2.1.1')
  .description('CreatShare 互联网实验室前端 Web App 项目脚手架')
  .option('-e, --enjoy')

program.
  .command('create &lt;dir&gt;')
  .description('创建一个新的 Web App 项目骨架')
  .action(function (rootDir) {
    cs.create(rootDir)
})

program.parse(process.argv)</code></pre>
<p>就这么二十来行。因为我们要写的模块是要运行在命令行下的，就需要 <code>#!/usr/bin/env node</code> 语句来告诉系统使用 node 环境来运行我们的文件，必不可少。</p>
<p>在引入 <code>commander</code> 并将其赋值给 <code>program</code> 变量后，我们对其使用了如下方法：</p>
<ul>
<li>
<code>.allowUnknownOption()</code> 方法：</li>
<li>
<code>.version()</code> 方法：用于设置命令程序的版本号。</li>
<li>
<code>.description()</code> 方法：用于设置命令的描述。可以绑定在跟命令下，这里是 <code>cs</code> 命令；或绑定在子命令下，如 <code>cs create &lt;dir&gt;</code> 命令。</li>
<li>
<code>.option()</code> 方法：定义命令的具体选项。</li>
<li>
<code>.command()</code> 方法：定义命令的子命令，这里是 <code>cs create &lt;dir&gt;</code> 命令。</li>
<li>
<code>.action()</code> 方法：用于设置命令执行的相关回调。这里绑定在 <code>cs create &lt;dir&gt;</code> 命令上，在使用该命令时触发执行回调函数。</li>
</ul>
<p>代码最后的 <code>process</code> 为进程对象，是 NodeJS 运行时存在的众多全局变量之一。process 对象中的 argv 属性用来捕获命令行参数。</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-9464c105f848f58b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>3</h1>
<p>刚刚在 <code>bin/index.js</code> 里说明的 <code>.action</code> 回调函数绑定在 <code>cs create &lt;dir&gt;</code> 命令下。当我们使用该命令时，会触发 <code>cs.create()</code> 语句的执行，这就要提及我们引入的 <code>lib/cs.js</code> 文件了。</p>
<p>打住，第一节里展示的 <code>package.json</code> 中，<code>script</code>字段里有这么一条语句：<code>""compile"": ""babel src/ -d lib/""</code>。这是说明 <code>lib/</code> 文件夹下的代码是通过 <code>src/</code> 文件夹下的代码转译过来的，真正我们需要去关注的是 <code>src/cs.js</code> 文件。</p>
<blockquote>为什么需要转译？src 里的 JavaScript 代码或多或少的使用到了 ECMAScript6 新特性，有些用户的 Node 环境并不一定能得到较好的解析。</blockquote>
<p><code>src/cs.js</code> 主要代码片段为：</p>
<pre><code>let create = require('./create')
let path = require('path')
let distPath = path.join(__dirname, '/../dist')
let dist = process.cwd() + '/'

/**
* [运行 create 命令]
* @return {[type]} [description]
*/
exports.create = (rootDir) =&gt; {
  console.log('\n项目目录开始创建\n')
  create.init(distPath, dist, rootDir)
  helpGuide()
}</code></pre>
<p>不难理解，<code>create</code> 变量指向 <code>cs create &lt;dir&gt;</code> 所要执行的源代码；<code>path</code> 是 NodeJS 自带模块，提供文件目录解析功能。</p>
<p>最终 <code>src/index.js</code> 使用 <code>exports.create</code> 语句向外部暴露出 <code>create</code> 方法。<code>bin/index.js</code> 便可以将该方法通过 <code>.action()</code> 绑定到 <code>cs create &lt;dir&gt;</code> 命令上了。</p>
<h1>4</h1>
<p>精彩的来了。都说 ECMAScript6 的指定振奋人心，JavaScript 的魅力越来越大，这里便是一次体验 JavaScript 在 NodeJS 上的新玩法有趣之旅。</p>
<p>在 <code>src/create.js</code> 文件中，主要用到了 NodeJS 自带的 <code>fs</code> 文件模块，来生成新项目的基础架构。文件最后暴露出的 <code>init</code> 方法源码如下。</p>
<pre><code>exports.init = (path, dist, rootDir) =&gt; {
  createRootDir(rootDir)
  // 从新目录开始新建项目
  dist = dist + rootDir
  copyDir(path, dist)
}</code></pre>
<p><code>init</code> 方法获取了 <code>path</code> 参数、<code>dist</code> 参数和 <code>rootDir</code> 参数。在该方法中，我们先将 <code>rootDir</code> 参数传入 <code>createRootDir()</code> 函数中创建项目根目录。</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-130ef6c78e5d5f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在哪里创建项目根目录呢？就在执行 <code>cs</code> 命令时的当前目录下：</p>
<pre><code>const createRootDir = (rootDir) =&gt; {
  fs.access(process.cwd(), function (err) {
    if (err) {
      // 目录不存在时创建目录
      fs.mkdirSync(rootDir)
    }
  })
}</code></pre>
<p>有了项目根目录，就要将模块下 <code>dist/</code> 文件夹里的所有文件递归拷贝到根目录下。一个参数用来指向 <code>dist/</code> 文件夹，另一个参数用来指向根目录，便可以开始递归复制。</p>
<pre><code>/**
 * [初始化静态资源]
 * @param  {[type]} src  [初始化资源路径]
 * @param  {[type]} dist [当前终端所在目录]
 * @return {[type]}      [description]
 */
const copyDir = (src, dist) =&gt; {
  fs.access(dist, function (err) {
    if (err) {
      // 目录不存在时创建目录
      fs.mkdirSync(dist)
    }
    _copy(null, src, dist)
  })

  function _copy (err, src, dist) {
    if (err) { throw err }
    fs.readdir(src, function (err, files) {
      if (err) { throw err }
      // 过滤不生成的文件
      miscFiles.forEach(function (v) {
        if (!files.includes(v)) return
        files = files.filter(function (k) {
          return k !== v
        })
      })
      // 遍历目录中的文件
      files.forEach(function (path) {
        var _src = src + '/' + path
        var _dist = dist + '/' + path
        fs.stat(_src, function (err, st) {
          if (err) { throw err }
          // 判断是文件还是目录
          if (st.isFile()) {
            fs.writeFileSync(_dist, fs.readFileSync(_src))
          } else if (st.isDirectory()) {
            // 当是目录是，递归复制
            copyDir(_src, _dist)
          }
        })
      })
    })
  }
}</code></pre>
<p><code>fs</code> 文件模块的具体内容推荐阅读阮一峰的开源电子书——《JavaScript 标准参考教程》中的“NodeJS”章节，来深入浅出 <code>fs</code> 模块的用法。</p>
<p>完美，这时我们就可以发布我们的脚手架包了。</p>
<h1>5</h1>
<p>如何发布一个 npm 包到 npm 仓库中，供其他人使用？当我们照着第一步，将 <code>package.json</code> 配置好后，其实模块的准备工作已经做好了。</p>
<p>还没有做的就是在域名为 npmjs.com 的官网上注册一个账号。这样，当我们直接在模块根目录使用 <code>npm publish</code> 命令的时候，输入正确的 npmjs.com 账号、密码，就能成功发布你的开源包了！</p>
<p>纵然读博文是一个有趣的体验，但也可以亲自动手试一试哦。</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-d2b38882c155aef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>6</h1>
<p>也就是说，酷炫的生成新项目骨架的来源，只是简单的递归复制该模块下的 <code>dist/</code> 文件夹到新项目中。但我们需要关注的重点在于，<code>dist/</code> 文件夹下，到底装了什么？</p>
<p>“初级 Web App 项目初始化工具”一说，也就名归有主了。<code>dist/</code> 模板，也就是新项目的骨架如下。</p>
<pre><code>.
├── .babelrc             # ES6 代码转义规则配置
├── .eslint.js           # JavaScript 代码规范
├── .gitignore           # Git 不跟踪的特殊文件
├── LICENSE              # 开源协议
├── README.md            # 项目介绍
├── material             # README.md 引用的图片库
├── package.json         # 项目配置文件
├── src                  # 源码开发目录
│   ├── favicon.ico      # 网页标题小图标
│   ├── html             # HTML 页面模板目录
│   ├── image            # 图片资源目录
│   ├── manifest.json    # 网络应用清单
│   ├── script           # 脚本文件资源目录
│   └── style            # 样式文件资源目录
├── webpack.config.js    # Webpack 多文件打包基础配置
├── webpack.dev.js       # Webpack 开发环境配置
├── webpack.prod.js      # Webpack 发布上线配置
└── yarn.lock            # yarn 包管理器的依赖说明</code></pre>
<p>新项目骨架中默认推荐了：</p>
<ul>
<li>使用 Webpack 来打包多页面；</li>
<li>使用 ESLint 来规范自己项目的 JavaScript 代码；</li>
<li>使用 Babel 来编译使用 ECMAScript 新特性的 JavaScript 代码。</li>
<li>使用 MIT 开源协议；</li>
<li>源代码都放在 <code>src/</code> 目录下；</li>
<li>
<code>src/</code> 目录要对不同的代码进行合理的分层。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-0d9615b2209f0902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>End</h1>
<p><strong><em>现在的不足，是未来的畅想。</em></strong></p>
<p>这个模块并不完美，一个健壮的命令还应该能支持足够多的参数，运行足够有意义的子命令。比如我们常用 <code>man</code> 命令来看另一个命令的使用手册，那要让用户能用到 <code>man cs</code> 命令，还需要我们在代码中加入 <code>man</code> 字段等等。。</p>
<p><strong><em>我又为什么，这么热衷于分享这个轮子？</em></strong></p>
<p>记得有一个前端群里曾有人问过：</p>
<blockquote>“怎么没有 VueJS 的源码解析？”</blockquote>
<p>时，我说过：</p>
<blockquote>“大牛很忙，关注的是前端前沿，不写这些源码解析博文是个好事。<p>“当我们想有一个源码解析教程的时候，这是一个打开新世界的契机——未尝不使我们亲自来写，通过分享走向学习效率金字塔的最高层？”</p>
</blockquote>
<p>这样的能力并不是人人都能具备，也不必要让人人都具备。我曾在大一傲气的说过“做最好的自己，影响该影响的人”，现在想起来除了有立刻找地洞钻进去的冲动外，反而还是觉得有一定的道理（笑。这时候允许我自称为一次“教主”，我们的理念是：</p>
<p><strong><em>读文档，读文档，读文档。</em></strong><br><strong><em>写博客，写博客，写博客。</em></strong></p>
<blockquote>
<ul>
<li>Hello，我是韩亦乐，现任本科软工男一枚。软件工程专业的一路学习中，我有很多感悟，也享受持续分享的过程。如果想了解更多或能及时收到我的最新文章，欢迎订阅我的个人微信号：韩亦乐。<a href=""http://www.jianshu.com/u/ecbf49bf207b"" rel=""nofollow noreferrer"">我的简书个人主页</a>中，有我的订阅号二维码和 <a href=""https://github.com/hylerrix"" rel=""nofollow noreferrer"">Github 主页地址</a>；<a href=""https://www.zhihu.com/people/hylerrix/activities"" rel=""nofollow noreferrer"">我的知乎主页</a> 中也会坚持产出，欢迎关注。</li>
<li>本文内部编号经由<a href=""https://github.com/hylerrix/FSD-Debris/issues"" rel=""nofollow noreferrer"">我的 Github 相关仓库</a>统一管理；本文可能发布在多个平台但仅在上述仓库中长期维护；本文同时采用<a href=""https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"" rel=""nofollow noreferrer"">【知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议】</a>进行许可。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/2558748-39f785a767794693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
</blockquote>

                ", 造轮子之 npm i -g creatshare-app-init 源码浅析,1531977766,370,1,348,1,1,https://segmentfault.com/a/1190000011837284
74,1,0,7,"
                    
<h1>git详细安装</h1>
<p><a href=""https://git-scm.com/downloads"" rel=""nofollow noreferrer"">git官方下载地址</a>    <a href=""https://git-scm.com/downloads"" rel=""nofollow noreferrer"">https://git-scm.com/downloads</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVXFZ4?w=1017&amp;h=563"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>目前最新的版本是2.15.0</p>
<h2>使用2.9.3版本为例，为大家展示</h2>
<h4>首先，双击安装包，打开安装界面，然后点击Next下一步</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXG5f?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>配置git的安装组件，默认就行，继续点击Next下一步</h4>
<blockquote><p>默认勾选的内容有：创建桌面快捷方式、右键快捷打开Git Bash Here和Git GUI Here以及后缀关联等</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXG7r?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>设置能否在cmd命令行中执行git操作,选择第二项</h4>
<blockquote><p>第一项的意思是：只能在Git Bash 中使用git，不会配置git命令的环境变量</p></blockquote>
<blockquote><p>第二项的意思是：除了Git Bash 以外，还可以在windows中的cmd命令行使用git，会自动配置好git命令的环境变量</p></blockquote>
<blockquote><p>第三项的意思是：Git和可选的Unix工具添加到环境配置中，git命令和unix工具命令都会添加到环境变量，但是会覆盖windows的查找和排序功能，不建议选择</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHaY?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>配置行结束,选择第一个选项</h4>
<blockquote>
<p>第一个选项是：git在跨平台项目中提交的文本文件会自动转化格式，推荐在windows上配置的</p>
<p>第二个选项是：git在跨平台项目中提交的文本文件会自动转化格式，推荐在Unix上配置的</p>
<p>第三个选项是：git在检测或提交文本文件时不会转化格式，不推荐跨平台项目选择此选项</p>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHjF?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>在终端模拟器选择页面，默认选择第一个就行</h4>
<blockquote><p>第一个选项是：Git使用MinTTY作为终端模拟器，Git的打开窗口可以自由调整大小</p></blockquote>
<blockquote><p>第二个选项是：Git使用windows的默认控制台窗口，Git的打开窗口不能自由调整大小</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHHD?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>最后配置Git的额外选项，选择默认就行，点击Install 开始安装</h4>
<blockquote><p>第一个选项：启动文件缓存(可选)</p></blockquote>
<blockquote><p>第二个选项：启动Git凭证管理器(可选)</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHS0?w=503&amp;h=389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>如果之前安装过其他版本的Git，会先卸载之前的版本，然后才会安装</p></blockquote>
<h4>安装完成后，桌面会有Git的快捷方式</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXIbx?w=78&amp;h=79"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>在任意目录下右击，会有Git Bash Here和Git GUI Here的快捷方式</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXInx?w=261&amp;h=200"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>使用任意方式，打开Git</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXInW?w=595&amp;h=329"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>出现这个黑色的框框，就说明Git安装成功了！</p></blockquote>
<h5>至此，安装Git教程就结束了，有什么疑问或错误，欢迎在文章下留言~</h5>

                ", windows详细安装Git以及Git的入门教程[安装Git],1531977768,172,1,668,1,1,https://segmentfault.com/a/1190000011809698
75,1,0,7,"
                    
<h2>项目上线</h2>
<h2>github 和 打包上线，感觉比较繁琐</h2>
<blockquote><p>每次更新完代码，手动push 到远程仓库，如果想让服务器的代码也同步的话，需要手动去服务器上面，拉取，编译，把编译后的代码复制需要的路径。</p></blockquote>
<h2>使用git webhooks 完美解决这个问题</h2>
<h2>webhooks 概念</h2>
<h3>打开方式</h3>
<blockquote><p>在你的github项目中 点击 settings  会在左侧webhooks</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHNm?w=1100&amp;h=366"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>hook 钩子，想要在git某个生命周期触发一个事件，就是想让程序在我们触发一个git事件的时候，做一些事情。<br>举个列子：当我们把代码 git push origin master  的时候，push成功以后，希望服务器自动把代码拉取，更新，做一些自己希望做的事情。</p></blockquote>
<h2>使用详细指南</h2>
<blockquote><p>下面以 vnshop10 为例子，点击图片的 add webhook 按钮</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHQI?w=1091&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>点击 addwebhook 后 会出现确认密码</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVXHQX?w=548&amp;h=542"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>确认完之后出现以下</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVXHQ7?w=1120&amp;h=682"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>输入一个payload url</h4>
<blockquote><p>Payload URL   当我们提交代码后，git webhook 会像这个url提交一个post请求</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHRU?w=620&amp;h=555"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>选择返回的类型</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXHSm?w=305&amp;h=127"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>Content type<br>一个是json 类型 （选择json类型）<br>一个是x-wwwl-from-urlencoded 类型</p>
<h4>Secret 输入秘钥，这个和程序里面的秘钥要保持一致</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXHSQ?w=503&amp;h=82"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>选择触发的事件</h4>
<blockquote><p>Which events would you like to trigger this webhook?</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHTV?w=1582&amp;h=1562"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>我们选择 Just the push event.</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXHUf?w=523&amp;h=299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>把deploy的项目克隆下拉</h3>
<pre><code>git clone https://github.com/itguide/deploy-vnshop.git deploy</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVXH0X?w=343&amp;h=508"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote>
<p>需要修改的<br><span class=""img-wrap""><img data-src=""/img/bVXH1z?w=1280&amp;h=443"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>添加的文件</p>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXH1V?w=1109&amp;h=367"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>打开index.js</h4>
<pre><code>const http = require('http')
const shell = require('shelljs')
const createHandler = require('github-webhook-handler')
const handler = createHandler({ path: '/webhook', secret: 'vnshop' })
    // 上面的 secret 保持和 GitHub 后台设置的一致

const port = 9988
const projects = ['vnshop.shudong.wang', 'vnshop', 'deploy', 'deploy-vnshop']

const projectHandler = (event, action) =&gt; {
    const project = event.payload.repository.name // 提交的仓库名字
    console.log(project);
    const branch = event.payload.ref
    if (projects.includes(project)) {
        console.log(new Date(), `Received a ${action} event for ${project} to ${branch}`)
        shell.exec(`sh ./projects/${project}.sh`, (code, stdout, stderr) =&gt; {
            console.log(new Date(), 'Exit code:', code)
                // console.log(new Date(), 'Program output:', stdout)
            console.log(new Date(), '执行完毕！错误信息：？', stderr)
        })

    }
}

http.createServer((req, res) =&gt; {
    handler(req, res, err =&gt; {
        res.statusCode = 404
        res.end('no such location')
    })
}).listen(port, () =&gt; {
    console.log(new Date(), `Deploy server Run！port at ${port}`)
    shell.exec('echo shell test OK!', (code, stdout, stderr) =&gt; {
        // console.log('Exit code:', code)
        // console.log('Program output:', stdout)
        // console.log('Program stderr:', stderr, stderr === '', !!stderr)

    })
})

handler.on('error', err =&gt; {
    console.error('Error:', err.message)
})

handler.on('push', event =&gt; { projectHandler(event, 'push') })
handler.on('commit_comment', event =&gt; { projectHandler(event, 'commit') })</code></pre>
<h4>以上代码重点修改</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVXHV6?w=828&amp;h=68"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>path：和git webhooks的payload 保持一致 记得前面加上完整url路径 比如： <a href=""http://vx.itnote.cn"" rel=""nofollow noreferrer"">http://vx.itnote.cn</a>:9988/webhook</p>
<p>相当于一个api，每次我们往github 提交事件的时候，github 的webhooks 根据我们设定的事件，然后像这个url提交一个post请求，然后服务器就会根据触发的请求，做一些事情。</p>
<p>secret：和git webhooks的secret 保持一致</p>
<h4>触发的shell 脚本，根据自己的项目业务，编写自己的shell</h4>
<blockquote><p>注意：以下shell 是针对这个教程的项目仅供参考，如果你的项目不符合，请修改自己的shell，<br>我的项目是 vnshop10 所以这个shell文件名字是 vnshop10<br>需要添加的文件<br>vnshop10.sh</p></blockquote>
<pre><code>#!/bin/bash
 
WEB_PATH='/home/wwwroot/vnshop/'
WEB_PATH_CLIENT='/home/wwwroot/vnshop/client'
WEB_USER='www'
WEB_USERGROUP='www'
# we can do 
echo ""Start deployment vx.itnote.cn""
cd $WEB_PATH
echo ""pulling source code...""
# git reset --hard origin/release
# git clean -f
# 把项目拉取到最新
git pull
git checkout master
echo ""changing permissions...""
# 切换到client里面
cd $WEB_PATH_CLIENT
# 把vue项目编译
npm run build
chown -R $WEB_USER:$WEB_USERGROUP $WEB_PATH_CLIENT
echo ""Finished.""
</code></pre>
<h4>以上代码修改完后推送到自己 的仓库</h4>
<pre><code>检查一下远程仓库是谁的
git remote -v 

更改成自己的仓库
先删除远程的仓库地址
git remote remove origin

添加自己的仓库地址
git remote add origin 自己的仓库地址
</code></pre>
<h4>然后去服务器自己把刚才推送的这个项目克隆下拉</h4>
<pre><code>cd /home/wwwroot

git clone https://github.com/itguide/deploy-vnshop.git

进入到项目里面
cd /home/wwwroot/deploy-vnshop

安装依赖包
cnpm i

</code></pre>
<p>然后启动这个deploy项目</p>
<pre><code>cd /home/wwwroot/deploy-vnshop

使用pm2 启动，需要提前安装 pm2  npm i -g pm2

pm2 start index.js --name deploy --watch -i max -e ./logs/deploy/error.log -o ./logs/deploy/out.log</code></pre>
<h4>测试接口启动是否成功</h4>
<pre><code>netstat -anp | grep 9988</code></pre>
<p>可以使用浏览器打开</p>
<pre><code>http://vx.itnote.cn:9988/webhook</code></pre>
<blockquote><p>如果浏览器不可以访问，是阿里云主机的话，需要配置安全组规则</p></blockquote>
<h3>去填写git webhooks 这些配置</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVXIsQ?w=925&amp;h=687"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>上面的信息，都要和自己填写的保持一致</p>
<h3>填写好点击 add webhook 按钮</h3>
<h3>测试git webhook是否配置成功</h3>
<blockquote><p>生成一个 webhook 点击进去<br> 出现以下情况，表示配置成功</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXIuf?w=777&amp;h=404"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVXItJ?w=1582&amp;h=1398"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>测试整个流程是否ok，本地编写代码，push到仓库，检查线上代码是否发生改变。</h3>
<blockquote><p>在本地修改代码，然后提交到master 经过几秒钟漫长的等待，发现线上代码成更改</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVXIyK?w=1347&amp;h=623"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVXIy1?w=1558&amp;h=622"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVXIza?w=1452&amp;h=610"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>大功告成，如果不能帮助到你，请留言</h3>
<h3>如果帮助到你，请点赞，收藏，嘿嘿，也可以打赏哦！</h3>
<h4>欢迎加入前端持续学习</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVZoaS?w=541&amp;h=741"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 【全栈项目上线（vue+node+mongodb）】07.使用git webhooks 优雅的自动化上线vue项目（巨详细）：）,1531977770,177,1,552,1,1,https://segmentfault.com/a/1190000011808364
76,1,0,7,"
                    
<h1>基于<code>vue-cli</code>优化的<code>webpack</code>配置</h1>
<p>大概分为以下几点</p>
<ul>
<li>通过 <code>externals</code> 配置来提取常用库，引用外链</li>
<li>配置<code>CommonsChunkPlugin</code>提取公用代码 （<code>vue-cli</code>已做）</li>
<li>善用<code>alias</code>（<code>vue-cli</code>配置了一部分）</li>
<li>启用<code>DllPlugin</code>和<code>DllReferencePlugin</code>预编译库文件</li>
<li>
<code>happypack</code>开启多核构建项目</li>
<li>将<code>webpack-parallel-uglify-plugin</code>来替换<code>webpack</code>本身的<code>UglifyJS</code>来进行代码压缩混淆</li>
<li>升级<code>webpack</code>至3.x版本开启<code>Scope Hoisting</code>
</li>
</ul>
<h3>externals</h3>
<blockquote>
<p>文档地址 <a href=""https://doc.webpack-china.org/configuration/externals/"" rel=""nofollow noreferrer"">https://doc.webpack-china.org...</a></p>
<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。</p>
</blockquote>
<h3>CommonsChunkPlugin</h3>
<blockquote>
<p>文档地址 <a href=""https://doc.webpack-china.org/plugins/commons-chunk-plugin/"" rel=""nofollow noreferrer"">https://doc.webpack-china.org...</a></p>
<p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p>
</blockquote>
<h3>resolve.alias</h3>
<blockquote>
<p>文档地址 <a href=""https://doc.webpack-china.org/configuration/resolve/#resolve-alias"" rel=""nofollow noreferrer"">https://doc.webpack-china.org...</a></p>
<p>创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块：</p>
</blockquote>
<h3>DllPlugin和DllReferencePlugin</h3>
<blockquote>
<p>文档地址 <a href=""https://doc.webpack-china.org/plugins/dll-plugin/"" rel=""nofollow noreferrer"">https://doc.webpack-china.org...</a></p>
<p>Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。使用Dll打包的基本上都是独立库文件，这类文件有一个特性就是变化不大。，只要包含的库没有升级， 增减，就不需要重新打包。这样也提高了构建速度。</p>
<p>一般是用于打包阶段</p>
</blockquote>
<ol><li>在<code>build</code>文件夹下新建<code>webpack.dll.conf.js</code>文件</li></ol>
<pre><code class=""javascript"">var path = require('path');
var webpack = require('webpack');
var AssetsPlugin = require('assets-webpack-plugin');
var CleanWebpackPlugin = require('clean-webpack-plugin');
var config = require('../config');
var env = config.build.env;

module.exports = {
  entry: {
    libs: [
      'babel-polyfill',
      'vue/dist/vue.esm.js',
      'vue-router',
      'vuex',
      'element-ui',
      'echarts',
      'mockjs',
    ],
  },
  output: {
    path: path.resolve(__dirname, '../libs'),
    filename: '[name].[chunkhash:7].js',
    library: '[name]_library',
  },
  plugins: [
    new webpack.DefinePlugin({
      'process.env': env,
    }),
    new webpack.DllPlugin({
      path: path.resolve(__dirname, '../libs/[name]-mainfest.json'),
      name: '[name]_library',
      context: __dirname, // 执行的上下文环境，对之后DllReferencePlugin有用
    }),
    new ExtractTextPlugin('[name].[contenthash:7].css'),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false,
      },
    }),
    new AssetsPlugin({
      filename: 'bundle-config.json',
      path: './libs',
    }),
    new CleanWebpackPlugin(['libs'], {
      root: path.join(__dirname, '../'), // 绝对路径
      verbose: true,
      dry: false,
    }),
  ],
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: 'babel-loader',
      },
    ],
  },
};</code></pre>
<ol><li>在<code>build</code>文件夹下新建<code>build-dll.js</code>文件</li></ol>
<pre><code class=""javascript"">var path = require(""path"");
var webpack = require(""webpack"");
var dllConfig = require(""./webpack.dll.conf"");
var chalk = require(""chalk"");
var rm = require(""rimraf"");
var ora = require(""ora"");

var spinner = ora({
  color: ""green"",
  text: ""building for Dll...""
});
spinner.start();
rm(path.resolve(__dirname, ""../libs""), err =&gt; {
  if (err) throw err;
  webpack(dllConfig, function(err, stats) {
    spinner.stop();
    if (err) throw err;
    process.stdout.write(
      stats.toString({
        colors: true,
        modules: false,
        children: false,
        chunks: false,
        chunkModules: false
      }) + ""\n\n""
    );
    console.log(chalk.cyan("" build dll succeed !.\n""));
  });
});
</code></pre>
<ol><li>修改<code>webpack.prod.conf.js</code>文件</li></ol>
<pre><code class=""javascript"">var bundleConfig = require(""../libs/bundle-config.json"");
...
...
plugins: [
  // 增加DllReferencePlugin配置
  new webpack.DllReferencePlugin({
    context: __dirname,
    manifest: require(""../libs/libs-mainfest.json"") // 指向生成的manifest.json
  }),
  ...
  ...
  new HtmlWebpackPlugin({
    ...
    // 增加两个变量
    libJsName: bundleConfig.libs.js,
    libCssName: bundleConfig.libs.css,
  }),
  ...
  ...
  // 增加一个静态文件目录
   new CopyWebpackPlugin([
     ...
     ...
    {
      from: path.resolve(__dirname, ""../libs""),
      to: config.build.assetsSubDirectory,
      ignore: [""*.json""]
    }
  ])
]</code></pre>
<ol><li>修改模版文件<code>index.html</code>
</li></ol>
<pre><code class=""ejs"">&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
  &lt;!-- built files will be auto injected --&gt;
  &lt;% if (htmlWebpackPlugin.options.libCssName){ %&gt;
    &lt;link rel=""stylesheet"" href=""./static/&lt;%= htmlWebpackPlugin.options.libCssName %&gt;""&gt;
  &lt;% } %&gt;

  &lt;% if (htmlWebpackPlugin.options.libJsName){ %&gt;
      &lt;script src=""./static/&lt;%= htmlWebpackPlugin.options.libJsName %&gt;""&gt;&lt;/script&gt;
  &lt;% } %&gt;
&lt;/body&gt;</code></pre>
<ol><li>修改<code>package.json</code>，增加<code>scripts</code>
</li></ol>
<pre><code class=""json"">""scripts"": {
  // 增加
  ""dll"": ""node build/build-dll.js""
},</code></pre>
<ol><li>
<code>npm run dll</code>先执行预编译，然后在打包项目文件，如果引入的类库文件没有变更就不再需要再次执行预编译</li></ol>
<h3>happypack</h3>
<blockquote>
<p>文档地址 <a href=""https://github.com/amireh/happypack"" rel=""nofollow noreferrer"">https://github.com/amireh/hap...</a></p>
<p>一般node.js是单线程执行编译，而happypack则是启动node的多线程进行构建，大大提高了构建速度。</p>
<p>在插件中new一个新的happypack进程出来，然后再使用使用loader的地方替换成对应的id</p>
</blockquote>
<ol><li>修改<code>webpack.base.conf.js</code>文件</li></ol>
<pre><code class=""javascript"">var HappyPack = require('happypack');
var os = require('os');
var happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });
...
...
// 增加plugins
 plugins: [
  new HappyPack({
    id: 'happy-babel-js',
    loaders: ['babel-loader?cacheDirectory=true'],
    threadPool: happyThreadPool,
  })
]
...
...
// 修改对应loader
{
  test: /\.js$/,
  loader: 'happypack/loader?id=happy-babel-js',
  include: [resolve('src'), resolve('test')],
}</code></pre>
<h3>webpack-parallel-uglify-plugin</h3>
<blockquote>
<p>文档地址 <a href=""https://github.com/gdborton/webpack-parallel-uglify-plugin"" rel=""nofollow noreferrer"">https://github.com/gdborton/w...</a></p>
<p><code>webpack</code>提供的<code>UglifyJS</code>插件由于采用单线程压缩，速度很慢 ,<br><code>webpack-parallel-uglify-plugin</code>插件可以并行运行<code>UglifyJS</code>插件，这可以有效减少构建时间。</p>
</blockquote>
<ol><li>修改<code>webpack.prod.conf.js</code>文件</li></ol>
<pre><code class=""javascript"">var ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');
...
...
// 删掉webpack提供的UglifyJS插件
// new webpack.optimize.UglifyJsPlugin({
//   compress: {
//     warnings: false,
//     drop_console: true
//   },
//   sourceMap: true
// }),
// 增加 webpack-parallel-uglify-plugin来替换
new ParallelUglifyPlugin({
  cacheDir: '.cache/',
  uglifyJS:{
    output: {
      comments: false
    },
    compress: {
      warnings: false
    }
  }
}),</code></pre>
<h3>webpack 3</h3>
<blockquote>
<p>webpack3新特性一览 <a href=""https://juejin.im/entry/5971483951882552681c4a30"" rel=""nofollow noreferrer"">https://juejin.im/entry/59714...</a></p>
<p>webpack 3.x 提供了一个新的功能：Scope Hoisting，又译作“作用域提升”。只需在配置文件中添加一个新的插件，就可以让 Webpack 打包出来的代码文件更小、运行的更快。</p>
</blockquote>
<ol><li>修改<code>webpack.prod.conf.js</code>
</li></ol>
<pre><code class=""javascript"">...
...
plugins: [
  // 往plugins添加一个配置
  // ps 只针对es6的模块化有效
  new webpack.optimize.ModuleConcatenationPlugin(),
]</code></pre>
<p>ps：配置文件详情请点击 <a href=""https://github.com/liaoyinglong/vue-template"" rel=""nofollow noreferrer"">https://github.com/liaoyinglo...</a></p>

                ", 基于vue-cli的webpack配置优化,1531977771,184,1,591,1,1,https://segmentfault.com/a/1190000011721918
77,1,0,7,"
                    
<h2>0x00 写在前面</h2>
<p>现在大部分的开发团队都以 Git 作为自己的版本控制工具，需要对 Git 的使用非常的熟悉。这篇文章中本人整理了自己在开发过程中经常使用到的 Git 命令，方便在偶尔忘记时速查。使用 GUI 工具的同学，也可以对照起来看看。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673668?w=948&amp;h=1010"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""常用 Git 命令使用教程"" title=""常用 Git 命令使用教程""></span></p>
<h2>0x01 Git 配置</h2>
<p>1. 在安装完成 Git 后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱。</p>
<p>设置的主要命令是 <code>git config</code>:</p>
<pre><code>git config --global user.name ""your name""      // 设置全局用户名
git config --global user.email ""your email""    // 设置邮箱</code></pre>
<p>其中， <code>--global</code> 指定为全局配置，不使用该参数，则为当前所在仓库配置。</p>
<p>2. 除了用户名、邮箱之外，还有很多的配置可以用来自定义 Git，如：</p>
<pre><code>git config --global color.ui true        // 让 Git 显示不同的颜色
git config core.ignorecase true            // 让 Git 对仓库中的文件大小写敏感</code></pre>
<p>3. 查看所有的已经做出的配置：</p>
<pre><code>git config -l</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673669?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git config"" title=""git config""></span></p>
<h2>0x02 基础操作</h2>
<h3>1. 创建 Git 版本库</h3>
<p>在本地创建 Git 版本库，需要使用 <code>git init</code> 命令。</p>
<p>首先，你需要新建一个存放版本库的目录，然后进入到该目录所在路径，然后执行：</p>
<pre><code>git init</code></pre>
<p>然后查看目录结构中，就可以看到包含有 <code>.git</code> 子目录，这就说明创建版本库成功了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673670?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git init"" title=""git init""></span></p>
<h3>2. 将文件添加到版本库</h3>
<p>要将一个文件纳入到版本库管理，首先要将其添加到暂存区(这里不做深入介绍)，然后才能提交到仓库中。</p>
<p>2.1 将文件添加到暂存区，使用的是 <code>git add</code>：</p>
<pre><code>git add Readme.md        // 添加单个文件到暂存区
git add .                // 将当前目录下所有修改添加到暂存区，除按照规则忽略的之外</code></pre>
<blockquote><p>注意：这边空文件夹是不会被添加到暂存区中的。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673671?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git add"" title=""git add""></span></p>
<p>2.2 将暂存区中的文件，提交到仓库中。需要使用 <code>git commit</code>：</p>
<pre><code>git commit        // 如果暂存区有文件，则将其中的文件提交到仓库
git commit -m 'your comments'         // 带评论提交，用于说明提交内容、变更、作用等</code></pre>
<blockquote><p>注意：这边直接用 <code>git commit</code> 提交，会先弹出添加评论的页面。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673672"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git commit"" title=""git commit""></span></p>
<h3>3. 查看仓库的状态</h3>
<p>不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：</p>
<pre><code>git status</code></pre>
<p>来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，我使用最多的一个命令。</p>
<h3>4. 查看仓库中的具体修改</h3>
<p>很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code> 来查看具体的修改内容。</p>
<pre><code>git diff    // 查看版本库中所有的改动
git diff Readme.md        // 查看具体文件的改动</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673673?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git diff"" title=""git diff""></span></p>
<h3>5. 查看提交历史记录</h3>
<p>有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：</p>
<pre><code>git log     // 显示所有提交的历史记录
git log --pretty=oneline    // 单行显示提交历史记录的内容</code></pre>
<p>在 <code>git log</code> 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673674?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git log"" title=""git log""></span></p>
<h3>6. 版本回退</h3>
<p>有了 <code>git log</code> 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。</p>
<pre><code>git reset --hard HEAD^        // 回退到上一个提交版本
git reset --hard HEAD^^        // 回退到上上一个提交版本
git reset --hard 'commit_id'    // 会退到 commit_id 指定的提交版本</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673675?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git reset --hard"" title=""git reset --hard""></span></p>
<h3>7. 回到未来的某个提交</h3>
<p>当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。</p>
<p>因此，想要回到未来的某个提交，先通过 <code>git reflog</code> 从历史命令中找到想要回到的提交版本的 ID，然后通过 <code>git reset --hard</code> 来切换。</p>
<pre><code>git reflog
git reset --hard 'commit_id'</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673676?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git reflog"" title=""git reflog""></span></p>
<h3>8. 撤销修改</h3>
<p>撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。</p>
<p>8.1 丢弃工作区中文件的修改</p>
<pre><code>git checkout -- Readme.md    // 如果 Readme.md 文件在工作区，则丢弃其修改
git checkout -- .            // 丢弃当前目录下所有工作区中文件的修改</code></pre>
<blockquote><p>注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673677?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git checkout --"" title=""git checkout --""></span></p>
<p>8.2 丢弃已经进入暂存区的修改</p>
<pre><code>git reset HEAD Readme.md     // 将 Readme.md 恢复到 HEAD 提交版本的状态</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673678?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git reset HEAD"" title=""git reset HEAD""></span></p>
<h3>9. 删除文件</h3>
<p>在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：</p>
<pre><code>git rm Readme.md     // 删除已经被提交过的 Readme.md</code></pre>
<blockquote><p>注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673679?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git rm"" title=""git rm""></span></p>
<p><strong><code>git rm</code> 与 先 rm 然后 <code>git add</code> 的区别</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011673680?w=647&amp;h=459"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rm and git add"" title=""rm and git add""></span></p>
<p>更详细的可以参考：<a href=""http://yang3wei.github.io/blog/2013/02/03/git-rm-he-rm-de-qu-bie/"" rel=""nofollow noreferrer"">""git rm"" 和 ""rm"" 的区别</a></p>
<blockquote><p>注意：上图中的结果是在 git 1.9.1 版本上的操作。在 git 2.0 以上两者没有区别了。</p></blockquote>
<h2>0x03 分支管理</h2>
<p>分支是版本控制系统中很重要的一个概念，在 Git 中新建、合并等分支的操作非常轻量便捷，因此我们会很经常的用到。</p>
<h3>1. 查看分支</h3>
<p>查看分支使用 <code>git branch</code>：</p>
<pre><code>git branch        // 查看本地分支信息
git branch -v     // 查看相对详细的本地分支信息
git branch -av     // 查看包括远程仓库在内的分支信息</code></pre>
<blockquote><p>注意：在 <code>git branch</code> 的输出内容中，有一个分支，前面带有 <code>*</code> 号，这标识我们当前所在的分支。</p></blockquote>
<h3>2. 创建分支</h3>
<p>当我们要修复一个 Bug，或者开发一个新特性，甚至是在初学的时候怕打乱原来的代码，都可以新建一个分支来避免对原来代码的影响。</p>
<pre><code>git branch dev    // 新建一个名称为 dev 的分支</code></pre>
<h3>3. 切换分支</h3>
<p>当我们创建完分支以后，我们需要切换到新建的分支，否则，所有的修改，还是在原来的分支上。事实上，所有的改动，只能影响到当前所在的分支。</p>
<pre><code>git checkout dev    // 新建完 dev 分支以后，通过该命令切换到 dev 分支</code></pre>
<h3>4. 创建并切换分支</h3>
<pre><code>git checkout -b dev        // 新建 dev 分支，并切换到该分支上</code></pre>
<p>这个命令合并了前两个独立的命令，平常使用中一般这样使用。</p>
<h3>5. 合并分支</h3>
<p>当我们修复完成一个 Bug，或者开发完成一个新特性，我们就会把相关的 Bug 或者 特性的上修改合并回原来的主分支上，这时候就需要 <code>git merge</code> 来做分支的合并。</p>
<p>首先需要切换回最终要合并到的分支，如 <code>master</code>：</p>
<pre><code>git checkout master        // 切换回 master 分支
git merge dev            // 将 dev 分钟中的修改合并回 master 分支</code></pre>
<p>合并回主分支的时候，后面可能会面临到冲突的问题。冲突的解决暂不在这里说明。</p>
<h3>6. 删除分支</h3>
<p>当之前创建的分支，完成了它的使命，如 Bug 修复完，分支合并以后，这个分支就不在需要了，就可以删除它。</p>
<pre><code>git branch -d dev        // 删除 dev 分支</code></pre>
<h2>0x04 远程仓库</h2>
<p>上面的所有命令都是针对本地仓库的操作。当我们希望多个人来协作时，会将代码发布到一个统一的远程仓库，然后多个人在本地操作以后，在推送到远程仓库。其他人协作时，需要先同步远程仓库的内容，再推送自己的修改。</p>
<h3>1. 从远程仓库克隆</h3>
<p>如果你本地没有仓库，希望从已有的远程仓库上复制一份代码，那么你需要 <code>git clone</code>。</p>
<pre><code>git clone https://github.com/git/git.git     // 通过 https 协议，克隆 Github 上 git 仓库的源码
git clone linfuyan@github.com/git/git.git    // 通过 ssh 协议，克隆 Github 上 git 仓库的源码</code></pre>
<blockquote><p>注意： <code>git clone</code> 后面的仓库地址，可以支持多种协议，如 https， ssh 等。</p></blockquote>
<h3>2. 添加远程仓库</h3>
<p>如果你已经有了一个本地仓库，如之前创建的 <code>git-guide</code>，然后你打算将它发布到远程，供其他人协作。那么使用：</p>
<pre><code>git remote add origin your_remote_git_repo        // 为本地仓库添加远程仓库</code></pre>
<h3>3. 推送本地的内容到远程仓库</h3>
<p>当本地仓库中，代码完成提交，就需要将代码等推送到远程仓库，这样其他协作人员可以从远程仓库同步内容。</p>
<pre><code>git push -u origin master // 第一次推送时使用，可以简化后面的推送或者拉取命令使用
git push origin master    // 将本地 master 分支推送到 origin 远程分支</code></pre>
<blockquote><p>注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code> 参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。</p></blockquote>
<h3>4. 从远程仓库获取最新内容</h3>
<p>在多人协作过程中，当自己完成了本地仓库中的提交，想要向远程仓库推送前，需要先获取到远程仓库的最新内容。</p>
<p>可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。</p>
<pre><code>git fetch origin master    
git pull origin master</code></pre>
<p><code>git fetch</code> 和 <code>git pull</code> 之间的区别：</p>
<ul>
<li>
<code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li>
<code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
</ul>
<blockquote><p>注意：建议多使用 <code>git fetch</code>。</p></blockquote>
<h3>5. 查看远程仓库信息</h3>
<pre><code>git remote [-v]        // 显示远程仓库信息</code></pre>
<h3>6. 建立本地分支和远程分支的关联</h3>
<p>在本地仓库中的分支和远程仓库中的分支是对应的。一般情况下，远程仓库中的分支名称和本地仓库中的分支名称是一致的。</p>
<p>有的时候，我们会需要指定本地分支与远程分支的关联。</p>
<pre><code>git branch --set-upstream 'local_branch' origin/remote_branch</code></pre>
<h3>7. 修改本地仓库对应的远程仓库地址</h3>
<p>当远程的仓库地址发生变化时，需要修改本地仓库对应的远程仓库的地址。主要应用在<a href=""http://blog.csdn.net/hongshan50/article/details/23663043"" rel=""nofollow noreferrer"">工程迁移</a>过程中。</p>
<pre><code>git remote set-url origin url</code></pre>
<h2>0x05 标签管理</h2>
<p>在项目开发过程中，当一个版本发布完成时，是需要对代码打上标签，便于后续检索。获取处于其他的原因，需要对某个提交打上特定的标签。</p>
<h3>1. 创建标签</h3>
<pre><code>git tag -a 'tagname' -m 'comment' 'commit_id'</code></pre>
<p><code>-a</code> 参数指定标签名， <code>-m</code> 添加备注信息， 'commit_id' 指定打标签的提交。</p>
<h3>2. 查看所有标签</h3>
<pre><code>git tag        // 查看本地仓库中的所有标签</code></pre>
<h3>3. 查看具体标签信息</h3>
<pre><code>git show tagname</code></pre>
<h3>4. 删除本地标签</h3>
<p>如果打的标签出错，或者不在需要某个标签，则可以删除它。</p>
<pre><code>git tag -d tagname</code></pre>
<h3>5. 删除远程标签</h3>
<pre><code>git push origin :refs/tags/tagname

git push origin --delete tagname

git push origin :tagname</code></pre>
<h3>6. 推送标签到远程仓库</h3>
<p>打完标签以后，有需要推送到远程仓库。</p>
<p>6.1 推送单个标签到远程仓库</p>
<pre><code>git push origin tagname</code></pre>
<p>6.2 一次性推送所有标签到远程仓库。</p>
<pre><code>git push origin --tags</code></pre>
<h2>0x06 进阶操作</h2>
<h3>1. 临时保存修改</h3>
<p>在执行很多的 Git 操作的时候，是需要保持当前操作的仓库/分支处于 clean 状态，及没有未提交的修改。如 <code>git pull</code>， <code>git merge</code> 等等，如果有未提交的修改，这些将无法操作。</p>
<p>但是做这些事情的时候，你可能修改了比较多的代码，却又不想丢弃它。那么，你需要把这些修改临时保存起来，这就需要用到 <code>git stash</code>。</p>
<p>1.1 <strong>临时保存修改</strong>，这样仓库就可以回到 clean 状态。</p>
<pre><code>git  stash        // 保存本地仓库中的临时修改。</code></pre>
<blockquote><p>注意：可以多次的 <code>git stash</code> 来保存不同的临时修改。</p></blockquote>
<p>1.2 <strong>查看临时保存</strong>。当你临时保存以后，后面还是要取回来的，那它们在哪里呢？</p>
<pre><code>git stash list    // 显示所有临时修改</code></pre>
<p>1.3 当我们处理完其他操作时，想要恢复临时保存的修改。</p>
<pre><code>git stash apply        // 恢复所有保存的临时修改
git stash pop        // 恢复最近一次保存的临时修改</code></pre>
<p>1.4 或者，我们后面觉得临时保存不想要了，那可以丢弃它。</p>
<pre><code>git stash clear        // 丢弃所有保存的临时修改</code></pre>
<h2>0x07 写在最后</h2>
<p>这些是我目前在项目中经常会用到的操作，这里整理下来，可以作为一个手册。对于 Git 的理解或者更多的解释，并不在这里体现。大家可以参考其他更多的资料。</p>
<p>文中的思维导图由于从源文件导出成图片之后会变得模糊，关注微信公众号 ID: up2048，回复“脑图”可以免费获取思维导图源文件。</p>
<h2>0x08 推荐阅读</h2>
<ul>
<li><a href=""http://mp.weixin.qq.com/s?__biz=MzAxMTE5MzYzOA==&amp;mid=2649861441&amp;idx=1&amp;sn=baf686fe84d5597bb97d128d22ad757a&amp;chksm=8341d108b436581e2e095aba0c1850b34562105e594bc4b3504b04434840325b20e8e76eaad6#rd"" rel=""nofollow noreferrer"">你开发的小程序慢到令人发指可能仅仅因为它</a></li>
<li><a href=""http://mp.weixin.qq.com/s?__biz=MzAxMTE5MzYzOA==&amp;mid=2649861300&amp;idx=1&amp;sn=9842d6549eb37ea260f2f1defbd6413a&amp;chksm=8341d0fdb43659eb50a853e09fcc0990b520444613d5969282693729e27aabcfd74a58c1905b#rd"" rel=""nofollow noreferrer"">我心目中的网络接口设计到底是怎样的过程？</a></li>
<li><a href=""http://mp.weixin.qq.com/s?__biz=MzAxMTE5MzYzOA==&amp;mid=2649861258&amp;idx=1&amp;sn=800f31ca01050dca9126b7d26889a81f&amp;chksm=8341d0c3b43659d53c1c6bd999784593742b33ec0e9768ac41103d1884b1f8217165b1072cf5#rd"" rel=""nofollow noreferrer"">多平台统一用户系统设计</a></li>
</ul>

                ", 常用Git命令使用教程,1531977773,330,1,959,1,1,https://segmentfault.com/a/1190000011673663
78,1,0,7,"
                    
<blockquote>
<p>Git-版本控制工具，适用于不同版本<code>上线代码</code>的存储；团队间代码提交、文件分享、临时存放等需要频繁修改的操作，建议采用局域网文件共享实现。本手册的主要内容有:</p>
<ul>
<li>服务器搭建 - 基于centos7系统</li>
<li>Git客户端使用</li>
</ul>
</blockquote>
<h2>Git服务器搭建</h2>
<blockquote><p>Git源码：<a href=""https://www.kernel.org/pub/software/scm/git/"" rel=""nofollow noreferrer"">https://www.kernel.org/pub/so...</a></p></blockquote>
<h3>Git安装（源码）</h3>
<pre><code class=""nginx"">yum remove git    #卸载旧版本
yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel    #环境准备

wget https://www.kernel.org/pub/software/scm/git/git-2.14.2.tar.gz
tar zxvf git-2.14.2.tar.gz
cd ./git-2.14.2
./configure --prefix=/usr/local/git    #设置安装目录
make &amp;&amp; make install
cp /usr/local/git/bin/git /bin

git --version    #查看版本</code></pre>
<h3>创建一个git用户</h3>
<p>用于执行Git服务</p>
<pre><code class=""nginx"">adduser git

#创建自动登录文件
mkdir /home/git/.ssh/
touch /home/git/.ssh/authorized_keys</code></pre>
<p>客户端生成自动登录公钥（生成公钥命令：ssh-keygen -t rsa），将其保存到/home/git/.ssh/authorized_keys文件中，一行一个；</p>
<h3>初始化Git仓库</h3>
<p>假定/git/test/作为Git仓库；</p>
<pre><code class=""nginx"">mkdir -p /git/test/    #创建文件夹

cd /git
chown git:git test/    #权限设置

cd ./test/
git init --bare .git/    #创建裸库

chown -R git:git .git</code></pre>
<h3>克隆仓库</h3>
<pre><code class=""nginx"">git clone git@***:/git/test/.git    #替换成服务器IP</code></pre>
<h2>Git客户端使用</h2>
<h3>基础使用</h3>
<pre><code>cd /git/test    #进入git文件夹

git add ""test.php""    #提交文件

git add -A   #提交文件所有改动

git status -s    #查看项目当前状态（A ：提交成功；AM： 文件在我们将它添加到缓存之后又有改动。）

git commit -m ""1.0.0""    #提交版本

git push git@***:/git/test/.git    #上传至服务器</code></pre>
<h3>进阶使用</h3>
<p>分支管理</p>
<pre><code>git branch    #分支列表

git branch ""branchname""    #创建分支

git checkout ""branchname""    #切换分支

git branch -d ""branchname""    #删除分支

git merge ""branchname""    #合并分支</code></pre>
<p>查看提交历史</p>
<pre><code class=""nginx"">git log --oneline --decorate</code></pre>
<p>标签</p>
<pre><code class=""nginx"">git tag    #标签列表

git tag -a v1.0    #添加列表</code></pre>

                ", Git - 版本控制工具十分钟入门手册,1531977774,447,1,611,1,1,https://segmentfault.com/a/1190000011664563
79,1,0,7,"
                    
<p>作者：Darkbug<br>原文标题：Google新技术：Instant App全拆解（4）——架构（完结）<br>原文链接：<a href=""https://segmentfault.com/a/1190000011648067"" rel=""nofollow noreferrer"">https://segmentfault.com/a/11...</a><br>首发地址：<a href=""http://www.doncc.org"" rel=""nofollow noreferrer"">http://www.doncc.org</a><br>转发请注明转载地址，请尊重原创作者权益！</p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：</p>
<p>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>
<p>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>
<p>第三篇：<a href=""https://segmentfault.com/a/1190000011315286"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（3）——着手</a></p>
<hr>
<p>本文着重介绍在进行Instant App程序开发时需要理解的程序架构，同学们需要首先理解架构里的几个基本概念，然后再需要理解如何进行基本的功能模块架构，甚至更为复杂的程序功能模块架构。只有当理解这些后，才能很顺利的进行程序重构，或者进行Instant App程序开发。</p>
<p>有描述不正确的地方，请及时联系我，我将吸取意见并改正。</p>
<h1>1.Instant App程序的结构及概念</h1>
<p>在之前的课程我们有介绍，要想进行Instant App的程序开发，必须基于Android Studio 3.0集成开发环境。故后面介绍的所有关于代码的书写，以及在集成开发环境内进行程序架构，本人均在Android Studio 3.0 preview版进行（因为写这文章的时候，最新版也就是preview版）。 -_-||</p>
<p>在Instant App内，有几个非常重要的概念。比如feature、feature modules、feature APK。在做之前，必须先搞懂这几个概念，才能做好你的Instant App程序开发。</p>
<p>瞬时加载程序应该起到的作用是，当你在需要一个功能需求时，从Google Play上可以下载这个程序的部分功能，从而体验到App级的用户体验，用户使用完这个应用的功能模块后，系统会丢掉这个功能模块的代码。不难发现，这个功能，肯定和完整App有着某种密切的联系。那么是什么联系呢？</p>
<p>好的，我们开始根据官方的图来进行程序架构分析。想要分析程序的结构，应从大到小、从外向内进行分析。我们会从下面两个方向进行分析，也就是从外到内。</p>
<ul>
<li>从程序功能划分程序结构</li>
<li>从功能结构划分工程架构</li>
</ul>
<h2>1.1 从程序功能划分程序结构</h2>
<p>如果你的应用程序是带有即时应用的话，那么你在构建你的项目之时，会带有一个或多个即时应用程序APK。这是根据你的程序划分程序功能情况而定，每个功能，可以生成对应功能的即时应用程序APK。</p>
<p>好，明白了这个功能APK后，我们再来看看它是怎么架构的。</p>
<p>我们先来从官方的一张图说起：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011648070?w=470&amp;h=334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""FeaturesDiagram"" title=""FeaturesDiagram""></span></p>
<p>从图中我们可知，一个Instant App APK程序内，只有一个Base feature APK，而可以有多个feature APK来构成。换句话说，每个即时应用程序，都会有且只有一个基础功能APK。</p>
<p>换个角度想，如果你的即时应用程序只有一个功能，那么你只需有一个基础功能APK就够了；如果你的即时应用程序有多个功能，那么你需要一个基础功能APK，它包含其他功能所需要用到的共有数据即可，比如不同功能间，界面内会有一些公用的控件、基本信息等，那么这些共有数据就可以放在基础功能APK内，而其他功能APK，具备不同功能即可。</p>
<p>还有另外一种情况。用户已经体验了一个功能了，系统已为用户下载了基础功能APK以及功能APK，如果需要在这个功能内请求数据到另外一个功能内的情况下，系统只会为你下载另一项功能的代码，因为这是基础功能的代码已经存在本地了，无需再次下载了。</p>
<p>怎么样，Google大大的这个设计，是不是感觉简直逆天到爆？总结一句话就是，需要的就下载；不需要的，不下载。这为我们在一定程度上节省了很多宝贵的流量，也减少应用程序所占用的系统空间。（土豪请随意）?</p>
<h2>1.2 从功能结构划分工程架构</h2>
<p>从上面的小结我们可以知道，你的程序其实是按照功能的不同进行区分的，所有功能应有一个基础功能，在基础功能之上，将整个程序划分出不同的功能。那么不同的功能之间，该如何进行代码模块的划分架构呢？</p>
<p>我们再来看下官方发布的另外一张结构图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011648071?w=470&amp;h=249"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""FeaturesSingle"" title=""FeaturesSingle""></span></p>
<p>从上图我们很清楚的知道，一个Instant App 程序内，只会包含一个基本的功能，而自定义的模块，会依赖于基本的功能块。这是一个很典型的瞬时加载程序的一个单一功能模块的程序架构。而<code>Instant app module</code>是瞬时加载程序的入口点，<code>App module</code>是功能程序的完整代码部分。</p>
<p>好的，我们了解了模块该如何划分后，就可以具体来看下，划分模块时需要配置的详细代码了。（不要跟我说看代码头疼，我们都是程序员?‍?‍）</p>
<h1>2.构建单个功能模块的Instant App</h1>
<p>想要构建单个功能模块，我们假如按照最简单的结构，可以分为如下：</p>
<ul>
<li>Base features module</li>
<li>Android Instant Apps module</li>
<li>App module (APK)</li>
</ul>
<p>这三个方面足以说明一个简单的Instant App结构了。下面我们来逐个详细的了解。</p>
<h2>2.1 按模块划分</h2>
<h3>2.1.1 Base features module</h3>
<p>Base Features module的说明，我们可以从两方面谈起。</p>
<ul><li>manifest文件的修改</li></ul>
<p>在AndroidManifest.xml文件中，你需要修改<code>application</code>标签的内容。像如下内容：</p>
<pre><code class=""xml"">&lt;application&gt;
        &lt;activity android:name="".MainActivity""&gt;
            &lt;intent-filter android:order=""1""&gt;
                &lt;action android:name=""android.intent.action.VIEW"" /&gt;
                &lt;category android:name=""android.intent.category.BROWSABLE"" /&gt;
                &lt;category android:name=""android.intent.category.DEFAULT"" /&gt;
                &lt;data android:host=""myfirstinstantapp.doncc.org""
                    android:path=""/""
                    android:scheme=""https"" /&gt;
            &lt;/intent-filter&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=""android.intent.action.MAIN"" /&gt;
                &lt;category android:name=""android.intent.category.LAUNCHER"" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
&lt;/application&gt;</code></pre>
<p>在这里，我们需要修改的东西会多一些。如果细心的同学会发现，其实修改的内容，和我们之前接触的App Links的配置是一致的。这就应了我们之前所述的，Instant App的实现是依赖于App Links的。固然在配置上也是一致的。</p>
<p>这到底是为什么呢？</p>
<p>别忘了，我们根据之前的架构可知，base features module是所有module的基础。也就是说，当系统加载程序时，首先加载的就是这个base features module，那么固然基础信息也就被系统读取到了。</p>
<p>所以你也就可以这么修改你的程序。当你需要一些基础信息，比如<code>&lt;activity&gt;</code>、<code>uses-permission</code>等基础信息，可以在base feature module的<code>manifest</code>文件中进行声明，作为基础需要的资源。</p>
<p>或许，你应该懂得，不是整个程序的基础信息，都必须加载进base feature module的<code>manifest</code>中，应是需要的就加载，不需要的就不加载。</p>
<ul><li>build.gradle的修改<p>这里指的gradle文件，是base feature的gradle配置文件。你可以在里面找到<code>android</code>的相关配置。在内部，添加<code>baseFeature true</code>这样的配置即可。比如下面的代码所示：</p>
</li></ul>
<pre><code class=""groovy"">apply plugin: 'com.android.feature'
    android {
          ...
        //add this line
        baseFeature true
          ...
        defaultConfig{
            //delete applicationId     
            ...
        }
    }</code></pre>
<p>这样系统在读取gradle配置信息时，会知道这个模块是属于base feature，就会继续找它相应的子模块。你看Google大大已经封装得多么简洁了，真心爽啊。</p>
<h3>2.1.2 Android Instant Apps module</h3>
<p>在这Instant App模块内，情况有些特殊。这个模块内不包含任何的代码，只包含有构建信息的配置。比如下面的<code>build.gradle</code>文件配置：</p>
<pre><code class=""groovy"">apply plugin: 'com.android.instantapp'
...
dependencies {
    implementation project(':base')
}</code></pre>
<p>在这里，我们需要把<code>apply plugin</code>这个配置改为<code>'com.android.instantapp'</code>，这是告知构建器本模块是Instant App模块。并且在<code>dependencies</code>模块内，需要指定Instant App模块是实现自谁，也就是从结构上它是谁的子结构。关于结构是怎么分，还需读懂上面的【图FeaturesSingle.png】为妙。</p>
<p>在这个模块内，你可以删除掉这个模块代码的<code>src</code>包，因为这个模块内，没有代码，所以即使添加<code>src</code>包也是没用的。故可以将其删除。</p>
<h3>2.1.3 App module (APK)</h3>
<p>在这个模块里，如果你需要构建你的Instant App的话，那么这个模块需要包含要所有功能的模块内容和产品的APK。在这个模块内也是比较特殊的 ， <code>manifest</code>文件内不包含除<code>&lt;manifest&gt;</code>以外的其他配置标签，因为有关于<code>application</code>、<code>activity</code>、<code>uses-permission</code>等配置信息，已经在base feature module中配置了，所以不用再进行配置。</p>
<p>这里我们也有个配置样例，可参考如下：</p>
<pre><code class=""xml"">&lt;manifest
    xmlns:android=""http://schemas.android.com/apk/res/android""
    package=""org.doncc.instantapp""&gt;
  &lt;!--remove application--&gt;
&lt;/manifest&gt;</code></pre>
<p>在上述代码中，<code>manifest</code>内的<code>package</code>值，要和你的base feature module所配置的包名保持一致。并且你需要移除掉生成的<code>&lt;application&gt;</code>标签。</p>
<p>而在build.gradle文件内，我们也需要进行一些修改：</p>
<pre><code class=""groovy"">apply plugin: 'com.android.application'
...
dependencies {
    implementation project(':base')
}</code></pre>
<p>不难发现，如果我们需要构建一个完整的Instant App，我们需要在这个模块内添加结构是实现自谁。根据上面的【图FeaturesSingle.png】可知，我们这个模块是实现自base模块，所以我们需要在build.gradle内填写实现自base模块的语句配置。</p>
<h2>2.2 总结</h2>
<p>在本章内，我们知道了如何将一个已有的项目，变为Instant App程序架构。其最主要的思想，我们可以总结如下：</p>
<ul>
<li>抽象父feature module：<p>是将程序架构成拥有一个最顶级的feature module，这个feature module内集合你的Instant App或者其他子module在运行时需要的一些必要资源内容，包括Activity、Fragment等资源。这样能相对减少你的子module的资源大小，从而减少你宝贵的流量消耗。</p>
</li>
<li>APK module及Instant App module，共同构成base feature module：<p>同第一条总结的，当你抽象出base级的feature后，他们构成总体的结构，包括apk module及instantapp module。当然这不仅限于这两个！</p>
</li>
<li>Instant App应使用App Links作为功能的接入口：<p>因为App Links具有独特的验证方式，能与Google服务进行互通，且瞬时加载程序是依托于Chrome浏览器来进行交互的。所以需要使用App Links作为功能的接入口。如何验证App Links的重要性也就不言而喻了。如果需要回顾这块儿的课程，请翻阅之前我写过的文章，在那里我有详细介绍有关于App Links的使用。</p>
</li>
</ul>
<h1>3.多个feature构建你的Instant App</h1>
<p>如果想了解多个feature是如何工作的，那么你首先、务必、一定要理解上个章节的内容，也就是单个功能模块是如何工作的，只有这样你才能很快的理解本章节内容。</p>
<h2>3.1 按模块划分</h2>
<p>多个feature工作起来其实并不复杂，原理跟单个feature其实是一样的。这里我依照贴心的放上google的官方图片来解释：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011648072?w=470&amp;h=453"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""FeaturesMulti"" title=""FeaturesMulti""></span></p>
<p>有人会说，为什么你只会引官方的图，而不自己做图呢。我想说，官方的图已经很简明扼要的阐述了内容，我们为什么还要重复造轮子呢？</p>
<p>好了废话不多说，来看图说话。看上去连线之间交叉复杂，但是这里面包含很清晰的逻辑关系。别急，跟着我的思路，一点一点理解上面的图。</p>
<p>第一，我们抛开浅绿色以上的图先不看，我们只看浅蓝色以下的部分。一个完整的Instant App，依旧有一个Base Feature，那么它可以引伸出两个子feature，分别是Feature 1、Feature 2。这是什么意思呢？这和我们之前讲过的内容正好相匹配上，一个父级的Feature，可能包含很多子级的Feature，而这些诸多的子Feature共同构成了一个完整的App功能。这也就是Instant App架构的精髓，把一个大的功能完全拆分成不同小部分的小功能，从而减少每个功能块的代码量的大小。</p>
<p>第二，我们再来看浅绿色的区域。我们会发现，Instant App module分别指向了Feature 1和Feature 2，并且App module也分别指向了Feature 1和Feature 2。这里有什么?腻么？</p>
<p>还记得App Links的特点么，在你要链接到的Activity，会在manifest文件处进行App Links的配置，链接到你想要访问的Activity。而Instant App恰恰就是运用App Links的机制。也就是说，从Instant App程序入口的操作，会在内部识别你请求的到底是哪个Activity，也就是哪个功能Feature。这样你才会看到，浅绿色的Instant App module分别指向了Feature 1和Feature 2。</p>
<p><strong>第三，我们要格外注意的是，浅绿色的Instant app module和app module需要同时实现自深蓝色的Base Feature，这需要在gradle配置文件内进行额外配置。图中并没有进行描述。这一点需要格外注意。</strong></p>
<h2>3.2 总结</h2>
<p>好了，这次我们就很容易的理解多个Feature是如何构架你的程序的。思路也不是很复杂，我们总结如下：</p>
<ul>
<li>将你的程序的大功能模块，分为若干个不同的小feature module。<strong>注意，我们之前提到过的不要忘记，每个feature module，尽量不要超过4MB大小。</strong>当然这仅仅是建议，尽量去满足他。</li>
<li>Instant App module、app module，要实现自每个feature，这样才能让App Links找到不同功能的Feature module。</li>
<li>你的instant app module和app module（假设你有这两个模块作为实现feature的子模块），那么你需要分别实现自base feature module。这样你的子feature才能生效。</li>
</ul>
<p>本文着重对Instant App程序架构的阐述，从基本的架构概念，到单个功能模块的架构，再到复杂的多功能模块架构，很详细的说明了其结构上的关联性，能让你更轻松的理解Instant App程序开发。</p>
<p>不难看出，其实如果搞懂了Instant App程序架构，那么你在进行程序开发时就会变得易如反掌了。相信看完这篇文章后，后续的课程对于聪明的你来讲，简直可以轻松驾驭。</p>
<p>至此，关于Instant App程序开发，我们已经摸清了头绪。我们可以很轻松的驾驭它，并且应用到自己的项目中了。</p>
<p>Enjoy it!!</p>

<p>广告位：更多、更有料的IT前沿技术课程，尽在顶级云加。详情请持续关注顶级云加的唯一官方网站：<a href=""https://yunp.top"" rel=""nofollow noreferrer"">https://yunp.top</a></p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：</p>
<p>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>
<p>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>
<p>第三篇：<a href=""https://segmentfault.com/a/1190000011315286"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（3）——着手</a></p>

                ", Google新技术：Instant App全拆解（4）——架构（完结）,1531977775,425,1,807,1,1,https://segmentfault.com/a/1190000011648067
80,1,0,7,"
                    
<h2>配置好的别名，会对工作有很大帮助，提升很大的效率</h2>
<h3>比如平时想查看本地改了什么</h3>
<pre><code>gd 就ok了
</code></pre>
<h3>看看本次更改了哪些文件</h3>
<pre><code>gst
</code></pre>
<h3>提交全部文件</h3>
<pre><code>ga .
</code></pre>
<h3>提交本次</h3>
<pre><code>gc -am""init""
</code></pre>
<h3>推送到master</h3>
<p>gpm</p>
<h2>正确的配置姿势</h2>
<h3>切换到家目录</h3>
<pre><code>cd ~
</code></pre>
<h3>然后在找到.bash_profile</h3>
<p>在这个里面写<br>另起一行就可以写了</p>
<p>alias gpm='git push origin master'</p>
<p>即刻生效 source .bash_profile</p>
<h2>推荐以下别名配置</h2>
<h3>因为使用习惯 zshell git 别名，下面采用 zshell的别名</h3>
<pre><code>alias gpm='git push origin master'
alias ...=../..
alias ....=../../..
alias .....=../../../..
alias ......=../../../../..
alias 1='cd -'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'
alias _=sudo
alias afind='ack -il'
alias d='dirs -v | head -10'
alias g=git
alias ga='git add'
alias gaa='git add --all'
alias gapa='git add --patch'
alias gau='git add --update'
alias gb='git branch'
alias gba='git branch -a'
alias gbd='git branch -d'
alias gbda='git branch --no-color --merged | command grep -vE ""^(\*|\s*(master|develop|dev)\s*$)"" | command xargs -n 1 git branch -d'
alias gbl='git blame -b -w'
alias gbnm='git branch --no-merged'
alias gbr='git branch --remote'
alias gbs='git bisect'
alias gbsb='git bisect bad'
alias gbsg='git bisect good'
alias gbsr='git bisect reset'
alias gbss='git bisect start'
alias gc='git commit -v'
alias 'gc!'='git commit -v --amend'
alias gca='git commit -v -a'
alias 'gca!'='git commit -v -a --amend'
alias gcam='git commit -a -m'
alias 'gcan!'='git commit -v -a --no-edit --amend'
alias 'gcans!'='git commit -v -a -s --no-edit --amend'
alias gcb='git checkout -b'
alias gcd='git checkout develop'
alias gcf='git config --list'
alias gcl='git clone --recursive'
alias gclean='git clean -fd'
alias gcm='git checkout master'
alias gcmsg='git commit -m'
alias 'gcn!'='git commit -v --no-edit --amend'
alias gco='git checkout'
alias gcount='git shortlog -sn'
alias gcp='git cherry-pick'
alias gcpa='git cherry-pick --abort'
alias gcpc='git cherry-pick --continue'
alias gcs='git commit -S'
alias gcsm='git commit -s -m'
alias gd='git diff'
alias gdca='git diff --cached'
alias gdct='git describe --tags `git rev-list --tags --max-count=1`'
alias gdt='git diff-tree --no-commit-id --name-only -r'
alias gdw='git diff --word-diff'
alias gf='git fetch'
alias gfa='git fetch --all --prune'
alias gfo='git fetch origin'
alias gg='git gui citool'
alias gga='git gui citool --amend'
alias ggpull='git pull origin $(git_current_branch)'
alias ggpur=ggu
alias ggpush='git push origin $(git_current_branch)'
alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'
alias ghh='git help'
alias gignore='git update-index --assume-unchanged'
alias gignored='git ls-files -v | grep ""^[[:lower:]]""'
alias git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github master:svntrunk'
alias gk='\gitk --all --branches'
alias gke='\gitk --all $(git log -g --pretty=%h)'
alias gl='git pull'
alias glg='git log --stat'
alias glgg='git log --graph'
alias glgga='git log --graph --decorate --all'
alias glgm='git log --graph --max-count=10'
alias glgp='git log --stat -p'
alias glo='git log --oneline --decorate'
alias globurl='noglob urlglobber '
alias glog='git log --oneline --decorate --graph'
alias gloga='git log --oneline --decorate --graph --all'
alias glol='git log --graph --pretty='\''%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\'' --abbrev-commit'
alias glola='git log --graph --pretty='\''%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\'' --abbrev-commit --all'
alias glp=_git_log_prettily
alias glum='git pull upstream master'
alias gm='git merge'
alias gmom='git merge origin/master'
alias gmt='git mergetool --no-prompt'
alias gmtvim='git mergetool --no-prompt --tool=vimdiff'
alias gmum='git merge upstream/master'
alias gp='git push'
alias gpd='git push --dry-run'
alias gpoat='git push origin --all &amp;&amp; git push origin --tags'
alias gpristine='git reset --hard &amp;&amp; git clean -dfx'
alias gpsup='git push --set-upstream origin $(git_current_branch)'
alias gpu='git push upstream'
alias gpv='git push -v'
alias gr='git remote'
alias gra='git remote add'
alias grb='git rebase'
alias grba='git rebase --abort'
alias grbc='git rebase --continue'
alias grbi='git rebase -i'
alias grbm='git rebase master'
alias grbs='git rebase --skip'
alias grep='grep  --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn}'
alias grh='git reset HEAD'
alias grhh='git reset HEAD --hard'
alias grmv='git remote rename'
alias grrm='git remote remove'
alias grset='git remote set-url'
alias grt='cd $(git rev-parse --show-toplevel || echo ""."")'
alias gru='git reset --'
alias grup='git remote update'
alias grv='git remote -v'
alias gsb='git status -sb'
alias gsd='git svn dcommit'
alias gsi='git submodule init'
alias gsps='git show --pretty=short --show-signature'
alias gsr='git svn rebase'
alias gss='git status -s'
alias gst='git status'
alias gsta='git stash save'
alias gstaa='git stash apply'
alias gstc='git stash clear'
alias gstd='git stash drop'
alias gstl='git stash list'
alias gstp='git stash pop'
alias gsts='git stash show --text'
alias gsu='git submodule update'
alias gts='git tag -s'
alias gtv='git tag | sort -V'
alias gunignore='git update-index --no-assume-unchanged'
alias gunwip='git log -n 1 | grep -q -c ""\-\-wip\-\-"" &amp;&amp; git reset HEAD~1'
alias gup='git pull --rebase'
alias gupv='git pull --rebase -v'
alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'
alias gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m ""--wip-- [skip ci]""'
alias history='fc -l 1'
alias l='ls -lah'
alias la='ls -lAh'
alias ll='ls -lh'
alias ls='ls --color=tty'
alias lsa='ls -lah'
alias md='mkdir -p'
alias please=sudo
alias po=popd
alias pu=pushd
alias rd=rmdir
alias which-command=whence
</code></pre>

                ", 【git效率篇】在window上面的git bash 配置永久别名 快捷方式,1531977777,180,1,595,1,1,https://segmentfault.com/a/1190000011532209
81,1,0,7,"
                    
<h2>前言</h2>
<p>之前<a href=""https://github.com/XNAL/node-MovieSpider"" rel=""nofollow noreferrer"">使用Node.js开发一个小爬虫</a>，算是初步对爬虫有了一定的了解，但爬取的数据没什么意义。最近使用Github的频率比较高，所以准备爬取一些Github的数据玩下。目前爬取了中国区followers排名前100的大神，以及各个编程语言stars大于1000的开源项目。</p>
<h2>源码</h2>
<p><a href=""https://github.com/XNAL/vue-github-rank"" rel=""nofollow noreferrer"">Talk is cheap. Show me the code.</a></p>
<h2>访问地址</h2>
<ul>
<li>
<a href=""http://www.qdnote.com/vue-github-rank/"" rel=""nofollow noreferrer"">访问地址：http://www.qdnote.com/vue-github-rank/</a>（pc端开启手机模式浏览效果更佳）</li>
<li>扫描二维码</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVWhQX?w=300&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>如何使用</h2>
<pre><code>git clone https://github.com/XNAL/vue-github-rank

// 需要先安装mysql，并创建数据库，可参考源码中的`github_rank.sql`

cd vue-github-rank
npm init

// 启动node服务
gulp nodemon 

// 本地运行需另开一个终端框口并执行以下命令，然后访问`http://localhost:8080/`
npm run dev
</code></pre>
<h2>技术栈</h2>
<ul>
<li>
<a href=""https://cn.vuejs.org/"" rel=""nofollow noreferrer"">vue.js</a>： 前端页面展示。</li>
<li>
<a href=""https://github.com/axios/axios"" rel=""nofollow noreferrer"">axios</a>: vue官方推荐HTTP库，请求后端数据。</li>
<li>
<a href=""http://www.iconfont.cn/"" rel=""nofollow noreferrer"">阿里巴巴的矢量图标库Iconfont</a>: 页面图标，个人项目中使用起来比较方便。</li>
<li>
<a href=""https://nodejs.org/en/"" rel=""nofollow noreferrer"">node.js</a> + <a href=""http://koajs.com/"" rel=""nofollow noreferrer"">Koa2</a>： 后台服务器搭架，（Koa2需要node v7.6以上）。</li>
<li>ES6/ES7： 后台开发以ES6语法为主，并使用了ES7中的<code>async/await</code>。</li>
<li>
<a href=""https://gulpjs.com/"" rel=""nofollow noreferrer"">gulp</a>： 后台服务器使用，自动化构建工具。</li>
<li>
<a href=""https://webpack.js.org/"" rel=""nofollow noreferrer"">webpack</a>： vue-cli自带的。需要配置本地代理<code>proxyTable</code>，以及配置<code>SCSS</code>的相关loader。</li>
<li>MySql: 数据保存。</li>
<li>
<a href=""http://visionmedia.github.io/superagent/"" rel=""nofollow noreferrer"">superagent</a>: 比node.js原生http模块更好用的客户端请求代理模块。</li>
<li>
<a href=""https://github.com/cheeriojs/cheerio"" rel=""nofollow noreferrer"">cheerio</a>：服务端jQuery，分析网页内容。</li>
<li>
<a href=""https://github.com/node-schedule/node-schedule"" rel=""nofollow noreferrer"">node-schedule</a>: node.js定时执行模块。</li>
</ul>
<h2>说明</h2>
<ol>
<li>关于爬虫爬取数据的说明：目前是每2个小时去Github官网爬取数据，取到的数据会存入数据库中。在爬取的过程中可能会出现单个页面一直无法取到数据的情况，为避免程序一直卡在此步骤，目前是单个页面数据循环请求50次，如果仍取不到数据则跳过此项数据的爬取，等待下一次再进行爬取。</li>
<li>数据库字符集需要设置为<code>utf8mb4</code>，因为需要存取emoji表情。</li>
</ol>
<h2>项目截图</h2>
<h3>关于（首页）</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVWhQ2?w=461&amp;h=818"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>中国区前100大神</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVWhQ4?w=459&amp;h=818"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>目录</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVWhRb?w=461&amp;h=814"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>项目</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVWhRf?w=461&amp;h=821"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Vue.js+Node.js爬虫开发一个Github排行榜,1531977778,561,1,750,1,1,https://segmentfault.com/a/1190000011469332
82,1,0,7,"
                    
<p><a href=""https://github.com/jaywcjlove/handbook/blob/master/other/Github-Oraganizations.md"" rel=""nofollow noreferrer"">Edit on GitHub</a></p>
<p><a href=""http://jsfiddle.net/jaywcjlove/ohhbff2a/embed/"" rel=""nofollow noreferrer"">http://jsfiddle.net/jaywcjlov...</a></p>
<ul>
<li>
<p><a href=""https://github.com/alibaba"" rel=""nofollow noreferrer"">Alibaba</a> 阿里巴巴 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468744?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>
<a href=""https://github.com/ant-design"" rel=""nofollow noreferrer"">Ant Design</a> Ant Design <span class=""img-wrap""><img data-src=""/img/remote/1460000011468955?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/antvis"" rel=""nofollow noreferrer"">Ant DataVis Team</a> 蚂蚁金服 - 体验技术部 - 数据图形组 <span class=""img-wrap""><img data-src=""/img/remote/1460000011469070?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/NG-ZORRO"" rel=""nofollow noreferrer"">NG-ZORRO</a> Angular Developers <span class=""img-wrap""><img data-src=""/img/remote/1460000011469071?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/aliceui"" rel=""nofollow noreferrer"">aliceui</a> 支付宝 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468745?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/kissyteam"" rel=""nofollow noreferrer"">issyteam</a> 淘宝 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468746?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/seajs"" rel=""nofollow noreferrer"">seajs</a> Web的模块加载程序 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468955?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/kissyteam"" rel=""nofollow noreferrer"">kissyteam</a> 强大的模块集合 <span class=""img-wrap""><img data-src=""/img/remote/1460000011480459?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/eggjs"" rel=""nofollow noreferrer"">egg</a> Node.js的Web框架框架 <span class=""img-wrap""><img data-src=""/img/remote/1460000011469072?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
</ul>
</li>
<li>
<a href=""https://github.com/Huawei-Hadoop"" rel=""nofollow noreferrer"">Huawei</a> 华为 <span class=""img-wrap""><img data-src=""/img/remote/1460000011469073?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<p><a href=""https://github.com/tencent"" rel=""nofollow noreferrer"">Tencent</a> 腾讯 Github <span class=""img-wrap""><img data-src=""/img/remote/1460000011470079?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>
<a href=""https://code.csdn.net/tencent"" rel=""nofollow noreferrer"">Tencent</a> 腾讯 csdn</li>
<li>
<a href=""https://github.com/AlloyTeam"" rel=""nofollow noreferrer"">腾讯 AlloyTeam </a> 腾讯 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468748?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
</ul>
</li>
<li>
<p><a href=""https://github.com/baidu"" rel=""nofollow noreferrer"">Baidu</a> 百度 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468893?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>
<a href=""https://github.com/fex-team"" rel=""nofollow noreferrer"">Baidu FEX team</a> 百度  <span class=""img-wrap""><img data-src=""/img/remote/1460000011468930?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/ecomfe"" rel=""nofollow noreferrer"">Baidu EFE team</a> 百度  <span class=""img-wrap""><img data-src=""/img/remote/1460000011468749?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/be-fe"" rel=""nofollow noreferrer"">Baidu BEFE</a> 百度企业产品前端研发团队  <span class=""img-wrap""><img data-src=""/img/remote/1460000011490381?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
</ul>
</li>
<li>
<p><a href=""https://github.com/eleme"" rel=""nofollow noreferrer"">eleme</a> 饿了么 <span class=""img-wrap""><img data-src=""/img/remote/1460000011470060?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul><li>
<a href=""https://github.com/elemefe"" rel=""nofollow noreferrer"">饿了么前端</a> 饿了么 <span class=""img-wrap""><img data-src=""/img/remote/1460000011470024?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li></ul>
</li>
<li>
<a href=""https://github.com/netease"" rel=""nofollow noreferrer"">NetEase</a> 网易 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468750?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/SOHUDBA"" rel=""nofollow noreferrer"">SOHUDBA</a> 搜狐 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468751?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/Qihoo360"" rel=""nofollow noreferrer"">Qihoo360</a> 奇虎360 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468752?w=14&amp;h=13"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/360EntSecGroup-Skylar"" rel=""nofollow noreferrer"">360EntSecGroup-Skylar</a> 360企业安全集团终端安全子公司 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468753?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/vipshop"" rel=""nofollow noreferrer"">唯品会</a> 唯品会 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468754?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/douban"" rel=""nofollow noreferrer"">Douban Inc.</a> 豆瓣 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468755?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/dianping"" rel=""nofollow noreferrer"">大众点评网 </a> 大众点评网 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468756?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/xiaomi"" rel=""nofollow noreferrer"">Xiaomi Open Source.</a> 小米</li>
<li>
<a href=""https://github.com/meituan"" rel=""nofollow noreferrer"">meituan.com</a> 美团 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468757?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/mogujie"" rel=""nofollow noreferrer"">蘑菇街</a> 蘑菇街 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468758?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/CodisLabs"" rel=""nofollow noreferrer"">CodisLabs</a> 豌豆荚 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468759?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/dangdangdotcom"" rel=""nofollow noreferrer"">当当</a> 当当 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468758?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/youzan"" rel=""nofollow noreferrer"">有赞</a> 有赞 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468760?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/TeamStuQ"" rel=""nofollow noreferrer"">TeamStuQ</a> TeamStuQ <span class=""img-wrap""><img data-src=""/img/remote/1460000011468761?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/xitu"" rel=""nofollow noreferrer"">稀土</a> 稀土 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468762?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
<li>
<a href=""https://github.com/jobbole"" rel=""nofollow noreferrer"">伯乐在线</a> 伯乐在线 <span class=""img-wrap""><img data-src=""/img/remote/1460000011468763?w=14&amp;h=14"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span>
</li>
</ul>

                ", 国内互联网公司的开源项目及Github地址汇总,1531977779,294,1,266,1,1,https://segmentfault.com/a/1190000011468741
83,1,0,7,"
                    
<h3>一、git的安装</h3>
<p><code>git</code>是一款源代码管理工具，接下来我们先介绍<code>git</code>在<code>windows</code>系统下的安装流程。我们先在<code>github</code>上搜索<code>git-for-win</code>，其网页链接为 <a href=""https://github.com/waylau/git-for-win"" rel=""nofollow noreferrer"">https://github.com/waylau/git...</a>。由于在国内直接从官网下载<code>Git for Windows</code>比较困难，需要翻墙，这里提供一个国内的下载站，方便网友下载。我们可以选择最新版本当中的<code>64-bit Git for Windows Setup</code>的链接进行下载把对应的可执行文件下载到本地（在老版本当中有<code>32</code>位和<code>64</code>位可供选择，在最新的几个版本当中不再提供<code>32</code>位的安装包）。<br>我们点击这个可执行文件来进行安装，先选择设置安装路径，如<code>D:\Git</code>。然后全都使用默认选项，一直选择<code>next</code>来完成安装即可。在完成之后我们可以在<code>D</code>盘根目录下看到新生成了一个<code>Git</code>文件夹，在该目录的<code>bin</code>文件夹下有<code>git.exe</code>可执行文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWb4a?w=879&amp;h=290"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>为了能在任意目录下都能运行这个可执行文件，则我们需要配置环境变量。我们在环境变量的用户变量当中新建一个<code>Git</code>变量，其值为<code>D:\Git\bin</code>，然后编辑用户变量的<code>PATH</code>变量值，在其值后面追加<code>;%Git%;</code>即可，然后点击确定来关闭窗口。接下去在<code>cmd</code>当中键入命令<code>-&gt; git --version</code>若能显示版本号则说明<code>git</code>安装成功。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWb4p?w=677&amp;h=190"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>二、git的基本命令</h3>
<p><code>git</code>是一款源代码管理工具，我们使用<code>git</code>可以帮我们记录源代码的所有变更情况。</p>
<h5>1、<code>-&gt; git init</code>
</h5>
<p>首先我们可以在我们的项目文件夹下键入命令<code>-&gt; git init</code>来初始化了一个本地的<code>git</code>仓储。即在我们的项目文件夹下添加了一个<code>.git</code>的<strong>隐藏</strong>文件夹，之后会在这个文件夹下记录该项目源代码的所有变更情况。</p>
<h5>2、<code>-&gt; git status</code>
</h5>
<p>在完成<code>git</code>仓储的初始化之后，在当前项目文件夹下键入命令<code>-&gt; git status</code>来查看本地仓储的当前状态。如下图所示，我们第一次查看时，罗列了一堆当前目录下没有被跟踪的文件。我们同样可以使用命令<code>-&gt; git status -s</code>来查看简化版的变更日志。这个命令更常用一些。（列表当中A表示添加，M表示修改，D表示删除。）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWb7D?w=677&amp;h=659"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h5>3、<code>-&gt; git add</code>
</h5>
<p>该命令用于添加本地暂存（托管）文件。我们可以使用命令<code>-&gt; git add 文件名</code>来把当前目录下没有被跟踪的文件添加到跟踪列表。如我们可以在当前项目文件夹下键入命令<code>-&gt; git add README.md</code>则完成添加。执行该命令不会有提示，我们需要通过<code>-&gt; git status</code>来查看结果。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWb8t?w=671&amp;h=467"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们可以使用<code>-&gt; git add --all</code>来把当前目录下所有没有被跟踪的文件都添加到跟踪列表当中。不过在执行该命令之前，我们需要明确当前目录下有一些文件没有必要被跟踪，如<code>node_modules</code>文件夹，（因为我们在<code>package.json</code>文件当中记录了该项目所有的依赖包）。故我们需要在当前目录下添加一个清单文件，用于明确该目录下哪些文件需要被忽略。<br>我们使用<code>sublime</code>等编辑器在当前项目文件夹下新建一个名为<code>.gitignore</code>的文本文件。（因为在<code>windows</code>环境下不允许新建一个名字以<code>.</code>开头的文件或文件夹）。在该文本文件当中直接写入文件名即可，一行写一个文件名即可。如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWb9D?w=678&amp;h=340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>忽略清单文件编辑完成后，我们再次用<code>-&gt; git status</code>来查看忽略结果。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcaa?w=673&amp;h=433"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>此时我们可以看到未被跟踪的文件当中已经忽略了<code>node_modules</code>文件夹。然后我们使用命令<code>-&gt; git add --all</code>把当前状态当中所有未被跟踪的文件都添加到跟踪列表里。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcaD?w=668&amp;h=505"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>如上图所示，我们在<code>.gitignore</code>文件当中写上<code>dist</code>则代表该项目文件夹下凡是文件名为<code>dist</code>的文件都会被忽略，但如果我们写<code>/dist</code>则只会忽略该项目根目录下的文件名为<code>dist</code>的文件，而其他文件夹下的<code>dist</code>文件不会被忽略。</p></blockquote>
<h5>4、<code>-&gt; git commit -m ""提交日志说明""</code>
</h5>
<p>上面我们使用<code>-&gt; git add --all</code>只是把文件添加到跟踪列表当中，在添加完成之后，我们使用<code>-&gt; git commit -m ""提交日志说明""</code>将当前文件夹当中被跟踪的文件的当前源代码保存一个副本，提交保存至本地的<code>git</code>仓储当中。由于在<code>git</code>当中每一次提交都<strong>必须</strong>要有提交日志，故我们必须能在参数<code>-m</code>后面加上提交的日志说明，方便我们以后能从历史记录当中快速的找到改动记录。在我们第一次提交时，会报如下错误：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWccK?w=673&amp;h=321"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这是因为我们在初次运行<code>git</code>时，需要进行配置用户信息。第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次<code>git</code>提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录。如果用了<code>--global</code>选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉<code>--global</code>选项重新配置即可，新的设定保存在当前项目的<code>.git/config</code>文件里。<br>我们可以键入<code>-&gt; git config --global user.name ""qianqian""</code>和<code>-&gt; git config --global user.email ""zhonglinqian@126.com""</code>。完成配置之后，我们就可以进行提交了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcc7?w=670&amp;h=541"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在完成提交之后，我们可以用<code>-&gt; git status</code>来查看当前状态，用<code>-&gt;git log</code>来查看我们的提交日志。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcdu?w=671&amp;h=314"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h5>5、<code>-&gt; git diff</code>
</h5>
<p>该命令用于对比当前状态与版本库当中最后一个版本之间的状态变化。当我们完成第一次提交源代码到本地<code>git</code>仓储之后，我们就可以进行对我们项目文件夹下的文件进行更改啦，如我们在<code>imgs</code>文件夹下删去了<code>1.png</code>图。此时我们可以使用<code>-&gt; git diff</code>来对比当前项目文件夹下那些被跟踪的文件与本地<code>git</code>仓储的最后一个版本源文件之间发生了哪些变化。<br>在明确了修改之后，如果我们希望把当前修改后的版本再提交到本地git仓储当中，则需要做的是：先用命令<code>-&gt; git add --all</code>来重新添加一次（即把所有变化了的文件都添加进来），然后紧接着用命令<code>-&gt; git commit -m ""第二次提交源代码""</code>来完成提交。提交之后我们仍可以用<code>-&gt; git log</code>来查看提交日志。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcek?w=670&amp;h=568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>我们想要把当前项目文件夹当中修改后的版本提交到本地<code>git</code>仓储当中，则我们一定要在修改完成之后先执行<code>add</code>命令，然后再执行<code>commit</code>命令。两步才可完成版本的提交。</p></blockquote>
<h5>6、<code>-&gt; git reset --hard 指定版本号的前六位编号</code>
</h5>
<p>该命令可以用于让我们当前的项目文件回到指定的版本。我们在本地<code>git</code>仓储库里存放的副本文件都是可以追溯回来的。（只要源代码库没被破坏，则仓储库当中任何一个版本都是可以追溯的。）我们通过<code>-&gt; git log</code>可以查看仓储库当中有几个版本，还有对应的版本说明。在每一版的<code>commit</code>属性值为其对应的版本编号，我们取其前六位作为版本编号。如果我们希望让我们的项目文件恢复到第一次提交的版本，则键入命令<code>-&gt; git reset --hard 20d91e</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWce0?w=675&amp;h=216"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>此时我们当前项目文件夹当中源代码则恢复到我们提交第一次版本时的状态了，查看本地项目文件夹的<code>imgs</code>文件夹，可以看到<code>1.png</code>文件又恢复了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWce6?w=678&amp;h=248"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h5>7、<code>-&gt; git log</code>
</h5>
<p>查看版本日志</p>
<h5>8、<code>-&gt; git help</code>
</h5>
<p>查看帮助文档</p>
<h3>三、github的使用</h3>
<p><code>git</code>服务器可以用来同步本地的代码仓储。我们可以通过<code>git</code>命令将本地代码库当中的代码备份到<code>git</code>服务器当中，可以实现代码，有利于项目的协同开发。<code>github</code>实质上是一家<code>git</code>服务器的提供商。接下去我们来介绍如何将我们本地的项目文件上传至<code>github</code>。</p>
<p>我们在<code>github</code>上完成账号的注册与激活之后，登陆自己的账号，选择<code>start a project</code>或者<code>new repository</code>来新建一个代码仓储。接下去在管理面板当中填写项目的名字，描述及选择为<code>public</code>（代码开源），不选<code>initialize this repository with README.md</code>则可以由自己来创建<code>README.md</code>文件，不需要自动生成。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcgQ?w=1345&amp;h=592"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVWcgV?w=1349&amp;h=616"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在上面的这个面板当中我们得到了这个项目仓储的<code>https</code>的地址，将其复制下来。如<code>https://github.com/linqian123/markdown-convertTo-html.git</code>。接下去我们在本地的项目文件夹下键入命令<code>-&gt; git remote add origin https://github.com/linqian123/markdown-convertTo-html.git</code>，此时我们是添加了一个<code>git</code>的远端服务器的仓储地址，该地址的别名为<code>origin</code>。在添加完成之后，我们通过命令<code>-&gt; git remote -v</code>来查看详细的远端地址。（<code>fetch</code>表示从远端获取的地址，<code>push</code>表示向远端推送的地址，这两个地址实际上是一样的。）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWchl?w=672&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们之前在第二部分介绍<code>git</code>基本命令的时候，已经对我们的项目文件进行了本地git仓储的版本提交操作。即我们可以在修改之后，先用命令<code>-&gt; git add --all</code>来重新添加一次（即把所有变化了的文件都添加进来），然后紧接着用命令<code>-&gt; git commit -m ""提交日志""</code>来完成提交。然后再执行命令<code>-&gt; git push -u origin master</code>,接下去会要求输入你在<code>github</code>上的用户名和密码。完成之后显示为：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWchz?w=674&amp;h=337"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>接下去刷新<code>github</code>上的地址，即可以看到我们的项目文件上传成功啦！</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWchQ?w=1352&amp;h=599"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>我们如果想要在<code>github</code>上对项目源代码进行线上编辑，推荐使用<code>chrome</code>浏览器，避免出现我们在编辑完成之后无法点击<code>preview changes</code>来进行预览，或无法点击<code>commit changes</code>来进行提交保存。</p></blockquote>
<p>因为<code>github</code>采用<code>linguist</code>来自动识别仓库代码应该归为哪一类，故如果我们想要修改<code>github</code>仓库默认显示的项目语言类型（如把默认显示的<code>css</code>类型改为<code>javascript</code>类型），我们可以在线上在我们项目的根目录下创建一个<code>.gitattributes</code>文件，在该文件当中添加如下代码:</p>
<pre><code>*.js linguist-language=js
*.css linguist-language=js
*.html linguist-language=js</code></pre>
<p>此时表示将该项目仓库当中的<code>js</code>,<code>css</code>,<code>html</code>代码都统计为js类型的代码。</p>

                ", git与github的使用,1531977780,493,1,458,1,1,https://segmentfault.com/a/1190000011447934
84,1,0,7,"
                    
<blockquote><p>想用GitBook的客户端写文档，但是发现不能登录GitBook的帐号，主要目的是想把工作成果保存到网络上避免放在自己电脑上丢失。于是我采用折衷的办法，用GitBook在本机写作，然后把文章保存在GitHub。</p></blockquote>
<h2>1. 下载安装GitBook Editor</h2>
<p>链接：<a href=""https://www.gitbook.com/editor/"" rel=""nofollow noreferrer"">https://www.gitbook.com/editor/</a></p>
<p>安装后打开，客户端提示登录GitBook帐号。由于我值需要用GitBook Editor做编辑工具，不需要把文章存在GitBook上（根本原因是登录不了，原因你懂）。<code>选Do that later</code>：<br><span class=""img-wrap""><img data-src=""/img/bVWaqc?w=486&amp;h=643"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>由于没有登录，创建的图书都会在存储在本地，而不会传到GitBook网上。GitBook Editor创建的图书默认是在<code>C:\Users\用户名\GitBook</code>目录下，我习惯把资料存在D盘，于是选择菜单栏<code>GitBook Editor - Change Library Path</code>，把目录改成<code>D:\GitBook</code>：<br><span class=""img-wrap""><img data-src=""/img/bVWaqp?w=486&amp;h=643"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>2. 在本地创建图书</h2>
<p>点击<code>New Book</code>创建图书，填写书名，点击确定，创建后图书相关的文件会存储在<code>D:\GitBook\Import</code>目录下。相关截图：<br><span class=""img-wrap""><img data-src=""/img/bVWaqM?w=486&amp;h=643"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVWaqN?w=1206&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVWaqO?w=690&amp;h=198"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>注意：</strong>由于我在创建图书前将<code>Library Path</code>改成了<code>D:\GitBook</code>，所以我新建的图书的文件才会存储在<code>D:\GitBook\Import</code>目录下。而<code>Import</code>目录是对应GitBook Editor菜单栏的<code>Import</code>命令。经我测试，如果再创建一个<code>D:\GitBook\Open</code>目录，对应的就是GitBook Editor菜单栏的<code>Open</code>命令。<strong>Import和Open的区别是：</strong></p>
<ul>
<li>
<code>Import</code>可以将从本地其它目录的图书（用<code>gitbook init</code>命令创建的图书目录）导入到<code>Library Path</code>，导入后修改的文件内容会保存在<code>Library Path</code>。比如：在<code>D:\test\hello</code>目录通过<code>gitbook init</code>创建了一本书，然后打开GitBook Editor <code>Import</code>，选择<code>D:\test\hello</code>，然后<code>D:\test\hello</code>目录的文件就会复制到<code>D:\GitBook\Import\hello</code>。而在GitBook Editor中修改了内容后，这些内容会保存在<code>D:\GitBook\Import\hello</code>目录下。</li>
<li>
<code>Open</code>就是直接打开一个<code>gitbook init</code>的图书。经测试，只有在<code>Library Path</code>下的<code>Open</code>目录下使用<code>gitbook init</code>命令创建的图书，才会正常在GitBook Editor中显示。</li>
</ul>
<h2>3. 关联GitHub</h2>
<p>在GitBook打开新创建的图书，点击<code>Add an article</code>随便输入点东西。<br><span class=""img-wrap""><img data-src=""/img/bVWarZ?w=1206&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>注意右上角有两个按钮：<code>Save</code>和<code>Publish</code>。当点击<code>Save</code>的时候，GitBook Editor会把编辑的内容保存在<code>Library Path</code>。而当点击<code>Publish</code>的时候，就会把编辑的内容保存到Git仓库（可以是任意的Git仓库：GitHub、码云、oschina...）。如果当前这本存储在本地的图书没有关联Git仓库，GitBook Editor会弹出提示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWasl?w=1206&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>那么这时候就需要创建一个Git仓库了。到GitHub创建一个空白的仓库，并复制<code>https</code>的git仓库地址。<strong>注意必须使用https的因为GitBook Editor暂时不支持SSH</strong>，相关截图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVWasv?w=402&amp;h=206"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVWasz?w=733&amp;h=602"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVWasB?w=978&amp;h=194"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>然后把git仓库地址复制到GitBook Editor，点击<code>Sync</code>，再输入GitHub的帐号密码就OK了，相关截图：<br><span class=""img-wrap""><img data-src=""/img/bVWasG?w=1206&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVWasH?w=1206&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>最后检查一下GitHub上时候已经有刚同步上去的文件，如果有就OK了。<br><span class=""img-wrap""><img data-src=""/img/bVWasL?w=1023&amp;h=493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>接下来就可以开始编辑自己的图书，编辑后记得要点击右上角<code>Publish</code>同步到GitHub。</p>

                ", GitBook关联GitHub,1531977782,413,1,995,1,1,https://segmentfault.com/a/1190000011440899
85,1,0,7,"
                    
<p><a href=""http://www.bestvist.com/2017/09/29/git-command/"" rel=""nofollow noreferrer"">原文链接</a></p>
<blockquote><p>github是全球最大的代码托管网站，其中管理项目的git命令更是繁多，所以在此记录一下</p></blockquote>
<h2>新建项目</h2>
<pre><code>新建一个目录，初始化为git代码库    
git init 'project name'

下载一个项目到当前目录下
git clone 'url'
</code></pre>
<h2>增：add</h2>
<pre><code>添加指定文件或目录到本地暂存区
git add 'file'或'dir'

添加目录下所有文件到本地暂存区
git add *
</code></pre>
<h2>删：rm</h2>
<pre><code>从git代码库中移除文件
git rm 'file'

从git代码库中移除目录
git rm -r 'dir'
</code></pre>
<h2>改：commit</h2>
<pre><code>提交暂存区内容到git代码库
git commit -m 'commit message'

提交暂存区指定文件到git代码库
git commit 'file' -m 'commit message' 

提交工作区内容到git代码库（不需要git add）
git commit -a

提交一次新信息替换上一次提交（如果没有变化，改写上一次提交信息）   
git commit --amend -m 'message'
</code></pre>
<h2>查</h2>
<pre><code>显示有变更的文件
git status

显示暂存区和工作区的区别
git diff  

显示当前分支的历史版本信息
git log

根据关键词搜索提交历史信息        
git log -S 'keyword'

显示指定文件修改详情
git blame 'file'

显示当前分支的最近几次提交    
git reflog
</code></pre>
<h2>分支：branch</h2>
<pre><code>列出所有本地分支
git branch

列出所有远程分支    
git branch -r

列出所有本地远程分支    
git branch -a

新建一个分支，但保持在当前分支    
git branch 'branch name'

删除分支    
git branch -d 'branch name'
</code></pre>
<h2>校验：checkout</h2>
<pre><code>恢复暂存区的文件到工作区 
git checkout 'file'

恢复暂存区的所有文件到工作区
git checkout *    

切换到上一个分支
git checkout -

新建一个分支，并切换到该分支
git checkout -b 'branch name'   
</code></pre>
<h2>合并：merge</h2>
<pre><code>将分支合并到当前分支    
git merge 'branch name'
</code></pre>
<h2>标签：tag</h2>
<pre><code>列出所有标签
git tag

新建一个标签在当前提交
git tag 'tag name'     

删除本地标签
git tag -d 'tag name'
</code></pre>
<h2>远程：remote</h2>
<pre><code>显示所有远程git代码库
git remote -v

显示指定远程git代码库信息
git remote show 'remote name' 
</code></pre>
<h2>推送：push</h2>
<pre><code>提交标签到指定远程git代码库
git push 'remote name' 'tag name'     

提交分支到指定远程git代码库
git push 'remote name' 'branch name'

强行提交当前分支到远程git代码库    
git push 'remote name' -force
</code></pre>
<h2>帮助：help</h2>
<pre><code>
帮助信息
git -help</code></pre>

                ", Git命令清单,1531977783,424,1,252,1,1,https://segmentfault.com/a/1190000011407541
86,1,0,7,"
                    
<p>学习 React 的过程中实现了一个个人主页，没有复杂的实现和操作，适合入门 ~</p>
<p>原文地址：<a href=""https://github.com/axuebin/react-blog/issues/17"" rel=""nofollow noreferrer"">https://github.com/axuebin/react-blog/issues/17</a></p>
<hr>
<p>这个项目其实功能很简单，就是常见的主页、博客、demo、关于我等功能。</p>
<p>页面样式都是自己写的，黑白风格，可能有点丑。不过还是最低级的 CSS ，准备到时候重构 ~</p>
<p>如果有更好的方法，或者是我的想法有偏差的，欢迎大家交流指正</p>
<p>欢迎参观：<a href=""http://axuebin.com/react-blog"" rel=""nofollow noreferrer"">http://axuebin.com/react-blog</a></p>
<p>Github：<a href=""https://github.com/axuebin/react-blog"" rel=""nofollow noreferrer"">https://github.com/axuebin/react-blog</a></p>
<h2>预览图</h2>
<h3>首页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399158?w=1886&amp;h=1062"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>博客页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399159?w=1893&amp;h=1062"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>文章内容页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399160?w=1893&amp;h=1059"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>Demo页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399161?w=1893&amp;h=1062"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>关键技术</h2>
<ul>
<li>ES6：项目中用到 ES6 的语法，在写的过程中尽量使用，可能有的地方没想到</li>
<li>React</li>
<li>React-Router：前端路由</li>
<li>React-Redux：状态管理</li>
<li>webpack：打包</li>
<li>marked：Markdown渲染</li>
<li>highlight.js：代码高亮</li>
<li>fetch：异步请求数据</li>
<li>eslint：代码检查</li>
<li>antd：部分组件懒得自己写。。</li>
</ul>
<h2>准备工作</h2>
<p>由于不是使用 React 脚手架生成的项目，所以每个东西都是自己手动配置的。。。</p>
<h3>模块打包器</h3>
<p>打包用的是 <code>webpack 2.6.1</code>，准备入坑 <code>webpack 3</code> 。</p>
<p>官方文档：<a href=""https://webpack.js.org/"" rel=""nofollow noreferrer"">https://webpack.js.org/</a></p>
<p>中文文档：<a href=""https://doc.webpack-china.org/"" rel=""nofollow noreferrer"">https://doc.webpack-china.org/</a></p>
<p>对于 <code>webpack</code> 的配置还不是太熟，就简单的配置了一下可供项目启动：</p>
<pre><code class=""javascript"">var webpack = require('webpack');
var path = require('path');

module.exports = {
  context: __dirname + '/src',
  entry: ""./js/index.js"",
  module: {
    loaders: [
      {
        test: /\.js?$/,
        exclude: /(node_modules)/,
        loader: 'babel-loader',
        query: {
          presets: ['react', 'es2015']
        }
      }, {
        test: /\.css$/,
        loader: 'style-loader!css-loader'
      }, {
        test: /\.js$/,
        exclude: /(node_modules)/,
        loader: 'eslint-loader'
      }, {
        test: /\.json$/,
        loader: 'json-loader'
      }
    ]
  },
  output: {
    path: __dirname + ""/src/"",
    filename: ""bundle.js""
  }
}
</code></pre>
<p><code>webpack</code> 有几个重要的属性：<code>entry</code>、<code>module</code>、<code>output</code>、<code>plugins</code>，在这里我还没使用到插件，所以没有配置 <code>plugins</code> 。</p>
<p><code>module</code> 中的 <code>loaders</code>：</p>
<ul>
<li>babel-loader：将代码转换成es5代码</li>
<li>css-loader：处理css中路径引用等问题</li>
<li>style-loader：动态把样式写入css</li>
<li>eslin-loader：使用eslint</li>
</ul>
<h3>包管理</h3>
<p>包管理现在使用的还是 <code>NPM</code> 。</p>
<p>官方文档：<a href=""https://docs.npmjs.com/"" rel=""nofollow noreferrer"">https://docs.npmjs.com/</a></p>
<ol>
<li>npm init</li>
<li>npm install</li>
<li>npm uninstall</li>
</ol>
<p>关于<code>npm</code>，可能还需要了解 <code>dependencies</code> 和 <code>devDependencies</code> 的区别，我是这样简单理解的：</p>
<ul>
<li>dependencies：项目跑起来后需要使用到的模块</li>
<li>devDependencies：开发的时候需要用的模块，但是项目跑起来后就不需要了</li>
</ul>
<h3>代码检查</h3>
<p>项目使用现在比较流行的 <code>ESLint</code> 作为代码检查工具，并使用 <code>Airbnb</code> 的检查规则。</p>
<p>ESLint：<a href=""https://github.com/eslint/eslint"" rel=""nofollow noreferrer"">https://github.com/eslint/eslint</a></p>
<p>eslint-config-airbnb：<a href=""https://www.npmjs.com/package/eslint-config-airbnb"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/eslint-config-airbnb</a></p>
<p>在 <code>package.json</code> 中可以看到，关于 <code>ESLint</code> 的包就是放在 <code>devDependencies</code> 底下的，因为它只是在开发的时候会使用到。</p>
<h4>使用</h4>
<ul><li>在 <code>webpack</code> 配置中加载 <code>eslint-loader</code>：</li></ul>
<pre><code class=""javascript"">module: {
  loaders: [
      {
        test: /\.js$/,
        exclude: /(node_modules)/,
        loader: 'eslint-loader'
      }
    ]
  }</code></pre>
<ul><li>创建 <code>.elintrc</code>文件：</li></ul>
<pre><code class=""javascript"">{
  ""extends"": ""airbnb"",
  ""env"":{
    ""browser"": true
  },
  ""rules"":{}
}</code></pre>
<p>然后在运行 <code>webpack</code> 的时候，就会执行代码检查啦，看着一堆的 <code>warning</code> 、<code>error</code> 是不是很爽~</p>
<p>这里有常见的ESLint规则：<a href=""http://eslint.cn/docs/rules/"" rel=""nofollow noreferrer"">http://eslint.cn/docs/rules/</a></p>
<h3>数据源</h3>
<p>由于是为了练习 <code>React</code>，暂时就只考虑搭建一个静态页面，而且现在越来越多的大牛喜欢用 <code>Github Issues</code> 来写博客，也可以更好的地提供评论功能，所以我也想试试用 <code>Github Issues</code> 来作为博客的数据源。</p>
<p>API在这：<a href=""https://developer.github.com/v3/issues/"" rel=""nofollow noreferrer"">https://developer.github.com/v3/issues/</a></p>
<p>我也没看完全部的API，就看了看怎么获取 <code>Issues</code> 列表。。</p>
<pre><code class=""javascript"">https://api.github.com/repos/axuebin/react-blog/issues?creator=axuebin&amp;labels=blog</code></pre>
<p>通过控制参数 <code>creator</code> 和 <code>labels</code>，可以筛选出作为展示的 <code>Issues</code>。它会返回一个带有 <code>issue</code> 格式对象的数组。每一个 <code>issue</code> 有很多属性，我们可能不需要那么多，先了解了解底下这几种：</p>
<pre><code class=""javascript"">// 为了方便，我把注释写在json中了。。
[{
  ""url"": ,  // issue 的 url
  ""id"": ,  // issue id ， 是一个随机生成的不重复的数字串 
  ""number"": ,  // issue number ， 根据创建 issue 的顺序从1开始累加
  ""title"": ,  // issue 的标题
  ""labels"": [], // issue 的所有 label，它是一个数组
  ""created_at"": , // 创建 issue 的时间
  ""updated_at"": , // 最后修改 issue 的时间
  ""body"": , // issue 的内容
}]</code></pre>
<h4>异步请求数据</h4>
<p>项目中使用的异步请求数据的方法时 <code>fetch</code>。</p>
<p>关于 <code>fetch</code> ：<a href=""https://segmentfault.com/a/1190000003810652"" rel=""nofollow noreferrer"">https://segmentfault.com/a/1190000003810652</a></p>
<p>使用起来很简单：</p>
<pre><code class=""javascript"">fetch(url).then(response =&gt; response.json())
      .then(json =&gt; console.log(json))
      .catch(e =&gt; console.log(e));</code></pre>
<h3>markdown 渲染</h3>
<p>在 <code>Github</code> 上查找关于如何在 <code>React</code> 实现 <code>markdown</code> 的渲染，查到了这两种库：</p>
<ul>
<li>react-markdown：<a href=""https://github.com/rexxars/react-markdown"" rel=""nofollow noreferrer"">https://github.com/rexxars/react-markdown</a>
</li>
<li>marked：<a href=""https://github.com/chjj/marked"" rel=""nofollow noreferrer"">https://github.com/chjj/marked</a>
</li>
</ul>
<p>使用起来都很简单。</p>
<p>如果是 <code>react-markdown</code>,只需要这样做：</p>
<pre><code class=""javascript"">import ReactMarkdown from 'react-markdown';

const input = '# This is a header\n\nAnd this is a paragraph';
ReactDOM.render(
    &lt;ReactMarkdown source={input} /&gt;,
    document.getElementById('container')
);</code></pre>
<p>如果是<code>marked</code>，这样做：</p>
<pre><code class=""javascript"">import marked from 'marked';

const input = '# This is a header\n\nAnd this is a paragraph';
const output = marked(input);</code></pre>
<p>这里有点不太一样，我们获取到了一个字符串 <code>output</code>，注意，是一个字符串，所以我们得将它插入到 <code>dom</code>中，在 <code>React</code> 中，我们可以这样做：</p>
<pre><code class=""html"">&lt;div dangerouslySetInnerHTML={{ __html: output }} /&gt;</code></pre>
<p>由于我们的项目是基于 <code>React</code> 的，所以想着用 <code>react-markdown</code>会更好，而且由于安全问题 <code>React</code> 也不提倡直接往 <code>dom</code> 里插入字符串，然而在使用过程中发现，<code>react-markdown</code> 对表格的支持不友好，所以只好弃用，改用 <code>marked</code>。</p>
<h3>代码高亮</h3>
<p>代码高亮用的是<code>highlight.js</code>：<a href=""https://github.com/isagalaev/highlight.js"" rel=""nofollow noreferrer"">https://github.com/isagalaev/highlight.js</a></p>
<p>它和<code>marked</code>可以无缝衔接~</p>
<p>只需要这样既可：</p>
<pre><code class=""javascript"">import hljs from 'highlight.js';

marked.setOptions({
  highlight: code =&gt; hljs.highlightAuto(code).value,
});</code></pre>
<p><code>highlight.js</code>是支持多种代码配色风格的，可以在<code>css</code>文件中进行切换：</p>
<pre><code class=""css"">@import '~highlight.js/styles/atom-one-dark.css';</code></pre>
<p>在这可以看到每种语言的高亮效果和配色风格：<a href=""https://highlightjs.org/"" rel=""nofollow noreferrer"">https://highlightjs.org/</a></p>
<h2>React</h2>
<h3>state 和 props 是什么</h3>
<p>可以看之前的一篇文章：<a href=""https://github.com/axuebin/react-blog/issues/8"" rel=""nofollow noreferrer"">https://github.com/axuebin/react-blog/issues/8</a></p>
<h3>关于React组件的生命周期</h3>
<p>可以看之前的一篇文章：<a href=""https://github.com/axuebin/react-blog/issues/9"" rel=""nofollow noreferrer"">https://github.com/axuebin/react-blog/issues/9</a></p>
<h2>前端路由</h2>
<p>项目中前端路由用的是 <code>React-Router V4</code>。</p>
<p>官方文档：<a href=""https://reacttraining.com/react-router/web/guides/quick-start"" rel=""nofollow noreferrer"">https://reacttraining.com/react-router/web/guides/quick-start</a></p>
<p>中文文档：<a href=""http://reacttraining.cn/"" rel=""nofollow noreferrer"">http://reacttraining.cn/</a></p>
<h3>基本使用</h3>
<pre><code class=""javascript"">&lt;Link to=""/blog""&gt;Blog&lt;/Link&gt;</code></pre>
<pre><code class=""javascript"">&lt;Router&gt;
  &lt;Route exact path=""/"" component={Home} /&gt;
  &lt;Route path=""/blog"" component={Blog} /&gt;
  &lt;Route path=""/demo"" component={Demo} /&gt;
&lt;/Router&gt;</code></pre>
<p>注意：一定要在根目录的 <code>Route</code> 中声明 <code>exact</code>，要不然点击任何链接都无法跳转。</p>
<h3>2级目录跳转</h3>
<p>比如我现在要在博客页面上点击跳转，此时的 <code>url</code> 是 <code>localhost:8080/blog</code>,需要变成 <code>localhost:8080/blog/article</code>，可以这样做：</p>
<pre><code class=""javascript"">&lt;Route path={`${this.props.match.url}/article/:number`} component={Article} /&gt;</code></pre>
<p>这样就可以跳转到 <code>localhost:8080/blog/article</code> 了，而且还传递了一个 <code>number</code> 参数，在 <code>article</code> 中可以通过 <code>this.props.params.number</code>获取。</p>
<h3>HashRouter</h3>
<p>当我把项目托管到 <code>Github Page</code> 后，出现了这样一个问题。</p>
<blockquote><p>刷新页面出现 <code>Cannot GET /</code> 提示，路由未生效。</p></blockquote>
<p>通过了解，知道了原因是这样，并且可以解决：</p>
<ul>
<li>由于刷新之后，会根据URL对服务器发送请求，而不是处理路由，导致出现 <code>Cannot GET /</code> 错误。</li>
<li>通过修改 <code>&lt;Router&gt;</code> → <code>&lt;HashRouter&gt;</code> 。</li>
<li>
<code>&lt;HashRouter&gt;</code> 借助URL上的哈希值（hash）来实现路由。可以在不需要全屏刷新的情况下，达到切换页面的目的。</li>
</ul>
<h3>路由跳转后不会自动回到顶部</h3>
<p>当前一个页面滚动到一定区域后，点击跳转后，页面虽然跳转了，但是会停留在滚动的区域，不会自动回到页面顶部。</p>
<p>可以通过这样来解决：</p>
<pre><code class=""javascript"">componentDidMount() {
    this.node.scrollIntoView();
}

render() {
  return (
    &lt;div ref={node =&gt; this.node = node} &gt;&lt;/div&gt;
  );
}</code></pre>
<h2>状态管理</h2>
<p>项目中多次需要用到从 <code>Github Issues</code> 请求来的数据，因为之前就知道 <code>Redux</code> 这个东西的存在，虽然有点大材小用，为了学习还是将它用于项目的状态管理，只需要请求一次数据即可。</p>
<p>官方文档：<a href=""http://redux.js.org/"" rel=""nofollow noreferrer"">http://redux.js.org/</a></p>
<p>中文文档：<a href=""http://cn.redux.js.org/"" rel=""nofollow noreferrer"">http://cn.redux.js.org/</a></p>
<p>简单的来说，每一次的修改状态都需要触发 <code>action</code> ，然而其实项目中我现在还没用到修改数据2333。。。</p>
<p>关于状态管理这一块，由于还不是太了解，就不误人子弟了~</p>
<h2>主要组件</h2>
<p>React是基于组件构建的，所以在搭建页面的开始，我们要先考虑一下我们需要一些什么样的组件，这些组件之间有什么关系，哪些组件是可以复用的等等等。</p>
<h3>首页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399162?w=1330&amp;h=597"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，我主要将首页分成了四个部分：</p>
<ul>
<li>header：网站标题，副标题，导航栏</li>
<li>banner：about me ~，准备用自己的照片换个背景，但是还没有合适的照片</li>
<li>
<p>card area：暂时是三个卡片</p>
<ul>
<li>blog card：最近的几篇博文</li>
<li>demo card：几个小demo类别</li>
<li>me card：算是我放飞自我的地方吧</li>
</ul>
</li>
<li>footer：版权信息、备案信息、浏览量</li>
</ul>
<h3>博客页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399163?w=1339&amp;h=589"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>博客页就是很中规中矩的一个页面吧，这部分是整个项目中代码量最多的部分，包括以下几部分：</p>
<ul>
<li>文章列表组件</li>
<li>翻页组件</li>
<li>归档按钮组件</li>
<li>类别组件</li>
<li>标签组件</li>
</ul>
<h4>文章列表</h4>
<p>文章列表其实就是一个 <code>list</code>，里面有一个个的 <code>item</code>:</p>
<pre><code class=""html"">&lt;div class=""archive-list""&gt;
  &lt;div class=""blog-article-item""&gt;文章1&lt;/div&gt;
  &lt;div class=""blog-article-item""&gt;文章2&lt;/div&gt;
&lt;div&gt;</code></pre>
<p>对于每一个 <code>item</code>，其实是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399164?w=873&amp;h=125"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一个文章item组件它可能需要包括：</p>
<ul>
<li>文章标题</li>
<li>文章发布的时间、类别、标签等</li>
<li>文章摘要</li>
<li>...</li>
</ul>
<p>如果用 <code>DOM</code> 来描述，它应该是这样的：</p>
<pre><code class=""html"">&lt;div class=""blog-article-item""&gt;
  &lt;div class=""blog-article-item-title""&gt;文章标题&lt;/div&gt;
  &lt;div class=""blog-article-item-time""&gt;时间&lt;/div&gt;
  &lt;div class=""blog-article-item-label""&gt;类别&lt;/div&gt;
  &lt;div class=""blog-article-item-label""&gt;标签&lt;/div&gt;
  &lt;div class=""blog-article-item-desc""&gt;摘要&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>所以，我们可以有很多个组件：</p>
<ul>
<li>文章列表组件 <code>&lt;ArticleList /&gt;</code>
</li>
<li>文章item组件 <code>&lt;ArticleItem /&gt;</code>
</li>
<li>类别标签组件 <code>&lt;ArticleLabel /&gt;</code>
</li>
</ul>
<p>它们可能是这样一个关系：</p>
<pre><code class=""javascript"">&lt;ArticleList&gt;
  &lt;ArticleItem&gt;
    &lt;ArticleTitle /&gt;
    &lt;ArticleTime /&gt;
    &lt;ArticleLabel /&gt;
    &lt;ArticleDesc /&gt;
  &lt;/ArticleItem&gt;
  &lt;ArticleItem&gt;&lt;/ArticleItem&gt;
  &lt;ArticleItem&gt;&lt;/ArticleItem&gt;
&lt;/ArticleList&gt;</code></pre>
<h4>分页</h4>
<p>对于分页功能，传统的实现方法是在后端完成分页然后分批返回到前端的，比如可能会返回一段这样的数据：</p>
<pre><code class=""javascript"">{
  total:500,
  page:1,
  data:[]
}</code></pre>
<p>也就是后端会返回分好页的数据，含有表示总数据量的<code>total</code>、当前页数的<code>page</code>，以及属于该页的数据<code>data</code>。</p>
<p>然而，我这个页面只是个静态页面，数据是放在Github Issues上的通过API获取的。（Github Issues的分页貌似不能自定义数量...），所以没法直接返回分好的数据，所以只能在前端强行分页~</p>
<p>分页功能这一块我偷懒了...用的是 <code>antd</code> 的翻页组件 <code>&lt;Pagination /&gt;</code>。</p>
<p>官方文档：<a href=""https://ant.design/components/pagination-cn/"" rel=""nofollow noreferrer"">https://ant.design/components/pagination-cn/</a></p>
<p>文档很清晰，使用起来也特别简单。</p>
<p>前端渲染的逻辑（有点蠢）：将数据存放到一个数组中，根据当前页数和每页显示条数来计算该显示的索引值，取出相应的数据即可。</p>
<p>翻页组件中：</p>
<pre><code class=""javascript"">constructor() {
  super();
  this.onChangePage = this.onChangePage.bind(this);
}

onChangePage(pageNumber) {
  this.props.handlePageChange(pageNumber);
}

render() {
  return (
    &lt;div className=""blog-article-paging""&gt;
      &lt;Pagination onChange={this.onChangePage} defaultPageSize={this.props.defaultPageSize} total={this.props.total} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>当页数发生改变后，会触发从父组件传进 <code>&lt;ArticlePaging /&gt;</code> 的方法 <code>handlePageChange</code>，从而将页数传递到父组件中，然后传递到 <code>&lt;ArticleList /&gt;</code> 中。 </p>
<p>父组件中：</p>
<pre><code class=""javascript"">handlePageChange(pageNumber) {
  this.setState({ currentPage: pageNumber });
}

render() {
  return (
    &lt;div className=""archive-list-area""&gt;
      &lt;ArticleList issues={this.props.issues} defaultPageSize={this.state.defaultPageSize} pageNumber={this.state.currentPage} /&gt;
      &lt;ArticlePaging handlePageChange={this.handlePageChange} total={this.props.issues.length} defaultPageSize={this.state.defaultPageSize} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>列表中：</p>
<pre><code class=""javascript"">render() {
  const articlelist = [];
  const issues = this.props.issues;
  const currentPage = this.props.pageNumber;
  const defaultPageSize = this.props.defaultPageSize;
  const start = currentPage === 1 ? 0 : (currentPage - 1) * defaultPageSize;
  const end = start + defaultPageSize &lt; issues.length ? start + defaultPageSize : issues.length;
  for (let i = start; i &lt; end; i += 1) {
    const item = issues[i];
    articlelist.push(&lt;ArticleItem /&gt;);
  }
}</code></pre>
<h4>label</h4>
<p>在 <code>Github Issues</code> 中，可以为一个 <code>issue</code> 添加很多个 <code>label</code>，我将这些对于博客内容有用的 <code>label</code> 分为三类，分别用不同颜色来表示。</p>
<p>这里说明一下， <code>label</code> 创建后会随机生成一个 <code>id</code>，虽然说 <code>id</code> 是不重复的，但是文章的类别、标签会一直在增加，当新加一个 <code>label</code> 时，程序中可能也要进行对应的修改，当作区分 <code>label</code> 的标准可能就不太合适，所以我采用颜色来区分它们。</p>
<ul>
<li>表示这是一篇文章的blog：只有有 <code>blog</code> 的 <code>issue</code> 才能显示在页面上，过滤 <code>bug</code> 、<code>help</code> 等</li>
<li>表示文章类别的：用来表示文章的类别，比如“前端”、“摄影”等</li>
<li>表示文章标签的：用来表示文章的标签，比如“JavaScript”、“React”等</li>
</ul>
<p>即使有新的 <code>label</code> ，也只要根据颜色区分是属于哪一类就好了。</p>
<h5>类别</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399165?w=315&amp;h=383"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在这里的思路主要就是：遍历所有 <code>issues</code>，然后再遍历每个 <code>issue</code>的 <code>labels</code>，找出属于类别的 <code>label</code>，然后计数。</p>
<pre><code class=""javascript"">const categoryList = [];
const categoryHash = {};
for (let i = 0; i &lt; issues.length; i += 1) {
  const labels = issues[i].labels;
  for (let j = 0; j &lt; labels.length; j += 1) {
    if (labels[j].color === COLOR_LABEL_CATEGORY) {
      const category = labels[j].name;
      if (categoryHash[category] === undefined) {
        categoryHash[category] = true;
        const categoryTemp = { category, sum: 1 };
        categoryList.push(categoryTemp);
      } else {
        for (let k = 0; k &lt; categoryList.length; k += 1) {
          if (categoryList[k].category === category) {
            categoryList[k].sum += 1;
          }
        }
      }
    }
  }
}</code></pre>
<p>这样实现得要经历三次循环，复杂度有点高，感觉有点蠢，有待改进，如果有更好的方法，请多多指教~</p>
<h5>标签</h5>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399166?w=315&amp;h=386"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里的思路和类别的思路基本一样，只不过不同的显示方式而已。</p>
<p>本来这里是想通过字体大小来体现每个标签的权重，后来觉得可能对于我来说，暂时只有那几个标签会很频繁，其它标签可能会很少，用字体大小来区分就没有什么意义，还是改成排序的方式。</p>
<h3>文章页</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399167?w=1337&amp;h=588"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>文章页主要分为两部分：</p>
<ul>
<li>文章内容区域：显示文章内容，显示在页面的主体区域</li>
<li>章节目录：文章的章节目录，显示在文章的右侧区域</li>
</ul>
<h4>文章内容</h4>
<p>有两种方式获取文章具体内容：</p>
<ul>
<li>从之前已经请求过的数组中去遍历查找所需的文章内容</li>
<li>通过 <code>issue number</code> 重新发一次请求直接获取内容</li>
</ul>
<p>最后我选择了后者。</p>
<p>文章是用 <code>markdown</code> 语法写的，所以要先转成 <code>html</code> 然后插入页面中，这里用了一个 <code>React</code> 不提倡的属性：<code>dangerouslySetInnerHTML</code>。 </p>
<p>除了渲染<code>markdown</code>，我们还得对文章中的代码进行高亮显示，还有就是定制文章中不同标签的样式。</p>
<h4>章节目录</h4>
<p>首先，这里有一个 <code>issue</code>，希望大家可以给一些建议~</p>
<p>文章内容是通过 <code>markdown</code> 渲染后插入 <code>dom</code> 中的，由于 <code>React</code> 不建议通过 <code>document.getElementById</code> 的形式获取 <code>dom</code> 元素，所以只能想办法通过字符串匹配的方式获取文章的各个章节标题。</p>
<p>由于我不太熟悉正则表达式，曾经还在sf上咨询过，就采用了其中一个答案：</p>
<pre><code class=""javascript"">const issues = content;
const menu = [];
const patt = /(#+)\s+?(.+)/g;
let result = null;
while ((result = patt.exec(issues))) {
  menu.push({ level: result[1].length, title: result[2] });
}</code></pre>
<p>这样可以获取到所有的 <code>#</code> 的字符串，也就是 <code>markdown</code> 中的标题， <code>result[1].length</code> 表示有几个 <code>#</code>，其实就是几级标题的意思，<code>title</code> 就是标题内容了。</p>
<p>这里还有一个问题，本来通过 <code>&lt;a target="""" /&gt;</code> 的方式可以实现点击跳转，但是现在渲染出来的 <code>html</code> 中对于每一个标题没有独一无二的标识。。。</p>
<h3>归档页</h3>
<p>按年份归档：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399168?w=1336&amp;h=633"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>按类别归档：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399169?w=1339&amp;h=633"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>按标签归档：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011399170?w=1337&amp;h=631"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>问题</h2>
<p>基本功能是已经基本实现了，现在还存在着以下几个问题，也算是一个 <code>TodoList</code> 吧</p>
<ul>
<li>评论功能。拟利用 <code>Github Issues API</code> 实现评论，得实现 <code>Github</code> 授权登录</li>
<li>回到顶部。拟利用 <code>antd</code> 的组件，但是 <code>state</code> 中 <code>visibility</code> 一直是 <code>false</code>
</li>
<li>
<p>首页渲染。现在打包完的js文件还是太大了，导致首页渲染太慢，这个是接下来工作的重点，也了解过关于这方面的优化：</p>
<ul>
<li>
<code>webpack</code> 按需加载。这可能是目前最方便的方式</li>
<li>服务端渲染。这就麻烦了，但是好处也多，不仅解决渲染问题，还有利于SEO，所以也是 <code>todo</code> 之一</li>
</ul>
</li>
<li>代码混乱，逻辑不对。这是我自己的问题，需要再修炼。</li>
</ul>
<p>原文地址：<a href=""https://github.com/axuebin/react-blog/issues/17"" rel=""nofollow noreferrer"">https://github.com/axuebin/react-blog/issues/17</a></p>

                ", 手把手教你用React实现一个简单的个人博客,1531977784,237,1,356,1,1,https://segmentfault.com/a/1190000011399153
87,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVVSne?w=1242&amp;h=536"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>前言</h3>
<p>前一阵子由于Facebook BSD+PATENTS License的原因，Apache项目禁止使用带该license的代码，引人注目的就是Facebook的React前端框架。<br>后来在知乎上看到百度内部也要求在半年内完成内部产品的转型，如下图所示。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>最近又看到Facebook 的React框架又重新将Facebook BSD+PATENTS License更新为了MIT协议。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>以上这些变化，引起了我的好奇，在接下来的内容中将对以下内容进行阐述。</p>
<h3>目录</h3>
<ol>
<li>Facebook的BSD+PATENTS License到底说了些什么，以React为例子。</li>
<li>开源协议选择</li>
<li>结尾</li>
</ol>
<h3>BSD+PATENTS License</h3>
<p>根据维基百科的定义，License即软件许可证，含义如下</p>
<blockquote><p>软件许可证是一种具有法律性质的合同或指导，目的在规范受著作权保护的软件的使用或散布行为。通常的授权方式会允许用户来使用单一或多份该软件的复制，因为若无授权而径予使用该软件，将违反著作权法给予该软件开发者的专属保护。效用上来说，软件授权是软件开发者与其用户之间的一份合约，用来保证在匹配授权范围的情况下，用户将不会受到控告。</p></blockquote>
<p>根据更新前的Facebook React仓库中的 Readme文件所示。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371386"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>React使用的是BSD协议，另外附加了专利许可证。而引起讨论的重点则出在PATENTS 专利许可上。<br>节选PATENTS专利许可证上的一段话</p>
<blockquote><p>The license granted hereunder will terminate, automatically and without notice, if you (or any of your subsidiaries, corporate affiliates or agents) initiate directly or indirectly, or take a direct financial interest in, any Patent  Assertion: (i) against Facebook or any of its subsidiaries or corporate affiliates, (ii) against any party if such Patent Assertion arises in whole or in part from any software, technology, product or service of Facebook or any of its subsidiaries or corporate affiliates, or (iii) against any party relating  to the Software</p></blockquote>
<p>这一段整体说明了，如果违反了以下三个限制，就会被撤销使用React的许可，在我个人的理解来说，就是Facebook可以反告你一把了。<br>由 (i)和(ii)看出，如果你采取专利申诉或者是挑战到了Facebook,Facebook的子公司以及合作方，你的React许可就会被撤销。<br>由(iii) 可以看出：你不能够其他使用了React的公司产生纠纷，不然也会被撤销React许可。<br>这一段是引起了很大的反向，换句话来说，只要你使用着Facebook的React框架，那么Facebook如果侵权你的专利，你还不能告他，你告他的话，你的React许可就会被撤销，然后被反告一把实锤，想想还真的是挺心塞的哈哈。<br>所以百度以及其他的一些公司有一些对应的举措也不足为怪。</p>
<h3>各种开源协议以及如何选择</h3>
<p>因为社区的反响实在强烈，以及Apache基金会的强硬举措，Facebook在近期是妥协了，将Facebook BSD+PATENTS License更新为了MIT协议。<br>开源协议的数量非常多，但一般来说，我们只需要在常用的当中进行选择即可。阮一峰老师在乌克兰程序员Paul Bagwell的基础上绘制了一份中文的协议选择图，非常浅显易懂。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371387"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>对于Facebook这次的升级来说，MIT相对于BSD的不同之处在于，使用MIT协议的是可以用原有作者的名字打广告的，其实就是更为宽松了一些。<br>在这些常见的协议当中，BSD和MIT的协议相对比较宽松，Apache次之，会保留作者的专利版权，GPL限定性更强。知乎网友<a href=""http://www.gcssloop.com/tips/choose-license"" rel=""nofollow noreferrer"">http://www.gcssloop.com/tips/...</a>也画了一张对应的示例图，从图中可以很清晰的看到各个协议之间的区别。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371388"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><a href=""https://choosealicense.com/"" rel=""nofollow noreferrer"">https://choosealicense.com/</a> 这个网站提供了选择开源协议上的一些建议。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371389"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>知乎网友gcssloop在这个的基础上对其做了汉化处理，具体网址见<a href=""http://choosealicense.online/"" rel=""nofollow noreferrer"">http://choosealicense.online/</a><br><span class=""img-wrap""><img data-src=""/img/remote/1460000011371390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>结尾</h3>
<p>这是个人对这次Facebook React开源协议事件的一些资料收集以及个人看法，希望对大家有所帮助。<br>同时也对之前网络上盛传的“ 不用学React”这种言论说一句。</p>
<blockquote><p>且不说你的公司使用React会不会和Facebook引起冲突，哪怕公司层面上有冲突，私下去学习这样一个优秀的框架也是极好的提升机会，切莫浮躁啊。</p></blockquote>

                ", 从Facebook的React框架事件学习一下开源协议,1531977785,306,1,204,1,1,https://segmentfault.com/a/1190000011371379
88,1,0,7,"
                    
<h2>简介</h2>
<p>cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。</p>
<h2>下载</h2>
<p>官网地址：<a href=""http://cmder.net/"" rel=""nofollow noreferrer"">http://cmder.net/</a> </p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPNl?w=1536&amp;h=859"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>下载的时候，会有两个版本，分别是mini与full版；唯一的差别在于有没有内建msysgit工具，这是Git for Windows的标准配备；全安装版 cmder 自带了 msysgit, 压缩包 23M, 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。</p>
<h2>安装</h2>
<p>直接解压到某个目录就可以了，点击Cmder.exe运行。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPOt?w=696&amp;h=392"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>配置环境变量</h2>
<p>在系统变量添加</p>
<ul>
<li>变量名： <strong><em>CMDER_HOME</em></strong>
</li>
<li>变量值： 安装绝对路径</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVVPPu?w=667&amp;h=187"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>最后在Path添加一条<em>斜体文字</em><br><strong><em>%CMDER_HOME%</em></strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPPP?w=541&amp;h=567"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>添加 cmder 到右键菜单</h2>
<p>配置环境变量后，在<strong>管理员权限</strong>的终端输入以下语句。<br>Win8或者Win10可以直接 win+x 再按 a 键进入。</p>
<pre><code>Cmder.exe /REGISTER ALL
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVVPQu?w=993&amp;h=516"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>配置好后，任意文件夹右键</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPQH?w=208&amp;h=367"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>新标签打开个管理员权限终端</h2>
<p>快捷键 Ctrl + t 后勾选</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPRb?w=471&amp;h=297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPRh?w=471&amp;h=297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>设置</h2>
<p>快捷键：win + alt + p<br>或者在右下角图标，右击</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPRS?w=391&amp;h=294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2><strong>设置bash作为默认开启的选项</strong></h2>
<p><span class=""img-wrap""><img data-src=""/img/bVVPSa?w=767&amp;h=489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>解决中文乱码问题</h2>
<p>之前在网找了好多方法，可是都解决不了，很多人在在Environment里添加set LANG=zh_CN.UTF-8来解决中文乱码的问题，可是我用这个方法并没有成功，可能是环境的原因吧，我的系统是win10的。<br>最后找到解决办法：<br>Settings-&gt;Startup-&gt;Environment 添加<br>set LANG=zh_CN.UTF-8<br>set LC_ALL=zh_CN.utf8</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPTf?w=767&amp;h=489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>重启Cmder，发现使用ls，中文正确显示了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVPUc?w=510&amp;h=89"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>更改背景</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVVP5C?w=767&amp;h=489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>更换主题</h2>
<p>内置了几款不错的主题，当然如果你觉得不合适，当然也支持自己设定。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVP54?w=767&amp;h=489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>常用功能介绍</h1>
<p><span class=""img-wrap""><img data-src=""/img/bVVPUy?w=652&amp;h=531"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>如上图示编号的部分说明如下：</p>
<p>1, Cmder常用快捷键</p>
<ul>
<li>利用Tab，自动路径补全；</li>
<li>利用Ctrl+T建立新页签；利用Ctrl+W关闭页签;</li>
<li>利用Ctrl+Tab切换页签;</li>
<li>Alt+F4：关闭所有页签</li>
<li>Alt+Shift+1：开启cmd.exe</li>
<li>Alt+Shift+2：开启powershell.exe</li>
<li>Alt+Shift+3：开启powershell.exe (系统管理员权限)</li>
<li>Ctrl+1：快速切换到第1个页签</li>
<li>Ctrl+n：快速切换到第n个页签( n值无上限)</li>
<li>Alt + enter： 切换到全屏状态；</li>
<li>Ctr+r 历史命令搜索</li>
</ul>
<p>2, 可在视窗内搜寻画面上出现过的任意关键字。</p>
<p>3, 新增页签按钮。</p>
<p>4, 切换页签按钮。</p>
<p>5, 锁定视窗，让视窗无法再输入。</p>
<p>6, 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。</p>
<p>7, 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P  ：开启工具选项视窗。</p>

                ", Windows命令行工具cmder配置,1531977787,461,1,218,1,1,https://segmentfault.com/a/1190000011361877
89,1,0,7,"
                    
<h1>GitHub的常用命令</h1>
<p>因为项目原因，最近准备Github在上面创建代码仓库，<br>发现以前常用的命令行有些已经记不得了，而Github这样的版本控制工具在我们的开发过程是必不可少的，<br>所以我就想写一写关于GitHub的一些使用方法和命令行，用来加深自己印象和理解。</p>
<blockquote><h3>一.了解Git</h3></blockquote>
<h4>Git是一款分布式的版本控制工具；</h4>
<ul><li>版本控制 :Git可以记录我们对项目文件、内容等所做的全部修改，并将这些改动记录成一个个版本，<br>方便我们查看历史记录，备份以及恢复以前的版本你可以很方便的通过指定某个版本的版本号来回滚至该版本，这样可以避免你在改动某些代码时导致项目崩溃的情况</li></ul>
<ul><li>分布式管理 :这是相对于集中式管理来说的，集中式管理必须有一个中央服务器，<br>数据要从中央服务器下载，没有网络就无法工作。而分布式管理每个人的电脑都是一个版本库，还可以做到离线提交。</li></ul>
<blockquote><h3>二.配置Git</h3></blockquote>
<p>1.全局配置用户名和邮箱，commit的时候记录提交；</p>
<pre><code>$ git config --global user.name ""username""

$ git config --global user.email ""email""
</code></pre>
<p>2.本地创建版本库</p>
<pre><code>$ git init
</code></pre>
<blockquote><h3>三.基本Git指令</h3></blockquote>
<ul>
<li>
<code>git add ""files"":</code> 将文件放入暂存区；</li>
<li>
<code>git rm ""files"":</code> 删除文件;</li>
<li>
<code>git commit -m '':</code> 提交至仓库，并添加备注；</li>
<li>
<code>git status:</code> 查看仓库状态;</li>
<li>
<code>git diff ：</code>查看文件最新改动的地方;</li>
<li>
<code>git log:</code> 查看修改记录;</li>
<li>
<code>git relog:</code> 查看所有记录（包括撤销操作）；</li>
<li>
<code>git reset ––hard HEAD^:</code> 回退到上一个版本;</li>
<li>
<code>git reset ––hard 版本号：</code>回退到指定版本;</li>
<li>
<code>git checkout ""files"":</code>撤销未提交的操作；</li>
</ul>
<blockquote><h3>四.远程仓库（origin）</h3></blockquote>
<ul>
<li>
<code>$ git remote -v：</code>查看远程仓库；</li>
<li>
<code>$ git remote add [name] [url]:</code> 添加远程仓库；</li>
<li>
<code>$ git remote rm [name] [url]:</code> 删除远程仓库；</li>
<li>
<code>$ git remote set-url --push [name] [newUrl]:</code> 修改远程仓库；</li>
<li>
<code>$ git clone git@github.com:&lt;address&gt;/&lt;project name&gt;.git:</code> 从远程仓库克隆至本地；</li>
<li>
<code>$ git pull origin [BranchName]：</code> 拉取远程仓库；</li>
<li>
<code>$ git push origin [BranchName]:</code> 推送远程仓库；(第一次推送需要<code>$ git push -u origin [localBranchName]</code>)；</li>
</ul>
<blockquote><h3>五.分支操作（branch）</h3></blockquote>
<ul>
<li>
<code>$ git branch:</code> 查看本地分支;</li>
<li>
<code>$ git branch -r:</code> 查看远程分支;</li>
<li>
<code>$ git branch [name]:</code> 创建本地分支;</li>
<li>
<code>$ git checkout [name]:</code> 切换到分支;</li>
<li>
<code>$ git checkout -b [name]:</code> 创建新分支并立即切换到新分支;</li>
<li>
<code>$ git merge [name]:</code> 合并分支（将名称为[name]的分支与当前分支合并）;</li>
<li>
<code>$ git log --graph:</code> 查看分支合并图;</li>
<li>
<code>$ git branch -d [name]:</code> 删除分支 （-d 只能删除已经参与了合并的分支如果想强制删除一个分支，可以使用-D选项)</li>
<li>
<code>$ git push origin [name]:</code> 创建远程分支（本地分支push到远程）;</li>
<li>
<code>$ git push origin --delete [name]:</code> 删除远程分支</li>
<li>
<code>$ git push origin test:master：</code> 提交本地test分支作为远程的master分支;</li>
<li>
<code>$ git push origin test:test：</code>  提交本地test分支作为远程的test分支;</li>
</ul>
<blockquote><h3>最后.一句话送给大家共勉</h3></blockquote>
<pre><code>业精于勤荒于嬉，行成于思毁于随。
</code></pre>

                ", Git的常用命令,1531977788,273,1,380,1,1,https://segmentfault.com/a/1190000011336551
90,1,0,7,"
                    
<blockquote><p>作者：Darkbug<br>原文标题：Google新技术：Instant App全拆解（3）——着手<br>原文链接：<a href=""https://segmentfault.com/a/1190000011315286"" rel=""nofollow noreferrer"">https://segmentfault.com/a/11...</a><br>首发地址：<a href=""http://www.doncc.org"" rel=""nofollow noreferrer"">http://www.doncc.org</a><br>转发请注明转载地址，请尊重原创作者权益！</p></blockquote>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：</p>
<p>第四篇：<a href=""https://segmentfault.com/a/1190000011648067"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（4）——架构</a></p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：</p>
<p>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>
<p>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>
<hr>
<p>本文着重介绍在进行Instant App程序开发时，所需要进行的准备工作，包括集成开发环境的准备，以及准备工作的注意事项。准备工作不是非常繁琐，所以内容照前一篇文章相比相对较少。</p>
<p>如有描述不正确的地方，请及时联系我，我将吸取意见并改正。</p>
<h1>1.集成开发环境的准备工作</h1>
<p>想要进行Instant App的开发，就需要对其开发环境进行准备。在Android官方SDK提供的内容来看，官方已经为我们提供了完整的SDK。我们只需下载使用即可。</p>
<p>在集成开发环境的准备工作一章内，我将分为两个部分进行阐述：</p>
<ul>
<li>Instant App SDK的导入</li>
<li>系统环境要求</li>
</ul>
<h2>1.1 Instant App SDK的导入</h2>
<p>对于导入Instant App的SDK，是比较简单的。在我们最为熟悉的Android SDK Manager内，有为我们提供的下载地址。</p>
<p>操作步骤如下：</p>
<ol>
<li>启动Android SDK Manager</li>
<li>选择“SDK Tools”标签</li>
<li>勾选中“Instant Apps Development SDK”选项，确定导入</li>
<li>当导入完毕后，点击“OK”关闭Android SDK Manager</li>
</ol>
<p>操作预览图如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011315291"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当我们成功导入SDK后，我们就可以利用它进行Instant App程序开发了。当然，这一步的完成，仅仅是可以动手开发的第一步。</p>
<h2>1.2 系统环境要求</h2>
<p>Instant App开发不是在所有的集成开发环境都可以进行的。在Windows、MacOS、Linux下均进行程序开发。</p>
<p>下面我会列举出系统所要求的环境：</p>
<ol>
<li>电脑的JDK 1.8以上</li>
<li>Android Studio version 3.0或以上（包含预览版）</li>
<li>配置好<code>ANDROID_HOME</code>环境变量</li>
<li>Android SDK 6.0+</li>
<li>Android SDK Tools 25.0+</li>
<li>Android SDK Build Tools 26.0+</li>
<li>Android SDK Platform Tools 25.0+</li>
<li>Android Support Library 最新版本</li>
<li>Android Repository 最新版本</li>
</ol>
<p>这里要格外说明下，想要进行Instant App开发，必须在Android Studio 3.0及以上的版本上进行开发（包括预览版）。目前官方已到最新的预览版为Android Studio Beta 5，官方已经提供预览版的下载地址：<a href=""https://developer.android.com/studio/preview/index.html?hl=zh-cn"" rel=""nofollow noreferrer"">https://developer.android.com/studio/preview/index.html?hl=zh-cn</a></p>
<p>如已发布正式版，请忽略上面链接，下载正式版即可。</p>
<h1>2.模拟器&amp;真机的准备工作</h1>
<p>同样，Instant App的开发，是有模拟器与真机的环境要求的。下面我来列举出对于真机及模拟器的系统环境要求：</p>
<h2>2.1模拟器的准备工作</h2>
<ul>
<li>Android 6.0（API Level 23）及以上版本系统</li>
<li>Nexus 5X镜像模拟器</li>
<li>带有Google APIs框架结构的镜像</li>
<li>CPU为x86架构</li>
</ul>
<p>创建模拟器的方法这里我就不再赘述了，相信大伙既然能看到本套教程，也会能知道该如何创建Android模拟器。这里注意，CPU的架构方式不能为x86_64的方式，绝对不能！</p>
<h2>2.2真机的准备工作</h2>
<ul><li>
<p>运行于Android 6.0+（API Level 23及以上）的系统</p>
<ul>
<li>
<p>手机厂商：</p>
<ul>
<li>Google亲儿子：Nexus 5X、Nexus 6P、Pixel、Pixel XL</li>
<li>三星：Galaxy S7(S7 edge)</li>
</ul>
</li>
<li>Google 服务框架已安装在手机上。</li>
</ul>
<p>Google的亲儿子系列是天生自带Google服务框架的，至于三星S7(edge)，需要xx上网的方式(你懂得)，另安装服务框架。</p>
</li></ul>
<p>当你的真机真正具备上述条件后，接下来的操作尤为重要：</p>
<h2>2.3开启Google服务</h2>
<p>当你的手机已有Google服务框架后，就可以启动Google账号。当开启Google账号服务后，就可以进行下面的步骤了。具体添加Google账号的方法，请参考如下；如已开启Google账号，请跳过本2.3章节，直接跳到2.4章节阅读。</p>
<h3>2.3.1 Samsung Galaxy S7(edge)系列</h3>
<p>这里手机系统以Android 7.0为例：</p>
<ol>
<li>打开手机设置。</li>
<li>选择云和账户。</li>
<li>选择账户。</li>
<li>选择添加账户。</li>
<li>添加一个Google账户。当然你得需要xx上网，你懂得。</li>
</ol>
<p>方法截图如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011315292"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后你就能在设置界面里，看到Google的选项设置了。</p>
<h3>2.3.2 Nexus系列</h3>
<p>这里手机以Nexus 5X，预装Android 7.1.1系统为例：</p>
<ol>
<li>打开手机设置。</li>
<li>选择账号。</li>
<li>选择添加账号。</li>
<li>选择Google。当然这里同样需要xx上网。。。-_-||</li>
</ol>
<p>所以你看吧，木有xx上网的童鞋，蓝瘦不蓝瘦，香菇不香菇。?</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011315293"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后你就能在设置界面里，看到Google的选项设置了。</p>
<h2>2.4开启免安装应用功能</h2>
<p>对于默认的Google账户，是没有开启免安装应用功能的开关的。因为Instant App是新技术，Google并没有强制让用户体验到这个功能，而是自由征集用户的选择。所以如果想要进行Instant App程序开发，这一项的功能开关是必不可少的需要打开。</p>
<p>操作步骤如下：</p>
<ol>
<li>打开手机设置</li>
<li>选择Google账户</li>
<li>滑动到下面，选择免安装应用</li>
<li>将关闭状态的开关，置为开启</li>
<li>在开启的时候，会弹出一个询问对话框，确定启用免安装应用服务，就可以成功打开免安装应用功能了。</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011315294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里需要同学们注意几点问题：</p>
<ul>
<li>Google Play Services框架需要在10.0.84+的版本，才能正常使用Instant App程序。</li>
<li>需安装Google Play for Services for Instant Apps即时应用程序服务框架。</li>
</ul>
<p>这样我们就可以进行Instant App程序开发了。怎么样，是不是感觉有点小激动？写到这里，我们确实发现，在进行Instant App程序开发前的准备工作，其实很简单。</p>
<p>接下来的文章，我会从程序架构方面来讲解Instant App程序开发。</p>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：</p>
<p>第四篇：<a href=""https://segmentfault.com/a/1190000011648067"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（4）——架构</a></p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：</p>
<p>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>
<p>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>

                ", Google新技术：Instant App全拆解（3）——着手,1531977789,360,1,242,1,1,https://segmentfault.com/a/1190000011315286
91,1,0,7,"
                    
<h1>API Mocker</h1>
<blockquote><p>先贴上项目地址：<a href=""https://github.com/DXY-F2E/api-mocker"" rel=""nofollow noreferrer"">DXY-F2E/api-mocker</a></p></blockquote>
<p>随着web发展，前后端分离的演进，网页的交互变的越来越复杂。在项目开发过程中，前后端并行开发时，在涉及到接口的部分，总是遇到各类问题。诸如接口假数据、接口参数的约定、代理调试等等，极大的影响了开发效率。</p>
<p>API Mocker致力于解决前后端开发协作过程中出现的各类问题，提高开发效率，对接口做统一管理，同时也能为后续的迭代维护提供更便捷的方式。</p>
<h2>系统功能</h2>
<h3>接口约定</h3>
<p>API Mocker提供操作简单但功能丰富的接口编辑，接口约定者能方便的设置接口的各类信息，其中：</p>
<ul>
<li>
<p>结构化的接口参数输入与输出</p>
<ul>
<li>支持不同维度的请求参数约定（<code>query</code>，<code>body</code>，<code>path</code>, <code>header</code>）</li>
<li>支持参数的类型约定（<code>string</code>，<code>number</code>，<code>boolean</code>，<code>object</code>，<code>array</code>）</li>
<li>参数备注、示例</li>
</ul>
</li>
<li>支持Json数据逆向生成参数结构</li>
<li>保留一定接口历史记录</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011199209"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>Mock数据</h3>
<p>API Mocker认为，mock不仅仅体现在返回数据中，mock请求本身也应该符合接口约定。因此，我们提供更加符合业务场景的mock服务。</p>
<ul>
<li>Mock请求会根据接口约定，自动生成假数据。</li>
<li>Mock请求会根据接口约定，对请求参数做校验。（校验是否选填、参数类型是否正确）。</li>
<li>根据接口约定与用户设置，能模拟不同的网络响应状态，如：<code>200</code>，<code>404</code>，<code>500</code>。</li>
<li>支持接口代理，代理mock请求到线上or测试地址，避免开发环境跨域，省下Charles代理过程。</li>
<li>支持<a href=""http://mockjs.com/"" rel=""nofollow noreferrer"">Mock.js</a>语法。</li>
</ul>
<h3>接口文档</h3>
<p>API Mocker会根据接口约定自动生成简洁优美、结构清晰的接口文档。同时，可以订阅接口，当接口发送变化时，及时收到邮件通知。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011199210"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>接口权限</h3>
<p>API Mocker提供简单易用的权限控制。</p>
<ul>
<li>组级别、API级别控制</li>
<li>可见性、可写性权限控制</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011199211"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>其他功能点</h3>
<ul>
<li>接口测试。开发人员可以在系统上直接测试接口，避免在postman等请求工具上又填写众多参数</li>
<li>便捷的接口搜索。（可以按接口地址、管理员等维度搜索接口）</li>
<li>数据呈现</li>
<li>支持rap的导入</li>
</ul>
<h2>技术栈与第三方库</h2>
<ul>
<li>ES6</li>
<li>ESLint (Standard)</li>
<li><a href=""https://github.com/ramda/ramda"" rel=""nofollow noreferrer"">Ramda</a></li>
<li>...</li>
</ul>
<h3>Client</h3>
<ul>
<li>
<a href=""https://github.com/vuejs/vue"" rel=""nofollow noreferrer"">Vue</a>全家桶（vue + vuex + vue-router + webpack）</li>
<li>
<a href=""https://github.com/ElemeFE/element"" rel=""nofollow noreferrer"">ElementUI</a>, <a href=""https://github.com/nuysoft/Mock"" rel=""nofollow noreferrer"">Mock.js</a>, etc...</li>
<li>Less</li>
</ul>
<p><strong>架构图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011199212"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>Server</h3>
<ul>
<li>
<a href=""https://github.com/eggjs/egg"" rel=""nofollow noreferrer"">Egg</a>, <a href=""https://github.com/koajs/koa"" rel=""nofollow noreferrer"">Koa</a>
</li>
<li><a href=""https://github.com/mongodb/mongo"" rel=""nofollow noreferrer"">MongoDB</a></li>
<li><a href=""https://github.com/Automattic/mongoose"" rel=""nofollow noreferrer"">Mongoose</a></li>
</ul>
<p><strong>架构图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011199213"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>其他部署相关内容可看项目github地址的介绍。</p>
<h2>系统未来展望</h2>
<h3>更加强大的接口约定</h3>
<ul>
<li>更多校验属性的添加（日期、范围、正则）</li>
<li>
<p>更便捷的编辑</p>
<ul>
<li>模板选择</li>
<li>组内接口字段智能提示</li>
<li>完善restful api的支持</li>
</ul>
</li>
<li>接口状态管理、版本管理</li>
</ul>
<h3>更完善的周边功能</h3>
<ul>
<li>swagger导入</li>
<li>markdown格式文档导出</li>
<li>Model文件导出（TypeScript等）</li>
<li>
<p>自动化测试</p>
<ul>
<li>随机数据</li>
<li>多次请求</li>
<li>生成报表</li>
</ul>
</li>
</ul>
<h3>其他完善的点</h3>
<ul>
<li>完善mock的体验</li>
<li>更多维度的数据统计</li>
<li>完善使用文档</li>
<li>国际化</li>
</ul>
<h2>致谢</h2>
<p>项目本身也引用了众多开源项目，在此再次感谢这些项目对社会与技术圈作出的杰出贡献。丁香园也将努力、持续的做技术输出、产品输出，为开源社区做出自己的一份力量。</p>
<p><strong><a href=""https://github.com/DXY-F2E/api-mocker"" rel=""nofollow noreferrer"">Github地址</a></strong>     <strong><a href=""https://github.com/DXY-F2E/api-mocker/tree/master/docs#api-mocker"" rel=""nofollow noreferrer"">API Mocker使用文档</a></strong></p>

                ", 丁香园开源接口管理系统,1531977790,557,1,137,1,1,https://segmentfault.com/a/1190000011199204
92,1,0,7,"
                    
<blockquote><p>作者：Darkbug<br>原文标题：Google新技术：Instant App全拆解（2）——剖析<br>原文链接：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">https://segmentfault.com/a/11...</a><br>首发地址：<a href=""http://www.doncc.org"" rel=""nofollow noreferrer"">http://www.doncc.org</a><br>转发请注明转载地址，请尊重原创作者权益！</p></blockquote>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：</p>
<p>第三篇：<a href=""https://segmentfault.com/a/1190000011315286"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（3）——着手</a></p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：<br>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>
<hr>
<p>本文着重介绍在进行Instant App程序开发时，所涉及的Android周边技术，其目的是更好的进行Instant App程序开发。</p>
<p>如有描述不正确的地方，请及时联系我，我将吸取意见并改正。</p>
<h1>1.为何引入Deep Links和App Links的概念</h1>
<p>肯定有很多童鞋不理解，为什么我要在讲Instant App技术之前，要提及这个“看似不相关”的概念呢？实则真正在进行Instant App程序开发时，是必然涉及到这标题所述的两个概念的。应该先搞清这两个概念的区别，再来进行程序开发，就会变得易如反掌了。</p>
<p>Google为我们提供了一个非常好的操作体验：比如当我的好朋友给我发了一个定位的链接信息，这个信息我们看上去好像不那么直观得看出，我的好朋友在什么具体位置。但是如果我一旦点击了这个链接，如果我直接能在某个地图应用里看到具体图像位置的话，那么这个体验就会变得更好了。</p>
<p>对于一个链接，当点击后，Google为我们预留了两种的处理方式，这就是Deep Links和App Links。这两种方式，在体验上是截然不同的。所以想要采用哪种处理方式，这就取决于我们自己的决定。</p>
<p>注意，我这里只是在处理链接的角度上讲，如何处理是取决于用户自己。但是对于Instant App技术来讲，是要采用App Links的处理方式。所以这里同学们需要注意。</p>
<p>那么好，接下来我要着重讲解Deep Links和App Links这两个处理URL的方式。</p>
<h1>2.Deep Links的作用</h1>
<p>要想明白Instant App中的精髓，首先要了解Deep Links是什么东西，以及其本身的作用。</p>
<p>我们来回想一个场景。假如你的手机内安装了UC浏览器（UC浏览器并没有给我充值，先声明），并且还同时存在其他浏览器，当你在一个应用程序内点击一个链接，系统会弹出一个对话框，说明的是让你选择一个可以打开链接的应用或方式。你可以选择系统浏览器，也可以选择UC浏览器；如果你的手机内只有一个可以打开链接的程序（比如只有一个浏览器程序），那么系统就会用这个应用程序直接打开这个链接。</p>
<p>那么结果来了，Deep Links是可以来让用户，通过一段类似URL的链接，达到快速用某个应用打开的作用。当然这也需要用户确认，到底是用哪个程序打开。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169955"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>好，接下来我们再看下官方对于Deep Links工作的阐述。当用户点击一个链接，或者有一个web URI的请求调用，安卓系统会尝试几个操作，直到操作请求成功：</p>
<blockquote><ol>
<li>Open the user's preferred app that can handle the URI, if one is designated.</li>
<li>Open the only available app that can handle the URI.</li>
<li>Allow the user to select an app from a dialog.</li>
</ol></blockquote>
<p>将上述的操作放入刚刚我们举得例子里，不难发现，系统内部执行了如下的判断过程：</p>
<ul>
<li>首先系统判断出哪些程序开放了可以处理URL的程序配置；</li>
<li>其次来看下是不是只有这一个应用程序能处理这个URL；</li>
<li>再次来看下有哪些应用可以处理这个URL；</li>
</ul>
<p>这个判断的过程，完全有系统来进行。所以要懂得它的判断过程，尤为重要。</p>
<h2>2.1进行Deep Links的配置</h2>
<p>我们来设定一个情景。当我的朋友给我发来一段链接，内容是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169956"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>那么这里我们要区分出来，我们需要在VideoActivity上呈现。这段链接对于intent-filter过滤器来说，scheme部分为“http”，而host部分为“doncc.org”，考虑到我的程序可能应对这个链接下面很多其他的视频，所以我可以选定pathPrefix的过滤方式，这样能包括其他视频的链接一并过滤出来（当然你也可以要求更为严格的过滤）。</p>
<p>对于支持Deep Links的程序的配置，很是简单。或许我们来段manifest文件的过滤器配置更为直观：</p>
<pre><code class=""xml"">&lt;activity android:name="".VideoActivity""&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=""android.intent.action.VIEW"" /&gt;
        &lt;category android:name=""android.intent.category.DEFAULT"" /&gt;
        &lt;category android:name=""android.intent.category.BROWSABLE"" /&gt;
        &lt;data
            android:host=""doncc.org""
            android:pathPrefix=""/video""
            android:scheme=""http"" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre>
<p>好，当我们的配置配好之后，就可以将程序运行在模拟器上了。然后将程序退出。</p>
<h2>2.2进行Deep Links的验证</h2>
<p>验证部分需要打开terminal，并输入命令如下：</p>
<pre><code class=""shell"">$ adb shell am start
        -W -a android.intent.action.VIEW
        -d &lt;URI&gt; &lt;PACKAGE&gt;</code></pre>
<p>注意这里的<code>&lt;URI&gt;</code>，指的是你在程序内指定的地址。那么应对上述文中，<code>&lt;URI&gt;</code>指定的就是<code>http://doncc.org/video/1.mp4</code>（或者尾部为其他的视频资源），而<code>&lt;PACKAGE&gt;</code>指的是你的程序的package包名。所以当你输入正确的命令并执行后，你的模拟器就会直接看到执行后的页面。说明此时Deep Links已奏效。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169957"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>特别强调一点。这里我们是直接验证Deep Links是否奏效。然而设置支持此Deep Links的Activity，在第一次呈现时，会有一个选择对话框，因为此Activity添加了其他的过滤器，同样系统内也有跟它一致的过滤器，系统默认是不知道你要用哪个程序打开此链接页面的。所以在提示框内呈现提示用什么应用方式打开。</p>
<p>说了这么多，如果还是没太清楚，可以参考我录制的视频：<a href=""http://v.youku.com/v_show/id_XMzAxMjU4NDIwOA==.html?spm=a2hzp.8253869.0.0"" rel=""nofollow noreferrer"">Android 如何使用 Deep Links 处理URL链接</a></p>
<h1>3.App Links的作用</h1>
<p>我们再来看一个应用场景。</p>
<p>或许我们有过这样的体验。当你的朋友用短信的形式，给你发了一篇知乎的文章链接给你，如果你点击了链接，假设你的手机内没有安装知乎程序，那么手机会自动通过浏览器，显示出来这个文章的页面信息；如果你的手机内安装了知乎的程序，那么会直接打开知乎程序，显示出这个文章的信息。</p>
<p>我们之前知道了Deep Links的作用，实则你可以理解成App Links是一个特殊的Deep Links。因为Deep Links在第一次使用时，是需要用户主动进行授权的，而App Links的作用是无需这第一次的主动授权，是足够信任这个链接地址的。当然这样开放，势必会带来安全的隐患。没有关系，Google大大已经为我们想到了这一点了，在Android 6.0以后，程序可以支持App Links来让程序处理默认指定的链接。</p>
<p>相比Deep Links而言，App Links具有一定的优势的：</p>
<ul>
<li>
<strong>更安全、更严格：</strong>相比Deep Links我们不难发现，在制定具体你的域名地址时，如果指定的条件过于宽泛，势必会可能其他的链接地址后缀也可以访问到你应用程序。如果过于严格的约束，那么所制定的业务有太过于麻烦。所以App Links的出现，就为我们更好的解决这一问题；</li>
<li>
<strong>更为无缝的用户体验：</strong>当你点击一个链接的时候，可能会有一个URL链接到你的网站。如果你的手机内没有安装这个应用，那么链接可以很轻松的重定向到你的网站，不至于页面会弹出一个404 not found的错误，给用户带来非常不好的体验；</li>
<li>
<strong>可支持Android Instant App瞬时加载技术：</strong>可以支持瞬时加载技术。用户无需安装应用，凭一个URL链接，就可以体验到同App一样的用户体验。这一点也是至关重要的，我们也会在后续课程内详细介绍。</li>
<li>
<strong>可从Google Search中搜到你的应用：</strong>同上条一样，我们可以通过Google Search来找到你的应用。这一点也是对我们Instant App有所帮助的一点。</li>
</ul>
<p>从诸多关于App Links的优点来看，我们可以总结出，想要掌握Instant App技术，首先必须掌握App Links是如何配置的，且App Links是基于Deep Links的。所以我们就知道了该如何去学习了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169958"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>好，接下来我们要深入学习关于App Links。</p>
<h2>3.1App Links的配置</h2>
<p>对于支持App Links的程序的配置，要比支持Deep Links的配置稍加复杂一步。总共可分为两个部分：</p>
<ul>
<li>对manifest过滤器的编写</li>
<li>数字资产链接文件的生成</li>
</ul>
<p>接下来我们详细说明每个部分。</p>
<h3>3.1.1对manifest过滤器的编写</h3>
<p>对于过滤器的编写，我们再来一段代码更为直接：</p>
<pre><code class=""xml"">&lt;activity android:name="".BlogActivity""&gt;
    &lt;intent-filter android:autoVerify=""true""&gt;
        &lt;action android:name=""android.intent.action.VIEW"" /&gt;

         &lt;category android:name=""android.intent.category.DEFAULT"" /&gt;
             &lt;category android:name=""android.intent.category.BROWSABLE"" /&gt;

             &lt;data
                android:scheme=""http""
                android:host=""doncc.github.io""
                android:pathPrefix=""/2017/"" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre>
<p>事实上我们不难发现，这个过滤器的编写，要比之前Deep Links的编写内容，只多了一个属性。那就是：</p>
<pre><code class=""xml"">&lt;intent-filter android:autoVerify=""true""&gt;
    ...
&lt;/intent-filter&gt;</code></pre>
<p>通过<code>android:autoVerify=""true""</code>这个属性，就能让系统知道，这个程序是属于可以自动进行验证的。也就为后续进行数字资产链接文件的验证做好了铺垫。</p>
<h3>3.1.2数字资产链接文件的生成</h3>
<p>对于数字资产链接，其实是一个json文件，里面包括了一些应用程序的信息，而这个文件需要放置在你的网站的特定路径内。</p>
<p>那么数字资产链接文件该如何写呢？下面来看个例子：</p>
<pre><code class=""json"">[{
  ""relation"": [""delegate_permission/common.handle_all_urls""],
  ""target"": {
    ""namespace"": ""android_app"",
    ""package_name"": ""org.doncc.learnapplinks"",
    ""sha256_cert_fingerprints"":
    [""01:CD:30:56:A8:5E:EC:18:64:3D:8B:F2:AF:3F:B6:02:85:33:79:13:97:23:E3:FF:99:59:14:E5:03:FC:57:78""]
  }
}]</code></pre>
<p>从上面的例子可以得出结论，数字资产链接文件配置的要求，有如下内容：</p>
<ul>
<li>需知道你应用的包名（package_name）</li>
<li>需知道你发布程序的sha256指纹签名证书（sha256_cert_fingerprints）</li>
</ul>
<p>对于包名，我们肯定知道该如何获得。而对于sha256指纹签名证书，我们可以通过命令来获取到。比如我发布的程序是用release.keystore来签名的，那么你在用命令行获得sha256签名时，就要指定你的key来获得：</p>
<pre><code class=""shell"">$ keytool -list -v -keystore release.keystore</code></pre>
<p>当生成完毕后，需要把这个文件重命名为<code>assetlinks.json</code>，并上传到你的网站的特定目录内：</p>
<pre><code>https://domain.name/.well-known/assetlinks.json</code></pre>
<p>其中<code>domain.name</code>部分为你的具体的网站地址。而需要在你的网站下面的<code>.well-known</code>目录下，新建<code>assetlinks.json</code>文件，也就是刚配置过的数字资产链接文件，来确定你的网址是可信的。</p>
<p>如果我们的网站会忽略隐藏文件，那么强烈建议你写一个取消忽略的配置文件。这个过程就不需要我讲了吧。。。</p>
<h2>3.2App Links的验证</h2>
<p>同样，对于App Links的验证，总体也可以分为两部分：</p>
<ul>
<li>对数字资产链接文件配置合法性的验证</li>
<li>通过Shell命令验证</li>
</ul>
<p>同样，我们详细说明每个部分。</p>
<h3>3.2.1对数字资产链接文件配置合法性的验证</h3>
<p>在进行App Links的验证过程要注意一点，根据官方说明，在程序安装完毕后，至少等待20秒后再进行链接的验证是最为好的。并且要保证你的网络足够好，因为在验证过程，系统识别一旦超过5秒，那么就会验证失败，以至于会出现和Deep Links同样的用户效果了。</p>
<blockquote><p><strong>Note:</strong> Make sure you wait at least 20 seconds after installation of your app to allow for the system to complete the verification process.</p></blockquote>
<ul><li>通过网页的验证链接进行验证</li></ul>
<p>我们可以首先来通过网页访问的形式，来确定我们自己的数字资产链接文件是否已经被网站关联上。这里我们给出官方的网页URL：</p>
<pre><code>https://digitalassetlinks.googleapis.com/v1/statements:list?
   source.web.site=https://domain.name:optional_port&amp;
   relation=delegate_permission/common.handle_all_urls</code></pre>
<p>这里<code>source.web.site</code>是需要替换成我们自己的网站地址的。然后点击回车，如果出现类似下面页面，就说明当前数字资产链接文件已经被网站关联上了：</p>
<pre><code class=""json"">{
  ""statements"": [
    {
      ""source"": {
        ""web"": {
          ""site"": ""https://doncc.github.io.""
        }
      },
      ""relation"": ""delegate_permission/common.handle_all_urls"",
      ""target"": {
        ""androidApp"": {
          ""packageName"": ""org.doncc.l02learnapplinks"",
          ""certificate"": {
            ""sha256Fingerprint"": ""01:CD:30:56:A8:5E:EC:18:64:3D:8B:F2:AF:3F:B6:02:85:33:79:13:97:23:E3:FF:99:59:14:E5:03:FC:57:78""
          }
        }
      }
    }
  ],
  ""maxAge"": ""599.298570247s"",
  ""debugString"": ""********************* ERRORS *********************\nNone!\n********************* INFO MESSAGES *********************\n* Info: The following statements were considered when processing the request:\n\n---\nSource: Web asset with site https://doncc.github.io. (which is equivalent to 'https://doncc.github.io')\nRelation: delegate_permission/common.handle_all_urls\nTarget: Android app asset with package name org.doncc.l02learnapplinks and certificate fingerprint 01:CD:30:56:A8:5E:EC:18:64:3D:8B:F2:AF:3F:B6:02:85:33:79:13:97:23:E3:FF:99:59:14:E5:03:FC:57:78\nWhere this statement came from:\n  Origin of the statement: Web asset with site https://doncc.github.io. (which is equivalent to 'https://doncc.github.io')\n  Include directives followed (in order):\n    \u003cNone\u003e\nMatches source query: Yes\nMatches relation query: Yes\nMatches target query: Yes\n\n--- End of statement list. ---\n\n\n""
}</code></pre>
<ul><li>借助Google Digital Asset Links工具验证</li></ul>
<p>还有一种验证方法，借助<a href=""https://developers.google.com/digital-asset-links/tools/generator"" rel=""nofollow noreferrer"">Google Digital Asset Links</a>这个工具，就能进行验证。</p>
<p>文中所填写的内容，正是你在配置前面<code>assetlinks.json</code>数字资产链接文件的信息。填写进去，进行验证。如果验证通过，说明你的网站已通过安全验证，可以愉快的使用App Links了。</p>
<ul><li>借助App Links Assistant的测试工具验证</li></ul>
<p>事实上还是有其他方法进行验证，借助App Links Assistant的测试工具进行验证。这部分我们会在后部分讲到。</p>
<h3>3.2.2通过Shell命令验证</h3>
<ul><li>adb命令构建URL Intent：</li></ul>
<p>验证的过程和验证Deep Links类似。我们可以用构建URL Intent的方式来进行模拟链接的验证：</p>
<pre><code class=""shell"">adb shell am start -a android.intent.action.VIEW \
    -c android.intent.category.BROWSABLE \
    -d ""http://domain.name:optional_port""</code></pre>
<p>注意，这里<code>-d</code>的内容需要替换成我们自己的网站地址。</p>
<p>如果成功，那么立即就会在模拟器上看到执行后的效果，直接的跳转到所在的Activity，而无需经过用户点击弹出框的确认过程。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169959"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里我贴出关于App Links在开发时的视频：<a href=""http://v.youku.com/v_show/id_XMzAyMTM0NTI5Ng==.html"" rel=""nofollow noreferrer"">如何使用 App Links 处理URL链接</a></p>
<h1>4.通过App Links Assistant来协助配置</h1>
<p>不难发现，实则Deep Links和App Links都有异曲同工之妙。我们从上面的内容来看，确实配置过程有点繁琐。幸好Google大大们已经为我们着想了这一点，在Android Studio 2.3版本及以上版本，内置了一个<strong>App Links Assistant</strong>的链接生成助手。根据这个助手的指引，我们就能很快的配置出属于我们自己程序的App Links，甚至是Deep Links。</p>
<p>那么这个助手该如何找到呢？在你的Tools &gt; App Links Assistant，就可以找到了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169960"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011169961"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里具体有一些如何使用App Links Assistant进行配置的文章描述，我们就不再赘述了，官方的文档已经很详尽的说明了这一点。如需参考请异步地址：<a href=""https://developer.android.com/studio/write/app-link-indexing.html"" rel=""nofollow noreferrer"">Add Android App Links</a></p>
<h1>5.Deep Links和App Links的对比</h1>
<p>这里我们引自官方的对比表格更为直接。（来自：<a href=""https://developer.android.com/training/app-links/verify-site-associations.html#the-difference"" rel=""nofollow noreferrer"">the-difference</a>）</p>
<table>
<thead><tr>
<th> </th>
<th>Deep Links</th>
<th>App Links</th>
</tr></thead>
<tbody>
<tr>
<td>Intent URL scheme</td>
<td>
<code>http</code>, <code>https</code>, or a custom scheme</td>
<td>Requires <code>http</code> or <code>https</code>
</td>
</tr>
<tr>
<td>Intent action</td>
<td>Any action</td>
<td>Requires <code>android.intent.action.VIEW</code>
</td>
</tr>
<tr>
<td>Intent  category</td>
<td>Any category</td>
<td>Requires <code>android.intent.category.BROWSABLE</code> and <code>android.intent.category.DEFAULT</code>
</td>
</tr>
<tr>
<td>Link verification</td>
<td>None</td>
<td>Requires a <a href=""https://developers.google.com/digital-asset-links/v1/getting-started"" rel=""nofollow noreferrer"">Digital Asset Links</a> file served on you website with HTTPS</td>
</tr>
<tr>
<td>User experience</td>
<td>May show a disambiguation dialog for the user to select which app to open the link</td>
<td>No dialog; your app opens to handle your website links</td>
</tr>
<tr>
<td>Compatiblity</td>
<td>All Android versions</td>
<td>Android 6.0 and higher</td>
</tr>
</tbody>
</table>
<p>我们不难看出，App Links的出现是弥补了Deep Links的一些不足。当然使用起来也应该酌情而定，毕竟Deep Links的超高自由度，也是后者望尘莫及的。说了这么多，再结合Instant App，我们就可以总结出以下几点：</p>
<ul>
<li>在Instant  App内使用App Links，具有更为安全的通信协议，也为协议的验证做好铺垫；</li>
<li>因为使用即时应用的前提，是点击一个链接直接跳转到界面，所以在Intent处理上，严格要求处理动作是<code>android.intent.action.VIEW</code>；</li>
<li>同上面描述的，Instant App也需要可以在网络上搜索到，并打开程序，比如Google搜索结果页面上打开。固然需要Intent的种类是<code>android.intent.category.BROWSABLE</code> 和 <code>android.intent.category.DEFAULT</code>；</li>
<li>App Links是可以对URL链接进行安全验证的，而Deep Links是不具有验证功能的。其目的是为了能让Android程序足够信任其URL链接地址，减少让用户选择“xxx方式打开”这种动作歧义的对话框出现，在用户体验上能更让用户觉得是“无缝”的感觉；</li>
<li>对于链接点击处理功能的兼容，Deep Links能兼容所有Android版本，而App Links只兼容Android 6.0及更高的版本。</li>
</ul>
<p>但是话有说回来，不难发现，在App Links与Deep Links的处理场景是很受局限的。大多数的程序是不经过系统处理的，而是直接内置方式处理。比如某聊天工具?。。。这就给其推广造成很大的阻碍，而能实现处理的地方有短信、内置浏览器内等一些原生App内。真是心塞。</p>
<p>好，这回我们就能彻底的了解了这两种URL链接处理方式了。</p>
<h1>6.总结</h1>
<p>对于Instant App程序开发，是依赖于App Links处理URL的方式，并且App Links又是一种特殊的Deep Links，也就是必须先知道Deep Links的作用，才能知道App Links的作用。</p>
<p>Deep Links的出现，是为了能让用户在不同应用见体验到App级的用户体验，而App Links的出现，是为了让这种体验更加“无缝衔接”；</p>
<p>对于App Links，需要一个数字资产链接文件的验证，这个文件是必须放在<code>网站根目录/.well-known/assetlinks.json</code>这个路径下，才能生效；</p>
<p>对于数字资产链接文件，其内部注意你的程序的签名，如果程序是released版本，那么你的签名指纹也需要换成对应的指纹；</p>
<p>对于App Links，需要在过滤器内添加<code>android:autoVerify=""true""</code>属性，保证系统能识别到。</p>
<p>讲到这里，我们就可以初步了解了有关于制作Instant App的周边技术了。接下来我还会有更多的文章来持续讲解Instant App程序开发。</p>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：</p>
<p>第三篇：<a href=""https://segmentfault.com/a/1190000011315286"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（3）——着手</a></p>
<hr>
<p>《Google新技术：Instant App全拆解》系列回顾：</p>
<p>第一篇：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（1）——初探</a></p>

                ", Google新技术：Instant App全拆解（2）——剖析,1531977792,138,1,804,1,1,https://segmentfault.com/a/1190000011169174
93,1,0,7,"
                    
<h2>Git环境配置</h2>
<h3>一、 全局配置</h3>
<h4>1. 配置文件</h4>
<p>git全局配置文件.gitconfig默认在当前系统用户文件夹下，window可运行%USERPROFILE%查找，Mac系统在cd ~查找。</p>
<p>具体配置可参考如下，其中：<br>【user】:  用户提交时显示在log里的信息<br>【alias】: 常用git命令简写<br>【core】:  window系统和类linux系统回车键转换<br>【push】:  默认对应远端（当本地分支名与远程分支名不一致有用）</p>
<pre><code>[user]
    name = hoby
    email = hoby@github.com
[alias]
    st = status
    co = checkout
    br = branch
    ci = commit
    pl = pull --rebase
    ps = push
    mg = merge --no-ff
    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit
[core]
    autocrlf = input
    ignorecase = false
[push]
    default = upstream</code></pre>
<p>若要使用git mergetool功能，再增加配置（cmd处可修改成本地文件比较工具如beyond compare）：</p>
<pre><code>[merge]
    tool = sourcetree
[diff]
    tool = sourcetree
[difftool ""sourcetree""]
    cmd = 'C:/Program Files/TortoiseGit/bin/TortoiseGitMerge.exe' \""$LOCAL\"" \""$REMOTE\""
[mergetool ""sourcetree""]
    cmd = 'C:/Program Files/TortoiseGit/bin/TortoiseGitMerge.exe'  -base:\""$BASE\"" -mine:\""$LOCAL\"" -theirs:\""$REMOTE\"" -merged:\""$MERGED\""
    trustExitCode = true</code></pre>
<h4>2. 命令修改</h4>
<p>如果不加--global 修改的是当前项目git配置。</p>
<pre><code class=""bash"">$ git config --global --list // 查看全局配置
$ git config --global user.name hoby // 修改提交名
$ git config --global alias.br branch // 修改简写
$ git config --unset alias.co // 删除配置项
$ git config --global core.ignorecase false // 关闭忽略大小写</code></pre>
<h3>二、 Git密钥配置</h3>
<h4>1. 以SSH方式创建Git项目</h4>
<p><strong>1.）检查SSH Key存在</strong><br>如果存在id_rsa.pub 或 id_dsa.pub 文件，跳过此步。</p>
<pre><code>$ cd ~/.ssh    // 其实就在用户目录下有个.ssh的文件夹
$ ls</code></pre>
<p><strong>2.）创建SSH Key</strong><br>创建ssh key时会提示自定名称和push时的密码（不是git登录密码），一般推荐略过，直接三个回车，如果创建成功会出来一个有图案的小框框。</p>
<pre><code>$ ssh-keygen -t rsa -C ""your_email@example.com""  // 此处email可任意，不一定要gitLab登录邮箱</code></pre>
<p><strong>3.）查看SSH Key</strong><br>copy公钥内容到gitLab里，添加进去。</p>
<pre><code>$ cat ~/.ssh/id_rsa.pub</code></pre>
<p><strong>4.）测试SSH Key</strong></p>
<pre><code>$ ssh -T ""git@xxx.xxx.com""</code></pre>
<p><strong>5.）配置多个网站ssh密钥</strong><br>在生成每个网站ssh-key时，自定义名称不要一样，然后在~/.ssh目录下新建一个config文件，然后配置多个网站的ssh信息，内容如下：</p>
<pre><code># gitLab
Host dev.gitLab.com
HostName dev.gitLab.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa

# phabricator
Host 192.168.1.5
HostName 192.168.1.5
Port 22
PreferredAuthentications publickey
IdentityFile ~/.ssh/phabricator</code></pre>
<h4>2. 以HTTP(S)方式创建Git项目</h4>
<p>http(s)创建的项目，操作时总是提示用户名和密码，不胜其烦，以下方案可以让Git永远记住用户名与密码：</p>
<p><strong>1.）添加HOME变量</strong><br>在Windows用户变量中添加一个HOME环境变量，值为%USERPROFILE%，如下图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011168710"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>2.）创建_netrc文件</strong><br>在""开始&gt;运行""中打开%Home%，新建一个名为_netrc的文件，输入Git服务器名、用户名、密码保存，可放多个不同登录信息的Git项目，中间空一行即可，具体内容如下：</p>
<pre><code>machine dev.github.com
login hoby
password 123456</code></pre>
<h2>Git常用命令</h2>
<h3>一、仓库管理</h3>
<h4>1. 初始化</h4>
<p>初始化后，目录下会生成.git隐藏文件夹，图标显示git可控，.git目录下有一个hooks，里面可以对预提交信息做一些规范和限制。</p>
<pre><code>$ git init</code></pre>
<h4>2. 添加/修改仓库地址</h4>
<p>a.) 添加关联地址：</p>
<pre><code>$ git remote add origin http://dev.github.com:9800/root/front.git</code></pre>
<p>b.) 修改关联地址：</p>
<pre><code>$ git remote set-url origin http://dev.github.com:9800/root/front.git</code></pre>
<p>c.) 切换http(s)/ssh方式：</p>
<pre><code>$ git remote rm origin
$ git remote add origin ""git远程地址""
$ git push origin</code></pre>
<h4>3. 查看当前仓库地址</h4>
<pre><code>$ git remote -v</code></pre>
<h4>4. 创建本地仓库</h4>
<pre><code>$ git clone http://dev.github.com:9800/root/front.git</code></pre>
<p>会在当前目录下自动生成front的仓库目录，如果自定义文件夹名，后面空格后加上名称</p>
<h3>二、分支管理</h3>
<h4>1. 查看分支</h4>
<pre><code>$ git br    // 查看本地

$ git br -r // 查看远端

$ git br -a // 查看所有</code></pre>
<h4>2. 查看分支状态（推荐）</h4>
<p>可全面查看本地分支状态，远端对应关系，落后/优先多少，最后一次提交信息及hash值</p>
<pre><code>$ git br -vv</code></pre>
<h4>3. 创建分支</h4>
<p>a.) 创建本地分支：</p>
<p>本地分支名可不与远程一致，简单一点，方便Tab键补全，只要.gitconfig里的[push]项设置default = upstream即可，不然提交时，会提示本地与远程不一致</p>
<pre><code>$ git br &lt;branch&gt; &lt;origin-branch&gt; // 创建分支，并关联远端
或：
$ git co -b &lt;branch&gt; &lt;origin-branch&gt; // 创建分支并立即切换过去</code></pre>
<p>b.) 创建远程分支：（本地分支推送到远端）</p>
<pre><code>$ git push origin -u &lt;branch&gt;:&lt;origin-branch&gt; // -u：创建远程分支并关联，origin-branch不用带origin/路径</code></pre>
<h4>4. 切换分支</h4>
<pre><code>$ git co &lt;branch&gt;</code></pre>
<h4>5. 合并分支</h4>
<p>a.) 合并本地分支：</p>
<pre><code>$ git merge &lt;branch&gt; --no-ff  // --no-ff：关闭Fast-Foward合并，这样可以生成merge提交，保留分支合并信息</code></pre>
<p>会出来vim编辑窗口(可修改提交信息)，不修改则按shift + : 再输入wq（保存退出）后回车即可。</p>
<p>b.) 合并远端本地(不用先checkout到本地)：</p>
<pre><code>$ git merge &lt;origin-branch&gt; --no-ff  // 推荐这样使用，因为从远端merge能保证永远是最新的</code></pre>
<p>c.) 取消合并：</p>
<pre><code>$ git merge --abort</code></pre>
<p>d.) 合并冲突处理：</p>
<pre><code>$ git mergetool  // 如果在~/.gitconfig下正确配置了比较工具，会依次弹出比较窗口，处理后保存
$ git clean -nfd  // 查看不在版本库中合并文件，以.org结尾
$ git clean -fd   // 确认无误后，移除这个.org临时文件
$ git add -A
$ git merge --continue  // 继续完成merge流程</code></pre>
<h4>6. 修改分支</h4>
<p>a.) 修改分支名称：</p>
<pre><code>$ git br -m &lt;branchName&gt;</code></pre>
<p>b.) 修改当前分支远端关联：</p>
<pre><code>$ git br --set-upstream-to &lt;origin-branch&gt;</code></pre>
<p>c.) 修改指定分支远端关联：</p>
<pre><code>$ git br --set-upstream &lt;branch&gt; &lt;origin-branch&gt;</code></pre>
<h4>7. 删除分支</h4>
<p>a.) 删除本地分支：</p>
<pre><code>$ git br -d &lt;branch&gt;</code></pre>
<p>b.) 强制删除本地分支：</p>
<pre><code>$ git br -D &lt;branch&gt;  // 未被合并的分支被删除的时候需要强制</code></pre>
<p>c.) 删除远端分支：</p>
<pre><code>$ git push origin --delete &lt;branch&gt;
或：
$ git push origin :&lt;branch&gt;  // 推送一个空分支到远端，即删除</code></pre>
<h4>8. 更新分支</h4>
<p>从远端拉取最新的分支信息，更新本地缓存</p>
<pre><code>$ git fetch -p   // 更新被删除的分支</code></pre>
<h3>三、查看管理</h3>
<h4>1. 查看当前状态</h4>
<pre><code>$ git st  // 查看当前工作状态</code></pre>
<h4>2. 查看提交记录</h4>
<p>a.) 查看全部提交记录：</p>
<pre><code>$ git lg</code></pre>
<p>b.) 查看单个文件所有记录：</p>
<pre><code>$ git lg &lt;fileName&gt;</code></pre>
<p>c.) 查看单个文件修改详情：</p>
<pre><code>$ git lg -p &lt;fileName&gt;  // 可查看比较文件历史修改记录</code></pre>
<p>d.) 查看单条记录详情：</p>
<pre><code>$ git show &lt;commit-id&gt;  // 日志的hash值</code></pre>
<p>e.) 查找所有包括指定字符串文件：</p>
<pre><code>$ git grep -n &lt;string&gt;  // -n：显示字符串所在的行数</code></pre>
<h4>3. 查看比较文件</h4>
<p>a.) 查看比较文件：（与暂存区比较）</p>
<p>如果当前文件没被修改，需要查看历史修改情况，用上面的git lg -p fileName</p>
<pre><code>$ git diff &lt;fileName&gt;  // 比较当前文件和暂存区文件差异，应用在提交前确认的场景</code></pre>
<p>b.) 比较两次提交记录：</p>
<pre><code>$ git diff &lt;commit-id1&gt; &lt;commit-id2&gt; // 比较两次提交之间的差异</code></pre>
<h4>4. 查看历史操作记录</h4>
<p>每一次当前HEAD发生改变（包括切换branch, pull, 添加新commit）一个新的纪录就会被添加到reflog</p>
<pre><code>$ git reflog</code></pre>
<h3>四、操作管理</h3>
<h4>1. 更新</h4>
<p>a.) 非快进更新：</p>
<pre><code>$ git pull --no-ff</code></pre>
<p>b.) 基于rebase：</p>
<p>这个命令会迫使git将远程分支上的变更同步到本地，然后将尚未推送的提交重新应用到这个最新版本，就好象它们刚刚发生一样，这样就可以避免合并以及随之而来的丑陋的合并信息</p>
<pre><code>$ git pull --rebase   // 避免产生无用的合并信息</code></pre>
<p>例：当前状态为 <em> master  c7bcf10 [origin/master: ahead 1, behind 1] </em> [cps-bk] add a.js<br>此时用--rebase只产生1 commit，而普通的git pull会产生2 commits，其中一条是没必要的合并信息。</p>
<p>若--rebase冲突了，解决方案：</p>
<pre><code>$ git add -A   // 强制添加到
$ git rebase --continue
$ git push</code></pre>
<p>c.) 临时更新：（暂存）</p>
<pre><code>$ git stash      // 先放入暂存区
$ git pull
$ git stash pop  // 恢复显示工作内容，或用git stash apply stash@{n}挑选恢复哪个</code></pre>
<p>d.) 管理暂存：</p>
<pre><code>$ git stash list    // 显示暂存列表
$ git stash clear   // 清除暂存列表</code></pre>
<h4>2. 提交</h4>
<p>a.) 多个修改，只提交部分：</p>
<pre><code>$ git add &lt;file1&gt; &lt;file2&gt;   // 只添加要提交的到本地暂存区
$ git ci -m 'commit info'   // -m处不加a
$ git push</code></pre>
<p>b.) 提交全部：</p>
<pre><code>$ git add .               // 有新文件时，一定要
$ git ci -am 'commit info'
$ git push</code></pre>
<p>c.) 追加提交：（未push到远端） <br>将最近一次的变更追加到最新的提交，同时也可以编辑提交信息，不产生新的提交记录。</p>
<pre><code>$ git ci --amend   // 如果已push到远端，不建议追加，容易跟自己冲突
$ git push</code></pre>
<p>d.) 提交时绕过pre-commit验证：</p>
<pre><code>git ci -am 'commit info' --no-verify</code></pre>
<h4>3. 提取</h4>
<p>从别的分支同步一个commit到本分支</p>
<pre><code>$ git cherry-pick &lt;commit-id&gt;</code></pre>
<h3>五、恢复管理</h3>
<h4>1. 恢复本地</h4>
<p>a.) 已修改，未暂存：</p>
<pre><code>$ git co &lt;fileName|directory&gt;  // 恢复单个文件或目录</code></pre>
<pre><code>$ git co .  // 恢复全部</code></pre>
<p>b.) 已暂存，未提交：</p>
<pre><code>$ git reset HEAD^   // 向前回滚一条记录，相当于HEAD~1
$ git co .</code></pre>
<p>c.) 恢复前N条：</p>
<pre><code>$ git reset HEAD~n   // 默认省略--soft参数，属于软恢复，n&gt;=1整数</code></pre>
<p>d.) 硬恢复：</p>
<pre><code>$ git reset --hard HEAD~n|&lt;commit-id&gt;   // 不保留当前修改，要当心，确认当前修改没有用了</code></pre>
<h4>2. 恢复远端</h4>
<p>a.) 单次回滚： <br>git revert 会产生一个新的与之前commit相反的操作，来抵消之前错误的提交</p>
<pre><code>$ git revert &lt;commit-id&gt;   // 也可以多次操作，达到恢复多个的目的
$ git push</code></pre>
<p>b.) 指定位置：</p>
<pre><code>$ git reset --hard &lt;commit-id&gt;   // 恢复到当前位置
$ git push -f      // 要加-f强制推送</code></pre>
<p>c.) 挑选模式：</p>
<pre><code>$ git rebase -i &lt;commit-id&gt;  // 会打开编辑，剔除挑选记录
$ git push -f      // 要加-f强制推送</code></pre>
<h3>六、其它命令</h3>
<h4>1. 临时忽略文件</h4>
<p>a.) 忽略跟踪：<br>.gitignore只能忽略那些原来没有被跟踪的文件，如果文件已被纳入版本管理中，则修改.gitignore是无效的。</p>
<pre><code>$ git update-index --assume-unchanged &lt;file&gt;</code></pre>
<p>b.) 恢复跟踪：</p>
<pre><code>$ git update-index --no-assume-unchanged &lt;file&gt;</code></pre>
<p>c.) 查看被忽略的跟踪：</p>
<pre><code>$ git ls-files -v|grep '^h'</code></pre>
<p>d.) 另一个类似的功能：</p>
<pre><code>$ git update-index --skip-worktree &lt;file&gt;  // 忽略

$ git update-index --no-skip-worktree &lt;file&gt;  // 恢复</code></pre>
<h4>2. 清理</h4>
<p>a.) 移除版本控制：</p>
<pre><code>$ git rm &lt;file&gt; --cached    // -r：移除目录， --cached：保留本地的文件</code></pre>
<p>b.) 清理工作树：</p>
<pre><code>$ git clean -fd    // 移除未跟踪的文件和目录，如果加上-n参数来先看看会删掉哪些文件</code></pre>
<p>c.) 垃圾回收：</p>
<p>Git 往磁盘保存对象时默认使用的格式叫松散对象(loose object)格式，当手动执行git gc 命令，或推送至远程服务器时，Git会将这些对象打包至一个叫packfile的二进制文件以节省空间并提高效率。</p>
<pre><code>$ git gc --auto
$ git repack -d -l  </code></pre>
<h4>3. 帮助</h4>
<pre><code>$ git help</code></pre>
<p>或查看某一条指令参数：</p>
<pre><code>git &lt;command&gt; -n</code></pre>

                ", Git基本配置与用法,1531977793,406,1,145,1,1,https://segmentfault.com/a/1190000011168654
94,1,0,7,"
                    
<h2>Git在我们的开发过程中必不可少，所以我记录了一些自己工作中常用的命令：</h2>
<p><a href=""https://github.com/CodeLittlePrince/blog/issues/1"" rel=""nofollow noreferrer"">原文请见我的github&gt;&gt;</a></p>
<ul>
<li>
<p>初始化</p>
<ul><li>git init</li></ul>
</li>
<li>
<p>克隆项目</p>
<ul><li>git clone</li></ul>
</li>
<li>
<p>长期保存密码</p>
<ul><li>git config --global credential.helperstore</li></ul>
</li>
<li>
<p>获取分支</p>
<ul><li>git fetch origin</li></ul>
</li>
<li>
<p>合并分支</p>
<ul><li>git merge</li></ul>
</li>
<li>
<p>获取并且合并分支</p>
<ul><li>git pull origin</li></ul>
</li>
<li>
<p>切换分支</p>
<ul><li>git checkout</li></ul>
</li>
<li>
<p>新建并切换到分支</p>
<ul><li>git checkout -b</li></ul>
</li>
<li>
<p>删除分支</p>
<ul><li>git branch -d</li></ul>
</li>
<li>
<p>查看修改状态</p>
<ul><li>git status</li></ul>
</li>
<li>
<p>查看所有的修改内容</p>
<ul><li>git diff</li></ul>
</li>
<li>
<p>查看指定文件修改内容</p>
<ul><li>git diff &lt;file&gt;</li></ul>
</li>
<li>
<p>添加指定文件到暂存区</p>
<ul><li>git add</li></ul>
</li>
<li>
<p>添加所有文件到暂存区</p>
<ul><li>git add all</li></ul>
</li>
<li>
<p>查看已经在提交区（即已经add了的）所有修改内容</p>
<ul><li>git diff --cached</li></ul>
</li>
<li>
<p>提交暂存区修改到本地</p>
<ul><li>git commit -m """"</li></ul>
</li>
<li>
<p>修改刚才提交的描述</p>
<ul><li>git commit --amend -m """"</li></ul>
</li>
<li>
<p>提交本地版本到远端</p>
<ul><li>git push origin</li></ul>
</li>
<li>
<p>其他分支有紧急问题，需要马上切过去处理，但当前分支又只改了一半，又不想commit</p>
<ul><li>git stash</li></ul>
</li>
<li>
<p>处理完其他分支的紧急问题以后，回到原先分支继续修改</p>
<ul><li>git stash pop</li></ul>
</li>
<li>
<p>清除所有没有add了的修改</p>
<ul><li>git checkout .</li></ul>
</li>
<li>
<p>清除指定没有add了的文件的修改</p>
<ul><li>git checkout</li></ul>
</li>
<li>
<p>清除untracked的文件</p>
<ul><li>git clean -fd</li></ul>
</li>
<li>
<p>清除git ignore了的文件</p>
<ul><li>git clean -x</li></ul>
</li>
<li>
<p>commit了修改到本地，想放弃这个commit</p>
<ul><li>git reset HEAD~</li></ul>
</li>
<li>
<p>commit了修改到本地，想放弃这个commit，并清空修改</p>
<ul><li>git reset --hard HEAD~</li></ul>
</li>
<li>
<p>commit了修改到本地，想恢复特定文件成指定的历史版本</p>
<ul><li>git checkout  --</li></ul>
</li>
<li>
<p>打标签</p>
<ul><li>git tag -a v1.0 -m ""somthing message""</li></ul>
</li>
<li>
<p>删除标签</p>
<ul><li>git tag -d v1.0</li></ul>
</li>
<li>
<p>列出所有标签</p>
<ul><li>git tag</li></ul>
</li>
<li>
<p>推送特定标签到远端</p>
<ul><li>git push origin v1.0</li></ul>
</li>
<li>
<p>推送所有标签到远端</p>
<ul><li>git push origin --tags</li></ul>
</li>
<li>
<p>删除远端tag</p>
<ul><li>git push origin -d tag v1.0</li></ul>
</li>
</ul>

                ", Git 面对不同的场景的命令使用,1531977794,330,1,111,1,1,https://segmentfault.com/a/1190000011127874
95,1,0,7,"
                    
<h1>HTML5</h1>
<ol>
<li><a href=""http://webres.wang/8-html5-css3-website-templates/"" rel=""nofollow noreferrer"">8个新的响应式HTML5 CSS3网站模版</a></li>
<li><a href=""http://webres.wang/50-free-html5-web-templates/"" rel=""nofollow noreferrer"">50+ 个免费的响应式 HTML5 网站模版</a></li>
</ol>
<h1>CSS3</h1>
<ol>
<li><a href=""http://webres.wang/10-characters-in-pure-css/"" rel=""nofollow noreferrer"">10 个由纯 CSS 实现的动画角色</a></li>
<li><a href=""http://webres.wang/20-css-libraries-for-developers/"" rel=""nofollow noreferrer"">Web 开发中 20 个很有用的 CSS 库</a></li>
<li><a href=""http://webres.wang/css-tools-frameworks-libraries-2015-first/"" rel=""nofollow noreferrer"">CSS 工具、框架、库合集(1-26)</a></li>
<li><a href=""http://webres.wang/css-tools-frameworks-libraries-2015-second/"" rel=""nofollow noreferrer"">CSS 工具、框架、库合集(27-54)</a></li>
<li><a href=""http://webres.wang/18-css3-loading-effect/"" rel=""nofollow noreferrer"">CSS3实现18种Loading效果</a></li>
<li><a href=""http://webres.wang/css-libraries-for-adding-image-hover-effects/"" rel=""nofollow noreferrer"">8 个为图片添加 Hover 效果的 CSS 库</a></li>
<li><a href=""http://webres.wang/8-awesome-css-filter-libraries-tools/"" rel=""nofollow noreferrer"">8 个 Awesome CSS 过滤库 &amp; 工具</a></li>
</ol>
<h1>JavaScript</h1>
<ol>
<li><a href=""http://webres.wang/15-best-javascript-charting-libraries/"" rel=""nofollow noreferrer"">15个最棒的JavaScript图形/图表库</a></li>
<li><a href=""http://webres.wang/2015-best-javascript-frameworks/"" rel=""nofollow noreferrer"">2015年最棒的10个 JavaScript 框架</a></li>
<li><a href=""http://webres.wang/10-javascript-notification-plugins/"" rel=""nofollow noreferrer"">JavaScript消息通知插件</a></li>
</ol>
<h1>JQuery</h1>
<ol>
<li><a href=""http://webres.wang/free-table-jquery-plugins/"" rel=""nofollow noreferrer"">推荐十个最新免费的 jQuery 表格插件</a></li>
<li><a href=""http://webres.wang/11-best-jquery-charting-libraries/"" rel=""nofollow noreferrer"">11个很棒的 jQuery 图表库</a></li>
<li><a href=""http://webres.wang/responsive-jquery-carousel-slider-plugins-2015/"" rel=""nofollow noreferrer"">10个免费的响应式jQuery Carousel 轮播图插件</a></li>
<li><a href=""http://webres.wang/10-best-video-jquery-plugins-web-developers/"" rel=""nofollow noreferrer"">为Web程序员准备的10个最棒的jQuery视频插件</a></li>
<li><a href=""http://webres.wang/best-and-useful-jquery-parallax-scrolling-tutorials/"" rel=""nofollow noreferrer"">jQuery视差滚动效果教程与插件</a></li>
<li><a href=""http://webres.wang/new-jquery-plugins-for-november-2015/"" rel=""nofollow noreferrer"">jQuery插件</a></li>
<li><a href=""http://webres.wang/16-jquery-modal-dialog-boxes/"" rel=""nofollow noreferrer"">16个 jQuery 模态弹出框/对话框</a></li>
<li><a href=""http://webres.wang/15-fantastic-free-jquery-sliders-for-bootstrap-sites/"" rel=""nofollow noreferrer"">适用于 BootStrap 站点的 15 个免费 jQuery 轮播图插件</a></li>
<li><a href=""http://webres.wang/10-jquery-time-picker-plugins/"" rel=""nofollow noreferrer"">10 个 jQuery 时间选择器插件</a></li>
<li><a href=""http://webres.wang/12-jquery-selectboxdrop-down-plugins/"" rel=""nofollow noreferrer"">12 个 jQuery selectBox / DropDown 插件</a></li>
<li><a href=""http://webres.wang/10-jquery-video-audio-player-plugins/"" rel=""nofollow noreferrer"">10 个响应式的 jQuery Audio &amp; Video 播放器插件</a></li>
</ol>
<h1>工具</h1>
<ol>
<li><a href=""http://webres.wang/7-amazing-gulp-plugins/"" rel=""nofollow noreferrer"">7个非常棒的 Gulp 插件</a></li>
<li><a href=""http://webres.wang/2015-best-angularjs-tools-for-web-developers/"" rel=""nofollow noreferrer"">11个很棒的 AngularJS 工具</a></li>
</ol>
<h1>资源</h1>
<ol>
<li><a href=""http://webres.wang/18-resources-learn-flexbox/"" rel=""nofollow noreferrer"">18个学习 flexbox 的优质资源</a></li>
<li><a href=""http://webres.wang/20-docs-guides-front-end-developers/"" rel=""nofollow noreferrer"">20个对前端开发人员有用的文档和指南</a></li>
<li><a href=""http://webres.wang/essential-sublime-text-javascript-plugins/"" rel=""nofollow noreferrer"">JavaScript 开发者必备的10款 Sublime Text 插件</a></li>
<li><a href=""http://webres.wang/20-docs-guides-front-end-developers-7/"" rel=""nofollow noreferrer"">对前端开发者有用的文档及指南</a></li>
<li><a href=""http://webres.wang/sublime-text-3-license-key/"" rel=""nofollow noreferrer"">Sublime Text (3103版本可用) 注册码 License Key</a></li>
</ol>
<h1>站点</h1>
<ol><li><a href=""http://webres.wang/14-code-demo-sites/"" rel=""nofollow noreferrer"">14个代码展示网站</a></li></ol>
<h1>动画库</h1>
<ol><li><a href=""http://webres.wang/top-9-animation-libraries-use-2016/"" rel=""nofollow noreferrer"">9个顶级动画库</a></li></ol>

                ", 前端工具模板,1531977795,237,1,278,1,1,https://segmentfault.com/a/1190000011123426
96,1,0,7,"
                    
<h1>H5系列</h1>
<ul>
<li><a href=""http://webres.wang/10-quick-ways-optimize-page-load-time/"" rel=""nofollow noreferrer"">10种优化页面加载速度的方法</a></li>
<li><a href=""http://www.cnblogs.com/Wayou/category/467061.html"" rel=""nofollow noreferrer"">随笔分类 - HTML5</a></li>
<li><a href=""http://www.techug.com/post/40-important-html-5-interview-questions-with-answers.html"" rel=""nofollow noreferrer"">HTML5中40个最重要的技术点</a></li>
<li><a href=""http://webres.wang/html-meta/"" rel=""nofollow noreferrer"">常用meta整理</a></li>
<li><a href=""http://webres.wang/web-page-performance-in-depth/"" rel=""nofollow noreferrer"">网页性能管理详解</a></li>
<li><a href=""http://yanhaijing.com/html/2014/12/28/html5-manifest/"" rel=""nofollow noreferrer"">HTML5 离线缓存-manifest简介</a></li>
</ul>
<h1>JS系列</h1>
<ul>
<li><a href=""http://www.codeceo.com/article/javascript-high-performance.html"" rel=""nofollow noreferrer"">编写高性能JavaScript</a></li>
<li><a href=""http://yanhaijing.com/javascript/2014/01/17/fun-with-javascript-native-array-functions/"" rel=""nofollow noreferrer"">有趣的JavaScript原生数组函数</a></li>
<li><a href=""http://www.codeceo.com/article/javascript-data-access.html"" rel=""nofollow noreferrer"">JavaScript数据访问性能优化方案</a></li>
<li><a href=""http://www.codeceo.com/article/javascript-9-sort-algorithms.html"" rel=""nofollow noreferrer"">JavaScript实现的9大排序算法</a></li>
<li><a href=""http://justjavac.com/javascript/2008/11/11/arguments-a-javascript-oddity.html"" rel=""nofollow noreferrer"">javascript 一怪——arguments 对象</a></li>
<li><a href=""http://webres.wang/68-javascript-functions/"" rel=""nofollow noreferrer"">JavaScript常用方法函数收集</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/09/01/array-use/"" rel=""nofollow noreferrer"">数组的操作</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/05/28/js-inherit/"" rel=""nofollow noreferrer"">JavaScrip面向对象和原型继承</a></li>
<li><a href=""http://www.zcfy.cc/article/gentle-explanation-of-this-keyword-in-javascript-901.html"" rel=""nofollow noreferrer"">JavaScript中‘this’关键词的优雅解释</a></li>
<li><a href=""https://my.oschina.net/os2015/blog/484017"" rel=""nofollow noreferrer"">《浅谈JavaScript系列》系列技术文章整理收藏</a></li>
<li><a href=""http://blog.csdn.net/VLilyV/article/details/72838439?locationNum=16&amp;fps=1"" rel=""nofollow noreferrer"">委托事件，事件冒泡，事件捕获，this，target总结</a></li>
<li><a href=""http://www.bootcss.com/p/underscore/"" rel=""nofollow noreferrer"">Underscore.js 中文文档</a></li>
<li><a href=""http://webres.wang/top-10-must-follow-javascript-best-practices/"" rel=""nofollow noreferrer"">10 个你需要了解的最佳 JavaScript 开发实践</a></li>
<li><a href=""http://webres.wang/12-rules-for-professional-javascript-in-2015/"" rel=""nofollow noreferrer"">12条专业的JavaScript规则</a></li>
<li><a href=""http://webres.wang/javascript-loop-functions-detail/"" rel=""nofollow noreferrer"">JavaScript 各种遍历方式详解</a></li>
<li><a href=""http://webres.wang/js-this-trap-collections/"" rel=""nofollow noreferrer"">JavaScript中的this陷阱的最全收集</a></li>
<li><a href=""http://webres.wang/201602-javascript-patterns/"" rel=""nofollow noreferrer"">常用的 JavaScript 模式</a></li>
<li><a href=""http://webres.wang/12-extremely-useful-hacks-for-javascript/"" rel=""nofollow noreferrer"">12 个非常有用的 JavaScript Hacks</a></li>
<li><a href=""http://webres.wang/10-javascript-concepts-nodejs-programmers-must-master/"" rel=""nofollow noreferrer"">10个JavaScript难点</a></li>
<li><a href=""http://webres.wang/9-chrome-console-skills-for-js-debug/"" rel=""nofollow noreferrer"">九个Console命令，让js调试更简单</a></li>
<li><a href=""http://yanhaijing.com/javascript/2014/04/23/seven-javascript-quirks-i-wish-id-known-about/"" rel=""nofollow noreferrer"">我希望我知道的七个JavaScript技巧</a></li>
<li><a href=""http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/"" rel=""nofollow noreferrer"">了解JavaScript的执行上下文</a></li>
<li><a href=""http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/"" rel=""nofollow noreferrer"">JavaScript的作用域和提升机制</a></li>
<li><a href=""http://yanhaijing.com/javascript/2016/07/24/prototype-and-inheritance-of-js/"" rel=""nofollow noreferrer"">详解JavaScript中的原型和继承</a></li>
<li><a href=""http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/"" rel=""nofollow noreferrer"">JavaScript对象继承一瞥</a></li>
<li><a href=""http://yanhaijing.com/javascript/2015/05/08/member-of-object/"" rel=""nofollow noreferrer"">细说JavaScript中对象的属性和方法</a></li>
</ul>
<h1>JQ系列</h1>
<ul>
<li><a href=""http://jquery.cuishifeng.cn/index.html"" rel=""nofollow noreferrer"">jQuery API 中文文档</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/05/19/each-use/"" rel=""nofollow noreferrer"">jquery中each的用法</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/04/06/jquery-skill/"" rel=""nofollow noreferrer"">jquery小技巧</a></li>
<li><a href=""http://www.cnblogs.com/Wayou/category/566742.html"" rel=""nofollow noreferrer"">随笔分类 - jQuery</a></li>
<li><a href=""http://webres.wang/10-jquery-tips-everyone-should-know/"" rel=""nofollow noreferrer"">10个 jQuery 小技巧</a></li>
</ul>
<h1>CSS系列</h1>
<ul>
<li><a href=""http://webres.wang/clearfix-history/"" rel=""nofollow noreferrer""> clearfix清除浮动进化史</a></li>
<li><a href=""http://webres.wang/a-collection-of-css-protips/"" rel=""nofollow noreferrer"">CSS 专业技巧收集</a></li>
<li><a href=""http://webres.wang/31-css-code-snippets-to-make-you-a-better-coder/"" rel=""nofollow noreferrer"">30+有用的CSS代码片段</a></li>
<li><a href=""http://webres.wang/you-don-t-need-javascript-for-that/"" rel=""nofollow noreferrer"">这些地方你不需要使用 JavaScript</a></li>
<li><a href=""http://webres.wang/the-css-target-trick/"" rel=""nofollow noreferrer"">CSS 伪类 :target 的黑科技</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/08/19/flex-use/"" rel=""nofollow noreferrer"">flex布局flex布局</a></li>
<li><a href=""https://css-tricks.com/centering-css-complete-guide/"" rel=""nofollow noreferrer"">Centering in CSS: A Complete Guide(CSS居中完全指南)</a></li>
<li><a href=""http://yanhaijing.com/css/2014/03/26/starting-to-write-css/"" rel=""nofollow noreferrer"">开始写 CSS 吧</a></li>
<li><a href=""http://yanhaijing.com/css/2014/04/01/grids-in-css3/"" rel=""nofollow noreferrer"">CSS3中的网格</a></li>
<li><a href=""http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html"" rel=""nofollow noreferrer"">Flex 布局教程：语法篇</a></li>
<li><a href=""http://www.ruanyifeng.com/blog/2015/07/flex-examples.html"" rel=""nofollow noreferrer"">Flex 布局教程：实例篇</a></li>
<li><a href=""http://yanhaijing.com/css/2014/05/17/12-little-known-css-facts/"" rel=""nofollow noreferrer"">12个很少被人知道的CSS事实</a></li>
</ul>
<h1>响应式</h1>
<ul><li><a href=""http://webres.wang/5-responsive-design-pitfalls-and-how-to-avoid-them/"" rel=""nofollow noreferrer"">5个常见响应式设计陷阱及解决方案</a></li></ul>
<h1>正则表达式</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/03/28/regular-use/"" rel=""nofollow noreferrer"">正则表达式（上篇）</a></li>
<li><a href=""http://www.ayqy.net/blog/category/regex/"" rel=""nofollow noreferrer"">分类目录归档：Regular_Expression</a></li>
<li><a href=""http://www.cnblogs.com/yugege/p/4821016.html"" rel=""nofollow noreferrer"">正则表达式学习笔记</a></li>
<li><a href=""http://yanhaijing.com/javascript/2017/08/06/regexp-syntax/"" rel=""nofollow noreferrer"">正则表达式教程——语法篇</a></li>
<li><a href=""http://yanhaijing.com/javascript/2017/08/26/regexp-practice/"" rel=""nofollow noreferrer"">正则表达式教程——实践篇</a></li>
<li><a href=""http://www.cnblogs.com/yugege/p/4821494.html"" rel=""nofollow noreferrer"">正则表达式元字符详解</a></li>
</ul>
<h1>面试</h1>
<ul>
<li><a href=""http://webres.wang/front-end-developer-interview-questions/"" rel=""nofollow noreferrer"">前端工作面试问题汇总</a></li>
<li><a href=""http://webres.wang/about-front-end-interview/"" rel=""nofollow noreferrer"">前端面试资源</a></li>
<li><a href=""http://www.cnblogs.com/coco1s/p/4029708.html"" rel=""nofollow noreferrer"">BAT及各大互联网公司2014前端笔试面试题--JavaScript篇</a></li>
<li><a href=""http://www.cnblogs.com/coco1s/p/4034937.html"" rel=""nofollow noreferrer"">BAT及各大互联网公司2014前端笔试面试题--Html,Css篇</a></li>
</ul>
<h1>ES6</h1>
<ul>
<li><a href=""http://es6.ruanyifeng.com/"" rel=""nofollow noreferrer"">ECMAScript 6 入门</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/08/25/es6-str/"" rel=""nofollow noreferrer"">ES6展开运算符</a></li>
<li><a href=""https://segmentfault.com/a/1190000003410285"" rel=""nofollow noreferrer"">ES6 的模块系统</a></li>
<li><a href=""http://yanhaijing.com/javascript/2015/09/11/learn-es2015/"" rel=""nofollow noreferrer"">ECMAScript 2015 简易教程</a></li>
</ul>
<h1>Promise</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/09/07/fech/"" rel=""nofollow noreferrer"">fetch用法说明</a></li>
<li><a href=""http://yanhaijing.com/javascript/2015/09/16/es6-promise/"" rel=""nofollow noreferrer"">快来使用ES2015的Promise吧</a></li>
</ul>
<h1>Babel</h1>
<ul><li><a href=""https://lingmissing.github.io/myBlog/2017/01/09/bable-basic/"" rel=""nofollow noreferrer"">Babel 入门教程</a></li></ul>
<h1>Node.Js</h1>
<ul>
<li><a href=""http://koa.bootcss.com/#"" rel=""nofollow noreferrer"">Koa (koajs) -- 基于 Node.js 平台的下一代 web 开发框架 | Koajs 中文文档</a></li>
<li><a href=""https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001471087582981d6c0ea265bf241b59a04fa6f61d767f6000"" rel=""nofollow noreferrer"">koa入门</a></li>
<li><a href=""http://www.expressjs.com.cn/"" rel=""nofollow noreferrer"">Express - 基于 Node.js 平台的 web 应用开发框架</a></li>
<li><a href=""https://github.com/alsotang/node-lessons/"" rel=""nofollow noreferrer"">Node.js 包教不包会</a></li>
<li><a href=""http://www.cnblogs.com/Wayou/p/hichat_built_with_nodejs_socket.html"" rel=""nofollow noreferrer"">Node.js + Web Socket 打造即时聊天程序嗨聊</a></li>
<li><a href=""http://www.ayqy.net/blog/category/node/"" rel=""nofollow noreferrer"">分类目录归档：Node</a></li>
<li><a href=""https://yjhjstz.gitbooks.io/deep-into-node/content/"" rel=""nofollow noreferrer"">深入理解Node.js：核心思想与源码分析</a></li>
</ul>
<h1>Vue.js</h1>
<ul>
<li><a href=""https://www.vue-js.com/"" rel=""nofollow noreferrer"">Vue：Vue.js专业中文社区</a></li>
<li><a href=""https://cn.vuejs.org/v2/guide/index.html"" rel=""nofollow noreferrer"">Vue.js教程</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2017/01/03/canvas-draw/"" rel=""nofollow noreferrer"">利用vue制作在线涂鸦板</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/12/23/vue-special/"" rel=""nofollow noreferrer"">vue使用总结</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/09/27/vue-1/"" rel=""nofollow noreferrer"">Vue 2.0的变化（一）之基本API变化</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/12/09/vue-2/"" rel=""nofollow noreferrer"">Vue 2.0 的变化（二）</a></li>
</ul>
<h1>React</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2017/03/10/react-hoc/"" rel=""nofollow noreferrer"">深入理解react高阶组件</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/12/12/react-audio/"" rel=""nofollow noreferrer"">基于react的audio组件</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/08/16/react-life/"" rel=""nofollow noreferrer"">React组件生命周期</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/08/16/react-router-basic/"" rel=""nofollow noreferrer"">react-router使用总结</a></li>
</ul>
<h1>Redux</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/08/18/react-redux-basic/"" rel=""nofollow noreferrer"">react&amp;redux基础</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/09/29/redux-act/"" rel=""nofollow noreferrer"">Action构建工具（redux-act）</a></li>
</ul>
<h1>Angular.Js</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/14/angularjs-filter/"" rel=""nofollow noreferrer"">angularJs之过滤器</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/12/angularjs-router/"" rel=""nofollow noreferrer"">angularJs之路由</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/04/angularjs-directive-1/"" rel=""nofollow noreferrer"">AngularJs中的directive（一）</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/04/angularjs-provide/"" rel=""nofollow noreferrer"">AngularJs中的provide</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/06/angularjs-directive-2/"" rel=""nofollow noreferrer"">AngularJs中的directive（二）</a></li>
</ul>
<h1>Gulp</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/04/10/gulp-1/"" rel=""nofollow noreferrer"">gulp-前端构建入门</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/04/13/gulp-2/"" rel=""nofollow noreferrer"">gulp-团队协作进阶篇</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/04/15/gulp-3/"" rel=""nofollow noreferrer"">gulp-高手装X进阶篇</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/04/20/gulp-4/"" rel=""nofollow noreferrer"">gulp-API文档</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/06/15/gulp-5/"" rel=""nofollow noreferrer"">gulp-常用插件列表</a></li>
<li><a href=""http://webres.wang/7-amazing-gulp-plugins/"" rel=""nofollow noreferrer"">7个非常棒的 Gulp 插件</a></li>
</ul>
<h1>Webpack</h1>
<ul>
<li><a href=""https://lingmissing.github.io/myBlog/2016/07/08/webpack/"" rel=""nofollow noreferrer"">webpack</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2016/12/12/webpack-load-on-demand/"" rel=""nofollow noreferrer"">webpack按需加载</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2017/01/05/webpack-list-plugin/"" rel=""nofollow noreferrer"">webpack插件列表详解</a></li>
<li><a href=""https://lingmissing.github.io/myBlog/2017/03/08/webpack-hot-load/"" rel=""nofollow noreferrer"">webpack热更新</a></li>
</ul>
<h1>Typescript</h1>
<ul><li><a href=""https://lingmissing.github.io/myBlog/2016/09/30/typescript/"" rel=""nofollow noreferrer"">typescript</a></li></ul>
<h1>网络基本</h1>
<ul>
<li><a href=""https://wizardforcel.gitbooks.io/network-basic/content/"" rel=""nofollow noreferrer"">网络基本功系列</a></li>
<li><a href=""http://blog.csdn.net/u013485792/article/details/52100533"" rel=""nofollow noreferrer"">HTTP与TCP的区别和联系</a></li>
<li><a href=""http://www.ayqy.net/blog/category/http/"" rel=""nofollow noreferrer"">分类目录归档：HTTP</a></li>
</ul>
<h1>Express</h1>
<ul><li><a href=""https://lingmissing.github.io/myBlog/2016/12/19/json-server/"" rel=""nofollow noreferrer"">如何在本地模拟接口</a></li></ul>
<h1>React</h1>
<ul><li><a href=""https://ant.design/docs/react/introduce-cn"" rel=""nofollow noreferrer"">Ant Design of React</a></li></ul>
<h1>Weex</h1>
<ul><li><a href=""http://weex.apache.org/cn/"" rel=""nofollow noreferrer"">Weex</a></li></ul>
<h1>Lodash</h1>
<ul>
<li><a href=""http://www.css88.com/doc/lodash/"" rel=""nofollow noreferrer"">Lodash 中文文档(v4.16.1)</a></li>
<li><a href=""http://lodashjs.com/"" rel=""nofollow noreferrer"">lodash 中文网</a></li>
<li><a href=""http://lodashjs.com/docs/"" rel=""nofollow noreferrer"">lodash 中文文档</a></li>
</ul>
<h1>Zepto</h1>
<ul><li><a href=""http://www.css88.com/doc/zeptojs_api/"" rel=""nofollow noreferrer"">Zepto.js (1.2.0) API 中文文档-轻量级兼容jQuery的JavaScript库</a></li></ul>
<h1>Electron</h1>
<ul>
<li><a href=""https://wizardforcel.gitbooks.io/electron-doc/content/"" rel=""nofollow noreferrer"">Electron 中文文档</a></li>
<li><a href=""https://www.w3cschool.cn/electronmanual/"" rel=""nofollow noreferrer"">Electron 中文文档_w3cschool</a></li>
</ul>
<h1>Unity3D</h1>
<ul><li><a href=""http://www.ayqy.net/blog/category/unity3d/"" rel=""nofollow noreferrer"">分类目录归档：Unity3D </a></li></ul>
<h1>shell</h1>
<ul><li><a href=""https://lingmissing.github.io/myBlog/2017/01/19/shell-basic-md/"" rel=""nofollow noreferrer"">shell脚本基础知识</a></li></ul>

                ", 前端文档收集,1531977796,367,1,124,1,1,https://segmentfault.com/a/1190000011008253
97,1,0,7,"
                    
<h2>使用Git的操作流程</h2>
<h3><strong>1.Git的下载与安装</strong></h3>
<p>首先去 <a href=""https://git-scm.com/downloads"" rel=""nofollow noreferrer"">https://git-scm.com/downloads</a>  这个网站下载与自己电脑相匹配的Git的安装文件下载完毕后点击运行,一路点击next即可完成安装.</p>
<h3><strong>2.创建版本库</strong></h3>
<p>首先选择一个合适的地方,创建一个空目录,然后进入当前目录,在当前目录下右键,点击Git Bush,可以使用 pwd 命令来显示当前目录,接着使用 git init 命令把这个目录变成Git 可以管理的仓库然后你就会看到这个目录下多了一个.git的目录,这个目录就是 Git 来追踪和管理版本库的,如果系统默认隐藏了这类后缀名的文件你可能就会看不到,使用 ls-ah 命令就可以看见.</p>
<h3><strong>3.配置你的git仓库的用户邮箱和用户名</strong></h3>
<p>git config --global user.email ""your email""<br>git config --global user.email ""your name""</p>
<h3><strong>4.添加远程仓库</strong></h3>
<p><strong>常用的git操作命令</strong></p>
<p><strong>(1) git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 克隆远程仓库到本地</strong><br>我比较推荐: 去GitHub网站上创建一个项目仓库,复制仓库地址,然后再本地选择一个你想要存放这个项目的地方,新建一个空的文件夹,在这个文件夹下面右键选择git Bush,然后使用git clone &lt;你复制的地址&gt;,这里本地目录名省略则默认时当前目录,就可以把你的项目克隆到本地了.</p>
<p><strong>(2) git add 添加文件到暂存区</strong></p>
<ul><li>git add &lt;filepath&gt;</li></ul>
<p>添加你新建的文件到暂存区.</p>
<ul><li>git add .</li></ul>
<p>把工作时的所有变化提交到暂存区,包括文件内容修改(modified)以及新(new)文件,但不包括删除的文件("".""是匹配符,这里可以代指匹配所有).</p>
<ul><li>git add -u</li></ul>
<p>u(update的缩写),该命令仅监控已经被add的文件,它会将被修改的文件（即tracked file）提交到暂存区. 不会提交新文件(untracked file)</p>
<ul><li>git add -A</li></ul>
<p>是 git add .  和 git add -u  这两个命令功能的合集,提交所有修改的(modified)文件到暂存区,包括新文件(new).</p>
<ul><li>git add -i</li></ul>
<p>我们可以通过git add -i [&lt;path&gt;]命令查看&lt;path&gt;中被所有修改过或已删除文件但没有提交的文件，<br><strong>补充: 通过git add &lt;匹配符&gt;的方式你可以添加符合特定条件的文件,例如hello* 表示添加以hello开头的文件的修改添加到暂存区,具体的写法大家可以自行百度下^_^^_^</strong><br>git push -u origin master  //把本地库的所有内容推送到远程库上</p>
<p><strong>(3)git commit  提交修改的文件到工作区</strong></p>
<ul><li>git commit -m ""&lt;modify message&gt;""</li></ul>
<p>提交所有暂存区的文件</p>
<ul><li>git commit -am | -a -m ""&lt;modify message&gt;""</li></ul>
<p>提交所有被跟踪的修改过的文件,包括没有进入暂存区的文件</p>
<ul><li>git commit --amend</li></ul>
<p>取消上一次的提交</p>
<p><strong>(4) git pull   //从远程仓库拉取数据同步到本地</strong></p>
<p><strong>(5) git push   //从本地仓库推送(同步)修改到远程仓库</strong></p>
<p>关于git push 的几个扩展的用法</p>
<ul><li>git push -u origin master</li></ul>
<p>如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式如果想更改设置，可以使用git config命令。git config --global push.default matching OR git config --global push.default simple；可以使用git config -l 查看配置</p>
<ul><li>git push --all origin</li></ul>
<p>当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项</p>
<ul><li>git push --force origin git</li></ul>
<p>push的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。</p>
<h3><strong>5.查看仓库文件的状态</strong></h3>
<p>使用 git status 命令可以让我们时刻掌握仓库当前的状态,比如那些文件被修改,那些文件需要提交等等.</p>
<h3><strong>6.比对版本间某文件的差异</strong></h3>
<p>使用 git diff ""filename"" 就可以查看某个文件修改前后的版本的不同</p>
<h3><strong>7.查看版本日志</strong></h3>
<p>使用 git log 命令我们可以查看某个项目从最近到最远的提交日志.如果内容太多,可以试试加上 --pretty=online 来进行筛选.</p>
<h3><strong>8. 查看历史操记录 git reflog</strong></h3>
<p>git reflog 可以记录你的每一次命令,方便你随时查看历史操作记录</p>
<h3><strong>9. git checkout -- filename</strong></h3>
<p>git checkout -- filename 这一指令可以将修改过但还未commit的文件版本返回至最近一次commit或者add的状态.</p>
<h3><strong>10. 关于版本控制的小结</strong></h3>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。git checkout -- file 还可以一键还原误删的文件.<br>  场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。<br>  场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h3><strong>11.删除文件</strong></h3>
<pre><code>git rm filename
git commit -m ""remove a file""
</code></pre>
<h3><strong>12.Git 分支</strong></h3>
<pre><code>Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch &lt;name&gt;
切换分支：git checkout &lt;name&gt;
创建+切换分支：git checkout -b &lt;name&gt;
合并某分支到当前分支：git merge &lt;name&gt;

git merge --no-ff feature-x: 默认情况下,git执行""快进式合并"",使用--no-ff参数后,会执行正常合并,当删除eature-x分支后,从分支历史上还可以看到给分支信息,但是如果是快进式合并,删除分支后,会丢掉分支信息.

删除分支：git branch -d &lt;name&gt;
强制删除没有被合并的分支: git branch -D &lt;name&gt;</code></pre>
<h3><strong>13. 提交日志</strong></h3>
<pre><code>git log: 打印版本提交日志.</code></pre>
<h3><strong>14. 回退之前的版本Git reset</strong></h3>
<pre><code>git reset(HEAD默认指向当前版本,也就是最新提交的版本,HEAD^表示当前版本的上一个版本, HEAD^^表示当前版本的上上个版本, ~n表示当前版本的上n个版本):
* git reset HEAD filename: 将某个文件从暂存区回退到工作区.
* git reset --soft HEAD~n: 意为将版本软回退n个版本,所谓软回退表示将本地版本库的头指针全部重置到指定版本,且将这次提交之后的所有变更都移动到暂存区.
* git reset --mixed HEAD 8306e6eb46a(version code): 意为将版本硬回退到某一指定版本号对应的版本,将本地版本库的头指针全部重置到指定版本,且会重置缓存区,即本次提交之后的所有更改都会被移动到未暂存阶段.如果想要的工作区的代码也回退到这个版本,需要git pull一下,因为当前的HEAD指向了想要回退的那个版本,所以此时的更新就是相对于制定版本的更新.
* git reset --hard HEAD 8306e6eb46a(version code): 意为将版本硬回退到某一指定版本号对应的版本,但是不仅仅是将本地版本库的头指针全部重置到指定版本,也会重置暂存区,并将工作代码回退到这个版本,就是比--mixed多了一个git pull.
* git reset --help  查看帮助



</code></pre>
<hr>
<blockquote>这里讲一讲多分支开发的合并,在正规的项目中,我们经常会采用多分支开发,主分支master, 开发分支develop(开发者们开发合并代码的分支),热更新分支hotFix(临时的用于解决上线项目运行时候的bug的分支),切分支的方法git branch &lt;branchName&gt;,提交的方式是向管理员提交pull request,步骤如下:</blockquote>
<h3><strong>15. pull request</strong></h3>
<ul>
<li>第一步: git fetch --all: 拉取下来upstream,也就是拉取线上版本的代码,并将线上版本的代码和本地合并,并解决冲突.</li>
<li>第二步: 合并以后测试,没有问题后push本地代码.</li>
<li>第三步: 请求管理员把自己仓库的分支合并到原仓库的分支下,这就是pull request.</li>
</ul>
<p>点击New Merge Request,选择要合并的源分支和目标分支,并添加合并的相关信息,可以<br>在description中@某个项目成员,也可以设置Assignee指定某个项目成员,这样他们可以会收到邮件要求进行Code review.</p>
<ul><li>第四步: Code Review阶段,收到邮件的成员可以针对更新的代码提出自己的意见,确认代码没有问题,就可以Accept Merge Request了,这时候你的代码就会被合并到master这个线上版本代码的分支上了.</li></ul>
<h3><strong> 16. 隐藏当前工作现场 </strong></h3>
<p>当你正在写一个功能,这个时候你又需要切一个分支去修复bug,但是当前功能未写完,不想提交,就可以使用<code>git stash</code>命令,把当前工作区""隐藏""起来,等以后恢复现场后继续工作.<br>那么git stash帮我们把代码隐藏在哪里了呢? 通过指令<code>git stash list</code>可以查看所有暂存的stash工作区.<br>当你想要回来继续工作的时候,切回之前工作的分支,然后回复之前的状态有两个方法:</p>
<ul><li>git stash apply: 恢复,恢复后,stash内容并不删除,你需要git stash drop来删除</li></ul>
<p>;</p>
<ul><li>git stash pop: 恢复的同事吧stash的内容也删了.</li></ul>
<p>也可以多次stash,然后恢复指定的stash.</p>
<p><strong> 补充</strong>: <br>git rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>git rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。**</p>
<p><strong>说明:</strong> 记得养成良好的习惯,每次添加修改和删除文件的时候都要先添加到暂存区再提交,每一次提交的时候要写说明,修改了哪些地方,方便日后查看.</p>
<h3><strong>推荐阅读</strong></h3>
<p><a href=""https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000"" rel=""nofollow noreferrer"">廖雪峰的Git教程</a></p>

                ", GIT指令学习笔记,1531977798,124,1,422,1,1,https://segmentfault.com/a/1190000010997341
98,1,0,7,"
                    
<p>本博主前一段时间刚接触git，鉴于以前没有用过git，而且作为前端届中的一名有理想的菜鸟，应该要掌握git的基本使用，所以私下花了一些时间去学习了一下基本用法，在学习的过程中也总结了一些看法和心得，因此在这里分享一下。<br>   接下来主要分四个方面分享git：</p>
<ol>
<li><p>git的概念；</p></li>
<li><p>git仓库的初始化；</p></li>
<li><p>git的工作原理；</p></li>
<li><p>git常用的命令；</p></li>
</ol>
<hr>
<p><strong>1.git的概念：</strong><br>在说git之前，先说一下另一个版本控制系统---svn；<br>svn：集中式版本控制器，它有一个中央服务器，完整的项目版本就放在这个中央服务器上，每个开发者都要从中央服务器下载项目，然后再进行开发，最后上传给中央服务器。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUe8l?w=608&amp;h=280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>git的定义：git是分布式版本控制系统，适用于多人同时开发同一个项目的应用场景；<br>特点：不需要中央服务器，不用联网，每个开发者都拥有一套完整的项目版本，多人协助，且可以多分支开发，然后再合并。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUgaY?w=524&amp;h=318"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>2.git仓库的初始化</strong><br>仓库：版本库，项目的目录，仓库中的所有文件都交由git管理，包括修改，删除，恢复等；<br>假设在本地F盘的workplace中创建一个git仓库：<br>step1：切换到F盘中的workplace中；</p>
<pre><code> cd F:/
 cd workplace/
 mkdir testgit
 cd testgit/
 pwd //用来查看当前路径，从而判断路径是否正确</code></pre>
<p>当创建了目录后，可以在该目录下创建各种后缀名的文件，<br>最后创建该目录的git仓库：</p>
<pre><code>git init</code></pre>
<p>之后将目录中的文件添加到git仓库中（后面会介绍到）；</p>
<p><strong>3.git的工作原理</strong><br>在使用git时，应该知道几个专业名词：工作区，缓存区，版本库；<br>工作区：项目目录中除git仓库外（git仓库一般作为隐藏文件存在）；<br>缓存区：git仓库中的一个区域（stage区域）,专门用来存在临时性文件（就是git add添加的文件），stage区域是在git仓库中的index文件夹里；<br>版本库：git仓库所包含的文件，也就是stage区域中所要提交到的地方；</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUgcu?w=604&amp;h=437"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>首先：工作区中某个文件添加新的内容或者修改了某部分内容，添加或修改后可以将文件通过git add 添加到stage区；<br>其次：在stage区中会对文件中添加或者修改的内容进行处理；</p>
<ol>
<li><p>将新增内容或修改的内容放到Object区中，Object区会创建一个对象来存放该部分内容；</p></li>
<li><p>stage区会得到Object区中相对应的objectId并保存（objectId相当于一个索引）；</p></li>
</ol>
<p>最后：stage区通过git commit提交到本地的版本库，此时master会得到objectId，并根据objectId在Object区中找到相对应的内容；</p>
<p><strong>4.git常用的命令</strong></p>
<p>1.文件处理：</p>
<pre><code>git add filename //添加文件到stage区
git commit -m ""注释"" //将git add 到stage区中的文件提交到版本库
git  status  //查看当前stage区中文件是否commit
git diff filename //查看修改过的文件内容</code></pre>
<p>2.取消缓存（即文件还在stage区，没有commit ）</p>
<pre><code>git checkout --file //撤销在workspace区文件的修改，还需要撤销后git add 到stage区
git reset Head --file //撤销stage区文件的修改，恢复到上一版的模样
git rm -cached file //删除stage区中文件
git rm file //删除workspace和stage区中的文件</code></pre>
<p>3.版本处理：</p>
<pre><code>git log //查看历史版本
git reflog //查看版本号
git reset --hard 指定的版本号 //版本回退到指定的版本号
git reset --hard Head~N //指定回退到前N个的版本号</code></pre>
<p>4.分支处理</p>
<pre><code>git branch //查看当前分支
git branch branchName //创建分支
git checkout branchName //切换到指定分支
git checkout -b branchName //创建并切换到指定分支
git checkout -d branchName //删除分支
git merge branchName //将分支与master分支合并</code></pre>
<p>5.远程库操作</p>
<pre><code>git clone url //克隆远程仓库的一个项目版本到本地，并生成与项目名同名的目录（适用于首次）
git fetch //提取远程仓库数据来更新本地数据，但更新后还需要合并到开发者当前的分支上
git pull //提取远程仓库数据来更新本地数据，并尝试合并到开发者当前的分支上
git push [remoteName] [branchName] //将本地的分支推送到远程仓库同名分支上
git remote //查看远程仓库
git remote -v //查看远程仓库和url
git remote add name url //将本地仓库以name的名义推送到指定url的远程仓库
git remote rm  name //删除远程仓库</code></pre>
<p>6.代码暂存</p>
<pre><code>git stash //将当前工作区未提交的内容推送到git栈，然后工作区会变回原来的样子，可多次提交
git stash list //查看git栈中所有git stash放进去的版本号
git stash apply //将git栈中最近一次的版本号恢复到工作区中
git stash apply stash@{n} //将指定git栈中某个版本号恢复到工作区
git stash pop //语法和apply一致，不同的是apply恢复后不会删除git栈中恢复的版本，而pop则会
git stash clean //清楚git栈</code></pre>
<p>以上就是博主对git的初步认识，git的用法远不止以上这些，所以还需要在日后的项目开发中补充git的知识。</p>

                ", git的基本用法,1531977799,378,1,94,1,1,https://segmentfault.com/a/1190000010990751
99,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010953149"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 Kubernetes 容器云平台于众多企业里遍地实施开花后，迅速结出的果实：应用微服务化当仁不让的居于首位。众所周知，基于容器平台构建后端服务，可以更加迅速的实现业务微服务化，与之而来的框架选型讨论也迅速火热了起来。</p>
<h1>微服务框架选型之争</h1>
<p>选项其实很多，这里挑选一些讨论火热、或者主流的来对比，仅供参阅。</p>
<ul>
<li>主流微服务框架：SpringCloud、Dubbo</li>
<li>新锐微服务框架：Istio</li>
</ul>
<h2>1、框架背景对比</h2>
<p>（1）Spring Cloud，来源于 Spring Source ，具有 Spring 社区的强大背书外，还有 Netflix 强大的后盾与技术输出。Netflix 作为一家成功实践微服务架构的互联网公司，在几年前就把几乎整个微服务框架栈开源贡献给了社区，这些框架开源的整套微服务架构套件是 Spring Cloud 的核心。</p>
<ul>
<li>Eureka:　服务注册发现框架；</li>
<li>Zuul:　服务网关；</li>
<li>Karyon:　服务端框架；</li>
<li>Ribbon:　客户端框架；</li>
<li>Hystrix: 服务容错组件；</li>
<li>Archaius: 服务配置组件；</li>
<li>Servo: Metrics组件；</li>
<li>Blitz4j: 日志组件。</li>
</ul>
<p>（2）Dubbo 是一个分布式服务框架，是国内互联网公司开源做的比较不错的阿里开放的微服务化治理框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 其核心部分包含（官网）:</p>
<ul>
<li>远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式；</li>
<li>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持；</li>
<li>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
<blockquote><p>Dubbo 也是采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。当然也支持官方不推荐的 API 调用方式。</p></blockquote>
<p>（3）Istio 作为用于微服务服务聚合层管理的新锐项目，是 Google、IBM、Lyft（海外共享出行公司、Uber劲敌） 首个共同联合开源的项目，提供了统一的连接，安全，管理和监控微服务的方案。 </p>
<p>目前首个测试版是针对 Kubernetes 环境的，社区宣称在未来几个月内会为虚拟机和 Cloud Foundry 等其他环境增加支持。 Istio 将流量管理添加到微服务中，并为增值功能（如安全性，监控，路由，连接管理和策略）创造了基础。</p>
<ul>
<li>HTTP、gRPC 和 TCP 网络流量的自动负载均衡；</li>
<li>提供了丰富的路由规则，实现细粒度的网络流量行为控制；</li>
<li>流量加密、服务间认证，以及强身份声明；</li>
<li>全范围（Fleet-wide）的策略执行；</li>
<li>深度遥测和报告。</li>
</ul>
<h2>2、开源社区活跃度对比</h2>
<p>开源社区情况：现如今企业在采用云计算首选开源，而选择一个开源框架，社区的活跃度将作为重要参考选项。</p>
<p>查看下在 Github 上的更新时间，截止 2017 年 8 月 31 日：</p>
<ul>
<li>Spring Cloud ：Spring Cloud · GitHub → 所有项目均更新于『1 小时』内。</li>
<li>Dubbo ：Dubbo · GitHub   → 核心项目最近更新于『一个月乃至数月』前。</li>
<li>Istio：Istio · GitHub → 所有项目均更新于『30 分钟』内。</li>
</ul>
<p>可见，项目在社区活跃度上，Istio &gt; Spring Cloud &gt; Dubbo，结合稳定性来看，对于使用 Java 系开发业务较多的企业，Spring Cloud 是相对更优的选择，对于更多企业来说，与语言几乎无绑定的 Istio 也是可以好好期待一下其在社区的发展。</p>
<blockquote><p>总结：结合项目背景、提供功能、社区更新活跃度，SpringCloud 是目前阶段最为稳妥的可执行微服务框架方案，Istio 作为支持对于 Kubernetes 的优先支持来讲，也是一个值得关注的方案。目前对比来看，Dubbo 则显得稍逊下来。</p></blockquote>
<p>时速云 | 企业版 - 微服务治理平台，即将发布！</p>
<p>产品特色：深度定制 SpringCloud 等微服务框架，支持 gRPC，动态路由配置，流量控制，配置管理等增强服务，同时提供应用业务级的 APM 能力。敬请期待！</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010953150"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 微服务框架 | 潮流当前该如何选择 SpringCloud、Dubbo or Istio？,1531977800,297,1,260,1,1,https://segmentfault.com/a/1190000010953144
100,1,0,7,"
                    
<p>sublime Text 3 以下简称ST3是一个非常性感的文本编辑器，很多前端开发者在使用它。无插件，不神器，插件的使用可以使开发更方便快捷。目前社区里提供了各种各样的插件，在搜索里一搜就是各类插件的使用推荐，即使有这么多的插件，有时也不能满足我们的开发需要，今天就跟大家聊一下前段时间实现的（QcmsAux）插件的开发过程，希望给打算写插件的小伙伴们提供参考。</p>
<h2>前期知识了解</h2>
<h3>1.了解Python</h3>
<p>ST3是通过C++开发的，它的插件系统是通过Python来编写的，所以你一定要会Python，不一定非常精通，但是一定要了解，用到哪块儿知道去哪儿查。</p>
<p>推荐：<a href=""http://www.runoob.com/python/python-tutorial.html"" rel=""nofollow noreferrer"">Python基础教程</a> 做为入门了解。</p>
<h3>2. Python控制台</h3>
<p>Sublime Text中内嵌了Python解释器。ST3中的Python和系统中的python是相互独立的。</p>
<p>我使用的是OSX系统，系统中的pythone版本是</p>
<pre><code class=""VI"">python -V // Python2.7.10</code></pre>
<h4>打开Python控制台</h4>
<ul>
<li>快捷键：Ctrl + `</li>
<li>菜单： View -&gt; Show Console</li>
</ul>
<p>在这个控制台中查看，当前ST3中sublime的信息</p>
<pre><code>sublime.version() // '3126'
sublime.platform() // 'osx'</code></pre>
<p>查看ST3中python的版本</p>
<pre><code>platform.python_version() //'3.3.6'</code></pre>
<h3>3. 重要的几个目录</h3>
<h4>Data目录</h4>
<p>ST3几乎所有需要的文件都保存在Data目录下，不同的操作系统路径不同：</p>
<ul>
<li>Windows: %APPDATA%Sublime Text 3</li>
<li>OS X: ~/Library/Application Support/Sublime Text 3</li>
<li>Linux: ~/.config/sublime-text-3</li>
</ul>
<p>删除这个目录之前使用的插件和自定义的一些配置都会被同时删除，再次打开ST3,这个目录会被自动创建。</p>
<h4>Packages目录</h4>
<p>Data目录下的Packages目录是一个非常重要的目录，关于编程和标记语言的所有支持都保存在这里。</p>
<p>通过Sublime Text -&gt; Preferences -&gt; Browse Packages…可以打开该目录。</p>
<h4>User 目录</h4>
<p>User目录在Packages目录下，用于保存自定义plugins，snippets, macros(宏)。插件配置等都存在这个目录下。插件更新时，这个目录里的内容不会被修改。</p>
<h2>准备工作</h2>
<h3>一个简单的插件示例</h3>
<p>Tools -&gt; Developer -&gt; New Plugin, 使用这个命令可以创建一个插件示例，保存该文件，默认会保存在User目录下，默认文件名是 untitled.py</p>
<h3>插件保存的位置</h3>
<p>通过<a href=""https://packagecontrol.io/installation"" rel=""nofollow noreferrer"">Package Control</a> 安装的插件有的以源码的形式存入Packages目录，有的则以<code>.sublime-package</code>结尾的压缩包存在在上层目录的<code>Installed Packages</code>文件夹下。</p>
<p>ST3将会3个地方依次加载插件：</p>
<ol>
<li>Installed Pacages(only .sublime-package files)</li>
<li>Packages</li>
<li>Packages/User</li>
</ol>
<p>根据约定，不会加载更深层次嵌套的文件，也就是说如果把 <code>untitled.py</code> 放在packages目录下会生效，但是如果放在User/new/下就不会生效。下面我直接放<code>Packages/Example/</code>下，文件名称改为<code>Example.py</code>，这里建议文件名和目录名保持一致。</p>
<p>我本机的目录<code>/Users/rongl/Library/Application Support/Sublime Text 3/Packages/Example/</code></p>
<p>打开控制台，看到<code>reloading plugin example.Example</code>，说明插件已经被自动加载了，然后运行<code>view.run_command('example')</code>,如下会在第一行插入<code>Hello, World!</code> ，这样这个简单的插件就执行成功了。</p>
<pre><code>Hello, World!import sublime
import sublime_plugin

class ExampleCommand(sublime_plugin.TextCommand):

    def run(self, edit):
        self.view.insert(edit, 0, ""Hello, World!"")</code></pre>
<p>到目前为止已经完成了简单的插件的编写执行。在上面的示例中：</p>
<ul>
<li>sublime_plugin.TextCommand:这是文本编辑相关的基类，文本编辑相关的命令都继承于这个基类。</li>
<li>ExampleCommand: 类名以<code>Command</code>结尾，之前的部分为命令名，其中首字母要大写。执行命令时则采用下划线风格的拼写，<code>view.run_command</code>中传入<code>example</code>，如果为<code>MyExampleCommand</code>，则传入<code>my_example</code>。</li>
<li>run(self,edit): 执行命令时会执行这个函数，这是固定格式。edit为API中提供的edit对象，在编辑时会用到。self,代表类ExampleCommand的实例。</li>
<li>self.view.insert(edit,point,content): point是init类型，指定编辑器中的一个坐标。所有插入，删除，选取等操作都通过self.view调用。</li>
</ul>
<p>示例的效果就是在point位置插入content.</p>
<h2>QcmsAux的开发过程</h2>
<h3>插件的主要功能</h3>
<ol>
<li>获取当前文件的路径，分析文件路径和文件名后缀，判断是否符合配置中指定的条件</li>
<li>如果未在qcms创建，调用qcms接口，在qcms创建文件，并返回新建文件的pid</li>
<li>已提交git，已在qcms创建，调用OBQ接口，发布到测试或上线</li>
<li>已提交git，调用OBQ接口，查看当前文件操作信息</li>
<li>调用验证接口，进行代码验证</li>
<li>跳转到OBQ平台，查看当前模板对应的query</li>
<li>跳转到OBQ平台，解锁当前模板</li>
<li>支持在SideBar中文件上右键弹出菜单上传到测试或上线</li>
</ol>
<h3>核心功能的实现</h3>
<ol><li>QCMS创建页面<a href=""http://add.corp.qihoo.net:8360/display/desktop/QCMS+HTTP+API+%28v2%29#QCMSHTTPAPI%28v2%29-2.1.1.%E5%88%9B%E5%BB%BA%E9%A1%B5%E9%9D%A2"" rel=""nofollow noreferrer"">查看QCMSAPI</a>
</li></ol>
<p><code>sublime.load_settins</code>加载插件的配置文件，配置文件内容格式为jsop,分User和default两种，分别位于<code>Packages/User/&lt;setting-name&gt;</code>和<code>Packages/&lt;package-name&gt;/&lt;setting-name&gt;</code>中，前者覆盖后者。</p>
<pre><code># 获取配置信息

settings = sublime.load_settins(""QcmsAux.sublime-settings"")

settings.get('key')

# 获取页面内容

content = view.substr(sublime.Region(0, view.size()))

# 往接口post信息,urllib发送数据和header伪代码

import urllib.parse
import urllib.request

url = 'http://localhost/login.php'
user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
values = {
    'act' : 'login',
    'login[email]' : xx@xx.com',
    'login[password]' : '123456'
}
headers = { 'User-Agent' : user_agent }

data = urllib.parse.urlencode(values)
req = urllib.request.Request(url, data, headers)
response = urllib.request.urlopen(req)
the_page = response.read()

print(the_page.decode(""utf8""))
</code></pre>
<p>2.指定浏览器打开url</p>
<pre><code># MacOS
CHROME_PATH = 'open -a /Applications/Google\ Chrome.app %s'

# Windows
# chrome_path = 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe %s'
# 
# Windows
# chrome_path = 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe %s' 
url = ""http://www.so.com""
webbrowser.get(CHROME_PATH).open(url,new=1)</code></pre>
<h3>耗时任务阻塞主线程</h3>
<p>ST3已经提供了非常方便的异步执行耗时任务的方法<code>set_timeout_async</code></p>
<h3>快捷键</h3>
<p>sublime大部分的配置都可以通过json文件来完成，键盘绑定也一样。不过它的键盘绑定是区分系统的，所以基本上要建立3个文件，而且命名为<code>Default (Windows).sublime-keymap</code>, <code>Default (Linux).sublime-keymap</code> 和 <code>Default (OSX).sublime-keymap</code></p>
<h3>菜单项</h3>
<ul>
<li>Main.sublime-menu 控制了程序的主菜单</li>
<li>Side Bar.sublime-menu 控制侧边栏文件或者目录的右键菜单</li>
<li>Context.sublime-menu 控制处于编辑状态的文件右键菜单</li>
</ul>
<h3>通过console打印</h3>
<p><code>print xxxx</code></p>
<h3>弹出式的窗口</h3>
<p><code>sublime.error_message(""hello world"")</code></p>
<h2>几个常见概念</h2>
<h3>Window:</h3>
<p>打开的 sublime text 窗口</p>
<h3>View</h3>
<p>表示一个文本缓冲的视图，可以认为是打开的一个 tab。</p>
<h3>Edit</h3>
<p>继承自 sublime_plugin.TextCommand 的命令， Edit 为第一个参数。 打开一个 view 以后必须要指定 Edit 才能真正的 insert 字符。需要 view.begin_edit 开始使用编辑区，使用完要 end_edit 。根据 <a href=""http://www.sublimetext.com/docs/3/api_reference.html#sublime.Edit"" rel=""nofollow noreferrer"">sublime 3 API</a> 的说法，只能继承，不能被创建。</p>
<h3>Region</h3>
<p>表示缓冲区的一个区域。有两个init类型的属性a和b。Region.a表示区域开始的点，Region.b表示区域结束的点。</p>
<p>view 的 find_all 等可以匹配一系列的 region 出来</p>
<h3>Selection(RegionSet)</h3>
<p>表示选择的区域。函数sublime.View.sel()返回的类型就是Selection，表示目前选中的所有区域。Selection.add(Region)方法可以添加选择区域。</p>
<h3>Point概念</h3>
<p>int类型，代表缓冲区的一个位置。可以通过sublime.View.rowcol(point)将point转化为行列信息(int,int)。或通过sublime.View.text_point(row,col)将行列信息转化为point。</p>
<ul>
<li>Point 是跟文本开头位置的偏移量</li>
<li>获得当前光标位置的 point: view.sel()[0].a</li>
<li>一个 region 的属性 a b 为起始的俩个 point</li>
</ul>
<h3>line:</h3>
<p>这里看到 line 返回的是鼠标所在行的起始字符数，从文件头开始，算 UTF8 字符，一个中文也是一个字符，无论光标在何处，都是这样的结构(行开始字符数, 行结束字符)</p>
<pre><code>mark = self.view.sel()[0]
line = self.view.line(mark.a)
sublime.status_message(""hickdebug ""  + time.strftime(""%Y-%m-%d %X - "") + str(line))
        </code></pre>
<h2>内置命令</h2>
<h3>expand_selection</h3>
<p>用内置的expand_selection命令，to参数设置为brackets 每个css规则区域内容就可以选中了</p>
<pre><code>self.view.run_command(""expand_selection"", {""to"": ""brackets""})</code></pre>
<h1>python中执行shell命令的四种方式</h1>
<ol><li>os.system()</li></ol>
<p><strong>这个方法得不到shell命令的输出</strong></p>
<pre><code>import os
os.system('ls')
# 执行ls命令</code></pre>
<ol><li>popen()</li></ol>
<p><strong>这个方法能得到命令执行后的结果是一个字符串，要自行处理才能得到想要的信息</strong></p>
<pre><code>import os
str = os.popen(""ls"").read()
a = str.split('\n')
for b in a:
    print b</code></pre>
<ol><li>commands模块</li></ol>
<p><strong>可以很方便的取得命令的输出（包括标准和错误输出）和执行状态位</strong></p>
<p>commands.getstatusoutput(cmd) 返回(status,output)</p>
<pre><code>import commands
a,b = commands.getstatusoutput('ls')
print a
# a是退出的状态
# 0 
print b
# b是输出结果
# 执行ls命令</code></pre>
<p>commands.getoutput(cmd) 只返回输出结果</p>
<pre><code>import commands
b = commands.getoutput('ls')
# 执行ls命令</code></pre>
<p>commands.getstatus(file) 待补充</p>
<ol><li>subprocess模块</li></ol>
<p>使用subprocess模块可以创建新的进程，可以与新建进程的输入/输出/错误管道连通，并可以获得新建进程执行的返回状态。使用subprocess模块的目的是替代os.system(),os.popen(),commands*等旧的函数和模块。</p>
<p>subprocess.call(command,shell=True)</p>
<pre><code>import subprocess
subprocess.call('ls',shell=True)
# 执行ls命令</code></pre>
<p>subprocess.Popen(command,shell=True)</p>
<pre><code>import subprocess
subprocess.Popen('ls',shell=True)
# 执行ls命令</code></pre>
<p>subprocess.Popen(command,stdout=subprocess.PIPE,shell=True)待补充</p>
<p>如果command不是一个可执行文件，shell=True是不可省略的。<br>shell=True表示在shell下执行command</p>
<h1>常用语句功能</h1>
<pre><code>view.settings().get('syntax')</code></pre>
<p>返回当前文件格式，常见的有</p>
<ul>
<li>[tpl,inc,html] : Packages/HTML/HTML.sublime-syntax</li>
<li>css: Packages/CSS/CSS.sublime-syntax</li>
<li>php: Packages/PHP/PHP.sublime-syntax</li>
<li>js:Packages/JavaScript/JavaScript.sublime-syntax</li>
<li>py:Packages/Python/Python.sublime-syntax</li>
<li>
</li>
</ul>
<pre><code>if int(sublime.version()) &gt; 3000
    print(""sublime3"")</code></pre>
<p>判断sublime的版本信息</p>
<h1>命令的拼写</h1>
<p>['node', '/Users/guopeipei/Library/Application Support/Sublime Text 3/Packages/JSLint/linter.js', '--bitwise', '--browser', '--es6', '--eval', '--for', '--fudge', '--node', '--this', '/Users/guopeipei/project/M_so_com/m_so/resource/js/result/scrollTab.js']</p>
<p>Running node /Users/guopeipei/Library/Application Support/Sublime Text 3/Packages/JSLint/linter.js --bitwise --browser --es6 --eval --for --fudge --node --this /Users/guopeipei/project/M_so_com/m_so/resource/js/result/scrollTab.js</p>
<h1>sublime.View类重要方法</h1>
<pre><code>sublime.View.find_by_class(point, forward, classes, &lt;separators&gt;)</code></pre>
<p>通过Class查找,sublime提供的Class</p>
<ul>
<li>sublime.CLASS_WORD_START</li>
<li>sublime.CLASS_WORD_END</li>
<li>sublime.CLASS_PUNCTUATION_START</li>
<li>sublime.CLASS_PUNCTUATION_END</li>
<li>sublime.CLASS_SUB_WORD_START</li>
<li>sublime.CLASS_SUB_WORD_END</li>
<li>sublime.CLASS_LINE_START</li>
<li>sublime.CLASS_LINE_END</li>
<li>sublime.CLASS_EMPTY_LINE</li>
</ul>
<pre><code>sublime.View.find_by_selector(selector)</code></pre>
<p>根据语法选择器查找 ，selector是一个字符串。<a href=""https://www.sublimetext.com/docs/3/scope_naming.html#punctuation"" rel=""nofollow noreferrer"">Scope Naming</a></p>
<h1>sublime.py文件位置</h1>
<p>/Applications/Sublime Text.app/Contents/MacOS/sublime.py</p>
<h1>参考</h1>
<ol>
<li><a href=""http://rinkky.net/2017/06/03/sublime-text-3-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BB%8E0%E5%88%B01/"" rel=""nofollow noreferrer"">sublime插件开发从0到1</a></li>
<li><a href=""http://yanxurui.cc/posts/tool/plugin-tutoral-for-sublime-text-3"" rel=""nofollow noreferrer"">为sublime text 3开发插件</a></li>
<li><a>Sublime Text非官方文档</a></li>
<li><a href=""https://github.com/natee/SublimeText3-Documentation"" rel=""nofollow noreferrer"">非官方文档的翻译整理</a></li>
<li><a href=""https://www.sublimetext.com/docs/3/api_reference.html"" rel=""nofollow noreferrer"">Sublime Text 3.0 API文档</a></li>
<li><a href=""http://mux.alimama.com/posts/549"" rel=""nofollow noreferrer"">Sublime Text 3.0 API 中文版</a></li>
</ol>

                ", sublime3插件开发,1531977801,348,1,313,1,1,https://segmentfault.com/a/1190000010912987
101,1,0,7,"
                    
<h1>vue-picker</h1>
<p>a picker componemt for vue2.0</p>
<hr>
<p>走了一圈 <code>github</code> 都没有找到自己想要的移动端的 <code>vue-picker</code>的组件，于是自己就下手，撸了一个出来，感受下效果图。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015269473?w=583&amp;h=728"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vue-pick.gif"" title=""vue-pick.gif""></span></p>
<h4>demo</h4>
<p><a href=""http://gitblog.naice.me/vue-picker/example/index.html"" rel=""nofollow noreferrer"">demo 地址：</a><a href=""http://gitblog.naice.me/vue-picker/example/index.html"" rel=""nofollow noreferrer"">http://gitblog.naice.me/vue-p...</a></p>
<h4>install</h4>
<p><code>npm install vue-pickers --save</code></p>
<h4>使用</h4>
<pre><code class=""javascript"">
&lt;template&gt;
  &lt;div&gt;
    &lt;vue-pickers
      :show=""show""
      :columns=""columns""
      :defaultData=""defaultData""
      :selectData=""pickData""
      @cancel=""close""
      @confirm=""confirmFn""&gt;&lt;/vue-pickers&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import vuePickers from 'vue-pickers'
export default {
  components: {
    vuePickers
  },
  data() {
    return {
      show: false,
      columns: 1,
      defaultData: [
        {
          text: 1999,
          value: 1999
        }
      ],
      pickData: {
        // 第一列的数据结构
        data1: [
          {
            text: 1999,
            value: 1999
          },
          {
            text: 2001,
            value: 2001
          }
        ]
      }
    }
  },
  methods: {
    close() {
      this.show = false
    },
    confirmFn(val) {
      this.show = false
      this.defaultData = [val.select1]
    },
    toShow() {
      this.show = true
    }
  }
}
&lt;/script&gt;</code></pre>
<h3>属性参数说明</h3>
<table>
<thead><tr>
<th>参数</th>
<th>说明</th>
<th>是否必须</th>
<th>类型</th>
<th>默认值</th>
</tr></thead>
<tbody>
<tr>
<td>show</td>
<td>显示隐藏picker</td>
<td>是</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>columns</td>
<td>列数设置</td>
<td>是</td>
<td>Number</td>
<td>1</td>
</tr>
<tr>
<td>defaultData</td>
<td>默认显示设置</td>
<td>否</td>
<td>Array&lt;object&gt;</td>
<td>[]</td>
</tr>
<tr>
<td>link</td>
<td>是否开启联动数据</td>
<td>否</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>selectData</td>
<td>数据设置，分别对应列（data1: [], data2: [], data3: [],）</td>
<td>是</td>
<td>Object</td>
<td>{}</td>
</tr>
</tbody>
</table>
<h3>事件说明</h3>
<table>
<thead><tr>
<th>参数</th>
<th>说明</th>
<th>是否必须</th>
<th>类型</th>
<th>默认值</th>
</tr></thead>
<tbody>
<tr>
<td>cancel</td>
<td>取消选择</td>
<td>否</td>
<td>function</td>
<td>无</td>
</tr>
<tr>
<td>confirm</td>
<td>确认选择</td>
<td>否</td>
<td>function(val)</td>
<td>无</td>
</tr>
</tbody>
</table>

                ", 一个很好用的 vue-picker组件,1531977803,392,1,324,1,1,https://segmentfault.com/a/1190000010907490
102,1,0,7,"
                    
<blockquote><p>作者：Darkbug<br>原文标题：Google新技术：Instant App全拆解（1）——初探<br>原文链接：<a href=""https://segmentfault.com/a/1190000010906162"" rel=""nofollow noreferrer"">https://segmentfault.com/a/11...</a><br>首发地址：<a href=""http://www.doncc.org"" rel=""nofollow noreferrer"">http://www.doncc.org</a><br>转发请注明转载地址，请尊重原创作者权益！</p></blockquote>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：<br>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>
<hr>
<p>本文开始，接下的几篇文章内，我会从概念、技术等方面，将着重介绍Google发布的最新Android Instant App技术，并描述如何制作属于自己的Instant App。</p>
<p>如有描述不正确的地方，请及时联系我，我将吸取意见并改正。</p>
<h1>1.Instant App是什么</h1>
<p>记得在2016年的Google大会上，Google大大就已经发布了有关Instant App的最新技术了。然而这款被人们寄予厚望的“黑科技”技术在发布之后，并没有像想象中推广的很好，究其原因我怀疑是因为当时发布的时候，所开发的步骤过于繁琐，才不得不将这个技术的推广拖延至今。</p>
<p>我们先来用下面的动图回顾体验下，Instant App的厉害之处：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010906167"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从图中我们初步可以看出，当操作者在点击一段Buzzfeed的视频链接时，会自动的加载这个链接所属程序的代码，并且很轻松的在这个“程序的APP内”体验到这个链接视频效果。</p>
<p>其实这就是Instant App，翻译成中文可以称之为瞬时程序加载，也可以称之为即时应用。它出现的目的，就是为了让人们能够像点击链接那么简单，节省掉安装App的痛苦，最快速度、最少流量的消耗，让用户体验到App级的用户体验。</p>
<p>事实上，Instant App的优点不仅如此，我们同样可以在Google的浏览器内，搜索具备Instant App能力的App的名字，也会得到相应的即时应用，同样能够让你体验到App的交互效果。比如下面我想在wish购物App内，购买Valentino Rossi的周边物（谁让我是个罗西粉），只需在Google搜索栏里，输入“wish Rossi”，你就会看到有关在wish中的一些物品，并且会在内容描述处，看到一个“Instant”标识。也就是说，当你点击这个链接后，你就能体验到属于wish应用的Instant App应用体验。下面有个我录制的微视频，简单的描述了下这个过程。</p>
<p><a href=""http://v.youku.com/v_show/id_XMjk4OTMxNTMwOA==.html"" rel=""nofollow noreferrer"">Instant App初体验-youku</a></p>
<p>怎么样，这个交互效果简直是棒极了吧！</p>
<p>如果细心的朋友肯定会发现，其实早在2015年，Google就已经推出了另外一项技术：App Links。其用意是想当用户点击链接后，能快速链接并打开本地所属应用，而无需经过用户的二次同意。这么做的优点是避免了用户的艰难选择，特别是对于那些选择困难户的童鞋来说。这些内容我会在后面文章着重介绍。</p>
<p>如果这么说比较笼统，那么你肯定遇到过这样情景，你的手机内除了浏览器这个内置App外，如果还安装了类似UC浏览器、360浏览器、各种浏览器。。当你想点击一个链接时，会在手机下方弹出一个对话框，提示你用什么App来打开你的链接。这种让你二次选择的感觉，着实让人感觉有点啰嗦。而App Links的出现，能让你无需再选择，直接选用你已经设定好的方式打开应用进行体验。</p>
<p>说了这么多额外的，我觉得其实Google就是为Instant App的出现做了前期铺垫。真是好大一盘棋啊！</p>
<h1>2.Instant App现阶段遇到的困难</h1>
<p>从上面的内容，想必大伙已经知道一部分了吧。对于Instant App技术的使用，可以分为如下几个方面来讲：</p>
<ul>
<li>xx上网（你懂的）</li>
<li>Google Service不能正常的推广</li>
<li>具有Google Service框架的手机</li>
</ul>
<p>从这一点，我要格外说明的是，所有谷歌亲儿子手机，都是天生具有Google Service框架的，谁让他是亲儿子。?特！还有一个是三星的s7 edge这款手机，自从升级到7.0系统后，就能让我们自己通过xx上网的方式，同样体验到Google Service框架。这次三星也算是开明了一把。这里想下，s8是不是同样也可以，虽然我没有s8。?</p>
<ul><li>完整应用必须提前安装到Google Play上</li></ul>
<p>如果想体验到Instant App的交互效果，首先你要保证的是，你的完整应用程序，需要在Google Play上成功发布。也就是说，要想将你的应用程序变为Instant App所支持效果，需要进行一定的程序修改。有关如何修改，后续我会用文章着重描述。</p>
<ul><li>部署信息验证文件的网站，需具有https方式访问功能的网站。</li></ul>
<p>这个对于一般小众开发者来讲，着实是让人头疼。索性我在实施的时候，干脆将自己的虚拟网站，部署到GitHub上，这样一来能模拟我的网站，不会把大量的时间花费在搭建网站上，又能解决掉SSL证书的问题。一举两得。</p>
<h1>3.Instant App瞬时加载程序与微信小程序的对比</h1>
<p>2016年的Google I/O大会，发布了Instant App技术，而微信小程序公开内侧的时间是同年9月21日。这其中是否有一些某种不言而喻的关系，我不得而知，我也不想去猜想。你们自己体会好了。</p>
<p>为什么我会拿小程序与Instant App技术相对比呢？很显然，他们共同点都是号称“不用安装，就能体验、使用”。对于程序的热爱，我不得不拿来进行对比一番。我会从各个角度进行中肯的对比，不偏不向。</p>
<ul><li>从部署到手机角度讲：</li></ul>
<p>这一点简直是小程序完胜，毕竟Google Service不能正常的引进大陆，这一点上小程序占尽了天时地利。不知道是不是小龙哥看到了这个痛点。</p>
<p>小程序可以利用微信的小程序功能，添加附近商家的小程序，也可进行搜索小程序；而Google的Instant App，想要使用此项技术，必须要保证你的完整App要在Google Play上有正式发布，用官方的话来说，我们要让用户体验到无缝对接。这一点来看，只能说仁者见仁智者见智罢了。个人感觉还是Google做的更为周到细致，虽然在大陆没什么卵用。?</p>
<ul><li>从程序体积来讲：</li></ul>
<p>从这一点来讲，Instant App的控制要比小程序要好。在Google官方要求里，每个Instant App程序最大不得超过4M的大小，一旦超过，必须重新划分模块，再缩减体积；而小程序来讲，没有一个明确的大小上线，如果业务简单，你可以控制在1M-2M的大小，如果业务复杂，包大小也能达到10M都不足为奇。所以这一点对于用户来讲，用户肯定喜欢用最少的开销，体验到业务。我们肯定不希望大把的手机空间，浪费了交给一个程序，特别是对那些手机空间严重不足的用户。我觉得这一点Instant App胜利。</p>
<ul><li>从存储角度来讲：</li></ul>
<p>对于小程序，数据会存储到手机的存取区域，并且每次加载小程序时，是加载本地存储优先。Instant App则是将程序的部分代码下载下来存储到本地存储，同样在每次加载时，也会优先检查本地存储是否有代码。从存储机制来讲，差别不太大。如果从底层实现的方式来看，小程序利用的是H5的存储机制，Instant App利用的是常见的java存储机制。我觉得从这一点来看，没什么比的必要，都还不错。</p>
<ul><li>从页面解析速度来讲：</li></ul>
<p>其实用户关注的这一点是尤为重要。对于小程序而言，毕竟底层是用HTML的实现方式，而Instant App底层用的是java的实现方式。</p>
<p>在小程序的展现过程，首先利用微信小程序特有的编码方式，转换成HTML，再来渲染、解析、展现等操作；而Instant App不需要这么麻烦，它天生就可以用Android来编写，然后通过下载这部分代码到本地，使用Instant App时，显然就是本地应用的用户体验，流畅度要比HTML页面展现的方式顺滑很多。这是Instant App能绝对胜出的一点。</p>
<p>综合对比，Instant App从用户体验角度来看，要比小程序好很多，体验起来让用户感觉，有种“我并没有安装这个程序，就能体验到和程序同样的丝滑体验”的感觉。但是从可实施角度看（我指的是只在大陆范围内），Instant App天生就不如微信小程序，因为啥？你懂得。 -_-||</p>
<p>当然，喜不喜欢这个技术，做不做这个技术，由你来做决定。如果你喜欢这个技术，我假设你是可以来克服这个不可实施的问题，来介绍后面的文章；如果您觉得不可实施，看到此为止就可以了，也没有什么必要往后看去浪费时间。</p>
<p>好了，今天就介绍到这，预告下下一篇文章，我会在技术层面上来着重介绍Instant App这项技术所用到的周边技术。</p>
<hr>
<p>《Google新技术：Instant App全拆解》系列预告：<br>第二篇：<a href=""https://segmentfault.com/a/1190000011169174"" rel=""nofollow noreferrer"">Google新技术：Instant App全拆解（2）——剖析</a></p>
<hr>

                ", Google新技术：Instant App全拆解（1）——初探,1531977804,575,1,184,1,1,https://segmentfault.com/a/1190000010906162
103,1,0,7,"
                    
<p>项目地址 <a href=""https://github.com/PuShaoWei/arithmetic-php"" rel=""nofollow noreferrer"">https://github.com/PuShaoWei/...</a></p>
<blockquote><p>每周最少一更，求出题，求虐待 At least once a week, ask for problems and abuse</p></blockquote>
<h2>简易结构</h2>
<pre><code>├──Package
│    ├── Sort  排序篇
│    │    ├── BubbleSort.php          冒泡排序
│    │    ├── HeapSort.php            堆排序   大根堆
│    │    ├── MBaseSort.php           基数排序 MSD
│    │    ├── LBaseSort.php           基数排序 LSD
│    │    ├── QuickSort.php           快速排序
│    │    ├── ShellSort.php           希尔排序
│    │    ├── MergeSort.php           归并排序
│    │    ├── InsertSort.php          插入排序
│    │    └── SelectSort.php          选择排序
│    │
│    ├── Query 查找篇
│    │    ├── BinaryQuery.php         二分查找
│    │    ├── InseertQuery.php        插入查找
│    │    ├── FibonacciQuery.php      斐波那契查找
│    │    └── QulickQuery.php         快速查找
│    │     
│    ├── Structure 数据结构
│    │    ├── StackExample.php         堆栈   先进后出 LIFO (Last In First Out)
│    │    ├── LinearChain.php          线性表 单链存储
│    │    └── LinearOrder.php          线性表 顺序存储 
│    │     
│    ├── Tools 小工具集
│    │    └──  SystemSwitch.php       堆栈实现进制转换  
│    │  
│    └── Other 其他
│         ├──  MonkeyKing.php         约瑟夫环
│         ├──  DynamicProgramming.php 动态规划
│         ├──  Fibonacci.php          斐波那契数列
│         ├──  StealingApples.php     偷苹果求余
│         ├──  HanoiGames.php         汉诺塔游戏
│         ├──  BidirectionalQueue.php 双向队列
│         ├──  ColorBricks.php        彩色砖块
│         ├──  GetCattle.php          牛年求牛
│         ├──  OnlyNumbers.php        求唯一数
│         ├──  PokerGames.php         洗扑克牌
│         └──  BigSmallReplace.php    Hello World 输出 Olleh Dlrow
│     
├──LICENSE
└──README.md
</code></pre>
<h2>要做什么？</h2>
<pre><code>记录自己理解算法，数据结构的过程，尽可能的简单全面以及详细，让算法学习运用灵活自如，加油(ง •̀_•́)ง
</code></pre>
<h2>当然</h2>
<pre><code>用 PHP 实现算法并替代官方提供的函数是愚蠢的事情 .但这觉不代表斟酌算法就是件无意义的事 , 每个算法都是一种思想的结晶 , 学习优秀的思想 , 开拓思维
</code></pre>
<h2>什么是算法？</h2>
<p>直白地说，算法就是任何明确定义的计算过程，它接收一些值或集合作为输入，并产生一些值或集合作为输出。这样，算法就是将输入转换为输出的一系列计算过程。来源：Thomas H. Cormen, Chales E. Leiserson (2009), 《算法导论第三版》。</p>
<p>简而言之，我们可以说算法就是用来解决一个特定任务的一系列步骤（是的，不止计算机在使用算法，人类也同样如此）。目前，一个有效的算法应该含有三个重要特性：</p>
<ul>
<li>它必须是有限的：如果你设计的算法永无休止地尝试解决问题，那么它是无用的。</li>
<li>它必须具备明确定义的指令：算法的每一步都必须准确定义，在任何场景下指令都应当没有歧义。</li>
<li>它必须是有效的：一个算法被设计用以解决某个问题，那么它就应当能解决这个问题，并且仅仅使用纸和笔就能证明该算法是收敛的。</li>
</ul>
<h2>对数</h2>
<p>log<sub>10</sub>100 相当于问""降多少个10相乘的结果为100""，答案当然是2个了<br>因此log<sub>10</sub>100=2，即对数运算是幂运算的逆运算</p>
<table>
<thead><tr>
<th>left</th>
<th>right</th>
</tr></thead>
<tbody>
<tr>
<td>2<sup>3</sup> = 8</td>
<td>log<sub>2</sub>8 = 3</td>
</tr>
<tr>
<td>2<sup>4</sup> = 16</td>
<td>log<sub>2</sub>16 = 4</td>
</tr>
<tr>
<td>2<sup>5</sup> = 32</td>
<td>log<sub>2</sub>32 = 5</td>
</tr>
</tbody>
</table>
<p>战斗吧！少年</p>
<h2>运行时间</h2>
<p>以二分查找为例，使用它可节省多少时间呢？简单查找诸葛地检查数字，如果列表包含100个数字，最多需要猜100次。<br>换而言之最多需要猜测的次数与列表长度相同，这被称为线性时间(linear time)，而二分查找则不同，如果列表包含100个元素<br>最多需要7次，如果列表包含40亿个数字，最多需猜32次，而分查找的运行时间为对数时间 <code>O(log)</code></p>
<h2>大O表示法</h2>
<p>大O表示法是一种特殊的表示法 ，指出了算法的速度有多快。有个屌用啊，实际上，你经常要去复制别人的代码。<br>在这种情况下，知道这些算法的速度有快有慢</p>
<ul><li>
<p>算法的运行时间以不同的速度增加</p>
<ul><li>例如简单查找与二分查找的区别</li></ul>
</li></ul>
<table>
<thead><tr>
<th>元素</th>
<th>简单查找</th>
<th>二分查找</th>
</tr></thead>
<tbody>
<tr>
<td>100个元素</td>
<td>100ms</td>
<td>7ms</td>
</tr>
<tr>
<td>10000个元素</td>
<td>10s</td>
<td>14ms</td>
</tr>
<tr>
<td>1 000 000 000 个元素</td>
<td>11天</td>
<td>30ms</td>
</tr>
</tbody>
</table>
<li><ul><li>大<code>O</code>表示发指出了算法有多快，例如列表包含<code>n</code>个元素，简单查找需要检查每个元素，因此需要执行<code>n</code>次操作<br>  使用大<code>O</code>表示发这个运行时间为<code>O(n)</code>,二分查找需要执行log<sub>n</sub>次操作，使用大<code>O</code>表示为<code>O(log n)</code>
</li></ul></li>
<ul>
<li>
<p>一些常见的大O运行时间</p>
<ul>
<li>O(log n) ,也叫对数时间，这样的算法包括二分算法</li>
<li>O(n),也叫线性时间，这样的算法包括简单查找。</li>
<li>O(n * log n) 快速排序</li>
<li>O(n<sub>2</sub>),选择排序</li>
<li>O(n!) 即阶乘时间</li>
</ul>
</li>
<li>
<p>这里是重点</p>
<ul>
<li>算法的速度指的并非时间，而是操作数的增速</li>
<li>谈论算法的速度时间时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加</li>
<li>算法的运行时间用大O表示发表示</li>
<li>O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快的越多</li>
</ul>
</li>
</ul>
<h2>编写解决实际问题的程序过程</h2>
<ul>
<li>如何用数据形式描述问题，即将问题抽象为一个数学模型</li>
<li>问题所涉及到的数据量的大小及数据之间的关系</li>
<li>如何在计算机中储存数据及体现数据之间的关系</li>
<li>处理数据时需要对数据执行的操作</li>
<li>编写的程序的性能是否良好</li>
</ul>
<h2>数据(Data)</h2>
<ul>
<li>是客观事物的符号表示，在计算机科学中指的是所有能输入到计算机中并被计算机程序处理的符号的总称。</li>
<li>数据元素(Data Element) :是数据的基本单位，在程序中通常作为一个整体来进行考虑和处理。一个数据元素可由若干个数据项(Data Item)组成。</li>
<li>数据项(Data Item) : 是数据的不可分割的最小单位。数据项是对客观事物某一方面特性的数据描述。</li>
<li>数据对象(Data Object) :是性质相同的数据元素的集合，是数据的一个子集。如字符集合C={‘A’,’B’,’C,…} 。</li>
<li>数据结构 :相互之间具有一定联系的数据元素的集合。</li>
<li>数据的逻辑结构 : 数据元素之间的相互关系称为逻辑结构。</li>
<li>数据操作 : 对数据要进行的运算</li>
<li>数据类型(Data Type):指的是一个值的集合和定义在该值集上的一组操作的总称。</li>
</ul>
<h2>数据的逻辑结构有四种基本类型</h2>
<ul>
<li>集合：结构中数据元素之间除了“属于同一个集合""外,再也没有其他的关系</li>
<li>线性结构：结构中的数据元素存在一对一的关系</li>
<li>树形结构：结构中的数据元素存在一对多的关系</li>
<li>网状或者图状结构：结构中的数据元素存在多对多的关系</li>
</ul>
<h2>数据结构的储存方式</h2>
<p>由数据元素之间的关系在计算机中有两种不同的表示方法——顺序表示和非顺序表示，从则导出两种储存方式，顺序储存结构和链式储存结构</p>
<ul>
<li>顺序存储结构：用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是连续的</li>
<li>链式存储结构：在每一个数据元素中增加一个存放另一个元素地址的指针(pointer)，用该指针来表示数据元素之间的逻辑结构(关系)，数据元素存放的地址是否连续没有要求</li>
</ul>
<p>数据的逻辑结构和物理结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构</p>
<h2>算法(Algorithm)</h2>
<p>是对特定问题求解方法(步骤)的一种描述，是指令的有限序列，其中每一条指令表示一个或多个操作。</p>
<blockquote><p>算法具有以下五个特性</p></blockquote>
<ul>
<li>有穷性： 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成</li>
<li>确定性：算法中每一条指令必须有确切的含义，不存在二义性，且算法只有一个入口和一个出口</li>
<li>可行性： 一个算法是能行的，即算法描述的操作都可以通过已经实现的基本运算执行有限次来实现</li>
<li>输入： 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合</li>
<li>输出： 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量</li>
</ul>
<blockquote><p>算法和程序是两个不同的概念</p></blockquote>
<p>一个计算机程序是对一个算法使用某种程序设计语言的具体实现。算法必须可终止意味着不是所有的计算机程序都是算法。</p>
<blockquote><p>评价一个好的算法有以下几个标准</p></blockquote>
<ul>
<li>正确性(Correctness )： 算法应满足具体问题的需</li>
<li>可读性(Readability)： 算法应容易供人阅读和交流，可读性好的算法有助于对算法的理解和修改</li>
<li>健壮性(Robustness)： 算法应具有容错处理，当输入非法或错误数据时，算法应能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果</li>
<li>通用性(Generality)： 算法应具有一般性 ，即算法的处理结果对于一般的数据集合都成立</li>
</ul>
<blockquote><p>效率与存储量需求： 效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间，一般地，这两者与问题的规模有关</p></blockquote>
<h2>算法的时间复杂度</h2>
<p>算法中基本操作重复执行的次数是问题规模n的某个函数，其时间量度记作T(n)=O(f(n))，称作算法的渐近时间复杂度(Asymptotic Time complexity)，简称时间复杂度</p>
<h2>算法的空间复杂度</h2>
<p>是指算法编写成程序后，在计算机中运行时所需存储空间大小的度量，记作：S(n)=O(f(n)),其中n为问题规模</p>
<h2>递归和循环的简单比较：</h2>
<ol>
<li>从程序上看，递归表现为自己调用自己，循环则没有这样的形式。</li>
<li>递归是从问题的最终目标出发，逐渐将复杂问题化为简单问题，并且简单的问题的解决思路和复杂问题一样，同时存在基准情况，就能最终求得问题，是逆向的。而循环是从简单问题出发，一步步的向前发展，最终求得问题，是正向的。</li>
<li>任意循环都是可以用递归来表示的，但是想用循环来实现递归（除了单向递归和尾递归），都必须引入栈结构进行压栈出栈。</li>
<li>一般来说，非递归的效率高于递归。而且递归函数调用是有开销的，递归的次数受堆栈大小的限制。</li>
</ol>
<h2>一起进步学习</h2>
<ol>
<li>Fork 我的项目并提交你的 <code>idea</code>
</li>
<li>Pull Request</li>
<li>Merge</li>
</ol>
<h2>纠错</h2>
<p>如果大家发现有什么不对的地方，可以发起一个<a href=""https://github.com/PuShaoWei/arithmetic-php/issues"" rel=""nofollow noreferrer"">issue</a>或者<a href=""https://github.com/PuShaoWei/arithmetic-php/pulls"" rel=""nofollow noreferrer"">pull request</a>,我会及时纠正</p>
<blockquote><p>补充:发起pull request的commit message请参考文章<a href=""http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"" rel=""nofollow noreferrer"">Commit message 和 Change log 编写指南</a></p></blockquote>
<h2>致谢</h2>
<p>感谢以下朋友的issue或pull request：</p>
<ul>
<li><a href=""https://github.com/hailwood"" rel=""nofollow noreferrer"">hailwood </a></li>
<li><a href=""https://github.com/zhangxuanru"" rel=""nofollow noreferrer"">zhangxuanru</a></li>
<li><a href=""https://github.com/ifreesec"" rel=""nofollow noreferrer"">ifreesec</a></li>
<li><a href=""https://github.com/openset"" rel=""nofollow noreferrer"">openset</a></li>
</ul>
<h2>License</h2>
<p>MIT</p>

                ", 用 PHP 的方式实现的各类算法合集,1531977805,408,1,474,1,1,https://segmentfault.com/a/1190000010818230
104,1,0,7,"
                    
<h2>简介</h2>
<ul>
<li>公司使用美餐点餐，但是美餐只能当天点餐，经常忘记点餐，没饭吃，所以只能捣鼓一套自动点餐的代码，已经稳定运行，再也不怕忘记了，对模拟登录刚兴趣的也可以看看源码。</li>
<li><a href=""https://github.com/279838089/meican"" rel=""nofollow noreferrer"">github源码</a></li>
<li><a href=""http://shangrui.pub/"" rel=""nofollow noreferrer"">我的个人博客</a></li>
</ul>
<h2>新增功能</h2>
<ul>
<li>20170623 新增取餐自动取 同事常点的餐，不用手动新增</li>
<li>20170821 新增过滤，过滤某些不喜欢的菜式</li>
</ul>
<h3>现已经实现的功能</h3>
<ul>
<li>[x] 定点定时点餐</li>
<li>[x] 订餐配置，可以提供固定的5份选择，周一到周五，或者提供n份选择，每天随机抽取</li>
<li>[x] 如果提供邮箱，点餐成功会自动发送邮件</li>
</ul>
<h3>环境</h3>
<ol>
<li>linux（mac也可以）</li>
<li>基于php5.6</li>
</ol>
<h3>步骤</h3>
<ol>
<li>cd ~ &amp;&amp; git clone   //下载源码</li>
<li>配置账号密码，点餐的id会再下面自动生成</li>
</ol>
<pre><code>//config.php
//配置项如果有多个用;隔开
//账号,多个账号用;隔开
define('USER', '****@****.com;***@*****.com;');
//密码
define('PASSWORD', '****;****;');
//选择，周一到周五，用,隔开
define('CHOICE', '69463546,69463546,69463546,69463546,69450031;69400482,69478131,69373084,69451271,69451272;');
//是否随机，选择数量不等于5，就算不选择也是随机
define('RANDOM', '1;0;');
//邮箱，订餐成功与否都发邮件,为空就不发
define('EMAIL', '***@qq.com;***@qq.com;');
//是否自动选择热门
define('HOT', '1;0;');
//是否过滤某些菜
define('PASS', '果,沙拉;;');</code></pre>
<ol>
<li>php login.php 模拟登录</li>
<li>php consult.php &gt; 1.html &amp;&amp; open 1.html //生成餐牌，==非必需步骤==，<a href=""http://note.youdao.com/noteshare?id=292282e0cfdb273b2beba51054cf6ae1"" rel=""nofollow noreferrer"">或者直接参考点击这里</a>,<strong>参考这里的餐牌，把自己喜欢吃的晚餐id放进第一步的配置文件CHOICE</strong>，生成的1.html是最新的，后续可以直接浏览器点开</li>
<li>把点餐加入自动任务cron里面</li>
</ol>
<pre><code>corntab -e
//进入后，加入以下代码，目录需要改为自己的存放目录，15就是下午3点，可以自行修改
0 15 * * 1-5 cd ~/meican &amp;&amp; php login.php &amp;&amp; php meican.php</code></pre>
<blockquote>更多内容请关注微信公众“p12310086”，为您带来最好玩最有趣的开发信息。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVZyAn?w=430&amp;h=430"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", php模拟登录，美餐自动点餐，公开源码,1531977807,105,1,235,1,1,https://segmentfault.com/a/1190000010804563
105,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010750652"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""VS Code"" title=""VS Code""></span></p>
<p>没错，我就是来给大家安利 VS Code 的。</p>
<p>对前端来说，这是一款性感无比的 IDE，哦不对应该是编辑器。我们团队有大部分人已经在用了，所以这周五在组内做了一个 VS Code 小分享，来发掘 VSC 一些提高开发效率的小技巧。我相信已经有不少前端在使用它了，所以大家更有必要一起分享下日常神操作了。</p>
<h2>为什么选择 VS Code ？</h2>
<p>在 VSC 刚出来的时候，我就开始使用了（<a href=""https://www.zhihu.com/question/29984607/answer/93300215"" rel=""nofollow noreferrer"">如何评价 Visual Studio Code？</a>),理由很简单：</p>
<ul>
<li>开源，免费，颜值高；</li>
<li>微软出品，实力保证。</li>
</ul>
<p>然而用了一阵发现还是 Sublime 好用，一是刚出来功能不完善，Sublime 一些技巧无法迁移过来，另外就是插件太少，实际开发略显吃力。然随着后面 VSC 一次次更新，不少新 features 着实让人眼前一亮：微软这是在用心做产品呐！以至于现在已经没有什么可以抱怨的了(有趣的是当天尤大也发微博说转投 VSC 了，可以预见这款产品未来会越做越好，方向选对了，就不怕路走错)。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010750653"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>而作为前端，VSC 简直就是为我们量身定制：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010750654"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>VSC 本身是基于当前大火的 TS 来写的，所以对于 TS 的支持自然很好；又是基于 electron 开发，底层 Node.js 对前端来说再熟悉不过了。所以，如果你发现哪里不好用，你可以自己写插件呐！如果一个满足不了，那就写两个。</p>
<p>而对于 VSC 的扩展开发也是相当友好，你只需要5步：</p>
<ol>
<li>申请一个 <a href=""https://www.visualstudio.com/zh-cn/docs/setup-admin/team-services/sign-up-for-visual-studio-team-services"" rel=""nofollow noreferrer"">Visual Studio Team Services Account</a>；</li>
<li>添加一个 <a href=""https://code.visualstudio.com/docs/extensions/publish-extension#_get-a-personal-access-token"" rel=""nofollow noreferrer"">Personal access token</a>;</li>
<li>创建一个发布账号，用来发布你的扩展即可(以上操作完全免费)；</li>
<li>使用 VSC 的 Yeoman 脚手架初始化你的扩展项目，之后就是调用官方提供的 API 开发你的扩展即可，就跟开发 Chrome 插件一样；</li>
<li>使用官方发布工具vsce来发布你的扩展到扩展市场，之后别人就可以搜到你的扩展啦！</li>
</ol>
<p>所以对于前端来说，都是我们熟悉的技术栈，你可以作为一个使用者，也可以转身变成一个开发贡献者！</p>
<p>而对于 Sublime 和 WebStorm 来说就没有这么方便了，当然你也可以用 Python 或者 Java 来贡献插件，不过对于前端还是稍稍有些门槛。如果仅仅是使用的话，WebStrom 确实也很好用，毕竟人家收了钱，而且你最好买一个高配的电脑，否则代码撸多了，会卡到你怀疑人生。</p>
<h2>一些实用扩展和技巧</h2>
<p>这才是重点。先贡献下自己的部分扩展列表：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010750655"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000010750656"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000010750657"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>各位要是有啥好用的扩展也分享一下呐，大家一起 get 新姿势！(有趣的是新版的 VSC在扩展栏增加了推荐栏，这样大家能更方便的发现一些精品）</p>
<p>强烈推荐的几个插件：</p>
<ul>
<li>Complete JSDoc Tags(好的注释不仅对项目有用，对 VSC 的代码智能感知也很有用)</li>
<li>Dash(如果你购买了 Dash App 的话）</li>
<li>EditorConfig for VS Code（统一的编辑配置对团队开发很有用）</li>
<li>ESLint（让 VSC 内置 ESLint）</li>
<li>Git History（装完输入 git log有惊喜)</li>
<li>Git Lens（让本就集成了 git 的 VSC 更加强大）</li>
<li>Path Intellisense(文件路径感知扩展）</li>
<li>Project Manager(多项目管理神器)</li>
<li>Settings Sync(将你所有的编辑器配置同步到 gist，省得在新设备上重新捣鼓)</li>
</ul>
<p>详细的介绍我就懒得写了，大家自己去探索发现吧，一些有用的资源：</p>
<ul>
<li>
<a href=""https://code.visualstudio.com/docs"" rel=""nofollow noreferrer"">官方文档</a> 永远是最有用的，或者你也可以选择<a href=""https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/"" rel=""nofollow noreferrer"">中文翻译版</a>；</li>
<li>这里列出了更多好玩的插件<a href=""https://github.com/viatsko/awesome-vscode"" rel=""nofollow noreferrer"">awesome-vscode</a>;</li>
</ul>
<p>一些小技巧：</p>
<ul>
<li>每次更新 VSC 后，好好看下更新日志，有惊喜；</li>
<li>有事没事逛逛扩展市场，有惊喜；</li>
<li>有时间仔细看看官方文档，有惊喜；</li>
<li>好好研究下控制面板和快捷键，你会发现很多命令不用记；</li>
<li>VSC 本身是默认 git 工作流的，基于 git 项目进行开发体验更佳，不要让自己的工作区处于非 git repo 文件夹。</li>
</ul>
<h2>总结</h2>
<p>不管你以前是用 Sublime 还是 WebStorm，又或者是 Atom 和 Eclipse，现在迁移到 VS Code 都是灰常方便的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010750658"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最后，我为什么要安利 VS Code？</p>
<p>毕竟用的人越多，插件市场越丰富，解决问题更快捷，交流起来更愉快嘛！</p>

                ",  为什么我选择使用 VS Code进行前端开发?,1531977808,383,1,86,1,1,https://segmentfault.com/a/1190000010750647
106,1,0,7,"
                    
<h3>多人开发时的数据库同步问题</h3>
<p>相信各位小伙伴在进行团队开发时都遇到过这个问题:一般开发时,各个团队成员使用的是自己开发环境上的本地数据库，这个数据库只有自己在使用，开发过程中，数据库是会经常变动的，比如其他小伙伴添加了一个字段，或者新增了一张表，那么此时问题就来了，我如何把其他小伙伴进行的数据库变更同步到我本地来？不然我更新代码后很可能各种报错。这个虽然是一个小问题，大不了直接再去拷贝一份最新的数据库出来，但是每次都这样，非常低效和繁琐，那这个问题该如何解决？</p>
<h4>解决方式1:</h4>
<p>开发时团队成员共用一套数据库，直接把数据库的变更同步到这个数据库上就行了。这个方法简单粗暴，不过还是有不爽的地方: 共用数据库的话，数据就是共用的，我开发测试一个功能时，数据有可能被其他小伙伴改动了；还有这种方式数据库变更也要单独做版本控制。</p>
<h4>解决方式2;</h4>
<p>每个小伙伴都使用本地库开发，有数据库变更时给其他人发邮件。<br>这种方式非常繁琐，低效，而且很可能其他小伙伴经常忘记发的情况。</p>
<h4>解决方式3:</h4>
<p>使用开源的数据库版本控制工具。比如<a href=""https://dbv.vizuina.com/"" rel=""nofollow noreferrer"">dbv</a> ，这个工具安装配置极其简单，也能满足现在的使用要求，其实我们的需求也并不多，主要是:</p>
<ol>
<li>对数据库的变更进行版本控制，这个是必须的，对数据库的变更必须要记录下来。</li>
<li>我本地的数据库如何同一键同步其他小伙伴做的数据库变动，比如小张增加了一个字段，我可以一键同步到我本地，不至于我本地各种页面报错。<br>目前这个工具这两个大需求都能满足，下面就介绍下如何安装使用吧。</li>
</ol>
<h3>安装及配置</h3>
<p>其实如何安装和配置文档上说的都很详细，<a href=""https://dbv.vizuina.com/documentation/"" rel=""nofollow noreferrer"">文档传送门</a>， 这里我再重复一遍。</p>
<h4>1. 下载安装</h4>
<p>下载后解压到<code>apache</code>的站点目录下，或者把它放到别的目录，配置为一个虚拟站点也行。<br>比如我就把它配置为了一个虚拟站点，<code>DocumentRoot</code>指向根目录即可:</p>
<p><strong>httpd-vhosts.conf</strong></p>
<pre><code>Listen 7845
&lt;VirtualHost *:7845&gt;
    
    DocumentRoot ""E:\devsofts\DBVC\shangsheng""
    ServerName localhost
    ErrorLog ""logs/localhost_123-error.log""
    CustomLog ""logs/localhost_123_access.log"" common
    DirectoryIndex index.html index.php
&lt;/VirtualHost&gt;</code></pre>
<p>重启<code>apache</code>。</p>
<h4>2. 配置</h4>
<p><code>php.ini</code> 要打开<code>php_gettext</code>扩展:</p>
<pre><code>extension=php_gettext.dll</code></pre>
<p>复制<code>dbv</code>根目下的<code>config.php.sample</code>一份为<code>config.php</code>，配置<code>config.php</code>中的数据库配置。连接到你本地的数据库。</p>
<pre><code>define('DB_HOST', 'localhost');
define('DB_PORT', 3306);
define('DB_USERNAME', 'root');
define('DB_PASSWORD', '123456');
define('DB_NAME', 'shangsheng_offical');</code></pre>
<p>配置完成后，在浏览器中访问你刚才配置的站点就能看到了<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010747499"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>3. 使用git或者svn做版本控制</h4>
<p><code>dbv</code>其实也是使用的<code>git</code>或者svn做的版本控制，这个和一般的项目是一样的，比如你使用<code>git</code>的话直接在根目录下执行</p>
<pre><code>git init</code></pre>
<p>就行了，然后把它提交到<code>git</code>服务器，方便下一步其他小伙伴同步更新。<br><strong>注意:</strong><br><code> /data/meta/revision</code>这个文件存储的是你本地数据库信息，这个文件必须添加到<code>git</code>的忽略列表，否则会覆盖到其他人的；还有<code>config.php</code>这个文件也要添加到忽略列表，因为这是你本地的配置。和其他团队成员无关。</p>
<h4>4. 如何使用</h4>
<p>官方举例了四个使用场景，其实我们需要的就是这个，这个是详细的使用举例，我就不再重复了，<a href=""https://dbv.vizuina.com/documentation/#usage-schema-create"" rel=""nofollow noreferrer"">看这里</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010747500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>注意:</strong><br>每个版本都是放在<code>data\revisions</code>目录下的，每个版本对应一个子目录，注意这里的子目录<code>必须是数字</code>，否则在浏览下看到的是空串，更不支持中文。官方也有说明:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010747501"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>结语</h3>
<p>OK, 这个工具就介绍完了，各位小伙伴可以尝试一下~，如果大家有更好的管理方式，可以在留言中探讨一下，相互学习。如果我的文章对你有帮助的话，动动手指点个赞吧~ 谢谢!</p>

                ", 团队开发时该如何同步数据库变更到本地,1531977810,351,1,252,1,1,https://segmentfault.com/a/1190000010747494
107,1,0,7,"
                    
<h2>问题复现</h2>
<p>新建的仓库，再把本地的代码往上<code>push</code>的时候Git提示</p>
<pre><code class=""sh"">$ fatal: I don't handle protocol 'https'</code></pre>
<h2>问题分析</h2>
<p>Git是支持<code>https</code>的，这点毋庸置疑，所以肯定不是Git的问题。<br>那问题可能出现在自己进行<code>remote add </code>的时候可能是Github<strong>仓库的地址</strong>出了问题。</p>
<h2>解决方法</h2>
<p>删除错误的Git仓库地址，重新添加即可</p>
<pre><code class=""sh"">$ git remote rm origin
$ git remote add origin yourURL</code></pre>

                ", git fatal: I don't handle protocol 'https'问题的解决,1531977811,389,1,922,1,1,https://segmentfault.com/a/1190000010727964
108,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010582251"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>
<p>???关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>
</li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li>
<strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li>
<strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a>1. 概述</a></li>
<li><a>2. InsertStatement</a></li>
<li>
<p><a>3. #parse()</a></p>
<ul>
<li><a>3.1 #parseInfo()</a></li>
<li><a>3.2 #parseColumns()</a></li>
<li><a>3.3 #parseValues()</a></li>
<li><a>3.4 #parseCustomizedInsert()</a></li>
<li><a>3.5 #appendGenerateKey()</a></li>
</ul>
</li>
<li><a>666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文前置阅读：</p>
<ul>
<li><a href=""http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self"" rel=""nofollow noreferrer"">《SQL 解析（一）之词法解析》</a></li>
<li><a href=""http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self"" rel=""nofollow noreferrer"">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>插入SQL解析</strong>的源码实现。</p>
<p>不考虑 INSERT SELECT 情况下，插入SQL解析比查询SQL解析复杂度低的多的多。不同数据库在插入SQL语法上也统一的多。<strong>本文分享 MySQL 插入SQL解析器 MySQLInsertParser</strong>。</p>
<p>MySQL INSERT 语法一共有 3 种 ：</p>
<ul><li>第一种：<code>INSERT {VALUES | VALUES}</code>
</li></ul>
<pre><code class=""SQL"">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name,...)]
    [(col_name,...)]
    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]</code></pre>
<ul><li>第二种：<code>INSERT SET</code>
</li></ul>
<pre><code class=""SQL"">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name,...)]
    SET col_name={expr | DEFAULT}, ...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]</code></pre>
<ul><li>第三种：<code>INSERT SELECT</code>
</li></ul>
<pre><code class=""SQL"">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name,...)]
    [(col_name,...)]
    SELECT ...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]</code></pre>
<p>Sharding-JDBC 目前支持：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code> <strong>单条记录</strong>
</li>
<li>第二种：<code>INSERT SET</code>
</li>
</ul>
<p>Sharding-JDBC 插入SQL解析主流程如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010646002"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<pre><code class=""Java"">// AbstractInsertParser.java
public final InsertStatement parse() {
   sqlParser.getLexer().nextToken(); // 跳过 INSERT 关键字
   parseInto(); // 解析INTO
   parseColumns(); // 解析表
   if (sqlParser.equalAny(DefaultKeyword.SELECT, Symbol.LEFT_PAREN)) {
       throw new UnsupportedOperationException(""Cannot support subquery"");
   }
   if (getValuesKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) { // 第一种插入SQL情况
       parseValues();
   } else if (getCustomizedInsertKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) { // 第二种插入SQL情况
       parseCustomizedInsert();
   }
   appendGenerateKey(); // 自增主键
   return insertStatement;
}</code></pre>
<blockquote><p>**Sharding-JDBC 正在收集使用公司名单：<a href=""https://github.com/dangdangdotcom/sharding-jdbc/issues/234"" rel=""nofollow noreferrer"">传送门</a>。  <br>? 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href=""https://github.com/dangdangdotcom/sharding-jdbc/issues/234"" rel=""nofollow noreferrer"">传送门</a>  <br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href=""https://github.com/dangdangdotcom/sharding-jdbc/issues/234"" rel=""nofollow noreferrer"">传送门</a>  <br>登记吧，骚年！<a href=""https://github.com/dangdangdotcom/sharding-jdbc/issues/234"" rel=""nofollow noreferrer"">传送门</a>**</p></blockquote>
<h1>2. InsertStatement</h1>
<p>插入SQL 解析结果。</p>
<pre><code class=""Java"">public final class InsertStatement extends AbstractSQLStatement {
    /**
     * 插入字段
     */
    private final Collection&lt;Column&gt; columns = new LinkedList&lt;&gt;();
    /**
     *
     */
    private GeneratedKey generatedKey;
    /**
     * 插入字段 下一个Token 开始位置
     */
    private int columnsListLastPosition;
    /**
     * 值字段 下一个Token 开始位置
     */
    private int valuesListLastPosition;
}</code></pre>
<p>我们来看下 <code>INSERT INTO t_order (uid, nickname) VALUES (?, ?)</code> 的<strong>解析结果</strong>：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010646003"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>3. #parse()</h1>
<h2>3.1 #parseInto()</h2>
<p>解析<strong>表</strong>。</p>
<pre><code class=""Java"">// AbstractInsertParser.java
/**
* 解析表
*/
private void parseInto() {
   // 例如，Oracle，INSERT FIRST/ALL 目前不支持
   if (getUnsupportedKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) {
       throw new SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());
   }
   sqlParser.skipUntil(DefaultKeyword.INTO);
   sqlParser.getLexer().nextToken();
   // 解析表
   sqlParser.parseSingleTable(insertStatement);
   skipBetweenTableAndValues();
}
/**
* 跳过 表 和 插入字段 中间的 Token
* 例如 MySQL ：[PARTITION (partition_name,...)]
*/
private void skipBetweenTableAndValues() {
   while (getSkippedKeywordsBetweenTableAndValues().contains(sqlParser.getLexer().getCurrentToken().getType())) {
       sqlParser.getLexer().nextToken();
       if (sqlParser.equalAny(Symbol.LEFT_PAREN)) {
           sqlParser.skipParentheses();
       }
   }
}</code></pre>
<p>其中 <code>#parseSingleTable()</code> 请看<a href=""http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self"" rel=""nofollow noreferrer"">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2>3.2 #parseColumns()</h2>
<p>解析<strong>插入字段</strong>。</p>
<pre><code class=""Java"">// AbstractInsertParser.java
private void parseColumns() {
   Collection&lt;Column&gt; result = new LinkedList&lt;&gt;();
   if (sqlParser.equalAny(Symbol.LEFT_PAREN)) {
       String tableName = insertStatement.getTables().getSingleTableName();
       Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName); // 自动生成键信息
       int count = 0;
       do {
           // Column 插入字段
           sqlParser.getLexer().nextToken();
           String columnName = SQLUtil.getExactlyValue(sqlParser.getLexer().getCurrentToken().getLiterals());
           result.add(new Column(columnName, tableName));
           sqlParser.getLexer().nextToken();
           // 自动生成键
           if (generateKeyColumn.isPresent() &amp;&amp; generateKeyColumn.get().equalsIgnoreCase(columnName)) {
               generateKeyColumnIndex = count;
           }
           count++;
       } while (!sqlParser.equalAny(Symbol.RIGHT_PAREN) &amp;&amp; !sqlParser.equalAny(Assist.END));
       //
       insertStatement.setColumnsListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());
       //
       sqlParser.getLexer().nextToken();
   }
   insertStatement.getColumns().addAll(result);
}</code></pre>
<h2>3.3 #parseValues()</h2>
<p>解析<strong>值字段</strong></p>
<pre><code class=""Java"">/**
* 解析值字段
*/
private void parseValues() {
   boolean parsed = false;
   do {
       if (parsed) { // 只允许INSERT INTO 一条
           throw new UnsupportedOperationException(""Cannot support multiple insert"");
       }
       sqlParser.getLexer().nextToken();
       sqlParser.accept(Symbol.LEFT_PAREN);
       // 解析表达式
       List&lt;SQLExpression&gt; sqlExpressions = new LinkedList&lt;&gt;();
       do {
           sqlExpressions.add(sqlParser.parseExpression());
       } while (sqlParser.skipIfEqual(Symbol.COMMA));
       //
       insertStatement.setValuesListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());
       // 解析值字段
       int count = 0;
       for (Column each : insertStatement.getColumns()) {
           SQLExpression sqlExpression = sqlExpressions.get(count);
           insertStatement.getConditions().add(new Condition(each, sqlExpression), shardingRule);
           if (generateKeyColumnIndex == count) { // 自动生成键
               insertStatement.setGeneratedKey(createGeneratedKey(each, sqlExpression));
           }
           count++;
       }
       sqlParser.accept(Symbol.RIGHT_PAREN);
       parsed = true;
   }
   while (sqlParser.equalAny(Symbol.COMMA)); // 字段以 "","" 分隔
}
/**
* 创建 自动生成键
*
* @param column 字段
* @param sqlExpression 表达式
* @return 自动生成键
*/
private GeneratedKey createGeneratedKey(final Column column, final SQLExpression sqlExpression) {
   GeneratedKey result;
   if (sqlExpression instanceof SQLPlaceholderExpression) { // 占位符
       result = new GeneratedKey(column.getName(), ((SQLPlaceholderExpression) sqlExpression).getIndex(), null);
   } else if (sqlExpression instanceof SQLNumberExpression) { // 数字
       result = new GeneratedKey(column.getName(), -1, ((SQLNumberExpression) sqlExpression).getNumber());
   } else {
       throw new ShardingJdbcException(""Generated key only support number."");
   }
   return result;
}</code></pre>
<h3>3.4.1 GeneratedKey</h3>
<p>自动生成键，<strong>属于分片上下文信息</strong>。</p>
<pre><code class=""Java"">public final class GeneratedKey {
    /**
     * 字段
     */
    private final String column;
    /**
     * 第几个占位符
     */
    private final int index;
    /**
     * 值
     */
    private final Number value;
}</code></pre>
<h3>3.4.2 Condition</h3>
<p>条件对象，<strong>属于分片上下文信息</strong>。在<strong>插入SQL解析</strong>里存储<strong>影响分片的值字段</strong>。后续<a href=""http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg"" rel=""nofollow noreferrer"">《SQL 路由》</a> 会专门分享这块。</p>
<pre><code class=""Java"">public final class Condition {

    /**
     * 字段
     */
    @Getter
    private final Column column;
    
    // ... 省略其它属性
}

public final class Column {

    /**
     * 列名
     */
    private final String name;
    /**
     * 表名
     */
    private final String tableName;
}</code></pre>
<h2>3.4 #parseCustomizedInsert()</h2>
<p>解析<strong>第二种插入SQL</strong>：<code>INSERT SET</code>。例如：</p>
<pre><code class=""SQL"">INSERT INTO test SET id = 4  ON DUPLICATE KEY UPDATE name = 'doubi', name = 'hehe';
INSERT INTO test SET id = 4, name = 'hehe';</code></pre>
<pre><code class=""Java"">private void parseInsertSet() {
   do {
       getSqlParser().getLexer().nextToken();
       // 插入字段
       Column column = new Column(SQLUtil.getExactlyValue(getSqlParser().getLexer().getCurrentToken().getLiterals()), getInsertStatement().getTables().getSingleTableName());
       getSqlParser().getLexer().nextToken();
       // 等号
       getSqlParser().accept(Symbol.EQ);
       // 【值】表达式
       SQLExpression sqlExpression;
       if (getSqlParser().equalAny(Literals.INT)) {
           sqlExpression = new SQLNumberExpression(Integer.parseInt(getSqlParser().getLexer().getCurrentToken().getLiterals()));
       } else if (getSqlParser().equalAny(Literals.FLOAT)) {
           sqlExpression = new SQLNumberExpression(Double.parseDouble(getSqlParser().getLexer().getCurrentToken().getLiterals()));
       } else if (getSqlParser().equalAny(Literals.CHARS)) {
           sqlExpression = new SQLTextExpression(getSqlParser().getLexer().getCurrentToken().getLiterals());
       } else if (getSqlParser().equalAny(DefaultKeyword.NULL)) {
           sqlExpression = new SQLIgnoreExpression();
       } else if (getSqlParser().equalAny(Symbol.QUESTION)) {
           sqlExpression = new SQLPlaceholderExpression(getSqlParser().getParametersIndex());
           getSqlParser().increaseParametersIndex();
       } else {
           throw new UnsupportedOperationException("""");
       }
       getSqlParser().getLexer().nextToken();
       // Condition
       if (getSqlParser().equalAny(Symbol.COMMA, DefaultKeyword.ON, Assist.END)) {
           getInsertStatement().getConditions().add(new Condition(column, sqlExpression), getShardingRule());
       } else {
           getSqlParser().skipUntil(Symbol.COMMA, DefaultKeyword.ON);
       }
   } while (getSqlParser().equalAny(Symbol.COMMA)); // 字段以 "","" 分隔
}</code></pre>
<h2>3.5 #appendGenerateKey()</h2>
<p>当表设置<strong>自动生成键</strong>，并且插入SQL<strong>没</strong>写自增字段，增加该字段。例如：</p>
<pre><code class=""SQL"">// 主键为user_id
INSERT INTO t_user(nickname, age) VALUES (?, ?)</code></pre>
<p>后续 SQL 改写会生成该自增编号，并改写该 SQL。后续<a href=""http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg"" rel=""nofollow noreferrer"">《SQL 改写》</a> 会专门分享这块。</p>
<pre><code class=""Java"">private void appendGenerateKey() {
   // 当表设置自动生成键，并且插入SQL没写自增字段
   String tableName = insertStatement.getTables().getSingleTableName();
   Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName);
   if (!generateKeyColumn.isPresent() || null != insertStatement.getGeneratedKey()) {
       return;
   }
   // ItemsToken
   ItemsToken columnsToken = new ItemsToken(insertStatement.getColumnsListLastPosition());
   columnsToken.getItems().add(generateKeyColumn.get());
   insertStatement.getSqlTokens().add(columnsToken);
   // GeneratedKeyToken
   insertStatement.getSqlTokens().add(new GeneratedKeyToken(insertStatement.getValuesListLastPosition()));
}</code></pre>
<h3>3.5.1 GeneratedKeyToken</h3>
<p>自增主键标记对象。</p>
<pre><code class=""Java"">public final class GeneratedKeyToken implements SQLToken {

    /**
     * 开始位置
     */
    private final int beginPosition;
}</code></pre>
<h1>666. 彩蛋</h1>
<p>? 是不是比<a href=""http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self"" rel=""nofollow noreferrer"">《SQL 解析（三）之插入SQL》</a>简单很多。</p>
<p><strong>道友，可否分享一波【本文】到朋友圈</strong>。</p>
<p><strong>继续加油更新！</strong></p>

                ", 数据库分库分表中间件 Sharding-JDBC 源码分析 —— SQL 解析（四）之插入SQL,1531977812,223,1,337,1,1,https://segmentfault.com/a/1190000010646060
109,1,0,7,"
                    
<p>个人总结出的一些实用的 <code>git</code> 命令，分享给大家。</p>
<ol><li><code>git config --global color.ui true</code></li></ol>
<p>让 <code>git</code> 命令默认使用彩色输出。  这条命令在 <code>git 2</code> 之后已经成为默认配置，但如果你还在用比较老的版本（例如 <code>CentOS</code> 上的默认的 git 版本），建议把这项配置加上去。</p>
<ol><li><code>git branch -av</code></li></ol>
<p>显示所有本地即远程分支，并显示最后提交的 <code>Commit</code> 信息。如果不加参数，则只会显示所有本地分支的名字。</p>
<ol><li><code>git checkout -b &lt;NAME&gt; [&lt;START POINT&gt;]</code></li></ol>
<p>创建，并切换到新分支。<code>git branch &lt;NAME&gt;</code> 只会创建分支而不会切换到新分支，可以用它备份当前分支。</p>
<ol><li><code>git tag -L &lt;PATTERN&gt;</code></li></ol>
<p>列出所有符合条件的标签。如果你的项目严格按照 <code>Major.Minor.Update</code> 作为版本名称，那么这条命令就非常有用。它可以直接列出来当前版本下有那些小的 bugfix 版本。当然如果你非要 <code>grep</code> 一下我也没意见。</p>
<ol><li><code>git diff -w</code></li></ol>
<p>显示未提交的更改，忽略空格。人们往往注重实际代码的改变而不注重缩进的变化。如果某个文件有大量缩进改变，<code>-w</code> 这个参数就非常有用。</p>
<ol><li><code>git commit --amend</code></li></ol>
<p>修补前一次提交。相当于撤销前一次提交，做更改后重新提交。这也是一条非常实用的命令。当你发现前一次提交有一些小问题的时候（比如说漏提交了新创建的文件，或者有一些小的拼写错误），可以用这条命令修正前一次提交。它对 <code>merge</code> 提交友好，而且可以用于修正前一次提交的 message 信息。需要注意的是：如果你已经推送了前一次提交，<code>amend</code> 之后需要强推，这一点需要注意。</p>
<ol><li><code>git log --graph --oneline --no-merge</code></li></ol>
<p>显示当前仓库的提交历史。<code>git log</code> 大家都用过，但真正研究过 <code>git log</code> 后面参数的人可能就不多。<code>git log</code> 后面可以接很多实用的参数，示例中的让提交历史以单行模式显示、显示提交历史树并删除 <code>merge</code> 提交。</p>
<ol><li><code>git log -p --follow --stat -- &lt;PATH&gt;</code></li></ol>
<p>显示某个文件的提交历史。在 <code>git</code> 中，<code>--</code> 后接文件路径就代表对单个文件的操作。<code>-p</code> 可以显示具体修改的行，<code>--follow</code> 可以跟踪文件的移动和重命名，<code>--stat</code> 用于显示添加、删除行的数量。</p>
<ol><li><code>git config --global alias.xx ""&lt;COMMAND&gt;""</code></li></ol>
<p>给某 git 命令创建别名。对于一些比较长的命令，可以创建别名。以后只需要 <code>git xx</code> 即可执行 <code>COMMAND</code> 这条命令</p>
<ol><li>
<code>git pull --rebase</code>, <code>--rebase</code> 可以简写为 <code>-r</code>
</li></ol>
<p>使用 <code>git rebase</code> 代替 <code>git merge</code> 执行 <code>pull</code> 操作。<code>git pull --rebase</code> 可以构造出非常整齐的提交历史树，强迫症的福利。<code>git</code> 的官方文档一再提醒这是个危险操作，因为它会修改你的代码提交历史。<code>git rebase</code> 的本质是撤销指定的提交，然后以指定的方式重新提交他们。<code>git pull -r</code> 就相当于首先撤销没有推送到远端的 <code>commit</code>，将远程代码覆盖到本地之后，重新提交所有之前撤销的 <code>commit</code>。与 <code>git merge</code> 不同，当有冲突产生时，<code>git rebase</code> 不会为你的 <code>merge</code> 操作生成一个新的提交。所以一旦 <code>git pull --rebase</code> 执行完毕就无法撤销。</p>
<ol><li><code>git config --global pull.rebase true</code></li></ol>
<p>默认使用 <code>git rebase</code> 代替 <code>git merge</code> 执行 <code>pull</code> 操作。<code>git</code> 提供了一系列配置 <code>git pull --rebase</code> 操作：<code>branch.&lt;BRANCH NAME&gt;.rebase</code>、<code>branch.autosetuprebase</code>。这条是最简单的全局配置项。尽管配置了默认使用 <code>rebase</code>，你可以使用 <code>--merge</code> 开关强制使用 <code>git merge</code> 执行 <code>git pull</code>。</p>
<ol><li><code>git rebase -i</code></li></ol>
<p>交互式变基操作。<code>git</code> 中最强大的修改提交历史的操作，当然也是最危险的操作。它可以让你修改 <code>commit</code> 说明、让几个 <code>commit</code> 合并、交换 <code>commit</code>、删除 <code>commit</code>，甚至在提交某 <code>commit</code> 前执行一段 <code>shell</code> 命令。非常有用、非常强大、同时也是极其危险的操作。强烈建议在执行 <code>git rebase -i</code> 之前先使用 <code>git branch</code> 备份当前分支。</p>
<ol><li><code>git push &lt;remote&gt; [&lt;commit&gt;]:&lt;branch&gt;</code></li></ol>
<p>推送指定的 <code>commit</code> 到远程。有时候你某个工作做到一半，然后来了一个bug要修。当然最好的做法是基于最新的远端分支新开一个分支，基于这个分支开发。但是如果你忘了新开分支，直接把代码提交到了当前分支怎么办？在你需要 <code>push</code> 的分支之前又有别的不需要的 <code>commit</code>。这时就可以先用 <code>git rebase</code> 交换 <code>commit</code> 的顺序，然后推送单个提交。如果你写了冒号但是不写 <code>commit</code> 号，就会变成删除某个远端分支。这是完全不同的而且可能有危险操作，需要注意。</p>
<ol><li><code>git blame &lt;PATH&gt; [-L &lt;M,N&gt;]</code></li></ol>
<p>逐行检查某文件的提交人、提交时间和 <code>commit</code> 号。<code>blame</code> 的中文意思是追责，大家顾名思义，撕逼甩锅时用。  <code>-L</code> 可以指定要检查的行号。</p>
<ol><li><code>git stash [push] [-u]</code></li></ol>
<p>贮存当前工作区的更改。经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是你还不想提交这些代码，这是就可以用 <code>git stash</code> 命令将未提交的更改临时保存到一个贮存项中。<code>-u</code> 表示将未加入版本管理的文件也保存（比如新建的一些文件）</p>
<ol><li>
<code>git stash apply &lt;INDEX&gt;</code>、<code>git stash pop &lt;INDEX&gt;</code>
</li></ol>
<p>将最后一次保存的（或指定的某个）贮存项应用至当前工作区。与前面的 <code>git stash [push]</code> 配套使用。  <code>apply</code> 与 <code>pop</code> 的区别是：<code>pop</code> 会在应用更改的同时把所应用的贮存项删除，而 <code>apply</code> 不会。</p>
<ol><li><code>git cherry-pick -x &lt;COMMIT&gt;..</code></li></ol>
<p><code>摘取</code> 某些提交。即把另一个本地分支的 <code>commit</code> 应用到当前分支。如果我们同时维护多个分支，这个操作就很有用。比如说你在主干 master 分支上修复了一个 bug，然后你想把这个修复应用到一个旧版本的分支上，但是你又不想把其他 master 分支的新功能拉进来，这时就可以用 <code>cherry-pick</code>。<code>-x</code>：在提交记录中添加一行 <code>(cherry picked from commit &lt;commit&gt;)</code>，让两个提交关联起来。</p>
<ol><li><code>git revert &lt;COMMIT&gt;</code></li></ol>
<p>回滚某个提交。即提交某个 <code>COMMIT</code> 的反提交。最快修复某个 bug 的方式就是把引入 bug 的代码干掉。注意干掉代码不代表就要用 <code>git rebase -i</code> 把提交本身也干掉。</p>
<ol><li><code>git grep &lt;PATTERN&gt;</code></li></ol>
<p>在当前加入版本管理的文件中全文检索某字符串。类似于 <code>grep</code> 操作，但是会忽略不需要的（加入 <code>.gitignore</code> 的）文件，非常实用的命令。</p>
<ol><li><code>git bisect</code></li></ol>
<p>实用二分查找的方式定位引入问题的提交。快速定位 bug 的方式。在找不到 bug 出现的原因时，不妨用 <code>git bisect</code> 将 bug 先锁定到某个 <code>commit</code> 上。</p>
<ol><li><code>git clean -fd</code></li></ol>
<p>删除未追踪的文件。<code>-d</code> 表示连目录也一起删除。<code>-x</code> 表示删除被忽略掉的文件，可以用此命令删除编译生成的文件。可以用 <code>-n</code> 查看有哪些文件将被删除。</p>
<ol><li><code>git reflog</code></li></ol>
<p>显示 <code>git</code> 的操作记录。当你使用 <code>git reset --hard</code> 误删某个 commit 时可以用此法抢救回来。</p>
<ul><li><code>brew install tig</code></li></ul>
<p>美化 git 输出，重度终端用户的福利。这个其实是工具安利了，它用图形化的方式（ncurses）美化 git 输出，谁用谁知道 :)</p>

                ", 20 条实用的 git 命令,1531977813,425,1,464,1,1,https://segmentfault.com/a/1190000010645904
110,1,0,7,"
                    
<p>PHP 获取 ip 地址信息之前用过新浪/淘宝的接口，但如果新浪/淘宝接口出问题就没法用了，而且网络获取也慢.<br>今天介绍一个开源的<a href=""https://github.com/maxmind/GeoIP2-php"" rel=""nofollow noreferrer"">geoip</a></p>
<h3>淘宝接口</h3>
<pre><code class=""js"">$ip = file_get_contents('http://ip.taobao.com/service/getIpInfo.php?ip=180.149.132.47');
print_r(json_decode($ip, 1));
Array
(
    [code] =&gt; 0
    [data] =&gt; Array
        (
            [country] =&gt; 中国
            [country_id] =&gt; CN
            [area] =&gt; 华北
            [area_id] =&gt; 100000
            [region] =&gt; 北京市
            [region_id] =&gt; 110000
            [city] =&gt; 北京市
            [city_id] =&gt; 110100
            [county] =&gt; 
            [county_id] =&gt; -1
            [isp] =&gt; 电信
            [isp_id] =&gt; 100017
            [ip] =&gt; 180.149.132.47
        )

)</code></pre>
<h3>纯真 IP 数据库</h3>
<pre><code class=""js"">// 先下文件 QQWry.Dat http://www.cz88.net/fox/  http://update.cz88.net/soft/setup.zip
$IpLocation = new IpLocation('qqwry/QQWry.Dat');
$client = $IpLocation-&gt;getlocation('180.149.132.47');</code></pre>
<h3>安装 geoip</h3>
<pre><code class=""js"">curl -sS https://getcomposer.org/installer | php
mv composer.phar /usr/bin/composer
chmod +x composer
composer require geoip2/geoip2:~2.0
</code></pre>
<h3>使用</h3>
<pre><code class=""js"">require_once 'vendor/autoload.php';
use GeoIp2\Database\Reader;
$reader = new Reader('GeoIP2-City.mmdb');
$record = $reader-&gt;city('180.149.132.47');// 百度 ip
dump($record);// dump 来自 laravel 

City {#1899 ▼
  #city: City {#1908 ▶}
  #location: Location {#1909 ▶}
  #postal: Postal {#1910 ▶}
  #subdivisions: array:1 [▶]
  #continent: Continent {#1902 ▶}
  #country: Country {#1903 ▶}
  #locales: array:1 [▶]
  #maxmind: MaxMind {#1904 ▶}
  #registeredCountry: Country {#1905 ▶}
  #representedCountry: RepresentedCountry {#1906 ▶}
  #traits: Traits {#1907 ▶}
  #raw: array:7 [▼
    ""city"" =&gt; array:2 [▼
      ""geoname_id"" =&gt; 1816670
      ""names"" =&gt; array:8 [▼
        ""de"" =&gt; ""Peking""
        ""en"" =&gt; ""Beijing""
        ""es"" =&gt; ""Pekín""
        ""fr"" =&gt; ""Pékin""
        ""ja"" =&gt; ""北京市""
        ""pt-BR"" =&gt; ""Pequim""
        ""ru"" =&gt; ""Пекин""
        ""zh-CN"" =&gt; ""北京""
      ]
    ]
    ""continent"" =&gt; array:3 [▼
      ""code"" =&gt; ""AS""
      ""geoname_id"" =&gt; 6255147
      ""names"" =&gt; array:8 [▼
        ""de"" =&gt; ""Asien""
        ""en"" =&gt; ""Asia""
        ""es"" =&gt; ""Asia""
        ""fr"" =&gt; ""Asie""
        ""ja"" =&gt; ""アジア""
        ""pt-BR"" =&gt; ""Ásia""
        ""ru"" =&gt; ""Азия""
        ""zh-CN"" =&gt; ""亚洲""
      ]
    ]
    ""country"" =&gt; array:3 [▼
      ""geoname_id"" =&gt; 1814991
      ""iso_code"" =&gt; ""CN""
      ""names"" =&gt; array:8 [▼
        ""de"" =&gt; ""China""
        ""en"" =&gt; ""China""
        ""es"" =&gt; ""China""
        ""fr"" =&gt; ""Chine""
        ""ja"" =&gt; ""中国""
        ""pt-BR"" =&gt; ""China""
        ""ru"" =&gt; ""Китай""
        ""zh-CN"" =&gt; ""中国""
      ]
    ]
    ""location"" =&gt; array:4 [▼
      ""accuracy_radius"" =&gt; 50
      ""latitude"" =&gt; 39.9289
      ""longitude"" =&gt; 116.3883
      ""time_zone"" =&gt; ""Asia/Shanghai""
    ]
    ""registered_country"" =&gt; array:3 [▼
      ""geoname_id"" =&gt; 1814991
      ""iso_code"" =&gt; ""CN""
      ""names"" =&gt; array:8 [▼
        ""de"" =&gt; ""China""
        ""en"" =&gt; ""China""
        ""es"" =&gt; ""China""
        ""fr"" =&gt; ""Chine""
        ""ja"" =&gt; ""中国""
        ""pt-BR"" =&gt; ""China""
        ""ru"" =&gt; ""Китай""
        ""zh-CN"" =&gt; ""中国""
      ]
    ]
    ""subdivisions"" =&gt; array:1 [▼
      0 =&gt; array:3 [▼
        ""geoname_id"" =&gt; 2038349
        ""iso_code"" =&gt; ""11""
        ""names"" =&gt; array:3 [▼
          ""en"" =&gt; ""Beijing""
          ""fr"" =&gt; ""Municipalité de Pékin""
          ""zh-CN"" =&gt; ""北京市""
        ]
      ]
    ]
    ""traits"" =&gt; array:1 [▼
      ""ip_address"" =&gt; ""180.149.132.47""
    ]
  ]
}

print($record-&gt;country-&gt;isoCode . ""\n""); // 'CN'
print($record-&gt;country-&gt;name . ""\n""); // 'China'
print($record-&gt;country-&gt;names['zh-CN'] . ""\n""); // '中国 '
print($record-&gt;mostSpecificSubdivision-&gt;name . ""\n""); // 'Beijing'
print($record-&gt;mostSpecificSubdivision-&gt;isoCode . ""\n""); // '11'
print($record-&gt;city-&gt;name . ""\n""); // 'Beijing '
print($record-&gt;location-&gt;latitude . ""\n""); // 39.9289
print($record-&gt;location-&gt;longitude . ""\n""); // 116.3883</code></pre>
<h3><a href=""https://github.com/lionsoul2014/ip2region"" rel=""nofollow noreferrer"">ip2region</a></h3>
<pre><code class=""js"">php binding/php/testSearcher ./data/ip2region.db
p2region&gt;&gt; 101.105.35.57
2163|中国|华南|广东省|深圳市|鹏博士 in 0.02295 millseconds</code></pre>
<p>公众号：苏生不惑</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOYWr?w=425&amp;h=433"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", php 获取 ip 信息,1531977814,518,1,821,1,1,https://segmentfault.com/a/1190000010406804
111,1,0,7,"
                    
<h3>概述</h3>
<p>项目是基于Vue.js，成品是一个移动端的音乐播放器，来源于imooc的实战课程。自己动手实践并加以修改拓展。<br>项目的大致流程是Vue-cli构建开发环境，分析需求，设计构思，规划目录结构，开始编码。</p>
<h4>视图层</h4>
<blockquote><ul>
<li><p>推荐页</p></li>
<li>
<p>歌手页</p>
<ul><li><p>歌手详情</p></li></ul>
</li>
<li>
<p>歌曲排行榜</p>
<ul><li><p>排行榜详情</p></li></ul>
</li>
<li><p>搜索页</p></li>
<li><p>用户中心</p></li>
</ul></blockquote>
<h4>数据来源</h4>
<p>所有数据都来自于QQ音乐，抓取自QQ的接口，大部分接口都是JSONP，抓取比较容易，其中一些接口限制了<code>host</code>，不能直接抓取，采用的方法是用<code>axios</code>代理，设置<code>header</code>，以此绕过<code>host</code>的限制。<br>PS：具体代码请看<code>prod.server.js</code>文件</p>
<h4>技术栈</h4>
<blockquote><ul>
<li><p>Vue</p></li>
<li><p>Vuex</p></li>
<li><p>Vue-Router</p></li>
<li><p>Vue-cli</p></li>
<li><p>Stylus</p></li>
<li><p>Axios</p></li>
<li><p>ESlint</p></li>
<li><p>Better-scroll</p></li>
</ul></blockquote>
<h4>src目录结构</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010403547"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>难点</h3>
<h4>player组件</h4>
<p>讲一讲<code>player</code>    播放器组件，播放器组件可谓是整个项目的核心，当然数据处理和用户体验方面也是不简单的（逃。<br>播放器是全局组件，放在<code>App.vue</code>下面，通过<code>Vuex</code>传递数据，触发<code>action</code>提交<code>mutation</code>，从而使播放器开始工作。当然，其中的数据交互说复杂也不是很复杂，就是要花多点时间理解，<code>player</code>组件由多个基础组件构成，具体请看项目代码，下面上图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010403548"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>为了防止切换歌曲时点击速度过快导致歌曲播放错误，使用了<code>audio</code>的<code>onplay</code>API，结合<code>Vuex</code>获取到数据，判断当前歌曲数据请求到才可以切换下一首歌曲，判断函数如下</p></blockquote>
<pre><code class=""javascript""> ready() {
   this.songReady = true
 }</code></pre>
<h4>数据处理</h4>
<p>通过调用QQ音乐的JSONP接口，获取的数据并不能直接拿来用，需要做进一步的规格化，达到我们使用的要求，所以在这方面单独封装了一个<code>class</code>来处理这方面的数据，具体请看<code>src/common/js/song.js</code></p>
<p>在请求JSONP的时候，用到了一个JSONP库，这个库代码十分简短，只有几十行，有兴趣的同学可以<a href=""https://github.com/webmodules/jsonp"" rel=""nofollow noreferrer"">学习</a>下。</p>
<p>使用时，就是将请求的参数拼接在请求url上，然后调用这个库的<code>jsonp</code>方法。所以，在此封装了两个函数，一个是将参数拼接在url上，另一个是将库里面的<code>jsonp</code>方法Promise化，方便我们使用，具体请查看<code>src/common/js/jsonp.js</code>。</p>
<p>将请求的数据格式化后再通过<code>Vuex</code>传递，组件间共享，实现歌曲的播放切换等。</p>
<h4>交互体验</h4>
<p>该项目的很多地方都涉及到滚动，包括下拉滚动，下拉滚动刷新等。这里面用到了一个库(<code>better-scroll</code>)，来实现所有涉及到的滚动，建议学习下它的<a href=""https://github.com/ustbhuangyi/better-scroll"" rel=""nofollow noreferrer"">API</a>。</p>
<p>其他动画包括了<code>Vue</code>的<code>transition</code>动画，路由之间切换时的简单动画，播放器打开时的动画，这个地方比较难，也比较好玩。</p>
<p>打开页面时的加载Loading效果，其实就是一个Loading组件，也比较简单。</p>
<p>为了减少流量，图片加载使用了懒加载的方式，滚动时再加载真实的图片。<br>具体效果请自身体验：）</p>
<h3>效果</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010403549"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000010403550"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000010403551"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000010403552"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>构建</h3>
<h4>开发环境</h4>
<pre><code class=""bash""># install dependencies
npm install

# serve with hot reload at localhost:8080
npm run dev

# run e2e tests
npm run e2e

# run all tests
npm test</code></pre>
<h4>生产环境</h4>
<pre><code class=""bash""># build for production with minification
npm run build
# run
node prod.server.js</code></pre>
<h3>总结</h3>
<p>通过学习该项目，自己收获了许多，实践中也遇到了大大小小许多问题，通过断点调试等最终解决了，对我来说无疑是最大的鼓励，也希望能与大家一起学习。<br>项目地址：<a href=""https://github.com/k-water/vue-music"" rel=""nofollow noreferrer"">https://github.com/k-water/vue-music</a><br>喜欢的点个赞<br>完 ：）</p>

                ", 基于Vue.js的音乐播放器（Webapp）,1531977816,495,1,427,1,1,https://segmentfault.com/a/1190000010403542
112,1,0,7,"
                    
<h2>概述</h2>
<ul><li><p>在平时工作中使用git难免会提交一些错误的文件到git库里，这时候，撤销吧，怕把正确的文件删除了，不撤销重新改又很麻烦，下面，我就从提交的三个阶段，来讲解如何撤销错误的操作。</p></li></ul>
<h2>Git Add了一个错误文件</h2>
<h3>解决方法</h3>
<ul><li>
<p>这种情况一般发生在新创建的项目，执行命令：</p>
<p>git add .</p>
<p>命令执行完后发现增加了错误的文件，比如Pycham自动生成的.idea文件夹。比如下图：</p>
</li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这时候，我想撤销add .idea这个操作，可以这么做：</p>
<pre><code>    
git reset &lt;file&gt; #撤销指定的文件
git reset #撤销所有的文件
</code></pre>
<p>执行完这个命令后，效果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364803"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到.idea这个目录变成了Untracked了。完美解决。<br>如果你在执行的时候遇到如下的错误：</p>
<pre><code>fatal: Failed to resolve 'HEAD' as a valid ref.
</code></pre>
<p>如果遇到这个错误，就说明你的本地git仓库从来没有执行过git commit操作，导致HEAD指针不存在。这时候你可以通过如下的命令撤销操作：</p>
<pre><code>
git rm --cached .   #删除文件
git rm -r --cached . #删除文件和目录
</code></pre>
<h3>如何避免</h3>
<ul>
<li><p>.gitignore: 把不需要提交的文件增加到这个文件</p></li>
<li><p>git add &lt;file&gt;: 增加指定的文件，少用点号</p></li>
</ul>
<h2>Git Commit了一个错误文件</h2>
<h3>举例</h3>
<p>我现在有个文件的状态如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364804"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>执行git diff blog-test.py后结果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364805"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到我增加了一行，现在把文件提交到本地仓库：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364806"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，本地以及没有需要提交的文件了。这时候，我发现，这个修改是错误的，我需要撤销这次commit，我该怎么做了？</p>
<h4>只撤销commit操作，保留文件</h4>
<p>执行命令如下：</p>
<pre><code>git reset HEAD~1</code></pre>
<p>执行完效果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364807"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，commit被撤销了，但是修改的部分还保留着。完美解决。不信看git log</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364808"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>撤销commit操作，删除变化</h4>
<p>执行命令如下：</p>
<pre><code>git reset --hard HEAD~1
</code></pre>
<p>执行完后效果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364809"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，我增加的那一行已经没有了，git log中也没有了那次的提交记录：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364810"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>完美</p>
<h3>如何避免</h3>
<ul>
<li><p>git status: 查看是否有不需要的文件被add进来</p></li>
<li><p>git diff: 查看文件的变化部分，是否是想提交的</p></li>
</ul>
<h3>查看更多</h3>
<p><a href=""http://bbs.bugcode.cn/t/7"" rel=""nofollow noreferrer"">Git如何取消最新一次的commit</a></p>
<h2>如何删除分支</h2>
<p>好，现在有个很严重的问题，我的分支里代码不用了，现在要删除，怎么整。</p>
<h3>分支没有push到远程</h3>
<p>删除本地的分支很简单：</p>
<pre><code>
git branch -d branch_name
</code></pre>
<p>举例截图如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364811"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>分支已经push到远程</h3>
<p>我现在本地和远程都有一个test分支，如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364812"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364813"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>执行如下的命令删除本地和远程的test分支：</p>
<pre><code>git push origin --delete test
git checkout master
git branch -d test
#git branch -D test 如果有未提交的文件，用它</code></pre>
<p>执行完效果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364814"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364815"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到都删掉了。</p>
<h2>总结</h2>
<p>出错不可怕，可怕的是你不知道为什么出错以及如何修复错误。所谓亡羊补牢，为时未晚。</p>
<h2><a href=""http://www.bugcode.cn/git_undo.html"" rel=""nofollow noreferrer"">为什么不来我的博客逛逛了</a></h2>

                ", Git各种错误操作撤销的方法,1531977817,123,1,340,1,1,https://segmentfault.com/a/1190000010364797
113,1,0,7,"
                    
<h2>日常生活中的git</h2>
<p>通常情况下，在进行git操作的时候，大家最熟悉的流程：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010309293"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可能还有的同学也经常<code>git commit --amend -C head</code>，向上一个commit提交内容。<br>然而在日常生活中总会有一些其他对代码版本管理的需求，比如需要去修改很久之前的一个commit的内容等。</p>
<p>本文主要记录一些git相对使用较少，但是非常有用的命令。</p>
<h2>git rebase</h2>
<p>git rebase 有两个常用功能：</p>
<ul>
<li><p>从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。</p></li>
<li><p>对当前分支的历史commit进行修改，合并，删除等操作</p></li>
</ul>
<h3>场景</h3>
<ul><li><p>你的分支和master冲突</p></li></ul>
<p>如果你<code>git merge master</code>就会留下一个merge的commit。在这种情况下，我们推荐使用<code>git rebase master</code>，就能不留commit将当前分支和master有机的合并。</p>
<ul><li><p>之前某次提交，改错了一个变量</p></li></ul>
<p>如果你修改那个变量然后再提交一个commit，这显然不是最优的。如果能将某次的提交挑出来修改就好了。当然git提供了这个功能，你可以使用<code>git rebase -i [git-hash| head~n]</code>,其中<code>git-hash</code>是你要开始进行rebase的commit的hash，而head~n则是从HEAD向前推n个commit.</p>
<p>当你执行<code>git rebase -i </code>你会看到如下界面，需要你去选择对应的commit指定一种操作。下面提示了很多操作项。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010309294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>git stash</h2>
<p>git stash 主要功能是：</p>
<ul><li><p>暂存当前没有提交的更改</p></li></ul>
<pre><code class=""shell"">git stash save 保存当前更改
git stash 保存当前更改
git stash pop 推出之前stash的内容更改
git stash apply 推出之前stash的内容更改

git stash save --keep-index 只stash没有被add的内容
git stash save --include-untracked stash还未加入git记录的文件

git stash list --stat 显示stash堆栈
git stash show stash@{0} 显示第x次的更改
git stash show 显示最近一次stash的更改
git stash show --patch 显示最近一次stash的详细更改

git stash save ""stash msg""

git stash branch new_brach stash@{0}
</code></pre>
<h3>场景</h3>
<ul><li><p>当做了更改之后但是没有编写完，这个时候发现线上有个bug，你需要停下当前分支去修bug，这个时候你可以提一个commit到当前分支，或则使用<code>git stash</code></p></li></ul>
<p>stash多次是以堆栈的形式进行存储的。</p>
<h2>git filter-branch</h2>
<p>git filter-branch的主要功能是</p>
<ul><li><p>过滤所有提交记录，进行相应的操作</p></li></ul>
<pre><code>git filter-branch --tree-filter 'rm -rf .vscode' 删除所有分支的.vscode文件夹
git filter-branch --tree-filter 'rm -f xxx' xxx不存在，不报错
git filter-branch --tree-filter 'rm -rf .vscoe' -- --all(所有分支所有提交)

git filter-branch --index-filter 'git rm --cached --ignore-unmatch password.txt' (只检查password.txt 一个文件)
git filter-branch -f --prune-empty -- --all</code></pre>
<h3>场景</h3>
<ul><li><p>你发现你错误的将一个不应该提交的文件提交，然后已经过了很久，已经累计了无数次提交。</p></li></ul>
<p>这个时候就可以使用git filter-branch将所有提交全部过滤一遍删除掉那个不应该提交的文件</p>
<h2>cherry-pick</h2>
<p>git cherry-pick的主要功能是</p>
<ul><li><p>从任何分支，抽取提交到当前分支</p></li></ul>
<pre><code>git cherry-pick git-hash 

git cherry-pick --edit git-hash

pick 多个
git cherry-pick --no-commit git-hash git-hash

git cherry-pick -x git-hash (添加cherry pick from 那个branch)
git cherry-pick --signoff git-hash不修改author</code></pre>
<h3>场景</h3>
<p>当需要将多个分支上的提交合在一个分支合并到master的时候，显然如果这3个分支有关联，一次合并更为合理。<br>这个时候就可以使用<code>git cherry-pick</code>进行精细化的commit的操作。</p>
<h2>work together</h2>
<p>git config --global core.autocrlf<br>linux osx是lf<br>windows 是crlf</p>
<p>如果你的源文件中是换行符是LF，而autocrlf=true, 此时Git add就会遇到 fatal: LF would be replaced by CRLF 的错误。有两个解决办法：</p>
<ol>
<li><p>将你的源文件中的LF转为CRLF即可【推荐】</p></li>
<li><p>将autocrlf 设置为 false</p></li>
</ol>
<p>如果你的源文件中是换行符是CRLF，而autocrlf=input,  此时git add也会遇到 fatal: CRLF would be replaced by LF 的错误。有两个解决办法：</p>
<ol>
<li><p>将你源文件中的CRLF转为LF【推荐】</p></li>
<li><p>将autocrlf 设置为true 或者 false</p></li>
</ol>
<p>.gitattributes</p>
<pre><code>* text = auto 
*.html text
*.css text

*.jpg binary
*.png binary

*.ssh text eol=lf
*.bat text eol=crlf
</code></pre>
<h2>一些可能会用到的</h2>
<h3>git submodule</h3>
<pre><code>git submodule add git@example.com:css.gi</code></pre>
<h3>git reflog</h3>
<pre><code>git log --walk-reflogs</code></pre>
<blockquote><p>原文链接：<a href=""http://hiluluke.cn/2017/07/23/git-senior/"" rel=""nofollow noreferrer"">http://hiluluke.cn/2017/07/23...</a></p></blockquote>

                ", git 高阶用法,1531977818,196,1,833,1,1,https://segmentfault.com/a/1190000010309288
114,1,0,7,"
                    
<p>GitHub地址：<a href=""https://github.com/qiangzi7723/img2Ascii"" rel=""nofollow noreferrer"">https://github.com/qiangzi772...</a></p>
<p>如果觉得不错可以给个<code>star</code>或者提出你的建议</p>
<hr>
<p>img2Ascii，基于JS的图片转ASCII示意图。</p>
<h3>效果</h3>
<p>转码前图片</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQCGP?w=886&amp;h=1012"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>转码后图片</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQCGW?w=1440&amp;h=1596"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>构建</h3>
<pre><code>npm install 或者 yarn install
</code></pre>
<p>之后通过</p>
<pre><code>npm run dev
</code></pre>
<p>即可打开项目</p>
<h3>使用</h3>
<p>以下代码在<code>main.js</code>中</p>
<pre><code>const Img2Ascii=require('./index');
const img=require('./assets/av.png');

new Img2Ascii(img,(nSrc,img)=&gt;{
    const nImg = new Image();
    nImg.src = nSrc;
    nImg.style.width = img.width + 'px';
    nImg.style.height = img.height + 'px';
    nImg.onload = () =&gt; {
        document.body.appendChild(nImg);
        document.getElementById('tip').style.display='none';
    }
});
</code></pre>
<p>Img2Ascii方法需要传入两个参数，第一个参数是图片路径，第二个参数是图片转换完毕后的回调函数，需要自己在回调函数中注入新生成的图片节点，否则看不到效果。</p>
<h3>实现思路</h3>
<p>把图片在<code>canvas</code>中绘制后，利用<code>getImageData</code>接口获取图片的<code>rgba</code>，计算<code>rgba</code>值转换为对应的<code>ASCII</code>码，在适当的位置进行换行，然后整体转换便完成。</p>
<h3>瓶颈</h3>
<p>目前项目的瓶颈存在于<code>html2canvas</code>这个插件，把图片转成ASCII码在浏览器中输出是十分快速的，但是后期将输出的ASCII码转换成图片时，使用了<code>html2canvas</code>插件，这个插件在转换图片的过程中十分缓慢，导致最后的输出缓慢。接下来会把<code>html2canvas</code>这个插件换成使用别的插件实现，忘广大网友提供一些转图片的插件。</p>
<hr>
<p>除此之外我还写有<code>draggable</code>拖拽库以及<code>ant-template</code>模板引擎，如果觉得不错可以给个<code>star</code>。</p>

                ", 开源自己写的图片转Ascii码图工具,1531977820,479,1,963,1,1,https://segmentfault.com/a/1190000010119453
115,1,0,7,"
                    
<h3>图片处理</h3>
<pre><code class=""js"">pip install pillow
from PIL import Image
import numpy as np

a = np.array(Image.open('test.jpg'))
b = [255,255,255] - a
im = Image.fromarray(b.astype('uint8'))
im.save('new.jpg')</code></pre>
<h3><a href=""https://github.com/sripathikrishnan/redis-rdb-tools/"" rel=""nofollow noreferrer"">Parse Redis dump.rdb</a></h3>
<pre><code class=""js"">pip install rdbtools
&gt; rdb --command json /var/redis/6379/dump.rdb

[{
""user003"":{""fname"":""Ron"",""sname"":""Bumquist""},
""lizards"":[""Bush anole"",""Jackson's chameleon"",""Komodo dragon"",""Ground agama"",""Bearded dragon""],
""user001"":{""fname"":""Raoul"",""sname"":""Duke""},
""user002"":{""fname"":""Gonzo"",""sname"":""Dr""},
""user_list"":[""user003"",""user002"",""user001""]},{
""baloon"":{""helium"":""birthdays"",""medical"":""angioplasty"",""weather"":""meteorology""},
""armadillo"":[""chacoan naked-tailed"",""giant"",""Andean hairy"",""nine-banded"",""pink fairy""],
""aroma"":{""pungent"":""vinegar"",""putrid"":""rotten eggs"",""floral"":""roses""}}]</code></pre>
<h3><a href=""https://github.com/rg3/youtube-dl/"" rel=""nofollow noreferrer"">youtube-dl下载国外视频</a></h3>
<pre><code class=""js"">pip install youtube-dl #直接安装youtube-dl
pip install -U youtube-dl #安装youtube-dl并更新
youtube-dl ""http://www.youtube.com/watch?v=-wNyEUrxzFU""</code></pre>
<h3><a href=""http://biezhi.me/2017/08/08/teach-you-how-to-use-asciinema.html"" rel=""nofollow noreferrer"">asciinema录制命令行操作</a></h3>
<pre><code class=""js"">pip3 install asciinema

asciinema rec
asciinema play https://asciinema.org/a/132560
&lt;script type=""text/javascript"" src=""https://asciinema.org/a/132560.js""
id=""asciicast-132560"" async&gt;&lt;/script&gt;</code></pre>
<h3>查看对象的全部属性和方法</h3>
<pre><code class=""js"">pip install pdir2
&gt;&gt;&gt; import pdir,requests
&gt;&gt;&gt; pdir(requests)
module attribute:
    __cached__, __file__, __loader__, __name__, __package__, __path__, __spec__
other:
    __author__, __build__, __builtins__, __copyright__, __license__, __title__,
__version__, _internal_utils, adapters, api, auth, certs, codes, compat, cookies
, exceptions, hooks, logging, models, packages, pyopenssl, sessions, status_code
s, structures, utils, warnings
special attribute:
    __doc__
class:
    NullHandler: This handler does nothing. It's intended to be used to avoid th
e
    PreparedRequest: The fully mutable :class:`PreparedRequest &lt;PreparedRequest&gt;
` object,
    Request: A user-created :class:`Request &lt;Request&gt;` object.
    Response: The :class:`Response &lt;Response&gt;` object, which contains a
    Session: A Requests session.
exception:
    ConnectTimeout: The request timed out while trying to connect to the remote
server.
    ConnectionError: A Connection error occurred.
    DependencyWarning: Warned when an attempt is made to import a module with mi
ssing optional
    FileModeWarning: A file was opened in text mode, but Requests determined its
 binary length.
    HTTPError: An HTTP error occurred.
    ReadTimeout: The server did not send any data in the allotted amount of time
.
    RequestException: There was an ambiguous exception that occurred while handl
ing your
    Timeout: The request timed out.
    TooManyRedirects: Too many redirects.
    URLRequired: A valid URL is required to make a request.
function:
    delete: Sends a DELETE request.
    get: Sends a GET request.
    head: Sends a HEAD request.
    options: Sends a OPTIONS request.
    patch: Sends a PATCH request.
    post: Sends a POST request.
    put: Sends a PUT request.
    request: Constructs and sends a :class:`Request &lt;Request&gt;`.
    session: Returns a :class:`Session` for context-management.</code></pre>
<h3><a href=""https://github.com/xiyouMc/ncmbot"" rel=""nofollow noreferrer"">Python 玩转网易云音乐</a></h3>
<pre><code class=""js"">#https://github.com/ziwenxie/netease-dl pip install netease-dl
pip install ncmbot
import ncmbot
#登录
bot = ncmbot.login(phone='xxx', password='yyy')
bot.content # bot.json()
#获取用户歌单
ncmbot.user_play_list(uid='36554272')</code></pre>
<h3><a href=""https://github.com/gyh1621/GetSubtitles"" rel=""nofollow noreferrer"">下载视频字幕</a></h3>
<pre><code class=""js"">pip install getsub</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQyrj?w=764&amp;h=394"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/waditu/tushare"" rel=""nofollow noreferrer"">Python 财经数据接口包</a></h3>
<pre><code class=""js"">pip install tushare
import tushare as ts
#一次性获取最近一个日交易日所有股票的交易数据
ts.get_today_all()

代码，名称，涨跌幅，现价，开盘价，最高价，最低价，最日收盘价，成交量，换手率
      code    name     changepercent  trade   open   high    low  settlement \  
0     002738  中矿资源         10.023  19.32  19.32  19.32  19.32       17.56   
1     300410  正业科技         10.022  25.03  25.03  25.03  25.03       22.75   
2     002736  国信证券         10.013  16.37  16.37  16.37  16.37       14.88   
3     300412  迦南科技         10.010  31.54  31.54  31.54  31.54       28.67   
4     300411  金盾股份         10.007  29.68  29.68  29.68  29.68       26.98   
5     603636  南威软件         10.006  38.15  38.15  38.15  38.15       34.68   
6     002664  信质电机         10.004  30.68  29.00  30.68  28.30       27.89   
7     300367  东方网力         10.004  86.76  78.00  86.76  77.87       78.87   
8     601299  中国北车         10.000  11.44  11.44  11.44  11.29       10.40   
9     601880   大连港         10.000   5.72   5.34   5.72   5.22        5.20   
10    000856  冀东装备         10.000   8.91   8.18   8.91   8.18        8.10  </code></pre>
<h3><a href=""https://github.com/phith0n/vulhub"" rel=""nofollow noreferrer"">开源漏洞靶场</a></h3>
<pre><code class=""js""># 安装pip
curl -s https://bootstrap.pypa.io/get-pip.py | python3

# 安装docker
apt-get update &amp;&amp; apt-get install docker.io

# 启动docker服务
service docker start

# 安装compose
pip install docker-compose 
# 拉取项目
git clone git@github.com:phith0n/vulhub.git
cd vulhub

# 进入某一个漏洞/环境的目录
cd nginx_php5_mysql

# 自动化编译环境
docker-compose build

# 启动整个环境
docker-compose up -d
#测试完成后，删除整个环境
docker-compose down</code></pre>
<h3><a href=""https://github.com/wong2/beijing_bus"" rel=""nofollow noreferrer"">北京实时公交</a></h3>
<pre><code class=""js"">pip install -r requirements.txt 安装依赖
python manage.py build_cache 获取离线数据，建立本地缓存
#项目自带了一个终端中的查询工具作为例子，运行： python manage.py cli
&gt;&gt;&gt; from beijing_bus import BeijingBus
&gt;&gt;&gt; lines = BeijingBus.get_all_lines()
&gt;&gt;&gt; lines
[&lt;Line: 运通122(农业展览馆-华纺易城公交场站)&gt;, &lt;Line: 运通101(广顺南大街北口-蓝龙家园)&gt;, ...]
&gt;&gt;&gt; lines = BeijingBus.search_lines('847')
&gt;&gt;&gt; lines
[&lt;Line: 847(马甸桥西-雷庄村)&gt;, &lt;Line: 847(雷庄村-马甸桥西)&gt;]
&gt;&gt;&gt; line = lines[0]
&gt;&gt;&gt; print line.id, line.name
541 847(马甸桥西-雷庄村)
&gt;&gt;&gt; line.stations
[&lt;Station 马甸桥西&gt;, &lt;Station 马甸桥东&gt;, &lt;Station 安华桥西&gt;, ...]
&gt;&gt;&gt; station = line.stations[0]
&gt;&gt;&gt; print station.name, station.lat, station.lon
马甸桥西 39.967721 116.372921
&gt;&gt;&gt; line.get_realtime_data(1) # 参数为站点的序号，从1开始
[
    {
        'id': 公交车id,
        'lat': 公交车的位置,
        'lon': 公交车位置,
        'next_station_name': 下一站的名字,
        'next_station_num': 下一站的序号,
        'next_station_distance': 离下一站的距离,
        'next_station_arriving_time': 预计到达下一站的时间,
        'station_distance': 离本站的距离,
        'station_arriving_time': 预计到达本站的时间,
    },
    ...
]</code></pre>
<h3><a href=""https://github.com/grangier/python-goose"" rel=""nofollow noreferrer"">文章提取器</a></h3>
<pre><code class=""js"">git clone https://github.com/grangier/python-goose.git
cd python-goose
pip install -r requirements.txt
python setup.py install

&gt;&gt;&gt; from goose import Goose
&gt;&gt;&gt; from goose.text import StopWordsChinese
&gt;&gt;&gt; url  = 'http://www.bbc.co.uk/zhongwen/simp/chinese_news/2012/12/121210_hongkong_politics.shtml'
&gt;&gt;&gt; g = Goose({'stopwords_class': StopWordsChinese})
&gt;&gt;&gt; article = g.extract(url=url)
&gt;&gt;&gt; print article.cleaned_text[:150]
香港行政长官梁振英在各方压力下就其大宅的违章建筑（僭建）问题到立法会接受质询，并向香港民众道歉。

梁振英在星期二（12月10日）的答问大会开始之际在其演说中道歉，但强调他在违章建筑问题上没有隐瞒的意图和动机。

一些亲北京阵营议员欢迎梁振英道歉，且认为应能获得香港民众接受，但这些议员也质问梁振英有</code></pre>
<h3><a href=""https://github.com/sylnsfar/qrcode"" rel=""nofollow noreferrer"">Python 艺术二维码生成器</a></h3>
<pre><code class=""js"">pip  install  MyQR
myqr https://github.com
myqr https://github.com -v 10 -l Q</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQyu7?w=520&amp;h=245"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/hellysmile/fake-useragent"" rel=""nofollow noreferrer"">伪装浏览器身份</a></h3>
<pre><code class=""js"">pip install fake-useragent
from fake_useragent import UserAgent
ua = UserAgent()

ua.ie
# Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US);
ua.msie
# Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)'
ua['Internet Explorer']
# Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1; .NET CLR 3.3.69573; WOW64; en-US)
ua.opera
# Opera/9.80 (X11; Linux i686; U; ru) Presto/2.8.131 Version/11.11
ua.chrome
# Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2'</code></pre>
<h3><a href=""https://github.com/reorx/httpstat"" rel=""nofollow noreferrer"">美化 curl</a></h3>
<pre><code class=""js"">pip install httpstat
httpstat httpbin.org/get</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQywG?w=865&amp;h=521"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/amoffat/sh"" rel=""nofollow noreferrer"">python shell</a></h3>
<pre><code class=""js"">pip install sh
from sh import ifconfig
print ifconfig(""eth0"")</code></pre>
<h3><a href=""https://github.com/isnowfy/snownlp"" rel=""nofollow noreferrer"">处理中文文本内容</a></h3>
<pre><code class=""js"">pip install -U textblob#英文文本的情感分析
pip install snownlp#中文文本的情感分析
from snownlp import SnowNLP
text = ""I am happy today. I feel sad today.""
from textblob import TextBlob
blob = TextBlob(text)
TextBlob(""I am happy today. I feel sad today."")
blob.sentiment
Sentiment(polarity=0.15000000000000002, subjectivity=1.0)


s = SnowNLP(u'这个东西真心很赞')

s.words         # [u'这个', u'东西', u'真心',
                #  u'很', u'赞']

s.tags          # [(u'这个', u'r'), (u'东西', u'n'),
                #  (u'真心', u'd'), (u'很', u'd'),
                #  (u'赞', u'Vg')]

s.sentiments    # 0.9769663402895832 positive的概率

s.pinyin        # [u'zhe', u'ge', u'dong', u'xi',
                #  u'zhen', u'xin', u'hen', u'zan']

s = SnowNLP(u'「繁體字」「繁體中文」的叫法在臺灣亦很常見。')

s.han           # u'「繁体字」「繁体中文」的叫法
                # 在台湾亦很常见。'
</code></pre>
<h3><a href=""https://github.com/fate0/proxylist"" rel=""nofollow noreferrer"">抓取发放代理</a></h3>
<pre><code class=""js"">pip install -U getproxy
➜ ~ getproxy --help
Usage: getproxy [OPTIONS]

Options:
--in-proxy TEXT Input proxy file
--out-proxy TEXT Output proxy file
--help Show this message and exit.</code></pre>
<ul>
<li>
<code>--in-proxy</code> 可选参数，待验证的 proxies 列表文件</li>
<li>
<code>--out-proxy</code> 可选参数，输出已验证的 proxies 列表文件，如果为空，则直接输出到终端</li>
</ul>
<p><code>--in-proxy</code> 文件格式和 <code>--out-proxy</code> 文件格式一致</p>
<h3><a href=""https://github.com/lzjun567/zhihu-api"" rel=""nofollow noreferrer"">zhihu api</a></h3>
<pre><code class=""js"">pip install git+git://github.com/lzjun567/zhihu-api --upgrade
from zhihu import Zhihu
zhihu = Zhihu()
zhihu.user(user_slug=""xiaoxiaodouzi"")

{'avatar_url_template': 'https://pic1.zhimg.com/v2-ca13758626bd7367febde704c66249ec_{size}.jpg',
     'badge': [],
     'name': '我是小号',
     'headline': '程序员',
     'gender': -1,
     'user_type': 'people',
     'is_advertiser': False,
     'avatar_url': 'https://pic1.zhimg.com/v2-ca13758626bd7367febde704c66249ec_is.jpg',
     'url': 'http://www.zhihu.com/api/v4/people/1da75b85900e00adb072e91c56fd9149', 'type': 'people',
     'url_token': 'xiaoxiaodouzi',
     'id': '1da75b85900e00adb072e91c56fd9149',
     'is_org': False}</code></pre>
<h3><a href=""https://github.com/lauixData/leakPasswd"" rel=""nofollow noreferrer"">Python 密码泄露查询模块</a></h3>
<pre><code class=""js"">pip install leakPasswd
import leakPasswd
leakPasswd.findBreach('taobao')</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQyMN?w=1702&amp;h=1304"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/lebinh/ngxtop"" rel=""nofollow noreferrer"">解析 nginx 访问日志并格式化输出</a></h3>
<pre><code class=""js"">pip install ngxtop
$ ngxtop
running for 411 seconds, 64332 records processed: 156.60 req/sec

Summary:
|   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx |
|---------+------------------+-------+-------+-------+-------|
|   64332 |         2775.251 | 61262 |  2994 |    71 |     5 |

Detailed:
| request_path                             |   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx |
|------------------------------------------+---------+------------------+-------+-------+-------+-------|
| /abc/xyz/xxxx                            |   20946 |          434.693 | 20935 |     0 |    11 |     0 |
| /xxxxx.json                              |    5633 |         1483.723 |  5633 |     0 |     0 |     0 |
| /xxxxx/xxx/xxxxxxxxxxxxx                 |    3629 |         6835.499 |  3626 |     0 |     3 |     0 |
| /xxxxx/xxx/xxxxxxxx                      |    3627 |        15971.885 |  3623 |     0 |     4 |     0 |
| /xxxxx/xxx/xxxxxxx                       |    3624 |         7830.236 |  3621 |     0 |     3 |     0 |
| /static/js/minified/utils.min.js         |    3031 |         1781.155 |  2104 |   927 |     0 |     0 |
| /static/js/minified/xxxxxxx.min.v1.js    |    2889 |         2210.235 |  2068 |   821 |     0 |     0 |
| /static/tracking/js/xxxxxxxx.js          |    2594 |         1325.681 |  1927 |   667 |     0 |     0 |
| /xxxxx/xxx.html                          |    2521 |          573.597 |  2520 |     0 |     1 |     0 |
| /xxxxx/xxxx.json                         |    1840 |          800.542 |  1839 |     0 |     1 |     0 |</code></pre>
<h3><a href=""https://github.com/protream/iquery"" rel=""nofollow noreferrer"">火车余票查询</a></h3>
<pre><code class=""js"">pip install iquery
 Usage:
        iquery (-c|彩票)
        iquery (-m|电影)
        iquery -p &lt;city&gt;
        iquery -l song [singer]
        iquery -p &lt;city&gt; &lt;hospital&gt;
        iquery &lt;city&gt; &lt;show&gt; [&lt;days&gt;]
        iquery [-dgktz] &lt;from&gt; &lt;to&gt; &lt;date&gt;

    Arguments:
        from             出发站
        to               到达站
        date             查询日期

        city             查询城市
        show             演出的类型
        days             查询近(几)天内的演出, 若省略, 默认15

        city             城市名,加在-p后查询该城市所有莆田医院
        hospital         医院名,加在city后检查该医院是否是莆田系


    Options:
        -h, --help       显示该帮助菜单.
        -dgktz           动车,高铁,快速,特快,直达
        -m               热映电影查询
        -p               莆田系医院查询
        -l               歌词查询
        -c               彩票查询

    Show:
        演唱会 音乐会 音乐剧 歌舞剧 儿童剧 话剧
        歌剧 比赛 舞蹈 戏曲 相声 杂技 马戏 魔术</code></pre>
<h3><a href=""https://github.com/warner/magic-wormhole/blob/master/README.md"" rel=""nofollow noreferrer"">电脑之间传文件</a></h3>
<pre><code class=""js"">pip install magic-wormhole
Sender:

% wormhole send README.md
Sending 7924 byte file named 'README.md'
On the other computer, please run: wormhole receive
Wormhole code is: 7-crossover-clockwork
 
Sending (&lt;-10.0.1.43:58988)..
100%|=========================| 7.92K/7.92K [00:00&lt;00:00, 6.02MB/s]
File sent.. waiting for confirmation
Confirmation received. Transfer complete.
Receiver:

% wormhole receive
Enter receive wormhole code: 7-crossover-clockwork
Receiving file (7924 bytes) into: README.md
ok? (y/n): y
Receiving (-&gt;tcp:10.0.1.43:58986)..
100%|===========================| 7.92K/7.92K [00:00&lt;00:00, 120KB/s]
Received file written to README.md</code></pre>
<h3><a href=""https://github.com/chenjiandongx/pyecharts"" rel=""nofollow noreferrer"">Python 数据可视化</a></h3>
<pre><code class=""js"">pip install pyecharts
from pyecharts import Bar

bar = Bar(""我的第一个图表"", ""这里是副标题"")
bar.add(""服装"", [""衬衫"", ""羊毛衫"", ""雪纺衫"", ""裤子"", ""高跟鞋"", ""袜子""], [5, 20, 36, 10, 75, 90])
bar.show_config()
bar.render()#在根目录下生成一个 render.html 的文件,用浏览器打开
#pyecharts制作词云图
from pyecharts import WordCloud

wordlist = ['Sam', 'Club','Macys', 'Amy Schumer', 'Jurassic World', 'Charter','Communications','Chick Fil A', 'Planet Fitness', 'Pitch Perfect', 'Express', 'Home', 'Johnny Depp','Lena Dunham', 'Lewis', 'Hamilton','KXAN', 'Mary Ellen Mark', 'Farrah','Abraham','Rita Ora', 'Serena Williams', 'NCAA', ' baseball',' tournament','Point Break']

#对应于wordlist中每个元素的词频
freq = [10000, 6181, 6000, 4386, 4055, 2467, 2244, 1898, 1484, 1112,1112,1112, 965, 847, 847, 555, 555,555,550, 462, 366, 360, 282, 273, 265]

#设置图标尺寸大小 
wordcloud = WordCloud(width=1000, height=620)

wordcloud.add(name="""", 
              attr=wordlist, 
              shape='circle', 
              value=freq, 
              word_size_range=[20, 100])

#notebook上渲染出词云图
wordcloud

#将词云图渲染并保存到html文件中
#wordcloud.render(path='词云图.html')



freq = [7000, 6181, 6000, 4386, 4055, 2467, 2244, 1898, 1484, 1112,1112,1112, 965, 847, 847, 555, 555,555,550, 462, 366, 360,299, 10000, 7000]

wordcloud = WordCloud(width=1000, height=620)

wordcloud.add(name="""", 
              attr=wordlist, 
              shape='star', 
              value=freq, 
              word_size_range=[20, 100])

wordcloud</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVRpF3?w=824&amp;h=390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/Chyroc/WechatSogou"" rel=""nofollow noreferrer"">微信公众号爬虫接口</a></h3>
<pre><code class=""js"">pip install wechatsogou
from wechatsogou import *
wechats = WechatSogouApi()
name = '南京航空航天大学'
wechat_infos = wechats.search_gzh_info(name)</code></pre>
<h3><a href=""http://tenacity.readthedocs.io/en/latest/"" rel=""nofollow noreferrer"">优雅的重试</a></h3>
<pre><code class=""js"">pip install tenacity 
#限制重试次数为3次
from tenacity import retry, stop_after_attempt
@retry(stop=stop_after_attempt(3))
def extract(url):
    info_json = requests.get(url).content.decode()
    info_dict = json.loads(info_json)
    data = info_dict['data']
    save(data)</code></pre>
<h3><a href=""https://pypi.python.org/pypi/qqwry-py3"" rel=""nofollow noreferrer"">查找IP地址归属地</a></h3>
<pre><code class=""js"">pip install qqwry-py3 
from qqwry import QQwry 
q = QQwry() 
q.load_file('qqwry.dat', loadindex=False) 
result = q.lookup('8.8.8.8') </code></pre>
<h3><a href=""https://github.com/bndr/pipreqs"" rel=""nofollow noreferrer"">导出 python 库列表</a></h3>
<pre><code class=""js"">#pip freeze 导出当前环境中所有的 python 库列表
$ pip install pipreqs
$ pipreqs /home/project/location
Successfully saved requirements file in /home/project/location/requirements.txt</code></pre>
<h3><a href=""https://github.com/fate0/pychrome"" rel=""nofollow noreferrer"">Google Chrome Dev Protocol</a></h3>
<pre><code class=""js"">pip install -U pychrome
google-chrome --remote-debugging-port=9222
# create a browser instance
browser = pychrome.Browser(url=""http://127.0.0.1:9222"")

# list all tabs (default has a blank tab)
tabs = browser.list_tab()

if not tabs:
    tab = browser.new_tab()
else:
    tab = tabs[0]


# register callback if you want
def request_will_be_sent(**kwargs):
    print(""loading: %s"" % kwargs.get('request').get('url'))

tab.Network.requestWillBeSent = request_will_be_sent

# call method
tab.Network.enable()
# call method with timeout
tab.Page.navigate(url=""https://github.com/fate0/pychrome"", _timeout=5)

# 6. wait for loading
tab.wait(5)

# 7. stop tab (stop handle events and stop recv message from chrome)
tab.stop()

# 8. close tab
browser.close_tab(tab)</code></pre>
<h3><a href=""https://github.com/seatgeek/fuzzywuzzy"" rel=""nofollow noreferrer"">模糊搜索</a></h3>
<pre><code class=""js"">pip install fuzzywuzzy
&gt;&gt;&gt; from fuzzywuzzy import fuzz
&gt;&gt;&gt; from fuzzywuzzy import process
&gt;&gt;&gt; fuzz.ratio(""this is a test"", ""this is a test!"")
    97
    &gt;&gt;&gt; choices = [""Atlanta Falcons"", ""New York Jets"", ""New York Giants"", ""Dallas Cowboys""]
&gt;&gt;&gt; process.extract(""new york jets"", choices, limit=2)
    [('New York Jets', 100), ('New York Giants', 78)]
&gt;&gt;&gt; process.extractOne(""cowboys"", choices)
    (""Dallas Cowboys"", 90)</code></pre>
<h3><a href=""https://github.com/OmkarPathak/pygorithm"" rel=""nofollow noreferrer"">算法学习</a></h3>
<pre><code class=""js"">from pygorithm.sorting import bubble_sort
myList = [12, 4, 3, 5, 13, 1, 17, 19, 15]
sortedList = bubble_sort.sort(myList)
print(sortedList)
[1, 3, 4, 5, 12, 13, 15, 17, 19]</code></pre>
<h3><a href=""https://kryptxy.github.io/torrench/"" rel=""nofollow noreferrer"">命令行洪流搜索程序</a></h3>
<pre><code class=""js"">pip install torrench --upgrade
$ torrench ""ubuntu desktop 16.04""    ## Search Linuxtracker for Ubuntu Desktop 16.04 distro ISO
$ torrench ""fedora workstation""    ## Search for Fedora Workstation distro ISO
$ torrench -d ""opensuse"" ## Search distrowatch for opensuse ISO
$ torrench -d ""solus"" ## Search distrowatch for solus ISO</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVTMvo?w=1055&amp;h=646"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://github.com/observerss/ngender"" rel=""nofollow noreferrer"">根据姓名来判断性别</a></h3>
<pre><code class=""js"">pip install ngender
$ ng 赵本山 宋丹丹
name: 赵本山 =&gt; gender: male, probability: 0.9836229687547046
name: 宋丹丹 =&gt; gender: female, probability: 0.9759486128949907
&gt;&gt;&gt; import ngender
&gt;&gt;&gt; ngender.guess('赵本山')
('male', 0.9836229687547046)</code></pre>
<h3><a href=""https://github.com/justdoit0823/pywxclient"" rel=""nofollow noreferrer"">Python编写的简单的微信客户端</a></h3>
<pre><code class=""js"">#https://github.com/pavlovai/match
pip install pywxclient
pip install git+https://github.com/justdoit0823/pywxclient
&gt;&gt;&gt; from pywxclient.core import Session, SyncClient

&gt;&gt;&gt; s1 = Session()

&gt;&gt;&gt; c1 = SyncClient(s1)

&gt;&gt;&gt; c1.get_authorize_url()  # Open the url in web browser

&gt;&gt;&gt; c1.authorize()  # Continue authorize when returning False

&gt;&gt;&gt; c1.login()

&gt;&gt;&gt; c1.sync_check()

&gt;&gt;&gt; msgs = c1.sync_message()  # Here are your wechat messages

&gt;&gt;&gt; c1.flush_sync_key()</code></pre>
<h3><a href=""http://image-match.readthedocs.io/en/latest/start.html"" rel=""nofollow noreferrer"">比较相似图片</a></h3>
<pre><code class=""js"">$ pip install numpy
$ pip install scipy
$ pip install image_match
from image_match.goldberg import ImageSignature
gis = ImageSignature()
a = gis.generate_signature('https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Mona_Lisa,_by_Leonardo_da_Vinci,_from_C2RMF_retouched.jpg/687px-Mona_Lisa,_by_Leonardo_da_Vinci,_from_C2RMF_retouched.jpg')
b = gis.generate_signature('https://pixabay.com/static/uploads/photo/2012/11/28/08/56/mona-lisa-67506_960_720.jpg')
gis.normalized_distance(a, b)</code></pre>
<h3><a href=""https://github.com/isee15/Card-Ocr"" rel=""nofollow noreferrer"">身份证识别OCR</a></h3>
<h3><a href=""https://github.com/lk-geimfari/mimesis"" rel=""nofollow noreferrer"">生成各类虚拟数据</a></h3>
<pre><code class=""js"">pip install mimesis
&gt;&gt;&gt; import mimesis
&gt;&gt;&gt; person = mimesis.Personal(locale='en')

&gt;&gt;&gt; person.full_name(gender='female')
'Antonetta Garrison'

&gt;&gt;&gt; person.occupation()
'Backend Developer'</code></pre>
<h3><a href=""https://github.com/Zulko/moviepy"" rel=""nofollow noreferrer"">视频处理库</a></h3>
<pre><code class=""js"">from moviepy.editor import *

video = VideoFileClip(""myHolidays.mp4"").subclip(50,60)

# Make the text. Many more options are available.
txt_clip = ( TextClip(""My Holidays 2013"",fontsize=70,color='white')
             .set_position('center')
             .set_duration(10) )

result = CompositeVideoClip([video, txt_clip]) # Overlay text on video
result.write_videofile(""myHolidays_edited.webm"",fps=25) # Many options...</code></pre>
<h3><a href=""https://github.com/humiaozuzu/wechat-explorer"" rel=""nofollow noreferrer"">微信聊天记录导出、分析工具</a></h3>
<pre><code class=""js"">pip install wechat-explorer
wexp list_chatrooms ../Documents user_id
wexp list_friends ../Documents user_id
wexp get_chatroom_stats ../Documents user_id chatroom_id@chatroom 2015-08-01 2015-09-01
wexp export_chatroom_records ../Documents user_id chatroom_id@chatroom 2015-10-01 2015-10-07 ../
wexp get_friend_label_stats ../Documents user_id
wkhtmltopdf --dpi 300 records.html records.pdf</code></pre>
<h3><a href=""http://icrawler.readthedocs.io/en/latest/install.html"" rel=""nofollow noreferrer"">图片爬虫库</a></h3>
<pre><code class=""js"">pip install icrawler
from icrawler.builtin import BaiduImageCrawler, BingImageCrawler, GoogleImageCrawler

google_crawler = GoogleImageCrawler(parser_threads=2, downloader_threads=4,
                                    storage={'root_dir': 'your_image_dir'})
google_crawler.crawl(keyword='sunny', offset=0, max_num=1000,
                     date_min=None, date_max=None,
                     min_size=(200,200), max_size=None)
bing_crawler = BingImageCrawler(downloader_threads=4,
                                storage={'root_dir': 'your_image_dir'})
bing_crawler.crawl(keyword='sunny', offset=0, max_num=1000,
                   min_size=None, max_size=None)
baidu_crawler = BaiduImageCrawler(storage={'root_dir': 'your_image_dir'})
baidu_crawler.crawl(keyword='sunny', offset=0, max_num=1000,
                    min_size=None, max_size=None)
from icrawler.builtin import GreedyImageCrawler

storage= {'root_dir': '/'}
greedy_crawler = GreedyImageCrawler(storage=storage)
greedy_crawler.crawl(domains='http://qq.com', 
                     max_num=6)</code></pre>
<h3>Python 剪贴板</h3>
<pre><code class=""js"">pip install pyperclip  
from pyperclip import copy, paste 

copy('2333') # 向剪贴板写入 2333 

paste() # 值为剪贴板中的内容 </code></pre>
<h3><a href=""https://github.com/ageitgey/face_recognition"" rel=""nofollow noreferrer"">获取图片的相似度</a></h3>
<pre><code class=""js"">import face_recognition
image = face_recognition.load_image_file(""your_file.jpg"")
face_locations = face_recognition.face_locations(image)</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVYi2C?w=563&amp;h=366"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a>浏览器自动化splinter</a></h3>
<pre><code class=""js"">#chromedriver.storage.googleapis.com/index.html
&gt;&gt;&gt; from splinter.browser import Browser

&gt;&gt;&gt; xx = Browser(driver_name=""chrome"")

&gt;&gt;&gt; xx.visit(""http://www.zhihu.com/"")</code></pre>
<h3><a href=""https://github.com/simonw/datasette"" rel=""nofollow noreferrer"">为SQLite数据库生成JSON</a></h3>
<pre><code class=""js"">pip3 install datasette
datasette serve path/to/database.db
http://localhost:8001/History/downloads.json</code></pre>
<h3><a href=""https://cupy.chainer.org/"" rel=""nofollow noreferrer"">numpy 接口直接工作在 CUDA</a></h3>
<pre><code class=""js"">&gt;&gt;&gt; import cupy as cp
&gt;&gt;&gt; x = cp.arange(6).reshape(2, 3).astype('f')
&gt;&gt;&gt; x
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]], dtype=float32)
&gt;&gt;&gt; x.sum(axis=1)
array([  3.,  12.], dtype=float32)</code></pre>
<h3><a href=""https://linux.cn/article-9131-1.html"" rel=""nofollow noreferrer"">了解一个命令或程序在执行前会做什么</a></h3>
<pre><code class=""js"">pip install maybe
maybe rm -r ostechnix/
maybe has prevented rm -r ostechnix/ from performing 5 file system operations:
 delete /home/sk/inboxer-0.4.0-x86_64.AppImage
 delete /home/sk/Docker.pdf
 delete /home/sk/Idhayathai Oru Nodi.mp3
 delete /home/sk/dThmLbB334_1398236878432.jpg
 delete /home/sk/ostechnix
Do you want to rerun rm -r ostechnix/ and permit these operations? [y/N] y</code></pre>
<h3><a href=""https://github.com/cls1991/ng"" rel=""nofollow noreferrer"">获取ip</a></h3>
<pre><code class=""js"">pip install ng
$ ng ip

local_ip:192.168.1.114
public_ip:49.4.160.250
$ ng wp
$ ng wp flyfish_5g

flyfish_5g:hitflyfish123456</code></pre>
<h3><a href=""https://github.com/cls1991/qu"" rel=""nofollow noreferrer"">图床服务</a></h3>
<pre><code class=""js"">$ pip install qu
$ qu up /somewhere/1.png
$ qu up /somewhere/1.png 2.png</code></pre>
<h3><a href=""https://github.com/cls1991/gy"" rel=""nofollow noreferrer"">get .gitignore</a></h3>
<pre><code class=""js"">#https://www.gitignore.io/
$ pip install gy
$ gy generate python java lisp</code></pre>
<h3><a href=""http://pygithub.github.io/PyGithub/v1/index.html"" rel=""nofollow noreferrer"">PyGithub</a></h3>
<pre><code class=""js"">pip install PyGithub
from github import Github

g = Github(""xxxxx"", ""passwd"")
my_forks = []
for repo in g.get_user().get_repos():
    if repo.fork:
        my_forks.append(repo)
        </code></pre>
<h3><a href=""https://github.com/Ehco1996/lazySpider"" rel=""nofollow noreferrer"">爬虫小工具</a></h3>
<pre><code class=""js"">pip install lazyspider
from lazyspider.lazyheaders import LazyHeaders

# 注意！字符串要包裹在 三引号 或 双引号 里
curl = ""curl 'https://pypi.python.org/pypi' -H 'cookie: .....balabala....""

lh = LazyHeaders(curl)

headers = lh.getHeaders()
cookies = lh.getCookies()

print('*' * 40)
print('Headers: {}'.format(headers))
print('*' * 40)
print('Cookies: {}'.format(cookies))
print('*' * 40)

import requests
r = requests.get('https://pypi.python.org/pypi',
                 headers=headers, cookies=cookies)
print(r.status_code)
</code></pre>
<h3><a href=""https://github.com/huyingxi/Synonyms"" rel=""nofollow noreferrer"">中文近义词工具包</a></h3>
<pre><code class=""js"">pip install -U synonyms
&gt;&gt;&gt; synonyms.display(""飞机"")
'飞机'近义词：
  1. 架飞机:0.837399
  2. 客机:0.764609
  3. 直升机:0.762116
  4. 民航机:0.750519
  5. 航机:0.750116
  6. 起飞:0.735736
  7. 战机:0.734975
  8. 飞行中:0.732649
  9. 航空器:0.723945
  10. 运输机:0.720578</code></pre>
<p>公众号：苏生不惑</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOYWr?w=425&amp;h=433"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", 那些有趣/用的 Python 库,1531977821,103,1,171,1,1,https://segmentfault.com/a/1190000010103386
116,1,0,7,"
                    
<p>大概在一个月前在 github 上看到了 <a href=""http://caniuse.com/"" rel=""nofollow noreferrer"">caniuse</a> 网站的一个数据源（<a href=""https://raw.githubusercontent.com/Fyrd/caniuse/master/data.json"" rel=""nofollow noreferrer"">https://raw.githubusercontent.com/Fyrd/caniuse/master/data.json</a>），于是就冒出了一个用这个数据源做一个小程序的想法。</p>
<p>当然，最后在不断折腾之下，也算是完成了一个简单的小程序，并且发布使用了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuSg?w=344&amp;h=344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""caniuse简化版小程序"" title=""caniuse简化版小程序""></span></p>
<p>不过整体来说，个人还是感觉有一些不是很满意，并且早期的代码太丑太丑了，虽然现在这个版本的也不好，但至少比早期的好一些了。?谁让我是一个不会写代码的切图仔呢，只好默默地在心里发苦。</p>
<h2>目前版本的改变</h2>
<h3>分享</h3>
<p>在微信小程序中玩这个 caniuse，最大的作用应该是在群里跟别人吹牛逼的时候，谈到兼容性时，甩出一个东西。而不用再是给一个链接地址。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuTo?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""兼容性列表分享"" title=""兼容性列表分享""></span></p>
<p>想想之前版本的时候，甩出去的分享页面感觉有点杂，现在这个就简洁一些了，而且是很明确的指向某个属性什么的。并且这个分享出去的内容，是可以在自己搜索之后，在某个卡片上长按（大于 300ms 即可）就可以松开手指，根据提示来操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuTM?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""选择分享的卡片"" title=""选择分享的卡片""></span></p>
<p>点了确定之后就会开一个新的页面，并且只有这个属性的兼容性列表。</p>
<h3>搜索</h3>
<p>要分享之前，必定是要搜索，所以，搜索的功能是必不可少的。</p>
<p>这个搜索的界面和功能是模仿 <a href=""http://caniuse.com/"" rel=""nofollow noreferrer"">caniuse</a> 网站来做的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuU0?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""主界面"" title=""主界面""></span></p>
<p>准确的说，应该是整个小程序的色调什么都是模仿 <a href=""http://caniuse.com/"" rel=""nofollow noreferrer"">caniuse</a> 网站来做的。</p>
<h3>其他功能</h3>
<ul>
<li><p>其他还有一些就是搜索的结果数据过多的时候，会提示；</p></li>
<li><p>加载时间过久的时候会提示；</p></li>
<li><p>找不到数据的时候也会提示；</p></li>
<li><p>下拉分批加载卡片信息</p></li>
</ul>
<h2>打开很慢？</h2>
<p>是的，第一次打开肯定是很慢，可以说是非常慢。我知道肯定还有优化的空间，只是目前我暂时还没找到方法，毕竟能力有限。还有就是，这个数据是直接通过 github 上获取的，加载的速度还会受到 github 的请求影响。反正我是经历过加载 40s 左右的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuWT?w=1098&amp;h=120"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""加载信息"" title=""加载信息""></span></p>
<h3>为什么不把数据放到本地？</h3>
<p>显然不会这么操作，因为这个 data.json 文件是不定期更新的，目前发现大概是一周左右的时间会有一些更新。但是具体更新了什么东西呢，没去 github 上看 <a href=""https://github.com/Fyrd/caniuse"" rel=""nofollow noreferrer"">https://github.com/Fyrd/caniuse</a>。</p>
<p>如果这样情况下，我放到本地的话，那么对于数据更新什么的就不够及时了。</p>
<p>当然啦，小程序中不会每次都去请求这个数据的，只有这么几种情况才会去请求：</p>
<ul>
<li><p>通过“关于”页面中的更新按钮，主动请求更新；</p></li>
<li><p>第一次打开小程序，在 <code>localStorage</code> 并没有数据的时候；</p></li>
<li><p>清空过 <code>localStorage</code> 之后再打开这个小程序时</p></li>
</ul>
<p>总之就是，发现 <code>localStorage</code> 中没有数据时（其实就只是判断一个时间戳），就会要求去请求下载这个 data.json 文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuY1?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""关于页面"" title=""关于页面""></span></p>
<h3>搜索之后为什么还是那么慢</h3>
<p>这个我想应该就是我没处理好的关系吧，每次搜索的时候都是去400多条的数据中找信息，那么这个信息有多少呢，大概是这样的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuZE?w=1902&amp;h=1712"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""存在storage中的数据"" title=""存在storage中的数据""></span></p>
<h2>开源</h2>
<p>好了，大概的情况就是这样，代码可优化的空间肯定是有很多，作为自己的一个练手的小作品，完成了之后也就开源出来跟大家一起交流用吧。反正早上我在 github 上提交之后，小秦就跟我说了不少可优化的点，突然感觉被小秦指点实在是太荣幸了。哈哈。</p>
<p>都说开源要写什么 license，反正我不懂，想了想，就选择了 <strong>CC BY-NC-SA 4.0</strong>。</p>
<h3>github地址</h3>
<p><a href=""https://github.com/linxz/caniuse"" rel=""nofollow noreferrer"">https://github.com/linxz/caniuse</a></p>
<h2>最后</h2>
<p>昨晚完成这个小程序的最后一个需求点后，赶紧上传找人简单体验了，并没有发现太多什么问题，就提交审核。结果早上起来的时候发现收到提示，已经审核通过了，想想就好激动。</p>
<p>说了这么多，如果你也想玩的话，那就扫一下二维码咯。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQuSg?w=344&amp;h=344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""caniuse简化版小程序"" title=""caniuse简化版小程序""></span></p>

                ", 第一个小程序作品，第一个开源作品,1531977822,574,1,789,1,1,https://segmentfault.com/a/1190000010090476
117,1,0,7,"
                    
<h2>干货( Dry goods？)</h2>
<ul>
<li><a href=""#nodeJS"" rel=""nofollow noreferrer"">node.js</a></li>
<li><a href=""#brew"" rel=""nofollow noreferrer"">brew(just for mac)</a></li>
<li><a href=""#ruby"" rel=""nofollow noreferrer"">ruby</a></li>
<li><a href=""#npm"" rel=""nofollow noreferrer"">npm</a></li>
<li><a href=""#cnpm"" rel=""nofollow noreferrer"">cnpm</a></li>
<li><a href=""#yarn"" rel=""nofollow noreferrer"">yarn</a></li>
<li><a href=""#git"" rel=""nofollow noreferrer"">git</a></li>
<li><a href=""#webpack"" rel=""nofollow noreferrer"">webpack</a></li>
<li><a href=""#bower"" rel=""nofollow noreferrer"">bower</a></li>
<li><a href=""#browser-sync"" rel=""nofollow noreferrer"">browser-sync</a></li>
<li><a href=""#express"" rel=""nofollow noreferrer"">express</a></li>
<li><a href=""#gulp"" rel=""nofollow noreferrer"">gulp</a></li>
<li><a href=""#grunt"" rel=""nofollow noreferrer"">grunt</a></li>
<li><a href=""#sass"" rel=""nofollow noreferrer"">sass</a></li>
<li><a href=""#vue"" rel=""nofollow noreferrer"">vue</a></li>
<li><a href=""#angular"" rel=""nofollow noreferrer"">angular</a></li>
<li><a href=""#react"" rel=""nofollow noreferrer"">react</a></li>
<li><a href=""#more"" rel=""nofollow noreferrer"">待续...</a></li>
</ul>
<hr>
<h2><a id=""nodeJS"">node.js</a></h2>
<blockquote><strong>Window</strong></blockquote>
<ol>
<li>官网下载地址：<a href=""https://nodejs.org/zh-cn/download"" rel=""nofollow noreferrer"">下载 | Node.js</a>
</li>
<li>Node.js默认安装目录为 <em>C:\Program Files\nodejs\</em>, 你也可以修改目录</li>
</ol>
<p>记住，一路都是 next（下一步）</p>
<ol>
<li>最后install，等安装好</li>
<li>在命令行里： node -v，看是否会出现一个版本号，出现了说明安装成功！</li>
<li>最后还要检查一下<strong>环境变量</strong>是否配置：我的电脑（此电脑）右键，打开属性</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQq8V?w=1199&amp;h=726"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""点击高级系统设置"" title=""点击高级系统设置""></span></li>
<li><span class=""img-wrap""><img data-src=""/img/bVQq9N?w=420&amp;h=442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""点击环境变量"" title=""点击环境变量""></span></li>
<li><span class=""img-wrap""><img data-src=""/img/bVQq92?w=436&amp;h=599"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""变量值加入node安装地址"" title=""变量值加入node安装地址""></span></li>
</ol>
<blockquote><strong>Mac</strong></blockquote>
<ol>
<li>官网下载地址：<a href=""https://nodejs.org/en/download/"" rel=""nofollow noreferrer"">下载 | Node.js</a>
</li>
<li>双击刚下载的文件，按步骤默认安装就行</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQrum?w=1464&amp;h=1100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""列表项目"" title=""列表项目""></span></li>
<li>安装完成后打开终端，输入<br>   npm -v <br>   node -v <br>   出现版本信息，说明安装成功。</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQruo?w=802&amp;h=200"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""列表项目"" title=""列表项目""></span></li>
</ol>
<hr>
<h2><a id=""brew"">brew(just for mac)</a></h2>
<p>安装方式，直接在终端里输入：</p>
<pre><code>ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""</code></pre>
<p>官网地址：<a href=""https://brew.sh/index_zh-cn.html"" rel=""nofollow noreferrer"">Homebrew-macOS 缺失的软件包管理器</a></p>
<h2><a id=""ruby"">ruby</a></h2>
<blockquote><strong>Window</strong></blockquote>
<ol>
<li>官网下载地址：<a href=""http://www.ruby-lang.org/zh_cn/downloads/"" rel=""nofollow noreferrer"">下载 Ruby</a>
</li>
<li>点击 Next，继续向导，记得勾选 Add Ruby executables to your PATH，</li>
</ol>
<p>直到 Ruby 安装程序完成</p>
<ol>
<li><span class=""img-wrap""><img data-src=""/img/bVQrnw?w=503&amp;h=387"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""列表项目"" title=""列表项目""></span></li>
<li>安装完成后， 在命令行输入 ruby -v查看是否安装成功</li>
<li>出现版本号则成功，未出现你可能需要进行<strong>环境变量</strong>的配置</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQq8V?w=1199&amp;h=726"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""点击高级系统设置"" title=""点击高级系统设置""></span></li>
<li><span class=""img-wrap""><img data-src=""/img/bVQq9N?w=420&amp;h=442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""点击环境变量"" title=""点击环境变量""></span></li>
<li>在path里面后面添加 %RUBY_HOME%bin</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQrop?w=414&amp;h=189"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""列表项目"" title=""列表项目""></span></li>
<li><span class=""img-wrap""><img data-src=""/img/bVQrov?w=414&amp;h=190"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""列表项目"" title=""列表项目""></span></li>
</ol>
<blockquote><strong>Mac</strong></blockquote>
<ol>
<li>先安装好XCode，因为它会安装好Unix环境需要的开发包</li>
<li>安装RVM: <br>   $ curl -L <a href=""https://get.rvm.io"" rel=""nofollow noreferrer"">https://get.rvm.io</a> | bash -s stable<br>   期间可能需要输入密码，等待一段时间将安装好。</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQrpe?w=926&amp;h=381"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></li>
<li>载入rvm（若打开新终端窗口则不用执行）<br>   $ source ~/.rvm/scripts/rvm<br>   然后检查是否安装好了<br>   $ rvm -v</li>
<li>安装Ruby<br>   列出已知的ruby版本<br>   $ rvm list known</li>
<li><span class=""img-wrap""><img data-src=""/img/bVQrqT?w=575&amp;h=193"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></li>
<li>选择2.0.0版本进行安装<br>   $ rvm install 2.0.0<br>   等待下载(途中需要按回车确定安装路径、还要输入密码)、编译</li>
<li>检查是否安装好了<br>   $ rvm -v<br>   $ gem -v</li>
<li>
<p>将源替换为淘宝的:</p>
<pre><code>$ gem source -r https://rubygems.org/
$ gem source -a https://ruby.taobao.org
$ gem sources -l  #查看打印是否替换成功</code></pre>
</li>
</ol>
<hr>
<h2><a id=""npm"">npm</a></h2>
<blockquote><strong>Window</strong></blockquote>
<ol>
<li>新版的 node.js已经集成了 npm，所以之前安装 node时 npm也一并安装好了，<br>   可以通过输入 ""npm -v"" 来测试是否成功安装</li>
<li>升级 npm:<br>   npm install npm -g<br>   cnpm install npm -g</li>
</ol>
<blockquote><strong>Mac</strong></blockquote>
<ol><li>升级 npm:<br>   $ sudo npm install npm -g</li></ol>
<hr>
<h2><a id=""cnpm"">cnpm</a></h2>
<p>命令行输入：</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre>
<hr>
<h2><a id=""git"">git</a></h2>
<blockquote><strong>Window</strong></blockquote>
<ol>
<li>官网下载地址：<a href=""https://git-scm.com/download/win"" rel=""nofollow noreferrer"">Downloading Git</a>
</li>
<li>另一个简单的方法是安装： GitHub for Windows。<br>   网址为：<a href=""https://desktop.github.com/"" rel=""nofollow noreferrer"">https://desktop.github.com/</a>
</li>
</ol>
<blockquote><strong>Mac</strong></blockquote>
<ol>
<li>官网下载地址：<a href=""https://git-scm.com/download/mac"" rel=""nofollow noreferrer"">https://git-scm.com/download/mac</a>
</li>
<li>Mac 版本好像在维护，如果下载没开始，请你手动点击。</li>
</ol>
<hr>
<h2><a id=""webpack"">webpack</a></h2>
<blockquote><strong>Window</strong></blockquote>
<p>用npm 安装webpack</p>
<pre><code>npm install webpack -g</code></pre>
<blockquote>
<strong>Mac</strong><br>mac下报错的话前面可能需要加sudo获取管理员权限</blockquote>
<pre><code>
```
(sudo) npm install -g webpack
```</code></pre>
<hr>
<h2><a id=""bower"">Bower-A package manager for the web</a></h2>
<ol>
<li>
<p>使用npm，打开终端，输入：</p>
<pre><code>npm install -g bower</code></pre>
</li>
<li>官网地址：<a href=""https://bower.io/"" rel=""nofollow noreferrer"">Bower-A package manager for the web</a>
</li>
</ol>
<hr>
<h2><a id=""browser-sync"">Browser-sync</a></h2>
<p>官网地址：<a href=""http://www.browsersync.cn/"" rel=""nofollow noreferrer"">http://www.browsersync.cn/</a></p>
<ol>
<li>
<p>全局安装 BrowserSync</p>
<pre><code>npm install -g browser-sync</code></pre>
</li>
<li>
<p>在您需要构建的项目里安装：</p>
<pre><code>npm install --save-dev browser-sync</code></pre>
</li>
<li>
<p>启动 BrowserSync：<br><strong>（1）</strong> 如果您想要监听.css文件, 您需要使用<em>服务器模式</em><br>   BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站</p>
<pre><code>   // --files 路径是相对于运行该命令的项目（目录） 
   browser-sync start --server --files ""*.css""</code></pre>
<p><strong>（2）</strong>如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件</p>
<pre><code>// --files 路径是相对于运行该命令的项目（目录）
browser-sync start --server --files ""*.css, *.html""
// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或.html文件
browser-sync start --server --files ""*.css, *.html""</code></pre>
<p><strong>（3）</strong>外网可以访问（不用连同一个网，wifi）</p>
<pre><code>browser-sync start --server --files ""*.css, *.html"" --tunnel</code></pre>
</li>
</ol>
<hr>
<h2><a id=""express"">Express</a></h2>
<ol>
<li>
<p>全局安装：</p>
<pre><code>npm install -g express-generator #4.0版本以上需先安装 express-generator
npm install -g express
npm install -g express@3.5.0     #按3.5版本安装就不需要安装 express-generator
express -V  #验证是否安装成功</code></pre>
</li>
<li>
<p>安装 Express 并将其保存到依赖列表</p>
<pre><code>npm install express --save</code></pre>
</li>
</ol>
<hr>
<h2><a id=""gulp"">Gulp</a></h2>
<ol>
<li>官网地址：<a href=""http://www.gulpjs.com.cn/"" rel=""nofollow noreferrer"">gulp-用自动化构建工具增强你的工作流程！</a>
</li>
<li>
<p>全局安装 gulp</p>
<pre><code>npm install --global gulp</code></pre>
</li>
<li>
<p>作为项目的开发依赖（devDependencies）安装</p>
<pre><code>npm install --save-dev gulp</code></pre>
</li>
</ol>
<hr>
<h2><a id=""grunt"">Grunt</a></h2>
<ol>
<li>官网地址：<a href=""http://www.gruntjs.net/"" rel=""nofollow noreferrer"">Grunt: JavaScript世界的构建工具</a>
</li>
<li>
<p>使用grunt，首先必须将grunt-cli安装到全局环境中</p>
<pre><code>npm install -g grunt-cli</code></pre>
</li>
<li>
<p>安装grunt</p>
<pre><code>npm install grunt --save-dev</code></pre>
</li>
</ol>
<hr>
<h2><a id=""yarn"">yarn</a></h2>
<ol>
<li>官网地址：<a href=""https://yarn.bootcss.com/"" rel=""nofollow noreferrer"">yarn - 一个可能取代npm的新型包管理器</a>
</li>
<li>官方下载地址：<a href=""https://yarn.bootcss.com/docs/install.html"" rel=""nofollow noreferrer"">https://yarn.bootcss.com/docs...</a>
</li>
</ol>
<hr>
<h2><a id=""sass"">sass</a></h2>
<ol>
<li>官网地址：<a href=""https://www.sass.hk/"" rel=""nofollow noreferrer"">Sass世界上最成熟、稳定和强大的CSS扩展语言</a>
</li>
<li>
<p>window下安装SASS首先需要安装Ruby</p>
<pre><code>gem install sass   # mac安装遇到权限问题需加 sudo gem install sass</code></pre>
</li>
</ol>
<hr>
<h2><a id=""vue"">Vue</a></h2>
<ol>
<li>官网地址：<a href=""https://cn.vuejs.org/"" rel=""nofollow noreferrer"">vue - 渐进式JavaScript 框架</a>
</li>
<li>
<p>安装vue:</p>
<pre><code>npm install vue</code></pre>
</li>
<li>
<p>Vue.js 官方命令行工具(<strong>脚手架</strong>)，可用于快速搭建大型单页应用:</p>
<pre><code># 全局安装 vue-cli
npm install --global vue-cli
# 创建一个基于 webpack 模板的新项目
vue init webpack my-project
# 安装依赖
cd my-project
npm install
npm run dev</code></pre>
</li>
</ol>
<hr>
<h2><a id=""angular"">Angular</a></h2>
<ol>
<li>官网地址：<a href=""https://angular.cn/"" rel=""nofollow noreferrer"">angular - 一套框架，多种平台同时适用手机与桌面</a>
</li>
<li>
<p>安装 angular:</p>
<pre><code>npm install angular</code></pre>
</li>
<li>
<p>安装 angular脚手架：</p>
<pre><code>npm install -g @angular/cli
# 生成一个新项目
ng new my-app
# 进入项目目录，并启动服务器
cd my-app
ng serve --open</code></pre>
</li>
</ol>
<hr>
<h2><a id=""react"">React</a></h2>
<ol>
<li>官网地址：<a href=""https://facebook.github.io/react/"" rel=""nofollow noreferrer"">React - 一种JAVASCRIPT库，用于构建用户接口</a>
</li>
<li>
<p>使用 create-react-app（类似一个脚手架工具gongju快速构建 React 开发环境：</p>
<pre><code>$ cnpm install -g create-react-app
$ create-react-app my-app
$ cd my-app/
$ npm start</code></pre>
</li>
</ol>
<hr>
<h2><a id=""more"">待续......</a></h2>
<hr>

                ", 前端开发环境的安装、搭建及配置,1531977823,261,1,269,1,1,https://segmentfault.com/a/1190000010081326
118,1,0,7,"
                    
<p>之前发过一系列有关 GitHub 的文章，有同学问了，GitHub 我大概了解了，Git 也差不多会使用了，但是 还是搞不清 GitHub 如何帮助我的工作，怎么提升我的工作效率？</p>
<p>问到点子上了，GitHub 其中一个最重要的作用就是发现全世界最优秀的开源项目，你没事的时候刷刷微博、知乎，人家没事的时候刷刷 GitHub ，看看最近有哪些流行的项目，久而久之，这差距就越来越大，那么如何发现优秀的开源项目呢？这篇文章我就来给大家介绍下。</p>
<h2>1. 关注一些活跃的大牛</h2>
<p>GitHub 主页有一个类似微博的时间线功能，所有你关注的人的动作，比如 star、fork 了某个项目都会出现在你的时间线上，这种方式适合我这种比较懒的人，不用主动去找项目，而这种基本是我每天获取信息的一个很重要的方式。不知道怎么关注这些人？那么很简单，关注我 stormzhang ，以及我 GitHub 上关注的一些大牛，基本就差不多了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008867342?w=1244&amp;h=1236"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>2. Trending</h2>
<p>点击下图的 Explore 菜单到“发现”页面</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008867343?w=1246&amp;h=732"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>紧接着点击 Trending 按钮</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010022781?w=2094&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这个 Trending 页面是干嘛的呢？直译过来就是趋势的意思，就是说这个页面你可以看到最近一些热门的开源项目，这个页面可以算是很多人主动获取一些开源项目最好的途径，可以选择「当天热门」、「一周之内热门」和「一月之内热门」来查看，并且还可以分语言类来查看，比如你想查看最近热门的 Android 项目，那么右边就可以选择 Java 语言。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008867344?w=2094&amp;h=874"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这样页面推荐大家每隔几天就去看下，主动发掘一些优秀的开源项目。</p>
<h2>3. Search</h2>
<p>除了 Trending ，还有一种最主动的获取开源项目的方式，那就是 GitHub 的 Search 功能。</p>
<p>举个例子，你是做 Android 的，接触 GitHub 没多久，那么第一件事就应该输入 android 关键字进行搜索，然后右上角选择按照 star 来排序，结果如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010022782?w=1084&amp;h=847"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果你是学习 iOS 的，那么不妨同样的方法输入 iOS 关键字看看结果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010022783?w=1127&amp;h=910"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以看到按照 star 数，排名靠前基本是一些比较火的项目，一定是很有用，才会这么火。值得一提的是左侧依然可以选择语言进行过滤。</p>
<p>而对于实际项目中用到一些库，基本上都会第一时间去 GitHub 搜索下有没有类似的库，比如项目中想采用一个网络库，那么不妨输入 android http 关键字进行搜索，因为我只想找到关于 Android 的项目，所以搜索的时候都会加上 android 关键字，按照 star 数进行排序，我们来看下结果：</p>
<p><span class=""img-wrap""><img data-src=""/image/github_search3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以看到 Retrofit、OkHttp、android-async-http 是最流行的网络库，只不过 android-async-http 的作者不维护了，之前很多人问我网络库用哪个比较好？哪怕你对每个网络库都不是很了解，那么单纯的按照这种方式你都该优先选择 Retrofit 或者 OkHttp，而目前绝大部分 Android 开发者确实也都是在用这两个网络库，当然还有部分在用 Volley 的，因为 google 没有选择在 GitHub 开源 volley，所以搜不到 volley 的上榜。</p>
<p>除此之外，GitHub 的 Search 还有一些小技巧，比如你想搜索的结果中 star 数大于1000的，那么可以这样搜索：</p>
<p>android http stars:&gt;1000</p>
<p>当然还有其他小技巧，但是我觉得不是很重要，就不多说了。</p>
<p>有些人如果习惯用 Google 进行搜索，那么想搜索 GitHub 上的结果，不妨前面加 GitHub 关键字就ok了，比如我在 google 里输入 GitHub android http ，每个关键字用空格隔开，然后搜索结果如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010022784?w=1772&amp;h=1332"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以看到，基本也是我们想要的结果，只不过排序就不是单纯的按照 star 来排序了。</p>
<h2>福利大放送</h2>
<p>相信以上三种方法够大家遨游在 GitHub 的海洋了，最后给大家献上一些福利，这些项目是 GitHub 上影响力很大，同时又对你们很有用的项目：</p>
<ul><li><p><a href=""https://github.com/vhf/free-programming-books"" rel=""nofollow noreferrer"">free-programming-books</a></p></li></ul>
<p>这个项目目前 star 数排名 GitHub 第三，总 star 数超过6w，这个项目整理了所有跟编程相关的免费书籍，而且全球多国语言版的都有，中文版的在这里：<a href=""https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md"" rel=""nofollow noreferrer"">free-programming-books-zh</a>，有了这个项目，理论上你可以获取任何编程相关的学习资料，强烈推荐给你们！</p>
<ul><li><p><a href=""https://github.com/robbyrussell/oh-my-zsh"" rel=""nofollow noreferrer"">oh-my-zsh</a></p></li></ul>
<p>俗话说，不会用 shell 的程序员不是真正的程序员，所以建议每个程序员都懂点 shell，有用不说，装逼利器啊！而 oh-my-zsh 毫无疑问就是目前最流行，最酷炫的 shell，不多说了，懂得自然懂，不懂的以后你们会懂的！</p>
<ul><li><p><a href=""https://github.com/sindresorhus/awesome"" rel=""nofollow noreferrer"">awesome</a></p></li></ul>
<p>GitHub 上有各种 awesome 系列，简单来说就是这个系列搜罗整理了 GitHub 上各领域的资源大汇总，比如有 awesome-android, awesome-ios, awesome-java, awesome-python 等等等，就不截图了，你们自行去感受。</p>
<ul><li><p><a href=""https://github.com/tiimgreen/github-cheat-sheet/"" rel=""nofollow noreferrer"">github-cheat-sheet</a></p></li></ul>
<p>GitHub 的使用有各种技巧，只不过基本的就够我们用了，但是如果你对 GitHub 超级感兴趣，想更多的了解 GitHub 的使用技巧，那么这个项目就刚好是你需要的，每个 GitHub 粉都应该知道这个项目。</p>
<ul><li><p><a href=""https://github.com/Trinea/android-open-project"" rel=""nofollow noreferrer"">android-open-project</a></p></li></ul>
<p>这个项目是我一个好朋友 Trinea 整理的一个开源项目，基本囊括了所有 GitHub 上的 Android 优秀开源项目，但是缺点就是太多了不适合快速搜索定位，但是身为 Android 开发无论如何你们应该知道这个项目。</p>
<ul><li><p><a href=""https://github.com/wasabeef/awesome-android-ui"" rel=""nofollow noreferrer"">awesome-android-ui</a></p></li></ul>
<p>这个项目跟上面的区别是，这个项目只整理了所有跟 Android UI 相关的优秀开源项目，基本你在实际开发终于到的各种效果上面都几乎能找到类似的项目，简直是开发必备。</p>
<ul><li><p><a href=""https://github.com/Freelander/Android_Data"" rel=""nofollow noreferrer"">Android_Data</a></p></li></ul>
<p>这个项目是我的邪教群的一位管理员整理的，几乎包括了国内各种学习 Android 的资料，简直太全了，我为这个项目也稍微做了点力，强烈推荐你们收藏起来。</p>
<ul><li><p><a href=""https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md"" rel=""nofollow noreferrer"">AndroidInterview-Q-A</a></p></li></ul>
<p>这个就不多说了，之前给大家推荐过的，国内一线互联网公司内部面试题库。</p>
<ul><li><p><a href=""https://github.com/GeniusVJR/LearningNotes"" rel=""nofollow noreferrer"">LearningNotes</a></p></li></ul>
<p>这是一份非常详细的面试资料，涉及 Android、Java、设计模式、算法等等等，你能想到的，你不能想到的基本都包含了，可以说是适应于任何准备面试的 Android 开发者，看完这个之后别说你还不知道怎么面试！</p>
<h2>总结</h2>
<p>GitHub 上优秀开源项目真的是一大堆，就不一一推荐了，授人以鱼不如授人以渔，请大家自行主动发掘自己需要的开源项目吧，不管是应用在实际项目上，还是对源码的学习，都是提升自己工作效率与技能的很重要的一个渠道，总有一天，你会突然意识到，原来不知不觉你已经走了这么远！</p>
<p>觉得不错，不妨随手转发、点赞，都是对我良心张莫大的鼓励！</p>

                ", 从0开始学习 GitHub 系列之「如何发现优秀的开源项目？」,1531977825,407,1,488,1,1,https://segmentfault.com/a/1190000010022776
119,1,0,7,"
                    
<p>Git 相比于 SVN 最强大的一个地方就在于「分支」，Git 的分支操作简直不要太方便，而实际项目开发中团队合作最依赖的莫过于分支了，关于分支前面的系列也提到过，但是本篇会详细讲述什么是分支、分支的具体操作以及实际项目开发中到底是怎么依赖分支来进行团队合作的。</p>
<h2>1. 什么是分支？</h2>
<p>我知道读者中肯定有些人对分支这个概念比较模糊，其实你们可以这么理解，你们几个人一起去旅行，中间走到一个三岔口，每条路可能有不同的风景，你们约定 3 天之后在某地汇聚，然后各自出发了。而这三条分叉路就可以理解成你们各自的分支，而等你们汇聚的时候相当于把你们的分支进行了合并。</p>
<h2>2. 分支的常用操作</h2>
<p>通常我们默认都会有一个主分支叫 master ，下面我们先来看下关于分支的一些基本操作：</p>
<ul><li><p>新建一个叫 develop 的分支</p></li></ul>
<pre><code>git branch develop    
</code></pre>
<p>这里稍微提醒下大家，新建分支的命令是基于当前所在分支的基础上进行的，即以上是基于 mater 分支新建了一个叫做 develop 的分支，此时 develop 分支跟 master 分支的内容完全一样。如果你有 A、B、C三个分支，三个分支是三位同学的，各分支内容不一样，如果你当前是在 B 分支，如果执行新建分支命令，则新建的分支内容跟 B 分支是一样的，同理如果当前所在是 C 分支，那就是基于 C 分支基础上新建的分支。</p>
<ul>
<li>
<p>切换到 develop 分支    </p>
<p>git checkout develop</p>
</li>
<li><p>如果把以上两步合并，即新建并且自动切换到 develop 分支：</p></li>
</ul>
<pre><code>git checkout -b develop    
</code></pre>
<ul>
<li>
<p>把 develop 分支推送到远程仓库    </p>
<p>git push origin develop</p>
</li>
<li>
<p>如果你远程的分支想取名叫 develop2 ，那执行以下代码：    </p>
<p>git push origin develop:develop2</p>
</li>
</ul>
<p>但是强烈不建议这样，这会导致很混乱，很难管理，所以建议本地分支跟远程分支名要保持一致。</p>
<ul>
<li>
<p>查看本地分支列表    </p>
<p>git branch</p>
</li>
<li>
<p>查看远程分支列表    </p>
<p>git branch -r</p>
</li>
<li>
<p>删除本地分支    </p>
<p>git branch -d develop    </p>
<p>git branch -D develop (强制删除)</p>
</li>
<li>
<p>删除远程分支    </p>
<p>git push origin :develop</p>
</li>
<li>
<p>如果远程分支有个 develop ，而本地没有，你想把远程的 develop 分支迁到本地：    </p>
<p>git checkout develop origin/develop</p>
</li>
<li>
<p>同样的把远程分支迁到本地顺便切换到该分支：    </p>
<p>git checkout -b develop origin/develop</p>
</li>
</ul>
<h2>3. 基本的团队协作流程</h2>
<p>一般来说，如果你是一个人开发，可能只需要 master、develop 两个分支就 ok 了，平时开发在 develop 分支进行，开发完成之后，发布之前合并到 master 分支，这个流程没啥大问题。</p>
<p>如果你是 3、5 个人，那就不一样了，有人说也没多大问题啊，直接可以新建 A、B、C 三个人的分支啊，每人各自开发各自的分支，然后开发完成之后再逐步合并到 master 分支。然而现实却是，你正在某个分支开发某个功能呢，这时候突然发现线上有一个很严重的 bug ，不得不停下手头的工作优先处理 bug ，而且很多时候多人协作下如果没有一个规范，很容易产生问题，所以多人协作下的分支管理规范很重要，就跟代码规范一样重要，以下就跟大家推荐一种我们内部在使用的一种分支管理流程 Git Flow。</p>
<h2>4. Git Flow</h2>
<p>准确的说 Git Flow 是一种比较成熟的分支管理流程，我们先看一张图能清晰的描述他整个的工作流程：    </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006777280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>第一次看上面那个图是不是一脸懵逼？跟我当时一样，不急，我来用简单的话给你们解释下。    </p>
<p>一般开发来说，大部分情况下都会拥有两个分支 master 和 develop，他们的职责分别是：</p>
<ul>
<li><p>master：永远处在即将发布(production-ready)状态</p></li>
<li><p>develop：最新的开发状态</p></li>
</ul>
<p>确切的说 master、develop 分支大部分情况下都会保持一致，只有在上线前的测试阶段 develop 比 master 的代码要多，一旦测试没问题，准备发布了，这时候会将 develop 合并到 master 上。    </p>
<p>但是我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug ，一个功能开发完成之后突然需求变动了等情况，所以 Git Flow 除了以上 master 和 develop 两个主要分支以外，还提出了以下三个辅助分支：</p>
<ul>
<li><p>feature:  开发新功能的分支, 基于 develop, 完成后 merge 回 develop</p></li>
<li><p>release: 准备要发布版本的分支, 用来修复 bug，基于 develop，完成后 merge 回 develop 和 master</p></li>
<li><p>hotfix: 修复 master 上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge 回 master 和 develop</p></li>
</ul>
<p>什么意思呢？    </p>
<p>举个例子，假设我们已经有 master 和 develop 两个分支了，这个时候我们准备做一个功能 A，第一步我们要做的，就是基于 develop 分支新建个分支：</p>
<pre><code>git branch feature/A    
</code></pre>
<p>看到了吧，其实就是一个规范，规定了所有开发的功能分支都以 feature 为前缀。    </p>
<p>但是这个时候做着做着发现线上有一个紧急的 bug 需要修复，那赶紧停下手头的工作，立刻切换到 master 分支，然后再此基础上新建一个分支：</p>
<pre><code>git branch hotfix/B    
</code></pre>
<p>代表新建了一个紧急修复分支，修复完成之后直接合并到 develop 和 master ，然后发布。    </p>
<p>然后再切回我们的 feature/A 分支继续着我们的开发，如果开发完了，那么合并回 develop 分支，然后在 develop 分支属于测试环境，跟后端对接并且测试的差不多了，感觉可以发布到正式环境了，这个时候再新建一个 release 分支：</p>
<pre><code>git branch release/1.0    
</code></pre>
<p>这个时候所有的 api、数据等都是正式环境，然后在这个分支上进行最后的测试，发现 bug 直接进行修改，直到测试 ok 达到了发布的标准，最后把该分支合并到 develop 和 master 然后进行发布。    </p>
<p>以上就是 Git Flow 的概念与大概流程，看起来很复杂，但是对于人数比较多的团队协作现实开发中确实会遇到这么复杂的情况，是目前很流行的一套分支管理流程，但是有人会问每次都要各种操作，合并来合并去，有点麻烦，哈哈，这点 Git Flow 早就想到了，为此还专门推出了一个 Git Flow 的工具，并且是开源的：</p>
<p>GitHub 开源地址：<a href=""https://github.com/nvie/gitflow"" rel=""nofollow noreferrer"">https://github.com/nvie/gitflow</a></p>
<p>简单点来说，就是这个工具帮我们省下了很多步骤，比如我们当前处于 master 分支，如果想要开发一个新的功能，第一步切换到 develop 分支，第二步新建一个以 feature 开头的分支名，有了 Git Flow 直接如下操作完成了：</p>
<pre><code>git flow feature start A    
</code></pre>
<p>这个分支完成之后，需要合并到 develop 分支，然而直接进行如下操作就行：</p>
<pre><code>git flow feature finish A    
</code></pre>
<p>如果是 hotfix 或者 release 分支甚至会自动帮你合并到 develop、master 两个分支。    </p>
<p>想必大家已经了解了这个工具的具体作用，具体安装与用法我就不多提了，感兴趣的可以看我下我之前写过的一篇博客：    </p>
<p><a href=""/git/2014/01/29/git-flow/"" rel=""nofollow noreferrer"">http://stormzhang.com/git/2014/01/29/git-flow/</a></p>
<h2>5. 总结</h2>
<p>以上就是我分享给你们的关于分支的所有知识，一个人你也许感受不到什么，但是实际工作中大都以团队协作为主，而分支是团队协作必备技能，而 Git Flow 是我推荐给你们的一个很流行的分支管理流程，也是我们薄荷团队内部一直在实践的一套流程，希望对你们有借鉴意义。</p>

                ", 从0开始学习 GitHub 系列之「团队合作利器 Branch」,1531977826,403,1,446,1,1,https://segmentfault.com/a/1190000009997044
120,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVP3wE?w=900&amp;h=385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>相信每一个程序猿都听说过 GitHub 了，简单来说 GitHub 是一个主要提供基于 Git 来进行版本控制的项目托管服务的网站，她是世界上最大的开源软件社区，世界各地的程序猿在 GitHub 上开源自己的项目，关注和参与自己感兴趣的开源项目，嗯，同时 GitHub 还是世界上最大的同性交友网站。</p>
<h2>什么是 GitHub</h2>
<p>先来了解下 Git 和 GitHub 到底是个什么关系吧~</p>
<p><a href=""https://segmentfault.com/p/1210000009474346/read"" rel=""nofollow noreferrer"">大白话解释 Git 和 GitHub</a></p>
<blockquote><p>本文旨在使用通俗易懂的文字，讲解版本控制背后的理论，以便你能对程序员们如何工作有个全局概念。</p></blockquote>
<p>求职面试时，你肯定看到过或者听说过在 GitHub 上有开源项目或是参加过别人的开源项目是加分项，甚至有面试官要求提供 GitHub 账号地址，那么 GitHub 到底为什么这么重要呢？</p>
<p><a href=""https://segmentfault.com/p/1210000009962531"" rel=""nofollow noreferrer"">［码农必知］GitHub</a></p>
<blockquote>
<p>知乎上面有人总结了 GitHub 的基本功能：</p>
<ul>
<li><p>GitHub 是社交网站，具有和社交网站相同的好友、评论、赞、讨论等功能。</p></li>
<li><p>任何人均可参与其他人的代码仓库的开发。（当然不能直接改人家的代码。）</p></li>
<li><p>协同开发与编程，而且支持互相评论。</p></li>
<li><p>通过 Git 版本控制系统来提高生产力。</p></li>
</ul>
</blockquote>
<h2>GitHub 入门</h2>
<p>非常给力的从 0 开始系列，还不太熟悉的小伙伴们赶紧来学习 GitHub 吧！</p>
<p><a href=""https://segmentfault.com/a/1190000005341489"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「初识 GitHub」</a></p>
<blockquote><p>我是从小白一路过来的，很能理解你们内心的感受与困惑，因为这些阶段都是我自己亲身经历过的，所以我写的文章都会从你们的角度去出发，并且我对文章高要求，除了排版、配图很用心外，文章的内容每次写完我都会亲自看三四遍，确保不会出现误导以及你们理解不了的情况，你们看的很轻松易懂的文章其实因为我背后做了很多的功课。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005611460"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「加入 GitHub」</a></p>
<blockquote><ul>
<li><p>注册 GitHub</p></li>
<li><p>认识 GitHub</p></li>
<li><p>GitHub 主页</p></li>
<li><p>设置你的 GitHub</p></li>
<li><p>GitHub 基本概念</p></li>
<li><p>创建自己的项目</p></li>
</ul></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005713232"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「Git 速成」</a></p>
<blockquote><p>GitHub 是基于 Git 的，所以也就意味着 Git 是基础，如果你不会 Git ，那么接下来你完全继续不下去，所以今天的教程就来说说 Git ，当然关于 Git 的知识单凭一篇文章肯定说不完的，我这篇文章先介绍一些最基本的、最常用的一些 Git 知识，争取让你们 Git 速成。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005713288"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「向GitHub 提交代码」</a></p>
<blockquote>
<p>上一篇文章只介绍了对本地 Git 仓库的基本操作，今天我就来介绍下如何跟远程仓库一起协作，教你们向 GitHub 上提交你们的第一行代码！</p>
<ul>
<li><p>SSH</p></li>
<li><p>生成SSH key</p></li>
<li><p>GitHub 上添加 SSH key</p></li>
<li><p>Push &amp; Pull</p></li>
<li><p>提交代码</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000005869506"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「Git 进阶」</a></p>
<blockquote>
<p>关于 Git 相信大家看了之前一系列的文章已经初步会使用了， 但是关于Git还有很多知识与技巧是你不知道的，今天就来给大家介绍下一些 Git 进阶的知识。</p>
<ul>
<li><p>用户名和邮箱</p></li>
<li><p>alias</p></li>
<li><p>其他配置</p></li>
<li><p>diff</p></li>
<li><p>checkout</p></li>
<li><p>stash</p></li>
<li><p>merge &amp; rebase</p></li>
<li><p>解决冲突</p></li>
</ul>
</blockquote>
<h2>SSH 深入研究</h2>
<blockquote><p>SSH 是一种网络协议，用于计算机之间的加密登录。目前是每一台 Linux 电脑的标准配置。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009576148/read"" rel=""nofollow noreferrer"">SSH相关知识</a></p>
<blockquote><p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005779677"" rel=""nofollow noreferrer"">Git自由之章 - 关于 SSH 公钥</a></p>
<blockquote>
<p>简单来说，SSH提供了两种级别的安全验证：</p>
<ul>
<li><p>第一种级别是基于密码的安全验证，知道账号和密码，就可以登陆到远程主机。<br>Team的开发工作中，就是使用这种方式登陆编译服务器，或者开发机器。因为是在内网中，这种级别的安全验证已经足够了。</p></li>
<li><p>第二种级别是基于Public-key cryptography (公开密匙加密）机制的安全验证。</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000009567424"" rel=""nofollow noreferrer"">（Git 学习）Git SSH Key 创建步骤</a></p>
<blockquote><p>首先：查看你是否有../ssh 这个文件；<br>怎么查看；找到你的git安装目录，在安装目录下查看是否./ssh</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000585526"" rel=""nofollow noreferrer"">如何优雅地连接ssh</a></p>
<blockquote><p>作为一个开发者，经常要面对管理一大堆服务器的情况，对unix类服务器，我们一般用ssh连接来管理。那么你一般怎么连接ssh，输入密码？弱爆了，既难得记，又不安全。现在俺们都用证书来连接</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002669374"" rel=""nofollow noreferrer"">ssh登录的调试方法和常见问题</a></p>
<blockquote><p>ssh登录服务器是程序猿日常生活必不可少的一部分，也时不时的会遇到自己配置ssh登录的问题，拿日常使用的git来讲，不管使用github也好，还是自己搭建的gitlab等等，如果不能很好的理解ssh的原理，极容易遇到各种问题。这篇文章就尝试向大家简单讲解下ssh的原理、调试方式和常见问题。这里要讲的主要是免密码登录，也就是使用密钥登录的方式。</p></blockquote>
<p>下面这个问题相信一定有小伙伴遇到过。</p>
<p><a href=""https://segmentfault.com/a/1190000008435592"" rel=""nofollow noreferrer"">解决向github提交代码不用输入帐号密码</a></p>
<blockquote><p>方案一与方案二都是创建  .git-credential 文件并写入用户信息，一个是手动创建，一个命令创建。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005607713"" rel=""nofollow noreferrer"">git:如何管理本机的多个ssh密钥</a></p>
<blockquote><p>我们可能会需要在一台电脑上以不同的github账户去使用git，这时就需要去解决如何管理本机上的多个ssh key的问题了。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000430544"" rel=""nofollow noreferrer"">git/ssh捋不清的几个问题</a></p>
<blockquote><p>主要是 windows 用户会遇到很多纠结的问题，linux/unix 用户属于这方面的高端用户，应该有能力处理此类问题，而且网络上也有很多解决方案，本文的受众是 windows 用户。由于今天配置了一下午，虽说配置过程基本搞清楚，懒得重新配置一遍，所以文中皆以文字形式叙述，没有截图。</p></blockquote>
<h2>个人博客</h2>
<blockquote><p>GitHub Pages 是通过我们的网站托管和发布的公共网页。<br>你可以通过在线生成器创建和发布GitHub Pages页面。如果你偏爱本地操作，你可以使用Mac和Windows的GUI软件，或者是命令行。</p></blockquote>
<h3>GitHub Pages</h3>
<p><a href=""https://segmentfault.com/a/1190000002473246"" rel=""nofollow noreferrer"">Github 是如何用 Github 撰写 Github 文档的</a></p>
<blockquote><p>文档团队通过 Github 利用 Github 的工作流程（译者注：即前文提到的 Markdown 编写内容，PR 提交等），Jekyll 以及 Github Pages 服务来提供一个高质量的文档。Github Pages 提供给我们文档团队的好处同样对每一个运行 Github Pages 的站点都是可用的。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002881418"" rel=""nofollow noreferrer"">使用github的pages服务建立项目主页的注意事项</a></p>
<blockquote><ul>
<li><p>确保你的username.github.io不会跳到别的站点</p></li>
<li><p>解决gh-pages分支clone到本地后出现push冲突</p></li>
</ul></blockquote>
<p>有任何问题，可以查看帮助文档。</p>
<p><a href=""https://segmentfault.com/a/1190000003776905"" rel=""nofollow noreferrer"">翻译自 GitHub Pages的 Help 页面（仍在更新中）</a></p>
<h3>Jekyll</h3>
<p>又一个系列教程。</p>
<p><a href=""https://segmentfault.com/a/1190000000406011"" rel=""nofollow noreferrer"">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>
<blockquote><p>Jekyll将原始文本根据一定规则转换成静态的网页和博客。但这个转换并不是简单的字符串替换就了事了，而是首先读取各个文件中的内容，根据配置文件中描述的参数在内存中构建一个巨大的对象存储整个博客的信息，然后再将这些信息根据配置文件中定义的输出方式来生成具体的HTML文件。整个项目是由Ruby写的，所以若需要在本地调试则需要安装Ruby。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000406013"" rel=""nofollow noreferrer"">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>
<blockquote><p>这篇文章主要介绍博客内容的编写及本地测试，内容主要来自Jekyll的文档、Liquid的文档</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000406015"" rel=""nofollow noreferrer"">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>
<blockquote><p>之前已经介绍了如何搭建环境和如何创建整个博客项目，并编写了博文，这篇文章主要就是介绍分页功能如何通过jekyll实现。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000406017"" rel=""nofollow noreferrer"">使用Jekyll在Github上搭建个人博客（文章分类索引）</a></p>
<blockquote><ul>
<li><p>使用Category分类</p></li>
<li><p>使用文章标签索引文章</p></li>
</ul></blockquote>
<p><a href=""https://segmentfault.com/a/1190000000406019"" rel=""nofollow noreferrer"">使用Jekyll在Github上搭建个人博客（将本地博客上传至github）</a></p>
<blockquote><ul>
<li><p>预先准备</p></li>
<li><p>对已有项目进行git初始化</p></li>
<li><p>创建一个名为gh-pages的分支</p></li>
<li><p>发布</p></li>
<li><p>上传到github</p></li>
<li><p>修改后提交</p></li>
</ul></blockquote>
<h3>hexo</h3>
<p>hexo，更快，更轻，更简洁。你值得拥有~</p>
<p><a href=""https://segmentfault.com/a/1190000000458953"" rel=""nofollow noreferrer"">使用Github搭建静态博客（Hexo）</a></p>
<blockquote><p>之前我一直在使用wordpress（下称wp），就在前些日子，我爱上了markdown，但在wp上又没找到完美一点兼容markdown的插件。慢慢地，越来越觉得wp很臃肿，最终，我选择了放弃它了。现在，我选择了一个基于node.js的小萝莉hexo。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005133715"" rel=""nofollow noreferrer"">途牛原创｜如何使用 hexo＋github 搭建个人博客</a></p>
<blockquote><p>要想搭建漂亮的 blog，还需要模板系统，官方推荐的是 jekyll，但是配置稍复杂，今天推荐另一个选择 —— hexo，一个简单地、轻量地、基于 Node 的一个静态博客框架。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005013053"" rel=""nofollow noreferrer"">使用 hexo + github pages快速搭建个人博客</a></p>
<blockquote><p>Hexo是一个基于Nodejs快速简洁高效的博客框架，Hexo使用Markdown语法来编辑文章，只需要几秒钟的时间就可以成生静态的网页。整个系统就是一个博客系统。</p></blockquote>
<h3>Github Issues</h3>
<p>嗯，是的，github issues 还可以这样用。</p>
<p><a href=""https://segmentfault.com/a/1190000002910568"" rel=""nofollow noreferrer"">基于 Github Issues 的单页面静态博客</a></p>
<blockquote>
<p>Wordpress 、Typecho 太重，还要买 VPS、部署服务器环境、安装插件、主题，太折腾人，于是我想，完全可以利用 Github 提供的 API 来实现一个只有一个静态页面的博客，具体思路如下：</p>
<ul>
<li><p>作者在 Github issues 上写文章（写 issues）</p></li>
<li><p>博客页面通过 JS Ajax 请求 Github API 来获取文章内容，进行页面的渲染</p></li>
<li><p>通过社会化评论插件实现评论功能</p></li>
</ul>
<p>于是花了几天时间实现了这个设想</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000009867081/read"" rel=""nofollow noreferrer"">Gitment：使用 GitHub Issues 搭建评论系统</a></p>
<blockquote><p>Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p></blockquote>
<h2>展示自己的项目</h2>
<p><a href=""https://segmentfault.com/a/1190000004639130"" rel=""nofollow noreferrer"">用Github Pages展示你的项目</a></p>
<blockquote><p>Github Pages，让用户能够自定义项目首页，同时，让其编写的网页能够通过域名访问直接展示出来。Github Pages被当作是用户编写的、托管在github上的静态网页，Github提供了一定的空间供开发者存放静态网页。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000008425992"" rel=""nofollow noreferrer"">如何在github上创建个人项目的在线演示demo</a></p>
<blockquote><p>在github上搜索相关项目时会发现，有的项目不光写了一手好文档并且还给出了项目的在线运行Demo。事实胜于雄辩，一个在线演示可能给项目带来更好的印象分。如何在github上维护自己个人项目源代码的同时并生成项目主页呢？</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000007544336"" rel=""nofollow noreferrer"">用github来展示你的前端页面吧</a></p>
<blockquote><p>经常会有人问我如何才能将自己做的静态页面放到网上供他人欣赏，是不是需要自己有一个服务器，是不是还要搞个域名才能访问？对于以上问题我都会回答：用github来展示你的前端页面吧。</p></blockquote>
<h2>优秀的开源项目</h2>
<p><a href=""https://segmentfault.com/a/1190000009475248"" rel=""nofollow noreferrer"">大牛公司github官网整理</a></p>
<p><a href=""https://segmentfault.com/p/1210000008030675/read"" rel=""nofollow noreferrer"">2016 年度 GitHub 上 Stars 最多的10个项目</a></p>
<p><a href=""https://segmentfault.com/a/1190000008997798"" rel=""nofollow noreferrer"">工作中经常用到github上优秀、实用、轻量级、无依赖的插件和库</a></p>
<p><a href=""https://segmentfault.com/a/1190000002804472"" rel=""nofollow noreferrer"">github上值得关注的前端项目</a></p>
<p><a href=""https://segmentfault.com/a/1190000008095948"" rel=""nofollow noreferrer"">react闲谈——推荐几个github上超级star的异步插件</a></p>
<h2>GitHub 助攻利器</h2>
<p><a href=""https://segmentfault.com/a/1190000008382540"" rel=""nofollow noreferrer"">用Node.js做一个GitHub爬虫</a></p>
<blockquote><p>用Node.js写了一个爬虫,可以获取GitHub各种编程语言star数前十的库</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000008342990"" rel=""nofollow noreferrer"">分享一个自己写的github-trending小工具</a></p>
<blockquote><p>Github Trending基本上是我每天都会浏览的网页，上面会及时发布一些GIthub上比较有潜力的项目，或者说每日Star数增量排行榜。<br>不过由于Github Trending经常会实时更新，即使你访问得再勤，难免还是会错过一些你感兴趣的项目，为此不少人都想出了自己的解决办法，例如josephyzhou，他的github-trending 项目得到了众多人的青睐，我仔细阅读了他的源码 (Go)，发现实现也较为简单, 就用Python 重写了一下，发现代码少了好多,详见 我的 github-trending。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008325834/read"" rel=""nofollow noreferrer"">专门为Github党打造的超级无敌Chrome插件</a></p>
<blockquote><p>作为GitHub党，分享一些好用的Chrome插件，帮助增强Github功能。标题名称在Chrome插件商场搜索，即可安装对应的插件。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000006936770/read"" rel=""nofollow noreferrer"">如果你用GitHub，可以这样提高效率 | BlueSun</a></p>
<blockquote><p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000007671099"" rel=""nofollow noreferrer"">Git-WebHook 自动化部署工具 - 支持Github / GitLab / Gogs / GitOsc</a></p>
<blockquote><p>Git WebHook 是一个使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维系统，支持：Github / GitLab / Gogs / GitOsc。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000006024686"" rel=""nofollow noreferrer"">【Chrome插件】Github Travis Stat</a></p>
<blockquote><p>最近自己写了一个Chrome浏览器扩展/插件(github repo)，并将其发布到了谷歌官方商店(chrome web store)，该插件为github上的仓库提供travis-ci运行状态和运行时间的图表，你可以直观地了解到哪些仓库（自己或者别人的）开通了travis-ci的build，还可以看到特定repo近十次build的时间和状态变化，鼠标置于具体build上，还可查看具体build时间和message，点击还可以进入特定的travis-ci build页面。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002944416"" rel=""nofollow noreferrer"">Chrome插件 GitHub-Chart Commits3D直方图视图</a></p>
<blockquote><p>现在没有多少人不用github，使用频率很高，首页的contributions对于我们了解自己和别人的提交记录比较有帮助，简直是交友神器，修改成立体直方图以后更加直观。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005097085"" rel=""nofollow noreferrer"">[开源] 分享自己用的 GitHub 分组管理工具.</a></p>
<blockquote><p>我们平时搜索发现 GitHub 上的不错的 Repo 就点 Star 的方式收藏了起来，想哪天会用到，但真的要用时也想不起来叫什么了，而且越收藏就越多，找出来也很费劲的，网友呼吁 GitHub 出个 Tag 的功能，但官方似乎已经回应不会做此功能了。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000004938777"" rel=""nofollow noreferrer"">Markcook 1.2，超轻的开源markdown编辑器</a></p>
<blockquote><p>使用了vue.js+webpack进行开发和构建。非常的简单，高效，没有多余的东西。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000004302628"" rel=""nofollow noreferrer"">保存代码段的利器Gist &amp; GistBox</a></p>
<blockquote><p>GitHub提供的Gist服务简直是保存代码段的神器！可以把gist当做一个小型仓库，具有版本控制，markdown。从网上的搜索的结果来看，好像在10年就推出了这项服务，真是知道的太晚了！请允许我大呼『工具改变生活！』『工具改变程序员的生活！』</p></blockquote>
<h2>GitHub 小贴士</h2>
<p><a href=""https://segmentfault.com/a/1190000009649780"" rel=""nofollow noreferrer"">github emoji 表情列表</a></p>
<p><a href=""https://segmentfault.com/a/1190000003830252"" rel=""nofollow noreferrer"">关于 Git 和 Github 你不知道的十件事</a></p>
<p><a href=""https://segmentfault.com/p/1210000009518723/read"" rel=""nofollow noreferrer"">github博客绑定个性域名</a></p>
<p><a href=""https://segmentfault.com/a/1190000006820290"" rel=""nofollow noreferrer"">程序员必备技能：在Github上部署自己的简历</a></p>
<p><a href=""https://segmentfault.com/p/1210000009722731/read"" rel=""nofollow noreferrer"">第三方登入例子-GitHub授权登入（node-koa）</a></p>
<p><a href=""https://segmentfault.com/a/1190000005944521"" rel=""nofollow noreferrer"">Github用法总结（持续更新）</a></p>
<p><a href=""https://segmentfault.com/p/1210000008733982/read"" rel=""nofollow noreferrer"">跟着 Github 学习 Restful HTTP API 设计</a></p>
<p><a href=""https://segmentfault.com/a/1190000000601562"" rel=""nofollow noreferrer"">Markdown的各种扩展</a></p>
<p><a href=""https://segmentfault.com/a/1190000006669149"" rel=""nofollow noreferrer"">GitHub：技巧集合</a></p>
<p><a href=""https://segmentfault.com/a/1190000003946969"" rel=""nofollow noreferrer"">单个GitHub帐号下添加多个GitHub Pages的相关问题</a></p>
<p><a href=""https://segmentfault.com/a/1190000009145735"" rel=""nofollow noreferrer"">面试经：GitHub</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVP744?w=1906&amp;h=886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", SegmentFault 技术周刊 Vol.28 - GitHub —— 你不得不上的交友网站,1531977827,558,1,857,1,1,https://segmentfault.com/a/1190000009985489
121,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVPFJP?w=900&amp;h=385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Git 的诞生是一个非常有趣的故事。1991年 Linus 开源了 Linux 内核，无数 Linux 爱好者在世界各地为 Linux 编写代码，那么问题来了，这些代码该如何管理呢？起初 Linus 使用 BitKeeper(BitMover 公司的版本控制软件)管理 Linux 的核心开发，后来 BitMover 停止了对 Linux 的支持，于是 Linus 秉承自己的版本自己写的精神，花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git。</p>
<h2>Git 入门</h2>
<p><a href=""https://segmentfault.com/a/1190000005695097"" rel=""nofollow noreferrer"">使用原理视角看 Git</a></p>
<blockquote><p>传统的设计方案我们可以简单的分成两块：工作目录，远程仓库。但是作为一个目标明确的分布式版本控制系统，首先要做的就是添加一个本地仓库。接着我们选择在工作目录与远程仓库中间加一个缓冲区域，叫做暂存区。</p></blockquote>
<p>如果还是没弄懂，那再来看看这篇精简版的吧。</p>
<p><a href=""https://segmentfault.com/p/1210000008103366/read"" rel=""nofollow noreferrer"">看完还不会用的GIT操作,你就掐死我</a></p>
<blockquote><p>无论你是前端还是后台，无论是运维还是移动端研发，GIT是逃避不了的东西，当然你说你要用SVN，那不在这次的讨论范围之内。不多说，请看下文GIT图解分析，10分钟学会git操作，当然下面的教程是为实战为主，会跟你在别的网站看到的不一样。</p></blockquote>
<p>实战是掌握一个工具最快的方法。</p>
<p><a href=""https://segmentfault.com/a/1190000005370037"" rel=""nofollow noreferrer"">Git 实战详解</a></p>
<blockquote><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p></blockquote>
<p>实战结束，来闯关试试学会了多少。</p>
<blockquote><p>为保大家都能顺利通关，学到所有的知识点，接下来我会写过关攻略，详细介绍每一关的玩法。并且我不会直接给答案，而是演示整个过关的过程。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000004222489"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树</a></p>
<p><a href=""https://segmentfault.com/a/1190000004234194"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树 (一)</a></p>
<p><a href=""https://segmentfault.com/a/1190000005123830"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树 (二)</a></p>
<p><a href=""https://segmentfault.com/a/1190000005160940"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树 (三)</a></p>
<p><a href=""https://segmentfault.com/a/1190000005342274"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树 (四)</a></p>
<p><a href=""https://segmentfault.com/a/1190000006214703"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树 (五) - 完结篇</a></p>
<p>附上备忘小手册。</p>
<p><a href=""https://segmentfault.com/a/1190000009320754"" rel=""nofollow noreferrer"">git 常用操作</a></p>
<blockquote><ul>
<li><p>第一次连接远程仓库的配置</p></li>
<li><p>管理修改</p></li>
<li><p>撤销修改(没有提交的[commit])</p></li>
<li><p>删除文件</p></li>
<li><p>创建与合并分支</p></li>
<li><p>Bug分支管理</p></li>
<li><p>远程仓库的操作</p></li>
</ul></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009387659/read"" rel=""nofollow noreferrer"">git常用命令</a></p>
<blockquote><p>下面是自己学习使用git的常用的命令，还有些使用过程中碰到问题的解决办法，现整理如下。</p></blockquote>
<h2>Git 深入理解</h2>
<p>相信经过上面的入门以后，再对比下面的图解会更有收获和体会。</p>
<p><a href=""https://segmentfault.com/a/1190000007067265"" rel=""nofollow noreferrer"">git 图解 1：代码区域总结</a></p>
<blockquote><p>本文背景，在实际项目中使用git已有一年多，发现不少同事虽然会使用常用git指令，但并不理解每个指令对应的作用原理。今天静下心总结下git 的基本理解：代码的存在区域；本文以实际项目出发，理清使用git过程中，代码的迁徙流程。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000007070302"" rel=""nofollow noreferrer"">git 图解 2：代码回退</a></p>
<blockquote><p>场景： 提交了一个commit（该提交包含很多文件）， 发现有问题， 需要回滚， 将线上分支（master）回滚到上一次commit。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000009091082"" rel=""nofollow noreferrer"">git 图解 3：分支操作</a></p>
<blockquote><p>git 的分支是它最明显的特性， 大部分人听别人推荐使用git都会听到“git分支操作方便...”，对比其他版本控制系统git 分支操作有难以置信的轻量，创建新分支几乎瞬间完成，不同分支之间切换也非常快捷方便；本文将结合实践以及绘图归纳、总结git常见的分支操作指令以及注意事项。</p></blockquote>
<p>终于看完了，最后再来总结回顾一下。</p>
<p><a href=""https://segmentfault.com/a/1190000007497383"" rel=""nofollow noreferrer"">全面理解 Git</a></p>
<blockquote><p>个人觉得git是需要认真学的，虽然是个工具但不学习很容易把自己弄糊涂，希望这篇博客可以在某些时候帮到您，让您大概理解git的工作原理并把基本命令串起来。那么下面就说一下Git重要的基本命令吧。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008819445/read"" rel=""nofollow noreferrer"">深入浅出 Git</a></p>
<blockquote><p>本文专注于支撑 Git 的图结构以及这些图的性质影响 Git 行为的方式。通过了解底层，你可以将你心中对 Git 的模型建立在事实之上，而不是基于通过积累使用经验而建立的假设上。这个更真实的模型可以让你更好的理解 Git 做了什么，正在做什么以及将要做什么。</p></blockquote>
<h2>Git 进阶</h2>
<p><a href=""https://segmentfault.com/a/1190000005730658"" rel=""nofollow noreferrer"">Git 分支管理</a></p>
<blockquote>
<p>Master 是 Git 默认的主分支，版本库初始化以后，默认就是在主分支在进行开发。master分支代码最完整，最干净，用于生产环境。</p>
<p>主分支只用来发布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支叫做Develop。</p>
<p>还有一些辅助开发分支，用于应对一些特定目的的版本开发。</p>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000006185954"" rel=""nofollow noreferrer"">git的reset和checkout的区别</a></p>
<blockquote><p>在讲git的reset和checkout的区别之前，不得不说说HEAD、Index、Working Directory三个区域。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000007942341"" rel=""nofollow noreferrer"">Git系列之Merging vs. Rebasing</a></p>
<blockquote><p>git rebase因其“新手应当远离的Git黑魔法”的名号名声在外，但只要使用得当，其可以使团队开发变得无比轻松。本文将对比两个相似的命令：git rebase与git rebase来区分它们的使用场景，最终将“黑魔法”纳入自己的工作流中。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000005937408"" rel=""nofollow noreferrer"">Git Rebase原理以及黄金准则详解</a></p>
<blockquote><p>本文主要讲解下Git Rebase的基本概念用法、其内部原理以及我们在真实项目中使用Git Rebase应该遵循的原则以及为啥需要遵循这些原则。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009610313/read"" rel=""nofollow noreferrer"">Git是怎样生成diff的：Myers算法</a></p>
<blockquote><p>diff是我们每天都要使用的一个功能，每次提交时，我都习惯先用git diff --cached看看这次提交更改了些什么，确定没问题，然后再git commit。git生成的diff非常直观，直观到我从来都没有去思考过diff是怎么生成的，觉得这应该是很简单的一件事，两个文件做个对比，不就行了。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009011224/read"" rel=""nofollow noreferrer"">Git由浅入深之存储原理</a></p>
<blockquote><p>本来计划本篇介绍Git分支的相关知识点与操作，但是准备的过程中发现涉及到很多内部存储原理，决定先介绍一下Git存储原理，明白了这些，有助于理解后续内容，对Git的使用也会有很大帮助。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000009796715"" rel=""nofollow noreferrer"">谈谈 Git 代码回滚</a></p>
<blockquote><p>本文讲述了如何使用 git rebase -i 及 git cherry-pick 实现代码回滚。代码回滚属于高危操作，建议慎用！</p></blockquote>
<h2>Git 高阶</h2>
<p><a href=""https://segmentfault.com/a/1190000002918123"" rel=""nofollow noreferrer"">深入理解学习Git工作流（git-workflow-tutorial）</a></p>
<blockquote>
<p>工作流其实不是一个初级主题，背后的本质问题其实是有效的项目流程管理和高效的开发协同约定，不仅是Git或SVN等VCS或SCM工具的使用。</p>
<p>这篇指南以大家在SVN中已经广为熟悉使用的集中式工作流作为起点，循序渐进地演进到其它高效的分布式工作流，还介绍了如何配合使用便利的Pull Request功能，体系地讲解了各种工作流的应用。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000009374489/read"" rel=""nofollow noreferrer"">简介我的 Git Work Flow</a></p>
<blockquote><p>统一的工作流程是至关重要的，不管对于哪一个行业的作业来说都一样。对于我们开发人员，工作流包含了开发时 Git 的使用规范、Repo 管理的规范、测试过程的规范、设计交互的管理规范等等。本篇文章重点说 Git 的使用规范和 repo 管理的规范。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008817524/read"" rel=""nofollow noreferrer"">Git工作流指南：Gitflow工作流</a></p>
<blockquote>
<p>Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p>
<p>Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。</p>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000008209343"" rel=""nofollow noreferrer"">研发团队GIT开发流程新人学习指南</a></p>
<blockquote><p>本文定位于为使用GIT标准分支开发流程的开发团队新人提供一份参考指南，其中的内容都是我们公司在研发团队初创时所遵循的一些开发流程标准，经过近一年的实践，虽说还有很多不足，但是随着团队经验的丰富和人员的扩张，我会适时地更新本文，分享我们在使用GIT开发流程中遇到的问题和解决方案。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009571726/read"" rel=""nofollow noreferrer"">git干货系列：（六）公司内部搭建git服务器</a></p>
<blockquote><p>因为gitHub上的项目是公开的，不适合公司内部项目放在上面，而私人的需要收费，这绝非是我们愿意的。所以找了个跟gitHub很相似，但是又免费的gitLab。现在将搭建gitLab过程记录一下留作参考。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000003969060"" rel=""nofollow noreferrer"">用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册</a></p>
<blockquote>
<p>什么时候需要 Subtree ？</p>
<ul>
<li><p>1、当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候</p></li>
<li><p>2、把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000007671099"" rel=""nofollow noreferrer"">Git-WebHook 自动化部署工具 - 支持Github / GitLab / Gogs / GitOsc</a></p>
<blockquote><p>Git WebHook 是一个使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维系统，支持：Github / GitLab / Gogs / GitOsc。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000004876514"" rel=""nofollow noreferrer"">Python 使用 Tornado 框架实现 WebHook 自动部署 Git 项目</a></p>
<blockquote><p>为了方便开发测试或项目部署至服务器不那么繁琐，搞一个自动部署的小轮子也是必要的。小轮子需要涉及到 Coding 项目托管平台(也可以用 Github 平台)，Linux服务器的Nginx、Python( Tornado框架 )。同时配置项目托管平台的个人私钥或项目公钥，保证 git pull 能直接拉取。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000009673544"" rel=""nofollow noreferrer"">如何在Linux上搭建一个Git中央仓库</a></p>
<blockquote><p>前言：本教程只面向那些个人开发者，想要自己在linux上搭建一个git中央仓库用来上传发布自己的项目。但是对于团队来说可能有更高的要求，可以使用gitlab搭建一个可视化的类似github的版本管理系统</p></blockquote>
<h2>Git 小知识</h2>
<p><a href=""https://segmentfault.com/a/1190000000669548"" rel=""nofollow noreferrer"">Git 常用命令图片展示</a></p>
<p><a href=""https://segmentfault.com/a/1190000008894790"" rel=""nofollow noreferrer"">盘点那些不知名却常用的 Git 操作</a></p>
<p><a href=""https://segmentfault.com/a/1190000005706707"" rel=""nofollow noreferrer"">常用的几十个Git小技巧分类与总结</a></p>
<p><a href=""https://segmentfault.com/a/1190000009753465"" rel=""nofollow noreferrer"">喜欢用 Git 做的一些小事</a></p>
<p><a href=""https://segmentfault.com/a/1190000008542123"" rel=""nofollow noreferrer"">git代码统计</a></p>
<p><a href=""https://segmentfault.com/a/1190000006218554"" rel=""nofollow noreferrer"">解决Git合并分支发生的冲突</a></p>
<p><a href=""https://segmentfault.com/a/1190000009369889"" rel=""nofollow noreferrer"">[Git] git config 常用配置</a></p>
<p><a href=""https://segmentfault.com/a/1190000009341332"" rel=""nofollow noreferrer"">使用 ""5W1H"" 写出高可读的 Git Commit Message</a></p>
<p><a href=""https://segmentfault.com/a/1190000008880580"" rel=""nofollow noreferrer"">Git免登Git免秘Git免密</a></p>
<p><a href=""https://segmentfault.com/p/1210000006996333/read"" rel=""nofollow noreferrer"">如何让Git忽略掉文件中的单/多行内容</a></p>
<p><a href=""https://segmentfault.com/a/1190000006105679"" rel=""nofollow noreferrer"">git多账号登录问题</a></p>
<p><a href=""https://segmentfault.com/a/1190000009525388"" rel=""nofollow noreferrer"">Git 如何删除远程服务器文件同时保留本地文件</a></p>
<p><a href=""https://segmentfault.com/a/1190000009103990"" rel=""nofollow noreferrer"">如何在phpStrom中登出git账号</a></p>
<p><a href=""https://segmentfault.com/a/1190000008185938"" rel=""nofollow noreferrer"">vscode集成git bash</a></p>
<p><a href=""https://segmentfault.com/a/1190000006866280"" rel=""nofollow noreferrer"">git中如何提交空目录</a></p>
<p><a href=""https://segmentfault.com/a/1190000006703926"" rel=""nofollow noreferrer"">Git如何检出指定目录或文件</a></p>
<p><a href=""https://segmentfault.com/a/1190000007039598"" rel=""nofollow noreferrer"">实际操作 Svn 迁移到 Git</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVP744?w=1906&amp;h=886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", SegmentFault 技术周刊 Vol.27 - Git 学习宝典：程序员走江湖必备,1531977829,299,1,573,1,1,https://segmentfault.com/a/1190000009893041
122,1,0,7,"
                    
<blockquote>
<p>作者：<a href=""https://twitter.com/csswizardry"" rel=""nofollow noreferrer"">@csswizardry</a></p>
<p>原文：<a href=""https://csswizardry.com/2017/05/little-things-i-like-to-do-with-git/"" rel=""nofollow noreferrer"">Little Things I Like to Do with Git</a></p>
<p>随便说点：这篇文章主要从管理者的角度谈论了使用 git 的心得，使用大量篇幅介绍 <code>git log</code> 的一些方法和技巧。</p>
<p>同样地，发现很多人其实并没有深入全面地去了解过 git 的用法，作为一名开发人员，大多数时候只要会使用 <code>git pull</code>，<code>git add</code>，<code>git commit</code>，<code>git push</code> 似乎就足够，还有很大一部分人只使用特定的图形化工具。但事实上真的是这样吗，可能在遇到某个稍微高级一点的问题或者需求就手足无措。对于某个特定个体而言，很多场景我们未必会遇到，即使碰到也可以现场寻求搜索工具的帮助，这也是一种学习方式，无意否定这种方式，但最大的问题就是只见一叶而难以窥见森林。在这里推荐一个小工具 <a href=""https://github.com/Gazler/githug"" rel=""nofollow noreferrer"">githug</a>，通过一种比较轻松的游戏的方式来一探全貌。</p>
</blockquote>
<p>在跟我的朋友 Tim 聊天的时候，谈到我有多喜欢 Git。作为经常使用的一个工具，它强大而优雅。在这里，介绍一下我个人使用得最多，同时也是最有用的一些小技巧。</p>
<h2>管理者面板</h2>
<p>无论你认为在工作中的游戏化（gamification）和竞争是好是坏，对于这个话题在不同的时间可能是完全不同的结论。但如果你对团队成员在项目中的提交数量感兴趣，使用 <code>shortlog</code> 就可以找到答案：</p>
<pre><code class=""sh"">$ git shortlog -sn
    80  Harry Roberts
    34  Samantha Peters
     3  Tom Smith</code></pre>
<p><code>shortlog</code> 可以视作对 <code>git log</code> 的概要。</p>
<ul>
<li><p><code>-s</code>选项将隐藏提交描述，仅提供提交计数摘要</p></li>
<li><p><code>-n</code> 选项将根据每个作者的提交数对输出进行排序，而不是默认的按作者字母顺序。</p></li>
</ul>
<p>上面显示的是项目生命周期的所有提交，但是如果想查看在特定时间内的情况，可以使用 <code>--since</code> 和 <code>--until</code> 选项：</p>
<pre><code class=""sh"">$ git shortlog -sn --since='10 weeks' --until='2 weeks'
    59  Harry Roberts
    24  Samantha Peters</code></pre>
<p>我为此配置了别名 <code>$ git stats</code></p>
<h2>责任人</h2>
<p>Git 有一个非常有用的 <code>blame</code> 功能，允许我们查看特定代码段的负责开发人员：</p>
<pre><code class=""sh""># See who last changed lines 5 through 10 of the buttons’ CSS:
$ git blame -L5,10 _components.buttons.scss</code></pre>
<p>这一条放在这里讲好像有点过头，像是我们在找开发人员哪些地方做错了。但也不完全是这样，另一方面，他们可能已经做了一些我们想要了解的特别厉害或是印象深刻的事情。我们原本会问，哇！我之前还没有看到这个功能，还想知道是谁做的。</p>
<p>由于是从 SVN 转到 Git，我使用 <code>praise</code> 作为 <code>blame</code> 的别名，这样二者都可以使用：</p>
<pre><code class=""sh"">$ git config --global alias.praise blame</code></pre>
<p>即，我也可以这样做：</p>
<pre><code class=""sh""># Find out who implemented Resource Hints and buy them a coffee:
$ git praise -L18,23 _includes/head.html</code></pre>
<p>只是一点小变化，但效果不错。</p>
<h2>隐藏空白提示</h2>
<p>当使用 <code>diff</code> 或 <code>show</code> 查看具有大量空白变化的版本对比时，会有很多视觉噪音干扰我们，使得很难看到更重要的变化内容。</p>
<p>幸运的是，去除这种空白提示非常容易，在 <code>git diff</code> 和 <code>git show</code> 使用 <code>-w</code> 选项就可以轻松搞定。比如，之前：</p>
<pre><code> a {
   color: $color-links;

-&amp;:hover {
-  color: $color-links-hover;
-}
+  &amp;:hover {
+    color: $color-links-hover;
+    text-decoration: underline;
+  }

}</code></pre>
<p>使用 <code>-w</code> 之后：</p>
<pre><code> a {
   color: $color-links;

   &amp;:hover {
     color: $color-links-hover;
+    text-decoration: underline;
   }

}</code></pre>
<p>现在可以很容易看出，唯一有意义的变化是增加了 <code>text-decoration: underline;</code>，而其余​​的 <code>diff</code> 是有点误导性的。</p>
<h2>仅显示单词的变化而不是整行</h2>
<p>写代码跟写文章不同，查看变化的单词而不是整行通常会更有用; 这在编辑 markdown 文档时尤其有用，就像现在。</p>
<p>幸运的是，我们只要使用 <code>--word-diff</code> 选项就能显示单词的变化：</p>
<pre><code class=""sh"">$ git diff --word-diff</code></pre>
<p>跟不使用 <code>--word-diff</code> 选项的区别还是很大的：</p>
<pre><code>-My friend Tom recently gave an excellent talk
+My good friend Tom gave an excellent talk</code></pre>
<p>如果启用 <code>--word-diff</code>，我们能得到更便于理解和更有用的概览：</p>
<pre><code>My {+good+} friend Tom [-recently-] gave an excellent talk</code></pre>
<p>注意只有变化的文本被突出显示（通过 <code>{+ +}</code> 和 <code>[- -]</code>)</p>
<h2>查看最近工作的分支</h2>
<p>在任何给定的项目，在许多不同的分支之间切换是很常见的，并且跟踪它们可能相当棘手。我们可以让 Git 帮助我们解决这个问题：</p>
<pre><code class=""sh"">$ git for-each-ref --count=10 --sort=-committerdate refs/heads/ --format=""%(refname:short)""</code></pre>
<p>通过这个命令可以知道最近在工作的 10（--count=10）个分支，按照上次工作的时间排序。只显示本地分支（<code>refs/heads/</code>），并通过 <code>--format</code> 选项获得更友好的呈现方式。</p>
<p>这是一个有点冗长的命令，所以我为此配置别名 <code>$ git recent</code>。</p>
<pre><code class=""sh"">git config --global alias.recent ""for-each-ref --count=10 --sort=-committerdate refs/heads/ --format=\""%(refname:short)\""""</code></pre>
<h2>看到每个人都在做什么</h2>
<p>有时候，特别是对于团队领导，了解团队成员在所有分支的行为概览是很有用的。再一次地，Git 可以让这一切变得很容易：</p>
<pre><code class=""sh"">$ git log --all --oneline --no-merges</code></pre>
<p>这可以得到一份关于所有人的日志报告简化版（带有 <code>--no-merges</code> 选项）</p>
<p>我们也可以通过 <code>--since</code> 选项来限制返回的提交数量：</p>
<pre><code class=""sh"">$ git log --all --since='2 weeks' --oneline --no-merges</code></pre>
<p>这样我们可以看到，在过去的两个星期里，每个人都在做什么。</p>
<p>可以配置一个别名 <code>$ git overview</code></p>
<pre><code class=""sh"">git config --global alias.overview ""log --all --since='2 weeks' --oneline --no-merges""</code></pre>
<h2>提醒你自己已经做了什么</h2>
<p>当你回到一个比较旧的项目，或是在长时间休息之后回到办公室，可能不知道你最后在做什么工作，这种情况时常发生。我们可以通过 Git 轻松获得我们在项目中的工作情况：</p>
<pre><code class=""sh"">$ git log --all --oneline --no-merges --author=&lt;your email address&gt;</code></pre>
<p>和上一条很类似，只是我们将日志限制于我们自己的提交，也可以增加 <code>--since</code> 限制。</p>
<p>这也有一个别名 <code>$ git recap</code>。</p>
<pre><code class=""sh"">git config --global alias.recap ""log --all --oneline --no-merges --author=name@mail.com""</code></pre>
<h2>今天的工作</h2>
<p>同样地，不在这里讨论如何衡量开发人员的生产力，但我觉得让客户知道我在任何一天的工作情况是很有用的。不是要你保留完成任务的详细列表，我们可以使用 Git 获取所有这些信息：</p>
<pre><code class=""sh"">$ git log --since=00:00:00 --all --no-merges --oneline --author=&lt;your email address&gt;</code></pre>
<p>这将记录（<code>log</code>） 你工作的所有（<code>--all</code>）分支，谁（<code>--author</code>）从（<code>--since</code>）午夜开始都做了什么，（不包括合并提交 <code>--no-merges</code>），并提供一个简单的一行 （<code>--oneline</code>） 概述。</p>
<p>我有这个别名 <code>$ git today</code>。</p>
<pre><code class=""sh"">git config --global alias.today ""log --since=00:00:00 --all --no-merges --oneline --author=name@mail.com""</code></pre>
<h2>生成更改日志</h2>
<p>维护一份 CHANGELOG 可能有点乏味，我们必须查看自上次发布以来所做的所有工作，然后提取其中有用的部分。幸运的是，我们可以使用 Git 来给我们一个好的开头：</p>
<pre><code class=""sh"">$ git log --oneline --no-merges &lt;last tag&gt;..HEAD</code></pre>
<p>注意：<code>HEAD</code> 是可选的，如果你省略（即... --no-merges &lt;last tag&gt;..），<code>HEAD</code> 会是隐含的，当然这样可以节省几次敲击键盘的时间。</p>
<p>这将创建一个简化的日志，显示最后一个发布版本和 <code>HEAD</code> 之间的所有提交（不包括合并提交）。</p>
<p>例如：</p>
<pre><code class=""sh"">$ git log --oneline --no-merges 1.0.0..
1257b95 [refs #00019] Bump version
2b9b28e [refs #00019] Add auto width class
17b8eb1 [refs #00015] Tidy up README.md
bbe7d05 [refs #00012] Rename Supercell main mixin</code></pre>
<p>这告诉我，自从上次发布（1.0.0）到当前项目状态（<code>HEAD</code>），已经完成哪些工作。这对于 CHANGELOG 来说是一个很好的参考。</p>
<p>注意：不仅仅适用于 tag，还可以使用提交哈希。</p>
<h2>检查需要拉取哪些变化</h2>
<p>如果你在一段时间内不在项目，可能需要先检查上游的变更，然后再将这些更新下载到本地分支。</p>
<pre><code class=""sh"">$ git log --oneline --no-merges HEAD..&lt;remote&gt;/&lt;branch&gt;</code></pre>
<p>注意：同样地，<code>HEAD</code> 在这里是可选的，省略将使其隐含。</p>
<p>例如，让我们来看看你在度假时在特性分支做了什么：</p>
<pre><code class=""sh"">$ git checkout feature/fonts
$ git fetch
$ git log --oneline --no-merges ..origin/feature/fonts</code></pre>
<p>我使用这个别名 <code>$ git upstream</code>。</p>
<h2>检查即将上传的内容</h2>
<p>最好的情况是可以经常提交和上传，但如果某种原因导致有大量的本地提交尚未上传，可以快速回顾一下都是什么。</p>
<p>为了做到这一点，我们反转之前的命令就能轻松实现：</p>
<pre><code class=""sh"">$ git log --oneline --no-merges &lt;remote&gt;/&lt;branch&gt;..HEAD</code></pre>
<p>例如：</p>
<pre><code class=""sh"">$ git fetch
$ git log --oneline --no-merges origin/feature/fonts..HEAD</code></pre>
<p>注意：同样地，<code>HEAD</code> 在这里是可选的，省略将使其隐含。</p>
<p>这将记录 <code>HEAD</code> 需要上传到 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的提交。</p>
<p>我使用这个别名 <code>$ git local</code>。</p>
<h2>查看复杂日志</h2>
<p>上面的每一个例子都使用简化的日志，因为只想快速了解发生了什么。对于更多细节，我使用带有 <code>--graph</code> 选项的日志和一些额外的选项：</p>
<pre><code class=""sh"">$ git log --graph --all --decorate --stat --date=iso</code></pre>
<p>这将给出所有（<code>--all</code>）分支基于 <code>--graph</code> 的提交记录 <code> --stat</code>（添加，删除）日志。<code>--decorate</code> 选项会告诉我们提交信息适用于那些分支，还包含一个更加严格的日期格式。</p>
<p>我使用这个别名 <code>$ git graph</code>。</p>
<pre><code class=""sh"">git config --global alias.graph ""log --graph --all --decorate --stat --date=iso""</code></pre>

                ", 喜欢用 Git 做的一些小事,1531977830,514,1,264,1,1,https://segmentfault.com/a/1190000009753465
123,1,0,7,"
                    
<p>作为程序员都习惯在命令行下操作，今天就推荐些命令行神器，可能让你大开眼界。</p>
<h3>统计当前目录代码数 line-counter</h3>
<pre><code class=""js"">//https://github.com/MorganZhang100/line-counter
//find . -name '*.py' -exec wc -l {} + 
//wc -l
pip install line-counter  
$ line
Search in /Users/Morgan/Documents/Example/
file count: 4
line count: 839
$ line -d
Search in /Users/Morgan/Documents/Example/
Dir A/file C.c                                             72
Dir A/file D.py                                           268
file A.py                                                 467
file B.c                                                   32
file count: 4
line count: 839

//https://github.com/AlDanial/cloc
npm install -g cloc   
$ cloc wechat-cli.py
       1 text file.
       1 unique file.
       0 files ignored.

github.com/AlDanial/cloc v 1.72  T=0.14 s (7.4 files/s, 779.4 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Python                           1             12              7             87
-------------------------------------------------------------------------------</code></pre>
<h3>命令行纠错 thefuck</h3>
<pre><code class=""js"">//https://github.com/nvbn/thefuck
pip install thefuck
➜ apt-get install vim
E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?

➜ fuck
sudo apt-get install vim
[sudo] password for nvbn:
Reading package lists... Done</code></pre>
<h3><a href=""https://github.com/hanzichi/codedog#demo"" rel=""nofollow noreferrer"">markdown to html </a></h3>
<pre><code class=""js"">npm install -g codedog
codedog xx.md or codedog xx.md width height</code></pre>
<h3>mysql 客户端，支持语法高亮和命令补全 mycli</h3>
<pre><code class=""js"">// https://github.com/dbcli/mycli
pip install -U mycli
$ mycli -h localhost -uroot
Password:
Version: 1.8.0
Chat: https://gitter.im/dbcli/mycli
Mail: https://groups.google.com/forum/#!forum/mycli-users
Home: http://mycli.net
Thanks to the contributor - Tech Blue Software
mysql root@localhost:(none)&gt; use test
You are now connected to database ""test"" as user ""root""
Time: 0.005s
mysql root@localhost:test&gt; show t
                                  TABLE STATUS
                                  TABLE STATUS
                                  TABLES
                                  TABLES
                                  TRIGGERS
                                  TRIGGERS
                                  STATUS
 [F2] Smart Completion: ON  [F3] Multiline: OFF  [F4] Emacs-mode</code></pre>
<h3><a href=""https://zhuanlan.zhihu.com/p/28646557"" rel=""nofollow noreferrer"">基于puppeteer的网页截图工具</a></h3>
<pre><code class=""js"">$ npm install -g vian
（1）截取 github 首页

$ vian https://github.com
（2）截取 github 首页 （非全屏）

$ vian --no-fullpage https://github.com
（3）保存 github 首页为图片，模拟 iPhone 6

$ vian -d 'iPhone 6' -f github.jpg https://github.com
（4）保存 github 首页为 pdf 文档，纸张尺寸选择 A4

$ vian -t pdf -s A4 https://github.com
（5）查看所有的可模拟设备

$ vian devices

//https://github.com/Runjuu/page2image
npm i page2image --global
# Single page
&gt; page2image https://github.com/Runjuu --type=jpeg --quality=80

# Multi-page
&gt; page2image https://github.com/Runjuu https://github.com/Runjuu --type=jpeg --quality=80</code></pre>
<h3><a href=""https://github.com/esbenp/pdf-bot"" rel=""nofollow noreferrer"">一个生成pdf文件的微服务</a></h3>
<p><code>npm install -g pdf-bot</code></p>
<h3>json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool</h3>
<pre><code class=""js"">//https://github.com/stedolan/jq http://blog.chinaunix.net/uid-24774106-id-3830242.html
$ cat json_raw.txt 
{""name"":""Google"",""location"":{""street"":""1600 Amphitheatre Parkway"",""city"":""Mountain View"",""state"":""California"",""country"":""US""},""employees"":[{""name"":""Michael"",""division"":""Engineering""},{""name"":""Laura"",""division"":""HR""},{""name"":""Elise"",""division"":""Marketing""}]}
cat json_raw.txt | jq '.location.state'
    ""California""
 echo '{""foo"": 42, ""bar"": ""less interesting data""}' | jq .nofoo
    null
cat json_raw.txt | jq 'keys'
[
  ""employees"",
  ""location"",
  ""name""
]</code></pre>
<h3>shell脚本静态检查工具 shellcheck</h3>
<pre><code class=""js"">//https://github.com/koalaman/shellcheck
apt-get install shellcheck
shellcheck test.sh</code></pre>
<h3>多线程下载工具 axel</h3>
<pre><code class=""js"">//  axel.alioth.debian.org/
sudo apt-get install axel
axel -n 10 -a &lt;url&gt;
axel -n 20 http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso</code></pre>
<h3>命令行请求工具 httpie</h3>
<pre><code class=""js"">//https://httpie.org/ https://github.com/jakubroztocil/httpie
pip install --upgrade httpie
http PUT example.org X-API-Token:123 name=John
http -f POST example.org hello=World
http example.org/file &gt; file
http httpbin.org/post  --  -name-starting-with-dash=foo -Unusual-Header:bar
POST /post HTTP/1.1
-Unusual-Header: bar
Content-Type: application/json

{
    ""-name-starting-with-dash"": ""value""
}</code></pre>
<h3>命令行文档 tldr</h3>
<pre><code class=""js"">// https://github.com/tldr-pages/tldr
npm install -g tldr
$ tldr curl
Cache is out of date, you should run ""tldr --update""

  curl
  Transfers data from or to a server.
  Supports most protocols including HTTP, FTP, POP.

  - Download a URL to a file:
    curl ""URL"" -o filename

  - Send form-encoded data:
    curl --data name=bob http://localhost/form

  - Send JSON data:
    curl -X POST -H ""Content-Type: application/json"" -d '{""name"":""bob""}' http://
localhost/login

  - Specify an HTTP method:
    curl -X DELETE http://localhost/item/123

  - Head request:
    curl --head http://localhost

  - Include an extra header:
    curl -H ""X-MyHeader: 123"" http://localhost

  - Pass a user name and password for server authentication:
    curl -u myusername:mypassword http://localhost</code></pre>
<h3>命令行提示工具 cheat</h3>
<pre><code class=""js"">//https://github.com/chrisallenlane/cheat
 pip install cheat
cheat tar
# To extract an uncompressed archive: 
tar -xvf '/path/to/foo.tar'

# To extract a .gz archive:
tar -xzvf '/path/to/foo.tgz'

# To create a .gz archive:
tar -czvf '/path/to/foo.tgz' '/path/to/foo/'

# To extract a .bz2 archive:
tar -xjvf '/path/to/foo.tgz'

# To create a .bz2 archive:
tar -cjvf '/path/to/foo.tgz' '/path/to/foo/'</code></pre>
<h3>后台运行和管理进程 pm2 同python的supervisoerd</h3>
<pre><code class=""js"">//http://pm2.keymetrics.io/
npm install pm2 -g 
pm2 list</code></pre>
<h3>在命令行实时监控 Nginx 的神器 ngxtop</h3>
<pre><code class=""js"">//https://linux.cn/article-3205-1.html
pip install ngxtop
ngxtop -n 20
ngxtop info</code></pre>
<h3>python代码格式规范化工具 yapf</h3>
<pre><code class=""js"">//https://github.com/google/yapf 
 pip install yapf
&gt;&gt;&gt; from yapf.yapflib.yapf_api import FormatCode  # reformat a string of code

&gt;&gt;&gt; FormatCode(""f ( a = 1, b = 2 )"")
'f(a=1, b=2)\n'
</code></pre>
<h3>命令行下模糊搜索工具 fzf</h3>
<pre><code class=""js"">//https://github.com/junegunn/fzf
brew install fzf
find * -type f | fzf &gt; selected</code></pre>
<h3>网易云音乐命令行版本 musicbox</h3>
<pre><code class=""js"">//https://github.com/darknessomi/musicbox
pip(3) install NetEase-MusicBox

$ git clone https://github.com/darknessomi/musicbox.git &amp;&amp; cd musicbox
$ python(3) setup.py install</code></pre>
<h3>多线程下载工具 aria2</h3>
<pre><code class=""js"">//https://github.com/aria2/aria2
aria2c http://a/f.iso ftp://b/f.iso
aria2 下载百度云链接https://github.com/acgotaku/BaiduExporter
</code></pre>
<h3>比 python -m SimpleHTTPServer 更好的 http 服务器 http-server</h3>
<pre><code class=""js"">//https://github.com/indexzero/http-server
npm install http-server -g
 http-server 8888
alias hs=""source ~/.bash_profile &amp;&amp; http-server -a $(ifconfig en0 | grep 'inet ' | cut -d ' ' -f 2)""
//浏览器打开http://localhost:8888</code></pre>
<h3>获取汉字拼音 pypinyin</h3>
<pre><code class=""js"">pip install pypinyin

$ pypinyin 有哪些命令行的软件堪称神器

yǒu něi xiē mìng lìng xíng de ruǎn jiàn kān chē</code></pre>
<h3>Nginx配置静态分析器</h3>
<pre><code class=""js"">https://github.com/yandex/gixy 
pip install gixy
gixy /etc/nginx/nginx.conf</code></pre>
<h3>HTTP Prompt</h3>
<pre><code class=""js"">pip install http-prompt
pip install httpie
# No parameters initially
&gt; httpie
http http://localhost

# Send a request with some overrided parameters
&gt; post /api/v1 --form name=jane

# Current state remains intact
&gt; httpie
http http://localhost</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQa9e?w=656&amp;h=388"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>node ppt</h3>
<pre><code class=""js"">https://github.com/ksky521/nodePPT
npm install -g nodeppt 
执行 nodeppt start
访问 http://127.0.0.1:8080/
在线demo： http://js8.in/nodeppt/</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVQbf0?w=707&amp;h=294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>检查浏览器的兼容性</h3>
<pre><code class=""js"">npm install -g caniuse-cmd
$ caniuse flex
Flexible Box Layout Module √ 83.86% Θ 13.63% [W3C Candidate Recommendation]
  Method of positioning elements in horizontal or vertical stacks. Support
  includes the support for the all properties prefixed with `flex` as well as
  `display: flex`, `display: inline-flex`, `align-content`, `align-items`,
  `align-self`, `justify-content` and `order`. #CSS3

  IE × 5.5+ Θ 10+ᵖ² Θ 11⁴
  Edge √
  Firefox Θ 2+ᵖ¹ Θ 22+³ √ 28+
  Chrome Θ 4+ᵖ¹ √ 21+ᵖ √ 29+
  Safari Θ 3.1+ᵖ¹ √ 6.1+ᵖ √ 9+
  Opera × 9+ √ 12.1+ √ 15+ᵖ √ 17+

    ¹Only supports the [old
    flexbox](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723) specification
    and does not support wrapping.
    ²Only supports the [2012
    syntax](http://www.w3.org/TR/2012/WD-css3-flexbox-20120322/)
    ³Does not support flex-wrap, flex-flow or align-content properties
    ⁴Partial support is due to large amount of bugs present (see known issues)
   ⓘ  Most partial support refers to supporting an [older
   version](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/) of the
   specification or an [older
   syntax](http://www.w3.org/TR/2012/WD-css3-flexbox-20120322/).</code></pre>
<h3><a href=""https://github.com/ShanaMaid/terminal-translate"" rel=""nofollow noreferrer"">命令行翻译工具</a></h3>
<pre><code class=""js"">npm install terminal-translate -g
//类似 npm install fanyi -g https://github.com/afc163/fanyi
$ tl great

  ~ great - [greɪt]   美[ɡret]   英[greɪt]
  ~ 伟大的

   -  n. 大师；大人物；伟人们
   -  adj. 伟大的，重大的；极好的，好的；主要的

   1. Great
     伟大的,Great,Great

   2. Great Lakes
     五大湖,五大湖,大湖区

   3. Great Recession
     经济大衰退,大衰退,大萧条
</code></pre>
<h3><a href=""https://u.nu/"" rel=""nofollow noreferrer"">短域名工具</a></h3>
<p><code>npm i -g u.nu</code></p>
<h3><a href=""https://github.com/netpi/baidu-ocr-api"" rel=""nofollow noreferrer"">图片识别</a></h3>
<pre><code class=""js"">npm install baidu-ocr-api -g

ocr --help
# 远程图片
ocr http://7pun4e.com1.z0.glb.clouddn.com/test.jpg

# 本地图片
ocr ./test.jpg</code></pre>
<h3><a href=""https://www.diffchecker.com/cli"" rel=""nofollow noreferrer"">文件比较</a></h3>
<pre><code class=""js"">npm install -g diffchecker
diffchecker file1.js file2.js
diffchecker --expires day file1.js file2.js</code></pre>
<h3><a href=""https://transfer.sh/"" rel=""nofollow noreferrer"">分享文件</a></h3>
<pre><code class=""js""># Uploading is easy using curl 
$ curl --upload-file ./hello.txt https://transfer.sh/hello.txt 
https://transfer.sh/66nb8/hello.txt 

$ curl -H ""Max-Downloads: 1"" -H ""Max-Days: 5"" --upload-file ./hello.txt https://transfer.sh/hello.txt 
https://transfer.sh/66nb8/hello.txt 
# Download the file 
$ curl https://transfer.sh/66nb8/hello.txt -o hello.txt</code></pre>
<h3><a href=""https://github.com/dthree/mailit"" rel=""nofollow noreferrer"">send emails</a></h3>
<pre><code class=""js"">First, create a config.json with your SMTP settings:

{
    ""host"": ""smtp.foobar.net"",
    ""port"": 465,
    ""user"": ""noreply"",
    ""pass"": ""foobar!""
}

Install the app and start it up to point at the config:

npm i mailit -g
mailit --config /path/to/config.json

And presto, a mail endpoint! Let's try it out:

curl --data ""to=d@me.net&amp;subject=hi&amp;text=hey world"" http://127.0.0.1:3000/email
</code></pre>
<h3><a href=""https://github.com/denysdovhan/bash-handbook"" rel=""nofollow noreferrer"">learnyoubash</a></h3>
<p><code>npm install -g bash-handbook</code></p>
<h3><a href=""https://github.com/codezjx/netease-cloud-music-dl"" rel=""nofollow noreferrer"">网易云音乐下载器</a></h3>
<pre><code class=""js"">$ git clone https://github.com/codezjx/netease-cloud-music-dl.git
$ python setup.py install
$ ncm -s 123123
or
$ ncm -s http://music.163.com/#/song?id=123123</code></pre>
<h3><a href=""https://github.com/reorx/httpstat"" rel=""nofollow noreferrer"">curl 统计分析 httpstat </a></h3>
<pre><code class=""js"">pip install httpstat
httpstat httpbin.org/get</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVTKTY?w=865&amp;h=521"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3><a href=""https://uncss-online.com/"" rel=""nofollow noreferrer"">清除多余 css</a></h3>
<pre><code class=""js"">//https://github.com/purifycss/purifycss
$ npm install -g purify-css
$ purifycss -h

purifycss &lt;css&gt; &lt;content&gt; [option]

Options:
  -m, --min        Minify CSS                         [boolean] [default: false]
  -o, --out        Filepath to write purified css to                    [string]
  -i, --info       Logs info on how much css was removed
                                                      [boolean] [default: false]
  -r, --rejected   Logs the CSS rules that were removed
                                                      [boolean] [default: false]
  -w, --whitelist  List of classes that should not be removed
                                                           [array] [default: []]
  -h, --help       Show help                                           [boolean]
  -v, --version    Show version number                                 [boolean]</code></pre>
<h3>http 请求工具</h3>
<pre><code class=""js"">pip install http
#验证代理ip有效性 将响应与真实IP进行对比，如果不一样就有效
$ http --proxy http://59.49.129.60:8998 http://ip.cip.cc
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 13
Content-Type: text/plain; charset=utf-8
Date: Sat, 09 Sep 2017 01:06:40 GMT
P3P: CP='CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NO
I DSP COR'
Proxy-Connection: keep-alive
Server: nginx
Vary: Accept-Encoding

59.49.129.60
&gt;&gt;&gt; pro={'http':'59.49.129.60:8998'}
&gt;&gt;&gt;pro=requests.get('http://lab.crossincode.com/proxy/get/?num=35&amp;head=https').json()['proxies']
&gt;&gt;&gt; import requests as rq
&gt;&gt;&gt; r=rq.get('http://ip.cip.cc',proxies=pro) 
&gt;&gt;&gt; r.text
'59.49.129.60\n'</code></pre>
<h3><a href=""https://www.npmjs.com/package/cellocate"" rel=""nofollow noreferrer"">手机号码归属地查询工具</a></h3>
<pre><code class=""js"">npm install -g cellocate
cellocate 13888888888
13888888888
云南 昆明 移动</code></pre>
<h3><a href=""https://segmentfault.com/a/1190000011692777"" rel=""nofollow noreferrer"">搭建简易静态文件http服务器</a></h3>
<pre><code class=""js"">python3 -m http.server port
npm install http-server -g
npm install -g serve
npm install -g anywhere
npm -g install puer
php -S localhost:9999</code></pre>
<h3><a href=""https://github.com/louisun/iSearch"" rel=""nofollow noreferrer"">命令行单词管理工具 iSearch</a></h3>
<pre><code class=""js"">pip install iSearch
s sun

sun 不在数据库中，从有道词典查询
sun /sʌn/

N-SING The sun is the ball of fire in the sky that the Earth goes around, and that gives us heat and light. 太阳 

例：The sun was now high in the southern sky. 太阳当时正高挂在南面天空上。 

例：The sun came out, briefly. 太阳出来了，时间很短。 </code></pre>
<h3><a href=""https://github.com/myst729/capteer"" rel=""nofollow noreferrer"">网页截图</a></h3>
<pre><code class=""js"">npm install capteer -g
capteer &lt;url&gt; [filename] [options]</code></pre>
<p><a href=""https://www.zhihu.com/question/59227720"" rel=""nofollow noreferrer"">更多</a><br><a href=""http://www.52liming.com/?p=86"" rel=""nofollow noreferrer"">用爽截图</a><br><a href=""https://github.com/int32bit/dotfiles?#"" rel=""nofollow noreferrer"">命令行工具</a><br>公众号：苏生不惑</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOYWr?w=425&amp;h=433"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", 命令行神器推荐,1531977831,533,1,314,1,1,https://segmentfault.com/a/1190000009728316
124,1,0,7,"
                    
<h2>前言</h2>
<p>第三方登入太常见了，微信，微博，QQ...总有一个你用过。当然看这篇文章的你，应该还用过github登入。这篇分享是在上一篇<a href=""https://segmentfault.com/a/1190000009470011"" rel=""nofollow noreferrer"">基于node的登入例子（node-koa-mongoose）</a>的基础增加了github账号第三方授权登入功能，如果有些代码，这篇中美介绍，你可以先去看下上一篇的分享。</p>
<p><strong>本项目源码地址</strong>：<a href=""https://github.com/linwalker/node-login"" rel=""nofollow noreferrer"">https://github.com/linwalker/...</a></p>
<h2>第三方登入</h2>
<p>第三方登入主要基于OAuth 2.0。OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的 ---- 百度百科</p>
<p>更详细的介绍可以看这篇文章<a href=""http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html"" rel=""nofollow noreferrer"">理解OAuth 2.0</a></p>
<h2>github 授权登入</h2>
<h3>原理过程</h3>
<p>先来大致了解下第三方通过GitHub账号授权登入的过程，具体实现结合后面代码讲解</p>
<ul>
<li>
<p>1.获取code</p>
<pre><code>第三方客户端向`https://github.com/login/oauth/authorize`发送get请求，带上`?client_id=XXXXXX`参数，这时会跳转到GitHub登入页面，授权后GitHub会向客户端返回`https://redirect_url?code=XXXXXX`。其中`client_id`和`redirect_url`是第三方事先在GitHub平台上配置好的。
</code></pre>
</li>
<li>
<p>2.通过code获取access_token</p>
<pre><code>客户端处理`https://redirect_url?code=XXXXXX`请求，获取code值，向`https://github.com/login/oauth/access_token`发起post请求，请求参数为`client_di`,`client_secret`和`code`。
</code></pre>
</li>
<li><p>3.通过access_token获取用户GitHub账号信息</p></li>
</ul>
<p>第二步的请求会返回这样<code>access_token=d0686dc49a22d64e77402db072b719f510f22421&amp;scope=user&amp;token_type=bearer</code>的内容，拿到access_token只需要向<code>https://api.github.com/user?access_token=xxx</code>发送GET请求，即可获取到登录用户的基本信息，</p>
<h3>具体实现</h3>
<h4>GitHub注册应用</h4>
<p>首先你要有一个GitHub账号，然后进入settings -&gt; OAuth application -&gt; Register a new application。进来后你会看到下面这个页面：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722477"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""应用注册(github-login).png"" title=""应用注册(github-login).png""></span></p>
<p>依次填好应用名称，应用地址和授权回掉地址后点击<code>Register application</code>按钮，会生成一个<code>client Id</code>和<code>client Secret</code>，用于后面向GitHub发送请求传参。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722478?w=763&amp;h=423"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""生成ID和Secret(github-login).png"" title=""生成ID和Secret(github-login).png""></span></p>
<h4>Github授权请求（获取code）</h4>
<p>在页面中添加GitHub登入跳转按钮，并在路由中对跳转请求进行转发处理：</p>
<pre><code class=""js"">//在node-login/components/LoginTab.js

&lt;a href=""/github/login""&gt;
     &lt;Icon type=""github"" style={{fontSize: 20, color: '#000'}}/&gt;
&lt;/a&gt;</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722479?w=349&amp;h=361"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""点击登入(github-login).png"" title=""点击登入(github-login).png""></span></p>
<p>添加跳转按钮后，增加相应路由处理,路由入口中添加／github路径处理</p>
<pre><code class=""js"">//在node-login/routes/index.js

const github = require('./github');
router.use('/github', github.routes(), github.allowedMethods());</code></pre>
<p>最后是具体的路由处理</p>
<pre><code class=""js"">//在node-login/routes/github.js
const config = require('../config');
const router = require('koa-router')();
const fetch = require('node-fetch');
const routers = router
    .get('/login', async (ctx) =&gt; {
        var dataStr = (new Date()).valueOf();
        //重定向到认证接口,并配置参数
        var path = ""https://github.com/login/oauth/authorize"";
        path += '?client_id=' + config.client_id;
        path += '&amp;scope=' + config.scope;
        path += '&amp;state=' + dataStr;
        //转发到授权服务器
        ctx.redirect(path);
    })
module.exports = routers;</code></pre>
<p>在config中事先添加配置请求所需参数<code>client_id</code>，<code>client_secret</code>和<code>scope</code>。</p>
<pre><code class=""js"">module.exports = {
    'database': 'mongodb://localhost:27017/node-login',
    'client_id': '83b21756e93d6ce27075',
    'client_secret': 'd87c4163ece5695a9ded1e8bf2701c5ee2651f28',
    'scope': ['user'],
};</code></pre>
<p>其中scope参数可选。就是你期待你的应用需要调用Github哪些信息，可以填写多个，以逗号分割，比如：scope=user,public_repo。state参数非必需，用于防治跨域伪造请求攻击。</p>
<p>现在可以运行一下项目，点击小黑猫，跳转到授权登入页面（没登入过，要输入账号密码），授权成功返回回掉地址。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722480?w=563&amp;h=571"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""授权(github-login).png"" title=""授权(github-login).png""></span></p>
<p>回掉地址中<code>code</code>就是返回的授权码，通过授权码再去获取令牌<code>access_token</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722481?w=861&amp;h=93"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""授权回掉(github-login).png"" title=""授权回掉(github-login).png""></span></p>
<h4>授权回掉处理（获取access_token）</h4>
<p>在第一步授权请求<code>https://github.com/login/oauth/authorize</code>成功后GitHub会给应用返回一个回掉<code>http://localhost:3003/github/oauth/callback?code=14de2c737aa02037132d&amp;state=1496989988474</code>。这个回掉地址就是之前在GitHub注册应用时填入的回掉地址，另外还带了需要的code参数，state就是上一步请求中带的state参数，原样返回。</p>
<p>现在我们要对这个回掉请求进行处理：</p>
<pre><code class=""js"">//node-login/routes/github.js
const config = require('../config');
const router = require('koa-router')();
const fetch = require('node-fetch');
const routers = router
    .get('/login', async (ctx) =&gt; {
        ...
    })
    .get('/oauth/callback', async (ctx) =&gt; {
        const code = ctx.query.code;
        let path = 'https://github.com/login/oauth/access_token';
        const params = {
            client_id: config.client_id,
            client_secret: config.client_secret,
            code: code
        }
        console.log(code);
        await fetch(path, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(params)
        })
        .then(res =&gt; {
            return res.text();
        })
        .then(body =&gt; {
            ctx.body = body;
        })
       .catch(e =&gt; {
            console.log(e);
        })
    })
module.exports = routers;</code></pre>
<p>GitHub返回回掉地址时，先拿到请求中的code参数，然后向<code>https://github.com/login/oauth/access_token</code>发送post请求并带上<code>client_id,client_secret,code</code>参数，请求成功后会返回带有access_token的信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722482?w=796&amp;h=89"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""access_token(github-login).png"" title=""access_token(github-login).png""></span></p>
<h4>获取GitHub账号信息</h4>
<p>最后带上获取的<code>access_token</code>请求<code>https://api.github.com/user?access_token=xxx</code>,返回的就是之前scope中对应的账号信息。</p>
<pre><code class=""js"">.get('/oauth/callback', async (ctx) =&gt; {
        const code = ctx.query.code;
        let path = 'https://github.com/login/oauth/access_token';
        const params = {
            client_id: config.client_id,
            client_secret: config.client_secret,
            code: code
        }
        console.log(code);
        await fetch(path, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(params)
        })
        .then(res =&gt; {
            return res.text();
        })
        .then(body =&gt; {
            const args = body.split('&amp;');
            let arg = args[0].split('=');
            const access_token = arg[1];
            console.log(body);
            console.log(access_token);
            return access_token;
        })
        .then(async(token) =&gt; {
            const url = ' https://api.github.com/user?access_token=' + token;
            console.log(url);
            await fetch(url)
                .then(res =&gt; {
                    return res.json();
                })
                .then(res =&gt; {
                    console.log(res);
                    ctx.body = res;
                })
        })
        .catch(e =&gt; {
            console.log(e);
        })
    })</code></pre>
<p>返回的用户信息如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722483?w=863&amp;h=399"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""user_info(github-login).png"" title=""user_info(github-login).png""></span></p>
<h3>总结</h3>
<p>用一张图来总结</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009722484?w=847&amp;h=555"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""原理过程(github-login).png"" title=""原理过程(github-login).png""></span></p>

                ", 第三方登入例子-GitHub授权登入（node-koa）,1531977832,479,1,978,1,1,https://segmentfault.com/a/1190000009722474
125,1,0,7,"
                    
<blockquote><p>前言：本教程只面向那些个人开发者，想要自己在<code>linux</code>上搭建一个<code>git</code>中央仓库用来上传发布自己的项目。但是对于团队来说可能有更高的要求，可以使用<a href=""https://about.gitlab.com/downloads/#centos7"" rel=""nofollow noreferrer""><code>gitlab</code></a>搭建一个可视化的类似<code>github</code>的版本管理系统</p></blockquote>
<h3>测试环境</h3>
<p>我使用的<code>linux</code>版本是<code>Centos7</code>，如果大家使用的是其他发行版本，步骤也都是一样的</p>
<h3>安装Git</h3>
<p><code>Centos</code>上使用的是<code>yum</code>的安装方式</p>
<pre><code class=""bash"">yum install -y git</code></pre>
<h3>创建一个Git用户来运行Git服务</h3>
<p>1.创建<code>git</code>用户</p>
<pre><code class=""bash"">adduser git</code></pre>
<p>2.设置用户密码</p>
<pre><code class=""bash"">passwd git</code></pre>
<p>3.禁止<code>shell</code>登录</p>
<pre><code class=""bash"">vim /etc/passwd</code></pre>
<p>找到<code>git</code>用户的那一行并进行修改</p>
<pre><code class=""bash"">将
git:x:1001:1001:,,,:/home/git:/bin/bash
修改为
git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></pre>
<p>这样一来刚创建<code>git</code>用户可以正常通过<code>ssh</code>使用<code>git</code>，但是无法登录<code>shell</code>，会更加的安全</p>
<h3>创建客户端登录证书</h3>
<p>1.客户端创建私钥和公钥</p>
<pre><code class=""bash"">ssh-keygen -t rsa -C ""12345678@qq.com""</code></pre>
<p>创建后你的用户主目录下面就有个<code>.ssh</code>文件夹，里面的<code>id.rsa</code>就是私钥，<code>id.rsa_pub</code>就是公钥。公钥里面的内容待会要用到</p>
<p>2.<code>git</code> 服务器打开RSA验证</p>
<pre><code class=""bash"">vim /etc/ssh/sshd_config</code></pre>
<p>找到并去掉前面的<code>#</code>号</p>
<pre><code class=""bash"">RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile  .ssh/authorized_keys</code></pre>
<p>最后效果如图所示</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOKGR?w=709&amp;h=173"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>3.在<code>git</code>用户的主目录里新建<code>.ssh</code>文件夹，然后在文件夹里面新建文件<code>authorized_keys</code></p>
<pre><code class=""bash"">cd /home/git
mkdir .ssh
cd .ssh
vim authorized_keys</code></pre>
<p>4.将客户端的<code>id.rsa_pub</code>公钥写进文件<code>authorized_keys</code>，一行一个。<em>添加了这个以后你连接中央仓库就不需要输入密码了，直接使用公钥和私钥的验证方式</em></p>
<h3>创建git中央仓库</h3>
<p>1.进入<code>git</code>用户主目录</p>
<pre><code class=""bash"">cd /home/git</code></pre>
<p>2.创建一个裸仓库 (一般以<code>.git</code>结尾)</p>
<pre><code class=""bash"">git init --bare test.git     #以test.git为例子,当然你可以叫任意名字</code></pre>
<p>裸仓库是没有工作区的，纯粹为了共享</p>
<p>3.修改仓库用户属主</p>
<pre><code class=""bash"">chown -R git:git test.git</code></pre>
<h3>使用<code>git hook</code>
</h3>
<blockquote><p>中央仓库其实只是一个中介，如果你想要把中央仓库的代码关联到你域名挂载下的文件夹时候，就需要使用到<code>git</code>的钩子来实现，当客户端提交代码到中央仓库，中央仓库能将代码也推送到另外的一个文件夹下面</p></blockquote>
<p>1.在服务器初始化一个本地仓库</p>
<p><strong>这个仓库就是你虚拟主机指定的文件夹，也就是你输入域名后会访问到的那个文件夹</strong></p>
<pre><code class=""bash"">cd /var/www     #进入你虚拟主机的挂载目录

git init         #初始化git
git remote add origin /home/git/test.git     #添加远程仓库到隔壁的中央仓库(滑稽)

chown -R git:git /var/www     #修改服务器本地仓库的用户属组</code></pre>
<p>2.在中央仓库中设置钩子</p>
<p>进入远程仓库的钩子目录</p>
<pre><code class=""bash"">cd /home/git/test.git/hooks</code></pre>
<p>新建一个文件<code>post-receive</code></p>
<pre><code class=""bash"">vim post-receive</code></pre>
<p>编写<code>shell</code>脚本</p>
<pre><code class=""bash"">#!/bin/sh
unset GIT_DIR
DeployPath=/var/www         #这里的目录是你自己虚拟主机的目录

cd $DeployPath
git add . -A &amp;&amp; git stash
git pull origin master</code></pre>
<p>当然你也可以视情况而定，将这个脚本编写得更加强大</p>
<p>给文件<code>post-receive</code>添加可执行权限</p>
<pre><code class=""bash"">chmod +x post-receive</code></pre>
<h3>客户端远程git服务器</h3>
<blockquote><p>这应该也是大家最期待的步骤了，实现本地提交代码上服务器，通过钩子实现项目的自动部署<br>其实到了这一步，就和你以前使用<code>git</code>上传代码到<code>github</code>上面没有什么区别了</p></blockquote>
<p>1.克隆中央仓库</p>
<pre><code class=""bash"">方法一
git clone git@192.168.229.130:test.git        #把ip换成你自己服务器的ip

方法二
git init
git remote add origin git@118.89.28.249:test.git    #把ip换成你自己服务器的ip</code></pre>
<p>2.推送远程服务器 (第一次加上-u参数)</p>
<pre><code class=""bash"">git push -u origin master</code></pre>
<h3>结尾</h3>
<p>通过上面的这些步骤其实就可以实现一个简易的<code>git</code>服务器了，是不是很简单呢?</p>

                ", 如何在Linux上搭建一个Git中央仓库,1531977834,324,1,811,1,1,https://segmentfault.com/a/1190000009673544
126,1,0,7,"
                    
<p>最新emoji大全：<a href=""https://github.com/caiyongji/emoji-list"" rel=""nofollow noreferrer"">emoji列表</a></p>
<h1>emoji-list</h1>
<p>emoji表情列表</p>
<p><a href=""https://github.com/caiyongji/emoji-list/issues"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000009649783"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a>  <a href=""https://github.com/caiyongji/emoji-list/network"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000009649784"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a> <a href=""https://github.com/caiyongji/emoji-list/stargazers"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000009649785"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a> <a href=""https://travis-ci.org/caiyongji/emoji-list"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000009649786"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a> <a href=""https://github.com/caiyongji/emoji-list/releases"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000009649787"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></a></p>
<h2>目录</h2>
<ul>
<li><p><a>人物</a></p></li>
<li><p><a>自然</a></p></li>
<li><p><a>事物</a></p></li>
<li><p><a>地点</a></p></li>
<li><p><a>符号</a></p></li>
</ul>
<h2>人物</h2>
<table>
<thead><tr>
<th>
<span class=""emoji emoji-bowtie""></span> <code>:bowtie:</code>
</th>
<th>
<span class=""emoji emoji-smile""></span> <code>:smile:</code>
</th>
<th>
<span class=""emoji emoji-laughing""></span> <code>:laughing:</code>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class=""emoji emoji-blush""></span> <code>:blush:</code>
</td>
<td>
<span class=""emoji emoji-smiley""></span> <code>:smiley:</code>
</td>
<td>
<span class=""emoji emoji-relaxed""></span> <code>:relaxed:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-smirk""></span> <code>:smirk:</code>
</td>
<td>
<span class=""emoji emoji-heart_eyes""></span> <code>:heart_eyes:</code>
</td>
<td>
<span class=""emoji emoji-kissing_heart""></span> <code>:kissing_heart:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-kissing_closed_eyes""></span> <code>:kissing_closed_eyes:</code>
</td>
<td>
<span class=""emoji emoji-flushed""></span> <code>:flushed:</code>
</td>
<td>
<span class=""emoji emoji-relieved""></span> <code>:relieved:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-satisfied""></span> <code>:satisfied:</code>
</td>
<td>
<span class=""emoji emoji-grin""></span> <code>:grin:</code>
</td>
<td>
<span class=""emoji emoji-wink""></span> <code>:wink:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-stuck_out_tongue_winking_eye""></span> <code>:stuck_out_tongue_winking_eye:</code>
</td>
<td>
<span class=""emoji emoji-stuck_out_tongue_closed_eyes""></span> <code>:stuck_out_tongue_closed_eyes:</code>
</td>
<td>
<span class=""emoji emoji-grinning""></span> <code>:grinning:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-kissing""></span> <code>:kissing:</code>
</td>
<td>
<span class=""emoji emoji-kissing_smiling_eyes""></span> <code>:kissing_smiling_eyes:</code>
</td>
<td>
<span class=""emoji emoji-stuck_out_tongue""></span> <code>:stuck_out_tongue:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sleeping""></span> <code>:sleeping:</code>
</td>
<td>
<span class=""emoji emoji-worried""></span> <code>:worried:</code>
</td>
<td>
<span class=""emoji emoji-frowning""></span> <code>:frowning:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-anguished""></span> <code>:anguished:</code>
</td>
<td>
<span class=""emoji emoji-open_mouth""></span> <code>:open_mouth:</code>
</td>
<td>
<span class=""emoji emoji-grimacing""></span> <code>:grimacing:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-confused""></span> <code>:confused:</code>
</td>
<td>
<span class=""emoji emoji-hushed""></span> <code>:hushed:</code>
</td>
<td>
<span class=""emoji emoji-expressionless""></span> <code>:expressionless:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-unamused""></span> <code>:unamused:</code>
</td>
<td>
<span class=""emoji emoji-sweat_smile""></span> <code>:sweat_smile:</code>
</td>
<td>
<span class=""emoji emoji-sweat""></span> <code>:sweat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-disappointed_relieved""></span> <code>:disappointed_relieved:</code>
</td>
<td>
<span class=""emoji emoji-weary""></span> <code>:weary:</code>
</td>
<td>
<span class=""emoji emoji-pensive""></span> <code>:pensive:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-disappointed""></span> <code>:disappointed:</code>
</td>
<td>
<span class=""emoji emoji-confounded""></span> <code>:confounded:</code>
</td>
<td>
<span class=""emoji emoji-fearful""></span> <code>:fearful:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cold_sweat""></span> <code>:cold_sweat:</code>
</td>
<td>
<span class=""emoji emoji-persevere""></span> <code>:persevere:</code>
</td>
<td>
<span class=""emoji emoji-cry""></span> <code>:cry:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sob""></span> <code>:sob:</code>
</td>
<td>
<span class=""emoji emoji-joy""></span> <code>:joy:</code>
</td>
<td>
<span class=""emoji emoji-astonished""></span> <code>:astonished:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-scream""></span> <code>:scream:</code>
</td>
<td>
<span class=""emoji emoji-neckbeard""></span> <code>:neckbeard:</code>
</td>
<td>
<span class=""emoji emoji-tired_face""></span> <code>:tired_face:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-angry""></span> <code>:angry:</code>
</td>
<td>
<span class=""emoji emoji-rage""></span> <code>:rage:</code>
</td>
<td>
<span class=""emoji emoji-triumph""></span> <code>:triumph:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sleepy""></span> <code>:sleepy:</code>
</td>
<td>
<span class=""emoji emoji-yum""></span> <code>:yum:</code>
</td>
<td>
<span class=""emoji emoji-mask""></span> <code>:mask:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sunglasses""></span> <code>:sunglasses:</code>
</td>
<td>
<span class=""emoji emoji-dizzy_face""></span> <code>:dizzy_face:</code>
</td>
<td>
<span class=""emoji emoji-imp""></span> <code>:imp:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-smiling_imp""></span> <code>:smiling_imp:</code>
</td>
<td>
<span class=""emoji emoji-neutral_face""></span> <code>:neutral_face:</code>
</td>
<td>
<span class=""emoji emoji-no_mouth""></span> <code>:no_mouth:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-innocent""></span> <code>:innocent:</code>
</td>
<td>
<span class=""emoji emoji-alien""></span> <code>:alien:</code>
</td>
<td>
<span class=""emoji emoji-yellow_heart""></span> <code>:yellow_heart:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-blue_heart""></span> <code>:blue_heart:</code>
</td>
<td>
<span class=""emoji emoji-purple_heart""></span> <code>:purple_heart:</code>
</td>
<td>
<span class=""emoji emoji-heart""></span> <code>:heart:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-green_heart""></span> <code>:green_heart:</code>
</td>
<td>
<span class=""emoji emoji-broken_heart""></span> <code>:broken_heart:</code>
</td>
<td>
<span class=""emoji emoji-heartbeat""></span> <code>:heartbeat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-heartpulse""></span> <code>:heartpulse:</code>
</td>
<td>
<span class=""emoji emoji-two_hearts""></span> <code>:two_hearts:</code>
</td>
<td>
<span class=""emoji emoji-revolving_hearts""></span> <code>:revolving_hearts:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cupid""></span> <code>:cupid:</code>
</td>
<td>
<span class=""emoji emoji-sparkling_heart""></span> <code>:sparkling_heart:</code>
</td>
<td>
<span class=""emoji emoji-sparkles""></span> <code>:sparkles:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-star""></span> <code>:star:</code>
</td>
<td>
<span class=""emoji emoji-star2""></span> <code>:star2:</code>
</td>
<td>
<span class=""emoji emoji-dizzy""></span> <code>:dizzy:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-boom""></span> <code>:boom:</code>
</td>
<td>
<span class=""emoji emoji-collision""></span> <code>:collision:</code>
</td>
<td>
<span class=""emoji emoji-anger""></span> <code>:anger:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-exclamation""></span> <code>:exclamation:</code>
</td>
<td>
<span class=""emoji emoji-question""></span> <code>:question:</code>
</td>
<td>
<span class=""emoji emoji-grey_exclamation""></span> <code>:grey_exclamation:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-grey_question""></span> <code>:grey_question:</code>
</td>
<td>
<span class=""emoji emoji-zzz""></span> <code>:zzz:</code>
</td>
<td>
<span class=""emoji emoji-dash""></span> <code>:dash:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sweat_drops""></span> <code>:sweat_drops:</code>
</td>
<td>
<span class=""emoji emoji-notes""></span> <code>:notes:</code>
</td>
<td>
<span class=""emoji emoji-musical_note""></span> <code>:musical_note:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-fire""></span> <code>:fire:</code>
</td>
<td>
<span class=""emoji emoji-hankey""></span> <code>:hankey:</code>
</td>
<td>
<span class=""emoji emoji-poop""></span> <code>:poop:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-shit""></span> <code>:shit:</code>
</td>
<td>:+1: <code>:+1:</code>
</td>
<td>
<span class=""emoji emoji-thumbsup""></span> <code>:thumbsup:</code>
</td>
</tr>
<tr>
<td>:-1: <code>:-1:</code>
</td>
<td>
<span class=""emoji emoji-thumbsdown""></span> <code>:thumbsdown:</code>
</td>
<td>
<span class=""emoji emoji-ok_hand""></span> <code>:ok_hand:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-punch""></span> <code>:punch:</code>
</td>
<td>
<span class=""emoji emoji-facepunch""></span> <code>:facepunch:</code>
</td>
<td>
<span class=""emoji emoji-fist""></span> <code>:fist:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-v""></span> <code>:v:</code>
</td>
<td>
<span class=""emoji emoji-wave""></span> <code>:wave:</code>
</td>
<td>
<span class=""emoji emoji-hand""></span> <code>:hand:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-raised_hand""></span> <code>:raised_hand:</code>
</td>
<td>
<span class=""emoji emoji-open_hands""></span> <code>:open_hands:</code>
</td>
<td>
<span class=""emoji emoji-point_up""></span> <code>:point_up:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-point_down""></span> <code>:point_down:</code>
</td>
<td>
<span class=""emoji emoji-point_left""></span> <code>:point_left:</code>
</td>
<td>
<span class=""emoji emoji-point_right""></span> <code>:point_right:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-raised_hands""></span> <code>:raised_hands:</code>
</td>
<td>
<span class=""emoji emoji-pray""></span> <code>:pray:</code>
</td>
<td>
<span class=""emoji emoji-point_up_2""></span> <code>:point_up_2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clap""></span> <code>:clap:</code>
</td>
<td>
<span class=""emoji emoji-muscle""></span> <code>:muscle:</code>
</td>
<td>
<span class=""emoji emoji-metal""></span> <code>:metal:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-fu""></span> <code>:fu:</code>
</td>
<td>
<span class=""emoji emoji-walking""></span> <code>:walking:</code>
</td>
<td>
<span class=""emoji emoji-runner""></span> <code>:runner:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-running""></span> <code>:running:</code>
</td>
<td>
<span class=""emoji emoji-couple""></span> <code>:couple:</code>
</td>
<td>
<span class=""emoji emoji-family""></span> <code>:family:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-two_men_holding_hands""></span> <code>:two_men_holding_hands:</code>
</td>
<td>
<span class=""emoji emoji-two_women_holding_hands""></span> <code>:two_women_holding_hands:</code>
</td>
<td>
<span class=""emoji emoji-dancer""></span> <code>:dancer:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-dancers""></span> <code>:dancers:</code>
</td>
<td>
<span class=""emoji emoji-ok_woman""></span> <code>:ok_woman:</code>
</td>
<td>
<span class=""emoji emoji-no_good""></span> <code>:no_good:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-information_desk_person""></span> <code>:information_desk_person:</code>
</td>
<td>
<span class=""emoji emoji-raising_hand""></span> <code>:raising_hand:</code>
</td>
<td>
<span class=""emoji emoji-bride_with_veil""></span> <code>:bride_with_veil:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-person_with_pouting_face""></span> <code>:person_with_pouting_face:</code>
</td>
<td>
<span class=""emoji emoji-person_frowning""></span> <code>:person_frowning:</code>
</td>
<td>
<span class=""emoji emoji-bow""></span> <code>:bow:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-couplekiss""></span> <code>:couplekiss:</code>
</td>
<td>
<span class=""emoji emoji-couple_with_heart""></span> <code>:couple_with_heart:</code>
</td>
<td>
<span class=""emoji emoji-massage""></span> <code>:massage:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-haircut""></span> <code>:haircut:</code>
</td>
<td>
<span class=""emoji emoji-nail_care""></span> <code>:nail_care:</code>
</td>
<td>
<span class=""emoji emoji-boy""></span> <code>:boy:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-girl""></span> <code>:girl:</code>
</td>
<td>
<span class=""emoji emoji-woman""></span> <code>:woman:</code>
</td>
<td>
<span class=""emoji emoji-man""></span> <code>:man:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-baby""></span> <code>:baby:</code>
</td>
<td>
<span class=""emoji emoji-older_woman""></span> <code>:older_woman:</code>
</td>
<td>
<span class=""emoji emoji-older_man""></span> <code>:older_man:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-person_with_blond_hair""></span> <code>:person_with_blond_hair:</code>
</td>
<td>
<span class=""emoji emoji-man_with_gua_pi_mao""></span> <code>:man_with_gua_pi_mao:</code>
</td>
<td>
<span class=""emoji emoji-man_with_turban""></span> <code>:man_with_turban:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-construction_worker""></span> <code>:construction_worker:</code>
</td>
<td>
<span class=""emoji emoji-cop""></span> <code>:cop:</code>
</td>
<td>
<span class=""emoji emoji-angel""></span> <code>:angel:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-princess""></span> <code>:princess:</code>
</td>
<td>
<span class=""emoji emoji-smiley_cat""></span> <code>:smiley_cat:</code>
</td>
<td>
<span class=""emoji emoji-smile_cat""></span> <code>:smile_cat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-heart_eyes_cat""></span> <code>:heart_eyes_cat:</code>
</td>
<td>
<span class=""emoji emoji-kissing_cat""></span> <code>:kissing_cat:</code>
</td>
<td>
<span class=""emoji emoji-smirk_cat""></span> <code>:smirk_cat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-scream_cat""></span> <code>:scream_cat:</code>
</td>
<td>
<span class=""emoji emoji-crying_cat_face""></span> <code>:crying_cat_face:</code>
</td>
<td>
<span class=""emoji emoji-joy_cat""></span> <code>:joy_cat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-pouting_cat""></span> <code>:pouting_cat:</code>
</td>
<td>
<span class=""emoji emoji-japanese_ogre""></span> <code>:japanese_ogre:</code>
</td>
<td>
<span class=""emoji emoji-japanese_goblin""></span> <code>:japanese_goblin:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-see_no_evil""></span> <code>:see_no_evil:</code>
</td>
<td>
<span class=""emoji emoji-hear_no_evil""></span> <code>:hear_no_evil:</code>
</td>
<td>
<span class=""emoji emoji-speak_no_evil""></span> <code>:speak_no_evil:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-guardsman""></span> <code>:guardsman:</code>
</td>
<td>
<span class=""emoji emoji-skull""></span> <code>:skull:</code>
</td>
<td>
<span class=""emoji emoji-feet""></span> <code>:feet:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-lips""></span> <code>:lips:</code>
</td>
<td>
<span class=""emoji emoji-kiss""></span> <code>:kiss:</code>
</td>
<td>
<span class=""emoji emoji-droplet""></span> <code>:droplet:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ear""></span> <code>:ear:</code>
</td>
<td>
<span class=""emoji emoji-eyes""></span> <code>:eyes:</code>
</td>
<td>
<span class=""emoji emoji-nose""></span> <code>:nose:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tongue""></span> <code>:tongue:</code>
</td>
<td>
<span class=""emoji emoji-love_letter""></span> <code>:love_letter:</code>
</td>
<td>
<span class=""emoji emoji-bust_in_silhouette""></span> <code>:bust_in_silhouette:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-busts_in_silhouette""></span> <code>:busts_in_silhouette:</code>
</td>
<td>
<span class=""emoji emoji-speech_balloon""></span> <code>:speech_balloon:</code>
</td>
<td>
<span class=""emoji emoji-thought_balloon""></span> <code>:thought_balloon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-feelsgood""></span> <code>:feelsgood:</code>
</td>
<td>
<span class=""emoji emoji-finnadie""></span> <code>:finnadie:</code>
</td>
<td>
<span class=""emoji emoji-goberserk""></span> <code>:goberserk:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-godmode""></span> <code>:godmode:</code>
</td>
<td>
<span class=""emoji emoji-hurtrealbad""></span> <code>:hurtrealbad:</code>
</td>
<td>
<span class=""emoji emoji-rage1""></span> <code>:rage1:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rage2""></span> <code>:rage2:</code>
</td>
<td>
<span class=""emoji emoji-rage3""></span> <code>:rage3:</code>
</td>
<td>
<span class=""emoji emoji-rage4""></span> <code>:rage4:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-suspect""></span> <code>:suspect:</code>
</td>
<td>
<span class=""emoji emoji-trollface""></span> <code>:trollface:</code>
</td>
</tr>
</tbody>
</table>
<h2>自然</h2>
<table>
<thead><tr>
<th>
<span class=""emoji emoji-sunny""></span> <code>:sunny:</code>
</th>
<th>
<span class=""emoji emoji-umbrella""></span> <code>:umbrella:</code>
</th>
<th>
<span class=""emoji emoji-cloud""></span> <code>:cloud:</code>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class=""emoji emoji-snowflake""></span> <code>:snowflake:</code>
</td>
<td>
<span class=""emoji emoji-snowman""></span> <code>:snowman:</code>
</td>
<td>
<span class=""emoji emoji-zap""></span> <code>:zap:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cyclone""></span> <code>:cyclone:</code>
</td>
<td>
<span class=""emoji emoji-foggy""></span> <code>:foggy:</code>
</td>
<td>
<span class=""emoji emoji-ocean""></span> <code>:ocean:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cat""></span> <code>:cat:</code>
</td>
<td>
<span class=""emoji emoji-dog""></span> <code>:dog:</code>
</td>
<td>
<span class=""emoji emoji-mouse""></span> <code>:mouse:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-hamster""></span> <code>:hamster:</code>
</td>
<td>
<span class=""emoji emoji-rabbit""></span> <code>:rabbit:</code>
</td>
<td>
<span class=""emoji emoji-wolf""></span> <code>:wolf:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-frog""></span> <code>:frog:</code>
</td>
<td>
<span class=""emoji emoji-tiger""></span> <code>:tiger:</code>
</td>
<td>
<span class=""emoji emoji-koala""></span> <code>:koala:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bear""></span> <code>:bear:</code>
</td>
<td>
<span class=""emoji emoji-pig""></span> <code>:pig:</code>
</td>
<td>
<span class=""emoji emoji-pig_nose""></span> <code>:pig_nose:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cow""></span> <code>:cow:</code>
</td>
<td>
<span class=""emoji emoji-boar""></span> <code>:boar:</code>
</td>
<td>
<span class=""emoji emoji-monkey_face""></span> <code>:monkey_face:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-monkey""></span> <code>:monkey:</code>
</td>
<td>
<span class=""emoji emoji-horse""></span> <code>:horse:</code>
</td>
<td>
<span class=""emoji emoji-racehorse""></span> <code>:racehorse:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-camel""></span> <code>:camel:</code>
</td>
<td>
<span class=""emoji emoji-sheep""></span> <code>:sheep:</code>
</td>
<td>
<span class=""emoji emoji-elephant""></span> <code>:elephant:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-panda_face""></span> <code>:panda_face:</code>
</td>
<td>
<span class=""emoji emoji-snake""></span> <code>:snake:</code>
</td>
<td>
<span class=""emoji emoji-bird""></span> <code>:bird:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-baby_chick""></span> <code>:baby_chick:</code>
</td>
<td>
<span class=""emoji emoji-hatched_chick""></span> <code>:hatched_chick:</code>
</td>
<td>
<span class=""emoji emoji-hatching_chick""></span> <code>:hatching_chick:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-chicken""></span> <code>:chicken:</code>
</td>
<td>
<span class=""emoji emoji-penguin""></span> <code>:penguin:</code>
</td>
<td>
<span class=""emoji emoji-turtle""></span> <code>:turtle:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bug""></span> <code>:bug:</code>
</td>
<td>
<span class=""emoji emoji-honeybee""></span> <code>:honeybee:</code>
</td>
<td>
<span class=""emoji emoji-ant""></span> <code>:ant:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-beetle""></span> <code>:beetle:</code>
</td>
<td>
<span class=""emoji emoji-snail""></span> <code>:snail:</code>
</td>
<td>
<span class=""emoji emoji-octopus""></span> <code>:octopus:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tropical_fish""></span> <code>:tropical_fish:</code>
</td>
<td>
<span class=""emoji emoji-fish""></span> <code>:fish:</code>
</td>
<td>
<span class=""emoji emoji-whale""></span> <code>:whale:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-whale2""></span> <code>:whale2:</code>
</td>
<td>
<span class=""emoji emoji-dolphin""></span> <code>:dolphin:</code>
</td>
<td>
<span class=""emoji emoji-cow2""></span> <code>:cow2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ram""></span> <code>:ram:</code>
</td>
<td>
<span class=""emoji emoji-rat""></span> <code>:rat:</code>
</td>
<td>
<span class=""emoji emoji-water_buffalo""></span> <code>:water_buffalo:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tiger2""></span> <code>:tiger2:</code>
</td>
<td>
<span class=""emoji emoji-rabbit2""></span> <code>:rabbit2:</code>
</td>
<td>
<span class=""emoji emoji-dragon""></span> <code>:dragon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-goat""></span> <code>:goat:</code>
</td>
<td>
<span class=""emoji emoji-rooster""></span> <code>:rooster:</code>
</td>
<td>
<span class=""emoji emoji-dog2""></span> <code>:dog2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-pig2""></span> <code>:pig2:</code>
</td>
<td>
<span class=""emoji emoji-mouse2""></span> <code>:mouse2:</code>
</td>
<td>
<span class=""emoji emoji-ox""></span> <code>:ox:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-dragon_face""></span> <code>:dragon_face:</code>
</td>
<td>
<span class=""emoji emoji-blowfish""></span> <code>:blowfish:</code>
</td>
<td>
<span class=""emoji emoji-crocodile""></span> <code>:crocodile:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-dromedary_camel""></span> <code>:dromedary_camel:</code>
</td>
<td>
<span class=""emoji emoji-leopard""></span> <code>:leopard:</code>
</td>
<td>
<span class=""emoji emoji-cat2""></span> <code>:cat2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-poodle""></span> <code>:poodle:</code>
</td>
<td>
<span class=""emoji emoji-paw_prints""></span> <code>:paw_prints:</code>
</td>
<td>
<span class=""emoji emoji-bouquet""></span> <code>:bouquet:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cherry_blossom""></span> <code>:cherry_blossom:</code>
</td>
<td>
<span class=""emoji emoji-tulip""></span> <code>:tulip:</code>
</td>
<td>
<span class=""emoji emoji-four_leaf_clover""></span> <code>:four_leaf_clover:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rose""></span> <code>:rose:</code>
</td>
<td>
<span class=""emoji emoji-sunflower""></span> <code>:sunflower:</code>
</td>
<td>
<span class=""emoji emoji-hibiscus""></span> <code>:hibiscus:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-maple_leaf""></span> <code>:maple_leaf:</code>
</td>
<td>
<span class=""emoji emoji-leaves""></span> <code>:leaves:</code>
</td>
<td>
<span class=""emoji emoji-fallen_leaf""></span> <code>:fallen_leaf:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-herb""></span> <code>:herb:</code>
</td>
<td>
<span class=""emoji emoji-mushroom""></span> <code>:mushroom:</code>
</td>
<td>
<span class=""emoji emoji-cactus""></span> <code>:cactus:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-palm_tree""></span> <code>:palm_tree:</code>
</td>
<td>
<span class=""emoji emoji-evergreen_tree""></span> <code>:evergreen_tree:</code>
</td>
<td>
<span class=""emoji emoji-deciduous_tree""></span> <code>:deciduous_tree:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-chestnut""></span> <code>:chestnut:</code>
</td>
<td>
<span class=""emoji emoji-seedling""></span> <code>:seedling:</code>
</td>
<td>
<span class=""emoji emoji-blossom""></span> <code>:blossom:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ear_of_rice""></span> <code>:ear_of_rice:</code>
</td>
<td>
<span class=""emoji emoji-shell""></span> <code>:shell:</code>
</td>
<td>
<span class=""emoji emoji-globe_with_meridians""></span> <code>:globe_with_meridians:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sun_with_face""></span> <code>:sun_with_face:</code>
</td>
<td>
<span class=""emoji emoji-full_moon_with_face""></span> <code>:full_moon_with_face:</code>
</td>
<td>
<span class=""emoji emoji-new_moon_with_face""></span> <code>:new_moon_with_face:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-new_moon""></span> <code>:new_moon:</code>
</td>
<td>
<span class=""emoji emoji-waxing_crescent_moon""></span> <code>:waxing_crescent_moon:</code>
</td>
<td>
<span class=""emoji emoji-first_quarter_moon""></span> <code>:first_quarter_moon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-waxing_gibbous_moon""></span> <code>:waxing_gibbous_moon:</code>
</td>
<td>
<span class=""emoji emoji-full_moon""></span> <code>:full_moon:</code>
</td>
<td>
<span class=""emoji emoji-waning_gibbous_moon""></span> <code>:waning_gibbous_moon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-last_quarter_moon""></span> <code>:last_quarter_moon:</code>
</td>
<td>
<span class=""emoji emoji-waning_crescent_moon""></span> <code>:waning_crescent_moon:</code>
</td>
<td>
<span class=""emoji emoji-last_quarter_moon_with_face""></span> <code>:last_quarter_moon_with_face:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-first_quarter_moon_with_face""></span> <code>:first_quarter_moon_with_face:</code>
</td>
<td>:moon: <code>:moon:</code>
</td>
<td>
<span class=""emoji emoji-earth_africa""></span> <code>:earth_africa:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-earth_americas""></span> <code>:earth_americas:</code>
</td>
<td>
<span class=""emoji emoji-earth_asia""></span> <code>:earth_asia:</code>
</td>
<td>
<span class=""emoji emoji-volcano""></span> <code>:volcano:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-milky_way""></span> <code>:milky_way:</code>
</td>
<td>
<span class=""emoji emoji-partly_sunny""></span> <code>:partly_sunny:</code>
</td>
<td>
<span class=""emoji emoji-octocat""></span> <code>:octocat:</code>
</td>
</tr>
<tr><td>
<span class=""emoji emoji-squirrel""></span> <code>:squirrel:</code>
</td></tr>
</tbody>
</table>
<h2>事物</h2>
<table>
<thead><tr>
<th>
<span class=""emoji emoji-bamboo""></span> <code>:bamboo:</code>
</th>
<th>
<span class=""emoji emoji-gift_heart""></span> <code>:gift_heart:</code>
</th>
<th>
<span class=""emoji emoji-dolls""></span> <code>:dolls:</code>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class=""emoji emoji-school_satchel""></span> <code>:school_satchel:</code>
</td>
<td>
<span class=""emoji emoji-mortar_board""></span> <code>:mortar_board:</code>
</td>
<td>
<span class=""emoji emoji-flags""></span> <code>:flags:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-fireworks""></span> <code>:fireworks:</code>
</td>
<td>
<span class=""emoji emoji-sparkler""></span> <code>:sparkler:</code>
</td>
<td>
<span class=""emoji emoji-wind_chime""></span> <code>:wind_chime:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rice_scene""></span> <code>:rice_scene:</code>
</td>
<td>
<span class=""emoji emoji-jack_o_lantern""></span> <code>:jack_o_lantern:</code>
</td>
<td>
<span class=""emoji emoji-ghost""></span> <code>:ghost:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-santa""></span> <code>:santa:</code>
</td>
<td>
<span class=""emoji emoji-christmas_tree""></span> <code>:christmas_tree:</code>
</td>
<td>
<span class=""emoji emoji-gift""></span> <code>:gift:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bell""></span> <code>:bell:</code>
</td>
<td>
<span class=""emoji emoji-no_bell""></span> <code>:no_bell:</code>
</td>
<td>
<span class=""emoji emoji-tanabata_tree""></span> <code>:tanabata_tree:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tada""></span> <code>:tada:</code>
</td>
<td>
<span class=""emoji emoji-confetti_ball""></span> <code>:confetti_ball:</code>
</td>
<td>
<span class=""emoji emoji-balloon""></span> <code>:balloon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-crystal_ball""></span> <code>:crystal_ball:</code>
</td>
<td>
<span class=""emoji emoji-cd""></span> <code>:cd:</code>
</td>
<td>
<span class=""emoji emoji-dvd""></span> <code>:dvd:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-floppy_disk""></span> <code>:floppy_disk:</code>
</td>
<td>
<span class=""emoji emoji-camera""></span> <code>:camera:</code>
</td>
<td>
<span class=""emoji emoji-video_camera""></span> <code>:video_camera:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-movie_camera""></span> <code>:movie_camera:</code>
</td>
<td>
<span class=""emoji emoji-computer""></span> <code>:computer:</code>
</td>
<td>
<span class=""emoji emoji-tv""></span> <code>:tv:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-iphone""></span> <code>:iphone:</code>
</td>
<td>
<span class=""emoji emoji-phone""></span> <code>:phone:</code>
</td>
<td>
<span class=""emoji emoji-telephone""></span> <code>:telephone:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-telephone_receiver""></span> <code>:telephone_receiver:</code>
</td>
<td>
<span class=""emoji emoji-pager""></span> <code>:pager:</code>
</td>
<td>
<span class=""emoji emoji-fax""></span> <code>:fax:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-minidisc""></span> <code>:minidisc:</code>
</td>
<td>
<span class=""emoji emoji-vhs""></span> <code>:vhs:</code>
</td>
<td>
<span class=""emoji emoji-sound""></span> <code>:sound:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-speaker""></span> <code>:speaker:</code>
</td>
<td>
<span class=""emoji emoji-mute""></span> <code>:mute:</code>
</td>
<td>
<span class=""emoji emoji-loudspeaker""></span> <code>:loudspeaker:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-mega""></span> <code>:mega:</code>
</td>
<td>
<span class=""emoji emoji-hourglass""></span> <code>:hourglass:</code>
</td>
<td>
<span class=""emoji emoji-hourglass_flowing_sand""></span> <code>:hourglass_flowing_sand:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-alarm_clock""></span> <code>:alarm_clock:</code>
</td>
<td>
<span class=""emoji emoji-watch""></span> <code>:watch:</code>
</td>
<td>
<span class=""emoji emoji-radio""></span> <code>:radio:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-satellite""></span> <code>:satellite:</code>
</td>
<td>
<span class=""emoji emoji-loop""></span> <code>:loop:</code>
</td>
<td>
<span class=""emoji emoji-mag""></span> <code>:mag:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-mag_right""></span> <code>:mag_right:</code>
</td>
<td>
<span class=""emoji emoji-unlock""></span> <code>:unlock:</code>
</td>
<td>
<span class=""emoji emoji-lock""></span> <code>:lock:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-lock_with_ink_pen""></span> <code>:lock_with_ink_pen:</code>
</td>
<td>
<span class=""emoji emoji-closed_lock_with_key""></span> <code>:closed_lock_with_key:</code>
</td>
<td>
<span class=""emoji emoji-key""></span> <code>:key:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bulb""></span> <code>:bulb:</code>
</td>
<td>
<span class=""emoji emoji-flashlight""></span> <code>:flashlight:</code>
</td>
<td>
<span class=""emoji emoji-high_brightness""></span> <code>:high_brightness:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-low_brightness""></span> <code>:low_brightness:</code>
</td>
<td>
<span class=""emoji emoji-electric_plug""></span> <code>:electric_plug:</code>
</td>
<td>
<span class=""emoji emoji-battery""></span> <code>:battery:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-calling""></span> <code>:calling:</code>
</td>
<td>
<span class=""emoji emoji-email""></span> <code>:email:</code>
</td>
<td>
<span class=""emoji emoji-mailbox""></span> <code>:mailbox:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-postbox""></span> <code>:postbox:</code>
</td>
<td>
<span class=""emoji emoji-bath""></span> <code>:bath:</code>
</td>
<td>
<span class=""emoji emoji-bathtub""></span> <code>:bathtub:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-shower""></span> <code>:shower:</code>
</td>
<td>
<span class=""emoji emoji-toilet""></span> <code>:toilet:</code>
</td>
<td>
<span class=""emoji emoji-wrench""></span> <code>:wrench:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-nut_and_bolt""></span> <code>:nut_and_bolt:</code>
</td>
<td>
<span class=""emoji emoji-hammer""></span> <code>:hammer:</code>
</td>
<td>
<span class=""emoji emoji-seat""></span> <code>:seat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-moneybag""></span> <code>:moneybag:</code>
</td>
<td>
<span class=""emoji emoji-yen""></span> <code>:yen:</code>
</td>
<td>
<span class=""emoji emoji-dollar""></span> <code>:dollar:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-pound""></span> <code>:pound:</code>
</td>
<td>
<span class=""emoji emoji-euro""></span> <code>:euro:</code>
</td>
<td>
<span class=""emoji emoji-credit_card""></span> <code>:credit_card:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-money_with_wings""></span> <code>:money_with_wings:</code>
</td>
<td>:e-mail: <code>:e-mail:</code>
</td>
<td>
<span class=""emoji emoji-inbox_tray""></span> <code>:inbox_tray:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-outbox_tray""></span> <code>:outbox_tray:</code>
</td>
<td>
<span class=""emoji emoji-envelope""></span> <code>:envelope:</code>
</td>
<td>
<span class=""emoji emoji-incoming_envelope""></span> <code>:incoming_envelope:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-postal_horn""></span> <code>:postal_horn:</code>
</td>
<td>
<span class=""emoji emoji-mailbox_closed""></span> <code>:mailbox_closed:</code>
</td>
<td>
<span class=""emoji emoji-mailbox_with_mail""></span> <code>:mailbox_with_mail:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-mailbox_with_no_mail""></span> <code>:mailbox_with_no_mail:</code>
</td>
<td>
<span class=""emoji emoji-door""></span> <code>:door:</code>
</td>
<td>
<span class=""emoji emoji-smoking""></span> <code>:smoking:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bomb""></span> <code>:bomb:</code>
</td>
<td>
<span class=""emoji emoji-gun""></span> <code>:gun:</code>
</td>
<td>
<span class=""emoji emoji-hocho""></span> <code>:hocho:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-pill""></span> <code>:pill:</code>
</td>
<td>
<span class=""emoji emoji-syringe""></span> <code>:syringe:</code>
</td>
<td>
<span class=""emoji emoji-page_facing_up""></span> <code>:page_facing_up:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-page_with_curl""></span> <code>:page_with_curl:</code>
</td>
<td>
<span class=""emoji emoji-bookmark_tabs""></span> <code>:bookmark_tabs:</code>
</td>
<td>
<span class=""emoji emoji-bar_chart""></span> <code>:bar_chart:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-chart_with_upwards_trend""></span> <code>:chart_with_upwards_trend:</code>
</td>
<td>
<span class=""emoji emoji-chart_with_downwards_trend""></span> <code>:chart_with_downwards_trend:</code>
</td>
<td>
<span class=""emoji emoji-scroll""></span> <code>:scroll:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clipboard""></span> <code>:clipboard:</code>
</td>
<td>
<span class=""emoji emoji-calendar""></span> <code>:calendar:</code>
</td>
<td>
<span class=""emoji emoji-date""></span> <code>:date:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-card_index""></span> <code>:card_index:</code>
</td>
<td>
<span class=""emoji emoji-file_folder""></span> <code>:file_folder:</code>
</td>
<td>
<span class=""emoji emoji-open_file_folder""></span> <code>:open_file_folder:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-scissors""></span> <code>:scissors:</code>
</td>
<td>
<span class=""emoji emoji-pushpin""></span> <code>:pushpin:</code>
</td>
<td>
<span class=""emoji emoji-paperclip""></span> <code>:paperclip:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-black_nib""></span> <code>:black_nib:</code>
</td>
<td>
<span class=""emoji emoji-pencil2""></span> <code>:pencil2:</code>
</td>
<td>
<span class=""emoji emoji-straight_ruler""></span> <code>:straight_ruler:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-triangular_ruler""></span> <code>:triangular_ruler:</code>
</td>
<td>
<span class=""emoji emoji-closed_book""></span> <code>:closed_book:</code>
</td>
<td>
<span class=""emoji emoji-green_book""></span> <code>:green_book:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-blue_book""></span> <code>:blue_book:</code>
</td>
<td>
<span class=""emoji emoji-orange_book""></span> <code>:orange_book:</code>
</td>
<td>
<span class=""emoji emoji-notebook""></span> <code>:notebook:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-notebook_with_decorative_cover""></span> <code>:notebook_with_decorative_cover:</code>
</td>
<td>
<span class=""emoji emoji-ledger""></span> <code>:ledger:</code>
</td>
<td>
<span class=""emoji emoji-books""></span> <code>:books:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bookmark""></span> <code>:bookmark:</code>
</td>
<td>
<span class=""emoji emoji-name_badge""></span> <code>:name_badge:</code>
</td>
<td>
<span class=""emoji emoji-microscope""></span> <code>:microscope:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-telescope""></span> <code>:telescope:</code>
</td>
<td>
<span class=""emoji emoji-newspaper""></span> <code>:newspaper:</code>
</td>
<td>
<span class=""emoji emoji-football""></span> <code>:football:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-basketball""></span> <code>:basketball:</code>
</td>
<td>
<span class=""emoji emoji-soccer""></span> <code>:soccer:</code>
</td>
<td>
<span class=""emoji emoji-baseball""></span> <code>:baseball:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tennis""></span> <code>:tennis:</code>
</td>
<td>
<span class=""emoji emoji-8ball""></span> <code>:8ball:</code>
</td>
<td>
<span class=""emoji emoji-rugby_football""></span> <code>:rugby_football:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bowling""></span> <code>:bowling:</code>
</td>
<td>
<span class=""emoji emoji-golf""></span> <code>:golf:</code>
</td>
<td>
<span class=""emoji emoji-mountain_bicyclist""></span> <code>:mountain_bicyclist:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bicyclist""></span> <code>:bicyclist:</code>
</td>
<td>
<span class=""emoji emoji-horse_racing""></span> <code>:horse_racing:</code>
</td>
<td>
<span class=""emoji emoji-snowboarder""></span> <code>:snowboarder:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-swimmer""></span> <code>:swimmer:</code>
</td>
<td>
<span class=""emoji emoji-surfer""></span> <code>:surfer:</code>
</td>
<td>
<span class=""emoji emoji-ski""></span> <code>:ski:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-spades""></span> <code>:spades:</code>
</td>
<td>
<span class=""emoji emoji-hearts""></span> <code>:hearts:</code>
</td>
<td>
<span class=""emoji emoji-clubs""></span> <code>:clubs:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-diamonds""></span> <code>:diamonds:</code>
</td>
<td>
<span class=""emoji emoji-gem""></span> <code>:gem:</code>
</td>
<td>
<span class=""emoji emoji-ring""></span> <code>:ring:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-trophy""></span> <code>:trophy:</code>
</td>
<td>
<span class=""emoji emoji-musical_score""></span> <code>:musical_score:</code>
</td>
<td>
<span class=""emoji emoji-musical_keyboard""></span> <code>:musical_keyboard:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-violin""></span> <code>:violin:</code>
</td>
<td>
<span class=""emoji emoji-space_invader""></span> <code>:space_invader:</code>
</td>
<td>
<span class=""emoji emoji-video_game""></span> <code>:video_game:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-black_joker""></span> <code>:black_joker:</code>
</td>
<td>
<span class=""emoji emoji-flower_playing_cards""></span> <code>:flower_playing_cards:</code>
</td>
<td>
<span class=""emoji emoji-game_die""></span> <code>:game_die:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-dart""></span> <code>:dart:</code>
</td>
<td>
<span class=""emoji emoji-mahjong""></span> <code>:mahjong:</code>
</td>
<td>
<span class=""emoji emoji-clapper""></span> <code>:clapper:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-memo""></span> <code>:memo:</code>
</td>
<td>
<span class=""emoji emoji-pencil""></span> <code>:pencil:</code>
</td>
<td>
<span class=""emoji emoji-book""></span> <code>:book:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-art""></span> <code>:art:</code>
</td>
<td>
<span class=""emoji emoji-microphone""></span> <code>:microphone:</code>
</td>
<td>
<span class=""emoji emoji-headphones""></span> <code>:headphones:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-trumpet""></span> <code>:trumpet:</code>
</td>
<td>
<span class=""emoji emoji-saxophone""></span> <code>:saxophone:</code>
</td>
<td>
<span class=""emoji emoji-guitar""></span> <code>:guitar:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-shoe""></span> <code>:shoe:</code>
</td>
<td>
<span class=""emoji emoji-sandal""></span> <code>:sandal:</code>
</td>
<td>
<span class=""emoji emoji-high_heel""></span> <code>:high_heel:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-lipstick""></span> <code>:lipstick:</code>
</td>
<td>
<span class=""emoji emoji-boot""></span> <code>:boot:</code>
</td>
<td>
<span class=""emoji emoji-shirt""></span> <code>:shirt:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tshirt""></span> <code>:tshirt:</code>
</td>
<td>
<span class=""emoji emoji-necktie""></span> <code>:necktie:</code>
</td>
<td>
<span class=""emoji emoji-womans_clothes""></span> <code>:womans_clothes:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-dress""></span> <code>:dress:</code>
</td>
<td>
<span class=""emoji emoji-running_shirt_with_sash""></span> <code>:running_shirt_with_sash:</code>
</td>
<td>
<span class=""emoji emoji-jeans""></span> <code>:jeans:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-kimono""></span> <code>:kimono:</code>
</td>
<td>
<span class=""emoji emoji-bikini""></span> <code>:bikini:</code>
</td>
<td>
<span class=""emoji emoji-ribbon""></span> <code>:ribbon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tophat""></span> <code>:tophat:</code>
</td>
<td>
<span class=""emoji emoji-crown""></span> <code>:crown:</code>
</td>
<td>
<span class=""emoji emoji-womans_hat""></span> <code>:womans_hat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-mans_shoe""></span> <code>:mans_shoe:</code>
</td>
<td>
<span class=""emoji emoji-closed_umbrella""></span> <code>:closed_umbrella:</code>
</td>
<td>
<span class=""emoji emoji-briefcase""></span> <code>:briefcase:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-handbag""></span> <code>:handbag:</code>
</td>
<td>
<span class=""emoji emoji-pouch""></span> <code>:pouch:</code>
</td>
<td>
<span class=""emoji emoji-purse""></span> <code>:purse:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-eyeglasses""></span> <code>:eyeglasses:</code>
</td>
<td>
<span class=""emoji emoji-fishing_pole_and_fish""></span> <code>:fishing_pole_and_fish:</code>
</td>
<td>
<span class=""emoji emoji-coffee""></span> <code>:coffee:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tea""></span> <code>:tea:</code>
</td>
<td>
<span class=""emoji emoji-sake""></span> <code>:sake:</code>
</td>
<td>
<span class=""emoji emoji-baby_bottle""></span> <code>:baby_bottle:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-beer""></span> <code>:beer:</code>
</td>
<td>
<span class=""emoji emoji-beers""></span> <code>:beers:</code>
</td>
<td>
<span class=""emoji emoji-cocktail""></span> <code>:cocktail:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tropical_drink""></span> <code>:tropical_drink:</code>
</td>
<td>
<span class=""emoji emoji-wine_glass""></span> <code>:wine_glass:</code>
</td>
<td>
<span class=""emoji emoji-fork_and_knife""></span> <code>:fork_and_knife:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-pizza""></span> <code>:pizza:</code>
</td>
<td>
<span class=""emoji emoji-hamburger""></span> <code>:hamburger:</code>
</td>
<td>
<span class=""emoji emoji-fries""></span> <code>:fries:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-poultry_leg""></span> <code>:poultry_leg:</code>
</td>
<td>
<span class=""emoji emoji-meat_on_bone""></span> <code>:meat_on_bone:</code>
</td>
<td>
<span class=""emoji emoji-spaghetti""></span> <code>:spaghetti:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-curry""></span> <code>:curry:</code>
</td>
<td>
<span class=""emoji emoji-fried_shrimp""></span> <code>:fried_shrimp:</code>
</td>
<td>
<span class=""emoji emoji-bento""></span> <code>:bento:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sushi""></span> <code>:sushi:</code>
</td>
<td>
<span class=""emoji emoji-fish_cake""></span> <code>:fish_cake:</code>
</td>
<td>
<span class=""emoji emoji-rice_ball""></span> <code>:rice_ball:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rice_cracker""></span> <code>:rice_cracker:</code>
</td>
<td>
<span class=""emoji emoji-rice""></span> <code>:rice:</code>
</td>
<td>
<span class=""emoji emoji-ramen""></span> <code>:ramen:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-stew""></span> <code>:stew:</code>
</td>
<td>
<span class=""emoji emoji-oden""></span> <code>:oden:</code>
</td>
<td>
<span class=""emoji emoji-dango""></span> <code>:dango:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-egg""></span> <code>:egg:</code>
</td>
<td>
<span class=""emoji emoji-bread""></span> <code>:bread:</code>
</td>
<td>
<span class=""emoji emoji-doughnut""></span> <code>:doughnut:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-custard""></span> <code>:custard:</code>
</td>
<td>
<span class=""emoji emoji-icecream""></span> <code>:icecream:</code>
</td>
<td>
<span class=""emoji emoji-ice_cream""></span> <code>:ice_cream:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-shaved_ice""></span> <code>:shaved_ice:</code>
</td>
<td>
<span class=""emoji emoji-birthday""></span> <code>:birthday:</code>
</td>
<td>
<span class=""emoji emoji-cake""></span> <code>:cake:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cookie""></span> <code>:cookie:</code>
</td>
<td>
<span class=""emoji emoji-chocolate_bar""></span> <code>:chocolate_bar:</code>
</td>
<td>
<span class=""emoji emoji-candy""></span> <code>:candy:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-lollipop""></span> <code>:lollipop:</code>
</td>
<td>
<span class=""emoji emoji-honey_pot""></span> <code>:honey_pot:</code>
</td>
<td>
<span class=""emoji emoji-apple""></span> <code>:apple:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-green_apple""></span> <code>:green_apple:</code>
</td>
<td>
<span class=""emoji emoji-tangerine""></span> <code>:tangerine:</code>
</td>
<td>
<span class=""emoji emoji-lemon""></span> <code>:lemon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cherries""></span> <code>:cherries:</code>
</td>
<td>
<span class=""emoji emoji-grapes""></span> <code>:grapes:</code>
</td>
<td>
<span class=""emoji emoji-watermelon""></span> <code>:watermelon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-strawberry""></span> <code>:strawberry:</code>
</td>
<td>
<span class=""emoji emoji-peach""></span> <code>:peach:</code>
</td>
<td>
<span class=""emoji emoji-melon""></span> <code>:melon:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-banana""></span> <code>:banana:</code>
</td>
<td>
<span class=""emoji emoji-pear""></span> <code>:pear:</code>
</td>
<td>
<span class=""emoji emoji-pineapple""></span> <code>:pineapple:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sweet_potato""></span> <code>:sweet_potato:</code>
</td>
<td>
<span class=""emoji emoji-eggplant""></span> <code>:eggplant:</code>
</td>
<td>
<span class=""emoji emoji-tomato""></span> <code>:tomato:</code>
</td>
</tr>
<tr><td>
<span class=""emoji emoji-corn""></span> <code>:corn:</code>
</td></tr>
</tbody>
</table>
<h2>地点</h2>
<table>
<thead><tr>
<th>
<span class=""emoji emoji-house""></span> <code>:house:</code>
</th>
<th>
<span class=""emoji emoji-house_with_garden""></span> <code>:house_with_garden:</code>
</th>
<th>
<span class=""emoji emoji-school""></span> <code>:school:</code>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class=""emoji emoji-office""></span> <code>:office:</code>
</td>
<td>
<span class=""emoji emoji-post_office""></span> <code>:post_office:</code>
</td>
<td>
<span class=""emoji emoji-hospital""></span> <code>:hospital:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bank""></span> <code>:bank:</code>
</td>
<td>
<span class=""emoji emoji-convenience_store""></span> <code>:convenience_store:</code>
</td>
<td>
<span class=""emoji emoji-love_hotel""></span> <code>:love_hotel:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-hotel""></span> <code>:hotel:</code>
</td>
<td>
<span class=""emoji emoji-wedding""></span> <code>:wedding:</code>
</td>
<td>
<span class=""emoji emoji-church""></span> <code>:church:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-department_store""></span> <code>:department_store:</code>
</td>
<td>
<span class=""emoji emoji-european_post_office""></span> <code>:european_post_office:</code>
</td>
<td>
<span class=""emoji emoji-city_sunrise""></span> <code>:city_sunrise:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-city_sunset""></span> <code>:city_sunset:</code>
</td>
<td>
<span class=""emoji emoji-japanese_castle""></span> <code>:japanese_castle:</code>
</td>
<td>
<span class=""emoji emoji-european_castle""></span> <code>:european_castle:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-tent""></span> <code>:tent:</code>
</td>
<td>
<span class=""emoji emoji-factory""></span> <code>:factory:</code>
</td>
<td>
<span class=""emoji emoji-tokyo_tower""></span> <code>:tokyo_tower:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-japan""></span> <code>:japan:</code>
</td>
<td>
<span class=""emoji emoji-mount_fuji""></span> <code>:mount_fuji:</code>
</td>
<td>
<span class=""emoji emoji-sunrise_over_mountains""></span> <code>:sunrise_over_mountains:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sunrise""></span> <code>:sunrise:</code>
</td>
<td>
<span class=""emoji emoji-stars""></span> <code>:stars:</code>
</td>
<td>
<span class=""emoji emoji-statue_of_liberty""></span> <code>:statue_of_liberty:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bridge_at_night""></span> <code>:bridge_at_night:</code>
</td>
<td>
<span class=""emoji emoji-carousel_horse""></span> <code>:carousel_horse:</code>
</td>
<td>
<span class=""emoji emoji-rainbow""></span> <code>:rainbow:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ferris_wheel""></span> <code>:ferris_wheel:</code>
</td>
<td>
<span class=""emoji emoji-fountain""></span> <code>:fountain:</code>
</td>
<td>
<span class=""emoji emoji-roller_coaster""></span> <code>:roller_coaster:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ship""></span> <code>:ship:</code>
</td>
<td>
<span class=""emoji emoji-speedboat""></span> <code>:speedboat:</code>
</td>
<td>
<span class=""emoji emoji-boat""></span> <code>:boat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sailboat""></span> <code>:sailboat:</code>
</td>
<td>
<span class=""emoji emoji-rowboat""></span> <code>:rowboat:</code>
</td>
<td>
<span class=""emoji emoji-anchor""></span> <code>:anchor:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rocket""></span> <code>:rocket:</code>
</td>
<td>
<span class=""emoji emoji-airplane""></span> <code>:airplane:</code>
</td>
<td>
<span class=""emoji emoji-helicopter""></span> <code>:helicopter:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-steam_locomotive""></span> <code>:steam_locomotive:</code>
</td>
<td>
<span class=""emoji emoji-tram""></span> <code>:tram:</code>
</td>
<td>
<span class=""emoji emoji-mountain_railway""></span> <code>:mountain_railway:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bike""></span> <code>:bike:</code>
</td>
<td>
<span class=""emoji emoji-aerial_tramway""></span> <code>:aerial_tramway:</code>
</td>
<td>
<span class=""emoji emoji-suspension_railway""></span> <code>:suspension_railway:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-mountain_cableway""></span> <code>:mountain_cableway:</code>
</td>
<td>
<span class=""emoji emoji-tractor""></span> <code>:tractor:</code>
</td>
<td>
<span class=""emoji emoji-blue_car""></span> <code>:blue_car:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-oncoming_automobile""></span> <code>:oncoming_automobile:</code>
</td>
<td>
<span class=""emoji emoji-car""></span> <code>:car:</code>
</td>
<td>
<span class=""emoji emoji-red_car""></span> <code>:red_car:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-taxi""></span> <code>:taxi:</code>
</td>
<td>
<span class=""emoji emoji-oncoming_taxi""></span> <code>:oncoming_taxi:</code>
</td>
<td>
<span class=""emoji emoji-articulated_lorry""></span> <code>:articulated_lorry:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bus""></span> <code>:bus:</code>
</td>
<td>
<span class=""emoji emoji-oncoming_bus""></span> <code>:oncoming_bus:</code>
</td>
<td>
<span class=""emoji emoji-rotating_light""></span> <code>:rotating_light:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-police_car""></span> <code>:police_car:</code>
</td>
<td>
<span class=""emoji emoji-oncoming_police_car""></span> <code>:oncoming_police_car:</code>
</td>
<td>
<span class=""emoji emoji-fire_engine""></span> <code>:fire_engine:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ambulance""></span> <code>:ambulance:</code>
</td>
<td>
<span class=""emoji emoji-minibus""></span> <code>:minibus:</code>
</td>
<td>
<span class=""emoji emoji-truck""></span> <code>:truck:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-train""></span> <code>:train:</code>
</td>
<td>
<span class=""emoji emoji-station""></span> <code>:station:</code>
</td>
<td>
<span class=""emoji emoji-train2""></span> <code>:train2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-bullettrain_front""></span> <code>:bullettrain_front:</code>
</td>
<td>
<span class=""emoji emoji-bullettrain_side""></span> <code>:bullettrain_side:</code>
</td>
<td>
<span class=""emoji emoji-light_rail""></span> <code>:light_rail:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-monorail""></span> <code>:monorail:</code>
</td>
<td>
<span class=""emoji emoji-railway_car""></span> <code>:railway_car:</code>
</td>
<td>
<span class=""emoji emoji-trolleybus""></span> <code>:trolleybus:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ticket""></span> <code>:ticket:</code>
</td>
<td>
<span class=""emoji emoji-fuelpump""></span> <code>:fuelpump:</code>
</td>
<td>
<span class=""emoji emoji-vertical_traffic_light""></span> <code>:vertical_traffic_light:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-traffic_light""></span> <code>:traffic_light:</code>
</td>
<td>
<span class=""emoji emoji-warning""></span> <code>:warning:</code>
</td>
<td>
<span class=""emoji emoji-construction""></span> <code>:construction:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-beginner""></span> <code>:beginner:</code>
</td>
<td>
<span class=""emoji emoji-atm""></span> <code>:atm:</code>
</td>
<td>
<span class=""emoji emoji-slot_machine""></span> <code>:slot_machine:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-busstop""></span> <code>:busstop:</code>
</td>
<td>
<span class=""emoji emoji-barber""></span> <code>:barber:</code>
</td>
<td>
<span class=""emoji emoji-hotsprings""></span> <code>:hotsprings:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-checkered_flag""></span> <code>:checkered_flag:</code>
</td>
<td>
<span class=""emoji emoji-crossed_flags""></span> <code>:crossed_flags:</code>
</td>
<td>
<span class=""emoji emoji-izakaya_lantern""></span> <code>:izakaya_lantern:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-moyai""></span> <code>:moyai:</code>
</td>
<td>
<span class=""emoji emoji-circus_tent""></span> <code>:circus_tent:</code>
</td>
<td>
<span class=""emoji emoji-performing_arts""></span> <code>:performing_arts:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-round_pushpin""></span> <code>:round_pushpin:</code>
</td>
<td>
<span class=""emoji emoji-triangular_flag_on_post""></span> <code>:triangular_flag_on_post:</code>
</td>
<td>
<span class=""emoji emoji-jp""></span> <code>:jp:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-kr""></span> <code>:kr:</code>
</td>
<td>
<span class=""emoji emoji-cn""></span> <code>:cn:</code>
</td>
<td>
<span class=""emoji emoji-us""></span> <code>:us:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-fr""></span> <code>:fr:</code>
</td>
<td>
<span class=""emoji emoji-es""></span> <code>:es:</code>
</td>
<td>
<span class=""emoji emoji-it""></span> <code>:it:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ru""></span> <code>:ru:</code>
</td>
<td>
<span class=""emoji emoji-gb""></span> <code>:gb:</code>
</td>
<td>
<span class=""emoji emoji-uk""></span> <code>:uk:</code>
</td>
</tr>
<tr><td>
<span class=""emoji emoji-de""></span> <code>:de:</code>
</td></tr>
</tbody>
</table>
<h2>符号</h2>
<table>
<thead><tr>
<th>
<span class=""emoji emoji-one""></span> <code>:one:</code>
</th>
<th>
<span class=""emoji emoji-two""></span> <code>:two:</code>
</th>
<th>
<span class=""emoji emoji-three""></span> <code>:three:</code>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class=""emoji emoji-four""></span> <code>:four:</code>
</td>
<td>
<span class=""emoji emoji-five""></span> <code>:five:</code>
</td>
<td>
<span class=""emoji emoji-six""></span> <code>:six:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-seven""></span> <code>:seven:</code>
</td>
<td>
<span class=""emoji emoji-eight""></span> <code>:eight:</code>
</td>
<td>
<span class=""emoji emoji-nine""></span> <code>:nine:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-keycap_ten""></span> <code>:keycap_ten:</code>
</td>
<td>
<span class=""emoji emoji-1234""></span> <code>:1234:</code>
</td>
<td>
<span class=""emoji emoji-zero""></span> <code>:zero:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-hash""></span> <code>:hash:</code>
</td>
<td>
<span class=""emoji emoji-symbols""></span> <code>:symbols:</code>
</td>
<td>
<span class=""emoji emoji-arrow_backward""></span> <code>:arrow_backward:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_down""></span> <code>:arrow_down:</code>
</td>
<td>
<span class=""emoji emoji-arrow_forward""></span> <code>:arrow_forward:</code>
</td>
<td>
<span class=""emoji emoji-arrow_left""></span> <code>:arrow_left:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-capital_abcd""></span> <code>:capital_abcd:</code>
</td>
<td>
<span class=""emoji emoji-abcd""></span> <code>:abcd:</code>
</td>
<td>
<span class=""emoji emoji-abc""></span> <code>:abc:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_lower_left""></span> <code>:arrow_lower_left:</code>
</td>
<td>
<span class=""emoji emoji-arrow_lower_right""></span> <code>:arrow_lower_right:</code>
</td>
<td>
<span class=""emoji emoji-arrow_right""></span> <code>:arrow_right:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_up""></span> <code>:arrow_up:</code>
</td>
<td>
<span class=""emoji emoji-arrow_upper_left""></span> <code>:arrow_upper_left:</code>
</td>
<td>
<span class=""emoji emoji-arrow_upper_right""></span> <code>:arrow_upper_right:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_double_down""></span> <code>:arrow_double_down:</code>
</td>
<td>
<span class=""emoji emoji-arrow_double_up""></span> <code>:arrow_double_up:</code>
</td>
<td>
<span class=""emoji emoji-arrow_down_small""></span> <code>:arrow_down_small:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_heading_down""></span> <code>:arrow_heading_down:</code>
</td>
<td>
<span class=""emoji emoji-arrow_heading_up""></span> <code>:arrow_heading_up:</code>
</td>
<td>
<span class=""emoji emoji-leftwards_arrow_with_hook""></span> <code>:leftwards_arrow_with_hook:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_right_hook""></span> <code>:arrow_right_hook:</code>
</td>
<td>
<span class=""emoji emoji-left_right_arrow""></span> <code>:left_right_arrow:</code>
</td>
<td>
<span class=""emoji emoji-arrow_up_down""></span> <code>:arrow_up_down:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-arrow_up_small""></span> <code>:arrow_up_small:</code>
</td>
<td>
<span class=""emoji emoji-arrows_clockwise""></span> <code>:arrows_clockwise:</code>
</td>
<td>
<span class=""emoji emoji-arrows_counterclockwise""></span> <code>:arrows_counterclockwise:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-rewind""></span> <code>:rewind:</code>
</td>
<td>
<span class=""emoji emoji-fast_forward""></span> <code>:fast_forward:</code>
</td>
<td>
<span class=""emoji emoji-information_source""></span> <code>:information_source:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ok""></span> <code>:ok:</code>
</td>
<td>
<span class=""emoji emoji-twisted_rightwards_arrows""></span> <code>:twisted_rightwards_arrows:</code>
</td>
<td>
<span class=""emoji emoji-repeat""></span> <code>:repeat:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-repeat_one""></span> <code>:repeat_one:</code>
</td>
<td>
<span class=""emoji emoji-new""></span> <code>:new:</code>
</td>
<td>
<span class=""emoji emoji-top""></span> <code>:top:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-up""></span> <code>:up:</code>
</td>
<td>
<span class=""emoji emoji-cool""></span> <code>:cool:</code>
</td>
<td>
<span class=""emoji emoji-free""></span> <code>:free:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ng""></span> <code>:ng:</code>
</td>
<td>
<span class=""emoji emoji-cinema""></span> <code>:cinema:</code>
</td>
<td>
<span class=""emoji emoji-koko""></span> <code>:koko:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-signal_strength""></span> <code>:signal_strength:</code>
</td>
<td>
<span class=""emoji emoji-u5272""></span> <code>:u5272:</code>
</td>
<td>
<span class=""emoji emoji-u5408""></span> <code>:u5408:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-u55b6""></span> <code>:u55b6:</code>
</td>
<td>
<span class=""emoji emoji-u6307""></span> <code>:u6307:</code>
</td>
<td>
<span class=""emoji emoji-u6708""></span> <code>:u6708:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-u6709""></span> <code>:u6709:</code>
</td>
<td>
<span class=""emoji emoji-u6e80""></span> <code>:u6e80:</code>
</td>
<td>
<span class=""emoji emoji-u7121""></span> <code>:u7121:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-u7533""></span> <code>:u7533:</code>
</td>
<td>
<span class=""emoji emoji-u7a7a""></span> <code>:u7a7a:</code>
</td>
<td>
<span class=""emoji emoji-u7981""></span> <code>:u7981:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-sa""></span> <code>:sa:</code>
</td>
<td>
<span class=""emoji emoji-restroom""></span> <code>:restroom:</code>
</td>
<td>
<span class=""emoji emoji-mens""></span> <code>:mens:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-womens""></span> <code>:womens:</code>
</td>
<td>
<span class=""emoji emoji-baby_symbol""></span> <code>:baby_symbol:</code>
</td>
<td>
<span class=""emoji emoji-no_smoking""></span> <code>:no_smoking:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-parking""></span> <code>:parking:</code>
</td>
<td>
<span class=""emoji emoji-wheelchair""></span> <code>:wheelchair:</code>
</td>
<td>
<span class=""emoji emoji-metro""></span> <code>:metro:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-baggage_claim""></span> <code>:baggage_claim:</code>
</td>
<td>
<span class=""emoji emoji-accept""></span> <code>:accept:</code>
</td>
<td>
<span class=""emoji emoji-wc""></span> <code>:wc:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-potable_water""></span> <code>:potable_water:</code>
</td>
<td>
<span class=""emoji emoji-put_litter_in_its_place""></span> <code>:put_litter_in_its_place:</code>
</td>
<td>
<span class=""emoji emoji-secret""></span> <code>:secret:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-congratulations""></span> <code>:congratulations:</code>
</td>
<td>
<span class=""emoji emoji-m""></span> <code>:m:</code>
</td>
<td>
<span class=""emoji emoji-passport_control""></span> <code>:passport_control:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-left_luggage""></span> <code>:left_luggage:</code>
</td>
<td>
<span class=""emoji emoji-customs""></span> <code>:customs:</code>
</td>
<td>
<span class=""emoji emoji-ideograph_advantage""></span> <code>:ideograph_advantage:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-cl""></span> <code>:cl:</code>
</td>
<td>
<span class=""emoji emoji-sos""></span> <code>:sos:</code>
</td>
<td>
<span class=""emoji emoji-id""></span> <code>:id:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-no_entry_sign""></span> <code>:no_entry_sign:</code>
</td>
<td>
<span class=""emoji emoji-underage""></span> <code>:underage:</code>
</td>
<td>
<span class=""emoji emoji-no_mobile_phones""></span> <code>:no_mobile_phones:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-do_not_litter""></span> <code>:do_not_litter:</code>
</td>
<td>:non-potable_water: <code>:non-potable_water:</code>
</td>
<td>
<span class=""emoji emoji-no_bicycles""></span> <code>:no_bicycles:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-no_pedestrians""></span> <code>:no_pedestrians:</code>
</td>
<td>
<span class=""emoji emoji-children_crossing""></span> <code>:children_crossing:</code>
</td>
<td>
<span class=""emoji emoji-no_entry""></span> <code>:no_entry:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-eight_spoked_asterisk""></span> <code>:eight_spoked_asterisk:</code>
</td>
<td>
<span class=""emoji emoji-eight_pointed_black_star""></span> <code>:eight_pointed_black_star:</code>
</td>
<td>
<span class=""emoji emoji-heart_decoration""></span> <code>:heart_decoration:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-vs""></span> <code>:vs:</code>
</td>
<td>
<span class=""emoji emoji-vibration_mode""></span> <code>:vibration_mode:</code>
</td>
<td>
<span class=""emoji emoji-mobile_phone_off""></span> <code>:mobile_phone_off:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-chart""></span> <code>:chart:</code>
</td>
<td>
<span class=""emoji emoji-currency_exchange""></span> <code>:currency_exchange:</code>
</td>
<td>
<span class=""emoji emoji-aries""></span> <code>:aries:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-taurus""></span> <code>:taurus:</code>
</td>
<td>
<span class=""emoji emoji-gemini""></span> <code>:gemini:</code>
</td>
<td>
<span class=""emoji emoji-cancer""></span> <code>:cancer:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-leo""></span> <code>:leo:</code>
</td>
<td>
<span class=""emoji emoji-virgo""></span> <code>:virgo:</code>
</td>
<td>
<span class=""emoji emoji-libra""></span> <code>:libra:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-scorpius""></span> <code>:scorpius:</code>
</td>
<td>
<span class=""emoji emoji-sagittarius""></span> <code>:sagittarius:</code>
</td>
<td>
<span class=""emoji emoji-capricorn""></span> <code>:capricorn:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-aquarius""></span> <code>:aquarius:</code>
</td>
<td>
<span class=""emoji emoji-pisces""></span> <code>:pisces:</code>
</td>
<td>
<span class=""emoji emoji-ophiuchus""></span> <code>:ophiuchus:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-six_pointed_star""></span> <code>:six_pointed_star:</code>
</td>
<td>
<span class=""emoji emoji-negative_squared_cross_mark""></span> <code>:negative_squared_cross_mark:</code>
</td>
<td>
<span class=""emoji emoji-a""></span> <code>:a:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-b""></span> <code>:b:</code>
</td>
<td>
<span class=""emoji emoji-ab""></span> <code>:ab:</code>
</td>
<td>
<span class=""emoji emoji-o2""></span> <code>:o2:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-diamond_shape_with_a_dot_inside""></span> <code>:diamond_shape_with_a_dot_inside:</code>
</td>
<td>
<span class=""emoji emoji-recycle""></span> <code>:recycle:</code>
</td>
<td>
<span class=""emoji emoji-end""></span> <code>:end:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-on""></span> <code>:on:</code>
</td>
<td>
<span class=""emoji emoji-soon""></span> <code>:soon:</code>
</td>
<td>
<span class=""emoji emoji-clock1""></span> <code>:clock1:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock130""></span> <code>:clock130:</code>
</td>
<td>
<span class=""emoji emoji-clock10""></span> <code>:clock10:</code>
</td>
<td>
<span class=""emoji emoji-clock1030""></span> <code>:clock1030:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock11""></span> <code>:clock11:</code>
</td>
<td>
<span class=""emoji emoji-clock1130""></span> <code>:clock1130:</code>
</td>
<td>
<span class=""emoji emoji-clock12""></span> <code>:clock12:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock1230""></span> <code>:clock1230:</code>
</td>
<td>
<span class=""emoji emoji-clock2""></span> <code>:clock2:</code>
</td>
<td>
<span class=""emoji emoji-clock230""></span> <code>:clock230:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock3""></span> <code>:clock3:</code>
</td>
<td>
<span class=""emoji emoji-clock330""></span> <code>:clock330:</code>
</td>
<td>
<span class=""emoji emoji-clock4""></span> <code>:clock4:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock430""></span> <code>:clock430:</code>
</td>
<td>
<span class=""emoji emoji-clock5""></span> <code>:clock5:</code>
</td>
<td>
<span class=""emoji emoji-clock530""></span> <code>:clock530:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock6""></span> <code>:clock6:</code>
</td>
<td>
<span class=""emoji emoji-clock630""></span> <code>:clock630:</code>
</td>
<td>
<span class=""emoji emoji-clock7""></span> <code>:clock7:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock730""></span> <code>:clock730:</code>
</td>
<td>
<span class=""emoji emoji-clock8""></span> <code>:clock8:</code>
</td>
<td>
<span class=""emoji emoji-clock830""></span> <code>:clock830:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-clock9""></span> <code>:clock9:</code>
</td>
<td>
<span class=""emoji emoji-clock930""></span> <code>:clock930:</code>
</td>
<td>
<span class=""emoji emoji-heavy_dollar_sign""></span> <code>:heavy_dollar_sign:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-copyright""></span> <code>:copyright:</code>
</td>
<td>
<span class=""emoji emoji-registered""></span> <code>:registered:</code>
</td>
<td>
<span class=""emoji emoji-tm""></span> <code>:tm:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-x""></span> <code>:x:</code>
</td>
<td>
<span class=""emoji emoji-heavy_exclamation_mark""></span> <code>:heavy_exclamation_mark:</code>
</td>
<td>
<span class=""emoji emoji-bangbang""></span> <code>:bangbang:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-interrobang""></span> <code>:interrobang:</code>
</td>
<td>
<span class=""emoji emoji-o""></span> <code>:o:</code>
</td>
<td>
<span class=""emoji emoji-heavy_multiplication_x""></span> <code>:heavy_multiplication_x:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-heavy_plus_sign""></span> <code>:heavy_plus_sign:</code>
</td>
<td>
<span class=""emoji emoji-heavy_minus_sign""></span> <code>:heavy_minus_sign:</code>
</td>
<td>
<span class=""emoji emoji-heavy_division_sign""></span> <code>:heavy_division_sign:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-white_flower""></span> <code>:white_flower:</code>
</td>
<td>
<span class=""emoji emoji-100""></span> <code>:100:</code>
</td>
<td>
<span class=""emoji emoji-heavy_check_mark""></span> <code>:heavy_check_mark:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-ballot_box_with_check""></span> <code>:ballot_box_with_check:</code>
</td>
<td>
<span class=""emoji emoji-radio_button""></span> <code>:radio_button:</code>
</td>
<td>
<span class=""emoji emoji-link""></span> <code>:link:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-curly_loop""></span> <code>:curly_loop:</code>
</td>
<td>
<span class=""emoji emoji-wavy_dash""></span> <code>:wavy_dash:</code>
</td>
<td>
<span class=""emoji emoji-part_alternation_mark""></span> <code>:part_alternation_mark:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-trident""></span> <code>:trident:</code>
</td>
<td>
<span class=""emoji emoji-black_square""></span> <code>:black_square:</code>
</td>
<td>:white_square: <code>:white_square:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-white_check_mark""></span> <code>:white_check_mark:</code>
</td>
<td>
<span class=""emoji emoji-black_square_button""></span> <code>:black_square_button:</code>
</td>
<td>
<span class=""emoji emoji-white_square_button""></span> <code>:white_square_button:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-black_circle""></span> <code>:black_circle:</code>
</td>
<td>
<span class=""emoji emoji-white_circle""></span> <code>:white_circle:</code>
</td>
<td>
<span class=""emoji emoji-red_circle""></span> <code>:red_circle:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-large_blue_circle""></span> <code>:large_blue_circle:</code>
</td>
<td>
<span class=""emoji emoji-large_blue_diamond""></span> <code>:large_blue_diamond:</code>
</td>
<td>
<span class=""emoji emoji-large_orange_diamond""></span> <code>:large_orange_diamond:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-small_blue_diamond""></span> <code>:small_blue_diamond:</code>
</td>
<td>
<span class=""emoji emoji-small_orange_diamond""></span> <code>:small_orange_diamond:</code>
</td>
<td>
<span class=""emoji emoji-small_red_triangle""></span> <code>:small_red_triangle:</code>
</td>
</tr>
<tr>
<td>
<span class=""emoji emoji-small_red_triangle_down""></span> <code>:small_red_triangle_down:</code>
</td>
<td>
<span class=""emoji emoji-shipit""></span> <code>:shipit:</code>
</td>
</tr>
</tbody>
</table>

                ", github emoji 表情列表,1531977836,358,1,794,1,1,https://segmentfault.com/a/1190000009649780
127,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546916?w=1195&amp;h=705"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>具备基本工程素养的同学都会注重编码规范，而代码风格检查（Code Linting，简称 Lint）是保障代码规范一致性的重要手段，你的工作流中有 Lint 环节么？有的话你用的爽么？你在团队中推广过 Lint，但是大家都不买账？究竟是为啥？</p></blockquote>
<h2>Lint 是什么？</h2>
<p>探讨怎么做之前，我们很有必要给 Lint 来个清晰、准确的定义，<a href=""https://en.wikipedia.org/wiki/Lint_%28software%29"" rel=""nofollow noreferrer"">wikipedia 的定义</a>如下：</p>
<blockquote><p>In computer programming, lint is a Unix utility that flags some suspicious and non-portable constructs (likely to be bugs) in C language source code; generically, lint or a linter is any tool that flags suspicious usage in software written in any computer language. The term lint-like behavior is sometimes applied to the process of flagging suspicious language usage. Lint-like tools generally perform static analysis of source code.</p></blockquote>
<p>简单来说，Lint 就是对代码做静态分析，并试图找出潜在问题的工具，实战中我们也用 Lint 来指使用工具的过程。</p>
<h2>为什么要 Lint？</h2>
<p>使用 Lint 会有什么好处呢？在我看来至少具有如下 3 点：</p>
<ul>
<li><p>更少的 Bug，剑桥大学的<a href=""http://www.prweb.com/releases/2013/1/prweb10298185.htm"" rel=""nofollow noreferrer"">研究</a>发现，全世界每年因为软 Bug 造成的经济损失约 3120 亿美金；</p></li>
<li><p>更高的开发效率，工程师平均会花掉 50% 的工作时间定位和解决各种 Bug，其中不乏那些显而易见的低级错误，而 Lint 很容易发现低级的、显而易见的错误；</p></li>
<li><p>更高的可读性，代码可读性的首要因子是“表面文章”，表面上看起来乱糟糟的代码通常更难读懂；</p></li>
</ul>
<p>可以毫不客气的说，如果你不做 Lint，就是在浪费自己的时间，浪费公司的资源。既然做 Lint 的预期效果很好？该怎么做呢？</p>
<h2>提交后 Lint：反馈链条太长？</h2>
<p>说到怎么做，多数人会自然而然的想到各种 Lint 工具，目前社区中针对各种语言都开发了 Lint 工具，前端能用到的就有大把：<a href=""http://eslint.org/"" rel=""nofollow noreferrer"">ESLint</a>、<a href=""https://standardjs.com/index.html"" rel=""nofollow noreferrer"">Standard</a>、<a href=""https://github.com/brigade/scss-lint"" rel=""nofollow noreferrer"">SCSSLint</a>、<a href=""https://github.com/zaach/jsonlint"" rel=""nofollow noreferrer"">JSONLint</a>、<a href=""https://github.com/yaniswang/HTMLHint"" rel=""nofollow noreferrer"">HTMLHint</a> 等。GitHub 官方出品的 <a href=""https://github.com/showcases/clean-code-linters"" rel=""nofollow noreferrer"">Lint 工具列表</a> 也是个非常不错的参考。</p>
<p>很多同学选择在持续集成阶段（后文用 CI 代称）做 Lint，比如使用远程的 Git Hooks 来触发。但是从实际的经历来看，这种做法的反馈链条通常如下：</p>
<pre><code>代码提交 --&gt; 发现问题(远程) --&gt; 修复问题 --&gt; 重新提交 --&gt; 通过检查(远程)</code></pre>
<p>整个过程可能会浪费掉你不少时间，毕竟 CI 过程通常不仅是在做 Lint，如果你是那种不知道自己时间每天都去哪儿了的工程师，可以反思下自己或者团队的工作流是否是这样。并且，请相信我，你不是少数人。</p>
<p>你有没有这样的经历：吭哧吭哧写了几天代码，各种验收都通过了，最后被 CI 拒绝，竟是因为你的代码中少加了一个逗号，这时候心情简直崩溃到无法形容：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546917?w=500&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从 GitHub 上各种修复 Lint 的提交数量不难发现工程师在修复 Lint 问题上浪费的时间，比如搜索 ""fix lint""，多达 45W 次提交：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546918?w=934&amp;h=424"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再比如搜索 “fix indent”，多达 226W 次提交，是不是很触目惊心？</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546919?w=942&amp;h=428"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>只在 CI 流程做 Lint 的缺点也是显而易见的：</p>
<ul>
<li><p>Lint 在整个开发工作流中的反馈链条太长，浪费时间、注意力和资源，最致命的；</p></li>
<li><p>CI 流程搭建成本比较高，即使有各种 CI 服务，步骤也还是比较繁琐；</p></li>
</ul>
<p>我们该怎么改进？</p>
<h2>提交前 Lint：错误信息不相关？</h2>
<p>为了缩短 Lint 的反馈链条，把 Lint 挪到本地是最有效的办法。常见做法是使用 <a href=""https://github.com/typicode/husky"" rel=""nofollow noreferrer"">husky</a> 或者 <a href=""https://github.com/observing/pre-commit"" rel=""nofollow noreferrer"">pre-commit</a> 在本地提交之前做 Lint。</p>
<p>使用 husky 的具体做法如下：</p>
<p>首先，安装依赖：</p>
<pre><code class=""bash"">npm install -D husky
yarn add --dev husky</code></pre>
<p>然后修改 package.json，增加配置：</p>
<pre><code class=""javascript"">{
  ""scripts"": {
    ""precommit"": ""eslint src/**/*.js""
  }
}</code></pre>
<p>最后尝试 Git 提交，你就会很快收到反馈：</p>
<pre><code>git commit -m ""Keep calm and commit""</code></pre>
<p>但是在遗留代码仓库上工作的同学很快会遇到新的问题，开启 Lint 初期，你可能会面临成千上万的 Lint Error 需要修复。部分同学对下面这个图可能并不陌生：只改了文件 A，但是文件 B、C、D 中也有大量错误。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546920?w=1240&amp;h=447"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>把整个仓库都格式化不失为一种选择，但是实际上需要很大的勇气。多数人在项目中运用新工具都希望是渐进式的，而不是推到重来式的，因为相比而言，业务系统稳定是更重要的事情。简单的把 Lint 挪到本地，反馈链条是缩短了，但是面对每次改动，<strong>工具还是给出了太多不相关的信息</strong>，这无疑与小步快跑的互联网节奏是相违背的。</p>
<p>该怎么破？</p>
<h2>只  Lint 改动的：66666</h2>
<p>如果把 Lint 挪到本地，并且每次提交只检查本次提交所修改的文件，上面的痛点就都解决了。Feedly 的工程师 <a href=""https://www.npmjs.com/~okonet"" rel=""nofollow noreferrer"">Andrey Okonetchnikov</a> 开发的 <a href=""https://github.com/okonet/lint-staged"" rel=""nofollow noreferrer"">lint-staged</a> 就是基于这个想法，其中 staged 是 Git 里面的概念，指待提交区，使用 <code>git commit -a</code>，或者先 <code>git add</code> 然后 <code>git commit</code> 的时候，你的修改代码都会经过待提交区。</p>
<p>lint-staged 用法如下：</p>
<p>首先，安装依赖：</p>
<pre><code class=""bash"">npm install -D lint-staged
yarn add --dev lint-staged</code></pre>
<p>然后，修改 package.json 配置：</p>
<pre><code class=""javascript"">{
  ""scripts"": {
    ""precommit"": ""lint-staged""
  },
  ""lint-staged"": {
    ""src/**/*.js"": ""eslint""
  }
}</code></pre>
<p>最后，尝试提交的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009546921?w=828&amp;h=568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>实际上，lint-staged 给了你提交前代码操作的更大自由度，比如使用下面的配置，自动修复错误：</p>
<pre><code class=""javascript"">{
  ""scripts"": {
    ""precommit"": ""lint-staged""
  },
  ""lint-staged"": {
    ""src/**/*.js"": [""eslint --fix"", ""git add""]
  }
}</code></pre>
<p>或者使用下面的配置，自动格式化代码（谨慎使用）：</p>
<pre><code class=""javascript"">{
  ""scripts"": {
    ""precommit"": ""lint-staged""
  },
  ""lint-staged"": {
    ""src/**/*.js"": [""prettier --write"", ""git add""]
  }
}</code></pre>
<p>此外，lint-staged 和 prettier <a href=""https://github.com/facebookincubator/create-react-app/pull/1759"" rel=""nofollow noreferrer"">已经集成到 create-react-app 中了</a>。你是不是也应该好好打磨下自己的 Lint 工作流了？</p>
<h2>总结</h2>
<p>有人说前端攻城狮是世界上最奇怪的动物，提交代码时用 prettier 把代码排版的很美观，但部署上线时又使用 uglify 把代码压缩的连亲妈都不认了，事实是，如果我们写出来的代码本来就很丑陋，就根本不需要用 uglify。希望读到这里的你能把 Lint 工作流打磨到极致，把更多时间专注在解决真正的问题上，成为真正高效的工程师。</p>
<h2>One More Thing</h2>
<p>本文作者王仕军，商业转载请联系作者获得授权，非商业转载请注明出处。如果你觉得本文对你有帮助，请点赞！如果对文中的内容有任何疑问，欢迎留言讨论。想知道我接下来会写些什么？欢迎订阅我的<a href=""https://juejin.im/user/57a7f634d342d300576b738d"" rel=""nofollow noreferrer"">掘金专栏</a>或<a href=""https://zhuanlan.zhihu.com/feweekly"" rel=""nofollow noreferrer"">知乎专栏</a>：《前端周刊：让你在前端领域跟上时代的脚步》。</p>

                ", 用 husky 和 lint-staged 构建超溜的代码检查工作流,1531977838,195,1,873,1,1,https://segmentfault.com/a/1190000009546913
128,1,0,7,"
                    
<p>1.Google</p>
<blockquote>1.Google<br><a href=""https://github.com/google"" rel=""nofollow noreferrer"">https://github.com/google</a><br>2.Google Samples<br><a href=""https://github.com/googlesamples"" rel=""nofollow noreferrer"">https://github.com/googlesamples</a><br>3.Google Codelabs<br><a href=""https://github.com/googlecodelabs"" rel=""nofollow noreferrer"">https://github.com/googlecode...</a><br>4.GoogleChrome<br><a href=""https://github.com/GoogleChrome"" rel=""nofollow noreferrer"">https://github.com/GoogleChrome</a><br>5.Google Creative Lab<br><a href=""https://github.com/googlecreativelab"" rel=""nofollow noreferrer"">https://github.com/googlecrea...</a><br>6.Google Internationalization<br>人人皆可使用的Google开源字体<br><a href=""https://github.com/googlei18n"" rel=""nofollow noreferrer"">https://github.com/googlei18n</a><br>7.tensorflow<br><a href=""https://github.com/tensorflow"" rel=""nofollow noreferrer"">https://github.com/tensorflow</a>
</blockquote>
<p>2.Facebook</p>
<blockquote>1.Facebook<br><a href=""https://github.com/facebook"" rel=""nofollow noreferrer"">https://github.com/facebook</a><br>2.Facebook Samples<br><a href=""https://github.com/fbsamples"" rel=""nofollow noreferrer"">https://github.com/fbsamples</a><br>3.facebookresearch<br><a href=""https://github.com/facebookresearch"" rel=""nofollow noreferrer"">https://github.com/facebookre...</a><br>4.Facebook Incubator<br><a href=""https://github.com/facebookincubator"" rel=""nofollow noreferrer"">https://github.com/facebookin...</a>
</blockquote>
<p>3.Twitter, Inc.<br><a href=""https://github.com/twitter"" rel=""nofollow noreferrer"">https://github.com/twitter</a><br>4.Square（android开源的类库多而且厉害）<br><a href=""https://github.com/square"" rel=""nofollow noreferrer"">https://github.com/square</a><br>5.Alibaba</p>
<blockquote>1.<a href=""https://github.com/alibaba"" rel=""nofollow noreferrer"">https://github.com/alibaba</a><br>2.hiloteam(阿里，终端跨平台小游戏)<br><a href=""https://github.com/hiloteam"" rel=""nofollow noreferrer"">https://github.com/hiloteam</a><br><a href=""https://github.com/hiloteam/hilo"" rel=""nofollow noreferrer"">https://github.com/hiloteam/hilo</a><br>3.ant-design(一套企业级的 UI 设计语言和 React 实现)<br><a href=""https://github.com/ant-design"" rel=""nofollow noreferrer"">https://github.com/ant-design</a>
</blockquote>
<p>6.Kotlin（可以写Android,现在已经扶正了）<br><a href=""https://github.com/Kotlin"" rel=""nofollow noreferrer"">https://github.com/Kotlin</a><br>7.ReactiveX（函数响应式编程）<br><a href=""https://github.com/ReactiveX"" rel=""nofollow noreferrer"">https://github.com/ReactiveX</a><br><a href=""https://github.com/Reactive-Extensions"" rel=""nofollow noreferrer"">https://github.com/Reactive-E...</a><br>8.Airbnb<br><a href=""https://github.com/airbnb"" rel=""nofollow noreferrer"">https://github.com/airbnb</a><br>9.Apple<br><a href=""https://github.com/apple"" rel=""nofollow noreferrer"">https://github.com/apple</a><br>10.Uber<br><a href=""https://github.com/uber"" rel=""nofollow noreferrer"">https://github.com/uber</a><br>11.百度</p>
<blockquote>1.Baidu EFE team<br><a href=""https://github.com/ecomfe"" rel=""nofollow noreferrer"">https://github.com/ecomfe</a><br>2.baidu-research<br><a href=""https://github.com/baidu-research"" rel=""nofollow noreferrer"">https://github.com/baidu-rese...</a><br>3.echarts<br><a href=""https://github.com/apache/incubator-echarts"" rel=""nofollow noreferrer"">https://github.com/apache/inc...</a>
</blockquote>
<p>12.Bilibili（B站）<br><a href=""https://github.com/Bilibili"" rel=""nofollow noreferrer"">https://github.com/Bilibili</a><br>13.Yalantis（音乐播放，好多比较好的移动端效果）<br><a href=""https://github.com/Yalantis"" rel=""nofollow noreferrer"">https://github.com/Yalantis</a><br><a href=""https://yalantis.com/"" rel=""nofollow noreferrer"">https://yalantis.com/</a><br>14.Spring<br><a href=""https://github.com/spring-projects"" rel=""nofollow noreferrer"">https://github.com/spring-pro...</a><br>15.饿了么<br><a href=""https://github.com/eleme"" rel=""nofollow noreferrer"">https://github.com/eleme</a><br><a href=""https://elelogistics.github.io/"" rel=""nofollow noreferrer"">https://elelogistics.github.io/</a><br>16.腾讯相关</p>
<blockquote>1.腾讯<br><a href=""https://github.com/Tencent"" rel=""nofollow noreferrer"">https://github.com/Tencent</a><br>2.腾讯前端库<br><a href=""https://github.com/AlloyTeam"" rel=""nofollow noreferrer"">https://github.com/AlloyTeam</a><br>3.微信开发团队<br><a href=""https://github.com/WeMobileDev/article"" rel=""nofollow noreferrer"">https://github.com/WeMobileDe...</a>
</blockquote>
<p>17.Yalantis（好几个效果不错android的控件）<br><a href=""https://github.com/Yalantis"" rel=""nofollow noreferrer"">https://github.com/Yalantis</a><br>18.SwiftAndroid<br><a href=""https://github.com/SwiftAndroid"" rel=""nofollow noreferrer"">https://github.com/SwiftAndroid</a><br>19.Ramotion（App Development Agency | Available for new projects）<br><a href=""https://github.com/Ramotion"" rel=""nofollow noreferrer"">https://github.com/Ramotion</a><br>20.Tinify(压缩图片的那个网站)<br><a href=""https://github.com/tinify"" rel=""nofollow noreferrer"">https://github.com/tinify</a><br>21.豆瓣<br><a href=""https://github.com/douban"" rel=""nofollow noreferrer"">https://github.com/douban</a><br>22.WeUI（微信ui）<br><a href=""https://github.com/weui"" rel=""nofollow noreferrer"">https://github.com/weui</a><br>23.美团·大众点评<br><a href=""https://github.com/Meituan-Dianping"" rel=""nofollow noreferrer"">https://github.com/Meituan-Di...</a><br>24.极光开发者 <br><a href=""https://github.com/jpush"" rel=""nofollow noreferrer"">https://github.com/jpush</a><br>25.Dropbox<br><a href=""https://github.com/dropbox"" rel=""nofollow noreferrer"">https://github.com/dropbox</a><br>26.伯乐在线<br><a href=""https://github.com/jobbole"" rel=""nofollow noreferrer"">https://github.com/jobbole</a><br>27.grpc（gRPC：Google开源的基于HTTP/2和ProtoBuf的通用RPC框架）<br><a href=""https://github.com/grpc"" rel=""nofollow noreferrer"">https://github.com/grpc</a><br>28.Nike Inc.(耐克)<br><a href=""https://github.com/Nike-Inc"" rel=""nofollow noreferrer"">https://github.com/Nike-Inc</a><br>29.Medium<br><a href=""https://github.com/Medium"" rel=""nofollow noreferrer"">https://github.com/Medium</a><br>30.Microsoft<br><a href=""https://github.com/Microsoft"" rel=""nofollow noreferrer"">https://github.com/Microsoft</a><br>31.Mapbox<br><a href=""https://github.com/mapbox"" rel=""nofollow noreferrer"">https://github.com/mapbox</a><br>32.JetBrains(好多ide都是他家出的)<br><a href=""https://github.com/JetBrains"" rel=""nofollow noreferrer"">https://github.com/JetBrains</a><br>33.滴滴出行<br><a href=""https://github.com/didi"" rel=""nofollow noreferrer"">https://github.com/didi</a><br>34.华为</p>
<blockquote>1.主团队<br><a href=""https://github.com/Huawei"" rel=""nofollow noreferrer"">https://github.com/Huawei</a><br>2.大数据团队<br><a href=""https://github.com/HuaweiBigData"" rel=""nofollow noreferrer"">https://github.com/HuaweiBigData</a>
</blockquote>
<p>35.小米<br><a href=""https://github.com/xiaomi"" rel=""nofollow noreferrer"">https://github.com/xiaomi</a><br>36.知乎<br><a href=""https://github.com/zhihu"" rel=""nofollow noreferrer"">https://github.com/zhihu</a><br>37.vue<br><a href=""https://github.com/vuejs"" rel=""nofollow noreferrer"">https://github.com/vuejs</a><br>38.iView<br><a href=""https://github.com/iview"" rel=""nofollow noreferrer"">https://github.com/iview</a><br>39.Node<br><a href=""https://github.com/nodejs"" rel=""nofollow noreferrer"">https://github.com/nodejs</a><br>40.Fuchsia<br><a href=""https://github.com/fuchsia-mirror"" rel=""nofollow noreferrer"">https://github.com/fuchsia-mi...</a><br>41.Flutter<br><a href=""https://github.com/flutter"" rel=""nofollow noreferrer"">https://github.com/flutter</a><br>42.Apache<br><a href=""https://github.com/apache"" rel=""nofollow noreferrer"">https://github.com/apache</a><br>43.AMAP-Demo(高德开放平台示例中心)<br><a href=""https://github.com/amap-demo"" rel=""nofollow noreferrer"">https://github.com/amap-demo</a><br>44.GitHub<br><a href=""https://github.com/github"" rel=""nofollow noreferrer"">https://github.com/github</a></p>
<p>持续更新,排名不分先后。。。<br>欢迎大家补充</p>

                ", 大牛公司github官网整理,1531977839,429,1,437,1,1,https://segmentfault.com/a/1190000009475248
129,1,0,7,"
                    
<blockquote><p>谷歌今天发布了一系列“性感”的软件，我们也发布了一款大家期待已久的开发者工具，同样很性感 ：)</p></blockquote>
<p>iView 2.0 已经发布有两个月了，在 2.0 发布后，npm 下载量、issues 数量都提升了很多（可以 watch 下项目，感受感受邮件量）。两个月里，我们平均 1 周发布一个版本，现在已发布了 13 个版本，2.0 的正式版也发布在即，不过在此之前，先给大家带来一个开发利器：<strong> iView Cli </strong>。</p>
<p>相信大部分 Vue 开发者都使用过 vue-cli 来构建项目，它的确很方便，但对于很多初级开发者来说，还是要踩不少坑的，构建完需要进一步个性化配置。而 iView Cli 具有以下特点：</p>
<ul>
<li><p>有 GUI 的脚手架</p></li>
<li><p>配置简单、业务化</p></li>
<li><p>分开发和生产环境</p></li>
<li><p>很多常用工具可选择</p></li>
<li><p>它不仅好用，还很好看</p></li>
</ul>
<p>先来感受下 iView Cli 的界面吧：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009463558"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009463559?w=1870&amp;h=1136"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在配置方面，支持 CSS 预处理器 Less 和 Sass。Ajax 使用的是 axios，而且会把配置写在工具函数 util.js 里，并做了开发和生产环境的不同配置。</p>
<p>多语言使用了 vue-i18n 的 5.x 版本，并整合了 iView 的多语言和使用者自己的多语言配置，而且会根据用户系统的语言自动切换为中文和英文。</p>
<p>状态管理可选 vuex 或 bus.js 。</p>
<p>除此之外，还增加了一些常用的中后台开发的工具：echarts、Cookie、复制 clipboard，以及 HTML 转图片的工具等。</p>
<p>这次还支持了大部分设备的安装包，包括 Mac、Windows 64 位、Windows 32 位、Linux 64 位、Linux 32 位。</p>
<p>用过 GitHub 的同学都知道，release 的文件下载走的国外的 AWS，那个慢仿佛回到了20年前拨号上网的窄带。这次我们 release 在了开源中国的码云，下载不是问题了。</p>
<p>话不多说，快去下载体验最性感的 Vue 脚手架吧！</p>
<p><strong>高速下载地址：<a href=""https://www.iviewui.com/cli"" rel=""nofollow noreferrer"">https://www.iviewui.com/cli</a></strong></p>
<hr>
<p>iView 在不断努力的改进，求 Star，更求 PR，contribution welcome ：）<br><strong>iView 地址：<a href=""https://github.com/iview/iview"" rel=""nofollow noreferrer"">https://github.com/iview/iview</a></strong><br><strong>iView Cli地址：<a href=""https://github.com/iview/iview-cli"" rel=""nofollow noreferrer"">https://github.com/iview/iview-cli</a></strong></p>
<p>我们还在招募翻译志愿者，帮助翻译 iView 的文档，如果你精通中文和英文，又有 Vue 开发经验，欢迎加入我们的翻译计划，一起完善 iView，享受开源的乐趣。</p>
<hr>
<p>最后再做个小广告吧，6月份还有两场关于 Vue.js 组件的课程，感兴趣的同学可以报名参加：<br><a href=""https://segmentfault.com/l/1500000009448056"" rel=""nofollow noreferrer"">Vue.js 实战之组件篇（上）</a><br><a href=""https://segmentfault.com/l/1500000009448189"" rel=""nofollow noreferrer"">Vue.js 实战之组件篇（下）</a></p>

                ", 基于 Webpack2、Vue2、iView2 的可视化脚手架 iView Cli 发布 2.0 版本,1531977841,502,1,601,1,1,https://segmentfault.com/a/1190000009463554
130,1,0,7,"
                    
<p>很久没有写文章了，说实话本人现在受困于五月病已经快变成一条死咸鱼了(T_T)，本次就当写一个简单的js插件教程了。本项目的代码相对比较简单，至于里面有些变量命名的问题就请你们不要吐槽了Σ(ﾟдﾟlll)（好的，我承认我英语就小学水平好吧。除了hello和goodbye其他的都不会了____orz）。 废话就讲到这里，下面开始正文。</p>
<p>demo: <a href=""http://lonelymoon.linux2.jiuhost.com/wantEmoji/"" rel=""nofollow noreferrer"">我是demo</a><br>git : <a href=""https://github.com/lonelymoon/projects/tree/master/wantPlugs/wantEmoji"" rel=""nofollow noreferrer"">我是项目git</a><br>下载地址： <a href=""http://lonelymoon.linux2.jiuhost.com/wantEmoji/wantEmoji.zip"" rel=""nofollow noreferrer"">点我下载</a></p>
<h2>1. 事前准备</h2>
<p>事实上在写一个插件前我们都需要事先想好你要实现哪些功能，怎么去实现，这些大方向的东西是需要事先考虑的，至于具体细节和优化选项我们可以在写代码的过程中再进行修改。</p>
<p>就以我们写的这个emoji插件为例，网上已经有一些相关的插件了，但你总感觉有些部分的需求不能被满足（如：可以自行添加新的表情包而不用去改源代码等等），这时我们就可以列出你想实现的功能项了：</p>
<ol>
<li><p>需要满足基本的表情插件的需求，包括图片和对应code的相互转换</p></li>
<li><p>希望可以通过参数来调整每行以及每列表情图片的显示个数，并且可以针对不同表情包单独调整</p></li>
<li><p>希望用户可以在不了解源代码的情况下也能自行主动添加新的表情包</p></li>
<li><p>模板界面简单，可以进行自适应，并且兼容移动端</p></li>
<li><p>尽可能只提供简单的api接口和方法，避免内部涉及其他不是很相关的功能（如绑定某个特定的元素或者在内部进行数据传输等等），保持插件的灵活性等等</p></li>
</ol>
<p>以上就是我们暂时能想到的功能和需求，下面就开始写一个完整的插件了（当然原生js插件某种程度来讲使用起来相对比较自由，因为不需要依赖某些特定库，而且也不需要按照某些库类的格式标准进行插件的编写，但少了一些封装好的方法也会使得插件写起来更费力，至于怎么取舍就需要看个人需求来定了）</p>
<h2>2. 进行结构划分</h2>
<p>当我们正式开始代码编写的时候，当然想自己写出来的代码不敢说很强势，但至少结构清晰，易于读懂，而且代码的性能也需要保证。这时我们就需要回到前面的需求了，由上面列出的5点可以看出，大部分的功能需求都是在我们程序内部去实现的，唯一需要考虑的是上面的第3点。</p>
<p>这时我们可能已经想到办法了，比如说将新的表情包填好相关的参数后由接口传入程序内部去作处理。当然这是一个合理的选择，但考虑到代码的复杂度和使用的简易度，我们最好还是建立一个对应config文件。因为首先这样我们可以提供一些默认的表情包，并且配置好相关的参数并注释，后面的使用者只需要按照相关的格式复制然后修改就行了。而且将一些非逻辑性的数据单独隔离开来有利于维持清晰的代码结构，增加代码的易读性。所以到这里已经可以基本上确定我们需要的文件了：</p>
<ol><li><p>一个模板css文件; 2. 一个数据配置文件config.js; 3. 一个逻辑实现文件js;</p></li></ol>
<h2>3. 填写配置文件</h2>
<p>这里先填写配置文件是为了有一个更明确的需求，以及防止在coding过程中忘记了某些需求（像我一样，老了，脑袋不好使ﾟﾟ(ﾟ´Д｀ﾟ)ﾟ），当然并不是所有插件都用配置文件比较好，新手请务必不要有这样的误区，下面是我写的配置代码：</p>
<pre><code>
    var path = ""http://localhost/wantEmoji/"",  //项目所在的根地址
    emojis = {
        ""paopao"" : {
            ""name"" : ""泡泡"", //名字
            ""col"" : 10, //每一行最大的表情个数(建议填选的时候值不要太大或太小)
            ""path"" : path+""emojiSources/paopao/"", //相对于项目根地址的路径
            ""enable"" : true, //是否启用本表情包
            ""sources"" : [""1.jpg""] //中间的值也支持{title:""笑"",url:""1.jpg""}的形式,且可单独设置
        }
    }
</code></pre>
<p>这部分代码考虑了几个点：<br>一是考虑到可能会在不同路径的文件中调用同一个配置文件，所以为了保证路径不出错，需要确定每个包的绝对路径值。<br>二是考虑到某些表情包现在可能并不想用，但代码删来删去可能会很麻烦，所以提供了一个是否启用的接口。<br>三是考虑到不同表情包的图片尺寸可能不同，为了让每张图片尽可能清晰我们允许调整每行显示的图片个数（在程序中每个单项的size都是自动计算的）<br>四是考虑到每张表情图片可能有的需要设置title来提示用户这个表情是什么意思，所以允许sources项数组中的值可以为string也可以为object<br>最后也是主要考虑的问题，我们希望每个表情对应的code值能够自动生成而不是人为的对每个图片去进行单独设置，所以需要保证每个code的值都是唯一的，而且是容易被解析的。<br>这里emojis变量不是数组而是对象就是基于这个原因。 （我们最终生成的code值为[wem:emojis的key值_图片名_图片类型:wem]这种形式，如[wem:paopao_1_jpg:wem]，表示的是paopao表情包里面的1.jpg)</p>
<h2>4. 插件开写</h2>
<p>前面的准备工作都做好后，现在我们终于可以开始写真正的代码了。虽然前面的内容不怎么多，但对于一个插件乃至一个项目来说都是必不可少的一个步骤，特别是初学者，开始动手写自己的插件时多想想该怎么做总是没错的。</p>
<p>首先我们需要创建一个对象（当然你通过闭包来写也是可以的），明确好哪些数据和函数是可以共用的，哪些是不能共用的。就我个人的经验来讲，一般对于用来保存数据用的变量，最好都放在函数体内，而方法则都放在原型上。</p>
<pre><code>var wantEmoji = function(options){
    options = options || {};
    var selector = options.wrapper || ""body"";  

    this.wrapper = document.querySelector(selector);    //包裹元素
    this.row = options.row || 4;                          //每页表情的行数
    this.callback = options.callback || function(){};     //当表情被点击时的回调，返回表情的code值

    this.emojis = window.emojis || emojis;        //加载表情包配置

    this.content = null;                   //.wEmoji-content
    this.navRow = null;                    //.wEmoji-row
    this.currentWrapper = null;         //.wEmoji-wrapper[data-choose=""true""]

    this.activePage = 0;
    this.totalPage = 0;
    this.eachPartsNum = 4;                 //每一批显示的表情包数(导航栏的表情包的最大显示个数)

    this.wrapWidth = 0;
    this.count = this.getEMJPackageCount();
    
    if(options.autoInit) //当设置了autoInit之后会自动调用init函数，默认不会
    this.init();
};
</code></pre>
<p>上面的代码我都加了注释就不做细说了，下面是各个功能部分的实现（马上就可以看到我英语捉急的地方了(｀・ω・´)）。</p>
<p>首先是init(): 完成某些数据的获取以及确认进入哪种情况</p>
<pre><code>init : function(){
        //当表情包的实际启用个数大于设定值时，启用.wEmoji-more
        if(this.count &gt; this.eachPartsNum)
        this.wrapper.className += "" wEmoji wEmoji-more"";
        else
        this.wrapper.className += "" wEmoji"";

        this.wrapWidth = this.wrapper.clientWidth;

        this.initTemplete();
},</code></pre>
<p>initTemplete(): 初始化模板，更新某些数据变量，并执行接下来的工作</p>
<pre><code>initTemplete : function(){

        var wrapper = this.wrapper,
            tpl = '&lt;div class=""wEmoji-header""&gt;'+
                    '&lt;div class=""wEmoji-prev-btn""&gt;&amp;lt;&lt;/div&gt;'+
                    '&lt;div class=""wEmoji-nav""&gt;'+
                        '&lt;div class=""wEmoji-row""&gt;&lt;/div&gt;'+
                    '&lt;/div&gt;'+
                    '&lt;div class=""wEmoji-next-btn""&gt;&amp;gt;&lt;/div&gt;'+
                '&lt;/div&gt;'+
                '&lt;div class=""wEmoji-container""&gt;'+
                    '&lt;div class=""wEmoji-content""&gt;&lt;/div&gt;'+
                    '&lt;div class=""wEmoji-pages""&gt;&lt;/div&gt;'+
                '&lt;/div&gt;';

        wrapper.innerHTML = tpl;

        this.content = wrapper.querySelector("".wEmoji-content"");
        this.navRow = wrapper.querySelector("".wEmoji-row"");

        this.__initData();
        this.__bindEvent();
},</code></pre>
<p>接下来是__initData():生成具体的表情图片和导航等，这里需要注意的是进行dom操作时不要让重排发生多次，使需要操作的dom元素脱离文档流是减少重排的方法之一。另外这里还将许多属性保存为临时变量是为了提高程序性能（至于代码优化需要自己去找资料看，这里就简单提一下）。</p>
<pre><code>__initData : function(){
        var emojis = this.emojis,
            wrapper = this.wrapper,
            navRow = this.navRow,
            content = this.content,
            rowWidth = navRow.clientWidth,
            count = this.count;

        //减少重排
        wrapper.style.display = ""none"";

        content.innerHTML = """";
        navRow.style.width = count / this.eachPartsNum * 100 + ""%"";

        for( var key in emojis ){
            var emj = emojis[key];

            if(!emj.enable)
            continue;
            //将每个生成的表情包的容器放入content中
            content.appendChild(this.__initContent(key,emj)); 
            navRow.innerHTML += '&lt;div class=""wEmoji-list"" data-eid=""'+key+'"" style=""width:'+(1/count*100)+'%;""&gt;'+emj.name+'&lt;/div&gt;';
        }

        this.__initStyle();

        this.wrapper.style.display = ""block"";
},</code></pre>
<p>事件绑定：正常流程来走就行，注意某些地方需要用事件委托来提升性能，而这里没用addEventListener是为了防止多次初始化init的时候导致事件重复绑定，on+“event”事实上已经够用了。</p>
<pre><code>__bindEvent : function(){
        var _self = this,
            wrapper = this.wrapper,
            row = this.navRow,
            pageBox = wrapper.querySelector('.wEmoji-pages'),
            prev = wrapper.querySelector('.wEmoji-prev-btn'),
            next = wrapper.querySelector('.wEmoji-next-btn'),
            content = this.content,
            down = ""ontouchstart"" in document ? ""touchstart"" : ""mousedown"",
            up = ""ontouchend"" in document ? ""touchend"" : ""mouseup"",
            move = ""ontouchmove"" in document ? ""touchmove"" : ""mousemove"",
            drag = false,
            x = 0;

        pageBox.onclick = function(e){
            e = e || event;
            var target = e.target || e.srcElement,
                idx = target.getAttribute(""data-pageIdx"");
            if(target.tagName.toLowerCase() != ""li"" || !idx){
                return false;
            }
            _self.showPage(idx-1);
        };

        row.onclick = function(e){
            e = e || event;
            var target = e.target || e.srcElement,
                eid = target.getAttribute(""data-eid"");

            if( eid &amp;&amp; _self.emojis[eid] ){
                _self.chooseEmoji(eid);
                _self.showPage(0);
            }
        };

        var parts = Math.ceil(this.count / this.eachPartsNum), //可以将表情包数分为N批（默认4个一批）
            partsIdx = 0,
            navWidth = wrapper.querySelector("".wEmoji-nav"").clientWidth;

        prev.onclick = function(e){
            partsIdx = partsIdx - 1 &lt; 0 ? 0 : partsIdx - 1;
            row.style.webkitTransform = ""translateX(""+(-partsIdx * navWidth)+""px) translateZ(0px)"";
            row.style.transform = ""translateX(""+(-partsIdx * navWidth)+""px) translateZ(0px)"";
        };

        next.onclick = function(e){
            partsIdx = partsIdx + 1 &gt;= parts ? partsIdx : partsIdx + 1;
            row.style.webkitTransform = ""translateX(""+(-partsIdx * navWidth)+""px) translateZ(0px)"";
            row.style.transform = ""translateX(""+(-partsIdx * navWidth)+""px) translateZ(0px)"";
        };

        content.onclick = function(e){
            e = e || event;
            var target = e.target || e.srcElement,
                trueTarget = getTargetNode(target,"".wEmoji-item""),
                emjCode;

            if(trueTarget)
            emjCode = trueTarget.getAttribute(""data-emj"");

            if(!emjCode)
            return false;

            _self.callback.call(_self,emjCode);
            console.log(emjCode);
        };

        content[""on""+down] = function(e){
            e = e || event;
            drag = true;
            x = e.pageX || e.touches[0].pageX;
        };

        content[""on""+move] = function(e){
            e = e || event;
            e.stopPropagation();
            e.preventDefault();
        };

        content[""on""+up] = function(e){
            e = e || event;
            if(drag){
                drag = false;
                var endX = e.pageX || e.changedTouches[0].pageX,
                    dis = endX - x,
                    idx;

                if(dis &gt; 50){
                    idx = Math.max(_self.activePage - 1,0);
                    _self.showPage(idx);
                } else if (dis &lt; -50){
                    idx = Math.min(_self.activePage + 1,_self.totalPage - 1);
                    _self.showPage(idx);
                }
                x = 0;
            }
        };

},</code></pre>
<p>下面是选择表情包的功能chooseEmoji()：封装好后只需要调用接口即可，不管是初始化的时候还是事件触发的时候，将表情包改变时会发生操作全都放一起，因为大部分操作都是同时变化的，所以没必要继续细分了。</p>
<pre><code>chooseEmoji : function(eid){
        var navRow = this.navRow,
            content = this.content,
            targetWrapper = content.querySelector("".wEmoji-wrapper[data-eid='""+eid+""']""),
            targetList = navRow.querySelector("".wEmoji-list[data-eid='""+eid+""']""),
            chooseWrapper = content.querySelector("".wEmoji-wrapper[data-choose='true']""),
            chooseList = navRow.querySelector("".wEmoji-list[data-choose='true']"");

        if(chooseWrapper){
            chooseList.setAttribute(""data-choose"",""false"");
            chooseWrapper.setAttribute(""data-choose"",""false"");
        }
        targetWrapper.setAttribute(""data-choose"",""true"");
        targetList.setAttribute(""data-choose"",""true"");

        this.currentWrapper = targetWrapper;
        this.__createPageList();
},</code></pre>
<p>下面是页面的切换showPage()：完成初始化和事件触发时页面的切换</p>
<pre><code>showPage : function(idx){
        this.activePage = idx;
        var wrapper = this.wrapper,
            currentWrapper = this.currentWrapper,
            pageTargetList = wrapper.querySelector("".wEmoji-page-list[data-pageIdx='""+(idx+1)+""']""),
            pageChoose = wrapper.querySelector("".wEmoji-page-list[data-choose='true']"");

        if(pageChoose)
        pageChoose.setAttribute(""data-choose"",""false"");
        pageTargetList.setAttribute(""data-choose"",""true"");

        currentWrapper.style.webkitTransform = ""translateX(""+(-this.wrapWidth*idx)+""px) translateZ(0px)"";
        currentWrapper.style.transform = ""translateX(""+(-this.wrapWidth*idx)+""px) translateZ(0px)"";
}</code></pre>
<p>最后一个是将code解释成img的功能函数explain(): 大家通过前面的介绍可以知道code的生成规则</p>
<pre><code>explain : function(str){
        var reg = /\[wem:(\w+):wem\]/g,
            _self = this;

        return str.replace(reg,function(str,target){
            var tempArr = target.split(""_""),
                eid = tempArr.shift(),
                type = tempArr.pop(),
                name = tempArr.join(""_"");
                path = _self.emojis[eid].path;
                url = name+"".""+type;

            return '&lt;img src=""'+path+url+'"" /&gt;';
        });
},</code></pre>
<p>基本上主要代码就这么多了，还有一部分代码可以看源代码来了解，因为我基本上都有写注释所以应该不怎么难理解。</p>
<h2>5. 结语</h2>
<p>虽然我很想进一步把教程写完全，但基于本人身体已经被掏空的现实情况考虑，就不做打算了，效果的话可以点开上面的demo去看，大家有什么问题欢迎留言提问，以后会不定时写一些插件，到时候也欢迎大家来捧场，以上（写完要死了(ง ° ͜  °)ง)。</p>

                ", 用javascript写一个emoji表情插件,1531977843,487,1,385,1,1,https://segmentfault.com/a/1190000009455711
131,1,0,7,"
                    
<h2>前言</h2>
<p><strong>总括：</strong> 包含这三个月来碰到的一些觉得比较好的面试题，三个月没怎么写博客着实有些手痒，哈哈哈。7000余字，不成敬意2333</p>
<ul>
<li><p>原文地址：<a href=""http://damonare.github.io/2017/04/24/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/#more"" rel=""nofollow noreferrer"">我的前端进阶之路</a></p></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href=""https://zhuanlan.zhihu.com/damonare"" rel=""nofollow noreferrer"">前端进击者（知乎）</a>&amp;&amp;<a href=""http://www.jianshu.com/collection/bbaa63e264f5"" rel=""nofollow noreferrer"">前端进击者（简书）</a></p></li>
<li><p>博主博客地址：<a href=""http://damonare.cn"" rel=""nofollow noreferrer"">Damonare的个人博客</a></p></li>
</ul>
<p><strong>烈火试真金，逆境试强者</strong></p>
<h2>正文</h2>
<h4>React和Vue对比</h4>
<p>相同点:</p>
<ol>
<li><p>数据驱动视图，提供响应式的视图组件</p></li>
<li><p>都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范</p></li>
<li><p>数据流动单向</p></li>
<li><p>都支持服务端渲染</p></li>
<li><p>都有支持native的方案，React的<code>React native</code>，Vue的<code>weex</code></p></li>
</ol>
<p>不同点：</p>
<ol>
<li><p>社区：React社区还是要比vue大很多；</p></li>
<li><p>开发模式：React在view层侵入性还是要比Vue大很多的,React严格上只针对MVC的view层，Vue则是MVVM模式的一种实现；</p></li>
<li><p>数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的</p></li>
<li><p>数据渲染：对于大规模数据渲染，React要比Vue更快，渲染机制启动时候要做的工作比较多；</p></li>
<li><p>数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React在复杂的应用里有两个选择:</p></li>
</ol>
<p>(1). 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。  (2).Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js；</p>
<ol>
<li><p>开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即""all in js""；Vue进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件；</p></li>
<li><p>使用场景：React配合Redux架构适合超大规模多人协作的复杂项目;Vue则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React；</p></li>
<li><p>Vue要比React更好上手，具体可能体现在很多人不熟悉React的JSX语法和函数式编程的思想，以及想要发挥出React的最大威力需要学习它一系列生态的缘故；</p></li>
<li><p>Vue着重提高开发效率,让前端程序员更快速方便的开发应用。React着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是UI的构建者；</p></li>
</ol>
<h4>gulp和webpack区别</h4>
<ol>
<li><p>gulp是一种工具，我们可以用它来优化前端的工作流程，比如自动刷新页面、combo、压缩css、js、编译less等等。具体体现为：在gulp的配置文件中书写一个个的task，webpack则是一种打包工具，或者说是一种模块化解决方案，实际上很大一部分人刚开始使用webpack的方式就是通过gulp-webpack这个插件，写好task来使用webpack对前端的一些文件进行打包;</p></li>
<li><p>gulp的处理任务需要自己去写，webpack则有现成的解决方案，只需要在webpack.config.js配置好即可;</p></li>
</ol>
<h4>防止重复发送Ajax请求</h4>
<ol>
<li><p>用户点击之后按钮disabled;</p></li>
<li><p>函数节流</p></li>
<li><p>abort掉上一个请求。</p></li>
</ol>
<h4>事件模型</h4>
<ul>
<li><p>事件捕获阶段(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p></li>
<li><p>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</p></li>
<li><p>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p></li>
</ul>
<h4>浏览器缓存机制</h4>
<ol><li><p>Expires策略</p></li></ol>
<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<ol><li><p>Cache-Control策略</p></li></ol>
<p>Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器是否直接从浏览器缓读取数据还是重新发请求到服务器取数据。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于Expires</strong>。</p>
<p>以上是设置缓存时间的两种方法。那么当缓存时间过了咋整呢？有人肯定说了，那就再次发起请求啊，这是对的。问题是如果服务器资源并没有更新呢？比如说我有一个<code>jQuery.js</code>文件已经缓存了，当它的缓存时间到了之后服务器的<code>jQuery.js</code>文件也没有更新，那实际上我们直接使用本地缓存的文件就可以啊！没必要浪费带宽和时间去重新请求一个新的文件啊！这时候我们就需要再进一步看一下HTTP协议里这几个参数的作用了。</p>
<ol><li><p>Last-Modified/If-Modified-Since</p></li></ol>
<p>首先Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<ul>
<li><p>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间(这个参数是和Cache-Control一起过来的)。</p></li>
<li><p>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 <strong>If-Modified-Since</strong>，表示请求时间。<strong>web服务器收到请求后发现有头If-Modified-Since ，则与被请求资源的最后修改时间进行比对</strong>。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p></li>
</ul>
<ol><li><p>ETag/If-None-Match</p></li></ol>
<p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<ul>
<li><p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。<em>Apache</em>中，ETag的值，<strong>默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime</strong>）进行<em>Hash</em>后得到的。</p></li>
<li><p>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。<strong>web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对</strong>，决定返回200或304。</p></li>
</ul>
<ol><li><p>ETag和Last-Modified</p></li></ol>
<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p></li>
<li><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p></li>
<li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p></li>
</ul>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong>Last-Modified</strong>与ETag是可以一起使用的，服务器会优先验证ETag<strong>，一致的情况下，才会继续比对Last-Modified</strong>，最后才决定是否返回304。</p>
<h4>Ajax的状态值与HTTP状态码</h4>
<ul><li><p>Ajax的状态值</p></li></ul>
<p>0: (未初始化)还没有调用send()方法。<br>  1: (载入)已经调用send()方法，正在派发请求。<br>  2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。<br>  3: (交互)正在解析响应内容。<br>  4: (完成)响应内容已经解析完成，用户可以调用。</p>
<ul><li><p>HTTP状态码</p></li></ul>
<p>200 &amp; OK: 请求成功；</p>
<p>204 &amp; No Content: 请求处理成功，但没有资源可以返回；</p>
<p>206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)；</p>
<p>301 &amp; Move Permanently: 永久性重定向；</p>
<p>302 &amp; Found： 临时性重定向；</p>
<p>303 &amp;  See Other: 请求资源存在另一个URI，应使用get方法请求；</p>
<p>304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存；</p>
<p>307 &amp; Temporary Redirect: 临时重定向；</p>
<p>400 &amp; Bad Request: 请求报文存在语法错误；</p>
<p>401 &amp; Unauthorized: 请求需要通过HTTP认证；</p>
<p>403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题；</p>
<p>404 &amp; Not Found: 服务器上没有请求的资源；</p>
<p>500 &amp; Internal Server Error: 服务器执行请求时出现错误；</p>
<p>502 &amp; Bad Gateway: 错误的网关；</p>
<p>503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求；</p>
<p>504 &amp; Gateway timeout: 网关超时；</p>
<h4>React-router原理</h4>
<p>1.<strong>History</strong></p>
<ul>
<li><p>老浏览器的history: 主要通过hash来实现，对应<code>createHashHistory</code></p></li>
<li><p>高版本浏览器: 通过html5里面的history，对应<code>createBrowserHistory</code></p></li>
<li><p>node环境下: 主要存储在memeory里面，对应<code>createMemoryHistory</code></p></li>
</ul>
<p>内部<code>createHistory</code>实现：</p>
<pre><code class=""javascript"">// 内部的抽象实现
function createHistory(options={}) {
  ...
  return {
    listenBefore, // 内部的hook机制，可以在location发生变化前执行某些行为，AOP的实现
    listen, // location发生改变时触发回调
    transitionTo, // 执行location的改变
    push, // 改变location
    replace,
    go,
    goBack,
    goForward,
    createKey, // 创建location的key，用于唯一标示该location，是随机生成的
    createPath,
    createHref,
    createLocation, // 创建location
  }
}</code></pre>
<p><code>createLocation</code>方法:</p>
<pre><code class=""javascript"">function createLocation() {
  return {
    pathname, // url的基本路径
    search, // 查询字段
    hash, // url中的hash值
    state, // url对应的state字段
    action, // 分为push、replace、pop三种
    key // 生成方法为: Math.random().toString(36).substr(2, length)
  }
}</code></pre>
<p>三种方法各自执行<code>URL</code>前进的方式：</p>
<ul>
<li><p><code>createBrowserHistory</code>: pushState、replaceState</p></li>
<li><p><code>createHashHistory</code>: <code>location.hash=***</code> <code>location.replace()</code></p></li>
<li><p><code>createMemoryHistory</code>: 在内存中进行历史记录的存储</p></li>
</ul>
<p>伪代码实现:</p>
<pre><code class=""javascript"">// createBrowserHistory(HTML5)中的前进实现
function finishTransition(location) {
  ...
  const historyState = { key };
  ...
  if (location.action === 'PUSH') ) {
    window.history.pushState(historyState, null, path);
  } else {
    window.history.replaceState(historyState, null, path)
  }
}
// createHashHistory的内部实现
function finishTransition(location) {
  ...
  if (location.action === 'PUSH') ) {
    window.location.hash = path;
  } else {
    window.location.replace(
    window.location.pathname + window.location.search + '#' + path
  );
  }
}
// createMemoryHistory的内部实现
entries = [];
function finishTransition(location) {
  ...
  switch (location.action) {
    case 'PUSH':
      entries.push(location);
      break;
    case 'REPLACE':
      entries[current] = location;
      break;
  }
}</code></pre>
<ol><li><p><strong>React-router的基本原理</strong></p></li></ol>
<p><code>URL</code>对应<code>Location</code>对象，而<code>UI</code>是由react的 <code>components</code>来决定的，这样就转变成<code>location</code>与<code>components</code>之间的同步问题。</p>
<h4>什么是原型链</h4>
<p>每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型<code>prototype</code>，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到<code>null</code>(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，<code>new</code>关键字做的主要的事情就是将实例对象的<code>__proto__</code>属性指向原型对象的prototype。</p>
<h4>什么是闭包</h4>
<ul>
<li><p>闭包是javascript支持<a href=""https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0"" rel=""nofollow noreferrer"">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</p></li>
<li><p>闭包是函数开始执行的时候被分配的一个<a href=""http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_"" rel=""nofollow noreferrer"">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</p></li>
<li>
<p>闭包的应用：</p>
<ul><li><p>比如写柯里化函数的时候利用闭包，保存参数在内存中；</p></li></ul>
<pre><code class=""javascript"">var currying = function(fun) {
      //格式化arguments
    var args = Array.prototype.slice.call(arguments, 1);
      return function() {
          //收集所有的参数在同一个数组中，进行计算
          var _args = args.concat(Array.prototype.slice.call(arguments));
          return fun.apply(null, _args);
      };
}</code></pre>
</li>
</ul>
<p>​</p>
<ul><li><p>模拟私有变量或是私有方法；</p></li></ul>
<ol>
<li>
<p>people = (num) =&gt; {<br>var num = num;<br>return {<br>  increase: () =&gt; {</p>
<pre><code>    num++;</code></pre>
<p>},</p>
<pre><code>get: () =&gt; {
    return num;
}
  }</code></pre>
<p>}</p>
</li>
<li><p>man = people(4);<br>  man.increase();<br>  man.get();</p></li>
</ol>
<ul><li><p>避免引用错误</p></li></ul>
<ol><li>
<p>(var i = 0; i &lt; 4; i++) {<br>(function(_i) {</p>
<pre><code>setTimeout(function() {
    console.log(_i)</code></pre>
<p>}, 1000)<br>})(i)<br>  }</p>
</li></ol>
<p>​</p>
<h4>图片懒加载与预加载</h4>
<ul>
<li><p>图片懒加载的原理就是暂时不设置图片的<code>src</code>属性，而是将图片的<code>url</code>隐藏起来，比如先写在<code>data-src</code>里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的<code>url</code>放进<code>src</code>属性里面，从而实现图片的延迟加载</p></li>
<li><p>图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在css的background的url属性里面，一种是通过javascript的Image对象设置实例对象的src属性实现图片的预加载。相关代码如下：</p></li>
<li>
<ol><li><p>CSS预加载图片方式：</p></li></ol>
<pre><code class=""css"">#preload-01 { background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; }  
#preload-02 { background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; }  
#preload-03 { background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; }</code></pre>
</li>
<li>
<ol><li><p>Javascript预加载图片的方式：</p></li></ol>
<pre><code class=""javascript"">function preloadImg(url) {
    var img = new Image();
    img.src = url;
    if(img.complete) {
        //接下来可以使用图片了
        //do something here
    } else {
        img.onload = function() {
            //接下来可以使用图片了
            //do something here
        };
    }
}</code></pre>
</li>
</ul>
<h4>跨域</h4>
<p>跨域的方式有很多种，最常用的是<code>jsonp</code>主要利用了<code>script</code>的开放策略:通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。缺点在于只支持get请求而且存在安全问题。</p>
<p>CORS跨域，关键在于服务器，如果服务器实现了CORS跨域的接口，那么就可以使用ajax(请求路径为绝对路径)进行跨域请求。CORS请求分为两种，一种是简单请求，一种是非简单请求。简单请求是指请求方法在<code>HEAD</code>,<code>GET</code>,<code>POST</code>三者之间并且请求头信息局限在</p>
<ul>
<li><p>Accept</p></li>
<li><p>Accept-Language</p></li>
<li><p>Content-Language</p></li>
<li><p>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></p></li>
</ul>
<p>非简单请求请求头：</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段</p>
<p>执行简单请求的时候，浏览器会在请求头信息增加<code>origin</code>字段，服务器据此来判断请求域名是否在许可范围之内，来决定是否返回<code>Access-Control-Allow-Origin</code>字段。响应头有以下几种：</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p>
<p><strong>(4)Access-Control-Max-Age</strong></p>
<p><code>Access-Control-Max-Age</code> 首部字段指明了预检请求的响应的有效时间。</p>
<p><strong>(5)Access-Control-Allow-Methods</strong></p>
<p><code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p>
<p><strong>(6)Access-Control-Allow-Headers</strong></p>
<p><code>Access-Control-Allow-Headers</code>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p>
<p>其他方法：<code>document.domin</code>,html5的<code>postMessage</code>,<code>window.name</code>等</p>
<h4>函数节流和函数防抖</h4>
<p>函数节流让指函数有规律的进行调用，应用场景：window.resize，游戏中子弹发射(1s只能发射一颗子弹)等；</p>
<p>函数防抖让函数在""调用''之后的一段时间后生效，应用场景:输入框(例：在用户停止输入的500ms后再处理用户数据)。</p>
<pre><code class=""javascript"">//函数节流
/*
* @params {Function} fun 调用函数
* @params {delay} number 延迟时间
*/
const throttle = (fun, delay, ...rest) =&gt; {
    let last = null;
    return () =&gt; {
        const now = + new Date();
        if (now - last &gt; delay) {
            fun(rest);
            last = now;
        }
    }
}
//实例
const throttleExample  = throttle(() =&gt; console.log(1), 1000);
//调用
throttleExample();
throttleExample();
throttleExample();
//函数防抖
const debouce = (fun, delay, ...rest) =&gt; {
    let timer = null;
    return () =&gt; {
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            fun(rest);
        }, delay);
    }
}
//实例
const debouceExample = debouce(() =&gt; console.log(1), 1000);
//调用
debouceExample();
debouceExample();
debouceExample();</code></pre>
<h4>快速排序</h4>
<ol>
<li><p>从数列中挑出一个元素，称为""基准""（pivot），</p></li>
<li><p>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</p></li>
<li><p><a href=""https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92"" rel=""nofollow noreferrer"">递归</a>地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li>
</ol>
<p>时间复杂度平均情况：O(nlog n) 最快：O(n^{2})  空间复杂度:  O(log n)</p>
<pre><code class=""javascript"">var quickSort = function(arr) {
    console.time('2.快速排序耗时');
　　if (arr.length &lt;= 1) { return arr; }
　　var pivot = arr.splice(0, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i &lt; arr.length; i++){
　　　　if (arr[i] &lt; pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
console.timeEnd('2.快速排序耗时');
　　return quickSort(left).concat([pivot], quickSort(right));
};
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(quickSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre>
<h4>AMD和CMD的区别</h4>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
<ol>
<li><p>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p></li>
<li><p>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</p></li>
<li><p>AMD 的 API 默认是<strong>一个当多个用</strong>，CMD 的 API 严格区分，推崇<strong>职责单一</strong>。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都<strong>简单纯粹</strong>。</p></li>
</ol>
<h4>JavaScript内存泄露的原因以及如何去手动释放内存</h4>
<p><strong>易出现泄露的场景</strong></p>
<ul>
<li><p>XMLHttpRequest 泄漏发生在IE7-8,释放方法，将XMLHttpRequest实例对象设置为Null；</p></li>
<li><p>DOM&amp;BOM等COM对象循环绑定 泄漏发生在IE6-8，释放方法，切断循环引用，将对对象的应用设置为Null；</p></li>
<li><p>定时器(严格上说不能算是泄露，是被闭包持有了，是正常的表现)，对于闭包中无用的变量可以使用delete操作符进行释放；</p></li>
</ul>
<p><strong>JavaScript垃圾回收机制</strong></p>
<ul><li><p>引用计数</p></li></ul>
<p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
<ul><li><p>标记清除</p></li></ul>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（<strong>闭包</strong>）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<h4>柯里化函数</h4>
<p>所谓的柯里化函数简单的说就是将本来接受多个参数的函数变为只接受一个参数的函数。柯里化函数的模板和实例如下：</p>
<pre><code class=""javascript"">var currying = function(fun) {
      //格式化arguments
    var args = Array.prototype.slice.call(arguments, 1);
      return function() {
          //收集所有的参数在同一个数组中，进行计算
          var _args = args.concat(Array.prototype.slice.call(arguments));
          return fun.apply(null, _args);
      };
}
var add = currying(function() {
    var args = Array.prototype.slice.call(arguments);
      return args.reduce(function(a, b) {
        return a + b;
    });
})
add(1, 2, 4)
/*
 * 经典面试题
 * 函数参数不定回调函数数目不定
 * 编写函数实现:
 * add(1,2,3,4,5)==15
 * add(1,2)(3,4)(5)==15
 */
function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = [].slice.call(arguments);
    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var adder = function () {
        var _adder = function() {
            [].push.apply(_args, [].slice.call(arguments));
            return _adder;
        };

        // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
        _adder.toString = function () {
            return _args.reduce(function (a, b) {
                return a + b;
            });
        }

        return _adder;
    }
    return adder.apply(null, _args);
}
// 输出结果，可自由组合的参数
console.log(add(1, 2, 3, 4, 5));  // 15
console.log(add(1, 2, 3, 4)(5));  // 15
console.log(add(1)(2)(3)(4)(5));  // 15</code></pre>
<h4>Less常用特性</h4>
<ul>
<li><p>变量(@color = #fff)</p></li>
<li><p>混合(Mixin)</p></li>
<li><p>内置函数(颜色，字符串，类型判断，数学)</p></li>
<li><p>循环</p></li>
<li><p>嵌套</p></li>
<li><p>运算</p></li>
<li><p>导入(@import)</p></li>
</ul>
<h4>ES6常用特性</h4>
<ul>
<li><p>变量定义(let和const,可变与不可变，const定义对象的特殊情况)</p></li>
<li><p>解构赋值</p></li>
<li><p>模板字符串</p></li>
<li><p>数组新API(例：Array.from(),entries(),values(),keys())</p></li>
<li><p>箭头函数(rest参数，扩展运算符，::绑定this)</p></li>
<li><p>Set和Map数据结构(set实例成员值唯一存储key值，map实例存储键值对(key-value))</p></li>
<li><p>Promise对象(前端异步解决方案进化史，generator函数，async函数)</p></li>
<li><p>Class语法糖(super关键字)</p></li>
</ul>
<h4>react中setState的原理</h4>
<p><strong>题目:</strong></p>
<pre><code class=""javascript"">import React from 'react'
class App extends React.Component {
  constructor() {
    super();
    this.state = {
      value: 0
    }
  }
  componentDidMount() {
    this.setState({value: this.state.value + 1});
    console.log(this.state.value);
    this.setState({value: this.state.value + 1});
    console.log(this.state.value);
    this.setState({value: this.state.value + 1});
    console.log(this.state.value);
    setTimeout(() =&gt; {
      this.setState({value: this.state.value + 1});
      console.log(this.state.value);
      this.setState({value: this.state.value + 1});
      console.log(this.state.value);
    }, 0)
  }
}</code></pre>
<p><strong>答案:</strong> 0、0、0、2、3；</p>
<p><strong>分析：</strong></p>
<p>当<code>setState</code>方法调用的时候<code>React</code>就会重新调用<code>render</code>方法来重新渲染组件；<code>setState</code>通过一个队列来更新<code>state</code>,当调用<code>setState</code>方法的时候会将需要更新的state放入这个状态队列中，这个队列会高效的批量更新<code>state</code>;</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009442747"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""setState简化调用栈"" title=""setState简化调用栈""></span></p>
<p>源码地址:<a href=""https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactUpdates.js"" rel=""nofollow noreferrer"">enqueueUpdate</a></p>
<pre><code class=""javascript"">function enqueueUpdate(component) {
  ensureInjected();
  //判断是否处于批量更新模式
  if (!batchingStrategy.isBatchingUpdates) {
    //关键！下面的代码片段是这个方法的源码
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }
  //如果处于批量更新模式，则将这个组件保存在dirtyComponents
  dirtyComponents.push(component);
}</code></pre>
<p>源码地址:<a href=""https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js"" rel=""nofollow noreferrer"">ReactDefaultBatchingStrategy</a></p>
<pre><code class=""javascript"">//batchingStrategy对象
var ReactDefaultBatchingStrategy = {
  //注意默认为false
  isBatchingUpdates: false,
  batchedUpdates: function(callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      //关键！！！事务的理解
      transaction.perform(callback, null, a, b, c, d, e);
    }
  },
};</code></pre>
<p>源码地址：<a href=""https://github.com/facebook/react/blob/401e6f10587b09d4e725763984957cf309dfdc30/src/shared/utils/Transaction.js"" rel=""nofollow noreferrer"">Transaction</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009442748"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""事务流程图"" title=""事务流程图""></span></p>
<p>如图：事务会将所需要执行的方法(图中的anyMethod)使用<code>wrapper</code>封装起来，再通过<code>perform</code>方法执行该方法，但在<code>perform</code>执行之前会先执行所有<code>wrapper</code>中的<code>initialize</code>方法，<code>perform</code>方法执行结束后，再执行所有的<code>close</code>方法；</p>
<pre><code class=""javascript"">var Transaction = require('./Transaction');
// 我们自己定义的
var MyTransaction = function() {  
  //do something
};
Object.assign(MyTransaction.prototype, Transaction.Mixin, {
      //需要自定义一个getTransactionWrappers对象，获取所有需要封装的initialize方法和close方法
      getTransactionWrappers: function() {    
          return [{      
              initialize: function() {        
              console.log('before method perform');      
            },      
              close: function() {        
              console.log('after method perform');      
            }    
        }];  
    };
});
//实例化一个transaction
var transaction = new MyTransaction();
//需要调用的方法
var testMethod = function() {
  console.log('test');
}
transaction.perform(testMethod);
//before method perform
//test
//after method perform</code></pre>
<p>理解题目的关键是，整个组件渲染到DOM中的过程就已经处于一次大的事务中了，因此在<code>componentDidMount</code>方法中调用<code>setState</code>的时候<code> ReactDefaultBatchingStrategy.isBatchingUpdates = true;</code>这句代码已经执行过了，所以<code>setState</code>的结果并没有立即生效，而是扔进了<code>dirtyComponent</code>;因此执行三次setState的结果this.state.value的值依然是0,而setTimeout中的两次setState由于没有调用过<code>batchedUpdates</code>方法(<code>isBatchingUpdates</code>默认为<code>false</code>)，所以<code>setState</code>方法立即生效，第二次<code>setSState</code>同理</p>
<h4>XSS与CSRF介绍</h4>
<p>XSS是一种跨站脚本攻击，是属于代码注入的一种，攻击者通过将代码注入网页中，其他用户看到会受到影响(代码内容有请求外部服务器);</p>
<p>CSRF是一种跨站请求伪造，冒充用户发起请求，完成一些违背用户请求的行为(删帖，改密码，发邮件，发帖等)</p>
<p>防御方法举例:</p>
<ol>
<li><p>对一些关键字和特殊字符进行过滤(&lt;&gt;,?,script等)，或对用户输入内容进行URL编码(encodeURIComponent);</p></li>
<li><p>Cookie不要存放用户名和密码，对cookie信息进行MD5等算法散列存放，必要时可以将IP和cookie绑定;</p></li>
</ol>
<h2>后记</h2>
<p>时隔三个月，终于迎来了博文的更新，有看到博友在评论留言：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000009442749?w=1140&amp;h=132"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>心里很温暖，这篇不算博文的博文就当是回归之作吧，接下来的时间会尽量保持在一周一更，实习结束有的是时间了，哈哈哈。</p>

                ", 我的前端进阶之路,1531977845,505,1,818,1,1,https://segmentfault.com/a/1190000009442744
132,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009341335?w=1240&amp;h=403"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>共 1926 字，读完需 4 分钟。所有工程师都知道，代码是编写一次，修改很多次，然后阅读更多次，代码可读性的重要程度不言而喻，但是在项目演进过程中有个很重要的记录也是会读很多次的，那就是 Git 的提交日志，而提交日志里面信息量最大的应该是 commit message，本文灵感来自 Linux 作者 <a href=""https://github.com/torvalds"" rel=""nofollow noreferrer"">Linus Torvalds</a> 在 GitHub 上对 commit mesage 的<a href=""https://github.com/torvalds/linux/pull/17#issuecomment-5659933"" rel=""nofollow noreferrer"">吐槽</a>。</p></blockquote>
<h2>Git Log 之痛</h2>
<p>在《The Art of Readable Code》这本经典书中，有个形象的比喻，衡量代码可读性的指标是阅读代码时每分钟的 WTF 次数，而在读 Git 提交历史的时候，不知道你有多少次爆粗口？不相信？你现在打开公司演进最快的项目，执行 <code>git log</code>，信息量过少甚至是误导的 <code>commit message</code> 非常常见，比如：</p>
<pre><code>fix     =&gt; 这到底是 fix 什么？为什么 fix？怎么 fix 的？
update  =&gt; 更新了什么？是为了解决什么问题？
test    =&gt; 这个最让人崩溃，难道是为了测试？至于为了测试而去提交一次代码么？</code></pre>
<p>说不定，你在这种 commit message 中也贡献了一份力量呢。</p>
<h2>正视问题</h2>
<p>我们先放下 Git 提交日志来看看典型的后端日志记录，如下面这则 <code>access log</code>：</p>
<pre><code>remote_addr=[127.0.0.1] http_x_forward=[-] time=[19/Apr/2017:07:28:13 +0800] request=[GET /admin/edu/exam_scores/index/225 HTTP/1.1] status=[200] byte=[15745] elapsed=[0.309] refer=[http://stu.youcaiedu.com/admin/edu/contests] body=[-] ua=[Mozilla/5.0 （Macintosh; Intel Mac OS X 10_12_4） AppleWebKit/537.36 （KHTML, like Gecko） Chrome/57.0.2987.133 Safari/537.36] cookie=[JSESSIONID=aaaXlJyT6Ju-K-FbLuWPv; pgv_pvi=7986424832; pgv_si=s905561088; easycms=a16pbumhusksq3vpcogcv2n715; toolbarDisplay=hide; _ga=GA1.2.1604145244.1486802034] gzip=[7.71]</code></pre>
<p>好的 <code>access log</code> 包含了哪些要素呢？</p>
<ul>
<li><p>用户请求的时间（time）；</p></li>
<li><p>用户请求的地址（request）、从何而来（refer）；</p></li>
<li><p>用户来源（remote_addr）；</p></li>
<li><p>服务端响应（status, byte, elapsed）；</p></li>
<li><p>...</p></li>
</ul>
<p>回忆下小学的知识，如何准确的描述一次事件？对，就是 <code>5W1H</code> 法则，具体说就是谁（who）在什么时候（when）、什么地点（where）因为什么（why）而做了什么事情（what），他是怎么做的（how），<code>access log</code> 是典型的事件日志，所以 <code>access log</code> 的记录完全可以参照 <code>5W1H</code> 方法去记录，你后来翻看的时候也不会错过细节。</p>
<p>回到正题，Git Log 本质上不也是事件日志么？必然是线上出了问题、产品提出了需求、工程师自己做了重构或技术改进才会导致它的变迁。如果没有详尽记录每次变迁的细节，代码 Review 的人怎么知道你做了什么？上线后遇到问题怎么去追溯？新人接手代码怎么去理解？</p>
<h2>解决问题</h2>
<p>因为 Git 的特殊性，Git 内核已经能把 <code>5W1H</code> 里面的 who、when 作为 commit 元信息记录下来，而研发活动的 where 明显是不需要记录的，真正需要工程师关注的是 what、why、how，这 3 项重要信息的载体就是 <code>commit message</code>。相信读到这里，你已经明白我想说什么了。</p>
<p>下面提出一种可以帮你写出高可读 commit message 的实践方法，这个方法并非原创，最早的实践来自于<a href=""https://robots.thoughtbot.com/better-commit-messages-with-a-gitmessage-template"" rel=""nofollow noreferrer"">这篇文章</a>。简单来说就是要在 commit message 中记录本次提交的 what、why、how，那么怎么把这个想法集成到你的开发工作流里面呢？可以参考下面的步骤来完成：</p>
<h3>1. 设置 .gitmessage 模板</h3>
<p>这是 Git 内置就支持的，你可以为每次提交的 commit message 设置一个模板，每次提交的时候都能促使你遵循这个思考的模式去编写 commit message，比如下面是我的模板，存放在 <code>~/.gitmessage</code>：</p>
<pre><code>What: 简短的描述干了什么

Why:

* 我为什么要这么做？

How:

* 我是怎么做的？这么做会有什么副作用？</code></pre>
<h3>2. 让模板生效</h3>
<p>在全局 Git 配置 <code>~/.gitconfig</code> 中添加如下配置：</p>
<pre><code>[commit]
  template = ~/.gitmessage</code></pre>
<h3>3. 拥抱新模板</h3>
<p>配置好模板之后，你要放弃在提交时直接指定 <code>commit message</code> 的习惯做法，即下面这种提交方式：</p>
<pre><code>git commit -m ""&lt;commit message here&gt;""</code></pre>
<p>因为这种提交方式是不会弹出模板来让你填写的，你提交的命令应该改成：</p>
<pre><code>git commit</code></pre>
<p>具体的操作过程见下面的动图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009341336?w=460&amp;h=302"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如同阿米尔汗在给他女儿做摔跤战术指导时说的话：拿五分很难，但不是没有可能。习惯的养成定不容易，但是是可行的，如果你认识到这点，离习惯养成已经很近了。</p>
<h3>4. 给用 Vim 的同学</h3>
<p>为了更好的 commit message 阅读者体验，可能你需要考虑给 <code>commit message</code> 里面的内容自动换行，让内容控制在轻松能看到的宽度之内，使用 Vim 的同学可以在你的 <code>~/.vimrc</code> 里面增加下面的配置：</p>
<pre><code>autocmd Filetype gitcommit setlocal spell textwidth=80</code></pre>
<h3>5. 最重要的是内容</h3>
<p>写出高可读的 <code>commit message</code> 需要你对每次提交的改动做认真深入的思考，认真回答上面提到的几个问题：</p>
<ul>
<li><p>What: 简短的描述这次的改动</p></li>
<li><p>Why：为什么修改？就是要说明这次改动的必要性，可以是需求来源，任务卡的链接，或者其他相关的资料；</p></li>
<li><p>How: 做了什么修改？需要说明的是使用了什么方法（比如数据结构、算法）来解决了哪个问题；</p></li>
</ul>
<p>此外，还有个非常重要的点就是本次修改的副作用可能有什么，因为工程就是不断在做权衡，本次修改为以后留下了什么坑？还需要什么工作？都可以记录在 <code>commit message</code> 中。</p>
<p>从本质上来说，上面只是你思考问题的框架和记录内容的形式，真正重要的是你要仔细思考的那几个问题，因为一定程度上，<code>commit message</code> 就是文档，活的文档，记录了仓库的所有变迁。</p>
<h2>总结</h2>
<p>怎么让你的代码可以追溯也是优秀工程师必备的素质，相信读到这里，你对如何写出高可读的 <code>commit message</code> 的原因、好处、方法有了清晰的认识，纸上得来终觉浅，绝知此事要躬行，接下来你就需要把这种方法运用到实际工作中，相信我，你的同事发现之后会开始感激你、效仿你。</p>
<h2>One More Thing</h2>
<p>本文作者王仕军，商业转载请联系作者获得授权，非商业转载请注明出处。如果你觉得本文对你有帮助，请点赞！如果对文中的内容有任何疑问，欢迎留言讨论。想知道我接下来会写些什么？欢迎订阅我的<a href=""https://juejin.im/user/57a7f634d342d300576b738d"" rel=""nofollow noreferrer"">掘金专栏</a>或<a href=""https://zhuanlan.zhihu.com/feweekly"" rel=""nofollow noreferrer"">知乎专栏</a>：《前端周刊：让你在前端领域跟上时代的脚步》。</p>

                ", 使用 &quot;5W1H&quot; 写出高可读的 Git Commit Message,1531977847,511,1,973,1,1,https://segmentfault.com/a/1190000009341332
133,1,0,7,"
                    
<h1>协作流程</h1>
<h2>1.职责</h2>
<h3>页面工程师</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVM3pR?w=382&amp;h=96"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>前端工程师</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVM3pM?w=533&amp;h=192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h1>接口设计</h1>
<p><span class=""img-wrap""><img data-src=""/img/bVNhwa?w=855&amp;h=274"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""三种接口"" title=""三种接口""></span></p>
<h2>1.页面入口规范</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVM3B5?w=853&amp;h=407"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""页面入口规范"" title=""页面入口规范""></span></p>
<p>基本信息</p>
<h3>输入参数</h3>
<p>模板列表<br>接口列表</p>
<h2>2.同步数据规范</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVM3B7?w=861&amp;h=384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>基本信息</p>
<p>预填数据</p>
<p>注入接口</p>
<h2>3.异步接口规范</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVM3B7?w=861&amp;h=384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>基本信息</p>
<p>输入数据</p>
<p>输出结果</p>
<h2>同步请求，异步请求？</h2>
<h1>版本管理</h1>
<p>版本控制系统<code>VCS</code> （Version control system）</p>
<h2>1.分支模型</h2>
<p>产品级的分支模型：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVM3Dh?w=823&amp;h=351"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>2.git</h2>
<p>git是一个<strong>基于内容寻址</strong>的存储系统。基于<strong>文件内容</strong>，而不是基于文件。</p>
<p>安装</p>
<blockquote>
<p>Windows: msysgit <a href=""http://msysgit.github.io"" rel=""nofollow noreferrer"">http://msysgit.github.io</a></p>
<p>Mac: brew install git</p>
<p>Ubuntu: apt-get install git</p>
</blockquote>
<h3>git基础操作</h3>
<h4>1.<code>git config</code>
</h4>
<p>用户配置：</p>
<pre><code>git config --global user.name ""Darcy""
git config --global user.name text.example.com</code></pre>
<p>配置级别：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVM3Ej?w=840&amp;h=145"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h4>2.<code>git init</code>
</h4>
<p>初始化之后会出现一个.git/目录，下面存储着包括config文件在内的几乎所有git相关文件。</p>
<h4>3.<code>git status</code>
</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVM3EF?w=323&amp;h=150"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVM3ES?w=870&amp;h=413"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>跟踪：track</p>
<h4>4.<code>git add</code>
</h4>
<p>添加文件内容到<code>暂存区</code>，同时文件被<code>跟踪</code>。</p>
<p>批量添加： <code>git add .</code> 添加当前目录所有文件</p>
<h4>5.<code>.gitignore</code>
</h4>
<p>如果有不希望跟踪的文件，那么需要配置忽略文件。</p>
<p>仅作用于未跟踪的文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVM3Fm?w=435&amp;h=409"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>gitignore常见配置：<a href=""https://github.com/github/gitignore"" rel=""nofollow noreferrer"">github中的示例</a></p>
<h4>6.<code>git rm</code>
</h4>
<p>从<code>暂存区</code>删除文件。</p>
<ul>
<li><p><code>git rm --cached</code> 仅仅从暂存区删除</p></li>
<li><p><code>git rm</code> 同时从暂存区和工作目录删除</p></li>
<li><p><code>git rm $(git ls-files --deleted)</code> 删除所有被跟踪，但是在工作目录被删除的文件</p></li>
</ul>
<h4>7.<code>git commit</code>
</h4>
<p>提交。</p>
<ul>
<li><p><code>git commit -m ""initial commit""</code></p></li>
<li><p><code>git commit -a -m ""initial commit""</code> 直接提交</p></li>
</ul>
<h4>8.<code>git log</code>
</h4>
<p>提交历史记录。</p>
<ul>
<li><p><code>git log</code></p></li>
<li><p><code>git log --oneline</code> 只有7位hash和提交时输入的commit message</p></li>
<li><p><code>git log --color --graph --pretty=format:(此处省略2行)</code> 更美观，且有分支链</p></li>
</ul>
<p>上面的命令太长了，不可能每次都这样输入，因此需要配置别名<code>alias</code>。</p>
<ul>
<li><p>语法：<code>git config --global alias.shortname &lt;full command&gt; </code></p></li>
<li><p>例子：<code>git config --global alias.lg ""log --color --graph --pretty=format:(此处省略2行)"" </code><br>  这样就可以用 <code>git lg</code> 来表示上面那行命令了。</p></li>
</ul>
<p>别名其实也存储在gitcofig文件中</p>
<h4>9.<code>git diff</code>
</h4>
<p>显示版本差异。</p>
<ul>
<li><p><code>git diff</code> 工作目录与暂存区的差异</p></li>
<li><p><code>git diff -cached[&lt;reference&gt;]</code> 暂存区与某次提交的差异，默认是&lt;HEAD&gt;，&lt;HEAD&gt;指向当前的提交</p></li>
<li><p><code>git diff [&lt;reference&gt;]</code> 工作目录与某次提交的差异</p></li>
</ul>
<h4>10.<code>git checkout --&lt;file&gt;</code>
</h4>
<p><strong>撤销本地修改。</strong></p>
<p>即：将工作内容从暂存区复制到工作目录。</p>
<h4>11.<code>git reset HEAD &lt;file&gt;</code>
</h4>
<p><strong>取消暂存。</strong></p>
<p>即：将文件内容从上次提交复制到暂存区。</p>
<h4>12.<code>git checkout HEAD --&lt;file&gt;</code>
</h4>
<p><strong>撤销全部改动</strong>：取消暂存 + 撤销本地修改。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVM3Jk?w=912&amp;h=451"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>git分支操作</h3>
<h4>13.<code>git branch</code>
</h4>
<ul>
<li><p><code>git branch &lt;branch-name&gt;</code> 新建分支</p></li>
<li><p><code>git branch -d &lt;branch-name&gt;</code> 删除指定分支</p></li>
<li><p><code>git branch -v</code> 显示所有分支信息</p></li>
</ul>
<h4>14.<code>git checkout</code>
</h4>
<p>通过移动HEAD检出版本，可用于分支切换。</p>
<ul>
<li><p><code>git checkout &lt;branch-name&gt;</code> 切换分支</p></li>
<li><p><code>git checkout -b &lt;branch-name&gt;</code> 新建一个分支并切换到新分支</p></li>
<li><p><code>git checkout -b &lt;reference&gt;</code> 切换到其他引用对象，比如 <code>commit id</code> 或 标签</p></li>
<li><p><code>git checkout -</code> 回到上一个分支（把HEAD移动到上一个分支）</p></li>
</ul>
<h4>15.<code>git reset</code>
</h4>
<p>将当前分支恢复到某个历史版本。以下三种模式的主要区别是内容是否会恢复到工作目录和暂存区。</p>
<ul>
<li><p><code>git reset --mixed e33e42</code> --mixed是默认参数，不写也行，当前内容（即原来的提交）会被复制到暂存区</p></li>
<li><p><code>git reset --hard e33e42</code> --hard 时，当前内容（即原来的提交）会被复制到暂存区和工作目录</p></li>
<li><p><code>git reset --soft e33e42</code> --soft时，暂存区和工作目录都不会有任何改变，原来的提交变成了一个无索引的提交，有可能会被回收，可以用 <code>git reflog</code> 找回来</p></li>
<li><p>捷径：<code>git reset HEAD^/HEAD~1/HEAD~n</code> HEAD的上一次提交，前第n次提交</p></li>
</ul>
<h4>区分<code>reset</code> 与 <code>checkout</code> 在操作<strong>分支</strong>与操作<strong>文件</strong>时的不同</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVM7ps?w=885&amp;h=375"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h4>16.<code>git stash</code>
</h4>
<p>我们在<code>git checkout</code>切换分支的时候，经常会被提示“当前有未提交的内容，请<code>commit</code>或<code>stash</code>”，而我们通常是写到一半不希望commit的，所以这时就需要<code>git stash</code>。</p>
<p>作用是：保存目前的工作目录和暂存区状态，返回一个干净的工作空间。</p>
<ul>
<li><p><code>git stash save 'push to stash area'</code> 第一步：保存</p></li>
<li><p><code>git stash list </code> 第二步：查看已有列表 会显示：<code>stash@{0}: On master: push to stash area</code></p></li>
<li><p><code>git stash apply stash@{0}</code> 第三步：把保存的内容恢复到工作目录</p></li>
<li><p><code>git stash drop stash@{0}</code> 第四步：把对应的stash命令删除掉</p></li>
<li><p><code>git stash pop stash@{0}</code> 捷径：第三步+第四步</p></li>
</ul>
<h4>17.<code>git merge</code>
</h4>
<p>假定当前在<code>master</code>分支。</p>
<ul><li><p><code>git merge next</code> 合并 next 分支的内容到master分支</p></li></ul>
<p>如有冲突，会是下面这样：</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD

next 

=======

origin/master

&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</code></pre>
<p>====上面指当前分支的提交，下面是要merge过来的分支的提交内容。</p>
<h4>18.<code>git rebase</code>
</h4>
<p>修剪提交历史的基线，俗称“变基”。</p>
<ul><li><p><code>git rebase master</code></p></li></ul>
<p>不要在共有分支使用rebase。</p>
<h4>19.<code>git tag</code>
</h4>
<p>标签，一个不变的别名。用于标记某次发布。指向一个commit对象。</p>
<ul><li><p><code>git tag v0.1 e39d0b2</code></p></li></ul>
<p>打完标签之后，可以直接使用标签名切换分支： <code>git checkout v0.1</code></p>
<h3>git远程操作</h3>
<h4>20.<code>git push</code>
</h4>
<p>提交本地历史到远程。</p>
<h4>21.<code>git remote</code>
</h4>
<ul>
<li><p><code>git remote add origin ~/git-server</code> 添加一个远程仓库别名origin</p></li>
<li><p><code>git remote -v</code> 查看远程仓库信息</p></li>
</ul>
<h4>22.<code>git fetch</code>
</h4>
<p>获取远程仓库的提交历史。</p>
<ul>
<li><p><code>git fetch origin/master</code></p></li>
<li><p><code>git merge origin/master</code></p></li>
</ul>
<h4>23.<code>git pull</code>
</h4>
<ul>
<li><p><code>git pull &lt;remote&gt; &lt;branch&gt;</code></p></li>
<li><p>=<code>git fetch + git merge</code></p></li>
</ul>
<h4>23.<code>git clone</code>
</h4>
<p>获取一个远程仓库作为本地仓库。</p>
<ul><li><p><code>git clone ~/git-server test2</code> 会克隆远程仓库到 test2目录下</p></li></ul>
<h1>技术选型</h1>
<h2>模块化（JS）</h2>
<h3>一、模块</h3>
<h3>1.模块的职责：</h3>
<ul>
<li><p>封装实现</p></li>
<li><p>暴露接口</p></li>
<li><p>声明依赖</p></li>
</ul>
<h3>2.第一步：没有应用任何模块系统（反模式 Anti-Pattern）</h3>
<p>math模块：</p>
<pre><code>//math.js
function add(a, b) {
  return a + b;
}
function sub(a, b) {
  return a - b;
}
</code></pre>
<p>caculator模块：</p>
<pre><code>//caculator.js
var action = ""add"";

function compute(a, b){
  switch(action){
    case ""add"": return add(a, b);
    case ""sub"": return sub(a, b);
  }
}</code></pre>
<p>可以看出 <code>caculator</code>模块是依赖<code>math</code>模块的。</p>
<h4>
<code>math</code>模块特点：</h4>
<ol>
<li><p><strong>无封装性</strong>：变量全部散落在全局里。</p></li>
<li><p><strong>接口结构不明显</strong>：如果我们没有简化代码，那么<strong>并不能清楚的知道<code>math</code>到底输出了哪些接口</strong>。</p></li>
</ol>
<h4>
<code>caculator</code>模块特点：</h4>
<ol>
<li><p><strong>没有依赖声明</strong>：依赖了math模块但是却没有声明。</p></li>
<li><p><strong>使用全局状态</strong>：使用了action这个全局状态，应该尽量避免。</p></li>
</ol>
<h3>3.第二步：使用字面量（Object Literal）优化</h3>
<p>math模块：</p>
<pre><code>//math.js
var math = {
  add: function add(a, b) {
    return a + b;
  }
  sub: function sub(a, b) {
    return a - b;
  }
}</code></pre>
<p>caculator模块：</p>
<pre><code>//caculator.js
var caculator = {
  action: ""add"",
  compute: function compute(a, b){
    switch(action){
      case ""add"": return add(a, b);
      case ""sub"": return sub(a, b);
    }
  }
}</code></pre>
<h4>
<code>math</code>模块特点：</h4>
<ol>
<li><p><strong>结构性好</strong>：用字面量把接口进行了结构化。</p></li>
<li><p><strong>访问控制差</strong>：依然没有进行控制。</p></li>
</ol>
<h4>
<code>caculator</code>模块特点：</h4>
<ol>
<li><p><strong>依然没有依赖声明</strong>：依赖了math模块但是却没有声明。</p></li>
<li><p><strong>无法设置私有属性</strong>：<code>action</code>虽然是成员属性，但在外部依然可以访问到。</p></li>
</ol>
<h3>4.第三步：使用立即执行的函数表达式<code>IIFE</code>（Immediately-invoked Function Expression）解决<code>无法设置私有属性</code>的问题。</h3>
<p>caculator模块：</p>
<pre><code>//caculator.js
var caculator = (function(){
  var action = ""add"";
  return {
    compute: function compute(a, b){
      switch(action){
        case ""add"": 
          return math.add(a, b);
        case ""sub"": 
          return math.sub(a, b);
      }
    }
  }
})();</code></pre>
<h4>
<code>caculator</code>模块特点：</h4>
<ol>
<li><p><strong>依然依然没有依赖声明</strong>：依赖了math模块但是却没有声明。</p></li>
<li><p><strong>有了私有属性</strong>：<code>action</code>是我们要的私有属性，<code>compute</code>函数可以访问到，而且在<code>caculator</code>外面无法访问到。</p></li>
</ol>
<h3>5.第四步：增加依赖声明</h3>
<p>caculator模块：</p>
<pre><code>//caculator.js
var caculator = (function(m){
  var action = ""add"";
  function compute(a, b){
    switch(action){
      case ""add"": 
        return m.add(a, b);
      case ""sub"": 
        return m.sub(a, b);
    }
  }
  return {
    compute: conpute
  }
})(math);</code></pre>
<h4>
<code>caculator</code>模块特点：</h4>
<ol>
<li><p><strong>显示了依赖声明</strong>：把math模块作为参数传了进去，并且可以对形参进行命名，这里命名为<code>m</code>。</p></li>
<li><p><strong>math模块仍然污染了全局变量</strong>。</p></li>
<li><p><strong>必须手动进行依赖管理</strong>：math模块是手动传进去的，必须手动保证math是在这之前就被加载了。</p></li>
<li><p>注意<code>return</code>的部分与原来不一样了：学名叫 <strong>揭露模块模式</strong><code>review module pattern</code>，优点是<strong>在暴露的模块进行增删查改的时候会非常方便</strong>。</p></li>
</ol>
<h3>6.第五步：使用命名空间（name space）解决污染全局空间的问题</h3>
<p>帮助我们只暴露一个类似于<code>namespace</code>的全局变量。而不是将<code>math</code>这样的模块都注册在全局作用域中。</p>
<p>math模块：</p>
<pre><code>//math.js
namespace(""math"", [], function(){
  function add(a, b) {
    return a + b;
  }
  function sub(a, b) {
    return a - b;
  }
  return {
    add: add,
    sub: sub
  }
})
//第一个参数为模块声明，第二个参数为依赖的模块，第三个参数为模块的构成</code></pre>
<p>caculator模块：</p>
<pre><code>//caculator.js
namespace(""caculator"", [""math""], function(m){
  var action = ""add"";
  function compute(a, b){
    return m[action](a, b);
  }
  return {
    compute: compute
  }
}</code></pre>
<p>依赖是统一注册在某个地方，而不是全局中的一个变量。</p>
<p>namespace的实现：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVNfC6?w=493&amp;h=409"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><code>cache</code>中缓存了所有的模块。<br>实际返回的是<code>createModule</code>这个函数，参数包括：模块名，依赖的模块，当前模块的实现。<br>如果只传入了一个参数，就返回这个模块<code>cache[name]</code>。<br>取得所有依赖的模块<code>deps</code>，即保证前面的模块都已经被定义好了，这样当前模块（这里为<code>caculator</code>模块）才能运行。<br>最后初始化模并返回定义的模块<code>cache[name]</code>。</p>
<h4>该方法特点：</h4>
<ol>
<li><p><strong>不再污染全局环境</strong>：把模块都定义在一个<code>namespace</code>变量中。</p></li>
<li><p><strong>没有依赖管理</strong>：依然是我们手动进行依赖管理。</p></li>
</ol>
<h4>依赖管理（dependency manage）</h4>
<p>如果这些模块分散在不同的文件中，我们在用的时候就要对引入的脚本顺序进行手动排序。<br>比如 module2.js中依赖了module1.js，那么写的时候就要先写module.js，像这样：</p>
<pre><code>&lt;body&gt;
  &lt;script src=""module1.js""&gt;&lt;/script&gt;
  &lt;script src=""module2.js""&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>但是我们在实际开发过程中的依赖总是很复杂。那是一条又长又复杂的依赖链。非要人肉分析是会抓狂的。而这其实是<strong>模块系统</strong>的工作。</p>
<h3>二、模块系统</h3>
<h3>1.模块系统的职责</h3>
<ul>
<li><p>依赖管理（加载 / 注入 / 分析 / 初始化）</p></li>
<li><p>决定模块写法</p></li>
</ul>
<h3>2.CommonJS</h3>
<pre><code>//main.js
function add(a, b){
  return a + b;
}
function sub(a, b){
  return a - b;
}
exports.add = add
exports.sub = sub</code></pre>
<p>比原来的写法多了接口暴露：<code>exports.add = add</code> <code>exports.sub = sub</code></p>
<pre><code>//caculator.js
var math = require(""./math"");

function Caculator(container){
  //...
}

exports.Caculator = Caculator</code></pre>
<p>比原来的写法多了依赖声明： <code>var math = require(""./math"");</code> 和 接口暴露：<code>exports.Caculator = Caculator</code>。</p>
<p>优点：</p>
<ul>
<li><p>运行时支持，模块定义非常简单：只是利用了几个全局变量<code>exports, module, require</code>。</p></li>
<li><p>文件级别的模块作用域隔离：这几个全局变量的作用域都是文件级别的，虽然JS没有文件级别的作用域，但我们对它进行了封装，使得使用时一个文件有一个作用域，它们使用起来非常安全。</p></li>
<li><p>可以处理循环依赖。</p></li>
</ul>
<p>缺点：</p>
<ul>
<li><p>不是标准组织的规范。</p></li>
<li><p>同步的require，没有考虑浏览器环境。而我们的浏览器文件加载是一个异步的过程，这是最大的问题，这是否就意味着我们的浏览器没办法使用了呢？当然不是。现在有很多工具比如<code>browserify</code>，比如<code>webpack</code>，可以帮助我们把多个文件级别的模块打包成一个文件，这样我们引入单个文件就可以在浏览器里使用了。</p></li>
</ul>
<p>因为CommonJS天然的不适合异步环境，所以出现了天然异步的AMD（Asynchronous Module Definition）</p>
<h3>3.AMD</h3>
<p>与我们前面的namespace非常像。</p>
<pre><code>//main.js
define([], function(){
  function add(a, b){
    return a + b;
  }
  function sub(a, b){
    return a - b;
  }
  return {
    add: add,
    sub: sub
  }
})</code></pre>
<p>比原来的写法多了包裹函数：<code>define</code>，第一个参数为依赖的模块列表，第二个参数为当前模块的实现。</p>
<pre><code>//caculator.js
define([""./math""], function(math){
  function Caculator(container){
    //...
  }
  return {
    Caculator: Caculator
  }
}</code></pre>
<p>同时AMD还支持一个简单的CommonJS写法，只不过要用一层函数包裹起来<code>define(function(require, exports){ ... })</code>。</p>
<p>优点：</p>
<ul>
<li><p>专为异步I/O环境打造，适合浏览器环境。</p></li>
<li><p>支持类似CommonJS的书写方式。</p></li>
<li><p>通过插件支持可以加载非JS资源。</p></li>
<li><p>成熟的打包构建工具，并可结合插件实现一些预处理的工作。</p></li>
</ul>
<p>缺点：</p>
<ul>
<li><p>模块定义繁琐，需要额外的函数嵌套。</p></li>
<li><p>只是库级别的支持，需要引入额外的库，比如requireJS。</p></li>
<li><p>无法处理循环依赖。</p></li>
<li><p>无法实现条件加载，因为只是库级别的。</p></li>
</ul>
<h3>4.原生JS语言级别支持的模块化标准ES6 Module（Javascript module definition for future）</h3>
<pre><code>//main.js
function add(a, b){
  return a + b;
}
function sub(a, b){
  return a - b;
}
export { add, sub }</code></pre>
<p>比原来的写法多了接口暴露：<code>export {add, sub}</code></p>
<pre><code>//caculator.js
import { math } from './math';

function Caculator(container){
  //...
}

export { Caculator }</code></pre>
<p>比原来的写法多了依赖声明： <code>import { math } from './math';</code> 和 接口暴露：<code>export { Caculator }</code>。</p>
<p>优点：</p>
<ul>
<li><p>真正官方的规范，未来的趋势。</p></li>
<li><p>语言级别的支持。</p></li>
<li><p>适应所有的JavaScript运行时环境，包括浏览器。</p></li>
<li><p>可以处理循环依赖。</p></li>
</ul>
<h2>框架（JS框架）</h2>
<h3>什么是库和框架</h3>
<h4>库</h4>
<ul>
<li><p>针对特定问题的解答，就有专业性</p></li>
<li><p>不控制应用程序的流程</p></li>
<li><p>被动的被调用</p></li>
</ul>
<p>比如，一个DatePicker时间选择器是一个库，一个Backbone.view是一个框架。</p>
<h4>框架</h4>
<ul>
<li><p><strong>控制反转 Inverse of control</strong> &lt;···主要区别</p></li>
<li><p>决定应用程序生命周期</p></li>
<li><p>一般会集成大量的库</p></li>
</ul>
<p>下面这个图很好的解释了<strong>控制反转</strong>：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVNfST?w=641&amp;h=278"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>框架决定了什么时候调用库，什么时候要求你的代码去实现某些功能。</p>
<p>框架和库，他们都是解决方案。关于解决方案，分为7各方面：</p>
<ul>
<li><p>DOM</p></li>
<li><p>communication 通信</p></li>
<li><p>Utility 工具库</p></li>
<li><p>Template 模板技术</p></li>
<li><p>Component 组件</p></li>
<li><p>Route 路由</p></li>
<li><p>Architecture MV*架构</p></li>
</ul>
<h3>1.DOM解决方案</h3>
<h4>重点：Selector / Manipulation(<em>操作</em>) / Event(dom) / Animation</h4>
<ol>
<li><p>jQuery</p></li>
<li><p>zepto.JS</p></li>
<li><p>Mootools</p></li>
<li><p>手势支持：Hammer.js</p></li>
<li><p>局部滚动：iScroll.js</p></li>
<li><p>高级动画：Velocity.js</p></li>
<li><p>视频播放：video.js</p></li>
</ol>
<h3>2.Communication(通信)解决方案</h3>
<h4>重点：XMLHttpRequest / Form / JSONP / Socket</h4>
<h4>作用：</h4>
<ul>
<li><p>处理与服务器的请求与响应</p></li>
<li><p>预处理请求数据/响应数据 &amp; Error/Success的判断封装</p></li>
<li><p>多种类型请求，统一接口</p></li>
<li><p>处理浏览器兼容性</p></li>
</ul>
<ol>
<li><p>jQuery</p></li>
<li><p>zepto.JS</p></li>
<li><p>Reqwest</p></li>
<li><p>qwest</p></li>
</ol>
<p>以上都是异步的请求，但对于实时性要求非常高的产品比如im聊天工具，就需要立即响应。这时需要用websocket。推荐下面的库：</p>
<ol><li><p>socket.io</p></li></ol>
<h3>3.Utility(工具包)解决方案</h3>
<h4>重点：函数增强 &amp; shim / Flow Control</h4>
<h4>职责：</h4>
<ul>
<li><p>提供JS原生不提供的功能</p></li>
<li><p>方法门面包装，使其易于使用。即shim（语言垫片），保证实现与规范一致。</p></li>
<li><p>异步队列 / 流程控制 比如promise</p></li>
</ul>
<h3>3.Template</h3>
<h4>三种类型：String-based / Dom-based / Living Template</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVNfZ1?w=918&amp;h=432"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>4.Component组件</h3>
<h4>常用组件： Modal / Slider / DatePicker / Tabs / Editor</h4>
<ol>
<li><p>Bootstrap</p></li>
<li><p>Foundation</p></li>
</ol>
<h3>5.Routing路由</h3>
<h4>分类：Client Side / Server Side</h4>
<h4>职责：</h4>
<ul>
<li><p>监听url变化，并通知注册的模块，进行页面切换</p></li>
<li><p>通过Javascript进行主动跳转</p></li>
<li><p>历史管理</p></li>
<li><p>对目标浏览器的兼容性的支持</p></li>
</ul>
<h4>route库</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVNf3J?w=737&amp;h=405"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>6.Architecture架构（目的：解耦）</h3>
<h4>分类：MVC / MVVM / MV*</h4>
<h4>职责：</h4>
<ul>
<li><p>提供一种范式帮助（强制）开发者进行模块解耦</p></li>
<li><p>试图与模型分离</p></li>
<li><p>更容易进行单元测试</p></li>
<li><p>更容易实现应用程序的扩展</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVNf4l?w=903&amp;h=449"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>各种框架比较的参考网站：<br><a href=""http://todomvc.com/"" rel=""nofollow noreferrer"">http://todomvc.com/</a><br><a href=""https://www.javascripting.com/"" rel=""nofollow noreferrer"">https://www.javascripting.com/</a><br><a href=""https://www.javascriptoo.com/"" rel=""nofollow noreferrer"">https://www.javascriptoo.com/</a><br><a href=""http://microjs.com/#"" rel=""nofollow noreferrer"">http://microjs.com/#</a></p>
<h3>7.Component组件</h3>
<h1>开发实践</h1>
<h2>系统设计</h2>
<h3>1.系统说明</h3>
<h3>2.系统分解</h3>
<h3>3.接口设计</h3>
<ul>
<li><p>数据类型（每个页面的每个模块都要单独定义包含的数据类型列表）</p></li>
<li><p>模板资源</p></li>
<li><p>异步接口（请求方式，请求地址，输入参数，输出结果）</p></li>
<li><p>页面摘要</p></li>
</ul>
<h3>4.工程构建</h3>
<ul>
<li><p>项目结构</p></li>
<li><p>初始代码</p></li>
<li><p>模拟数据</p></li>
</ul>
<h2>系统实现</h2>
<h3>1.组件封装</h3>
<ul>
<li><p>通用原件（logo，输入框，图标，按钮，翻页，复选框列表，loading）</p></li>
<li><p>通用列表（歌单。歌手，收藏的节目）</p></li>
<li><p>复合组件（比如评论）</p></li>
<li><p>浮层弹窗</p></li>
</ul>
<p>一个组件（BannerSlifer）的栗子：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVNgud?w=367&amp;h=407"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>2.逻辑实现</h3>
<h2>测试发布</h2>
<h3>1.测试联调</h3>
<ol>
<li><p>本地测试</p></li>
<li><p>异步测试</p></li>
<li><p>对接联调</p></li>
</ol>
<h3>2.发布上线</h3>
<ol>
<li><p>打包发布</p></li>
<li><p>优化配置</p></li>
</ol>

                ", 前端架构（git、模块化）,1531977848,600,1,440,1,1,https://segmentfault.com/a/1190000009341189
134,1,0,7,"
                    
<h1>git常用操作</h1>
<h2>第一次连接远程仓库的配置</h2>
<h3>配置user.name 和user.email</h3>
<blockquote><ul>
<li><p><code>git config --global user.name ""name""</code>    设置你的用户名</p></li>
<li><p><code>git config --global user.email ""emil""</code>    设置用户的email账号</p></li>
</ul></blockquote>
<h3>生成密钥</h3>
<blockquote><ul>
<li><p><code>ssh-keygen -t rsa -C ""your email""</code>  其中填的是你的注册的<code>github</code>的账号，输入之后如果不需要输入密码的话，连续输入三个回车即可，最后在你的在终端输入 cd ~/.ssh 进入到你的文件下可以看到有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>,最后复制你的<code>id_rsa.pub</code>中的内容到<code>github</code>中的账号中即可</p></li>
<li><p><code>ssh -T git@github.com</code> 如果上面的步骤已经完成了，那么就是验证是否完成了，输入上述语句，如果出现信息，那么证明说明你已经成功了</p></li>
</ul></blockquote>
<h2>管理修改</h2>
<blockquote><p>通常我们在提交之后会想要修改，当然我们是在文件上直接修改，但是修改后在<code>git</code>上输入<code>git status</code>查看此时的工作区的状态，你会发现出现了出现了如下的语句：</p></blockquote>
<pre><code class=""Git"">On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use ""git push"" to publish your local commits)
Changes not staged for commit:
  (use ""git add &lt;file&gt;..."" to update what will be committed)
  (use ""git checkout -- &lt;file&gt;..."" to discard changes in working directory)

        modified:   file.txt

no changes added to commit (use ""git add"" and/or ""git commit -a"")
</code></pre>
<blockquote>
<p>从上面的提示可以看出我们有如下方案：</p>
<ul><li><p><strong>首先执行-&gt;<code>git add file.txt</code>,然后重新提交<code>git commit -m 'modified file.txt</code></strong></p></li></ul>
</blockquote>
<h2>撤销修改(没有提交的[<code>commit</code>])</h2>
<blockquote><p><em>这里的撤销修改仅仅是对于没有提交的撤销(<code>git commit -m ''</code>),在下面会讲到如何撤销提交后的撤销</em></p></blockquote>
<h3>未<code>git add</code>
</h3>
<blockquote><p>当我们修改后会出现上面的提示，前面已经贴过了，这里就不再贴代码了，根据提示，我们可以<strong><code>git checkout -- file.txt</code>来丢弃工作区的修改</strong>，之后就可以看见先前的修改已经不见了</p></blockquote>
<h3>已经<code>git add</code>
</h3>
<blockquote><p>当我们修改文件后并且<code>git add</code> 添加到暂存区了，那么查看状态<code>git status</code>,出现的提示如下</p></blockquote>
<pre><code class=""Git"">On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use ""git push"" to publish your local commits)
Changes to be committed:
  (use ""git reset HEAD &lt;file&gt;..."" to unstage)

        modified:   file.txt</code></pre>
<blockquote><p>根据上面提示的方法：输入<code>git reset HEAD file.txt</code>,可以看到文件回到<strong>未<code>git add</code></strong>的状态了，这时如果你想要丢弃修改，使用<code>git checkout -- file.txt</code>,之后就可以看到你的修改已经不见了</p></blockquote>
<h2>删除文件</h2>
<blockquote><p>其实删除也是一种修改操作，我们在文件管理器中直接使用<code>rm</code>删除文件，这时输入<code>git status</code>可以看到如下的提示：</p></blockquote>
<pre><code class=""Git"">On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use ""git push"" to publish your local commits)
Changes not staged for commit:
  (use ""git add/rm &lt;file&gt;..."" to update what will be committed)
  (use ""git checkout -- &lt;file&gt;..."" to discard changes in working directory)

        deleted:    file.txt

no changes added to commit (use ""git add"" and/or ""git commit -a"")
PS G:\file&gt; git checkout -- file.txt</code></pre>
<blockquote>
<blockquote>
<ul>
<li><p>如果你<strong>不想删除</strong>了，想要恢复原来的文件，使用<code>git checkout -- file.txt</code> 这个命令可以让<em>撤销修改，也可以撤销删除</em>，起到一键还原的作用</p></li>
<li><p>如果你想要继续删除,那么有两种方法：</p></li>
</ul>
<blockquote><ol>
<li><p><strong>first:</strong><code>git add file.txt</code>,<strong>second:</strong><code>git commit -m ''</code></p></li>
<li><p><strong>first:</strong><code>git rm file.txt</code>,<strong>second:</strong><code>git commit -m ''</code></p></li>
</ol></blockquote>
</blockquote>
<p><strong>注意：</strong> <em><code>git rm file</code> 可以用来删除提交到版本库中的文件，一般删除要执行以下命令：<code>git rm file.txt</code>,<code>git commit -m 'delete'</code>，注意在<code>git commit</code>之前还是可以<strong>取消删除</strong>的，使用<code>git checkout -- file.txt</code>，可以一键取消删除</em></p>
</blockquote>
<h2>创建与合并分支</h2>
<h3>常用命令：</h3>
<blockquote><ul>
<li><p><code>git checkout -b dev</code>   创建并且切换到<code>dev</code>分支</p></li>
<li><p><code>git checkout dev</code> 切换到<code>dev</code>分支</p></li>
<li><p><code>git branch</code>   查看所有的分支，带有<code>*</code>的是当前所处的分支</p></li>
<li><p><code>git branch -d dev</code> 删除<code>dev</code>分支，一般在合并之后删除</p></li>
<li><p><code>git branch -D dev</code>  ：强制删除分支，一般在没有合并就删除分支会出现不能删除，这是就要使用强制删除这个分支的命令</p></li>
<li><p><code>git merge dev</code>    将<code>dev</code>分支合并到当前分支,使用到<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p></li>
<li><p><code>git merge --no-ff -m ""merge with no-ff"" dev</code>    强制禁用<code>Fast forward</code>模式，<code>Git</code>就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p></li>
<li><p><code>git log --graph --pretty=oneline --abbrev-commit</code>  查看分支历史</p></li>
</ul></blockquote>
<h3>创建合并</h3>
<blockquote><ul>
<li><p>首先我们创建一个<code>dev</code>分支,使用命令：<code>git checkout -b dev</code>(创建一个<code>dev</code>分支，并且切换到<code>dev</code>分支上)，我们可以使用<code>git branch</code>查看所有的分支</p></li>
<li><p><em>现在在改变之前<code>master</code>分支上的<code>file.txt</code>文件内容，之后<code>git add file.txt</code>,并且提交到<strong>版本库</strong>中了(<code>git commit -m 'file.txt'</code>)，此时使用<code>git checkout master</code>切换到<code>master</code>分支上，查看<code>file.txt</code>的文件内容，可以看到里面的内容并<strong>没有改变</strong>，由此可知两个分支是<strong>独立</strong>的，如果你在一个分之上创建了文件并且提交到版本库中了，切换到另外一个分支上，此时可以发现原来创建的文件<strong>不见了</strong>，因为那是另外一个分支的文件，当然我们可以<strong>合并分支</strong>，使用<code>git merge dev</code>,这两个命令将<code>dev</code>分支合并到<strong>当前分支</strong></em></p></li>
</ul></blockquote>
<h2>Bug分支管理</h2>
<blockquote>
<p><em>如果正在一个分支上工作，另外一个分支上的程序有一个Bug需要马上修改，但是此时这个分支上的东西还需要很长时间才能完成，这应该怎么办呢？难道要放弃当前分支上的修改吗？当然不是了，幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作，具体步骤如下：</em></p>
<blockquote><ul><li><p>git stash  将当前的工作状态暂时存储在stash中，输出如下信息</p></li></ul></blockquote>
</blockquote>
<pre><code class=""Git"">Saved working directory and index state WIP on dev: 6224937 add merge
HEAD is now at 6224937 add merge</code></pre>
<blockquote><blockquote><ul>
<li><p>此时可以使用<code>git status</code> 查看当前的分支上的状态，可以知道当前的的工作区就是干净的，因此可以放心的修复另外一个分支上的的<code>Bug</code>了</p></li>
<li><p><code>git checkout master</code> 切换分支，修复<code>Bug</code></p></li>
<li><p><code>git checkout dev</code>  修复好Bug继续回到上一个分支干活</p></li>
<li><p><code>git stash list</code> 可以看到工作现场还在，输出如下信息：</p></li>
</ul></blockquote></blockquote>
<pre><code class=""Git"">stash@{0}: WIP on dev: 6224937 add merge</code></pre>
<blockquote><blockquote>
<p><em>如果有多个修改的内容，这里的信息肯定不止一条</em></p>
<ul>
<li><p><code>git stash apply</code>：恢复修改，但是这只是恢复<code>stash</code>的内容并不会删除，这里建议使用<code>git stash pop</code> 既恢复了又删除了<code>stash</code>中内容，注意这里只能恢复一条数据，此时使用<code>git status</code>查看状态，可以看到已经出现修改的内容了</p></li>
<li><p><code> git stash list</code> ：此时查看当前<code>stash</code>中的内容可以看到已经什么都没了，当然这只是清除一条，如果本来有多个，那么还是会有其他内容的</p></li>
</ul>
</blockquote></blockquote>
<h3>常用命令</h3>
<blockquote><ul>
<li><p><code>git stash</code> 将当前的分支上的工作暂存到<code>stash</code>中</p></li>
<li><p><code>git stash list</code> 列出<code>stash</code>中的所有暂存的内容</p></li>
<li><p><code>git stash pop</code> 恢复并且删除stash中的内容</p></li>
<li><p><code>git stash apply</code> 恢复但是步删除<code>stash</code>中的内容</p></li>
</ul></blockquote>
<h2>远程仓库的操作</h2>
<h3>常用的命令</h3>
<blockquote><ul>
<li><p><code>git remote -v</code> 查看远程仓库的详细信息</p></li>
<li><p><code>git remote add remote-name URL</code> 添加远程仓库</p></li>
<li><p><code>git remote rename origin pb</code>   将远程仓库的origin改为pb，此时使用git remote 查看可以知道这里已经没有origin了，变成了pb</p></li>
<li><p><code>git remote rm origin</code>   将远程仓库origin删除</p></li>
<li><p><code>git push origin master</code>   将内容提交到远程仓库origin的master上，当然这里亦可以使用其他的分支</p></li>
<li><p><code>git clone URL</code>      克隆一个远程仓库，这里的URL是远程仓库的地址</p></li>
<li><p><code>git pull origin</code>    将远程仓库中更新的数据拉到本地</p></li>
<li><p><code>git checkout -b branch-name origin/branch-name</code>   在本地创建和远程仓库对应的分支，最好分支的名字相同</p></li>
<li><p><code>git push origin branch-name</code>    推送到远程仓库的分支</p></li>
</ul></blockquote>
<h3>注意</h3>
<blockquote><p><em>同一个文件夹中可以添加很多远程仓库，不过可以在提交的时候需要指定远程仓库的名字，比如在你的文件夹下有origin和pb两个远程仓库，可以使用git remote  -v查看详细的信息，此时你在版本库中已经有想要推送的文件了，那么使用git push origin master就可以指定推送到origin远程仓库中</em></p></blockquote>
<h3>实例</h3>
<blockquote>
<p><em>假如你新建一个文件夹，此时要在里面添加远程仓库，具体实现如下：</em></p>
<blockquote>
<ul>
<li><p><code>git clone URL</code> 将一个仓库克隆来的同时也具有推送的权限了，这时就可以使用<code>git remote add origin URL</code>来添加远程仓库了</p></li>
<li><p>如果没有使用<code>clone</code>的方法创建一个版本库，那么先<code>git init</code> 然后<code>git remote add origin URL</code> 添加远程仓库，之后就是将本地仓库和远程仓库对应了，使用<code>git pull origin master</code> 来拉取远程仓库中内容，当然这也可以分两步，使用如下：</p></li>
</ul>
<blockquote><ol>
<li><p><code>git fetch origin master</code>   这是将远程仓库中的文件拉取到本地，但是没有与本地的<code>master</code>合并，因此本地的<code>master</code>分支不能追踪远程仓库中的分支</p></li>
<li><p><code>git merge origin/master</code>  将远程仓库和本地的<code>master</code>分支合并，那么就可以使用本地的<code>master</code>分支追踪远程仓库了，这就完成了</p></li>
</ol></blockquote>
<ul><li><p>无论<code>clone</code>还是<code>pull</code>都只是拉取远程的<code>master</code>分支，但是一般远程仓库中还有其他的分支，那么怎么办呢？拉取远程仓库的次分支步骤如下：</p></li></ul>
<blockquote><ol><li><p><code>git checkout -b dev origin/dev</code>  拉去远程仓库中的<code>dev</code>仓库到本地的<code>dev</code>分支</p></li></ol></blockquote>
</blockquote>
</blockquote>
<h2>想看更多文章请移步<a href=""https://chenjiabing666.github.io/2017/05/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"" rel=""nofollow noreferrer"">本人博客</a>
</h2>

                ", git常用操作,1531977850,443,1,594,1,1,https://segmentfault.com/a/1190000009320754
135,1,0,7,"
                    
<p>最近做了一个<a href=""https://github.com/opendigg/awesome-github-android-ui"" rel=""nofollow noreferrer"">Android UI相关开源项目库汇总</a>，里面集合了<a href=""http://www.opendigg.com/"" rel=""nofollow noreferrer"">OpenDigg</a> 上的优质的<a href=""http://www.opendigg.com/tags/android"" rel=""nofollow noreferrer"">Android</a>开源项目库，方便移动开发人员便捷的找到自己需要的项目工具等，感兴趣的可以到GitHub上给个star。<br>【注：项目数量过多，超出博文长度限制，点击项目汇总地址可查看更多。】</p>
<h2>抽屉菜单</h2>
<ul>
<li><p><a href=""https://github.com/mikepenz/MaterialDrawer"" rel=""nofollow noreferrer"">MaterialDrawer</a> ★7337 - 安卓抽屉效果实现方案</p></li>
<li><p><a href=""https://github.com/Yalantis/Side-Menu.Android"" rel=""nofollow noreferrer"">Side-Menu.Android</a> ★3865 - 创意边侧菜单</p></li>
<li><p><a href=""https://github.com/mxn21/FlowingDrawer"" rel=""nofollow noreferrer"">FlowingDrawer</a> ★1744 - 向右滑动流动抽屉效果</p></li>
<li><p><a href=""https://github.com/yarolegovich/SlidingRootNav"" rel=""nofollow noreferrer"">SlidingRootNav</a> ★1338 - 仿DrawerLayout的ViewGroup</p></li>
<li><p><a href=""https://github.com/mzule/FantasySlide"" rel=""nofollow noreferrer"">FantasySlide</a> ★1049 - 单手势滑出侧边栏与选择菜单</p></li>
<li><p><a href=""https://github.com/andremion/Floating-Navigation-View"" rel=""nofollow noreferrer"">Floating-Navigation-View</a> ★779 - 浮动菜单显示锚导航视图</p></li>
<li><p><a href=""https://github.com/heinrichreimer/material-drawer"" rel=""nofollow noreferrer"">material-drawer</a> ★525 - MD风格的自定义抽屉实现</p></li>
<li><p><a href=""https://github.com/Brioal/SwipeMenuDemo"" rel=""nofollow noreferrer"">SwipeMenuDemo</a> ★514 - 侧滑菜单动画效果库</p></li>
<li><p><a href=""https://github.com/rom4ek/ArcNavigationView"" rel=""nofollow noreferrer"">ArcNavigationView</a> ★326 - 具有曲线边缘的NavigationView</p></li>
<li><p><a href=""https://github.com/drakeet/QQSliddingMenu"" rel=""nofollow noreferrer"">QQSliddingMenu</a> ★106 - 与QQ5.0 完全一模一样的侧滑菜单</p></li>
<li><p><a href=""https://github.com/lemonade-hq/SlideSideMenu"" rel=""nofollow noreferrer"">SlideSideMenu</a> ★60 - 滑动侧菜单的布局部件</p></li>
</ul>
<h2>ListView</h2>
<ul>
<li><p><a href=""https://github.com/hongyangAndroid/baseAdapter"" rel=""nofollow noreferrer"">baseAdapter</a> ★2475 - Android 万能的Adapter</p></li>
<li><p><a href=""https://github.com/beworker/pinned-section-listview"" rel=""nofollow noreferrer"">Pinned Section Listview</a> ★2363 - 便于使用的ListView</p></li>
<li><p><a href=""https://github.com/felipecsl/AsymmetricGridView"" rel=""nofollow noreferrer"">AsymmetricGridView</a> ★1388 - Android自定义列表视图</p></li>
<li><p><a href=""https://github.com/pedrovgs/Renderers"" rel=""nofollow noreferrer"">Renderers</a> ★1023 - 创建适配器的Android库</p></li>
<li><p><a href=""https://github.com/Kelin-Hong/CalendarListView"" rel=""nofollow noreferrer"">CalendarListView</a> ★726 - 可互动的ListView+CalendarView</p></li>
<li><p><a href=""https://github.com/diegodobelo/AndroidExpandingViewLibrary"" rel=""nofollow noreferrer"">AndroidExpandingViewLibrary</a> ★515 - 创建Android动画折叠视图</p></li>
<li><p><a href=""https://github.com/lurbas/ListItemView"" rel=""nofollow noreferrer"">ListItemView</a> ★490 - 基于MD风格的列表item实现</p></li>
<li><p><a href=""https://github.com/venshine/WheelView"" rel=""nofollow noreferrer"">WheelView</a> ★411 - 基于ListView实现的Android滚轮控件</p></li>
<li><p><a href=""https://github.com/yll2wcf/YLListView"" rel=""nofollow noreferrer"">YLListView</a> ★209 - 仿IOS弹簧效果的ListView</p></li>
<li><p><a href=""https://github.com/vivian8725118/SearchListView"" rel=""nofollow noreferrer"">SearchListView</a> ★149 - 带搜索栏的 listview</p></li>
<li><p><a href=""https://github.com/ruzhan123/ScollZoomListView"" rel=""nofollow noreferrer"">ScollZoomListView</a> ★38 - 优雅的漫画阅读器插件</p></li>
</ul>
<h2>WebView</h2>
<ul>
<li><p><a href=""https://github.com/lzyzsd/JsBridge"" rel=""nofollow noreferrer"">JsBridge</a> ★2867 - Android的Java和JavaScript桥接</p></li>
<li><p><a href=""https://github.com/JackyAndroid/AndroidChromium"" rel=""nofollow noreferrer"">AndroidChromium</a> ★1476 - 谷歌浏览器安卓版源码项目</p></li>
<li><p><a href=""https://github.com/TheFinestArtist/FinestWebView-Android"" rel=""nofollow noreferrer"">FinestWebView-Android</a> ★1428 - 可自定义webview</p></li>
<li><p><a href=""https://github.com/cprcrack/VideoEnabledWebView"" rel=""nofollow noreferrer"">VideoEnabledWebView</a> ★608 - Android的WebView和WebChromeClint类扩展</p></li>
<li><p><a href=""https://github.com/RameshBhupathi/CollapsingToolbar-With-Webview"" rel=""nofollow noreferrer"">CollapsingToolbar-With-Webview</a> ★183 - 带有可折叠toolbar的Webview</p></li>
<li><p><a href=""https://github.com/wendux/DSBridge-Android"" rel=""nofollow noreferrer"">DSBridge-Android</a> ★132 - 目前地球上最好的IOS及Android javascript bridge</p></li>
<li><p><a href=""https://github.com/wendux/DSBridge-IOS"" rel=""nofollow noreferrer"">DSBridge-IOS</a> ★117 - 目前地球上最好的IOS javascript bridge</p></li>
<li><p><a href=""https://github.com/slm/WebViewNativeBridge"" rel=""nofollow noreferrer"">WebViewNativeBridge</a> ★27 - 从WebView向Java通过url发送数据</p></li>
<li><p><a href=""https://github.com/AhmadNemati/ClickableWebView"" rel=""nofollow noreferrer"">ClickableWebView</a> ★20 - 检测图片上的点击</p></li>
</ul>
<h2>SwitchButton</h2>
<ul>
<li><p><a href=""https://github.com/zcweng/ToggleButton"" rel=""nofollow noreferrer"">ToggleButton</a> ★1756 - Android上类似iOS的开关控件</p></li>
<li><p><a href=""https://github.com/zagum/Android-SwitchIcon"" rel=""nofollow noreferrer"">Android-SwitchIcon</a> ★1407 - Switch图标的Google启动器风格实现</p></li>
<li><p><a href=""https://github.com/glomadrian/material-animated-switch"" rel=""nofollow noreferrer"">material-animated-switch</a> ★967 - 带有图标动画和颜色转换的Switch</p></li>
<li><p><a href=""https://github.com/polyak01/IconSwitch"" rel=""nofollow noreferrer"">IconSwitch</a> ★548 - 自定义切换部件</p></li>
<li><p><a href=""https://github.com/7heaven/SHSwitchView"" rel=""nofollow noreferrer"">SHSwitchView</a> ★318 - iOS7风格的Switch开关</p></li>
<li><p><a href=""https://github.com/xiaopansky/SwitchButton"" rel=""nofollow noreferrer"">SwitchButton</a> ★283 - 安卓开关按钮</p></li>
<li><p><a href=""https://github.com/zcweng/SwitchButton"" rel=""nofollow noreferrer"">SwitchButton</a> ★268 - 优美的轻量级自定义样式的Switch按钮</p></li>
</ul>
<h2>按钮</h2>
<ul>
<li><p><a href=""https://github.com/medyo/Fancybuttons"" rel=""nofollow noreferrer"">FancyButtons</a> ★1100 - 创建花式按钮</p></li>
<li><p><a href=""https://github.com/fenjuly/ArrowDownloadButton"" rel=""nofollow noreferrer"">ArrowDownloadButton</a> ★773 - 超酷的下载按钮</p></li>
<li><p><a href=""https://github.com/Scalified/fab"" rel=""nofollow noreferrer"">fab</a> ★760 - 浮动按钮</p></li>
<li><p><a href=""https://github.com/mcxtzhang/AnimShopButton"" rel=""nofollow noreferrer"">AnimShopButton</a> ★745 - 带伸缩位移旋转动画的购物车按钮</p></li>
<li><p><a href=""https://github.com/venshine/GoodView"" rel=""nofollow noreferrer"">GoodView</a> ★701 - Android点赞+1效果</p></li>
<li><p><a href=""https://github.com/Nightonke/JellyToggleButton"" rel=""nofollow noreferrer"">JellyToggleButton</a> ★684 - 果冻动态效果及缓动类型开关按钮</p></li>
<li><p><a href=""https://github.com/niniloveyou/StateButton"" rel=""nofollow noreferrer"">StateButton</a> ★675 - 不必为每种类型的button写一个drawable</p></li>
<li><p><a href=""https://github.com/varunest/SparkButton"" rel=""nofollow noreferrer"">SparkButton</a> ★670 - 创建一个带动画效果的按钮</p></li>
<li><p><a href=""https://github.com/ckurtm/FabButton"" rel=""nofollow noreferrer"">FabButton</a> ★666 - 带有进度条指示器的环形浮动动作按钮</p></li>
<li><p><a href=""https://github.com/cctanfujun/ProgressRoundButton"" rel=""nofollow noreferrer"">ProgressRoundButton</a> ★624 - 显示进度的流畅下载按钮</p></li>
<li><p><a href=""https://github.com/dewarder/HoldingButton"" rel=""nofollow noreferrer"">HoldingButton</a> ★461 - 控制录音状态的按钮</p></li>
<li><p><a href=""https://github.com/SparkYuan/SubmitButton"" rel=""nofollow noreferrer"">SubmitButton</a> ★343 - 实用酷炫又优雅的提交按钮</p></li>
<li><p><a href=""https://github.com/ishaan1995/ButtonProgressBar"" rel=""nofollow noreferrer"">ButtonProgressBar</a> ★307 - 下载按钮进度条</p></li>
<li><p><a href=""https://github.com/gjiazhe/MultiChoicesCircleButton"" rel=""nofollow noreferrer"">MultiChoicesCircleButton</a> ★299 - 带3d视差效果的多选按钮</p></li>
<li><p><a href=""https://github.com/rubensousa/RaiflatButton"" rel=""nofollow noreferrer"">RaiflatButton</a> ★284 - 凸起的按钮</p></li>
<li><p><a href=""https://github.com/jiang111/CProgressButton"" rel=""nofollow noreferrer"">CProgressButton</a> ★240 - 仿iOS环形进度按钮</p></li>
<li><p><a href=""https://github.com/czy1121/roundbutton"" rel=""nofollow noreferrer"">roundbutton</a> ★238 - 可设置圆角背景边框的的按钮</p></li>
<li><p><a href=""https://github.com/recruit-lifestyle/PlayPauseButton"" rel=""nofollow noreferrer"">PlayPauseButton</a> ★225 - 制作动画播放状态的视图</p></li>
<li><p><a href=""https://github.com/HomHomLin/Android-DivergeView"" rel=""nofollow noreferrer"">Android-DivergeView</a> ★160 - 仿美拍直播的点赞动画</p></li>
<li><p><a href=""https://github.com/BeppiMenozzi/TriStateToggleButton"" rel=""nofollow noreferrer"">TriStateToggleButton</a> ★132 - 完全可自定义3态切换按钮</p></li>
<li><p><a href=""https://github.com/ceryle/SegmentedButton"" rel=""nofollow noreferrer"">SegmentedButton</a> ★85 - 类似IOS的带动画分割按钮</p></li>
<li><p><a href=""https://github.com/StevenDXC/DxLoadingButton"" rel=""nofollow noreferrer"">DxLoadingButton</a> ★77 - 带有动画的Android加载按钮</p></li>
<li><p><a href=""https://github.com/laocaixw/SuspendButtonLayout"" rel=""nofollow noreferrer"">SuspendButtonLayout</a> ★67 - 带浮动按钮的布局</p></li>
<li><p><a href=""https://github.com/dimorinny/floating-text-button"" rel=""nofollow noreferrer"">floating-text-button</a> ★44 - 带动作文本的简单浮动按钮</p></li>
<li><p><a href=""https://github.com/developer-shivam/PentagonFloatingActionButton"" rel=""nofollow noreferrer"">PentagonFloatingActionButton</a> ★41 - 浮动点击动画按钮</p></li>
<li><p><a href=""https://github.com/Sbingo/FreeRadioGroup"" rel=""nofollow noreferrer"">FreeRadioGroup</a> ★32 - 类似于苹果的虚拟辅助按钮</p></li>
<li><p><a href=""https://github.com/LongDinhF/Hamburger-Button"" rel=""nofollow noreferrer"">Hamburger-Button</a> ★31 - 完全定制的汉堡按钮</p></li>
<li><p><a href=""https://github.com/hcs-xph/BadgeRadioButton"" rel=""nofollow noreferrer"">BadgeRadioButton</a> ★25 - 仿QQ底部Tab切换RadioButton</p></li>
<li><p><a href=""https://github.com/LinXiaoTao/OrderButton"" rel=""nofollow noreferrer"">OrderButton</a> ★21 - 仿饿了么下单按钮</p></li>
</ul>
<h2>点赞按钮</h2>
<ul>
<li><p><a href=""https://github.com/ChadCSong/ShineButton"" rel=""nofollow noreferrer"">ShineButton</a> ★2400 - 安卓闪光UI库</p></li>
<li><p><a href=""https://github.com/jd-alexander/LikeButton"" rel=""nofollow noreferrer"">LikeButton</a> ★1823 - 仿Twitter点赞时的的heart</p></li>
<li><p><a href=""https://github.com/venshine/GoodView"" rel=""nofollow noreferrer"">GoodView</a> ★701 - Android点赞+1效果</p></li>
<li><p><a href=""https://github.com/varunest/SparkButton"" rel=""nofollow noreferrer"">SparkButton</a> ★670 - 创建一个带动画效果的按钮</p></li>
<li><p><a href=""https://github.com/ldoublem/ThumbUp"" rel=""nofollow noreferrer"">ThumbUp</a> ★550 - 精致的点赞控件</p></li>
<li><p><a href=""https://github.com/yanbober/MagicFloatView"" rel=""nofollow noreferrer"">MagicFloatView</a> ★224 - 自定义拓展漂浮路径的MagicFlyLinearLayout 控件</p></li>
<li><p><a href=""https://github.com/HomHomLin/Android-DivergeView"" rel=""nofollow noreferrer"">Android-DivergeView</a> ★160 - 仿美拍直播的点赞动画</p></li>
<li><p><a href=""https://github.com/zFxiang/LikeView"" rel=""nofollow noreferrer"">LikeView</a> ★28 - 仿即刻APP点赞桃心的效果</p></li>
<li><p><a href=""https://github.com/alex5241/TumblrLikeAnimView"" rel=""nofollow noreferrer"">TumblrLikeAnimView</a> ★9 - 仿Tumblr点赞动画效果</p></li>
</ul>
<h2>进度条</h2>
<ul>
<li><p><a href=""https://github.com/81813780/AVLoadingIndicatorView"" rel=""nofollow noreferrer"">AVLoadingIndicatorView</a> ★4771 - 安卓载入动画合集</p></li>
<li><p><a href=""https://github.com/daimajia/NumberProgressBar"" rel=""nofollow noreferrer"">NumberProgressBar</a> ★3876 - 多彩进度条</p></li>
<li><p><a href=""https://github.com/ybq/Android-SpinKit"" rel=""nofollow noreferrer"">Android-SpinKit</a> ★3092 - Android加载动画</p></li>
<li><p><a href=""https://github.com/dinuscxj/LoadingDrawable"" rel=""nofollow noreferrer"">LoadingDrawable</a> ★2536 - 安卓工具动画集合</p></li>
<li><p><a href=""https://github.com/lzyzsd/CircleProgress"" rel=""nofollow noreferrer"">CircleProgress</a> ★2307 - 三种圆形进度视图</p></li>
<li><p><a href=""https://github.com/Todd-Davies/ProgressWheel"" rel=""nofollow noreferrer"">ProgressWheel</a> ★2245 - 圆形旋转效果</p></li>
<li><p><a href=""https://github.com/ozodrukh/CircularReveal"" rel=""nofollow noreferrer"">CircularReveal</a> ★1990 - 创建加载动画效果</p></li>
<li><p><a href=""https://github.com/ldoublem/LoadingView"" rel=""nofollow noreferrer"">LoadingView</a> ★1662 - 简单的带有动画效果的加载控件</p></li>
<li><p><a href=""https://github.com/JorgeCastilloPrz/AndroidFillableLoaders"" rel=""nofollow noreferrer"">AndroidFillableLoaders</a> ★1576 - 有趣的填充型进程视图</p></li>
<li><p><a href=""https://github.com/Tibolte/ElasticDownload"" rel=""nofollow noreferrer"">ElasticDownload</a> ★1422 - 下载动画效果</p></li>
<li><p><a href=""https://github.com/dodola/MetaballLoading"" rel=""nofollow noreferrer"">MetaballLoading</a> ★1323 - 一个2d圆球加载</p></li>
<li><p><a href=""https://github.com/zzz40500/android-shapeLoadingView"" rel=""nofollow noreferrer"">android-shapeLoadingView</a> ★1288 - 高仿新版58 加载动画</p></li>
<li><p><a href=""https://github.com/akexorcist/Android-RoundCornerProgressBar"" rel=""nofollow noreferrer"">Android-RoundCornerProgressBar</a> ★1213 - Android圆角进度条库</p></li>
<li><p><a href=""https://github.com/DreaminginCodeZH/MaterialProgressBar"" rel=""nofollow noreferrer"">MaterialProgressBar</a> ★1155 - MD风格的进度条</p></li>
<li><p><a href=""https://github.com/tangqi92/WaveLoadingView"" rel=""nofollow noreferrer"">WaveLoadingView</a> ★1140 - 仿真波浪加载效果</p></li>
<li><p><a href=""https://github.com/race604/WaveLoading"" rel=""nofollow noreferrer"">WaveLoading</a> ★1051 - 能够提供波浪动画的Drawable</p></li>
<li><p><a href=""https://github.com/nntuyen/mkloader"" rel=""nofollow noreferrer"">mkloader</a> ★997 - 优美又流畅的自定义加载视图</p></li>
<li><p><a href=""https://github.com/Rogero0o/GifLoadingView"" rel=""nofollow noreferrer"">GifLoadingView</a> ★962 - webpage中的简单动画方法</p></li>
<li><p><a href=""https://github.com/jlmd/AnimatedCircleLoadingView"" rel=""nofollow noreferrer"">AnimatedCircleLoadingView</a> ★927 - 加载视图动画</p></li>
<li><p><a href=""https://github.com/Devlight/ArcProgressStackView"" rel=""nofollow noreferrer"">ArcProgressStackView</a> ★919 - arc模式进度条</p></li>
<li><p><a href=""https://github.com/yankai-victor/Loading"" rel=""nofollow noreferrer"">Loading</a> ★888 - 多个Android加载效果</p></li>
<li><p><a href=""https://github.com/lopspower/CircularFillableLoaders"" rel=""nofollow noreferrer"">CircularFillableLoaders</a> ★864 - 精致的环形填充加载效果</p></li>
<li><p><a href=""https://github.com/Fichardu/CircleProgress"" rel=""nofollow noreferrer"">CircleProgress</a> ★752 - 带旋转动画的环形进度视图</p></li>
<li><p><a href=""https://github.com/vlonjatg/progress-activity"" rel=""nofollow noreferrer"">progress-activity</a> ★743 - 进度条空视图及错误视图库</p></li>
<li><p><a href=""https://github.com/Rogero0o/CatLoadingView"" rel=""nofollow noreferrer"">CatLoadingView</a> ★743 - Android猫头像加载视图</p></li>
<li><p><a href=""https://github.com/Kaopiz/KProgressHUD"" rel=""nofollow noreferrer"">KProgressHUD</a> ★718 - 安卓ProgressHUD实现</p></li>
<li><p><a href=""https://github.com/jakob-grabner/Circle-Progress-View"" rel=""nofollow noreferrer"">CircleView</a> ★678 - 动画环形视图</p></li>
<li><p><a href=""https://github.com/aliab/circular-music-progressbar"" rel=""nofollow noreferrer"">Circular Music ProgressBar</a> ★613 - Android环形音乐进度条</p></li>
<li><p><a href=""https://github.com/JeasonWong/SlackLoadingView"" rel=""nofollow noreferrer"">SlackLoadingView</a> ★596 - 模仿Slack加载动画</p></li>
<li><p><a href=""https://github.com/Shinelw/ColorArcProgressBar"" rel=""nofollow noreferrer"">ColorArcProgressBar</a> ★593 - 可定制的圆形进度条</p></li>
<li><p><a href=""https://github.com/JustZak/DilatingDotsProgressBar"" rel=""nofollow noreferrer"">DilatingDotsProgressBar</a> ★592 - 自定义模糊进度条</p></li>
<li><p><a href=""https://github.com/d-max/spots-dialog"" rel=""nofollow noreferrer"">spots-dialog</a> ★591 - Android提示对话框</p></li>
<li><p><a href=""https://github.com/rahatarmanahmed/CircularProgressView"" rel=""nofollow noreferrer"">CircularProgressView</a> ★585 - 环形进度条安卓视图</p></li>
<li><p><a href=""https://github.com/HotBitmapGG/RingProgressBar"" rel=""nofollow noreferrer"">RingProgressBar</a> ★521 - MD风格的环形进度条</p></li>
<li><p><a href=""https://github.com/lingochamp/MagicProgressWidget"" rel=""nofollow noreferrer"">MagicProgressWidget</a> ★486 - 圆形进度条与横向进度条</p></li>
<li><p><a href=""https://github.com/SaeedMasoumi/FAB-Loading"" rel=""nofollow noreferrer"">FAB-Loading</a> ★474 - 浮动加载动画</p></li>
<li><p><a href=""https://github.com/pavlospt/CircleView"" rel=""nofollow noreferrer"">CircleView</a> ★472 - 包含标题和子标题的环形视图</p></li>
<li><p><a href=""https://github.com/TomWithJerry/CoolAndroidAnim"" rel=""nofollow noreferrer"">CoolAndroidAnim</a> ★472 - 酷炫的android loading效果</p></li>
<li><p><a href=""https://github.com/ldoublem/RingProgress"" rel=""nofollow noreferrer"">RingProgress</a> ★464 - 带效果的环形进度条</p></li>
<li><p><a href=""https://github.com/saiwu-bigkoo/Android-SVProgressHUD"" rel=""nofollow noreferrer"">Android-SVProgressHUD</a> ★436 - 精仿iOS的提示库 SVProgressHUD</p></li>
<li><p><a href=""https://github.com/LineChen/FlickerProgressBar"" rel=""nofollow noreferrer"">FlickerProgressBar</a> ★425 - 安卓仿应用宝下载进度条</p></li>
<li><p><a href=""https://github.com/arieridwan8/pageloader"" rel=""nofollow noreferrer"">pageloader</a> ★340 - 轻松自定义加载页面</p></li>
<li><p><a href=""https://github.com/yingLanNull/CircleAlarmTimerView"" rel=""nofollow noreferrer"">CircleAlarmTimerView</a> ★297 - 圆形进度条</p></li>
<li><p><a href=""https://github.com/yuweiguocn/SquareLoading"" rel=""nofollow noreferrer"">SquareLoading</a> ★286 - 一个方形动画加载器</p></li>
<li><p><a href=""https://github.com/yxping/AdhesiveLoadingView"" rel=""nofollow noreferrer"">AdhesiveLoadingView</a> ★259 - 具有粘性的滑动小球loading</p></li>
<li><p><a href=""https://github.com/zhangyuChen1991/OverWatchLoading"" rel=""nofollow noreferrer"">OverWatchLoading</a> ★241 - 守望先锋的加载动画效果</p></li>
<li><p><a href=""https://github.com/VictorAlbertos/SwipeCoordinator"" rel=""nofollow noreferrer"">SwipeCoordinator</a> ★212 - 简化动画滑动视图进程</p></li>
<li><p><a href=""https://github.com/xiprox/MarkView"" rel=""nofollow noreferrer"">MarkView</a> ★208 - 彩色圆弧的环形进度条</p></li>
<li><p><a href=""https://github.com/YangShaoXiong/LikeSinaSportProgress"" rel=""nofollow noreferrer"">LikeSinaSportProgress</a> ★200 - 仿新浪体育客户端的进度条</p></li>
<li><p><a href=""https://github.com/niniloveyou/BounceLoadingView"" rel=""nofollow noreferrer"">BounceLoadingView</a> ★161 - 模仿饿了么加载效果</p></li>
<li><p><a href=""https://github.com/biodunalfet/SlidingSquaresLoader"" rel=""nofollow noreferrer"">SlidingSquaresLoader</a> ★144 - 简单的进度加载</p></li>
<li><p><a href=""https://github.com/peng8350/LoadingProgress"" rel=""nofollow noreferrer"">LoadingProgress</a> ★142 - 加载进度条</p></li>
<li><p><a href=""https://github.com/andyxialm/CutoLoadingView"" rel=""nofollow noreferrer"">CutoLoadingView</a> ★126 - 自定义加载视图</p></li>
<li><p><a href=""https://github.com/alex5241/AwesomeProgressbar"" rel=""nofollow noreferrer"">AwesomeProgressbar</a> ★105 - 支持左右两边同时滚动的进度条</p></li>
<li><p><a href=""https://github.com/zhangyuChen1991/ZYDownloading"" rel=""nofollow noreferrer"">ZYDownloading</a> ★88 - 一个蛮酷的加载进度条</p></li>
<li><p><a href=""https://github.com/ForgetAll/LoadingDialog"" rel=""nofollow noreferrer"">LoadingDialog</a> ★79 - 简单好用的LoadingDialog</p></li>
<li><p><a href=""https://github.com/jineshfrancs/LazyLoadingViews"" rel=""nofollow noreferrer"">LazyLoadingViews</a> ★74 - Adapter视图中子视图加载效果</p></li>
<li><p><a href=""https://github.com/XBeats/and_cube_progress"" rel=""nofollow noreferrer"">and_cube_progress</a> ★74 - 正方体样式的loadingView</p></li>
<li><p><a href=""https://github.com/niniloveyou/GradeProgressView"" rel=""nofollow noreferrer"">GradeProgressView</a> ★62 - 用来评估移动电话的进度条视图</p></li>
<li><p><a href=""https://github.com/DamanSingh4321/ProProgressViews"" rel=""nofollow noreferrer"">ProProgressViews</a> ★46 - Android精致进度视图收集库</p></li>
<li><p><a href=""https://github.com/eralpyucel/CircleProgressView"" rel=""nofollow noreferrer"">CircleProgressView</a> ★43 - 显示百分比进度的安卓组件</p></li>
<li><p><a href=""https://github.com/AlexMofer/CircleProgressBar"" rel=""nofollow noreferrer"">CircleProgressBar</a> ★32 - 带载入动画的环形进度条</p></li>
<li><p><a href=""https://github.com/XuDeveloper/VideoLoadingView"" rel=""nofollow noreferrer"">VideoLoadingView</a> ★29 - 加载界面</p></li>
<li><p><a href=""https://github.com/anderson9/LovelyProgressBar"" rel=""nofollow noreferrer"">LovelyProgressBar</a> ★26 - 漂亮的加载动画</p></li>
<li><p><a href=""https://github.com/bingoogolapple/BGAProgressBar-Android"" rel=""nofollow noreferrer"">BGAProgressBar-Android</a> ★24 - 安卓进度条</p></li>
<li><p><a href=""https://github.com/linglongxin24/BaiduProgressBar"" rel=""nofollow noreferrer"">BaiduProgressBar</a> ★21 - 仿百度加载动画</p></li>
<li><p><a href=""https://github.com/lvleo/DataLoadingLayoutAndroid"" rel=""nofollow noreferrer"">DataLoadingLayoutAndroid</a> ★15 - 展示当前数据加载状态的库</p></li>
</ul>
<h2>TabLayout</h2>
<ul>
<li><p><a href=""https://github.com/ogaclejapan/SmartTabLayout"" rel=""nofollow noreferrer"">SmartTabLayout</a> ★4248 - 在用户滚动时给出连续的反馈</p></li>
<li><p><a href=""https://github.com/H07000223/FlycoTabLayout"" rel=""nofollow noreferrer"">FlycoTabLayout</a> ★3783 - Android的TabLayout库</p></li>
<li><p><a href=""https://github.com/hackware1993/MagicIndicator"" rel=""nofollow noreferrer"">MagicIndicator</a> ★2037 - 强大易扩展的ViewPager指示器框架</p></li>
<li><p><a href=""https://github.com/hugeterry/CoordinatorTabLayout"" rel=""nofollow noreferrer"">CoordinatorTabLayout</a> ★1874 - 自定义组合控件</p></li>
<li><p><a href=""https://github.com/DevLight-Mobile-Agency/NavigationTabStrip"" rel=""nofollow noreferrer"">NavigationTabStrip</a> ★1366 - 平滑可交互导航标签条</p></li>
<li><p><a href=""https://github.com/Andy671/Dachshund-Tab-Layout"" rel=""nofollow noreferrer"">Dachshund-Tab-Layout</a> ★534 - 增强型Android标签布局</p></li>
<li><p><a href=""https://github.com/HomHomLin/AdvancedPagerSlidingTabStrip"" rel=""nofollow noreferrer"">AdvancedPagerSlidingTabStrip</a> ★303 - 安卓导航控件</p></li>
<li><p><a href=""https://github.com/simplezhli/ChangeTabLayout"" rel=""nofollow noreferrer"">ChangeTabLayout</a> ★166 - 模仿乐视LIVEApp主界面TabLayout效果</p></li>
<li><p><a href=""https://github.com/myinnos/SlidingTabWithColorIcons"" rel=""nofollow noreferrer"">SlidingTabWithColorIcons</a> ★19 - 带彩色图标的滑动标签</p></li>
</ul>
<h2>图标</h2>
<ul>
<li><p><a href=""https://github.com/google/material-design-icons"" rel=""nofollow noreferrer"">Material design icons</a> ★29344 - 谷歌官方图标</p></li>
<li><p><a href=""https://github.com/JoanZapata/android-iconify"" rel=""nofollow noreferrer"">android-iconify</a> ★2922 - 多个图标供应商的图标整合</p></li>
<li><p><a href=""https://github.com/mikepenz/Android-Iconics"" rel=""nofollow noreferrer"">Android-Iconics</a> ★2716 - 在应用中使用图标字体或矢量</p></li>
<li><p><a href=""https://github.com/code-mc/material-icon-lib"" rel=""nofollow noreferrer"">material-icon-lib</a> ★1917 - 1500个MD风格矢量图标</p></li>
<li><p><a href=""https://github.com/tarek360/Animated-Icons"" rel=""nofollow noreferrer"">Animated-Icons</a> ★138 - 安卓动画图标</p></li>
<li><p><a href=""https://github.com/Livin21/DroidAwesome"" rel=""nofollow noreferrer"">DroidAwesome</a> ★25 - 视图或者菜单中显示FontAwesome图标</p></li>
</ul>
<h2>下拉刷新</h2>
<ul>
<li><p><a href=""https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh"" rel=""nofollow noreferrer"">android-Ultra-Pull-To-Refresh</a> ★7720 - 下拉刷新项目的替代方案</p></li>
<li><p><a href=""https://github.com/Yalantis/Phoenix"" rel=""nofollow noreferrer"">Phoenix</a> ★3198 - 可自定义滑动刷新实现</p></li>
<li><p><a href=""https://github.com/bingoogolapple/BGARefreshLayout-Android"" rel=""nofollow noreferrer"">BGARefreshLayout-Android</a> ★2827 - 多种下拉刷新和上拉加载插件</p></li>
<li><p><a href=""https://github.com/race604/FlyRefresh"" rel=""nofollow noreferrer"">FlyRefresh</a> ★2735 - 最有特色的下拉刷新</p></li>
<li><p><a href=""https://github.com/lcodecorex/TwinklingRefreshLayout"" rel=""nofollow noreferrer"">TwinklingRefreshLayout</a> ★1866 - 下拉刷新和上拉加载的RefreshLayout</p></li>
<li><p><a href=""https://github.com/recruit-lifestyle/WaveSwipeRefreshLayout"" rel=""nofollow noreferrer"">WaveSwipeRefreshLayout</a> ★1564 - Android刷新控件</p></li>
<li><p><a href=""https://github.com/Aspsine/SwipeToLoadLayout"" rel=""nofollow noreferrer"">SwipeToLoadLayout</a> ★1411 - 可重用下拉刷新及上拉加载更多组件</p></li>
<li><p><a href=""https://github.com/Yalantis/Taurus"" rel=""nofollow noreferrer"">Taurus</a> ★1411 - 简单和可定制的下拉刷新实现</p></li>
<li><p><a href=""https://github.com/dinuscxj/RecyclerRefreshLayout"" rel=""nofollow noreferrer"">RecyclerRefreshLayout</a> ★1357 - 通过垂直滑动手势刷新当前view内容</p></li>
<li><p><a href=""https://github.com/Yalantis/pull-to-make-soup"" rel=""nofollow noreferrer"">pull-to-make-soup</a> ★1228 - 自定义动画下拉刷新</p></li>
<li><p><a href=""https://github.com/Hitomis/FunGameRefresh"" rel=""nofollow noreferrer"">FunGameRefresh</a> ★1069 - 有趣好玩的下拉刷新库</p></li>
<li><p><a href=""https://github.com/WuXiaolong/PullLoadMoreRecyclerView"" rel=""nofollow noreferrer"">PullLoadMoreRecyclerView</a> ★903 - 上拉刷新加载</p></li>
<li><p><a href=""https://github.com/Chanven/CommonPullToRefresh"" rel=""nofollow noreferrer"">CommonPullToRefresh</a> ★842 - 下拉刷新</p></li>
<li><p><a href=""https://github.com/OrangeGangsters/SwipyRefreshLayout"" rel=""nofollow noreferrer"">SwipyRefreshLayout</a> ★816 - 在两个方向上滑动的SwipeRefreshLayout扩展</p></li>
<li><p><a href=""https://github.com/huxq17/XRefreshView"" rel=""nofollow noreferrer"">XRefreshView</a> ★803 - android下拉上拉刷新框架</p></li>
<li><p><a href=""https://github.com/ashqal/ChromeLikeSwipeLayout"" rel=""nofollow noreferrer"">ChromeLikeSwipeLayout</a> ★626 - 执行更多事件的下拉事件</p></li>
<li><p><a href=""https://github.com/imallan/JellyRefreshLayout"" rel=""nofollow noreferrer"">JellyRefreshLayout</a> ★601 - 下拉刷新布局</p></li>
<li><p><a href=""https://github.com/shichaohui/AnimRefreshRecyclerView"" rel=""nofollow noreferrer"">AnimRefreshRecyclerView</a> ★522 - 下拉刷新和上拉加载更多的RecyclerView</p></li>
<li><p><a href=""https://github.com/lubeast/PullToRefresh"" rel=""nofollow noreferrer"">PullToRefresh</a> ★513 - 下拉刷新实现</p></li>
<li><p><a href=""https://github.com/hougr/SmartisanPull"" rel=""nofollow noreferrer"">SmartisanPull</a> ★496 - 最优雅的下拉控件</p></li>
<li><p><a href=""https://github.com/pengjianbo/LoadingViewFinal"" rel=""nofollow noreferrer"">LoadingViewFinal</a> ★261 - 实现了下拉刷新/加载更多的android组件</p></li>
<li><p><a href=""https://github.com/Y-bao/PullRefreshView"" rel=""nofollow noreferrer"">PullRefreshView</a> ★228 - 为滑动控件添加上拉刷新下拉加载等功能</p></li>
<li><p><a href=""https://github.com/dinuscxj/ShootRefreshView"" rel=""nofollow noreferrer"">ShootRefreshView</a> ★210 - 快手Android客户端刷新动画</p></li>
<li><p><a href=""https://github.com/songixan/SmileRefresh"" rel=""nofollow noreferrer"">SmileRefresh</a> ★183 - 微笑下拉刷新</p></li>
<li><p><a href=""https://github.com/leoleohan/RecyclerRefresh"" rel=""nofollow noreferrer"">RecyclerRefresh</a> ★158 - 仿简书安卓端</p></li>
<li><p><a href=""https://github.com/LuckyJayce/CoolRefreshView"" rel=""nofollow noreferrer"">CoolRefreshView</a> ★115 - 安卓刷新视图库</p></li>
<li><p><a href=""https://github.com/anzaizai/EasyRefreshLayout"" rel=""nofollow noreferrer"">EasyRefreshLayout</a> ★98 - 轻松实现下拉刷新和上拉加载</p></li>
<li><p><a href=""https://github.com/linuxjava/RefreshLayout"" rel=""nofollow noreferrer"">RefreshLayout</a> ★72 - 实现下拉刷新和上拉加载</p></li>
<li><p><a href=""https://github.com/ileelay/VRefreshLayout"" rel=""nofollow noreferrer"">VRefreshLayout</a> ★62 - 竖直方向的下拉刷新控件</p></li>
<li><p><a href=""https://github.com/linuxjava/HorizontalRefreshLayout"" rel=""nofollow noreferrer"">HorizontalRefreshLayout</a> ★30 - 实现左右刷新</p></li>
<li><p><a href=""https://github.com/StevenDXC/DxWaveRefresh"" rel=""nofollow noreferrer"">DxWaveRefresh</a> ★25 - 波浪效果的下拉刷新</p></li>
<li><p><a href=""https://github.com/sangenan/DonkeyRefresh"" rel=""nofollow noreferrer"">DonkeyRefresh</a> ★16 - 仿赶集下拉刷新</p></li>
</ul>
<h2>ViewPager</h2>
<ul>
<li><p><a href=""https://github.com/florent37/MaterialViewPager"" rel=""nofollow noreferrer"">MaterialViewPager</a> ★5957 - 安卓选项卡插件</p></li>
<li><p><a href=""https://github.com/DevLight-Mobile-Agency/InfiniteCycleViewPager"" rel=""nofollow noreferrer"">InfiniteCycleViewPager</a> ★3398 - 无限循环的视图页</p></li>
<li><p><a href=""https://github.com/lsjwzh/RecyclerViewPager"" rel=""nofollow noreferrer"">RecyclerViewPager</a> ★2288 - 基于RecyclerView的ViewPager替代品</p></li>
<li><p><a href=""https://github.com/ongakuer/CircleIndicator"" rel=""nofollow noreferrer"">CircleIndicator</a> ★2205 - 轻量级ViewPager指示器</p></li>
<li><p><a href=""https://github.com/rubensousa/ViewPagerCards"" rel=""nofollow noreferrer"">ViewPagerCards</a> ★2200 - 视图页卡片</p></li>
<li><p><a href=""https://github.com/romandanylyk/PageIndicatorView"" rel=""nofollow noreferrer"">PageIndicatorView</a> ★1860 - 能够指示选定页的ViewPage</p></li>
<li><p><a href=""https://github.com/githubwing/ZoomHeader"" rel=""nofollow noreferrer"">ZoomHeader</a> ★1717 - 模仿饿了么详情页的例子</p></li>
<li><p><a href=""https://github.com/xmuSistone/android-page-transition"" rel=""nofollow noreferrer"">android-page-transition</a> ★1546 - 带有垂直滑动效果和Activity过渡的ViewPager</p></li>
<li><p><a href=""https://github.com/LuckyJayce/ViewPagerIndicator"" rel=""nofollow noreferrer"">ViewPagerIndicator</a> ★1530 - 布局插件</p></li>
<li><p><a href=""https://github.com/ToxicBakery/ViewPagerTransforms"" rel=""nofollow noreferrer"">ViewPagerTransforms</a> ★1494 - 包含视图页滚动常见动画的库</p></li>
<li><p><a href=""https://github.com/qs-lll/ExpandingPager"" rel=""nofollow noreferrer"">ExpandingPager</a> ★1457 - 卡片peek及pop控件</p></li>
<li><p><a href=""https://github.com/kmshack/Android-ParallaxHeaderViewPager"" rel=""nofollow noreferrer"">Android-ParallaxHeaderViewPager</a> ★1298 - 带标题头的左右滑动</p></li>
<li><p><a href=""https://github.com/alibaba/UltraViewPager"" rel=""nofollow noreferrer"">UltraViewPager</a> ★1275 - 封装多种特性的ViewPager</p></li>
<li><p><a href=""https://github.com/Pixplicity/MultiViewPager"" rel=""nofollow noreferrer"">MultiViewPager</a> ★847 - 支持V4库的ViewPager的扩展</p></li>
<li><p><a href=""https://github.com/chengdazhi/DecentBanner"" rel=""nofollow noreferrer"">DecentBanner</a> ★804 - 基于安卓Banner的ViewPager</p></li>
<li><p><a href=""https://github.com/Telenav/ExpandablePager"" rel=""nofollow noreferrer"">ExpandablePager</a> ★679 - 两个状态（展开和滑动）间的垂直滑动切换</p></li>
<li><p><a href=""https://github.com/antonyt/InfiniteViewPager"" rel=""nofollow noreferrer"">InfiniteViewPager</a> ★579 - 环绕实现首页末页跳转</p></li>
<li><p><a href=""https://github.com/voghDev/PdfViewPager"" rel=""nofollow noreferrer"">PdfViewPager</a> ★561 - 在Activities或Fragments中显示PDF文档</p></li>
<li><p><a href=""https://github.com/ybq/ParallaxViewPager"" rel=""nofollow noreferrer"">ParallaxViewPager</a> ★485 - 安卓视差视图页</p></li>
<li><p><a href=""https://github.com/lightSky/InfiniteIndicator"" rel=""nofollow noreferrer"">InfiniteIndicator</a> ★462 - 视图回收适配器</p></li>
<li><p><a href=""https://github.com/qdxxxx/BezierViewPager"" rel=""nofollow noreferrer"">BezierViewPager</a> ★456 - 触摸贝塞尔圆球式图片展示</p></li>
<li><p><a href=""https://github.com/hongyangAndroid/MagicViewPager"" rel=""nofollow noreferrer"">MagicViewPager</a> ★396 - 单页ViewPager炫酷切换效果</p></li>
<li><p><a href=""https://github.com/jeasonlzy/HeaderViewPager"" rel=""nofollow noreferrer"">HeaderViewPager</a> ★309 - 具有共同头部的 ViewPager</p></li>
<li><p><a href=""https://github.com/youngkaaa/YViewPagerDemo"" rel=""nofollow noreferrer"">YViewPagerDemo</a> ★235 - 水平竖直方向上滑动</p></li>
<li><p><a href=""https://github.com/chaossss/PianoView"" rel=""nofollow noreferrer"">PianoView</a> ★229 - 有趣的类似钢琴键盘的 ViewPager Indicator</p></li>
<li><p><a href=""https://github.com/githubwing/ExpandableViewpager"" rel=""nofollow noreferrer"">ExpandableViewpager</a> ★224 - 可展开缩小的Viewpager</p></li>
<li><p><a href=""https://github.com/BCsl/GalleryLayoutManager"" rel=""nofollow noreferrer"">GalleryLayoutManager</a> ★125 - Android中Gallery或ViewPager控件的效果</p></li>
<li><p><a href=""https://github.com/xingstarx/InkeVerticalViewPagerLive"" rel=""nofollow noreferrer"">InkeVerticalViewPagerLive</a> ★66 - 仿映客上下滑动切换直播demo</p></li>
<li><p><a href=""https://github.com/BeppiMenozzi/ArcPageIndicator"" rel=""nofollow noreferrer"">ArcPageIndicator</a> ★32 - 全自定义超简单的页面指示器</p></li>
</ul>
<h2>图表(Chart)</h2>
<ul>
<li><p><a href=""https://github.com/PhilJay/MPAndroidChart"" rel=""nofollow noreferrer"">MPAndroidChart</a> ★15282 - 安卓图表解决方案</p></li>
<li><p><a href=""https://github.com/lecho/hellocharts-android"" rel=""nofollow noreferrer"">hellocharts-android</a> ★4114 - Android图表库</p></li>
<li><p><a href=""https://github.com/diogobernardino/WilliamChart"" rel=""nofollow noreferrer"">WilliamChart</a> ★3051 - 在应用程序中实现图表的Android库</p></li>
<li><p><a href=""https://github.com/jjoe64/GraphView"" rel=""nofollow noreferrer"">GraphView</a> ★1541 - 通过编程创建灵活好看的图表</p></li>
<li><p><a href=""https://github.com/ZuYun/Jgraph"" rel=""nofollow noreferrer"">Jgraph</a> ★1030 - 可自定义图表</p></li>
<li><p><a href=""https://github.com/HackPlan/AndroidCharts"" rel=""nofollow noreferrer"">AndroidCharts</a> ★920 - 一个简单的Android图表库</p></li>
<li><p><a href=""https://github.com/bmarrdev/android-DecoView-charting"" rel=""nofollow noreferrer"">android-DecoView-charting</a> ★758 - 实现高度可配置动画环形图表</p></li>
<li><p><a href=""https://github.com/robinhood/spark"" rel=""nofollow noreferrer"">spark</a> ★635 - 将任何规模xy点绘制为sparkline图表</p></li>
<li><p><a href=""https://github.com/whataa/SuitLines"" rel=""nofollow noreferrer"">SuitLines</a> ★500 - 小巧且高效的线性图表组件</p></li>
<li><p><a href=""https://github.com/DmitriyZaitsev/RadarChartView"" rel=""nofollow noreferrer"">RadarChartView</a> ★412 - 渲染径向图的Android视图</p></li>
<li><p><a href=""https://github.com/hrules6872/Charter"" rel=""nofollow noreferrer"">Charter</a> ★192 - 简易图表</p></li>
<li><p><a href=""https://github.com/qstumn/RadarChart"" rel=""nofollow noreferrer"">RadarChart</a> ★184 - 自由定制旋转交互的Android雷达图</p></li>
<li><p><a href=""https://github.com/JeasonWong/AndroidChart"" rel=""nofollow noreferrer"">AndroidChart</a> ★156 - 简单的安卓分时行情页</p></li>
<li><p><a href=""https://github.com/danimahardhika/candybar-library"" rel=""nofollow noreferrer"">candybar-library</a> ★90 - Android图表包装材料面板</p></li>
<li><p><a href=""https://github.com/mancj/SlimChart"" rel=""nofollow noreferrer"">SlimChart</a> ★77 - 轻量级便于使用的图表库</p></li>
<li><p><a href=""https://github.com/Cuieney/BarChart-master"" rel=""nofollow noreferrer"">BarChart-master</a> ★23 - 自动伸缩的chart</p></li>
<li><p><a href=""https://github.com/Andy671/PianoChartView"" rel=""nofollow noreferrer"">PianoChartView</a> ★20 - 显示钢琴和弦比例尺图</p></li>
</ul>
<h2>菜单(Menu)</h2>
<ul>
<li><p><a href=""https://github.com/levey/AwesomeMenu"" rel=""nofollow noreferrer"">AwesomeMenu</a> ★5069 - 与Path的故事菜单具有相同外观的菜单</p></li>
<li><p><a href=""https://github.com/Yalantis/Context-Menu.Android"" rel=""nofollow noreferrer"">Context-Menu.Android</a> ★2884 - 独特的动画内容菜单</p></li>
<li><p><a href=""https://github.com/dongjunkun/DropDownMenu"" rel=""nofollow noreferrer"">DropDownMenu</a> ★1912 - 多条件筛选菜单</p></li>
<li><p><a href=""https://github.com/ShamylZakariya/FlyoutMenus"" rel=""nofollow noreferrer"">FlyoutMenus</a> ★805 - Android简易MD风格弹出菜单</p></li>
<li><p><a href=""https://github.com/michaldrabik/TapBarMenu"" rel=""nofollow noreferrer"">TapBarMenu</a> ★781 - Tap Bar菜单布局</p></li>
<li><p><a href=""https://github.com/Hitomis/CircleMenu"" rel=""nofollow noreferrer"">CircleMenu</a> ★701 - 具有设计感的菜单</p></li>
<li><p><a href=""https://github.com/Hitomis/SpinMenu"" rel=""nofollow noreferrer"">SpinMenu</a> ★634 - 轮播样式的Fragment菜单选择空间</p></li>
<li><p><a href=""https://github.com/baiiu/DropDownMenu"" rel=""nofollow noreferrer"">DropDownMenu</a> ★596 - 完整的筛选器解决方案</p></li>
<li><p><a href=""https://github.com/gotokatsuya/BlurredGridMenu"" rel=""nofollow noreferrer"">BlurredGridMenu</a> ★464 - 酷炫网格菜单</p></li>
<li><p><a href=""https://github.com/Hitomis/ThumbnailMenu"" rel=""nofollow noreferrer"">ThumbnailMenu</a> ★412 - 简单而精致的Fragment菜单控件</p></li>
<li><p><a href=""https://github.com/zaaach/TopRightMenu"" rel=""nofollow noreferrer"">TopRightMenu</a> ★319 - 仿手机QQ界面右上角的弹出菜单</p></li>
<li><p><a href=""https://github.com/Cleveroad/CycleMenu"" rel=""nofollow noreferrer"">CycleMenu</a> ★230 - 圆形菜单</p></li>
<li><p><a href=""https://github.com/stewForAni/CircleProgressMenu"" rel=""nofollow noreferrer"">CircleProgressMenu</a> ★104 - 带有进度效果的简单环形菜单</p></li>
<li><p><a href=""https://github.com/desnyki/InfinityMenu"" rel=""nofollow noreferrer"">InfinityMenu</a> ★65 - 实现手风琴样式菜单的Android库</p></li>
<li><p><a href=""https://github.com/kareluo/PopupMenuView"" rel=""nofollow noreferrer"">PopupMenuView</a> ★55 - iOS中弹框气泡菜单的控件</p></li>
<li><p><a href=""https://github.com/cpacm/FloatingMusicMenu"" rel=""nofollow noreferrer"">FloatingMusicMenu</a> ★42 - 用于音乐播放器的悬浮菜单按钮</p></li>
<li><p><a href=""https://github.com/AlexLiuSheng/CircleMenuView"" rel=""nofollow noreferrer"">CircleMenuView</a> ★40 - 自定义圆形菜单</p></li>
<li><p><a href=""https://github.com/lichenyu10/SlidMenu"" rel=""nofollow noreferrer"">SlidMenu</a> ★25 - 轮盘样式的Fragment菜单选择控件</p></li>
<li><p><a href=""https://github.com/Rance935/SectorMenu"" rel=""nofollow noreferrer"">SectorMenu</a> ★12 - 炫酷的扇形菜单</p></li>
</ul>
<h2>浮动菜单</h2>
<ul>
<li><p><a href=""https://github.com/Nightonke/BoomMenu"" rel=""nofollow noreferrer"">BoomMenu</a> ★3479 - 具有炸裂效果的菜单按钮</p></li>
<li><p><a href=""https://github.com/oguzbilgener/CircularFloatingActionMenu"" rel=""nofollow noreferrer"">CircularFloatingActionMenu</a> ★1931 - 自定义圆形浮动动画菜单</p></li>
<li><p><a href=""https://github.com/michaldrabik/TapBarMenu"" rel=""nofollow noreferrer"">TapBarMenu</a> ★781 - Tap Bar菜单布局</p></li>
<li><p><a href=""https://github.com/Karumi/ExpandableSelector"" rel=""nofollow noreferrer"">ExpandableSelector</a> ★568 - 动画的折叠或展开按钮列表</p></li>
<li><p><a href=""https://github.com/ImangazalievM/CircleMenu"" rel=""nofollow noreferrer"">CircleMenu</a> ★560 - 简单的优雅的菜单</p></li>
<li><p><a href=""https://github.com/kakajika/RelativePopupWindow"" rel=""nofollow noreferrer"">RelativePopupWindow</a> ★539 - 轻松对锚视图相对定位</p></li>
<li><p><a href=""https://github.com/gjiazhe/MultiChoicesCircleButton"" rel=""nofollow noreferrer"">MultiChoicesCircleButton</a> ★299 - 带3d视差效果的多选按钮</p></li>
<li><p><a href=""https://github.com/tiancaiCC/SpringFloatingActionMenu"" rel=""nofollow noreferrer"">SpringFloatingActionMenu</a> ★278 - 点击FAB弹出菜单</p></li>
<li><p><a href=""https://github.com/crosg/FloatMenuSample"" rel=""nofollow noreferrer"">FloatMenuSample</a> ★249 - android 悬浮窗菜单</p></li>
<li><p><a href=""https://github.com/xue5455/SmartMenu"" rel=""nofollow noreferrer"">SmartMenu</a> ★174 - 一个优美的浮动菜单</p></li>
<li><p><a href=""https://github.com/joelan/WeiboPopupMenu"" rel=""nofollow noreferrer"">WeiboPopupMenu</a> ★14 - 仿微博添加按钮弹出菜单</p></li>
</ul>
<h2>对话框</h2>
<ul>
<li><p><a href=""https://github.com/afollestad/material-dialogs"" rel=""nofollow noreferrer"">Material Dialogs</a> ★9477 - 安卓Material风格对话框</p></li>
<li><p><a href=""https://github.com/orhanobut/dialogplus"" rel=""nofollow noreferrer"">dialogplus</a> ★3106 - 对话框动画</p></li>
<li><p><a href=""https://github.com/sd6352051/NiftyDialogEffects"" rel=""nofollow noreferrer"">NiftyDialogEffects</a> ★2009 - Nifty模式对话框效果</p></li>
<li><p><a href=""https://github.com/yipianfengye/android-adDialog"" rel=""nofollow noreferrer"">android-adDialog</a> ★1611 - 简单强大的广告活动弹窗控件</p></li>
<li><p><a href=""https://github.com/tvbarthel/BlurDialogFragment"" rel=""nofollow noreferrer"">BlurDialogFragment</a> ★1496 - 背景模糊效果的DialogFragment</p></li>
<li><p><a href=""https://github.com/saiwu-bigkoo/Android-AlertView"" rel=""nofollow noreferrer"">Android-AlertView</a> ★810 - 仿iOS的AlertViewController</p></li>
<li><p><a href=""https://github.com/Meetic/MaryPopup"" rel=""nofollow noreferrer"">MaryPopup</a> ★804 - 无忧扩展视图</p></li>
<li><p><a href=""https://github.com/javiersantos/MaterialStyledDialogs"" rel=""nofollow noreferrer"">MaterialStyledDialogs</a> ★786 - 显示优美可定制的Android对话框</p></li>
<li><p><a href=""https://github.com/shaohui10086/BottomDialog"" rel=""nofollow noreferrer"">BottomDialog</a> ★715 - 底部弹窗布局</p></li>
<li><p><a href=""https://github.com/kakajika/SwipeAwayDialog"" rel=""nofollow noreferrer"">SwipeAwayDialog</a> ★690 - 实现滑动取消对话框</p></li>
<li><p><a href=""https://github.com/yarolegovich/LovelyDialog"" rel=""nofollow noreferrer"">LovelyDialog</a> ★620 - 帮助你轻松的创建流行的MD风格对话框</p></li>
<li><p><a href=""https://github.com/michaelye/EasyDialog"" rel=""nofollow noreferrer"">EasyDialog</a> ★532 - Android轻量级提示对话框</p></li>
<li><p><a href=""https://github.com/hss01248/DialogUtil"" rel=""nofollow noreferrer"">DialogUtil</a> ★315 - 任意界面弹出框</p></li>
<li><p><a href=""https://github.com/geniusforapp/fancyDialog"" rel=""nofollow noreferrer"">fancyDialog</a> ★298 - Android自定义提示框</p></li>
<li><p><a href=""https://github.com/weavey/NormalSelectDialog"" rel=""nofollow noreferrer"">NormalSelectDialog</a> ★234 - 常见布局封装</p></li>
<li><p><a href=""https://github.com/Zhaoss/HintPopupWindow"" rel=""nofollow noreferrer"">HintPopupWindow</a> ★204 - 仿qq弹出方式</p></li>
<li><p><a href=""https://github.com/SpikeKing/BottomDialogDemo"" rel=""nofollow noreferrer"">BottomDialogDemo</a> ★197 - 使用 DialogFragment 实现底部弹窗布局</p></li>
<li><p><a href=""https://github.com/codemybrainsout/PlaceSearchDialog"" rel=""nofollow noreferrer"">PlaceSearchDialog</a> ★153 - 位置自动搜索对话框</p></li>
<li><p><a href=""https://github.com/jjdxmashl/jjdxm_dialogui"" rel=""nofollow noreferrer"">jjdxm_dialogui</a> ★96 - 多种弹出框样式</p></li>
<li><p><a href=""https://github.com/1em0nsOft/LemonHello4Android"" rel=""nofollow noreferrer"">LemonHello4Android</a> ★73 - 内置多种主题提示框</p></li>
<li><p><a href=""https://github.com/kngfrhzs/panter-dialog"" rel=""nofollow noreferrer"">panter-dialog</a> ★68 - 丰富样式的Android对话框</p></li>
<li><p><a href=""https://github.com/t-kurimura/flickabledialog"" rel=""nofollow noreferrer"">flickabledialog</a> ★48 - 通过轻滑实现取消效果</p></li>
<li><p><a href=""https://github.com/GitPhoenix/WheelDialogFragment"" rel=""nofollow noreferrer"">WheelDialogFragment</a> ★15 - 用于时间选择城市选择的对话框</p></li>
<li><p><a href=""https://github.com/loonggg/BottomSheetPopupDialog"" rel=""nofollow noreferrer"">BottomSheetPopupDialog</a> ★5 - 底部弹出框</p></li>
</ul>
<h2>空白页</h2>
<ul>
<li><p><a href=""https://github.com/Kennyc1012/MultiStateView"" rel=""nofollow noreferrer"">MultiStateView</a> ★760 - 基于状态显示不同内容的Android视图</p></li>
<li><p><a href=""https://github.com/vlonjatg/progress-activity"" rel=""nofollow noreferrer"">progress-activity</a> ★743 - 进度条空视图及错误视图库</p></li>
<li><p><a href=""https://github.com/iammert/StatusView"" rel=""nofollow noreferrer"">StatusView</a> ★546 - Android自定义状态视图</p></li>
<li><p><a href=""https://github.com/gturedi/StatefulLayout"" rel=""nofollow noreferrer"">StatefulLayout</a> ★530 - 显示最常见的状态模板</p></li>
<li><p><a href=""https://github.com/xiprox/ErrorView"" rel=""nofollow noreferrer"">ErrorView</a> ★519 - 显示错误信息的自定义视图</p></li>
<li><p><a href=""https://github.com/weavey/LoadingLayoutDemo"" rel=""nofollow noreferrer"">LoadingLayoutDemo</a> ★483 - 加载中/无网络/无数据/出错四种情况效果封装</p></li>
<li><p><a href=""https://github.com/qyxxjd/MultipleStatusView"" rel=""nofollow noreferrer"">MultipleStatusView</a> ★439 - 支持多种状态的自定义View</p></li>
<li><p><a href=""https://github.com/barryhappy/TEmptyView"" rel=""nofollow noreferrer"">TEmptyView</a> ★424 - 更简单地设置EmptyView</p></li>
<li><p><a href=""https://github.com/fingdo/stateLayout"" rel=""nofollow noreferrer"">stateLayout</a> ★351 - 快速switch布局</p></li>
<li><p><a href=""https://github.com/czy1121/loadinglayout"" rel=""nofollow noreferrer"">loadinglayout</a> ★296 - 简单实用的页面多状态布局</p></li>
<li><p><a href=""https://github.com/WassimBenltaief/FlowLayout"" rel=""nofollow noreferrer"">FlowLayout</a> ★217 - 非常常见的安卓视图流</p></li>
<li><p><a href=""https://github.com/XuDaojie/MultiStateView"" rel=""nofollow noreferrer"">MultiStateView</a> ★178 - 用于切换不同View的各种状态</p></li>
<li><p><a href=""https://github.com/WangGanxin/LoadDataLayout"" rel=""nofollow noreferrer"">LoadDataLayout</a> ★163 - 加载数据Layout</p></li>
<li><p><a href=""https://github.com/nguyenhoanglam/ProgressLayout"" rel=""nofollow noreferrer"">ProgressLayout</a> ★98 - 展示加载布局空白布局和error布局</p></li>
<li><p><a href=""https://github.com/hss01248/PageStateManager"" rel=""nofollow noreferrer"">PageStateManager</a> ★78 - 页面状态管理</p></li>
<li><p><a href=""https://github.com/hcs-xph/HHEmptyView"" rel=""nofollow noreferrer"">HHEmptyView</a> ★35 - 网络加载提示进度封装View</p></li>
<li><p><a href=""https://github.com/lvleo/DataLoadingLayoutAndroid"" rel=""nofollow noreferrer"">DataLoadingLayoutAndroid</a> ★15 - 展示当前数据加载状态的库</p></li>
</ul>
<h2>滑动删除</h2>
<ul>
<li><p><a href=""https://github.com/daimajia/AndroidSwipeLayout"" rel=""nofollow noreferrer"">AndroidSwipeLayout</a> ★7804 - 安卓滑动出现子菜单</p></li>
<li><p><a href=""https://github.com/yanzhenjie/SwipeRecyclerView"" rel=""nofollow noreferrer"">SwipeRecyclerView</a> ★1579 - RecyclerView侧滑菜单</p></li>
<li><p><a href=""https://github.com/kikoso/Swipeable-Cards"" rel=""nofollow noreferrer"">Swipeable-Cards</a> ★1368 - 提供类似Tinder卡片效果</p></li>
<li><p><a href=""https://github.com/HoneyNeutrons/RecyclerViewUndoSwipe"" rel=""nofollow noreferrer"">RecyclerViewUndoSwipe</a> ★1263 - 本地ItemTouch助手</p></li>
<li><p><a href=""https://github.com/flschweiger/SwipeStack"" rel=""nofollow noreferrer"">SwipeStack</a> ★1118 - 安卓纸质视图栈</p></li>
<li><p><a href=""https://github.com/mcxtzhang/SwipeDelMenuLayout"" rel=""nofollow noreferrer"">SwipeDelMenuLayout</a> ★887 - 仿IOS侧滑Item删除菜单</p></li>
<li><p><a href=""https://github.com/loopeer/itemtouchhelper-extension"" rel=""nofollow noreferrer"">itemtouchhelper-extension</a> ★795 - 添加滑动条目处理</p></li>
<li><p><a href=""https://github.com/TUBB/SwipeMenu"" rel=""nofollow noreferrer"">SwipeMenu</a> ★636 - 滑动菜单</p></li>
<li><p><a href=""https://github.com/wenchaojiang/AndroidSwipeableCardStack"" rel=""nofollow noreferrer"">AndroidSwipeableCardStack</a> ★545 - 流畅的纸质卡片组件</p></li>
<li><p><a href=""https://github.com/chthai64/SwipeRevealLayout"" rel=""nofollow noreferrer"">SwipeRevealLayout</a> ★490 - 通过swipe及slide显示另一个布局</p></li>
<li><p><a href=""https://github.com/Qiaoidea/QQTipsView"" rel=""nofollow noreferrer"">QQTipsView</a> ★471 - 仿QQ消息未读拖拽清除</p></li>
<li><p><a href=""https://github.com/huxq17/SwipeCardsView"" rel=""nofollow noreferrer"">SwipeCardsView</a> ★361 - Android高仿秒拍热榜的卡片滑动和左右飞出效果</p></li>
<li><p><a href=""https://github.com/HalfStackDeveloper/SwipeCardRecyclerView"" rel=""nofollow noreferrer"">SwipeCardRecyclerView</a> ★234 - 炫酷滑动卡片</p></li>
<li><p><a href=""https://github.com/yanbober/SlideLayout"" rel=""nofollow noreferrer"">SlideLayout</a> ★176 - 全方向完美滑动处理侧滑控件</p></li>
<li><p><a href=""https://github.com/yuqirong/CardSwipeLayout"" rel=""nofollow noreferrer"">CardSwipeLayout</a> ★172 - RecyclerView卡片滑动布局</p></li>
<li><p><a href=""https://github.com/alexandrius/accordion-swipe-layout"" rel=""nofollow noreferrer"">accordion-swipe-layout</a> ★69 - Android手风琴滑动布局</p></li>
</ul>
<h2>手势操作</h2>
<ul>
<li><p><a href=""https://github.com/nisrulz/sensey"" rel=""nofollow noreferrer"">sensey</a> ★1890 - 手势交互Android库</p></li>
<li><p><a href=""https://github.com/alexvasilkov/GestureViews"" rel=""nofollow noreferrer"">GestureViews</a> ★1184 - 手势控制和位置动画</p></li>
<li><p><a href=""https://github.com/zhaozhentao/InboxLayout"" rel=""nofollow noreferrer"">InboxLayout</a> ★641 - 仿谷歌下拉返回效果</p></li>
<li><p><a href=""https://github.com/pkarira/Swipper"" rel=""nofollow noreferrer"">Swipper</a> ★47 - 控制亮度的自定义视图</p></li>
</ul>
<h2>RecyclerView</h2>
<ul>
<li><p><a href=""https://github.com/CymChad/BaseRecyclerViewAdapterHelper"" rel=""nofollow noreferrer"">BaseRecyclerViewAdapterHelper</a> ★6876 - 强大灵活的RecyclerAdapter</p></li>
<li><p><a href=""https://github.com/wasabeef/recyclerview-animators"" rel=""nofollow noreferrer"">recyclerview-animators</a> ★5977 - 轻松创建动画RecyclerView</p></li>
<li><p><a href=""https://github.com/cymcsg/UltimateRecyclerView"" rel=""nofollow noreferrer"">UltimateRecyclerView</a> ★5332 - 功能强大的Recyclerview</p></li>
<li><p><a href=""https://github.com/alibaba/vlayout"" rel=""nofollow noreferrer"">vlayout</a> ★3453 - 布局方案和布局间的组件复用</p></li>
<li><p><a href=""https://github.com/h6ah4i/android-advancedrecyclerview"" rel=""nofollow noreferrer"">android-advancedrecyclerview</a> ★3188 - 提供高级特性的RecyclerView扩展</p></li>
<li><p><a href=""https://github.com/airbnb/epoxy"" rel=""nofollow noreferrer"">epoxy</a> ★2771 - Airbnb安卓视图架构</p></li>
<li><p><a href=""https://github.com/jianghejie/XRecyclerView"" rel=""nofollow noreferrer"">XRecyclerView</a> ★2752 - 下拉刷新和加载更多</p></li>
<li><p><a href=""https://github.com/hongyangAndroid/baseAdapter"" rel=""nofollow noreferrer"">baseAdapter</a> ★2475 - Android 万能的Adapter</p></li>
<li><p><a href=""https://github.com/Malinskiy/SuperRecyclerView"" rel=""nofollow noreferrer"">SuperRecyclerView</a> ★2431 - 轻松制作可使用的RecyclerView</p></li>
<li><p><a href=""https://github.com/lsjwzh/RecyclerViewPager"" rel=""nofollow noreferrer"">RecyclerViewPager</a> ★2288 - 基于RecyclerView的ViewPager替代品</p></li>
<li><p><a href=""https://github.com/yarolegovich/DiscreteScrollView"" rel=""nofollow noreferrer"">DiscreteScrollView</a> ★2216 - 基于RecyclerView的滚动列表实现</p></li>
<li><p><a href=""https://github.com/drakeet/MultiType"" rel=""nofollow noreferrer"">MultiType</a> ★1823 - 快速清晰的开发复杂列表页面</p></li>
<li><p><a href=""https://github.com/yanzhenjie/SwipeRecyclerView"" rel=""nofollow noreferrer"">SwipeRecyclerView</a> ★1579 - RecyclerView侧滑菜单</p></li>
<li><p><a href=""https://github.com/mikepenz/FastAdapter"" rel=""nofollow noreferrer"">FastAdapter</a> ★1517 - 简化RecyclerView配置过程</p></li>
<li><p><a href=""https://github.com/kanytu/android-parallax-recyclerview"" rel=""nofollow noreferrer"">android-parallax-recyclerview</a> ★1429 - Android 视差 RecycleView</p></li>
<li><p><a href=""https://github.com/Jude95/EasyRecyclerView"" rel=""nofollow noreferrer"">EasyRecyclerView</a> ★1382 - 常用的RecyclerView的各种需求封装</p></li>
<li><p><a href=""https://github.com/huazhiyuan2008/RecyclerViewCardGallery"" rel=""nofollow noreferrer"">RecyclerViewCardGallery</a> ★1380 - RecyclerView实现Card Gallery效果</p></li>
<li><p><a href=""https://github.com/HoneyNeutrons/RecyclerViewUndoSwipe"" rel=""nofollow noreferrer"">RecyclerViewUndoSwipe</a> ★1263 - 本地ItemTouch助手</p></li>
<li><p><a href=""https://github.com/zhouchaoyuan/excelPanel"" rel=""nofollow noreferrer"">excelPanel</a> ★1229 - 仿Excel表格的RecyclerView</p></li>
<li><p><a href=""https://github.com/jdsjlzx/LRecyclerView"" rel=""nofollow noreferrer"">LRecyclerView</a> ★1220 - 多功能RecyclerView</p></li>
<li><p><a href=""https://github.com/sharish/ShimmerRecyclerView"" rel=""nofollow noreferrer"">ShimmerRecyclerView</a> ★1077 - 展现视图加载中的视图</p></li>
<li><p><a href=""https://github.com/blipinsk/RecyclerViewHeader"" rel=""nofollow noreferrer"">RecyclerViewHeader</a> ★1060 - 为安卓RecyclerView创建header</p></li>
<li><p><a href=""https://github.com/EverythingMe/overscroll-decor"" rel=""nofollow noreferrer"">overscroll-decor</a> ★1048 - Android的仿iOS滚动效果</p></li>
<li><p><a href=""https://github.com/pedrovgs/Renderers"" rel=""nofollow noreferrer"">Renderers</a> ★1023 - 创建适配器的Android库</p></li>
<li><p><a href=""https://github.com/afollestad/drag-select-recyclerview"" rel=""nofollow noreferrer"">drag-select-recyclerview</a> ★957 - 实现GooglePhoto样式多选择</p></li>
<li><p><a href=""https://github.com/WuXiaolong/PullLoadMoreRecyclerView"" rel=""nofollow noreferrer"">PullLoadMoreRecyclerView</a> ★903 - 上拉刷新加载</p></li>
<li><p><a href=""https://github.com/danoz73/RecyclerViewFastScroller"" rel=""nofollow noreferrer"">RecyclerViewFastScroller</a> ★873 - 连接到RecyclerView实现快速滚动</p></li>
<li><p><a href=""https://github.com/jaychang0917/SimpleRecyclerView"" rel=""nofollow noreferrer"">SimpleRecyclerView</a> ★845 - 轻松创建列表的RecyclerView扩展</p></li>
<li><p><a href=""https://github.com/jiang111/IndexRecyclerView"" rel=""nofollow noreferrer"">IndexRecyclerView</a> ★824 - 使用Recyclerview实现的联系人列表</p></li>
<li><p><a href=""https://github.com/Genius/groupie"" rel=""nofollow noreferrer"">groupie</a> ★802 - 显示并管理复杂的RecyclerView布局</p></li>
<li><p><a href=""https://github.com/nikhilpanju/RecyclerViewEnhanced"" rel=""nofollow noreferrer"">RecyclerViewEnhanced</a> ★760 - 条目滑动点击安卓库</p></li>
<li><p><a href=""https://github.com/ShamylZakariya/StickyHeaders"" rel=""nofollow noreferrer"">StickyHeaders</a> ★741 - 安卓RecyclerView的适配器和布局管理器</p></li>
<li><p><a href=""https://github.com/Solartisan/WaveSideBar"" rel=""nofollow noreferrer"">WaveSideBar</a> ★726 - 快速跳跃分组的侧边栏控件</p></li>
<li><p><a href=""https://github.com/timusus/RecyclerView-FastScroll"" rel=""nofollow noreferrer"">RecyclerView-FastScroll</a> ★706 - 简单的FastScroller</p></li>
<li><p><a href=""https://github.com/zaihuishou/ExpandableRecyclerview"" rel=""nofollow noreferrer"">ExpandableRecyclerview</a> ★691 - ExpandableRecycler适配器</p></li>
<li><p><a href=""https://github.com/Frank-Zhu/AndroidRecyclerViewDemo"" rel=""nofollow noreferrer"">AndroidRecyclerViewDemo</a> ★613 - 安卓RecyclerView 示例</p></li>
<li><p><a href=""https://github.com/AleBarreto/DragRecyclerView"" rel=""nofollow noreferrer"">DragRecyclerView</a> ★562 - 在RecyclerView中拖拽的简单实现</p></li>
<li><p><a href=""https://github.com/drakeet/RecyclerViewWithHeaderNewPractice"" rel=""nofollow noreferrer"">RecyclerViewWithHeaderNewPractice</a> ★533 - 结合HeaderView的RecyclerView新实现</p></li>
<li><p><a href=""https://github.com/truizlop/SectionedRecyclerView"" rel=""nofollow noreferrer"">SectionedRecyclerView</a> ★530 - 安卓RecyclerView 适配器</p></li>
<li><p><a href=""https://github.com/L4Digital/FastScroll"" rel=""nofollow noreferrer"">FastScroll</a> ★525 - 类似列表视图的FastScroller</p></li>
<li><p><a href=""https://github.com/shichaohui/AnimRefreshRecyclerView"" rel=""nofollow noreferrer"">AnimRefreshRecyclerView</a> ★522 - 下拉刷新和上拉加载更多的RecyclerView</p></li>
<li><p><a href=""https://github.com/radzio/android-data-binding-recyclerview"" rel=""nofollow noreferrer"">android-data-binding-recyclerview</a> ★478 - 配有Android数据绑定的RecyclerView</p></li>
<li><p><a href=""https://github.com/bingoogolapple/BGAAdapter-Android"" rel=""nofollow noreferrer"">BGAAdapter-Android</a> ★437 - 通用的Adapter和ViewHolder</p></li>
<li><p><a href=""https://github.com/kHRYSTAL/CircleRecyclerView"" rel=""nofollow noreferrer"">CircleRecyclerView</a> ★421 - 一个循环RecyclerView</p></li>
<li><p><a href=""https://github.com/iwgang/FamiliarRecyclerView"" rel=""nofollow noreferrer"">FamiliarRecyclerView</a> ★354 - RecyclerView类库</p></li>
<li><p><a href=""https://github.com/LuckyJayce/MultiTypeView"" rel=""nofollow noreferrer"">MultiTypeView</a> ★306 - 复杂界面分多个模块开发</p></li>
<li><p><a href=""https://github.com/AlphaBoom/ClassifyView"" rel=""nofollow noreferrer"">ClassifyView</a> ★284 - 拖拽合并的RecyclerView</p></li>
<li><p><a href=""https://github.com/wuapnjie/SuspensionBar"" rel=""nofollow noreferrer"">SuspensionBar</a> ★249 - Android轻松实现RecyclerView悬浮条</p></li>
<li><p><a href=""https://github.com/TellH/RecyclerStickyHeaderView"" rel=""nofollow noreferrer"">RecyclerStickyHeaderView</a> ★241 - RecyclerView的悬浮视图</p></li>
<li><p><a href=""https://github.com/HalfStackDeveloper/SwipeCardRecyclerView"" rel=""nofollow noreferrer"">SwipeCardRecyclerView</a> ★234 - 炫酷滑动卡片</p></li>
<li><p><a href=""https://github.com/MFlisar/DragSelectRecyclerView"" rel=""nofollow noreferrer"">DragSelectRecyclerView</a> ★218 - 简单的触摸监听类</p></li>
<li><p><a href=""https://github.com/songhanghang/Smart-HeaderFooter-RecyclerView"" rel=""nofollow noreferrer"">Smart-HeaderFooter-RecyclerView</a> ★198 - 将Recyclerview添加HeaderView和FooterView</p></li>
<li><p><a href=""https://github.com/myinnos/AlphabetIndex-Fast-Scroll-RecyclerView"" rel=""nofollow noreferrer"">AlphabetIndex-Fast-Scroll-RecyclerView</a> ★169 - 强大的AlphabetIndex FastScroller</p></li>
<li><p><a href=""https://github.com/leoleohan/RecyclerRefresh"" rel=""nofollow noreferrer"">RecyclerRefresh</a> ★158 - 仿简书安卓端</p></li>
<li><p><a href=""https://github.com/TellH/RecyclerTreeView"" rel=""nofollow noreferrer"">RecyclerTreeView</a> ★150 - 安卓的TreeView实现</p></li>
<li><p><a href=""https://github.com/ssseasonnn/PracticalRecyclerView"" rel=""nofollow noreferrer"">PracticalRecyclerView</a> ★140 - RecyclerView的一个封装</p></li>
<li><p><a href=""https://github.com/limedroid/ARecyclerView"" rel=""nofollow noreferrer"">ARecyclerView</a> ★105 - 一个库搞定recyclerview</p></li>
<li><p><a href=""https://github.com/gjiazhe/SpringRecyclerView"" rel=""nofollow noreferrer"">SpringRecyclerView</a> ★88 - 具有弹簧效果的RecyclerView</p></li>
<li><p><a href=""https://github.com/10clouds/InifiniteRecyclerView"" rel=""nofollow noreferrer"">InifiniteRecyclerView</a> ★61 - 实现无尽加载列表</p></li>
<li><p><a href=""https://github.com/oubowu/StickyItemDecoration"" rel=""nofollow noreferrer"">StickyItemDecoration</a> ★58 - RecyclerView粘性头部</p></li>
<li><p><a href=""https://github.com/IntruderShanky/Sectioned-RecyclerView"" rel=""nofollow noreferrer"">Sectioned-RecyclerView</a> ★55 - 带header和item的RecyclerView的简单实现方式</p></li>
<li><p><a href=""https://github.com/youngkaaa/RecyclerAnimations"" rel=""nofollow noreferrer"">RecyclerAnimations</a> ★46 - item滑动时的循环动画</p></li>
<li><p><a href=""https://github.com/tikivn/NoAdapter"" rel=""nofollow noreferrer"">NoAdapter</a> ★45 - 使用RecyclerView实现一个列表</p></li>
<li><p><a href=""https://github.com/LinLshare/StickyRecyclerSettingView"" rel=""nofollow noreferrer"">StickyRecyclerSettingView</a> ★45 - 快速在Android上建立SettingActivity</p></li>
<li><p><a href=""https://github.com/rubengees/EasyHeaderFooterAdapter"" rel=""nofollow noreferrer"">EasyHeaderFooterAdapter</a> ★32 - 在RecyclerView中添加header或者footer</p></li>
<li><p><a href=""https://github.com/laobie/RecyclerViewDivider"" rel=""nofollow noreferrer"">RecyclerViewDivider</a> ★25 - 为RecyclerView设置分频器</p></li>
<li><p><a href=""https://github.com/yuyuyu123/SwipeCardsRecyclerView"" rel=""nofollow noreferrer"">SwipeCardsRecyclerView</a> ★20 - 基于RecyclerView的Android组件</p></li>
<li><p><a href=""https://github.com/AndroidMsky/GlideScrollRecyclerView"" rel=""nofollow noreferrer"">GlideScrollRecyclerView</a> ★19 - RecyclerView优先加载可见item</p></li>
<li><p><a href=""https://github.com/nukc/RecyclerAdapter"" rel=""nofollow noreferrer"">RecyclerAdapter</a> ★14 - 简化封装RecyclerView.Adapter</p></li>
</ul>
<h2>Card</h2>
<ul>
<li><p><a href=""https://github.com/Ramotion/folding-cell-android"" rel=""nofollow noreferrer"">folding-cell-android</a> ★2556 - 安卓FoldingCell</p></li>
<li><p><a href=""https://github.com/rubensousa/ViewPagerCards"" rel=""nofollow noreferrer"">ViewPagerCards</a> ★2200 - 视图页卡片</p></li>
<li><p><a href=""https://github.com/huazhiyuan2008/RecyclerViewCardGallery"" rel=""nofollow noreferrer"">RecyclerViewCardGallery</a> ★1380 - RecyclerView实现Card Gallery效果</p></li>
<li><p><a href=""https://github.com/kikoso/Swipeable-Cards"" rel=""nofollow noreferrer"">Swipeable-Cards</a> ★1368 - 提供类似Tinder卡片效果</p></li>
<li><p><a href=""https://github.com/flschweiger/SwipeStack"" rel=""nofollow noreferrer"">SwipeStack</a> ★1118 - 安卓纸质视图栈</p></li>
<li><p><a href=""https://github.com/xiepeijie/SwipeCardView"" rel=""nofollow noreferrer"">SwipeCardView</a> ★999 - 基于Diolor的Swipecards控件改进实现</p></li>
<li><p><a href=""https://github.com/loopeer/CardStackView"" rel=""nofollow noreferrer"">CardStackView</a> ★936 - 以三种动画效果像卡片一样展示内容</p></li>
<li><p><a href=""https://github.com/jeasonlzy/NineGridView"" rel=""nofollow noreferrer"">NineGridView</a> ★791 - 展示图片的九宫格控件</p></li>
<li><p><a href=""https://github.com/mxn21/SlidingCard"" rel=""nofollow noreferrer"">SlidingCard</a> ★618 - 画廊效果的幻灯片卡片</p></li>
<li><p><a href=""https://github.com/ldoublem/GiftCard"" rel=""nofollow noreferrer"">GiftCard</a> ★571 - Android漂亮的礼物卡片</p></li>
<li><p><a href=""https://github.com/wenchaojiang/AndroidSwipeableCardStack"" rel=""nofollow noreferrer"">AndroidSwipeableCardStack</a> ★545 - 流畅的纸质卡片组件</p></li>
<li><p><a href=""https://github.com/lawloretienne/TinderStack"" rel=""nofollow noreferrer"">TinderStack</a> ★523 - 一叠类似Tinder的卡片</p></li>
<li><p><a href=""https://github.com/BakerJQ/Android-InfiniteCards"" rel=""nofollow noreferrer"">Android-InfiniteCards</a> ★466 - 可自定义动效的卡片切换视图</p></li>
<li><p><a href=""https://github.com/huxq17/SwipeCardsView"" rel=""nofollow noreferrer"">SwipeCardsView</a> ★361 - Android高仿秒拍热榜的卡片滑动和左右飞出效果</p></li>
<li><p><a href=""https://github.com/vivian8725118/CardView"" rel=""nofollow noreferrer"">CardView</a> ★200 - 类似小票效果的卡片列表</p></li>
<li><p><a href=""https://github.com/yuqirong/CardSwipeLayout"" rel=""nofollow noreferrer"">CardSwipeLayout</a> ★172 - RecyclerView卡片滑动布局</p></li>
<li><p><a href=""https://github.com/wensefu/StackCardsView"" rel=""nofollow noreferrer"">StackCardsView</a> ★44 - 堆叠滑动控件</p></li>
<li><p><a href=""https://github.com/czy1121/turncardlistview"" rel=""nofollow noreferrer"">turncardlistview</a> ★30 - 上下翻页的卡片列表</p></li>
<li><p><a href=""https://github.com/yuyuyu123/SwipeCardsRecyclerView"" rel=""nofollow noreferrer"">SwipeCardsRecyclerView</a> ★20 - 基于RecyclerView的Android组件</p></li>
</ul>
<h2>Color</h2>
<ul>
<li><p><a href=""https://github.com/Taishi-Y/InstagramLikeColorTransitionAndroid"" rel=""nofollow noreferrer"">InstagramLikeColorTransitionAndroid</a> ★352 - 创建类似渐变颜色过渡的Instagram</p></li>
<li><p><a href=""https://github.com/skydoves/ColorPickerView"" rel=""nofollow noreferrer"">ColorPickerView</a> ★278 - 从图片中获取颜色</p></li>
<li><p><a href=""https://github.com/zzhoujay/MaterialDesignColor"" rel=""nofollow noreferrer"">MaterialDesignColor</a> ★274 - 谷歌官方MaterialDesign颜色代码</p></li>
<li><p><a href=""https://github.com/kizitonwose/colorpreference"" rel=""nofollow noreferrer"">colorpreference</a> ★204 - 建立优秀的颜色选择器</p></li>
<li><p><a href=""https://github.com/mathiazhagan01/DrawableColorChange"" rel=""nofollow noreferrer"">DrawableColorChange</a> ★81 - drawable颜色修改工具</p></li>
<li><p><a href=""https://github.com/bassaer/MaterialDesignColors"" rel=""nofollow noreferrer"">MaterialDesignColors</a> ★54 - 提供MD风格的Android库</p></li>
</ul>
<h2>Drawable</h2>
<ul>
<li><p><a href=""https://github.com/maoruibin/OneDrawable"" rel=""nofollow noreferrer"">OneDrawable</a> ★202 - 为View设置具有按下效果的背景</p></li>
<li><p><a href=""https://github.com/yuanwenbing/SelectorDrawable"" rel=""nofollow noreferrer"">SelectorDrawable</a> ★23 - 为按钮设置selector</p></li>
</ul>
<h2>Spinner</h2>
<ul>
<li><p><a href=""https://github.com/arcadefire/nice-spinner"" rel=""nofollow noreferrer"">nice-spinner</a> ★955 - Android spinner的重新实现</p></li>
<li><p><a href=""https://github.com/Lesilva/BetterSpinner"" rel=""nofollow noreferrer"">BetterSpinner</a> ★526 - 好用的Spinner</p></li>
<li><p><a href=""https://github.com/Jasonchenlijian/MemorySpinner"" rel=""nofollow noreferrer"">MemorySpinner</a> ★125 - 可以记住历史选项的spinner</p></li>
</ul>
<h2>布局</h2>
<ul>
<li><p><a href=""https://github.com/google/flexbox-layout"" rel=""nofollow noreferrer"">flexbox-layout</a> ★7787 - Android盒式布局功能库</p></li>
<li><p><a href=""https://github.com/hongyangAndroid/AndroidAutoLayout"" rel=""nofollow noreferrer"">AndroidAutoLayout</a> ★4814 - Android屏幕适配方案</p></li>
<li><p><a href=""https://github.com/alibaba/vlayout"" rel=""nofollow noreferrer"">vlayout</a> ★3453 - 布局方案和布局间的组件复用</p></li>
<li><p><a href=""https://github.com/hongyangAndroid/FlowLayout"" rel=""nofollow noreferrer"">FlowLayout</a> ★2233 - Android流式布局</p></li>
<li><p><a href=""https://github.com/florent37/DiagonalLayout"" rel=""nofollow noreferrer"">DiagonalLayout</a> ★1778 - MD风格的新的样式和方法</p></li>
<li><p><a href=""https://github.com/Cleveroad/FanLayoutManager"" rel=""nofollow noreferrer"">FanLayoutManager</a> ★1393 - 扇形水平列表视图</p></li>
<li><p><a href=""https://github.com/henrytao-me/smooth-app-bar-layout"" rel=""nofollow noreferrer"">smooth-app-bar-layout</a> ★1389 - 视图布局</p></li>
<li><p><a href=""https://github.com/mmin18/FlexLayout"" rel=""nofollow noreferrer"">FlexLayout</a> ★1370 - 强大的Android布局视图</p></li>
<li><p><a href=""https://github.com/facebookincubator/TextLayoutBuilder"" rel=""nofollow noreferrer"">TextLayoutBuilder</a> ★1108 - Facebook出品的在Android中轻松实现文字布局</p></li>
<li><p><a href=""https://github.com/mcxtzhang/FlowLayoutManager"" rel=""nofollow noreferrer"">FlowLayoutManager</a> ★1018 - 利用自定义LayoutManager 的一些实战实例</p></li>
<li><p><a href=""https://github.com/AAkira/ExpandableLayout"" rel=""nofollow noreferrer"">ExpandableLayout</a> ★995 - 带有各种动画的扩展布局</p></li>
<li><p><a href=""https://github.com/nex3z/FlowLayout"" rel=""nofollow noreferrer"">FlowLayout</a> ★886 - 让子视图自动浮动到下一行</p></li>
<li><p><a href=""https://github.com/florent37/ArcLayout"" rel=""nofollow noreferrer"">ArcLayout</a> ★835 - 使用ArcLayout探索新的MD风格的样式和方法</p></li>
<li><p><a href=""https://github.com/cachapa/ExpandableLayout"" rel=""nofollow noreferrer"">ExpandableLayout</a> ★783 - 实现动画扩展和子视图折叠</p></li>
<li><p><a href=""https://github.com/hanhailong/FlowTag"" rel=""nofollow noreferrer"">FlowTag</a> ★549 - Android流式布局</p></li>
<li><p><a href=""https://github.com/SilenceDut/ExpandableLayout"" rel=""nofollow noreferrer"">ExpandableLayout</a> ★411 - 节省空间的可扩展布局</p></li>
<li><p><a href=""https://github.com/githubwing/ThreeDLayout"" rel=""nofollow noreferrer"">ThreeDLayout</a> ★351 - 让任何view拥有3D效果</p></li>
<li><p><a href=""https://github.com/Chacojack/HiveLayoutManager"" rel=""nofollow noreferrer"">HiveLayoutManager</a> ★321 - 蜂巢布局管理器</p></li>
<li><p><a href=""https://github.com/HuanHaiLiuXin/ILayoutAnimationController"" rel=""nofollow noreferrer"">ILayoutAnimationController</a> ★246 - 一行代码搞定布局动画</p></li>
<li><p><a href=""https://github.com/ta893115871/StickyNavLayout"" rel=""nofollow noreferrer"">StickyNavLayout</a> ★235 - 悬浮控件</p></li>
<li><p><a href=""https://github.com/liuguangqiang/RippleLayout"" rel=""nofollow noreferrer"">RippleLayout</a> ★203 - 实现波纹效果的布局</p></li>
<li><p><a href=""https://github.com/Qiang3570/LiveLayout"" rel=""nofollow noreferrer"">LiveLayout</a> ★184 - 关于直播布局与礼物特效的Demo</p></li>
<li><p><a href=""https://github.com/rantianhua/AssembleEssay"" rel=""nofollow noreferrer"">AssembleEssay</a> ★72 - 自定义LayoutManager实现流动布局</p></li>
<li><p><a href=""https://github.com/PingerOne/FlowLayoutDemo"" rel=""nofollow noreferrer"">FlowLayoutDemo</a> ★19 - 自定义View实现流式布局</p></li>
<li><p><a href=""https://github.com/CSnowStack/LikeELMLeftLoad"" rel=""nofollow noreferrer"">LikeELMLeftLoad</a> ★14 - 仿饿了么左滑跳转</p></li>
</ul>
<h2>模糊效果</h2>
<ul>
<li><p><a href=""https://github.com/kikoso/android-stackblur"" rel=""nofollow noreferrer"">Android StackBlur</a> ★2721 - 图片模糊效果</p></li>
<li><p><a href=""https://github.com/wasabeef/Blurry"" rel=""nofollow noreferrer"">Blurry</a> ★2534 - Android简易模糊库</p></li>
<li><p><a href=""https://github.com/500px/500px-android-blur"" rel=""nofollow noreferrer"">500px-android-blur</a> ★1925 - Android模糊视图</p></li>
<li><p><a href=""https://github.com/wonderkiln/blurkit-android"" rel=""nofollow noreferrer"">blurkit-android</a> ★1913 - 类似iOS上的实时模糊效果</p></li>
<li><p><a href=""https://github.com/Dimezis/BlurView"" rel=""nofollow noreferrer"">BlurView</a> ★1606 - Android底层视图动态仿iOS模糊</p></li>
<li><p><a href=""https://github.com/qiujuer/ImageBlurring"" rel=""nofollow noreferrer"">ImageBlurring</a> ★1079 - 通过 Java 与 JNI 分别进行图片模糊</p></li>
<li><p><a href=""https://github.com/mmin18/RealtimeBlurView"" rel=""nofollow noreferrer"">RealtimeBlurView</a> ★914 - 仿UIVisualEffectView实时模糊覆盖</p></li>
<li><p><a href=""https://github.com/wl9739/BlurredView"" rel=""nofollow noreferrer"">BlurredView</a> ★844 - Android图片视图动态模糊</p></li>
<li><p><a href=""https://github.com/Nightonke/BlurLockView"" rel=""nofollow noreferrer"">BlurLockView</a> ★830 - 毛玻璃效果的解锁界面</p></li>
<li><p><a href=""https://github.com/patrickfav/Dali"" rel=""nofollow noreferrer"">Dali</a> ★771 - Android图像模糊库</p></li>
<li><p><a href=""https://github.com/SmartDengg/RxBlur"" rel=""nofollow noreferrer"">RxBlur</a> ★515 - 毛玻璃（高斯模糊）效果</p></li>
<li><p><a href=""https://github.com/Manabu-GT/EtsyBlur"" rel=""nofollow noreferrer"">EtsyBlur</a> ★506 - 在Etsy应用添加仿玻璃模糊效果</p></li>
<li><p><a href=""https://github.com/jrvansuita/GaussianBlur"" rel=""nofollow noreferrer"">GaussianBlur</a> ★289 - 对图片应用高斯模糊</p></li>
<li><p><a href=""https://github.com/Hitomis/CrazyShadow"" rel=""nofollow noreferrer"">CrazyShadow</a> ★215 - 为 View 添加阴影效果</p></li>
</ul>
<h2>TabBar</h2>
<ul>
<li><p><a href=""https://github.com/thelong1EU/SpaceTabLayout"" rel=""nofollow noreferrer"">SpaceTabLayout</a> ★933 - RelativeLayout的自定义实现方式</p></li>
<li><p><a href=""https://github.com/nshmura/RecyclerTabLayout"" rel=""nofollow noreferrer"">RecyclerTabLayout</a> ★859 - 高效TabLayout库</p></li>
<li><p><a href=""https://github.com/huage2580/ZuiMeiTAG"" rel=""nofollow noreferrer"">ZuiMeiTAG</a> ★232 - 仿最美应用的底栏</p></li>
<li><p><a href=""https://github.com/jeasonlzy/AlphaIndicatorView"" rel=""nofollow noreferrer"">AlphaIndicatorView</a> ★201 - 仿微信底部tab标签</p></li>
</ul>
<h2>AppBar</h2>
<ul>
<li><p><a href=""https://github.com/henrytao-me/smooth-app-bar-layout"" rel=""nofollow noreferrer"">smooth-app-bar-layout</a> ★1389 - 视图布局</p></li>
<li><p><a href=""https://github.com/ToDou/appbarlayout-spring-behavior"" rel=""nofollow noreferrer"">appbarlayout-spring-behavior</a> ★733 - 实现滚动弹簧效果</p></li>
<li><p><a href=""https://github.com/SpikeKing/TestAppBar"" rel=""nofollow noreferrer"">TestAppBar</a> ★271 - AppBar动画效果</p></li>
<li><p><a href=""https://github.com/zoonooz/simple-view-behavior"" rel=""nofollow noreferrer"">simple-view-behavior</a> ★239 - 简单视图行为</p></li>
</ul>
<h2>选择器(Picker)</h2>
<ul>
<li><p><a href=""https://github.com/saiwu-bigkoo/Android-PickerView"" rel=""nofollow noreferrer"">Android-PickerView</a> ★3898 - 精仿iOS的PickerView控件</p></li>
<li><p><a href=""https://github.com/code-troopers/android-betterpickers"" rel=""nofollow noreferrer"">android-betterpickers</a> ★2461 - 选择器DialogFragments库</p></li>
<li><p><a href=""https://github.com/gzu-liyujiang/AndroidPicker"" rel=""nofollow noreferrer"">AndroidPicker</a> ★2021 - 安卓选择器类库</p></li>
<li><p><a href=""https://github.com/vikramkakkar/SublimePicker"" rel=""nofollow noreferrer"">SublimePicker</a> ★1768 - 提供选择器的自定义视图</p></li>
<li><p><a href=""https://github.com/DroidNinja/Android-FilePicker"" rel=""nofollow noreferrer"">Android-FilePicker</a> ★1060 - 灵活选择图片和视频的文件选择器</p></li>
<li><p><a href=""https://github.com/JZXiang/TimePickerDialog"" rel=""nofollow noreferrer"">TimePickerDialog</a> ★977 - Android时间选择器</p></li>
<li><p><a href=""https://github.com/zaaach/CityPicker"" rel=""nofollow noreferrer"">CityPicker</a> ★880 - 仿美团等选择城市列表demo</p></li>
<li><p><a href=""https://github.com/philliphsu/BottomSheetPickers"" rel=""nofollow noreferrer"">BottomSheetPickers</a> ★824 - ndroid的新的数据和时间选择器库</p></li>
<li><p><a href=""https://github.com/brucetoo/PickView"" rel=""nofollow noreferrer"">PickView</a> ★791 - 选择日期或者省份的辅助库</p></li>
<li><p><a href=""https://github.com/fishwjy/MultiType-FilePicker"" rel=""nofollow noreferrer"">MultiType-FilePicker</a> ★748 - 轻量级Android文件选择库</p></li>
<li><p><a href=""https://github.com/Carbs0126/NumberPickerView"" rel=""nofollow noreferrer"">NumberPickerView</a> ★625 - 灵活的安卓NumberPicker组件</p></li>
<li><p><a href=""https://github.com/ai212983/android-spinnerwheel"" rel=""nofollow noreferrer"">android-spinnerwheel</a> ★623 - 安卓轮式旋转部件</p></li>
<li><p><a href=""https://github.com/ImKarl/CharacterPickerView"" rel=""nofollow noreferrer"">CharacterPickerView</a> ★610 - 仿iOS的PickerView控件</p></li>
<li><p><a href=""https://github.com/GoodieBag/HorizontalPicker"" rel=""nofollow noreferrer"">HorizontalPicker</a> ★285 - 支持文本和图标的水平选择器</p></li>
<li><p><a href=""https://github.com/florent37/SingleDateAndTimePicker"" rel=""nofollow noreferrer"">SingleDateAndTimePicker</a> ★268 - 在一个部件内选择一个数据和一个时间</p></li>
<li><p><a href=""https://github.com/aliab/Two-Step-Picker-Dialog"" rel=""nofollow noreferrer"">Two-Step-Picker-Dialog</a> ★231 - 两步选择器对话框</p></li>
<li><p><a href=""https://github.com/StephaneBg/SimpleNumberPicker"" rel=""nofollow noreferrer"">SimpleNumberPicker</a> ★154 - 十进制和十六进制选择器视图</p></li>
<li><p><a href=""https://github.com/leonHua/LFilePicker"" rel=""nofollow noreferrer"">LFilePicker</a> ★150 - 轻量级的文件选择器</p></li>
<li><p><a href=""https://github.com/myinnos/AwesomeImagePicker"" rel=""nofollow noreferrer"">AwesomeImagePicker</a> ★113 - 使用精致的接口选择images和gifs</p></li>
<li><p><a href=""https://github.com/codbking/PickTime"" rel=""nofollow noreferrer"">PickTime</a> ★101 - 日期选择控件</p></li>
<li><p><a href=""https://github.com/jrvansuita/PickImage"" rel=""nofollow noreferrer"">PickImage</a> ★79 - 带有Camera和Gallery选项的DialogFragment</p></li>
<li><p><a href=""https://github.com/polok/ClickNumberPicker"" rel=""nofollow noreferrer"">ClickNumberPicker</a> ★75 - 从给定范围内使用点击按钮或者触摸选定一个值</p></li>
<li><p><a href=""https://github.com/Airsaid/Android-PickerView-Library"" rel=""nofollow noreferrer"">Android-PickerView-Library</a> ★72 - 高仿 IOS PickerView 控件的库</p></li>
<li><p><a href=""https://github.com/dunwen/JDSelector"" rel=""nofollow noreferrer"">JDSelector</a> ★68 - 仿京东的地址多级选择器</p></li>
<li><p><a href=""https://github.com/BorealisAgency/NumberPicker"" rel=""nofollow noreferrer"">NumberPicker</a> ★40 - Android数字选择器视图</p></li>
<li><p><a href=""https://github.com/limxing/CityPickerWebView"" rel=""nofollow noreferrer"">CityPickerWebView</a> ★35 - JS实现的省市县三级联动</p></li>
<li><p><a href=""https://github.com/huzenan/EasyPickerView"" rel=""nofollow noreferrer"">EasyPickerView</a> ★34 - Android轻量级PickerView</p></li>
</ul>
<h2>跑马灯</h2>
<ul>
<li><p><a href=""https://github.com/sfsheng0322/MarqueeView"" rel=""nofollow noreferrer"">MarqueeView</a> ★1568 - 垂直翻页公告</p></li>
<li><p><a href=""https://github.com/gongwen/MarqueeViewDemo"" rel=""nofollow noreferrer"">MarqueeViewDemo</a> ★896 - 跑马灯View</p></li>
<li><p><a href=""https://github.com/oubowu/MarqueeLayoutLibrary"" rel=""nofollow noreferrer"">MarqueeLayoutLibrary</a> ★388 - 支持四个方向循环滚动的自定义控件</p></li>
<li><p><a href=""https://github.com/czy1121/noticeview"" rel=""nofollow noreferrer"">noticeview</a> ★256 - 滚动播放的公告控件</p></li>
<li><p><a href=""https://github.com/guojunustb/VerticalBannerView"" rel=""nofollow noreferrer"">VerticalBannerView</a> ★194 - 安卓自定义控件</p></li>
<li><p><a href=""https://github.com/SumiMakito/AdvancedTextSwitcher"" rel=""nofollow noreferrer"">AdvancedTextSwitcher</a> ★193 - 卡片上滚动显示最新评论</p></li>
<li><p><a href=""https://github.com/chenpengfei88/VerticalMarqueeView"" rel=""nofollow noreferrer"">VerticalMarqueeView</a> ★12 - 新闻向上不断滚动跑马灯效果</p></li>
</ul>
<h2>日历时间</h2>
<ul>
<li><p><a href=""https://github.com/square/android-times-square"" rel=""nofollow noreferrer"">android-times-square</a> ★3710 - 从日历视图选择一个单独日期</p></li>
<li><p><a href=""https://github.com/prolificinteractive/material-calendarview"" rel=""nofollow noreferrer"">material-calendarview</a> ★2770 - MD风格的日历视图</p></li>
<li><p><a href=""https://github.com/wdullaer/MaterialDateTimePicker"" rel=""nofollow noreferrer"">MaterialDateTimePicker</a> ★2407 - MD风格日期时间选择器</p></li>
<li><p><a href=""https://github.com/alamkanak/Android-Week-View"" rel=""nofollow noreferrer"">Android-Week-View</a> ★2301 - 在Android应用中显示日历</p></li>
<li><p><a href=""https://github.com/roomorama/Caldroid"" rel=""nofollow noreferrer"">Caldroid</a> ★1263 - 以月为单位的日历控件</p></li>
<li><p><a href=""https://github.com/iwgang/CountdownView"" rel=""nofollow noreferrer"">CountdownView</a> ★1257 - 安卓倒计时控件</p></li>
<li><p><a href=""https://github.com/JZXiang/TimePickerDialog"" rel=""nofollow noreferrer"">TimePickerDialog</a> ★977 - Android时间选择器</p></li>
<li><p><a href=""https://github.com/Tibolte/AgendaCalendarView"" rel=""nofollow noreferrer"">AgendaCalendarView</a> ★929 - 仿Outloo和Google日历</p></li>
<li><p><a href=""https://github.com/SundeepK/CompactCalendarView"" rel=""nofollow noreferrer"">CompactCalendarView</a> ★921 - 简单的日历视图</p></li>
<li><p><a href=""https://github.com/borax12/MaterialDateRangePicker"" rel=""nofollow noreferrer"">MaterialDateRangePicker</a> ★835 - 日期选择控件库</p></li>
<li><p><a href=""https://github.com/philliphsu/BottomSheetPickers"" rel=""nofollow noreferrer"">BottomSheetPickers</a> ★824 - ndroid的新的数据和时间选择器库</p></li>
<li><p><a href=""https://github.com/Kelin-Hong/CalendarListView"" rel=""nofollow noreferrer"">CalendarListView</a> ★726 - 可互动的ListView+CalendarView</p></li>
<li><p><a href=""https://github.com/nomanr/WeekCalendar"" rel=""nofollow noreferrer"">WeekCalendar</a> ★555 - 提供星期日历的库</p></li>
<li><p><a href=""https://github.com/Mulham-Raee/HorizontalCalendar"" rel=""nofollow noreferrer"">HorizontalCalendar</a> ★482 - MD风格的水平日历视图</p></li>
<li><p><a href=""https://github.com/codbking/CalendarExaple"" rel=""nofollow noreferrer"">CalendarExaple</a> ★445 - 高仿钉钉和小米的日历控件</p></li>
<li><p><a href=""https://github.com/myjoybar/android-calendar-view"" rel=""nofollow noreferrer"">android-calendar-view</a> ★322 - 易扩展的andorid日历控件库</p></li>
<li><p><a href=""https://github.com/memfis19/Cadar"" rel=""nofollow noreferrer"">Cadar</a> ★305 - 可以显示事件的日历视图</p></li>
<li><p><a href=""https://github.com/fashare2015/TimerView"" rel=""nofollow noreferrer"">TimerView</a> ★299 - 解耦良好的计时控件</p></li>
<li><p><a href=""https://github.com/florent37/SingleDateAndTimePicker"" rel=""nofollow noreferrer"">SingleDateAndTimePicker</a> ★268 - 在一个部件内选择一个数据和一个时间</p></li>
<li><p><a href=""https://github.com/henry-newbie/CalendarView"" rel=""nofollow noreferrer"">CalendarView</a> ★195 - 高度定制的日期选择器</p></li>
<li><p><a href=""https://github.com/MonkeyMushroom/MiClockView"" rel=""nofollow noreferrer"">MiClockView</a> ★189 - 高仿小米时钟</p></li>
<li><p><a href=""https://github.com/jMavarez/MaterialCalendar"" rel=""nofollow noreferrer"">MaterialCalendar</a> ★167 - 一个MD风格的日历</p></li>
<li><p><a href=""https://github.com/Carbs0126/GregorianLunarCalendar"" rel=""nofollow noreferrer"">GregorianLunarCalendar</a> ★153 - 农历+公历的日期选择模式</p></li>
<li><p><a href=""https://github.com/Ajian-studio/GAHonorClock"" rel=""nofollow noreferrer"">GAHonorClock</a> ★110 - 时钟动画</p></li>
<li><p><a href=""https://github.com/huanghaibin-dev/CalendarView"" rel=""nofollow noreferrer"">CalendarView</a> ★98 - 优雅且性能高效的日历控件</p></li>
<li><p><a href=""https://github.com/Kunzisoft/Android-SwitchDateTimePicker"" rel=""nofollow noreferrer"">Android-SwitchDateTimePicker</a> ★71 - 日期时间选择器库</p></li>
<li><p><a href=""https://github.com/afinal/week-month-Calendar"" rel=""nofollow noreferrer"">week-month-Calendar</a> ★68 - 周月切换的日历</p></li>
<li><p><a href=""https://github.com/k0shk0sh/RetainedDateTimePickers"" rel=""nofollow noreferrer"">RetainedDateTimePickers</a> ★67 - 在手机方向改变时保持日期时间选择器</p></li>
<li><p><a href=""https://github.com/Yuncun/WeekViewSwipeable"" rel=""nofollow noreferrer"">WeekViewSwipeable</a> ★59 - 以周格式显示数据的Android视图</p></li>
<li><p><a href=""https://github.com/MedAmineTazarki/DateRangePicker"" rel=""nofollow noreferrer"">DateRangePicker</a> ★48 - 带数据选择器的Dialogo fragment</p></li>
<li><p><a href=""https://github.com/iballan/TimelyView"" rel=""nofollow noreferrer"">TimelyView</a> ★42 - 时间动画视图</p></li>
<li><p><a href=""https://github.com/jiefly/NubiaTimer"" rel=""nofollow noreferrer"">NubiaTimer</a> ★34 - 高仿Nubia 定时器的自定义view</p></li>
</ul>
<h2>主题样式</h2>
<ul>
<li><p><a href=""https://github.com/Bilibili/MagicaSakura"" rel=""nofollow noreferrer"">MagicaSakura</a> ★1809 - Android多主题库</p></li>
<li><p><a href=""https://github.com/ximsfei/Android-skin-support"" rel=""nofollow noreferrer"">Android-skin-support</a> ★1525 - 用心的Android 换肤框架</p></li>
<li><p><a href=""https://github.com/garretyoder/Colorful"" rel=""nofollow noreferrer"">Colorful</a> ★1479 - 轻松改变app的配色方案</p></li>
<li><p><a href=""https://github.com/52inc/Scoops"" rel=""nofollow noreferrer"">Scoops</a> ★680 - 动态改变应用主题</p></li>
<li><p><a href=""https://github.com/zzz40500/ThemeDemo"" rel=""nofollow noreferrer"">ThemeDemo</a> ★384 - 日夜间模式切换</p></li>
<li><p><a href=""https://github.com/burgessjp/ThemeSkinning"" rel=""nofollow noreferrer"">ThemeSkinning</a> ★248 - Android 主题换肤的开源库</p></li>
<li><p><a href=""https://github.com/fython/Blackbulb"" rel=""nofollow noreferrer"">Blackbulb</a> ★150 - MD风格的夜间屏幕Android 应用</p></li>
<li><p><a href=""https://github.com/wutongke/AndroidSkinAnimator"" rel=""nofollow noreferrer"">AndroidSkinAnimator</a> ★143 - 仿网易云音乐换肤框架</p></li>
<li><p><a href=""https://github.com/zhangke3016/ChangeMode"" rel=""nofollow noreferrer"">ChangeMode</a> ★66 - Android动态切换夜间模式的实现库</p></li>
<li><p><a href=""https://github.com/qqliu10u/QSkinLoader"" rel=""nofollow noreferrer"">QSkinLoader</a> ★33 - QSkinLoader换肤框架</p></li>
</ul>
<h2>ImageView</h2>
<ul>
<li><p><a href=""https://github.com/vinc3m1/RoundedImageView"" rel=""nofollow noreferrer"">RoundedImageView</a> ★3860 - 支持圆角的快速ImageView。</p></li>
<li><p><a href=""https://github.com/davemorrissey/subsampling-scale-image-view"" rel=""nofollow noreferrer"">subsampling-scale-image-view</a> ★2845 - 安卓自定义图片视图</p></li>
<li><p><a href=""https://github.com/gjiazhe/PanoramaImageView"" rel=""nofollow noreferrer"">PanoramaImageView</a> ★1460 - 可以随设备旋转自动滚动的imageView</p></li>
<li><p><a href=""https://github.com/MostafaGazar/CustomShapeImageView"" rel=""nofollow noreferrer"">CustomShapeImageView</a> ★1395 - 自定义使用SVG和填充图的ImageView</p></li>
<li><p><a href=""https://github.com/stfalcon-studio/FrescoImageViewer"" rel=""nofollow noreferrer"">FrescoImageViewer</a> ★1112 - 简单的自定义全屏图片视图</p></li>
<li><p><a href=""https://github.com/LuckyJayce/LargeImage"" rel=""nofollow noreferrer"">LargeImage</a> ★1018 - Android加载大图</p></li>
<li><p><a href=""https://github.com/developer-shivam/Crescento"" rel=""nofollow noreferrer"">Crescento</a> ★883 - 图像视图和相关布局的下面添加曲线</p></li>
<li><p><a href=""https://github.com/lopspower/CircularImageView"" rel=""nofollow noreferrer"">CircularImageView</a> ★875 - 以简单的方法实现环形ImageView</p></li>
<li><p><a href=""https://github.com/laobie/NineGridImageView"" rel=""nofollow noreferrer"">NineGridImageView</a> ★841 - 仿微信朋友圈或微博的九宫格图片</p></li>
<li><p><a href=""https://github.com/githubwing/DragPhotoView"" rel=""nofollow noreferrer"">DragPhotoView</a> ★819 - 高仿微信可拖拽返回PhotoView</p></li>
<li><p><a href=""https://github.com/yingLanNull/ShadowImageView"" rel=""nofollow noreferrer"">ShadowImageView</a> ★789 - 更加细腻的阴影效果</p></li>
<li><p><a href=""https://github.com/vikramkakkar/ImageTransition"" rel=""nofollow noreferrer"">ImageTransition</a> ★552 - Activity视图过渡</p></li>
<li><p><a href=""https://github.com/kongnanlive/android-combination-avatar"" rel=""nofollow noreferrer"">android-combination-avatar</a> ★498 - 模仿QQ讨论组组合头像</p></li>
<li><p><a href=""https://github.com/jineshfrancs/CaptchaImageView"" rel=""nofollow noreferrer"">CaptchaImageView</a> ★495 - 生成验证码图片的自定义ImageView</p></li>
<li><p><a href=""https://github.com/gjiazhe/ScrollParallaxImageView"" rel=""nofollow noreferrer"">ScrollParallaxImageView</a> ★395 - 滚动视差效果</p></li>
<li><p><a href=""https://github.com/IntruderShanky/Frisson"" rel=""nofollow noreferrer"">Frisson</a> ★308 - 在图片上提供时髦的剪裁</p></li>
<li><p><a href=""https://github.com/developer-shivam/Diagonalify"" rel=""nofollow noreferrer"">Diagonalify</a> ★282 - 创建图像视图的对角线切割</p></li>
<li><p><a href=""https://github.com/TangoAgency/avatar-view"" rel=""nofollow noreferrer"">avatar-view</a> ★205 - 带有用户名字的第一个字母的图片视图</p></li>
<li><p><a href=""https://github.com/jcodeing/AnchorImageView"" rel=""nofollow noreferrer"">AnchorImageView</a> ★186 - Android锚点定位ImageView</p></li>
<li><p><a href=""https://github.com/zuoweitan/CircleImageView"" rel=""nofollow noreferrer"">CircleImageView</a> ★166 - 环形ImageView</p></li>
<li><p><a href=""https://github.com/suzeyu1992/SImageView"" rel=""nofollow noreferrer"">SImageView</a> ★116 - 设置一个网址即可显示图片的控件</p></li>
<li><p><a href=""https://github.com/385841539/IdentityImageView"" rel=""nofollow noreferrer"">IdentityImageView</a> ★95 - 带进度条的图片框架</p></li>
<li><p><a href=""https://github.com/HuTianQi/CoolImageView"" rel=""nofollow noreferrer"">CoolImageView</a> ★51 - 可以上下移动的imageView</p></li>
<li><p><a href=""https://github.com/IntruderShanky/Blaze"" rel=""nofollow noreferrer"">Blaze</a> ★40 - 提供移动图像和缩放图像的视图</p></li>
<li><p><a href=""https://github.com/GitLqr/LQRNineGridImageView"" rel=""nofollow noreferrer"">LQRNineGridImageView</a> ★31 - 仿微信群头像九宫格控件</p></li>
<li><p><a href=""https://github.com/A-W-C-J/GridImageView"" rel=""nofollow noreferrer"">GridImageView</a> ★21 - 根据图片数量自动适配加载</p></li>
<li><p><a href=""https://github.com/gslovemy/RoundImageView"" rel=""nofollow noreferrer"">RoundImageView</a> ★12 - Android自定义圆角图片</p></li>
</ul>
<h2>通知</h2>
<ul>
<li><p><a href=""https://github.com/Tapadoo/Alerter"" rel=""nofollow noreferrer"">Alerter</a> ★2528 - 克服Toast和Snackbar的限制</p></li>
<li><p><a href=""https://github.com/wenmingvs/NotifyUtil"" rel=""nofollow noreferrer"">NotifyUtil</a> ★920 - 高仿淘宝微信等热门APP通知视图</p></li>
<li><p><a href=""https://github.com/halysongoncalves/Pugnotification"" rel=""nofollow noreferrer"">Pugnotification</a> ★683 - 通过一行代码实现通知功能</p></li>
<li><p><a href=""https://github.com/hss01248/NotifyUtil"" rel=""nofollow noreferrer"">NotifyUtil</a> ★119 - notification工具类</p></li>
<li><p><a href=""https://github.com/shaileshmamgain5/Carousel-Notification"" rel=""nofollow noreferrer"">Carousel-Notification</a> ★73 - 轮播框通知</p></li>
<li><p><a href=""https://github.com/linglongxin24/NotificationUtil"" rel=""nofollow noreferrer"">NotificationUtil</a> ★37 - 全新的Android通知栏</p></li>
</ul>
<h2>聊天视图</h2>
<ul>
<li><p><a href=""https://github.com/stfalcon-studio/ChatKit"" rel=""nofollow noreferrer"">ChatKit</a> ★906 - 简化UI开发</p></li>
<li><p><a href=""https://github.com/himanshu-soni/ChatMessageView"" rel=""nofollow noreferrer"">ChatMessageView</a> ★552 - 快速创建聊天信息视图</p></li>
<li><p><a href=""https://github.com/bassaer/ChatMessageView"" rel=""nofollow noreferrer"">ChatMessageView</a> ★249 - Android聊天UI视图</p></li>
<li><p><a href=""https://github.com/Maxi-Mao/ChatDemo"" rel=""nofollow noreferrer"">ChatDemo</a> ★109 - 实现聊天界面</p></li>
</ul>
<h2>Header</h2>
<ul>
<li><p><a href=""https://github.com/sfsheng0322/StickyHeaderListView"" rel=""nofollow noreferrer"">StickyHeaderListView</a> ★1816 - 基于实际需求做出的灵活可定制的UI功能</p></li>
<li><p><a href=""https://github.com/githubwing/ZoomHeader"" rel=""nofollow noreferrer"">ZoomHeader</a> ★1717 - 模仿饿了么详情页的例子</p></li>
<li><p><a href=""https://github.com/kmshack/Android-ParallaxHeaderViewPager"" rel=""nofollow noreferrer"">Android-ParallaxHeaderViewPager</a> ★1298 - 带标题头的左右滑动</p></li>
<li><p><a href=""https://github.com/ShamylZakariya/StickyHeaders"" rel=""nofollow noreferrer"">StickyHeaders</a> ★741 - 安卓RecyclerView的适配器和布局管理器</p></li>
<li><p><a href=""https://github.com/drakeet/RecyclerViewWithHeaderNewPractice"" rel=""nofollow noreferrer"">RecyclerViewWithHeaderNewPractice</a> ★533 - 结合HeaderView的RecyclerView新实现</p></li>
<li><p><a href=""https://github.com/ta893115871/StickyNavLayout"" rel=""nofollow noreferrer"">StickyNavLayout</a> ★235 - 悬浮控件</p></li>
<li><p><a href=""https://github.com/songhanghang/Smart-HeaderFooter-RecyclerView"" rel=""nofollow noreferrer"">Smart-HeaderFooter-RecyclerView</a> ★198 - 将Recyclerview添加HeaderView和FooterView</p></li>
</ul>
<h2>引导图(Intro)</h2>
<ul>
<li><p><a href=""https://github.com/PaoloRotolo/AppIntro"" rel=""nofollow noreferrer"">AppIntro</a> ★6053 - 制作一个很酷的app介绍页</p></li>
<li><p><a href=""https://github.com/amlcurran/ShowcaseView"" rel=""nofollow noreferrer"">ShowcaseView</a> ★4660 - 向用户突出app的特定部分</p></li>
<li><p><a href=""https://github.com/Nightonke/WoWoViewPager"" rel=""nofollow noreferrer"">WoWoViewPager</a> ★1881 - 优化App介绍/引导页面</p></li>
<li><p><a href=""https://github.com/TangoAgency/material-intro-screen"" rel=""nofollow noreferrer"">material-intro-screen</a> ★1807 - MD风格的介绍页面</p></li>
<li><p><a href=""https://github.com/binIoter/GuideView"" rel=""nofollow noreferrer"">GuideView</a> ★1463 - 创建遮罩式导航页</p></li>
<li><p><a href=""https://github.com/eoinfogarty/Onboarding"" rel=""nofollow noreferrer"">Onboarding</a> ★1390 - 以一种漂亮的方式向用户介绍应用</p></li>
<li><p><a href=""https://github.com/Ramotion/paper-onboarding-android"" rel=""nofollow noreferrer"">paper-onboarding-android</a> ★1309 - MD风格的onboarding</p></li>
<li><p><a href=""https://github.com/riggaroo/MaterialIntroTutorial"" rel=""nofollow noreferrer"">MaterialIntroTutorial</a> ★753 - MD风格介绍导航</p></li>
<li><p><a href=""https://github.com/faruktoptas/FancyShowCaseView"" rel=""nofollow noreferrer"">FancyShowCaseView</a> ★581 - 易于使用的自定义显示案例视图</p></li>
<li><p><a href=""https://github.com/codemybrainsout/ahoy-onboarding"" rel=""nofollow noreferrer"">ahoy-onboarding</a> ★505 - 可自定义背景的引导页面</p></li>
<li><p><a href=""https://github.com/jaydenxiao2016/HighLightGuideView"" rel=""nofollow noreferrer"">HighLightGuideView</a> ★351 - 用于 app 新功能高亮引导的库</p></li>
<li><p><a href=""https://github.com/ronaldsmartin/Material-ViewPagerIndicator"" rel=""nofollow noreferrer"">Material-ViewPagerIndicator</a> ★316 - 超级简单的页面指示器</p></li>
<li><p><a href=""https://github.com/armcha/Vertical-Intro"" rel=""nofollow noreferrer"">Vertical-Intro</a> ★238 - 在你的应用程序中整合material vertical</p></li>
<li><p><a href=""https://github.com/yilylong/UserGuideView"" rel=""nofollow noreferrer"">UserGuideView</a> ★198 - 用户指引view</p></li>
<li><p><a href=""https://github.com/Vexigon/Material-Onboarding"" rel=""nofollow noreferrer"">Material-Onboarding</a> ★172 - 轻松实现引导图</p></li>
<li><p><a href=""https://github.com/guangzq/StepDialog"" rel=""nofollow noreferrer"">StepDialog</a> ★118 - ofo应用首次注册时的步骤控件</p></li>
<li><p><a href=""https://github.com/ihsanbal/SlidingIntoView"" rel=""nofollow noreferrer"">SlidingIntoView</a> ★61 - 简单的滑动介绍视图</p></li>
</ul>
<h2>图片</h2>
<ul>
<li><p><a href=""https://github.com/nostra13/Android-Universal-Image-Loader"" rel=""nofollow noreferrer"">Android-Universal-Image-Loader</a> ★15152 - 异步图像加载程序</p></li>
<li><p><a href=""https://github.com/bumptech/glide"" rel=""nofollow noreferrer"">glide</a> ★15006 - 媒体管理和图片加载框架</p></li>
<li><p><a href=""https://github.com/square/picasso"" rel=""nofollow noreferrer"">picasso</a> ★13268 - 安卓图片缓存库</p></li>
<li><p><a href=""https://github.com/facebook/fresco"" rel=""nofollow noreferrer"">fresco</a> ★12543 - 在Android应用中显示图片</p></li>
<li><p><a href=""https://github.com/chrisbanes/PhotoView"" rel=""nofollow noreferrer"">PhotoView</a> ★9843 - 简单可用的放大安卓ImageView实现</p></li>
<li><p><a href=""https://github.com/hdodenhof/CircleImageView"" rel=""nofollow noreferrer"">CircleImageView</a> ★6779 - 圆形介绍头像</p></li>
<li><p><a href=""https://github.com/Yalantis/uCrop"" rel=""nofollow noreferrer"">uCrop</a> ★4983 - 极限且灵活的图像裁剪体验</p></li>
<li><p><a href=""https://github.com/jdamcd/android-crop"" rel=""nofollow noreferrer"">android-crop</a> ★3506 - 简单的图片裁剪功能的Android库项目</p></li>
<li><p><a href=""https://github.com/wasabeef/glide-transformations"" rel=""nofollow noreferrer"">glide-transformations</a> ★3492 - 图像转换类库</p></li>
<li><p><a href=""https://github.com/crazycodeboy/TakePhoto"" rel=""nofollow noreferrer"">TakePhoto</a> ★2596 - Android设备上获取裁剪压缩图片</p></li>
<li><p><a href=""https://github.com/lovetuzitong/MultiImageSelector"" rel=""nofollow noreferrer"">MultiImageSelector</a> ★2263 - 仿微信实现多图选择</p></li>
<li><p><a href=""https://github.com/ArthurHub/Android-Image-Cropper"" rel=""nofollow noreferrer"">Android-Image-Cropper</a> ★2223 - Android图片裁剪库</p></li>
<li><p><a href=""https://github.com/zhihu/Matisse"" rel=""nofollow noreferrer"">Matisse</a> ★1850 - Android本地图像选择器</p></li>
<li><p><a href=""https://github.com/donglua/PhotoPicker"" rel=""nofollow noreferrer"">PhotoPicker</a> ★1787 - 仿Wechat图片选择器</p></li>
<li><p><a href=""https://github.com/flavioarfaria/KenBurnsView"" rel=""nofollow noreferrer"">KenBurnsView</a> ★1697 - 身临其境的动画拖拽</p></li>
<li><p><a href=""https://github.com/Bilibili/boxing"" rel=""nofollow noreferrer"">boxing</a> ★1668 - 基于MVP模式的Android多媒体选择器</p></li>
<li><p><a href=""https://github.com/lyft/scissors"" rel=""nofollow noreferrer"">scissors</a> ★1640 - Android图片裁剪库</p></li>
<li><p><a href=""https://github.com/Piasy/BigImageViewer"" rel=""nofollow noreferrer"">BigImageViewer</a> ★1602 - 支持平移和缩放的大图像缩放器</p></li>
<li><p><a href=""https://github.com/Zomato/AndroidPhotoFilters"" rel=""nofollow noreferrer"">AndroidPhotoFilters</a> ★1598 - 快速强大灵活的图片处理器</p></li>
<li><p><a href=""https://github.com/IsseiAoki/SimpleCropView"" rel=""nofollow noreferrer"">SimpleCropView</a> ★1591 - Android图片裁剪库</p></li>
<li><p><a href=""https://github.com/sephiroth74/ImageViewZoom"" rel=""nofollow noreferrer"">ImageViewZoom</a> ★1470 - 支持超大图片流畅缩放</p></li>
<li><p><a href=""https://github.com/jeasonlzy/ImagePicker"" rel=""nofollow noreferrer"">ImagePicker</a> ★1433 - Android仿微信UI自定义相册</p></li>
<li><p><a href=""https://github.com/LuckSiege/PictureSelector"" rel=""nofollow noreferrer"">PictureSelector</a> ★1209 - 多图选择上传</p></li>
<li><p><a href=""https://github.com/bm-x/PhotoView"" rel=""nofollow noreferrer"">PhotoView</a> ★1201 - 图片浏览缩放控件</p></li>
<li><p><a href=""https://github.com/wingjay/BlurImageView"" rel=""nofollow noreferrer"">BlurImageView</a> ★1059 - 逐步加载图像</p></li>
<li><p><a href=""https://github.com/steelkiwi/cropiwa"" rel=""nofollow noreferrer"">cropiwa</a> ★1033 - 实现图片剪裁的多配置部件</p></li>
<li><p><a href=""https://github.com/TangXiaoLv/TelegramGallery"" rel=""nofollow noreferrer"">TelegramGallery</a> ★998 - 快速高效低耗相册选择器</p></li>
<li><p><a href=""https://github.com/FinalTeam/RxGalleryFinal"" rel=""nofollow noreferrer"">RxGalleryFinal</a> ★982 - android图片/视频文件选择器</p></li>
<li><p><a href=""https://github.com/mrwonderman/android-square-progressbar"" rel=""nofollow noreferrer"">android-square-progressbar</a> ★957 - 围绕图片的进度条</p></li>
<li><p><a href=""https://github.com/jkwiecien/EasyImage"" rel=""nofollow noreferrer"">EasyImage</a> ★887 - 从gallery，相机或者文件中获取图片</p></li>
<li><p><a href=""https://github.com/Sunzxyong/Tiny"" rel=""nofollow noreferrer"">Tiny</a> ★849 - 图像压缩框架</p></li>
<li><p><a href=""https://github.com/boycy815/PinchImageView"" rel=""nofollow noreferrer"">PinchImageView</a> ★842 - 安卓图片手势控件</p></li>
<li><p><a href=""https://github.com/shaohui10086/AdvancedLuban"" rel=""nofollow noreferrer"">AdvancedLuban</a> ★817 - 方便简约的 Android 图片压缩工具库</p></li>
<li><p><a href=""https://github.com/jarlen/PhotoEditDemo"" rel=""nofollow noreferrer"">PhotoEditDemo</a> ★802 - 图片处理sdk</p></li>
<li><p><a href=""https://github.com/wujingchao/SimpleTagImageView"" rel=""nofollow noreferrer"">SimpleTagImageView</a> ★800 - 安卓中带有标签的ImageView</p></li>
<li><p><a href=""https://github.com/jeasonlzy/NineGridView"" rel=""nofollow noreferrer"">NineGridView</a> ★791 - 展示图片的九宫格控件</p></li>
<li><p><a href=""https://github.com/yanzhenjie/album"" rel=""nofollow noreferrer"">album</a> ★777 - Android轻量级相册</p></li>
<li><p><a href=""https://github.com/bingoogolapple/BGAPhotoPicker-Android"" rel=""nofollow noreferrer"">BGAPhotoPicker-Android</a> ★726 - Android图片选择</p></li>
<li><p><a href=""https://github.com/chengdazhi/StyleImageView"" rel=""nofollow noreferrer"">StyleImageView</a> ★717 - 图片相关视图的风格添加及亮度对比度设置</p></li>
<li><p><a href=""https://github.com/coomar2841/image-chooser-library"" rel=""nofollow noreferrer"">image-chooser-library</a> ★656 - 以很少的代码捕获图片/视频</p></li>
<li><p><a href=""https://github.com/martin90s/ImagePicker"" rel=""nofollow noreferrer"">ImagePicker</a> ★651 - 图片选择控件</p></li>
<li><p><a href=""https://github.com/siwangqishiq/ImageEditor-Android"" rel=""nofollow noreferrer"">ImageEditor-Android</a> ★646 - 编辑图片</p></li>
<li><p><a href=""https://github.com/imablanco/Zoomy"" rel=""nofollow noreferrer"">Zoomy</a> ★634 - 缩放Android库</p></li>
<li><p><a href=""https://github.com/cesards/CropImageView"" rel=""nofollow noreferrer"">CropImageView</a> ★586 - 支持不同类型裁剪的ImageView</p></li>
<li><p><a href=""https://github.com/lawloretienne/ImageGallery"" rel=""nofollow noreferrer"">ImageGallery</a> ★549 - 用于放置图像数组的gallery</p></li>
<li><p><a href=""https://github.com/smuyyh/ImageSelector"" rel=""nofollow noreferrer"">ImageSelector</a> ★500 - Android图片选择器</p></li>
<li><p><a href=""https://github.com/hpfs0/DragScaleCircleView"" rel=""nofollow noreferrer"">DragScaleCircleView</a> ★477 - 能够拖拽和缩放及裁剪图片的环形窗口</p></li>
<li><p><a href=""https://github.com/wqandroid/wqgallery"" rel=""nofollow noreferrer"">wqgallery</a> ★383 - 微信样式相册选择器</p></li>
<li><p><a href=""https://github.com/Carbs0126/AvatarImageView"" rel=""nofollow noreferrer"">AvatarImageView</a> ★373 - 电话本联系人头像</p></li>
<li><p><a href=""https://github.com/MartinRGB/RapidInterpolator"" rel=""nofollow noreferrer"">RapidInterpolator</a> ★368 - 动态调整interpolator的Java库</p></li>
<li><p><a href=""https://github.com/andremion/Louvre"" rel=""nofollow noreferrer"">Louvre</a> ★355 - 自定义图片选择器</p></li>
<li><p><a href=""https://github.com/NodensN/MediaPickerInstagram"" rel=""nofollow noreferrer"">MediaPickerInstagram</a> ★344 - 仿Instagram的MediaPicker</p></li>
<li><p><a href=""https://github.com/liuguangqiang/IPicker"" rel=""nofollow noreferrer"">IPicker</a> ★300 - Material Design 风格的图片选择器</p></li>
<li><p><a href=""https://github.com/Hitomis/TransferImage"" rel=""nofollow noreferrer"">TransferImage</a> ★292 - 仿qq 点击缩略图后预览高清图</p></li>
<li><p><a href=""https://github.com/yasharpm/InstaCropper"" rel=""nofollow noreferrer"">InstaCropper</a> ★291 - 仿Instagram图片裁剪</p></li>
<li><p><a href=""https://github.com/jeanboydev/Android-BitherCompress"" rel=""nofollow noreferrer"">Android-BitherCompress</a> ★263 - Android图片压缩目前最优解决方案</p></li>
<li><p><a href=""https://github.com/imuhao/RxPicker"" rel=""nofollow noreferrer"">RxPicker</a> ★261 - 基于RxJava的Android图片选择器.</p></li>
<li><p><a href=""https://github.com/sangcomz/FishBun"" rel=""nofollow noreferrer"">FishBun</a> ★261 - Android图片选择器</p></li>
<li><p><a href=""https://github.com/Werb/PickPhotoSample"" rel=""nofollow noreferrer"">PickPhotoSample</a> ★256 - 帮助你选择图片的库</p></li>
<li><p><a href=""https://github.com/xyzxqs/XLowPoly"" rel=""nofollow noreferrer"">XLowPoly</a> ★235 - low poly图片的安卓实现</p></li>
<li><p><a href=""https://github.com/lijunguan/AlbumSelector"" rel=""nofollow noreferrer"">AlbumSelector</a> ★222 - 图片选择库</p></li>
<li><p><a href=""https://github.com/fengyongge/imagepickerdemo"" rel=""nofollow noreferrer"">imagepickerdemo</a> ★206 - 图片选择器</p></li>
<li><p><a href=""https://github.com/newtonker/JigsawDemo"" rel=""nofollow noreferrer"">JigsawDemo</a> ★203 - Android的拼图Demo</p></li>
<li><p><a href=""https://github.com/dreamlivemeng/HotImg"" rel=""nofollow noreferrer"">HotImg</a> ★199 - 图片不规则区域点击事件处理</p></li>
<li><p><a href=""https://github.com/w4lle/PullDownView"" rel=""nofollow noreferrer"">PullDownView</a> ★196 - 下拉展示大图</p></li>
<li><p><a href=""https://github.com/YancyYe/GalleryPick"" rel=""nofollow noreferrer"">GalleryPick</a> ★181 - Android 自定义相册</p></li>
<li><p><a href=""https://github.com/lopei/collageview"" rel=""nofollow noreferrer"">collageview</a> ★177 - 创建简单照片拼贴</p></li>
<li><p><a href=""https://github.com/ekimual/croperino"" rel=""nofollow noreferrer"">croperino</a> ★146 - 简单的图像裁剪工具</p></li>
<li><p><a href=""https://github.com/Jhuster/ImageCropper"" rel=""nofollow noreferrer"">ImageCropper</a> ★143 - 图片裁剪库</p></li>
<li><p><a href=""https://github.com/HomHomLin/FrescoImageView"" rel=""nofollow noreferrer"">FrescoImageView</a> ★140 - Android平台的图像控件</p></li>
<li><p><a href=""https://github.com/laomengzhu/MutiPhotoChoser"" rel=""nofollow noreferrer"">MutiPhotoChoser</a> ★139 - 支持多选的图片选择器</p></li>
<li><p><a href=""https://github.com/CarGuo/FrescoUtils"" rel=""nofollow noreferrer"">FrescoUtils</a> ★133 - 图片处理</p></li>
<li><p><a href=""https://github.com/esafirm/android-image-picker"" rel=""nofollow noreferrer"">android-image-picker</a> ★99 - 选择图像的简单的库</p></li>
<li><p><a href=""https://github.com/soulrelay/ImageLoaderUtil"" rel=""nofollow noreferrer"">ImageLoaderUtil</a> ★89 - ImageLoaderUtil实现的图集功能</p></li>
<li><p><a href=""https://github.com/nshmura/SnappyImageViewer"" rel=""nofollow noreferrer"">SnappyImageViewer</a> ★79 - 安卓图片视图</p></li>
<li><p><a href=""https://github.com/hss01248/PicCrop"" rel=""nofollow noreferrer"">PicCrop</a> ★62 - 对ucrop的封装工具类</p></li>
<li><p><a href=""https://github.com/okaybroda/ImageZoom"" rel=""nofollow noreferrer"">ImageZoom</a> ★50 - 仿Instagram的视图缩放功能</p></li>
<li><p><a href=""https://github.com/Tofira/ImagePickerWithCrop"" rel=""nofollow noreferrer"">ImagePickerWithCrop</a> ★47 - 指定选择图片的库</p></li>
<li><p><a href=""https://github.com/vansikrishna/Multimager"" rel=""nofollow noreferrer"">Multimager</a> ★46 - 多图片选择器和多图片捕获</p></li>
<li><p><a href=""https://github.com/Mr-wangyong/ImageFrame"" rel=""nofollow noreferrer"">ImageFrame</a> ★41 - 高效省内存的播放序列帧控件</p></li>
<li><p><a href=""https://github.com/Idtk/IKNinePhotoView"" rel=""nofollow noreferrer"">IKNinePhotoView</a> ★40 - 开源的Android九宫格控件</p></li>
<li><p><a href=""https://github.com/GitLqr/LQRImagePicker"" rel=""nofollow noreferrer"">LQRImagePicker</a> ★37 - 完全仿微信的图片选择</p></li>
<li><p><a href=""https://github.com/huzhenjie/ImageSelector"" rel=""nofollow noreferrer"">ImageSelector</a> ★32 - 支持多图选择和图片预览的图片选择器</p></li>
<li><p><a href=""https://github.com/AlexZhuo/AlxPicassoProgress"" rel=""nofollow noreferrer"">AlxPicassoProgress</a> ★25 - 图片下载进度实时显示</p></li>
</ul>
<h2>徽章(Badge)</h2>
<ul>
<li><p><a href=""https://github.com/bingoogolapple/BGABadgeView-Android"" rel=""nofollow noreferrer"">BGABadgeView-Android</a> ★1622 - Android 徽章控件</p></li>
<li><p><a href=""https://github.com/qstumn/BadgeView"" rel=""nofollow noreferrer"">BadgeView</a> ★1239 - 自由定制的BadgeView</p></li>
<li><p><a href=""https://github.com/mikepenz/Android-ActionItemBadge"" rel=""nofollow noreferrer"">Android-ActionItemBadge</a> ★1079 - 为ActionItem添加标识</p></li>
<li><p><a href=""https://github.com/matrixxun/MaterialBadgeTextView"" rel=""nofollow noreferrer"">MaterialBadgeTextView</a> ★859 - 展示新的信息标识和新的特色标识</p></li>
<li><p><a href=""https://github.com/volders/Badger"" rel=""nofollow noreferrer"">Badger</a> ★686 - 添加徽章</p></li>
<li><p><a href=""https://github.com/nekocode/Badge"" rel=""nofollow noreferrer"">Badge</a> ★544 - 一系列徽章图片</p></li>
<li><p><a href=""https://github.com/AlexLiuSheng/BadgeView"" rel=""nofollow noreferrer"">BadgeView</a> ★457 - 基于Android的BadeView</p></li>
<li><p><a href=""https://github.com/czy1121/badgebutton"" rel=""nofollow noreferrer"">badgebutton</a> ★333 - 带有徽标(数字，小红点)的按钮</p></li>
<li><p><a href=""https://github.com/nex3z/NotificationBadge"" rel=""nofollow noreferrer"">NotificationBadge</a> ★81 - 带有动画的通知标记</p></li>
<li><p><a href=""https://github.com/hcs-xph/BadgeRadioButton"" rel=""nofollow noreferrer"">BadgeRadioButton</a> ★25 - 仿QQ底部Tab切换RadioButton</p></li>
<li><p><a href=""https://github.com/chendongde310/SuperBadge"" rel=""nofollow noreferrer"">SuperBadge</a> ★19 - 消息红点计数解决方案</p></li>
</ul>

                ", Android UI相关开源项目库汇总,1531977852,429,1,990,1,1,https://segmentfault.com/a/1190000009259373
136,1,0,7,"
                    
<blockquote><blockquote><p>原创 西安前端交流会: <code>卡农</code>  <code>ovenzeze@qq.com</code>  <br>本文章同步发表在<code>wdShare西安前端交流会网站</code>、<code>我的个人博客</code>以及<code>segmentFault</code>和<code>掘金</code>。    转载请注明出处</p></blockquote></blockquote>
<p>这是西安初级前端群里边的一次分享，整理出来，分享给大家，希望对大家的学习有帮助，也希望大家可以和我多多交流。</p>
<h1>写在前面</h1>
<p>Hello，大家好，我是卡农。上周<a href=""https://github.com/codefine"" rel=""nofollow noreferrer"">Michael兄</a>分享的内容<a href=""http://www.wdshare.org/article/58a9ae41d02bb00403a58ef2"" rel=""nofollow noreferrer"">机械转行前端，半年零基础自学的心路历程</a>干货满满，非常精彩。本周的分享由我来带给大家。首先非常感觉<code>杰克哥</code>给我这次机会让我能够在这里分享一点学习的经验，也非常感谢<code>F7哥</code>提供的这么好的交流平台让大家能够在这里心无旁骛的讨论技术，共同进步。今天我分享的内容主要是关于前端初学者的学习路线和一些建议，还有自己在准备校招过程中的一点经验。由于我目前还是在校生，所以在某些问题的见解和选择上可能会更多的偏向于学生的思维，不一定适合群里的所有人，不足的地方希望大家多多指点，当然我会尽量从更大的适用人群的角度去输出我的经验，希望可以对大家前端学习有所帮助。<br>我会从我的入坑之路、初学历程、学习路线以及准备应聘过程中的简历、知识、心态准备几个方面来给大家分享。</p>
<h1>我是如何选择这个方向</h1>
<p>严格意义上来说，我学的专业并不属于计算机（智能科学与技术），更偏向于一个软硬件结合的学科，而很凑巧的我们学校在安排我们专业课的时候把硬件课程放到了一个更重要的位置。所以专业课里能学到的知识其实并不多，当初也是见到这么霸气的名字才填的专业。如果按照我们专业的路线，我以后应该研究的是人工智能、机器学习、机器视觉或者自然语言处理这些方向。但是在大二，我很认真的研究了这些可能的方向之后，我很严肃的发现了一个问题。这些看起来很高大上的学科或者职业，在我们这种学校是一个很尴尬的存在。以以我们这种普通学校本科生的学力和研究深度，几乎不太可能在这些方向上找到合适的工作（至少是没有先例的）,当然也有想过做第一个吃螃蟹的人，但是当认真审视自己的没有良好的基础学科功底和对这些方向有限的热情之后，我还是选择放弃。这样，唯二的可选项是继续深造和选择别的方向。因为我一直都没有在国内继续深造的打算，所以我很果断的放弃了这个选项。于是在选择别的方向的路上，很巧合的碰到了学校计算机学院（我们专业被分到自动化学院）各种实验室的招新。宣讲会听了一场又一场，发现我都大二了（对大一学生的要求比较低），还没有任何可以拿得出手的作品，也没有比较熟悉的编程语言，只有对互联网和科技行业满满的热情。最后抱着试试看得心态，初步选定了前端和产品两个方向。但是在后来的就业前景、学习路线以及未来的发展这些综合考虑之下（信息主要来自知乎），还是选择了技术路线的前端。所幸的是那时候，大家的水平都不高，在我挑灯夜读了大概一周之后，很凑巧的遇到一个非常赏识我的学姐，让我进了实验室的<code>WEB组</code>。也就正式开始了我的前端之路。</p>
<h1>我的初学之路</h1>
<p>对于学生，我强烈推荐加入学校的实验室，这会对你的学习之路有极大的帮助，在后面我会提到。<br>很幸运，我所在的实验室是一个以项目为驱动的实验室。实验室里有各个方向的人才，<code>嵌入式、安卓开发、大数据、WEB前端、WEB后台</code>等等，当你有一个好的<code>idea</code>很快可以汇集到各个方向的成员去实现它。于是我的第一个项目开始了。就是写一个简单的实验室官网。<br>当然这时候，我才知道自己其实只是了解一点皮毛都算不上的知识，如何开始一个项目，前期的需求分析怎么写，网站整体怎么设计，用什么技术栈，如何规范代码，如何写出健壮可维护的代码，甚至与还有网站放什么东西，资料哪里来这些问题，一下子全部都出现了。我根本无从下手，不知道从哪里开始。这个时候，有人指导的重要性就凸显出来了。在学长学姐的指导下，我参考了以前的项目计划书花了一周时间写出了网站的需求分析，画出了大体的布局图，选定了技术框架用<code>Bootstrap</code>。这个时候我就是在慕课网和官网上看<code>Bootstrap</code>的使用教程，发现仅仅是使用也没有什么难度，大概两周基本上都会了。但是会照着例子敲代码并没有什么用，还是什么都做不出来。这个时候，我做了一件很可耻的事情，我把学校成立比较早的几家实验室官网的代码都扒了下来，看他们的目录结构、布局以及代码。很幸运的是大家都没有在这个静态网站上使用太复杂的技术，基本上都是我能看得懂的<code>CSS</code>和<code>HTML</code>，<code>JS</code>的部分很少。于是，参考他们的例子和我之前自己设计的整体布局和结构，我大概写出了网站的整体框架，虽然很丑，虽然即使是用了<code>Bootstrap</code>还有很多布局上的<code>Bug</code>,但是看到自己设计并写出来的第一个网站还是非常激动的。后面的工作就是在实际编写过程中，不断的改代码，改布局，甚至还多次改了需求，历时大概两个月加上一个寒假，终于完成了自己的第一个正式上线的作品。在这期间，我还购买并配置了自己的云服务器，自己的博客系统，自己的<code>Github</code>,还学会了<code>linux</code>的基本操作。<br>要知道，在几个月以前，我是想都没想过自己能够亲自写出一个网站并提供给这么多人使用，一是不相信我会有这样的机会，二是不相信我有这样的能力。but so what,事实是我真的做出来了这个东西，而且以后我会做出更多更好的东西。我写这段经历希望和大家分享的就是，dont be shy,勇敢的踏出你的第一步，如果你不给自己一个机会，你永远都不会知道你到底能做什么，在这之前我完全不知道如何开始并完成一个项目，也不知道什么<code>博客</code>，<code>Github</code>，<code>云服务器</code>，这些完全是因为在这个项目中会用到，我不得已去学习，但是一开始学习我才发现这些东西为我们带来的便利远远超乎我的想象，于是已经停不下来了。所以对于刚入行的初学者，我强烈的建议你，发挥你的想象力，尝试亲手去做一个完整的作品，当你想去实现一个东西，想去完成一件事情的时候，你会有更充足的热情和动力去为之学习，每一次学习都是都会离你的目标更进一步，而每一次完成作品中的一个部分你就会更有动力去继续，这是一个正向激励的良性循环。相信在这种情况下，你会学的更快更有深度。</p>
<p>很容易看到，对我的整个成长过程，学校实验室提供的资源、平台和氛围起了很重要的作用。在这里，我可以非常容易找到和自己同方向的学长学姐，在这里，我想再次想帮助过我的学长学姐们说声“感谢”，没有你们当初你们的指点，我现在还在泥潭中打滚，没有方向的乱撞。也很容易有各种机会去做出会被大家使用的产品，同时还有良好的学习氛围.举个简单的例子，在没有加入实验室之前，我最多学到九点（因为学校图书馆九点钟关门），而且还要受到各种干扰，在加入实验室之后，只要去了，我很少有十点之前回宿舍，因为在这个环境里，大家都在学习，都在讨论，你很难有其他的想法。而住的更近的同学院同学，在保安大爷没来催人之前，是绝对不会走的。<br>当你可以完整的做一个小项目的时候，我相信常用的技术你肯定都了解的差不多了，但是用归用，如果仅仅是会用某项术，对你的成长帮助是非常有限的。</p>
<h1>学习路线推荐</h1>
<p>这个时候我推荐可以花大块的时间系统学习知识点。比如，多久时间学习<code>HTML4.1</code> <code>HTML5</code> <a href=""https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5"" rel=""nofollow noreferrer"">MDN-HTML5</a><code>CSS2.1</code>,<code>CSS3</code><a href=""http://css.doyoe.com/"" rel=""nofollow noreferrer"">雾雨漂零CSS手册</a>,<code>ES5</code>,<code>ES6/ES7</code><a href=""http://es6.ruanyifeng.com/"" rel=""nofollow noreferrer"">阮一峰ES6手册</a>等等。这个时候的学习就是既要有广度又要有深度。不必说的是<code>JavaScript高级程序设计</code><a href=""https://book.douban.com/subject/10546125/"" rel=""nofollow noreferrer"">豆瓣链接</a>这本书，也就是大家常说的高程，基本上每个合格的前端程序员都要熟读很多很多次，每次读都会有新发现。JS最原理性的东西这里面都解释的很清楚，但是它也有很多不够深入的地方，这个时候犀牛书就出现了。但是犀牛书（<code>JavaScript权威指南</code>）<a href=""https://book.douban.com/subject/1232061/"" rel=""nofollow noreferrer"">豆瓣链接</a>讲的很细，很深，反正目前我是基本没怎么看，水平还不够很多地方理解不了。但是想深入理解<code>JavaScript</code>，这本书也是必读的。<code>CSS</code>方面，我推荐<code>CSS权威指南</code><a href=""https://book.douban.com/subject/2308234/"" rel=""nofollow noreferrer"">豆瓣链接</a>和<code>W3C 大漠老师</code><a href=""http://www.w3cplus.com/"" rel=""nofollow noreferrer"">W3C-PLUS</a>的<code>图解CSS3</code><a href=""https://book.douban.com/subject/25920727/"" rel=""nofollow noreferrer"">豆瓣链接</a>,基本看熟这两本书，在绝大多数情况下<code>CSS</code>方面的深度和广度就都够了。</p>
<p>推荐一些网站，一个<a href=""http://ife.baidu.com/"" rel=""nofollow noreferrer"">百度IFE前端技术学院</a>，里面有百度IFE前端团队为初学者设置的循序渐进的<code>前端Tasks</code>,只要按照顺序一步一步做出来，你的前端技术一定会上一个台阶。而且有很多厉害的学学员在做同样的事情，可以尽情参考和评价别人的代码，可以学到很多的东西。还有一个是<a href=""https://www.freecodecamp.cn/"" rel=""nofollow noreferrer"">Free Code Camp</a>,应该是全世界最火的技术学习网站，和上一个类似，也是任务形式的，他会提供很多的学习资源，然后完成目标学习任务，学习结束并完成作品，还可以得到学习认证证书。</p>
<p>但是光有这些知识也还是不够的，现在的前端工程师不是只有<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>，现在的前端还要求了解网络协议、网络请求、浏览器运行机制、前端性能优化、服务端等知识，你没有办法很系统的全面的去学习，学的太深，可能你会发现光着一个知识点就够我研究几个月了，那么如何判断学到什么程度呢？我觉得这个就需要根据你自己的情况来权衡，比我我自己，我是在校生，我有大把的时间，而且我以后要面对的是校招，校招是一个很注重基础知识的面试，而且我也希望能够深入的了解一些原理性的知识。那么我当然可以更深入的去了解这些相对属于辅助性知识的内容，网络协议我可以看<code>HTTP权威指南</code><a href=""https://book.douban.com/subject/10746113/"" rel=""nofollow noreferrer"">豆瓣链接</a>，服务端的知识我可以自己去搭一个服务器，做一个前后端完全自己完成的项目，但是也有很多人网络协议看一遍博文就够了，服务端只是知道<code>Node.js</code>、<code>PHP</code>,但是他也可以很出色的完成前端的任务，对于这些东西我的建议的如果你有足够的时间和学力，你可以学的更深入一些，相信这些知识无论是对你自己驾驭手中的工作还是以后的发展都会有很大的帮助。<br>在这些路线学完之后，不出意外的话你应该有了自己的常用的组件库，比如<code>轮播图</code>、<code>模态框</code>等，还有JS的类库比如<code>操作Cookie</code>、<code>操作LocalStorage</code>、<code>Ajax</code>等。<br>接下来，你可以尝试用这些技术重构之前做的小项目，或者可以尝试去做一个更复杂的项目，比如模仿一个知乎、自己动手写一个博客系统等等。反正，到现在，基本的技术应该都会，只是还不熟练，需要的就是大量的练习使这些技术融会贯通。</p>
<h1>如何准备校招</h1>
<p>因为最近一段时间，我都在准备校招，走了不少弯路，也踩了不少坑，希望也可以把这部分的经验分享给大家。</p>
<h2>简历准备</h2>
<p>既然要去面试，简历当然是最基础的准备工作了。对于技术路线的人来说呢，简历需要注意哪些地方呢。简单说下我的看法。<br>首先简历一定要简洁明了，不然怎么叫简历。简洁，主要包括排版、配色和字体。一般的建议是主色调最好用浅色调，整个简历的配色最好不要超过两种，排版就按照自然文档流的竖排排版，每个大的区块之间有明显的分界，字体推荐使用微软雅黑、黑体、宋体等这种常见的字体，一是看起来舒服无压力，二是常见字体会让HR产生亲切感，当然也不是不可以使用其他字体，只是陌生的字体会有很大的风险，除非十分有把握，否则不推荐冒险。<br>其次是简历内容的书写，最重要的一点就是尽量写和你求职意向相关的内容，并且要主次分明。举个例子，在写校园经历的时候，A经历是担任全校最大社团某某会部长，组织了某某活动，成功吸引到多少人参与，达到了什么效果，B经历是担任某某不知名社团社员，完成了社团的网站建设，组织技术沙龙，吸引到多少人参与。对于很多同学，很容易先入为主的放弃B经历而选择A,理由也很好，A社团是全校闻名的一级社团，人尽皆知，在这样的社团里组织活动并获得良好反响是我实力的证明。而B社团，人数很少，在学校默默无闻，没有几个人知道，没有什么说服力。这非常对，但是我想问的是A社团证明的你的能力是今天面试官关心的能力吗？既然是技术面试，最关心的当然是技术能力，而且对于面试官来说他才不会在乎A、B社团那个人多，那个比较有名，在他们眼里都是一样的社团，他更关心的是你在里面做了什么、承担了什么责任。很显然，建设社团网站、举办技术沙龙这种经历，对技术面试来说是更加分的。<br>在写经历的时候，一定把与技术相关的放到最显眼的位置，同时把自己最得意、最熟悉的项目放在前面，始终记住的是面试的是技术岗，始终把技术能力放在第一位，有其他的机会的时候再展示附加的能力。</p>
<h2>知识准备</h2>
<p>其实在校招面试中，最注重的还是基础知识。以我长期以来助攻实验室学长学姐面试的经历来看，问的最多的问题就那么几类。一个是高程中的基础知识，比如原型、原型链、闭包、对象、继承等，一个是网络协议、运行机制，比如<code>TCP三次握手</code>、<code>Event Loop</code>、<code>消息队列</code>等，再就是算法，比如<code>数组去重</code>、<code>快速排序</code>、<code>冒泡排序</code>等。当然还有CSS和HTML相关的知识，热点的是<code>Flex</code>，<code>Position</code>，<code>CSS画各种图形</code>，<code>如何实现垂直水平居中</code>，<code>常用的浏览器Hack代码</code>等，这些相对比较杂且多，但是需要理解的部分不多基本上过几次就能知道，复习起来非常快。<br>我的建议是在复习这些知识的时候，最好不仅要知道基本的内容，还要了解其概念和外延。<br>举个例子，<a href=""http://css.doyoe.com/properties/positioning/position.htm"" rel=""nofollow noreferrer"">posiation</a>有哪几种属性，各有什么特点？<br>绝大多数人都能回答出<code>static |  inherit | relative | absulote | fixed</code>,其中<code>fixed</code>脱离文档流，相对窗口定位，<code>absulote</code>脱离文档流，相对最近的一个<code>Position</code>属性不为<code>static</code>的父元素定位，<code>relative</code>不脱离文档流，相对元素原来的位置定位。当然，这些说的是没错的。但是，如果你还可以说出 <code>center | page | sticky</code> 并且知道这几种定位方式出现的缘由会不会更好，即为什么会有<code>sticky</code>定位，它解决了之前用<code>CSS</code>解决不了的什么问题或者更便捷的实现了之前用<code>CSS</code>需要大段代码才能实现的效果。如果你还能说出目前的兼容性如何，都用在哪些地方，会不会更好。而由<code>Position</code>有经验的面试官又会很容易的引出脱离文档流的问题，如何脱离文档流，不同的脱离文档流的方式各有什么特点等等。<br>简单的说就是在准备面试过程中，对热点的知识点需要全面深入的了解，而不仅仅是了解其基本属性和用法，同时面试中常用提问方式和技巧也要有所了解，在准备的时候就以面试官的思维去问自己问题。<br>在复习知识的时候，我非常推荐大家自己总结，写成博客。因为要发到网上被大家审阅的文章，潜意识会写的更加严谨、认真，会整理的相对完善并且准确。<br>我的习惯遇到比较大的知识点的时候会整理成一篇博文，在整理的过程中会参考很多的文章、查基本不同的书，很多时候你会发现同一个知识点在不同的博主笔下完全是不同的调调。有的甚至是有错的。我比较推荐的阮一峰和张鑫旭老师的博文，大都写得很完整且案例丰富。<br>下面就是我做过的部分整理和总结，有一些已经同步到博客，有些还在继续整理。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000009251983?w=291&amp;h=556"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一些笔记"" title=""一些笔记""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000009251984?w=294&amp;h=555"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一些笔记"" title=""一些笔记""></span></p>
<h2>心态准备</h2>
<p>找工作和招员工本来就是一个互相选择的过程，没有最优秀，只有最合适。<br>对于水平很好，有明确目标的人，要做的就是做好准备工作，充分了解目标公司，提高嗅觉，捕捉每一分信息。举个例子，我对A公司非常感兴趣，而且知道每年都会校招。那么你要做就是关注A公司的招聘官网、微信，加入A公司的招聘社群，同时积极利用已有的校友资源捕捉第一手信息，同时在技术上关注A公司技术团队的微博、博客，及时了解A公司的技术动向，认真研究其使用的技术栈，分析其技术路线和口味。<br>而对于技术一般，没有明确目标的同学。要做就是广投简历，积累面试经验，提高被选中的概率。这是很简单的数学题，在同样分子的情况下（技术水平），分母越大（面试公司），结果越好（offer越多）。而且面试本来就是一个打怪升级的过程，通过面试积累经验，补足短板，最后拿到名企offer的案例屡见不鲜，重要的善于总结，面试没有回答上来的问题，出来快速用手机记下来，下来一定要好好总结，想想面试官想考察什么，为什么这个知识我不知道，是因为知识点太偏，还是因为属于非知识性的内容，还是因为不熟练，针对不同的问题用不同方式来补足，还有考虑一下如果回答上来了下一步他可能问什么。还是那句话，从面试官的角度去问自己问题。</p>
<h1>总结</h1>
<p>最后，借用知乎上很有名的一句话共勉。以大多数人的努力程度之低，根本轮不到拼天赋。所以，拼命努力吧，各位小伙伴们，希望大家都能在前端这条路上越走越远。<br>也希望西安前端群越来越专业，越来越开放有活力。<br>最后的最后，我要提一下我的学校<a href=""http://www.xiyou.edu.cn/"" rel=""nofollow noreferrer"">西安邮电大学</a>和我的实验室<a href=""https://github.com/ovenzeze/ThoughtCodingOfficeWebsite"" rel=""nofollow noreferrer"">ThoughtCoding实验室</a>，这是一个很棒的学校和一个很开放包容的实验室。我很感谢在我的成长路上能够遇到他们。<br>同时再次感谢杰克哥和F7哥提供这么好的交流机会和交流平台，还有西安前端群的各位小伙伴的指点，从你们身上也学到了很多的东西，大家可以一起进步。</p>
<p>下面是我的Blog、Github和邮箱，欢迎有兴趣的小伙伴和我一起讨论问题，共同进步。</p>
<p>博客：<a href=""http://ovenzeze.coding.me"" rel=""nofollow noreferrer"">ovenzeze.coding.me</a></p>
<p>Github：<a href=""https://github.com/ovenzeze"" rel=""nofollow noreferrer"">github.com/ovenzeze</a></p>
<p>邮箱：ovenzeze@qq.com</p>

                ", 一个普通本科在校生的前端学习之路,1531977854,335,1,557,1,1,https://segmentfault.com/a/1190000009251980
137,1,0,7,"
                    
<p>GitHub地址：<a href=""https://github.com/SimonZhangITer/MyBlog/issues/12"" rel=""nofollow noreferrer"">https://github.com/SimonZhang...</a></p>
<blockquote><p>this的指向问题应该是让每一个前端er都头疼的问题，我也一样，曾经遇到甚至都是一顿乱猜。最近在研读一些书籍如《你不知道的JavaScript》和《JavaScript语言精粹与编程实践》，让我对this的问题豁然开朗。故写下此篇文章，分享一下我的心得。</p></blockquote>
<h1>隐式绑定</h1>
<p>关于this，一般来说，谁调用了方法，该方法的this就指向谁，如：</p>
<pre><code class=""javascript"">function foo(){
    console.log(this.a)
}

var a = 3;

var obj = {
    a: 2,
    foo: foo
};

obj.foo(); // 输出2,因为是obj调用的foo，所以foo的this指向了obj，而obj.a = 2</code></pre>
<p>如果存在多次调用，<code>对象属性引用链只有上一层或者说最后一层在调用位置中起作用</code>，如：</p>
<pre><code class=""javascript"">function foo() {
    console.log( this.a )
}

var obj2 = { 
    a: 42,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}

obj1.obj2.foo(); // 42</code></pre>
<h2>隐式丢失</h2>
<p>一个最常见的this绑定问题就是被<code>隐式绑定</code>的函数会丢失绑定对象，也就是说他回应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。</p>
<pre><code class=""javascript"">function foo() {
    console.log( this.a )
}

var obj1 = {
    a: 2,
    foo: foo
}

var bar = obj1.foo; // 函数别名！

var a = ""oops, global""; // a是全局对象的属性

bar(); // ""oops, global""</code></pre>
<p><code>虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定</code></p>
<p>一个更微妙、更常见并且更出乎意料的情况发生在<code>传入回调函数时</code>：</p>
<pre><code class=""javascript"">function foo() {
    console.log( this.a )
}

function doFoo( fn ){
    // fn 其实引用的是 foo
    fn(); // &lt;-- 调用位置！
}

var obj = {
    a: 2,
    foo: foo
}

var a = ""oops, global""; // a是全局对象的属性

doFoo( obj.foo ); // ""oops, global""</code></pre>
<p><code>参数传递其实就是一种隐式赋值</code>，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样，如果把函数传入语言内置的函数而不是传入自己声明的函数（如setTimeout等），<code>结果也是一样的</code></p>
<h1>显式绑定</h1>
<p>简单的说，就是指定this，如：call、apply、bind、new绑定等</p>
<h2>硬绑定</h2>
<pre><code class=""javascript"">function foo( something ) {
    console.log( this.a, something)
    return this.a + something
}

var obj = {
    a: 2
}

var bar = function() {
    return foo.apply( obj, arguments)
}

var b = bar(3); // 2 3
console.log(b); // 5</code></pre>
<p>这里简单做一下解释：<br>在bar函数中，foo使用apply函数绑定了obj，也就是说foo中的this将指向obj，与此同时，使用arguments（不限制传入参数的数量）作为参数传入foo函数中；所以在运行bar(3)的时候，首先输出obj.a也就是2和传入的3，然后foo返回了两者的相加值，所以b的值为5</p>
<p>同样，本例也可以使用<code>bind</code>:</p>
<pre><code class=""javascript"">function foo( something ) {
    console.log( this.a, something)
    return this.a + something
}

var obj = {
    a: 2
}

var bar = foo.bind(obj)

var b = bar(3); // 2 3
console.log(b); // 5</code></pre>
<h2>new绑定</h2>
<p>在传统面向类的语言中，使用new初始化类的时候会调用类中的构造函数，但是JS中new的机制实际上和面向类和语言完全不同。</p>
<p>使用<code>new</code>来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>
<ul>
<li><p>创建（或者说构造）一个全新的对象</p></li>
<li><p>这个新对象会被执行[[Prototype]]连接</p></li>
<li><p>这个新对象会绑定到函数调用的this</p></li>
<li><p>如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个新对象<br>如：</p></li>
</ul>
<pre><code class=""javascript"">function foo(a){
    this.a = a
}

var bar = new foo(2);
console.log(bar.a); // 2</code></pre>
<p>使用new来调用foo(...)时，我们会构造一个新对象并把它绑定到foo(...)调用中的this上。new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。</p>
<h1>this的优先级</h1>
<p>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。</p>
<p>隐式绑定和显式绑定哪个优先级更高？我们来测试一下：</p>
<pre><code class=""javascript"">function foo(a){
    console.log(this.a)
}

var obj1 = {
    a: 2,
    foo: foo
}

var obj2 = {
    a: 3,
    foo: foo
}

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call(obj2); // 3
obj2.foo.call(obj1); // 2</code></pre>
<p>可以看到，<code>显式绑定</code>优先级更高，也就是说在判断时应当先考虑是否可以存在显式绑定。</p>
<p>现在我们要搞清楚<code>new绑定</code>和<code>隐式绑定</code>的优先级谁高谁低 ：</p>
<pre><code class=""javascript"">function foo(a){
    this.a = something
}

var obj1 = {
    foo: foo
}

var obj2 = {}

obj1.foo(2); 
console.log(obj1.a); // 2

obj1.foo.call(obj2,3);
console.log(obj2.a); // 3

var bar = new obj1.foo(4)
console.log(obj1.a); // 2
console.log(bar.a); // 4</code></pre>
<p>可以看到<code>new绑定</code>比<code>隐式绑定</code>优先级高。但是<code>new绑定</code>和<code>显式绑定</code>谁的优先级更高呢？</p>
<pre><code class=""javascript"">function foo(something){
    this.a = something
}

var obj1 = {}

var bar = foo.bind(obj1);
bar(2);
console.log(obj1.a); // 2

var baz = new bar(3);
console.log(obj1.a); // 2
console.log(baz.a); // 3</code></pre>
<p>可以看到，<code>new绑定</code>修改了<code>硬绑定</code>中的this，所以<code>new绑定</code>的优先级比<code>显式绑定</code>更高。</p>
<p>之所以要在new中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。bind(...)的功能之一就是可以把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“<code>柯里化</code>”的一种）。举例来说：</p>
<pre><code class=""javascript"">function foo(p1,p2){
    this.val = p1 + p2;
}

// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么
// 反正使用new时this会被修改
var bar = foo.bind(null,'p1');

var baz = new bar('p2');

baz.val; // p1p2
}</code></pre>
<blockquote><p>柯里化:在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。所以对于有两个变量的函数yx，如果固定了 y = 2，则得到有一个变量的函数 2x</p></blockquote>
<h1>This在箭头函数中的应用</h1>
<p>箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。</p>
<p>我们来看一下箭头函数的词法作用域：</p>
<pre><code class=""javascript"">function foo() {
    // 返回一个箭头函数
    return (a) =&gt; {
        // this继承自foo()
        console.log(this.a)
    };
}

var obj1 = {
    a: 2
};

var obj2 = {
    a: 3
};

var bar = foo.call(obj1);
bar.call(obj2); // 2, 不是3！</code></pre>
<p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行!）</p>
<h1>总结</h1>
<p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断this的绑定对象。</p>
<ol>
<li><p>由new调用？绑定到新创建的对象。</p></li>
<li><p>由call或者apply（或者bind）调用？绑定到指定的对象。</p></li>
<li><p>由上下文对象调用？绑定到那个上下文对象。</p></li>
<li><p>默认：在严格模式下绑定到undefined，否则绑定到全局对象。</p></li>
</ol>

                ", JS 中的 This 别再被问倒了，面试常见问题分析,1531977856,211,1,381,1,1,https://segmentfault.com/a/1190000009215974
138,1,0,7,"
                    
<p>GitHub 越来越有名，很多同学都把它作为一个关键字加入自己的简历当中。不过我在面试中，问到如何使用 GitHub，对方通常会答复：上去看源码呀！这个答案完全无法让我满意，具体的原因，一方面可以参考我之前的一篇文章<a href=""http://blog.meathill.com/tech/how-to-learn-about-reading-source-code.html"" rel=""nofollow noreferrer"">《谈学习：读源码》</a>，源码不是小说，直接看源码收获太小。另一方面，看源码是一个太直接的逻辑推断——上面有源码所以我去看源码——我不认为这是一个细心耕耘慢慢养成的习惯。</p>
<p>接下来我想简单谈一下，我认为应该如何使用 GitHub。</p>
<h2>Issues 和 PR</h2>
<p>一个 GitHub 仓库可不仅仅是一份源代码那么简单。GitHub 是开发者社交平台，所以每个项目在代码之外，都会有两个非常重要的模块：</p>
<ol>
<li><p>Issues 问题，包括 Bug，和其它使用者希望有的功能</p></li>
<li><p>Pull Requests（PR） 其他的开发者在这个项目上做出了一些改进，或者修复了一些 Bug，希望能够合并到 master 当中，就会发起 PR</p></li>
</ol>
<p>完美的代码是不存在的，越是用的人多的库，存在的问题，或者说被发现的问题可能就越多。阅读其他人提的问题，很多时候可以获得不小的收获，比如，大家开发时都遇到了什么问题？有没有与我类似的情况？他们是怎么解决的？大家最想要的新功能是什么？有哪些值得关注？我能做什么？等等。</p>
<blockquote><p>以及，可能是更重要的，我们应该怎么样通过 Issues 与仓库的原作者进行交流。</p></blockquote>
<p>毕竟我们每个人的时间都是有限的，对于大部分开源的类库来说，了解怎么用、有哪些问题、怎么避免踩坑，通常会比你知道它某个函数是怎么写的更有价值。</p>
<h2>看文档</h2>
<p>好的开源类库通常还会有一个做得非常到位的地方，便是它们的文档，做得通常详尽有价值。通过阅读文档，可以很快的了解这个仓库是干嘛用的，应该怎么用，能解决哪些问题，以及接下来，它的发展方向是怎样的。</p>
<p>据我观察，文档通常分布在三个地方：</p>
<ol>
<li><p>README.md，也就是打开仓库页面，默认渲染在文件列表下面的那块</p></li>
<li><p>官方网站，通常在导航下方，仓库简介那里</p></li>
<li><p>wiki，通过导航链接可以到达</p></li>
</ol>
<h2>观察提交频率</h2>
<p>并不是所有的仓库，都有开发者在进行积极地开发和维护。如果搜索到几年前的文章，被导引到一些比较古老的仓库，可能出于某种原因，已经没人对它进行维护了，这个时候，该放弃就要放弃。</p>
<p>人生苦短，时间有限，总会有更具价值的仓库供我们学习。</p>
<h2>GitHub 热门趋势</h2>
<p>GitHub 还有一个<a href=""https://github.com/trending"" rel=""nofollow noreferrer"">热门趋势</a>页面，从中你可以了解到全世界的开发者都在关注哪些仓库，你可以把自己感兴趣的那些加星标记一下，将来不定时的翻一翻看一看它的 Issue、PR 和文档，通常都会有不小的收获。</p>
<h2>GitHub Pages</h2>
<p>GitHub 还提供给我们一个非常好的静态网站空间，完全免费，全世界都有 CDN，不用白不用。便是传说中的 GitHub Pages。</p>
<p>我们可以用它写博客，做笔记，重点是内容完全可以进行版本管理。</p>
<p>具体做法请自行 Google。</p>
<h2>不要放弃提交自己的仓库，也应积极向别的开发者提出 Issue 和发起 PR</h2>
<p>我觉得这件事和写博客一样，如果你只是在纸上记笔记给自己看，那多半会不求甚解；但是你想到写成博客总会有人看到，那多半还是会把要写的内容搞清楚，写全面，逻辑清晰可自洽。所以写博客是比记笔记更好的学习方法。以此类推，把自己的仓库推到 GitHub，也理应也是比在本地练习更好的学习方式。</p>
<p>这里绝不鼓励大家乱来，相反，我希望大家对自己的行为负责，重视 Issue 和 PR，毕竟都是提给其他开发者的，或多或少都会对别人造成影响。所以在提之前，十分有必要阅读仓库主人的提交须知，按照对方的代码规范书写代码，写好相关测试，然后再提交。做到言之有物，切不可乱来画猫。</p>
<hr>
<h2>总结</h2>
<p>这篇文章不是传授大家应聘技巧的，而是希望分享自己的一些经验，让大家能够通过 GitHub 这个世界上最大的代码托管平台，正确的学习开发技巧。</p>
<p>如果您有相关的经验技巧，欢迎交流。</p>
<hr>
<p>人肉与 <a href=""http://blog.meathill.com/tech/interview-tutorial-how-to-use-github.html"" rel=""nofollow noreferrer"">我的博客</a> 同步。</p>

                ", 面试经：GitHub,1531977857,355,1,543,1,1,https://segmentfault.com/a/1190000009145735
139,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVMi6Q?w=600&amp;h=252"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>git 的分支是它最明显的特性， 大部分人听别人推荐使用git都会听到“git分支操作方便...”，对比其他版本控制系统git 分支操作有难以置信的轻量，创建新分支几乎瞬间完成，不同分支之间切换也非常快捷方便；本文将结合实践以及绘图归纳、总结git常见的分支操作指令以及注意事项；本文只总结git分支的实践运用， git分支底层实现原理请阅读<a href=""https://www.gitbook.com/book/bingohuang/progit2/details"" rel=""nofollow noreferrer"">ProGit第二版</a>分支部分章节；</p>
<h1>1.GIT创建分支；</h1>
<p>首先我们得知道， GIT分支包括本地分支 跟 远程分支； 惯例先上图：<br><span class=""img-wrap""><img data-src=""/img/bVMi61?w=600&amp;h=525"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>有时远程有的分支我们本地没有（其他同事维护的分支）， 或者本地有的分支远程没有（修复线上小问题开的本地小分支）；以下具体说下如何创建本地分支和远程分支：</p>
<h3>1.1 创建本地分支：</h3>
<p>新分支都是基于原有分支创建， 而在实践开发中基本从线上分支（与线上代码同步的分支）： master 分支创建。<br><span class=""img-wrap""><img data-src=""/img/bVMi7m?w=600&amp;h=228"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>而 从master创建本地分支也有两种方式：基于本地master分支创建分支、基于线上master分支创建分支；<br><strong>基于本地master分支创建分支（命令窗口进入工程根目录）：</strong><br>查看当前是否在master分支：</p>
<pre><code>// 查看本地分支信息
git branch</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi7r?w=880&amp;h=146"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>绿色分支表示其为当前分支，所以得切换至master分支</p>
<pre><code>git checkout master
git pull
// 创建并切换到新分支相当于：git branch xxx, git checkout xxx
git checkout -b newBranchName</code></pre>
<p><code>git checkout master</code> 切换到本地master分支;</p>
<p><code>git pull</code> 更新本地master分支代码至最新（如 本地master分支未关联远程master分支，<code>git pull origin master</code>）;</p>
<p><code>git checkout -b newBranchName</code> 基于本地master分支代码创建新分支：newBranchName,并切换到该分支;<br><span class=""img-wrap""><img data-src=""/img/bVMi97?w=600&amp;h=278"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>基于远程master分支创建分支（命令窗口进入工程根目录）：</strong></p>
<p>首先查看本地、线上分支信息（调用以下指令前建议先执行""git pull -p""防止本地git分支信息缓存）：</p>
<pre><code>git branch -a</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi7S?w=600&amp;h=485"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>白色显示为本地分支、绿色显示为当前分支、红色显示为远程分支；</p>
<p>切换至远程分支：</p>
<pre><code>git checkout remotes/origin/master</code></pre>
<p>基于远程master分支创建新分支：</p>
<pre><code>git checkout -b newBranchName</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8e?w=600&amp;h=327"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>1.2 创建远程分支：</h3>
<p>创建远程分支可以直接由本地新分支推送完成也可以在远程分支管理系统（例如：github 、gitLab）上可视化操作完成；</p>
<p><strong>本地新分支推送创建远程分支</strong><br>在 1.1 部分我们在本地创建了一新分支， 如果在该分支更新了代码， 然后执行<code>git add </code>、<code>git commit</code>指令后， 再执行以下指令可在远程创建新分支；</p>
<pre><code>// git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
git push origin newBranch:newBranch</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8o?w=600&amp;h=296"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>GitHub上创建远程分支</strong></p>
<p>选中项目， 然后在项目首页左上侧点选分支按钮， 弹出的弹层输入新分支名称即可；<br><span class=""img-wrap""><img data-src=""/img/bVMi8s?w=600&amp;h=345"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVMi8t?w=600&amp;h=292"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>PS: 上述创建的同名本地分支跟远程分支并没建立关联， 这样操作指令会比较不方便（如“git pull”指令得输入对应的远程分支名）， 怎么让其建立关联？</p>
<p>切换到newBranchName分支(如当前处在其他分支):</p>
<pre><code>git checkout newBranchName</code></pre>
<p>执行更新代码指令：</p>
<pre><code>git pull</code></pre>
<p>就能看到git 的关联提示：<br><span class=""img-wrap""><img data-src=""/img/bVMi8y?w=600&amp;h=194"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>按照其提示提示执行指令即可：</p>
<pre><code>// git branch --set-upstream-to=origin/&lt;远程分支名&gt; &lt;本地分支名&gt;如设置当前分支，第二个参数可省略,；
git branch --set-upstream-to=origin/newBranchName </code></pre>
<p>校验是否关联成功：</p>
<pre><code>git pull</code></pre>
<p>提示 “Already up-to-date.” 表示已关联成功；</p>
<h1>2.GIT切换分支；</h1>
<h3>2.1工作区没新代码切换分支：</h3>
<p>创建好新分支后就可以在新分支进行开发， 但可能中途需要去维护其他分支代码；这个时候就得切换分支了，切换分支指令：</p>
<pre><code>git checkout newBranch2</code></pre>
<p>ps: 编辑代码不会直接在develop、master分支操作，因为最终代码要同时合并到这两个分支上，所以一般均在新分支开发（即使是很小的改动）；</p>
<h3>2.2工作区有新代码切换分支：</h3>
<p>工作区间的代码均已提交到本地仓库（当前分支）， 那切换分支没什么问题， 但如果工作区域代码尚未提交，这时切换分支会怎样呢？<br>有时候无法切换， 有时候能正常切换；<br>能正常切换：改动的代码能正常合并到切换后的分支（自动合并成功）<br>无法切换：改动的代码不能正常合并到切换后的分支（自动合并失败）<br>工作区间有未提交代码，切换分支自动执行<code>git merge</code>操作，故有冲突将无法切换成功；<br>当然也会有这样的场景： 当前分支代码没写完，还不想提交且因为有紧急需求不得不切换分支；这个时候可以 使用“<a href=""http://www.kancloud.cn/wteamxq/git_rank/276490"" rel=""nofollow noreferrer"">工作现场</a>”将代码暂时放着：</p>
<pre><code>// 如 直接 ""git stash""则将上次commit注释作为说明
git stash save ""存储说明""
git checkout B</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8E?w=600&amp;h=197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>处理完紧急需求拿出继续开发：</p>
<pre><code>git checkout A
git stash pop</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8K?w=600&amp;h=177"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果本来想在A分支上开发， 开发过程中才发现当前处在B分支，想强制将工作区间代码迁到A分支也可以借助“工作现场”完成：</p>
<pre><code>git stash save ""存储说明""
git checkout B</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8E?w=600&amp;h=197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<pre><code>git stash pop
// 如有冲突且处理完所有冲突
git add -A</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi8T?w=600&amp;h=192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>2.3切换分支异常处理（windows下）</h3>
<p>不少在windows下使用git的同学会碰到这样的问题： 从A分支切换到B分支由于git异常导致虽然切换分支成功，但在当前B分支上留存了大量A分支的代码（被git认为是新的改动或新增文件）；<br>这个时候就得用到上一篇博文（<a href=""https://zhuanlan.zhihu.com/p/22734098"" rel=""nofollow noreferrer"">git图解2：git 代码回退；</a>）知识了!<br>我们可以将所有改动提交， 然后使用远程分支代码覆盖！放心提交到本地仓库，反正后面这个commit会被覆盖。</p>
<pre><code>// 将所有改动提交到本地仓库
git add -A
git commit -m ""这个commit会被覆盖""
//B 是当前分支名
git reset --hard origin/B</code></pre>
<p>惯例放图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVMjag?w=600&amp;h=441"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h1>3.GIT合并分支；</h1>
<h3>3.1正常合并分支代码</h3>
<p>分支代码合并也有两方式： 合并本地分支代码、合并远程分支代码；</p>
<p><strong>合并本地分支代码</strong>: 例如在新分支 newBranch开发的功能已完成并已提交；接下来走测试流程需要将代码合并到develop分支（我所在团队develop为测试分支，不同团队的测试分支会不一样）。</p>
<pre><code>// 切换到develop分支
git checkout develop
// 合并newBranch代码
git merge newBranch
// 提交commit到远程（newBranch分支有多少个commit就会生成几个）
git push</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi80?w=600&amp;h=288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>合并远程分支代码: 如果新分支由多人维护，为保证更新代码为最新，使用上述方式合并分支会比较麻烦：</p>
<p>首先得切换到本地newBranch分支(<code>git checkout newBranch</code>)；</p>
<p>然后更新代码(<code>git pull</code>)；</p>
<p>再次切换回develop分支(<code>git checkout develop</code>)；</p>
<p>最后才能执行合并操作(<code>git merge newBranch</code>);</p>
<p>其实可直接将远程的 newBranch分支代码合并到本地 develop分支：</p>
<pre><code>git pull origin newBranch</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVMi86?w=600&amp;h=301"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>3.2合并代码冲突解决</h3>
<p>无论哪种方式合并分支代码代码冲突是无可避免的情况， 开发流程使用了typescript/sass等需要执行编译的语言更容易产生冲突；</p>
<p>分支合并代码冲突跟一般代码冲突一样： git能处理的冲突会自动解决， 否则就得手动解决冲突；冲突是由于多人维护代码导致，一定要找到相关人一起讨论冲突代码的取舍；</p>
<p>如果待合并分支代码跟当前分支前几次commit修改了同一文件，合并分支就会出现以下提示：<br><span class=""img-wrap""><img data-src=""/img/bVMi9e?w=600&amp;h=87"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>以上提示git自动合并失败，需要手动解决冲突， 打开冲突文件会发现以下：<br><span class=""img-wrap""><img data-src=""/img/bVMi9f?w=600&amp;h=210"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><code>HEAD</code>到<code>=======</code>之间为当前分支改动， <code>=======</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; newBranch</code>为待合并分支的改动；</p>
<p>手动解决冲突后：<br><span class=""img-wrap""><img data-src=""/img/bVMi9i?w=600&amp;h=82"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>告诉git冲突已解决：</p>
<pre><code>git add -A</code></pre>
<p>合并完成，提交代码：</p>
<pre><code>git commit -m ""[master]-合并newBranch代码""
git push</code></pre>
<h3>3.3合并代码异常处理</h3>
<p>同切换分支异常情况， 在windows下合并分支也会出现异常， 异常处理方式同上：</p>
<pre><code>// 将所有改动提交到本地仓库
git add -A
git commit -m ""这个commit会被覆盖""
//B 是当前分支名
git reset --hard origin/B</code></pre>
<h3>3.4合并代码减少commit次数（简洁合并）</h3>
<p>在合并分支后使用可视化工具查看代码提交记录(或者 ""git log"" 指令)， 有代码洁癖的同学可能接受不了。如果 newBranch分支开发过程中有10个commit， 那合并完成后（没产生冲突）也会产生10个commit；如何让合并代码后commit更简洁？</p>
<p>使用<code>git rebase</code>合并分支代码（实际开发中会发现<code>git rebase</code>执行起来非常麻烦）：</p>
<p>rebase，合并的结果好看：清晰、直观，但合并过程中出现冲突处理比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；</p>
<p>merge，合并结果不好看：一堆线交错，但合并有冲突的话，只要解决一次就行了；</p>
<p>所以建议先<code>git rebase xxx</code>，如有冲突，<code>git rebase --abort</code>，再换用<code>git merge xxx</code>。</p>
<p>另一方案： 可以合并完成后（<code>git push</code>之前）编辑commit 信息， 将多个commit合并成一个：</p>
<p>例如： 我再当前newBranch分支提交了三个commit :<br><span class=""img-wrap""><img data-src=""/img/bVMi9o?w=600&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>执行<code>git rebase -i</code>进入交互模式，自动打开vim:</p>
<p>将后两个“pick”改成（vim模式输入“i”进入编辑状态）“s”, 然后保存退出(esc退出编辑状态，然后"":""输入“wq”保存退出):<br><span class=""img-wrap""><img data-src=""/img/bVMi9u?w=600&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>保存成功后还有一个编辑vim, 合并commit后，新的commit注释填写下，保存退出：<br><span class=""img-wrap""><img data-src=""/img/bVMi9A?w=600&amp;h=333"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>合并完成：<br><span class=""img-wrap""><img data-src=""/img/bVMjar?w=600&amp;h=558"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>ps： 简洁合并付出的就是多余的操作， 实际开发讲求的是效率， 所以很多人懒得弄这些（例如我）；</p>
<h1>4.GIT删除分支；</h1>
<p>git的分支在完成它使命后就没必要存在了：</p>
<blockquote><p>上线流程完成：应删除本地分支及远程分支(git lab分支)： git branch -D xxxx， 上线完成意味着当前xxx分支代码已经合并到线上分支（master）以及开发分支(develop)， 该分支后续功能的改动（bug修复或代码扩展）完全可以在master新开分支完成；（<strong>否则可能遗忘删除，导致远程分支原来越多</strong>） ----[git_tips - [ git常用指令排行榜 ] - 看云](<a href=""http://www.kancloud.cn/wteamxq/git_rank/292402)"" rel=""nofollow noreferrer"">http://www.kancloud.cn/wteamx...</a></p></blockquote>
<h3>4.1删除本地分支</h3>
<pre><code>// ""-d"" 如果该分支代码未合并到其他分支，将无法删除;
// ""-D"" 强制删除分支，不会出现任何提示；
git branch -D xxxx</code></pre>
<h3>4.2删除远程分支</h3>
<p>删除远程分支两种方式：</p>
<p>1.在git管理系统的Web页面操作（gitLab）；<br>gitHub上无法删除远程分支， 如果你团队使用的是gitLab那可以在gitLab管理页面操作；</p>
<p>2.本地指令完成；</p>
<pre><code>git push origin --delete newBranch</code></pre>
<hr>
<h1>参考资料：</h1>
<p><a href=""https://git-scm.com/docs/git-branch"" rel=""nofollow noreferrer"">git branch官方API文档</a><br><a href=""http://yongpoliu.com/reorganize-git-local-commits/"" rel=""nofollow noreferrer"">重新组织git本地提交 | yongpoliu.com</a><br><a href=""http://www.kancloud.cn/wteamxq/git_rank/277620"" rel=""nofollow noreferrer"">git常用指令排行榜</a></p>
<h1>相关文章：</h1>
<p><a href=""https://segmentfault.com/a/1190000007067265"" rel=""nofollow noreferrer"">git图解1：git区域总结；</a><br><a href=""https://segmentfault.com/a/1190000007070302"" rel=""nofollow noreferrer"">git图解2：git 代码回退；</a></p>

                ", git图解3：分支操作,1531977859,272,1,157,1,1,https://segmentfault.com/a/1190000009091082
140,1,0,7,"
                    
<h2>前言</h2>
<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>
<p>不过话说回来，作为最具个人创造力和最会利用工具的物种——程序猿，最好是能有规范和工具的约束。否者的话，你可能看到以下的<code>commit message</code>：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVL8aF?w=532&amp;h=496"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""401f01ddcb6c4aacdd8ca827cc941da1_b.jpg"" title=""401f01ddcb6c4aacdd8ca827cc941da1_b.jpg""></span></p>
<p>目前，社区有多种 Commit message 的写法规范。本文介绍<a href=""https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0"" rel=""nofollow noreferrer"">Angular 规范</a>是目前使用最广的写法，比较合理和系统化，并且有配套的工具。前前端框架<a href=""https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#toc10"" rel=""nofollow noreferrer"">Angular.js</a>采用的就是该规范。如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009048914?w=700&amp;h=678"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>Commit message 的作用</h2>
<h3>提供更多的历史信息，方便快速浏览。</h3>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
<pre><code>$ git log &lt;last tag&gt; HEAD --pretty=format:%s</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009048915?w=546&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>可以过滤某些commit（比如文档改动），便于快速查找信息</h3>
<pre><code>$ git log &lt;last release&gt; HEAD --grep feature</code></pre>
<h3>可以直接从commit生成Change log。</h3>
<p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000009048916?w=700&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>其他优点</h3>
<ul>
<li><p>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</p></li>
<li><p>为 Code Reviewing做准备</p></li>
<li><p>方便跟踪工程历史</p></li>
<li><p>让其他的开发者在运行 git blame 的时候想跪谢</p></li>
<li><p>提高项目的整体质量，提高个人工程素质</p></li>
</ul>
<h2>Commit message 的格式</h2>
<p>每次提交，Commit message 都包括三个部分：header，body 和 footer。</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;</code></pre>
<p>其中，header 是必需的，body 和 footer 可以省略。<br>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h3>Header</h3>
<p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<h4>type</h4>
<p>用于说明 commit 的类别，只允许使用下面7个标识。</p>
<ul>
<li><p>feat：新功能（feature）</p></li>
<li><p>fix：修补bug</p></li>
<li><p>docs：文档（documentation）</p></li>
<li><p>style： 格式（不影响代码运行的变动）</p></li>
<li><p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p></li>
<li><p>test：增加测试</p></li>
<li><p>chore：构建过程或辅助工具的变动</p></li>
</ul>
<p>如果type为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<h4>scope</h4>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>例如在<code>Angular</code>，可以是<code>$location</code>, <code>$browser</code>, <code>$compile</code>, <code>$rootScope</code>, <code>ngHref</code>, <code>ngClick</code>, <code>ngView</code>等。</p>
<p>如果你的修改影响了不止一个<code>scope</code>，你可以使用<code>*</code>代替。</p>
<h4>subject</h4>
<p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p>
<p>其他注意事项：</p>
<ul>
<li><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p></li>
<li><p>第一个字母小写</p></li>
<li><p>结尾不加句号（.）</p></li>
</ul>
<h3>Body</h3>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<pre><code>More detailed explanatory text, if necessary.  Wrap it to 
about 72 characters or so. 

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Use a hanging indent</code></pre>
<p>有两个注意点:</p>
<ul>
<li><p>使用第一人称现在时，比如使用change而不是changed或changes。</p></li>
<li><p>永远别忘了第2行是空行</p></li>
<li><p>应该说明代码变动的动机，以及与以前行为的对比。</p></li>
</ul>
<h3>Footer</h3>
<p>Footer 部分只用于以下两种情况：</p>
<h4>不兼容变动</h4>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<pre><code>BREAKING CHANGE: isolate scope bindings definition has changed.

    To migrate the code follow the example below:

    Before:

    scope: {
      myAttr: 'attribute',
    }

    After:

    scope: {
      myAttr: '@',
    }

    The removed `inject` wasn't generaly useful for directives so there should be no code using it.</code></pre>
<h4>关闭 Issue</h4>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<pre><code>Closes #234</code></pre>
<h3>Revert</h3>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p>
<pre><code>revert: feat(pencil): add 'graphiteWidth' option

This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</code></pre>
<p>Body部分的格式是固定的，必须写成<code>This reverts commit &amp;lt;hash&gt;</code>.，其中的hash是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p>
<h2>Commitizen</h2>
<p>可以使用典型的git工作流程或通过使用CLI向导<a href=""https://github.com/commitizen/cz-cli"" rel=""nofollow noreferrer"">Commitizen</a>来添加提交消息格式。</p>
<h3>安装</h3>
<pre><code> npm install -g commitizen</code></pre>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<pre><code>commitizen init cz-conventional-changelog --save --save-exact</code></pre>
<p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000009048917?w=557&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>validate-commit-msg</h2>
<p><a href=""https://github.com/kentcdodds/validate-commit-msg"" rel=""nofollow noreferrer"">validate-commit-msg</a> 用于检查项目的 Commit message 是否符合Angular规范。</p>
<p>该包提供了使用githooks来校验<code>commit message</code>的一些二进制文件。在这里，我推荐使用<a href=""http://npm.im/husky"" rel=""nofollow noreferrer"">husky</a>，只需要添加<code> ""commitmsg"": ""validate-commit-msg"" </code>到你的<code>package.json</code>中的<code>nam scripts</code>即可.</p>
<p>当然，你还可以通过定义配置文件<code>.vcmrc</code>来自定义校验格式。详细使用请见文档 <a href=""https://github.com/kentcdodds/validate-commit-msg"" rel=""nofollow noreferrer"">validate-commit-msg</a></p>
<h2>生成 Change log</h2>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分：</p>
<ul>
<li><p>New features</p></li>
<li><p>Bug fixes</p></li>
<li><p>Breaking changes.</p></li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p><a href=""https://github.com/ajoslin/conventional-changelog"" rel=""nofollow noreferrer"">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<pre><code>$ npm install -g conventional-changelog
$ cd my-project
$ conventional-changelog -p angular -i CHANGELOG.md -w</code></pre>
<h2>参考文章</h2>
<p><a href=""http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"" rel=""nofollow noreferrer"">Commit message 和 Change log 编写指南</a><br><a href=""https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#toc10"" rel=""nofollow noreferrer"">Angular.js Git Commit Guidelines</a></p>

                ", git commit 规范指南,1531977861,433,1,952,1,1,https://segmentfault.com/a/1190000009048911
141,1,0,7,"
                    
<p>原文收录在我的 GitHub博客 ( <a href=""https://github.com/jawil/blog"" rel=""nofollow noreferrer"">https://github.com/jawil/blog</a> ) ，喜欢的可以关注最新动态，大家一起多交流学习，共同进步，以学习者的身份写博客，记录点滴。</p>
<p>按照格式推荐好用的插件有福利哦，说不定会送1024论坛邀请码，好自为之，你懂的，嘿嘿嘿。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/e0451ec1.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>由于github的issues没有TOC菜单栏导航，所以这里方便大家查看，先安利一款Chrome浏览器的插件，感谢github用户@BBcaptain 推荐。<a href=""https://chrome.google.com/webstore/detail/smart-toc/lifgeihcfpkmmlfjbailfpfhbahhibba"" rel=""nofollow noreferrer"">点击我呀，进入商店，自备梯子，如果不会翻墙，赶紧转行</a>。。。</p>
<p>效果预览，是不是很方便，图片较多，建议等待一会或者多刷新几下：</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2003.33.45.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Echo.js – 简单易用的图片延迟加载插件</h2>
<p>github：<a href=""https://github.com/toddmotto/echo"" rel=""nofollow noreferrer"">https://github.com/toddmotto/...</a> </p>
<p>官方网站：<a href=""https://toddmotto.com/echo-js-simple-javascript-image-lazy-loading/"" rel=""nofollow noreferrer"">https://toddmotto.com/echo-js...</a></p>
<p>star：3k+</p>
<p>Install：</p>
<pre><code>npm:npm install echo-js
bower:bower install echojs</code></pre>
<p>大小：2KB</p>
<p>功能介绍：<br>　　Echo.js 是一个独立的延迟加载图片的 JavaScript 插件。Echo.js 不依赖第三方库，压缩后不到1KB大小。 延迟加载是提高网页首屏显示速度的一种很有效的方法，当图片元素进入窗口可视区域的时候，它就会改变图像的 src 属性，从服务端加载所需的图片，这也是一个异步的过程。<br>　　<br>Demo：<br>效果预览地址：<a href=""https://jawil.github.io/demo/echo.js/"" rel=""nofollow noreferrer"">https://jawil.github.io/demo/...</a><br>Demo源码：<a href=""https://github.com/jawil/jawil.github.io/tree/master/demo/echo.js"" rel=""nofollow noreferrer"">https://github.com/jawil/jawi...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.39.33.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Lazyr.js – 延迟加载图片（Lazy Loading）</h2>
<p>github：<a href=""https://github.com/callmecavs/layzr.js"" rel=""nofollow noreferrer"">https://github.com/callmecavs...</a></p>
<p>官方网站：<a href=""http://callmecavs.com/layzr.js/"" rel=""nofollow noreferrer"">http://callmecavs.com/layzr.js/</a></p>
<p>star：5k+</p>
<p>Install：</p>
<pre><code>npm:npm install layzr.js --save</code></pre>
<p>大小：2.75 KB</p>
<p>功能介绍：<br>　　Lazyr.js 是一个小的、快速的、现代的、相互间无依赖的图片延迟加载库。通过延迟加载图片，让图片出现在（或接近)）视窗才加载来提高页面打开速度。这个库通过保持最少选项并最大化速度。</p>
<p>Demo：<br>跟上面的Echo.js用法类似，喜欢的可以自行去尝试，这里就不再演示了，我一般用Echo.js。</p>
<p>   </p>
<h2>better-scroll.js – 小巧，灵活的 JavaScript 模拟滚动条的插件</h2>
<p>github：<a href=""https://github.com/ustbhuangyi/better-scroll"" rel=""nofollow noreferrer"">https://github.com/ustbhuangy...</a></p>
<p>官方网站：<a href=""https://ustbhuangyi.github.io/better-scroll/"" rel=""nofollow noreferrer"">https://ustbhuangyi.github.io...</a></p>
<p>star：300+</p>
<p>Install：</p>
<pre><code>npm install better-scroll --save-dev
import BScroll from 'better-scroll';</code></pre>
<p>大小：24 KB</p>
<p>功能介绍：<br>　　better-scroll 是一个只有24.8KB的 JavaScript 模拟浏览器自带滚动条的插件，是在<a href=""https://github.com/cubiq/iscroll"" rel=""nofollow noreferrer"">iscroll</a>开源的基础上进行优化的一款插件，简单好用，轻巧高性能，功能强大，API通俗易懂，是一款优秀的scroll插件，抛弃原生滚动条，从现在做起。</p>
<p>Demo：<br>效果预览地址：<a href=""https://jawil.github.io/demo/eleme/"" rel=""nofollow noreferrer"">https://jawil.github.io/demo/...</a> (PC端切换到移动模式)<br>Demo源码：<a href=""https://github.com/jawil/webpack2"" rel=""nofollow noreferrer"">https://github.com/jawil/webp...</a><br>注：在ustbhuangyi的源码下改进了一下，做成多页面，技术栈：webpack2+vue.js2+sass+axios</p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.49.15.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>better-picker – 一款轻量级IOS风格的JavaScript选择器</h2>
<p>github：<a href=""https://github.com/ustbhuangyi/picker"" rel=""nofollow noreferrer"">https://github.com/ustbhuangy...</a></p>
<p>官方网站：<a href=""http://ustbhuangyi.github.io/picker/"" rel=""nofollow noreferrer"">http://ustbhuangyi.github.io/...</a></p>
<p>star：200+</p>
<p>Install：</p>
<pre><code>npm: npm install better-picker --save-dev
import Picker from 'better-picker'</code></pre>
<p>大小：46.5 KB</p>
<p>功能介绍：<br>　  移动端最好用的的筛选器组件，高仿 ios 的 UIPickerView ，非常流畅的体验，原生 JS 实现，不依赖任何插件和第三方库。<br>Demo：<br>效果预览地址：<a href=""http://ustbhuangyi.github.io/picker/"" rel=""nofollow noreferrer"">http://ustbhuangyi.github.io/...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2001.48.38.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Sortable – 一款用于实现元素拖拽排序的功能的插件</h2>
<p>github：<a href=""https://github.com/RubaXa/Sortable"" rel=""nofollow noreferrer"">https://github.com/RubaXa/Sor...</a></p>
<p>官方网站：<a href=""http://rubaxa.github.io/Sortable/"" rel=""nofollow noreferrer"">http://rubaxa.github.io/Sorta...</a></p>
<p>star：9k+</p>
<p>Install：</p>
<pre><code>Bower: bower install sortablejs --save
npm: npm install sortablejs </code></pre>
<p>大小：5 KB</p>
<p>功能介绍：<br>　Sortable：现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuery这玩意。</p>
<p>Demo：<br>效果预览地址：<a href=""http://rubaxa.github.io/Sortable/"" rel=""nofollow noreferrer"">http://rubaxa.github.io/Sorta...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2003.19.52.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>   </p>
<h2>slick – 功能异常强大的一个图片滑动切换效果库</h2>
<p>github：<a href=""https://github.com/kenwheeler/slick"" rel=""nofollow noreferrer"">https://github.com/kenwheeler...</a></p>
<p>官方网站：<a href=""http://kenwheeler.github.io/slick/"" rel=""nofollow noreferrer"">http://kenwheeler.github.io/s...</a></p>
<p>star：17k+</p>
<p>Install：</p>
<pre><code>Bower: bower install slick-carousel --save
npm: npm install slick-carousel
CDNs:
https://cdnjs.com/libraries/slick-carousel
https://www.jsdelivr.com/projects/jquery.slick</code></pre>
<p>大小：40 KB</p>
<p>功能介绍：<br>　slick 是一个功能异常强大的一个图片滑动切换效果库，接口丰富，支持各种动画和各种样式的切换滑动，唯一的缺点就是基于jQuery，基本废了，现在没人喜欢用jQuery，该淘汰了。。。支持 RequireJS 以及 Bower 安装。</p>
<p>Demo：<br>效果预览地址：<a href=""http://kenwheeler.github.io/slick/"" rel=""nofollow noreferrer"">http://kenwheeler.github.io/s...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2002.19.48.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span> <br>   </p>
<h2>swipe – 非常轻量级的一个图片滑动切换效果库</h2>
<p>github：<a href=""https://github.com/lyfeyaj/Swipe"" rel=""nofollow noreferrer"">https://github.com/lyfeyaj/Swipe</a></p>
<p>官方网站：<a href=""http://lyfeyaj.github.io/swipe/"" rel=""nofollow noreferrer"">http://lyfeyaj.github.io/swipe/</a></p>
<p>star：200+</p>
<p>Install：</p>
<pre><code>Bower: bower install swipe-js  --save
npm: npm install swipe-js </code></pre>
<p>大小：5 KB</p>
<p>功能介绍：<br>　swipe：非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kb。可以结合 jQuery、RequireJS 使用。</p>
<p>Demo：<br>效果预览地址：<a href=""http://lyfeyaj.github.io/swipe/"" rel=""nofollow noreferrer"">http://lyfeyaj.github.io/swipe/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2002.29.27.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Slideout.js – 触摸滑出式 Web App 导航菜单</h2>
<p>github：<a href=""https://github.com/mango/slideout"" rel=""nofollow noreferrer"">https://github.com/mango/slid...</a></p>
<p>官方网站：<a href=""https://slideout.js.org/"" rel=""nofollow noreferrer"">https://slideout.js.org/</a></p>
<p>star：6k+</p>
<p>Install：</p>
<pre><code>npm:npm install slideout
spm:spm install slideout
bower:bower install slideout.js
component:component install mango/slideout
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js""&gt;&lt;/script&gt;</code></pre>
<p>大小：4 KB</p>
<p>功能介绍：<br>　　Slideout.js 是为您的移动 Web 应用开发的触摸滑出式的导航菜单。它没有依赖，自由搭配简单的标记，支持原生的滚动，您可以轻松地定制它。它支持不同的 CSS3 转换和过渡。最重要的是，它只是4KB 。</p>
<p>Demo：<br>效果预览地址：<a href=""https://slideout.js.org/"" rel=""nofollow noreferrer"">https://slideout.js.org/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.53.07.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>SweetAlert – 替代 Alert 的漂亮的提示效果</h2>
<p>github：<a href=""https://github.com/t4t5/sweetalert"" rel=""nofollow noreferrer"">https://github.com/t4t5/sweet...</a></p>
<p>官方网站：<a href=""http://t4t5.github.io/sweetalert/"" rel=""nofollow noreferrer"">http://t4t5.github.io/sweetal...</a></p>
<p>star：15k+</p>
<p>Install：</p>
<pre><code>bower:bower install sweetalert
npm:npm install sweetalert
&lt;script src=""dist/sweetalert.min.js""&gt;&lt;/script&gt;
&lt;link rel=""stylesheet"" type=""text/css"" href=""dist/sweetalert.css""&gt;</code></pre>
<p>大小：16 KB</p>
<p>功能介绍：<br>　 Sweet Alert 是一个替代传统的 JavaScript Alert 的漂亮提示效果。SweetAlert 自动居中对齐在页面中央，不管您使用的是台式电脑，手机或平板电脑看起来效果都很棒。另外提供了丰富的自定义配置选择，可以灵活控制。</p>
<p>Demo：<br>效果预览地址：<a href=""http://t4t5.github.io/sweetalert/"" rel=""nofollow noreferrer"">http://t4t5.github.io/sweetal...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2023.32.43.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>类似插件：limonte/sweetalert2，好像这个最近还在更新，这个感觉更漂亮，大同小异，这里不多做介绍。</p>
<p>github：<a href=""https://github.com/limonte/sweetalert2"" rel=""nofollow noreferrer"">https://github.com/limonte/sw...</a></p>
<p>官方网站： <a href=""https://limonte.github.io/sweetalert2/"" rel=""nofollow noreferrer"">https://limonte.github.io/swe...</a></p>
<p>   </p>
<h2>Awesomplete.js - 比datalist更强大更实用，零依赖的简单自动补全插件</h2>
<p>github：<a href=""https://github.com/leaverou/awesomplete/"" rel=""nofollow noreferrer"">https://github.com/leaverou/a...</a></p>
<p>官方网站：<a href=""http://leaverou.github.io/awesomplete/"" rel=""nofollow noreferrer"">http://leaverou.github.io/awe...</a></p>
<p>star：5k+</p>
<p>Install：<br>`npm: npm install awesomplete<br>`</p>
<p>大小：5 KB</p>
<p>功能介绍：<br>　Awesomplete 是一款超轻量级的，可定制的，简单的自动完成插件，零依赖，使用现代化标准构建。你可以简单地添加 awesomplete 样式，让它自动处理（你仍然可以通过指定 HTML 属性配置更多选项），您可以用几行 JS 代码，提供更多的自定义。</p>
<p>Demo：<br>效果预览地址：<a href=""http://leaverou.github.io/awesomplete/"" rel=""nofollow noreferrer"">http://leaverou.github.io/awe...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.31.03.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p> </p>
<h2>Cleave.js – 自动格式化表单输入框的文本内容</h2>
<p>github：<a href=""https://github.com/nosir/cleave.js/"" rel=""nofollow noreferrer"">https://github.com/nosir/clea...</a></p>
<p>官方网站：<a href=""http://nosir.github.io/cleave.js/"" rel=""nofollow noreferrer"">http://nosir.github.io/cleave...</a></p>
<p>star：6k+</p>
<p>Install：</p>
<pre><code>npm:npm install --save cleave.js
bower:bower install --save cleave.js</code></pre>
<p>大小：11.1 KB</p>
<p>功能介绍：<br>　　Cleave.js 有一个简单的目的：帮助你自动格式输入的文本内容。 这个想法是提供一个简单的方法来格式化您的输入数据以增加输入字段的可读性。通过使用这个库，您不需要编写任何正则表达式来控制输入文本的格式。然而，这并不意味着取代任何验证或掩码库，你仍应在后端验证数据。它支持信用卡号码、电话号码格式（支持各个国家）、日期格式、数字格式、自定义分隔符，前缀和块模式等，提供 CommonJS/AMD 模式以及ReactJS 组件端口。</p>
<p>Demo：<br>效果预览地址：<a href=""http://nosir.github.io/cleave.js/"" rel=""nofollow noreferrer"">http://nosir.github.io/cleave...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。<br>输入201748自动格式化成2017-04-08，是不是很方便<br><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.35.27.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>  </p>
<h2>Immutable.js – JavaScript 不可变数据集合（Facebook出品）</h2>
<p>github：<a href=""https://github.com/facebook/immutable-js"" rel=""nofollow noreferrer"">https://github.com/facebook/i...</a></p>
<p>官方网站：<a href=""http://facebook.github.io/immutable-js/"" rel=""nofollow noreferrer"">http://facebook.github.io/imm...</a></p>
<p>star：18k+</p>
<p>Install：</p>
<pre><code>npm install immutable --S-D</code></pre>
<p>大小：60 KB</p>
<p>功能介绍：<br>　　不可变数据是指一旦创建就不能被修改的数据，使得应用开发更简单，允许使用函数式编程技术，比如惰性评估。Immutable JS 提供一个惰性 Sequence，允许高效的队列方法链，类似 map 和 filter ，不用创建中间代表。Immutable.js 提供持久化的列表、堆栈、Map， 以及 OrderedMap 等，最大限度地减少需要复制或缓存数据。</p>
<p>Demo：</p>
<pre><code class=""JavaScript"">&lt;script src=""immutable.min.js""&gt;&lt;/script&gt;
&lt;script&gt;
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
&lt;/script&gt;</code></pre>
<p>更多信息和探讨请移步,这里不多做介绍：<a href=""https://www.zhihu.com/question/28016223"" rel=""nofollow noreferrer"">facebook immutable.js 意义何在，使用场景？</a></p>
<p>   </p>
<h2>Popmotion.js – 小巧，灵活的 JavaScript 运动引擎</h2>
<p>github：<a href=""https://github.com/Popmotion/popmotion"" rel=""nofollow noreferrer"">https://github.com/Popmotion/...</a></p>
<p>官方网站：<a href=""https://popmotion.io/"" rel=""nofollow noreferrer"">https://popmotion.io/</a></p>
<p>star：3k+</p>
<p>Install：</p>
<pre><code>npm install --save popmotion
import { tween } from 'popmotion';</code></pre>
<p>大小：12 KB</p>
<p>功能介绍：<br>　　Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。Popmotion 网站上有很多很赞的效果，赶紧去体验一下。</p>
<p>Demo：<br>效果预览地址：<a href=""http://codepen.io/popmotion/pen/egwMGQ"" rel=""nofollow noreferrer"">http://codepen.io/popmotion/p...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.38.19.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>    </p>
<h2>Dynamics.js - 创建逼真的物理动画的 JS 库</h2>
<p>github：<a href=""https://github.com/michaelvillar/dynamics.js"" rel=""nofollow noreferrer"">https://github.com/michaelvil...</a></p>
<p>官方网站：<a href=""http://dynamicsjs.com/"" rel=""nofollow noreferrer"">http://dynamicsjs.com/</a></p>
<p>star：6k+</p>
<p>Install：</p>
<pre><code>npm: npm install dynamics.js
bower: bower install dynamics.js</code></pre>
<p>大小：20 KB</p>
<p>功能介绍：<br>　　Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。Popmotion 网站上有很多很赞的效果，赶紧去体验一下。</p>
<p>Demo：<br>效果预览地址：<a href=""http://dynamicsjs.com/"" rel=""nofollow noreferrer"">http://dynamicsjs.com/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.42.46.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Rainyday.js – 使用 JavaScript 实现雨滴效果</h2>
<p>github：<a href=""https://github.com/maroslaw/rainyday.js"" rel=""nofollow noreferrer"">https://github.com/maroslaw/r...</a></p>
<p>官方网站：<a href=""http://maroslaw.github.io/rainyday.js/"" rel=""nofollow noreferrer"">http://maroslaw.github.io/rai...</a></p>
<p>star：5k+</p>
<p>Install：</p>
<p>在github的dist目录下载rainyday.min.js</p>
<p>大小：10 KB</p>
<p>功能介绍：<br>　Rainyday.js 背后的想法是创建一个 JavaScript 库，利用 HTML5 Canvas 渲染一个雨滴落在玻璃表面的动画。Rainyday.js 有功能可扩展的 API，例如碰撞检测和易于扩展自己的不同的动画组件的实现。它是一个使用 HTML5 特性纯 JavaScript 库，支持大部分现代浏览器。</p>
<p>Demo：<br>效果预览地址：<a href=""http://maroslaw.github.io/rainyday.js/demo012_1.html"" rel=""nofollow noreferrer"">http://maroslaw.github.io/rai...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.44.08.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Swiper – 经典的移动触摸滑块轮播插件</h2>
<p>github：<a href=""https://github.com/nolimits4web/Swiper"" rel=""nofollow noreferrer"">https://github.com/nolimits4w...</a></p>
<p>官方网站：<a href=""http://idangero.us/swiper/"" rel=""nofollow noreferrer"">http://idangero.us/swiper/</a></p>
<p>star：11.8k+</p>
<p>Install：</p>
<pre><code>在github上下载</code></pre>
<p>大小：暂不确定，按需引入</p>
<p>功能介绍：<br>　Swiper 是移动 Web 开发中最常用的滑块插件，是一款免费的，最现代化的移动触摸滑块，支持硬件加速的转换和惊人的原生表现。它的目的是在移动网站，移动 Web 应用程序和 Hygrid 混合应用程序中使用。最初的设计主要是为 iOS，但同时也支持最新的 Android，Windows Phone 8 和现代的桌面浏览器。</p>
<p>Demo：<br>效果预览地址：<a href=""http://idangero.us/swiper/#.WOik3l--uaW"" rel=""nofollow noreferrer"">http://idangero.us/swiper/#.W...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2022.46.15.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Snabbt.js – 极简的 JavaScript 动画库</h2>
<p>github：<a href=""https://github.com/daniel-lundin/snabbt.js"" rel=""nofollow noreferrer"">https://github.com/daniel-lun...</a></p>
<p>官方网站：<a href=""http://daniel-lundin.github.io/snabbt.js/"" rel=""nofollow noreferrer"">http://daniel-lundin.github.i...</a></p>
<p>star：5k+</p>
<p>Install：</p>
<pre><code>bower:bower install snabbt.js
npm:npm install snabbt.js
CDNs:
https://cdnjs.com/libraries/snabbt.js
http://www.jsdelivr.com/#!snabbt</code></pre>
<p>大小：16 KB</p>
<p>功能介绍：<br>　Snabbt.js 是一个简约的 JavaScript 动画库。它会平移，旋转，缩放，倾斜和调整你的元素。通过矩阵乘法运算，变换等可以任何你想要的方式进行组合。最终的结果通过 CSS3 变换矩阵设置。</p>
<p>Demo：<br>效果预览地址：<a href=""http://daniel-lundin.github.io/snabbt.js/periodic.html"" rel=""nofollow noreferrer"">http://daniel-lundin.github.i...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-08%2023.14.26.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>imagesLoaded – 检测网页中的图片是否加载完成</h2>
<p>github：<a href=""https://github.com/desandro/imagesloaded"" rel=""nofollow noreferrer"">https://github.com/desandro/i...</a></p>
<p>官方网站：<a href=""http://imagesloaded.desandro.com/"" rel=""nofollow noreferrer"">http://imagesloaded.desandro....</a></p>
<p>star：6k+</p>
<p>Install：</p>
<pre><code>Bower: bower install imagesloaded --save
npm: npm install imagesloaded
CDNs:
&lt;script src=""https://unpkg.com/imagesloaded@4.1/imagesloaded.pkgd.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://unpkg.com/imagesloaded@4.1/imagesloaded.pkgd.js""&gt;&lt;/script&gt;</code></pre>
<p>大小：5 KB</p>
<p>功能介绍：<br>　imagesLoaded 是一个用于来检测网页中的图片是否载入完成的 JavaScript 工具库。支持回调的获取图片加载的进度，还可以绑定自定义事件。可以结合 jQuery、RequireJS 使用。</p>
<p>Demo：<br>效果预览地址：<a href=""http://codepen.io/desandro/full/hlzaw/"" rel=""nofollow noreferrer"">http://codepen.io/desandro/fu...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2003.12.46.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Fort.js – 时尚、现代的表单填写进度提示效果</h2>
<p>github：<a href=""https://github.com/idriskhenchil/Fort.js"" rel=""nofollow noreferrer"">https://github.com/idriskhenc...</a></p>
<p>官方网站：<a href=""https://github.com/idriskhenchil/Fort.js"" rel=""nofollow noreferrer"">https://github.com/idriskhenc...</a></p>
<p>star：800+</p>
<p>Install：</p>
<pre><code>CDN:
css:
https://cdnjs.cloudflare.com/ajax/libs/Fort.js/2.0.0/fort.min.css
js:
https://cdnjs.cloudflare.com/ajax/libs/Fort.js/2.0.0/fort.min.js</code></pre>
<p>大小：6 KB</p>
<p>功能介绍：<br>　　Fort.js 是一款用于时尚、现代的表单填写进度提示效果的 JavaScript 库，你需要做的就是添加表单，剩下的任务就交给 Fort.js 算法了，使用非常简单。提供了Default、Gradient、Sections 以及 Flash 四种效果，满足开发的各种场合需要。</p>
<p>Demo：<br>效果预览地址：<a href=""http://idriskhenchil.github.io/default/index.html"" rel=""nofollow noreferrer"">http://idriskhenchil.github.i...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2000.06.51.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>MagicSuggest – Bootstrap 主题的多选组合框</h2>
<p>github：<a href=""https://github.com/nicolasbize/magicsuggest"" rel=""nofollow noreferrer"">https://github.com/nicolasbiz...</a></p>
<p>官方网站：<a href=""http://nicolasbize.com/magicsuggest/"" rel=""nofollow noreferrer"">http://nicolasbize.com/magics...</a></p>
<p>star：1k+</p>
<p>Install：</p>
<pre><code>github自行进行下载</code></pre>
<p>大小：21.8 KB</p>
<p>功能介绍：<br>　　MagicSuggest 是专为 Bootstrap 主题开发的多选组合框。它支持自定义呈现，数据通过 Ajax 异步获取，使用组件自动过滤。它允许空间免费项目，也有动态加载固定的建议。</p>
<p>Demo：<br>效果预览地址：<a href=""http://nicolasbize.com/magicsuggest/examples.html"" rel=""nofollow noreferrer"">http://nicolasbize.com/magics...</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2000.16.44.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Numeral.js – 格式化和操作数字的 JavaScript 库</h2>
<p>github：<a href=""https://github.com/adamwdraper/Numeral-js"" rel=""nofollow noreferrer"">https://github.com/adamwdrape...</a></p>
<p>官方网站：<a href=""http://numeraljs.com/"" rel=""nofollow noreferrer"">http://numeraljs.com/</a></p>
<p>star：4k+</p>
<p>Install：</p>
<pre><code>npm: npm install numeral
CDNs:
&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js""&gt;&lt;/script&gt;</code></pre>
<p>大小：10 KB</p>
<p>功能介绍：<br>　　　Numeral.js 是一个用于格式化和操作数字的 JavaScript 库。数字可以格式化为货币，百分比，时间，甚至是小数，千位，和缩写格式，功能十分强大。支持包括中文在内的17种语言。</p>
<p>Demo：</p>
<pre><code class=""JavaScript"">var myNumeral = numeral(1000);

var value = myNumeral.value();
// 1000

var myNumeral2 = numeral('1,000');

var value2 = myNumeral2.value();
// 1000</code></pre>
<p>   </p>
<h2>Draggabilly – 轻松实现拖放功能（Drag &amp; Drop）</h2>
<p>github：<a href=""https://github.com/desandro/draggabilly"" rel=""nofollow noreferrer"">https://github.com/desandro/d...</a></p>
<p>官方网站：<a href=""http://draggabilly.desandro.com/"" rel=""nofollow noreferrer"">http://draggabilly.desandro.com/</a></p>
<p>star：2k+</p>
<p>Install：</p>
<pre><code>Bower: bower install draggabilly --save
npm: npm install draggabilly
CDNs:
&lt;script src=""https://npmcdn.com/draggabilly@2.1/dist/draggabilly.pkgd.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://npmcdn.com/draggabilly@2.1/dist/draggabilly.pkgd.js""&gt;&lt;/script&gt;</code></pre>
<p>大小：5 KB</p>
<p>功能介绍：<br>　Draggabilly 是一个很小的 JavaScript 库，专注于拖放功能。只需要简单的设置参数就可以在你的网站用添加拖放功能。兼容 IE8+ 浏览器，支持多点触摸。可以灵活绑定事件，支持 RequireJS 以及 Bower 安装。</p>
<p>Demo：<br>效果预览地址：<a href=""http://draggabilly.desandro.com/"" rel=""nofollow noreferrer"">http://draggabilly.desandro.com/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2000.43.20.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>Quill – 可以灵活自定义的开源的富文本编辑器</h2>
<p>github：<a href=""https://github.com/quilljs/quill/"" rel=""nofollow noreferrer"">https://github.com/quilljs/qu...</a></p>
<p>官方网站：<a href=""https://quilljs.com"" rel=""nofollow noreferrer"">https://quilljs.com</a></p>
<p>star：12k+</p>
<p>Install：</p>
<pre><code>npm: npm install quill
CDNs:
&lt;!-- Main Quill library --&gt;
&lt;script src=""//cdn.quilljs.com/1.0.0/quill.js"" type=""text/javascript""&gt;&lt;/script&gt;
&lt;script src=""//cdn.quilljs.com/1.0.0/quill.min.js"" type=""text/javascript""&gt;&lt;/script&gt;

&lt;!-- Theme included stylesheets --&gt;
&lt;link href=""//cdn.quilljs.com/1.0.0/quill.snow.css"" rel=""stylesheet""&gt;
&lt;link href=""//cdn.quilljs.com/1.0.0/quill.bubble.css"" rel=""stylesheet""&gt;

&lt;!-- Core build with no theme, formatting, non-essential modules --&gt;
&lt;link href=""//cdn.quilljs.com/1.0.0/quill.core.css"" rel=""stylesheet""&gt;
&lt;script src=""//cdn.quilljs.com/1.0.0/quill.core.js"" type=""text/javascript""&gt;&lt;/script&gt;</code></pre>
<p>大小：需求不同，大小不同</p>
<p>功能介绍：<br>　　Quill 的建立是为了解决现有的所见即所得（WYSIWYG）的编辑器本身就是所见即所得（指不能再扩张）的问题。如果编辑器不正是你想要的方式，这是很难或不可能对其进行自定义以满足您的需求。</p>
<p>　　Quill 旨在通过把自身组织成模块，并提供了强大的 API 来构建额外的模块来解决这个问题。它也并没有规定你用样式来定义编辑器皮肤。Quill 还提供了所有你希望富文本编辑器说用于的功能，包括轻量级封装，众多的格式化选项，以及广泛的跨平台支持。</p>
<p>Demo：<br>效果预览地址：<a href=""https://quilljs.com/"" rel=""nofollow noreferrer"">https://quilljs.com/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2000.57.07.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>basket.js – 基于 LocalStorage 的资源加载器</h2>
<p>github：<a href=""https://github.com/addyosmani/basket.js"" rel=""nofollow noreferrer"">https://github.com/addyosmani...</a></p>
<p>官方网站：<a href=""https://addyosmani.com/basket.js/"" rel=""nofollow noreferrer"">https://addyosmani.com/basket...</a></p>
<p>star：2k+</p>
<p>Install：</p>
<pre><code>Bower: bower install basket.js --save
npm: npm install basket.js</code></pre>
<p>大小：4 KB</p>
<p>功能介绍：<br>　basket.js是一款基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存。<br>　<br>Demo：<br>效果预览地址：<a href=""https://addyosmani.com/basket.js/"" rel=""nofollow noreferrer"">https://addyosmani.com/basket...</a><br>更多示例请查看官方文档</p>
<p>   </p>
<h2>scrollReveal.js – 使元素以非常酷帅的方式进入画布 (Viewpoint)</h2>
<p>github：<a href=""https://github.com/jlmakes/scrollreveal"" rel=""nofollow noreferrer"">https://github.com/jlmakes/sc...</a></p>
<p>官方网站：<a href=""https://scrollrevealjs.org/"" rel=""nofollow noreferrer"">https://scrollrevealjs.org/</a></p>
<p>star：12k+</p>
<p>Install：</p>
<pre><code>Bower: bower install scrollreveal --save
npm: npm install scrollreveal
CDNs:
&lt;script src=""https://unpkg.com/scrollreveal/dist/scrollreveal.min.js""&gt;&lt;/script&gt;</code></pre>
<p>大小：8 KB</p>
<p>功能介绍：<br>　scrollReveal.js 是一个用于使元素以非常酷帅的方式进入画布的 JavaScript 工具库。轻量级，高性能，无依赖的一个小巧酷炫的库。<br>　<br>Demo：<br>效果预览地址：<a href=""https://scrollrevealjs.org/"" rel=""nofollow noreferrer"">https://scrollrevealjs.org/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2003.17.49.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>moment.js – 一款轻量级的Javascript日期处理类库</h2>
<p>github：<a href=""https://github.com/moment/moment/"" rel=""nofollow noreferrer"">https://github.com/moment/mom...</a></p>
<p>官方网站：<a href=""http://momentjs.com/"" rel=""nofollow noreferrer"">http://momentjs.com/</a></p>
<p>star：30k+</p>
<p>Install：</p>
<pre><code>bower install moment --save # bower
npm install moment --save   # npm
yarn add moment             # Yarn
Install-Package Moment.js   # NuGet
spm install moment --save   # spm
meteor add momentjs:moment  # meteor</code></pre>
<p>大小：16.6 KB</p>
<p>功能介绍：<br>　 moment.js是一个轻量级的JavaScript库日期解析、验证操作,格式化日期的库。</p>
<p>Demo：<br>效果预览地址：<a href=""http://momentjs.com/"" rel=""nofollow noreferrer"">http://momentjs.com/</a></p>
<p>Demo效果预览：<br>这是一个GIF动图，不信，你看第一行的日期，时间在走?。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2002.54.29.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>infinite-scroll – 一款滚动加载按需加载的轻量级插件</h2>
<p>github：<a href=""https://github.com/infinite-scroll/infinite-scroll"" rel=""nofollow noreferrer"">https://github.com/infinite-s...</a></p>
<p>官方网站：<a href=""http://www.infinite-scroll.com/"" rel=""nofollow noreferrer"">http://www.infinite-scroll.com/</a></p>
<p>star：4k+</p>
<p>Install：</p>
<pre><code>github自行下载</code></pre>
<p>大小：20 KB</p>
<p>功能介绍：<br>　infinite-scroll是一款滚动加载，滚动到最下到自动加载的轻量级JavaScript插件，简单实用，按需加载提高用户体验，非常适合移动端使用，配合上面的图片懒加载如虎添翼。</p>
<p>Demo：<br>效果预览地址：<a href=""http://www.dazeddigital.com/"" rel=""nofollow noreferrer"">http://www.dazeddigital.com/</a></p>
<p>Demo效果预览：<br>图片有点大，稍等片刻。建议上面Demo效果预览地址进行预览。</p>
<p><span class=""img-wrap""><img data-src=""http://oo2r9rnzp.bkt.clouddn.com/2017-04-09%2003.15.47.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>   </p>
<h2>欢迎大家按照格式补充，持续更新，有什么好用的轮子赶紧滚起来吧！</h2>
<p>推荐有福利，送1024论坛邀请码，嘿嘿嘿。</p>
<p><span class=""img-wrap""><img data-src=""http://i61.tinypic.com/2vccd1c.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""http://i62.tinypic.com/15grr52.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 工作中经常用到github上优秀、实用、轻量级、无依赖的插件和库,1531977863,348,1,188,1,1,https://segmentfault.com/a/1190000008997798
142,1,0,7,"
                    
<p>Git 非常复杂。我即使几乎每天都在用，也不敢保证对 Git 的每一个角落都了如指掌。<br>本文试图盘点一些不知名，但在我看来较常用的操作。如果没有你预期的操作，说明要么在我看来它很知名，要么在我看来它不太常用。</p>
<ul>
<li><p><code>git log --graph --abbrev-commit --decorate --all --oneline</code></p></li>
<li><p><code>git cherry</code></p></li>
<li><p><code>git show ref:path</code></p></li>
<li><p><code>git reset [--hard|--soft|--keep]</code></p></li>
<li><p><code>git update-index --assume-unchanged</code></p></li>
</ul>
<h3>git log --graph --abbrev-commit --decorate --all --oneline</h3>
<p>如果要看项目中的分支情况，通常的做法是打开一个 Git GUI 软件，通过 GUI 界面来查看全景。<br>对于有些人来说，这是装 GUI 的唯一需求。<br>其实这个需求可以砍掉，因为 Git 提供了在终端中输出提交记录全景的操作：</p>
<pre><code>git log --graph --abbrev-commit --decorate --all --oneline</code></pre>
<p>输出结果相当惊艳，你可以像看 GUI 界面一样，在终端中查看不同分支的提交信息。<br><span class=""img-wrap""><img data-src=""/img/bVLt6o?w=727&amp;h=725"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git-log.png"" title=""git-log.png""></span><br>（这里采用了一个开源项目的提交历史来示例，如果是公司的商业项目，输出会更炫目）</p>
<p>这个输出跟 <code>man xxx</code> 一样，会通过 $PAGER（通常是 less） 显示在终端上。这意味着你可以在输出中搜索特定的提交或 tag。<br>许多 GUI 界面并不提供这一功能，导致用户只能瞪大眼睛，一点点地挪动，才能揪出特定的提交。<br>就这一点上，终端版的功能要比 GUI 版本胜出许多。<br>终端版的另一个优点是，提供了自由组合各种选项的能力。你可以自定义输出信息和显示的提交范围。<br>如果嫌命令太长，可以给它一个 alias（通过 git alias 或 shell 的 alias 功能）。</p>
<h3>git cherry</h3>
<p>有一个常用的 Git 操作是 <code>git cherry-pick</code>。<code>git cherry</code> 顾名思义，自然跟 <code>cherry-pick</code> 有关。<br><code>git cherry</code> 可以比较两个分支，筛选出存在于甲分支却不存在于乙分支的提交。显而易见，这是在为后面的 <code>cherry-pick</code> 做准备。</p>
<pre><code> ￥ git cherry 4.2.0 | tail
+ bb5f4b02340b3c269d7a8e11842d4a16b2b8eba1
+ 2451c0c202dd48bc610ef9731c503ea54f19af83
+ 64b4a599e8af4b31444f2a86559d4860401925f4
+ c80b4e773f746ffe11aca9010b4433f6b6ba13ad
+ b2c7de9a5a5c8ea0254001a07ae24ffc27118dbb
+ 719dd2c3af9ba801114101ccdec1cd9e2f1bbc5d
+ 518db6e648aaf646db4be3067a583bdcc37ee2a8
+ b01359efc5761a17cd3b893fd51219a005009641
+ 422c9a8e69acc5cf013340715f8d2fa7d7cabf75
+ cc0dff2f49cfbd786eca498fe2532de0455e1759</code></pre>
<p>美中不足的是，<code>git cherry</code> 的输出是 sha1，对机器来说友好，对人来说就是天书。如果要看具体的提交信息，需要借其他命令之力。比如 <code>git show</code>：</p>
<pre><code>git show --no-patch --format='%s' cc0dff2f49cfbd786eca498fe2532de0455e1759</code></pre>
<h3>git show ref:path</h3>
<p><code>git show</code> 是我最喜欢的命令之一。输出提交的内容，是 <code>git show</code> 的拿手好戏之一。举个例子，<code>git show @</code> 可以显示当前分支上最新提交。（<code>@</code> 是 <code>HEAD</code><br>的别名，能少敲三个字符呢）</p>
<p>不过这不算 <code>git show</code> 的杀手锏。<code>git show</code> 的绝活，是能在不检出特定提交的前提下，显示特定提交的某个文件的内容。<br>假设我们想看看 xxx 提交上的 <code>db.lua</code>，纯粹只想看一看，不涉及调试或其他复杂的操作。我们当然可以 <code>git checkout xxx</code>，然后想看啥就看啥。然而用 <code>git show</code> 的话，就能保持当前分支不变，直接显示 xxx 提交上的 <code>db.lua</code> 了：</p>
<pre><code>git show xxx:path/to/db.lua</code></pre>
<p>编辑器的 Git 插件一般支持在编辑器内直接打开 <code>git show</code> 的输出。如果你用的是 Vim，又装了 <a href=""https://github.com/tpope/vim-fugitive"" rel=""nofollow noreferrer"">fugitive</a>，<br>通过敲 <code>:Gedit revision:%</code>，可以打开当前文件的特定版本。<br>如果想找到哪几个提交修改了特定文件，可以先用 <code>git log --format='%s' -- /path/to/your/file</code> 获取涉及的提交。</p>
<h3>git reset [--hard|--soft|--keep]</h3>
<p><code>git reset</code> 可不能算是“不知名”操作。任何 Git 入门教程，都会提到怎么用 <code>git reset</code> 把文件移出暂存区。但在本人的日常开发流程中，移出暂存区其实是最少用上的<br><code>git reset</code> 操作。所以我觉得可以打个擦边球，讲讲 <code>git reset</code> 其他的打开方式。</p>
<p>移出暂存区的 <code>git reset</code> 操作，相当于 <code>git reset --mixed</code>。除了 <code>--mixed</code>，常用的选项还有下面三个：</p>
<ul>
<li><p><code>--soft</code></p></li>
<li><p><code>--hard</code></p></li>
<li><p><code>--keep</code></p></li>
</ul>
<p>开发中常有的情况：劈劈啪啪写了一堆代码，连续好几个提交。然后脑子里灵机一动，顿悟了更好的做法。这个做法是如此地好，以致于之前的提交记录都成了你的黑历史。你恨不得<br>把这些提交记录一笔勾销，但该怎么办呢？这时候就轮到 <code>reset --soft</code> 上场了。<br><code>reset --soft</code> 俗称 <code>squash</code>，可以在保留修改的同时，把最近的几个提交历史给抹掉。比如 <code>git reset --soft @~3</code> 就能重置到倒数第四个提交，但保留被抹掉的三个提交的更改。<br>这么操作之后再提交一次，然后选一个夜深人静的时刻，<code>push -f</code> 到远程仓库，你的黑历史就烟消云散了。当然还是会留下些痕迹什么的，但至少别人一般发现不了……</p>
<p>跟 <code>--soft</code> 对应的是 <code>--hard</code>。<code>--hard</code> 也会抹掉最近的几个提交，但不保留修改。如果感到自己的代码实在没法看，可以直接 <code>reset --hard</code> 试试。不过 <code>reset --hard</code> 倒不失清理环境的好方法。</p>
<p><code>--keep</code> 正好在 <code>--soft</code> 和 <code>--hard</code> 之间。<code>--keep</code> 会保留未提交的更改，这一点跟 <code>--soft</code> 一样；同时会抹掉已经提交的更改，这一点跟 <code>--hard</code> 相同。<br>有些时候，这一特性会派上用场。</p>
<p>如果你在开发的时候，突然发现自己忘记切分支了，可以这么做：</p>
<pre><code>git branch feature/you_need
git reset --keep comit_your_hack_starts_from
git checkout feature/you_need</code></pre>
<p>这样做既消除了错误分支上的提交，又保留了工作区里未提交的内容。</p>
<p>提到 <code>reset</code>，不能不提误操作时的补救办法。</p>
<ol>
<li><p>被抹掉的内容已经提交了。这种情况好办。通过 <code>git reflog</code>，我们可以找到被抹掉的提交，然后 <code>cherry-pick</code>回来，抑或 <code>reset --hard HEAD{x}</code> 到对应的提交上去。</p></li>
<li><p>被抹掉的内容原来在暂存区里。这个比较蛋疼。你需要 <code>git fsck | grep blob</code> 拣出每一个 dangling blob，逐个 <code>git show xxx</code> 看看，应该能找回被抹掉的内容。这种感觉，就像在垃圾桶里翻出丢失的手稿一样。</p></li>
<li><p>被抹掉的内容不在暂存区里。靠 Git 已经救不回来了。要不找下编辑器的备份文件，要不尝试能不能从文件系统缓存里把文件抠出来。如果不行，试试磁盘数据恢复程序……</p></li>
</ol>
<p>说这么多，关键记住一点：reset 有风险，用时需谨慎。</p>
<h3>git update-index --assume-unchanged</h3>
<p>假设代码仓库里存在这么一个配置文件：每个人在开发时，会根据本地情况修改里面的值。比如某些 IDE 的项目描述文件，里面可能夹杂着项目的路径。<br>有什么办法，可以避免本地的修改不会提交到仓库里去呢？<br>个人认为 <code>git update-index --assume-unchanged</code> 是众多解决方法中最好的。<br><code>git update-index</code> 可以修改 Git 对特定路径下的文件的处理方式。其中 <code>--assume-unchanged</code> 选项告诉 Git，指定路径下的文件不会有修改。<br>即使在本地修改了那些文件，也不会被 Git 记录在案。<br>如果我有一天需要修改这个配置文件并入库，可以用 <code>--no-assume-unchanged</code> 选项解开封印，让 Git 重新追踪修改。</p>
<pre><code> ￥ gs
On branch master
Changes not staged for commit:
  (use ""git add &lt;file&gt;..."" to update what will be committed)
  (use ""git checkout -- &lt;file&gt;..."" to discard changes in working directory)

    modified:   check_integrity.sh

no changes added to commit (use ""git add"" and/or ""git commit -a"")
 ￥ git update-index --assume-unchanged check_integrity.sh
 ￥ gs
On branch master
nothing to commit, working tree clean
 ￥ git update-index --no-assume-unchanged check_integrity.sh
 ￥ gs
On branch master
Changes not staged for commit:
  (use ""git add &lt;file&gt;..."" to update what will be committed)
  (use ""git checkout -- &lt;file&gt;..."" to discard changes in working directory)

    modified:   check_integrity.sh</code></pre>

                ", 盘点那些不知名却常用的 Git 操作,1531977865,478,1,249,1,1,https://segmentfault.com/a/1190000008894790
143,1,0,7,"
                    
<h2>快捷键</h2>
<ul><li><p><code>r</code>快速引用 <br>你可以选中别人的评论文字，然后按r，这些内容会以引用的形式被复制在文本框中：</p></li></ul>
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9bw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<ul>
<li><p>t：搜索文件</p></li>
<li><p>s：光标定位到搜索窗口</p></li>
<li><p>w：选择分支</p></li>
<li><p><code>g n</code>    Go to Notifications</p></li>
<li><p><code>g d</code>    Go to Dashboard</p></li>
<li><p><code>g c</code>    Go to Code</p></li>
<li><p><code>g i</code>    Go to Issues</p></li>
<li><p><code>g p</code>    Go to Pull Requests</p></li>
<li><p><code>g w</code>    Go to Wiki</p></li>
<li><p>?：<br>如果要查看所有的快捷键，可以在键盘上按下 ?</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008867341?w=600&amp;h=524"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>watch vs Star vs Fork</h2>
<h3>watch</h3>
<p>watch翻译过来可以称之为观察，点击watch可以看到如下的列表。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009079951"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>默认每一个用户都是处于Not watching的状态，当你选择Watching，表示你以后会关注这个项目的所有动态，以后只要这个项目发生变动，如被别人提交了pull request、被别人发起了issue或者issue里面有新的讨论等等情况，</p>
<p>你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。</p>
<p>所以，watch要谨慎使用，不然你的邮箱会被垃圾邮件占满。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009079952"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>如果你不想接受这些通知，那么点击 Not Watching 即可。</p>
<p>另外这里有一篇文章讲 <a href=""https://github.com/cssmagic/blog/issues/49"" rel=""nofollow noreferrer"">如何正确接收 GitHub 的消息邮件</a>，很不错的一篇文章，推荐大家看看。</p>
<h3>star</h3>
<p>star 翻译过来应该是星星，但是这个翻译没任何具体意义，这里解释为<code>关注</code>或者<code>点赞</code>更合适，当你点击 star,表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持。</p>
<p>不过相比朋友圈的点赞，github 里面会有一个列表，专门收集了你所有 star 过的项目，</p>
<p>点击 github 个人头像，可以看到 your star的条目，点击就可以查看你 star 过的所有项目了。如下图</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009079953"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>不过，在你的 star 列表很容易出现这样的问题。就是你可能 star 成百上千个项目怎么办。</p>
<p>这时，如果 github 可以提供一个分类功能该多好，就像微博网页版的收藏，你在收藏的时候可以设置 tag，</p>
<p>这样设置的好处是，以后再次查找项目时，可以根据归类查找，但是不知道 github 的产品经理是怎么想的，</p>
<h3>fork</h3>
<p>当选择 fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。</p>
<p>一般来说，我们不需要使用 fork 这个功能，至少我一般不会用，除非有一些项目，可能存在 bug 或者可以继续优化的地方，你想帮助原项目作者去完善这个项目</p>
<p>，那么你可以 fork 一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起 pull request给原项目作者了，</p>
<p>然后就静静等待他的 merge。</p>
<p>我看到很多人错误的在使用 fork。很多人把 fork 当成了收藏一样的功能，包括一开始使用 github 的我，每次看到一个好的项目就先 fork，</p>
<p>因为这样，就可以我的 repository(仓库)列表下查看 fork 的项目了。其实你完全可以使用 star 来达到这个目的。</p>
<h2>搜索</h2>
<h3>指定搜索范围</h3>
<ul>
<li><p><code>octocat in:file</code> 搜索文件中有octocat的代码</p></li>
<li><p><code>octocat in:path</code> 搜索路径中有octocat的代码</p></li>
<li><p><code>octocat in:file,path</code> 搜索路径中有octocat的代码或者文件中有octocat的代码</p></li>
<li><p><code>display language:sass</code> 搜索用scss写的包含display的代码</p></li>
<li><p><code>Integer</code> 搜索包含Integer的字段 搜索mozilla用户下用markdown写的代码</p></li>
</ul>
<h3>通过语言搜索代码</h3>
<ul>
<li><p><code>element language:xml size:100</code> 搜索大小为100字节的xml代码</p></li>
<li><p><code>user:mozilla language:markdown</code> 搜索mozilla用户下用markdown写的代码</p></li>
</ul>
<h3>通过fork的数量或者是否有父节点的方式搜索</h3>
<ul>
<li><p><code>android language:java fork:true</code> 搜索用java写的 android相关的代码并且被fork过</p></li>
<li><p><code>function size:&gt;10000 language:python</code> 搜索与function相关的python代码，文件大小超过10kb</p></li>
</ul>
<h3>按照目录结构搜索</h3>
<ul>
<li><p><code>console path:app/public language:javascript</code> 在app/public directory目录下搜索console关键字</p></li>
<li><p><code>form path:cgi-bin language:perl</code> 搜索cgi-bin目录下包含form的perl代码</p></li>
</ul>
<h3>通过文件名搜索</h3>
<ul>
<li><p><code>filename:.vimrc commands</code> 搜索 文件名匹配<em>.vimrc</em> 并且包含commands的代码</p></li>
<li><p><code>minitest filename:test_helper path:test language:ruby</code> 在test目录中搜索包含minitest且文件名匹配""<em>test_helper</em>""的ruby代码</p></li>
</ul>
<h3>根据扩展名来搜索代码</h3>
<ul>
<li><p><code>form path:cgi-bin extension:pm</code> 搜索cgi-bin目录下以pm为扩展名的代码</p></li>
<li><p><code>icon size:&gt;200000 extension:css</code> 搜索超过200kb包含icon的css代码</p></li>
</ul>
<h3>通过用户或者组织来查找</h3>
<ul>
<li><p><code>user:github extension:rb</code> 查找github用户中以rb为扩展的代码</p></li>
<li><p><code>repo:mozilla/shumway extension:as</code>搜索mozilla的shumway以as为扩展的代码</p></li>
</ul>
<h3>根据star数搜索</h3>
<ul><li><p><code>react starts:&gt;300</code>搜索react相关的，且star数量大于300的项目</p></li></ul>
<p>搜索结果可以根据需要排序网站上提供了排序的选项，更多搜索需求可以选择高级搜索。</p>
<h2>发现优秀项目</h2>
<h3>关注大牛</h3>
<p>GitHub 主页有一个类似微博的时间线功能，所有你关注的人的动作，比如 star、fork 了某个项目都会出现在你的时间线上，这种方式适合我这种比较懒的人，不用主动去找项目，而这种基本是我每天获取信息的一个很重要的方式。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008867342?w=1244&amp;h=1236"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>Trending</h3>
<p>点击下图的 Explore 菜单到“发现”页面,</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008867343?w=1246&amp;h=732"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>这个 Trending 页面是干嘛的呢？直译过来就是趋势的意思，就是说这个页面你可以看到最近一些热门的开源项目，这个页面可以算是很多人主动获取一些开源项目最好的途径，可以选择「当天热门」、「一周之内热门」和「一月之内热门」来查看，并且还可以分语言类来查看。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008867344?w=2094&amp;h=874"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3><a href=""https://github.com/sindresorhus/awesome"" rel=""nofollow noreferrer"">awesome</a></h3>
<p>GitHub 上有各种 awesome 系列，简单来说就是这个系列搜罗整理了 GitHub 上各领域的资源大汇总，比如有 awesome-android, awesome-ios, awesome-java, awesome-python 等等等，就不截图了，你们自行去感受。</p>
<h3>Trending repositories on GitHub today</h3>
<p>浩如烟海的库中，如何知道哪些语言有哪些优秀的库，有哪些优秀的开发者，github官方贴心出品，这里<a href=""https://link.zhihu.com/?target=https%3A//github.com/trending"" rel=""nofollow noreferrer"">Trending repositories on GitHub today · GitHub</a> 并且一天固定时间更新一波，<br><span class=""img-wrap""><img data-src=""/img/remote/1460000009079954?w=600&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>url后缀</h2>
<h3>不比较空白字符</h3>
<p>在任意 diff 页面的 UR L后加上 <code>?w=1</code>，可以去掉那些只是空白字符的改动，使你能更专注于代码改动。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763287"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Diff without whitespace"" title=""Diff without whitespace""></span></p>
<p><a href=""https://github.com/blog/967-github-secrets"" rel=""nofollow noreferrer""><em>详见 GitHub secrets.</em></a></p>
<h3>调整 Tab 字符所代表的空格数</h3>
<p>在 diff 或文件的 URL 后面加上 <code>?ts=4</code> ，这样当显示 tab 字符的长度时就会是 4 个空格的长度，不再是默认的 8 个空格。 <code>ts</code> 后面的数字还可以根据你个人的偏好进行修改。这个技巧不适用于 Gists，或者以 Raw 格式查看文件， 但有浏览器扩展插件可以帮你自动调整: <a href=""https://chrome.google.com/webstore/detail/github-tab-size/ofjbgncegkdemndciafljngjbdpfmbkn"" rel=""nofollow noreferrer"">Chrome 扩展</a> ， <a href=""https://addons.opera.com/en/extensions/details/github-tab-size/"" rel=""nofollow noreferrer"">Opera 扩展</a>。</p>
<p>下面以一个 Go 语言源文件为例，看看在 URL 里添加 <code>?ts=4</code> 参数的效果。添加前：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763288?w=933&amp;h=248"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Before, tab space example"" title=""Before, tab space example""></span></p>
<p>... 添加后的样子：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763289?w=935&amp;h=236"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""After, tab space example"" title=""After, tab space example""></span></p>
<h3>查看用户的全部 Commit 历史</h3>
<p>在 Commits 页面 URL 后加上 <code>?author={user}</code> 查看用户全部的提交。</p>
<pre><code>https://github.com/rails/rails/commits/master?author=dhh</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008861047?w=938&amp;h=415"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""DHH commit history"" title=""DHH commit history""></span></p>
<p><a href=""https://help.github.com/articles/differences-between-commit-views"" rel=""nofollow noreferrer""><em>深入了解提交视图之间的区别</em></a></p>
<h3>仓库克隆</h3>
<p>当克隆仓库时可以不要那个<code>.git</code>后缀。</p>
<pre><code class=""bash"">$ git clone https://github.com/tiimgreen/github-cheat-sheet</code></pre>
<p><a href=""http://git-scm.com/docs/git-clone"" rel=""nofollow noreferrer""><em>更多对 Git <code>clone</code> 命令的介绍.</em></a></p>
<h3>分支</h3>
<h4>将某个分支与其他所有分支进行对比</h4>
<p>当你查看某个仓库的分支（Branches）页面（紧挨着 Commits 链接）时</p>
<pre><code>https://github.com/{user}/{repo}/branches</code></pre>
<p>你会看到一个包含所有未合并的分支的列表。</p>
<p>在这里你可以访问分支比较页面或删除某个分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008861048?w=999&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Compare branches not merged into master in rails/rails repo - https://github.com/rails/rails/branches"" title=""Compare branches not merged into master in rails/rails repo - https://github.com/rails/rails/branches""></span></p>
<h4>比较分支</h4>
<p>如果要在 GitHub 上直接比较两个分支，可以使用如下形式的 URL ：</p>
<pre><code>https://github.com/{user}/{repo}/compare/{range}</code></pre>
<p>其中 <code>{range} = master...4-1-stable</code></p>
<p>例如：</p>
<pre><code>https://github.com/rails/rails/compare/master...4-1-stable</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008861049?w=931&amp;h=463"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Rails branch compare example"" title=""Rails branch compare example""></span></p>
<p><code>{range}</code> 参数还可以使用下面的形式:</p>
<pre><code>https://github.com/rails/rails/compare/master@{1.day.ago}...master
https://github.com/rails/rails/compare/master@{2014-10-04}...master</code></pre>
<p><em>日期格式 <code>YYYY-MM-DD</code></em></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763295?w=943&amp;h=423"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Another compare example"" title=""Another compare example""></span></p>
<p>在 <code>diff</code> 和 <code>patch</code> 页面里也可以比较分支：</p>
<pre><code>https://github.com/rails/rails/compare/master...4-1-stable.diff
https://github.com/rails/rails/compare/master...4-1-stable.patch</code></pre>
<p><a href=""https://help.github.com/articles/comparing-commits-across-time"" rel=""nofollow noreferrer""><em>了解更多关于基于时间的 Commit 比较.</em></a></p>
<h2>参考文章</h2>
<p><a href=""https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md"" rel=""nofollow noreferrer"">GitHub秘籍 </a><br><a href=""http://robbiefeng.iteye.com/blog/2169967"" rel=""nofollow noreferrer"">github代码搜索技巧</a></p>

                ", 你真的会使用Github吗？,1531977866,250,1,646,1,1,https://segmentfault.com/a/1190000008867338
144,1,0,7,"
                    
<h3>写在前面</h3>
<p>在我第一次接触编程的时候，学的是Pascal，在那个叫做Turbo的蓝屏编辑器里写下一些简单的流程控制去解一些简单的算法题。那时候，天还很蓝，我的代码还保存在自己电脑的文件夹里。  <br>上了大学以后知道了github这个东西（aka: <strong>gayhub</strong>），而后又去了解了git的概念，也从字面上明白了对于一个项目的开发人员而言，版本控制是一件很重要的事情。  <br>当有了项目经验以后，不再是自己一个人coding了，由于责任的划分、产品的迭代等方面都出现过一些小范围内毁灭性的“失误”，所以终于深刻意识到了<strong>版本控制是一件重要的事情</strong>。  <br>目前最流行的版本控制工具有两种：<code>svn</code>和<code>git</code>。  <br>因为一些开源社区和自身特点的原因，<code>git</code>似乎更受广大开发者的青睐。  <br><em>（本文所介绍的工作流是借鉴livoras大神的相关<a href=""https://github.com/livoras/blog/issues/7"" rel=""nofollow noreferrer"">issue</a>）</em></p>
<h3>什么是<code>git</code>？</h3>
<p>关于<code>git</code>的概念，大概分为以下三点：</p>
<ol>
<li><p>打开浏览器</p></li>
<li><p>在地址栏输入“baidu.com”</p></li>
<li><p>搜索：“什么是<code>git</code>”</p></li>
</ol>
<h3>一些概念的正确打开方式</h3>
<h4>仓库</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008657140?w=762&amp;h=559"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github的仓库"" title=""github的仓库""></span><br>就像图中所示，仓库有两大类：源仓库（最中间的）和开发者仓库（四周的）。  <br><strong>源仓库</strong>就是项目发起人所建立的仓库，其他开发者只能基于这个仓库对项目进行开发。  <br><strong>开发者仓库</strong>则是众多开发者们从项目发起这那里<code>fork</code>来的，可以在自己的主页看到这个“转发”来的仓库，相应的，开发者的<code>commit</code>和<code>push</code>操作都是基于这个克隆体来进行的。</p>
<h4>分支</h4>
<p>分支在<code>git</code>中是一个很重要的概念（当然了，<code>svn</code>中也有）。  <br>在<code>git</code>中，分支主要分为两种：永久性分支和临时性分支。</p>
<h5>永久性分支</h5>
<p>一般情况下就是指<code>master</code>和<code>develop</code>这两个分支，前者用于保存产品每个版本的代码，通常由<code>develop</code>分支合并而来；后者则是开发者的主要战场。</p>
<h5>临时性分支</h5>
<p>根据不同的用途，可将临时性分支分为以下三种：</p>
<ul>
<li><p>功能分支</p></li>
<li><p>预发布分支</p></li>
<li><p>bug修复分支</p></li>
</ul>
<p>我喜欢把临时性分支成为<strong>备胎分支</strong>，因为她们的设定非常符合<strong>用完即走</strong>的产品理念（备胎们哭晕在仓库）。  <br>可能你会有点不理解为什么这些分支的命运如此悲凉，那我来<strong>举个栗子</strong>  <br>有一天，产品要求小明给主页增加一个点赞的功能，说时迟那时快，小明撸起袖子就是干</p>
<pre><code class=""bash"">$ git checkout -b feature-thumbsUp
//新建一个功能分支

$ vi thumbsUp.js
//进行开发

$ git add thumbsUp.js
$ git commit -m 'add feature-thumbsUp'
//将当前分支的的修改保存到本地

$ git checkout develop
$ git merge --no-ff feature-thumbsUp
$ git branch -d feature-thumbsUp
//切换到develop分支并且合并刚才功能分支的修改
//并且删除那个功能分支（虐不虐！你就说虐不虐！用完即走啊！）

$ git push origin develop
//push到自己的远程仓库</code></pre>
<p>看到了吧，这就是临时性分支的悲惨命运。不过话说回来，为了整个项目的推进而牺牲不失为一件光荣的事情。</p>
<h3>Workflow</h3>
<p>ok，接下来就到本文的<code>Highlight</code>了，一种可靠的工作流——使用<code>git</code>和<code>github</code>进行协同开发（<em>livoras大神的    那篇文章也叫这个名字，大家可以去看看</em>）</p>
<h4>step 1</h4>
<p>找到源仓库并<code>fork</code>之，<code>clone</code>这个“转发”来的副本（开发者仓库）。</p>
<h4>step 2</h4>
<p>在本地就可以进行开发啦，进入<code>develop</code>分支（你的主战场），并根据需求创建临时分支进行开发，最终合并到<code>develop</code>分支。  <br>自己搞好以后就可以<code>push</code>了，但这并不是上传到源仓库，而是你的开发者仓库。</p>
<h4>step 3</h4>
<p>此时对于 自己刚才上传的代码，你肯定满满的自信，大概是：“卧槽我怎么这么帅真是写得一手好代码”，肯定是希望项目的发起者（管理员）将你的贡献“收录”了，这时，就需要你去提交一个<code>pull request</code>（江湖人称<code>PR</code>）。  <br>提交之后，剩下的工作就交给管理员了。</p>
<h4>step 4</h4>
<p>管理员看到了你的PR，可以在github上面直接review你提交的更改，下一步，他会在本地仓库输入以下命令：</p>
<pre><code class=""bash"">$ git checkout develop
$ git checkout -b kyrieliu-develop
$ git pull https://github.com/kkkyrie/project.git develop
//将你的代码pull到本地的测试分支中进行测试</code></pre>
<p>如果管理员确定没问题，一般情况下就会接受你的PR了。  <br>当然，可以通过两种方法接受一个PR：</p>
<ol>
<li><p>直接在github上接受</p></li>
<li><p>命令行：</p></li>
</ol>
<pre><code class=""bash"">$ git checkout develop
$ git merge --no-ff kyrieliu-develop
$ git branch -d kyrieliu-develop
$ git push origin develop</code></pre>
<p>通过上述的步骤，由你新加的<code>thumbsUp.js</code>就从你本地经历了万水千山最终到达了源仓库。</p>
<h3>有冲突了？莫慌！</h3>
<p>在实际操作中，经常会出现有冲突的情况，作为一个同样遇到过冲突并且最终解决了的人，我由衷的告诉你：不要慌，出现冲突也是一件很平常的事情，实在解决不了那就无脑回滚吧！（噗哈哈哈）  <br>如果其他开发者在你开发的过程中有上传新的代码，在你<code>pull</code>之前一定要先<code>commit</code>你本地的修改，不然可能等你<code>pull</code>下来以后会发现：卧槽我刚写的代码呢？  <br>另外，个人觉得<code>git</code>的提示还是很友好的，有冲突我们<code>diff</code>一下，去解决不久好了嘛。</p>
<blockquote><p>我们的口号是：  <br>有冲突解决冲突，没有冲突就制造冲突也要去解决冲突！</p></blockquote>
<h3>最后</h3>
<p><strong>感谢Gayhub的吉祥物愿意出现在标题中。</strong><br>向livoras大神学习，祭上一张神图供大家理解。  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000008657141"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git协同开发"" title=""git协同开发""></span></p>
<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVKuhf?w=186&amp;h=179"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一个还算有趣的前端er"" title=""一个还算有趣的前端er""></span><br>一个还算有趣的前端er</p>

                ", 浅谈git协作开发工作流,1531977867,589,1,826,1,1,https://segmentfault.com/a/1190000008657137
145,1,0,7,"
                    
<blockquote><p><strong>最近这几个月，特别是 TiDB RC1 发布后，越来越多的用户已经开始测试起来，也有很多朋友已经在生产环境中使用，我们这边也陆续的收到了很多用户的测试和使用反馈。非常感谢各位小伙伴和早期用户的厚爱，而且看了这么多场景后，也总结出了一些 TiDB 的使用实践 (其实 Spanner 的最佳实践大部分在 TiDB 中也是适用的，MySQL 最佳实践也是），也是借着 Google Cloud Spanner 发布的东风，看了一下 Spanner 官方的一些最佳实践文档，写篇文章讲讲 TiDB 以及分布式关系型数据库的一些正确的使用姿势，当然，时代也在一直发展，TiDB 也在不停的进化，这篇文章基本上只代表近期的一些观察。</strong></p></blockquote>
<p>首先谈谈 Schema 设计的一些比较好的经验。由于 TiDB 是一个分布式的数据库，可能在表结构设计的时候需要考虑的事情和传统的单机数据库不太一样，需要开发者能够带着「这个表的数据会分散在不同的机器上」这个前提，才能做更好的设计。</p>
<p>和 Spanner 一样，TiDB 中的一张表的行（Rows）是按照主键的字节序排序的（整数类型的主键我们会使用特定的编码使其字节序和按大小排序一致），即使在 CREATE TABLE 语句中不显式的创建主键，TiDB 也会分配一个隐式的。<br>有四点需要记住：</p>
<ol>
<li><p>按照字节序的顺序扫描的效率是比较高的；</p></li>
<li><p>连续的行大概率会存储在同一台机器的邻近位置，每次批量的读取和写入的效率会高；</p></li>
<li><p>索引是有序的（主键也是一种索引），一行的每一列的索引都会占用一个 KV Pair，比如，某个表除了主键有 3 个索引，那么在这个表中插入一行，对应在底层存储就是 4 个 KV Pairs 的写入：数据行以及 3 个索引行。</p></li>
<li><p>一行的数据都是存在一个 KV Pair 中，不会被切分，这点和类 BigTable 的列式存储很不一样。</p></li>
</ol>
<p>表的数据在 TiDB 内部会被底层存储 TiKV 切分成很多 64M 的 Region（对应 Spanner 的 Splits 的概念），每个 Region 里面存储的都是连续的行，Region 是 TiDB 进行数据调度的单位，随着一个 Region 的数据量越来越大和时间的推移，Region 会分裂/合并，或者移动到集群中不同的物理机上，使得整个集群能够水平扩展。</p>
<ul><li>
<p>建议：</p>
<ol>
<li><p>尽可能批量写入，但是一次写入总大小不要超过 Region 的分裂阈值（64M），另外 TiDB 也对单个事务有大小的限制。</p></li>
<li><p>存储超宽表是比较不合适的，特别是一行的列非常多，同时不是太稀疏，一个经验是最好单行的总数据大小不要超过 64K，越小越好。大的数据最好拆到多张表中。</p></li>
<li><p>对于高并发且访问频繁的数据，尽可能一次访问只命中一个 Region，这个也很好理解，比如一个模糊查询或者一个没有索引的表扫描操作，可能会发生在多个物理节点上，一来会有更大的网络开销，二来访问的 Region 越多，遇到 stale region 然后重试的概率也越大（可以理解为 TiDB 会经常做 Region 的移动，客户端的路由信息可能更新不那么及时），这些可能会影响 .99 延迟；另一方面，小事务（在一个 Region 的范围内）的写入的延迟会更低，TiDB 针对同一个 Region 内的跨行事务是有优化的。另外 TiDB 对通过主键精准的点查询（结果集只有一条）效率更高。</p></li>
</ol>
</li></ul>
<h2>关于索引</h2>
<p>除了使用主键查询外，TiDB 允许用户创建二级索引以加速访问，就像上面提到过的，在 TiKV 的层面，TiDB 这边的表里面的行数据和索引的数据看起来都是 TiKV 中的 KV Pair，所以很多适用于表数据的原则也适用于索引。和 Spanner 有点不一样的是，TiDB 只支持全局索引，也就是 Spanner 中默认的 Non-interleaved indexes。全局索引的好处是对使用者没有限制，可以 scale 到任意大小，不过这意味着，索引信息<em>不一定</em>和实际的数据在一个 Region 内。</p>
<ul><li><p>建议：<br>对于大海捞针式的查询来说 (海量数据中精准定位某条或者某几条)，务必通过索引。</p></li></ul>
<p>当然也不要盲目的创建索引，创建太多索引会影响写入的性能。</p>
<h2>反模式 (最好别这么干！)</h2>
<p>其实 Spanner 的白皮书已经写得很清楚了，我再赘述一下：</p>
<p><strong>第一种，过度依赖单调递增的主键，AUTO INCREMENT ID</strong><br>在传统的关系型数据库中，开发者经常会依赖自增 ID 来作为 PRIMARY KEY，但是其实大多数场景大家想要的只是一个不重复的 ID 而已，至于是不是自增其实无所谓，但是这个对于分布式数据库来说是不推荐的，随着插入的压力增大，会在这张表的尾部 Region 形成热点，而且这个热点并没有办法分散到多台机器。TiDB 在 GA 的版本中会对非自增 ID 主键进行优化，让 insert workload 尽可能分散。</p>
<ul><li><p>建议：<br>如果业务没有必要使用单调递增 ID 作为主键，就别用，使用真正有意义的列作为主键（一般来说，例如：邮箱、用户名等）</p></li></ul>
<p>使用随机的 UUID 或者对单调递增的 ID 进行 bit-reverse （位反转）</p>
<p><strong>第二种，单调递增的索引 (比如时间戳)</strong><br>很多日志类型的业务，因为经常需要按照时间的维度查询，所以很自然需要对 timestamp 创建索引，但是这类索引的问题本质上和单调递增主键是一样的，因为在 TiDB 的内部实现里，索引也是一堆连续的 KV Pairs，不断的插入单调递增的时间戳会造成索引尾部的 Region 形成热点，导致写入的吞吐受到影响。</p>
<ul><li><p>建议：<br>因为不可避免的，很多用户在使用 TiDB 存储日志，毕竟 TiDB 的弹性伸缩能力和 MySQL 兼容的查询特性是很适合这类业务的。另一方面，如果发现写入的压力实在扛不住，但是又非常想用 TiDB 来存储这种类型的数据，可以像 Spanner 建议的那样做 Application 层面的 Sharding，以存储日志为例，原来的可能在 TiDB 上创建一个 log 表，更好的模式是可以创建多个 log 表，如：log_1, log_2 … log_N，然后业务层插入的时候根据时间戳进行 hash ，随机分配到 1..N 这几个分片表中的一个。</p></li></ul>
<p>相应的，查询的时候需要将查询请求分发到各个分片上，最后在业务层汇总结果。</p>
<h2>查询优化</h2>
<p>TiDB 的优化分为基于规则的优化（Rule Based Optimization）和基于代价的优化（Cost Based Optimization）, 本质上 TiDB 的 SQL 引擎更像是一个分布式计算框架，对于大表的数据因为本身 TiDB 会将数据分散到多个存储节点上，能将查询逻辑下推，会大大的提升查询的效率。</p>
<p><strong>TiDB 基于规则的优化有：</strong><br><strong><em>谓词下推</em></strong></p>
<pre><code>谓词下推会将 where/on/having 条件推到离数据表尽可能近的地方，比如：
</code></pre>
<p><code>select * from t join s on t.id = s.id where t.c1 &lt; 10</code></p>
<p>可以被 TiDB 自动改写成</p>
<p><code>select * from (select * from t where t.c1 &lt; 10) as t join s on t.id = s.id</code></p>
<p><strong><em>关联子查询消除</em></strong></p>
<p>关联子查询可能被 TiDB 改写成 Join，例如：</p>
<p><code>select * from t where t.id in (select id from s where s.c1 &lt; 10 and s.name = t.name)</code></p>
<p>可以被改写成：</p>
<p><code>select * from t semi join s on t.id = s.id and s.name = t.name and s.c1 &lt; 10</code></p>
<p><strong><em>聚合下推</em></strong><br>聚合函数可以被推过 Join，所以类似带等值连接的 Join 的效率会比较高，例如：</p>
<p><code>select count(s.id) from t join s on t.id = s.t_id</code></p>
<p>可以被改写成：</p>
<p><code>select sum(agg0) from t join (select count(id) as agg0, t_id from s group by t_id) as s on t.id = s.t_id</code></p>
<p>基于规则的优化有时可以组合以产生意想不到的效果，例如：</p>
<p><code>select s.c2 from s where 0 = (select count(id) from t where t.s_id = s.id)</code></p>
<p>在TiDB中，这个语句会先通过关联子查询消除的优化，变成：</p>
<p><code>select s.c2 from s left outer join t on t.s_id = s.id group by s.id where 0 = count(t.id)</code></p>
<p>然后这个语句会通过聚合下推的优化，变成：</p>
<p><code>select s.c2 from s left outer join (select count(t.id) as agg0 from t group by t.s_id) t on t.s_id = s.id group by s.id where 0 = sum(agg0)</code></p>
<p>再经过聚合消除的判断，语句可以优化成：</p>
<p><code>select s.c2 from s left outer join (select count(t.id) as agg0 from t group by t.s_id) t on t.s_id = s.id where 0 = agg0</code></p>
<p>基于代价的优化有：</p>
<p>读取表时，如果有多条索引可以选择，我们可以通过统计信息选择最优的索引。例如:</p>
<p><code>select * from t where age = 30 and name in ( ‘小明’, ‘小强’)</code><br>对于包含 Join 的操作，我们可以区分大小表，TiDB 的对于一个大表和一个小表的 Join 会有特殊的优化。<br>例如 <br><code>select * from t join s on s.id = t.id</code><br>优化器会通过对表大小的估计来选择 Join 的算法：即选择把较小的表装入内存中。<br>对于多种方案，利用动态规划算法选择最优者，例如: </p>
<p><code>(select * from t where c1 &lt; 10) union all (select * from s where c2 &lt; 10) order by c3 limit 10</code></p>
<p>t 和 s 可以根据索引的数据分布来确定选择索引 c3 还是 c2。</p>
<p>总之正确使用 TiDB 的姿势，或者说 TiDB 的典型的应用场景是：</p>
<p>大数据量下，MySQL 复杂查询很慢；</p>
<p>大数据量下，数据增长很快，接近单机处理的极限，不想分库分表或者使用数据库中间件等对业务侵入性较大，架构反过来约束业务的 Sharding 方案；</p>
<p>大数据量下，有高并发实时写入、实时查询、实时统计分析的需求；</p>
<p>有分布式事务、多数据中心的数据 100% 强一致性、auto-failover 的高可用的需求。</p>
<p><strong><em>如果整篇文章你只想记住一句话，那就是数据条数少于 5000w 的场景下通常用不到 TiDB，TiDB 是为大规模的数据场景设计的。如果还想记住一句话，那就是单机 MySQL 能满足的场景也用不到 TiDB。</em></strong></p>

                ", TiDB 的正确使用姿势,1531977869,249,1,228,1,1,https://segmentfault.com/a/1190000008643974
146,1,0,7,"
                    
<h2>概述</h2>
<p><strong>先用一幅图，从总体上描述主要git命令的工作流程</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVKndm?w=517&amp;h=420"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>workspace</strong>: 本地的工作目录。（记作A） <br><strong>index/stage</strong>：<strong>暂存</strong>区域，临时保存本地改动。 （记作B）<br><strong>local repository</strong>: 本地仓库，只想最后一次提交HEAD。（记作C） <br><strong>remote repository</strong>：远程仓库。（记作D）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVKnDJ?w=840&amp;h=593"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>命令笔记</h2>
<p>以下所有的命令的功能说明，都采用上述的标记的A、B、C、D的方式来阐述。</p>
<p><strong>初始化</strong></p>
<pre><code>git init //创建
git clone /path/to/repository //检出
git config --global user.email ""you@example.com"" //配置email
git config --global user.name ""Name"" //配置用户名
</code></pre>
<p><strong>操作</strong></p>
<pre><code>git add &lt;file&gt; // 文件添加，A → B
git add . // 所有文件添加，A → B
git commit -m ""代码提交信息"" //文件提交，B → C
git commit --amend //与上次commit合并, *B → C
git push origin master //推送至master分支, C → D
git pull //更新本地仓库至最新改动， D → A
git fetch //抓取远程仓库更新， D → C
git log //查看提交记录
git status //查看修改状态
git diff//查看详细修改内容
git show//显示某次提交的内容
</code></pre>
<p><strong>撤销操作</strong></p>
<pre><code>git reset &lt;file&gt;//某个文件索引会回滚到最后一次提交， C → B
git reset//索引会回滚到最后一次提交， C → B
git reset --hard // 索引会回滚到最后一次提交， C → B → A
git checkout // 从index复制到workspace， B → A
git checkout -- files // 文件从index复制到workspace， B → A
git checkout HEAD -- files // 文件从local repository复制到workspace， C → A
</code></pre>
<p><strong>分支相关</strong></p>
<pre><code>git checkout -b branch_name //创建名叫“branch_name”的分支，并切换过去
git checkout master //切换回主分支
git branch -d branch_name // 删除名叫“branch_name”的分支
git push origin branch_name //推送分支到远端仓库
git merge branch_name // 合并分支branch_name到当前分支(如master)
git rebase //衍合，线性化的自动， D → A
</code></pre>
<p><strong>冲突处理</strong></p>
<pre><code>git diff //对比workspace与index
git diff HEAD //对于workspace与最后一次commit
git diff &lt;source_branch&gt; &lt;target_branch&gt; //对比差异
git add &lt;filename&gt; //修改完冲突，需要add以标记合并成功
</code></pre>
<p><strong>其他</strong></p>
<pre><code>gitk //开灯图形化git
git config color.ui true //彩色的 git 输出
git config format.pretty oneline //显示历史记录时，每个提交的信息只显示一行
git add -i //交互式添加文件到暂存区
</code></pre>
<h2>实操：</h2>
<p><strong>① 创建版本库</strong><br>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库<br>第一步，用命令git add告诉Git，把文件添加到仓库：<br>$ git add readme.txt<br>执行上面的命令，没有任何显示，这就对了，</p>
<blockquote><p>Unix的哲学是“<strong>没有消息就是好消息</strong>”</p></blockquote>
<p>说明添加成功。</p>
<p>第二步，用命令<code>git commit -m ""xxx""</code> 告诉Git，把文件提交到仓库，-m后面输入的是本次提交的说明，能从历史记录里方便地找到改动记录。</p>
<p><strong>② 添加远程库</strong></p>
<pre><code>git remote add origin git@github.com:tcyfree/test.git(或https://github.com/tcyfree/test.git，用git@比https快)    
</code></pre>
<p>添加后，<strong>远程库的名字就是origin，这是Git默认的叫法</strong>，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<pre><code>$ git push -u origin master</code></pre>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们<strong>第一次推送master分支时，加上了-u参数</strong>，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>总结：从现在起，只要本地作了提交，就可以通过命令：<code>git push origin master</code><br>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！<br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；<br>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<p><strong>③ 从远程库克隆</strong><br>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。<br>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h2>场景操作</h2>
<p><strong>时光机穿梭</strong><br>1.要随时掌握工作区的状态，使用<code>git status</code>命令。<br>2.如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。<br><strong>版本回退</strong><br>1.HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。<br>2.穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。<br>3.要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<p><strong>git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别</strong></p>
<p><strong>撤销修改</strong><br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。<br>（<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。）</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本回退</strong>一节，不过前提是没有推送到远程库。</p>
<p><strong>删除文件</strong><br>1.命令<code>git rm</code>用于删除一个文件。<br>2.确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<pre><code>$ git rm test.txt
rm 'test.txt'
$ git commit -m ""remove test.txt""
[master d17efd8] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre>
<p>现在，文件就从版本库中被删除了</p>
<p><strong>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong><br>git pull：相当于是从远程获取最新版本并merge到本地<br>git pull origin master<br>上述命令其实相当于git fetch 和 git merge<br>在实际使用中，git fetch更安全一些<br>因为在merge前，我们可以查看更新情况，然后再决定是否合并</p>
<p><strong>创建与合并分支</strong><br>截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。<strong>HEAD严格</strong>来说不是指向提交，而是<strong>指向master</strong>，master才是指向提交的，所以，<strong>HEAD指向的就是当前分支</strong>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs7eI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示<strong>创建并切换</strong>，相当于以下两条命令：</p>
<pre><code>$ git branch dev
$ git checkout dev
Switched to branch 'dev'</code></pre>
<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<pre><code>$ git branch
* dev
  master
</code></pre>
<p>git branch命令会列出所有分支，<strong>当前分支</strong>前面会标一个<code>*</code>号。</p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs7eL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs7eS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><code>git merge</code>命令用于<strong>合并指定分支到当前分支</strong>。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 </p>
<p><strong>小结</strong></p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<p><strong>解决冲突</strong></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容<br>修改master后提交：<br>现在，master分支和feature1分支变成了下图所示：<br><span class=""img-wrap""><img data-src=""/img/bVs7jI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>最后，删除feature1分支：</p>
<p><code>git branch -d feature1</code></p>
<p>总结：</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<p><strong>分支管理策略</strong></p>
<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，<strong>会丢掉分支信息</strong>。<br>分支策略</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs7nn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>准备合并dev分支，请注意<strong>--no-ff</strong>参数，表示禁用Fast forward：</p>
<p>$ git merge --no-ff -m ""merge with no-ff"" dev<br>Merge made by the 'recursive' strategy.<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br>因为本次合并要创建一个新的<strong>commit，所以加上-m参数，把commit描述写进去</strong>。</p>
<p>合并后，我们用git log看看分支历史：</p>
<p>$ git log --graph --pretty=oneline --abbrev-commit</p>
<ul><li><p>7825a50 merge with no-ff<br>|\</p></li></ul>
<p>| * 6224937 add merge<br>|/</p>
<ul><li><p>59bc1cb conflict fixed<br>...</p></li></ul>
<p>可以看到，不使用Fast forward模式，merge后就像这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs7mF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>小结</p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<strong>--no-ff</strong>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p><strong>Bug分支</strong><br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p><strong>Feature分支</strong></p>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，<strong>每添加一个新功能，最好新建一个feature分支，</strong>在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<p><strong>多人协作</strong></p>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用<code>git remote</code>或者，用<code>git remote -v</code>显示更详细的信息。</p>
<p>并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><p>master分支是主分支，因此要时刻与远程同步；</p></li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p><strong><em>多人协作的工作模式通常是这样</em></strong>：</p>
<ul>
<li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p></li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li>
<li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p></li>
</ul>
<p>如果<code>git pull</code>提示<code>“no tracking information”</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<p><strong><em>小结</em></strong></p>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>忽略特殊文件</strong></p>
<p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p>
<p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要<strong>忽略的文件名填进去</strong>，Git就会自动忽略这些文件。</p>
<p>忽略文件的原则是：</p>
<p>忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini

# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build

# My configurations:
db.ini
deploy_key_rsa</code></pre>
<p>最后一步就是把.gitignore也提交到Git，就完成了！</p>
<p><strong><em>小结</em></strong></p>
<ul>
<li><p>忽略某些文件时，需要编写<code>.gitignore</code>；</p></li>
<li><p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p></li>
</ul>
<p><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000"" rel=""nofollow noreferrer"">安装Git</a><br><a href=""http://gityuan.com/2015/06/27/git-notes/"" rel=""nofollow noreferrer"">参考文档：Git常用命令</a><br><a href=""https://segmentfault.com/a/1190000004992316"" rel=""nofollow noreferrer"">推荐文档：Git常用命令和Git团队使用规范指南</a><br><a href=""http://www.bootcss.com/p/git-guide/"" rel=""nofollow noreferrer"">git - 简易指南</a><br><a href=""https://mp.weixin.qq.com/s/QDPJ1IPqzYNoBMDQgw0lIQ"" rel=""nofollow noreferrer"">常用Git命令清单</a></p>

                ", Git 图解、常用命令和廖雪峰教程笔记总结,1531977870,315,1,490,1,1,https://segmentfault.com/a/1190000008617626
147,1,0,7,"
                    
<h2>命令行</h2>
<h3>查看git上的个人代码量：</h3>
<pre><code>git log --author=""username"" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf ""added lines: %s, removed lines: %s, total lines: %s\n"", add, subs, loc }' -</code></pre>
<p>结果示例：(记得修改 username)</p>
<pre><code>added lines: 120745, removed lines: 71738, total lines: 49007</code></pre>
<h3>统计每个人增删行数</h3>
<pre><code>git log --format='%aN' | sort -u | while read name; do echo -en ""$name\t""; git log --author=""$name"" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf ""added lines: %s, removed lines: %s, total lines: %s\n"", add, subs, loc }' -; done</code></pre>
<p>结果示例</p>
<pre><code>Max-laptop    added lines: 1192, removed lines: 748, total lines: 444
chengshuai    added lines: 120745, removed lines: 71738, total lines: 49007
cisen    added lines: 3248, removed lines: 1719, total lines: 1529
max-h    added lines: 1002, removed lines: 473, total lines: 529
max-l    added lines: 2440, removed lines: 617, total lines: 1823
mw    added lines: 148721, removed lines: 6709, total lines: 142012
spider    added lines: 2799, removed lines: 1053, total lines: 1746
thy    added lines: 34616, removed lines: 13368, total lines: 21248
wmao    added lines: 12, removed lines: 8, total lines: 4
xrl    added lines: 10292, removed lines: 6024, total lines: 4268
yunfei.huang    added lines: 427, removed lines: 10, total lines: 417
³ö    added lines: 5, removed lines: 3, total lines: 2</code></pre>
<h3>查看仓库提交者排名前 5</h3>
<pre><code>git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5</code></pre>
<h3>贡献值统计</h3>
<pre><code>git log --pretty='%aN' | sort -u | wc -l</code></pre>
<h3>提交数统计</h3>
<pre><code>git log --oneline | wc -l</code></pre>
<h3>添加或修改的代码行数：</h3>
<pre><code>git log --stat|perl -ne 'END { print $c } $c += $1 if /(\d+) insertions/'</code></pre>
<h2>使用gitstats</h2>
<p><a href=""https://github.com/hoxu/gitstats"" rel=""nofollow noreferrer"">GitStats项目</a>，用Python开发的一个工具，通过封装Git命令来实现统计出来代码情况并且生成可浏览的网页。官方文档可以参考这里。</p>
<h3>使用方法</h3>
<pre><code>git clone git://github.com/hoxu/gitstats.git
cd gitstats
./gitstats 你的项目的位置 生成统计的文件夹位置</code></pre>
<p>可能会提示没有安装gnuplot画图程序，那么需要安装再执行：</p>
<pre><code>//mac osx
brew install gnuplot
//centos linux
yum install gnuplot</code></pre>
<p>生成的统计文件为HTML：<br><span class=""img-wrap""><img data-src=""/img/bVJ0s4?w=900&amp;h=675"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2014-8-16-git.jpg"" title=""2014-8-16-git.jpg""></span></p>
<h2>使用cloc</h2>
<pre><code>npm install -g cloc</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010648166"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>参考文章</h2>
<p><a href=""http://www.jianshu.com/p/8fd14064c201"" rel=""nofollow noreferrer"">git代码行统计命令集</a><br><a href=""http://www.94joy.com/archives/115#comment-319"" rel=""nofollow noreferrer"">统计本地Git仓库中不同贡献者的代码行数的一些方法</a><br><a href=""http://blog.cyeam.com/kaleidoscope/2015/01/17/gitstats"" rel=""nofollow noreferrer"">使用Git工具统计代码</a></p>

                ", git代码统计,1531977871,385,1,576,1,1,https://segmentfault.com/a/1190000008542123
148,1,0,7,"
                    
<h1>SSH KEY</h1>
<h2>生成 SSH KEY</h2>
<pre><code class=""bash"">$ ssh-keygen -t rsa -C ""your_email@example.com""
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again: </code></pre>
<p><code>your_email@example.com</code> 改成自己的邮箱。</p>
<p>密码输入成功后出现如下提示，表示创建成功：</p>
<pre><code>Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.
Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.
The key fingerprint is:
fingerprint值 your_email@example.com
The key's randomart image is:
 +--[ RSA 2048]----+
 | .+ + |
 | =oO. |
 ...</code></pre>
<p>注解：这里第一次输入的是<strong>文件名</strong>，如果直接按回车则会自动生成私钥和公钥：<code>id_rsa</code>、<code>id_rsa.pub</code>。后面跟着的是<strong>密码</strong>和<strong>确认密码</strong>。</p>
<p>上方的命令执行多次则会生成多个 SSH KEY。</p>
<h2>查看 SSH KEY</h2>
<pre><code class=""bash"">$ cat ~/.ssh/id_rsa.pub
ssh-rsa 公开密钥的内容 your_email@example.com</code></pre>
<p>如果创建时输入了文件名，上方的<code>id_rsa</code>替换成文件名。</p>
<p>此处返回的这段内容可用于使用 SSH KEY 的网站，这里不作过多阐述。</p>
<h1>GIT CONFIG</h1>
<p>像 <code>github</code> 或者 <code>gitlab</code> 等网站都会要求验证身份。通常情况下配置一个全局信息就可以了，针对一些特殊情况，如果需要配置多个身份信息，可以为项目单独配置。</p>
<h2>配置全局信息</h2>
<pre><code class=""bash"">$ git config --global user.name ""Firstname Lastname""
$ git config --global user.email ""your_email@example.com""</code></pre>
<p>这个命令会在<code>~/.gitconfig</code>填入以下信息：</p>
<pre><code>[user]
  name = Firstname Lastname
  email = your_email@example.com</code></pre>
<p>如果需要修改信息，直接修改这个文件即可。</p>
<h2>配置单独信息</h2>
<pre><code class=""bash"">$ cd your_project
$ git config user.name ""Firstname Lastname""
$ git config user.email ""your_email@example.com""</code></pre>
<p>这个命令会在项目目录下输出文件：<code>/.git／.config</code></p>
<p>这里设置的姓名和邮箱地址会用在 Git 的提交日志中。</p>
<h1>为不同网站应用各自的 SSH KEY</h1>
<p>在 <code>~/.ssh</code> 目录下创建 <code>config</code> 文件：</p>
<pre><code class=""bash"">$ vim ~/.ssh/config</code></pre>
<p>输入以下信息：</p>
<pre><code>Host github.com
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_rsa_a

Host git.oschina.net
    HostName git.oschina.net
    User git
    IdentityFile ~/.ssh/id_rsa_b

...</code></pre>
<p>再把对应的公钥添加至对应的网站上面。</p>
<p>注解：未加入配置文件的网站会自动应用<code>id_rsa</code>。</p>
<p>至此，多个 SSH KEY 就可以同时使用了。</p>
<blockquote><p>原文地址：<a href=""https://ueibo.cn/yi-tai-dian-nao-pei-zhi-duo-ge-ssh-key-duo-ge-yong-hu-shen-fen/"" rel=""nofollow noreferrer"">一台电脑配置多个SSH KEY，多个用户身份</a><br>文章作者：<a href=""https://ueibo.cn/author/heleth/"" rel=""nofollow noreferrer"">何启邦</a>  <br>版权声明：自由转载-非商用-非衍生-保持署名（<a href=""http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh"" rel=""nofollow noreferrer"">创意共享3.0许可证</a>） 转载请注明出处</p></blockquote>

                ", 一台电脑配置多个SSH KEY，多个用户身份,1531977873,535,1,151,1,1,https://segmentfault.com/a/1190000008462401
149,1,0,7,"
                    
<blockquote><p><strong>缘由：</strong>每次向<code>github提交代码</code>时都要输入用户名密码，太麻烦了，影响效率</p></blockquote>
<p><strong>解决方案：</strong><br>方案一：</p>
<ol>
<li>
<p>在你的用户目录下新建一个文本文件<code>.git-credentials</code></p>
<ul>
<li><p><code>Windows</code>：<code>C:/Users/username</code></p></li>
<li><p><code>Mac OS X</code>： <code>/Users/username</code></p></li>
<li><p><code>Linux</code>： <code>/home/username</code><br>注意：鼠标右键新建文件<code>重复命名</code>是成功不了的，需要借助<code>Sublime</code>等<code>IDE</code>工具来创建文件。</p></li>
</ul>
</li>
<li>
<p><code>.git-credentials</code>在文件中输入以下内容：</p>
<pre><code>https:{username}:{password}@github.com
</code></pre>
<p><code>{username}</code>和<code>{password}</code>是你的<code>github</code>的<code>账号</code>和<code>密码</code></p>
</li>
<li>
<p>修改<code>git</code>配置<br>执行命令：</p>
<pre><code>git config --global credential.helper store</code></pre>
<p>上述命令会在<code>.gitconfig</code>文件(<code>.gitconfig</code>与<code>.git-credentials</code>在同目录下)末尾添加如下配置:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVJyB5?w=361&amp;h=146"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
</li>
</ol>
<p>经过上述三步配置之后, 你<code>push代码</code>到github时, 便<code>无需再输入用户名密码</code>了</p>
<p>方案二：</p>
<ol>
<li>
<p>在命令行输入命令:</p>
<pre><code>git config --global credential.helper store</code></pre>
<p>这一步会在用户目录下的<code>.gitconfig</code>文件最后添加：</p>
<pre><code>[credential]
    helper = store</code></pre>
</li>
<li><p>push 代码<br><code>push</code>你的代码 (<code>git push</code>), 这时会让你输入<code>用户名</code>和<code>密码</code>, 这一步输入的用户名密码会被<code>记住</code>, 下次再push代码时就不用输入用户名密码!这一步会在用户目录下生成文件<code>.git-credential</code>记录用户名密码的信息。</p></li>
</ol>
<p><strong>总结：</strong><br><code>方案一</code>与<code>方案二</code>都是创建<code>.git-credential</code>文件并写入用户信息，一个是手动创建，一个命令创建。</p>

                ", 解决向github提交代码不用输入帐号密码,1531977875,455,1,498,1,1,https://segmentfault.com/a/1190000008435592
150,1,0,7,"
                    
<h3>前言</h3>
<p>Github作为目前优秀的同性交友平台，其上维护了众多优秀的开源项目。目前Github上关于前端的项目也是数不胜数，Vue、React、Angular等等。自己也是通过官方文档+github的方式来学习一些新的技术和框架。在github上搜索相关项目时会发现，有的项目不光写了一手好文档并且还给出了项目的在线运行Demo。事实胜于雄辩，一个在线演示可能给项目带来更好的印象分。如何在github上维护自己个人项目源代码的同时并生成项目主页呢？</p>
<h3>Github项目主页</h3>
<p>Github给用户提供了运行静态页面的地址，如何展示个人项目的静态页面？以下是创建项目主页的关键：</p>
<ul>
<li>gh-pages分支</li>
<li>访问地址：[github用户名].github.io/[项目仓库名]，如：<a href=""https://monster1935.github.io/vue-example"" rel=""nofollow noreferrer"">monster1935.github.io/vue-example</a>
</li>
</ul>
<p>生成项目主页首先是将欲展示的静态页面推送的Github个人项目仓库的gh-pages分支下，然后通过上述的访问形式访问。</p>
<h3>如何在维护源代码的同时并同时生成项目主页</h3>
<p>以下以Vue的单页应用为例，给出完整的项目维护以及生成项目主页的步骤。</p>
<p><strong>一、Github上创建远程仓库</strong></p>
<p>在github上为个人项目创建远程仓库，如下所示:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008425995?w=847&amp;h=601"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>二、clone远程仓库到本地</strong></p>
<p>创建好远程仓库后，使用git工具将远程仓库clone到本地，如下所示:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008425996?w=1029&amp;h=501"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>三、使用vue-cli生成vue单页应用项目</strong></p>
<p>进入项目根目录，使用vue-cli生成vue的项目的初始结构。步骤如下：</p>
<pre><code class=""bash""># 以webpack模板生成项目原型
vue init webpack vue-example</code></pre>
<p>在使用vue-cli脚手架工具生成vue项目过程中会提示是否安装一些辅助工具库，可根据自己项目要求酌情安装，或者生成项目后安装。</p>
<p>项目生成完毕后，进入package.json所在目录执行npm install命令，安装项目运行需要的依赖。</p>
<p>依赖安装完成后，即可执行npm run dev命令启动本地的webpack-dev-server进行开发调试。<br>如下图所示，出现如下画面代表vue项目初始化完毕。后期可在该基础上进行自己项目的开发。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008425997?w=1906&amp;h=1002"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>四、将项目推送到远程仓库</strong></p>
<p>项目开发过程中，可以将项目源码推送至github远程仓库中管理。</p>
<pre><code>git add --all

git commit -m 'Initial the vue project'

git push </code></pre>
<p><strong>五、执行项目构建命令，并将构建后的静态页面推送至gh-pages分支</strong></p>
<p>项目开发完毕可以执行<code> npm run build </code> 打包文件，进行文件的打包发布流程。</p>
<ol>
<li>切换到gh-pages分支 <code> git checkout -b gh-pages </code>
</li>
<li>执行<code> npm run build </code>命令，构建代码</li>
<li>将dist目录下的所有文件夹推送至远程仓库的gh-pages分支，执行以下命令：</li>
</ol>
<pre><code class=""bash""># 强制添加dist文件夹，因为.gitignore文件中定义了忽略该文件
git add -f dist

# 提交到本地暂存区
git commit -m 'Initial the page of project'

# 部署dist目录下的代码
git subtree push --prefix dist origin gh-pages</code></pre>
<p><strong>注：使用git subtree命令可以在同一分支上维护源代码以及构建代码，在部署时仅仅推送dist目录下的内容。</strong></p>
<h3>小结</h3>
<p>以上所述的在github上gh-pages分支上生成项目主页主要是利用了github提供的静态页解析功能，因此本文中所属的范围仅使用于静态页面的部署。在将Vue应用部署到gh-pages分支后，可能会出现部分资源无法加载的问题，原因就在于vue中的webpack配置在打包时其publicPath为根路径，如果该静态页在服务器中被访问则不会出现以上问题。在github解析时如果按照根路径解析会出错，因此在github上部署静态页时可以考虑将publicPath设置为当前目录，即<code> publicPath: './' </code>。</p>
<p>使用Vue-cli webpack模板生成的vue项目，出现上述问题应设置config/index.js中build对象下的<code>assetsPublicPath</code>字段为<code>assetsPublicPath: './'</code>,原理都是设置publicPath字段。</p>
<hr>
<h3>更新</h3>
<p>目前发现了一种更为简便的部署到github gh-pages的方式，<a href=""https://github.com/tschaub/gh-pages"" rel=""nofollow noreferrer"">gh-pages</a> 提供了更为简便的管理本地项目到github的提交流程。详情见<a href=""https://github.com/monster1935/vue-ghpages-test"" rel=""nofollow noreferrer"">vue-ghpages-test</a>。</p>

                ", 如何在github上创建个人项目的在线演示demo,1531977876,371,1,846,1,1,https://segmentfault.com/a/1190000008425992
151,1,0,7,"
                    
<blockquote><p>时隔半年多，iView 终于迎来了它的第一个正式版本 1.0.0，到目前版本，已经有 43 个常用 UI 组件，从功能和设计上，是最接近 Ant.Design 的 Vue.js 实现。</p></blockquote>
<h2>关于 iView 1.0</h2>
<p><strong> GitHub 地址：<a href=""https://github.com/iview/iview"" rel=""nofollow noreferrer"">https://github.com/iview/iview</a> </strong></p>
<p>iView 已经从最初的高质量 UI 组件库，逐步过渡到了从工程构建、主题定制、多语言、设计规范的一整套的前端解决方案。主要服务于中后台业务，目的就是让网站快速成型上线。</p>
<h2>1.0 都有哪些新特性</h2>
<p>先看一下目前支持的组件情况：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008409106?w=2266&amp;h=1820"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>常用的组件包括了：Grid 栅格、提醒类（Message、Notice）、模态 Modal、表格 Table、级联选择、输入框、表单验证、单选、多选、下拉选择、滑块、上传、日期时间选择、分页、导航菜单等。</p>
<p>除了基本组件外，1.0 还加了很多新东西:</p>
<ul>
<li><p>常用布局 <a href=""https://www.iviewui.com/components/layout"" rel=""nofollow noreferrer"">Layout</a></p></li>
<li><p>定制主题 <a href=""https://www.iviewui.com/docs/guide/theme"" rel=""nofollow noreferrer"">查看</a>，及主题构建工具 <a href=""https://github.com/iview/iview-theme"" rel=""nofollow noreferrer"">https://github.com/iview/iview-theme</a></p></li>
<li><p>支持 vue-cli 的模板 <a href=""https://github.com/iview/webpack"" rel=""nofollow noreferrer"">https://github.com/iview/webpack</a></p></li>
<li><p>支持 Mac 和 Windows 的可视化脚手架软件 <a href=""https://github.com/iview/iview-cli"" rel=""nofollow noreferrer"">iview-cli</a></p></li>
</ul>
<p>值得一提的是，可视化脚手架 iview-cli。相信大家都用过 vue-cli，用命令行来创建 Vue 应用，虽然已经很方便了，但配置起来不够全面，而且对于很多后端人员，安装成本也比较高。看一下 iview-cli 的界面吧：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008409107?w=1104&amp;h=1328"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008409108?w=1004&amp;h=1318"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>关于更多的细节，会在下一篇文章《Electron 从 0 到 1：可视化脚手架 iview-cli 开发实践》中详细介绍，敬请期待！</p>
<h2>2.0 计划</h2>
<p>基于 Vue.js 2.x 的 iView 2.x 也会很快开始开发，初步预计开发时间为2~3个月。<br>iView 还有很多需要改进和提高的地方，希望对其感兴趣的小伙伴可以加入到开源项目里来，贡献您的代码，一起把 iView 做到极致！</p>

                ", iView 发布 1.0 正式版，43 个 UI 组件助力中后台业务开发,1531977877,515,1,329,1,1,https://segmentfault.com/a/1190000008409103
152,1,0,7,"
                    
<p>在实际工作中，一个大型的项目或版本迭代可能不是一次上线，可能会分好几次上线，这时候就会涉及创建多个分支，进行分别开发。</p>
<h2>创建分支</h2>
<p>功能分为2个分支，分别为A、B。<br>A上面有个列表页功能<br>B上面有个详情页功能，还有个系统消息功能</p>
<p>产品经理说先上列表功能，于是我们就开发A分支，列表功能很快开发完成。<br>第二天按常理开发B分支，开发到一半，产品经理说目前的系统消息功能需要急着上线，要和列表功能一起上线，当时就懵逼了，然后赶紧放下详情页的开发，立马去开发系统消息功能，开发完之后需要将列表功能和系统消息功能放在一个分支上提测，这时候分支合并就派上用场了。</p>
<h2>合并分支</h2>
<p>使用git merge 命令进行分支合并是通用的做法，但是git merge 合并的时候会将两个分支的内容完全合并，如果想合并一部分肯定是不行的。那怎么办？</p>
<p>如何从其他分支merge指定文件到当前分支，git checkout 是个合适的工具。</p>
<p><code>git checkout source_branch &lt;path&gt;...</code></p>
<h2>强制合并</h2>
<p>我们使用git checkout 将B分支上的系统消息功能添加到A分支上</p>
<pre><code>$ git branch
  * A  
    B
    
$ git checkout B message.html message.css message.js other.js

$ git status
# On branch A
# Changes to be committed:
#   (use ""git reset HEAD &lt;file&gt;..."" to unstage)
#
#    new file:   message.css
#    new file:   message.html
#    new file:   message.js
#    modified:   other.js
#
</code></pre>
<p>合并完成</p>
<p><strong>注意：在使用git checkout某文件到当前分支时，会将当前分支的对应文件强行覆盖</strong></p>
<p>这里新增文件没问题，但是A分支上原有的other.js会被强行覆盖，如果A分支上的other.js有修改，在checkout的时候就会将other.js内容强行覆盖，这样肯定是不行的。如何避免不强制覆盖，往下看。</p>
<h2>智能合并</h2>
<p>1.使用git checkout 将根据A分支创建一个A_temp分支，避免影响A分支</p>
<pre><code>$ git checkout -b A_temp
Switched to a new branch 'A_temp'
</code></pre>
<p>2.将B分支合并到A_temp分支</p>
<pre><code>$ git merge B
Updating 1f73596..04627b5
Fast-forward
 message.css                     | 0
 message.html                    | 0
 message.js                      | 0
 other.js                        | 1 +
 4 files changed, 1 insertion(+)
 create mode 100644 message.css
 create mode 100644 message.html
 create mode 100644 message.js
</code></pre>
<p>3.切换到A分支，并使用git checkout 将A_temp分支上的系统消息功能相关文件或文件夹覆盖到A分支</p>
<pre><code>
$ git checkout A
Switched to branch 'A'

$ git checkout A_temp message.html message.css message.js other.js

$ git status
# On branch A
# Changes to be committed:
#   (use ""git reset HEAD &lt;file&gt;..."" to unstage)
#
#    new file:   message.css
#    new file:   message.html
#    new file:   message.js
#    modified:   other.js
#
    </code></pre>
<p>ok，完结，这是工作中使用git合并总结的经验，仅供参考，有错误请指出，谢谢！</p>

                ", git小技巧--如何从其他分支merge个别文件或文件夹,1531977878,265,1,519,1,1,https://segmentfault.com/a/1190000008360855
153,1,0,7,"
                    
<p>下面，给大家介绍一个把 <code>git bash</code> 集成到 <code>VSC(Visual Studio Code)</code> 中的小技巧，因为我们使用 <code>mac</code> 的同学没有这样的需求，所以这里只是windows下的配置方法，希望能帮助大家，也祝大家新年快乐！</p>
<h3>起因</h3>
<p>以前我们团队大部分同学都使用 <code>sublime</code> 来开发项目，每打开一个项目，就要开一个终端运行任务。随着项目越来越多，打开的终端也越来越多，这样在 <code>sublime</code> 和终端的切换中让自己晕头转向（请原谅我们使用的 <code>windows</code> 原生终端）。</p>
<p>直到发现了 <code>VSC</code> 这样的神器，它自己内部集成终端，这样我们就能在编辑器中运行任务了，写代码的幸福指数蹭蹭蹭的上升。可是新问题来了，它内置的 <code>git</code> 工具并不好用，而且 <code>SouceTree</code> 也越来越卡。所以能在它的集成终端中使用 <code>git</code> 命令才是我理想的打开方式。</p>
<h3>git版本</h3>
<p>我安装的 <code>git</code> 的版本，如下图<br><span class=""img-wrap""><img data-src=""/img/bVIvCn?w=843&amp;h=549"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>tips：如果 <code>git</code> 命令不能在 <code>cmd</code> 中使用，需要把 <code>git cmd</code> 的路径添加到系统环境变量 <code>PATH</code> 中</p></blockquote>
<pre><code>C:\Program Files (x86)\Git\cmd</code></pre>
<p>打开文件夹<em>C:\Program Files (x86)\Git\bin</em>，找到我们可爱的 <code>bash.exe</code><br><span class=""img-wrap""><img data-src=""/img/bVIvER?w=1847&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>tips：如果文件夹里面不是酱紫的几个文件，请更新下 <code>git</code>，填坑，大家请踩我通过..</p></blockquote>
<h3>集成</h3>
<p>打开 <code>VSC</code>，点击 <em>文件 -&gt; 首选项 -&gt; 用户设置</em>，复制并粘贴下面的内容</p>
<pre><code>{
    ""terminal.integrated.shell.windows"": ""C:\\Program Files (x86)\\Git\\bin\\bash.exe"" // 这里是我电脑上bash.exe的路径
}</code></pre>
<p>保存重启下，这下终端里面就能看到当前的 <code>branch</code> 了。<br><span class=""img-wrap""><img data-src=""/img/bVIvGk?w=1839&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", vscode集成git bash,1531977880,499,1,535,1,1,https://segmentfault.com/a/1190000008185938
154,1,0,7,"
                    
<blockquote><h3>Vue.js 实战系列讲座</h3></blockquote>
<ul>
<li><p><a href=""https://segmentfault.com/l/1500000009448056"" rel=""nofollow noreferrer"">Vue.js 实战之组件篇</a></p></li>
<li><p><a href=""https://segmentfault.com/l/1500000009448189"" rel=""nofollow noreferrer"">Vue.js 实战之工程篇</a></p></li>
<li><p><a href=""https://segmentfault.com/l/1500000010070434"" rel=""nofollow noreferrer"">Vue.js 实战之插件篇</a></p></li>
<li><p><a href=""https://segmentfault.com/l/1500000008892728"" rel=""nofollow noreferrer"">Vue.js 实战之 Render 函数</a></p></li>
<li><p><a href=""https://segmentfault.com/l/1500000008614960"" rel=""nofollow noreferrer"">基于 Vue.js 2.x 的 iView 组件开发实践</a></p></li>
</ul>
<hr>
<blockquote>
<p>2016年工作中做过最自豪的两件事情：</p>
<ul>
<li><p>把 Vue.js 和 Webpack 技术栈引进公司并逐步成为前端规范；</p></li>
<li><p>开源 <a href=""https://github.com/iview/iview"" rel=""nofollow noreferrer"">iView</a> 项目。</p></li>
</ul>
</blockquote>
<h1>初识 Vue</h1>
<h2>第一次接触</h2>
<p>使用 Vue.js 已经有一年半时间了，在接触 Vue 之前，有写过半年多的 Angular，所以刚了解 Vue 时，与很多开发者一样，认为 Vue 是一个轻量级的或是移动端的 ng，就好比 zepto 之于 jQuery。直到 15 年 10 月，打算用 Vue 开发一个个人项目时，才开始认真地学习它，发现 Vue 的使用方法和 API 设计如此优美简洁，而且中文文档甚是详细，我觉得这也是 Vue 受很多中国开发者喜爱的原因，许多初中级开发者、英文不好的、jQ导向的，在刚接触 MVVM 时，这点很有价值，再者 Vue 的使用和学习门槛相比 ng 和 React 的要求都要低，概念理解起来也容易。</p>
<p>比起 Angular，Vue 最大的特点就是对数据双向绑定这件事处理的很优雅。ng 中你需要注入依赖服务，比如 $scope 和 $rootScope，变量写起来也散落在各处，而且有时候还得用 $apply 来告知，这对于很多初学者来说是很麻烦的事情。我以前是写 jQuery 的，所以还是喜欢用 jQ 的很多东西，比如 ajax，而 Vue 在数据使用上很灵活，可以引用外部变量，可以在各种情况下直接修改，不需要额外的工作，所以当看到 Vue 双向绑定这一特性时，就决定尝试用它了。</p>
<h2>一个人搞了一个产品</h2>
<p>从 14 年毕业到 15 年底，就一直在两个规模不大的创业团队工作，先后做了 5 款产品，都是 App，涉及的面也很广，比如 Canvas、Hybrid 什么的。在初创团队工作就像打了鸡血一样，每天早上起床都迫不及待地开始写代码，对工作的热爱绝对不是只把它当做一件赚钱的事情，所有人都是有理想和技术追求的，所以那段时间我做的东西都很用心、精致。</p>
<p>两年的创业经历也把我锻炼成了一个对产品有理解、追求细节、美观的一个人。</p>
<p>从 15 年中旬开始，由于项目需要，我开始接触 Python，这也是我第一次接触后端语言，以前对服务端的开发是一点不懂的。不知道是 Python 本身的原因，还是我理解的快，上手其实并不难，而且没多久就已经可以熟练的写起来了（现在接触的东西多了，觉得那时学习的快，是有一套很好的架构和有人带，先能写，然后慢慢了解其中奥妙，这种办法对于程序员掌握一门新技术还是很有效的）。</p>
<p>我相信但凡写过 Python 的人，都会用优雅来形容它，比如一行代码带有循环的赋值：</p>
<pre><code class=""python"">user_hash = dict((str(user.id), user.to_base_dict()) for user in users)</code></pre>
<p>其实写后端和写前端，很多地方是想通的，只是概念上有区别。只不过后端专注在数据的获取、缓存和整理上，加以各种服务，前端则在获取数据、整理数据、可视化数据。</p>
<p>学会了 Python，发现这个时候可以自己独立做一点东西了，于是就有了 <strong>一个人搞了一个产品</strong> 。不卖关子了，这个产品就是 <a href=""https://www.talkingcoder.com/"" rel=""nofollow noreferrer"">TalkingCoder</a>，从产品、设计、前端、后端、运维、iOS &amp; Android 客户端，几乎都是我一人撸的了，只不过在写移动 App 时，有两位兄弟帮忙写了个壳。</p>
<p>从产品和技术复杂度上，TalkingCoder 很接近 知乎 和 Segmentfault，基于关注内容推荐的 Feed 流、文章、提问（最佳实践）。看一下用到的技术栈：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008168187?w=1830&amp;h=818"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>后端当然是基于 Python 了，主要用 <strong>Tornado</strong> 框架提供 Framework 和 WebService 及 APIService（也巧，貌似 知乎 和 Segmentfault 也用的Tornado）。Tornado 是一个单线程、单进程、非阻塞式的 Web框架，性能很不错。<strong>Sqlalchemy</strong> 提供 ORM（Model层），这东西很好，尤其是对于我这样不太擅长写 sql 的人。<strong>Celery</strong> 提供了 worker ，完成一些不影响用户使用的定时任务（统计）、耗时任务（发邮件）等，通过异步，不阻塞主线程。<strong>Redis</strong> 主要用于存储用户的 token，数据库用的是 MySQL（阿里云RDS），同时还用了下阿里云的 SLB 负载均衡（其实没有什么好均衡的，量又到不了知乎那级别，主要还是做https的支持和域名绑定，对Nginx不是很熟，17年要学一下了，毕竟 SLB 的费用一年也好几百呢?）。</p>
<p>前端相对还是比较传统，没有完全使用 前后端分离 ，Vue 也没有用到组件和组件化，主要原因还是刚学 Vue，没有深入到组件，所以路由和页面渲染，甚至html模块都是 Tornado 完成的。任何技术都需要循序渐进，如果现在再写一遍，肯定不是这套架构，但在当时，这的确是最好的技术方案。但是服务端渲染也是有好处的，比如 SEO、页面打开速度，前端再怎么优化，也没有直接服务端渲染好 HTML 来得快。</p>
<p>iOS 和 Android App 是在 web 版全部完成后开发的，当时找了两个对技术有追求的 iOS 和 Android 的小伙伴帮忙搭了壳，定制了一些 UI 和 Bridge 接口，iOS 用的 UIwebview，本打算用 WKwebview，但测试下来很多地方效果不是很理想，最终还是选择了较为成熟的 UIwebview。整个移动端开发过程大概2个多月吧，也是基于 Vue + Gulp + Swiper 的，体验还算不错，尤其在 iOS 上。</p>
<p>运维是我的短板，Linux 不怎么熟，所以很尴尬的就是一开始只能在自己电脑上玩，到了 ECS 上就蒙了。好在 TalkingData 大牛有的是，折腾了一周，所有的环境和库都装好了，找人帮忙写了个 shell，就这样上线了，上线后，就再没断过。</p>
<p>前前后后开发了有近半年，服务上线也快一年了，这套架构从没出现过故障和报警，唯独一次重启机器把 Redis 数据丢失了。这个项目让我对 全栈 有了更深的理解，但凡是后端的会点 Angular，前端的会写写 Node.js ，都不完全是全栈，全栈应该是能理解整个产品的命脉，并把它最终实现出来，安全运行。</p>
<h2>推广 Vue</h2>
<p>我是 15 年双十一那天加入 <strong>TalkingData</strong> 的。TalkingData 仍然还是创业公司，但规模和影响力要比我之前的两家大很多，在大数据领域，更是领先者。</p>
<p>在这里，前端团队都统称为可视化，因为我们是跟数据打交道。其实 TD 几年前是没有专门的前端团队的，由于历史问题，很多产品线都还是较老的技术，公司的核心技术在大数据处理能力上，前端页面很多都是写 Java 的同事做的，用的最多的自然是 Angular（知道 ng 背景的肯定了解其中的原因?）。</p>
<p>我刚来时，做的是一个基于百度地图 overlay 的大数据地理可视化框架 TDMap（各种原因尚未开源），贴几张图感受下吧：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008168188?w=1200&amp;h=767"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>之后就是我的第一个业务类项目了，也是全面运用 TDMap。当时用的是 TD 自研的一套组件引擎和 jQuery。这个项目到最后做权限系统时，才开始接入 Vue.js ，这应该是 TD 首次使用 Vue，不过当时也有限制，只用它做简单的双向绑定，但仅此一点，开发效率已经提高很多了。</p>
<p>在一个公司推广一项技术栈也是有难度和技巧的，因为不同的人思考问题的角度可能会不同。新的东西一方面会增加学习成本，一方面对它潜在的问题是未知的，如果暴露出了问题或性能瓶颈，是否能够处理或应急方案，尤其是选择开源框架时，社区影响力、维护和持续开发都是考虑的因素。好在 Vue.js 给我们带来了很多惊喜，社区反响也不错，一句话就是用着放心。</p>
<p>既然尝到了 Vue.js 带来的甜头，就要把它推广起来，提高整个前端团队的开发效率。</p>
<h1>Webpack，又一前端神器</h1>
<p>如果只是用 Vue.js 的基本功能，那其实只利用了20%的特性。<br>推广 webpack 这一过程是缓慢的，因为开始和很多人一样，以为又是个和 Gulp 类似的工具，所以有段时间仍然是使用 Vue + Gulp + jQuery 的技术栈，已经开始使用 Vue 的组件，但还没有组件化。这样写的多了，问题就暴露了：</p>
<ul>
<li><p>每个组件需要手动拆分html 、 js、 css 部分，维护成本高；</p></li>
<li><p>html 需预先加载，所以会看到一个页面有一大坨的html</p></li>
</ul>
<p>业务第一，一开始也就没有在意工作流，虽然麻烦，但也撑了几个小项目。直到一个机会开始做 <a href=""https://www.talkingdata.com/product-MarketingCloud.jsp?languagetype=zh_cn"" rel=""nofollow noreferrer"">MarketingCloud营销云</a>，才开始彻底学习 webpack，好在项目初期不太紧张，有了一周多过渡时间来搭建。</p>
<p>我觉得 webpack 的难点在于概念，因为你在开发时写的代码，并不是最终呈现的代码。这对于传统技术栈来说思维切换还是需要成本的，因此有了一个概念：编译。<br>说到底，webpack 就是一个 .js 配置文件，你的架构或好或差，都体现在这一个配置里，随着需求的不断出现，工程也是逐渐完善的，一口吃不成胖子。这里也分享一下 TalkingData 用到的工程配置：<br><a href=""https://github.com/icarusion/vue-vueRouter-webpack"" rel=""nofollow noreferrer"">https://github.com/icarusion/vue-vueRouter-webpack</a><br>关于 webpack 的技术介绍就不多扯了，掘金上有很多不错的文章，不过也推荐我之前写的几篇：</p>
<ul>
<li><p><a href=""https://www.talkingcoder.com/article/6310080842228107877"" rel=""nofollow noreferrer"">Vue+Webpack开发可复用的单页面富应用教程（配置篇）</a></p></li>
<li><p><a href=""https://www.talkingcoder.com/article/6310724958473489215"" rel=""nofollow noreferrer"">Vue+Webpack开发可复用的单页面富应用教程（组件篇）</a></p></li>
<li><p><a href=""https://www.talkingcoder.com/article/6310756346094488391"" rel=""nofollow noreferrer"">Vue+Webpack开发可复用的单页面富应用教程（技巧篇）</a></p></li>
</ul>
<p>这一年下来，这套架构在多个项目中得到了验证，工作效率自然是提升了不少，也奠定了我们前端团队的开发规范，Vue 的推广，至此算是非常成功了。</p>
<h1>iView，把开发效率再提高50%</h1>
<p>经常混掘金的小伙伴，应该对 iView 不陌生吧！再贴一下地址：<br><strong><a href=""https://github.com/iview/iview"" rel=""nofollow noreferrer"">https://github.com/iview/iview</a></strong><br>也感谢大家的关注与支持，iView 的 1.0 工作马上就结束了，计划的 43 个组件，现在已经完成 41 个了，我们也承诺过，在 1.0 发布后，会在 17 年初支持到 Vue2.x。<br>关于 iView 的介绍和使用，这里就不多说了，可以看看下面三篇文章，这里主要还是想说说关于它的一些故事和开源的经历。</p>
<ul>
<li><p><a href=""https://gold.xitu.io/post/581ee7de128fe1005a06dd34"" rel=""nofollow noreferrer"">Vue高效UI组件库—iView开发实践</a></p></li>
<li><p><a href=""https://gold.xitu.io/post/5843dcad128fe100577876e1"" rel=""nofollow noreferrer"">Vue中你不知道但却很实用的黑科技</a></p></li>
<li><p><a href=""https://gold.xitu.io/post/5859c5fab123db0065926723"" rel=""nofollow noreferrer"">项目进展快，全靠 iView 带 | 掘金技术征文</a></p></li>
</ul>
<p>发起这个项目的初衷，是公司举办的一次创新项目活动，当时团队正好也需要一套自己的 UI 组件库，于是就申请了，从此就信心满满地开始了来源之旅，那时是 16 年 7月。</p>
<p>时间过得真是快，都开发 半年 了，也收获了近 3000 ★。因为是第一次做开源项目，对 Github、npm 的很多东西还不了解，虽然平时都在用，但却没发布过。慢慢地知道了什么是 <code>.gitattributes</code>、<code>.npmignore</code>、<code>.travis.yml</code>、<code>.eslintrc.json</code>，也了解了 MIT、Apache Licence 2.0 开源协议，涨了不少姿势。</p>
<p>iView 在一开始时，还是暴露了很多问题，比如必须通过 webpack 才可以使用，而且还得配置 babel，否则无法编译 <code>node_modules/iview</code> 下的文件，就这一个简单的配置，折腾了很久，因为不同平台不同版本，写法不一样。后来在 <a href=""https://github.com/jingsam"" rel=""nofollow noreferrer"">@jingsam</a> 的 contribution 下，优化了 iView 编译过程，最终不再依赖 webpack，也不需要配置 babel，在此特别感谢下 jingsam，虽从未见面，却对技术有着同样的追求。</p>
<p>iView 基本是我一个人在开发和维护，不过有一位在美国上大学的同学也多次贡献代码，我们的沟通似乎并没有时差的概念，因为他基本很晚才睡，夜猫子类型的 <a href=""https://github.com/rijn"" rel=""nofollow noreferrer"">@rijn</a>，在此也特别感谢。</p>
<p>iView 的 contributors 并不多，也借此机会，希望更多对技术有追求的朋友能参与到 iView 2.0 的开发中，把它一起做好。</p>
<p>因为太想把 iView 做好，所以在写每个组件前，都看了很多别人的实现，比如 Element UI、vue-antd、AntDesign、vue-beauty 等，这个过程学到了很多东西，看别人代码的确是最快最有效的学习方法，因为有时候思路会被限制，看看别人的实现，才能打开思路，多加对比，也能知道几者之间的差距。</p>
<p>现在公司最核心的服务 — 应用统计分析已经开始用 iView 重构了，相信在 2017 年，iView 也会像 Vue 和 Webpack 一样，被很多项目验证。</p>
<h1>后记</h1>
<p>16 年可以说是工作以来进步最大的一年了，学习了很多前沿的技术，也做了不少东西，但做技术的就是这样，接触的越多，越能感到自己的渺小，17 年继续加油吧！</p>
<p><strong>作者：梁灏</strong><br><strong>文章首发于掘金，未经许可，禁止转载</strong></p>

                ", 2016 我的心路历程：从 Vue 到 Webpack 到 iView,1531977881,134,1,558,1,1,https://segmentfault.com/a/1190000008168184
155,1,0,7,"
                    
<p>项目地址：<a href=""https://github.com/marktony/Awesome_API"" rel=""nofollow noreferrer"">https://github.com/marktony/A...</a></p>
<p>本页仅收集国内部分官方API，如需查看其他版本，请点击<a href=""https://github.com/marktony/Awesome_API"" rel=""nofollow noreferrer"">这里</a>。</p>
<h3>目录</h3>
<ul>
<li><p><a>笔记</a></p></li>
<li><p><a>出行</a></p></li>
<li><p><a>词典</a></p></li>
<li><p><a>电商</a></p></li>
<li><p><a>地图</a></p></li>
<li><p><a>电影</a></p></li>
<li><p><a>即时通讯</a></p></li>
<li><p><a>开发者网站</a></p></li>
<li><p><a>快递查询</a></p></li>
<li><p><a>旅游</a></p></li>
<li><p><a>社交</a></p></li>
<li><p><a>视频</a></p></li>
<li><p><a>天气</a></p></li>
<li><p><a>图片与图像处理</a></p></li>
<li><p><a>外卖</a></p></li>
<li><p><a>消息推送</a></p></li>
<li><p><a>音乐</a></p></li>
<li><p><a>云</a></p></li>
<li><p><a>语音识别</a></p></li>
<li><p><a>综合</a></p></li>
</ul>
<h4>笔记</h4>
<ul>
<li><p><a href=""http://www.wiz.cn/manual/plugin/"" rel=""nofollow noreferrer"">为知笔记</a> - 为知笔记Windows客户端开放了大量的API，其中绝大部分，都通过COM提供，可以在javascript, C#, C++, Delphi等语言中使用。接口通过IDL(Interface description language)语言描述。</p></li>
<li><p><a href=""https://dev.yinxiang.com/"" rel=""nofollow noreferrer"">印象笔记</a> - 印象笔记提供了ActionScript 3, Android, C++, Windows, iOS, Java, JavaScript, OS X, Perl, PHP, Python, Ruby等平台的SDK和完整的API参考文档，可通过API进行认证，笔记，笔记本，附件，搜索，同步等操作，同时提供企业版和本地API。</p></li>
<li><p><a href=""http://note.youdao.com/open/"" rel=""nofollow noreferrer"">有道云笔记</a> - 有道云笔记提供了Android SDK，同时Open API允许进行授权，用户，笔记本，笔记，分享，附件等方面的操作。</p></li>
</ul>
<h4>出行</h4>
<ul>
<li><p><a href=""http://open.xiaojukeji.com/"" rel=""nofollow noreferrer"">滴滴</a> - 滴滴提供了iOS和Android SDK, 可实现拉起滴滴叫车等方面的操作。</p></li>
<li><p><a href=""http://developerpre.10101111.com/"" rel=""nofollow noreferrer"">神州专车</a> - 神州专车提供了API模式和H5模式两种接入模式，允许进行基础信息，订单，支付，充值，用户，发票，代金券，企业等方面的操作。</p></li>
<li><p><a href=""https://developer.uber.com/"" rel=""nofollow noreferrer"">Uber</a> - Uber提供了Android和iOS的SDK,允许进行乘客，行程体验，司机，派送次数等四大方面的操作。</p></li>
</ul>
<h4>词典</h4>
<ul>
<li><p><a href=""http://api.fanyi.baidu.com/api/trans/product/index"" rel=""nofollow noreferrer"">百度翻译</a> - 百度翻译支持多种语言互相翻译，包含PHP, JS, Python, C, Java版Demo。</p></li>
<li><p><a href=""https://www.microsoft.com/en-us/translator/translatorapi.aspx"" rel=""nofollow noreferrer"">必应词典</a> - 微软翻译API支持文字和语音两种类型，支持多种语言互相翻译，提供C#版本Demo。</p></li>
<li><p><a href=""http://open.iciba.com/?c=api"" rel=""nofollow noreferrer"">金山词霸</a> - 金山词霸允许进行简单的翻译操作。</p></li>
<li><p><a href=""https://www.shanbay.com/help/developer/api_v1/"" rel=""nofollow noreferrer"">扇贝</a> - 扇贝提供了完整的API，允许进行用户，查询，添加学习记录，忘记单词，例句，笔记等方面的操作。</p></li>
<li><p><a href=""http://fanyi.youdao.com/openapi"" rel=""nofollow noreferrer"">有道词典</a> - 有道词典允许进行简单的翻译操作。</p></li>
</ul>
<h4>电商</h4>
<ul>
<li><p><a href=""http://open.dangdang.com/"" rel=""nofollow noreferrer"">当当</a> - 当当允许商家用户和网站接入授权，可进行商品，订单，图片，问答，店铺和促销等方面的操作。</p></li>
<li><p><a href=""https://jos.jd.com/api/index.htm"" rel=""nofollow noreferrer"">京东</a> - 京东提供了Java, PHP, .net的SDK，授权后可进行多种操作。</p></li>
<li><p><a href=""http://open.suning.com/ospos/apipage/toApiListMenu.do"" rel=""nofollow noreferrer"">苏宁开放服务</a> - 苏宁提供了Java, PHP, .Net, Python版本的SDK，授权后可进行多种操作。</p></li>
<li><p><a href=""https://open.taobao.com/doc2/api_list.htm"" rel=""nofollow noreferrer"">淘宝开放平台</a> - 淘宝提供了Java, .Net, PHP, Python版本的SDK，授权后提供多种操作。</p></li>
<li><p><a href=""https://developer.amazon.com/public/zh"" rel=""nofollow noreferrer"">亚马逊</a> - 亚马逊提供多种语言版本的SDK，授权后允许多种操作。</p></li>
</ul>
<h4>地图</h4>
<ul>
<li><p><a href=""http://lbsyun.baidu.com/"" rel=""nofollow noreferrer"">百度地图</a> - 百度地图提供了Android, iOS版本的SDK和JavaScript API，可进行定位、地图、数据、出行、鹰眼轨迹和分析服务。</p></li>
<li><p><a href=""http://lbs.amap.com/"" rel=""nofollow noreferrer"">高德地图</a> - 高德地图提供了JavaScript和web服务API，Android和iOS SDK，支持地图，定位，搜索，路线规划，导航和室内地图等。</p></li>
<li><p><a href=""http://lbs.qq.com/"" rel=""nofollow noreferrer"">腾讯地图</a> - 腾讯地图提供了JavaScript API，Android和iOS SDK，支持定位，地图，地点搜索，路线和导航等。</p></li>
<li><p><a href=""http://lbs.tianditu.com/api-new/home.html"" rel=""nofollow noreferrer"">天地图</a> - 天地图提供了H5 API和JavaScript API等web API，同时提供了Android和iOS SDK，支持基础地图服务，图层管理，地图覆盖物，地图工具，地名搜索和出行规划服务。</p></li>
<li><p><a href=""http://open.mapbar.com/"" rel=""nofollow noreferrer"">图吧地图</a> - 图吧提供了JavaScript和Flash API，Android和iOS SDK，支持定位，地址解析，位置标注，位置截图，路线规划，周边查询，兴趣点搜索和在线导航。</p></li>
</ul>
<h4>电影</h4>
<ul><li><p><a href=""https://developers.douban.com/wiki/?title=movie_v2"" rel=""nofollow noreferrer"">豆瓣电影</a> - 豆瓣电影支持电影条目，影人条目，搜索和榜单等。</p></li></ul>
<h4>即时通讯</h4>
<ul>
<li><p><a href=""http://www.easemob.com/"" rel=""nofollow noreferrer"">环信</a> - 支持Android, iOS, WebIM, Linux, REST集成，支持多种消息类型。</p></li>
<li><p><a href=""http://rongcloud.cn/"" rel=""nofollow noreferrer"">融云</a> - 支持Android, iOS, Web, 游戏集成，支持多种消息类型。</p></li>
<li><p><a href=""http://netease.im/"" rel=""nofollow noreferrer"">网易云信</a> - 支持IM实时通讯，实时音视频，教学白班，专线电话，短信，聊天室，提供iOS, Android, Windows和Web SDK。</p></li>
<li><p><a href=""https://www.qcloud.com/product/im"" rel=""nofollow noreferrer"">腾讯云通信IM</a> - 提供iOS, Android, Windows和Web SDK，支持多种消息类型。</p></li>
</ul>
<h4>开发者网站</h4>
<ul>
<li><p><a href=""http://gank.io/api"" rel=""nofollow noreferrer"">干货集中营</a> - 提供妹子图和Android, iOS, 前端，拓展资源等内容。</p></li>
<li><p><a href=""https://www.diycode.cc/api"" rel=""nofollow noreferrer"">diycode</a> - 授权后可访问diycode网站的内容。</p></li>
<li><p><a href=""http://www.oschina.net/openapi"" rel=""nofollow noreferrer"">开源中国</a> - 授权后可访问开源中国网站的内容。</p></li>
<li><p><a href=""https://ruby-china.org/api-doc/"" rel=""nofollow noreferrer"">Ruby China</a> - 授权后可访问Ruby China网站的内容。</p></li>
<li><p><a href=""https://www.v2ex.com/p/7v9TEc53"" rel=""nofollow noreferrer"">V2EX</a> - 可访问V2EX网站的内容。</p></li>
</ul>
<h4>快递查询</h4>
<ul>
<li><p><a href=""http://www.aikuaidi.cn/api/"" rel=""nofollow noreferrer"">爱快递</a> - 爱快递支持国内90多家快递物流订单查询服务，免费版有使用次数限制，可用于电子商城单号跟踪,手机应用,微信快递接口等服务。</p></li>
<li><p><a href=""http://www.kuaidi100.com/openapi/"" rel=""nofollow noreferrer"">快递100</a> - 快递100支持300家国内国际快递，免费版有使用次数限制。</p></li>
<li><p><a href=""http://www.kdniao.com/"" rel=""nofollow noreferrer"">快递鸟</a> - 快递鸟支持国内外400多家快递公司，免费版有使用次数限制，包含.Net, PHP, Java版Demo。</p></li>
<li><p><a href=""http://www.kuaidi.com/openapi.html"" rel=""nofollow noreferrer"">快递网</a> - 快递网支持上百家快递查询服务，免费版有使用次数限制。</p></li>
</ul>
<h4>旅游</h4>
<ul>
<li><p><a href=""http://open.qunar.com/"" rel=""nofollow noreferrer"">去哪儿</a> - 支持获取去哪儿网的内容。</p></li>
<li><p><a href=""http://open.tuniu.cn/"" rel=""nofollow noreferrer"">途牛</a> - 支持途牛网的内容，仅开放给供应商系统。</p></li>
<li><p><a href=""http://u.ctrip.com/union/help/Termsofuse.aspx"" rel=""nofollow noreferrer"">携程</a> - 支持携程网的内容。</p></li>
<li><p><a href=""http://open.elong.com/wiki/API%E6%96%87%E6%A1%A3"" rel=""nofollow noreferrer"">艺龙</a> - 支持获取产品数据，完成用户的预订，进行订单查询、更改或取消。提供在线工具，以及H5, Java, C#, PHP, Ruby版本的Demo。</p></li>
</ul>
<h4>社交</h4>
<ul>
<li><p><a href=""https://open-doc.dingtalk.com/"" rel=""nofollow noreferrer"">钉钉</a> - 支持免登，企业通讯录，服务窗，钉盘，地图，会话，DING，电话，音频，扫码，支付，分享等服务，提供SDK和Demo，PC版UI规范，调试工具和钉钉UI组件库。</p></li>
<li><p><a href=""https://developers.douban.com/wiki/?title=guide"" rel=""nofollow noreferrer"">豆瓣</a> - 支持图书，电影，音乐，同城，广播，用户，日记，相册，线上活动，论坛，回复和我去等功能，提供豆瓣组件，豆瓣标示和Demo。</p></li>
<li><p><a href=""http://open.kaixin001.com/document.php"" rel=""nofollow noreferrer"">开心网</a> - 支持用户信息，登录授权，好友，传播应用，支付，分享内容，消息，交互，开心网应用等内容，提供SDK，开源插件和标示素材。</p></li>
<li><p><a href=""http://wiki.connect.qq.com/api%E5%88%97%E8%A1%A8"" rel=""nofollow noreferrer"">QQ互联</a> - 支持用户资料，QQ会员信息，空间相册，腾讯微博资料，分享到腾讯微博，微博好友信息，财付通信息等内容，提供SDK, Demo, 以及设计资源。</p></li>
<li><p><a href=""http://open.weibo.com/wiki/API"" rel=""nofollow noreferrer"">微博</a> - 支持粉丝服务，微博，评论，用户，关系，账号，收藏，搜索，提醒，短链，公共服务，位置服务，地理信息，地图引擎，支付以及OAuth2.0授权等内容，提供微博标示及SDK。</p></li>
<li><p><a href=""https://open.weixin.qq.com/"" rel=""nofollow noreferrer"">微信</a> - 支持移动应用，网站应用，公众账号，公众号第三方平台等内容，提供SDK, Demo, 以及设计资源。</p></li>
</ul>
<h4>视频</h4>
<ul>
<li><p><a href=""http://open.iqiyi.com/"" rel=""nofollow noreferrer"">爱奇艺</a> - 支持弹幕，全色彩播放器，高清码流，视频托管，播放爱奇艺视频，应用分发，IOCP等内容。</p></li>
<li><p><a href=""http://www.lecloud.com/zh-cn/help/api.html"" rel=""nofollow noreferrer"">乐视</a> - 支持标准直播，标准点播，视频发行平台，移动直播等内容，提供SDK下载。</p></li>
<li><p><a href=""http://lm.tv.sohu.com/union/open_platform.do"" rel=""nofollow noreferrer"">搜狐视频</a> - 支持一二级内容获取，内容分类获取，视频详情信息，专辑详情信息，分级列表获取，关键词搜索等内容。</p></li>
<li><p><a href=""http://api.tudou.com/apidoc/index.php/%E9%A6%96%E9%A1%B5"" rel=""nofollow noreferrer"">土豆</a> - 支持视频模块，豆单模块，影视库模块，用户模块，转帖模块，字段定义模块等内容。</p></li>
<li><p><a href=""http://doc.open.youku.com/?spm=0.0.0.0.fOn6ND"" rel=""nofollow noreferrer"">优酷</a> - 支持内容输出，视频搜索，智能推荐，用户登录，用户互动，用户信息，视频上传至优酷，视频互动等内容，提供SDK。</p></li>
</ul>
<h4>天气</h4>
<ul>
<li><p><a href=""http://wiki.swarma.net/index.php/%E5%BD%A9%E4%BA%91%E5%A4%A9%E6%B0%94API/v2"" rel=""nofollow noreferrer"">彩云天气</a> - 支持全球天气数据，两种空气质量数据，天气预报，实况天气，独家降水预报，独家空气质量预报，六种天气数据，四种生活指数数据等内容，部分功能收费。</p></li>
<li><p><a href=""http://www.kancloud.cn/hefengyun/weather/222344"" rel=""nofollow noreferrer"">和风天气</a> - 支持7-10天预报，实况天气，每小时预报，生活指数，灾害预警，景点天气，历史天气，城市查询等内容，仅国内数据免费。</p></li>
<li><p><a href=""http://www.thinkpage.cn/doc"" rel=""nofollow noreferrer"">心知天气</a> - 支持天气实况，逐日预报和历史，24小时逐小时预报，过去24小时天气历史记录，气象灾害预警，空气质量实况与城市排行，逐日和逐小时空气质量预报，过去24小时空气质量历史记录，生活指数，农历、节气、生肖，机动车尾号限行，日出日落，月初月落和月像，城市搜索等内容，仅国内数据免费。</p></li>
</ul>
<h4>图片与图像处理</h4>
<ul>
<li><p><a href=""https://github.com/pinguo/PGSkinPrettifyEngine"" rel=""nofollow noreferrer"">Camera360</a> - 支持全帧率直播美白滤镜，提供SDK和Demo。</p></li>
<li><p><a href=""http://imgsdk.com/"" rel=""nofollow noreferrer"">嗨图</a> - 支持图片标注，仅提供iOS版本SDK。</p></li>
<li><p><a href=""https://dev.camcard.com/?language=zh-cn"" rel=""nofollow noreferrer"">名片全能王</a> - 支持精准识别几十种语言的名片，自动切边并美化名片图像，自动返回识别结果，提供多种版本SDK，收费。</p></li>
<li><p><a href=""http://www.intsig.com/zh/products/camcard_for_id"" rel=""nofollow noreferrer"">企业证件识别</a> - 支持身份证，驾驶证，护照等，收费。</p></li>
<li><p><a href=""https://dev.camscanner.com/?language=zh-cn"" rel=""nofollow noreferrer"">扫描全能王</a> - 支持图像智能剪裁，五种图像增强模式，手动调节图像细节，自动返回扫描结果等，提供iOS与Android版本SDK，收费。</p></li>
<li><p><a href=""http://api1.wozhitu.com/"" rel=""nofollow noreferrer"">我知图</a> - 支持相似图像搜索，图像识别匹配，图像识别关键词推荐，重复图片探测等内容。</p></li>
<li><p><a href=""http://www.intsig.com/zh/products/creditcard"" rel=""nofollow noreferrer"">银行卡|信用卡识别</a> - 提供SDK和API，收费。</p></li>
</ul>
<h4>外卖</h4>
<ul>
<li><p><a href=""http://dev.waimai.baidu.com/"" rel=""nofollow noreferrer"">百度外卖</a> - 支持商户，菜品，商品，订单和基础数据等内容，提供SDK和Demo。</p></li>
<li><p><a href=""http://developer.dianping.com/"" rel=""nofollow noreferrer"">大众点评</a> - 支持商户，团购，在线预定，商品点评，数据统计，元数据等内容。</p></li>
<li><p><a href=""http://openapi.eleme.io/v2/quickstart.html"" rel=""nofollow noreferrer"">饿了么</a> - 支持查询，预定，订单，其他订单，数据推送，支付，评价，活动，账户同步，数据落地同步等内容。</p></li>
<li><p><a href=""http://developer.waimai.meituan.com/doc/show"" rel=""nofollow noreferrer"">美团外卖</a> - 支持门店，配送范围，菜品，药品，订单，订单推送等内容。</p></li>
</ul>
<h4>消息推送</h4>
<ul>
<li><p><a href=""http://push.baidu.com/doc/restapi/restapi"" rel=""nofollow noreferrer"">百度云推送</a> - 支持iOS, Android和服务器端，支持推送，统计，组管理等Rest API接口。服务器端支持Java, Python, PHP, REST API。提供所支持各语言版本的SDK。</p></li>
<li><p><a href=""http://developer.huawei.com/push"" rel=""nofollow noreferrer"">华为推送</a> - 支持Android，提供SDK。</p></li>
<li><p><a href=""https://docs.jiguang.cn/jpush/server/push/rest_api_v3_push/"" rel=""nofollow noreferrer"">极光</a> - 支持Android, iOS, WindowsPhone, 服务器端REST API, 提供Java, Python, PHP, Ruby, C#, Node.js等版本的SDK。</p></li>
<li><p><a href=""https://leancloud.cn/docs/push_guide.html"" rel=""nofollow noreferrer"">LeanCloud</a> - 支持Android, iOS, WindowsPhone和Web网页推送，使用云引擎和JavaScript创建推送，使用REST API推送消息。提供Objectvie-C(开放源码), JavaScript(开放源码), Android, Unity, .Net, WindowsPhone, Java(开放源码), Python(开放源码), PHP(开放源码), C++(开放源码), Swift(开放源码)版本SDK。同时提供Demo。</p></li>
<li><p><a href=""http://xg.qq.com/"" rel=""nofollow noreferrer"">腾讯信鸽</a> - 支持iOS和Android平台，服务器端采用Rest API, 同时服务器端支持Java, PHP, Python等语言并提供SDK。</p></li>
<li><p><a href=""http://dev.xiaomi.com/console/appservice/push.html"" rel=""nofollow noreferrer"">小米</a> - 支持Android和iOS平台，服务器端支持Java, Python并提供SDK。</p></li>
<li><p><a href=""http://dev.umeng.com/push/android/api-doc"" rel=""nofollow noreferrer"">友盟</a> - 支持Android和iOS平台，服务器端支持PHP, Java, Python并提供SDK。</p></li>
</ul>
<h4>音乐</h4>
<ul>
<li><p><a href=""https://developers.douban.com/wiki/?title=music_v2"" rel=""nofollow noreferrer"">豆瓣音乐</a> - 支持音乐信息，评论信息，标签信息，搜索音乐，某个音乐中标记最多的标签，发表、修改、删除评论，用户对音乐的所有标签等内容。</p></li>
<li><p><a href=""https://github.com/kaolafm/api"" rel=""nofollow noreferrer"">考拉FM</a> - 支持获取指定分类下列表和内容，搜索指定关键字内容，专辑/电台/直播详情，指定专辑下列表，指定电台播单，分类下专辑TOP50，指定期(碎片)所在专辑最新分页功能，分类下全部直播计划，版本升级接口，排行榜，精选，传统电台列表/详情/地区等。</p></li>
<li><p><a href=""http://wq.qq.com/"" rel=""nofollow noreferrer"">企鹅FM</a> - 支持获取电台分类列表，电台分类下的专辑信息列表，专辑下节目信息列表，电台节目播放链接，搜索关键字相关主播/专辑/节目，主播名下专辑，特定时间段内新增主播/更新的专辑/新增的专辑等。</p></li>
<li><p><a href=""http://open.qingting.fm/"" rel=""nofollow noreferrer"">蜻蜓FM</a> - 支持OAuth2.0授权，音频数据中心，分类，点播，直播，临时直播，排行榜，搜索，内容更新状态，主播，此刻，专题，活动等内容。</p></li>
<li><p><a href=""http://open.ximalaya.com/index"" rel=""nofollow noreferrer"">喜马拉雅FM</a> - 支持Android和iOS平台，并提供相应的SDK和Demo，具体支持内容请下载相关文件查看。</p></li>
</ul>
<h4>云</h4>
<ul>
<li><p><a href=""https://develop.aliyun.com/api?spm=5176.8142029.388261.274.4FJSwV"" rel=""nofollow noreferrer"">阿里云</a> - 支持弹性计算，数据库，存储与CDN，网络，应用服务，域名与网站等类别的内容，并提供了相关SDK。</p></li>
<li><p><a href=""https://cloud.baidu.com/doc/index.html"" rel=""nofollow noreferrer"">百度云</a> - 支持计算和网络，存储和CDN，数据库，安全和管理，数据分析，智能多媒体服务，物联网服务，人工智能，应用服务，网站服务，数字营销服务等内容，并提供相关的SDK。</p></li>
<li><p><a href=""http://www.bmob.cn/"" rel=""nofollow noreferrer"">Bmob</a> - 支持云数据库，容器服务，消息推送，文件存储，短信验证码，及时通讯，云端逻辑，定时任务，地理位置等。</p></li>
<li><p><a href=""https://leancloud.cn/"" rel=""nofollow noreferrer"">LeanCloud</a> -     支持云存储，数据分析，用户关系，实时通讯，消息推送，移动统计等。</p></li>
<li><p><a href=""http://www.qiniu.com/"" rel=""nofollow noreferrer"">七牛云</a> - 支持对象存储，融合CDN，直播云，数据处理等。</p></li>
<li><p><a href=""https://www.qcloud.com/doc/api"" rel=""nofollow noreferrer"">腾讯云</a> - 支持计算，网络，存储与CDN，数据库，安全服务，监控与管理，域名服务，视频服务，大数据与AI等内容，提供相关SDK。</p></li>
<li><p><a href=""https://www.wilddog.com/"" rel=""nofollow noreferrer"">野狗</a> - 支持实时数据同步，实时视频通话，及时通讯，短信，身份认证等。</p></li>
</ul>
<h4>语音识别</h4>
<ul>
<li><p><a href=""http://yuyin.baidu.com/"" rel=""nofollow noreferrer"">百度语音</a> - 支持全平台REST API, 离线在线融合模式，深度语义解析，场景识别定制，自定义上传语料、训练模型，基础服务永久免费。提供相应SDK和Demo应用。</p></li>
<li><p><a href=""http://openspeech.sogou.com/Sogou/php/index.php"" rel=""nofollow noreferrer"">搜狗语音云开放平台</a> - 支持在线/离线语音识别，在线听歌识曲，离线语音合成等内容。提供相应平台SDK。</p></li>
<li><p><a href=""http://www.xfyun.cn/"" rel=""nofollow noreferrer"">讯飞开放平台</a> - 支持语音听写/转写，在线/离线命令词识别，语音唤醒等内容，平台支持广泛，提供相应SDK。</p></li>
</ul>
<h4>综合</h4>
<ul>
<li><p><a href=""http://www.avatardata.cn/Docs"" rel=""nofollow noreferrer"">阿凡达数据</a> - 支持金融股票，充值认证，便民类，新闻文章，医药交通，科教文艺，创意数据，及时通讯等内容。</p></li>
<li><p><a href=""http://www.alidayu.com/"" rel=""nofollow noreferrer"">阿里大于</a> - 支持验证码，短信通知，语音通知，流量钱包充值，私密专线，群发助手等内容。</p></li>
<li><p><a href=""https://www.apix.cn/"" rel=""nofollow noreferrer"">APiX</a> - 支持基础征信数据，信用分析服务，支付缴费接口等数据，部分免费。</p></li>
<li><p><a href=""http://apistore.baidu.com/"" rel=""nofollow noreferrer"">百度API STORE</a> - 支持多种类型数据，部分免费，提供SDK。</p></li>
<li><p><a href=""http://www.haoservice.com/"" rel=""nofollow noreferrer"">HaoService</a> - 支持多种类型数据。</p></li>
<li><p><a href=""https://www.juhe.cn/"" rel=""nofollow noreferrer"">聚合数据</a> - 支持多种类型数据，部分免费。</p></li>
<li><p><a href=""https://m.datayes.com/"" rel=""nofollow noreferrer"">通联数据</a> - 提供金融类数据，支持免费试用。</p></li>
</ul>

                ", 国内值得关注的官方API集合,1531977883,389,1,431,1,1,https://segmentfault.com/a/1190000008149811
156,1,0,7,"
                    
<p>源码：<a href=""https://github.com/treadpit/wx_calendar"" rel=""nofollow noreferrer"">https://github.com/treadpit/wx_calendar</a></p>
<h3>思路分析</h3>
<p>要实现一个简单的日历，需要先知道几个值：</p>
<ul>
<li>每月有多少天</li>
<li>每月第一天、最后一天各星期几</li>
<li>每月1号之前应有多少天属于上一个月</li>
<li>每月最后一天之后应有多少天属于下一个月</li>
</ul>
<blockquote>每月最多31天，最少28天。</blockquote>
<h3>日历模板引入</h3>
<blockquote>日历模板面板支持 <strong><em>手势左右滑动</em></strong>；</blockquote>
<p>提供 <code>template</code> <a href=""https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/template.html"" rel=""nofollow noreferrer"">模板引入</a></p>
<h4>1. 引入<code>wxml</code>及<code>wxss</code>
</h4>
<pre><code class=""xml"">// example.wxml
&lt;import src=""../../template/calendar/index.wxml""/&gt;
&lt;view class=""calendar-wrap""&gt;
   &lt;template is=""calendar"" data=""{{...calendar}}"" /&gt;
&lt;/view&gt;</code></pre>
<pre><code class=""css"">/* example.wxss */
@import '../../template/calendar/index.wxss';</code></pre>
<h4>2. 日历组件初始化</h4>
<pre><code class=""js"">import initCalendar from '../../template/calendar/index';
const conf = {
  onShow: function() {
    initCalendar(); // 使用默认配置初始化日历
  }
};
Page(conf);</code></pre>
<h4>3. 日历组件配置</h4>
<p><code>initCalendar()</code> 可传入自定义配置</p>
<pre><code class=""js"">  import initCalendar from '../../template/calendar/index';

  const conf = { 
    multi: true, // 是否开启多选,
    disablePastDay: true, // 是否禁选过去日期
    /**
     * 选择日期后执行的事件
     * @param { object } currentSelect 当前点击的日期
     * @param { array } allSelectedDays 选择的所有日期（当mulit为true时，才有allSelectedDays参数）
     */
    afterTapDay: (currentSelect, allSelectedDays) =&gt; {},
    /**
     * 日期点击事件（此事件会完全接管点击事件）
     * @param { object } currentSelect 当前点击的日期
     * @param { object } event 日期点击事件对象
     */
    onTapDay(currentSelect, event) {},
    /**
     * 日历初次渲染完成后触发事件，如设置事件标记
     */
    afterCalendarRender() {},
  }

  initCalendar(conf);</code></pre>
<h4>4. <code>jumpToToday()</code>，跳转至今天；</h4>
<h4>5. 待办事项</h4>
<h5>5.1 设置日期待办事项标记 <code>setTodoLabels</code>；</h5>
<pre><code class=""js"">  import { setTodoLabels } from '../../template/calendar/index';

  setTodoLabels({
    pos: 'bottom',
    dotColor: '#40',
    days: [{
      year: 2018,
      month: 5,
      day: 12,
    }, {
      year: 2018,
      month: 5,
      day: 15,
    }],
  });</code></pre>
<h5>5.2 删除指定日期待办事项标记 <code>deleteTodoLabels</code>；</h5>
<pre><code class=""js"">  import { deleteTodoLabels } from '../../template/calendar/index';

  deleteTodoLabels([{
    year: 2018,
    month: 5,
    day: 12,
  }, {
    year: 2018,
    month: 5,
    day: 15,
  }]);</code></pre>
<h5>5.3 清空所有日期待办事项标记 <code>clearTodoLabels()</code>；</h5>
<h4>6. 周月视图切换 <code>switchView('week')</code>，默认值为'month'；</h4>
<pre><code class=""js"">
  import { switchView } from '../../template/calendar/index';
  // 切换为周视图
  switchView('week');

  // 切换为月视图
  switchView();
  // 或者
  switchView('month');</code></pre>
<h3>日历选择器模板引入</h3>
<blockquote>日历模板面板支持 <strong><em>手势左右滑动</em></strong>；<p>此 <code>template</code> 带有 <code>input</code> 输入框，不影响模板的使用，可配置隐藏；</p>
<p>日期选择 input 组件支持直接输入指定日期；</p>
</blockquote>
<h4>1. 引入<code>wxml</code>及<code>wxss</code>
</h4>
<pre><code class=""xml"">// example.wxml
&lt;import src=""../../template/datepicker/index.wxml""/&gt;

&lt;view class=""datepicker-box""&gt;
    &lt;template is=""datepicker"" data=""{{...datepicker}}"" /&gt;
&lt;/view&gt;</code></pre>
<pre><code class=""css"">/* example.wxss */
@import '../../template/datepicker/index.wxss';</code></pre>
<h4>2. 日期选择器初始化</h4>
<pre><code class=""js"">import initDatepicker from '../../template/datepicker/index';
const conf = {
  onShow: function() {
    initDatepicker(); // 使用默认配置初始化日历选择器
  },
};
Page(conf);</code></pre>
<h4>3. 日期选择器配置</h4>
<pre><code class=""js"">  import initDatepicker from '../../template/datepicker/index';

  const conf = {
    disablePastDay: true, // 是否禁选过去日期
    showInput: false, // 默认为 true
    placeholder: '请选择日期', // input 输入框
    type: 'normal', // [normal 普通单选模式(默认), timearea 时间段选择模式(待开发), multiSelect 多选模式(待完善)]

    /**
     * 选择日期后执行的事件
     * @param { object } currentSelect 当前点击的日期
     */
    afterTapDay: (currentSelect) =&gt; {},

    /**
     * 日期点击事件（此事件会完全接管点击事件）
     * @param { object } currentSelect 当前点击的日期
     * @param {object} event 日期点击事件对象
     */
    onTapDay(currentSelect, event) {},
  }

  initDatepicker(conf);</code></pre>
<h4>4. <code>jumpToToday()</code>，跳转至今天；</h4>
<pre><code class=""js"">import { getSelectedDay, jumpToToday } from '../../template/datepicker/index';

jumpToToday();
</code></pre>
<h4>日历模板效果图</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015584305?w=317&amp;h=569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""日历效果图"" title=""日历效果图""></span></p>
<h4>日期选择器效果图</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015584306?w=317&amp;h=566"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""日期选择器"" title=""日期选择器""></span></p>

                ", 微信小程序-日历,1531977884,565,1,939,1,1,https://segmentfault.com/a/1190000008054872
157,1,0,7,"
                    
<h1>wx_selectArea</h1>
<p>地址联动选择器采用微信小程序的 <code>picker-view</code> 组件</p>
<h3>模板引入</h3>
<p>提供 <code>template</code> <a href=""https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/template.html"" rel=""nofollow noreferrer"">模板引入</a></p>
<ol><li>引入<code>wxml</code>及<code>wxss</code>
</li></ol>
<pre><code class=""xml"">// example.wxml
&lt;import src=""../../template/index.wxml""/&gt;
&lt;template is=""areaPicker"" data=""{{...areaPicker}}"" /&gt;

// example.wxss
@import '../../template/index.wxss';</code></pre>
<ol><li>组件初始化</li></ol>
<pre><code class=""js"">// example.js

import initAreaPicker, { getSelectedAreaData } from '../../template/index';
Page({
    onShow() {
      initAreaPicker({
        // hideDistrict: true, // 是否隐藏区县选择栏，默认显示
      });
    },
    getSelecedData() {
        console.table(getSelectedAreaData()); // 提供`getSelectedAreaData`方法，返回当前选择的省市区信息组成的数组
    }
});
</code></pre>
<h3>截图</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013344903?w=2582&amp;h=1192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""省市区选择器"" title=""省市区选择器""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013344904?w=374&amp;h=665"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""省市区选择器"" title=""省市区选择器""></span></p>
<h4>旧版</h4>
<blockquote>小程序不支持 <code>picker-view</code> 组件时，用 <code>scroll-view</code> 模拟的联动选择器（不再维护）</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013344905?w=378&amp;h=673"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""旧版省市区选择器"" title=""旧版省市区选择器""></span></p>
<h5>GitHub地址(含新旧两个版本)： <a href=""https://github.com/treadpit/wx_selectArea"" rel=""nofollow noreferrer"">https://github.com/treadpit/w...</a>
</h5>

                ", 微信小程序-省市区联动选择器,1531977885,440,1,384,1,1,https://segmentfault.com/a/1190000008054815
158,1,0,7,"
                    
<p><a href=""https://www.atlassian.com/git/tutorials/git-log"" rel=""nofollow noreferrer"">原文地址</a></p>
<p>使用任何版本控制工具的目的都在于记录你代码的变化。这可以给予你查看项目历史的能力，去发现谁做出了贡献，弄清楚何时产生了bug，回滚到错误的修改。但是，如果你无法定位，获取这些历史记录将变得毫无意义。这也是<code>git log</code>命令存在的理由。</p>
<p>我想你因该能用基本的<code>git log</code>命令来显示提交。但是，你可以通过向其传入不同的参数来控制输出不同的结果。</p>
<p><code>git log</code>的高级命令可以被分为两类：格式化每条commit的展示与过滤展示出的commit。总之，这两项技能让你回到项目的任意位置，获取到任何你可能需要的信息。</p>
<h2>格式化日志输出</h2>
<p>首先，本文将会介绍一些格式化<em>git</em>输出的方法。多数都以标志的形式出现，让你能从git日志中获取更多／更少的信息。</p>
<p>如果你喜欢默认的git日志输出格式，你可以使用git config的同名函数为下面讨论的任意一种格式化选项创建缩写。请参阅<code>git config</code>命令如何设置别名。</p>
<h3>Oneline</h3>
<p><strong>--oneline</strong> 标记的作用是把每一个提交信息压缩为一行。默认情况下只会展示提交 ID与提交信息的首行。<code>git log --oneline</code>的结果如下：</p>
<pre><code>0e25143 Merge branch 'feature'
ad8621a Fix a bug in the feature
16b36c6 Add a new feature
23ad9ad Add the initial code base
</code></pre>
<p>这是一个得到你项目高度概述的有效方法。</p>
<h3>Decorating</h3>
<p>多数情况下，了解每条提交与与那个分支／标签关联是很有用的。<strong>--decorate</strong> 标记让<code>git log</code>展示所有指向每个提交引用（如分支，标签等）。</p>
<p>这可以与别的控制选项一起使用。如执行<code>git log --oneline --decorate</code>命令建辉得到下面格式的提交历史：</p>
<pre><code>0e25143 (HEAD, master) Merge branch 'feature'
ad8621a (feature) Fix a bug in the feature
16b36c6 Add a new feature
23ad9ad (tag: v0.9) Add the initial code base
</code></pre>
<p>由此我们可以获悉顶部commit被检出（用HEAD表示）同时它也位于主分支的末端。feature分支指向第二个提交，第四个提交被标记为v0.9。</p>
<p>分支，标记，HEAD与提交历史几乎涵盖了你Git仓库中的所有信息，因此这样可以将你仓库的结构以一个更有逻辑的方式展示出来。</p>
<h3>Diffs</h3>
<p><code>git log</code>命令包含了多个用于展示每个提交差异的选项。其中最常用的两个选项是 <strong>--stat</strong> 与 <strong>-p</strong>。</p>
<p><strong>--stat</strong>选项通过比较每个提交展示了插入与删除的数量（请注意，修改将被表示为1行插入与1行删除）。这在你想要获得每个提交中变化的摘要时很有用。例如，下面的提交向<em>hello.py</em>文件添加了67行并移除了38行：</p>
<pre><code>commit f2a238924e89ca1d4947662928218a06d39068c3
Author: John &lt;john@example.com&gt;
Date:   Fri Jun 25 17:30:28 2014 -0500

    Add a new feature

 hello.py | 105 ++++++++++++++++++++++++-----------------
 1 file changed, 67 insertion(+), 38 deletions(-)
</code></pre>
<p>其中在文件名边上的<em>-</em>与<em>+</em>记号代表经过比较后，相关变化的数量。他让你知晓每个提交的变化能在那里找到。</p>
<p>如果你想要查看每个提交实际的变化，你可以使用带<strong>-p</strong> 选项的<code>git log</code>命令，来展示所有描述该提交的差异：</p>
<pre><code>commit 16b36c697eb2d24302f89aa22d9170dfe609855b
Author: Mary &lt;mary@example.com&gt;
Date:   Fri Jun 25 17:31:57 2014 -0500

    Fix a bug in the feature

diff --git a/hello.py b/hello.py
index 18ca709..c673b40 100644
--- a/hello.py
+++ b/hello.py
@@ -13,14 +13,14 @@ B
-print(""Hello, World!"")
+print(""Hello, Git!"")
</code></pre>
<p>对于有大量改变的提交，结果将变的冗长。通常，如果你需要展示所有的改变，你可能在找寻一个具体的变化。为此，你需要使用<strong> pickaxe </strong>。</p>
<h3>短日志</h3>
<p><code>git shortlog</code>是用于创建发布公告的一种特殊的<code>git log</code>命令。按作者对每个提交分组，并展示每个提交信息的第一行。这种方式能很容易看出谁参与了工作。</p>
<p>例如，两个开发者向一个项目贡献了五次提交，<code>git shortlog</code>的输出会像下面这样：</p>
<pre><code>Mary (2):
      Fix a bug in the feature
      Fix a serious security hole in our framework

John (3):
      Add the initial code base
      Add a new feature
      Merge branch 'feature'
</code></pre>
<p>通常，<code>git shortlog</code>会按照作者的名字来排序，但你也可以通过<strong>-n</strong>选项来按照每个作者的提交数量排序。</p>
<h3>Graphs</h3>
<p>添加<strong>--graph</strong> 选项将会绘制一幅表示分支结构提交历史的ASCII图。该选项通常会结合<strong>--oneline</strong>与<strong>--decorate</strong>一起使用，使得能更加容易地看出提交所属的分支：</p>
<pre><code>git log --graph --oneline --decorate
</code></pre>
<p>对于含有两条分支的简单仓库，使用上述命令可得到一下结果：</p>
<pre><code>*   0e25143 (HEAD, master) Merge branch 'feature'
|\  
| * 16b36c6 Fix a bug in the new feature
| * 23ad9ad Start a new feature
* | ad8621a Fix a critical security issue
|/  
* 400e4b7 Fix typos in the documentation
* 160e224 Add the initial code base
</code></pre>
<p>星号表示分支中的一条提交，因此上表可以看出23ad9ad与16b36c6位于一个分支上，而其他提交位于主分支上。</p>
<p>虽然对于小仓库这是一个不错的选择，但是你可能需要在拥有繁杂分支的项目中使用更加全面的可视化工具如<strong>gitk</strong>或<strong>SourceTree</strong>。</p>
<h3>自定义格式</h3>
<p>你所有其他的<code>git log</code>格式的需求，都可以使用<strong>--pretty=format:""&lt;string&gt;""</strong>选项来实现。这可以让你使用 <em>printf</em> 风格的占位符来展示每条提交。</p>
<p>例如，以下命令中分别使用<em> %cn，%h </em>和<em> %cd</em> 字符来替代提交者姓名，提交哈希的缩写以及提交的时间。</p>
<pre><code>git log --pretty=format:""%cn committed %h on %cd""
</code></pre>
<p>上述命令将会得到以下格式的结果：</p>
<pre><code>John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500
John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500
Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500
John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500
</code></pre>
<p>关于完整的占位符列表可以参阅<em> git log 手册 美化样式 一节 </em></p>
<p>除了能让你查看你感兴趣的信息外，<strong>--pretty=format:""&lt;string&gt;""</strong> 还有特别的用途即能将结果作为参数传给另一个git命令。</p>
<h2>过滤提交历史</h2>
<p>学会如何格式化每个提交的显示方式我们已经成功了一半。另一半是要学会如何控制提交历史。在本文的余下部分将会介绍一些从项目历史中筛选出特定提交的<code>git log</code>高级方法。所有这些方法都可以和上述的格式化选项结合使用。</p>
<h3>按数量输出</h3>
<p>最基础的<code>git log</code>过滤选项就是限制输出提交的数量。当你只在意最近的一些提交时，它可以帮你解决浏览所有提交的困扰。</p>
<p>通过使用<strong> -&lt;n&gt; </strong>选项可以限制日志的输出数量。例如下面命令将会只展示最近三条提交：</p>
<pre><code>git log -3
</code></pre>
<h3>按日期</h3>
<p>如果想要从某个特定的日期开始显示提交，你可以使用<strong> --after </strong>或<strong> --before </strong> 来按日期过滤提交。该参数接收多种日期格式。例如下面命令只显示了2014年七月一日（含本日）之后创建的提交：</p>
<pre><code>git log --after=""2014-7-1""
</code></pre>
<p>你也可以传入像“1 week ago”或“ yesterday”这样格式的参数：</p>
<pre><code>get log --after=""yesterday""
</code></pre>
<p>要搜索两个时间点之间创建的提交，可以同时提供<strong> --before </strong>与<strong> --after </strong>日期。比如要展示在2014年七月一日到2014年七月四日之间的提交你可以使用：</p>
<pre><code>git log --after=""2014-7-1"" --before=""2014-7-4""</code></pre>
<p>另外，<strong>--since</strong> 与<strong> --after </strong>， <strong>--until </strong>与<strong> --before</strong> 用法一致。</p>
<h3>按作者</h3>
<p>当你只查看特定提交者的工作时，使用<strong> --author</strong> 选项来过滤。该选项接受一个正则表达式，并返回所有匹配到格式的作者的提交。如果你明确地知道你需要查看谁的提交，你可以使用简单的传统的字符串而不必使用正则：</p>
<pre><code>git log --author=""John""
</code></pre>
<p>这将展示所有作者名字中含“John”的提交。作者名字并非需要完全一致，仅需要包含即可。</p>
<p>通过正则表达式可以搜索更复杂的结果。例如下面的代码将搜索出“Mary”或“John”的提交。</p>
<pre><code>git log --author=""John\|Mary""
</code></pre>
<p>值得注意的是，作者的邮箱也被包含在作者名字中，所以也可以使用该方式来按邮箱搜索。</p>
<p>如果您的工作流将提交者与作者分开，则需要使用<strong> --committer</strong> 选项来到达到筛选的目的。</p>
<h3>按消息</h3>
<p>使用<strong> --grep </strong>选项来按提交信息筛选。该方法与上述<strong> --author </strong>一致，不过搜索内容换成了提交信息。</p>
<p>如果你的团队在每个提交信息中都包含了相关问题的编号，那么你可以使用下面命令来输出关于该问题的提交：</p>
<pre><code>git log --grep=""JRA-224:""
</code></pre>
<p>通过<strong> -i </strong>参数可以在筛选中忽略大小写。</p>
<h3>按文件</h3>
<p>有些时候，你只对发生在某个特定文件中的变化感兴趣时。为了展示关于这个文件的历史你所需要做的就是传入文件路径。例如，下面命令会返回影响foo.py／bar.py文件的提交：</p>
<pre><code>git log -- foo.py bar.py</code></pre>
<p><strong> -- </strong>标记用于告知<code>git log</code>命令随后的参数是文件名而非分支名。如果命令中并不包含分支名，该标记也可省略。</p>
<h3>按内容</h3>
<p>也可以搜索对特定代码的添加或删除的提交。这种采用<strong> -S""&lt;string&gt;"" </strong>格式的方式被称为<strong> pickaxe </strong>，例如，你想要知道字符串“Hello, World!”被添加的提交你可以使用以下命令：</p>
<pre><code>git log -S""Hello, World!""
</code></pre>
<p>也可以使用正则表达式，只需要用<strong> -G""&lt;regex&gt;"" </strong>代替上述格式即可。</p>
<p>这是一个极其强大的纠错工具，因其可以定位所有影响特定代码的提交。甚至可以显示复制或移动到另一个文件的提交。</p>
<h3>按范围</h3>
<p>你可以通过传入一个范围来查询该范围内的提交。该范围由以下格式指定，其中&lt;since&gt;和&lt;until&gt;是提交引用：</p>
<pre><code>git log &lt;since&gt;..&lt;until&gt;
</code></pre>
<p>当使用分支引用作为参数时，此命令特别有用。 这是一个简单的方法来显示两个分支之间的差异。 考虑以下命令：</p>
<pre><code>git log master..feature
</code></pre>
<p><strong> master..feature </strong>包含所有不在主分支中的功能分支的提交。换句话说，这显示了特性分支从主分支分离后的历史进程。可以用下图理解：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHTGi?w=1402&amp;h=1192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>注意如果你变换范围种的顺序（feature..master），你将得到所有在主分支而不在特性分支上的提交。如果日志输出了这两个版本的提交，则意味着你的历史线有了分叉。</p>
<h3>筛选合并提交</h3>
<p>默认情况下，日志会输出合并提交。但是如果你的团队使用的是<strong> always-merge </strong>策略，那么你的项目历史中将会包含大量无用的提交。<br>（注：<strong> always-merge </strong>策略指对于上游的更改合并（merge）到主题分支而非rebase）</p>
<p>你可以通过<strong> --no-merges </strong>选项来过滤掉日志中的合并提交：</p>
<pre><code>git log --no-merges
</code></pre>
<p>另外，当你只对合并提交感兴趣时，可以使用<strong> --merges </strong>选项只输出合并提交：</p>
<pre><code>git log --merges
</code></pre>
<h2>总结</h2>
<p>现在你应该具备使用<code>git log</code>高级命令去按需展示日志提交记录的能力了。</p>
<p>该新技能将成为你Git工具包中的重要组成部分，请记住<code>git log</code>命令常与其他Git命令联用。通过使用<code>git log</code>命令来找到你需要的提交后，通过<code>git checkout</code>，<code>git revert</code>或其他工具控制提交历史。所以你要持续学习git高级命令。</p>

                ", Git系列之git log高级命令,1531977887,190,1,339,1,1,https://segmentfault.com/a/1190000008039809
159,1,0,7,"
                    
<p>这里记录了Gitlab暴力从8.12升级到8.15.2的过程，包括不停的安装过程中遇到的问题。</p>
<p><a href=""https://github.com/jaywcjlove/handbook"" rel=""nofollow noreferrer"">这里持续更新修正，我会在我使用过程中把一些问题记录下来</a></p>
<h2>官方安装</h2>
<p>下面是官网复制过来的官方安装方法，最简单的安装，在我大天朝，只能望天兴叹，你可翻墙安装或者略过这里，看下面的。</p>
<ol><li>安装并配置必要的依赖项</li></ol>
<p>If you install Postfix to send email please select 'Internet Site' during setup. Instead of using Postfix you can also use Sendmail or configure a custom SMTP server and configure it as an SMTP server.</p>
<p>On Centos 6 and 7, the commands below will also open HTTP and SSH access in the system firewall.</p>
<pre><code>sudo yum install curl openssh-server openssh-clients postfix cronie
sudo service postfix start
sudo chkconfig postfix on
sudo lokkit -s http -s ssh</code></pre>
<ol><li>添加gitlab服务器包和安装包</li></ol>
<pre><code>curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
sudo yum install gitlab-ce</code></pre>
<p>If you are not comfortable installing the repository through a piped script, you can find the entire script here and select and download the package manually and install using<br><a href=""https://packages.gitlab.com/gitlab/gitlab-ce"" rel=""nofollow noreferrer"">gitlab/gitlab-ce</a></p>
<pre><code class=""bash"">curl -LJO https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/6/gitlab-ce-XXX.rpm/download
curl -LJO https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-10.2.2-ce.0.el7.x86_64.rpm/download
rpm -i gitlab-ce-XXX.rpm</code></pre>
<ol><li>配置并启动GitLab</li></ol>
<pre><code>sudo gitlab-ctl reconfigure</code></pre>
<ol><li>浏览器打开并登录</li></ol>
<p>On your first visit, you'll be redirected to a password reset screen to provide the password for the initial administrator account. Enter your desired password and you'll be redirected back to the login screen.</p>
<p>The default account's username is root. Provide the password you created earlier and login. After login you can change the username if you wish.</p>
<h2>第三方镜像安装</h2>
<ul>
<li><a href=""https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"" rel=""nofollow noreferrer"">Gitlab Community Edition 镜像使用帮助</a></li>
<li><a href=""https://github.com/hehongwei44/my-blog/issues/19"" rel=""nofollow noreferrer"">在阿里云上通过Omnibus一键安装包安装Gitlab</a></li>
</ul>
<h3>编辑源</h3>
<p>新建 /etc/yum.repos.d/gitlab-ce.repo，内容为</p>
<p><a href=""https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"" rel=""nofollow noreferrer"">使用清华大学 TUNA 镜像源</a> 打开网址将内容复制到<code>gitlab-ce.repo</code>文件中，编辑路径<code>vim /etc/yum.repos.d/gitlab-ce.repo</code></p>
<pre><code class=""bash"">[gitlab-ce]
name=gitlab-ce
baseurl=http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6
repo_gpgcheck=0
gpgcheck=0
enabled=1
gpgkey=https://packages.gitlab.com/gpg.key</code></pre>
<h3>更新本地YUM缓存</h3>
<pre><code class=""bash"">sudo yum makecache</code></pre>
<h3>安装社区版</h3>
<pre><code class=""bash"">sudo yum install gitlab-ce #(自动安装最新版)
sudo yum install gitlab-ce-8.15.2-ce.0.el6 #(安装指定版本)</code></pre>
<h3>更改配置</h3>
<pre><code class=""bash"">vim /etc/gitlab/gitlab.rb
# 找到 external_url 'http://000.00.00.00:8081'
# 修改成你的地址</code></pre>
<h3>配置并启动GitLab</h3>
<pre><code class=""bash""># 打开`/etc/gitlab/gitlab.rb`,
# 将`external_url = 'http://git.example.com'`修改为自己的IP地址：`http://xxx.xx.xxx.xx`，
# 然后执行下面的命令，对GitLab进行编译。
sudo gitlab-ctl reconfigure
# 清除缓存
sudo gitlab-rake cache:clear RAILS_ENV=production</code></pre>
<h3>登录GitLab</h3>
<pre><code>Username: root 
Password: 5iveL!fe</code></pre>
<h2>卸载</h2>
<pre><code class=""bash"">sudo gitlab-ctl uninstall</code></pre>
<h2>运维</h2>
<pre><code class=""bash""># 修改默认的配置文件
sudo vim /etc/gitlab/gitlab.rb

# 查看版本
sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION
# echo ""vm.overcommit_memory=1"" &gt;&gt; /etc/sysctl.conf
# sysctl -p
# echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled

# 检查gitlab
gitlab-rake gitlab:check SANITIZE=true --trace
gitlab-rake gitlab:check
gitlab-rake gitlab:check SANITIZE=true
# 查看日志
gitlab-ctl tail
# 数据库关系升级
gitlab-rake db:migrate
# 清理缓存
gitlab-rake cache:clear

# 更新gitlab包
yum update gitlab-ce

# 升级gitlab
yum install gitlab-ce

# 升级数据命令
gitlab-ctl pg-upgrade</code></pre>
<h3>服务管理</h3>
<pre><code class=""bash"">gitlab-ctl start # 启动所有 gitlab 组件：
gitlab-ctl stop  # 停止所有 gitlab 组件：
gitlab-ctl stop postgresql # 停止所有 gitlab postgresql 组件：
# 停止相关数据连接服务
gitlab-ctl stop unicorn
gitlab-ctl stop sidekiq
gitlab-ctl restart # 重启所有 gitlab 组件：
gitlab-ctl restart gitlab-workhorse # 重启所有 gitlab gitlab-workhorse 组件：
gitlab-ctl status # 查看服务状态
gitlab-ctl reconfigure # 生成配置启动服务</code></pre>
<h3>日志查看</h3>
<pre><code class=""bash"">sudo gitlab-ctl tail # 查看日志
sudo gitlab-ctl tail redis # 检查redis的日志
sudo gitlab-ctl tail postgresql       # 检查postgresql的日志
sudo gitlab-ctl tail gitlab-workhorse # 检查gitlab-workhorse的日志
sudo gitlab-ctl tail logrotate # 检查logrotate的日志
sudo gitlab-ctl tail nginx    # 检查nginx的日志
sudo gitlab-ctl tail sidekiq  # 检查sidekiq的日志
sudo gitlab-ctl tail unicorn  # 检查unicorn的日志
</code></pre>
<h3>重置管理员密码</h3>
<p>gitlab管理员密码忘记，怎么重置密码，Gitlab 修改root用户密码</p>
<p>使用rails工具打开终端</p>
<pre><code class=""bash"">sudo gitlab-rails console production</code></pre>
<p>查询用户的email，用户名，密码等信息，id:1 表示root账号</p>
<pre><code class=""bash"">user = User.where(id: 1).first</code></pre>
<p>重新设置密码</p>
<pre><code class=""bash"">user.password = '新密码'
user.password_confirmation = '新密码'　</code></pre>
<p>保存密码</p>
<pre><code class=""bash"">user.save!</code></pre>
<p>完整的操作ruby脚本</p>
<pre><code class=""bash"">user = User.where(id: 1).first
user.password = '新密码'
user.password_confirmation = '新密码'
user.save!</code></pre>
<h2>备份恢复</h2>
<p>使用Gitlab一键安装包安装Gitlab非常简单, 同样的备份恢复与迁移也非常简单,用一条命令即可创建完整的Gitlab备份:</p>
<h3>修改备份文件默认目录</h3>
<p>修改<code>/etc/gitlab/gitlab.rb</code>来修改默认存放备份文件的目录:</p>
<pre><code class=""bash"">gitlab_rails['backup_path'] = '/mnt/backups'  </code></pre>
<h3>创建备份</h3>
<pre><code class=""bash"">gitlab-rake gitlab:backup:create</code></pre>
<p>以上命令将在/var/opt/gitlab/backups目录下创建一个名称类似为xxxxxxxx_gitlab_backup.tar的压缩包, 这个压缩包就是Gitlab整个的完整部分, 其中开头的xxxxxx是备份创建的时间戳。</p>
<p>修改后使用gitlab-ctl reconfigure命令重载配置文件。</p>
<h3>开始备份</h3>
<p>这里放你的备份文件文件夹，和仓库源文件。</p>
<pre><code class=""bash"">/var/opt/gitlab/backups                   # 备份文件文件夹
/var/opt/gitlab/git-data/repositories     # git仓库源文件</code></pre>
<h3>自动备份</h3>
<p>通过crontab使用备份命令实现自动备份</p>
<pre><code class=""bash"">crontab -e
# 每天2点备份gitlab数据
0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create
0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create</code></pre>
<p>上面两行保存之后，重新载入配置</p>
<pre><code class=""bash"">service crond reload
# or
systemctl reload crond.service</code></pre>
<h3>备份保留七天</h3>
<p>设置只保存最近7天的备份，编辑 /etc/gitlab/gitlab.rb 配置文件，找到如下代码，删除注释 <code>#</code> 保存</p>
<pre><code class=""bash""># /etc/gitlab/gitlab.rb 配置文件 修改下面这一行
gitlab_rails['backup_keep_time'] = 604800  </code></pre>
<p>重新加载gitlab配置文件</p>
<pre><code class=""bash"">sudo gitlab-ctl reconfigure  </code></pre>
<h3>开始恢复</h3>
<p>迁移如同备份与恢复的步骤一样, 只需要将老服务器/var/opt/gitlab/backups目录下的备份文件拷贝到新服务器上的/var/opt/gitlab/backups即可(如果你没修改过默认备份目录的话)。 然后执行恢复命令。<br>如果修改了，首先进入备份 gitlab 的目录，这个目录是配置文件中的 <code>gitlab_rails['backup_path']</code> ，默认为 <code>/var/opt/gitlab/backups</code> 。</p>
<p>然后停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。</p>
<pre><code class=""bash""># 停止相关数据连接服务
gitlab-ctl stop unicorn
# ok: down: unicorn: 0s, normally up
gitlab-ctl stop sidekiq
# ok: down: sidekiq: 0s, normally up

# 从xxxxx编号备份中恢复
# 然后恢复数据，1406691018为备份文件的时间戳
gitlab-rake gitlab:backup:restore BACKUP=1406691018

# 新版本 1483533591_2017_01_04_gitlab_backup.tar
gitlab-rake gitlab:backup:restore BACKUP=1483533591_2017_01_04_gitlab_backup.tar

# 启动Gitlab
sudo gitlab-ctl start  </code></pre>
<p>判断是执行实际操作的gitlab相关用户：git，没有得到足够的权限。依次执行命令：</p>
<pre><code class=""bash""># 恢复过程中没有权限
mkdir /var/opt/gitlab/backups
chown git /var/opt/gitlab/backups
chmod 700 /var/opt/gitlab/backups

# 恢复成功页面报没有权限的错误
sudo chown -R git:git /var/opt/gitlab/git-data/repositories
sudo chmod -R ug+rwX,o-rwx /var/opt/gitlab/git-data/repositories
sudo chmod -R ug-s /var/opt/gitlab/git-data/repositories
sudo find /var/opt/gitlab/git-data/repositories -type d -print0 | sudo xargs -0 chmod g+s</code></pre>
<p>如果备份文件报没有权限，通过<code>ls -al</code>查看权限是不是<code>git</code>，而不是<code>root</code>，通过下面方式给<code>git</code>用户权限</p>
<pre><code class=""bash"">sudo chown -R git:git 1483533591_2017_01_04_gitlab_backup.tar</code></pre>
<h2>暴力升级</h2>
<p>直接编辑源 /etc/yum.repos.d/gitlab-ce.repo，安装 GitLab 社区版</p>
<pre><code class=""bash"">sudo yum install gitlab-ce #(自动安装最新版)
sudo yum install gitlab-ce-8.15.2-ce.0.el6 #(安装指定版本)</code></pre>
<p>安装过程会报错</p>
<pre><code>gitlab preinstall: Automatically backing up only the GitLab SQL database (excluding everything else!)
Dumping database ...
Dumping PostgreSQL database gitlabhq_production ... pg_dump: [archiver (db)] connection to database ""gitlabhq_production"" failed: could not connect to server: 没有那个文件或目录
    Is the server running locally and accepting
    connections on Unix domain socket ""/var/opt/gitlab/postgresql/.s.PGSQL.5432""?
Backup failed
[FAILED]
gitlab preinstall:
gitlab preinstall: Backup failed! If you want to skip this backup, run the following command and
gitlab preinstall: try again:
gitlab preinstall:
gitlab preinstall:   sudo touch /etc/gitlab/skip-auto-migrations
gitlab preinstall:
error: %pre(gitlab-ce-8.15.2-ce.0.el6.x86_64) scriptlet failed, exit status 1
Error in PREIN scriptlet in rpm package gitlab-ce-8.15.2-ce.0.el6.x86_64
error:   install: %pre scriptlet failed (2), skipping gitlab-ce-8.15.2-ce.0.el6
gitlab-ce-8.11.5-ce.0.el6.x86_64 was supposed to be removed but is not!
  Verifying  : gitlab-ce-8.11.5-ce.0.el6.x86_64                                                                                                                                                             1/2
  Verifying  : gitlab-ce-8.15.2-ce.0.el6.x86_64                                                                                                                                                             2/2

Failed:
  gitlab-ce.x86_64 0:8.11.5-ce.0.el6</code></pre>
<p>看上面一堆错误，瞬间就懵逼了，看到一条救星命令让我尝试运行 <code>sudo touch /etc/gitlab/skip-auto-migrations</code> 于是我二逼的运行了，结果真的安装成功了，?。</p>
<pre><code>...
gitlab: Thank you for installing GitLab!
gitlab: To configure and start GitLab, RUN THE FOLLOWING COMMAND:

sudo gitlab-ctl reconfigure

gitlab: GitLab should be reachable at http://114.55.148.71:8081
gitlab: Otherwise configure GitLab for your system by editing /etc/gitlab/gitlab.rb file
gitlab: And running reconfigure again.
gitlab:
gitlab: For a comprehensive list of configuration options please see the Omnibus GitLab readme
gitlab: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md
gitlab:

gitlab: GitLab now ships with a newer version of PostgreSQL (9.6.1), and will be used
gitlab: as the default in the next major relase. To upgrade, RUN THE FOLLOWING COMMANDS:

sudo gitlab-ctl pg-upgrade

gitlab: For more details, please see:
gitlab: https://docs.gitlab.com/omnibus/settings/database.html#upgrade-packaged-postgresql-server
gitlab:
  清理       : gitlab-ce-8.11.5-ce.0.el6.x86_64                                                                                                                                                             2/2
Found /etc/gitlab/skip-auto-migrations, exiting...
  Verifying  : gitlab-ce-8.15.2-ce.0.el6.x86_64                                                                                                                                                             1/2
  Verifying  : gitlab-ce-8.11.5-ce.0.el6.x86_64                                                                                                                                                             2/2

更新完毕:
  gitlab-ce.x86_64 0:8.15.2-ce.0.el6

完毕！</code></pre>
<p>重启配置，可以解决大部分<code>502</code>错误。</p>
<pre><code class=""bash"">gitlab-ctl reconfigure</code></pre>
<h2>错误处理</h2>
<h3>解决80端口被占用</h3>
<p>nginx配置解决 <code>80</code> 端口被占用</p>
<pre><code class=""nginx"">upstream gitlab {
     server 114.55.111.111:8081 ;
}
server {
  # 侦听的80端口
  listen       80;
  server_name  git.diggg.cn;
  location / {
    proxy_pass   http://gitlab;    #在这里设置一个代理，和upstream的名字一样
    #以下是一些反向代理的配置可删除
    proxy_redirect             off;
    #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
    proxy_set_header           Host $host;
    proxy_set_header           X-Real-IP $remote_addr;
    proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size       10m; #允许客户端请求的最大单文件字节数
    client_body_buffer_size    128k; #缓冲区代理缓冲用户端请求的最大字节数
    proxy_connect_timeout      300; #nginx跟后端服务器连接超时时间(代理连接超时)
    proxy_send_timeout         300; #后端服务器数据回传时间(代理发送超时)
    proxy_read_timeout         300; #连接成功后，后端服务器响应时间(代理接收超时)
    proxy_buffer_size          4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
    proxy_buffers              4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
    proxy_busy_buffers_size    64k; #高负荷下缓冲大小（proxy_buffers*2）
    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传
  }
}</code></pre>
<p>nginx配置检查和立即生效</p>
<pre><code class=""bash""># 检查配置
/usr/local/nginx/sbin/nginx -tc conf/nginx.conf
# nginx 重新加载配置
/usr/local/nginx/sbin/nginx -s reload</code></pre>
<h3>头像无法正常显示</h3>
<p>原因：gravatar被墙<br>解决办法：<br>编辑 /etc/gitlab/gitlab.rb，将</p>
<pre><code class=""bash""># gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'</code></pre>
<p>修改为：</p>
<pre><code>gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'</code></pre>
<p>然后在命令行执行：</p>
<pre><code class=""bash"">sudo gitlab-ctl reconfigure 
sudo gitlab-rake cache:clear RAILS_ENV=production</code></pre>
<h3>其它错误</h3>
<pre><code class=""bash"">Error executing action `run` on resource 'bash[migrate gitlab-rails database]'</code></pre>
<p>上面错误是数据库没有启动，我不知道如何启动，我重启了服务器，然后好球了。? <br><a href=""https://gitlab.com/gitlab-org/gitlab-ce/issues/2052#note_1667899"" rel=""nofollow noreferrer"">https://gitlab.com/gitlab-org...</a></p>
<pre><code class=""bash"">NameError: uninitialized constant Devise::Async</code></pre>
<pre><code>Processing by RootController#index as HTML
Completed 401 Unauthorized in 17ms (ActiveRecord: 2.7ms)</code></pre>
<pre><code>/var/log/gitlab/nginx/gitlab_access.log &lt;==
114.55.148.71 - - [04/Jan/2017:17:20:24 +0800] ""GET /favicon.ico HTTP/1.0"" 502 2662 ""http://git.xxxxx.cn/"" ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36""</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href=""https://packages.gitlab.com/gitlab/gitlab-ce"" rel=""nofollow noreferrer"">gitlab/gitlab-ce</a></li>
<li><a href=""https://www.gitlab.cc/downloads"" rel=""nofollow noreferrer"">官网下载</a></li>
<li><a href=""https://doc.gitlab.cc/ce/install/requirements.html"" rel=""nofollow noreferrer"">官网安装说明</a></li>
<li><a href=""https://www.gitlab.cc/features/#enterprise"" rel=""nofollow noreferrer"">开源版本和企业版本对比</a></li>
<li><a href=""https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/update/8.14-to-8.15.md"" rel=""nofollow noreferrer"">官方升级Gitlab教程</a></li>
<li><a href=""https://gitlab.com/gitlab-org/gitlab-recipes/tree/master/install/centos"" rel=""nofollow noreferrer"">官方Centos安装Gitlab教程</a></li>
<li><a href=""http://opjasee.com/2016/01/28/gitlab-upgrade.html"" rel=""nofollow noreferrer"">Gitlab升级记录</a></li>
<li><a href=""http://www.yuzhewo.com/2015/11/03/%E4%BF%AE%E6%94%B9gitlab%E4%BD%BF%E7%94%A8%E7%8E%B0%E6%9C%89nginx%E6%9C%8D%E5%8A%A1%E5%8F%8A502%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"" rel=""nofollow noreferrer"">修改gitlab使用现有nginx服务及502问题解决</a></li>
<li><a href=""http://blog.csdn.net/wangxicoding/article/details/43738137"" rel=""nofollow noreferrer"">我所遇到的GitLab 502问题的解决</a></li>
</ul>

                ", Centos7中安装维护Gitlab暴力从8.12升级到最新版本,1531977888,441,1,734,1,1,https://segmentfault.com/a/1190000008025217
160,1,0,7,"
                    
<p>Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>
<p>Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>
<p>起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>
<h2>依赖注入（Dependency Injection）</h2>
<p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>
<pre><code class=""java"">public class Car{

    private Engine engine;
    
    public Car(){
        engine = new Engine();
    }
}</code></pre>
<p>这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>
<h4>1、构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</h4>
<pre><code class=""java"">public class Car{

    private Engine engine;
    
    public Car(Engine engine){
        this.engine = engine;
    }
}</code></pre>
<h4>2、接口注入：实现接口方法，同样以传参的方式实现注入。</h4>
<pre><code class=""java"">public interface Injection&lt;T&gt;{

    void inject(T t);
}

public class Car implements Injection&lt;Engine&gt;{

    private Engine engine;
    
    public Car(){}

    public void inject(Engine engine){
        this.engine = engine;
    }

}</code></pre>
<h4>3、注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</h4>
<pre><code class=""java"">public class Car{

    @Inject
    Engine engine;
    
    public Car(){}
}</code></pre>
<p>前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>
<h2>为什么需要依赖注入</h2>
<p>我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>
<p>下面我们看看同一个业务的两种实现方案：</p>
<h4>1、方案A</h4>
<pre><code class=""java"">public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(){
        engine = new Engine();
        wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
    }

    public void start{
        System.out.println(""启动汽车"");
    }
}

public class CarTest{

    public static void main(String[] args){
        Car car = new Car();
        car.start();
    }
} </code></pre>
<h4>2、方案B</h4>
<pre><code class=""java"">public class Car{

    private Engine engine;
    private List&lt;Wheel&gt; wheels;

    public Car(Engine engine, List&lt;Wheel&gt; wheels){
        this.engine = engine;
        this.wheels = wheels;
    }

    public void start{
        System.out.println(""启动汽车"");
    }
}

public class CarTest{

    public static void main(String[] args){

        Engine engine = new Engine();
        List&lt;Wheel&gt; wheels = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; 4; i++){
            wheels.add(new Wheel());
        }
        Car car = new Car(engine, wheels);
        car.start();
    }
}</code></pre>
<p>方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>
<p>方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>
<p>方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>
<h2>为什么是Dagger2</h2>
<p>无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>
<p>谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>
<p>又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>
<p>前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>
<h2>Dagger2注解</h2>
<p>开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>
<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p></li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p></li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p></li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p></li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。----一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p></li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p></li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p></li>
</ul>
<p>我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>
<ul>
<li><p>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</p></li>
<li>
<p>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。</p>
<ul>
<li><p>a：若存在参数，则按从步骤1开始依次初始化每个参数；</p></li>
<li><p>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</p></li>
</ul>
</li>
<li>
<p>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。</p>
<ul>
<li><p>a：若存在参数，则从步骤1开始依次初始化每一个参数</p></li>
<li><p>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</p></li>
</ul>
</li>
</ul>
<h2>Dagger2使用入门</h2>
<p>前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href=""https://github.com/google/dagger"" rel=""nofollow noreferrer"">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>
<h4>1、案例A</h4>
<p>Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>
<pre><code class=""Java"">public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}</code></pre>
<p>Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>
<pre><code class=""Java"">public class Engine {
    
    @Inject
    Engine(){}
    
    public void run(){
        System.out.println(""引擎转起来了~~~"");
    }
}</code></pre>
<p>接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>
<pre><code class=""Java"">@Component
public interface CarComponent {
    void inject(Car car);
}</code></pre>
<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>
<pre><code class=""Java"">public Car() {
    DaggerCarComponent.builder().build().inject(this);
}</code></pre>
<h4>2、案例B</h4>
<p><strong>如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</strong></p>
<p>同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>
<pre><code class=""Java"">public class Car {

    @Inject
    Engine engine;

    public Car() {
        DaggerCarComponent.builder().markCarModule(new MarkCarModule())
                .build().inject(this);
    }

    public Engine getEngine() {
        return this.engine;
    }
}</code></pre>
<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>
<pre><code class=""Java"">@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(""gear"");
    }
}</code></pre>
<p>接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上<code>modules = {MarkCarModule.class}</code>，用来告诉Dagger2提供依赖的是<code>MarkCarModule</code>这个类。</p>
<pre><code class=""Java"">@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}</code></pre>
<p>Car类的构造函数我们也需要修改，相比之前多了个<code>markCarModule(new MarkCarModule())</code>方法，这就相当于告诉了注入器<code>DaggerCarComponent</code>把<code>MarkCarModule</code>提供的依赖注入到了Car类中。</p>
<pre><code class=""Java"">public Car() {
   DaggerCarComponent.builder()
           .markCarModule(new MarkCarModule())
           .build().inject(this);
}</code></pre>
<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>
<pre><code class=""Java"">public static void main(String[] args){
    Car car = new Car();
    car.getEngine().run();
}</code></pre>
<p>输出</p>
<pre><code class=""Text"">引擎转起来了~~~</code></pre>
<h4>3、案例C</h4>
<p>那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>
<pre><code class=""Java"">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierA { }</code></pre>
<pre><code class=""Java"">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface QualifierB { }</code></pre>
<p>同时我们需要对依赖提供方做出修改</p>
<pre><code class=""Java"">@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @QualifierA
    @Provides
    Engine provideEngineA(){
        return new Engine(""gearA"");
    }

    @QualifierB
    @Provides
    Engine provideEngineB(){
        return new Engine(""gearB"");
    }
}</code></pre>
<p>接下来依赖需求方Car类同样需要修改</p>
<pre><code class=""Java"">public class Car {

    @QualifierA @Inject Engine engineA;
    @QualifierB @Inject Engine engineB;

    public Car() {
        DaggerCarComponent.builder().markCarModule(new MarkCarModule())
                .build().inject(this);
    }

    public Engine getEngineA() {
        return this.engineA;
    }

    public Engine getEngineB() {
        return this.engineB;
    }
}</code></pre>
<p>最后我们再对Engine类做些调整方便测试</p>
<pre><code class=""Java"">public class Engine {

    private String gear;
    
    public Engine(String gear){
        this.gear = gear;
    }
    
    public void printGearName(){
        System.out.println(""GearName:"" + gear);
    }
}</code></pre>
<p>测试代码</p>
<pre><code class=""Java"">public static void main(String[] args) {
    Car car = new Car();
    car.getEngineA().printGearName();
    car.getEngineB().printGearName();
}</code></pre>
<p>执行结果：</p>
<pre><code class=""Text"">GearName:gearA
GearName:gearB</code></pre>
<h4>4、案例D</h4>
<p>接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>
<p>首先我们需要通过@Scope定义一个CarScope注解：</p>
<pre><code class=""Java"">@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface CarScope {
}</code></pre>
<p>接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>
<pre><code class=""Java"">@Module
public class MarkCarModule {

    public MarkCarModule() {
    }

    @Provides
    @CarScope
    Engine provideEngine() {
        return new Engine(""gear"");
    }
}</code></pre>
<p>同时还需要使用@Scope去标注注入器Compoent</p>
<pre><code class=""Java"">@CarScope
@Component(modules = {MarkCarModule.class})
public interface CarComponent {
    void inject(Car car);
}</code></pre>
<p>为了便于测试我们对Car和Engine类做了一些改造：</p>
<pre><code class=""Java"">public class Car {

    @Inject Engine engineA;
    @Inject Engine engineB;

    public Car() {
        DaggerCarComponent.builder()
                .markCarModule(new MarkCarModule())
                .build().inject(this);
    }
}</code></pre>
<pre><code class=""Java"">public class Engine {

    private String gear;
    
    public Engine(String gear){
        System.out.println(""Create Engine"");
        this.gear = gear;
    }
}</code></pre>
<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次""Create Engine""输出。现在我们在有@Scope的情况测试下劳动成果：</p>
<pre><code class=""Java"">public static void main(String[] args) {
    Car car = new Car();

    System.out.println(car.engineA.hashCode());
    System.out.println(car.engineB.hashCode());
}</code></pre>
<p>输出</p>
<pre><code class=""Java"">Create Engine</code></pre>
<p>bingo！我们确实通过@Scope实现了局部的单例。</p>
<h2>Dagger2原理分析</h2>
<p>前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的<strong>案例B</strong>来做分析。</p>
<p>Dagger2编译期生成的代码位于<code>build/generated/source/apt/debug/your package name/</code>下面:<br><span class=""img-wrap""><img data-src=""/img/bVHQYg?w=914&amp;h=498"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>首先我们看看Dagger2依据依赖提供方<code>MarkCarModule</code>生成的对应工厂类<code>MarkCarModule_ProvideEngineFactory</code>。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>
<pre><code class=""Java"">/**
* 我们自己的类
*/
@Module
public class MarkCarModule {

    public MarkCarModule(){ }

    @Provides Engine provideEngine(){
        return new Engine(""gear"");
    }
}

/**
* Dagger2生成的工厂类
*/
public final class MarkCarModule_ProvideEngineFactory implements Factory&lt;Engine&gt; {
  private final MarkCarModule module;

  public MarkCarModule_ProvideEngineFactory(MarkCarModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Engine get() {
    return Preconditions.checkNotNull(
        module.provideEngine(), ""Cannot return null from a non-@Nullable @Provides method"");
  }

  public static Factory&lt;Engine&gt; create(MarkCarModule module) {
    return new MarkCarModule_ProvideEngineFactory(module);
  }

  /** Proxies {@link MarkCarModule#provideEngine()}. */
  public static Engine proxyProvideEngine(MarkCarModule instance) {
    return instance.provideEngine();
  }
}</code></pre>
<p>我们可以看到<code>MarkCarModule_ProvideEngineFactory</code>中的get()调用了<code>MarkCarModule</code>的<code>provideEngine()</code>方法来获取我们需要的依赖<code>Engine</code>，<code>MarkCarModule_ProvideEngineFactory</code>的实例化有<code>crate()</code>创建，并且<code>MarkCarModule</code>的实例也是通过<code>create()</code>方法传进来的。那么这个<code>create()</code>一定会在哪里调用的，我们接着往下看。</p>
<p>前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>
<pre><code class=""Java"">/**
* 我们自己的类
*/
@Component(modules = {MarkCarModule.class})
public interface CarComponent {

    void inject(Car car);
}

/**
* Dagger2生成的CarComponent实现类
*/
public final class DaggerCarComponent implements CarComponent {
  private Provider&lt;Engine&gt; provideEngineProvider;

  private MembersInjector&lt;Car&gt; carMembersInjector;

  private DaggerCarComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static CarComponent create() {
    return builder().build();
  }

  @SuppressWarnings(""unchecked"")
  private void initialize(final Builder builder) {

    this.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);

    this.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);
  }

  @Override
  public void inject(Car car) {
    carMembersInjector.injectMembers(car);
  }

  public static final class Builder {
    private MarkCarModule markCarModule;

    private Builder() {}

    public CarComponent build() {
      if (markCarModule == null) {
        this.markCarModule = new MarkCarModule();
      }
      return new DaggerCarComponent(this);
    }

    public Builder markCarModule(MarkCarModule markCarModule) {
      this.markCarModule = Preconditions.checkNotNull(markCarModule);
      return this;
    }
  }
}</code></pre>
<p>通过上面的代码我们看到Dagger2依据<code>CarComponent</code>接口生成了实现类<code>DaggerCarComponent</code>（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。<code>DaggerCarComponent</code>在build的时候实例化了<code>DaggerCarComponent</code>对象，并首先调用<code>MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)</code>始化了<code>provideEngineProvider</code>变量，接着调用<code>Car_MembersInjector.create(provideEngineProvider)</code>初始化了<code>carMembersInjector</code>变量。当我们手动在Car类的构造函数中调用<code>inject(Car car)</code>方法时会执行<code>carMembersInjector.injectMembers(car)</code>。所以接下来我们要看看<code>Car_MembersInjector</code>的实现。</p>
<pre><code class=""Java"">public final class Car_MembersInjector implements MembersInjector&lt;Car&gt; {
  private final Provider&lt;Engine&gt; engineProvider;

  public Car_MembersInjector(Provider&lt;Engine&gt; engineProvider) {
    assert engineProvider != null;
    this.engineProvider = engineProvider;
  }

  public static MembersInjector&lt;Car&gt; create(Provider&lt;Engine&gt; engineProvider) {
    return new Car_MembersInjector(engineProvider);
  }

  @Override
  public void injectMembers(Car instance) {
    if (instance == null) {
      throw new NullPointerException(""Cannot inject members into a null reference"");
    }
    instance.engine = engineProvider.get();
  }

  public static void injectEngine(Car instance, Provider&lt;Engine&gt; engineProvider) {
    instance.engine = engineProvider.get();
  }
}</code></pre>
<p><code>Car_MembersInjector</code>中的<code>create()</code>用于实例化自己，这个方法前面我们看到是在<code>DaggerCarComponent</code>中调用的。<code>injectMembers(Car instance)</code>将<code>engineProvider.get()</code>的返回值赋给了依赖需求方Car的engine变量，而<code>engineProvider.get()</code>正是本节一开始我们提到的<code>MarkCarModule_ProvideEngineFactory</code>中的<code>get()</code>方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>
<h2>总结</h2>
<p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <a href=""https://github.com/BaronZ88/MinimalistWeather"" rel=""nofollow noreferrer"">https://github.com/BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>
<blockquote><p><a href=""https://github.com/BaronZ88/MinimalistWeather"" rel=""nofollow noreferrer"">MinimalistWeather</a>是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p></blockquote>

                ", 神兵利器Dagger2,1531977889,548,1,281,1,1,https://segmentfault.com/a/1190000008016507
161,1,0,7,"
                    
<p><a href=""https://www.atlassian.com/git/tutorials/refs-and-the-reflog/"" rel=""nofollow noreferrer"">原文地址</a><br>Git是一切关于commit的艺术：你暂存commit，提交commit，浏览以往的commit，在不同的仓库切换commit，这一切使用不同的命令来实现。这些命令中大部分以各种形式操作commit，一些可以接受commit作为参数。例如，你可以使用<em>git checkout</em>命令来查看以往的commit，只需要传入该commit的哈希即可，抑或传入分支名在不同分支间切换。<br><span class=""img-wrap""><img data-src=""/img/bVHIk1?w=940&amp;h=838"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>通过理解这些使用commit的不同方式，将使得这些命令变得更加强大。本章，我将通过探究commit引用的多种方式来阐述常见命令的内部工作原理，这些常见命令包括<code>git checkout</code>, <code>git branch</code>和<code>git push</code>。</p>
<p>我们也将学到怎样去恢复看似“丢失”的命令，通过Git的reflog机制来访问到它们。</p>
<h2>哈希</h2>
<p>引用commit最直接的方式就是通过它的SHA-1哈希。这是每个commit独一无二的ID。在<code>git log</code>的输出中你可以找到每个commit的哈希。</p>
<pre><code>commit 0c708fdec272bc4446c6cabea4f0022c2b616eba
Author: Mary Johnson &lt;mary@example.com&gt;
Date:   Wed Jul 9 16:37:42 2014 -0500

    Some commit message
</code></pre>
<p>当你向其他命令传commit时，你只需要输入足够的字符来标明这个独一无二的提交即可（译注：即你不需要将40位的哈希都输入）例如，你可以查看某个commit通过像下面这样运行<code>git show</code>命令：</p>
<pre><code>git show 0c708f
</code></pre>
<p>工作中有时需要将一个分支（branch），标签（tag）或其他间接引用解析成相应的commit哈希时。此时你需要使用<code>git rev-parse</code>命令。以下命令执行后将显示主分支当前commit的哈希。</p>
<pre><code>git rev-parse master
</code></pre>
<p>这在编写接受commit引用的自定义脚本时非常有用。你可以使用<code>git rev-parse</code>命令来使你的输入规范化，而非手动编译你的commit引用。</p>
<h2>引用（Refs）</h2>
<p>引用（Refs）是一种间接引用commit的方式。它是一种对用户来说更亲和的commit哈希的别名。使Git表示分支与标签的内部机制。</p>
<p>引用被作为一个普通的文本文件保存在<em>.git/refs</em>路径下，where .git is usually called .git。要浏览在你的仓库之中的refs，请访问你的<em>.git/refs</em>路径。你将看到以下结构，结构包含的文件因你仓库中的分支，标签，远程分支而异。</p>
<pre><code>.git/refs/
    heads/
        master
        some-feature
    remotes/
        origin/
            master
    tags/
        v0.9
</code></pre>
<p><code>heads</code>目录描述了了在你仓库中所有的本地分支。每一个文件名对应了相应的分支，在文件夹内部的文件中你会看他对应的commit哈希。这个哈希是现在的分支最末端的那个commit的哈希。为了证实这点，你可以在<em>Git</em>所在的根目录，执行下面两段代码：</p>
<pre><code># Output the contents of `refs/heads/master` file:
cat .git/refs/heads/master

# Inspect the commit at the tip of the `master` branch:
git log -1 master
</code></pre>
<p>由<code>cat</code>命令得到的commit哈希应与<code>git log</code>得到的哈希一致。</p>
<p>要更改主分支的位置就必须要改到<em>refs/heads/master</em>的内容。同样地，创建一个新的分支就是把commit哈希写入新文件这样简单。这也是为何Git与SVN相比是如此轻量的部分原因。</p>
<p>tag文件夹实际上以同样的方式工作着，只是其中存放的是tag而非分支。remotes文件夹将所有由<code>git remote</code>命令创建的所有远程分支存储为单独的子目录。在每个子目录中，可以发现被fetch进仓库的对应的远程分支。</p>
<h3>规范引用（refs）</h3>
<p>当你把引用传给Git命令时，你可以使用引用的全称，也可以使用缩写去让Git匹配符合的引用。你应该对引用缩写足够熟悉，以便在你每次通过其来切换分支。</p>
<pre><code>git show some-feature
</code></pre>
<p>上面命令的<code>some-feature</code>参数实际上就是分支的缩写。在使用前Git会将其解析为<em>refs/heads/some-feature</em>。你也可以使用引用的全名：</p>
<pre><code>git show refs/heads/some-feature
</code></pre>
<p>这样写能避免引用位置产生歧义。这是很必要的，例如，你有标签与分支都叫做<em>some-feature</em>然而，当你使用正确的命名规范，标签与分支间的歧义将不再困扰你。</p>
<p>在<code>Refspecs</code>部分，我们将看到更多的全名引用。</p>
<h2>Packed Refs</h2>
<p>对于大型仓库，Git将会周期性地运行垃圾回收将移除不必需要的对象，并将引用压缩至单个文件中，来提高性能。你可以执行下面命令来强制启动这一过程：</p>
<pre><code>git gc
</code></pre>
<p>这将把在refs文件夹所有单独的分支与标签文件移动到在<em>.git</em>根目录中的一个叫做<code>packed-refs</code>的文件。如果你打开这个文件，你将会发现commit哈希与引用映射表：</p>
<pre><code>00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature
0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/master
bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9
</code></pre>
<p>垃圾回收对于正常的Git功能并不会有任何影响。但是，如果你想知道你的<em>.git/refs</em>文件为什么是空的话，现在你知道答案了。</p>
<h2>特殊的引用（Refs）</h2>
<p>除了引用目录之外，还有一些特别的引用存在于<em>.git</em>路径的顶部：</p>
<ul>
<li><p>HEAD – 当前检出的 commit/branch.</p></li>
<li><p>FETCH_HEAD – 最新从远程仓库获取的分支。</p></li>
<li><p>ORIG_HEAD – 作为备份指向危险操作前的HEAD。</p></li>
<li><p>MERGE_HEAD – 使用<code>git merge</code>命令合并进当前分支的提交。</p></li>
<li><p>CHERRY_PICK_HEAD – 使用<code>git cherry-pick</code>命令的提交。</p></li>
</ul>
<p>当需要时这些<em>引用</em>会被创建或更新。例如，当执行<code>git pull</code>命令时，首先会执行<code>git fetch</code>命令，此时会更新<strong>FETCH_HEAD</strong>引用，其后执行<code>git merge FETCH_HEAD</code>命令将获取的分支导入仓库。当然上述这些引用可以像普通引用一样使用，我想你一定使用过HEAD作为参数吧。</p>
<p>由于你仓库的类型与状态的差异，这些文件会包含不同的内容。HEAD引用有可能是一个指向其他引用的象征性的引用，也可能是一个commit哈希。当你在主分支下，查看你的HEAD文件内容：</p>
<pre><code>git checkout master
cat .git/HEAD
</code></pre>
<p>你将看到<code>ref: refs/heads/master</code>，这意味着HEAD指向refs/heads/master的引用。这就是为什么Git能获悉当前主分支被检出了的原因。如果切换到其他分支，HEAD的内容将被更新为指向那个分支。但是如果你在commit的层面使用<code>check out</code>而非分支层面，HEAD的内容将会是一个commit哈希而非引用。这就是为什么Git能获悉它处在独立的状态的原因。</p>
<p>多数情况，HEAD仅仅是一个你可以直接使用的引用。其他仅仅在使用Git内部工作的底层脚本时才会用到。</p>
<h2>Refspecs</h2>
<p>每个<em>refspec</em>都会创建一个本地仓库分支到远程仓库分支的映射。这让通过本地Git命令操作远程分支成为可能，并且配置一些高级的<code>git push</code>与<code>git fetch</code>行为。</p>
<p><em>refspec</em>被表示为<em>[+]&lt;src&gt;:&lt;dst&gt;</em>。<strong>&lt;src&gt;</strong>参数表示本地仓库的分支，<strong>&lt;src&gt;</strong>参数表示远程仓库的目标分支，可选参数<em>+</em>表示是否让远程仓库执行<code>non-fast-forward</code>更新。</p>
<p>Refspec可与<code>git push</code>命令联合使用来为远程分支添加不同的名字。例如，以下命令推送主分支到远程分支与寻常<code>git push</code>命令无二，所不同的是使用了<em>qa-master</em>作为分支名。这样的做法常用于需要将自己的分支推送到远程仓库的QA团队中。</p>
<pre><code>git push origin master:refs/heads/qa-master
</code></pre>
<p>你也可以通过<em>refspecs</em>来删除远程分支。在使用特性分支工作流的团队里，将特性分支推送到远程仓库是一个很常见的场景（例如出于备份的目的）。远程特性分支在本地分支从仓库中删除后会依旧存在于远程仓库中，这意味着随着你项目的推进死分支的数量会一直叠加。可以通过以下命令来删除他们：</p>
<pre><code>git push origin :some-feature
</code></pre>
<p>这是非常方便的，因为你不需要登录到远程仓库去手动删除远程分支。请注意，在Git v1.7.0你可以使用<strong>--delete</strong>来替代上述方法。下面的命令具有同样的效果：</p>
<pre><code>git push origin --delete some-feature
</code></pre>
<p>通过添加几行代码到Git配置文件中，你可以使用refspec来改变<code>git fetch</code>命令的行为。通常，<code>git fetch</code>命令会获取远程仓库所有分支，由于.git/confi文件中的一下部分：</p>
<pre><code>[remote ""origin""]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>
<p><em>fetch</em>一行告诉<code>git fetch</code>从源仓库下载所有分支。但是在一些工作流中，你并不需要把他们都下载下来。例如，许多持续集成的工作流只关注主分支。为了只获取主分支，可将<em>fetch</em>行修改为：</p>
<pre><code>[remote ""origin""]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
</code></pre>
<p>你可以用相同的方式来配置<code>git push</code>。例如你总是想要将本地的<em>qa-master</em>推送至远程（像前问所述），你可以按下述方式修改配置文件：</p>
<pre><code>[remote ""origin""]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    push = refs/heads/master:refs/heads/qa-master
</code></pre>
<p>Refspecs提供了各种能在仓库间转移分支的Git命令的一个全面控制。有了这些命令你可以重命名或删除本地仓库中的分支，通过别名提交／获取分支，控制<code>git push</code>和<code>git fetch</code>命令作用于你指定的分支。</p>
<h2>相对引用</h2>
<p>你可以通过<code>~</code>字符来引用相对于另一个commit的commit。例如：下面的代码引用了HEAD的祖父级：</p>
<pre><code>git show HEAD~2
</code></pre>
<p>但是，当用于合并提交时，事情变的有点复杂。因为合并提交存在一个以上的父级，意味着至少有两条路径可以选择。对于3路合并（两条分支合并为一体），第一父级在你执行合并命令时所在的分支，第二父级在你传入<code>git merge</code>命令的那个分支上。</p>
<p><code>~</code>字符将在第一父级上追踪，如果你想要在别的父级上追踪，你需要使用<code>^</code>字符来指定对那一个父级进行追踪。例如，如果你合并提交，下面的命令会追踪第二父级：</p>
<pre><code>git show HEAD^2
</code></pre>
<p>可以使用多个<code>^</code>来移动多代。例如，下面代码展示了追踪第二父级的HEAD的祖父级（假设其为一个合并）</p>
<pre><code>git show HEAD^2^1
</code></pre>
<p>为了说明<code>~</code>和<code>^</code>是如何工作的，下图展示了基于A通过相对引用如何追踪的每个具体的引用。在一些情况下可以通过多种方式来得到同一个提交：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHIk4?w=1068&amp;h=532"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>使用普通引用的命令也能使用相对引用。例如，以下的命令：</p>
<pre><code># 列出合并提交第二父级上的提交（commits）
git log HEAD^2

# 从当前分支上移除最近三次提交
git reset HEAD~3

# 在当前分支上动态rebase最近三次提交
git rebase -i HEAD~3
</code></pre>
<h2>Reflog</h2>
<p>reflog是Git的安全网，其中记录了基本上所有的本地仓库中的改变，不论你是否提交了快照。你可以把它想象成你对本地仓库做的多有操作的历史记录。可以运行<code>git reflog</code>命令查看reflog。将会输出如下结果：</p>
<pre><code>400e4b7 HEAD@{0}: checkout: moving from master to HEAD~2
0e25143 HEAD@{1}: commit (amend): Integrate some awesome feature into `master`
00f5425 HEAD@{2}: commit (merge): Merge branch ';feature';
ad8621a HEAD@{3}: commit: Finish the feature
</code></pre>
<p>上面代码可解读为：</p>
<ul>
<li><p>执行checked out HEAD~2</p></li>
<li><p>在此之前，修改了提交信息</p></li>
<li><p>在此之前，将特性分支合并进主分支</p></li>
<li><p>在此之前，提交了快照</p></li>
</ul>
<p>通过<em>HEAD{&lt;n&gt;}</em>语法你可以引用存在reflog中的提交。这与之前章节的<em>HEAD~&lt;n&gt;</em>有着相似的用法，但&lt;n&gt;引用reflog中的记录而不是commit历史中的记录。</p>
<p>你可以使用此方法回滚在别的记录中丢失的状态。例如，刚用<code>git reset</code>删除一个特性后，你的reflog会像下面这样：</p>
<pre><code>ad8621a HEAD@{0}: reset: moving to HEAD~3
298eb9f HEAD@{1}: commit: Some other commit message
bbe9012 HEAD@{2}: commit: Continue the feature
9cb79fa HEAD@{3}: commit: Start a new feature
</code></pre>
<p>在<code>git reset</code>命令之前执行的三个操作现在处在悬空状态，这意味着若非使用reflog你将无法通过任何方法找到他们的引用。现在你知道你不应该丢掉你所有的工作了吧。你现在需要做的就是检出HEAD@{1}提交，将你的仓库退回到执行<code>git reset</code>之前的状态。</p>
<pre><code>git checkout HEAD@{1}
</code></pre>
<p>这将把你的HEAD分离出来（和分支）从这步你可以创建一个新的分支继续你的特性开发工作。</p>
<h2>小结</h2>
<p>你现在应该很愉快地引用一个Git仓库中的commit。 我们学习了如何将分支和标签存储为.git子目录中的refs，如何读取packed-refs文件，如何表示HEAD，如何使用refspec进行高级<code>push</code>和<code>fetch</code>，以及如何使用相对<em>〜</em>和<em>^</em>字符在分支结构中切换。</p>
<p>我们还了解了reflog，这是一种引用通过任何其他方式不可用的commit的方式。这一个你有种“起死回生”之感的操作。</p>
<p>所有这一切的要点是能够精确地在开发方案中挑选出你的需要的commit。运用本文学到的知识对你已有的Git知识体系将有很大的提升：即对常用的命令<code>git log</code>,<code>git show</code>,<code>git checkout</code>,<code>git reset</code>,<code>git revert</code>,<code>git rebase</code>等命令使用<code>refs</code>作为参数。</p>

                ", Git系列之Refs 与 Reflog,1531977891,379,1,347,1,1,https://segmentfault.com/a/1190000007996197
162,1,0,7,"
                    
<h3>优化工具</h3>
<ul>
<li><p>JPG、PNG压缩工具：<a href=""https://tinypng.com/"" rel=""nofollow noreferrer"">在线编辑网站</a></p></li>
<li><p>SVG在线压缩：<a href=""http://iconizr.com/"" rel=""nofollow noreferrer"">在线编辑网站</a></p></li>
<li><p><a href=""http://www.bitbug.net/"" rel=""nofollow noreferrer"">在线制作favicon</a></p></li>
<li><p>在线检测兼容性<a href=""http://caniuse.com/#home"" rel=""nofollow noreferrer"">Can I Use</a></p></li>
<li><p><a href=""http://browserhacks.com/"" rel=""nofollow noreferrer"">不同浏览器hack一览网站</a></p></li>
<li><p><a href=""http://necolas.github.io/normalize.css/"" rel=""nofollow noreferrer"">CSS normalize</a></p></li>
</ul>
<h3>调试工具</h3>
<ul>
<li><p>调试网站模拟不同系统是所需虚拟机：Virtual Box、VMware</p></li>
<li><p><a href=""https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/"" rel=""nofollow noreferrer"">Windows不同系统镜像</a>（包含不同的IE浏览器版本）</p></li>
<li><p><a href=""http://www.genymotion.net/"" rel=""nofollow noreferrer"">安卓模拟器</a></p></li>
<li><p>浏览器同步测试工具<a href=""http://www.browsersync.cn/"" rel=""nofollow noreferrer"">BrowerSync</a></p></li>
<li><p>在线网站性能测试<a href=""http://www.webpagetest.org/"" rel=""nofollow noreferrer"">WebPagetest</a></p></li>
</ul>
<h3>Polyfill</h3>
<ul>
<li><p><a href=""https://github.com/OwlCarousel2/OwlCarousel2"" rel=""nofollow noreferrer"">焦点图组件库</a></p></li>
<li><p><a href=""http://scottjehl.github.io/picturefill/"" rel=""nofollow noreferrer"">picture元素模拟库</a></p></li>
<li><p><a href=""https://github.com/aFarkas/html5shiv"" rel=""nofollow noreferrer"">兼容老版本IE不支持HTML5的模拟库</a></p></li>
<li><p><a href=""https://github.com/scottjehl/Respond"" rel=""nofollow noreferrer"">兼容老版本IE不支持CSS3的媒体查询的模拟库</a></p></li>
</ul>
<h3>小工具</h3>
<ul>
<li><p>icon字体图标在线生成工具<a href=""https://icomoon.io/app/#/select/font"" rel=""nofollow noreferrer"">Ico Moon</a></p></li>
<li><p>阿里巴巴矢量图标库<a href=""http://www.iconfont.cn/"" rel=""nofollow noreferrer"">Iconfont</a></p></li>
<li><p>雪碧图生成工具<a href=""http://www.99css.com/1524/"" rel=""nofollow noreferrer"">CssGaga</a></p></li>
<li><p>浏览器插件---<a href=""https://www.baidufe.com/fehelper"" rel=""nofollow noreferrer"">Web前端助手Helper</a></p></li>
<li><p>Gith UI操作软件SourceTreeSetup</p></li>
<li><p>取色软件<a href=""http://ngwin.com/picpick"" rel=""nofollow noreferrer"">Picpick</a></p></li>
<li><p>LongPathTool v2.20 绿色版(Windows长路径文件删除工具)</p></li>
</ul>
<h3>前端开发常用工具</h3>
<ul>
<li><p>Photoshop</p></li>
<li><p>Axure</p></li>
<li><p>Sublime Text、Atom</p></li>
<li><p><a href=""http://yanxyz.github.io/emmet-docs/"" rel=""nofollow noreferrer"">Emmet</a></p></li>
<li><p>Node.js、NPM</p></li>
<li><p>Windows下安装<a href=""https://git-scm.com/download/"" rel=""nofollow noreferrer"">Git Bash</a>、<a href=""https://git-scm.com/downloads/guis"" rel=""nofollow noreferrer"">GUI</a></p></li>
<li><p>Grunt、Gulp、Webpack</p></li>
<li><p>Fiddler</p></li>
<li><p>常用配置文件：rebots.txt、humans.txt、.editorconfig、gitignore、LICENSE.txt、README.md、CHANGELOG.md</p></li>
<li><p>常用库和框架Bootstrap、JQuery、React、AngularJs、Vue</p></li>
<li><p>Apache</p></li>
<li><p>FireFox 15.0.1</p></li>
</ul>

                ", 前端开发工具一览,1531977892,590,1,593,1,1,https://segmentfault.com/a/1190000007967862
163,1,0,7,"
                    
<p><a href=""https://www.atlassian.com/git/tutorials/merging-vs-rebasing/summary"" rel=""nofollow noreferrer"">原文地址</a></p>
<p><code>git rebase</code>因其“新手应当远离的Git黑魔法”的名号名声在外，但只要使用得当，其可以使团队开发变得无比轻松。本文将对比两个相似的命令：<code>git rebase</code>与<code>git rebase</code>来区分它们的使用场景，最终将“黑魔法”纳入自己的工作流中。</p>
<h2>概述</h2>
<p>首先你需要明白<code>git rebase</code>与<code>git merge</code>解决的是同一类问题，即都被设计来解决将一个分支与另一个分支整合的工作，所以它们可谓一体两面。</p>
<p>想象一下但你在专用分支上开发一个新的特性时，团队的另一个成员更新了主分支。这导致了及时记录上的一个分叉，这一场景对以Git作为协作工具的你我是再熟悉不过了。</p>
<p>假设这一提交与你在开发的功能有关，为了将提交纳入你的特性分支中，你必须在合并（merge）和变基（rebase）中作出选择。</p>
<h3>选择合并</h3>
<p>最简单的方式就是使用如下操作将主分支合并入特性分支中：</p>
<pre><code>git checkout feature
git merge master
</code></pre>
<p>或者用一行操作：</p>
<pre><code>git merge master feature
</code></pre>
<p>此时在特性分支上有了一次“合并提交（merge commit）”将两个分支的历史线中出现了一个共同节点如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHsjY?w=968&amp;h=578"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><code>merge</code>是一个很优秀的命令，它是一个非破坏性的操作（历史线不改变结构）。已存在的分支并不会有任何变化。这能避免所有由rebase带来的潜在陷阱（后文将涉及）。</p>
<p>不过这也意味着，在每次相关上游变化时，你都要添加一条无关的合并提交。如果主分支更新活跃，使用合并会很大程度上污染你的特性分支历史线。虽然<code>git log</code>命令可以一定程度缓解这一问题，但是其他程序猿将难以理解项目的历史线。</p>
<h3>选择rebase</h3>
<p>作为<code>merge</code>的替代，你可以使用一下命令进行<code>rebase</code>：</p>
<pre><code>git checkout feature
git rebase master
</code></pre>
<p>这样所有的特性分支被移至主分支的末端，有效地纳入了主分支的新提交。但是<code>rebase</code>命令重写了项目的历史线通过对先前分支的每一个提交都创建新的提交。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHsAe?w=1138&amp;h=652"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><code>rebase</code>带来的主要好处是更清晰的项目历史线。首先，不再会有由merge带来的不必要的合并提交。其次，如上图所示，rebase命令将项目历史线变得理想的线形（从头到尾都没有分叉），这样，使用<code>git log</code>，<code>git bisect</code>，<code>gitk</code>这样的命令都能轻松定位你的项目。</p>
<p>但是，对于rebase操作有两个需要考虑的点：安全性和可追溯性。你若不遵循“Rebase黄精准则”重写历史线将会给你的合作工作流带来灭顶之灾。还有一点需要注意的是：rebase并不存在像merge一样的上下文，这意味着你很难定位由上游变化而带来的特性的合并的位置。</p>
<h3>交互式rebase</h3>
<p>交互式rebase让你有能力去控制最终移动到分支末尾的提交。这比自动提交来的更强大，因其提供了对提交历史完整的控制。这通常被用于将某个分支合并进主分支之前，去清理杂乱的历史线。</p>
<p>通过加上在<code>git rebase</code>中加入<code>i</code>选项来开启交互式rebase：</p>
<pre><code>git checkout feature
git rebase -i master
</code></pre>
<p>之后会打开一个文本编辑，其中罗列了将会被移动的所有提交：</p>
<pre><code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
</code></pre>
<p>这一列表展示的就是最终执行<code>rebase</code>后分支。通过改变<strong>pick</strong>命令或重排顺序，你可以将分支历史线变成需要的样子。例如，如果第二行提交是为了修正了第一行提交的中德小问题，你可以将两者合为一条通过<code>fixup</code>命令：</p>
<pre><code>pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
</code></pre>
<p>当你保存并关闭了文件，git会根据你的指令去执行<code>rebase</code>命令。项目历史线的结果如下：<br>去除掉非必要的提交后可以让你的特性分支历史线更容易读懂，这是简单的<code>git merge</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVHsI4?w=962&amp;h=694"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Rebase黄金法则</h2>
<p>一旦你理解了rebase，最重要的事就是学会何时不使用rebase。Rebase黄金法则：永远不要在公开分支上使用<code>git rebase</code>。</p>
<p>例如，想象一下如果你将你的特性分支rebase到主分支：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHsRa?w=1102&amp;h=764"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>rebase将移动所有主分支上的所有提交到特性分支末端。问题是这只发生在你的仓库中。其他开发者依旧在最早的分支中开发。由于改变了最新的提交，Git会认为你的分支历史线与其他成员产生了分岔。</p>
<p>唯一能使两天分支同步的办法就是将它们合并在一起，这将会导致一条额外的提交与两组对相同变化的提交（初始分支上，你rebase的分支上）。不必说，这是一个极容易让人混淆的状态。</p>
<p>在你执行<code>git rebase</code>之前，问一问自己，“其他人会看到这条分支？”如果会，把手从键盘上移开并且想一个无破坏性的方式来解决（例如<code>git revert</code>命令）。此外，你可以尽情重写历史线。</p>
<h3>强制发布</h3>
<p>如果你要将一个rebase过的分支发布到远程分支上，Git会阻止你这样做，因为这会和远程主分支产生冲突。但是，可以加上<strong>-- force</strong>参数来强制发布：</p>
<pre><code># Be very careful with this command!
git push --force
</code></pre>
<p>该操作会用你仓库中的主分支覆盖远程仓库中的主分支，并且让团队中其他成员一头雾水。所以，请谨慎使用这条命令。</p>
<p>唯一需要强制推送的情况是在你推送了一个个人特性分支到远程仓库后，你完成了一次本地的清理。这好像就在说“哎哟喂，我不想要之前上传的特性分支了，用现在的版本替代吧”同时，需要确保没有人在之前那个版本的提交下开展工作。</p>
<h2>工作流演练</h2>
<p>Rebase可以被尽可能多／少地纳入你们现有的工作流中，这取决于团队对于它的态度。本节中我们将了解到rebase在分支开发的各个阶段带来的好处。</p>
<p>使用<code>git rebase</code>的任何工作流的第一步是为每个特性创建一个专有分支。这将为你安全地使用<code>rebase</code>提供必须的分支结构。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHtjb?w=1010&amp;h=680"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>本地清理</h3>
<p>将<code>rebase</code>纳入你们的工作的的一个最好的方法是去清理本地在开发的特性。通过周期性的使用交互式rebase，可以确保你特性上的每一次提交是清晰且有意义的。这使得你可以去书写代码而不必担忧将其分割为一次独立的提交，因为事后还是可以修复的。</p>
<p>当调用<code>git rebase</code>命令时，你需呀注意两个选项：特性的父分支（如主分支）或是在你的特性上更早的提交。我们参考<em>交互式rebase</em>一节中关于第一选项的例子。当你仅需要修改最近的几次提交时后一个参数是很有用的。例如，例如下面的命令创建一个只有最近三次提交的<em>交互式rebase</em>。</p>
<pre><code>git checkout feature
git rebase -i HEAD~3
</code></pre>
<p>通过将<code>HEAD~3</code>指定为新的“基”，你实际并不需要移动分支，你只是重写了三次提交。值得注意的是上述操作并没有把依赖的变化纳入<em>特性</em>分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHtrL?w=1032&amp;h=862"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果你想要使用这种方法重写全部的特性，<code>git merge-base</code>命令将能够帮助你找到特性分支之前的基。以下命令会返回之前基的<code>提交ID</code>，用于之后执行<code>git rebase</code>使用。</p>
<pre><code>git merge-base feature master
</code></pre>
<p>这种交互式rebase的用法是将<code>git rebase</code>引入你们工作流的一个好方法。其他开发者看到的只会是你最终的成品，其将拥有清晰，易于理解的特性分支历史。</p>
<p>但是再次重申，这只适用于专有特性分支，如果你和其他开发者同时在相同的分支上合作，那条分支就是共有的，重写历史线将不被允许。</p>
<p><em>交互式rebase</em>用于清理本地提交的功能是不存在<code>git merge</code>类的替代功能的。</p>
<h3>将依赖的变化纳入特性中</h3>
<p>在概述一节中，你了解到了如何使用<code>git merge</code>/<code>git rebase</code>将主分支上游的变化纳入一个特性分支中去。merge是一个可以保证仓库历史线的安全选择，同时，rebase通过将你的特性分支移至主分支末端来创建一条线形的历史线。</p>
<p>该用法与本地清理相似（可以同时进行），但是该过程从主分支纳入了上游提交。</p>
<p>请牢记，除了远程主分支外的任意远程分支的rebase都是完全合法的。这通常发生在团队协同开发同一特性，你需要将成员的修改纳入你的仓库时。</p>
<p>例如，如果你的伙伴<em>John</em>提交了一次修改，当你fetch远程分支从<em>John</em>的仓库中，你的分支就会像下图一样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHt7M?w=854&amp;h=684"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>解决这一分岔你有两个选择：<br>1.用本地分支与<em>John</em>的分支进行merge：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHt8m?w=1004&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.使用rebase将你本地的特性分支移至<em>John</em>的分支末端：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHt8w?w=1064&amp;h=788"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>注意这并未违背Rebase黄金法则，因为移动只发生在你的本地分支提交后，在此之前都是不变的。也就是说“添加我的修改在<em>John</em>的工作之后”。在多数情况下这比通过合并提交使远程分支同步的方法来得更为直观。</p>
<p>默认情况下，<code>git pull</code>命令执行了一个merge，但是你可是通过加上<code>--rebase</code>选项强制其使用rebase。</p>
<h3>使用<code>Pull Request</code>检查分支</h3>
<p>如果你在代码检查阶段有使用<code>Pull Request</code>，那么你需要避免使用<code>git rebase</code>在你创建了<code>pull request</code>后。一旦你执行了<code>pull request</code>,其他开发者将会看见你的提交，这意味着这就是一个公共分支。重写历史线将导致Git和你的团队成员不能追踪到在此特性上补增的提交。</p>
<p>任何从其他开发者纳入的修改请使用<code>git merge</code>而不要用<code>git rebase</code>。</p>
<p>因此，通常的清理代码的做法是在执行你的<code>pull request</code>前使用<strong>交互式rebase</strong>。</p>
<h3>合并一个审核过的特性</h3>
<p>当一个特性通过团队的审核后，在将特性整合进主代码库前，你可以选择将特性rebase到主分支末端。</p>
<p>该步骤和把上游修改整合进特性相似，但不同的是，由于你不能在主分支上重写提交（commits），你最终必须使用<code>git merge</code>来合并特性。然而通过在<code>rebase</code>之前执行<code>rebase</code>可以确保迅速的合并，并且得到一条完美的线形历史线。这也提供了一个在<code>pull request</code>阶段塞入任意补增提交的机会。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHug5?w=1084&amp;h=750"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVHug6?w=1192&amp;h=700"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVHuhV?w=1280&amp;h=802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果你还无法完全适应<code>git rebase</code>你可以在短期分支上使用它。这时，当你不小心弄乱了你的分支历史线，你可以<code>checkout</code>早前的分支，并且再次尝试：</p>
<pre><code>git checkout feature
git checkout -b temporary-branch
git rebase -i master
# [Clean up the history]
git checkout master
git merge temporary-branch
</code></pre>
<h2>总结</h2>
<p>以上就是开始rebase你的分支前你需要知道的一切。如果你想要一条干净，清晰的历史线（没有非必要的合并提交），那么你需要使用<code>git rebase</code>去吸纳别的分支上的修改而非使用<code>git merge</code>。</p>
<p>不过，如果你想要保留完整的项目历史线，避免重写公共提交，那你需要贯彻<code>git merge</code>。这两者都是完全有效的。但是至少现在你需要衡量一下使用<code>git rebase</code>这个选择将带来的优势。</p>

                ", Git系列之Merging vs. Rebasing,1531977894,431,1,290,1,1,https://segmentfault.com/a/1190000007942341
164,1,0,7,"
                    
<p>本文目的是通过自己写的一个php的简单的库（<a href=""https://github.com/rpnanhai/huami"" rel=""nofollow noreferrer"">花密密码生成工具</a>），</p>
<p>来学习我认为的php库开发的一些规范，以及github上持续构建你的项目的一些方法。其实是为了显示下边一系列的的徽章</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHfPj?w=711&amp;h=180"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>本文涉及的内容有：</p>
<ul>
<li><p>项目目录</p></li>
<li><p>php的psr规范</p></li>
<li><p>php备注的规范</p></li>
<li><p>php的包管理器composer</p></li>
<li><p>php保证代码质量（php-cs-fix，styleci，phpunit，coveralls）</p></li>
<li><p>php的持续集成Travis CI</p></li>
<li><p>php包发布Packagist 以及 LICENSE</p></li>
<li><p>更多的徽章获得</p></li>
</ul>
<h2>项目目录</h2>
<pre><code>    /
    |── bin/                            //命令行目录
    |── build/                          //构建目录
    |── src/                            //用于存放项目源代码
    |── tests/                          //单元测试目录
    |   ├── ClassNameTest/              //测试目录
    |   |── phpunit.xml                 //phpunit 配置文件
    |   └── bootstrap.php               //phpunit 引导文件
    |── vendor/                         //第三方依赖库
    |── .gitignore                      //git忽略文件
    |── .gitmessage                     //git提交规范文件
    |── .php_cs                         //php-cs-fix配置文件
    |── .styleci.yml                    //https://styleci.io配置文件
    |── .travis.yml                     //Travis CI 配置文件
    |── LICENSE                         //LICENSE
    |── composer.json                   //composer配置
    └── README.md                       //README</code></pre>
<h2>php的psr规范</h2>
<p><a href=""https://github.com/PizzaLiu/PHP-FIG"" rel=""nofollow noreferrer"">详见</a></p>
<p><strong>PSR-1</strong> 基本代码规范:</p>
<p><strong>PSR-2</strong> 代码风格规范:(本篇规范是 PSR-1 基本代码规范的继承与扩展)</p>
<p><strong>PSR-3</strong> 日志接口规范:</p>
<p><strong>PSR-4</strong> 自动加载相关</p>
<p><strong>PSR-7</strong> HTTP消息相关</p>
<h2>php备注的规范</h2>
<p><a href=""https://zh.wikipedia.org/wiki/PHPDoc"" rel=""nofollow noreferrer"">PHPDoc WIKI</a></p>
<ul>
<li><p>@name 名字</p></li>
<li><p><a href=""/u/abstract"" rel=""nofollow noreferrer"">@abstract</a> 申明变量/类/方法</p></li>
<li><p>@access 指明这个变量、类、函数/方法的存取权限</p></li>
<li><p>@author 函数作者的名字和邮箱地址</p></li>
<li><p>@category  组织packages</p></li>
<li><p>@copyright 指明版权信息</p></li>
<li><p>@const 指明常量</p></li>
<li><p>@deprecate 指明不推荐或者是废弃的信息MyEclipse编码设置</p></li>
<li><p><a href=""/u/example"" rel=""nofollow noreferrer"">@example</a> 示例</p></li>
<li><p>@exclude 指明当前的注释将不进行分析，不出现在文挡中</p></li>
<li><p><a href=""/u/final"" rel=""nofollow noreferrer"">@final</a> 指明这是一个最终的类、方法、属性，禁止派生、修改。</p></li>
<li><p>@global 指明在此函数中引用的全局变量</p></li>
<li><p><a href=""/u/include"" rel=""nofollow noreferrer"">@include</a> 指明包含的文件的信息</p></li>
<li><p>@link 定义在线连接</p></li>
<li><p>@module 定义归属的模块信息</p></li>
<li><p>@modulegroup 定义归属的模块组</p></li>
<li><p>@package 定义归属的包的信息</p></li>
<li><p>@param 定义函数或者方法的参数信息</p></li>
<li><p><a href=""/u/return"" rel=""nofollow noreferrer"">@return</a> 定义函数或者方法的返回信息</p></li>
<li><p><a href=""/u/see_55f1cc43cc79f"" rel=""nofollow noreferrer"">@see</a> 定义需要参考的函数、变量，并加入相应的超级连接。</p></li>
<li><p>@since 指明该api函数或者方法是从哪个版本开始引入的</p></li>
<li><p><a href=""/u/static"" rel=""nofollow noreferrer"">@static</a> 指明变量、类、函数是静态的。</p></li>
<li><p><a href=""/u/throws"" rel=""nofollow noreferrer"">@throws</a> 指明此函数可能抛出的错误异常,极其发生的情况</p></li>
<li><p>@todo 指明应该改进或没有实现的地方</p></li>
<li><p>@var 定义说明变量/属性。</p></li>
<li><p>@version 定义版本信息</p></li>
</ul>
<h2>php的包管理器composer</h2>
<p>详见<a href=""http://docs.phpcomposer.com/"" rel=""nofollow noreferrer"">composer中文网</a></p>
<p><strong>注意</strong>：如果访问不了国外镜像，可以全局修改使用中国镜像</p>
<pre><code class=""shell"">  $  composer config -g repo.packagist composer https://packagist.phpcomposer.com</code></pre>
<h2>php保证代码质量</h2>
<p>这一部分现在有很多解决方案。在github搜索phpQA也很多集成工具包</p>
<p>在我这个项目主要用到的就是php-cs-fix,phpunit.为了保证在github的代码风格<br>，用了<a href=""https://styleci.io"" rel=""nofollow noreferrer"">https://styleci.io</a>。</p>
<h3>php-cs-fix</h3>
<p>有关php-cs-fix可以参考这篇文章文章学习 <a href=""https://segmentfault.com/a/1190000004162229"" rel=""nofollow noreferrer"">php-cs-fixer - PHP 编码格式化工具</a><br>但是上边文章是php-cs-fix 配置文件是1.*版本的。现在<a href=""https://github.com/FriendsOfPHP/PHP-CS-Fixer"" rel=""nofollow noreferrer"">官网</a>升级到2.*版本。<br>很多配置文件名变化了。具体变化可以参考官方说明<a href=""https://github.com/FriendsOfPHP/PHP-CS-Fixer/UPGRADE.md"" rel=""nofollow noreferrer"">UPGRADE.md</a><br>下边给出在这个项目里的配置<a href=""https://github.com/rpnanhai/huami/blob/master/.php_cs"" rel=""nofollow noreferrer"">.cs_php</a></p>
<pre><code class=""php"">&lt;?php
$year = date('Y');
$header = &lt;&lt;&lt;EOF
The file is part of the rpnanhai/huami
(c) $year rpnanhai &lt;rpnanhai@gamil.com&gt;
This source file is subject to the MIT license that is bundled
with this source code in the file LICENSE.
EOF;
$finder = PhpCsFixer\Finder::create()
    -&gt;files()
    -&gt;name('*.php')
    -&gt;exclude('vendor')
    -&gt;in(__DIR__)
    -&gt;ignoreDotFiles(true)
    -&gt;ignoreVCS(true);
;
$fixers = array(
    '@PSR2' =&gt; true,
    'header_comment' =&gt; array('header' =&gt; $header),
    'no_empty_statement' =&gt; true, //多余的分号
    'no_extra_consecutive_blank_lines' =&gt; true, //多余空白行
    'include' =&gt; true, //include 和文件路径之间需要有一个空格，文件路径不需要用括号括起来；
    'no_trailing_comma_in_list_call'  =&gt; true, //删除 list 语句中多余的逗号；
    'no_leading_namespace_whitespace' =&gt; true, //命名空间前面不应该有空格；
    'array_syntax'  =&gt; array('syntax' =&gt; 'short'), //数组 【】 php版本大于5.4
    'no_blank_lines_after_class_opening' =&gt; true, //类开始标签后不应该有空白行；
    'no_blank_lines_after_phpdoc' =&gt; true, //PHP 文档块开始开始元素下面不应该有空白行；
    'object_operator_without_whitespace' =&gt; true, //(-&gt;) 两端不应有空格；
    'binary_operator_spaces'    =&gt; true, //二进制操作符两端至少有一个空格；
    'phpdoc_indent'             =&gt; true, //phpdoc 应该保持缩进；
    'phpdoc_no_access'          =&gt; true, //@access 不应该出现在 phpdoc 中；
    'phpdoc_no_package'         =&gt; true,
    'phpdoc_scalar'             =&gt; true, //phpdoc 标量类型声明时应该使用 int 而不是 integer，bool 而不是 boolean，float 而不是 real 或者 double；
    'phpdoc_to_comment'         =&gt; true, //文档块应该都是结构化的元素；
    'phpdoc_trim'               =&gt; true,
    'phpdoc_no_alias_tag'       =&gt; array('type' =&gt; 'var'),// @type 需要使用 @var 代替；
    'phpdoc_var_without_name'   =&gt; true, //@var 和 @type 注释中不应该包含变量名；
    'no_leading_import_slash'   =&gt; true, //删除 use 前的空行；
    //'no_extra_consecutive_blank_lines'  =&gt; array('use'), //删除 use 语句块中的空行；
    'self_accessor'             =&gt; true, //在当前类中使用 self 代替类名；
    'no_trailing_comma_in_singleline_array' =&gt; true, //PHP 单行数组最后一个元素后面不应该有空格；
    'single_blank_line_before_namespace' =&gt; true,//命名空间声明前应该有一个空白行；
    'single_quote'      =&gt; true,    //简单字符串应该使用单引号代替双引号；
    'binary_operator_spaces'    =&gt; array('align_equals' =&gt; true,'align_double_arrow' =&gt; true), //等号 =&gt; 对齐   symfony是不对齐的
    'no_singleline_whitespace_before_semicolons' =&gt; true, //禁止只有单行空格和分号的写法；
    'cast_spaces'   =&gt;   true, //变量和修饰符之间应该有一个空格；
    'standardize_not_equals' =&gt; true, //使用 &lt;&gt; 代替 !=；
    'concat_space' =&gt; array('spacing' =&gt; 'one'), //点连接符左右两边有一个的空格；symfony是没空格
    'ternary_operator_spaces'   =&gt; true, //三元运算符之间的空格标准化
    'trim_array_spaces' =&gt; true, //数组需要格式化成和函数/方法参数类似，上下没有空白行；
    'unary_operator_spaces' =&gt; true, //一元运算符和运算数需要相邻;
    'no_whitespace_in_blank_line' =&gt; true, //删除空白行中多余的空格；
    'no_multiline_whitespace_before_semicolons' =&gt; true, //分号前的空格
    'no_unused_imports' =&gt; true, //删除没用到的use
);
return PhpCsFixer\Config::create()
    -&gt;setRules($fixers)
    -&gt;setFinder($finder)
    -&gt;setUsingCache(false);</code></pre>
<p>另外php-cs-fix都有对应的编辑器插件比如：</p>
<ul>
<li><p><a href=""http://tzfrs.de/2015/01/automatically-format-code-to-match-psr-standards-with-phpstorm/"" rel=""nofollow noreferrer"">PhpStorm</a></p></li>
<li><p><a href=""https://github.com/benmatselby/sublime-phpcs"" rel=""nofollow noreferrer"">Sublime Text</a></p></li>
<li><p><a href=""https://github.com/stephpy/vim-php-cs-fixer"" rel=""nofollow noreferrer"">Vim</a></p></li>
</ul>
<h3>styleci</h3>
<p>在规定了自己的代码规范之后，如何保证别人提交的pr是否符合你的规范呢。</p>
<p>这时候就需要用<a href=""https://styleci.io"" rel=""nofollow noreferrer"">https://styleci.io</a>。通过github帐号注册后。就可以关联你的项目。</p>
<p>在你的项目目录添加配置文件 <a href=""https://github.com/rpnanhai/huami/blob/master/.styleci.yml"" rel=""nofollow noreferrer"">.styleci.yml</a></p>
<p>下边是和上面.php_cs对应的我的styleci配置文件，具体可以看<a href=""https://styleci.io"" rel=""nofollow noreferrer"">https://styleci.io</a>文档</p>
<pre><code class=""yml"">preset: PSR2

risky: false

enabled:
  - no_empty_statement
  - no_extra_consecutive_blank_lines
  - include
  - no_trailing_comma_in_list_call
  - no_leading_namespace_whitespace
  - no_blank_lines_after_class_opening
  - no_blank_lines_after_phpdoc
  - object_operator_without_whitespace
  - binary_operator_spaces
  - phpdoc_indent
  - phpdoc_no_access
  - phpdoc_no_package
  - phpdoc_scalar
  - phpdoc_to_comment
  - phpdoc_trim
  - phpdoc_type_to_var
  - phpdoc_var_without_name
  - no_leading_import_slash
  - remove_lines_between_uses
  - self_accessor
  - no_trailing_comma_in_singleline_array
  - single_blank_line_before_namespace
  - single_quote
  - align_equals
  - no_singleline_whitespace_before_semicolons
  - cast_spaces
  - standardize_not_equals
  - concat_with_spaces
  - ternary_operator_spaces
  - trim_array_spaces
  - unary_operator_spaces
  - no_whitespace_in_blank_line
  - no_multiline_whitespace_before_semicolons
  - no_unused_imports
  - align_double_arrow
  - short_array_syntax


finder:
  exclude:
    - ""vendor""
  name:
    - ""*.php""</code></pre>
<p>另外在<a href=""https://styleci.io"" rel=""nofollow noreferrer"">https://styleci.io</a>有这个徽章。<span class=""img-wrap""><img data-src=""/img/bVHfP4?w=107&amp;h=31"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span>，可以自己的项目添加上了。</p>
<h3>phpunit</h3>
<p>php单元测试，具体使用可以参考<a href=""https://phpunit.de/manual/current/zh_cn/"" rel=""nofollow noreferrer"">中文手册</a></p>
<p>这里配置好之后主要通过Travis CI进行调用，下边会讲到。</p>
<h3>coveralls</h3>
<p>coveralls是利用phpunit生成测试代码覆盖率的xml，来展示你的代码覆盖率。<br>网址是<a href=""https://coveralls.io/"" rel=""nofollow noreferrer"">https://coveralls.io/</a>。 依然是github注册。然后在Travis CI进行调用。需要 <code>satooshi/php-coveralls</code> 这个库调用。<br>在这个coveralls配置好之后就可以添加<span class=""img-wrap""><img data-src=""/img/bVHfUm?w=103&amp;h=27"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span>这个徽章了。</p>
<h2>php的持续集成Travis CI</h2>
<p>登录<a href=""https://travis-ci.org/"" rel=""nofollow noreferrer"">https://travis-ci.org/</a>，依然使用github注册之后。给自己的项目开启持续构建。添加配置文件， ``</p>
<pre><code class=""yml"">language: php

php:
  # - 5.4
  # - 5.5
  - 5.6
  - 7.0
  # - 7.1

before_script:
  - composer self-update
  - composer install -n --dev --prefer-source

script:
  - mkdir -p build/logs
  - ./vendor/bin/phpunit -c tests/phpunit.xml --coverage-clover build/logs/clover.xml

after_script:
  #coveralls调用 默认文件是build/logs/clover.xml，如果不是可以添加配置
  - travis_retry ./vendor/bin/coveralls -v

matrix:
  fast_finish: true</code></pre>
<p>这时候push你的代码就可以开始持续构建了。另外在Travis CI可以获取<span class=""img-wrap""><img data-src=""/img/bVHfVF?w=96&amp;h=25"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span>这个徽章。</p>
<h2>php包发布Packagist 以及 LICENSE</h2>
<p>当你的代码完成后，测试完成后。就可以发布到<a href=""https://packagist.org/"" rel=""nofollow noreferrer"">Packagist</a>包管理平台了。<br>如果composer.json配置好，按照官网一步一步来还是比较容易的，记得设置hook自动更新。<br>另外如果你的composer设置的国内的镜像，大概会有一到两个小时的延迟。</p>
<p>关于LICENSE的选取，可以参考这篇文章<a href=""http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html"" rel=""nofollow noreferrer"">如何选择开源许可证？</a></p>
<p>在发布完之后就可以去<a href=""https://poser.pugx.org/"" rel=""nofollow noreferrer"">https://poser.pugx.org/</a> 获取<span class=""img-wrap""><img data-src=""/img/bVHfYj?w=281&amp;h=28"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span>这几个徽章了。</p>
<h2>更多的徽章获得</h2>
<p>大家可以通过<a href=""http://shields.io/"" rel=""nofollow noreferrer"">http://shields.io/</a>这个网站来获得，获得去github添加更多的integrations，来获得相对应的徽章。<br><br><br><br><br><br></p>

                ", 在github规范开发以及持续构建php项目,1531977895,383,1,125,1,1,https://segmentfault.com/a/1190000007887167
165,1,0,7,"
                    
<blockquote>
<p>TLDR;</p>
<ol>
<li><p>介绍 Git 钩子的基本开发流程</p></li>
<li><p>介绍如何用 Node.js 写 Git 钩子</p></li>
</ol>
</blockquote>
<h2>Hooks-钩子</h2>
<h3>简介</h3>
<p>Git 钩子是指在特定的 Git 动作（如：<code>git commit</code>、 <code>git push </code>）下被触发的脚本。而钩子主要被分为两种：</p>
<ol>
<li><p>客户端钩子</p></li>
<li><p>服务端钩子</p></li>
</ol>
<p>而客户端钩子又被分为以下几种：</p>
<table>
<thead><tr>
<th>类型</th>
<th>钩子名称</th>
<th>接收参数</th>
<th>可否终止操作</th>
</tr></thead>
<tbody>
<tr>
<td>提交工作流钩子</td>
<td>pre-commit</td>
<td>\</td>
<td>是</td>
</tr>
<tr>
<td>提交工作流钩子</td>
<td>prepare-commit-msg</td>
<td>filepath、committype、sha-1</td>
<td>\</td>
</tr>
<tr>
<td>提交工作流钩子</td>
<td>commit-msg</td>
<td>filepath</td>
<td>是</td>
</tr>
<tr>
<td>提交工作流钩子</td>
<td>post-commit</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>电子邮件工作流钩子</td>
<td>applypatch-msg</td>
<td>merge-filename</td>
<td>是</td>
</tr>
<tr>
<td>电子邮件工作流钩子</td>
<td>pre-applypatch</td>
<td>\</td>
<td>是</td>
</tr>
<tr>
<td>电子邮件工作流钩子</td>
<td>post-commit</td>
<td>\</td>
<td>否</td>
</tr>
<tr>
<td>其它客户端钩子</td>
<td>pre-rebase</td>
<td>\</td>
<td>是</td>
</tr>
<tr>
<td>其它客户端钩子</td>
<td>post-rewrite、post-checkout 和 post-merge</td>
<td>commandname</td>
<td>\</td>
</tr>
<tr>
<td>其它客户端钩子</td>
<td>pre-push</td>
<td>originbranhname &amp; head</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>服务器端钩子主要有三种：</p>
<table>
<thead><tr>
<th>钩子名称</th>
<th>接收参数</th>
<th>可否终止操作</th>
</tr></thead>
<tbody>
<tr>
<td>pre-receive</td>
<td>推送的引用</td>
<td>是</td>
</tr>
<tr>
<td>update</td>
<td>引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值</td>
<td>是</td>
</tr>
<tr>
<td>post-receive</td>
<td>同pre-receive</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3>客户端钩子和服务端钩子的异同</h3>
<p>Git 的钩子不管客户端钩子还是服务端钩子，都是放在当前项目的 <br><code>.git/hooks</code> 目录下。不同的是，客户端钩子是放置在你的本地项目的目录下，而服务器端钩子是放在对应的服务器上的目录。</p>
<p>我们知道 Git 相当于本地的文件数据库，而 <code>.git</code> 目录存放了项目文件的快照以及其他一系列 git 信息，且 <code>.git</code> 目录是不会被提交到服务器上的，所以放置在 <code>.git/hooks</code> 目录中的客户端脚本也不会被提交。所以如果想让项目中的其他人使用你的钩子，就需要一种策略来偷偷的安装这个钩子或者在服务端放置实现这个钩子的功能。</p>
<h2>如何用 Nodejs 写一个钩子</h2>
<blockquote>
<p>钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。</p>
<p>把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。</p>
</blockquote>
<p>之后我会用 Node.js 来写一个<code>拒绝提交没有被解决的冲突的文件</code>的钩子。</p>
<p>需要的知识储备：</p>
<ul>
<li><p>会写 Javascript</p></li>
<li><p>了解一点环境变量的知识</p></li>
<li><p>了解 Nodejs require 路径规则</p></li>
</ul>
<p>写这个钩子的初衷是因为在多人合作项目中，总是难免会遇到文件冲突的情况，而有些同事没有找到全部的冲突文件并一一解决，这个钩子就会在 commit 的时候检查是否有冲突，如果有冲突，就会把所有冲突找到，并提示出错文件后，拒绝 commit。</p>
<p>直接上源码:</p>
<pre><code class=""js"">#!/usr/bin/env node
// 在 commit 之前检查是否有冲突，如果有冲突就 process.exit(1)

const execSync = require('child_process').execSync

// git 对所有冲突的地方都会生成下面这种格式的信息，所以写个检测冲突文件的正则
const isConflictRegular = ""^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s""

let results

try {
 // git grep 命令会执行 perl 的正则匹配所有满足冲突条件的文件
    results = execSync(`git grep -n -P ""${isConflictRegular}""`, {encoding: 'utf-8'})
} catch (e) {
    console.log('没有发现冲突，等待 commit')
    process.exit(0)
}

if(results) {
    console.error('发现冲突，请解决后再提交，冲突文件：')
    console.error(results.trim())
    process.exit(1)
}

process.exit(0)
</code></pre>
<p>把这个文件拷贝到 <code>.git/hooks/pre-commit</code> 下，并执行 <code>chmod 777 pre-commit</code> 就可以在每次 commit 的情况下检查之前文件是否有冲突。</p>
<h3>有没有更好的做法？</h3>
<p>试想一下，我们在写钩子的时候，并不会一次就把代码写对，所以需要经常把这个文件拷贝到 <code>.git/hooks</code> 目录下；有没有更好的做法？ 有的。只需要在<code>.git/hooks</code>下面创建一个 shell 脚本，来调用这个 js 文件即可。</p>
<pre><code class=""node"">#!/usr/bin/env node
const execSync = require('child_process').execSync
execSync(""./pre-commit.js"" )</code></pre>
<p>这中 <code>shebang</code> 写法在使用 git 的命令来运行的时候是没有问题的，但是在使用 <code>Source Tree</code> 的 Git-GUI，会报 node 命令不存在， 这是新版本的 osx 的安全策略造成的（可以运行 which node 命令看看和上面的 shebang 有什么区别），对于这种情况使用下面的脚本可以完美解决。</p>
<pre><code class=""shell"">#!/usr/bin/env bash

# 支持 sourcetree
export PATH=/usr/local/bin:$PATH
node ""./pre-commit.js""</code></pre>
<p>NOTE:<br>注意 <code>node './pre-commit.js'</code> 这个路径，是指如果在当前项目的根目录下运行 <code>git commit</code>，所以 <code>pre-commit.js</code> 是相对于当前根目录的路径。想优化的话可以通过 Git 的一些默认环境变量来配置。</p>
<p>到这里就基本结束了，但是我们再回忆下之前说过的内容『客户端钩子是不会被其他项目成员 clone 下来的』，所以需要一种策略来保证项目中每个成员都安装了这个钩子。由于我们的前端项目是需要每个成员都通过 npm start 命令开启服务的，所以可以在 npm start 中做些手脚。</p>
<pre><code class=""js"">const fs = require('fs');

// 判断是否已经存在 pre-commit，不存在就读取 pre-commit.sh 并写入
if (!fs.existsSync('.git/hooks/pre-commit')) {
    if(!fs.existsSync('.git/hooks/')) {
        fs.mkdirSync('.git/hooks/');
    }

    let preCommitFile = fs.readFileSync('./pre-commit.sh');

    fs.writeFileSync('.git/hooks/pre-commit', preCommitFile, {
        encoding: 'utf8',
        mode: 0o777
    });
}
</code></pre>
<h3>总结：</h3>
<p>凡是能被 JS 重写的项目，最终一定会被 JS 重写。</p>

                ", 用 Node.js 写前端自己的 Git-hooks ,1531977896,216,1,610,1,1,https://segmentfault.com/a/1190000007820338
166,1,0,7,"
                    
<p>在使用 Git 作为版本控制的时候，我们可能会由于各种各样的原因提交了许多临时的 commit，而这些 commit 拼接起来才是完整的任务。那么我们为了避免太多的 commit 而造成版本控制的混乱，通常我们推荐将这些 commit 合并成一个。</p>
<p><strong>1,查看提交历史，git log</strong></p>
<p>首先你要知道自己想合并的是哪几个提交，可以使用git log命令来查看提交历史，假如最近4条历史如下：</p>
<pre><code>commit 3ca6ec340edc66df13423f36f52919dfa3......

commit 1b4056686d1b494a5c86757f9eaed844......

commit 53f244ac8730d33b353bee3b24210b07......

commit 3a4226b4a0b6fa68783b07f1cee7b688.......
</code></pre>
<p>历史记录是按照时间排序的，时间近的排在前面。 </p>
<p><strong>2,git rebase</strong></p>
<p>想要合并1-3条，有两个方法</p>
<p>1.从HEAD版本开始往过去数3个版本</p>
<pre><code>git rebase -i HEAD~3
</code></pre>
<p>2.指名要合并的版本之前的版本号</p>
<pre><code>git rebase -i 3a4226b
</code></pre>
<p>请注意3a4226b这个版本是不参与合并的，可以把它当做一个坐标 </p>
<p><strong>3,选取要合并的提交</strong></p>
<p>1.执行了rebase命令之后，会弹出一个窗口，头几行如下：</p>
<pre><code>pick 3ca6ec3   '注释**********'

pick 1b40566   '注释*********'

pick 53f244a   '注释**********'
</code></pre>
<p>2.将pick改为squash或者s,之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：</p>
<pre><code>pick 3ca6ec3   '注释**********'

s 1b40566   '注释*********'

s 53f244a   '注释**********'
</code></pre>
<p>3.然后保存退出，Git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令：</p>
<pre><code>git add .  

git rebase --continue  
</code></pre>
<p>如果你想放弃这次压缩的话，执行以下命令：</p>
<pre><code>git rebase --abort  
</code></pre>
<p>4.如果没有冲突，或者冲突已经解决，则会出现如下的编辑窗口：</p>
<pre><code># This is a combination of 4 commits.  
#The first commit’s message is:  
注释......
# The 2nd commit’s message is:  
注释......
# The 3rd commit’s message is:  
注释......
# Please enter the commit message for your changes. Lines starting # with ‘#’ will be ignored, and an empty message aborts the commit.
</code></pre>
<p>5.输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。</p>
<p>还可参考其他<a href=""http://www.jianshu.com/p/964de879904a"" rel=""nofollow noreferrer"">http://www.jianshu.com/p/964d...</a></p>

                ", (Git)合并多个commit,1531977897,578,1,504,1,1,https://segmentfault.com/a/1190000007748862
167,1,0,7,"
                    
<h1>一、背景</h1>
<p>首先贴地址，<strong>开源项目</strong>：<a href=""https://github.com/NetEaseGame/git-webhook"" rel=""nofollow noreferrer"">https://github.com/NetEaseGame/git-webhook</a>，<strong>DEMO 地址</strong>：<a href=""http://webhook.hust.cc/"" rel=""nofollow noreferrer"">http://webhook.hust.cc/</a></p>
<p>我个人是在线这边的测试开发，主要工作是开发一些工具，辅助测试和开发，规范流程等等，这些内网的工具，一般不存在什么并发，性能瓶颈，上线部署其实非常简单，在需要更新上线的时候，提交最新代码到 release 分支，然后 ssh 登陆服务器，去执行一个 shell 脚本，拉取最新代码，restart 一下即可，其实并不是很复杂，然后还是存在一些问题：</p>
<ol>
<li><p>一些<strong>没有 ssh 权限</strong>的同学更新代码之后，都会找你来帮忙重启一下；</p></li>
<li><p>周末<strong>节假日</strong>，加班的同学跟你打电话：服务挂了需要重启怎么办？</p></li>
<li><p>每次 push 都要去 restart 一下，其实挺烦躁的；</p></li>
<li><p>一次 git push 的代码，需要更新到<strong>很多台服务器</strong>，你就更加烦躁了；</p></li>
</ol>
<p>所以我做了这样一个小工具，利用 git 的 webhook 来简化部署工作。</p>
<h1>二、git-webhook</h1>
<p>Git WebHook 是一个使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维系统，支持：Github / GitLab / Gogs / GitOsc。</p>
<ul>
<li><p>技术栈简单，部署容易；</p></li>
<li><p>代码简洁易懂，二次开发毫无压力；</p></li>
<li><p>支持 Github / GitLab / Gogs / GitOsc；</p></li>
<li><p>使用 SSH 方式，支持多服务配置；</p></li>
</ul>
<h1>三、如何安装？</h1>
<h2>1. 安装应用</h2>
<pre><code>pip install git-webhook</code></pre>
<p>备注：项目中某一个依赖库需要安装 python-dev。</p>
<h2>2. 创建配置</h2>
<pre><code>gitwebhook config</code></pre>
<p>命令执行之后，会在对应<strong>用户目录</strong>（~）生成新的配置文件，然后对应修改配置文件内容。主要需要配置三点：</p>
<ul>
<li><p><code>DATABASE_URI</code>: 数据库地址，理论上可以使用<strong>任何关系数据库</strong>；推荐使用 sqlite 和 mysql （经过测试）；</p></li>
<li><p><code>CELERY REDIS</code>: Redis URI 配置，主要用于 Celery 后台任务；</p></li>
<li><p><code>GITHUB</code>: GitHub 登陆配置，可以到 <a href=""https://github.com/settings/developers"" rel=""nofollow noreferrer"">OAuth applications</a> 自行申请，登陆 Callback 地址为： <code>your_domain/github/callback</code>.</p></li>
</ul>
<h2>3. 初始化数据库结构</h2>
<pre><code>gitwebhook createdb</code></pre>
<h2>4. 运行应用</h2>
<pre><code># 1. run python webserver
gitwebhook runserver
# 2. run celery async task
gitwebhook celery</code></pre>
<p>运行之后，打开 <a href=""http://127.0.0.1:18340"" rel=""nofollow noreferrer"">http://127.0.0.1:18340</a> （一巴扇死你）即可访问。使用 GitHub 账号登陆。</p>
<p>在工具中添加 WebHook 项目，获得 WebHook URL，并填写到 Github / GitLab / OscGit 的 WebHook 配置中。</p>
<h1>四、截图</h1>
<p><span class=""img-wrap""><img data-src=""/img/bVGlLo?w=1292&amp;h=710"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>MIT @hustcc</p>

                ",  Git-WebHook 自动化部署工具 - 支持Github / GitLab / Gogs / GitOsc,1531977899,397,1,890,1,1,https://segmentfault.com/a/1190000007671099
168,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVGh1i?w=2562&amp;h=1972"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h1>docsify</h1>
<blockquote><p>无需构建快速生成文档页</p></blockquote>
<p>网站：<a href=""https://github.com/qingwei-li/docsify"" rel=""nofollow noreferrer"">https://github.com/qingwei-li...</a><br>文档：<a href=""https://docsify.js.org/zh-cn"" rel=""nofollow noreferrer"">https://docsify.js.org/zh-cn</a></p>
<h2>特性</h2>
<ul>
<li><p>无需构建，写完 markdown 直接发布</p></li>
<li><p>支持自定义主题</p></li>
<li><p>容易使用并且轻量</p></li>
</ul>
<h2>快速上手</h2>
<h3>创建项目</h3>
<p>新建一个空项目，接着创建一个 <code>docs</code> 目录并进入到 docs 目录下</p>
<pre><code class=""shell"">mkdir my-project &amp;&amp; cd my-project
mkdir docs &amp;&amp; cd docs</code></pre>
<h3>创建入口文件</h3>
<p>创建一个 <code>404.html</code> 文件，内容为</p>
<pre><code class=""html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=""UTF-8""&gt;
  &lt;link rel=""stylesheet"" href=""//unpkg.com/docsify/themes/vue.css""&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=""app""&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;script src=""//unpkg.com/docsify""&gt;&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>新建 <code>README.md</code> 文件，作为主页面</p>
<pre><code># Title

## balabala</code></pre>
<h3>部署！</h3>
<p>将项目 <code>push</code> 到 GitHub 仓库后到设置页面开启 <strong>GitHub Pages</strong> 功能，选择 <code>docs/</code> 选项<br><span class=""img-wrap""><img data-src=""/img/remote/1460000007656682?w=792&amp;h=453"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>命令行工具</h2>
<p>方便快速创建文档目录，会读取项目的 <code>package.json</code> 里的选项作为 docsify 的配置，支持本地预览。</p>
<h3>安装</h3>
<pre><code class=""shell"">npm i docsify-cli -g</code></pre>
<h3>初始化文档</h3>
<p>默认初始化在当前目录，推荐将文档放在 <code>docs</code> 目录下</p>
<pre><code class=""shell"">docsify init docs</code></pre>
<h3>启动本地服务</h3>
<p>启动一个 server 方便预览，打开 <a href=""http://localhost:3000"" rel=""nofollow noreferrer"">http://localhost:3000</a></p>
<pre><code class=""shell"">docsify serve docs</code></pre>
<p>更多选项参考 <a href=""https://github.com/QingWei-Li/docsify-cli"" rel=""nofollow noreferrer"">docsify-cli</a></p>
<h2>主题</h2>
<p>目前提供 vue.css 和 buble.css，直接修改 <code>404.html</code> 里的 cdn 地址即可</p>
<pre><code class=""html"">&lt;link rel=""stylesheet"" href=""//unpkg.com/docsify/themes/vue.css""&gt;
&lt;link rel=""stylesheet"" href=""//unpkg.com/docsify/themes/buble.css""&gt;</code></pre>
<p>压缩版</p>
<pre><code class=""html"">&lt;link rel=""stylesheet"" href=""//unpkg.com/docsify/lib/themes/vue.css""&gt;
&lt;link rel=""stylesheet"" href=""//unpkg.com/docsify/lib/themes/buble.css""&gt;</code></pre>
<h2>更多功能</h2>
<h3>多页面</h3>
<p><code>README.md</code> 作为主页面，如果需要其他页面，直接在文档目录下创建对应的 <code>*.md</code> 文件，例如创建一个 <code>guide.md</code> 那么对应的路由就是 <code>/guide</code>。</p>
<h3>导航</h3>
<p>导航需要自己写在 <code>404.html</code> 文件里，效果参考本文档</p>
<pre><code class=""html"">&lt;nav&gt;
  &lt;a href=""/docsify/""&gt;En&lt;/a&gt;
  &lt;a href=""/docsify/zh-cn""&gt;中文&lt;/a&gt;
&lt;/nav&gt;</code></pre>
<h3>配置参数</h3>
<h4>repo</h4>
<p>参考本文档的右上角的 GitHub 图标，如果要开启的话，将 <code>404.html</code> 里的 script 改成</p>
<pre><code class=""html"">&lt;script src=""//unpkg.com/docsify"" data-repo=""your/repo""&gt;&lt;/script&gt;</code></pre>
<h4>max-level</h4>
<p>目录最大展开层级，默认值为 6</p>
<pre><code class=""html"">&lt;script src=""//unpkg.com/docsify"" data-max-level=""6""&gt;&lt;/script&gt;</code></pre>
<h4>el</h4>
<p>替换节点元素，默认为 <code>#app</code></p>
<pre><code class=""html"">&lt;script src=""//unpkg.com/docsify"" data-el=""#app""&gt;&lt;/script&gt;</code></pre>
<h4>sidebar-toggle</h4>
<p>Sidebar 开关按钮</p>
<pre><code class=""html"">&lt;script src=""//unpkg.com/docsify"" data-sidebar-toggle&gt;&lt;/script&gt;</code></pre>
<h4>sidebar</h4>
<p>设置后 TOC 功能将不可用，适合导航较多的文档，<code>data-sidebar</code> 传入全局变量名。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007656683?w=297&amp;h=174"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<pre><code class=""html"">&lt;script&gt;
  window.sidebar = [
    { slug: '/', title: 'Home' },
    {
      slug: '/pageA',
      title: 'page A',
      children: [
        { slug: '/pageA/childrenB', title: 'children B' }
      ]
    },
    { slug: '/PageC', title: 'Page C' }
  ]
&lt;/script&gt;
&lt;script src=""/lib/docsify.js"" data-sidebar=""sidebar""&gt;&lt;/script&gt;</code></pre>
<h4>load-sidebar</h4>
<p>读取侧边栏配置文件，如果配置，默认加载当前目录下的 <code>_sidebar.md</code>。如果文件不存在，会显示 TOC 作为侧边栏内容。如果你有二级目录，也应该放置一份配置文件。</p>
<pre><code class=""html"">&lt;script src=""/lib/docsify.js"" data-load-sidebar&gt;&lt;/script&gt;</code></pre>
<p>你可以指定侧边栏文件名</p>
<pre><code class=""html"">&lt;script src=""/lib/docsify.js"" data-load-sidebar=""_sidebar.md""&gt;&lt;/script&gt;</code></pre>
<p><code>_sidebar.md</code> 的内容可以是这样的</p>
<pre><code class=""markdown"">- [Home](/)
- [Installation](/installation)
- Essentials
  - [Getting Started](/getting-started)
  - [Dynamic Route Matching](/dynamic-matching)
  - [Nested Routes](/nested-routes)
  - [Programmatic Navigation](/navigation)
  - [Named Routes](/named-routes)
  - [Named Views](/named-views)
  - [Redirect and Alias](/redirect-and-alias)
  - [HTML5 History Mode](/history-mode)</code></pre>
<h4>load-navbar</h4>
<p>读取导航配置文件，如果配置，默认加载当前目录下的 <code>_navbar.md</code>。如果文件不存在，会显示 html 里定义的导航栏。</p>
<pre><code class=""html"">&lt;script src=""/lib/docsify.js"" data-load-navbar&gt;&lt;/script&gt;</code></pre>
<p>你可以指定导航栏文件名</p>
<pre><code class=""html"">&lt;script src=""/lib/docsify.js"" data-load-navbar=""_navbar.md""&gt;&lt;/script&gt;</code></pre>
<p><code>_navbar.md</code> 的内容可以是这样</p>
<pre><code class=""markdown"">- [en](/)
- [中文](/zh-cn)</code></pre>
<p>当然也支持二级列表，将生成一个下拉列表</p>
<pre><code class=""markdown"">- [download](/download)
- language
  - [en](/)
  - [中文](/zh-cn)</code></pre>
<h2>FAQ</h2>
<h3>为什么是 <code>404.html</code> 而不用 <code>index.html</code>
</h3>
<p>docsify 想要实现的是用最简单的方式 <strong>动态渲染内容</strong>。</p>
<p>例如我有两个文档分别为 <code>README.md</code> 和 <code>guide.md</code>，如果我用 <code>index.html</code> 作为文件名，<code>README.md</code> 可以被正确的渲染因为我们已经规定它为首页文件，但是如果我们访问 <code>my-domain.com/guide</code> 想要得到的结果是 <code>guide.md</code> 的内容，它将无法工作，因为目录下并不存在一个 <code>guide.html</code> 的文件。</p>
<p>但是 GitHub Pages 服务器找不到资源， 就会回退并渲染 <code>404.html</code> 文件。?</p>
<hr>
<p>网站：<a href=""https://github.com/qingwei-li/docsify"" rel=""nofollow noreferrer"">https://github.com/qingwei-li...</a><br>文档：<a href=""https://docsify.js.org/zh-cn"" rel=""nofollow noreferrer"">https://docsify.js.org/zh-cn</a></p>

                ", docsify - 无需构建快速生成文档网站,1531977901,235,1,978,1,1,https://segmentfault.com/a/1190000007656679
169,1,0,7,"
                    
<h1>什么是专注</h1>
<p>简而言之，专注就是注意力分散的对立面。<br>记得大学时候教我英语的老教授说过的一句，<br>「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」</p>
<p>每一天，我们坐下来打开电脑，想做点什么正经事情的时候。<br>却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。<br>又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。<br>还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。</p>
<p>就像吴晓波每周都会说的「世界如此喧嚣」。<br>现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。</p>
<p>不知道你还记得最近一次解决真正的难题是什么时候吗？<br>你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。<br>时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。<br>你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。<br>这就是「专注」。<br>就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。</p>
<h2>冲量</h2>
<p>「冲量」是一个物理词汇</p>
<blockquote><p>冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。</p></blockquote>
<p>我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。</p>
<p>就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。<br>倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。</p>
<p>又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。<br>就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。<br>也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。</p>
<p>所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。</p>
<p>如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。<br>被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。<br>忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」</p>
<h2>思维体力</h2>
<p>我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。<br>也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。</p>
<p>如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。<br>这个能力，因人而异，也因事而异。</p>
<p>有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。<br>有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。<br>还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)</p>
<p>长时间的「专注」，容易让人思维疲劳。<br>不同人对于不同的事情保持「专注」的时间也不一样。<br>明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。</p>
<p>比如「番茄工作法」。<br>番茄工作法的核心概念也很简单，可以总结成：</p>
<blockquote><p>一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。<br>把一个任务所需要完成的时间，细分到以番茄时间来做单位。<br>番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。<br>以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。</p></blockquote>
<h2>单线程</h2>
<p>人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。<br>我们所承担的多个任务都要「环境切换」的成本。<br>当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。</p>
<p>想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。</p>
<p>如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。<br>让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。</p>
<h1>如何保持专注</h1>
<p>明白了什么是「专注」，以及专注的克星「打断」。<br>我们可以总结保持专注所需要解决的几个主要问题：</p>
<ol>
<li><p>锻炼专注，缩短冲量的成本</p></li>
<li><p>减少干扰源，避免打断</p></li>
<li><p>注意休息，注意思维体力</p></li>
<li><p>学会管理任务，明确目标</p></li>
</ol>
<p>下面是，一些建议与安利。</p>
<h2>「番茄闹钟」类工具</h2>
<p><strong><a href=""https://pomotodo.com/"" rel=""nofollow noreferrer"">番茄土豆</a></strong><br>我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。<br>以下是这款产品做的很不错的几点：</p>
<ol>
<li><p>支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。</p></li>
<li><p>还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。</p></li>
<li><p>支持任务打标签</p></li>
</ol>
<p><strong>此刻</strong><br>一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。<br>当我极简风的情绪来了，就会用这个APP。</p>
<h2>「白噪音」类应用</h2>
<p><strong><a href=""https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8"" rel=""nofollow noreferrer"">潮汐</a></strong><br>iOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。<br>也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVF69G?w=3254&amp;h=1160"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""潮汐"" title=""潮汐""></span><br>(注：界面太美，忍不住贴个图了)</p>
<h2>「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」</h2>
<p>当我打开IDE或者文本编译器，准备专注的写几段代码的时候。<br>发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。</p>
<p><strong>一副耳机</strong><br>这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。</p>
<p><strong>一份后摇歌单</strong><br>有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。<br>后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。<br>没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。<br>后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。</p>
<p>如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：<a href=""http://music.163.com/#/share/1337344/122993280"" rel=""nofollow noreferrer"">多巴胺作菜，后摇作酒</a></p>
<p><strong> 再额外推荐点，班得瑞十三张专辑 </strong><br>如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试<a href=""http://music.163.com/#/artist/album?id=88149"" rel=""nofollow noreferrer"">「班得瑞」</a>十三张专辑。<br>班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。<br>其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。<br>风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。</p>
<p><strong>一双普通的海绵耳塞</strong><br>耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。<br>「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。</p>
<h2>「GTD (Go To Do)」类工具</h2>
<p><strong><a href=""https://www.wunderlist.com"" rel=""nofollow noreferrer"">Wunderlist</a></strong><br>中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。<br>单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。<br>一个账号通用Android、iOS、Mac、Windows、网页平台。</p>
<p><strong><a href=""https://trello.com/"" rel=""nofollow noreferrer"">Trello</a></strong><br>更适合团队协作的，「面板式」的任务管理工具。<br>能把任务分为不同的状态，分配给不同的人，定义好时间。<br>项目进度，个人进度一目了然。<br>支持Web、iOS、Android三个平台</p>
<p><strong><a href=""https://www.teambition.com/"" rel=""nofollow noreferrer"">Teambition</a></strong><br>这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。<br>同样支持Web、iOS、Android三个平台。<br>有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。</p>
<h2>「记录日志」类工具</h2>
<p>回顾和总结是一个好习惯。<br>一天一小结，一周一大结，还有季度总结，年度总结。<br>并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。<br>无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。</p>
<p>对我个人来说，记笔记最重要的是两点：</p>
<ol>
<li><p>支持云同步</p></li>
<li><p>支持Markdown</p></li>
</ol>
<p><strong> <a href=""https://www.yinxiang.com/?from=evernote"" rel=""nofollow noreferrer"">印象笔记</a> 结合 <a href=""https://maxiang.io/"" rel=""nofollow noreferrer"">马克飞象</a> </strong><br>很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。<br>总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。<br>直到遇到了「Day One」的限免。</p>
<p><strong> <a href=""http://dayoneapp.com/"" rel=""nofollow noreferrer"">Day One</a> </strong><br>又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。<br>就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。</p>
<h2>「思维导图」类工具</h2>
<p>1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。<br>它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。<br>由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。<br>而我用思维脑图来做的比较多的是：</p>
<ol>
<li><p>项目设计、架构设计。</p></li>
<li><p>个人任务整理。</p></li>
<li><p>思考的时候用来记录思维过程。</p></li>
<li><p>做会议笔记、读书笔记。</p></li>
</ol>
<p><strong><a href=""http://naotu.baidu.com/"" rel=""nofollow noreferrer"">百度脑图</a></strong><br>尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。<br>百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。<br>但是唯一让我还不满足的是，没有移动端的支持。<br>又是直到 「MindNode」限免为止.....</p>
<p><strong><a href=""http://mindnode.com/"" rel=""nofollow noreferrer"">Mindnode</a></strong><br>如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。<br>嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。</p>
<h2>最后的一个建议，关注健康</h2>
<p>身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。<br>我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。<br>保养好我们的身体，可以让我们更好的完成更多的事情。<br>所以，我们开始站立办公了，解决方案就是：<a href=""http://www.ikea.com/cn/zh/catalog/products/00193664/"" rel=""nofollow noreferrer"">「39块的宜家拉克边桌」</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVF69F?w=1280&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""站立办公"" title=""站立办公""></span></p>
<h1>最后再啰嗦一下，关于团队效率</h1>
<p>以上，都是讲述了如何提高个人的工作效率。<br>但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。</p>
<p>这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。<br><a href=""http://m.jiemian.com/article/800398.html"" rel=""nofollow noreferrer"">腾讯：管理研发大团队就像10人小分队</a></p>
<p>我的总结如下：</p>
<ol>
<li><p>角色分明，各司其职</p></li>
<li><p>迭代流程，形成循环</p></li>
<li><p>需求透明，进度透明</p></li>
<li><p>线上数据，随手可得</p></li>
<li><p>沟通沉淀，形成归档</p></li>
</ol>
<p>然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。<br>改天另立文章，来安利一些不错的工具。</p>
<h1>总结</h1>
<p>本篇讲述了以下内容：</p>
<ol>
<li><p>关于什么是专注，如何理解专注，以及如何达到专注。</p></li>
<li><p>要做到专注，需要解决的问题。</p></li>
<li><p>借助工具来解决这些问题，安利了一波。</p></li>
<li><p>简单提及了一下团队效率</p></li>
</ol>
<h1>关于转载</h1>
<p>本文默认允许转载，但：</p>
<ol>
<li><p>请务必注明出处：<a href=""http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/"" rel=""nofollow noreferrer"">BlueSun | 《程序员如何保证「专注」与「效率」》</a></p></li>
<li><p>如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc<a href=""/u/gmail"" rel=""nofollow noreferrer"">@gmail</a> .com)</p></li>
</ol>
<p>感谢！</p>

                ", 程序员如何保证「专注」与「效率」,1531977902,295,1,700,1,1,https://segmentfault.com/a/1190000007614939
170,1,0,7,"
                    
<h2>前言</h2>
<p>经常会有人问我如何才能将自己做的静态页面放到网上供他人欣赏，是不是需要自己有一个服务器，是不是还要搞个域名才能访问？对于以上问题我都会回答：用github来展示你的前端页面吧。</p>
<p>工欲善其事，必先利其器。github是一个很好的代码管理与协同开发平台，在程序界又被称为最大的“同性交友网站”。如果你不懂git，没有自己的github账户，那你就丢失了一把能够很好的展示自我，储存知识的利器。</p>
<p>当然知道github的人不在少数，但是大部分人可能仅知道它可以用于管理我们的项目代码，而不知道其还可以用于展示我们前端的静态页面。比如：</p>
<blockquote><p><a href=""https://github.com/luozhihao/demo"" rel=""nofollow noreferrer"">https://github.com/luozhihao/...</a></p></blockquote>
<p>了解github的人都知道上方的地址指向的是一个github项目目录，同时你可能还会发现这样的一个地址：</p>
<blockquote><p><a href=""https://luozhihao.github.io/demo"" rel=""nofollow noreferrer"">https://luozhihao.github.io/demo</a></p></blockquote>
<p>上方的地址就是对应demo项目的展示页面了。</p>
<h2>步骤</h2>
<p>其实利用github来展示前端静态页面的例子很多，比如各种插件、框架的demo演示地址都会这样做，那么下面我们就来实际操作一下，体验一把展示自己前端项目成果的乐趣。</p>
<h4>1.安装git</h4>
<p>如果你是mac用户，那么恭喜你mac自带git命令功能，你无须安装git。如果你是windows用户，你可以前往<a href=""https://git-for-windows.github.io/index.html"" rel=""nofollow noreferrer"">windows地址</a>下载并安装。</p>
<h4>2.建立仓库</h4>
<p>在你的github主页，我们可以点击右上角的加号按钮下的“New repository”来新建一个项目仓库，如图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007544339?w=300&amp;h=192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>点击之后我们给仓库取一个名字并进行相应的描述和配置后点击“Create repository”就ok了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007544340?w=746&amp;h=616"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>3.上传代码</h4>
<p>仓库建立完毕后，这时候就需要用我们之前安装的git命令来将本地的代码推送到github上了。如果你仅为了展示自己的前端页面，那么只要掌握如下命令即可（不熟悉git命令的可以参考<a href=""http://www.bootcss.com/p/git-guide/"" rel=""nofollow noreferrer"">git - 简易指南</a>）：</p>
<p>（1）打开你的目录</p>
<pre><code>cd demo</code></pre>
<p>（2）初始化版本库，用于生成.git文件</p>
<pre><code>git init</code></pre>
<p>（3）将所有文件添加到缓存区</p>
<pre><code>git add *</code></pre>
<p>（4）提交当前工作空间的修改内容</p>
<pre><code>git commit -m ""first commit""</code></pre>
<p>（5）将仓库连接到远程服务器</p>
<pre><code>git remote add origin &lt;server&gt;</code></pre>
<p>（6）将改动推送到所添加的服务器上</p>
<pre><code>git push -u origin master</code></pre>
<p>上方server中的地址在github上创建仓库后可以找到，如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007544341?w=645&amp;h=132"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>4.创建gh-pages分支</h4>
<p>之前的工作只是将我们的代码发布到了github上demo仓库的master分支上，当然你也可以不发布，而我们的展示页面代码必须发布到名为“gh-pages”的分支上。方法很简单，我们只需要在github的demo项目页面手动创建gh-pages分支即可。如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007544342?w=525&amp;h=420"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>输入gh-pages后创建即可，这样的方式会直接拷贝master分支的所有文件到gh-pages分支，而你也可以用命令行的形式创建并重新上传一份新的代码：</p>
<p>（1）新建并切换到gh-pages分支</p>
<pre><code>git checkout --orphan gh-pages</code></pre>
<p>（2）之后的操作和之前一样，只是push的时候是gh-pages</p>
<pre><code>git add *
git commit -m ""update""
git push -u origin gh-pages</code></pre>
<p>如此，我们的demo项目就多了一个gh-pages分支，里面的代码文件就可以用来展示页面了。</p>
<h4>5.访问页面</h4>
<p>创建并上传文件至gh-pages之后，我们就可以访问如下url来查看自己的demo了：</p>
<pre><code class=""git"">http://(user_name|org_name).github.io/repo_name</code></pre>
<p>这里我们的demo地址为：<a href=""https://luozhihao.github.io/demo/,"" rel=""nofollow noreferrer"">https://luozhihao.github.io/d...</a> 最终页面如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007544343?w=767&amp;h=422"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这样我们便实现了利用github来展示前端静态页面的目标。</p>
<h2>结语</h2>
<p>很多时候方法就摆在眼前，就看你会不会捅破那层隔膜，敢不敢进行钻研与尝试。github之所以经久不衰是因为其不仅解决了我们代码提交、版本管理的问题，还提供了其他实用而独特的功能。</p>
<p>本文只针对Github Pages提供给我们展示静态页面（不支持服务端语言）的功能做了基础的介绍，至于想真正掌握并了解更加深入内容的同学还请付诸于实践，比如利用gihub搭建博客等。</p>
<p>补充：根据读者反馈，现在github有一种更加简便的方式来实现上述功能，将代码上传至仓库后在settings里配置下GitHub Pages为你想展示的分支就行了。</p>
<p>本文为劳卜原创文章，首发于微信公众号：<strong>前端呼啦圈（Love-FED）</strong> <br>转载请注明来自——微信公众号：前端呼啦圈（Love-FED）</p>

                ", 用github来展示你的前端页面吧,1531977904,318,1,847,1,1,https://segmentfault.com/a/1190000007544336
171,1,0,7,"
                    
<p>转载请注明出处：</p>
<p><a href=""http://blog.csdn.net/tzs_1041218129/article/details/53214497"" rel=""nofollow noreferrer"">http://blog.csdn.net/tzs_1041...</a></p>
<p><a href=""http://www.54tianzhisheng.cn/Blog/html/blog_github.html"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/Blog/html/blog_github.html</a>  (阅读效果最好)</p>
<p>pdf版本：<a href=""http://www.54tianzhisheng.cn/Blog/pdf/blog_github.pdf"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/...</a></p>
<p>更多精彩文章请关注微信公众号：<strong>猿blog</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522960?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>前言</h2>
<p>最近这几天，没事干，想找点事折腾下，于是自己便想到了自己一直想干的一件事：搭建一个属于自己的博客网站。目前搭建个人 <code>blog</code> 网站最好的是用 <code>wordpress</code> ，但是那个折腾起来好像还挺麻烦的，再加上还需要自己修改些前端代码和用 <code>PHP</code> 做（虽然我学了几天拍黄片，但是早已忘了），然后就是用 <code>Github Page</code> 吧，自己也一直在这个最大的交友网站装 X 。想想就用这个吧（后来好像觉得这个还挺省事的）</p>
<p>再说说拥有个人博客网站的好处吧：</p>
<ul>
<li><p>装 X（如果网站够炫）</p></li>
<li><p>很好的用来总结自己所学的知识</p></li>
<li><p>面试加分（在简历上放上自己的个人网站链接，面试官就可以更好的了解你，知道你所学知识的深度和广度）</p></li>
<li><p>不再受其他博客平台的规则所束缚</p></li>
</ul>
<p>如果你现在还没有自己个人博客网站的话，那么我觉得你看完本篇博客后，强烈的建议你去折腾折腾下，搞个自己的，让自己也能够体验装 X 的感觉。</p>
<p>要想用搭建一个个人博客网站，首先你得有一个域名，这样别人才可以通过域名访问，其次你还要一个空间来存放你的页面。</p>
<ul>
<li><p>域名  域名的话，你可以在万网、阿里云、腾讯云等注册，我的域名 <a href=""http://www.54tianzhisheng.cn/"" rel=""nofollow noreferrer"">www.54tianzhisheng.cn</a> 就是在腾讯云注册的，记得是腾讯云一元钱（一个域名+主机）搞的，这是腾讯云对学生才有这优惠。  <code>.cn</code> 的域名需要备案，备案的审核速度我觉得还是挺快的，还需要上传证件。当然你也可以买其他的那些不需要备案的域名，省得麻烦事。</p></li>
<li><p>空间  空间有免费的空间，也有收费的空间。免费的当然就不够稳定了，收费的就很贵了，终究是很不爽，有没有什么地方是既免费又稳定的空间呢？有，<code>Github</code> 。它允许上传个人网站项目并自定义你的域名，而且又有稳定的服务，实在是不能够在好了。</p></li>
</ul>
<p>下面就一起跟着我来一步一步的利用 Github 搭建个人博客网站吧！</p>
<h2>1.  拥有一个域名</h2>
<p>这个步骤我就不详述了。</p>
<p>举例：</p>
<blockquote><ul>
<li><p>打开腾讯云官网</p></li>
<li><p>搜索你想要的域名，下单买一个</p></li>
</ul></blockquote>
<h2>2.  拥有一个 Github账号</h2>
<p>互联网崇尚自由与分享。<code>Github</code> 是一个全世界程序员聚集的地方，大家相互分享自己写的代码，提升别人，也提升自己。大家都在为着开源社区努力着。因为我从开源项目中学到很多知识，所以我也非常愿意分享我的所见所学所得，我的 Github 主页：<a href=""https://github.com/zhisheng17"" rel=""nofollow noreferrer"">https://github.com/zhisheng17</a>   （欢迎 follow 和对我的项目给个 star 或者 fork 我的项目一起来和我完善项目）</p>
<p>如果还没有 Github 账号的话你就先去注册一个吧，有的话，直接登录就行，后面的操作都要用到 Github 的。</p>
<h2>3.  Github 上新建个人网站项目</h2>
<p>登录 GitHub 之后，在页面右上角点击 + 加号按钮，点击 New repository。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522961?w=796&amp;h=246"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>由于我们是新建一个个人网站项目，所有仓库的名称需要安装 GitHub 个人网站项目的规定来写。 </p>
<p>规则就是：</p>
<blockquote><p>YOUR-GITHUB-USERNAME.github.io</p></blockquote>
<p>比如我的 GitHub 用户名是 zhisheng17，那我就要填写 zhisheng17.github.io。然后选择公开模式，接着点击创建仓库按钮。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522962?w=1289&amp;h=859"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>创建成功之后，进入了项目主页面。点击设置按钮。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522963?w=1430&amp;h=842"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>进入之后，滚动页面到下方。点击页面自动生成器按钮。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522964?w=1206&amp;h=746"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>点击右下方继续去布局按钮。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522965?w=1324&amp;h=927"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>选择一个模板，点击发布页面按钮。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522966?w=1180&amp;h=880"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522967?w=1220&amp;h=680"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>这个时候，你就可以通过YOUR-GITHUB-USERNAME.github.io来访问此页面了。</p>
<h2>4.  上传个人网页到 Github</h2>
<p>自动生成页面，肯定不符合我们的要求，我们希望能够自己设计自己的个人网站。我们可以自己编写一个网页文件，命名为 index.html。然后上传到 GitHub个人网站项目上。这里为了节约时间，可以先下载我的个人网站项目代码，然后修改为你的网页上传到 GitHub。</p>
<p>下面介绍详细步骤。</p>
<p>进入此项目<a href=""https://github.com/zhisheng17/zhisheng17.github.io"" rel=""nofollow noreferrer"">https://github.com/zhisheng17...</a>，然后下载源码。解压之后，拿到里面的index.html文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522968?w=1518&amp;h=886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>然后进入自己的个人网站项目主页 YOUR-GITHUB-USERNAME/YOUR-GITHUB-USERNAME.github.io。点击上传文件按钮，进入上传文件页面，将 index.html 文件拖入蓝色大圈圈区域，点击提交按钮即可提交成功。此时打开网址 YOUR-GITHUB-USERNAME.github.io 就可以看到主页已经改变为我们自己的网页了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522969?w=1375&amp;h=849"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522970?w=1465&amp;h=892"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>通过 zhisheng17.github.io 查看效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522971?w=1912&amp;h=983"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<h2>5.  域名CNAME到个人网站项目</h2>
<p>网页上传成功了，我们不想一直通过YOUR-GITHUB-USERNAME.github.io来访问我们的个人网站，而是希望通过自己的域名来访问。</p>
<p>下面讲述详细步骤。</p>
<p>点击我们的个人网站项目设置选项卡，滚动到下面，就会发现一个自定义域名卡片。输入我们买的域名，然后点击保存。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522972?w=1143&amp;h=802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522973?w=1494&amp;h=727"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>接着我们还要将我们的域名解析到这个个人网站项目上。因为我的域名是在腾讯云上面买的，所以我打开腾讯云域名管理页面，进行相关的设置。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522974?w=1879&amp;h=711"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>接着，点击添加一条域名解析记录，主机填写www，代表你是一级域名来访问，指向填写YOUR-GITHUB-USERNAME.github.io，然后点击保存按钮。应该要等会，域名的解析时间可能不一样，我的腾讯云就是很慢的</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522975?w=1897&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<h2>6.  访问你的域名</h2>
<p>所有这些步骤做完之后，在浏览器里输入自己的域名，回车键一按，就会返回我们刚刚上传到 GitHub 的index.html 页面了。</p>
<p>这里只是入门了 GitHub 搭建个人网站的功能，GitHub 官方推荐 Jekyll 博客系统来发布自己的页面。以后有数据更新，都可以通过 Jekyll 来重新编译整个网站。（期待后续我的使用 Jekyll 博客系统发布自己博客的文章吧）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007522976?w=1900&amp;h=970"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<h2>7.  注意事项</h2>
<p>尽管GitHub个人网站项目是免费的，但是却有一些限制。总体来说，完全够用，甚至太多了。</p>
<ul>
<li><p>单个仓库大小不超过1GB，上传单个文件大小不能超过100MB，如果通过浏览器上传不能超过25MB</p></li>
<li><p>个人网站项目也不例外，最大空间1GB</p></li>
<li><p>个人网站项目每个月访问请求数不能超过10万次，总流量不能超过100GB</p></li>
<li><p>个人网站项目一小时创建数量不能超过10个</p></li>
</ul>
<p>当然了，这些政策可能随时改变，可以通过此网页查看最新政策。 <a href=""https://help.github.com/articles/what-is-github-pages/#recommended-limits"" rel=""nofollow noreferrer"">https://help.github.com/artic...</a></p>

                ", 利用Github Page 搭建个人博客网站,1531977906,531,1,591,1,1,https://segmentfault.com/a/1190000007522957
172,1,0,7,"
                    
<h3>前言</h3>
<p><strong>人生贵知心，定交无暮早。</strong></p>
<p>原文博客地址：<a href=""http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#more"" rel=""nofollow noreferrer"">Git命令总结</a></p>
<p>知乎专栏&amp;&amp;简书专题：<a href=""https://zhuanlan.zhihu.com/damonare"" rel=""nofollow noreferrer"">前端进击者（知乎）</a>  <a href=""http://www.jianshu.com/collection/bbaa63e264f5"" rel=""nofollow noreferrer"">前端进击者（简书）</a></p>
<h2>正文</h2>
<h3>1.Git简介</h3>
<p>    Git的诞生确实是一个有趣的故事，我们知道，当年Linus创建了开源的Linux，从此，Linux系统不断发展，现在已经成为最大的服务器系统软件了。(请不要傻傻分不清Linus和Linux)</p>
<p>    但是随着Linux的不断壮大，就需要各种版本控制了，起初Linus带着他的小弟们使用的是BitKeeper(商业版本控制系统),之后呢由于某种原因BitKeeper的公司不让他们使用了，于是Linus自己花了两周时间写出了Git并且开源了(BitKeeper已哭晕在厕所)，阿弥陀佛，幸亏BitKeeper不让Linus他们用了，要不然我们现在也不会有这么好用的Git了，博主更不会在这写这篇博文了。</p>
<p>    之后的岁月里，渐渐有了github,coding等一些可以使用git存储的网站，Git的江湖地位变得无可替代了，如果你是个开发者却还不会使用Git那就太out了。</p>
<p>这里先引用一张图解释Git<br>工作原理：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000007497386"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git原理"" title=""Git原理""></span></p>
<ul>
<li><p>Workspace:工作区，执行<code>git add *</code>命令就把改动提交到了暂存区，执行<code>git pull</code>命令将远程仓库的数据拉到当前分支并合并，执行<code>git checkout [branch-name]</code>切换分支</p></li>
<li><p>Index:暂存区，执行<code>git commit -m '说明'</code> 命令就把改动提交到了仓库区（当前分支）</p></li>
<li><p>Repository:仓库区（或本地仓库），执行<code>git push origin master</code>提交到远程仓库，执行<code>git clone 地址</code>将克隆远程仓库到本地</p></li>
<li><p>Remote:远程仓库，就是类似github，coding等网站所提供的仓库</p></li>
</ul>
<p><strong>注</strong>：实际操作命令和上述命令会有所不同，这里这是解释清楚命令和仓库的关系。</p>
<h4>1.1  Git 术语</h4>
<table>
<thead><tr>
<th>术语</th>
<th>定义</th>
</tr></thead>
<tbody>
<tr>
<td>仓库（Repository）</td>
<td>一个仓库包括了所有的版本信息、所有的分支和标记信息。在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。</td>
</tr>
<tr>
<td>分支（Branches）</td>
<td>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支执行命令<code>git checkout branch</code>.</td>
</tr>
<tr>
<td>标记（Tags）</td>
<td>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态</td>
</tr>
<tr>
<td>提交（Commit）</td>
<td>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</td>
</tr>
<tr>
<td>修订（Revision）</td>
<td>用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长，16进制标识的字符串.。最新的版本可以通过HEAD来获取。之前的版本可以通过""HEAD~1""来获取，以此类推。</td>
</tr>
</tbody>
</table>
<h4>1.2 忽略特定的文件</h4>
<p>可以配置Git忽略特定的文件或者是文件夹。这些配置都放在<code>.gitignore</code>文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。<br>比如<code>.gitignore</code>内容可以如下：</p>
<pre><code class=""git"">忽略某文件
npm-debug.log
忽略文件夹
dist/
node_modules/
.idea/</code></pre>
<p>同时Git也提供了全局的配置，core.excludesfile。</p>
<blockquote><p>忽略之后的文件或是文件夹Git就不去提交里面的内容了。</p></blockquote>
<h4>1.3 使用.gitkeep来追踪空的文件夹</h4>
<p>Git会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置<code>.gitkeep</code>文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。</p>
<h4>1.4 配置</h4>
<pre><code class=""git""># 显示当前的Git配置
$ git config --list
# 编辑Git配置文件，只是配置用户信息的话直接看下面两行命令即可
$ git config -e [--global]
# 设置提交代码时的用户信息，是否加上全局--global自行决定，一般是直接设置全局的。另外用户邮箱需要注意最好使用gmail,QQ也可以，需要和你远程仓库保持一致不然你的contribution是不会被记录在远程仓库的
$ git config [--global] user.name ""[name]""
$ git config [--global] user.email ""[email address]""</code></pre>
<blockquote><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p></blockquote>
<p><strong>个人觉得git是需要认真学的，虽然是个工具但不学习很容易把自己弄糊涂，希望这篇博客可以在某些时候帮到您，让您大概理解git的工作原理并把基本命令串起来。那么下面就说一下Git重要的基本命令吧。</strong></p>
<h3>2.Git安装</h3>
<p><a href=""https://git-for-windows.github.io/index.html"" rel=""nofollow noreferrer"">Git-for-window</a></p>
<blockquote><p>下载安装这个不用多说吧....</p></blockquote>
<h3>3.创建仓库</h3>
<pre><code class=""git""># 在当前目录创建一个文件夹
$ mkdir [project-name]
# 在当前目录新建一个Git代码库
$ git init
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
# 下载一个项目和它的整个代码历史（各个分支提交记录等）
$ git clone [url]</code></pre>
<blockquote><p><code>git init</code>后会出现.git文件夹，里面有配置文件，如果没有git bash里面输入<code>ls -lah</code>就可以看到了</p></blockquote>
<p><strong>关于如何关联Git和远程仓库，比如Coding，github等，可以看这两篇文章</strong>：<br><a href=""http://www.cnblogs.com/plinx/archive/2013/04/08/3009159.html"" rel=""nofollow noreferrer"">Git链接到自己的Github</a>   <a href=""https://coding.net/help/doc/git/getting-started.html#git-1"" rel=""nofollow noreferrer"">Coding帮助中心</a></p>
<h3>4.提交文件</h3>
<h4>4.1首次推送</h4>
<pre><code class=""git""># 添加当前目录的所有文件到暂存区
$ git add *
# 提交暂存区到仓库区
$ git commit -m [message]
# 为远程Git更名为origin
$ git remote add origin git@github.com:abcd/tmp.git
# 推送此次修改，这是首次推送需要加上-u,之后推送就可以直接git push  origin master,origin是远程Git名字，这个可以自己定义，不过一般是用origin罢了，master是默认的分支，如果不在master分支提交需要写清楚分支名称
$ git push -u origin master</code></pre>
<blockquote><p>首次推送成功后可以看下下面的命令：</p></blockquote>
<pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
# 添加当前目录的所有文件到暂存区
$ git add *
# 添加每个变化前，都会要求确认
对于同一个文件的多处变化，可以实现分次提交
$ git add -p
# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...
# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]
# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
# 提交暂存区到仓库区
$ git commit -m [message]
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a
# 提交时显示所有diff信息
$ git commit -v
# 使用一次新的commit，替代上一次提交
如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]
# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
# 提交更改到远程仓库
$ git push origin master
# 拉取远程更改到本地仓库默认自动合并
$ git pull origin master  </code></pre>
<blockquote><p>如果我们只是维护自己的小项目的话，上面的命令已经够用了，自己一个人在master分支想咋折腾就咋折腾</p></blockquote>
<h4>5.分支</h4>
<blockquote><p>但如果是多人协作的话，git的魅力就开始提现出来了，每个人有自己的一个分支，各自在自己的分支上工作互不干扰。具体的看这：<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000"" rel=""nofollow noreferrer"">Git教程-创建合并分支</a></p></blockquote>
<pre><code class=""git""># 列出所有本地分支
$ git branch
# 列出所有远程分支
$ git branch -r
# 列出所有本地分支和远程分支
$ git branch -a
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
# 新建一个分支，指向指定commit
$ git branch [branch] [commit]
# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
# 切换到上一个分支
$ git checkout -
# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
# 合并指定分支到当前分支，如果有冲突需要手动合并冲突（就是手动编辑文件保存咯），然后add,commit再提交
$ git merge [branch]
# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]</code></pre>
<h4>6.标签</h4>
<blockquote><p>标签的作用主要是用来做版本回退的，关于版本回退，这也是Git的亮点之一，起到了后悔药的功能·</p></blockquote>
<pre><code class=""git""># 列出所有tag
$ git tag
# 新建一个tag在当前commit
$ git tag [tag]
# 新建一个tag在指定commit
$ git tag [tag] [commit]
# 删除本地tag
$ git tag -d [tag]
# 删除远程tag
$ git push origin :refs/tags/[tagName]
# 查看tag信息
$ git show [tag]
# 提交指定tag
$ git push [remote] [tag]
# 提交所有tag
$ git push [remote] --tags
# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]</code></pre>
<h4>7.后悔药</h4>
<blockquote><p>想一下在你写完N个文件代码后，commit到了本地仓库，突然发现整个应用崩溃了！咋整？Git给了我们吃后悔药</p></blockquote>
<p>的机会：</p>
<pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]
# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]
# 恢复暂存区的所有文件到工作区
$ git checkout .
# 回退到上一个版本，在Git中，用HEAD表示当前版本
$ git reset --hard HEAD^
# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]
# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard
# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]
# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]
# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]
# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop</code></pre>
<blockquote><p>这个时候标签的作用就体现出来了，因为commit号太冗长了，记起来太麻烦有了标签我们相当于自定义了commit号</p></blockquote>
<h4>8. 文件信息</h4>
<pre><code class=""git""># 显示当前分支的版本历史
$ git log
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
# 搜索提交历史，根据关键词
$ git log -S [keyword]
# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s
# 显示某个commit之后的所有变动，其""提交说明""必须符合搜索条件
$ git log [tag] HEAD --grep feature
# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]
# 显示指定文件相关的每一次diff
$ git log -p [file]
# 显示过去5次提交
$ git log -5 --pretty --oneline
# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn
# 显示指定文件是什么人在什么时间修改过
$ git blame [file]
# 显示暂存区和工作区的差异
$ git diff
# 显示暂存区和上一个commit的差异
$ git diff --cached [file]
# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD
# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]
# 显示今天你写了多少行代码
$ git diff --shortstat ""@{0 day ago}""
# 显示某次提交的元数据和内容变化
$ git show [commit]
# 显示某次提交发生变化的文件
$ git show --name-only [commit]
# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]</code></pre>
<h3>8.其它命令</h3>
<table>
<thead><tr>
<th>命令</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>git blame filepath</td>
<td>git blame清楚的记录某个文件的更改历史和更改人，简直是查看背锅人的利器，filepath是需要查看的文件路径</td>
</tr>
<tr>
<td>git status</td>
<td>显示有变更的文件</td>
</tr>
<tr>
<td>git reflog</td>
<td>显示当前分支的最近几次提交</td>
</tr>
</tbody>
</table>
<h3>后记</h3>
<blockquote><p>要想彻底熟练使用git那需要记住的命令多了去了，起码几百个吧，不过在日常使用中，本文涉及的命令应该是足够用了，有遗漏的常用命令欢迎提出补充。另外，诚心希望您能把参考文章好好读一下，阮老师和廖老师总结的十分到位。本文好多命令也都是使用的两位老师总结的。</p></blockquote>
<p>参考文章：</p>
<ul>
<li><p><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">Git教程</a></p></li>
<li><p><a href=""http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html"" rel=""nofollow noreferrer"">Git命令清单</a></p></li>
</ul>

                ", 全面理解Git,1531977907,284,1,849,1,1,https://segmentfault.com/a/1190000007497383
173,1,0,7,"
                    
<blockquote><p>好长时间不写东西了， 因为换了工作，所以在忙着熟悉公司的项目代码，所以没什么时间搞自己的东西，回想了一下，在计划中要总结一下关于如何使用终端的git连接github，所以写一下这个。</p></blockquote>
<h2>创建github仓库</h2>
<p>在注册了账号后登陆点击头像旁边的+选择New repository创建一个个人的仓库。填写仓库名称，如图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVFuua?w=748&amp;h=595"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>安装git客户端</h2>
<p>如果是windows，建议安装<a href=""https://git-for-windows.github.io/"" rel=""nofollow noreferrer"">gitbash</a></p>
<p>如果是mac，先安装<a href=""http://brew.sh/index_zh-cn.html"" rel=""nofollow noreferrer"">Homebrew</a>，然后再使用homebrew安装git。</p>
<pre><code class=""shell"">$ brew install git </code></pre>
<p>如果是linux直接在终端使用<code>apt-get</code>安装：</p>
<pre><code class=""shell"">sudo apt-get install git</code></pre>
<h2>配置git</h2>
<h3>1.初始化git</h3>
<p>一般我们是要将自己的本地项目上传到github，实现开源共享，那么就首先需要让git知道它需要跟踪这个项目，所以，我们首先在终端进入项目，初始化git(以mac为例，假设项目在桌面)：</p>
<pre><code class=""shell"">//进入项目

$ cd Desktop/myproject

//初始化git

$ git init</code></pre>
<h4>2.创建ssh key</h4>
<p>为了让github能够识别是我们自己上传文件，需要创建ssh key</p>
<pre><code class=""shell"">$ ssh-keygen -t rsa -C ""your_email@youremail.com""</code></pre>
<p>这里的<strong>your_email@youremail.com</strong>是你的<strong>邮箱地址</strong>，在输入后会询问你是否保存创建的ssh key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh key已经创建好。</p>
<h4>3.将ssh可以写入github</h4>
<p>创建好本地的ssh key后，我们需要让github知道这个ssh key是我们自己，所以需要将生成的ssh key复制出来，写入github，在mac下在终端输入</p>
<pre><code class=""shell"">cat ~/.ssh/id_rsa.pub</code></pre>
<p>此时在终端会显示出刚刚创建好的ssh key，复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。</p>
<h4>4.验证是否连接成功</h4>
<p>在终端输入</p>
<pre><code class=""shell"">$ ssh -T git@github.com</code></pre>
<p>如果回车看到：<strong>You’ve successfully authenticated, but GitHub does not provide shell access</strong> 。表示已成功连上github。</p>
<h4>5.设置username和email</h4>
<p>在把本项目上传到github之前还需要分别输入设置username和email，因为github每次commit都会记录他们。所以分别输入如下命令：</p>
<pre><code class=""shell"">$ git config --global user.name ""your name""
$ git config --global user.email ""your_email@youremail.com""</code></pre>
<h4>6.添加远程地址</h4>
<p>在与github连接成功后，如何才能让相应的项目上传到对应的仓库呢？这里就需要添加远程地址，从而让我们的本地项目顺利到达对应的仓库。</p>
<p>打开终端，输入</p>
<pre><code class=""shell"">$ git remote add origin git@github.com:yourName/yourRepo.git</code></pre>
<p>后面的yourName和yourRepo分别是你的github的用户名和刚才新建的仓库名。</p>
<h2>上传项目</h2>
<p>进入项目，在终端运行</p>
<pre><code class=""shell"">$ git status</code></pre>
<p>查看要上传的文件是否正确，然后将项目下的所有文件添加到git跟踪范围。</p>
<pre><code class=""shell"">$ git add .</code></pre>
<p>记录此次提交并上传</p>
<pre><code class=""shell"">$ git commit -m 'my project push'
$ git push origin master</code></pre>
<p>这里的<strong>master</strong>指的是主分支名，如果是其他分支，则填写相应的分支名。</p>
<p>这样我们就将我们的项目上传到github仓库。</p>
<h2>补充</h2>
<h4>1.<code>Permission denied</code>的解决：</h4>
<p>之前使用终端上传github的时候遇到错误</p>
<pre><code class=""shell"">
Permission denied (publickey).
</code></pre>
<p>解决办法就是直接重新生成一下公钥，然后重新更新就行，其中密码没必要设置</p>
<pre><code class=""shell"">
$ ssh-keygen -t rsa
</code></pre>
<h4>2.github项目内搜索</h4>
<p>在页面按住t，即可在项目中搜索需要的文件</p>

                ", git连接github总结,1531977909,483,1,769,1,1,https://segmentfault.com/a/1190000007466317
174,1,0,7,"
                    
<h1>我的个人简历线上版</h1>
<h2>背景</h2>
<p>在国外已经生活了将近四年，突然间萌生了想辞掉现在工作回国重新找工作的想法。既然是找工作，那么简历自然是少不了的事情。作为一个前端工程师，如果没有一份线上简历，这将是一件很low逼的事情，于是有了现在这份线上简历。</p>
<h2>产品</h2>
<p>不懂产品的开发不是一个好的开发。在做这份简历之前我站在产品的角度上进行了很多思考:</p>
<ol>
<li><p>产品面向的用户是谁？<br>既然是找工作，那么这份简历如果真能被看到应该是HR和国内的一些同行。</p></li>
<li><p>产品的入口是什么？<br>对于HR，看到我这份线上简历肯定是通过我的PDF版简历，如果只是在上面附上一个链接，想象着HR手动输入你的链接去看一下那简直是太天真了，时间对于他们是很宝贵的，所以最好的形式应该是一个二维码，拿出手机扫一扫，直接浏览。对于一些同行，可能是上班的时候，看到社区中我的一些宣传，点击链接的形式打开。所以线上版本应该同时对移动端和PC端友好。</p></li>
<li><p>信息架构？<br>简历应该主要包括以下内容：个人信息，教育背景，工作经历，技能。简历的最终呈现形式应该是简洁的，突出重点，尤其是在移动端，由于屏幕的限制，应该只显示关键内容。对于PC端可以适当的增加一些内容。</p></li>
</ol>
<h2>设计</h2>
<p>设计主要包括以下几个部分: 颜色，字体(中文和英文)，图像等。作为一个开发，这对我来说还是有点难度的，对于颜色方面，由于个人的偏好，比较喜欢极简风(又称性冷淡风)，所以色彩方面整体比较淡雅，色彩使用<a href=""https://coolors.co"" rel=""nofollow noreferrer"">colors</a>进行调配。色调大致如下:<br><span class=""img-wrap""><img data-src=""/img/bVFc6X?w=800&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>字体方面，英文字体就不必说了，系统自带的已经足够了，我选了monospace，个人偏好。中文字体让人非常为难，好看的系统没有，如果引入外部字体，大几千个汉字会造成字体文件非常大，用户的响应时间也会增加，在没有更好的方案之前，最终还是选用系统默认的中文字体 -  微软雅黑和华文细黑。图片方面，页面中引用的图片只有本人的头像和一个微信二维码，所以图片方面没有太大的问题(已考虑到iphone的2x或3x retina高分屏)。</p>
<h2>实现概要</h2>
<p>实现方面，引用了前端自动化工具gulp。可能有的人会说我装逼，总共几个页面，纯html，css，js两三个小时完全可以做的很好。你要是这么说，我也无言以对，使用gulp是基于以下几个方面考虑:</p>
<ul>
<li><p>开发时，我希望页面可以实时刷新，能够立马反馈到我代码方面的更新，使用纯页面开发则需要我手动刷新，作为一个工程师简直无法忍受</p></li>
<li><p>相比于css我更喜欢sass/scss，所以要求能够实时编译到css</p></li>
<li><p>从长远的角度来看，以后应该会对该项目进行更新，当项目变得庞大时再引入自动化流程为时已晚</p></li>
<li><p>线上版本和开发版本是有区别的。如果在本地开发之后，直接推到线上在展示方面没什么问题，但是在性能方面表现的则不太好。一个良好的线上版本应该是压缩合并过后的html/css/js/image等，将文件体积和http请求数减少到最小，这样用户在网络环境并不好的环境下也能在可接受范围内访问到页面。自动化流程中的一些工具可以帮助我们很方面的做到这些。</p></li>
</ul>
<h2>实现细节</h2>
<h3>页面重构</h3>
<p>由于要同时支持移动页和pc页，所以应为响应式布局。移动方面，参考了阿里的flexible方案，但是在落地实现时我使用了一种更为简单的方案，分别定义了三种尺寸的屏幕：480px(手机)，480 - 768px(平板)，768以上(pc)。每一种屏幕对应于html font-size: 16px, 20px, 24px。其他元素尺寸使用rem。这种方案，元素虽不会等比放大，但是显示效果可接受。</p>
<pre><code>//IOS: 320/480, 320/568 -&gt; 2, 375/667 -&gt; 2, 414/736 -&gt; 3
@media screen and (max-width: $screen-phone) {
  html {
    font-size: 16px;
  }
}

@media screen and (min-width: $screen-phone + 1) and (max-width: $screen-tablet - 1) {
  html {
    font-size: 20px;
  }
}

@media screen and (min-width: $screen-tablet) {
  html {
    font-size: 24px;
  }
}</code></pre>
<p>内容展示方面，提前做好规划，在什么样尺寸方面展现什么内容如何布局等，然后使用相关的media-query语句。</p>
<h3>业务逻辑</h3>
<p>使用<a href=""https://github.com/alvarotrigo/fullPage.js"" rel=""nofollow noreferrer"">fullpage.js</a>。</p>
<h3>自动化工作流</h3>
<p>开发时，使用gulp <a href=""http://www.browsersync.cn"" rel=""nofollow noreferrer"">browser-sync</a>作为本地的静态服务器，这样当你有所改动时，页面会实时刷新，另一个好处，你可以同时在移动设备进行测试。</p>
<p>使用bower作为包管理器，搭配gulp的wiredep工具，引入的外部js文件时会自动引入到页面中。搭配其他一些工具对html/css/js等进行压缩合并等。</p>
<p>talk is easy, show me the code, 具体请参考项目的<a href=""https://github.com/simonwoo/cv/blob/master/gulpfile.js"" rel=""nofollow noreferrer"">gulpfile.js</a>文件。</p>
<h2>测试</h2>
<h3>
<a href=""http://ami.responsivedesign.is"" rel=""nofollow noreferrer"">Responsive</a>测试</h3>
<p>使用responsive design工具对各尺寸屏幕进行测试，在各种尺寸下显示良好:<br><span class=""img-wrap""><img data-src=""/img/bVFdaN?w=2096&amp;h=1146"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>性能测试</h3>
<p>速度测试方面使用chrome network throttling对各种网络环境下进行测试, 即使是在GPRS环境下，也能在2s左右打开页面:<br><span class=""img-wrap""><img data-src=""/img/bVFda9?w=2548&amp;h=1486"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ol><li><p>在实体机上进行测试，测试机型为iphone 5/6/6+还有我的13 MBP。</p></li></ol>
<h2>发布</h2>
<p>对于一个程序员，github应该是你最好的托管中心。对于静态页面github提供了两种方式: gh-pages分支和master分支的docs目录。我采用了第二种方式，gulp构建流程的最后一步就是将线上使用到的文件拷入到docs目录。</p>
<h2>总结</h2>
<p>感兴趣的话你就扫一扫吧:<br><span class=""img-wrap""><img data-src=""/img/bVFdcU?w=330&amp;h=330"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""你不扫一下吗"" title=""你不扫一下吗""></span></p>
<p>这个小项目耗时2天，线上版本为<a href=""https://simonwoo.github.io/cv/"" rel=""nofollow noreferrer"">CV线上版</a>。写这篇博客的目的一方面是为了对这个项目进行一些总结，如果你对源代码感兴趣请访问<a href=""https://github.com/simonwoo/cv"" rel=""nofollow noreferrer"">项目地址</a>。另一方面也希望业内的一些朋友能够关注到我给我提供一些工作的机会，先谢谢各位大佬。如果你想更多的了解我，请访问我的<a href=""http://simonwoo.github.io"" rel=""nofollow noreferrer"">个人主页</a>。</p>
<p>写完这篇文章之后，突然间听到一个噩耗，国内好像不能访问github。此刻我的心情：<br><span class=""img-wrap""><img data-src=""/img/bVFdbO?w=225&amp;h=225"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 我的个人简历线上版,1531977911,496,1,223,1,1,https://segmentfault.com/a/1190000007399804
175,1,0,7,"
                    
<p><a href=""http://masonry.desandro.com/"" rel=""nofollow noreferrer"">Masonry</a>是最流行的瀑布流插件之一，配置简单，功能强大，在Github上收获了1w+ stars。如果你想使用瀑布流提升网站体验，Masonry将是不错的选择。</p>
<blockquote><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格,像花瓣网、蘑菇街、美丽说等。</p></blockquote>
<p>需要注意的是，如果你需要加载图片，Masonry不会在图片加载完后重新布局，这可能会影响你的布局效果，建议配合使用<a href=""http://imagesloaded.desandro.com/"" rel=""nofollow noreferrer"">imagesloaded</a>插件。<br><a href=""https://segmentfault.com/a/1190000007316974"" rel=""nofollow noreferrer"">imagesloaded配置与使用</a></p>
<h2>安装方式</h2>
<p>Bower</p>
<pre><code>bower install masonry --save</code></pre>
<p>Npm</p>
<pre><code>npm install masonry-layout</code></pre>
<p>加载</p>
<pre><code>&lt;script src=""/path/to/masonry.pkgd.min.js""&gt;&lt;/script&gt;</code></pre>
<h2>html代码</h2>
<pre><code>&lt;div class=""grid""&gt;
  &lt;div class=""grid-item""&gt;&lt;/div&gt;
  &lt;div class=""grid-item""&gt;&lt;/div&gt;
  ...
&lt;/div&gt;
</code></pre>
<h2>配置方式</h2>
<pre><code>// jQuery方式
$('.grid').masonry({
  columnWidth: 200,
  itemSelector: '.grid-item'
});

// Vanilla方式
var msnry = new Masonry( '.grid', {
  columnWidth: 200,
  itemSelector: '.grid-item'
});

&lt;!-- HTML方式，不推荐 --&gt;
&lt;div class=""grid"" data-masonry='{ ""columnWidth"": 200, ""itemSelector"": "".grid-item"" }'&gt;
</code></pre>
<h2>设置网格宽度</h2>
<pre><code>columnWidth: 80
columnWidth: elements
columnWidth: '.grid-sizer'
.grid-item { width: 20%; }
</code></pre>
<h2>全部属性配置</h2>
<pre><code>$('.grid').masonry({
  columnWidth: 200,
  itemSelector: '.grid-item'，     // 要布局的网格元素
  gutter：10,                      // 网格间水平方向边距，垂直方向边距使用css的margin-bottom设置
  percentPosition：true,           // 使用columnWidth对应元素的百分比尺寸
  stamp:'.grid-stamp',             // 网格中的固定元素，不会因重新布局改变位置，移动元素填充到固定元素下方
  fitWidth: true,                  // 设置网格容器宽度等于网格宽度，这样配合css的auto margin实现居中显示
  originLeft: true,                // 默认true网格左对齐，设为false变为右对齐
  originTop: true,                 // 默认true网格对齐顶部，设为false对齐底部
  containerStyle: { position: 'relative' },     // 设置容器样式
  transitionDuration: '0.8s',      // 改变位置或变为显示后，重布局变换的持续时间，时间格式为css的时间格式
  stagger: '0.03s',                // 重布局时网格并不是一起变换的，排在后面的网格比前一个延迟开始，该项设置延迟时间  
  resize： false,                  // 改变窗口大小将不会影响布局
  initLayout: true,                // 初始化布局，设未true可手动初试化布局
});
</code></pre>
<h2>方法调用方式</h2>
<pre><code>// jQuery方式。重新布局，添加元素，另一种方式添加元素，重新布局
$grid.masonry().append( elem ).masonry( 'appended', elem ).masonry();

// vanilla方式。同上
var msnry = new Masonry( '.grid', {...});
gridElement.appendChild( elem );
msnry.appended( elem );
msnry.layout();
</code></pre>
<h2>全部方法</h2>
<pre><code>$grid.masonry();                             // 重新布局
$grid.masonry( options );                    // 修改设置，再重新布局
$grid.masonry( 'layoutItems', items, isStill );     // 重布局指定元素，isStill接受布尔值，表示是否变换
$grid.masonry( 'stamp', $stamp );            // 固定元素
$grid.masonry( 'unstamp', $stamp );          // 解除固定
$grid.masonry( 'appended', elements );       // 在最后添加元素
$grid.masonry( 'prepended', elements );      // 在最前添加元素    
$grid.masonry( 'addItems', elements );       // 添加元素，但不布局
$grid.masonry( 'remove', elements );         // 删除元素    

 
</code></pre>
<h2>全部事件</h2>
<pre><code>// jQuery方式
var msnry = $grid.masonry( 'on', eventName, listener );
var msnry = $grid.masonry( 'off', eventName, listener );
var msnry = $grid.masonry( 'once', eventName, listener );

// vanilla方式
msnry.on( eventName, listener );
msnry.off( eventName, listener );
msnry.once( eventName, listener );

// jQuery,布局完成事件和移除完成事件
$grid.on( 'layoutComplete', function( event, items ) {
  console.log( items.length );
});
$grid.on( 'removeComplete', function( event, removedItems ) {...} )     

// vanilla，同上
msnry.on( 'layoutComplete', function( event, items ) {
  console.log( items.length );
});
msnry.on( 'removeComplete', function( event, removedItems ) {...} )
</code></pre>
<h2>Utilties</h2>
<pre><code>$grid.masonry('reloadItems');     // 重新载入元素，适用Angular和React被改变DOM元素后
$grid.masonry('destroy');         // 移除Masonry,元素返回初试化前状态
var elems = $grid.masonry('getItemElements');     // 返回网格元素
var msnry = $('.grid').data('masonry');           // 返回Masonry实例
var msnry = Masonry.data( $('.grid')[0] );        // 根据网格，返回Masonry实例

</code></pre>

                ", 瀑布流插件Masonry的配置和使用,1531977912,347,1,87,1,1,https://segmentfault.com/a/1190000007316788
176,1,0,7,"
                    
<p>对于一个团队来说，工作效率的高低很大程度上取决于团队的管理。</p>
<p>而作为一名刚接触测试职位的新人来说，如何把一堆堆杂乱不堪的bug管理得井井有条，无疑是最重要的。</p>
<p>我之前一直觉得测试是一份很个人化的工作，每个人有每个人做测试的思路，尤其是编写测试用例，需要大量的自定义字段来充实整个测试体系。在bug管理上，交给任何一个管理工具，我觉得都不如自己手动编辑测试逻辑更加高效。</p>
<p>因此，除了excel，我之前基本没有接触过其他工具。</p>
<p>工作了一段时间，我渐渐发现还是自己太年轻，测试其实是一份非常需要配合沟通的工作。由于excel在协作上实在办法不多，我每次只能把excel文件发给开发妹子们（没错，我们公司的开发都是妹子）。</p>
<p>但excel中的是个整体计划，每个开发负责的部分都是不同的，所以只能在全部信息中寻找自己需要做的那部分，这很难保证不会有遗漏。而计划一旦需要修改，我也很难与她们在第一时间达成同步。因此，很需要找一款能够在不同角色间沟通的bug管理工具。</p>
<p>于是，我将工作内容做了一个汇总，好帮助自己理清bug管理方面的需求：</p>
<ul>
<li><p>编写测试用例（经测试，还是excel最好用）</p></li>
<li><p>记录并做好版本、功能、优先级相关bug分类</p></li>
<li><p>与开发沟通，及时反馈bug完成情况</p></li>
<li><p>一些个人的事务管理</p></li>
</ul>
<p>带着这些需求，我开始试用bug管理类的工具。</p>
<p>起初，同事给我推荐了几款bug管理类的工具，像bugzilla，mantis，redmine，QC，jira等。但这些工具的使用体验真的很不友好：我连安装都没学会。</p>
<p>你要下载一个安装包，解压，在一群格式不明的文件中寻找一个尾部有.exe的文件，如果有好几个，那么你还要看看他们的名字哪一个更像是安装启动文件了，当然，你也可能根本找不到exe……（血泪史如图）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVEDHv?w=651&amp;h=591"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>对我这种软件小白来说，一次安装和配置就要花上好久，还加上各种看不明白的英文。最可怕的是，一旦不能用了还不知道是什么原因，网上各种找解决的帖子，想想都觉得挫败感满满……</p>
<p>随后，我将目标转向了中文化的在线团队协作工具，诸如teambition、worktile这种，希望能用更简单直接的方式解决我的问题。至少，我不用再花时间和exe文件做斗争了！</p>
<p>但tb和wt的问题是，这种以“项目+看板”为基础的管理模式，虽然能够更直观的展现bug的处理进度。但对于测试管理这种动辄1000+的bug量来说，前期制定版本计划会变得非常麻烦。</p>
<p>“使用管理工具的目的不就是提高效率么？为什么会比excel表格还难用？”这是我在试用过一大堆管理工具后产生的最大困惑。</p>
<p>接下来我又试用了几款小众软件，在这个过程中，偶然发现了一款叫做teamin的团队协作工具（这里吐个槽：开始看名字，还以为是teambition的精简版，teamin团队表打我！&gt;_&lt; ）。</p>
<p>秉持着是骡子是马拉出来溜溜的心态，我注册账号试用了一下……</p>
<h2>他给我的第一印象是简单</h2>
<p>和teambition，worktile这些团队协作工具一样，teamin也是一款基于Saas的在线管理工具，没有在一开始就让我的“安装包恐惧症”发作。</p>
<p>他的界面很干净，没有那么多复杂的功能干扰我，如果不是左侧的菜单，第一眼会让我以为这是一款像evernote、石墨那种类型的文档管理工具。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVEDHL?w=1128&amp;h=648"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>它创建任务的方式也很像是在做笔记：写完一条任务，回车，开始记录下一条，我觉得这种记录bug的方式让我觉得很舒服。</p>
<h2>他有很自由的使用体验</h2>
<p>经过一段时间的使用，我发现teamin的层级结构很特别。它一共分为3层：组织、团队和项目；项目中又分为列表、看板、日历、进展和文件五个模块；“我的任务”和“我的消息”作为个人事务管理独立于项目，信息范围覆盖整个组织；任务可以不断向下创建不止一层子任务。</p>
<p>这个结构纵向和横向的延展度都很好。简单来说呢，就是自由度很高。在这个结构下，我尝试出了一些与其他管理工具不太一样的新用法。</p>
<p><strong>举个栗子来说：</strong></p>
<p>teamin中，“我的任务”支持创建独立于组织之外的私人任务（只有创建者可以查看并编辑），并且可以通过设置任务所属项目与组织内任务进行相互转化。</p>
<p>如此一来，我就可以在自己的任务列表中随手记录下一些问题或是建议，也不会干扰到其他人。而一旦这些东西得到验证，我可以直接将它们转化成任务分配到项目中去。也就是说，记录与管理可以分开来做了。</p>
<p>这一点让我感觉很自在。</p>
<p>无论发现了什么问题，我都可以先记录下来，而不必担心打乱已有的bug清单，之后找个时间统一进行进一步的筛选与管理。这就比以往那种把任务从头设到尾的管理方式轻松多了，优先级设置也更精确……</p>
<p>个人管理的便利性和人性化让我渐渐爱上了这款工具。而且越使用，你就越会觉得，好像所有事都变得得心应手起来……很奇怪，它没有太多限制，也没有太复杂的功能，却很有控制力。</p>
<p>这种让人奇怪的感觉不仅体现在结构上，功能上teamin也秉承了“去边框化，去功能化”的特点，让我可以根据自己的实际需要，快速尝试出适合自己的那套管理方式。</p>
<h2>他如何解决我的问题</h2>
<p>上文提到了我在工作中遇到的一些问题。为了解决这些问题，我渐渐总结出了一套用法，涉及到一些teamin中比较特别的功能，接下来我就与大家分享一下。</p>
<p><strong>1、如何做版本管理</strong></p>
<p>第一个要说的，就是“目标”功能了。之所以把它放在第一位说，就是因为它完美解决了我在其他在线管理工具中一直没有解决的问题——版本管理。</p>
<p>而一开始，对于这个功能的出现我是很困惑的：这样一排tab页一样的东西是用来做什么的？这不是和标签功能重复了吗？（teamin的任务本身是可以设置标签的）</p>
<p>用了一段时间后，当我想要将创建的任务进一步整理归类的时候，突然发现“目标”功能的真正价值……这不就是一个版本管理神器么！</p>
<p>目标是一个独立于项目与任务间的管理层级，不同于标签，它能够带给我管理上更多发挥的空间。对于测试而言，目标非常适合做bug的版本管理。</p>
<p>显示目标后会出现两个默认标签，“全部”和“无目标”。</p>
<p>“全部”就是查看项目内所有bug；而没有被指定目标的bug，会被统一归入“无目标”中，这里我更喜欢叫它“bug需求池”；除此之外，我还需要新建几个目标用来管理具体版本：</p>
<ul>
<li><p>调出项目目标，按不同的版本创建好目标，将任务添加到项目中。</p></li>
<li><p>进入“无目标”中，将其中的bug分配到各自的版本目标中。</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVEDIu?w=1129&amp;h=655"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这种方式可以帮助我将冗长的“bug清单”进行瘦身，相比其他管理工具那种上千条bug混在一起的bug表单来说，“列表+目标”这一功能组合无疑是更好的选择。</p>
<p>你想想，当一个开发MM怀揣着以往与测试GG种种工作上不愉快的回忆战战兢兢来到这里时，却遇见了我这样一个如此为她着想，把bug计划安排的井井有条的SunshineTestBigBoy，难免不会产生崇拜之情，难免不会……</p>
<p>哼哼，我才不会让你们发现我的真正意图~</p>
<p><strong>2、如何制定计划、跟踪进展</strong></p>
<p>teamin的第二个功能特点，就是他看板+列表的双模式管理方式。</p>
<p>大家都知道，看板模式的优点就是便于查看任务进度，但却不擅长做整体计划，而teamin是我试用过的所有工具中，唯一拥有列表和看板两种模式的管理工具。</p>
<p>不仅如此，teamin中的列表看板任务信息是互通的。也就是说，我在列表中做的所有操作和修改，都会实时反映在看板中。</p>
<p>这样一来，我可以先在列表中做好计划，再到看版中管理bug进度。两种模式分别对应两种管理需求，使制定计划与控制进度都能达到效率最大化。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVEDIE?w=1131&amp;h=621"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>除此之外，日历中的任务也是相连通的。</p>
<p><strong>3、如何与开发进行协作</strong></p>
<p>很多时候，测试和开发间最大的问题就是沟通，我们无法即时将bug推送到开发面前，往往过了几个月，查看bug清单时，才发现仍然后很多bug没有被处理过，相信很多测试都遇到过这种问题。</p>
<p>为了能让bug得到及时解决，我一开始的做法是直接将bug提到开发项目中，但结果反而效率更低了。</p>
<p>在与开发妹子交换意见时，我了解到，其实bug与任务放在一起会使项目列表显得纷乱不堪，任务也会变得更难区分。</p>
<p>于是，我换了一种方式，把测试项目独立出来，将bug和开发项目分开，需要在当前开发计划中修改的bug才通过任务跨项目的方式分配给她们。这样的好处是可以防止开发陷入bug的汪洋大海中，可以有条不紊地安排开发的bug修改计划。</p>
<p>当然，想要做到这一点，和任务跨项目协同是分不开的。</p>
<p>其他管理工具在解决跨项目任务协同的问题时，一般都用任务复制，或是任务关联，将一条bug分成两条不同的任务，测试一份，开发一份。但实际上，他没有真正解决信息同步这个问题，即便开发那边完成了bug的修改，测试这里的bug状态也不会随之更新。</p>
<p>而在teamin中，却完全不同。任务可以属于多个项目，也就是说不同的项目共同拥有一条任务，而且支持状态同步。通俗一点说呢，就是心灵感应，你在那边干了什么我都知道哦~</p>
<p><span class=""img-wrap""><img data-src=""/img/bVEDIV?w=520&amp;h=554"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这样的处理方式，最终得到了广大妹子们的一致好评，她们纷纷表示喜闻乐见，人民幸福指数也有了显著提高，朕心甚慰。</p>
<h2>一点建议</h2>
<p>讲完了独特用法和优点，我对teamin还有几点小建议。</p>
<p>首先，希望能够添加信息导入导出的功能：之前光是将测试项目搬到teamin中，就花费了我大半天的时间。对于想要入驻teamin的用户来说，这也算是个不大不小的门槛了。</p>
<p>其次，希望能有类似垃圾箱的功能：被删除的项目或团队可以被恢复，以免误删或数据丢失。</p>
<h2>整体感觉</h2>
<p>总体来说，teamin是一款体验流畅、功能强大的管理工具。虽然略有不足，但同时也给了我很多使用上的惊喜。</p>
<p>而且，它和同类管理工具相比，有个最大的不同点：</p>
<p>我感觉teamin一直在跟着我的思维走，它不会束缚我，让我可以随意发挥、创造。很多需求都能找到很多种解决办法，我只需要在其中选择一个最优的，无须担心它在功能上会不会支持。随着使用的不断深入，又会发现更多让人眼前的一亮的点。</p>
<p>它就像一块七巧板，看似平淡无奇，但当你真正深入其中，却发现它可以凭借玩家的发挥，变换出千种形状。这一点尤为难得，也是我最终选择它的原因。</p>
<h2>写在后面的话</h2>
<p>其实没有什么规定说，bug管理就一定要用bug管理工具，那只是人们的一种固有思维，有时我们需要撕下它们的标签，才能看清我们探求问题的本质。</p>
<p>选择管理工具的唯一标准，是它能否让我的工作提高效率，而非它的标签。</p>
<p>如果大家有什么问题，或是有更好的工具和管理方法，也欢迎一起探讨。</p>

                ", 如何用轻量协作工具做bug管理,1531977914,159,1,309,1,1,https://segmentfault.com/a/1190000007263594
177,1,0,7,"
                    
<blockquote><p>本来打算在 centos 中安装 <code>nodejs</code>，先安装 <code>nvm</code> ，结果报错，安装不了，后来看到是因为 <code>git</code> 的版本问题，yum 源里的 <code>git</code> 版本太老了（1.7.1），所以必须安装新版，现在的新版最新为 2.10.1 （2016年10月11日），其实新版也不用安装最新的，反正 2.8 版本的也能用，我这里就安装最新的。</p></blockquote>
<h2>写在前面</h2>
<blockquote>
<p>遇到问题的时候，经常需要查 百度或谷歌，有时候一篇文章可能还解决不了问题，就需要看多篇文章，结果发现好多文章都是直接复制粘贴的，也不知道原作者是谁，一点自己的问题都没有，直接抄。看这种文章简直是浪费时间，对这些作者表示很坑，特别反感这种，我觉得写文章除了自己记录之外，也是一种知识分享，经验交流，写博客写文章就应该认认真真，把自己的问题叙述清楚，然后把解决方案讲明白，不要误导别人。</p>
<p>有这样的感受，所以我写文章都是很认真的，都是自己在看过很多文章，思考之后总结出来的，我们可能遇到的问题不同，但多多少少可以给些提示，说不定哪一个细节就是问题的关键所在呢，谢谢～～</p>
</blockquote>
<h2>下载最新版 git</h2>
<p>从 github 上下载最新版的 git 源码 </p>
<p>网址 ：<a href=""https://github.com/git/git/"" rel=""nofollow noreferrer""></a><a href=""https://github.com/git/git/"" rel=""nofollow noreferrer"">https://github.com/git/git/</a></p>
<p>打开网址后，点击 <code>releases</code> ，可以看到目前最新的 <code>git</code> 版本</p>
<p><span class=""img-wrap""><img data-src=""/img/bVD6ay?w=1127&amp;h=529"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVD6aP?w=1159&amp;h=498"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>从上图看到，最新版是 2.10.1 ，不要下载带有-rc的，因为它代表了一个候选发布版本，使用 wget 下载 v2.10.1 最新版本。</p>
<pre><code>wget https://github.com/git/git/archive/v2.10.1.tar.gz
</code></pre>
<p>下载成功后，对其解压</p>
<pre><code>➜  ~ ls
v2.10.1.tar.gz
➜  ~ tar -zvxf v2.10.1.tar.gz </code></pre>
<p>解压完成后 ，会多出一个 git 文件</p>
<pre><code>➜  ~ ls
git-2.10.1  v2.10.1.tar.gz</code></pre>
<h2>安装编译工具 和 依赖包</h2>
<p>在编译 git 之前，需要安装 编译工具和一些依赖文件，否则编译的时候会出错</p>
<pre><code>➜  ~ yum groupinstall ""Development Tools"" #安装 编译工具包</code></pre>
<p>再安装依赖包</p>
<pre><code>➜  ~ yum install zlib-devel perl-ExtUtils-MakeMaker asciidoc xmlto openssl-devel</code></pre>
<p>安装完成后就开始编译 git 源码了</p>
<h2>编译 git 源码</h2>
<p>进入 git 源码文件目录，执行下面的命令</p>
<pre><code>➜  ~ cd git-2.10.1 
➜  ~ autoconf    #自动配置
➜  ~ ./configure  
➜  ~ make &amp;&amp; make install</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVD6dN?w=713&amp;h=211"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVD6dS?w=884&amp;h=175"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVD6ee?w=842&amp;h=286"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>没有出错，编译成功了。</p>
<h2>添加 git 符号链接</h2>
<p>安装好的git是在<code>/usr/local/bin/git</code>下面，通过<code>link</code>来进行调用。如果报文件已经存在的错误，可以将原来的 git 删掉。</p>
<pre><code>➜  ~ ls /usr/local/bin
git            gitk              git-shell           git-upload-pack
git-cvsserver  git-receive-pack  git-upload-archive
➜  ~ ln -s /usr/local/bin/git /usr/bin
ln: 创建符号链接 ""/usr/bin/git"": 文件已存在
➜  ~ rm /usr/bin/git
➜  ~ ln -s /usr/local/bin/git /usr/bin
➜  ~ git --version
git version 2.10.1
➜  ~ </code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVD6eY?w=543&amp;h=160"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>再次 查看 git 的版本就是 2.10.1 了</p>
<blockquote><p>文中如有纰漏或者有什么问题，可以提出来，谢谢～～</p></blockquote>

                ", centos 6.7 安装 最新版 git,1531977915,455,1,802,1,1,https://segmentfault.com/a/1190000007134786
178,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVDOBN?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>本文背景，在实际项目中使用git已有一年多，发现不少同事虽然会使用常用git指令，但并不理解每个指令对应的作用原理。今天静下心总结下git 的基本理解：代码的存在区域；本文以实际项目出发，理清使用git过程中，代码的迁徙流程。</p>
<p>git跟传统的代码管理器（如:svn）不同， 主要区别在于git多了个<strong>本地仓库</strong>以及<strong>缓存区</strong>，所以即使无法联网也一样能提交代码。术语解释：</p>
<ul>
<li><p><strong>工作区间:</strong>  即我们创建的工程文件， 在编辑器可直观显示；</p></li>
<li><p><strong>缓存区:</strong>     只能通过git GUI或git shell 窗口显示，提交代码、解决冲突的中转站；</p></li>
<li><p><strong>本地仓库:</strong>  只能在git shell 窗口显示，连接本地代码跟远程代码的枢纽，不能联网时本地代码可先提交至该处；</p></li>
<li><p><strong>远程仓库:</strong>  即保存我们代码的服务器，本文以公共版本控制系统：<strong>github</strong>为例，登录github账号后可直观显示；</p></li>
</ul>
<p>接下来， 我们以三个实际操作的例子讲解git的日常，代码如何在上述4个区域流动。</p>
<h5>1.提交 代码到远程仓库：</h5>
<p>首先在本地工作区间创建一个新工程：testGit，然后在项目里新建一个README.md， 工作区间的工程如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOCv?w=744&amp;h=516"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>远程仓库创建一新工程，具体操作参见<a href=""http://michaelye1988.iteye.com/blog/1637951"" rel=""nofollow noreferrer"">如何在window上把你的项目提交到github</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOCF?w=1026&amp;h=490"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>将该新建的工程提交至远程仓库，关键的git 指令如下：</p>
<pre><code class=""bash"">git init
git add README.md
git commit -m ""首次提交代码""
git remote add origin https://github.com/wteam-xq/testGit.git
git push -u origin master</code></pre>
<p><strong>指令解释：</strong></p>
<p><code>git init</code>  表示在当前的项目目录中生成本地的git管理；</p>
<p><code>git add README.md</code>将“README.md”文件保存至<strong>缓存区</strong>，实际开发中一般使用 <code>git add -A</code>，使用-A:将新增、删除、修改的文件改动全保存至缓存区；</p>
<p><code>git commit -m ""first commit""</code> 将代码从<strong>缓存区</strong>保存至<strong>本地仓库</strong>，实际开发中一般使用<code>git commit -am ""first commit""</code>，<code>-a</code>即为<code>all</code>将<strong>缓存区</strong>所有改动保存至<strong>本地仓库</strong>；</p>
<p><code>git remote add origin https://github.com/wteam-xq/testGit.git</code>将<strong>本地仓库</strong>与指定的<strong>远程仓库</strong>创建 联系； <br><code>push -u origin master</code> 将<strong>本地仓库</strong>代码推送至<strong>远程仓库</strong>，实际开发中 该指令后需要输入github 账号以及密码。（首次提交注意别遗漏<code>-u</code>指定默认主机）</p>
<p>以上指令正常执行后， 本地仓库的代码就提交到远程仓库了：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOCI?w=1023&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>原理图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOCO?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h5>2.将远程仓库代码更新到本地：</h5>
<p>首先我们新建一文件夹：copyTestGit，进入该文件夹后使用git 指令：</p>
<pre><code class=""bash"">git clone https://github.com/wteam-xq/testGit</code></pre>
<p>指令执行完毕后， 就在该文件夹下生成一份副本啦（相当于多人协作时另一台设备上的工程文件），<strong>原理图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDODQ?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>接下来， 讨论<code>git pull</code>、 <code>git fetch</code> 、 <code>git merge</code>的关系</p>
<p><strong>先抛简单结论：</strong></p>
<pre><code class=""Bash"">git pull
#等同于下面命令
git fetch
git merge</code></pre>
<p>实际项目：我们在testGit工程中修改README.md,然后更新、提交下代码 执行以下git 指令(日常使用中会用<code>git status</code>看看是否有文件需要<code>git add</code>)：</p>
<pre><code>git commit -am 'update readme.md'
git push origin master</code></pre>
<p><strong>原理图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOEF?w=882&amp;h=512"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>提交成功：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOEL?w=1022&amp;h=542"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>远程仓库代码更新后， 我们进入<strong>另一本地仓库：</strong>copyTestGittestGit，将远程仓库的代码更新至该本地仓库。<br>在该目录下输入以下git指令：</p>
<pre><code>git fetch 
git merge origin/master</code></pre>
<p>日常使用图方便一般都是直接：</p>
<pre><code>git pull</code></pre>
<p>以上指令的详细探讨请看 <a href=""http://www.oschina.net/translate/git-fetch-and-merge?cmp"" rel=""nofollow noreferrer"">少用pull,多用fetch 和 merge</a>（<strong>注意:</strong> 本文注重git工作原理图不考虑多分支情况，且使用了<code>git clone</code>所以副本工程已经跟主分支建立了追踪关系，所以<code>pull</code> <code>fetch</code> 后都不接分支代码 ） </p>
<p><strong>以上指令区别的原理图：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOEG?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h5>3.更新到本地仓库时， 出现冲突，解决冲突；</h5>
<h6>3.1 放弃本地修改</h6>
<h6>3.2 解决冲突后提交本地修改</h6>
<p>首先， 我们先重现下出现冲突的情况； 在testGit目录下先修改README.md文件第三行，hello word 修正为 hello world：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFa?w=639&amp;h=384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>提交该修改到远程仓库（提交细节参照前述步骤）：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFb?w=1006&amp;h=577"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>然后， 在副本工程copyTestGit/testGit 目录下也修改README.md文件第三行，hello word 修正为 hello world2：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFf?w=631&amp;h=406"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>现在副本工程修改完了代码打算提交，提交前先将<strong>远程仓库</strong>最新代码更新至<strong>本地仓库</strong>, 惯例使用指令:</p>
<pre><code>git pull</code></pre>
<p>指令执行之后会发现以下冲突提示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFj?w=677&amp;h=392"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>出现以上提示， 说明本次更新代码失败；主要在于本地<strong>工作区间</strong>跟<strong>远程仓库</strong>的新代码冲突了， <strong>图解如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFh?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>接下来，有两种方式处理冲突: <strong>放弃本地修改</strong> 或 <strong>解决冲突后提交本地修改</strong></p>
<h6>3.1 放弃本地修改</h6>
<p>放弃本地修改意味着将<strong>远程仓库</strong>的代码完全覆盖<strong>本地仓库</strong>以及本地<strong>工作区间</strong>， 如果对git的指令不熟悉那大可以将本地工程完全删除，然后再重新拷贝一次（<code>git clone</code>）。</p>
<p>当然， git如此强大没必要用这么原始的方法，可以让<strong>本地仓库</strong>代码覆盖本地修改，然后更新<strong>远程仓库</strong>代码； </p>
<p><strong>本地仓库</strong>代码完全覆盖本地<strong>工作区间</strong>，具体指令如下：</p>
<pre><code>git checkout head .</code></pre>
<p>(注意： 别遗漏  <strong>""head""</strong> 后的 <strong>"" .""</strong> )<br>然后更新<strong>远程仓库</strong>的代码就不会出现冲突了:</p>
<pre><code>git pull</code></pre>
<p><strong>原理图如下：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFp?w=960&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h6>3.2 解决冲突后提交本地修改</h6>
<p>覆盖本地代码解决冲突方法适合不太懂git的菜鸟， 像我这种git老鸟（其实并不是(￢_￢)）当然用更高级的git指令解决冲突。<br>除了上述说的4个区间外， 其实git还有第5个区：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFu?w=502&amp;h=125"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>（关于git stash详见 本人 <a href=""https://github.com/wteam-xq/testGit/blob/master/learn_log/git_stash.md"" rel=""nofollow noreferrer"">testGit日志</a>）</p>
<p>跟 <strong>缓存区 </strong>一样， <strong>工作现场</strong>是 独立存在于<strong>本地仓库</strong>、<strong>工作区：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFv?w=600&amp;h=305"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>解决冲突后提交本地修改</strong>的思路大概如下：<br>将本地修改的代码放在<strong>工作现场</strong>， 然后从<strong>远程仓库</strong>拉取最新代码，拉取成功后再从<strong>工作现场</strong>将修改的代码取出， 这样最新代码跟本地修改的代码就会混杂在一起， 手工解决冲突后， 提交解决冲突后的代码。<br><strong>原理图：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFw?w=600&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFx?w=600&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>对应到我们实际项目中， 进入 copyTestGit/testGit 执行指令<code>git pull</code>出现 (重回到上述冲突场景)</p>
<pre><code>error: Your local changes to the following files would be overwritten by merge:
        README.md
Please, commit your changes or stash them before you can merge.
Aborting</code></pre>
<p>将本地修改放入<strong>工作现场</strong>(成功后本地<strong>工作区间</strong>的代码跟<strong>本地仓库</strong>代码会同步)， 具体指令：</p>
<pre><code>git stash </code></pre>
<p>从<strong>远程仓库</strong>获取最新代码，具体指令：</p>
<pre><code>git pull</code></pre>
<p>然后， 取出本地修改的代码， 具体指令:</p>
<pre><code>git stash pop</code></pre>
<p>然后， git 自动合并冲突失败， 冲突的代码就很清晰的展现在我们面前了：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFz?w=600&amp;h=347"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFC?w=600&amp;h=334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>手工解决冲突：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFD?w=600&amp;h=362"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>告诉git， 这个文件（README.md）的冲突 已经解决:</p>
<pre><code>git add README.md</code></pre>
<p>提交代码（细节参考前述流程）：</p>
<pre><code>git commit -am '终于解决冲突啦！'
git push origin master</code></pre>
<p>于是本地有冲突的代码就提交成功啦！</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFE?w=600&amp;h=340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<hr>
<h4>后记：</h4>
<p>以上很多git指令适合在无图形化界面的linux中使用（例如：阿里云服务器操作git）， 实际开发中当然是用<strong>图形化界面</strong>解决!<br>例如： <code>git status</code>在window 中对应的就是右键-&gt;git GUI</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFK?w=600&amp;h=392"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>解决冲突之<strong>覆盖本地代码</strong>对应的是： 工程目录下tortoiseGit(git 小乌龟) “Revert” ：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFL?w=600&amp;h=512"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>解决冲突之<strong>解决冲突后提交本地修改</strong>对应的是： 手工合并冲突代码后，工程目录下tortoiseGit(git 小乌龟) “resolve” ：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVDOFP?w=597&amp;h=490"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<hr>
<p>参考文章：<br>1.<a href=""http://www.jianshu.com/p/67afe711c731#"" rel=""nofollow noreferrer"">Git版本控制与工作流</a><br>2.<a href=""http://oss.org.cn/html/87/n-73187.html"" rel=""nofollow noreferrer"">图解git项目代码</a><br>3.<a href=""http://michaelye1988.iteye.com/blog/1637951"" rel=""nofollow noreferrer"">如何在window上把你的项目提交到github</a><br>4.<a href=""http://www.ruanyifeng.com/blog/2014/06/git_remote.html"" rel=""nofollow noreferrer"">阮一峰：git 远程操作详解</a><br>5.<a href=""http://www.oschina.net/translate/git-fetch-and-merge?cmp"" rel=""nofollow noreferrer"">少用pull,多用fetch 和 merge</a></p>
<hr>
<p>相关文章：<br><a href=""https://segmentfault.com/a/1190000007070302"" rel=""nofollow noreferrer"">git图解2：git 代码回退；</a><br><a href=""https://segmentfault.com/a/1190000009091082"" rel=""nofollow noreferrer"">git图解3：git 分支操作；</a></p>

                ", git图解：代码区域总结,1531977916,316,1,710,1,1,https://segmentfault.com/a/1190000007067265
179,1,0,7,"
                    
<p>最近把一个开发了很久的项目从公司的 svn 服务器迁移到 GitLab 上，折腾了几天。我们的 svn 目录结构不是很标准，所以网上的资料没一个能够照搬用的。Anyway，最后成功了，我这里详细记录一下，供参考。</p>
<p>本文地址：<a href=""https://segmentfault.com/a/1190000007039598"" rel=""nofollow noreferrer"">https://segmentfault.com/a/1190000007039598</a></p>
<h2>Reference</h2>
<p><a href=""http://blog.csdn.net/huaishu/article/details/41083951"" rel=""nofollow noreferrer"">SVN 迁移到GIT</a><br><a href=""http://blog.csdn.net/benq_xym/article/details/8980000"" rel=""nofollow noreferrer"">svn迁移到Git</a><br><a href=""http://www.blogjava.net/lishunli/archive/2012/01/15/368562.html"" rel=""nofollow noreferrer"">SVN迁移到Git的过程（+ 一些技巧）</a><br><a href=""http://www.cnblogs.com/bzhao/archive/2012/07/13/2590203.html"" rel=""nofollow noreferrer"">git-svn 使用环境和步骤</a><br><a href=""http://www.oschina.net/code/snippet_168578_13760"" rel=""nofollow noreferrer"">git如何恢复本地删除的文件</a><br><a href=""http://stackoverflow.com/questions/924574/git-alternatives-to-svn-info-that-can-be-included-in-a-build-for-traceability"" rel=""nofollow noreferrer"">git alternatives to “svn info” that can be included in a build for traceability?</a><br><a href=""https://github.com/nirvdrum/svn2git"" rel=""nofollow noreferrer"">svn2git</a><br><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000"" rel=""nofollow noreferrer"">为git配置扩展命令</a><br><a href=""http://blog.csdn.net/subfate/article/details/7806361"" rel=""nofollow noreferrer"">SVN、GIT生成版本号</a><br><a href=""http://www.cnblogs.com/gzpblog/p/5463031.html"" rel=""nofollow noreferrer"">git使用规范</a><br><a href=""http://www.cnblogs.com/jinzhao/archive/2012/03/21/2410156.html"" rel=""nofollow noreferrer"">Git 添加空文件夹的方法</a><br><a href=""http://blog.163.com/tango_zhu/blog/static/223471015201442691521954/"" rel=""nofollow noreferrer"">转：批量查找空文件夹并放置.gitkeep或.gitignore </a><br><a href=""http://www.cnblogs.com/softidea/p/5579668.html"" rel=""nofollow noreferrer"">git add --all 为啥不能添加空文件夹，这样设计的初衷是？</a><br><a href=""https://www.v2ex.com/t/163650"" rel=""nofollow noreferrer"">git 为何不能添加空文件夹?</a><br><a href=""http://www.zhihu.com/question/27712995"" rel=""nofollow noreferrer"">Git 里面的 origin 到底代表啥意思?</a><br><a href=""https://www.v2ex.com/t/136903"" rel=""nofollow noreferrer"">新手请教：Git 里面的 origin 到底代表啥意思？</a><br><a href=""http://www.cnblogs.com/smilegao/p/3642278.html"" rel=""nofollow noreferrer"">git 查看分支 以及所对应的remote</a><br><a href=""https://segmentfault.com/q/1010000000430426/"" rel=""nofollow noreferrer"">.gitignore 不起作用</a><br><a href=""http://www.cnblogs.com/iosdev/archive/2013/06/14/3135765.html"" rel=""nofollow noreferrer"">git 放弃本地修改更新</a><br><a href=""http://zhidao.baidu.com/question/360063745508995692.html"" rel=""nofollow noreferrer"">git 提交到本地但未push到远端的代码</a><br><a href=""http://www.cnblogs.com/mengdd/p/3585038.html"" rel=""nofollow noreferrer"">Git 分支管理和冲突解决</a><br><a href=""http://www.cnblogs.com/0201zcr/p/5752771.html"" rel=""nofollow noreferrer"">git cherry-pick合并某个commit</a><br><a href=""http://www.linuxidc.com/Linux/2012-04/58985.htm"" rel=""nofollow noreferrer"">Git错误non-fast-forward后的冲突解决</a><br><a href=""http://www.cnblogs.com/sinojelly/archive/2011/08/07/2130172.html"" rel=""nofollow noreferrer"">Git下的冲突解决</a><br><a href=""http://www.cnblogs.com/craftor/archive/2012/11/04/2754149.html"" rel=""nofollow noreferrer"">Git学习笔记05--git stash</a></p>
<p>看了好多资料……</p>
<p><span class=""img-wrap""><img data-src=""/img/bVD0IB?w=800&amp;h=3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Svn 代码库情况</h2>
<p>我们的 svn 代码库的 URL 当然是机密啦。不过大致原理上，我需要迁移的目录状况如下：</p>
<p>主分支（在 git 上应成为 master 分支）：<br><a href=""https://segmentfault.com/a/1190000007039598#articleHeader1"" rel=""nofollow noreferrer"">http://rdsvn.company.net/some_mid_path/Branches/main</a></p>
<p>此外打了几个tag：<br><a href=""https://segmentfault.com/a/1190000007039598#articleHeader1"" rel=""nofollow noreferrer"">http://rdsvn.company.net/some_mid_path/Branches/main_tag_25189</a><br><a href=""https://segmentfault.com/a/1190000007039598#articleHeader1"" rel=""nofollow noreferrer"">http://rdsvn.company.net/some_mid_path/Branches/main_tag_28141</a><br><a href=""https://segmentfault.com/a/1190000007039598#articleHeader1"" rel=""nofollow noreferrer"">http://rdsvn.company.net/some_mid_path/Branches/main_tag_28576</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVD0IB?w=800&amp;h=3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>导出 svn 工程</h2>
<p>首先，我们需要<code>git-svn</code>：</p>
<pre><code>$ sudo yum install git-svn
or
$ sodu apt-get install git-svn</code></pre>
<p>原理上，就是使用<code>git svn clone ...</code>命令。如果你只是简单的执行这个命令的话：</p>
<pre><code>$ git svn clone http://rdsvn.company.net/some_mid_path/Branches/main</code></pre>
<p>那么我们只是将主分支及其 log 取到了本地，但是其他的分支并没有。如果要把所有的分支都 checkout 出来的话，需要用到<code>--trunk</code>、<code>--tags</code>、<code>--branches</code>等选项。</p>
<p>需要注意的有三点：</p>
<ol>
<li>除了<code>trunk</code>单词是单数之外，其他的选项单词，请注意是<strong>复数</strong>。前者就是主分支的目录了，而后者表示的则是对应各个分支 / 标签的<strong>上层目录</strong>。Git-svn 会将该目录下的所有子目录视为一个独立的分支 / 标签进行导出。</li>
<li>这几个选项指定的都是<code>相对路径</code>，相对于你在<code>git svn clone</code>后面紧跟着的路径的位置。所以请不要在这些选项里面指定诸如 “<a href=""https://segmentfault.com/a/1190000007039598#articleHeader2"" rel=""nofollow noreferrer"">http://</a>” 开头的绝对地址。</li>
<li>除了 trunk 之外，其他几个相关选项可以重复指定。如果你的分支 / 标签分别在 svn 目录上的不同文件夹下，可以多次指定。</li>
</ol>
<p>于是，对应我们的实际情况，git-svn 命令是这样的：</p>
<pre><code>git svn clone http://rdsvn.company.net/some_mid_path/   \  # 注意这里并没有把主分支的路径写完整
--trunk=""Branches/main"" --tags=""Branches""</code></pre>
<p>稍等一会儿，就可以看到整个 svn 的主分支及分支都被导出来了，一颗赛艇！</p>
<p><span class=""img-wrap""><img data-src=""/img/bVD0IB?w=800&amp;h=3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>分支处理</h2>
<p>执行<code>git branch -a</code>可以看到相应的分支已经按照我们指定的选项建立起来了。我的实际情况，分支是这样的：</p>
<pre><code>    trunk
    tags/main_tag_25189
    tags/main_tag_28141
    tags/main_tag_28576</code></pre>
<p>这几个分支都被视为 Git 的<strong>远程分支</strong>，你的本地仓库暂时是空的。可以使用<code>git checkout -b ...</code>来将这几个分支拉到本地。</p>
<p>讲道理，svn 上的分支命名和 git 上的分支命名规则未必是一致的，因此这个时候你会想要重新命名分支。我的建议是这么操作：</p>
<ol>
<li>在这个仓库中，首先把这几个虚拟的远程分支 checkout 到本地保存下来，这样可以保存 change log</li>
<li>向服务器上传主分支，一般分支名就是 master</li>
<li>将复制出来的其他分支，推到 git 服务器上，按照你希望的规则进行命名</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVD0IB?w=800&amp;h=3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>上传到 git 服务器</h2>
<p>首先要在 git 服务器上创建一个空的工程，比如 “<a href=""https://segmentfault.com/a/1190000007039598#articleHeader4"" rel=""nofollow noreferrer"">git@rdgit.company.net/some_mid_path/some_group/firmware.git</a>”</p>
<p>然后在本地仓库中执行：</p>
<pre><code>git remote add origin git@rdgit.company.net/some_mid_path/some_group/firmware.git</code></pre>
<p>然后将主分支上传：</p>
<pre><code>git push origin trunk:master</code></pre>
<p>其他的分支也是利用这个语句创建新分支上传。</p>
<p>完成之后，在 git 服务器上就可以看到完整的 change log 以及分支变化情况啦。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVD0IB?w=800&amp;h=3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>关于空目录</h2>
<p>其实迁移的时候还需要注意一个问题，那就是 svn 支持空目录的版本控制，但是 git 不支持。</p>
<p>导出 svn 之后，最好对比一下原始的 svn 工程内是否有空目录。如果有，那么你需要手工（或者写脚本）在导出的 git 工程中创建这些目录，并且在目录中建立一个 “<code>.gitkeep</code>” 文件（这是约定俗成的做法），并且将这些文件<code>git add .gitkeep</code>，以加入 git 的版本控制。这样就以迂回的方式通过 git 版本控制了目录。</p>

                ", 实际操作 Svn 迁移到 Git,1531977917,312,1,160,1,1,https://segmentfault.com/a/1190000007039598
180,1,0,7,"
                    
<blockquote><p>有问题可通过微博联系我： <a href=""http://weibo.com/jinfali"" rel=""nofollow noreferrer"">http://weibo.com/jinfali</a></p></blockquote>
<h2>开源项目</h2>
<ul>
<li><p><a href=""https://github.com/xwartz/wechatApp-demo"" rel=""nofollow noreferrer"">wechatApp-demo</a> - 微信小程序 DEMO</p></li>
<li><p><a href=""https://github.com/gavinkwoe/weapp-ide-crack/blob/master/README.md"" rel=""nofollow noreferrer"">weapp-ide-crack</a> - 微信小应用资源破解</p></li>
<li><p><a href=""https://github.com/gztchan/wechat-mini-app/tree/master/page/API"" rel=""nofollow noreferrer"">API</a> - API 文档</p></li>
<li><p><a href=""https://github.com/phodal/weapp-quick"" rel=""nofollow noreferrer"">weapp-quick</a> - 微信小应用示例代码</p></li>
</ul>
<h2>文档</h2>
<ul>
<li><p><a href=""http://wxopen.notedown.cn/"" rel=""nofollow noreferrer"">简易教程</a></p></li>
<li><p><a href=""http://wxopen.notedown.cn/devtools/devtools.html"" rel=""nofollow noreferrer"">开发者工具文档</a></p></li>
<li><p><a href=""http://wxopen.notedown.cn/api/"" rel=""nofollow noreferrer"">API 文档</a></p></li>
<li><p><a href=""http://wxopen.notedown.cn/component/"" rel=""nofollow noreferrer"">视图组件文档</a></p></li>
<li><p><a href=""http://wxopen.notedown.cn/qa/qa.html"" rel=""nofollow noreferrer"">常见问题</a></p></li>
</ul>
<h2>教程</h2>
<ul>
<li><p><a href=""http://wxopen.notedown.cn/"" rel=""nofollow noreferrer"">微信小程序开发文档</a></p></li>
<li><p><a href=""https://github.com/Notedown-cn/wxopen"" rel=""nofollow noreferrer"">微信公众平台 API 文档 - GitHub</a></p></li>
<li><p><a href=""http://www.ifanr.com/721124"" rel=""nofollow noreferrer"">微信小程序怎么开发？玩物志用一个上午上线了电商应用 | 爱范儿</a></p></li>
<li><p><a href=""http://gold.xitu.io/entry/57e34d6bd2030900691e9ad7"" rel=""nofollow noreferrer"">首个微信小程序开发教程！</a></p></li>
<li><p><a href=""http://www.woshipm.com/ucd/418190.html"" rel=""nofollow noreferrer"">抢先看：微信官方发布的微信应用号（小程序）设计规范</a></p></li>
<li><p><a href=""https://laravel-china.org/topics/2890"" rel=""nofollow noreferrer"">开发微信小程序入门前</a></p></li>
<li><p><a href=""https://xituqu.com/508.html"" rel=""nofollow noreferrer"">微信小程序开发教程！</a></p></li>
<li><p><a href=""http://blog.csdn.net/xiehuimx/article/details/52629657"" rel=""nofollow noreferrer"">微信小程序开发环境搭建</a></p></li>
<li><p><a href=""https://my.oschina.net/wwnick/blog/750055"" rel=""nofollow noreferrer"">全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p></li>
<li><p><a href=""https://zhuanlan.zhihu.com/p/22574282"" rel=""nofollow noreferrer"">微信小程序「官方示例代码」浅析【上】</a></p></li>
<li><p><a href=""https://zhuanlan.zhihu.com/p/22579053"" rel=""nofollow noreferrer"">微信小程序「官方示例代码」浅析【下】</a></p></li>
</ul>
<h2>知乎讨论</h2>
<ul>
<li><p><a href=""https://www.zhihu.com/question/50874500"" rel=""nofollow noreferrer"">如何评价 9 月 21 日开始内测的「微信小程序」？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/39374074"" rel=""nofollow noreferrer"">如何看待微信将推应用号？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50875544"" rel=""nofollow noreferrer"">微信小程序（应用号）价值是什么？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50871887"" rel=""nofollow noreferrer"">开始内测的「微信公众平台 · 小程序」可能有哪些应用场景？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50885176"" rel=""nofollow noreferrer"">微信小程序（应用号）来了，对创业者来说到底是不是好机会？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50900987"" rel=""nofollow noreferrer"">微信小程序的出现会给前端开发带来什么？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50878415"" rel=""nofollow noreferrer"">微信应用号是否真能颠覆APP？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50878674"" rel=""nofollow noreferrer"">在微信应用号（微信小程序）开发什么什么应用爆发概率大？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50875630"" rel=""nofollow noreferrer"">如何获得「微信·小程序」的内测资格？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50874710"" rel=""nofollow noreferrer"">微信“小程序”真的来了！移动端会炸吗？Native开发何去何从？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50879269"" rel=""nofollow noreferrer"">微信的小程序会导致安卓和ios开发失业吗？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50879437"" rel=""nofollow noreferrer"">微信小程序（应用号）是如何通过苹果审核的？</a></p></li>
<li><p><a href=""https://www.zhihu.com/question/50886759"" rel=""nofollow noreferrer"">做微信小程序的开发者，需要掌握哪些编程技能？</a></p></li>
</ul>
<h2>媒体报道</h2>
<ul>
<li><p><a href=""https://kenengba.com/post/3515.html"" rel=""nofollow noreferrer"">关于微信小程序（应用号），我能透露的几个细节</a></p></li>
<li><p><a href=""http://www.pmcaff.com/article/index/411074173930624"" rel=""nofollow noreferrer"">微信应用号来了，程序猿要涨工资了！</a></p></li>
<li><p><a href=""http://36kr.com/topics/98"" rel=""nofollow noreferrer"">微信推出小程序应用号，移动互联网第二春会来吗？</a></p></li>
<li><p><a href=""http://www.woshipm.com/it/417887.html"" rel=""nofollow noreferrer"">一篇文章读懂微信小程序(应用号)是什么，是否值得投入进来做？</a></p></li>
<li><p><a href=""https://www.huxiu.com/article/164700.html"" rel=""nofollow noreferrer"">你的产品适不适合做微信小程序？你需要这篇产品逻辑分析</a></p></li>
<li><p><a href=""https://www.huxiu.com/article/164634.html"" rel=""nofollow noreferrer"">微信应用号正式公开，一个开放的微信已经上路？</a></p></li>
<li><p><a href=""https://www.huxiu.com/article/164679.html"" rel=""nofollow noreferrer"">一文读懂微信小程序（应用号）是什么，创业者是否值得投入进来做？</a></p></li>
<li><p><a href=""http://wenda.louqun.com/article/107593"" rel=""nofollow noreferrer"">一张图看懂微信“小程序”</a></p></li>
<li><p><a href=""https://zi.com/w/a/b32fJp"" rel=""nofollow noreferrer"">关于微信小程序，我联想到的几点</a></p></li>
<li><p><a href=""http://www.880917.com/wang/10850.html"" rel=""nofollow noreferrer"">你想做个怎样的微信小程序？</a></p></li>
<li><p><a href=""http://it.sohu.com/20160922/n468981595.shtml"" rel=""nofollow noreferrer"">微信小程序动了谁的蛋糕,又会把蛋糕分给谁?</a></p></li>
</ul>
<h2>文章</h2>
<ul>
<li><p><a href=""http://blog.csdn.net/yulianlin/article/details/52621413"" rel=""nofollow noreferrer"">从程序员的角度分析微信小程序</a></p></li>
<li><p><a href=""http://www.jianshu.com/p/060c6f3dd4e8"" rel=""nofollow noreferrer"">微信小程序，一个有局限的类似 React Native 轮子！</a></p></li>
<li><p><a href=""https://zhuanlan.zhihu.com/p/22565340"" rel=""nofollow noreferrer"">关于微信小程序（应用号）的底层逻辑分析和拥抱建议</a></p></li>
<li><p><a href=""http://kulianw.com/keji/201609/18558.html"" rel=""nofollow noreferrer"">微信小程序常见问题汇总 微信小程序有什么功能 如何申请？</a></p></li>
<li><p><a href=""http://www.jianshu.com/p/f8266c940eaf"" rel=""nofollow noreferrer"">关于微信小程序（应用号）的全部看法</a></p></li>
<li><p><a href=""http://www.jianshu.com/p/597de915ef68"" rel=""nofollow noreferrer"">微信应用号相关资料集合</a></p></li>
<li><p><a href=""https://www.v2ex.com/t/308005#reply17"" rel=""nofollow noreferrer"">封闭一周开发微信应用号（小程序）</a></p></li>
<li><p><a href=""http://t.cn/RcYXD4Q"" rel=""nofollow noreferrer"">微信应用号「小程序」最全的Q&amp;A列表</a></p></li>
<li><p><a href=""http://t.cn/RcYXsoP"" rel=""nofollow noreferrer"">为什么要发布微信应用号</a></p></li>
<li><p><a href=""http://t.cn/RcYowhy"" rel=""nofollow noreferrer"">微信小程序，仅仅是 Web App 么？</a></p></li>
</ul>

                ", 微信小程序资源汇总整理,1531977919,437,1,152,1,1,https://segmentfault.com/a/1190000006986886
181,1,0,7,"
                    
<p>这里要提到的是我之前从项目抽离出来的微型 Javascript 项目 <a href=""https://github.com/hustcc/timeago.js"" rel=""nofollow noreferrer"">timeago.js</a>，为什么是微型，因为他还不到 2kb，这个也是做这个项目的原因之一。</p>
<p>已有的类似项目不是一般都依赖 jQuery 和 moment.js，实际上仅仅用到其中的选择器、一个日期方法（fromNow），<code>为了这么一点方法依赖，而引入则好么大的库</code>，个人感觉不是很划算。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006893725?w=740&amp;h=364"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""http://static.oschina.net/uploads/space/2016/0912/133711_0Rge_134320.png"" title=""http://static.oschina.net/uploads/space/2016/0912/133711_0Rge_134320.png""></span></p>
<p><a href=""https://github.com/hustcc/timeago.js"" rel=""nofollow noreferrer"">timeago.js</a> 项目大概开始于今年6月底左右，抽离出来，npm publish之后，在自己的多个项目中使用良好，就没有再多做更新了，后来因为另外一个项目中的 PR 引用到 timeago.js 项目，所以决定好好做一做，并推广一下，并陆续增加修改如下东西：</p>
<ol>
<li><p>增加<code>实时更新方法 render</code>，可以选择一些节点实时更新和计算；</p></li>
<li><p>完善<code>Testcase</code>，使用travis CI；</p></li>
<li><p>申请<code>域名 timeago.org</code>，后来因为这个域名和其他项目产生了一些不愉快，不过无所谓，我很大条；</p></li>
<li><p>更新优化<code>本地化 locale</code>文件的格式；</p></li>
<li><p>新开一个 issue 专门记录 locale 的 pr；</p></li>
</ol>
<p>然后将域名 <a href=""http://timeago.org"" rel=""nofollow noreferrer"">timeago.org</a> 发到 Hack New上，然后就是域名被老外转到reddit，并且关于创造更小的轮子，依赖jQuery这些问题引起了一些争论，再然后就过了一天，就上了 Github 的 Trending 总榜，<strong>目前已经在榜上 4 天了。就在这次天内，star 数量瞬间达到 1000 +</strong>，自己还是很激动的。</p>
<p>说说自己的感想吧？</p>
<ol>
<li><p>如果真的想好好做一个项目，还是申请一个<code>合适的域名</code>吧，这样可能会给人更加专业，更加重视的感觉；</p></li>
<li><p>老外真的特别喜欢发 pr 和 issue，可能是国内程序员的时间被商人完全榨干了；</p></li>
<li><p>保证项目有<code>完善的测试</code>，travis CI集成起来其实非常简单；</p></li>
<li><p><code>项目特色</code>，比如timeago.js特色就是tiny（1.75 kb完成其他项目依赖 jQ 的事情），并且在多个 issue 中要求 pr 一定要保证代码的简洁；</p></li>
<li><p><code>PR 规范</code>，比如 timeago.js 中的主要 pr 来源于本地化语言的翻译，所以我会专门开一个issue来展现需要 pr 哪些语言，然后大家一目了然，可以增加大家 pr 的积极性；</p></li>
</ol>
<p>做好这些之后，就可以到一些技术论坛发发文章，博客了，具体发哪些位置呢？</p>
<p><code>Hack New、开发者头条、V2ex、OSChina、segmentfault、极客头条</code>等等。我对国外技术站点不是很了解，仅仅发了 Hack New。</p>
<p>然后就是等着其他开发人员给你提意见、建议，然后积极响应和修改吧。</p>

                ", 一个微型 Javascript 开源项目如何在 4 天到 1000 star ？,1531977920,502,1,400,1,1,https://segmentfault.com/a/1190000006893696
182,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVCMqq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>项目简介：本课程将带领大家在 Github Pages 上部署自己的简历，教大家如何将简历保存为 pdf 格式且该简历文件可直接在 A4 纸上打印。另外本课程还提供了简单的在线可编辑的简历页面，同学可直接使用它来生成自己的简历文件。</p>
<p>项目由<a href=""https://www.shiyanlou.com/user/8834"" rel=""nofollow noreferrer"">ekCit</a>发布在<a href=""https://www.shiyanlou.com/courses"" rel=""nofollow noreferrer"">实验楼</a>，完整教程及在线练习地址：<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">在Github Pages上部署自己的简历</a>，可以直接在实验环境中部署实践。</p>
<h2>一、课程介绍</h2>
<h3>1. 课程背景</h3>
<p>这几天室友忙着找工作改简历，想到自己也会有这么一天，那么就来一起好好写一份简历吧。</p>
<p>期间在网上找了不少写简历的资源，我对自己写的简历模板有信心，放这个出来就是要比比看。比比看性价比，我们这个模版的价格是 0，分母是 0 就意味着性价比无穷大！</p>
<p>写这个模版的初衷是希望同一份简历既能做页面展示，也能直接打印出来给我到处投。（请认真对待每一份简历，不要学习笔者）。</p>
<p>写这份模版也是站在巨人的肩膀上，参考了前人经验的。</p>
<p>我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。</p>
<blockquote>
<p>什么是 Github Pages？</p>
<p>Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：<a href=""https://help.github.com/articles/what-is-github-pages/"" rel=""nofollow noreferrer"">https://help.github.com/artic...</a></p>
</blockquote>
<p>可以说相当于一个可直接用 git 管理内容的静态服务器，有许多人会用它来托管自己的个人博客（利用 Jekyll、Pelican 这一类静态页面生成工具）或是在这上面发布自己的 HTML5 小游戏。当然这么好的东西也是有限制的。</p>
<p>Github Pages 的限制：</p>
<ul>
<li><p>仓库存储的所有文件不能超过 1 GB</p></li>
<li><p>页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。</p></li>
<li><p>每小时最多只能部署 10 个静态网站。</p></li>
</ul>
<p>对于发布自己的简历或是部署自己的博客的这一类需求我想是不用担心这些限制的，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。</p>
<h3>2. 预备知识</h3>
<p>本课程需要的预备知识：</p>
<ul><li><p><code>git</code> 的基本使用</p></li></ul>
<p>如果对 <code>git</code> 完全陌生，推荐学习实验楼的<a href=""https://www.shiyanlou.com/courses/4"" rel=""nofollow noreferrer"">《Git 实战教程》</a>，仅需了解最基本的操作即可。</p>
<h3>3. 课程知识点</h3>
<p>本课程项目完成过程中，我们将学习：</p>
<ol><li><p>在 Github Pages 上部署自己的简历</p></li></ol>
<h3>4. 最终效果</h3>
<p>简历页面展示：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006820293"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>保存后的 pdf 版本：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<h2>二、实验步骤</h2>
<h3>1、初始化 git 库</h3>
<p>打开终端，进入 <code>Code</code> 目录，创建 <code>CV</code> 文件夹, 并将其作为我们的工作目录。</p>
<pre><code>$ cd Code
$ mkdir CV &amp;&amp; cd CV
</code></pre>
<p>初始化 git 库。</p>
<pre><code>$ git init
</code></pre>
<p>用户配置（可选）：</p>
<pre><code>$ git config --global user.name ""你的用户名""
$ git config --global user.email ""你的邮箱地址""
</code></pre>
<p>这一步不做也没关系，用户名和邮箱是你提交<code>commit</code>时的签名，在 Github 的仓库页面上会显示这次提交的用户，如果不做设置就会默认为该仓库的拥有者，做了则根据邮箱来匹配用户。</p>
<h3>2、编辑简历文件</h3>
<p>下载页面模板文件。</p>
<p>解包，并且直接将其中的文件置于 CV 文件夹下。</p>
<pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/624/cv-template.zip
$ unzip cv-template
$ mv cv-template/* .
$ rm -rf cv-template* __MACOSX*
</code></pre>
<p>用浏览器打开就可以看见模板的样子了。同学们可以根据自己的需求来修改模板的样式。</p>
<p>有的同学可能已经发现这份模板是可编辑的了。</p>
<p>所有的文字栏目都是可以随意编辑的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820295"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>点击图片可以通过图片的url地址替换：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820296"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>微信号不想留就把整个栏目删掉，可增加新的条目：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>可通过点击编辑进度条，注意敏感信息不要发布在页面上，我们仅在需要打印简历时用到这些信息：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820298"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>注意简历的内容不要超出背景的高度。</p>
<p>编辑完自己的简历以后，就把修改后的代码复制下来，替换掉原<code>index.html</code>里的代码。</p>
<p>Firefox 下：</p>
<p>打开查看器：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>复制 html 标签的外部 HTML：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>然后将index.html中的 html 标签的所有内容（包括 html 标签）替换掉即可。</p>
<p>我的本意是发布后的简历页面仍是可编辑的，这方便我日后直接在上面编辑手机等个人信息后保存打印。</p>
<h3>3、部署简历文件</h3>
<p>首先需要每位同学都有自己的 Github 账号，没有就快去注册一个吧。然后新建一个仓库，名字取 cv 或是 resume 皆可，之后先别跟着它给的步骤做。</p>
<p>Github Pages 支持托管的页面分两类，个人/组织页面 与 项目页面，其主要区别就是托管位置的区别。<br>如果想使用个人主页，那么就创建一个名为 <code>username.github.io</code> （username需要替换为你的用户名）的库，在主分支<code>master</code>上托管你的页面代码。</p>
<p>如果是使用项目主页，那么可以选择将代码托管在<code>master</code>、<code>gh-pages</code>、或者<code>master</code>的<code>doc</code>目录下，其中<code>gh-pages</code>是默认的页面托管分支，如果想使用<code>master</code>，可在项目页面的设置栏中进行切换。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820301"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>无论使用哪一种页面操作都是差不多的，这里就用项目页面来做演示了，由于我们所有的代码就只有页面代码而已，那么就直接在<code>master</code>分支上进行托管吧。</p>
<p>先在本地仓库做一次代码提交：</p>
<pre><code>$ git add .
$ git commit -m 'commit my cv'
</code></pre>
<p>在项目页面找到你的仓库地址后输入：</p>
<pre><code>$ git remote add origin 你的远程仓库地址
$ git push -u origin master
</code></pre>
<p>代码提交到远程仓库后，在项目页面设置 Github Pages 使用的托管源。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820302"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>现在你可以访问<code>https://你的用户名.github.io/resume/</code>这个地址了，恭喜，简历页面已成功部署在了 Github Pages 上。</p>
<h3>4、保存简历为 pdf 格式</h3>
<p>笔者考察过多个在线转换 pdf 的网站以及 js 保存 pdf 的方案，效果都不甚理想。最后发现这一步其实可以很简单，你只要打开浏览器的打印选项然后它其实是可以直接帮你保存为 pdf 的！这里还是推荐使用 Chrome ，Firefox 似乎无法删页脚与页眉。</p>
<p>Chrome 下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820303"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>因为等到打印 pdf 的时候，那个页边距是可以再调的，所以笔者比较倾向于在保存的时候不保留页边距。</p>
<p>完整教程可在<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">实验楼</a>查看并在线完成，有更详细的简历编辑及部署细节，还有<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">简历模板福利</a>。<br>更多经典项目：<a href=""https://www.shiyanlou.com/courses"" rel=""nofollow noreferrer"">全部-课程-实验楼</a></p>

                ", 程序员必备技能：在Github上部署自己的简历,1531977921,386,1,981,1,1,https://segmentfault.com/a/1190000006820290
183,1,0,7,"
                    
<blockquote><p>这篇文章将如何搭建hexo，以及如何通过git webhooks实现远程vps的自动部署</p></blockquote>
<p>这篇文章适合的条件：</p>
<ol>
<li><p>简单的用于个人博客、公司博客展示，hexo的定位是静态博客，要实现动态服务器的功能并不适合</p></li>
<li><p>有自己私有的服务器、vps、域名</p></li>
<li><p>git仓库，<a href=""https://github.com/"" rel=""nofollow noreferrer"">Github</a>或国内的<a href=""https://coding.net/user"" rel=""nofollow noreferrer"">Coding.net</a></p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763830"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>hexo本地部署</h2>
<p>流程：先在本机搭建好hexo环境，push到git仓库，再部署到服务器上。</p>
<p>第一步，安装hexo命令行工具，这个工具在服务器端也需要执行安装</p>
<pre><code class=""bash"">npm install hexo-cli -g</code></pre>
<p>第二部，生成一个本地hexo项目</p>
<pre><code class=""bash""># 创建blog目录，并初始化hexo项目
hexo init blog
cd blog
# 安装hexo依赖，hexo是基于nodejs开发的，npm是nodejs的包管理工具
npm install
# 启动本地服务，打开localhost:4000测试是否成功
hexo server</code></pre>
<p>第三部，新建一篇文章</p>
<pre><code class=""bash"">hexo new ""My First Post""
# 启动本地服务，查看效果
hexo server</code></pre>
<p>这样，在/source/_posts目录下就生成了了<code>my-first-post.md</code>这样一个文件，.md是markdown文件的扩展名，我们可以使用自己喜欢的工具去编辑markdown，比如Sublime Text。</p>
<p>这里推荐一个Sublime Text插件，给人家免费推广了，<a href=""https://packagecontrol.io/packages/OmniMarkupPreviewer"" rel=""nofollow noreferrer"">OmniMarkupPreviewer</a>。</p>
<h2>提交到远程仓库</h2>
<p>你得需要一个远程仓库托管代码，可以使用<a href=""https://github.com/"" rel=""nofollow noreferrer"">Github</a>或国内的<a href=""https://coding.net/user"" rel=""nofollow noreferrer"">Coding.net</a>，因为我有些项目属于私有项目，Github开私有项目是需要收费的，所以我选择的是国内的Coding.net，速度也比较理想。</p>
<p>先在coding上新建一个项目名为hexo，并拷贝仓库ssh地址（使用ssh需要配置ssh公钥和私钥，如果不会配可以google或使用http地址）。</p>
<p><strong>提示，如果需要通过webhooks实现服务器自动化部署，推荐使用ssh会更方便一些</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763831"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后在hexo目录初始化本地仓库并提交到coding</p>
<pre><code class=""bash"">git init
git remote add origin git@git.coding.net:lianer/hexo-blog.git
git add .
git commit -m 'publish'
git push origin master</code></pre>
<p>这时候coding上已经有我提交的代码了。</p>
<h2>服务器环境配置</h2>
<p>登录你自己的vps服务器，安装好nodejs,git,nginx，个人服务器还是推荐使用ubuntu，安装这些工具很容易，具体百度或谷歌。</p>
<p>我在公司搭的hexo，公司服务器使用的是centos，git我是请运维同学帮我安装的，比较麻烦。</p>
<h3>将代码从远程仓库拉下来</h3>
<p>同样的服务器也需要配置ssh才能使用ssh地址，否则还是使用http地址吧。</p>
<p>在这里，我直接把项目放在root目录下了。</p>
<pre><code class=""bash"">mkdir hexo
git init
git remote add origin git@git.coding.net:lianer/hexo-blog.git
git pull origin master</code></pre>
<h3>安装hexo模块</h3>
<pre><code class=""bash"">cd ~/hexo
npm install hexo-cli -g
npm install</code></pre>
<h3>hexo静态编译</h3>
<pre><code class=""bash"">hexo g</code></pre>
<p>这一步会在hexo目录下生成一个public目录，这里面就是编译后的静态文件目录，<br>其实这时候直接访问里面的html文件即可看到完整的效果了，只不过还需要一个服务来运行它。</p>
<h3>配置nginx</h3>
<p>进入nginx服务配置文件目录，该目录下应该已经有一个default.conf，不去管它，另外新建一个配置文件</p>
<pre><code class=""bash"">cd /etc/nginx/conf.d/
vi hexo.conf</code></pre>
<p>在hexo.conf中输入以下内容并保存，注意细节，不要少分号。</p>
<pre><code>server {
    listen          80;  # 监听端口
    server_name     imlianer.com www.imlianer.com;  # 你的域名
    location / {
        root        ~/hexo;
        index        index.html;
    }
}</code></pre>
<p>重载nginx，使配置生效。</p>
<pre><code class=""bash"">nginx -s reload</code></pre>
<p>然后就可以通过 <a href=""http://imlianer.com"" rel=""nofollow noreferrer"">http://imlianer.com</a> 访问hexo了。</p>
<h2>Git WebHooks 自动化部署</h2>
<p>是不是觉得每次写完文章还要登录服务器去执行一次git pull很麻烦？</p>
<p>ok，git有很多钩子，可以在仓库发生变化的时候触发，类似js中的事件。<br>WebHooks就是在你本地执行git push的时候，<br>远程仓库(coding)会检测到仓库的变化，并发送一个请求到我们配置好的WebHooks。</p>
<p>实现WebHooks自动化部署的推荐条件：</p>
<ol>
<li><p>服务器端配置ssh认证</p></li>
<li><p>服务器端配置nodejs服务，接收Coding发来的请求</p></li>
</ol>
<h3>远程仓库配置WebHooks</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006763832"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Coding WebHooks 配置界面</p>
<p>这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到<a href=""http://imlianer.com/webhooks/push/123456"" rel=""nofollow noreferrer"">http://imlianer.com/webhooks/...</a>。</p>
<p>为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。</p>
<p>到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。</p>
<h3>服务器配置响应WebHooks的服务</h3>
<p>我使用的是nodejs，其它语言也可以。</p>
<p>在本地hexo目录中新建一个webhooks.js文件，内容如下：</p>
<pre><code class=""js"">var http = require('http')
var exec = require('child_process').exec

http.createServer(function (req, res) {
    // 该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。
    if(req.url === '/webhooks/push/123456'){
        // 如果url匹配，表示认证通过，则执行 sh ./deploy.sh
        exec('sh ./deploy.sh')
    }
    res.end()
}).listen(4002)</code></pre>
<p>这段代码就能启动一个nodejs服务，监听4002端口。<br>当请求过来的url完全匹配的时候，执行deploy.sh。</p>
<p>再新建一个文件deploy.sh处理部署相关脚本，内容如下：</p>
<pre><code class=""bash"">git pull origin master
hexo g</code></pre>
<p>将新增的webhooks.js与deploy.sh两个文件push到服务器。</p>
<p>然后在服务器中启动nodejs服务监听webhooks</p>
<pre><code class=""bash"">node ./webhooks.js</code></pre>
<p>这样，当你本地提交文章的时候，服务器就会自动部署啦。</p>
<p>如果你使用上面的命令运行nodejs服务，nodejs服务会在前台运行，<br>可以使用<a href=""https://www.baidu.com/link?url=v0z1NSTvZC7h01nvvBjS5FoU-IwyEdcjSntjdAQB9myM2FkPXW68e4it5uhLitCZ&amp;wd=&amp;eqid=d558847e000b20ae0000000357bc649c"" rel=""nofollow noreferrer"">pm2</a>使nodejs运行在后台。</p>

                ", Hexo快速搭建静态博客并实现远程VPS自动部署,1531977923,383,1,997,1,1,https://segmentfault.com/a/1190000006745478
184,1,0,7,"
                    
<h2>SublimeText快捷键大全</h2>
<h3>选择类</h3>
<p>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。（非常好用，当你要改多出同样的代码时）</p>
<p>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。（快速选中并更改所有相同的变量名、函数名等）</p>
<p>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。（不想动鼠标）</p>
<p>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p>
<p>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。（快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容）</p>
<p>Ctrl+M 光标移动至括号内结束或开始的位置。</p>
<p>Ctrl+Enter 在下一行插入新行。（即使光标不在行尾，也能快速向下插入一行）</p>
<p>Ctrl+Shift+Enter 在上一行插入新行。（即使光标不在行首，也能快速向上插入一行）</p>
<p>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。</p>
<p>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。</p>
<p>Ctrl+K+0 展开所有折叠代码。</p>
<p>Ctrl+← 向左单位性地移动光标，快速移动光标。</p>
<p>Ctrl+→ 向右单位性地移动光标，快速移动光标。</p>
<p>shift+↑ 向上选中多行。</p>
<p>shift+↓ 向下选中多行。</p>
<p>Shift+← 向左选中文本。</p>
<p>Shift+→ 向右选中文本。</p>
<p>Ctrl+Shift+← 向左单位性地选中文本。</p>
<p>Ctrl+Shift+→ 向右单位性地选中文本。</p>
<p>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</p>
<p>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</p>
<p>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。</p>
<p>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</p>
<h3>编辑类</h3>
<p>编辑类常用，以下不多说</p>
<p>Ctrl+J 合并选中的多行代码为一行。（将多行格式的CSS属性合并为一行）</p>
<p>Ctrl+Shift+D 复制光标所在整行，插入到下一行。</p>
<p>Tab 向右缩进。 </p>
<p>Shift+Tab 向左缩进。</p>
<p>Ctrl+K+K 从光标处开始删除代码至行尾。</p>
<p>Ctrl+Shift+K 删除整行。</p>
<p>Ctrl+/ 注释单行。</p>
<p>Ctrl+Shift+/ 注释多行。</p>
<p>Ctrl+K+U 转换大写。</p>
<p>Ctrl+K+L 转换小写。</p>
<p>Ctrl+Z 撤销。</p>
<p>Ctrl+Y 恢复撤销。</p>
<p>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。</p>
<p>Ctrl+F2 设置书签</p>
<p>Ctrl+T 左右字母互换。</p>
<p>F6 单词检测拼写</p>
<h3>搜索类</h3>
<p>搜索类在查找文件或搜索关键词找文件灰常有用。</p>
<p>Ctrl+F 打开底部搜索框，查找关键字。</p>
<p>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。</p>
<p>Ctrl+P 打开搜索框。（1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名）</p>
<p>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。（在页面代码比较长的文件中快速定位）</p>
<p>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。（在函数较多的页面快速查找某个函数）</p>
<p>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</p>
<p>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。</p>
<p>Esc 退出光标多行选择，退出搜索框，命令框等。</p>
<h3>显示类</h3>
<p>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。</p>
<p>Ctrl+PageDown 向左切换当前窗口的标签页。</p>
<p>Ctrl+PageUp 向右切换当前窗口的标签页。</p>
<p>Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）</p>
<p>Alt+Shift+2 左右分屏-2列</p>
<p>Alt+Shift+3 左右分屏-3列</p>
<p>Alt+Shift+4 左右分屏-4列</p>
<p>Alt+Shift+5 等分4屏</p>
<p>Alt+Shift+8 垂直分屏-2屏</p>
<p>Alt+Shift+9 垂直分屏-3屏</p>
<p>Ctrl+K+B 开启/关闭侧边栏。</p>
<p>F11 全屏模式</p>
<p>Shift+F11 免打扰</p>
<p>延伸阅读：<a href=""https://segmentfault.com/a/1190000000505218"" rel=""nofollow noreferrer"">12个不可不知的Sublime Text应用技巧和诀窍</a><br>插件推荐：<a href=""http://www.imjeff.cn/blog/146/"" rel=""nofollow noreferrer"">Sublime Text 3 支持的热门插件推荐</a> O(∩_∩)O~</p>

                ", 前端资源系列（2）-SublimeText快捷键大全,1531977924,204,1,572,1,1,https://segmentfault.com/a/1190000006623991
185,1,0,7,"
                    
<p>当你进入一个团队开发时，或许这个团队使用的是基于Git的迭代开发。</p>
<p>Git的安装这里就不说了，主要讲讲几种基于Git的常用的开发模式。</p>
<p>一般我喜欢会设置Git的<code>alias</code>，这样每次输入命令的时候可以少打些字母，同时还能减少拼写的错误。例如：</p>
<pre><code>    git config --global alias.st status ==&gt;&gt;  git st
    git config --global alias.co checkout ==&gt;&gt; git co
    git config --global alias.br branch ==&gt;&gt; git br</code></pre>
<p>当团队成员给你一个git仓库地址后，并赋予你<code>developer access</code>权限后，那么你可以直接从这个项目地址将代码克隆下来.</p>
<pre><code>    git clone git://github.com/sample/sample.git</code></pre>
<p>这个时候既然你拥有了<code>access</code>权限，那么你是可以的直接向这个仓库推送代码的。当然了，你不会直接在<code>master</code>分支上进行开发，你可能会新建一个属于自己的分支<code>xl-dev</code>:</p>
<pre><code>    git co -b xl-dev</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVBI9e"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>每次对于你这个分支作出修改完后，而且此时<code>master</code>分支没有其他任何变化,此时你可以切换到<code>master</code>分支上，将你修改后的分支代码合并到<code>master</code>分支上</p>
<pre><code>    git co master
    git merge xl-dev</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVBI9X"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>注意在切换分支前，需要对于你在<code>xl-dev</code>分支下作出的修改，添加到工作区内,避免切换分支时，git阻止你的行为:</p>
<pre><code>    git add .
    git commit -m 'fix the xxxx bug'</code></pre>
<p>如果xl-dev分支你不再需要的时候，即可删除这个分支:</p>
<pre><code>    git br -D xl-dev</code></pre>
<p>如果你在<code>xl-dev</code>分支下进行开发的过程中,需要进行其他的开发工作，你可能会从master分支下再次新建一个<code>xl-fix</code>分支，并合并到了<code>master</code>分支下了。如果你修改的文件当中不存在公共文件，那么可以顺利的将你的代码合并到<code>master</code>分支上。但是，如果都修改了公共的文件，这个时候去合并的时候就会发生<code>confict</code>,例如<code>webstorm</code>就直接提供了<code>merge confict</code>的功能选项，这个时候需要你手动去合并代码，哪些是<code>aceept yours</code>,哪些是<code>aceept theirs</code>。流程图见下。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVBJiX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVBJjo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVBJk1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVBJg5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>解决了冲突后，可以使用</p>
<pre><code>    git st </code></pre>
<p>来查看文件的修改状态。</p>
<p>以上是你在本地进行一系列的分支开发工作，但是你在每次在本地开发完后需要将代码推送到远程的服务器上。</p>
<p>每次当你从远程仓库克隆代码下来后，本地会保存一份<code>origin/master</code>的指针，它是你克隆代码时，远程仓库<code>origin</code>的<code>master</code>分支的指针。你在本地是无法对<code>origin/master</code>进行修改的。当你将本地的分支合并到本地的<code>master</code>分支后，<code>origin/master</code>指针的位置是落后于你合并后的<code>master</code>指针的。这个时候当你想往仓库推送代码前，需要将<code>origin/master</code>的代码拉到本地进行合并后，才能向远程服务器推送代码</p>
<pre><code>    git fetch origin</code></pre>
<p><code>fetch</code>代码的动作是同步远程服务器上的数据到本地，从上面获取你所没有的数据，然后更新本地的代码仓库，将本地代码库的<code>origin/master</code>指针移动到新的位置。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVBJhy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>然后将<code>master</code>分支和你的开发分支<code>xl-dev</code>合并,并完成远程代码仓库的推送工作:</p>
<pre><code>    git push origin(远程仓库名) xl-dev(本地需要上传的分支名):xl-dev(推送到远程仓库后分支的命名)</code></pre>
<p>有时候，你需要接替其他同学的分支进行开发，那么可以直接从远程仓库的分支中新建一个分支后继续开发</p>
<pre><code>    git co -b xl-dev origin/xl-dev</code></pre>
<p>即从远程仓库的<code>xl-dev</code>分支下新建一个分支后继续开发。</p>
<p>有时，你没有对于项目仓库的<code>develop access</code>，那么这个时候你需要<code>fork</code>一个原始仓库到你的远程仓库地址中，然后从你自己的远程仓库中<code>clone</code>一份代码到本地。</p>
<pre><code>    git remote 
    
    origin</code></pre>
<p>输入此命令查看<code>remote</code>仓库，此时你仅仅和你的远程仓库地址有关联。当然这是不行的，因为原始仓库代码发生了任何变化你都无法感知，这个时候你还需要添加一个上游仓库，就是原始仓库:</p>
<pre><code>    git add remote remoteStore ....url....</code></pre>
<p>再次输入</p>
<pre><code>    git remote 
    
    orgin
    remoteStore</code></pre>
<p>关联原始仓库后，每当你在本地完成了<code>xl-dev</code>的开发工作后，需要提<code>PR</code>给原始仓库合并到<code>master</code>分支前，需要：</p>
<pre><code>    git fetch remoteStore</code></pre>
<p>这样获取了原始仓库中所有的数据，接下来你需要将<code>remoteStore/master</code>分支和你本地的<code>xl-dev</code>分支进行合并，并解决冲突，然后完成本项工作后，将代码推送到你的远程仓库中，并发出<code>PR</code>.</p>
<p>参考资料:</p>
<p><a href=""http://iissnan.com/progit/html/zh/ch3_5.html"" rel=""nofollow noreferrer"">git pro</a></p>

                ", Git--从入门到干活,1531977926,225,1,90,1,1,https://segmentfault.com/a/1190000006570172
186,1,0,7,"
                    
<blockquote><p>凡是能用JavaScript写出来的，最终都会用JavaScript写出来。</p></blockquote>
<p>—— Atwood定律</p>
<p>在那篇《<a href=""http://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=405412226&amp;idx=1&amp;sn=3bc7a9c6afd166591a90723a1802ed99&amp;scene=21#wechat_redirect"" rel=""nofollow noreferrer"">最流行的编程语言JavaScript能做什么？</a>》里，我们列举了JavaScript在不同领域的使用情况，今天让我们来详解一下JavaScript在物联网中的应用。</p>
<h2>基础：物联网的三个层级</h2>
<p>开始之前， 先让我们简单地介绍点物联网的基础知识。如果你有点Web开发经验的话，都知道下图是CS架构：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006774589"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Client-Server架构"" title=""Client-Server架构""></span></p>
<p>相比于一个物联网系统，无非就是多了一层硬件层以及可选的协调层。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""源自《自己动手设计物联网》"" title=""源自《自己动手设计物联网》""></span></p>
<p>这个硬件层决定了物联网应用比Web应用更加复杂。对于大部分的Web应用来说 ，客户端都是手机、电脑、平板这些设备，都有着强大的处理能力，不需要考虑一些额外的因素。</p>
<p>对于物联网应用来说，我们需要考虑设备上的MCU的处理能力，根据其处理能力和使用环境使用不同的通信协议，如我们在一些设备上需要使用CoAP协议。在一些设备上不具备网络功能，需要考虑借助于可以联网的协助层，并且还需要使用一些短距离的无线传输协议，如低功耗蓝牙、红外、Zigbee等等。</p>
<h2>一个物联网系统：六种语言</h2>
<p>两年半以前，大四，电子信息工程，我选定的毕业论文是一篇关于物联网的论文——《基于REST服务的最小物联网系统设计》。这是一篇入门级的物联网论文，如果大部分学习CS的人有一点硬件基础，都能写出这样的论文。</p>
<p>这篇论文是之前参加比赛的作品论文的“最小化”，里面使用到的主要就是创建RESTful服务，而它甚至称不上是一种技术。在这个作品里：</p>
<ul>
<li><p>我们使用Python语言里的Django框架作为Web服务框架，使用Django REST Framework来创建RESTful服务。</p></li>
<li><p>为了使用手机当控制器，我们还要用Java写一个Android应用。</p></li>
<li><p>我们使用Raspberry Pi作为硬件端的协调层，用于连接网络，并传输控制信号给硬件。</p></li>
<li><p>我们在硬件端使用Arduino作为控制器，写起代码特别简单，可以让我们关注于业务。</p></li>
<li><p>最后，我们还需要在网页上做一个图表来显示实时数据。</p></li>
</ul>
<p>所有的这些，我们需要使用Python、Java、JavaScript、C、Arduino五种语言。而如果我们要写相应的iOS应用，我们还需要Objective-C。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""你是在逗我吗？"" title=""你是在逗我吗？""></span></p>
<h2>JavaScript在物联网领域的发展</h2>
<p>同样的，两年多以前，刚实习，在我们的项目里，我们的新项目里我们使用Backbone作为单页面应用框架的核心来打造Web应用。这时，我开始关注Node.js实现物联网应用的可能性。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223289"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Node.js Express Mongodb"" title=""Node.js Express Mongodb""></span></p>
<p>当时，已经有了物联网协议MQTT和CoAP协议的库，于是我照猫画虎地写了一个支持HTTP、CoAP、WebSocket和MQTT的物联网。由于，当时缺乏一些大型应用的开发经典，所以做得并不是很好，但是已经可以看到JavaScript在这方面的远景。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Ionic Cordova"" title=""Ionic Cordova""></span></p>
<p>一年多以前，Ionic还没推出正式版的时候，我发现到了这个框架真的很棒——它自带了一系列的UI，还用NgCordova集成了Cordova的一系列插件。我便开始使用Ionic写了一些移动应用，发现还挺顺手的。接着，我就开始拿这个框架尝试写物联网应用，这需要一些原生的插件，如BLE、MQTT。后来，我也写了一个简单的CoAP插件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223305"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Iot"" title=""Iot""></span></p>
<p>后来我们不再需要编译Node.js，就可以在ARM处理器上运行Node.js。并且我们已经有Tessel、Espruino、Kinoma Create、Ruff这些可以直接运行JavaScript的开发板。三星还推出iot.js，可以让更多的嵌入式设备可以使用JavaScript语言作为开发语言。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223303"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Node.js Future"" title=""Node.js Future""></span></p>
<p>人们开始在硬件上使用JavaScript的原因有很多，如Web的开发人员是最多的、JavaScript很容易上手。</p>
<p>现在，这次我们在这三个层级上都可以使用JavaScript，只需要一种语言。</p>
<h2>使用一种语言开发物联网应用：JavaScript</h2>
<p>在我写的那本《自己动手设计物联网》中，我就试图去展示JavaScript在这方面的威力。使用Node.js + Node-CoAP + MQTT.js + MongoDB + Express搭建了一个支持多协议的物联网：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223307"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Lan IoT"" title=""Lan IoT""></span></p>
<p>不过，上图是完善版的物联网，代码自然是在GitHub上啦：<a href=""https://github.com/phodal/lan"" rel=""nofollow noreferrer"">Lan</a>。作为服务端来说，Node.js的能力已经是经过验证的。而在混合应用上，仍然也可以经受住考验，混合应用在手机上做个图表是轻轻松松的事（只需要获取数据，然后显示）：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223318"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""混合应用图表"" title=""混合应用图表""></span></p>
<p>作一个控制端也是轻轻松松的事（我们只需要发个POST请求，更具逻辑一点的就是先获取状态）：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223312"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Led控制"" title=""Led控制""></span></p>
<p>而在硬件端，我并没有在书中以JavaScript作为例子来展示JavaScript的用法，因为这会局限了用户的硬件设备。</p>
<p>不过，我们仍然可以使用类似于Johnny-Five这样的库来做硬件方面的编程，只是它没有那么好玩~~。</p>
<p>既然我们可以JavaScript来实现，为什么我们还要喝杯咖啡等它用C编译完呢？</p>
<p>你想知道的答案都在这本书里，已在亚马逊、京东、当当上架：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006223314"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""自己动手设计物联网"" title=""自己动手设计物联网""></span></p>
<p>亚马逊：<a href=""https://www.amazon.cn/dp/B01IBZWTWW"" rel=""nofollow noreferrer"">https://www.amazon.cn/dp/B01I...</a></p>
<p>京东：<a href=""http://item.jd.com/11946585.html"" rel=""nofollow noreferrer"">http://item.jd.com/11946585.html</a></p>
<p>毕竟：</p>
<blockquote><p>凡是能用JavaScript写出来的，最终都会用JavaScript写出来。</p></blockquote>

                ", JavaScript在物联网中的应用,1531977927,576,1,494,1,1,https://segmentfault.com/a/1190000006223271
187,1,0,7,"
                    
<p>之前看到 <a href=""https://github.com/getlantern/lantern"" rel=""nofollow noreferrer"">lantern</a> 这个十分火的翻墙工具，其利用了P2P的思想，就想了解一下P2P相关的协议。看了下最流行的BT协议官方文档，就产生了实现BT协议的想法，顺便根据协议实现了一个<a href=""https://github.com/shiyanhui/dht"" rel=""nofollow noreferrer"">BT种子嗅探器</a>。</p>
<p>也有人将BT种子嗅探器称为BT种子爬虫，个人觉得其行为特性和传统的web爬虫相差较大，反而和嗅探器很类似，因此暂且称之为BT种子嗅探器吧。</p>
<p>接下来将写一系列文章来介绍其原理和具体实现方式。这篇文章先提纲挈领，介绍其工作原理，以对全局有一个把握。后序的文章再介绍具体细节。</p>
<h2>背景知识</h2>
<p>在讲原理之前首先你得具备BitTorrent(简称BT)协议的一些基本知识，以便于理解接下来要讲的嗅探器。BT协议其实是一个协议簇，<a href=""http://www.bittorrent.org/beps/bep_0003.html"" rel=""nofollow noreferrer"">BEP-3</a> 是其基本协议内容，其他的大部分都是围绕这个来进行扩展或补充。要想从BT网络中下载一个资源，必须具备以下部分：</p>
<ul>
<li><p>种子文件（也就是我们常说的种子，后缀是 .torrent，本质上是一个由bencode编码的文本文件，其把资源分成很多虚拟块，并记录每个块的hash值，另外上面还记录着其他信息，比如文件大小、名字、Tracker服务器等）</p></li>
<li><p>BT客户端（需要有专门解析BT协议的程序，这样才能下载，比如迅雷，电驴）</p></li>
<li><p>Tracker服务器 （记录着peer和种子相关信息，起着中心调控的作用）</p></li>
</ul>
<p>下载资源的时候，客户端首先根据bencode（bencode是BT协议中的编码方式）解码种子文件，得到Tracker服务器的地址和资源信息，通过和Tracker服务器沟通得到其他已经下载该资源的peers信息（其他已经拥有该资源的客户端或者发布该资源的人），然后再和这些peers沟通得到自己想要的部分，即互通有无。由于把文件分成很多块来同时从不同的地方下载，这也就是为什么BT通常下载快的原因。</p>
<h2>DHT协议</h2>
<p>通过上面我们知道，Tracker服务器在资源下载的过程中起着至关重要的作用，只有通过它我们才能得到其他peers的信息，才能够下载，但这同时也成了BT协议的一个弱点，如果Tracker服务器挂掉了或者被封被屏蔽，整个网络也就瘫痪了。由于一些资源都是有版权的，还有一些资源是限制级的，比如色情资源，Tracker服务器很容易被迫关闭或被墙。后来聪明的人类发明了另外一种协议，就是 <a href=""https://en.wikipedia.org/wiki/Distributed_hash_table"" rel=""nofollow noreferrer"">Distributed hash table</a>, 简称DHT，这个协议就是用来弥补这个弱点的。</p>
<p><a href=""http://www.bittorrent.org/beps/bep_0005.html"" rel=""nofollow noreferrer"">BT协议簇中的DHT协议</a> 是基于 <a href=""http://www.ic.unicamp.br/~bit/ensino/mo809_1s13/papers/P2P/Kademlia-%20A%20Peer-to-Peer%20Information%20System%20Based%20on%20the%20XOR%20Metric%20.pdf"" rel=""nofollow noreferrer"">Kademlia协议</a> 建立的，其基本思想很好理解。DHT 由很多节点组成，每个节点保存一张表，表里边记录着自己的好友节点。当你向一个节点A查询另外一个节点B的信息的时候，A就会查询自己的好友表，如果里边包含B，那么A就返回B的信息，否则A就返回距离B距离最近的k个节点。然后你再向这k个节点再次查询B的信息，这样循环一直到查询到B的信息，查询到B的信息后你应该向之前所有查询过的节点发个通知，告诉他们，你有B的信息。</p>
<p>举个例子，比如我现在想要Angelababy的微信号（额…我要干嘛），我就从自己的微信好友中挑出k个最可能认识她的人，然后依次问他们有没有Angelababy的微信号，假如其中一个认识，那么他就会给我Angelababy的微信号，我也就不继续问其他人了。假如他不认识，他就给我推荐k个他微信好友中最有可能认识Angelababy的k个人，然后我再继续这k个人，就这样循环一直到我问到为止。OK，现在我已经得到了Angelababy的微信号，我就会告诉之前所有我问过的人，我有Angelababy的微信号。</p>
<p>当客户端下载资源的时候，他会利用上述方式查找peers信息，这样每个人都充当了Tracker的作用，也就解决了上面那个问题。</p>
<h2>嗅探器原理</h2>
<p>终于到核心部分了。</p>
<p>BT种子嗅探器就是利用了DHT协议得到peer信息后会向他之前查询过的节点发送通知这一点，这就是嗅探器的核心。</p>
<p>剩下的工作就是我们要让更多的节点发给我们通知。那么如何让更多的节点发给我们通知呢？</p>
<ul>
<li><p>我们要不断的查询自己的好友节点表，并对返回回来的节点进行查询，这样才会有更多的人认识我们</p></li>
<li><p>别人向我们查询Target的时候，我们要伪装成Target的好友，返回结果里边包括自己，这样会有更多被查询、收到通知的机会</p></li>
</ul>
<p>这就是BT种子嗅探器的原理，简单吧 :)</p>
<h2>种子下载器</h2>
<p>在BT网络中，通过上述原理收到信息并不是种子，而是发送消息者的ip和port、种子infohash（可以理解为种子的id）。我们如果想要得到种子的话，还需要做一番工作。这里涉及到另外一个非常重要的协议 <a href=""http://www.bittorrent.org/beps/bep_0009.html"" rel=""nofollow noreferrer"">BEP-09</a>，BEP-09规定了如何通过种子infohash得到种子。</p>
<p>这里不铺开讲，仅说下大致过程。首先同我们收到的消息里边的 ip:port 建立TCP连接，然后发送握手消息，并告知对方自己支持BEP-09协议，然后向对方请求种子的信息，收到对方返回的种子信息后，依次或同时请求每一个块。最有所有块收集完后，对其进行拼接并通过sha1算法计算其infohash，如果和我们请求的infohash值相同则保存起来，否则丢掉。</p>
<h2>应用</h2>
<p>这样你可以得到非常多的种子信息，你可以对其进行索引建立自己的BT种子搜索引擎，建立自己的海盗湾。但你需要注意版权问题和色情资源问题。</p>
<h2>最后</h2>
<p><a href=""https://github.com/shiyanhui/dht"" rel=""nofollow noreferrer"">https://github.com/shiyanhui/dht</a> 这个是Go实现的一个BT种子嗅探器，你可以参照一下其具体实现，喜欢这篇文章的话就到github上给个Star呗。</p>
<p><a href=""http://bthub.io"" rel=""nofollow noreferrer"">http://bthub.io</a> 是基于上面这个嗅探器写的一个BT种子搜索引擎。</p>
<p>有任何问题可以在这里提问：<a href=""https://github.com/shiyanhui/dht/issues"" rel=""nofollow noreferrer"">https://github.com/shiyanhui/...</a></p>
<p>关注我的公众号，及时获得下一篇推送。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVAroN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 一步一步教你写BT种子嗅探器之一---原理篇,1531977929,163,1,99,1,1,https://segmentfault.com/a/1190000006219988
188,1,0,7,"
                    
<h2>Git Flow是什么?</h2>
<p>Git Flow是一套基于git的工作流程，这个工作流程围绕着project的发布(release)定义了一个严格的如何建立分支的模型。</p>
<p>Git建分支是非常cheap的，我们可以任意建立分支，对任意分支再分支，分支开发完后再合并。</p>
<p>比较推荐、多见的做法是特性驱动(Feature Driven)的建立分支法(Feature Branch Workflow)。</p>
<p>简而言之就是每一个特性(feature)的开发并不直接在主干上开发，而是在分支上开发，分支开发完毕后再合并到主干上。</p>
<p>这样做的好处是</p>
<ol>
<li><p>还处于半成品状态的feature不会影响到主干</p></li>
<li><p>各个开发人员之间做自己的分支，互不干扰</p></li>
<li><p>主干永远处于可编译、可运行的状态</p></li>
</ol>
<p>GitFlow则在这个基础上更进一步，规定了如何建立、合并分支，如何发布，如何维护历史版本等工作流程。</p>
<h2>master和develop分支</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVydeA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>master分支只存放历史发布(release)版本的源代码。各个版本通过tag来标记。上图里的v0.1和v0.2就是tag。</p>
<p>develop分支则用来整合各个feature分支。开发中的版本的源代码存放在这里。</p>
<h2>feature分支</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVydhi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>每一个特性(feature)都必须在自己的分支里开发，feature分支派生自develop分支。</p>
<p>当feature开发完毕后，要合并回develop分支。feature分支永远不会和master分支打交道。</p>
<h2>release分支</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVydjW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>release分支不是一个放正式发布产品的分支，你可以将它理解为“待发布”分支。</p>
<p>我们用这个分支干所有和发布有关的事情，比如：</p>
<ol>
<li><p>把这个分支打包给测试人员测试</p></li>
<li><p>在这个分支里修复bug</p></li>
<li><p>编写发布文档</p></li>
</ol>
<p>所以在这个分支里面<strong>绝对不会添加新的特性</strong>。</p>
<p>当和发布相关的工作都完成后，release分支合并回develop和master分支。</p>
<p>单独搞一个release分支的好处是，当一个团队在做发布相关的工作时，另一个团队则可以接着开发下一版本的东西。</p>
<h2>hotfix分支</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVz9wa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>一个项目发布后或多或少肯定会有一些bug存在，而bug的修复工作并不适合在develop上做，这是因为</p>
<ol>
<li><p>develop分支上包含还未验证过的feature</p></li>
<li><p>用户未必需要develop上的feature</p></li>
<li><p>develop还不能马上发布，而客户急需这个bug的修复。</p></li>
</ol>
<p>这时就需要新建hotfix分支，hotfix分支派生自master分支，仅仅用于修复bug，当bug修复完毕后，马上回归到master分支，然后发布一个新版本，比如v0.1.1。</p>
<p>同时hotfix也要合并回develop分支，这样develop分支就能享受到bug修复的好处了。</p>
<h2>配套工具</h2>
<p>Git Flow不仅仅是一种规范，还提供了一套方便的工具。大大简化了执行Git Flow的过程。</p>
<h4>安装</h4>
<h5>OSX</h5>
<pre><code class=""bash"">$ brew install git-flow</code></pre>
<h5>Debian/Ubuntu Linux</h5>
<pre><code class=""bash"">$ apt-get install git-flow</code></pre>
<h5>Windows(cygwin)</h5>
<pre><code class=""bash"">$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</code></pre>
<h3>Initialize</h3>
<p>对一个git仓库配置一下git flow。主要是一些命名规范，比如feature分支的前缀，hotfix分支的前缀等。一般用默认值就行。</p>
<pre><code class=""bash"">git flow init</code></pre>
<h3>Feature</h3>
<h4>Start a new feature</h4>
<p>从develop开启一个新的分支</p>
<pre><code class=""bash"">git flow feature start MYFEATURE</code></pre>
<p>这个命令会从develop分出一个分支，然后切换到这个分支上面。</p>
<h4>Finish up a feature</h4>
<p>一个feature分支开发完毕后，要做以下事情：</p>
<ul>
<li><p>把 MYFEATURE 合并到 develop</p></li>
<li><p>把这个分支干掉</p></li>
<li><p>切换回develop分支</p></li>
</ul>
<pre><code class=""bash"">git flow feature finish FEATURE_NAME</code></pre>
<h4>Publish a feature</h4>
<p>如果你想让别人和你一起开发MYFEATURE分支，那就把这个分支push到服务器上</p>
<pre><code class=""bash"">git flow feature publish MYFEATURE</code></pre>
<h4>Getting a published feature</h4>
<p>获得一个别人publish到服务器上的feature分支</p>
<pre><code class=""bash"">git flow feature pull origin MYFEATURE</code></pre>
<h3>Release</h3>
<h3>Start a release</h3>
<p>创建一个release分支，派生自develop分支。</p>
<pre><code class=""bash"">git flow release start RELEASE</code></pre>
<h4>Publish a release</h4>
<pre><code class=""bash"">git flow release publish RELEASE</code></pre>
<h4>Finish up a release</h4>
<p>一个release分支结束后，需要做以下工作：</p>
<ul>
<li><p>把release分支合并回master</p></li>
<li><p>给本次发布打tag</p></li>
<li><p>同时把release分支合并回develop</p></li>
<li><p>干掉release分支</p></li>
</ul>
<pre><code class=""bash"">git flow release finish RELEASE</code></pre>
<p>最后不要忘记把tag push到服务器<code>git push --tags</code></p>
<h3>Hotfix</h3>
<h4>git flow hotfix start</h4>
<p>开启一个hotfix分支</p>
<pre><code class=""bash"">git flow hotfix start VERSION</code></pre>
<h4>Finish a hotfix</h4>
<p>结束一个hotfix分支，和release一样，同时合并回develop和master</p>
<pre><code class=""bash"">git flow hotfix finish VERSION</code></pre>
<h2>参考资料</h2>
<ul>
<li><p><a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer"">Git Flow - A successful branching model</a></p></li>
<li><p><a href=""https://www.atlassian.com/git/workflows#"" rel=""nofollow noreferrer"">Git Flow of Workflow</a></p></li>
<li><p><a href=""http://www.syntevo.com/smartgithg/documentation/5/show?page=git-flow"" rel=""nofollow noreferrer"">Another Git Flow introduction</a></p></li>
<li><p><a href=""http://danielkummer.github.io/git-flow-cheatsheet/"" rel=""nofollow noreferrer"">Git Flow Cheatsheet</a></p></li>
</ul>

                ", Git Flow简介,1531977931,413,1,957,1,1,https://segmentfault.com/a/1190000006194051
189,1,0,7,"
                    
<p>在讲git的reset和checkout的区别之前，不得不说说HEAD、Index、Working Directory三个区域。</p>
<h2>HEAD、Index、Working Directory</h2>
<p>Git里有三个区域很重要</p>
<ol>
<li>HEAD 指向最近一次commit里的所有snapshot</li>
<li>Index 缓存区域，只有Index区域里的东西才可以被commit</li>
<li>Working Directory 用户操作区域</li>
</ol>
<p>下图解释了这三个区域的状态的变化过程：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVz7pc?w=500&amp;h=411"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>初始状态</h3>
<p>当你checkout分支的时候，git做了这么三件事情</p>
<ol>
<li>将HEAD指向那个分支的最后一次commit</li>
<li>将HEAD指向的commit里所有文件的snapshot替换掉Index区域里原来的内容</li>
<li>将Index区域里的内容填充到Working Directory里</li>
</ol>
<p>所以你可以发现，HEAD、Index、Working Directory这个时候里的内容都是一模一样的。</p>
<p><strong>注意</strong>：一般会误解为，Index中的内容是空的，只有git add后才会有东西。实际上不是，Index里一直是有东西的。</p>
<p>所以，Git的所有操作就是对这三个区域的状态（或内容）的操作。</p>
<h3>Changed</h3>
<p>如果你在Working Directory里修改了文件，git会发现Working Directory里的内容和Index区域里的内容不一致了。</p>
<p>这个时候git status的结果是：</p>
<pre><code># Changes not staged for commit:</code></pre>
<h3>Staged</h3>
<p>一个文件仅仅changed是不能被commit的，Git要求只能提交Index里的东西。</p>
<p>所以需要git add。这个命令的意思是，把Changed的文件的内容同步到Index区域里。这样Working Directory和Index区域的内容就一致了。这个过程被称之为stage</p>
<p>这个时候git status的结果是：</p>
<pre><code># Changes to be committed:</code></pre>
<h3>Committed</h3>
<p>最后，你就可以提交了</p>
<p>git commit</p>
<p>这样，就把HEAD的状态和Index以及Working Directory形成一致了。</p>
<h2>reset</h2>
<p>reset是用来修改提交历史的，想象这种情况，如果你在2天前提交了一个东西，突然发现这次提交是有问题的。</p>
<p>这个时候你有两个选择，要么使用git revert（推荐），要么使用git reset。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVz7ph?w=236&amp;h=238"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>上图可以看到git reset是会<strong>修改</strong>版本历史的，他会丢弃掉一些版本历史。</p>
<p>而git revert是根据那个commit逆向生成一个新的commit，版本历史是不会被破坏的。</p>
<h3>已经push到远程仓库的commit不允许reset</h3>
<p>上面已经讲了，git reset是会丢弃掉commit的。</p>
<p>如果commit已经被push到远程仓库上了，也就意味着其他开发人员就可能基于这个commit形成了新的commit，这时你去reset，就会造成其他开发人员的提交历史莫名其妙的丢失，或者其他灾难性的后果。</p>
<p><strong>因此，一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。</strong></p>
<h3>不带文件参数的reset</h3>
<p>前面章节已经说道Git有三个区域，Git的所有操作实际上是在操作这三个区域的状态（或内容）。</p>
<p>git reset配合不同的参数，对这三个区域会产生不同的影响。</p>
<p>reset实际上有3个步骤，根据不同的参数可以决定执行到哪个步骤(<code>--soft</code>, <code>--mixed</code>, <code>--hard</code>)。</p>
<ol>
<li>改变HEAD所指向的commit(<code>--soft</code>)</li>
<li>执行第1步，将Index区域更新为HEAD所指向的commit里包含的内容(<code>--mixed</code>)</li>
<li>执行第1、2步，将Working Directory区域更新为HEAD所指向的commit里包含的内容(<code>--hard</code>)</li>
</ol>
<p><strong>注意</strong></p>
<p><code>–mixed</code>是默认参数，也就是说执行reset的时候不给就认为是<code>--mixed</code>。</p>
<p>下表说明了三种形式的git reset所产生的不同效果。</p>
<p>target代表想要将git指向到哪个commit</p>
<pre><code>working index HEAD target         working index HEAD
----------------------------------------------------
  A       B     C    D     --soft   A       B     D
                           --mixed  A       D     D
                           --hard   D       D     D
                           --merge (disallowed)

working index HEAD target         working index HEAD
----------------------------------------------------
  A       B     C    C     --soft   A       B     C
                           --mixed  A       C     C
                           --hard   C       C     C
                           --merge (disallowed)</code></pre>
<h3>带文件参数的reset</h3>
<p>上面讲到的git reset实际上不带参数的，如果带上文件参数，那么效果会是怎样的？</p>
<ol>
<li>HEAD不会动</li>
<li>将那个commit的snapshot里的那个文件放到Index区域中</li>
</ol>
<p>需要注意的是带文件参数的git reset没有--hard, --soft这两个参数。只有--mixed参数。</p>
<h3>unstage</h3>
<p>下面这两个命令是一样的，都是reset到HEAD上。</p>
<pre><code>git reset file.txt
git reset --mixed HEAD file.txt</code></pre>
<p>这个例子的意义在于，unstage file，仔细想一想是不是这样？当你把一个文件stage到Index区域里后后悔了，那么只需要把Index区域里的这个文件恢复到最近一次commit的状态（也就是HEAD），那就相当于unstage了。</p>
<h3>恢复到历史版本</h3>
<p>下面这个命令就是将某个文件恢复到历史版本上。</p>
<pre><code>reset eb43bf file.txt</code></pre>
<p>这个例子的意思在于，把某个文件恢复到Index区域里，然后直接commit，这样就等于把这个文件恢复到历史版本了，这样依赖你都不需要去改动Working Directory了。</p>
<h2>checkout</h2>
<p>前面讲到checkout是会修改HEAD的指向，变更Index区域里的内容，修改Working Directory里的内容。</p>
<p>这看上去很像<code>reset --hard</code>，但和<code>reset --hard</code>相比有两个重要的差别</p>
<ol>
<li>reset会把working directory里的所有内容都更新掉</li>
<li>checkout不会去修改你在Working Directory里修改过的文件</li>
<li>reset把branch移动到HEAD指向的地方</li>
<li>checkout则把HEAD移动到另一个分支</li>
</ol>
<p>第二个区别可能有点难以理解，举例来说：假设你有两个分支master和develop，这两个分支指向不一样的commit，我们现在在develop分支上（HEAD指向的地方）</p>
<p>如果我们<code>git reset master</code>，那么develop就会指向master所指向的那个commit。</p>
<p>如果我们<code>git checkout master</code>，那么develop不会动，只有HEAD会移动。HEAD会指向master。看图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVz7pB?w=500&amp;h=366"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>带文件参数</h3>
<p>当执行git checkout [branch] file时，checkout干了这件事情：</p>
<ol>
<li>更新了index区域里file文件的内容</li>
<li>更新了working directory里file文件的内容</li>
</ol>
<h2>总结reset和checkout</h2>
<pre><code>                         head    index   work dir  wd safe
Commit Level
reset --soft [commit]    REF     NO      NO        YES
reset [commit]           REF     YES     NO        YES
reset --hard [commit]    REF     YES     YES       NO
checkout [commit]        HEAD    YES     YES       YES

File Level
reset (commit) [file]    NO      YES     NO        YES
checkout (commit) [file] NO      YES     YES       NO</code></pre>
<p>“head”一列中的“REF”表示该命令移动了HEAD指向的分支引用，而“HEAD”则表示只移动了HEAD自身。 特别注意 “wd safe?” 一列，YES表示不会懂你在work dir的修改，NO代表会动你在work dir的修改。</p>

                ", git的reset和checkout的区别,1531977932,433,1,954,1,1,https://segmentfault.com/a/1190000006185954
190,1,0,7,"
                    
<p>今年微软Build 2016大会最让开发人员兴奋的消息之一，就是在Windows上可以原生运行Linux bash，对开发人员来说，这是一个喜闻乐见的消息。</p>
<h2>1 安装</h2>
<p>你必须安装开发者预览版本，才能使用windows的linux subsystem功能。</p>
<ol>
<li><p>首先打开你的Windows 10的设置，在""更新和安全""选项中（我的机器是英文操作系统，但中文操作系统类似），选择""开发者""，然后选择""开发者模式""：</p></li>
<li><p>在Windows 更新和安全选项中，选择""Windows 更新""，在""更新设置""中选择高级选项，你必须打开""内部预览版本""选项，并且将内部预览的级别设置为最快：</p></li>
<li><p>在""设置""-&gt;""系统""选项中，查看当前系统信息，你的OS版本必须是14316，如果不是这个版本，请运行在线升级，升级到这个版本：</p></li>
<li><p>升级完成后，打开""控制面板""-》""程序""，选择""打开或者关闭Windows特性""，找到Windows Subsystem for Linux(beta)点选并确定，系统会下载更新并提示重启机器：</p></li>
<li><p>重启完成后，进入命令行程序，激动人心的时刻来临了，在命令行下敲bash，会提示你是否继续，选择yes，系统会安装Ubuntu文件系统等待完成后，系统会切换到你熟悉的Linux bash模式，试试你熟悉的ls等命令：</p></li>
<li><p>打开Windows菜单，你会发现系统中多了一个Ubuntu的图标，这个就是bash on Ubuntu on Windows：</p></li>
<li><p>简单测试一下python，perl等语言，发现已经装好了，当然，这个就是Ubuntu的bash，你可以安装Java，Ruby等等：</p></li>
</ol>
<p>下面来实际测试下ubuntu on windows环境！</p>
<h2>2 系统检测和更新</h2>
<h3>2.1 版本检测</h3>
<p>运行 <code>uname -a</code> 结果如下</p>
<pre><code>webmaster@FEKETERIGO-PC:~$ uname -a
Linux FEKETERIGO-PC 3.4.0+ #1 PREEMPT Thu Aug 1 17:06:05 CST 2013 x86_64 x86_64 x86_64 GNU/Linux
webmaster@FEKETERIGO-PC:~$</code></pre>
<p>运行 <code>lsb_release -a</code> 结果如下</p>
<pre><code>webmaster@FEKETERIGO-PC:~$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.4 LTS
Release:        14.04
Codename:       trusty</code></pre>
<p>可以看到，安装的是ubuntu 14.04 trusty</p>
<h3>2.2 系统更新</h3>
<p>既然是ubuntu，就可以使用apt-get进行软件包管理。</p>
<p>首先替换自带的更新源</p>
<pre><code class=""bash"">sudo mv /etc/apt/sources.list /etc/apt/sources.list.save</code></pre>
<p>把下面的阿里源内容粘贴到 <code>/etc/apt/sources.list</code></p>
<pre><code>deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse

deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse

deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse

deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse

deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse

deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</code></pre>
<p>你也可以使用163源等，选取原则是更新速度，目前测试的情况是阿里云的源更新速度最快。</p>
<p>接着运行下面的命令进行系统更新，如果速度很慢的话请尝试使用其他的源，另外ubuntu的源是版本相关的，注意别添加错误版本的源。</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade</code></pre>
<p>使用<code>sudo</code>命令之前可以运行 <code>passwd</code> 更新当前用户的命令， bashonwindows默认运行在用户模式，<br>windows会把当前用户添加到<code>sudoer</code>列表中，如果想切换到超级管理员，需要手动输入<code>su - </code></p>
<h2>3 搭建开发环境</h2>
<h3>3.1 使用apt和ppa repository安装git</h3>
<p>ubuntu trusty默认的git版本是1.9.1</p>
<p>如果你不想使用git最新版本的话可以运行<code>sudo apt-get install git</code> 直接安装</p>
<p>如果想安装最新的git版本参考下面的命令</p>
<pre><code>sudo add-apt-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git</code></pre>
<p><code>sudo add-apt-repository ppa:git-core/ppa</code> 会在<code>/etc/apt/sources.list.d</code> 目录下面生成一个<br><code>git-core-ppa-trusty.list</code>文件，然后运行<code>sudo apt-get update</code> 的时候会从相应的仓库里面获取新<br>的git版本信息。</p>
<p>由于每个人的网络环境不一样， 如果你更新失败，使用apt-get不能安装最新版本的git的话，请到github上面下载源码进行编译安装，过程也很简单<br>这里就不写源码编译教程了， git源码点击 <a href=""https://github.com/git/git"" rel=""nofollow noreferrer"">这里</a></p>
<h3>3.2 使用pyenv搭建python开发环境</h3>
<p>命令如下</p>
<pre><code>sudo apt-get install curl
curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
pyenv install 2.7.11
pyenv install 3.5.1
pyenv shell 3.5.1</code></pre>
<p>python的2.x和3.x版本不兼容，所有把两个版本多安装到本地，方便需要的时候进行版本切换，使用命令<code>pyenv shell 2.7.11</code><br>指定当前的python版本。上面的命令指定的python版本是3</p>
<p>python的另一个有用的工具是virtualenv，它和pyenv都能实现python版本的切换，不过实现的方法却大相径庭。<br>pyenv在用户模式下安装多个版本python，但是每一个python版本的包依赖还是安装的同一个位置，它不能解决两个项目中引用<br>同一个库有版本冲突，但是viertualenv可以。</p>
<p>virtualenv给每一个python项目安装一个项目内部python，具体版本可以在初始化的时候指定，项目的依赖也是安装在内部python的<br>路径下面，这样能防止和系统上其他python项目的依赖冲突， 隔离性更高，不好的地方是安装和使用略微复杂。</p>
<p>具体使用哪个工具看个人喜好，github上面pyenv的关注度要高点，而且现在pyenv有一个virtualenv插件，可以使用后者同样的功能，<br>我个人还是推荐使用pyenv。</p>
<h3>3.3 使用rvm安装ruby</h3>
<pre><code>curl -L https://get.rvm.io | bash -s stable --autolibs=enabled --ruby
rvm install 2.3.1
bash --login
rvm use ruby-2.3.1</code></pre>
<p>具体命令输入<code>rvm help</code>，很好掌握。</p>
<h3>3.4 使用gvm安装go语言</h3>
<pre><code>curl -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer | bash
gvm install go1.6
gvm use go1.6 --default</code></pre>
<p>由于<a href=""http://gohugo.io"" rel=""nofollow noreferrer"">hugo</a>是使用go语言开发的，趁着这个机会向学习一些这个由google开发的编程语言，本博客就是使用<br>hugo搭建的，服务器使用<a href=""https://firebase.google.com/"" rel=""nofollow noreferrer"">firebase</a>，firebase提供和github pages一样的免费静态服<br>务器的功能，稳定性比github要好，github在国内的访问速度实在不能再慢了，特别是在clone大一点的项目的时候。</p>
<p>go语言开发的程序有一个好处就是没有运行时依赖，打包成exe就能直接运行，简单方便，更多的内容以后再更新吧，这里集中在开发环境<br>搭建这个主题上面。</p>
<h3>3.5 使用nvm安装nodejs</h3>
<pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.0/install.sh | bash
nvm install v6.2.0
nvm use v6.2.0</code></pre>
<p><code>node.js</code>可以说是从2015年以来最火的语言了，node.js是后端工程师转向前端最好的工具，博主一起就是java后端开发工程师，偶然的机会<br>学习了node.js，然后开始了自己的前端工程师的进化之路，目标是全栈工程师。</p>
<p>node.js还有一个npm包<code>n</code>可以用来进行版本管理，不过你需要先安装一个node.js才能使用<code>npm install -g n</code>安装这个工具</p>
<p><code>n</code>和<code>nvm</code>都很好用，你可以随便选择一个，也可以两个都安装，他们之间没有冲突，可以共存。</p>
<blockquote><p>这里注意一下，如果你使用的是 <code>windows build 14352</code> 的话，使用nvm安装nodejs可能会出现错误，详情参见<a href=""https://github.com/Microsoft/BashOnWindows/issues/426"" rel=""nofollow noreferrer"">这里</a><br>我安装的时候是出现问题，但是又没有看到其他人遇到这个问题，如果你安装的windows预览版是比14352更新的版本的话，你可以自己测试下</p></blockquote>
<h3>3.6 安装gcc工具链</h3>
<pre><code>sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev</code></pre>
<p>这些工具不仅仅是c和c++开发者才会用到，如果你开发一个node.js native模块，你也需要这些工具。</p>
<h3>3.7 安装nginx</h3>
<pre><code>sudo apt-get install python-software-properties
sudo add-apt-repository ppa:nginx/stable
sudo apt-get update
sudo apt-get install nginx</code></pre>
<p>和安装git的时候一样，这里通过添加nginx的第三方repository，实现apt-get方式安装nginx最新版本，比源码编译安装方式在管理上还是要方便一点。</p>
<h3>3.8 使用shell安装rust-lang</h3>
<p>安装命令,非常简单</p>
<pre><code>curl -sSf https://static.rust-lang.org/rustup.sh | sh</code></pre>
<p>rust是和node.js一样热门的新星编程语言，不过和node.js不同，rust不是一款前端领域的编程语言，而是一款系统编程语言。</p>
<p>rust的有点是安全、高并发，吸收了大量现代高级编程语言的有点，极力避免现有编程语言的各种缺点，让我印象最深刻的一个特性是<br><strong>rust的垃圾回收机制</strong>,</p>
<p>最开始的时候rust也是使用类似java语言的garbage collector方式实现垃圾回收，后来受不了gc的<br>运行时性能损耗，自己实现了一套更高效的垃圾回收机制，极大的提高的系统稳定性和性能。</p>
<p>而且在rust在1.0的时候已经实现了自举（自己编译自己）,后面版本的rust都是使用rust自己编译出来的，包括编译器。</p>
<p>唯一不好的地方是rust语言为了最大程度的帮助开发人员避免犯错误，采用了极其复杂的语法，对于刚开始学习编程语言的人来说，不建议学习<br>rust，因为rust的学习曲线非常陡峭，入门语言选择c或者java都是不错的。</p>
<h2>4 最后总结</h2>
<p>虽然这篇文章没有讲一些高深的内容（水平有限）， 但是还是总结一些。</p>
<h3>4.1 关于包管理</h3>
<p>不管是操作系统，linux、mac、windows，还是编程语言，java、node.js、rust，流行的趋势是<strong>自带包管理工具</strong>，</p>
<p>linux 有apt，centos有yum，mac有brew，windows目前没有，不排除以后不会有，win10应用商店已经有了，估计应用<br>管理工具也不好很远了吧，目前已经有一个第三方的10AppsManager了。</p>
<p>java没有自带的包管理工具，但是<code>maven</code>，node.js有npm，rust有cargo。</p>
<p>使用包管理工具能帮助开发者解决很多的问题，例如版本管理，依赖管理，甚至软件发布都可以使用包管理工具来完成，node.jsd的包<br>就是使用npm进行发布的。</p>
<p>所以我觉得<strong>自带包管理工具</strong>应该是以后编程语言的趋势，这方面做得最差的是java，从make到ant到ivy再到maven再到gradle，java的包<br>管理是最复杂的，如果是心学习java的推荐学习gradle，gradle还能用来打包android项目，是目前最优秀的工具。</p>
<p>另外操作系统的包管理工具比编程语言又更悠久的历史，几乎每一个类linux操作系统都有自己的包管理工具。</p>
<h3>4.2 版本管理</h3>
<p><strong>软件版本管理</strong></p>
<p>每一个软件都会进行版本迭代，有时候进行版本更新的时候又会有<strong>broken update</strong>，为了方便实现版本切换，现在很多编程语言<br>都提供了版本管理工具（第三方的），所以我在想能不能把这个功能添加在编程语言上面，简而言之就是编程语言能自带一个版本管理<br>工具（就像自带包管理工具一样），这样能更快的实现版本切换。</p>
<h3>4.3 以开发人员为中心</h3>
<p>随着windows开始各种拉拢<a href=""https://lanmaowz.com/learn-bash-on-windows/"" rel=""nofollow noreferrer"">开发人员</a>和软件工程师队伍的壮大，我认为<strong>以开发人员为中心的时代，广大开发人员的春天就要到来了</strong>，</p>

                ", 深入体验bash on windows，在windows上搭建原生的linux开发环境，酷！,1531977934,204,1,600,1,1,https://segmentfault.com/a/1190000006175018
191,1,0,7,"
                    
<h4><strong>前言</strong></h4>
<p>“小王，明天公司在<em>*</em>举办一个xxx产品发布会，你今天准备2000份问卷调查。还有，我们这次还做一个抽奖活动，也记得弄一个抽奖箱和一些抽奖球哦。”</p>
<p>……</p>
<p>活动结束了，小王想起早上捧着这2000张问卷和抽奖箱的情景，生平第一次对弘二头肌起了念想。回过神来看着桌子上回收回来的问卷，整整齐齐的像座小山一样好看，但领导依然不太满意，因为只回收了1000来张。可是1000多张的样本已经足够了呀，统计也很花时间的呀。小王本想反驳，但他什么也没说，只是下意识地摸了摸自己的背包，包里装着那丢失的900多张问卷。</p>
<p>以上剧情根据真实故事改编，如有雷同，算你倒霉。</p>
<h4><strong>数字化大背景</strong></h4>
<p>现在还有不少活动是用纸质问卷来做调查的，几千张纸是小钱，但后期统计这一堆数据可是费神费力的苦力活。以前设备落后，手机上做问卷体验太差。但现在是80岁大爷都会玩智能手机的年代，一个二维码也解决了入口问题，在线调查问卷的体验也就上来了。再加上现在办个活动什么的都是用微信宣传微信组织，配合一点抽奖活动，观众们还是愿意去回答的。既然已经具备了在线问卷的大环境，下面就让小茄带大家来做一个在线问卷调查吧。</p>
<h4><strong>需求</strong></h4>
<p>先来分析一下需求。</p>
<p>1、在线问卷调查的使用者都是市场运营的工作人员，他们对编程的了解很少，所以后台操作必须简单明了。</p>
<p>2、输入为问题信息，输出为回答统计信息，输出需要使用可视化图表呈现，必要时也提供元数据。</p>
<p>3、最好能带一点圈粉属性，扫一扫关注公众号然后才开始答题。硬生生让人关注公众号，许多人可能无动于衷，但增加了一个问卷和抽奖的梗，关注公众号就显得非常合理自然。</p>
<p>4、最好能带一点统计功能，统计一下到底多少人打开了页面，从而为后续改进提供数据分析支撑。</p>
<p>其中1、2是刚需，3、4是软需。</p>
<h4><strong>后端</strong></h4>
<p>简单分析可以发现，开发这个小应用最主要的工作是在后端开发部分，而且这个主要是以数据处理为主，显然采用面向数据库编程的方式来开发更为合适。</p>
<p>面向数据库开发第一步，先来定义数据库吧。先使用excel做出相应的表格，大概是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzJ8k"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>然后就是分表写数据库，将question、options、answer分成3个表，以questionID做索引关联3个表，另外用户信息和奖品信息也要用一个数据表来保存。本来这里想用MySQL for Excel来实现，这样市场的妹子们也能简单上手。不过想想还是导出一个sql脚本更好，毕竟这样就可以手把手教妹子怎么把问卷数据写到sql文件里面了。(/▽╲)</p>
<p>问卷数据的读写都可以用WeX5通用的查询接口来实现数据的读写，这里不再赘述。</p>
<p>这里要自己写的是抽奖算法的实现，要点是保证中奖几率的均一性。但是，算法也不能太死板，主要看脸，哦不，主要看奖品大小。</p>
<p>如果有大奖，那么大奖单独出来所有人抽一次会比较好，这样能有效活跃起现场气氛。这种情况下可以设置一个抽奖期间，后台统计这个期间内的人数，然后在这个人数里面随机选中一个即可。如果都是些小奖品，那么肯定就是先答题后抽奖，抽奖结果要马上呈现。也就是每个观众抽奖的时刻是不同的，而且抽奖的人数也是未知的，这种情况下要保证前后抽奖的人都有相同的中奖几率，而且要把奖品发完的话，好像很难的样子。但是，既然是小奖品，按照先来先得发不完也没事的原则，每次都查询当前奖品池的奖品，如果还有奖品则用随机数判断是否中奖，否则就不中奖就完事了，简单粗暴。</p>
<p>所以说，一切以实际出发，把重心放到重要的事上，把吃奶的力用到吃奶上，才是王道。</p>
<p>贴个抽奖算法的简单实现：</p>
<pre><code> 1 public static JSONObject drawPrize(JSONObject params, ActionContext context) throws SQLException, NamingException {
  2   // 获取参数
  3   String batch = params.getString(""batch"");
  4   int index = params.getInteger(""index"");
  5   String weixinID = params.getString(""weixinID"");
  6   JSONObject result = new JSONObject();
  7   Connection conn = context.getConnection(DATASOURCE);
  8 
  9   try {
 10     conn.setAutoCommit(false);
 11     try {
 12       // 获取user
 13       Statement stat = conn.createStatement();
 14       try {
 15         ResultSet rsUser = stat.executeQuery(""SELECT * FROM user WHERE fBatch = '"" + batch + ""' AND fWeixinID = '"" + weixinID + ""'"");
 16         if (!rsUser.next()) {
 17           // 未登记
 18           result.put(""code"", -2);
 19         } else if (!Utils.isEmptyString(rsUser.getString(""fPrize"" + index))) {
 20           // 已中奖
 21           result.put(""code"", -1);
 22           result.put(""prize"", rsUser.getString(""fPrize"" + index));
 23         } else {
 24           // 读取奖池
 25           List&lt;String&gt; prizes = new ArrayList&lt;String&gt;();
 26           ResultSet rsPrize = stat.executeQuery(""SELECT * FROM prize WHERE (fTotal - COALESCE(fCount, 0)) &gt; 0 AND fBatch = '"" + batch + ""' AND fIndex = "" + index);
 27           while (rsPrize.next()) {
 28             prizes.add(rsPrize.getString(""fName""));
 29           }
 30           if (prizes.size() == 0) {
 31             // 奖池空了
 32             result.put(""code"", -3);
 33           } else {
 34             Random r = new Random();
 35             // 看运气
 36             int luck = r.nextInt(10);
 37             if (luck &gt; 0) {
 38               // 未中奖
 39               result.put(""code"", 0);
 40             } else {
 41               // 抽奖
 42               luck = r.nextInt(prizes.size());
 43               String prize = prizes.get(luck);
 44 
 45               int k = stat.executeUpdate(""UPDATE prize SET fCOUNT = COALESCE(fCount, 0) + 1 WHERE (fTotal - COALESCE(fCount, 0)) &gt; 0 AND fBatch = '"" + batch + ""' AND fIndex = ""
 46                   + index + "" AND fName = '"" + prize + ""'"");
 47               if (k == 0) {
 48                 // 未中奖
 49                 result.put(""code"", 0);
 50               } else {
 51                 // 记录数据
 52                 stat.executeUpdate(""UPDATE user SET fPrize"" + index + "" = '"" + prize + ""' WHERE fBatch = '"" + batch + ""' AND fWeixinID = '"" + weixinID + ""'"");
 53                 result.put(""code"", 1);
 54                 result.put(""prize"", prize);
 55               }
 56             }
 57           }
 58         }
 59       } finally {
 60         stat.close();
 61       }
 62       conn.commit();
 63     } catch (SQLException e) {
 64       conn.rollback();
 65       throw e;
 66     }
 67   } finally {
 68     conn.close();
 69   }
 70 
 71   return result;
 72 }
</code></pre>
<h4><strong>前端</strong></h4>
<p>问卷部分：前端当然是一个单页应用了。因为问题形式差不多，所以可以做一个问题模板，将从后端获取到的依次问题数据渲染到页面。这里可以用WeX5的数据组件和模板绑定来实现。另外要考虑到的一个问题是问卷的原子性，就是说要么不回答，要么就要回答所有题目。所以问卷的提交是一次性的，不能做成每道题都提交的形式。因为数据量不大，所以可以一次请求把所有question、option都取回来，减少请求数。</p>
<p>抽奖部分：这里使用了摇一摇的形式来进行抽奖。原理很简单，就是判断加速度计在一个时间区间内的变化率大小，当变化率超过一定阈值时就说明当前手机受力突增，也就是正在“摇一摇”的状态。具体实现是监听’devicemotion’事件，代码如下：</p>
<pre><code> 1 // 摇一摇事件
  2 if (window.DeviceMotionEvent) {
  3     window.addEventListener('devicemotion', deviceMotionHandler, false);
  4 } else {
  5     alert('本设备不支持摇一摇');
  6 }
  7 function deviceMotionHandler(eventData) {
  8     var acceleration = eventData.accelerationIncludingGravity;
  9     var curTime = new Date().getTime();
 10     if ((curTime - last_update) &gt; 100) {
 11         var diffTime = curTime - last_update;
 12         last_update = curTime;
 13         x = acceleration.x;
 14         y = acceleration.y;
 15         z = acceleration.z;
 16         var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000;
 17 
 18         if (speed &gt; SHAKE_THRESHOLD) {
 19             self.imgRockClick();
 20         }
 21         last_x = x;
 22         last_y = y;
 23         last_z = z;
 24     }
 25 }
</code></pre>
<p>输出部分：问卷数据采集完之后，可以使用echart来展现统计数据。具体教程可以看看官方文档：<a href=""http://docs.wex5.com/integrate-echarts/"" rel=""nofollow noreferrer"">http://docs.wex5.com/integrat...</a> ，但是不赞同使用单文件的形式，建议采用模块按需载入的方式。这里用到的无外乎是柱状或者饼状图，所以只加载基类和这两类js文件即可。</p>
<p>如果妹子要元数据怎么办？一行代码搞定：select * from answer into outfile  ‘d:/answer.xls’;  建议一定要拉着妹子的手，手把手地把这个好用的技能教给她。</p>
<h4><strong>更进一步</strong></h4>
<p>通过上面几步，一个简单好用的在线问卷就已经实现了。细心的你估计发现了，3、4点需求还没实现呢。好吧，下面看看这两点怎么实现，没兴趣的同学可以直接到文章末尾点赞了，谢谢配合。</p>
<p>首先是增加圈粉属性。</p>
<p>这个前提就是你要把应用部署在你的公众号服务器上。还没有服务器？Cloud X5 搞起吧，简明教程：<a href=""http://docs.wex5.com/about-cloudx5/"" rel=""nofollow noreferrer"">http://docs.wex5.com/about-cl...</a></p>
<p>圈粉主要是要把你的应用入口改成微信网页授权页面，也就是这个地址：<a href=""https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect"" rel=""nofollow noreferrer"">https://open.weixin.qq.com/co...</a>，记得里面的大写字母参数要改成你自己的参数。回调 uri 记得要做URI转码。一般来说我们还要获取用户信息的，所以这里的SCOPE填入snsapi_userinfo。其他参数请参考微信开发者文档自行补充，这里就不赘述了：<a href=""https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842&amp;token=&amp;lang=zh_CN"" rel=""nofollow noreferrer"">https://mp.weixin.qq.com/wiki...</a>。如果对这一部分不太熟悉的话，可以看看小茄上一篇【30分钟做一个二维码名片应用】<a href=""http://www.wex5.com/openway_qrcode/"" rel=""nofollow noreferrer"">http://www.wex5.com/openway_q...</a>，里面有详细介绍如何使用WeX5进行微信公众号开发。</p>
<p>再来看看统计功能：在2016年7月4号之前，你都只能在网页中引用站长工具啦、百度统计啦、谷歌统计来进行数据统计。而现在你也可以使用微信自家的统计功能了，这个是专门统计微信客户端的访问量的。传送门：<a href=""https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;key=1467639271&amp;version=1&amp;lang=zh_CN"" rel=""nofollow noreferrer"">https://mp.weixin.qq.com/cgi-...</a>，直接在后台就能看。由于它统计的是使用了JSSDK的页面，所以这个页面也需要配置jssdk_config。既然上面都说要圈粉了，那就增加一个分享接口就好了，后面判断这个分享接口被调用的次数就能间接得到某个时间段的访问量了。对了，每个接口还按照页面区分好了，所以你不用担心其他页面数据的干扰。<br><span class=""img-wrap""><img data-src=""/img/bVzJ8u"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>然后，然后小王终于可以忘了曾一度被问卷调查所支配的恐怖和被囚禁于数据统计中的那份屈辱了。</p>
<p>全文完，点赞不谢！</p>

                ", 来，做一个问卷调查（有抽奖！）,1531977936,107,1,402,1,1,https://segmentfault.com/a/1190000006096491
192,1,0,7,"
                    
<p>欢迎提issues斧正喜欢star：<a href=""https://github.com/xiaohuazheng/twbm/issues/6"" rel=""nofollow noreferrer"">Git常用命令&amp;设置快捷命令</a></p>
<h2>Git-常用命令&amp;快捷命令&amp;小工作流</h2>
<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。在团队合作时作用不言而喻，更是为了解决团队合作代码冲突而生。</p>
<h3>Git常用命令</h3>
<pre><code>初始化新版本库：git init
全局设置：git config --global user.name ""xzavier""  git config --global user.email ""xzavier.xxx.com""
克隆版本库：git clone ""url""
查看分支：git branch
创建分支：git branch branch_name
切换分支：git checkout branch_name
创建+切换分支：git checkout -b branch_name
合并某分支到当前分支：git merge branch_name
重命名分支：git branch -m branch_name branch_new_name //不会覆盖已经存在的分支
重命名分支：git branch -M branch_name branch_new_name //会覆盖已经存在的分支
删除分支：git branch -d branch_name 
强制删除分支： git branch -D branch_name
删除远程分支： git push origin : branch_name 
拉取代码：git pull origin branch_name
查看更改：git status 
查看更改细节： git diff file_name
查看谁修改过代码： git blame filename
回到上次修改： git reset --hard
添加单个文件：git add filename.js 
添加所有js文件：git add *.js
添加所有文件：git add .
提交添加的文件：git commit -m ""your description about this branch""
提交单个文件：git commit -m ""your description about it"" filename.js
push分支：git push origin your_branch_name
备份当前分支内容：git stash //在后面再讲讲这个
查看历史记录：git log
创建标签：git tag 1.0.0  //标签无法重命名
显示标签列表：git tag 
切出标签：git checkout 1.0.0
删除标签：git tag -d 1.0.0
查看git远程网址：git remote -v
更改git远程网址：git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git  ; git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git
</code></pre>
<p>git远程网址参考：<a href=""https://help.github.com/articles/changing-a-remote-s-url/"" rel=""nofollow noreferrer"">Changing a remote's URL</a></p>
<h3>设置Git快捷命令</h3>
<p>如果你用的是 git bash 或者 XSHell 的话，在记住了命令含义的情况下，工作时键入快捷命令会提高工作效率。<br>在git bash中进入c://User/user，执行touch .bashrc，然后在此目录下会生成一个.bashrc文件，将下面的快捷命令拷入保存即可，快捷命令可自行修改添加，主要是自己习惯和喜欢。<br>在XSHell里快捷命令是在~/.bashrc中配置，在XSHell中 vim ~/.bashrc,把以上命令加到合适的位置保存（:wq）即可。</p>
<pre><code>alias gs='git status'
alias gd='git diff'
alias ga='git add'
alias gc='git commit'
alias gck='git checkout'
alias gb='git branch'
alias gl='git log'
alias gthis='git rev-parse --abbrev-ref HEAD'
alias gpushthis='git push origin `gthis`'
alias gpullthis='git pull origin `gthis`'
alias gup='git remote update'
alias gpl='git pull origin'
</code></pre>
<h3>git小工作流</h3>
<p>早上来上班,处理好邮件，开完早会，打开虚拟机，切到master分支，拉一下代码：</p>
<pre><code>git pull origin develop/master </code></pre>
<p>开始写代码。当然，作为团队一员，肯定不能在master分支上随便写代码。</p>
<p>新建分支：</p>
<pre><code>git checkout -b branch_name(分支名按照一定规范会很好) </code></pre>
<p>然后工作安安静静的写代码，这时候如果有别的分支上需要处理点紧急bug什么的，又不能现在提交代码。</p>
<p>那就先保存起来吧:</p>
<pre><code>git stash  （见后面git status）</code></pre>
<p>切到别的分支修改代码 ：</p>
<pre><code>git checkout -b branch_name</code></pre>
<p>修复bug后提交代码查看修改：</p>
<pre><code>git status</code></pre>
<p>需要查看修改的细节：</p>
<pre><code>git diff file_name</code></pre>
<p>没有问题了，那就提交吧(三部曲)：</p>
<pre><code>git add file_name (一般来说你可以 git add . 点符号代表所有修改文件) 
git commit -m ""your description about this branch"" 
git push origin your_branch_name</code></pre>
<p>bug算是解决了，那就回到正常的工作吧，切回原来的分支：</p>
<pre><code>git chekcout -b your_old_branch</code></pre>
<p>恢复刚刚保存的内容： git stash pop (至于这个pop,详细需要自己去找官网或者博客学习，简单介绍</p>
<pre><code>git stash: 备份当前的工作区的内容，保存到Git栈中。
git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。
git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
git stash clear: 清空Git栈。此时使用git等图形化工具会发现，原来stash的哪些节点都消失了。   </code></pre>
<p>代码恢复了，就开始工作了。代码写完了，又是提交三部曲(快捷命令)。</p>
<pre><code>ga .
gc -m ""your description about this branch"" 
gpullthis    </code></pre>
<p>最后合并到master，多个队员一个开发，一般合并master时要遇到冲突，这时相应开发人员就要出来解决冲突，冲突一般是多个开发员修改了同一处代码造成的。拉取master代码(队友也没合master就商量好拉他的代码，最后解决完冲突只把你这个分支提交就行了)：</p>
<pre><code>git pull origin master </code></pre>
<p>或者</p>
<pre><code>git pull origin his/her_branch_name </code></pre>
<p>出现：</p>
<pre><code>Auto-merging xzavier.js CONFLICT (content): Merge conflict in xzavier.js</code></pre>
<p>看到conflict（冲突）,找到相应文件，出现这样的地方：</p>
<pre><code>    1&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 
     your code
     ===============
     others code
    1&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>
<p>解决完冲突后提交即可，提交三部曲。</p>
<pre><code>    ga .
    gc -m ""your description about this branch"" 
    gpullthis
</code></pre>
<p>阮老师的Git教程：<a href=""http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html"" rel=""nofollow noreferrer"">常用 Git 命令清单</a></p>

                ", 前端资源系列（1）-Git常用命令&amp;设置快捷命令&amp;小工作流,1531977937,147,1,532,1,1,https://segmentfault.com/a/1190000005945614
193,1,0,7,"
                    
<blockquote><p><a href=""https://medium.freecodecamp.com/git-rebase-and-the-golden-rule-explained-70715eccc372#.h4rzk9cui"" rel=""nofollow noreferrer"">原文地址</a><br><a href=""https://github.com/wxyyxc1992/just-coder-handbook/blob/master/VersionControl/Git/Branch/Rebase/git-rebase-and-the-gloden-rule-explained.md"" rel=""nofollow noreferrer"">Git系列文章地址</a></p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006767500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>本文主要讲解下Git Rebase的基本概念用法、其内部原理以及我们在真实项目中使用Git Rebase应该遵循的原则以及为啥需要遵循这些原则。</p>
<h1>Base of Rebase</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937411"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>相信对于rebase肯定不会陌生，就好像上图描述的过程一样，当你使用rebase命令的时候，即好像将你需要去rebase的分支拔下来然后重新插到另一个分支上。官方对于rebase的描述为：</p>
<pre><code>
“git-rebase: Forward-port local commits to the updated upstream head”— git doc
</code></pre>
<p>翻译一下，就是讲你在某个分支上的所有提交记录移花接木到另一个分支上。这边需要强调一个概念：reapply，使用rebase并不是简单地好像你用ctrl-x/ctrl-v进行剪切复制一样，rebase会依次地将你所要操作的分支的所有提交应用到目标分支上。也就是说，实际上在执行rebase的时候，有两个隐含的注意点：</p>
<ul>
<li><p>在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。</p></li>
<li><p>Git rebase并不会删除老的提交，也就是说你在对某个分支执行了rebase操作之后，老的提交仍然会存放在.git文件夹的objects目录下。如果你对于Git是如何存放你的提交不太了解的话可以参考这篇文章：<a href=""https://medium.freecodecamp.com/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807#.6ylqa5e2w"" rel=""nofollow noreferrer"">Understanding git for real by exploring the .git directory</a></p></li>
</ul>
<p>基于以上表述，我们可以得出以下相对更准确的Git rebase的工作流程：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从上图可以看出，在对特征分支进行rebase之后，其等效于创建了新的提交。并且老的提交也没有被销毁，只是简单地不能再被访问或者使用。在对于分支的章节我们曾经提及，一个分支只是一个执行提交的指针。因此如果既没有分支或者Tag指向某个提交，该提交将无法再被访问使用，但是该提交会一直存在于你的文件系统中，占用着你的磁盘存储。</p>
<h1>Golden Rule of Rebase</h1>
<blockquote><p>“No one shall rebase a shared branch” — Everyone about rebase</p></blockquote>
<p>估计你也肯定看过这个原则，不过可能表述不一样罢了。本章节就是用实例的角度来探讨下，为啥不能再一个共享的分支上进行Git rebase操作。所谓共享的分支，即是指那些存在于远端并且允许团队中的其他人进行Pull操作的分支。假设现在Bob和Anna在同一个项目组中工作，项目所属的仓库和分支大概是下图这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937420"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在Bob为了图一时方便打破了原则，正巧这时Anna在特征分支上进行了新的提交，此时的结构图大概是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937424"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当Bob打算推送自己的分支到远端的时候，它收到了如下的警告：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937422"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Git尝试着使用fast-forward来合并你的分支，具体的细节我们会在其他博客中进行讨论，这边只需要明白远端的Git Server被Bob搞得一头雾水，不知道应该如何去合并。此时Bob为了推送他的本地的提交，只能选择强行合并，即告诉远端：不要再尝试着合并我推送给你的和你已经有点提交，一切按照我推送过去的来。那么Git会进行如下操作：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937426"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后呢，当Anna也进行推送的时候，她会得到如下的提醒：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937428"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个消息很正常，没啥特殊的，只是Git提醒Anna她本地的版本与远程分支并不一致，在Anna提交之前，分支中的Commit序列是如下这样的：</p>
<pre><code>
A--B--C--D'   origin/feature // GitHub

A--B--D--E    feature        // Anna
</code></pre>
<p>在进行Pull操作之后，Git会进行自动地合并操作，结果大概是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937430"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个第M个提交即代表着合并的提交，也就是Anna本地的分支与Github上的特征分支最终合并的点，现在Anna解决了所有的合并冲突并且可以Push她的代码，在Bob进行Pull之后，每个人的Git Commit结构为：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937432"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>到这里，看到上面这个混乱的流线图，相信你对于Rebase和所谓的黄金准则也有了更形象深入的理解。这还只是仅有两个人，一个特征分支的项目因为误用rebase产生的后果。如果你团队中的每个人都对公共分支进行rebase操作，那还不得一团乱麻。另外，相信你也注意到，在远端的仓库中存有大量的重复的Commit信息，这会大大浪费我们的存储空间。如果你还觉得这么什么，那我们来假设下还有一哥们Emma，第三个开发人员，在他进行了本地Commit并且Push到远端之后，仓库变为了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005937489"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006058452"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", Git Rebase原理以及黄金准则详解,1531977939,163,1,243,1,1,https://segmentfault.com/a/1190000005937408
194,1,0,7,"
                    
<h2>背景</h2>
<p>ios 的 notification 在多线程的情况下，线程的管理非常不好控制。这个怎么理解呢？</p>
<p>按照官方文档的说法就是，不管你在哪个线程注册了 observer，notification 在哪个线程 post，那么它就将在哪个线程接收，这个意思用代码表示，效果如下：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@""current thread = %@"", [NSThread currentThread]);
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:POST_NOTIFICATION object:nil];
    
}

- (void)viewDidAppear:(BOOL)animated {
    [self postNotificationInBackground];
}

- (void)postNotificationInBackground {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        [[NSNotificationCenter defaultCenter] postNotificationName:POST_NOTIFICATION object:nil userInfo:nil];
    });
}

- (void)handleNotification:(NSNotification *)notification {
     NSLog(@""current thread = %@"", [NSThread currentThread]);
}</code></pre>
<p>输出如下：</p>
<pre><code>2016-07-02 11:20:56.683 Test[31784:3602420] current thread = &lt;NSThread: 0x7f8548405250&gt;{number = 1, name = main}
2016-07-02 11:20:56.684 Test[31784:3602420] viewWillAppear: ViewController
2016-07-02 11:20:56.689 Test[31784:3602469] current thread = &lt;NSThread: 0x7f854845b790&gt;{number = 2, name = (null)}</code></pre>
<p>也就是说，尽管我在主线程注册了 observer，但是由于我在子线程 post 了消息，那么 handleNotification 响应函数也会在子线程处理。这样一来就会给我们带来困扰，因为 notification 的响应函数执行线程将变得不确定，而且很多操作如 UI 操作，我们是需要在主线程进行的。</p>
<h2>解决方案</h2>
<p>怎么解决这个问题呢？</p>
<h3>在响应函数处强制切线程</h3>
<h5>实现</h5>
<p>一个很土的方法就在在 handleNotification 里面，强制切换线程，如:</p>
<pre><code>- (void)handleNotification:(NSNotification *)notification {
   dispatch_async(dispatch_get_main_queue(), ^{
      NSLog(@""current thread = %@"", [NSThread currentThread]);
   });
}</code></pre>
<h5>缺陷</h5>
<p>每一个响应函数都强制切换线程。这样带来的问题就是每一处理代码你都得这样做，对于开发者而言负担太大，显然是下下策。</p>
<h3>线程重定向</h3>
<p>其实解决思路和上面的差不多，不过实现的方式更优雅一点，这个方案在 <a href=""https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG"" rel=""nofollow noreferrer"">apple 的官方文档</a>中有详细介绍，它的思路翻译过来就是:重定向通知的一种的实现思路是使用一个通知队列(注意，不是 NSNotificationQueue 对象，而是一个数组)去记录所有的被抛向非预期线程里面的通知，然后将它们重定向到预期线程。这种方案使我们仍然是像平常一样去注册一个通知的观察者，当接收到 Notification 的时候，先判断 post 出来的这个 Notification 的线程是不是我们所期望的线程，如果不是，则将这个 Notification 存储到我们自定义的队列中，并发送一个信号( signal )到期望的线程中，来告诉这个线程需要处理一个 Notification 。指定的线程在收到信号后，将 Notification 从队列中移除，并进行处理。</p>
<h5>实现</h5>
<pre><code>/* Threaded notification support. */
@property (nonatomic) NSMutableArray    *notifications;         // 通知队列
@property (nonatomic) NSThread          *notificationThread;    // 预想的处理通知的线程
@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突
@property (nonatomic) NSMachPort        *notificationPort;      // 用于向预想的处理线程发送信号的通信端口

@end

@implementation ViewController

 - (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@""current thread = %@"", [NSThread currentThread]);
    
    [self setUpThreadingSupport];
    
    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString *)kCFRunLoopCommonModes];
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:POST_NOTIFICATION object:nil];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        [[NSNotificationCenter defaultCenter] postNotificationName:POST_NOTIFICATION object:nil userInfo:nil];
        
    });
}

 - (void) setUpThreadingSupport {
    if (self.notifications) {
        return;
    }
    self.notifications      = [[NSMutableArray alloc] init];
    self.notificationLock   = [[NSLock alloc] init];
    self.notificationThread = [NSThread currentThread];
    
    self.notificationPort = [[NSMachPort alloc] init];
    [self.notificationPort setDelegate:self];
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString*)kCFRunLoopCommonModes];
}

 - (void)handleMachMessage:(void *)msg {
    
    [self.notificationLock lock];
    
    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    };
    
    [self.notificationLock unlock];
}

 - (void)processNotification:(NSNotification *)notification {
    
    if ([NSThread currentThread] != _notificationThread) {
        // Forward the notification to the correct thread.
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date]
                                   components:nil
                                         from:nil
                                     reserved:0];
    }
    else {
        // Process the notification here;
        NSLog(@""current thread = %@"", [NSThread currentThread]);
        NSLog(@""process notification"");
    }
}
}</code></pre>
<p>但是这种方案有明显额缺陷，官方文档也对其进行了说明，归结起来有两点：</p>
<ul>
<li><p>所有的通知的处理都要经过 processNotification 函数进行处理。</p></li>
<li><p>所有的接听对象都要提供相应的 NSMachPort 对象，进行消息转发。</p></li>
</ul>
<p>正是由于存在这样的缺陷，因此官方文档并不建议直接这样使用，而是鼓励开发者去继承NSNoticationCenter 或者自己去提供一个单独的类进行线程的维护。</p>
<h3>block 方式的 NSNotification</h3>
<p>为了顺应语法的变化，apple 从 ios4 之后提供了带有 block 的 NSNotification。使用方式如下：</p>
<pre><code> - (id&lt;NSObject&gt;)addObserverForName:(NSString *)name
                            object:(id)obj
                             queue:(NSOperationQueue *)queue
                        usingBlock:(void (^)(NSNotification *note))block</code></pre>
<p>这里说明几点</p>
<ul>
<li><p>观察者就是当前对象</p></li>
<li><p>queue 定义了 block 执行的线程，nil 则表示 block 的执行线程和发通知在同一个线程</p></li>
<li><p>block 就是相应通知的处理函数</p></li>
</ul>
<p>这个 API 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 remove 操作。</p>
<p>首先回忆一下我们原来的 NSNotification 的 remove 方式，见如下代码：</p>
<pre><code>- (void)removeObservers {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:POST_NOTIFICATION object:nil];
}</code></pre>
<p>需要指定 observer 以及 name。但是带 block 方式的 remove 便不能像上面这样处理了。其方式如下：</p>
<pre><code>- (void)removeObservers {
    if（_observer）{
        [[NSNotificationCenter defaultCenter] removeObserver:_observer];
    }
}</code></pre>
<p>其中 _observer 是 addObserverForName 方式的 api 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 remove 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 observer 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p>
<h2>LRNotificationObserver</h2>
<p>git 上有一个想要解决上述问题的开源代码，其使用方式如下：</p>
<pre><code>+ (void)observeName:(NSString *)name
              owner:(id)owner
      dispatchQueue:(dispatch_queue_t)dispatchQueue
              block:(LRNotificationObserverBlock)block;</code></pre>
<p>它能够方便的控制线程切换，而且它还能做到 owner dealloc 的时候，自动 remove observer。比如我们很多时候在 viewDidLoad 的时候addObserver，然后还需要重载 dealloc，在里面调用 removeObserver，这个开源方案，帮我们省去了再去dealloc 显示 remove 的额外工作。但是如果你想显式的调用 remove，就比较麻烦了（比如有时候，我们在viewWillAppear 添加了 observer，需要在 viewWillDisAppear 移除 observer），它类似官方的解决方案，需要你用成员变量，将 observer 一个个保存下来，然后在 remove 的地方移除。</p>
<h2>GYNotificationCenter</h2>
<p>为了解决上面的问题，因此决定重新写一个 Notification 的管理类，<a href=""https://github.com/zachwangb/GYNotificationCenter"" rel=""nofollow noreferrer"">GYNotificationCenter</a> 想要达到的效果有两个</p>
<ol>
<li><p>能够方便的控制线程切换</p></li>
<li><p>能够方便的remove observer</p></li>
</ol>
<h3>使用</h3>
<pre><code>- (void)addObserver:(nonnull id)observer
              name:(nonnull NSString *)aName
     dispatchQueue:(nullable dispatch_queue_t)disPatchQueue
             block:(nonnull GYNotificatioObserverBlock)block;</code></pre>
<p>我们提供了和官方 api 几乎一样的调用方法，支持传入 dispatchQueue 实现线程切换控制，同时能够以 block 的方式处理消息响应，而且支持在 observer dealloc 的时候，自动调用 observer 的 remove 操作。同时还提供了和原生一样的显式调用 remove 的操作，方便收到调用 remove .</p>
<pre><code>- (void)removerObserver:(nonnull id)observer
                   name:(nonnull NSString *)anName
                 object:(nullable id)anObject;

- (void)removerObserver:(nonnull id)observer;</code></pre>
<p>能够方便的手动调用 remove 操作。</p>
<h3>实现思路</h3>
<p>GYNotificaionCenter 借鉴了官方的线程重定向 以及 LRNotificationObserver 的一些方案。在 addObserver 的时候，生成了一个和 observer 关联的 GYNotificationOberverIdentifer 对象，这个对象记录了传入的 block 、name 的数据，然后对这个对象依据传入的 name 注册观察者。</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:anName object:object];</code></pre>
<p>当收到通知的时候，在 handleNotification 里面执行传入的 block，回调的外面去。</p>
<pre><code>- (void)handleNotification:(NSNotification *)notification {
    
    if (self.dispatchQueue) {
        dispatch_async(self.dispatchQueue, ^{
            if (self.block) {
                self.block(notification);
            }
        });
    } else {
        self.block(notification);
    }   
}</code></pre>
<p>GYNotificationOberverIdentifer 对象放入 GYNotificationOberverIdentifersContainer 对象中进行统一管理。</p>
<pre><code>- (void)addNotificationOberverIdentifer:(GYNotificationOberverIdentifer *)identifier {
    
    NSAssert(identifier,@""identifier is nil"");
    if (identifier) {
        NotificationPerformLocked(^{
            [self modifyContainer:^(NSMutableDictionary *notificationOberverIdentifersDic) {
                //不重复add observer
                if (![notificationOberverIdentifersDic objectForKey:identifier.name]) {
                    [notificationOberverIdentifersDic setObject:identifier forKey:identifier.name];
                }
            }];
        });
    }
    
}</code></pre>
<p>这个对象也和 observer 关联。由于其和 observer 是关联的，因此当 observer 释放的时候，GYNotificationOberverIdentifer 也会释放，因此，也就能在 GYNotificationOberverIdentifer 的 dealloc 里面调用 remove 操作移除通知注册从而实现自动 remove。</p>
<p>同时由于 GYNotificationOberverIdentifersContainer 里面保留了所有的 Identifer 对象，因此也就能够方便的根据 name 进行 remove 了。</p>
<pre><code>- (void)removeObserverWithName:(NSString *)name {
    
    if (name) {
        NotificationPerformLocked(^{
            [self modifyContainer:^(NSMutableDictionary *notificationOberverIdentifersDic) {
                
                if ([notificationOberverIdentifersDic objectForKey:name]) {
                    GYNotificationOberverIdentifer *identifier = (GYNotificationOberverIdentifer *)[notificationOberverIdentifersDic objectForKey:name];
                    [identifier stopObserver];
                    [notificationOberverIdentifersDic removeObjectForKey:name];
                }
            }];

        });
    }
}</code></pre>

                ", NSNotification 线程管理以及自动注销开源方案,1531977941,108,1,321,1,1,https://segmentfault.com/a/1190000005889055
195,1,0,7,"
                    
<p>关于 Git 相信大家看了之前一系列的文章已经初步会使用了， 但是关于Git还有很多知识与技巧是你不知道的，今天就来给大家介绍下一些 Git 进阶的知识。</p>
<h2>1. 用户名和邮箱</h2>
<p>我们知道我们进行的每一次commit都会产生一条log，这条log标记了提交人的姓名与邮箱，以便其他人方便的查看与联系提交人，所以我们在进行提交代码的第一步就是要设置自己的用户名与邮箱。执行以下代码：</p>
<pre><code>git config --global user.name ""stormzhang""
git config --global user.email ""stormzhang.dev@gmail.com""
</code></pre>
<p>以上进行了全局配置，当然有些时候我们的某一个项目想要用特定的邮箱，这个时候只需切换到你的项目，以上代码把 <strong>--global</strong> 参数去除，再重新执行一遍就ok了。</p>
<p>PS：我们在 GitHub 的每次提交理论上都会在 主页的下面产生一条绿色小方块的记录，如果你确认你提交了，但是没有绿色方块显示，那肯定是你提交代码配置的邮箱跟你 GitHub 上的邮箱不一致，GitHub 上的邮箱可以到 <strong>Setting -&gt; Emails</strong>里查看。</p>
<h2>2. alias</h2>
<p>我们知道我们执行的一些Git命令其实操作很频繁的类似有：</p>
<pre><code>git commit
git checkout
git branch
git status
...
</code></pre>
<p>这些操作非常频繁，每次都要输入完全是不是有点麻烦，有没有一种简单的缩写输入呢？比如我对应的直接输入以下：</p>
<pre><code>git c
git co
git br
git s
...
</code></pre>
<p>是不是很简单快捷啊？这个时候就用到了alias配置了，翻译过来就是别名的意思，输入以下命令就可以直接满足了以上的需求。</p>
<pre><code>git config --global alias.co checkout  # 别名
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.br branch
</code></pre>
<p>当然以上别名不是固定的，你完全可以根据自己的习惯去定制，除此之外还可以设置组合，比如：</p>
<pre><code>git config --global alias.psm 'push origin master'
git config --global alias.plm 'pull origin master'
</code></pre>
<p>之后经常用到的<strong>git push origin master</strong> 和 <strong>git pull origin master</strong> 直接就用 <strong>git psm</strong> 和 <strong>git plm</strong> 代替了，是不是很方便？</p>
<p>另外这里给大家推荐一个很强大的 alias 命令，我们知道我们输入 <strong>git log</strong> 查看日志的时候是类似这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006767234"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>告诉大家一个比较屌的命令，输入<strong>git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative </strong> 然后日志这样了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005869757"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>是不是比较清晰，整个分支的走向也很明确，但是每次都要输这么一大串是不是也很烦？这时候你就该想到 alias 啊：</p>
<pre><code>git config --global alias.lg ""log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative""
</code></pre>
<p>这样以后直接输入 <strong>git lg</strong> 就行了。</p>
<h2>3. 其他配置</h2>
<p>当然还有一些其他有用的配置，默认情况下 git 用的编辑器是 vi ，如果不喜欢可以改成其他编辑器，比如我习惯 vim 。</p>
<pre><code>git config --global core.editor ""vim""  # 设置Editor使用vim
</code></pre>
<p>你们如果喜欢其他编辑器可自行搜索配置，前提是本机有安装。</p>
<p>有些人纳闷我的终端怎么有各种颜色，自己却不是这样的，那是因为你们没有开启给 Git 着色，输入如下命令即可：</p>
<pre><code>git config --global color.ui true
</code></pre>
<p>还有些其他的配置如：</p>
<pre><code>git config --global core.quotepath false # 设置显示中文文件名
</code></pre>
<p>以上基本所有的配置就差不多了，默认这些配置都在 <strong>~/.gitconfig</strong> 文件下的，你可以找到这个文件查看自己的配置，也可以输入 <strong>git config -l</strong> 命令查看。</p>
<h2>4. diff</h2>
<p>diff命令算是很常用的，使用场景是我们经常在做代码改动，但是有的时候2天前的代码了，做了哪些改动都忘记了，在提交之前需要确认下，这个时候就可以用diff来查看你到底做了哪些改动，举个例子，比如我有一个 a.md 的文件，我现在做了一些改动，然后输入 <strong>git diff</strong> 就会看到如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005869755"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>红色的部分前面有个 <strong>-</strong> 代表我删除的，绿色的部分前面有个 <strong>+</strong> 代表我增加的，所以从这里你们很一目了然的知道我到底对这个文件做了哪些改动。</p>
<p>值得一提的是直接输入 <strong>git diff</strong> 只能比较当前文件和暂存区文件差异，什么是暂存区？就是你还没有执行 <strong>git add</strong> 的文件。</p>
<p>当然跟暂存区做比较之外，他还可以有其他用法，如比较两次 commit 之间的差异，比较两个分支之间的差异，比较暂存区和版本库之间的差异等，具体用法如下：</p>
<pre><code>git diff &lt;$id1&gt; &lt;$id2&gt;   # 比较两次提交之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 
git diff --staged   # 比较暂存区和版本库差异
</code></pre>
<h2>5. checkout</h2>
<p>我们知道 <strong>checkout</strong> 一般用作切换分支使用，比如切换到 develop 分支，可以执行：</p>
<pre><code>git checkout develop
</code></pre>
<p>但是 <strong>checkout</strong> 不只用作切换分支，他可以用来切换tag，切换到某次commit，如：</p>
<pre><code>git checkout v1.0
git checkout ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7 # 后面的一长串是commit_id，是每次commit的SHA1值，可以根据 git log 看到。
</code></pre>
<p>除了有“切换”的意思，<strong>checkout</strong> 还有一个撤销的作用，举个例子，假设我们在一个分支开发一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了了，好在你刚写，甚至都没有 <strong>git add</strong> 进暂存区，这个时候很简单的一个操作就直接把原文件还原：</p>
<pre><code>git checkout a.md
</code></pre>
<p>这里稍微提下，<strong>checkout</strong> 命令只能撤销还没有 add 进暂存区的文件。</p>
<h2>6. stash</h2>
<p>设想一个场景，假设我们正在一个新的分支做新的功能，这个时候突然有一个紧急的bug需要修复，而且修复完之后需要立即发布。当然你说我先把刚写的一点代码进行提交不就行了么？这样理论上当然是ok的，但是这会产品垃圾commit，原则上我们每次的commit都要有实际的意义，你的代码只是刚写了一半，还没有什么实际的意义是不建议就这样commit的，那么有没有一种比较好的办法，可以让我暂时切到别的分支，修复完bug再切回来，而且代码也能保留的呢？</p>
<p>这个时候 <strong>stash</strong> 命令就大有用处了，前提是我们的代码没有进行 <strong>commit</strong> ，哪怕你执行了 <strong>add</strong> 也没关系，我们先执行</p>
<pre><code>git stash
</code></pre>
<p>命令，什么意思呢？意思就是把当前分支所有没有 commit 的代码先暂存起来，这个时候你再执行 <strong>git status</strong> 你会发现当前分支很干净，几乎看不到任何改动，你的代码改动也看不见了，但其实是暂存起来了。执行</p>
<pre><code>git stash list
</code></pre>
<p>你会发现此时暂存区已经有了一条记录。</p>
<p>这个时候你可以切换会其他分支，赶紧把bug修复好，然后发布。之后一切都解决了，你再切换回来继续做你之前没做完的功能，但是之前的代码怎么还原呢？</p>
<pre><code>git stash apply
</code></pre>
<p>你会发现你之前的代码全部又回来了，就好像一切都没发生过一样，紧接着你最好需要把暂存区的这次 <strong>stash</strong> 记录删除，执行：</p>
<pre><code>git stash drop
</code></pre>
<p>就把最近一条的 <strong>stash</strong> 记录删除了，是不是很方便？其实还有更方便的，你可以使用：</p>
<pre><code>git stash pop
</code></pre>
<p>来代替 <strong>apply</strong> 命令，<strong>pop</strong> 跟 <strong>apply</strong> 的唯一区别就是 <strong>pop</strong> 不但会帮你把代码还原，还自动帮你把这条 <strong>stash</strong> 记录删除，省的自己再 <strong>drop</strong> 一次了，为了验证你可以紧接着执行 <strong>git stash list</strong> 命令来确认是不是已经没有记录了。</p>
<p>最后还有一个命令介绍下：</p>
<pre><code>git stash clear
</code></pre>
<p>就是清空所有暂存区的记录，<strong>drop</strong> 是只删除一条，当然后面可以跟 <strong>stash_id</strong> 参数来删除指定的某条记录，不跟参数就是删除最近的，而 <strong>clear</strong> 是清空。</p>
<h2>7. merge &amp; rebase</h2>
<p>我们知道 <strong>merge</strong> 分支是合并的意思，我们在一个 featureA 分支开发完了一个功能，这个时候需要合并到主分支 master 上去，我们只需要进行如下操作：</p>
<pre><code>git checkout master
git merge featureA
</code></pre>
<p>其实 <strong>rebase</strong> 命令也是合并的意思，上面的需求我们一样可以如下操作：</p>
<pre><code>git checkout master
git rebase featureA
</code></pre>
<p><strong>rebase</strong> 跟 <strong>merge</strong> 的区别你们可以理解成有两个书架，你需要把两个书架的书整理到一起去，第一种做法是 <strong>merge</strong> ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是 <strong>rebase</strong> ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。</p>
<p>只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。</p>
<h2>8. 解决冲突</h2>
<p>假设这样一个场景，A和B两位同学各自开了两个分支来开发不同的功能，大部分情况下都会尽量互不干扰的，但是有一个需求A需要改动一个基础库中的一个类的方法，不巧B这个时候由于业务需要也改动了基础库的这个方法，因为这种情况比较特殊，A和B都认为不会对地方造成影响，等两人各自把功能做完了，需要合并的到主分支 master 的时候，我们假设先合并A的分支，这个时候没问题的，之后再继续合并B的分支，这个时候想想也知道就有冲突了，因为A和B两个人同时更改了同一个地方，Git 本身他没法判断你们两个谁更改的对，但是这个时候他会智能的提示有 <strong>conflicts</strong> ，需要手动解决这个冲突之后再重新进行一次 commit 提交。我随便在项目搞了一个冲突做下示例：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005869753"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>以上截图里就是冲突的示例，冲突的地方由 <strong>====</strong> 分出了上下两个部分，上部分一个叫 <strong>HEAD</strong> 的字样代表是我当前所在分支的代码，下半部分是一个叫 <strong>baidu_activity</strong> 分支的代码，可以看到 <strong>HEAD</strong> 对 gradle 插件进行了升级，同时新增了一个插件，所以我们很容易判断哪些代码该保留，哪些代码该删除，我们只需要移除掉那些老旧代码，而且同时也要把那些 <strong>&lt;&lt;&lt; HEAD</strong>、<strong>====</strong> 以及 <strong>&gt;&gt;&gt;&gt;&gt;&gt;baidu_activity</strong> 这些标记符号也一并删除，最后进行一次 commit 就ok了。</p>
<p>我们在开发的过程中一般都会约定尽量大家写的代码不要彼此影响，以减少出现冲突的可能，但是冲突总归无法避免的，我们需要了解并掌握解决冲突的方法。</p>
<p><br></p>
<blockquote><p>本文原创发布于微信公众号 <strong>AndroidDeveloper「googdev」</strong>，转载请务必注明出处！</p></blockquote>

                ", 从0开始学习 GitHub 系列之「Git 进阶」,1531977943,421,1,591,1,1,https://segmentfault.com/a/1190000005869506
196,1,0,7,"
                    
<h1>简介</h1>
<blockquote>
<p>GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书。GitBook支持输出以下几种文档格式</p>
<ul>
<li><p>静态站点：GitBook默认输出该种格式</p></li>
<li><p>PDF：需要安装gitbook-pdf依赖</p></li>
<li><p>eBook：需要安装ebook-convert</p></li>
</ul>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVyKyI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>准备安装</h1>
<blockquote><p>在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器。</p></blockquote>
<h2>Node.js</h2>
<blockquote><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台， 用来方便地搭建快速的， 易于扩展的网络应用· Node.js 借助事件驱动， 非阻塞 I/O 模型变得轻量和高效， 非常适合 run across distributed devices 的 data-intensive 的实时应用。</p></blockquote>
<p>1、win下安装Node.js</p>
<blockquote><p>直接到nodejs官网下载，简单安装即可，此处不再细述。</p></blockquote>
<p>2、检测是否安装成功</p>
<blockquote><p>node -v  //显示v4.1.1</p></blockquote>
<h2>GitBook</h2>
<blockquote><p>GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书。通过Node.js命令安装GitBook</p></blockquote>
<p>1、NMP安装Gitbook</p>
<blockquote><p>npm install gitbook -g</p></blockquote>
<p>2、安装gitbook CLI</p>
<blockquote>
<p>想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI”，执行以下命令</p>
<p>//安装命令<br>npm install -g gitbook-cli<br>//卸载命令<br>npm uninstall -g gitbook</p>
</blockquote>
<p>3、检验下是否安装成功</p>
<blockquote><p>gitbook -V  //显示0.4.2</p></blockquote>
<h2>Git</h2>
<blockquote><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。基本安装请点击安装教程。如果不需要从GitHub更新书到本地再编译，则可以不安装Git。</p></blockquote>
<h2>GitBookEditor</h2>
<blockquote>
<p>GitBook官方客户端编辑器，支持Win、Linux、Mac系统。请点击下载GitBookEditor。使用该编辑器可以快速的创建、编辑GitBook。安装具有以下步骤：</p>
<ul>
<li><p>解压下载包 gitbook-editor-4.2.1-windows-ia32.zip</p></li>
<li><p>运行GitBook Editor Setup.exe进行默认安装</p></li>
</ul>
</blockquote>
<h1>基本使用</h1>
<blockquote>
<p>GitBook 大致分为两种使用方式，即离线和在线。最简单的使用方式是使用GitBook Editor编辑GitBook ，然后使用相关命令编译成功HTML。当然还有以下几种方式</p>
<ul>
<li><p>使用命令创建基本GitBook</p></li>
<li><p>使用网页在线编辑器创建、编辑GitBook。</p></li>
<li><p>使用itBookEditor客户端创建、编辑GitBook。</p></li>
</ul>
</blockquote>
<h2>gitBookEditor</h2>
<blockquote><p>使用客户端方式，支持在线和本地两种方式创建、编辑GitBook，再执行相关命令编译成HTML，这种方式比较方便，推荐使用。以本地创建书籍为例</p></blockquote>
<p>1、gitBookEditor客户端基本使用</p>
<p><span class=""img-wrap""><img data-src=""/img/bVyKz5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVyKz9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>2、使用命令对已经创建的Book进行编译</p>
<blockquote><p>找到需要编译的书籍所在目录，执行gitbook serve 命令,在本电脑的默认路径为C:UsersQGYGitBookLibraryImportgitbooksimpletutorial，如图所示</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVyKAb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>高级扩展</h1>
<blockquote><p>掌握了“基本使用”，但有时候想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等。</p></blockquote>
<h2>Book.json配置</h2>
<blockquote><p>GitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json，这里以 book.json 为例，参考 GitBook 文档 可以知道，book.json 支持如下配置</p></blockquote>
<pre><code>{

    //样式风格配置格式
    ""styles"": {
        ""website"": ""styles/website.css"",
        ""ebook"": ""styles/ebook.css"",
        ""pdf"": ""styles/pdf.css"",
        ""mobi"": ""styles/mobi.css"",
        ""epub"": ""styles/epub.css""
     },

    //插件安装配置格式

    ""plugins"": [""myplugin""],
    ""pluginsConfig"": {
        ""myPlugin"": {
            ""message"": ""Hello World""
        }
     }    
}</code></pre>
<h2>自定义插件扩展</h2>
<blockquote><p>插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大，例如，把数学公式显示支持，跟踪回访使用谷歌解析，…以toggle-chapters插件为例<br>toggle-chapters 插件的效果是默认只在目录导航中显示章的标题，而不会显示小节的标题，点击每一章或者每一节会显示当前章或节的子目录，如果有的话，但是同时会收起其它之前展开的章节。所以，个人认为不是非常实用，因为这样子用户不能快速跳转到没有展开的章节！</p></blockquote>
<p>一、搜索、安装插件方式</p>
<p>1、编辑器方式（没成功）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVyKAo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>2、通过GitHub方式</p>
<blockquote><p>www.plugins.gitbook.com</p></blockquote>
<p>3、node.js命令方式</p>
<ul><li><p>默认安装在以下路径</p></li></ul>
<pre><code>C:\Users\QGY\AppData\Roaming\npm\node_modules</code></pre>
<ul><li><p>把插件文件夹复制到</p></li></ul>
<pre><code>npm install gitbook-plugin-toggle-chapters --save-dev</code></pre>
<p>二、通过Book.json配置插件</p>
<pre><code>""plugins"": [""toggle-chapters""],
    ""pluginsConfig"": {
        ""myPlugin"": {
            ""message"": ""Hello World""
        }
     }</code></pre>

                ", Gitbook简易教程,1531977944,545,1,957,1,1,https://segmentfault.com/a/1190000005859901
197,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006796319"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>让我们来聊聊部署</h3>
<p>无论你何时对自己的代码库做出改动，总会伴随着要破坏一些东西的风险。</p>
<p>没有人喜欢宕机，没有人喜欢暴躁的用户，也没有人喜欢生气的经理，所以部署新代码到生产环境变成颇具压力的一个环节。</p>
<p>你完全没必要对它有压力，我将在这里重复一遍又一遍这句话：</p>
<blockquote><p>你的部署应该尽可能单调、直接、毫无压力。</p></blockquote>
<p>部署新功能到生产环境中应该像在 Hacker News 开始一场关于 <a href=""http://www.bilibili.com/video/av4839483/"" rel=""nofollow noreferrer"">用 spaces 还是 tabs</a> 的口水战一样简单。它应该足够简单到让新员工理解，它应该为防止错误而生，它应该在第一个最终用户看到新代码前被很好地测试过。</p>
<p>这是一篇高层次谈论部署的文章，包含了：协作，安全和速度等，在底层方面也讲了很多，但这些都是很难跨语言进行概括，并且说实话，比起在高层次技术方面有很多更密切的问题要去解决，我更喜欢谈论团队如何协同工作，而部署是与其他人协作最关键的一部分。我认为你值得花时间并不时地来评估你团队的状况。</p>
<p>有很多来自我在 GitHub 任职 5 年的经验，和去年我与大大小小科技公司提供建议和咨询的经验，对在提高他们的部署工作流程的重点上（已经从“非常可敬”到归纳于“我觉得这服务器已经着火了”）。我特别推荐一个初创公司，Dockbit ，其产品是旨在正视部署中的合作，等等。这篇文章来源于许多关于我和它们团队的谈话，我认为写下来许多部署难题中的不同部分会大有益处的。</p>
<p>我很感激一些来自不同公司的朋友给予这篇文章的校队和帮忙，并提供各自在部署上不同的观点： Corey Donohoe (Heroku) ，Jesse Toth (GitHub) ，Aman Gupta (GitHub) ，和 Paul Betts (Slack) 。我不断的发现不同的公司可能采取很有趣的不同路径，但一般都集中在合作，风险和谨慎这种基础方面，我觉得有东西在这里具有普遍性。 </p>
<p>不管怎么说，对于这个漫长的导语我感到很抱歉，但无论如何这篇文章将是很长的，请尽力读完吧，lol.</p>
<h3>目录</h3>
<ul>
<li><p><strong>目标</strong> 难道部署不是一个已经解决的问题吗?</p></li>
<li><p><strong>准备</strong> 开始为部署做准备：测试，feature flags 和你的开发协作方式</p></li>
<li><p><strong>分支</strong> 为你的代码设置建立分支是部署最基本的部分。在部署新代码时你能把其中导致任何可能意外后果的部分分离出来。开始思考部署分支，自动部署 master 分支，蓝／绿部署。</p></li>
<li><p><strong>控制</strong> 部署的核心。你如何才能控制被发布的代码。处理在部署和合并中不同的权限结构，为你的部署建立一套审计跟踪，通过部署锁定和部署队列让一切有序。</p></li>
<li><p><strong>监视</strong> Cool，你的代码已经在生产环境了。现在你可以关心的你的部署在不同方面的监视指标，并且最终做出是否要为你的改动回滚代码的决定。</p></li>
<li><p><strong>结论</strong></p></li>
</ul>
<p>""我们学到了什么，Palmer ?""<br>""先生我不知道。""<br>""我 TM 也不知道。我猜我们学到的就是，不要再这么做了。""<br>""是的，先生。""</p>
<blockquote><p>How to Deploy Software was originally published on March 1, 2016.</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838566"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>难道部署不是一个已经解决的问题吗?</h3>
<p>如果你说的是拉取代码并将它们传送到不同的服务器上，那么事情已经解决的很漂亮并且这些事情相当无聊。你已经获得了 Ruby 中的 Capistrano（一种远程服务器自动化工具），Python 中的 Fabric(Python 的一个类库以及命令行工具)，Node 中的 Shipit （Javascript 写的一个通用自动化和发布工具），以及所有的亚马逊云服务，甚至是 FTP 也貌似会存在好几个世纪，因此工具现在真的不是问题。</p>
<p>如果我们此时有了相当不错的工具，为什么部署会出错呢？为什么人们总是发布 bug 呢？为什么总是存在宕机的情况？我们可都是写完美代码的完美程序员啊，这真是见鬼了。</p>
<p>很明显，事情总是始料未及地发生，所以我认为部署应该是中小型公司应关注的有趣领域，其他领域没有如此好的投入产出比。你可以做好尽早处理和应对问题的工作流程吗？你可以使用不同的工具来更简单地进行协助部署吗？</p>
<blockquote><p>这不是工具问题，这是处理的问题。</p></blockquote>
<p>我对很多很多创业公司讲，过去的几年，还没有一个从组织的角度看上去“好的”部署工作流。</p>
<p>你无需负责部署的专人，无需特定一个部署日期，无需在每次部署时动用所有人手。你只需要采取一些聪明的办法。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>在一个好的基础上开始。</p>
<p>在跑之前你必须走起来。我认为初创公司有一个很时髦的方面就是它们都用着最酷并且最新的部署工具，但是当你切进去观察他们的处理时，会发现他们花了 80% 的时间在处理基础上。如果他们从开始时就是流水化的，每件事都会恰当地处理并且更为迅速。</p>
<h3>测试</h3>
<p>测试是前期一个最简单的地方。在一些浅显的依赖处理中这不是一个必需的步骤，不过却对其着有着巨大的影响。</p>
<p>这里很多技巧取决于你的语言，平台或者框架，不过普遍的建议是测试你的代码 ，并提高测试速度。</p>
<p>我最喜欢引用 <a href=""https://twitter.com/rtomayko"" rel=""nofollow noreferrer"">Ryan Tomayko</a> 在 GitHub 的内部测试文档里写的：</p>
<blockquote><p>我们能让好的测试变快却不能让快的测试变好。</p></blockquote>
<p>所以以一个好的基础开始：做个好的测试，别吝啬这点，因为它影响一切的方向。</p>
<p>一旦你开始有一个值得依靠的质量测试套件，尽管在开始时得花钱。如果你有任何形式的收入或者你们幕后团队的资助，几乎头号你应该花钱的地方就是你应该运行测试的地方。如果你使用 Travis CI 或者 CircleCI ，如果你能运行并行编译构建那么就重复今天所做的。如果你需要在特定的硬件上运行，那就买巨大的服务器。</p>
<p>我见过一些公司通过迁移到更加快的测试套件上使其获得了最重要的生产力优势，而你也能赚到，因为它影响迭代反馈周期，缩短依赖时间，增加开发者的幸福感并且使其成为一种惯性。在问题解决方案上花钱吧：因为服务器很便宜，但程序员却不。</p>
<p>我在 Twitter上 做过一个<a href=""https://twitter.com/holman/status/703311796329799680"" rel=""nofollow noreferrer"">非正式的投票</a> 问我的 followers 他们的测试套件究竟跑得有多快。诚然，很难解释那些微小服务，语言差异上居然有惊人数目的人从来没有做过测试。不过在全栈和更快的单元测试者对决中，它表现的还是非常明显。大多数人在 push 后至少要等待5分钟才能看到构建状态。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838573"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>快究竟指多快呢？ 当我在 GitHub 时，测试一般在 2-3 分钟内跑完。我们并没有很多集成测试，所以允许以相对较快的速度测试，但是实际上你测试的越快，你就能越快的得到开发人员的循环反馈。</p>
<p>有许多的项目旨在帮助你并行化构建项目。在 Ruby 里有 <a href=""https://github.com/grosser/parallel_tests"" rel=""nofollow noreferrer"">parallel_tests</a> 和 <a href=""https://github.com/tmm1/test-queue"" rel=""nofollow noreferrer"">test-queue</a> 。比如你的测试没有相互完全独立，以不同的方式编写测试是一个很好的方法，如果情况相反，你也应该好好处理它。</p>
<h5>Feature Flags</h5>
<p>这一切的另一个方面是开始看你的代码并且把它转化来支持多渠道部署代码路径。</p>
<p>重复一遍，我们的目标是你的部署应该尽可能单调，直接，无压力。部署任何新代码的自然压力是代码运行出你无法预见的问题，你最终影响到用户的行为（即他们经历的停机时间和错误）。即使你有宇宙中最好的程序员，糟糕的代码将最终被部署。不管这些坏代码是影响 100% 的用户或只是一个对你们非常重要的用户。</p>
<p>用一个简单的方法来处理，那就是 <a href=""https://en.wikipedia.org/wiki/Feature_toggle"" rel=""nofollow noreferrer"">Feature Flag</a> 。 Feature Flag 已经出现很久了，至少，技术上讲，是自从 if 语句发明开始的，而我记得第一次真正听到有公司的使用 Feature Flag 是 Flickr 在 2009 年的一篇文章。<a href=""http://code.flickr.net/2009/12/02/flipping-out/"" rel=""nofollow noreferrer"">Flipping Out</a></p>
<blockquote><p>这允许我们开启我们正在开发的功能而不影响其他开​​发人员正在开发的功能。它也可以让我们打开或关闭测试单独的功能。</p></blockquote>
<p>只有你可以看到，或只有你的团队可以查看 flags，或所有员工都能看是两件不同的事：你可以在现实世界使用真实的数据测试代码，并确保一切工作正常；你还可以得到真正的关于该功能正式发布时得到关于性能和风险的 benchmarks。</p>
<p>所有这一切的对你准备部署新的功能是大大有利的，你需要做的就是修改一行代码为 true ，然后每个人都看到了新的代码。这使得通常吓人的新版本部署变为为单调，直接，且无压力。</p>
<h3>可查验的正确的部署</h3>
<p>作为一个额外的步骤，Feature Flag 提供了一个很好的方式来证明你的即将代码部署不会对性能和可靠性产生不利影响。最近几年一些新的工具能帮助你做到这个。</p>
<p>我在几年前的演讲文章 <a href=""https://zachholman.com/talk/move-fast-break-nothing/"" rel=""nofollow noreferrer"">《Move Fast and Break Nothing》</a> 中谈过，它的主要内容是在生产环境运行 Feature Flag 的两个代码路径中，并且只返回旧代码的结果，观察你引进的新代码与你即将更换的新代码的表现。一旦你有了这些数据，你可以确保你不会破坏任何事情。部署将变得单调，直接，无压力。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838575"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>GitHub 上一个叫做 Scientist 的开源 Ruby 库能抽象的帮助你很多。这个库已经这点上被移植到最受欢迎的语言上，所以如果你感兴趣，它可能很值得你花时间去看一看。</p>
<p>另一种方法是灰度发布。一旦你对要部署的代码是准确无误充满信心，首先你仍然谨慎地仅公开到一小部分用户来进行双重检查和三重检查，直到没有产生什么破坏。破坏 5% 用户的体验比破坏 100% 用户的体验要好得多。</p>
<p>有大量旨在帮助你的库，从 Ruby 中的 Rollout ，Java 中 Togglz ，到 JavaScript 中的 fflip ，和许多其他的。还有很多初创公司在为这个问题提供解决方案，比如 LaunchDarkly 。</p>
<p>另外值得一提的是，这并不仅仅是 Web 的事情。本地应用也可以从中获益良多。粗略看下 <a href=""https://github.com/mattt/GroundControl"" rel=""nofollow noreferrer"">GroundControl</a> 这个 iOS 中处理表现的库就懂了。 </p>
<p>在代码构建上自我感觉良好？赞，我们现在来跳出这点，开始讨论下部署。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838577"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>用分支管理</h3>
<p>很多围绕部署的组织问题被部署者与其他人缺少沟通阻碍着。你需要每个人了解了你即将上线的代码的方方面面，在做这个同时避免踩到她人的脚趾。</p>
<p>这里有几个可以帮到你的有趣的方式，它们都取决于部署的最简单元：分支。</p>
<h3>代码分支</h3>
<p>分支，我是指 Git，Mercurial 等版本控制系统的分支。先切出一个分支，在该分支上编程，然后推送代码到你喜爱的代码托管平台（如 GitLab，Bitbucket，Coding 等）    <br>你也应该使用 Pull Requests，Merge Request，或其他 code review 工具去评审写好的代码。部署环节必须要协作，代码评审是非常重要的一部分。我们稍后会进一步说明这块。</p>
<h3>代码评审</h3>
<p>代码评审这个话题太大，太复杂，且依你的团队和风险状况不同。我认为这里有几个重要的问题需要所有的团队去思考：</p>
<ul>
<li><p><strong>你的分支你负责。</strong> 我见过的成功型公司都有这个理念，即部署代码失败的最终负责人是写这个代码的人。他们不把部署失败的责任归结于部署上线的人然后就去起床吃饭，当然这些人应该参与代码评审，但最重要的是你要对你自己的代码负责。如果它（编译）失败了，你自己去解决.......而不是你可怜的 ops 团队。所以不要搞砸它。</p></li>
<li><p><strong>尽早开始并经常性进行评审。</strong> 你不需要完成一个分支后再去请求评审。如果你可以发起一个关于预期代码的评审请求，比如，花了 20 分钟在这上面然后被通知说 “不，我们不用做这个了” 远远比之后花两周时间写这个代码更好。</p></li>
<li><p><strong>总是需要某人来评审代码。</strong> 你可以依靠团队来做这个，但有一双专门负责评审的眼睛是非常有帮助的。对于结构化程度高的公司，你可能要明确指派人来负责代码评审，并要求他们在代码完前就开始 review。对于结构化程度较低的公司，你可以指派不用的团队看看谁最可以帮到你。在光谱的两端，你设定的期望是有人在猛冲前给你搭把手，或独自部署代码。</p></li>
</ul>
<h3>分支和部署节奏</h3>
<p>这里有个关于代码评审的老段子。无论何时你开启了一个关于 6 行代码的评审请求，你总会得到很多同事关于这 6 行代码的指指点点。但当你 push 了一个花了几周时间的代码分支，你常常会得到一个很快回复的：赞，我看行！</p>
<p>基本上，程序员常常都是一群很讨厌的懒虫。</p>
<p>但你可以利用其作为你的优势，通过：使用尽快，较小的分支和 Pull Request。让代码小到可以很容易让人随时切入并进行评审。如果你写了大型的分支，这需要别人花很长时间去 review，同时拖慢了整个开发的进度。</p>
<p>如何让代码更小？这时之前说的 feature flags 就派上用场了。当 2014 年我团队的三个人重建 GitHub 的 Issues 时，我们向 Production 推送了大约上百数量的使用 Feature Flag 的小型 Pull Requests。我们部署了很多小单元（在其“完美”之前）。这让代码评审更简单，同时让部署更快，更早看到线上的产品状况。</p>
<p>你需要快速并频繁地部署。十人规模的团队可以每天无忧地部署至少 7-15 个分支。重复一遍，diff 越小，部署就越单调，越直接，越无压力。</p>
<h3>部署分支</h3>
<p>当你准备好部署你的新代码，你应该总是在合并代码前部署你的分支。注意""总是""。</p>
<p>查看整个代码库作为事实的记录。你的 master 分支（或你指定的任何的默认主分支）应该作为你的生产环境的绝对镜像。换句话说，你需要确保你的主分支是“没问题的”，就是该分支没有任何已知的问题。</p>
<p>分支是个大问题。如果你合并你的分支到 master 然后就部署 master 分支，你无法简单地判断代码是否正常，“没问题”分支是无需做任何恶心的代码回滚操作的分支。<br>这不一定是火箭科学才需要的事情，但如果你的部署搞坏了网站，最后你就需要反思下了。你需要一个简单的方法。</p>
<p>这就是为什么你的部署工具应该支持你部署分支是很重要的。一旦你确认你的性能没有波动，没有稳定性问题，功能可用性在预期内，你就可以 merge 它了。这么做的原因不是为了确保事情可行，而是防止事情不可行。当其出错时，你的解决方案应该是单调，直接且无压力的：重新部署 master 分支即可。就是这样。你回到了“没问题”的状态。</p>
<h3>自动部署</h3>
<p>重要的是要对你的“已知状态”有清晰的定义，最简单的方法就是定一个简单的不出错的规则：</p>
<blockquote><p>除非你正在测试一个分支，所有部署到生产环境的都始终由 master 分支体现。</p></blockquote>
<p>我见过的最简单的方法是保持在 master 分支设置自动部署。这是超简单的规则组，它鼓励大家向分支做出最无风险的提交。</p>
<p>这里有很多工具平台可用，如 Heroku 可以自动部署最新分支。CI 工具如 Travis CI （译者注：国内有 <a href=""https://flow.ci"" rel=""nofollow noreferrer"">flow.ci</a> ）也可以帮你自动部署。或私有部署的 Heaven 和 hubot-deploy-tools （我们稍后会提到）也可以帮到你。</p>
<p>自动部署在你 merge 你工作的分支到 master 分支时也有帮助。你的工具应该可以选取一个新的修订并重新再次部署网站。尽管软件内容没变（你在有效的部署同一套代码），SHA-1 值变化了，这使生产环境的已知状态变得更加明确（再次重申下，master 分支是已知状态）。</p>
<h3>蓝绿部署</h3>
<p>Martin Fowler 曾经在 2010 年的文章推崇过 <a href=""http://martinfowler.com/bliki/BlueGreenDeployment.html"" rel=""nofollow noreferrer"">蓝绿部署</a>（很值得一读）。在其中，Fowler 谈论到使用两种理想的生产环境的理念，即他说的“蓝”和“绿”。蓝意味着在线的生产环境，绿代表空闲的生产环境。你可以部署到绿色集群，确认一切正常运行后，通过无缝切换（如负载均衡）切换到蓝色集群。如此，生产环境收到了没有风险的代码。</p>
<blockquote><p>自动部署的一个挑战就是切换，将软件从测试的最后环节检出到生产环境。</p></blockquote>
<p>这是一个非常强大的想法，而日益普及的虚拟化，容器技术和（可以很容易地扔掉，被遗忘的）自有环境使它变得更加强大。除了一个简单的蓝色/绿色的部署，你也可以让生成产环境流动起来，因为一切都是虚拟的。</p>
<p>这里有很多解决方法，从灾备恢复到在用户看到它前附加时间测试关键功能，但我最喜欢的是附加功能使用代码。</p>
<p>使用新代码是在产品开发周期非常重要的。当然，很多问题应提前在代码审查或通过自动测试找到了，但如果你正在尝试做真正的产品，有时很难预测直到你已经长时间试过了真实的数据。这就是为什么蓝绿部署比有一个简单的临时服务器更重要，其数据可能过时了或完全捏造。</p>
<p>更重要的是，如果你需要你的代码部署到特定的环境中，你就可以在早期开始就引入不同利益相关者。不是每个人都有技术能力把你的代码拉取到他们的计算机上，并在本地安装你的代码 - 而且这也是不应该的！比如，如果你能给你的会记部门展示你的新的上线情况的屏幕，在整个公司看到它之前，他们可以给你一些关于它的现实反馈，这可以帮你在早期找到很多的错误和问题。</p>
<h3>Heroku Pipelines</h3>
<p>不管你用不用 Heroku，看一下他们生态系统中的“Review Apps”理念：apps 直接从一个 Pull Request 进行部署，直接上线而不是截图或大幅的关于“这就是它上线后的样子”的描述。让更多人尽早参与进来而不是你之后试图用烂的产品说服他们。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838583"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>控制部署流程</h3>
<p>你看，当我在谈一个创业公司的组织方式时，我是完全嬉皮自由雅痞的：我笃信开发者的自主性，用一种自下而上的方法去开发，注重人而不是管理。我认为这会让大家更快乐且让产品更好。但在部署时，嗯哼，这是非常重要的，属于 all-or-nothing 的需要做好的事情，所以我觉得这里加入管控是合理的。</p>
<p>幸运的是，部署工具就是加入限制，从而把大家从压力中解放出来，所以如果你做对了将大大获益，而不是常人说的这将是阻碍。换句话说，你的流程应该促使事情搞定，而不是阻碍它。</p>
<h3>审计跟踪</h3>
<p>我惊讶一些竟然不可以很快拿到审计日志的创业公司。尽管可能会有一些聊天记录可查，但这不应该是你需要时拿不出来的东西。</p>
<p>审计跟踪的好处就是你预见到的：你可以找出是何时何地何人部署的。当你之后遇到问题时，你可以回滚到某一节点，这将节省不少时间。</p>
<p>很多服务都提供了这类的部署日志。如 Amazon CodeDeploy 和 Dockbit，提供了广义上的部署工具并提供了很好的追踪工具。GitHub 杰出的部署 API （译者注：Coding.net 也提供了 <a href=""https://coding.net/help/doc/account/ssh-key.html#ssh"" rel=""nofollow noreferrer"">部署 API</a>）也是很好的从 Pull Request 部署集成到你的外部系统的好办法。</p>
<h3>GitHub 的开发 API</h3>
<p>如果你在专家模式，在你的部署和部署时间需要插入很多数据库和服务，如 InfluxDB，Grafana，Librato 或 Graphite。可以在给定指标和部署层指标中对比是非常强大的：起初看到一个意外的指标增加或许让你好奇，但当那是一次部署在发生时，你就不会感到意外了。</p>
<h3>部署锁定</h3>
<p>如果你走到了在一个代码库中有很多人的这一步，你自然会遇到有很多人在某时都准备部署各自代码的状况。当然同时部署多个分支到生产环境是可行的，但我建议，当你走到这一步时，你需要些处理这种情况的工具。部署锁定就是我们要了解的第一个东西。</p>
<p>部署锁定基本是你已经预料到的东西：锁定生产环境以便大家可以依次进行部署。这里有很多方法可行，但最重要的是你要让这 <strong>可见</strong>。</p>
<p>实现这一目标的最简单办法就是通过聊天。一个常见的方式可以是设置部署命令锁定生产环境，比如：</p>
<pre><code>/deploy &lt;app&gt;/&lt;branch&gt; to &lt;environment&gt;</code></pre>
<p>i.e.,</p>
<pre><code>/deploy api/new-permissions to production</code></pre>
<p>这使大家都明白你在部署什么。我见过一些使用 Slack 的公司在 Slack 的部署聊天室里说：我在部署...！我觉得这是没有必要的，这只会分散你的同事。这里只要把信息扔进聊天室就够了。如果你之后忘了做也可以添加一条额外命令让系统返回目前生产环境的状态。</p>
<p>这里有很多简单方法可以把这套工作流插入你的聊天室。Dockbit 有一个 Slack 集成。也有一个开源解决方案叫作 SlashDeploy 可以集成 GitHub 和 Slack。（译者注：国内有 bearychat.com 提供了类似服务）</p>
<p>我还见过一些特制的关于这一步的网页版工具。Slack 有个自定义的内部 App 提供了可视化的部署。Pinterest 有一个开源的基于网页的部署系统。你可以将锁定的理念延伸到其他方面，这取决于如何使你的团队最高效工作。</p>
<p>一旦部署分支被 merge 到 master 分支，生产环境应该自动解锁以便下一个人进行操作。</p>
<p>这里也有一定的锁定礼仪。你当然不希望大家等待一个粗心的程序员忘记了解锁生产环境。自动解锁工具就派上用场了，比如，你也可以设置定时提醒部署人员其生产环境是否被锁定超过了 10 分钟。宗旨就是：拉完屎赶紧走。</p>
<h3>部署队列</h3>
<p>一旦你有很多部署要安排且你有很多人员准备部署，你显然会有一些部署争论。对于这一点，从你内心深处的英国绅士特色中选择，形成一个部署队列。</p>
<p>一个部署队列有几个部分：1）如果需要等待，把你的名字添加到末尾，2）允许有人插队 （有些非常重要的部署需要立即执行，你需要允许这样做）</p>
<p>部署队列的唯一问题就是有太多人排队部署了。GitHub 从过去一年至今都面临这个问题；在周一人人都想部署他们的变更，部署列表看起来可以持续一个小时或更久。我不是特别提倡微服务，但我认为部署队列有一个好处就是你可以从雄伟的巨石中劈东西了。</p>
<h3>权限</h3>
<p>有很多方法可以限制使用部署权限的人。</p>
<p>两步验证是一个选项。最好你的雇员聊天帐号不会被公开，最好他们在他们电脑上有其他安全措施（全盘加密，强密码等等），但是如果你要安心的话，最好要求他们开启两步验证。</p>
<p>或许你已经有提供两步验证服务的聊天服务商，如 Campfire 和 Slack。（译者注：Coding.net 也提供了 <a href=""https://coding.net/help/doc/mobile/2fa.html"" rel=""nofollow noreferrer"">两步验证</a> ） 如果你需要在部署前进行两步验证，你可以在其流程中增加两步验证。</p>
<p>另一种可行的处理方法是，我称权限外的调查员为“骑猎枪”。我见过很多拥有正式或非正式的流程或工具去保证至少有一位高级开发人员参与每一步部署。这里没有理由不这么做，比如，要求你的部署人员和高级开发人员（骑猎枪）去确认代码可以部署。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838585"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>欣赏并检验你的工作</h3>
<p>一旦你部署完你的代码，便是时候开始验你是否真的做了你所想做的。</p>
<h5>检查你的 Playbook</h5>
<p>无论是更新前端、后端或其他任何代码，每次部署都必须符合同一个策略方针。你必须查看网站是否还正常运行着，是否性能突然变得更糟糕，是否产生更多误码率，亦或者有更多反馈的问题等等。所以说精简那个策略方针将对你非常有利。</p>
<p>对于上述的不同方面，如果多个信息来源，试着比如在最终确认部署的时候给每个仪表盘中加一个链接。这样每次都能提醒大家观察并验证这些变更是否对度量指数产生了负面影响。</p>
<p>理想状态下，应从一个来源里获取信息。这样更容易指引，比如一个新员工在第一次部署的时候该观察重要的度量指数。比如 Printerest 的 <a href=""https://github.com/pinterest/teletraan"" rel=""nofollow noreferrer"">Teletraan</a> 在一个界面里就包含了所有的信息。</p>
<h3>度量指数</h3>
<p>有很多可以收集的度量指数将有助于你判断刚刚部署得是否成功。</p>
<p>当然最显著的是误码率。如果它突然急速上升，意味着你可能得重新部署 master 分支并且修复这些问题。这些过程可以自动化实现，甚至可以设定一个阈值，如误码率超了就自动重新部署。如果你确定 master 是一个对你来说熟知并且可以回滚的分支，那么自动回滚将变得更容易，一旦你部署后就触发大量异常则自动回滚部署。</p>
<p>部署本身也是个很有意思的度量，值得放在手上。一个很好的例子就是纵览过去一年的部署情况，可以帮助你了解部署的节奏是在放大，或者让你了解它慢下来的原因。你可以进一步收集是谁在部署，谁导致了错码，并开发一种能够检测团队开发者是否可靠的方法。</p>
<h3>部署后的清理</h3>
<p>最后一步需要做的家务活就是清理。</p>
<p><a href=""http://swreflections.blogspot.com/2014/08/feature-toggles-are-one-of-worst-kinds.html"" rel=""nofollow noreferrer"">Feature Toggles 是最糟糕的技术债之一</a> 对这进行了讨论，虽然这个标题有点激进。如果你正在构建一些有 feature flags 以及人员发展的项目，你将面临长期使你代码库的变得更复杂化的风险：</p>
<blockquote><p>用管道与脚手架逻辑支持代码分支是一种令人讨厌的技术债务，因为自此以后每个功能开关都要引入。Feature flags 使得代码更脆弱，很难测试、理解、维护、支持，也更不安全。</p></blockquote>
<p>你不需要部署完就立刻清理；如果你有一个新功能或者 bug 修复的需求，你应该花时间在监测系统指标，而不是立刻删除代码，尽管部署后不久你还是得这样做。如果你有一个重大版本发布，你可以在一天或一星期后回顾并删除那些已经不用的代码。我喜欢做的一件事就是准备两个 pull request：一个是切换 Feature flags （比如，开放该功能给所有人），另一个是清除所有的你引入的冗余代码。当我确保我没破坏任何事情并且看上去不错的话，我就可以合并第二个 pull request 而不需再更多的考虑或开发。</p>
<p>你还需要给自己庆祝一番：因为这个终极信号意味着你们已经成功地完成了这个项目。所有人都会喜欢看到 diff 几乎都变红的状态，删除代码的确是件很开心的事情。</p>
<h3>删除分支</h3>
<p>当你完成任务后，你同样可以删除分支，这肯定是不会错的。但如果你用的是 GitHub 的 pull request，你通常可以保留删除的分支，这样相当于从分支列表中删除了该分支，但其实不会有任何的数据丢失。这个过程同样也可以自动完成：定期执行一个脚本，检查你那些陈旧的已合并到 master 的分支并且删除它们。（译者注：Coding.net 的 Merge Request 也提供了 merge 后自动删除分支功能）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005838587"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>整个球赛</h3>
<p>我只对两种事情感到情绪激动：一个是一张动人的照片：山顶上一只金毛寻回犬倚着它最好的朋友，面朝大海，看夕阳西下；还有就是部署工作流。我如此关心这件事是因为它是整个比赛最关键的一部分，在一天结束的时候，我只关心两件事情：同事的感觉是怎么样的，我工作的产品是怎么样的。对我来说其他一切皆源于这两方面。</p>
<p>部署可以造成压力和挫折，尤其当你的公司开发节奏是迟缓的，也可以减缓和阻止你添加新功能、为用户修复 BUG。</p>
<p>我认为思考这些是值得的，优化自己的工作流也是值得的。花一些时间让自己的部署变得尽可能单调、直接、无压力，是会得到回报的。</p>
<p>（完）</p>
<p>你可能会感兴趣的文章：</p>
<ul>
<li><p>《使用原理视角看 Git 》<a href=""https://blog.coding.net/blog/principle-of-Git"" rel=""nofollow noreferrer"">https://blog.coding.net/blog/principle-of-Git</a></p></li>
<li><p>《使用 Feature Branch Workflow 让开发更简单》<a href=""https://blog.coding.net/blog/feature-branch-workflow"" rel=""nofollow noreferrer"">https://blog.coding.net/blog/feature-branch-workflow</a></p></li>
<li><p>《大话 Git 工作流》<a href=""https://blog.coding.net/blog/git-workflow"" rel=""nofollow noreferrer"">https://blog.coding.net/blog/git-workflow</a></p></li>
<li><p>其他技术博文 <a href=""https://blog.coding.net/technology/blogs"" rel=""nofollow noreferrer"">https://blog.coding.net/technology/blogs</a></p></li>
</ul>
<blockquote><p>作者 <a href=""https://zachholman.com/posts/deploying-software"" rel=""nofollow noreferrer"">Zach Holman</a><br>本文为 Coding 用户协作翻译，转载请注明来源。如果你对本文的翻译有建议，欢迎提交 <a href=""https://coding.net/u/tvvocold/p/deploying-software/git/"" rel=""nofollow noreferrer"">Pull Request</a> 。</p></blockquote>

                ", 如何部署软件 - 让你团队的部署像地狱一样无聊且毫无压力,1531977946,560,1,85,1,1,https://segmentfault.com/a/1190000005838563
198,1,0,7,"
                    
<p>接触go也已经有一个星期多了 相比与java 感觉最大的不足就是没有强大的IDE其他方面都还不错 然后 把自己最今一段时间学习Go的资料整理了一下</p>
<p>快速入门<br><a href=""https://tour.go-zh.org/welcome/1"" rel=""nofollow noreferrer"">Go指南</a></p>
<p>书籍：<br><a href=""https://github.com/Unknwon/the-way-to-go_ZH_CN"" rel=""nofollow noreferrer"">《Go 入门指南》(《The Way to Go》中文版)</a> <br><a href=""https://github.com/Unknwon/go-fundamental-programming"" rel=""nofollow noreferrer"">《Go 编程基础》</a><br><a href=""https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/preface.md"" rel=""nofollow noreferrer"">《GO 标准库》:</a><br><a href=""https://github.com/astaxie/build-web-application-with-golang"" rel=""nofollow noreferrer"">《Go Web 编程》</a> <br><a href=""http://www.ituring.com.cn/book/967"" rel=""nofollow noreferrer"">《Go语言编程》</a> 比较老的一本书<br><a href=""https://github.com/qyuhen/book"" rel=""nofollow noreferrer"">《Go学习笔记》</a> </p>
<p>视频：<br><a href=""http://study.163.com/course/courseMain.htm?courseId=306002"" rel=""nofollow noreferrer"">Go编程基础</a><br><a href=""http://study.163.com/course/courseMain.htm?courseId=328001"" rel=""nofollow noreferrer"">Go Web 基础</a><br><a href=""http://study.163.com/course/courseMain.htm?courseId=510006"" rel=""nofollow noreferrer"">Go名库讲解</a><br><a href=""http://study.163.com/course/introduction/634003.htm#/courseDetail"" rel=""nofollow noreferrer"">beego入门教程</a><br><a href=""http://www.imooc.com/learn/345"" rel=""nofollow noreferrer"">Go语言第一课</a></p>
<p>网站社区：<br><a href=""http://studygolang.com/"" rel=""nofollow noreferrer"">Go语言中文网</a><br><a href=""http://golanghome.com/"" rel=""nofollow noreferrer"">Go友团</a></p>
<p>更多：<br><a href=""http://www.ucai.cn/4347.html"" rel=""nofollow noreferrer"">无闻大神的更多视频</a><br><a href=""http://pan.baidu.com/s/1slrbOS1"" rel=""nofollow noreferrer"">云盘书籍</a><br><a href=""https://bitbucket.org/golang-china/gopl-zh/wiki/Home"" rel=""nofollow noreferrer"">Go语言圣经（中文版）</a><br><a href=""http://wiki.jikexueyuan.com/list/go/"" rel=""nofollow noreferrer"">极客学院</a></p>

                ", Go学习【二】学习资料,1531977948,213,1,492,1,1,https://segmentfault.com/a/1190000005757688
199,1,0,7,"
                    
<h1>概述</h1>
<p>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。</p>
<p>我画的git分支管理<br><span class=""img-wrap""><img data-src=""/img/bVyt3F"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Git的优势</h2>
<p>Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称""快照""）的指针，因此非常快捷易用。<br>快捷带来的问题就是如果稍不注意分支就会太多，造成不方便管理。因此分支管理变的尤为重要。Vincent Driessen提出了一个分支管理的策略，用来给大家学习。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。</p>
<p>［说明：在一个团队中，使用git来进行版本管理，高端大气上档次，不我不是表达这个。而是我们的小伙伴在刚开始使用git时，对git分支不明确，不明确具体分支做什么的,以及如何使用，下面具体实战，有不对之处请指正!］</p>
<h2>git分支模型参考</h2>
<p><span class=""img-wrap""><img data-src=""http://static.oschina.net/uploads/img/201302/25142840_pKcL.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git分支模型"" title=""git分支模型""></span></p>
<h2>分支管理</h2>
<p>下面内容参考上面的模型进行讲解，但不是绝对的。</p>
<h4>主分支Master</h4>
<p>首先，中央仓库应该有一个、且仅有一个主分支。所有提供到生产环境的正式版本。<br>Master 是Git默认的主分支。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。(master分支代码最完整，最干净，用于生产环境)</p>
<h4>开发分支Develop</h4>
<p>主分支只用来发布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支叫做Develop。<br>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行""合并""（merge）。<br>Git创建Develop分支并切换为当前分支的命令：</p>
<pre><code>git checkout -b develop</code></pre>
<p>将Develop分支发布到Master分支的命令：</p>
<p># 切换到Master分支</p>
<pre><code> git checkout master</code></pre>
<p># 对Develop分支进行合并</p>
<pre><code> git merge --no-ff develop</code></pre>
<p>上一条命令的--no-ff参数是什么意思。默认情况下，Git执行""快进式合并""（fast-farward merge），会直接将Master分支指向Develop分支。<br>使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p>
<h3>临时性分支(辅助分支)</h3>
<p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。<br>但是，除了常设分支以外，还有一些辅助开发分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<p>功能（feature）分支<br>   预发布（release）分支<br>   修补bug（hotfix）分支</p>
<p>这三种分支都属于临时性需要，使用完以后，应该删除(用完即焚)，使得代码库的常设分支始终只有Master和Develop。<br>我应用时候一般回把fixbug分成fix和bug，为了方便的管理上线的时间节点，因为一般fix是指不修改会有错误，但错误不是致命的，可以根据开发安排来选择上线时间，而bug是对使用造成了影响，因此要实时上线。所以分成两个。</p>
<h3>临时分支</h3>
<h5>功能分支</h5>
<p>feature是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop,并且每个功能都有一个对应的功能分支<br>功能分支的名字，可以采用feature_xx的形式命名。如：我们要开发一个oss文件上传功能或者地图的功能，就可以使用到功能分支！如:feature_ossfileupload<br>  创建一个功能分支：</p>
<p># 切换到develp分支</p>
<pre><code> git checkout develop</code></pre>
<p># 从develp分支切出分支feature_x<br> git checkout -b feature_x</p>
<p>开发完成后，将功能分支合并到develop分支</p>
<p># 从当前分支切换到develop分支</p>
<pre><code> git checkout develop</code></pre>
<p># 合并feature_xx</p>
<pre><code> git merge --no-ff feature_xx</code></pre>
<p># 删除feature_x分支</p>
<pre><code> git branch -d feature_xx</code></pre>
<h5>发布分支</h5>
<p>release是发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们要对当前完成的功能进行测试。<br>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，采用release_xx的命名形式<br>创建一个预发布分支</p>
<p># 切换到develp分支</p>
<pre><code> git checkout develop</code></pre>
<p># 从develp分支切出分支release_xx</p>
<pre><code> git checkout -b release_1.2.1</code></pre>
<p>确认没有问题后，合并到master分支</p>
<pre><code> git checkout master

 git merge --no-ff release_1.2.1</code></pre>
<p># 对合并生成的新节点，做一个标签</p>
<pre><code> git tag -a 1.2  -m “1.2版本”</code></pre>
<p>再合并到develop分支并删除预发布分支</p>
<pre><code> git checkout develop
 git merge --no-ff release_1.2.1
 git branch -d release_1.2.1</code></pre>
<h5>hotfix分支</h5>
<p>修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。<br>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug_xx的形式。<br>创建一个修补bug分支</p>
<p># 切换到 master 分支</p>
<pre><code>git checkout master</code></pre>
<p># 创建bug分支</p>
<pre><code> git checkout -b hotfix_0.1</code></pre>
<p>修补结束后，合并到master分支</p>
<pre><code> git checkout master
 git merge --no-ff hotfix_0.1
 git tag -a 0.1.1 -m ""添加tag0.1.1""</code></pre>
<p>合并到develop分支然后删除bug分支</p>
<pre><code> git checkout develop
 git merge --no-ff hotfix_0.1
 git branch -d hotfix_0.1</code></pre>
<p>参考原文： A successful Git branching model<br><a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer"">http://nvie.com/posts/a-successful-git-branching-model/</a><br>小福利 ：git命令别名(部分)特别是在命令较长时通过别名可以节省很多时间。在.gitconfig [alias]栏 中配置</p>
<pre><code> co = checkout #切换分支
 cm = commit  #提交
 br = branch  #查看分支
 st = status  #查看状态
 ad = add  # 添加新增或者修改的文件到git
 pl = pull  # 拉分支 更新操作
 ps = push  # 推分支
 bdm = ""!git branch --merged | grep -v '*' | xargs -n 1 git branch -d"" #删除已经合并到了当前分支的分支
 #log catch
 logp = log --graph --pretty=oneline --abbrev-commit
 sref = for-each-ref --sort=-committerdate --format='%(committerdate:short) %(refname:short) ""%(subject)"" [%(committername)]'
 # Complex aliases
 plog = log --graph --pretty='format:%C(red)%d%C(reset) %C(yellow)%h%C(reset) %ar %C(green)%aN%C(reset) %s'
 tlog = log --stat --since='1 Day Ago' --graph --pretty=oneline --abbrev-commit --date=relative
 lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit
 rank = shortlog -sn --no-merges
 bdm = ""!git branch --merged | grep -v '*' | xargs -n 1 git branch -d""</code></pre>
<p>使用 如: git st 等于 git status</p>

                ", Git 分支管理,1531977949,494,1,552,1,1,https://segmentfault.com/a/1190000005730658
200,1,0,7,"
                    
<p>之前的这篇文章「<a href=""http://stormzhang.com/github/2016/05/30/learn-github-from-zero3/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「Git速成」</a>」相信大家都已经对 Git 的基本操作熟悉了，但是这篇文章只介绍了对本地 Git 仓库的基本操作，今天我就来介绍下如何跟远程仓库一起协作，教你们向 GitHub 上提交你们的第一行代码！</p>
<h2>1. SSH</h2>
<p>你拥有了一个 GitHub 账号之后，就可以自由的 clone 或者下载其他项目，也可以创建自己的项目，但是你没法提交代码。仔细想想也知道，肯定不可能随意就能提交代码的，如果随意可以提交代码，那么 GitHub 上的项目岂不乱了套了，所以提交代码之前一定是需要某种授权的，而 GitHub 上一般都是基于 SSH 授权的。</p>
<p>那么什么是 SSH 呢？<br>简单点说，SSH是一种网络协议，用于计算机之间的加密登录。目前是每一台 Linux 电脑的标准配置。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。</p>
<h2>2. 生成SSH key</h2>
<p>Linux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win下在 Git Bash 里）输入 ssh 如果出现以下提示证明你本机已经安装 SSH， 否则请搜索自行安装下。</p>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/ssh.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>紧接着输入 <strong>ssh-keygen -t rsa</strong> ，什么意思呢？就是指定 rsa 算法生成密钥，接着连续三个回车键（不需要输入密码），然后就会生成两个文件 id_rsa 和 id_rsa.pub ，而 id_rsa 是密钥，id_rsa.pub 就是公钥。这两文件默认分别在如下目录里生成：</p>
<p>Linux/Mac 系统 在 <strong>~/.ssh</strong> 下，win系统在 <strong>/c/Documents and Settings/username/.ssh</strong> 下，都是隐藏文件，相信你们有办法查看的。</p>
<p>接下来要做的是把 id_rsa.pub 的内容添加到 GitHub 上，这样你本地的 id_rsa 密钥跟 GitHub 上的 id_rsa.pub 公钥进行配对，授权成功才可以提交代码。</p>
<h2>3. GitHub 上添加 SSH key</h2>
<p>第一步先在 GitHub 上的设置页面，点击最左侧 SSH and GPG keys ：</p>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/github_sshkey.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后点击右上角的 New SSH key 按钮：</p>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/github_ssh2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>需要做的只是在 Key 那栏把 id_rsa.pub 公钥文件里的内容复制粘贴进去就可以了（上述示例为了安全粘贴的公钥是无效的），Title 那栏不需要填写，点击 Add SSH key 按钮就ok了。</p>
<p>这里提醒下，怎么查看 id_rsa.pub 文件的内容？</p>
<p>Linux/Mac 用户执行以下命令：</p>
<pre><code>cd ~/.ssh
cat id_rsa.pub
</code></pre>
<p>Windows用户，设置显示隐藏文件，可以使用 EditPlus 或者 Sublime 打开复制就行了。</p>
<p>SSH key 添加成功之后，输入 <strong>ssh -T git@github.com</strong> 进行测试，如果出现以下提示证明添加成功了。</p>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/ssh_test.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>4. Push &amp; Pull</h2>
<p>在提交代码之前我们先要了解两个命令，也是上次的文章没有介绍的，因为这两个命令需要跟远程仓库配合。</p>
<p>Push ：直译过来就是「推」的意思，什么意思呢？如果你本地代码有更新了，那么就需要把本地代码推到远程仓库，这样本地仓库跟远程仓库就可以保持同步了。</p>
<p>代码示例： <strong>git push origin master</strong></p>
<p>意思就是把本地代码推到远程 master 分支。</p>
<p>Pull：直译过来就是「拉」的意思，如果别人提交代码到远程仓库，这个时候你需要把远程仓库的最新代码拉下来，然后保证两端代码的同步。</p>
<p>代码示例： <strong>git pull origin master</strong></p>
<p>意思就是把远程最新的代码更新到本地。一般我们在 push 之前都会先 pull ，这样不容易冲突。</p>
<h2>5. 提交代码</h2>
<p>添加 SSH key 成功之后，我们就有权限向 GitHub 上我们自己的项目提交代码了，而提交代码有两种方法：</p>
<p>Clone自己的项目<br>我们以我在 GitHub 上创建的 test 项目为例，执行如下命令：</p>
<pre><code>git clone git@github.com:stormzhang/test.git
</code></pre>
<p>这样就把 test 项目 clone 到了本地，你可以把 clone 命令理解为高级点的复制，这个时候该项目本身就已经是一个git 仓库了，不需要执行 <strong>git init</strong> 进行初始化，而且甚至都已经关联好了远程仓库，我们只需要在这个 test 目录下任意修改或者添加文件，然后进行 commit ，之后就可以执行：</p>
<pre><code>git push origin master
</code></pre>
<p>进行代码提交，这种是最简单方便的一种方式。</p>
<p>至于怎么获取项目的仓库地址呢？如下图：</p>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/test_clone.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>关联本地已有项目<br>如果我们本地已经有一个完整的 git 仓库，并且已经进行了很多次 commit ，这个时候第一种方法就不适合了。</p>
<p>假设我们本地有个 test2 的项目，我们需要的是在 GitHub 上建一个 test 的项目，然后把本地 test2 上的所有代码 commit 记录提交到 GitHub 上的 test 项目。</p>
<p>第一步就是在 GitHub 上建一个 test 项目，这个想必大家都会了，就不用多讲了。</p>
<p>第二步把本地 test2 项目与 GitHub 上的 test 项目进行关联，切换到 test2 目录，执行如下命令：</p>
<pre><code>git remote add origin git@github.com:stormzhang/test.git
</code></pre>
<p>什么意思呢？就是添加一个远程仓库，他的地址是 <strong>git@github.com:stormzhang/test.git</strong> ，而 origin 是给这个项目的远程仓库起的名字，是的，名字你可以随便取，只不过大家公认的只有一个远程仓库时名字就是 origin ，为什么要给远程仓库取名字？因为我们可能一个项目有多个远程仓库？比如 GitHub 一个，比如公司一个，这样的话提交到不同的远程仓库就需要指定不同的仓库名字了。</p>
<p>查看我们当前项目有哪些远程仓库可以执行如下命令：</p>
<pre><code>git remote -v
</code></pre>
<p>接下来，我们本地的仓库就可以向远程仓库进行代码提交了：</p>
<pre><code>git push origin master
</code></pre>
<p>就是默认向 GitHub 上的 test 目录提交了代码，而这个代码是在 master 分支。当然你可以提交到指定的分支，这个之后的文章再详细讲解。</p>
<p>对了，友情提醒，在提交代码之前先要设置下自己的用户名与邮箱，这些信息会出现在所有的 commit 记录里，执行以下代码就可以设置：</p>
<pre><code>git config —global user.name ""stormzhang""
git config —global user.email ""stormzhang.dev@gmail.com""
</code></pre>
<h2>6. 总结</h2>
<p>通过本文的介绍，终于大家可以成功的向 GitHub 提交代码了，但是相信大家还有很多疑问，比如关于分支的理解与使用，比如 git 的其他一些有用的配置，比如怎么向一些开源项目贡献代码，发起 Pull Request 等，之后的系列文章会逐一进行介绍，敬请期待。</p>
<p>PS：昨天的文章「<a href=""http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661814&amp;idx=1&amp;sn=853c880e447ae595c6836218a26868a1#rd"" rel=""nofollow noreferrer"">如何在一群程序员中识别Android开发？</a>」，是我写这么多文章以来第一次没有一个反对意见的，回复全是清一色的「有理有据，深度好文」，还有表示「看了我的文章后特意去照了下镜子，突然发现说的太他妈对了」，还有说「终于找到了为什么一开始就选中 Android 的原因了」，我只能说，低调低调！</p>
<p>PS：以前你们生日的时候都在我文章底下评论求祝福，我给你们祝福过，号召点赞过，甚至还给有些人发过红包，其实我想说，28年前的今天，一位伟大的程序员诞生了，因为天生长得帅，所以命中注定选择了 Android 开发，今天终于轮到我生日了，还特意给你们准备了一篇干货，你们看着办吧!</p>
<h4>相关文章：</h4>
<p><a href=""http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「初识 GitHub」</a></p>
<p><a href=""http://stormzhang.com/github/2016/05/26/learn-github-from-zero2/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「加入 GitHub」</a></p>
<p><a href=""http://stormzhang.com/github/2016/05/30/learn-github-from-zero3/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「Git 速成」</a></p>
<p><br></p>
<blockquote><p>本文原创发布于微信公众号 <strong>AndroidDeveloper「googdev」</strong>，转载请务必注明出处！</p></blockquote>
<p><span class=""img-wrap""><img data-src=""http://stormzhang.com/image/weixinpublic.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 从0开始学习 GitHub 系列之「向GitHub 提交代码」,1531977951,187,1,262,1,1,https://segmentfault.com/a/1190000005713288
201,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006773192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>前面的 GitHub 系列文章介绍过，GitHub 是基于 Git 的，所以也就意味着 Git 是基础，如果你不会 Git ，那么接下来你完全继续不下去，所以今天的教程就来说说 Git ，当然关于 Git 的知识单凭一篇文章肯定说不完的，我这篇文章先介绍一些最基本的、最常用的一些 Git 知识，争取让你们 Git 速成。</p>
<h2>1. 什么是Git？</h2>
<p>Git 是 Linux 发明者 Linus 开发的一款新时代的版本控制系统，那什么是版本控制系统呢？怎么理解？网上一大堆详细的介绍，但是大多枯燥乏味，对于新手也很难理解，这里我只举几个例子来帮助你们理解。</p>
<p>熟悉编程的知道，我们在软件开发中源代码其实是最重要的，那么对源代码的管理变得异常重要：</p>
<p>比如为了防止代码的丢失，肯定本地机器与远程服务器都要存放一份，而且还需要有一套机制让本地可以跟远程同步；</p>
<p>又比如我们经常是好几个人做同一个项目，都要对一份代码做更改，这个时候需要大家互不影响，又需要各自可以同步别人的代码；</p>
<p>又比如我们开发的时候免不了有bug，有时候刚发布的功能就出现了严重的bug，这个时候需要紧急对代码进行还原；</p>
<p>又比如随着我们版本迭代的功能越来越多，但是我们需要清楚的知道历史每一个版本的代码更改记录，甚至知道每个人历史提交代码的情况；</p>
<p>等等等类似以上的情况，这些都是版本控制系统能解决的问题。所以说，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，对于软件开发领域来说版本控制是最重要的一环，而 Git 毫无疑问是当下最流行、最好用的版本控制系统。</p>
<h2>2. Git 安装</h2>
<p>上面说了，Git 是一个版本控制系统，你也可以理解成是一个工具，跟 Java 类似，使用之前必须得先下载安装，所以第一步必须要安装，我用的是 Mac ， Mac 上其实系统自带 Git 的，不过这里统一提供一下各平台的安装方式，这部分就不过多介绍，相信大家这里搞的定。</p>
<ul>
<li><p>Mac：<a href=""https://sourceforge.net/projects/git-osx-installer/"" rel=""nofollow noreferrer"">https://sourceforge.net/projects/git-osx-installer/</a></p></li>
<li><p>Windows：<a href=""https://git-for-windows.github.io/"" rel=""nofollow noreferrer"">https://git-for-windows.github.io/</a></p></li>
<li><p>Linux：apt-get install git</p></li>
</ul>
<h2>3. 如何学习 Git ？</h2>
<p>安装好 Git 之后，怎么学习是个问题，其实关于 Git 有很多图形化的软件可以操作，但是我强烈建议大家从命令行开始学习理解，我知道没接触过命令行的人可能会很抵触，但是我的亲身实践证明，只有一开始学习命令行，之后你对 Git 的每一步操作才能理解其意义，而等你熟练之后你想用任何的图形化的软件去操作完全没问题。</p>
<p>我一开始教我们团队成员全是基于命令行的，事后证明他们现在已经深深爱上命令行无法自拔，他们很理解 Git 每一步操作的具体含义，以致于在实际项目很少犯错，所以我这里也是基于命令行去教你们学习理解。</p>
<h2>4. Git 命令列表</h2>
<p>怎么判断你 Git 有没有安装成功？请在命令行里输入 git ，如果出现以下提示证明你已经安装成功了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713235"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Git 所有的操作命令开头都要以 git 开头，上面列举了最常用的一些 Git 命令，紧接着会有一句英文解释这个命令的意义，都不是很难的单词，不妨试着看一下，不过没有实际操作你仍然不好理解，下面我们来以一个实际的操作来介绍下一些常用命令的含义。</p>
<h2>5. Git 具体命令</h2>
<p>第一步，我们先新建一个文件夹，在文件夹里新建一个文件（我是用 Linux 命令去新建的，Windows用户可以自己手动新建）</p>
<p>mkdir test    （创建文件夹test）<br>cd test    （切换到test目录）<br>touch a.md    （新建a.md文件）</p>
<p>这里提醒下：在进行任何 Git 操作之前，都要先切换到 Git 仓库目录，也就是先要先切换到项目的文件夹目录下。</p>
<p>这个时候我们先随便操作一个命令，比如 git status ，可以看到如下提示（别纠结颜色之类的，配置与主题不一样而已）：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713237"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>意思就是当前目录还不是一个 Git 仓库。</p>
<h4>git init</h4>
<p>这个时候用到了第一个命令，代表初始化 git 仓库，输入 git init 之后会提示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713239"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到初始化成了，至此 test 目录已经是一个 git 仓库了。</p>
<h4>git status</h4>
<p>紧接着我们输入 git status 命令，会有如下提示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713241"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>默认就直接在 master 分支，关于分支的概念后面会提，这时最主要的是提示 a.md 文件 Untracked files ，就是说 a.md 这个文件还没有被跟踪，还没有提交在 git 仓库里呢，而且提示你可以使用 git add &lt;file&gt; 去操作你想要提交的文件。</p>
<p>git status 这个命令顾名思义就是查看状态，这个命令可以算是使用最频繁的一个命令了，建议大家没事就输入下这个命令，来查看你当前 git 仓库的一些状态。</p>
<h4>git add</h4>
<p>上面提示 a.md 文件还没有提交到 git 仓库里，这个时候我们可以随便编辑下 a.md 文件，然后输入 git add a.md ，然后再输入 git status :</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713243"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此时提示以下文件 Changes to be committed ， 意思就是 a.md 文件等待被提交，当然你可以使用 git rm --cached 这个命令去移除这个缓存。</p>
<h4>git commit</h4>
<p>接着我们输入 git commit -m 'first commit' ，这个命令什么意思呢？ commit 是提交的意思，-m 代表是提交信息，执行了以上命令代表我们已经正式进行了第一次提交。</p>
<p>这个时候再输入 git status ，会提示 nothing to commit。</p>
<h4>git log</h4>
<p>这个时候我们输入 git log 命令，会看到如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713245"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>git log 命令可以查看所有产生的 commit 记录，所以可以看到已经产生了一条 commit 记录，而提交时候的附带信息叫 'first commit' 。</p>
<h4>git add &amp; git commit</h4>
<p>看到这里估计很多人会有疑问，我想要提交直接进行 commit 不就行了么，为什么先要再 add 一次呢？首先 git add 是先把改动添加到一个「暂存区」，你可以理解成是一个缓存区域，临时保存你的改动，而 git commit 才是最后真正的提交。这样做的好处就是防止误提交，当然也有办法把这两步合并成一步，不过后面再介绍，建议新手先按部就班的一步步来。</p>
<h4>git branch</h4>
<p>branch 即分支的意思，分支的概念很重要，尤其是团队协作的时候，假设两个人都在做同一个项目，这个时候分支就是保证两人能协同合作的最大利器了。举个例子，A, B俩人都在做同一个项目，但是不同的模块，这个时候A新建了一个分支叫a， B新建了一个分支叫b，这样A、B做的所有代码改动都各自在各自的分支，互不影响，等到俩人都把各自的模块都做完了，最后再统一把分支合并起来。</p>
<p>执行 git init 初始化git仓库之后会默认生成一个主分支 master ，也是你所在的默认分支，也基本是实际开发正式环境下的分支，一般情况下 master 分支不会轻易直接在上面操作的，你们可以输入 git branch 查看下当前分支情况：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713248"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如果我们想在此基础上新建一个分支呢，很简单，执行 git branch a 就新建了一个名字叫 a 的分支，这时候分支 a 跟分支 master 是一模一样的内容，我们再输入 git branch 查看的当前分支情况：</p>
<p><span class=""img-wrap""><img data-src=""/image/git8.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>但是可以看到 master 分支前有个 * 号，即虽然新建了一个 a 的分支，但是当前所在的分支还是在 master 上，如果我们想在 a 分支上进行开发，首先要先切换到 a 分支上才行，所以下一步要切换分支</p>
<p>git checkout a</p>
<p>执行这个命令，然后再输入 git branch 查看下分支情况：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713250"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到当前我们在的分支已经是a了，这个时候 A 同学就可以尽情的在他新建的a分支去进行代码改动了。</p>
<p>那有人就说了，我要先新建再切换，未免有点麻烦，有没有一步到位的，聪明：</p>
<p>git checkout -b a</p>
<p>这个命令的意思就是新建一个a分支，并且自动切换到a分支。</p>
<h4>git merge</h4>
<p>A同学在a分支代码写的不亦乐乎，终于他的功能完工了，并且测试也都ok了，准备要上线了，这个时候就需要把他的代码合并到主分支master上来，然后发布。git merge 就是合并分支用到的命令，针对这个情况，需要先做两步，第一步是切换到 master 分支，如果你已经在了就不用切换了，第二步执行 git merge a ，意思就是把a分支的代码合并过来，不出意外，这个时候a分支的代码就顺利合并到 master 分支来了。为什么说不出意外呢？因为这个时候可能会有冲突而合并失败，留个包袱，这个到后面进阶的时候再讲。</p>
<h4>git branch -d</h4>
<p>有新建分支，那肯定有删除分支，假如这个分支新建错了，或者a分支的代码已经顺利合并到 master 分支来了，那么a分支没用了，需要删除，这个时候执行 git branch -d a 就可以把a分支删除了。</p>
<h4>git branch -D</h4>
<p>有些时候可能会删除失败，比如如果a分支的代码还没有合并到master，你执行 git branch -d a 是删除不了的，它会智能的提示你a分支还有未合并的代码，但是如果你非要删除，那就执行 git branch -D a 就可以强制删除a分支。</p>
<h4>git tag</h4>
<p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不同的代码，所以我一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又不晓得v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试了。</p>
<p>所以如果想要新建一个标签很简单，比如 git tag v1.0 就代表我在当前代码状态下新建了一个v1.0的标签，输入 git tag 可以查看历史 tag 记录。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005713255"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到我新建了两个标签 v1.0、v1.1。</p>
<p>想要切换到某个tag怎么办？也很简单，执行 git checkout v1.0 ，这样就顺利的切换到 v1.0 tag的代码状态了。</p>
<p>OK，以上全是一些最基本的Git操作，而且全是在本地环境进行操作的，完全没有涉及到远程仓库，下一章节将以远程 GitHub 仓库为例，讲解下本地如何跟远程仓库一起同步协作，另外今天讲的全是最基础最简单的Git操作，一步步来，后续再继续讲解一下Git的高阶以及一些Git的酷炫操作。</p>
<p>另外，考虑到可能会有人嫌我讲解的太基础太慢，毕竟我是针对小白，所以得一步步来，迫不及待的想要提前自己学习的不妨在我公众号 AndroidDeveloper 回复「git」关键字，获取一份我推荐的还不错的 Git 学习资料，不谢，毕竟我这么帅！</p>
<h4>相关文章：</h4>
<p><a href=""http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「初识 GitHub」</a></p>
<p><a href=""http://stormzhang.com/github/2016/05/26/learn-github-from-zero2/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「加入 GitHub」</a></p>
<p><br></p>
<blockquote><p>本文原创发布于微信公众号 <strong>AndroidDeveloper「googdev」</strong>，转载请务必注明出处！</p></blockquote>

                ", 从0开始学习 GitHub 系列之「Git 速成」,1531977953,372,1,744,1,1,https://segmentfault.com/a/1190000005713232
202,1,0,7,"
                    
<blockquote><p><a href=""https://github.com/git-tips/tips"" rel=""nofollow noreferrer"">原文地址</a>，笔者将原Repo上的命令进行了整理，希望能有所帮助。不过这种分类方式只是笔者自己总结的，包括一些说明若存在谬误请及时指教。<br><a href=""https://github.com/wxyyxc1992/just-coder-handbook/blob/master/VersionControl/Git/Practice/git-tips.md"" rel=""nofollow noreferrer"">Github 系列文章地址</a></p></blockquote>
<h1>Configuration:配置</h1>
<ul><li><p>列举所有的别名与配置</p></li></ul>
<pre><code>git config --list</code></pre>
<ul><li><p>Git 别名配置</p></li></ul>
<pre><code>git config --global alias.&lt;handle&gt; &lt;command&gt; git config --global alias.st status
</code></pre>
<ul><li><p>设置git为大小写敏感</p></li></ul>
<pre><code>git config --global core.ignorecase false</code></pre>
<h2>User</h2>
<h2>Help:常用的辅助查询命令</h2>
<ul><li><p>在git 命令行里查看everyday git</p></li></ul>
<pre><code>git help everyday</code></pre>
<ul><li><p>显示git常用的帮助命令</p></li></ul>
<pre><code>git help -g</code></pre>
<ul><li><p>获取Git Bash的自动补全</p></li></ul>
<pre><code>curl http://git.io/vfhol &gt; ~/.git-completion.bash &amp;&amp; echo '[ -f ~/.git-completion.bash ] &amp;&amp; . ~/.git-completion.bash' &gt;&gt; ~/.bashrc</code></pre>
<ul><li><p>设置自动更正</p></li></ul>
<pre><code>git config --global help.autocorrect 1</code></pre>
<h2>Remote:远端仓库配置</h2>
<ul><li><p>获取所有远端引用配置</p></li></ul>
<pre><code>git remote</code></pre>
<p>或者</p>
<pre><code>git remote show</code></pre>
<ul><li><p>修改某个远端的地址</p></li></ul>
<pre><code>git remote set-url origin &lt;URL&gt;</code></pre>
<h2>Repo</h2>
<ul><li><p>查看当前仓库中的所有未打包的objects和磁盘占用</p></li></ul>
<pre><code>git count-objects --human-readable</code></pre>
<ul><li><p>从object数据库中删除所有不可达的object</p></li></ul>
<pre><code>git gc --prune=now --aggressive</code></pre>
<h1>Cache:缓存</h1>
<h2>Track:文件追踪</h2>
<h3>Info</h3>
<ul><li><p>展示所有被追踪的文件</p></li></ul>
<pre><code>git ls-files -t</code></pre>
<ul><li><p>展示所有未被追踪的分支</p></li></ul>
<pre><code>git ls-files --others</code></pre>
<ul><li><p>展示所有被忽略的文件</p></li></ul>
<pre><code>git ls-files --others -i --exclude-standard
git check-ignore *
git status --ignored</code></pre>
<h3>Manipulation:操作</h3>
<ul><li><p>停止追踪某个文件但是不删除它</p></li></ul>
<pre><code>git rm --cached &lt;file_path&gt;</code></pre>
<p>或者</p>
<pre><code>git rm --cached -r &lt;directory_path&gt;</code></pre>
<ul><li><p>强制删除未被追踪的文件或者目录</p></li></ul>
<pre><code>git clean -f
git clean -f -d
git clean -df</code></pre>
<ul><li><p>清空<code>.gitignore</code></p></li></ul>
<pre><code>git clean -X -f</code></pre>
<h2>Changes:修改</h2>
<h3>Info:信息查看</h3>
<ul><li><p>查看上次提交之后的未暂存文件</p></li></ul>
<pre><code>git diff</code></pre>
<ul><li><p>查看准备用于提交的暂存了的修改的文件</p></li></ul>
<pre><code>git diff --cached</code></pre>
<ul><li><p>显示所有暂存与未暂存的文件</p></li></ul>
<pre><code>git diff HEAD</code></pre>
<ul><li><p>查看最新的文件版本与Stage中区别</p></li></ul>
<pre><code>git diff --staged</code></pre>
<h3>Add:追踪某个修改，准备提交</h3>
<ul><li><p>Stage某个文件的部分修改而不是全部</p></li></ul>
<pre><code>git add -p</code></pre>
<h3>Reset:修改重置</h3>
<ul><li><p>以HEAD中的最新的内容覆盖某个本地文件的修改</p></li></ul>
<pre><code>git checkout -- &lt;file_name&gt;</code></pre>
<h2>Stash:贮存</h2>
<h3>Info:信息查看</h3>
<ul><li><p>展示所有保存的Stashes</p></li></ul>
<pre><code>git stash list</code></pre>
<h3>Manipulation:操作</h3>
<h4>Save:保存</h4>
<ul><li><p>保存当前追踪的文件修改状态而不提交，并使得工作空间恢复干净</p></li></ul>
<pre><code>git stash</code></pre>
<p>或者</p>
<pre><code>git stash save</code></pre>
<ul><li><p>保存所有文件修改，包括未追踪的文件</p></li></ul>
<pre><code>git stash save -u</code></pre>
<p>或者</p>
<pre><code>git stash save --include-untracked</code></pre>
<h4>Apply:应用</h4>
<ul><li><p>应用任何的Stash而不从Stash列表中删除</p></li></ul>
<pre><code>git stash apply &lt;stash@{n}&gt;</code></pre>
<ul><li><p>应用并且删除Stash列表中的最后一个</p></li></ul>
<pre><code>git stash pop</code></pre>
<p>或者</p>
<pre><code>git stash apply stash@{0} &amp;&amp; git stash drop stash@{0}</code></pre>
<ul><li><p>删除全部存储的Stashes</p></li></ul>
<pre><code>git stash clear</code></pre>
<p>或者</p>
<pre><code>git stash drop &lt;stash@{n}&gt;</code></pre>
<ul><li><p>从某个Stash中应用单个文件</p></li></ul>
<pre><code>git checkout &lt;stash@{n}&gt; -- &lt;file_path&gt;</code></pre>
<p>或者</p>
<pre><code>git checkout stash@{0} -- &lt;file_path&gt;</code></pre>
<h1>Commit:提交</h1>
<ul><li><p>检索某个提交的Hash值</p></li></ul>
<pre><code>git rev-list --reverse HEAD | head -1</code></pre>
<h2>Info:信息查看</h2>
<h3>List:Commit列表</h3>
<ul><li><p>查看自Fork Master以来的全部提交</p></li></ul>
<pre><code>git log --no-merges --stat --reverse master..</code></pre>
<ul><li><p>展示当前分支中所有尚未合并到Master中的提交</p></li></ul>
<pre><code>git cherry -v master</code></pre>
<p>或者</p>
<pre><code>git cherry -v master &lt;branch-to-be-merged&gt;</code></pre>
<ul><li><p>可视化地查看整个Version树</p></li></ul>
<pre><code>git log --pretty=oneline --graph --decorate --all</code></pre>
<p>或者</p>
<pre><code>gitk -all</code></pre>
<ul><li><p>查看所有在分支1而不在分支2中的提交</p></li></ul>
<pre><code>git log Branch1 ^Branch2</code></pre>
<h3>Files:文件信息</h3>
<ul><li><p>展示直到某次提交的全部文件列表</p></li></ul>
<pre><code>git ls-tree --name-only -r &lt;commit-ish&gt;</code></pre>
<ul><li><p>展示所有在某次提交中修改的文件</p></li></ul>
<pre><code>git diff-tree --no-commit-id --name-only -r &lt;commit-ish&gt;</code></pre>
<ul><li><p>展示所有对于某个文件的提交修改</p></li></ul>
<pre><code>git log --follow -p -- &lt;file_path&gt;</code></pre>
<h2>Manipulation:关于提交的操作</h2>
<h3>Apply:Commit确认或者应用</h3>
<ul><li><p>利用cherry-pick将某个分支的某个提交跨分支的应用到其他分支</p></li></ul>
<pre><code>git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-ish&gt;</code></pre>
<ul><li><p>提交时候忽略Staging区域</p></li></ul>
<pre><code>git commit -am &lt;commit message&gt;</code></pre>
<ul><li><p>提交时候忽略某个文件</p></li></ul>
<pre><code>git update-index --assume-unchanged Changelog; 
git commit -a; 
git update-index --no-assume-unchanged Changelog</code></pre>
<ul><li><p>撤销某个故意忽略</p></li></ul>
<pre><code>git update-index --no-assume-unchanged &lt;file_name&gt;</code></pre>
<ul><li><p>将某个提交标记为对之前某个提交的Fixup</p></li></ul>
<pre><code>git commit --fixup &lt;SHA-1&gt;
</code></pre>
<h3>Reset:将当前分支的HEAD重置到某个提交时候的状态</h3>
<ul><li><p>重置HEAD到第一次提交</p></li></ul>
<pre><code>git update-ref -d HEAD</code></pre>
<ul><li><p>丢弃自某个Commit之后的提交，建议只在私有分支上进行操作。注意，和上一个操作一样，重置不会修改当前的文件状态，Git会自动将当前文件与该Commit时候的改变作为Changes列举出来</p></li></ul>
<pre><code>git reset &lt;commit-ish&gt;</code></pre>
<h3>Undo&amp;Revert:撤销与恢复某个Commit</h3>
<ul><li><p>以创建一个新提交的方式撤销某个提交的操作</p></li></ul>
<pre><code>git revert &lt;commit-ish&gt;</code></pre>
<ul><li><p>恢复某个文件到某个Commit时候的状态</p></li></ul>
<pre><code>git checkout &lt;commit-ish&gt; -- &lt;file_path&gt;</code></pre>
<h3>Update:修改某个Commit</h3>
<ul><li><p>修改上一个提交的信息</p></li></ul>
<pre><code>git commit -v --amend</code></pre>
<ul><li><p>修改提交的作者信息</p></li></ul>
<pre><code>git commit --amend --author='Author Name &lt;email@address.com&gt;'</code></pre>
<ul><li><p>在全局的配置改变了之后，修改某个作者信息</p></li></ul>
<pre><code>git commit --amend --reset-author --no-edit</code></pre>
<ul><li><p>修改前一个Commit的提交内容但是不修改提交信息</p></li></ul>
<pre><code>git add --all &amp;&amp; git commit --amend --no-edit</code></pre>
<h1>Branch:分支</h1>
<h2>Info:信息查看</h2>
<ul><li><p>获取当前分支名</p></li></ul>
<pre><code>git rev-parse --abbrev-ref HEAD</code></pre>
<h3>Tag</h3>
<ul><li><p>列举当前分支上最常用的标签</p></li></ul>
<pre><code>git describe --tags --abbrev=0</code></pre>
<h3>List:分支枚举</h3>
<ul><li><p>获取所有本地与远程的分支</p></li></ul>
<pre><code>git branch -a</code></pre>
<ul><li><p>只展示远程分支</p></li></ul>
<pre><code>git branch -r</code></pre>
<ul><li><p>根据某个Commit的Hash来查找所有关联分支</p></li></ul>
<pre><code>git branch -a --contains &lt;commit-ish&gt;</code></pre>
<p>或者</p>
<pre><code>git branch --contains &lt;commit-ish&gt;</code></pre>
<h3>Changes:某个分支上的修改情况查看</h3>
<ul><li><p>查看两周以来的所有修改</p></li></ul>
<pre><code>git log --no-merges --raw --since='2 weeks ago'</code></pre>
<p>或者</p>
<pre><code>git whatchanged --since='2 weeks ago'</code></pre>
<h3>Merger:合并情况查看</h3>
<ul><li><p>追踪某个分支的上游分支</p></li></ul>
<pre><code>git branch -u origin/mybranch</code></pre>
<ul><li><p>列举出所有的分支以及它们的上游和最后一次提交</p></li></ul>
<pre><code>git branch -vv</code></pre>
<ul><li><p>列举出所有已经合并进入Master的分支</p></li></ul>
<pre><code>git branch --merged master</code></pre>
<h2>Manipulation:操作</h2>
<h3>Checkout:检出与分支切换</h3>
<ul><li><p>快速切换到上一个分支</p></li></ul>
<pre><code>git checkout -</code></pre>
<ul><li><p>不带历史记录的检出某个分支</p></li></ul>
<pre><code>git checkout --orphan &lt;branch_name&gt;</code></pre>
<h3>Remove:分支移除</h3>
<ul><li><p>删除本地分支</p></li></ul>
<pre><code>git branch -d &lt;local_branchname&gt;</code></pre>
<ul><li><p>删除远程分支</p></li></ul>
<pre><code>git push origin --delete &lt;remote_branchname&gt;</code></pre>
<p>或者</p>
<pre><code>git push origin :&lt;remote_branchname&gt;</code></pre>
<ul><li><p>移除所有已经合并进入Master的分支</p></li></ul>
<pre><code>git branch --merged master | grep -v '^\*' | xargs -n 1 git branch -d</code></pre>
<ul><li><p>移除所有在远端已经被删除的远程分支</p></li></ul>
<pre><code>git fetch -p</code></pre>
<p>或者</p>
<pre><code>git remote prune origin</code></pre>
<h3>Update:信息更新</h3>
<ul><li><p>修改当前分支名</p></li></ul>
<pre><code>git branch -m &lt;new-branch-name&gt;</code></pre>
<p>或者</p>
<pre><code>git branch -m [&lt;old-branch-name&gt;] &lt;new-branch-name&gt;</code></pre>
<h3>Archive:打包</h3>
<ul><li><p>将Master分支打包</p></li></ul>
<pre><code>git archive master --format=zip --output=master.zip</code></pre>
<ul><li><p>将历史记录包括分支内容打包到一个文件中</p></li></ul>
<pre><code>git bundle create &lt;file&gt; &lt;branch-name&gt;</code></pre>
<ul><li><p>从某个Bundle中导入</p></li></ul>
<pre><code>git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
</code></pre>
<h1>Merge:合并</h1>
<h2>Pull&amp;Push:远程分支合并操作</h2>
<ul><li><p>用pull覆盖本地内容</p></li></ul>
<pre><code>git fetch --all &amp;&amp; git reset --hard origin/master</code></pre>
<ul><li><p>根据Pull的ID拉取某个Pull请求到本地分支</p></li></ul>
<pre><code>git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</code></pre>
<p>或者</p>
<pre><code>git pull origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</code></pre>
<h2>Rebase:变基</h2>
<ul><li><p>在Pull时候强制用变基进行操作</p></li></ul>
<pre><code>git config --global branch.autosetuprebase always</code></pre>
<ul><li><p>将某个feature分支变基到master，然后合并进master</p></li></ul>
<pre><code>git checkout feature &amp;&amp; git rebase @{-1} &amp;&amp; git checkout @{-2} &amp;&amp; git merge @{-1}</code></pre>
<ul><li><p>变基之前自动Stash所有改变</p></li></ul>
<pre><code>git rebase --autostash</code></pre>
<ul><li><p>利用变基自动将fixup提交与正常提交合并</p></li></ul>
<pre><code>git rebase -i --autosquash</code></pre>
<ul><li><p>利用ReBase将前两个提交合并</p></li></ul>
<pre><code>git rebase --interactive HEAD~2</code></pre>
<h2>Diff&amp;Conflict:差异与冲突</h2>
<h3>Info:信息查看</h3>
<ul><li><p>列举全部的冲突文件</p></li></ul>
<pre><code>git diff --name-only --diff-filter=U</code></pre>
<ul><li><p>在编辑器中打开所有冲突文件</p></li></ul>
<pre><code>git diff --name-only | uniq | xargs $EDITOR</code></pre>
<h1>Workflow:工作流</h1>
<h2>SubModules:子模块</h2>
<h3>Info:信息查看</h3>
<h3>Manipulation:操作</h3>
<ul><li><p>利用SubTree方式将某个Project添加到Repo中</p></li></ul>
<pre><code>git subtree add --prefix=&lt;directory_name&gt;/&lt;project_name&gt; --squash git@github.com:&lt;username&gt;/&lt;project_name&gt;.git master</code></pre>
<ul><li><p>更新所有的子模块</p></li></ul>
<pre><code>git submodule foreach git pull</code></pre>
<h2>Work Tree</h2>
<h3>Manipulation:操作</h3>
<ul><li><p>从某个仓库中创建一个新的Working Tree</p></li></ul>
<pre><code>git worktree add -b &lt;branch-name&gt; &lt;path&gt; &lt;start-point&gt;</code></pre>
<ul><li><p>从HEAD状态中创建一个新的Working Tree</p></li></ul>
<pre><code>git worktree add --detach &lt;path&gt; HEAD</code></pre>

                ", 常用的几十个Git小技巧分类与总结,1531977954,465,1,828,1,1,https://segmentfault.com/a/1190000005706707
203,1,0,7,"
                    
<h1>1. Git 的玩法</h1>
<p>欢迎来到 Coding 技术小馆，我叫谭贺贺，目前我在 Coding.net 主要负责 <a href=""https://ide.coding.net"" rel=""nofollow noreferrer"">WebIDE</a> 与 <a href=""https://src.coding.net"" rel=""nofollow noreferrer"">Codeinsight</a> 的开发。我今天带来的主要内容是 Git 的原理与使用。</p>
<p>谈起 git，大家的第一印象无非是和 svn 一样的版本控制系统，但其实，他们有着非常大的不同，至少 svn 没有像 git 一样这么多的玩法。下面我举几个例子，简略的说一下。</p>
<h2>1.1 搭建博客</h2>
<p>阮一峰将写 blog 的人分成三个阶段</p>
<p>使用免费空间，比如 CSDN、博客园。<br>发现免费空间限制太多，于是自己购买域名和空间，搭建独立博客。<br>独立博客管理太麻烦，最好在保留控制权的前提下，让别人来管，自己负责写文章。</p>
<p>其实第三种阶段指的就是使用 Pages 服务。很多公司比如 Coding、Github 等代码托管平台都推出了 <a href=""http://pages.coding.me"" rel=""nofollow noreferrer"">Pages 服务</a>，可以用来搭建个人博客。Pages 服务不需要复杂的配置，就可以完成博客的搭建。</p>
<p>在使用 Pages 的过程中，通过使用标记语言（Markdown）完成博客的编写，推送到服务器上，就可以看到新发布的博客了。</p>
<p>不需要管理服务器，降低了搭建博客的门槛，同时又保持了用户对博客的高度定制权。</p>
<h2>1.2 写书</h2>
<p>很多牛人喜欢写博客，博客写多了，然后汇集起来就出了本书。比如 Matrix67《思考的乐趣》、阮一峰《如何变得有思想》就是这样的例子。</p>
<p>其实出书距离我们也并不遥远，为什么？因为有 gitbook 这类服务。</p>
<p>对于 git + Pages 服务的用户，gitbook 很容易上手，因为使用 gitbook 就是使用 git 与 markdown。<br>你完全可以将你 markdown 的博客 copy，汇集起来，形成一本书籍。内容的排版 gitbook 会帮你做，我们只负责内容就可以了。编写好内容，我们就能立刻获得  html、pdf、epub、mobi 四个版本的电子书。这是 html 版的预览：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695738"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>在 gitbook 上有 explore 频道，上面列出了所有公开的书籍（当然也可以直接搜索）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006772020"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>实际上，除了写书，还可以连同其他人一起进行外文资料的翻译，举个例子《The Swift Programming Language》中文版，将英文版分成几个部分，然后在开源项目中由参与者认领翻译，每个人贡献一份自己的力量，完成了这样以非常快的相应速度跟随官方文档更新的操作。如果你喜欢的一门语言，或者技术，中文资料缺乏，大家可以发起这样的活动，完成外文资料的翻译。</p>
<h2>1.3 人才招聘</h2>
<p>人才招聘这一块，至今还并没有形成一定的规模。但仍旧有很多的公司选择在代码托管平台上（比如 Coding、Github）上寻找中意的开发者。</p>
<p>有一些开发者看准了这一块，专门开发了这样的网站，比如 githuber.cn、github-awards.com。</p>
<p>拿 githuber 举例，该网站主要提供两个功能，第一个是星榜，说白了将所有所有用户按照语言分类，然后根据粉丝数（star）排序。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695854"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>我们可以很容易的看到排行榜上前几位的用户，他们的开源项目，这在一定程度上能代表这门语言的发展趋势。比如我对java比较感兴趣，然后我看了一下前十名，发现大部分都是 android 开发，由此可见android开发的火爆程度。</p>
<p>当然你也可以看到你的排名，会让你有打怪升级的快感。</p>
<p>第二个功能是搜索，输入筛选条件，搜搜程序员！</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695856"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h2>1.4 WebIDE</h2>
<p><a href=""https://ide.coding.net"" rel=""nofollow noreferrer"">Coding WebIDE</a> 是 Coding 自主研发的在线集成开发环境 (IDE)。只要你的项目在代码托管平台存放，就可以导入到 WebIDE。之后就可以在线开发。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695858"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>WebIDE 还提供 WebTerminal 功能，用户可以远程操作Docker容器，自由安装偏好的软件包、方便折腾。</p>
<p>看起来是不是还挺好玩的，如果想把这些都玩转，git 是肯定要好好学的。接下来，我们就看一下 git 的基本原理。</p>
<h1>2. Git 原理</h1>
<p>我们可以现在想一下，如果我们自己来设计，应该怎么设计。</p>
<p>传统的设计方案我们可以简单的分成两块：工作目录，远程仓库。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695862"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>但是作为一个目标明确的分布式版本控制系统，首先要做的就是添加一个本地仓库。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695864"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>接着我们选择在工作目录与远程仓库中间加一个缓冲区域，叫做暂存区。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695866"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>加入暂存区的原因有以下几点：</p>
<ol>
<li><p>为了能够实现部分提交</p></li>
<li><p>为了不再工作区创建状态文件、会污染工作区。</p></li>
<li><p>暂存区记录文件的修改时间等信息，提高文件比较的效率。</p></li>
</ol>
<p>至此就我们本地而言有三个重要的区域：工作区、暂存区、本地仓库。</p>
<p>接下来我们想一下本地仓库是如何存放项目历史版本。</p>
<h2>2.1 快照</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695871"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>这是项目的三个版本，版本1中有两个文件A和B，然后修改了A，变成了A1，形成了版本2，接着又修改了B变为B1，形成了版本3。</p>
<p>如果我们把项目的每个版本都保存到本地仓库，需要保存至少6个文件，而实际上，只有4个不同的文件，A、A1、B、B1。为了节省存储的空间，我们要像一个方法将同样的文件只需要保存一份。这就引入了Sha-1算法。</p>
<p>可以使用git命令计算文件的 sha-1 值。</p>
<pre><code>echo 'test content' | git hash-object --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
<p>SHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。</p>
<p>Sha-1的非常有特点：</p>
<ul>
<li><p>由文件内容计算出的hash值</p></li>
<li><p>hash值相同，文件内容相同</p></li>
</ul>
<p>对于上图中的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id 。同时，它还有一个额外的功能，校验文件完整性。</p>
<p>有了 sha-1 的帮助，我们可以对项目版本的存储方式做一下调整。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>2.1.1 数据库中存储的数据内容</h3>
<p>实际上，现在就与git实际存储的结构一致了。我们可以预览一下实际存储在 .git 下的文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005112151"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>我们可以看到，在 objects 目录下，存放了很多文件，他们都使用 sha-1 的前两位创建了文件夹，剩下的38位为文件名。我们先称呼这些文件为 obj 文件。</p>
<p>对于这么多的 obj 文件，就保存了我们代码提交的所有记录。对于这些 obj 文件，其实分为四种类型，分别是 blob、tree、commit、tag。接下来，我们分别来看一下。</p>
<ol>
<li>
<p>blob</p>
<p>首先  A、A1、B、B1 就是 blob 类型的 obj。</p>
<p>blob: 用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。</p>
</li>
<li>
<p>tree</p>
<p>tree 用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 tree 中有 blob、子tree，且都是使用 sha-1值引用的。这是与目录对应的。从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 tree 对象就代表了当前项目的快照。</p>
</li>
<li>
<p>commit</p>
<p>commit: 表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。</p>
</li>
</ol>
<h2>2.2 暂存区</h2>
<p>暂存区是一个文件，路径为： <code>.git/index</code></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005112154"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>它是一个二进制文件，但是我们可以使用命令来查看其中的内容。<br>这里我们关注第二列和第四列就可以了，第四列是文件名，第二列指的是文件的blob。这个blob存放了文件暂存时的内容。</p>
<p>第二列就是sha-1 hash值，相当于内容的外键，指向了实际存储文件内容的blob。第三列是文件的冲突状态，这个后面会讲，第四列是文件的路径名。</p>
<p>我们操作暂存区的场景是这样的，每当编辑好一个或几个文件后，把它加入到暂存区，然后接着修改其他文件，改好后放入暂存区，循环反复。直到修改完毕，最后使用 commit 命令，将暂存区的内容永久保存到本地仓库。</p>
<p>这个过程其实就是构建项目快照的过程，当我们提交时，git 会使用暂存区的这些信息生成tree对象，也就是项目快照，永久保存到数据库中。因此也可以说暂存区是用来构建项目快照的区域。</p>
<h2>2.3 文件状态</h2>
<p>有了工作区、暂存区、本地仓库，就可以来定义文件的状态了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695896"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>文件的状态可以分为两类。一类是暂存区与本地仓库比较得出的状态，另一类是工作区与暂存区比较得出的状态。为什么要分成两类的愿意也很简单，因为第一类状态在提交时，会直接写入本地仓库。而第二种则不会。一个文件可以同时拥有两种状态。</p>
<p>比如一个文件可能既有上面的 modified 状态，又有下面 modified 状态，但其实他们表示了不同的状态，git 会使用绿色和红色把这两中 modified 状态区分开来。</p>
<h2>2.4 分支</h2>
<p>接下来，看一个很重要的概念，分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695898"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>分支的目的是让我们可以并行的进行开发。比如我们当前正在开发功能，但是需要修复一个紧急bug，我们不可能在这个项目正在修改的状态下修复 bug，因为这样会引入更多的bug。</p>
<p>有了分支的概念，我们就可以新建一个分支，修复 bug，使新功能与 bug 修复同步进行。</p>
<p>分支的实现其实很简单，我们可以先看一下 .git/HEAD 文件，它保存了当前的分支。</p>
<pre><code>cat .git/HEAD
=&gt;ref: refs/heads/master</code></pre>
<p>其实这个 ref 表示的就是一个分支，它也是一个文件，我们可以继续看一下这个文件的内容：</p>
<pre><code>cat .git/refs/heads/master
=&gt; 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8</code></pre>
<p>可以看到分支存储了一个 object，我们可以使用 cat-file 命令继续查看该 object 的内容。</p>
<pre><code>git cat-file -p 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8
=&gt; tree 15f880be0567a8844291459f90e9d0004743c8d9
=&gt; parent 3d885a272478d0080f6d22018480b2e83ec2c591
=&gt; author Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800
=&gt; committer Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800
=&gt; 
=&gt; add branch paramter for rebase</code></pre>
<p>从上面的内容，我们知道了分支指向了一次提交。为什么分支指向一个提交的原因，其实也是git中的分支为什么这么轻量的答案。</p>
<p>因为分支就是指向了一个 commit 的指针，当我们提交新的commit，这个分支的指向只需要跟着更新就可以了，而创建分支仅仅是创建一个指针。</p>
<h1>3. 高层命令</h1>
<p>在 git 中分为两种类型的命令，一种是完成底层工作的工具集，称为底层命令，另一种是对用户更友好的高层命令。一条高层命令，往往是由多条底层命令组成的。</p>
<p>不知道的人可能一听高层感觉很厉害的样子，其实就是指的是那些我们最常使用的git命令。</p>
<h2>3.1 Add &amp; Commit</h2>
<p>add 和 commit 应该可以说是我们使用频率最高的高层命令了。</p>
<pre><code>touch README.md
git add README.md
git commit -m ""add readme”</code></pre>
<p>touch 指的是创建一个文件，代表了我们对项目文件内容的修改，add 操作是将修改保存到暂存区，commit 是将暂存区的内容永久保存到本地仓库。</p>
<p>每当将修改的文件加入到暂存区，git 都会根据文件的内容计算出 sha-1，并将内容转换成 blob，写入数据库。然后使用 sha-1 值更新该列表中的文件项。在暂存区的文件列表中，每一个文件名，都会对应一个sha-1值，用于指向文件的实际内容。最后提交的那一刻，git会将这个列表信息转换为项目的快照，也就是 tree 对象。写入数据库，并再构建一个commit对象，写入数据库。然后更新分支指向。</p>
<h2>3.2 Conflicts &amp; Merge &amp; Rebase</h2>
<h2>3.2.1 Conflicts</h2>
<p>git 中的分支十分轻量，因此我们在使用git的时候会频繁的用到分支。不可不免的需要将新创建的分支合并。</p>
<p>在 git 中合并分支有两种选择：merge 和 rebase。但是，无论哪一种，都有可能产生冲突。因此我们先来看一下冲突的产生。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>图上的情况，并不是移动分支指针就能解决问题的，它需要一种合并策略。首先，我们需要明确的是谁和谁的合并，是 2，3 与 4，5，6的合并吗？说到分支，我们总会联想到线，就会认为是线的合并。其实不是的，真实合并的是 3 和 6。因为每一次提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。</p>
<p>我们可以先想一个简单的算法。用来比较3和6。但是我们还需要一个比较的标准，如果只是3和6比较，那么3与6相比，添加了一个文件，也可以说成是6与3比删除了一个文件，这无法确切表示当前的冲突状态。因此我们选取他们的两个分支的分歧点（merge base）作为参考点，进行比较。</p>
<p>比较时，相对于 merge base（提交1）进行比较。</p>
<p>首先把1、3、6中所有的文件做一个列表，然后依次遍历这个列表中的文件。现在我们拿列表中的一个文件进行举例，把在提交1、3、6中的该文件分别称为版本1、版本3、版本6。</p>
<ol>
<li><p>版本1、版本3、版本6的 sha-1 值完全相同，这种情况表明没有冲突</p></li>
<li><p>版本3或6至少一个与版本1状态相同（指的是sha-1值相同或都不存在），这种情况可以自动合并。比如1中存在一个文件，3对该文件进行修改，而6中删除了这个文件，则以6为准就可以了</p></li>
<li><p>版本3或版本6都与版本1的状态不同，情况复杂一些，自动合并策略很难生效，需要手动解决。我们来看一下这种状态的定义。</p></li>
</ol>
<p>冲突状态定义：</p>
<ul>
<li><p><strong>1 and 3:</strong> DELETED_BY_THEM;</p></li>
<li><p><strong>1 and 6:</strong> DELETED_BY_US;</p></li>
<li><p><strong>3 and 6:</strong> BOTH_ADDED;</p></li>
<li><p><strong>1 and 3 and 6</strong>: BOTH_MODIFIED</p></li>
</ul>
<p>我们拿第一种情况举例，文件有两种状态 1 和 3，1 表示该文件存在于 commit 1（也就是MERGE_BASE），3 表示该文件在 commit 3 （master 分支）中被修改了，没有 6，也就是该文件在 commit 6（feature 分支）被删除了，总结来说这种状态就是 DELETED_BY_THEM。</p>
<p>可以再看一下第四种情况，文件有三种状态 1、3、6，1 表示 commit 1（MERGE_BASE）中存在，3 表示 commit 3（master 分支）进行了修改，6 表示（feature 分支）也进行了修改，总结来说就是 BOTH_MODIFIED（双方修改）。</p>
<p>遇到不可自动合并冲突时，git会将这些状态写入到暂存区。与我们讨论不同的是，git使用1，2，3标记文件，1表示文件的base版本，2表示当前的分支的版本，3表示要合并分支的版本。</p>
<h3>3.2.2 Merge</h3>
<p>在解决完冲突后，我们可以将修改的内容提交为一个新的提交。这就是 merge。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695902"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>merge 之后仍可以做出新的提交。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695904"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用    起来不太方便，比如当我们创建了 pr、mr 或者 将修改补丁发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。</p>
<p>使用 rebase 可以解决这种问题。</p>
<h3>3.2.3 Rebase</h3>
<p>假设我们的分支结构如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新达到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward，即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695906"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>如果我们想要看 rebase 实际上做了什么，有一个方法，那就是用“慢镜头”来看rebase的整个操作过程。rebase 提供了交互式选项(参数 -i)，我们可以针对每一个patch，选择你要进行的操作。</p>
<p>通过这个交互式选项，我们可以”单步调试”rebase操作。</p>
<p>经过测试，其实 rebase 主要在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就可以看得出来。git-rebase-todo 存放了 rebase 将要操作的 commit。而 done 存放正在操作或已经操作完毕的 commit。比如我们这里，git-rebase-todo 存放了 4、5、6，三个提交。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695908"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>首先 git 将 sha-1 为 4 的 commit 放入 done。表示正在操作 4，然后将 4 以补丁的形式打到 3 上，形成了新的提交 4’。这一步是可能产生冲突的，如果有冲突，需要解决完冲突之后才能继续操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695910"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>接着讲 sha-1 为 5 的提交放入 done 文件，然后将 5 以补丁的形式打到 4’ 上，形成 5’。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695912"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>再接着将 sha-1 为 6 的提交放入 done 文件，然后将 6 以补丁的形式打到 5’ 上，形成 6’。最后移动分支指针，使其指向最新的提交 6’ 上。这就完成了 rebase 的操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695915"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>我们看一下真实的 rebase 文件。</p>
<pre><code>pick e0f56d9 update gitignore
pick e370289 add a

# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit</code></pre>
<p>该文件一共有三列，第一列表示要进行的操作，所有可以进行的操作，在下面注释里都列了出来，比如 pick 表示使用该提交，reword 表示使用该提交，但修改其提交的 message，edit 表示使用该提交，但是要对该提交进行一些修改，其它的就不一一说了。</p>
<p>而 done 文件的形式如下，和 git-rebase-todo 是一样的：</p>
<pre><code>pick e0f56d9 update gitignore
pick e370289 add a</code></pre>
<p>从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。</p>
<p>所以使用 rebase 最好不要在公共分支上进行操作。</p>
<h2>3.3 Checkout、Revert、Reset</h2>
<h3>3.3.1 Checkout</h3>
<p>对于 checkout，我们一般不会陌生。因为使用它的频率非常高，经常用来切换分支、或者切换到某一次提交。</p>
<p>这里我们以切换分支为例，从 git 的工作区、暂存区、本地仓库分别来看 checkout 所做的事情。Checkout 前的状态如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695917"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>首先 checkout 找到目标提交（commit），目标提交中的快照也就是 tree 对象就是我们要检出的项目版本。<br>checkout 首先根据tree生成暂存区的内容，再根据 tree 与其包含的 blob 转换成我们的项目文件。然后修改 HEAD 的指向，表示切换分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695919"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>可以看到 checkout 并没有修改提交的历史记录。只是将对应版本的项目内容提取出来。</p>
<h3>3.3.2 Revert</h3>
<p>如果我们想要用一个用一个反向提交恢复项目的某个版本，那就需要 revert 来协助我们完成了。什么是反向提交呢，就是旧版本添加了的内容，要在新版本中删除，旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。</p>
<p>Revert 之前：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695921"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>revert 也不会修改历史提交记录，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的“回退”。</p>
<p>Revert 之后：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695923"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<h3>Reset</h3>
<p>reset 操作与 revert 很像，用来在当前分支进行版本的“回退”，不同的是，reset 是会修改历史提交记录的。</p>
<p>reset 常用的选项有三个，分别是 —soft, —mixed, —hard。他们的作用域依次增大。</p>
<p>我们分别来看。</p>
<p>soft 会仅仅修改分支指向。而不修改工作区与暂存区的内容，我们可以接着做一次提交，形成一个新的 commit。这在我们撤销临时提交的场景下显得比较有用。</p>
<p>使用 reset --soft 前：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695925"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>使用 reset --soft 后:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695927"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>mixed 比 soft 的作用域多了一个 暂存区。实际上 mixed 选项与 soft 只差了一个 add 操作。</p>
<p>使用 reset --mixed 前：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695929"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>使用 reset --mixed 后：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005695931"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>hard 会作用域又比 mixed 多了一个 工作区。</p>
<p>使用 reset --hard 前：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005696712"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>使用 reset --hard 后：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006772021"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>hard 选项会导致工作区内容“丢失”。</p>
<p>在使用 hard 选项时，一定要确保知道自己在做什么，不要在迷糊的时候使用这条选项。如果真的误操作了，也不要慌，因为只要 git 一般不会主动删除本地仓库中的内容，根据你丢失的情况，可以进行找回，比如在丢失后可以使用 git reset --hard ORIG_HEAD 立即恢复，或者使用 reflog 命令查看之前分支的引用。</p>
<h2>3.4 stash</h2>
<p>有时，我们在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。在曾经这样做过，将当前的修改做一次提交，message 填写 half of work，然后切换另一个分支去做工作，完成工作后，切换回来使用 reset —soft 或者是 commit amend。</p>
<p>git 为了帮我们解决这种需求，提供了 stash 命令。</p>
<p>stash 将工作区与暂存区中的内容做一个提交，保存起来，然后使用reset hard选项恢复工作区与暂存区内容。我们可以随时使用 stash apply 将修改应用回来。</p>
<p>stash 实现思路将我们的修改提交到本地仓库，使用特殊的分支指针（.git/refs/stash）引用该提交，然后在恢复的时候，将该提交恢复即可。我们可以更进一步，看看 stash 做的提交是什么样的结构。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005696714"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>如图所示，如果我们提供了 —include-untracked 选项，git 会将 untracked 文件做一个提交，但是该提交是一个游离的状态，接着将暂存区的内容做一个提交。最后将工作区的修改做一个提交，并以untracked 的提交、暂存区 的提交、基础提交为父提交。</p>
<p>搞这么复杂，是为了提供更灵活地选项，我们可以选择性的恢复其中的内容。比如恢复 stash 时，可以选择是否重建 index，即与 stash 操作时完全一致的状态。</p>
<h2>3.5 bisect</h2>
<p>最后要讲到一个曾经把我从“火坑”中救出来的功能。</p>
<p>项目发布到线上的项目出现了bug，而经过排查，却找不到问 bug 的源头。我们还有一种方法，那就是先找到上一次好的版本，从上一次到本次之间的所有提交依次尝试，一一排查。直到找到出现问题的那一次提交，然后分析 bug 原因。</p>
<p>git 为我们想到了这样的场景，同样是刚才的思路，但是使用二分法进行查找。这就是 bisect 命令。</p>
<p>使用该命令很简单，</p>
<pre><code>git bisect start
git bisect bad HEAD
git bisect good v4.1</code></pre>
<p>git 会计算中间的一个提交，然后我们进行测试。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005696722"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>根据测试结果，使用  git bisect good or bad 进行标记，git 会自动切换到下一个提交。不断的重复这个步骤，直到找到最初引入 bug 的那一次提交。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005696720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>我们知道二分法的效率是很高的，2的10次方就已经1024了，因此我们测试一般最多是10次，再多就是11次、12次。其实这就要求我们优化测试的方法，使得简单的操作就能使 bug 重现。如果重新的操作非常简单，简单到我们可以使用脚本就能测试，那就更轻松了，可以使用 git bisect run ./test.sh，一步到位。</p>
<p>如果某一个提交代码跑不起来，可以使用 git bisect skip 跳过当前提交或者使用 visualize 在 git 给出的列表中手动指定一个提交进行测试。</p>
<p>Happy Coding ; )<br><a href=""https://coding.net"" rel=""nofollow noreferrer"">Coding.net</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005696718"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 使用原理视角看 Git,1531977956,308,1,464,1,1,https://segmentfault.com/a/1190000005695097
204,1,0,7,"
                    
<p>最近几个月在学习<code>Vue.js</code>并把它应用到实际项目中，在通读官方中文教程之后，前期学习期间<a href=""https://scotch.io/tutorials/create-a-github-file-explorer-using-vue-js"" rel=""nofollow noreferrer"">Create a GitHub File Explorer Using Vue.js</a>这篇文章给我了较好的启发。于是结合自己最新的学习成果写下这篇总结。</p>
<p>源码地址：<a href=""https://github.com/xiaoluoboding/vue-demo-collection/tree/master/github-file-explorer"" rel=""nofollow noreferrer"">github-file-explorer</a></p>
<p>See <a href=""http://xiaoluoboding.github.io/vue-demo-collection/github-file-explorer/"" rel=""nofollow noreferrer"">DEMO</a></p>
<h2>开发环境搭建</h2>
<p>参考官方教程<a href=""http://cn.vuejs.org/guide/application.html"" rel=""nofollow noreferrer"">构建大型应用</a>中提到的脚手架工具<a href=""https://github.com/vuejs/vue-cli"" rel=""nofollow noreferrer"">vue-cli</a>，我初次了解到了<code>webpack</code>，<code>vue-cli</code>是一个简单的脚手架，可以帮助你快速地构建 Vue 项目：单文件 Vue 组件，热加载，保存时检查代码，单元测试等功能。<code>vue-cli</code>中有五个模板，我想用<code>webpack-simple</code>模板作为demo的开发环境再好不过了。</p>
<pre><code class=""sh"">$&gt; npm install vue-cli -g</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVxSkY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>创建第一个Vue应用</h2>
<pre><code class=""sh"">$&gt; vue init webpack-simple github-file-explorer

$&gt; cd github-file-explorer

$&gt; npm install

$&gt; npm run dev</code></pre>
<p>打开浏览器，输入<code>http://localhost:8080</code></p>
<p>Boom，你会发现我们创建的第一个Vue应用启动了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVxSkZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>更改默认端口</h3>
<p><code>webpack-simple</code>集成了<code>webpack-dev-server</code>，默认启动的端口为<strong>8080</strong>，端口容易冲突。</p>
<p>翻阅文档，修改配置文件<code>package.json</code>，更换端口为<strong>8090</strong>。</p>
<pre><code class=""json"">""scripts"": {
  ""dev"": ""webpack-dev-server --inline --hot --port 8090"",
  ""build"": ""cross-env NODE_ENV=production webpack --progress --hide-modules""
},</code></pre>
<h3>热重载</h3>
<p><code>webpack</code>结合<code>vue-loader</code>以及<code>vue-hot-reload-api</code>实现了热重载，让开发体验极速提升。保存秒级更新，再也不用reload浏览器了。那些年我们都习惯了<kbd>F5</kbd>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVxUkS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>组件化开发体验</h2>
<ul>
<li><p>项目结构</p></li>
<li><p>引入资源</p></li>
<li><p>简单vue指令的使用</p></li>
<li><p>计算属性</p></li>
<li><p>数据观察</p></li>
<li><p>组件间数据传递</p></li>
</ul>
<h3>项目结构</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVxSk1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>引入资源</h3>
<p>在index.html中引入资源，采用<code>jsdelivr</code>CDN加速。</p>
<pre><code class=""html"">&lt;!-- Bootstrap --&gt;
&lt;link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/bootstrap/3.3.6/css/bootstrap.min.css""&gt;

&lt;!-- Octicons --&gt;
&lt;link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/octicons/3.5.0/octicons.css""&gt;</code></pre>
<h3>简单vue指令的使用</h3>
<ul>
<li><p><code>v-model</code> 表单控件绑定</p></li>
<li><p><code>v-if</code> 根据表达式的值的真假条件渲染元素</p></li>
<li><p><code>v-for</code> 列表渲染</p></li>
<li><p><code>@click</code> 是<code>v-on:click</code>的简写，绑定事件监听</p></li>
</ul>
<h3>计算属性</h3>
<p><code>computed</code>可以对Vue实例上的数据进行再计算，根据需求，再次拼接fullRepoUrl。</p>
<pre><code class=""js"">fullRepoUrl: function() {
  return this.username + '/' + this.repo;
}</code></pre>
<h3>数据观察</h3>
<p><code>watch</code>可以观察每一个Vue实例上的数据变动。当数据发生变化的时候会触发方法。通过这个机制我们可以实现更换repo来触发列表更新。</p>
<pre><code class=""js"">watch: {
  repo: function(newVal, oldVal) {
    this.path = '/';
    this.getFiles();
  }
}</code></pre>
<h3>组件间数据传递</h3>
<blockquote><p>组件（Component）是Vue.js最强大的功能之一。</p></blockquote>
<p>在官方教程中<strong>组件</strong>占了绝大部分内容，说明组件在Vue中占有很重要的地位。</p>
<p>下图是我对<code>github-file-explorer</code>构建的简单<strong>组件链</strong>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVxSk2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><code>main.js</code>，是Vue的根实例，它扩展了App.vue作为父组件。</p>
<pre><code class=""js"">import Vue from 'vue'
import VueResource from 'vue-resource'
import App from './App.vue'

Vue.use(VueResource)

new Vue({
  el: 'body',
  components: { App }
})</code></pre>
<ul>
<li><p>A，<code>App</code>作为父组件，建议App中不写业务逻辑，作为应用的layout，根据需求，做一个布局。比如：<strong>Header/Container/Sidebar</strong>。</p></li>
<li><p>B，<code>Github</code>是App组件的子组件，同时也是FileExplorer组件的父组件，实现form表单获取github文件API列表。</p></li>
<li><p>C，<code>FileExplorer</code>组件为Github组件的子组件，实现列表清单。</p></li>
</ul>
<p>组件关系：<code>App &gt; Github &gt; FileExplorer</code></p>
<p>父组件与子组件间通讯(使用Props传递数据)：</p>
<blockquote><p><strong>组件实例的作用域是孤立的</strong>。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 <code>props</code> 把数据传给子组件。</p></blockquote>
<p><strong>父组件Github</strong>通过动态绑定Props向子组件传递数据</p>
<pre><code class=""js"">&lt;file-explorer :username=""username"" :repo=""repo""&gt;&lt;/file-explorer&gt;</code></pre>
<p><strong>子组件FileExplorer</strong>通过Props接收父组件传递的数据</p>
<pre><code class=""js"">props: {
  username: {
    type: String,
    required: true
  },
  repo: {
    type: String,
    required: true
  }
},</code></pre>
<h2>使用Vue插件</h2>
<blockquote><p><strong>vue-resource</strong>，通过 XMLHttpRequest 或 JSONP 发起请求并处理响应</p></blockquote>
<p>通过vue-resource请求github的API</p>
<pre><code class=""js"">getFiles: function() {
  this.$http.get('https://api.github.com/repos/' + this.fullRepoUrl + '/contents' + this.path,
    function(data) {
      this.files = data;
    }
  );
}</code></pre>
<h2>使用Vue Devtools提升开发效率</h2>
<p>下图是对<code>github-file-explorer</code>组件链作用域的简单演示</p>
<p><span class=""img-wrap""><img data-src=""/img/bVxUk1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><code>Vue Devtools</code>可以大大提升Vue应用的调试效率，再也不用<code>{{ $data | json }}</code><br>打印调试数据了，并且它还可以调试Vuex，当你在使用Vuex时候可能对数据流转很困惑。那么使用Vue DevTools中的Vuex调试工具可以解决你的烦恼。关于Vuex的使用后续我会再写篇文章总结下，很好用的状态管理插件。不过Vue Devtools目前只有Chrome。意味着你只能在Chrome浏览器中才能使用Vue Devtools。</p>
<h2>最终效果图</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVxSk5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>原文：<a href=""http://xlbd.me/vue-demo-github-file-explorer/"" rel=""nofollow noreferrer"">使用Vue.js从零构建GitHub项目浏览器</a></p></blockquote>

                ", 使用Vue.js从零构建GitHub项目浏览器,1531977958,319,1,508,1,1,https://segmentfault.com/a/1190000005651367
205,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/972352-2618647253f0e9d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""GitHub：全球最大的代码托管平台"" title=""GitHub：全球最大的代码托管平台""></span></p>
<blockquote><p>第一次做开源项目，从0到1024个star数量经历了一个多月的开发和维护，从新手到入门（至于之后的阶段，我也还在摸索中）。在这里我就来分享一下我的经历吧，希望能够对<strong>想做开源但是没行动的小伙伴</strong>有所帮助。</p></blockquote>
<p>项目地址：<a href=""https://github.com/CymChad/BaseRecyclerViewAdapterHelper"" rel=""nofollow noreferrer"">https://github.com/CymChad/BaseRecyclerViewAdapterHelper</a></p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/972352-66220228e9735483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1024"" title=""1024""></span></p>
<h2>为什么做这个项目？</h2>
<blockquote><p>最近一段时候在编写项目（APP应用）的时候使用列表控件频率非常高，写着就发现很多代码冗余了，于是就想封装一下，开始做起了代码优化，之前做过类似的优化，于是根据之前的优化经验，最终代码量得到了大幅度的优化。<strong>只要原有代码量的30%即可完成显示功能</strong>，后来随着项目需求的增加不断的完善封装，使得只需要<strong>简单的几行代码就可以完成的需求</strong>（如：添加头部尾部、添加列表动画、等等）。最终形成了一个还不错的基类，本着分享的精神就上传到了GitHub上面。</p></blockquote>
<ul><li><p>目的：让更多开发者加入开发，把这个项目做的更强大，使更多人受益。</p></li></ul>
<p><strong>在github上面没有查找到有满足我的需求的开源项目，我才造轮子的。</strong></p>
<h2>切入点</h2>
<p><strong>解决实际问题</strong></p>
<ul>
<li><p><strong>优化Adapter代码（减少百分之70%代码）</strong></p></li>
<li><p><strong>添加点击item点击、长按事件、以及item子控件的点击事件</strong></p></li>
<li><p><strong>添加加载动画（一行代码轻松切换5种默认动画）</strong></p></li>
<li><p><strong>添加头部、尾部、下拉刷新、上拉加载（感觉又回到ListView时代）</strong></p></li>
<li><p><strong>设置自定义的加载更多布局</strong></p></li>
<li><p><strong>添加分组（随心定义分组头部）</strong></p></li>
<li><p><strong>自定义不同的item类型（简单配置、无需重写额外方法）</strong></p></li>
<li><p><strong>设置空布局（比Listview的setEmptyView还要好用！）</strong></p></li>
</ul>
<p>除了解决问题，还有就是让更多人知道，所以接下来就是「推广」。</p>
<h2>推广</h2>
<p>我的方法是通过写作平台去推广，写一些文章关于该项目的</p>
<ul>
<li><p>使用方法（便于让开发者理解它的简单使用以及强大的功能）</p></li>
<li><p>原理分析（让更多开发者学会它，加入开发，也可以收到更好的反馈）</p></li>
</ul>
<p>我用的写作平台有（你也可以选择更多，多多益善）：</p>
<ul>
<li><p>伯乐在线 <a href=""http://www.jobbole.com/"" rel=""nofollow noreferrer"">http://www.jobbole.com/</a></p></li>
<li><p>CSDN <a href=""http://www.csdn.net/"" rel=""nofollow noreferrer"">http://www.csdn.net/</a></p></li>
<li><p>简书 <a href=""http://www.jianshu.com/"" rel=""nofollow noreferrer"">http://www.jianshu.com/</a></p></li>
</ul>
<p>写完之后再发链接到分享平台（你也可以选择更多，多多益善）：</p>
<ul>
<li><p>掘金 <a href=""http://gold.xitu.io/"" rel=""nofollow noreferrer"">http://gold.xitu.io/</a></p></li>
<li><p>开发者头条 <a href=""http://toutiao.io/"" rel=""nofollow noreferrer"">http://toutiao.io/</a></p></li>
<li><p>极客头条 <a href=""http://geek.csdn.net/"" rel=""nofollow noreferrer"">http://geek.csdn.net/</a></p></li>
<li><p>干货集中营 <a href=""http://gank.io/"" rel=""nofollow noreferrer"">http://gank.io/</a></p></li>
</ul>
<p>这些都是开发者平时比较关注的平台（你也可以选择更多，多多益善）。</p>
<blockquote><p>推广后，开发者就会进入你的项目首页所以接下来看的就是「<a href=""https://github.com/CymChad/BaseRecyclerViewAdapterHelper/blob/master/README.md"" rel=""nofollow noreferrer"">README.md</a>」的编写。</p></blockquote>
<h2>README（自述文件）</h2>
<p>我的README(英语版、中文版)，它的结构：</p>
<ul>
<li><p>gif案例效果</p></li>
<li><p>demo下载方式</p></li>
<li><p>框架导入方式</p></li>
<li><p>框架使用方式</p></li>
</ul>
<p>效果（看）=》demo（玩）=》源码（用）</p>
<blockquote><p>当开发者使用过后就要想到后续的「开发及维护」</p></blockquote>
<h2>开发及维护</h2>
<blockquote><p>有任何需求可以在github提issue，（bug我通常在24小时内就会解决）但是很重要的一点是，由于每个人的精力都是有限的，做开源项目都是用的业余时间，所以要寻找小伙伴一起来维护项目，所以我就建了一个Q群（目前134人），让感兴趣的开发者加入进来，一起来完善，形成一个圈子，这样遇到问题的人多了，自然解决方法就多了，最开始也许都需要问我，但是到了现在，已经有很多成员会主动的去帮助新入群的小伙伴解决问题了，形成了一种解决问题的气氛。</p></blockquote>
<p>入群门槛：star我的项目，为什么呢？</p>
<ul>
<li><p>有门槛，都有人加入的话证明加入者求知欲强。</p></li>
<li><p>确定star了我的项目，肯定看过源码或者用过我的项目，这样入群后才有更深入技术的交流，群里面内容质量才能够得到保障。</p></li>
<li><p>选拔人才，从使用者中选择，让他们加入开发或维护，这样才能把这个东西做好做大。</p></li>
</ul>
<h2>开源项目的好处</h2>
<ul>
<li><p>帮助自己的同时，帮助了别人</p></li>
<li><p>结交志同道合的朋友</p></li>
<li><p>收获反馈，技术提升</p></li>
</ul>
<h2>总结</h2>
<blockquote><p>其实做开源项目并<strong>不难</strong>（我行，你也行！）主要是要迈出第一步，然后<strong>及时接受反馈，不断满足用户需求</strong>！我建议大家都去开源实践，无论你的技术如何，分享是互联网的一种精神，献出自己的一份代码，帮助更多人吧，也许你曾经使用过别人的开源框架，而现在你也开源以同样的方式献出自己的一份力量，无论结果怎样，你总会有收获。</p></blockquote>
<p><strong>如果你是Android开发者，欢迎加入我的开源项目：<a href=""https://github.com/CymChad/BaseRecyclerViewAdapterHelper"" rel=""nofollow noreferrer"">[传送门</a>]</strong></p>

                ", 我的开源项目从0到1024的过程,1531977960,156,1,399,1,1,https://segmentfault.com/a/1190000005640523
206,1,0,7,"
                    
<p>对 Git 的学习一直处于学了忘，忘了学的状态。主要是第一次学会的时候没有好好进行运用，当想要使用的时，发现，大半都已经忘记了。重新拾起来的时候，又是发现了大量问题。然后再次学习→忘记→学习→忘记，死循环。所以，我还是将自己一直陷进去的坑给填好吧，这样，下次忘记的时候容易→学习→忘记→学习。</p>
<p>更好的阅读体验课移至此处 <br><a href=""https://halfmoonvic.github.io/2017/07/20/Git-reset-checkout-commit-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"" rel=""nofollow noreferrer"">https://halfmoonvic.github.io...</a></p>
<h3>1、 三个区</h3>
<p>看了许多关于 Git 的教程，大多是先说工作目录、暂存目录（索引）和版本库（仓库或者HEAD）。都会配些图片，看来看去，我觉得在<a href=""https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting/"" rel=""nofollow noreferrer"">Reset, Checkout, and Revert</a>一文中就三个区的概念最为恰当。一图以蔽之<span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/1.three_area.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul><li>Working Directory —— 工作目录</li></ul>
<p>视力所及处皆是 Working Directory</p>
<ul><li>Staged Snapshot</li></ul>
<p>有的将这里称为暂存目录，有的称为索引区。而在<a href=""https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting/"" rel=""nofollow noreferrer"">Reset, Checkout, and Revert</a>一文中就是简单称之为“快照区”，在下实在是认同。原因以下讲。</p>
<ul><li>Commit History</li></ul>
<p>其它文章看到过有将其为版本库或是仓库的，这个让人糊涂。因为 Git 本身就是一个版本控制系统，私以为这三者联合起来才能称之为版本库。而至于 HEAD，说的还是比较贴切的。HEAD 只能在这里游动，跑不了。</p>
<pre><code>而将其称为 Commit Histroy 最为贴切处是因为它很好的描述了这个区域的作用 —— 保存 commit 历史。
</code></pre>
<h3>2、commit</h3>
<p>初学 Git 时，只是简单的学习 <code>add commit</code> 等等基本操作命名，进而去学习各种远程库的推送等等操作，以为这些好复杂。可等到学完的时候，才发现，自己还是不怎么懂最为基本的 <code>commit</code> 概念。我自己在学习的过程中逐渐认识到 <code>commit</code> 的厉害之处，对它的认识也是一直处于变化当中。到现在根本不在乎它的中文意思应该是什么，而只是简单称它为 <code>commit</code> ，动词性的或者名词性质的，统统称之为 <code>commit</code>。  </p>
<p>而我就 Git 的个人理解，我认为其思想就是<strong>基于 <code>commit</code> 的各种控制操作</strong>。</p>
<h5>2.1、 基于 commit 的版本操作控制思想</h5>
<ol><li>最开始对 <code>commit</code> 的理解就是简单的认为其为中文释义——提交。</li></ol>
<p>在我们修改了文件之后进行<code>git add &lt;file_path&gt;</code>操作，进而进行<code>git commit &lt;file_path&gt;</code>。从 <code>Staged Snapshot</code> 到 <code>Commit History</code> 的操作，这看起来很像一个提交。</p>
<ol><li>继续学习当中，即涉及到第三个区 <code>Commit History</code> 中的 <code>commit</code> 时，让人沉醉 —— 快照。</li></ol>
<p>我们可以通过 <code>checkout</code> 命名轻松的移动HEAD到不同的 <code>&lt;commitID&gt;</code> 上，在上一处对 <code>commit</code> 的理解还是一个动词性的（提交）。这里 <code>commit</code> 却好像是变成了一个名词——快照（个人跟乐意用<code>&lt;commitID&gt;</code>来表示)。</p>
<ol><li>怀疑阶段——我究竟在 提交（<code>git commit &lt;file_path&gt;</code>）什么？</li></ol>
<p><code>git commit &lt;file_path&gt;</code>操作，开始会认为是提交了你在 <code>Working Dir</code> 中<code>add</code>的文件。这个非常对，没有半点错误。可是，你<code>commit</code>操作是 <code>Staged Snapshot</code> 与 <code>Commit History</code> 两者之间的操作。这个叉跨的太大！</p>
<ol><li>释疑阶段 —— 合体啊～</li></ol>
<p><strong><code>commit</code>既是提交又是快照</strong>  <br>这里所谓的既是提交又是快照指的仅仅是<code>git commit &lt;file_path&gt;</code>一处操作。什么意思？  <br>我在将文件<code>git add &lt;file_path&gt;</code>操作后，我在进行<code>git commit &lt;file_path&gt;</code>操作时，事实上是先对<code>add</code>进 <code>Staged Snapshot</code> 来的文件进行拍照（快照），然后提交给 <code>Commit History</code>。</p>
<ol><li>处处皆是 <strong>commit</strong>
</li></ol>
<p>私以为，快照这个动作是时时进行的。如你在 <code>Working Dir</code> 中对文件的<code>add</code>操作，是将 <code>Working Dir</code> 拍照了一下，传给了 <code>Staged Snapshot</code> 了。然后 <code>Staged Snapshot</code> 在将传过来的快照传给 <code>Commit History</code>。这样，从工作目录开始就是<strong>快照</strong>级别的操作。这些命令操作当中也就不用纠结这个文件到底是怎样的一副状态了。因为它远在你<code>add</code>的时候就已经被固定为快照了。</p>
<h5>2.2、 根据颜色辨别状态</h5>
<p><code>git status</code>时，那个 modified 是显示红色还是绿色，是依据于 commit 所处状态来决定的。</p>
<ol><li>显示 红色 就是 「Woring Dir 区的 commit」 与 「Staged Snapshot 的 commit / Commit History 的 commit」 有区别。</li></ol>
<p>红色 modified 即为「Woring Dir 区的 commit」中内容还未被 add。</p>
<ol><li>显示 绿色 是 「Woring Dir 区的 commit / Staged Snapshot 的 commit」 与 「Commit History 的 commit」 有区别。</li></ol>
<p>绿色 modified 即为「Staged Snapshot 的 commit」还未被 commit。</p>
<p>印象加深图：<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/2.git-status.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""modified"" title=""modified""></span></p>
<h5>2.3、 总结 commit</h5>
<p>到现在，我已经不在乎 <code>commit</code> 到底是什么意思了，只是简单称为 <code>commit</code>，如果一定让我翻译一下。我更为乐意称之为「快照」。  <br>至于那种 <code>commit</code> 的传递，我将其认为是 Git 自己内部命令的结果。  <br>而涉及到「提交」一概念大概只有<code>git commit &lt;file_path&gt;</code>中的<code>commit</code>。</p>
<h3>3、reset 命令</h3>
<p>与<code>checkout</code>命令相比，我认为<code>reset</code>简单的多，但此命令有危险。除非，你知道自己在做什么。</p>
<p><strong>reset</strong> 许多命令模式会变更 <code>master</code>（或者其它分支名，本文只以 <code>master</code> 分支举例）分支位置</p>
<h5>3.1、 reset 的三种命令模式：</h5>
<table>
<thead><tr>
<th align=""left"">模式名称</th>
<th align=""center"">master的位置</th>
<th align=""center"">暂存区</th>
<th align=""center"">工作目录</th>
</tr></thead>
<tbody>
<tr>
<td align=""left"">情况1.1 <code>--mixed</code> 无<code>&lt;file_path&gt;</code> 操控 <code>Commit History 和 Staged Snapshot</code>
</td>
<td align=""center"">修改</td>
<td align=""center"">修改</td>
<td align=""center"">不修改</td>
</tr>
<tr>
<td align=""left"">情况1.2 <code>--mixed</code> 有<code>&lt;file_path&gt;</code> 操控 <code>Staged Snapshot</code>
</td>
<td align=""center"">不修改</td>
<td align=""center"">修改</td>
<td align=""center"">不修改</td>
</tr>
<tr>
<td align=""left"">情况 2   <code>--hard</code> 操控 <code>Commit History、Staged Snapshot、Working Directory</code>
</td>
<td align=""center"">修改</td>
<td align=""center"">修改</td>
<td align=""center"">修改</td>
</tr>
<tr>
<td align=""left"">情况 3   <code>--soft</code> 操控 <code>Commit History</code>
</td>
<td align=""center"">修改</td>
<td align=""center"">不修改</td>
<td align=""center"">不修改</td>
</tr>
</tbody>
</table>
<p>示意如下三图，从左至右依次为：mixed(操作对象为HEAD、情况1.1)、hard、soft三种模式。</p>
<ul>
<li>
<code>mixed</code>模式的时候操作对象即可是 <code>HEAD</code> 也可以是 <code>Staged Snapshop</code>。</li>
<li>
<code>soft hard</code>模式针对的操作对象均是 <code>HEAD</code>。</li>
</ul>
<p>如果强行添加<code>&lt;file_path&gt;</code>，则会报错<code>fatal: Cannot do (hard, soft) reset with paths</code></p>
<ul><li>三种模式操作<code>HEAD</code>时，均可以移动<code>HEAD</code>及其<code>HEAD</code>所处的当前<code>&lt;branch&gt;</code>。<code>mixed</code>模式带有<code>&lt;file_path&gt;</code>时则不可以,其操作控制影响的 是 <code>Staged Snapshop</code> 区。</li></ul>
<p><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/mixed.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/hard.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/soft.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>ᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂ 分割线 ᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂᶂ</h2>
<p>关于本人所做图片有两处需要阐述，请看下大图：<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/3.git-reset.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""高清无码大图！！！"" title=""高清无码大图！！！""></span></p>
<ul>
<li>在 <code>Working Dir</code> 与 <code>Staged Snapshot</code> 两区，我依然画出了历史 <code>commit</code>。不过，未处于激活状态时，是以灰蒙状态般显示的。这个灰蒙状态实际意义上就是不存在的意思，此处是为理解上文中「处处皆 <code>commit</code>」之意而做。真正有多个 <code>commit</code> 的只有 <code>Commit History</code>区。</li>
<li>
<p>在我多方多查看参考资料时，发现大多是以箭头形式来指向，如 <code>Commit History</code> → <code>Staged Snapshot</code>。箭头性的示意图给了我一个误会，那就是 <code>Commit History</code> 控制着 <code>Staged Snapshot</code> 区，<code>Staged Snapshot</code> 区控制着 <code>Working Dir</code> 区。  </p>
<p>而事实上，我更乐意用&lt;font style=""color: red;""&gt;<strong>同步</strong>&lt;/font&gt;一词来做比喻。</p>
<ul>
<li>
<code>reset hard</code>的时候，是三区的 <code>commit</code> 相同步的；</li>
<li>
<code>reset mixed</code>的时候则是 <code>Commit History</code> 与 <code>Staged Snapshot</code> 之间的同步；</li>
<li>
<code>reset soft</code>就只有 <code>Commit History</code> 自己玩耍了。</li>
</ul>
</li>
</ul>
<p>可是，光是这样还不够。如<code>git reset hard HEAD^^</code>模式的时候，是将<code>HEAD^^</code>所在的 <code>&lt;commitID&gt;</code>同步至 <code>Staged Snapshot</code> 和 <code>Staged Snapshot</code> 区。看起来还是用箭头来指示比较合适。    <br>这里箭头容易造成的误导是这看起来像是 <code>Commit History</code> 在发号施令，故放弃使用箭头形式。那么是谁在发号施令呢？答：是 <code>reset</code> 命令（亦或者说是 <code>reset</code> 在使三者相同步）。  <br>施术者不同，职务不同，采用的形式不同。而我，我更偏向于这种<strong>同步</strong>性的符号，而非箭头这种指示性的符号。</p>
<ul><li>三副动图中，在 <code>Commit History</code> 区变化的是 <code>master</code> 对不同的 <code>commit</code> 的指向。三个区的所依据的同步状态既是 <code>HEAD</code> 所处的位置。亦可以说是，HEAD指向哪里，master 跟着到哪里。主导的可以说是通过 <code>master</code> 分支 指向 <code>commit</code> 的 <code>HEAD</code>。</li></ul>
<h5>3.2、 情况1.1 情况1.2 <code>--mixed</code>模式</h5>
<p>当为注明<code>reset</code>采用何种模式的时候，默认是采用<code>--mixed</code>模式  <br>此命令常常被用于撤销 <code>Staged Snapshot</code> 中的 <code>add</code> 进来的文件，一些教程如是说。可事实上，这个命令从始至终都没 <code>Working Dir</code> 啥事。</p>
<h6>1. <strong><code>git reset &lt;commitID&gt;</code></strong>
</h6>
<p>此种情况会移动<code>master</code>位置。   <br>如下图所示，其作用是将 <code>Commit History</code> 区<code>HEAD^^</code>处的 <code>&lt;commitID&gt;</code> 同步至 <code>Staged Snapshot</code> 区。<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/4.git-reset--commitID.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h6>2. <strong><code>git reset &lt;commitID&gt; &lt;file_path&gt;</code></strong>
</h6>
<p>如下图所示，<code>HEAD</code>位置是不变的,自然<code>HEAD</code>所指向的分支位置也是不变的。变化的只有 <code>Staged Snapshot</code> 区。<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/5.git-reset-commitID-file_path.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>如此，当你进行的<code>add</code>操作时，一般情况下，<code>Working Dir</code> 的 <code>commit</code> 是会超前于 <code>Commit History</code> 区 的 <code>commit</code>。  <br>当进行 <code>git reset &lt;file_path&gt;</code>（当未注明 <code>&lt;commitID&gt;</code> 时，默认采用 <code>HEAD</code>） 操作时，<code>Staged Snapshot</code> 区的 <code>commit</code> 恢复到上个状态。  <br>这看起来像是撤销操作，实质上是覆盖操作。即是如上图中的<code>6</code>跑到了现在的<code>7'</code>位置上</p>
<h6>3. 其它无关杂项</h6>
<ol>
<li>
<p>事实上， <code>HEAD</code> <code>&lt;file_path&gt;</code> 均可省略书写，</p>
<ul>
<li>
<code>git reset &lt;file_path&gt;</code>  等价于 <code>git reset HEAD &lt;file_path&gt;</code>
</li>
<li>
<code>git reset</code>              等价于 <code>git reset HEAD</code>
</li>
</ul>
</li>
<li>
<code>git reset &lt;commitID&gt; .</code> 并不等价于 <code>git reset &lt;commitID&gt;</code>
</li>
</ol>
<p><code>git reset HEAD^^ .</code> 也不会移动 <code>HEAD</code>，因为 <code>.</code> 就是代表了所有文件。这样，<code>reset</code> 的操作对象又变成了 <code>Staged Snapshot</code> 区。</p>
<h5>3.3 情况2 <strong>hard —— <code>git reset --hard &lt;commitID&gt;</code></strong>
</h5>
<p>此命令用于你做错了事情，想要彻底抹除踪迹。  <br>采用<code>hard</code>模式的时候，意味着你想要丢弃在 <code>Working Dir</code> 区中的修改。之后继续进行你的工作。详细的 <code>commit</code> 步骤不讲了，对照第一条看即可。放张图给你。<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/6.git-reset-hard.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ol>
<li>
<code>git reset --hard HEAD^^</code>命令使得 <code>master</code> 分支情况发生改变，版本回退了两个，这里就有危险要发生了。  <p>假如你已经将最新的<code>「6commit」</code>推送到远程库。这个时候，你通过<code>hard</code>回退了两个版本，<code>「5commit」</code>与<code>「6commit」</code>已被在本地 Commit History 区 删除掉（我亦用了灰蒙状态来表示）。这个时候，你再次进行<code>git commit &lt;file_path&gt;</code>操作时，新的 commit 将是<code>「55commit」</code>。至此，你已与远程库的 <code>Commit History</code> 历史相冲突了。反正，我能想到的解决办法只有将远程库删除掉，重新推送本地库，除此之外没有其它招了。</p>
</li>
<li>
<code>git reset --hard HEAD</code>命令</li>
</ol>
<p>与<code>git reset --hard HEAD^^</code>命令相比，<code>git reset --hard HEAD</code>命令要柔和的多。如下图所示：  <br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/7.git-reset-hard-head.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>这个是恢复当前 HEAD 所在的 commit 到以下两个区。也就不存在与远程库相冲突的问题了。</p>
<h5>3.4 情况3 <strong>soft —— <code>git reset --soft HEAD^^</code></strong>
</h5>
<p>soft 仅仅是移动 <code>Commit History </code>区的 <code>master</code> 就不同的 <code>commit</code> 的指向。没什么好说的了。</p>
<h3>4、checkout 命令</h3>
<ul>
<li>情况1.1: <strong>切换<code>HEAD</code>到具体分支</strong>「如 <code>git checkout dev</code>」</li>
<li>情况1.2: <strong>切换<code>HEAD</code>到匿名分支</strong>「如 <code>git checkout &lt;commitID&gt;</code>」</li>
<li>情况2:  <strong><code>Staged Snapshop 区 &lt;commitID&gt;</code>的同步操作，未有分支切换</strong>「如 <code>git checkout &lt;file_path&gt;</code>」</li>
<li>情况3: <strong><code>Commit History 区 &lt;commitID&gt;</code>同步操作，未有分支切换</strong> 如「<code>git checkout &lt;commitID&gt; &lt;file_path&gt;</code>」</li>
</ul>
<h5>4.1、 checkout 作用对象是谁？答：看你写谁</h5>
<ol><li>当 <code>checkout</code> 用于「情况1.1」，或者「情况1.2」时，那么其作用对象就是 <strong>Commit History 中的 HEAD</strong>。</li></ol>
<p>其作用是让 <code>HEAD</code> 指向某一个 <code>&lt;commitID&gt;</code> 并将 此 <code>&lt;commitID&gt;</code> 的内容同步至 <code>Staged Snapshot</code> 与 <code>Working Dir</code></p>
<ol><li>而当 checkout 用于「情况2」，其作用对象为当前 <strong>Staged Snapshot 区的 commitID</strong>。</li></ol>
<p>其作用是让 <strong>当前 <code>Staged Snapshop</code></strong> 区的 <code>&lt;commitID&gt;</code> 同步进 <strong>当前 <code>Woring Dir</code></strong></p>
<ol><li>而当 <code>checkout</code> 用于「情况3」，其作用对象为 <strong>Commit History 中 的 <code>&lt;commitID&gt;</code>，而非 HEAD</strong>。</li></ol>
<p>其作用是 同步<code>Commit History</code>上某一个<code>&lt;commitID&gt;</code>的内容至当下的<code>Staged Snapshop</code> 与 <code>Woring Dir</code> 区</p>
<h5>4.2、 情况1.1 &amp;&amp; 1.2</h5>
<p><strong>HEAD基本上是一直处于指向某一分支的情况的（HEAD指针指向发生过变动），如 HEAD → master、HEAD → dev 亦或是 HEAD → 匿名分支</strong></p>
<ol><li><code>git checkout dev</code></li></ol>
<p>我们可以使用诸如<code>git branch dev</code>般的命令达到切换分支的效果。这里可以注意一下，所谓的分支切换，<strong>其实质只不过是更改 HEAD 的指向</strong>。切换分支的时候就是在更改 HEAD 指向哪个分支</p>
<ol><li><code>git checkout &lt;commitID&gt;</code></li></ol>
<p>当我们不写明具体的分支名称的时，而却是写了一个 <code>Commit History</code> 中的一个 <code>&lt;commitID&gt;</code>。那么，<code>HEAD</code> 将被直接切换指向到这个 <code>&lt;commitID&gt;</code>。这个时候我们可以称其为<strong>匿名分支</strong>  <br>修改 bug 的时候会常常这么做吧。  <br>如下图，此时，你可以通过<code>git branch fix_bug</code>命令新建分支，之后在<code>merge</code>到主分支。</p>
<p><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/8.git-checkout-commitID.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h5>4.3、 情况2: <code>git checkout &lt;file_path&gt;</code>
</h5>
<p><strong>HEAD 未发生过变动，一直处于当前分支。</strong></p>
<p><code>git checkout &lt;file_path&gt;</code>命令常常被用于丢弃本地修改。  <br><strong>&lt;span style=""color:red""&gt;实质上这是一个 Staged Snapshot 区 与 Working Dir 区 两区相同步的一个操作。同步的方向是由 Staged Snapshot 区 → Working Dir 区。&lt;/span&gt;</strong><br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/9.git-checkout-file_path.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>其作用效果与<code>git reset --hard test.txt</code>差不多，只是在<code>git reset --hard test.txt</code>中，Staged Snapshot 区的 <code>commit</code> 被更新了一次，但它和原来一样。</p>
<h5>4.4、 情况3: 命令组合<code>git checkout &lt;commitID&gt; &lt;file_path&gt;</code>
</h5>
<p><strong>HEAD 未发生过变动，一直处于当前分支。</strong></p>
<p><strong>&lt;span style=""color:red""&gt;<code>git checkout HEAD^^ &lt;file_path&gt;</code>命令是将 Commit History 中 的 commit 同步到 Staged Snapshot 和 Working Dir 区。而 Commit History 中的 HEAD 并未发生移动。&lt;/span&gt;</strong>  </p>
<p><code>git checkout HEAD^^ &lt;file_path&gt;</code>命令造成的结果是 Staged Snapshot 区的 commit 与 Working Dir 区的 commit 保持一致，而与 Commit History 当前的 commit 不同（HEAD未移动的原因）  <br>如下图，即 4' = 4'' ≠ 6<br><span class=""img-wrap""><img data-src=""https://halfmoonvic.github.io/images/git-reset-checkout/10.git-checkout-commitID-file_path.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>同时，我们可以通过 <strong><code>git checkout HEAD^^ .</code></strong> 命令将过去的某一版本下的所有文件放置当前的文件目录下面，而不更改 <code>HEAD</code> 指针</p>
<h5>4.5 总结</h5>
<p>情况1.1，情况1.2，未有指定 <code>&lt;file_path&gt;</code> 这时，会发生 <code>HEAD</code> 的变动，其指向自然也是由 <code>Commit History</code> 指向 <code>Staged Snapshot</code> 和 <code>Woring Dir</code>    <br>情况2，情况3 指定了 <code>&lt;file_path&gt;</code>时（针对操作是特定文件），如果没有指定 Commit Id，则默认从 <code>Staged Snapshot</code> → <code>Woring Dir</code>  <br>如果指定了 <code>&lt;commitID&gt;</code>, 则是 在 <code>&lt;commitID&gt;</code> → <code>Staged Snapshot</code>， <code>&lt;commitID&gt;</code> → <code>Woring Dir</code></p>
<h3>结语</h3>
<p>个人对git的基本命令的理解就是这些。平常使用 Git 过程当中，大致上可以随心所欲的控制各个 commit 版本了。  <br>以上均是学习过程当中个人总结，如有纰漏之处，请一定指出来啊。。。</p>
<h3>参考资料：</h3>
<p><a href=""https://marklodato.github.io/visual-git-guide/index-zh-cn.html"" rel=""nofollow noreferrer"">图解Git</a></p>
<p><a href=""https://medicineyeh.wordpress.com/2015/01/22/%E7%B4%B0%E8%AA%AAgit-reset%E5%92%8Cgit-checkout%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E8%99%95/"" rel=""nofollow noreferrer"">細說git reset和git checkout的不同之處</a></p>
<p><a href=""https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting"" rel=""nofollow noreferrer"">Reset, Checkout, and Revert</a></p>
<p><a href=""https://stackoverflow.com/questions/11200839/why-git-cant-do-hard-soft-resets-by-path"" rel=""nofollow noreferrer"">Why git can't do hard/soft resets by path?</a></p>

                ", 有关 Git 中 commit 的原理 理解 及 reset、checkout 命令详解,1531977961,145,1,343,1,1,https://segmentfault.com/a/1190000005638174
207,1,0,7,"
                    
<p>偶然的机会看到了<a href=""https://hexo.io/zh-cn/"" rel=""nofollow noreferrer"">Hexo</a>，就深深被吸引了，加载速度快，支持Makedown,还支持部署到Github上。作为一位PHP程序员，之前的博客用的是PHP开发的WordPress,其实感觉WordPress也不错，找了个漂亮的WordPress模板，加上七牛的CDN缓存，速度上，还算满意。既然对WordPress感觉不错，那为什么要把博客从WordPress迁移到Hexo上呢。第一，好奇，以前就经常听说Node.js有多么多么好，要把PHP给替代掉什么的，虽然Node.js的作用只是用来生成静态页面的，但可以感觉到，生成速度的确快；第二，支持Makedown，早就想学习Makedown了，正好边写博客，边学Makedown；第三，支持部署到Github上，以前WordPress都是部署到阿里云的云服务器ECS上的，还单独买了一个云数据库RDS，一个月得一百多块的花销，现在可以免费地放在Github上，省了一百多块钱，何乐而不为呢，哈哈。。不罗嗦了，直接上步骤。。</p>
<h3>配置环境</h3>
<p><strong>1.安装Node.js</strong>  <br>Centos之类的,yum install nodejs &amp;&amp; sudo yum install npm  <br>Mac OS X系统,使用brew install node 安装一下  <br>如果需要源码安装，可以去<a href=""https://nodejs.org"" rel=""nofollow noreferrer"">Node官网</a>下载,然后编译安装  <br><strong>2.安装git</strong>  <br>和上面一样，yum或brew或源码安装一下，这里就不再多说。可以参考此文档:<a href=""https://git-scm.com/book/en/v2/Getting-Started-Installing-Git"" rel=""nofollow noreferrer"">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a> 进去可以选择中文,</p>
<h3>安装Hexo</h3>
<p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<pre><code class=""bash"">npm install -g hexo-cli  
npm install hexo-server --save</code></pre>
<h3>使用Hexo</h3>
<pre><code class=""bash"">npm install hexo-cli -g
hexo init blog
cd blog
npm install
hexo server</code></pre>
<p>浏览器输入<a href=""http://localhost:4000"" rel=""nofollow noreferrer"">http://localhost:4000</a><br>效果图如下:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000007462096?w=600&amp;h=516"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""hexo-default-web"" title=""hexo-default-web""></span></p>
<h3>更换主题与配置</h3>
<p>默认的主题不是特别好看，我们可以在<a href=""https://hexo.io/themes/"" rel=""nofollow noreferrer"">Hexo官网的主题页</a>选择自己喜欢的主题，我选的是<a href=""https://github.com/litten/hexo-theme-yilia"" rel=""nofollow noreferrer"">yilia</a>。  <br><strong>1.安装</strong></p>
<pre><code class=""bash"">cd blog
git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia
cd themes/yilia
git pull</code></pre>
<p><strong>2.主题修改配置</strong>  <br>修改blog目录下的 _config.yml ： theme: yilia</p>
<p><strong>3.yilia配置</strong></p>
<pre><code class=""bash"">cd blog/theme/yilia
vim _config.yml</code></pre>
<p>然后根据里面的提示填写就行了，这里就不多说了。里面有个多说的配置，litten可能有点没说清楚，其实填写的是多说站点设置里的多说域名你填写的部分。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624509"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""duoshuo-domain"" title=""duoshuo-domain""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624511"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""duoshuo-domain"" title=""duoshuo-domain""></span><br>我这里如下填写：</p>
<pre><code>duoshuo: jsyzchen
</code></pre>
<p><strong>4.添加Share.js</strong></p>
<blockquote><p><a href=""https://github.com/overtrue/share.js"" rel=""nofollow noreferrer"">Share.js</a> 一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等</p></blockquote>
<p>编辑yilia目录下的_config.yml</p>
<pre><code class=""bash"">#是否开启分享
share_jia: false
share_addthis: false
share_social: true   #这里添加Share.js的开关</code></pre>
<p>编辑yilia/layout/_partial/head.ejs文件，加入代码</p>
<pre><code class=""html"">&lt;% if (theme.share_social){ %&gt;
&lt;%- css('https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.13/css/share.min') %&gt;
&lt;% } %&gt;</code></pre>
<p>进入yilia/layout/_partial/post目录，添加share_social.ejs文件,代码如下</p>
<pre><code class=""html"">&lt;div style=""padding:0 40px 10px;""&gt;
    &lt;!-- social-share Button BEGIN --&gt;
    &lt;div class=""social-share""&gt;&lt;/div&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.15/js/social-share.min.js""&gt;&lt;/script&gt;
    &lt;!-- social-share Button END --&gt;
&lt;/div&gt;</code></pre>
<p>编辑yilia/layout/_partial/article.ejs文件，找到theme.share_jia和share_addthis的位置，把加载social-share的代码放在与他们同级的位置</p>
<pre><code class=""html"">&lt;% if (!index &amp;&amp; theme.share_social){ %&gt;
&lt;%- partial('post/share_social') %&gt;
&lt;% } %&gt;</code></pre>
<h3>WordPress迁移</h3>
<p>现在我们将WordPress的文章迁移到Hexo，如果你不需要迁移，跳过即可。  <br>首先，安装 hexo-migrator-wordpress 插件。</p>
<pre><code class=""bash"">npm install hexo-migrator-wordpress --save</code></pre>
<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href=""https://en.support.wordpress.com/export/"" rel=""nofollow noreferrer"">WP支持页面</a>）。  <br>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。</p>
<pre><code class=""bash"">hexo migrate wordpress &lt;source&gt;</code></pre>
<p>完成之后可以</p>
<pre><code class=""bash"">hexo server</code></pre>
<p>浏览器输入<a href=""http://localhost:4000"" rel=""nofollow noreferrer"">http://localhost:4000</a> 查看效果</p>
<h3>配置Github</h3>
<p><strong>1.申请GitHub</strong>  <br><a href=""https://github.com/"" rel=""nofollow noreferrer"">GitHub</a>直接申请一下就好了。</p>
<p><strong>2.新建Repository(仓库)</strong></p>
<p>登陆Github账号后，点击右上角的“+”号按钮，选择“New repository”  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624515"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""new-repository"" title=""new-repository""></span></p>
<p>在Create a new repository界面填写格式如下图所示: 用户名.github.io，固定写法<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624517"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""create-a-new-repository"" title=""create-a-new-repository""></span></p>
<p><strong>3.设置你的git用户名和密码</strong></p>
<p>Git会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理。  <br>git config --global user.name""这里是你申请Github账号时的name""  <br>git config --global user.email""这里是你申请Github账号时的邮箱""</p>
<p><strong>3.SSH配置</strong></p>
<p>SSH配置，有些麻烦。可以参考此文档：<a href=""https://git-scm.com/book/en/v2/GitHub-Account-Setup-and-Configuration"" rel=""nofollow noreferrer"">https://git-scm.com/book/en/v2/GitHub-Account-Setup-and-Configuration</a>,进去可以选择中文,还是比较详细的。<br><strong>4.部署</strong></p>
<p>进入blog目录下,编辑 _config.yml，把下面的your_username换成你的github用户名，注意冒号后面有一空格。</p>
<pre><code>deploy:
    type: git
    repo: https://github.com/your_username/your_username.github.io.git
    branch: master
    </code></pre>
<h3>部署代码到Github</h3>
<p><strong>1.清除缓存文件 (db.json) 和已生成的静态文件 (public)。</strong></p>
<pre><code class=""bash"">hexo clean</code></pre>
<p><strong>2.生成静态文件</strong></p>
<pre><code class=""bash"">hexo generate</code></pre>
<p><strong>3.部署</strong></p>
<pre><code class=""bash""> hexo deploy</code></pre>
<p>上面2、3两个命令可以合起来</p>
<pre><code class=""bash"">hexo d -g</code></pre>
<p>如果你此时没有看到一大段执行代码，一般是SSH配置有误。  <br>如果成功了，你进入Github repository,就是your_username.github.io是有代码的  <br>此时，你在浏览器里输入<a href=""http://your_username.github.io"" rel=""nofollow noreferrer"">http://your_username.github.io</a> 就可以看到你的博客了</p>
<h3>效果展示</h3>
<p>我的WordPress和Hexo博客对比图:  <br>1.原来的WordPress  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624519"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""wordpress-blog-pictures"" title=""wordpress-blog-pictures""></span><br>2.如今的Hexo  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624521"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""hexo-blog-pictures"" title=""hexo-blog-pictures""></span><br>怎么感觉变丑了呢，没事，能省钱就好了，哈哈。。</p>
<h3>绑定域名</h3>
<p>虽然使用your_username.github.io可以直接访问博客，但如果你想用自己的域名打开博客。  <br><strong>1.域名解析</strong></p>
<p>进入你的域名解析管理控制台，设置主机记录@，类型A，到IP 192.30.252.153(GitHub IP)。  <br>我用的是万网,设置如下:  <br><span class=""img-wrap""><img data-src=""/img/remote/1460000005624523"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""hexo-blog-pictures"" title=""hexo-blog-pictures""></span><br><strong>2.GitHub设置</strong></p>
<p>在github项目中，blog/source目录下,新建一个文件CNAME，文件中写出你要绑定的域名,比如我的是jsyzchen.com</p>
<p><strong>3.部署更新文件</strong></p>
<pre><code class=""bash"">hexo clean
hexo g -d</code></pre>
<p>然后在浏览器输入你绑定的域名就可以看到你的Hexo博客了</p>
<h3>性能优化</h3>
<p>所谓的性能优化，也就是把能一些图片,js,css放入cdn里,这样的话加载速度会大大加快，我这里推荐的<a href=""http://www.qiniu.com/"" rel=""nofollow noreferrer"">七牛云存储</a>,它有免费的额度，一般像博客这样的系统文件不会超的，而且七牛的CDN挺不错的，加载速度挺快。至于如何设置，可以查看七牛的帮助文档，你可以使用七牛的镜像存储，这样你就不需要把你的文件一个一个地往七牛存了，你可能还需要改些你选择主题的源码，就是把它以前调的图片，js，css地址改为CDN的访问地址就行了，这里不在啰嗦了。</p>
<h3>文档推荐</h3>
<p>1.Hexo官方文档: <a href=""https://hexo.io/zh-cn/docs/"" rel=""nofollow noreferrer"">https://hexo.io/zh-cn/docs/</a>  <br>2.Git文档,里面有Git介绍、安装和使用等等，GitHub讲解也有: <a href=""https://git-scm.com/doc"" rel=""nofollow noreferrer"">https://git-scm.com/doc</a><br>3.Node.js官网: <a href=""https://nodejs.org"" rel=""nofollow noreferrer"">https://nodejs.org</a><br>4.MakeDown语法中文版: <a href=""http://www.markdown.cn/"" rel=""nofollow noreferrer"">http://www.markdown.cn/</a></p>
<h3>参考文章</h3>
<p>1.<a href=""http://www.jianshu.com/p/465830080ea9"" rel=""nofollow noreferrer"">HEXO+Github,搭建属于自己的博客</a>  <br>2.<a href=""http://www.jianshu.com/p/a2023a601ceb"" rel=""nofollow noreferrer"">hexo--搭建</a><br>3.<a href=""http://blog.fens.me/hexo-blog-github/"" rel=""nofollow noreferrer"">Hexo在github上构建免费的Web应用</a></p>
<p><strong>为了更好的交流，可以加QQ群：415183844</strong></p>
<p><strong>码字不容易,转载请注明原地址，Jsyz Chen的博客：<a href=""http://jsyzchen.com/2016/04/30/blog-wordpress-to-hexo/"" rel=""nofollow noreferrer"">http://jsyzchen.com/2016/04/30/blog-wordpress-to-hexo/</a> 谢谢！</strong></p>

                ", 博客从WordPress迁移到Hexo,1531977963,408,1,397,1,1,https://segmentfault.com/a/1190000005624504
208,1,0,7,"
                    
<h2>1、说明</h2>
<p>codebrag是一款审核代码的工具，安装部署很简单。现在网上有很多代码审核工具，收费的开源的一大堆，开源的比较好的是Facebook的phabricator，这款工具功能非常强大，利用得当非常利于开发，但是安装部署比较麻烦，并且团队使用需要所有人学习。而codebrag操作很简单，部署和使用相对方便。</p>
<h2>2、安装</h2>
<p>首先、从官网<a href=""http://www.codebrag.com"" rel=""nofollow noreferrer"">http://www.codebrag.com</a>下载程序代码，或者直接从github搜索拷贝下来。<br>然后、就需要部署安装需要审核代码的系统文件。官方的指导文件上<a href=""https://github.com/softwaremill/codebrag/wiki/installation"" rel=""nofollow noreferrer"">https://github.com/softwaremill/codebrag/wiki/installation</a></p>
<p><strong>安装要求</strong></p>
<ul>
<li><p>需要安装java7，并且不支持java8</p></li>
<li><p>安装git工具,版本1.7以及以上</p></li>
</ul>
<p><strong>安装过程</strong></p>
<p>1.克隆版本库</p>
<p>git</p>
<pre><code>cd codebrag-2.3/repos
git clone git://yourcompany.com/path/to/project-abc.git</code></pre>
<p>svn</p>
<pre><code>cd codebrag-2.3/repos
git svn clone http://yourcompany.com/path/to/svn/project-abc project-abc    
 # Use 'git svn clone', not 'svn checkout'</code></pre>
<p>2.修改配置文件<br>如果版本库需要账户密码验证，可以找<code>cdoebrag.conf</code>文件，添加以下配置：</p>
<pre><code>repository {
    username = ""johndoe""
    password = ""password""
}</code></pre>
<p>若需要安全认证的秘钥，则添加以下配置：</p>
<pre><code>repository {
    passphrase = ""secret_passphrase""
}</code></pre>
<p>3.运行Codebrag</p>
<ul>
<li><p>windows环境下，直接运行<code>codebrag.bat</code>文件</p></li>
<li><p>linux环境下，<code>./codebrag.sh</code></p></li>
</ul>
<h2>3、使用说明</h2>
<p><strong>管理员</strong><br>第一个注册的用户成为管理员，然后可以邀请其他人，向其他人发送注册链接进行注册。</p>
<p><strong>审核代码</strong><br>审核代码过程是需要开发人员上传到版本库之后，根据版本库的更新记录进行识别。直接在左上角选择所要审核的项目，然后中间那个选项为项目的版本控制分枝，最右边的那个选项选择<code>all</code>就可以看到所有之前上传的记录了。</p>
<p><strong>更新代码</strong><br>coderbrag是只和svn或git的版本库进行关联，没有和用户有直接联系，所以开发人员按照原来的方式进行操作就可以了。</p>

                ", codebrag审核代码工具安装配置,1531977965,200,1,230,1,1,https://segmentfault.com/a/1190000005624216
209,1,0,7,"
                    
<p>看完昨天的文章「<a href=""http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/"" rel=""nofollow noreferrer"">从0开始学习 GitHub 系列之「初识 GitHub」</a>」估计不少人已经开始期待我继续更新了，这不赶紧马不停蹄，加班加点给你们更新了第二篇。在更新本篇文章之前先回答昨天大家留言的两个问题：</p>
<ul><li><p>GitHub 需要翻墙么？</p></li></ul>
<p>印象中 GitHub 之前确实总是断断续续的访问不了，不过在13年初的时候有段时间最严重，一度被封了，当时李开复老师再也忍无可忍，公开发了一条抗议 GitHub 被封的微博，这事我印象很深，因为我是12年底加入的 GitHub ，那时候简直像遇到世外桃源一般，但是也深受老是访问不了的困扰，很多人早就对这件事怨声载道了，加上李开复老师的声讨，这一下就炸开了锅，微博上纷纷转发谴责，算的上是整个IT界的大新闻，后来因为这事影响太大了，没过几天 GitHub 就可以正常访问了，这里真的要感谢李开复老师敢于站出来的勇气，可以这么说，如果没有 GitHub ，中国的编程水平起码要倒退好多年！</p>
<p>因为 GitHub 的影响力太大，基本上是各种黑客攻击的对象，所以现在偶尔也会有宕机访问不了的情况，但是好在不会被封，所以大家不用担心，访问 GitHub 不用翻墙，只是可能访问速度稍慢些，另外为了维护一个和谐的环境，这里也呼吁大家不要在 GitHub 上发表任何关于政治的言论与文章，在 GitHub 上我们只是单纯的技术交流，无关政治，在复杂的大环境下，希望 GitHub 永远是我们程序员的一片净土！</p>
<ul><li><p>英语差、0基础学得会么？</p></li></ul>
<p>这个也是不少人问我的，GitHub 虽然都是英文，但是对英语水平的要求不是那么高，都是些简单的单词，遇到不会的查一下就行了，你觉得很难只是你对英文网站反射性的抵触而已，相信我，跟着我的详细教程，我的文章面向从没有接触过甚至没有听过 GitHub 的同学，一步步教你由浅入深。如果你学不会，那么来打我，不过我这么帅，你也不忍心！</p>
<p>好了，废话不多说，咱们进入正文！</p>
<h2>1. 注册 GitHub</h2>
<p>先去 GitHub 官网「How people build software · GitHub」注册「Sign Up」个账号，注册页面如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006783413"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个应该没啥说的，需要填用户名、邮箱、密码，值得一提的用户名请不要那么随便，最好取的这个名字就是你以后常用的用户名了，也强烈建议你各大社交账号都用一样的用户名，这样识别度较高，比如我的博客域名、GitHub、知乎等其他社交账号 ID 都是 stormzhang ，微博是因为被占用了，无奈换了个id，而且这个用户名以后在 GitHub 搭建博客的时候默认给你生成的博客地址就是 <a href=""http://username.github.io"" rel=""nofollow noreferrer"">http://username.github.io</a> ，所以给自己取个好点的用户名吧。</p>
<p>填好用户名、邮箱、密码紧接着到这一步：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611463"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个是什么意思呢？GitHub 有两种，一种是公开，这种是免费的，就是你创建的项目是开放的，所有人都能看得到；另一种是私有，这种是收费的，这种一般是很多企业在使用 GitHub 的私有仓库在托管自己的项目，这也是 GitHub 的一种盈利模式对于个人你就直接默认选择公开的就行了。</p>
<h2>2. 认识 GitHub</h2>
<p>注册成功之后你会到 GitHub 的主页面来：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611474"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>你如果是新注册的可能看到的跟我不一样，因为你们新用户，没有自己的项目，没有关注的人，所以只有一个导航栏。</p>
<p>导航栏，从左到右依次是 GitHub 主页按钮、搜索框、PR、Issues、Gist（这些概念后面会讲的）、消息提醒、创建项目按钮、我的账号相关。</p>
<p>我的 Timeline，这部分你可以理解成微博，就是你关注的一些人的活动会出现在这里，比如如果你们关注我了，那么以后我 star、fork 了某些项目就会出现在你的时间线里。</p>
<p>我的项目，这部分就不用说了，如果你创建了项目，就里就可以快捷访问。</p>
<h2>3. GitHub 主页</h2>
<p>点击下图的 Your profile 菜单进入到你的个人 GitHub 主页。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611487"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>还是以我的 GitHub 主页为例：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611484"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这么详细应该不会看不懂吧？只不过你的账号可能没有这么丰富，因为你可能啥也没做过，但是如果做全了基本上就会看到跟我一样的了。</p>
<h2>4. 设置你的 GitHub</h2>
<p>如果你是新注册的 GitHub 账号，是不是觉得很简陋？虽然你没有自己的项目，但是第一步起码要先完善自己的信息，点击如下的 Settings 菜单：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611478"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>到设置页面来设置一些基本信息：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611476"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>像头像、Name 建议要设置一个常用的，这两个很有识别性，公开的邮箱也要设置一个，这样那些企业啊、猎头啊就通过这个公开邮箱去联系你，友情提醒：别在 GitHub 把自己的 QQ 邮箱放上去，不显得太 low 了么？没有 gmail 邮箱，起码也得注册个 foxmail、163 邮箱之类的吧。</p>
<h2>5. GitHub 基本概念</h2>
<p>上面认识了 GitHub 的基本面貌之后，你需要了解一些 GitHub 的基本概念，这些概念是你经常会接触并遇到的。</p>
<ul><li><p>Repository</p></li></ul>
<p>仓库的意思，即你的项目，你想在 GitHub 上开源一个项目，那就必须要新建一个 Repository ，如果你开源的项目多了，你就拥有了多个 Repositories 。</p>
<ul><li><p>Issue</p></li></ul>
<p>问题的意思，举个例子，就是你开源了一个项目，别人发现你的项目中有bug，或者哪些地方做的不够好，他就可以给你提个 Issue ，即问题，提的问题多了，也就是 Issues ，然后你看到了这些问题就可以去逐个修复，修复ok了就可以一个个的 Close 掉。</p>
<ul><li><p>Star</p></li></ul>
<p>这个好理解，就是给项目点赞，但是在 GitHub 上的点赞远比微博、知乎点赞难的多，如果你有一个项目获得100个star都算很不容易了！</p>
<ul><li><p>Fork</p></li></ul>
<p>这个不好翻译，如果实在要翻译我把他翻译成分叉，什么意思呢？你开源了一个项目，别人想在你这个项目的基础上做些改进，然后应用到自己的项目中，这个时候他就可以 Fork 你的项目，这个时候他的 GitHub 主页上就多了一个项目，只不过这个项目是基于你的项目基础（本质上是在原有项目的基础上新建了一个分支，分支的概念后面会在讲解Git的时候说到），他就可以随心所欲的去改进，但是丝毫不会影响原有项目的代码与结构。</p>
<ul><li><p>Pull Request</p></li></ul>
<p>发起请求，这个其实是基于 Fork 的，还是上面那个例子，如果别人在你基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候他就可以发起一个 Pull Request（简称PR） ，原有项目创建人就可以收到这个请求，这个时候他会仔细review你的代码，并且测试觉得OK了，就会接受你的PR，这个时候你做的改进原有项目就会拥有了。</p>
<ul><li><p>Watch</p></li></ul>
<p>这个也好理解就是观察，如果你 Watch 了某个项目，那么以后只要这个项目有任何更新，你都会第一时间收到关于这个项目的通知提醒。</p>
<ul><li><p>Gist</p></li></ul>
<p>有些时候你没有项目可以开源，只是单纯的想分享一些代码片段，那这个时候 Gist 就派上用场了！</p>
<h2>6. 创建自己的项目</h2>
<p>点击顶部导航栏的 + 可以快速创建一个项目，如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611482"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>创建一个项目需要填写如上的几部分：项目名、项目描述与简单的介绍，你不付费没法选择私有的，所以接着只能选择 public 的，之后勾选「Initialize this repository with a README」，这样你就拥有了你的第一个 GitHub 项目：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005611480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到这个项目只包含了一个 README.md 文件，但是它已经是一个完整的 Git 仓库了，你可以通过对它进行一些操作，如watch、star、fork，还可以 clone 或者下载下来。</p>
<p>这里提一下 README.md ，GitHub 上所有关于项目的详细介绍以及 Wiki 都是基于 Markdown 的，甚至之后在 GitHub 上搭建博客，写博客也是如此，所以如果还不懂 Markdown 语法的，建议先去学习下。推荐一篇学习 Markdown 的文章给你们：</p>
<p><a href=""http://www.jianshu.com/p/q81RER"" rel=""nofollow noreferrer"">献给写作者的 Markdown 新手指南</a></p>
<h2>7. 总结</h2>
<p>相信看完以上文章你已经基本算是了解 GitHub 的基本概念并且正式加入 GitHub 这个大家庭了，之后会有更深入的文章介绍 Git、介绍对项目的常用操作、介绍如何给开源项目提交代码、介绍如何协同合作甚至怎么搭建博客等，敬请期待吧！</p>
<p><br></p>
<blockquote><p>本文原创发布于微信公众号 <strong>AndroidDeveloper「googdev」</strong>，转载请务必注明出处！</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004843315"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 从0开始学习 GitHub 系列之「加入 GitHub」,1531977966,495,1,661,1,1,https://segmentfault.com/a/1190000005611460
210,1,0,7,"
                    
<h2>说明</h2>
<p>Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被诸如Capistrano和Vlad the Deployer这样的部署工具所使用。[来自某度]</p>
<p>此文章会持续更新，总结自己使用git遇到的错误以及解决办法。</p>
<h2>git开发错误总结</h2>
<h3>cannot lock ref</h3>
<h4>错误描述</h4>
<blockquote><p>error: cannot lock ref 'refs/remotes/origin/dev': ref refs/remotes/origin/dev is at 19070aed6873f8d58f35e4631272b59f13927a1c but expected 8a5b3bda0778070bd6b92123556475c9484e04b8<br>From 120.26.77.241:yourWorkspace/yourProject</p></blockquote>
<p>如果使用的sourceTree可视化工具，看到的完整的信息是这样的：<br>git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree fetch origin <br>error: cannot lock ref 'refs/remotes/origin/dev': ref refs/remotes/origin/dev is at 19070aed6873f8d58f35e4631272b59f13927a1c but expected 8a5b3bda0778070bd6b92123556475c9484e04b8<br>From 120.26.77.241:dongjia/php<br> ! 8a5b3bd..007af81  dev        -&gt; origin/dev  (unable to update local ref)<br>Completed with errors, see above</p>
<h4>解决办法</h4>
<p>进入到项目根目录，执行下面命令：</p>
<pre><code>rm .git/refs/remotes/origin/dev

git fetch</code></pre>
<p>如果没有权限，请加sudo，windows用户在文件工具开启查看隐藏文件，进入到对应目录删除该文件即可。</p>

                ", git中常见的错误,1531977968,113,1,791,1,1,https://segmentfault.com/a/1190000005346163
211,1,0,7,"
                    
<h2>1. 写在前面</h2>
<p>我一直认为 GitHub 是程序员必备技能，程序员应该没有不知道 GitHub 的才对，没想到这两天留言里给我留言最多的就是想让我写关于 GitHub 的教程，说看了不少资料还是一头雾水，我转念一想，我当初接触 GitHub 也大概工作了一年多才开始学习使用，我读者里很多是初学者，而且还有很多是在校大学生，所以不会用 GitHub 也就不奇怪了，所以我觉得写一写关于 GitHub 的教程就非常有必要了！</p>
<h2>2. 为什么还要造轮子</h2>
<p>很多人难免要问这个问题，说网上关于 GitHub 的资料很多，为什么还要写呢？讲真，网上关于 Android 的资料更多，为什么你们还喜欢看我写的文章呢？是因为哪怕同样的内容，我写出来之后就有了我的风格，除了我的幽默以及我的帅，关键的是我有办法让你们看的轻松易懂，并且还有我个人的一些见解与指导，这大概是一种特殊的魅力吧！</p>
<p>我是从小白一路过来的，很能理解你们内心的感受与困惑，因为这些阶段都是我自己亲身经历过的，所以我写的文章都会从你们的角度去出发，并且我对文章高要求，除了排版、配图很用心外，文章的内容每次写完我都会亲自看三四遍，确保不会出现误导以及你们理解不了的情况，你们看的很轻松易懂的文章其实因为我背后做了很多的功课。</p>
<p>所以，为了你们，我觉得有必要用我的风格去教你们如何从0开始，跟着我一步步学习 GitHub ！</p>
<h2>3. 什么是 GitHub</h2>
<p>确切的说 GitHub 是一家公司，位于旧金山，由 Chris Wanstrath, PJ Hyett 与 Tom Preston-Werner 三位开发者在2008年4月创办。这是它的 Logo：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVwCDN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2008年4月10日，GitHub正式成立，地址：How people build software · GitHub ，主要提供基于git的版本托管服务。一经上线，它的发展速度惊为天人，截止目前，GitHub 已经发展成全球最大的开（同）源（性）社区。</p>
<h2>4. GitHub 与 Git 的关系</h2>
<p>这个我还专门在群里调查过，很多人以为 GitHub 就是 Git，其实这是一个理解误区。</p>
<p>Git 是一款免费、开源的分布式版本控制系统，他是著名的 Linux 发明者 Linus Torvalds 开发的。说到版本控制系统，估计很多人都用过 SVN ，只不过 Git 是新时代的产物，如果你还在用 SVN 来管理你的代码，那就真的有些落伍了。不管是学习 GitHub ，还是以后想从事编程行业，Git 都可以算是必备技能了，所以从现在开始建议你先去学习熟悉下 Git ，后面我会有文章推荐一些适合新手的 Git 学习资料给你们。</p>
<p>而 GitHub 上面说了，主要提供基于 git 的版本托管服务。也就是说现在 GitHub 上托管的所有项目代码都是基于 Git 来进行版本控制的，所以 Git 只是 GitHub 上用来管理项目的一个工具而已，GitHub 的功能可远不止于此！</p>
<h2>5. GitHub 的影响力</h2>
<p>上面我说了 GitHub 现在毫无疑问基本是全球最大的开源社区了，这样说你们可能认为未免有点浮夸，且听我一一举证：</p>
<p>全球顶级科技公司纷纷加入 GitHub ，并贡献他们自己的项目代码</p>
<ul>
<li><p>Google: <a href=""https://github.com/google"" rel=""nofollow noreferrer"">https://github.com/google</a></p></li>
<li><p>苹果: <a href=""https://github.com/apple"" rel=""nofollow noreferrer"">https://github.com/apple</a></p></li>
<li><p>Facebook: <a href=""https://github.com/facebook"" rel=""nofollow noreferrer"">https://github.com/facebook</a></p></li>
<li><p>Twitter：<a href=""https://github.com/twitter"" rel=""nofollow noreferrer"">https://github.com/twitter</a></p></li>
<li><p>微软：<a href=""https://github.com/microsoft"" rel=""nofollow noreferrer"">https://github.com/microsoft</a></p></li>
<li><p>Square：<a href=""https://github.com/square"" rel=""nofollow noreferrer"">https://github.com/square</a></p></li>
<li><p>阿里：<a href=""https://github.com/alibaba"" rel=""nofollow noreferrer"">https://github.com/alibaba</a></p></li>
<li><p>...</p></li>
</ul>
<p>全球顶级开源项目都优先选择在 GitHub 上开源</p>
<ul>
<li><p>Linux：<a href=""https://github.com/torvalds/linux"" rel=""nofollow noreferrer"">https://github.com/torvalds/linux</a></p></li>
<li><p>Rails：<a href=""https://github.com/rails/rails"" rel=""nofollow noreferrer"">https://github.com/rails/rails</a></p></li>
<li><p>Nodejs：<a href=""https://github.com/nodejs/node"" rel=""nofollow noreferrer"">https://github.com/nodejs/node</a></p></li>
<li><p>Swift：<a href=""https://github.com/apple/swift"" rel=""nofollow noreferrer"">https://github.com/apple/swift</a></p></li>
<li><p>CoffeeScript：<a href=""https://github.com/jashkenas/coffeescript"" rel=""nofollow noreferrer"">https://github.com/jashkenas/coffeescript</a></p></li>
<li><p>Ruby：<a href=""https://github.com/ruby/ruby"" rel=""nofollow noreferrer"">https://github.com/ruby/ruby</a></p></li>
<li><p>...</p></li>
</ul>
<p>全球顶级编程大牛加入GitHub</p>
<p>Linux 发明者 Linus Torvalds：<a href=""https://github.com/torvalds"" rel=""nofollow noreferrer"">https://github.com/torvalds</a></p>
<p><span class=""img-wrap""><img data-src=""https://pic4.zhimg.com/7c5c4724afd68e72aa8df9b1b80a492b_b.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Rails 创始人 DHH：<a href=""https://github.com/dhh"" rel=""nofollow noreferrer"">https://github.com/dhh</a></p>
<p><span class=""img-wrap""><img data-src=""https://pic2.zhimg.com/e6a32ec3773a3c834b16304a0b610d3d_b.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>被称为「Android之神」的 JakeWharton：<a href=""https://github.com/JakeWharton"" rel=""nofollow noreferrer"">https://github.com/JakeWharton</a> ， 你们用的很多开源库如 ButterKnife、OkHttp、 Retrofit、 Picasso、ViewPagerIndicator 等都是出自他之手！</p>
<p><span class=""img-wrap""><img data-src=""https://pic2.zhimg.com/9960fcbbefaf41823077cfae7fa639ad_b.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>其他就不一一列举了，GitHub 上活跃的很多是 Google 、Square、阿里等公司的员工，有些甚至还是Google Android Team组的，所以在这里你可以接触到全球顶级编程大牛！</p>
<h2>6. GitHub 有什么用</h2>
<ul><li><p>学习优秀的开源项目</p></li></ul>
<p>开源社区一直有一句流行的话叫「不要重复发明轮子」，某种意义上正是因为开源社区的贡献，我们的软件开发才能变得越来越容易，越来越快速。试想你在做项目时，如果每一模块都要自己去写，如网络库、图片加载库、ORM库等等，自己写的好不好是一回事，时间与资源是很大的成本。对于大公司可能会有人力与资源去发明一套自己的轮子，但是对于大部分互联网创业公司来说时间就是一切。而且你在使用开源项目的过程也可以学习他们优秀的设计思想、实现方式，这是最好的学习资料，也是一份提升自己能力的绝佳方式！</p>
<ul><li><p>多人协作</p></li></ul>
<p>如果你想发起一个项目，比如翻译一份不错的英文文档，觉得一个人的精力不够，所以你需要更多的人参与进来，这时候 GitHub 是你的最佳选择，感兴趣的人可以参与进来，利用业余时间对这个项目做贡献，然后可以互相审核、合并，简直不要太棒！</p>
<ul><li><p>搭建博客、个人网站或者公司官网</p></li></ul>
<p>这个就不用多说了，现在越来越多的博客都是基于 GitHub Pages 来搭建的了，你可以随心所欲的定制自己的样式，可以给你博客买个逼格高的域名，再也不用忍受各大博客网站的约束与各式各样的广告了！</p>
<ul><li><p>写作</p></li></ul>
<p>如果你喜欢写作，而且基于 Markdown， 并准备出版书籍，那么推荐你用 Gitbook ，技术写作人的最爱！</p>
<ul><li><p>个人简历</p></li></ul>
<p>如果你有一个活跃的 GitHub 账号，上面有自己不错的开源项目，还经常给别的开源项目提问题，push 代码，那么你找工作将是一个非常大的优势，现在程序员的招聘很多公司都很看中你 GitHub 账号，某种意义上 GitHub 就可以算是你的简历了。而且不仅国内，很多国外的科技公司都会通过 GitHub 来寻找优秀的人才，比如我甚至通过 GitHub 收到过 Facebook 的邀请邮件！</p>
<ul><li><p>其他</p></li></ul>
<p>当然 GitHub 能做的还远不止这些，我见过很多在 GitHub 搞的一些有意思的项目，有找男朋友的，甚至还有利用 GitHub 的 commit 丧心病狂的秀恩爱的，没错，那个丧心病狂的人就是我，如果你前段日子关注了我的 GitHub ，那么能看到这么一个壮观的景象：<br><span class=""img-wrap""><img data-src=""https://pic3.zhimg.com/a2185ec57eb7790ed27445a07bd762c2_b.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>7. 加入 GitHub</h2>
<p>读完我的文章，我相信你已经蠢蠢欲动了，从现在开始，立刻、马上去注册个 GitHub 「<a href=""https://github.com/"" rel=""nofollow noreferrer"">https://github.com/</a>」，去体验一番，不会用不要紧，接下来我会有一系列详细的文章，来教你学会使用 GitHub ！</p>
<p>但是为了保证文章的质量，我要做很多准备工作，我没法保证每天都会连载，但是我会尽力尽快更新这个系列，让你们从0开始一步步一起来学习，如果周围有同学或者朋友想要学习的，那赶紧转发或者推荐他关注这个系列的文章，毕竟有个小伙伴一起学会更有氛围，后续除了理论我还会考虑结合实践，我不信你学不会！</p>
<blockquote><p>本文原创发布于微信公众号 <strong>AndroidDeveloper「googdev」</strong>，转载请务必注明出处！</p></blockquote>

                ", 从0开始学习 GitHub 系列之「初识 GitHub」,1531977970,453,1,86,1,1,https://segmentfault.com/a/1190000005341489
212,1,0,7,"
                    
<h3>背景</h3>
<p>前一段时间，是通过百度云的BAE部署自己的Node应用的，不过随着应用的不断开发，BAE的限制不断制约了应用的使用。于是着手将应用迁移到阿里云的ECS上去。本文即是介绍了如何在ECS上搭建Node环境，并将本地制作好的应用进行发布。</p>
<h3>环境介绍</h3>
<p><strong>本地：</strong> Mac OSX 10.11.4，应用采用的技术：Node.js + Express.js</p>
<p><strong>远端服务器：</strong>阿里云ECS（1核CPU、1GB内存），IP：123.57.205.23，系统为CentOS7.0</p>
<p><strong>Github：</strong>账户名：e10101</p>
<h3>系统架构</h3>
<p>服务器部署Node的应用，并在3000端口进行监听。本地代码开发测试后，更新到Github私人仓库。然后通过pm2部署远程服务器。</p>
<h3>服务器端安装必要的软件</h3>
<p>拟安装如下应用：Node、npm、pm2。<br>通过预留的账号密码登录系统，终端中输入：</p>
<pre><code>ssh root@123.57.205.23
</code></pre>
<p>更新软件：</p>
<pre><code>yum update -y
</code></pre>
<p>更新完毕后，安装Node.js：</p>
<pre><code>yum install nodejs -y
</code></pre>
<p>安装Npm：</p>
<pre><code>yum install yum -y
</code></pre>
<p>安装pm2：</p>
<pre><code>npm install pm2 -g
</code></pre>
<h3>（可选）服务器端创建新用户</h3>
<p>为服务器安全起见，创建用户（用户名：yishi）：</p>
<pre><code>useradd yishi
</code></pre>
<p>设置密码：</p>
<pre><code>passwd yishi
</code></pre>
<p>添加sudo权限：</p>
<pre><code>usermod -aG wheel yishi
</code></pre>
<h3>（可选）服务器端关闭root用户的ssh访问</h3>
<p>为服务器安全起见，关闭root账户的远程访问。</p>
<p>打开配置文件：</p>
<pre><code>vi /etc/ssh/sshd_config
</code></pre>
<p>找到如下设置，并修改yes为no：</p>
<pre><code>PermitRootLogin no
</code></pre>
<p>保存文件后，重启sshd服务：</p>
<pre><code>service sshd restart
</code></pre>
<p>退出root账户，并使用新创建用户访问。</p>
<h3>本地安装pm2</h3>
<p>Macbook中，由于已经具备了node以及npm，再次不介绍如何安装上述两个软件了。与服务器端类似，通过如下命令安装pm2：</p>
<pre><code>npm install pm2 -g
</code></pre>
<p>如果可得到版本号，则说明安装成功：</p>
<pre><code>pm2 -v
</code></pre>
<h3>设置Github仓库</h3>
<p>此处为方便演示，我们在Github上新建一个私人（private）仓库，名为pm2app。</p>
<p>仓库创建后，还需要设置Deploy keys，依次点击Settings &gt; Deploy keys &gt; Add deploy key。其中的Key部分，可以在服务器端上通过ssh-keygen生成，并通过</p>
<pre><code>cat ~/.ssh/id_rsa.pub
</code></pre>
<p>即可输出。输出后，复制到deploy key中点击Add key，完成设置。</p>
<p>完成上述设置后，需要本地的应用代码关联此Github仓库，按照Github官网的介绍，通过在本地应用下执行：</p>
<pre><code>git remote add origin https://github.com/e10101/pm2app.git
git push -u origin master
</code></pre>
<p>来完成设置。</p>
<h3>本地pm2的ecosystem配置</h3>
<p>在本地的目标应用下，输入：</p>
<pre><code>pm2 ecosystem
</code></pre>
<p>生成pm2的部署配置模板文件如下：</p>
<pre><code>  /**
   * Application configuration section
   * PM2 - Application Declaration
   */
  apps : [
    // First application
    {
      name      : ""API"",
      script    : ""app.js"",
      env: {
        COMMON_VARIABLE: ""true""
      },
      env_production : {
        NODE_ENV: ""production""
      }
    },
    // Second application
    {
      name      : ""WEB"",
      script    : ""web.js""
    }
  ],
  /**
   * Deployment section
   * PM2 - Deployment
   */
  deploy : {
    production : {
      user : ""node"",
      host : ""212.83.163.1"",
      ref  : ""origin/master"",
      repo : ""git@github.com:repo.git"",
      path : ""/var/www/production"",
      ""post-deploy"" : ""npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production""
    },
    dev : {
      user : ""node"",
      host : ""212.83.163.1"",
      ref  : ""origin/master"",
      repo : ""git@github.com:repo.git"",
      path : ""/var/www/development"",
      ""post-deploy"" : ""npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env dev"",
      env  : {
        NODE_ENV: ""dev""
      }
    }
  }
}</code></pre>
<p>应为目前我们仅部署一个应用，因此，先把不必要的信息删除，即删除apps部分的第二项。同时把我们的目标文件改为你应用的入口文件，此处修改为Express.js的默认设置，即：</p>
<pre><code>script    : ""./bin/www"",
</code></pre>
<p>apps部分就设置完毕了，然后再设置deploy部分。其中production用于生产环境，dev用于开发环境，为了演示，我们只设置production部分。</p>
<p>下面依次介绍各个设置：</p>
<pre><code>    production : {
      user : ""登录远程服务器的用户名，此处填写我们创建的yishi"",
      host : ""远程服务器的IP或hostname，此处可以是数组同步部署多个服务器，不过鉴于我们只有一个服务器，因此我们填写123.57.205.23"",
      ref  : ""远端名称及分支名，此处填写origin/master"",
      repo : ""git仓库地址，此处填写git@github.com:e10101/pm2app.git"",
      path : ""远程服务器部署目录，需要填写user具备写入权限的目录，此处填写/home/yishi/www/production"",
      ""post-deploy"" : ""部署后需要执行的命令，此处填写npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production""
    },</code></pre>
<p>整理后，按照我们的设置，应为：</p>
<pre><code>production: {
  user: ""yishi"",
  host: ""123.57.205.23"",
  ref: ""origin/master"",
  repo: ""git@github.com:e10101/pm2app.git"",
  path: ""/home/yishi/www/production"",
  ""post-deploy"": ""npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production""
},</code></pre>
<p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：</p>
<pre><code>scp ~/.ssh/id_rsa.pub yishi@123.57.205.23:/home/yishi/.ssh/authorized_keys
</code></pre>
<p>上述命令中的yishi为用户名，执行时需要替换为你设置的用户名。</p>
<p>设置ssh完毕后，再看看整理完毕的ecosystem配置文件，如下：</p>
<pre><code>{
  /**
   * Application configuration section
   * PM2 - Application Declaration
   */
  apps : [
    // First application
    {
      name      : ""pm2app"",
      script    : ""./bin/www"",
      env: {
        COMMON_VARIABLE: ""true""
      },
      env_production : {
        NODE_ENV: ""production""
      }
    }
  ],
  /**
   * Deployment section
   * PM2 - Deployment
   */
  deploy : {
    production : {
      user: ""yishi"",
      host: ""123.57.205.23"",
      ref: ""origin/master"",
      repo: ""git@github.com:e10101/pm2app.git"",
      path: ""/home/yishi/www/production"",
      ""post-deploy"": ""npm install &amp;&amp; pm2 startOrRestart ecosystem.json --env production""
    }
  }
}</code></pre>
<p>在本地应用目录下，执行pm2 deploy命令：</p>
<pre><code>pm2 deploy ecosystem.json production setup
</code></pre>
<p>提示错误：</p>
<pre><code>Host key verification failed.
fatal: Could not read from remote repository.
Please make sure you have the correct access rights and the repository exists.
  failed to clone
Deploy failed</code></pre>
<p>此时主要是在远程服务器中，并未将<a href=""http://github.com"" rel=""nofollow noreferrer"">http://github.com</a>加入known_hosts，在服务器端通过如下命令设置：</p>
<pre><code>ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts
</code></pre>
<p>在本地继续执行部署命令：</p>
<pre><code>pm2 deploy ecosystem.json production setup
</code></pre>
<p>此时，如无其他问题，输出应提示：</p>
<pre><code>  ○ setup complete
--&gt; Success</code></pre>
<p>至此，pm2的部署设置完毕。</p>
<h3>pm2部署</h3>
<p>pm2的部署设置完毕后，接下来就是实际部署了。</p>
<p>在部署前，现将本地代码修改并进行git提交：</p>
<pre><code>git add .
git commit -m ""update ecosystem""
git push
</code></pre>
<p>提交后，在本地应用目录，输入如下命令进行生产环境的部署：</p>
<pre><code>pm2 deploy ecosystem.json production
</code></pre>
<p>可以看到如下输出：</p>
<pre><code>[PM2][WARN] Applications pm2app not running, starting...
[PM2] App [pm2app] launched (1 instances)
┌──────────┬────┬──────┬──────┬────────┬─────────┬────────┬─────────────┬──────────┐
│ App name │ id │ mode │ pid  │ status │ restart │ uptime │ memory      │ watching │
├──────────┼────┼──────┼──────┼────────┼─────────┼────────┼─────────────┼──────────┤
│ pm2app   │ 0  │ fork │ 1028 │ online │ 0       │ 0s     │ 11.246 MB   │ disabled │
└──────────┴────┴──────┴──────┴────────┴─────────┴────────┴─────────────┴──────────┘
 Use `pm2 show &lt;id|name&gt;` to get more details about an app
  ○ hook test
  ○ successfully deployed origin/master
--&gt; Success</code></pre>
<p>部署成功，在远程服务器查看端口情况：</p>
<pre><code>netstat -antp
</code></pre>
<p>可以看到应用默认部署的3000端口已经开放了。通过浏览器打开：</p>
<pre><code>http://123.57.205.23:3000/
</code></pre>
<p>可以看到部署的Web应用可以访问了。（如果netstat -antp中可见3000端口可访问，可以检查下ECS的防火墙设置，确保3000端口对外开放）</p>
<h3>pm2其他命令</h3>
<p>应用列表：</p>
<pre><code>pm2 list
</code></pre>
<p>应用信息（查看应用编号为0的信息）：</p>
<pre><code>pm2 show 0 
</code></pre>
<h3>（重要）服务器端设置pm2开机自动启动</h3>
<p>开启启动设置，此处是CentOS系统，其他系统替换最后一个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon）：</p>
<pre><code>pm2 startup centos
</code></pre>
<p>然后按照提示需要输入的命令进行输入：</p>
<pre><code>sudo su -c ""env PATH=$PATH:/usr/bin pm2 startup centos -u yishi --hp /home/yishi""
</code></pre>
<p>保存pm2设置</p>
<pre><code>pm2 save
</code></pre>
<p>现在重新启动系统，测试是否可以开机启动：</p>
<pre><code>sudo reboot
</code></pre>
<p>等系统重启后，通过浏览器检查系统是否自动启动：</p>
<pre><code>http://123.57.205.23:3000/
</code></pre>
<p>如果启动正常，说明设置成功！</p>
<p>以上就是如何通过pm2部署Node应用到服务器生成环境的总结。</p>
<h3>参考</h3>
<p>参考部分包含了一些先关链接，详见我的知乎专栏此：</p>
<blockquote><p>作者：郭一实<br>链接：<a href=""https://zhuanlan.zhihu.com/p/20940096"" rel=""nofollow noreferrer"">https://zhuanlan.zhihu.com/p/20940096</a><br>来源：知乎</p></blockquote>

                ", 通过Github与PM2部署Node应用,1531977972,561,1,756,1,1,https://segmentfault.com/a/1190000005171229
213,1,0,7,"
                    
<p>我其实也是个刚刚入行没多久的新人，github玩的比较少，上次发了一篇文章，部门老大希望我在github上创建一个演示demo使文章更加有说服力。</p>
<p>当时就去查了许多资料，百度里说得各种天花乱坠，没点用，我只想说：<br><span class=""img-wrap""><img data-src=""/img/bVvMH1?w=152&amp;h=220"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>能不能有点公德心，像百度上什么什么认证的人都是胡说八道，回答的牛头不对马嘴。花了好多时间的都没有弄好。后面自己花了许多精力，终于弄好了！<br>前面抱怨了几句百度答案的坑爹，现在详细说一下github上做一个demo演示的步骤：</p>
<h3>第一步：新建仓库</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMJu?w=666&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>登陆之后，在首页右侧找到如图所示的<code>New repository</code>按钮，点击新建一个仓库</p>
<h3>第二步：填写仓库说明</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMLV?w=1562&amp;h=1156"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>readme文档自己选择要不要，readme是一个markdown文档，可以在其中填写一些文字内容，展示在你的仓库页面</p>
<h3>第三步：通过GitHub Desktop客户端上传demo文档</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvML5?w=2032&amp;h=1590"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第四步：选择或创建一个本地仓库（用来同步到github.com）</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvML6?w=2476&amp;h=1532"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第五步：第四部完成后左上角就出现了你刚在github.com上创建的仓库</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvML9?w=2468&amp;h=1528"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第六步：将你的demo放在本地仓库里</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMc?w=1702&amp;h=1040"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第七步：打开Desktop客户端，点击Commit to master</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMh?w=2460&amp;h=1512"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第八步：点击右上角的publish发布</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMn?w=2460&amp;h=1522"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第九步：点击sync将demo文档同步到github.com上</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMu?w=2452&amp;h=1534"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第十步：在web端刷新，就可以看到你刚同步的demo</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMC?w=2044&amp;h=1310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第十一步：点击index.html进入，复制该页地址</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMH?w=2536&amp;h=1378"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>第十二步：在地址前加htmlpreview.github.io/?就可以访问了</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVvMMK?w=3350&amp;h=1880"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>完成</h3>
<p>其实百度等地方有很多这种教程，但是有些不够详细或者太含糊，所以结合自己当时的尴尬经历，写了这一个在github上创建demo演示的文章，希望能够帮助到一些和我当时一样刚入行或还在学习的小青年吧！！</p>

                ", 如何直接访问github的html项目,1531977973,142,1,912,1,1,https://segmentfault.com/a/1190000005153433
214,1,0,7,"
                    
<h1>如何使用 hexo＋github 搭建个人博客</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006768644"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>前段时间，在一次分享会上发现，很多人不知道 github 的一个强大功能 —— <strong>GitHub Pages</strong>，今天就介绍下。如果你不想要像新浪、csdn 这类样式丑、页面内容杂的博客网站，或者不想在移植、迁移上浪费精力，又或者不想付出多余的银子买VPS，那么 GitHub Pages 是不错的选择。</p>
<p>GitHub Pages 有以下几个优点：</p>
<ul>
<li><p>轻量级的博客系统，没有麻烦的配置</p></li>
<li><p>免费空间，享受 Git 版本管理功能</p></li>
<li><p>使用标记语言，比如 Markdown</p></li>
<li><p>无需自己搭建服务器</p></li>
<li><p>可以绑定自己的域名</p></li>
</ul>
<p>当然他也有缺点：</p>
<ul>
<li><p>搭配模板系统，相当于静态页发布，每运行生成一次都必须遍历全部的文本文件，网站越大，生成时间越长</p></li>
<li><p>动态程序的部分相当局限，比如没有评论，不过有解决方案</p></li>
<li><p>基于 Git，很多东西需要定制，不像 Wordpress 有强大的后台</p></li>
</ul>
<p>要想搭建漂亮的 blog，还需要模板系统，官方推荐的是 jekyll，但是配置稍复杂，今天推荐另一个选择 —— <a href=""https://hexo.io/"" rel=""nofollow noreferrer"">hexo</a>，一个简单地、轻量地、基于 Node 的一个静态博客框架。</p>
<p>下面介绍下如何使用 hexo 和 github pages 搭建个人博客。</p>
<h2>准备工作</h2>
<blockquote><p><em>注意:</em> 本文针对 Windows 平台和 Hexo 3.1.1</p></blockquote>
<h3>安装 github windows</h3>
<p>主要使用 git bash，如果对 git 命令不熟悉的也可以使用 git 客户端进行某些操作</p>
<p><a href=""https://windows.github.com/"" rel=""nofollow noreferrer"">github windows</a></p>
<h3>安装 node.js</h3>
<p>因为要使用 npm，比较简单的方法就是安装 node.js</p>
<p><a href=""http://nodejs.org/"" rel=""nofollow noreferrer"">node.js</a></p>
<blockquote><p>安装完成后添加 Path 环境变量，使 npm 命令生效</p></blockquote>
<pre><code class=""bash"">;C:\Program Files\nodejs\node_modules\npm</code></pre>
<h3>创建 Github Pages</h3>
<p>没有 github 账号的话，需要注册一个，不赘述</p>
<p>然后创建一个仓库，名字是[yourGithubAccount].github.io</p>
<h3>配置 ssh key</h3>
<p>使用 git bash 生成 public ssh key，以下是最简单的方法</p>
<pre><code class=""bash"">$ ssh-keygen -t rsa</code></pre>
<p>C/Documents and Settings/username/.ssh 目录下会生成 id_rsa.pub</p>
<p>将 id_rsa.pub 的内容完全复制到 github Account Setting 里的 ssh key 里即可</p>
<p>测试</p>
<pre><code class=""bash"">$ ssh -T git@github.com</code></pre>
<p>然后会看到</p>
<pre><code class=""bash"">Hi [yourGithubAccount]! You've successfully authenticated, but GitHub does not provide shell access.</code></pre>
<p>设置用户信息</p>
<pre><code class=""bash"">$ git config --global user.name ""[yourName]""//用户名
$ git config --global user.email  ""[yourEmail]""//填写自己的邮箱</code></pre>
<p>经过以上步骤，本机已成功连接到 github，为部署打下基础。</p>
<h2>配置 hexo</h2>
<h3>本地 clone</h3>
<p>创建本地目录，然后使用 git bash 或者客户端 clone 之前创建的仓库（[yourGithubAccount].github.io）</p>
<h3>安装、配置 hexo</h3>
<p>进入仓库目录，使用 git bash 安装配置 hexo</p>
<pre><code class=""bash"">$ npm install -g hexo-cli
$ npm install hexo --save
$ hexo init</code></pre>
<p>安装 hexo 插件</p>
<pre><code class=""bash"">npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked@0.2 --save
npm install hexo-renderer-stylus@0.2 --save
npm install hexo-generator-feed@1 --save
npm install hexo-generator-sitemap@1 --save</code></pre>
<blockquote><p>安装 ejs，否则无法解析模板</p></blockquote>
<pre><code class=""bash"">$ npm install</code></pre>
<p>生成 public 文件夹</p>
<pre><code class=""bash"">$ hexo g</code></pre>
<p>浏览器输入 localhost:4000 本地查看效果</p>
<pre><code class=""bash"">$ hexo s</code></pre>
<h3>主题</h3>
<p>hexo 有很多主题可选，我选了 <a href=""https://github.com/wuchong/jacman"" rel=""nofollow noreferrer"">Jacman</a>，默认支持多说评论、网站统计、分享等功能，只要稍微配置即可使用。可以根据自己需求进行选择。</p>
<h2>使用 hexo</h2>
<h3>部署</h3>
<p>配置 _config.yml</p>
<pre><code class=""bash"">deploy:
  type: git
  repository: git@github.com:[yourGithubAccount]/[yourGithubAccount].github.io.git
  branch: master</code></pre>
<pre><code class=""bash"">$ hexo d</code></pre>
<p>即可将 hexo 部署到 github 上</p>
<blockquote><p>提示找不到 git 时</p></blockquote>
<p>需执行（虽然之前已经执行过）</p>
<pre><code class=""bash"">npm install hexo-deployer-git --save</code></pre>
<p>然后</p>
<pre><code class=""bash"">$ hexo d</code></pre>
<p>即可通过 <a href=""http://%5ByourGithubAccount%5D.github.io/"" rel=""nofollow noreferrer"">http://[yourGithubAccount].github.io/</a> 查看了</p>
<h3>发表新文章</h3>
<pre><code class=""bash"">$ hexo new ""title""</code></pre>
<p>然后在 source/_post 下会生成该md文件，即可使用编辑器编写了</p>
<p>编写过程中，可以在本地实时查看效果，很是方便</p>
<p>支持 markdown，不了解的自行 google 吧</p>
<p>编写完成后，部署还是一样的</p>
<pre><code class=""bash"">$ hexo g
$ hexo d</code></pre>
<blockquote><p>如果部署过程中报错，可执行以下命令重新部署</p></blockquote>
<pre><code class=""bash"">$ hexo clean
$ hexo generate
$ hexo deploy</code></pre>
<h3>添加自定义页面</h3>
<pre><code class=""bash"">$ hexo new page ""about""</code></pre>
<p>该命令会生成 source/about/index.md，编辑即可</p>
<h3>插件的升级与卸载</h3>
<pre><code class=""bash"">$ npm update
$ npm uninstall &lt;plugin-name&gt;</code></pre>
<h3>更新 hexo</h3>
<pre><code class=""bash"">npm update -g hexo</code></pre>
<h3>绑定自定义域名</h3>
<p>在/source/ 目录下新建内容为自定义域名的 CNAME 文件，部署即可（域名设置略）</p>
<blockquote><p><em>备注：</em></p></blockquote>
<p>Hexo简写命令</p>
<pre><code class=""bash"">hexo n #new
hexo g #generate
hexo s #server
hexo d #deploy</code></pre>
<hr>
<p>以上是基本操作，质量高的 blog 所带来的好处是不言而喻的，感兴趣的可以行动起来了。</p>
<h2>参考资料</h2>
<ul>
<li><p><a href=""http://alfred-sun.github.io/blog/2014/12/05/github-pages/"" rel=""nofollow noreferrer"">http://alfred-sun.github.io/blog/2014/12/05/github-pages/</a></p></li>
<li><p><a href=""http://beiyuu.com/github-pages/"" rel=""nofollow noreferrer"">http://beiyuu.com/github-pages/</a></p></li>
<li><p><a href=""http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/"" rel=""nofollow noreferrer"">http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/</a></p></li>
<li><p><a href=""http://wsgzao.github.io/post/hexo-guide/"" rel=""nofollow noreferrer"">http://wsgzao.github.io/post/hexo-guide/</a></p></li>
<li><p><a href=""http://fy98.com/2014/03/03/build-blog-with-hexo/"" rel=""nofollow noreferrer"">http://fy98.com/2014/03/03/build-blog-with-hexo/</a></p></li>
</ul>

                ", 途牛原创｜如何使用 hexo＋github 搭建个人博客,1531977975,575,1,292,1,1,https://segmentfault.com/a/1190000005133715
215,1,0,7,"
                    
<p>这是一个系列文章，介绍了学习 Git 的好工具 - githug，如果你是第一次看到，请先阅读：<br><a href=""https://www.codingstyle.cn/topics/51"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树</a><br><a href=""https://codingstyle.cn/topics/57"" rel=""nofollow noreferrer"">闯过这 54 关，点亮你的 Git 技能树（一）</a></p>
<p>今天我将带大家完成第 11 - 20 关。如对任何命令有疑问请看第一篇里的推荐教程。</p>
<h2>第十一关</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006766228"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>在 git 里，创建一个新文件时，要用 <code>git add</code> 来告诉 git，同样，删除一个文件时候，也要告诉 git。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123833"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十二关</h2>
<p>有时候执行 add 操作的时候不小心把多余的文件 add 进去了，这时我们需要把它从 staging area 移除出来，但不能删除文件。<br>通过 <code>git help rm</code>，搜索 <code>cached</code>，可以看到有这个参数，刚好能满足我们的需求。</p>
<pre><code>--cached
    Use this option to unstage and remove paths only from the index. Working tree files, whether modified or
    not, will be left alone.</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005123838"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十三关</h2>
<p>这一关的场景也非常常见，回想一下以前我们用 CVS 或 SVN 的时候。<br>你写一个新需求写的正 High，突然你的主管找到你说有一个用户打电话来遇到一个问题，非常紧急。<br>我以前的做法是：把当前改过的文件「复制」一份先放在其它地方，把代码还原到没修改的状态，签出对应 production 环境的代码。<br>定位修复问题，提交代码，确认问题修复后再合并回开发分支，并把之前备份的代码复制进来进行合并。</p>
<p>stash 正是解决这个问题的，只需要 <code>git stash</code>，它就把当前未提交的改动「复制」到另一个地方暂存起来，待要恢复的时候执行 <code>git stash pop</code> 即可。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123873"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十四关</h2>
<p>这一关有两种解法，第一种是：</p>
<pre><code>mv oldfile.txt newfile.txt
git rm oldfile.txt
git add newfile.txt</code></pre>
<p>显然这样做用户体验很糟，Linux 肯定不会这么设计软件的。</p>
<p>第二种做法：<br><code>git mv oldfile.txt newfile.txt</code><br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123882"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十五关</h2>
<p>这一关相当于上一关的增强版，可以用通配符一起批量移动文件。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123871"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十六关</h2>
<p>有时候我们要看代码的提交历史，比如 <a href=""https://codingstyle.cn/topics/node20"" rel=""nofollow noreferrer"">Code Review</a> 的时候。<br>不过 git 自带的 <code>git log</code> 命令比较弱，建议使用 GUI 客户端或 tig。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123888"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十七关</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005123868"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十八关</h2>
<p><code>git push</code> 命令默认是不会 push Tags 的，需要加参数。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123884"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>第十九关</h2>
<p>有时候提交之后发现漏掉了某些文件，怎么办？<br>往往很多人就会选择再单独提交一次，这样做其实是不合理的，之前的 commit 就不完整了，有可能上了 CI 就会挂掉。<br>好的做法是 amend：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005123875"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>命令执行后会调用默认的编辑器编辑 commit message，它会自动带出之前的 message，如果不需要修改，直接保存退出即可。</p>
<h2>第二十关</h2>
<p>默认提交的时候记录的是当前系统时间，但这一关要求覆盖提交日期。<br>我想不到有什么场景需要这么做，邪恶一点，有可能你把周五的提交，日期写成周末，这样表示周末在加班。<br>纯属YY，千万不要学，学了也不要告诉别人是我教你的。<br><code>git help commit</code>，搜索 <code>date</code>：</p>
<pre><code>--date=&lt;date&gt;
    Override the author date used in the commit.</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005123886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>今天就到这里了，如果想第一时间得到更新，请关注 <a href=""https://codingstyle.cn"" rel=""nofollow noreferrer"">CodingStyle.cn</a>！</p>

                ", 闯过这 54 关，点亮你的 Git 技能树 (二),1531977977,311,1,357,1,1,https://segmentfault.com/a/1190000005123830
216,1,0,7,"
                    
<h2>序言</h2>
<p>微信作为手机上的第一大应用，有着上亿的用户。并且很多人都不只拥有一个微信帐号，有的微信账号是用于商业的，有的是用于私人的。可惜的是官方版的微信并不支持多开的功能，并且频繁更换微信账号也是一件非常麻烦的事，于是大家纷纷在寻找能够在手机上登陆多个微信账号的方法，相对于iOS，Android上早就有了很成熟的产品，比如360 OS的微信双开和LBE的双开大师就可以满足很多用户多开的需求。</p>
<p>但是在iOS上，因为苹果的安全机制，并没有任何知名的IT厂商推出微信多开的产品，反而是各种小公司的微信双开产品满天飞。但使用这些产品真的安全吗？今天我们就来看看这些产品的真面目。</p>
<h2>一、 “倍推微信分身”初探</h2>
<p>这次要分析的产品名字叫”倍推微信分身”，可以实现非越狱iOS上的微信多开。这个app的安装是通过itms-services，也就是企业证书的安装模式进行安装的。服务器是架在59os.com。可以看到除了微信分身以外，还有很多别的破解应用提供下载：<br><span class=""img-wrap""><img data-src=""/img/bVvlUH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>app安装完后的图标和微信的一模一样，只是名字变成了“倍推微信分身”： <br><span class=""img-wrap""><img data-src=""/img/bVvlUI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>下载完倍推微信分身，并登陆后，可以看到首页与原版微信并没有太大的变化，只是左上角多了一个VIP的标志：<br><span class=""img-wrap""><img data-src=""/img/bVvlUM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们知道，根据苹果的系统机制，一台iOS设备上不允许存在多个Bundle ID一样的app。因此，我们猜测这个微信分身app是修改过Bundle ID的。于是我们查看一下Info.plist，果然Bundle ID已经做了修改：<br><span class=""img-wrap""><img data-src=""/img/bVvlUN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>但是研究过iOS上微信分身的人一定知道，微信app在启动以及发送消息的时候会对Bundle ID做校验的，如果不是” com.tencent.xin”就会报错并退出。那么”倍推微信分身”是怎么做到的呢？经过分析，原来”倍推微信分身”是通过hook的手段，在app启动的时候对BundleID做了动态修改。至于怎么进行非越狱iOS上的hook可以参考我之前写的两篇文章：</p>
<p>【iOS冰与火之歌番外篇 - 在非越狱手机上进行AppHook】<br><a href=""http://drops.wooyun.org/papers/12803"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/12803</a></p>
<p>【iOS冰与火之歌番外篇 -App Hook答疑以及iOS 9砸壳】<br><a href=""http://drops.wooyun.org/papers/13824"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/13824</a></p>
<p>于是我们对”倍推微信分身”的binary进行分析，发现这个binary在启动的时候会load一个伪装成一个png文件的第三方的dylib– wanpu.png：<br><span class=""img-wrap""><img data-src=""/img/bVvlUQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>用file指令可以看到这个伪png文件其实是一个包含了armv7和arm64的dylib：<br><span class=""img-wrap""><img data-src=""/img/bVvlUT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们看到这个伪图片就像是一个寄生虫一样存在于微信app的体内，特别像dota里的Naix（俗称小狗）的终极技能 - 寄生，因此我们把这个高危样本称之为ImgNaix。<br><span class=""img-wrap""><img data-src=""/img/bVvlUV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>二、wanpu.png分析</h2>
<p>用ida打开wanpu.png，可以看到这个dylib分别对BundleID，openURL和NewMainFrameViewController进行了hook：<br><span class=""img-wrap""><img data-src=""/img/bVvlUY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>BundleID不用说，是为了让app在运行的时候改回”com.tencent.xin”。</p>
<p>NewMainFrameViewController的hook函数就是在微信主页上显示VIP的图片，以及传输一些非常隐私的用户数据（ssid, mac, imei等）到开发者自己的服务器上：<br><span class=""img-wrap""><img data-src=""/img/bVvlUW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVvlU2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>OpenURL这个hook就很有意思了，这个函数本身是用来处理调用微信的URL Schemes的。看过我之前写过的《iOS URL Scheme 劫持》的文章的人一定知道这个”倍推微信分身”是有能力进行URL Scheme劫持的，如果在Info.plist里进行了声明，手机上所有使用的URL Schemes的应用都有可能被hijack。</p>
<p>除了这些hook以外，我们在竟然在”倍推微信分身”的逆向代码里，发现了Alipay的SDK！一个没想到，在”倍推微信分身”的帮助下，支付宝和微信支付终于走到了一起：<br><span class=""img-wrap""><img data-src=""/img/bVvlU5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>因为捆绑了支付宝的SDK，”倍推微信分身”可以调用支付宝的快捷支付功能：<br><span class=""img-wrap""><img data-src=""/img/bVvlU7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>通过网络抓包分析，我们可以看到”倍推微信分身”会发送一些服务收费的数据到手机上：<br><span class=""img-wrap""><img data-src=""/img/bVvlVa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>经分析，”倍推微信分身”之所以加入支付宝sdk是为了对这个微信多开app进行收费。因为天下没有免费的午餐，软件开发者之所以制作腾讯的盗版软件”倍推微信分身”就是为了能够获取到一定的收入，所以才会接入支付SDK的。</p>
<h2>三、高危接口分析</h2>
<p>需要注意的是，”倍推微信分身”打开的url数据都是服务端可控的，并且没有进行加密，黑客可以使用MITM (Man-in-the-middle attack) 随意修改推送的内容，进行钓鱼攻击等操作。比如我通过DNS劫持就能够随意修改推送给用户的数据，以及诱导用户去下载我自己设定的企业app，简直和XcodeGhost一模一样（具体细节可以参考我之前发表的《你以为服务器关了这事就结束了？ - XcodeGhost截胡攻击和服务端的复现，以及UnityGhost预警》<a href=""http://drops.wooyun.org/papers/9024"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/9024</a>）。</p>
<p>这里我们进行DNS劫持并修改了推送的内容，同时我们把URL替换成了另一个企业应用的下载plist：<br><span class=""img-wrap""><img data-src=""/img/bVvlVd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以看到我们在启动”倍推微信分身”的时候弹出了更新对话框，还无法取消：<br><span class=""img-wrap""><img data-src=""/img/bVvlVl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点击后，”倍推微信分身”下载了我们替换后的企业应用，一个伪装成微信的假app：<br><span class=""img-wrap""><img data-src=""/img/bVvlVo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>除此之外，在分析的过程中，我们还发现”倍推微信分身”app还存在非常多的高危接口，并且可以利用第三方服务器的控制进行远程调用：</p>
<p>(1). “倍推微信分身”app利用动态加载的方式调用了很多私有API。比如app使用了MobileCoreServices里的[LSApplicationWorkspace allInstalledApplications]来获取手机上安装的应用：<br><span class=""img-wrap""><img data-src=""/img/bVvlVA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>比如app使用了SpringBoardServices的SBSLaunchApplicationWithIdentifier。这个API 可以在不需要urlscheme的情况下调起目标app：<br><span class=""img-wrap""><img data-src=""/img/bVvlVC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>比如app加载了和应用安装有关的私有Framework MobileInstallation以及预留了通过URL Scheme安装企业app的接口：<br><span class=""img-wrap""><img data-src=""/img/bVvlVJ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>(2). “倍推微信分身”app预留了一整套文件操作的高危接口，可以直接对微信app内的所有文件进行操作，这些文件包括好友列表，聊天记录，聊天图片等隐私信息。<br><span class=""img-wrap""><img data-src=""/img/bVvlVL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>要知道在iOS上，聊天记录等信息都是完全没有加密的保存在MM.sqlite文件里的：<br><span class=""img-wrap""><img data-src=""/img/bVvlVN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>总结</h2>
<p>虽然我们在样本分析的过程中除了获取用户隐私外，暂时没有捕获到恶意攻击的行为，但这个”倍推微信分身”预留了大量高危的接口（私有API，URL Scheme Hijack，文件操作接口等），并且破解者是可以随便修改客户端的内容，因此不要说推送任意广告和收费信息了，连窃取微信账号密码的可能性都有，简直就像一颗定时炸弹装在了手机上。这样的微信双开你还敢用吗？</p>
<p>从这个样本中，我们已经看到在非越狱iOS上的攻防技术已经变的非常成熟了，无论是病毒（XcodeGhost）还是破解软件（ImgNaix）都利用了很多苹果安全机制的弱点，并且随着研究iOS安全的人越来越多，会有更多的漏洞会被发现 (e.g., 利用XPC漏洞过App沙盒<a href=""http://drops.wooyun.org/papers/14170)"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/14170)</a>。此外，iOS上的app不像Android，简直一点防护措施都没有，当遇到黑客攻击的时候几乎会瞬间沦陷。正如同我在MDCC 2015开发者大会上所讲的，XcodeGhost只是一个开始而已，随后会有越来越多的危机会出现在iOS上，请大家做好暴风雨来临前的准备吧！</p>
<p><strong>作者：蒸米@阿里移动安全，更多安全技术文章，请查看<a href=""https://jaq.alibaba.com/community/index"" rel=""nofollow noreferrer"">阿里聚安全博客</a></strong></p>

                ", 微信双开是定时炸弹？关于非越狱iOS上微信分身高危插件ImgNaix的分析,1531977978,318,1,634,1,1,https://segmentfault.com/a/1190000005050164
217,1,0,7,"
                    
<blockquote><p>我说的以下流程，sourceTree等工具已经完美的支持了，鼠标点两下就完成了。简直是完美。</p></blockquote>
<h2>简介</h2>
<p>Feature Branch Workflow是一种非常灵活的开发方式。对于一些规模比较大的团队，最好就是给特定的分支赋予不同的角色。除了<strong>功能分支(feature branch)</strong>，Gitflow Workflow还使用独立的分支来<strong>准备发布(preparing)</strong>，<strong>维护(maintaining)</strong>, 和<strong>记录版本(recording releases)</strong>。</p>
<h2>分支类型和流程</h2>
<p>下图能说明整个流程，只要你看得懂的话。该模式来自 <a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer"">Nvie</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009050390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li><p>feature（多个、玫红）。主要是自己玩了，差不多的时候要合并回develop去。从不与master交互。</p></li>
<li><p>develop（1个、黄色）。主要是和feature以及release交互。</p></li>
<li><p>release（同一时间1个、绿色）。总是基于develop，最后又合并回develop。当然对应的tag跑到master这边去了。生命周期很短，只是为了发布</p></li>
<li><p>hotfix（同一时间1个、红色）。总是基于master，并最后合并到master和develop。生命周期较短，用了修复bug或小粒度修改发布。</p></li>
<li><p>master（1个蓝色）。没有什么东西，仅是一些关联的tag，因从不在master上开发。</p></li>
</ul>
<p>在这个模型中，master和develop都具有象征意义。master分支上的代码总是稳定的（stable build），随时可以发布出去。develop上的代码总是从feature上合并过来的，可以进行Nightly Builds，但不直接在develop上进行开发。当develop上的feature足够多以至于可以进行新版本的发布时，可以创建release分支。</p>
<p>release分支基于develop，进行很简单的修改后就被合并到master，并打上tag，表示可以发布了。紧接着release将被合并到develop；此时develop可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并。这步完成后就删除release分支。</p>
<p>当从已发布版本中发现bug要修复时，就应用到hotfix分支了。hotfix基于master分支，完成bug修复或紧急修改后，要merge回master，打上一个新的tag，并merge回develop，删除hotfix分支。</p>
<p>由此可见release和hotfix的生命周期都较短，master/develop虽然总是存在但却不常使用。</p>
<h2>分支详解</h2>
<h3>主分支 （Historical Branches）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009050391"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""主分支"" title=""主分支""></span></p>
<p>主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支分为<strong>master</strong>分支和<strong>development</strong>分支。</p>
<h5>master 分支</h5>
<p>master分支上存放的应该是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG）。</p>
<h5>develop分支</h5>
<p>develop分支是保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码（Nightly build）。因此这个分支有时也可以被称作整合分支（integration branch）。</p>
<h3>辅助分支</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005110614"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""辅助分支"" title=""辅助分支""></span></p>
<p>辅助分支是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。这些分支与主分支不同，通常只会在有限的时间范围内存在。</p>
<p>辅助分支包括：</p>
<ol>
<li><p>用于开发新功能时所使用的feature分支；</p></li>
<li><p>用于辅助版本发布的release分支；</p></li>
<li><p>用于修正生产代码中的缺陷的hotfix分支。</p></li>
</ol>
<p>以上这些分支都有固定的使用目的和分支操作限制。从单纯技术的角度说，这些分支与Git其他分支并没有什么区别，但通过命名，我们定义了使用这些分支的方法。</p>
<h4>feature 分支</h4>
<p>使用规范：</p>
<ol>
<li><p>可以从develop分支发起feature分支</p></li>
<li><p>代码必须合并回develop分支</p></li>
<li><p>feature分支的命名可以使用除<code>master</code>，<code>develop</code>，<code>release-*</code>，<code>hotfix-*</code>之外的任何名称</p></li>
</ol>
<p>feature分支（有时也可以被叫做“topic分支”）通常是在开发一项新的软件功能的时候使用，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。</p>
<h3>release分支（preparing）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005110615"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="" release分支"" title="" release分支""></span></p>
<p>使用规范：</p>
<ul>
<li><p>可以从develop分支派生</p></li>
<li><p>必须合并回develop分支和master分支</p></li>
<li><p>分支命名惯例：<code>release-*</code></p></li>
</ul>
<p>release分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。</p>
<p>当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。</p>
<p>成功的派生了release分支，并被赋予版本号之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。</p>
<h3>hotfix分支（maintaining）</h3>
<p>使用规范：</p>
<ul>
<li><p>可以从master分支派生</p></li>
<li><p>必须合并回master分支和develop分支</p></li>
<li><p>分支命名惯例：<code>hotfix-*</code></p></li>
</ul>
<p>除了是计划外创建的以外，hotfix分支与release分支十分相似：都可以产生一个新的可供在生产环境部署的软件版本。</p>
<p>当生产环境中的软件遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。</p>
<p>这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。</p>
<h2>问题</h2>
<h4>管理冲突</h4>
<ol>
<li><p>多个Feature 分支开发完成，提交到develop 分支时，修改了共同的模块。</p></li>
<li><p>release 分支或者hotfix 分支修改了bug合并回develop时，发现develop分支已经往前面走了一截。</p></li>
</ol>
<p>在执行可能有冲突的操作前，先查看一下 暂存区 和 工作目录，保证其中没有修改。</p>
<p>比如使用<code>git stash</code>就可以把暂存区 和 工作目录的修改保存起来，让暂存区 和 工作目录处于干净的状态。</p>
<h2>更进一步</h2>
<p>Gitflow workflow 和pull request 组合起来使用，代码审查机制的加入，会让这个模式大放异彩。下一篇文章中， 我会详细介绍 代码审查????。</p>
<h2>扩展：Forking Workflow</h2>
<p>Forking Workflow与以上讨论的工作流很不同，一个很重要的<strong>区别</strong>就是它不只是多个开发共享一个远程仓库(central repository)，而是每个开发者都拥有一个独立的服务端仓库。也就是说每个contributor都有两个仓库：本地私有的仓库和远程共享的仓库。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005110616"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Forking Workflow"" title=""Forking Workflow""></span><br>Forking Workflow</p>
<p>Forking Workflow这种工作流主要好处就是每个开发者都拥有自己的远程仓库，可以将提交的commits推送到自己的远程仓库，但只有工程维护者才有权限push提交的commits到官方的仓库，其他开发者在没有授权的情况下不能push。Github很多<strong>开源项目</strong>都是采用Forking Workflow工作流。</p>
<h3>文章来源</h3>
<p><a href=""http://www.techug.com/git-2"" rel=""nofollow noreferrer"">Git版本控制与工作流</a></p>
<p><a href=""http://www.ituring.com.cn/article/56870"" rel=""nofollow noreferrer"">基于git的源代码管理模型——git flow</a></p>

                ", 企业级开发：Gitflow Workflow工作流,1531977980,488,1,778,1,1,https://segmentfault.com/a/1190000005047758
218,1,0,7,"
                    
<h2>前言</h2>
<p>相信大部分使用 Git 的朋友都会遇见相同的疑问，并且也从网上搜索了不少资料。那么，为什么我还要写这篇文章呢？因为我想尝试从自己的角度解释这个问题，如果能给到大家灵光一闪的感悟，便善莫大焉啦。估计点进来的朋友也对 merge 和 rebase 有了一定了解，所以我也就不浪费篇幅再去详细介绍 merge 和 rebase，让我们直入主题吧。</p>
<h2>merge 与 rebase 的区别</h2>
<h3>merge(以下说明都基于 merge 的默认操作)</h3>
<p>现在假设我们有一个主分支 master 及一个开发分支 deve，仓库历史就像这样：</p>
<p><span class=""img-wrap""><img data-src=""http://7xinvi.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-26%2021.58.22.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""初始仓库历史"" title=""初始仓库历史""></span></p>
<p>现在如果在 master 分支上 <code>git merge deve</code>：Git 会自动根据两个分支的共同祖先即 <code>e381a81</code> 这个 commit 和两个分支的最新提交即 <code>8ab7cff</code> 和 <code>696398a</code> 进行一个三方合并，然后将<strong>合并中修改的内容生成一个新的 commit</strong>，即下图的 <code>78941cb</code>。</p>
<p><span class=""img-wrap""><img data-src=""http://7xinvi.com1.z0.glb.clouddn.com/hexo%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-26%2022.08.28.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""merge 合并图"" title=""merge 合并图""></span></p>
<h3>rebase</h3>
<p>rebase 是什么情况呢？还是一个初始的仓库历史图：</p>
<p><span class=""img-wrap""><img data-src=""http://7xinvi.com1.z0.glb.clouddn.com/hexo%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-26%2022.20.15.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rebase初始仓库历史"" title=""rebase初始仓库历史""></span></p>
<p>如果是在 master 分支上 <code>git rebase deve</code>：Git 会从两个分支的共同祖先 <code>3311ba0</code> 开始提取 master 分支（当前所在分支）上的修改，即 <code>85841be</code>、<code>a016f64</code> 与 <code>e53ec51</code>，再将 master 分支指向 deve 的最新提交（目标分支）即 <code>35b6708</code> 处，然后将刚刚提取的修改依次应用到这个最新提交后面。操作会舍弃 master 分支上提取的 commit，同时<strong>不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍</strong>,操作完成后的版本历史就像这样：</p>
<p><span class=""img-wrap""><img data-src=""http://7xinvi.com1.z0.glb.clouddn.com/hexo%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-26%2022.26.23.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rebase 合并图"" title=""rebase 合并图""></span></p>
<p>可以看见 master 分支从 deve 分支最新提交 <code>35b6708</code> 开始依次提交了自己的三个 commit（由于是提取修改后重新依次提交，故 commit 的 hash 码与上面的<code>85841be</code>、<code>a016f64</code>、<code>e53ec51</code> 不同）。</p>
<h3>rebase -i</h3>
<p>rebase 操作加上 <code>-i</code> 选项可以更直观的看见被提取的 commit 信息。</p>
<p>仍然在 master 分支上 rebase deve 分支，不过这次要加上 <code>-i</code> 选项，即 <code>git rebase -i deve</code>，然后我们可以得到这样一个文本信息框</p>
<p><span class=""img-wrap""><img data-src=""http://7xinvi.com1.z0.glb.clouddn.com/C48C3A61-64FD-4BD5-BD42-2CBF11937B4F.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rebase -i信息"" title=""rebase -i信息""></span></p>
<ul>
<li><p>A 区域内的信息说明了这次 rebase 操作提取了哪些 commit 记录（<code>f9a7673</code> 与 <code>edb2ba2</code>），会连接到目标分支的哪个 commit （<code>9c86a5c</code>）后面。可以根据 B 区域中的命令说明修改 <code>pick</code> 为其他命令，对该次提取出来的 commit 做额外的操作</p></li>
<li><p>B 区域内说明了本次 rebase 操作可以选用的命令</p></li>
<li><p>通过 <code>:wq</code> 保存退出后，就会按照刚刚在 A 区域内设定的命令处理 commit 并 rebase。</p></li>
</ul>
<h3>冲突处理策略的不同</h3>
<ul>
<li><p>merge 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge</p></li>
<li><p>rebase 遇见冲突后会暂停当前操作，开发者可以选择手动解决冲突，然后 <code>git rebase --continue</code> 继续，或者 <code>--skip</code> 跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分），亦或者 <code>--abort</code> 直接停止该次 rebase 操作</p></li>
</ul>
<h2>总结：选择 merge 还是 rebase？</h2>
<ul>
<li><p>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</p></li>
<li><p>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</p></li>
<li><p>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</p></li>
<li><p>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</p></li>
<li><p>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</p></li>
<li><p>merge 和 rebase 还有很多强大的选项，可以使用 <code>git help &lt;command&gt;</code> 查看</p></li>
</ul>
<h2>最后：一些注意点</h2>
<ul>
<li><p>使用 merge 时应考虑采用默认操作，还是 <code>--no-ff</code> 或 <code>--ff-only</code> 的方式</p></li>
<li><p>rebase 操作会丢弃当前分支已提交的 commit，故不要在已经 push 到远程，和其他人正在协作开发的分支上执行 rebase 操作</p></li>
<li><p>与远程仓库同步时，使用 pull 命令默认进行了 <code>git fetch + git merge</code> 两个操作，可以通过加上 <code>--rebase</code> 命令将 fetch 后的 merge 操作改为 rebase 操作，或者仅仅 'git fetch remoteName',然后才思考采取哪种整合策略 <code>git merge(or rebase) origin/master</code></p></li>
<li><p>开发与 commit 时注意自己此时在哪个分支上</p></li>
<li><p>当有修改未 commit 时，不能进行 rebase 操作，此时可以考虑先用 <code>git stash</code> 命令暂存</p></li>
</ul>
<h2>参考</h2>
<ul>
<li><p><a href=""https://git-scm.com/book/zh/v2"" rel=""nofollow noreferrer"">ProGit 2nd Edition</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/28140434/is-there-a-difference-between-git-rebase-and-git-merge-ff-only"" rel=""nofollow noreferrer"">Stackoverflow:Is there a difference between git rebase and git merge --ff-only</a></p></li>
<li><p><a href=""http://www.ruanyifeng.com/blog/2012/07/git.html"" rel=""nofollow noreferrer"">Git分支管理策略</a></p></li>
</ul>

                ", 闲谈 git merge 与 git rebase 的区别,1531977982,329,1,333,1,1,https://segmentfault.com/a/1190000005013964
219,1,0,7,"
                    
<blockquote><p>本文首发于<a href=""https://ourai.ws"" rel=""nofollow noreferrer"">欧雷流</a>。由于我会时不时对文章进行补充、修正和润色，为了保证所看到的是最新版本，请阅读<a href=""https://ourai.ws/posts/working-with-git-in-team/"" rel=""nofollow noreferrer"">原文</a>。</p></blockquote>
<p>在 2005 年的某一天，Linux 之父 Linus Torvalds 发布了他的又一个里程碑作品——Git。它的出现改变了软件开发流程，大大地提高了开发流畅度！直到现在仍十分流行，完全没有衰退的迹象。</p>
<p>本文不是一篇 Git 入门教程，这样的文章一搜一大把，我是要从具体实践角度，尤其是在团队协作中，阐述如何去好好地应用 Git。既然是讲在团队中的应用实践，我就尽可能地结合实际场景来讲述。</p>
<h2>习惯养成</h2>
<p>如果一个团队在使用 Git 时没有一些规范，那么将是一场难以醒来的噩梦！然而，规范固然重要，但更重要的是个人素质，在使用 Git 时需要自己养成良好的习惯。</p>
<h3>提交</h3>
<p>如何去写一个提交信息，《<a href=""http://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==&amp;mid=401622986&amp;idx=1&amp;sn=470717939914b956ac372667ed23863c&amp;scene=2&amp;srcid=0114ZcTNyAMH8CLwTKlj6CTN&amp;from=timeline&amp;isappinstalled=0#wechat_redirect"" rel=""nofollow noreferrer"">Git: 教你如何在Commit时有话可说</a>》中做了很好的说明。在具体开发工作中主要需要遵守的原则就是「使每次提交都有质量」，只要坚持做到以下几点就 OK 了：</p>
<ol>
<li><p>提交时的粒度是一个小功能点或者一个 bug fix，这样进行恢复等的操作时能够将「误伤」减到最低；</p></li>
<li><p>用一句简练的话写在第一行，然后空一行稍微详细阐述该提交所增加或修改的地方；</p></li>
<li><p>不要每提交一次就推送一次，多积攒几个提交后一次性推送，这样可以避免在进行一次提交后发现代码中还有小错误。</p></li>
</ol>
<p>假如已经把代码提交了，对这次提交的内容进行检查时发现里面有个变量单词拼错了或者其他失误，只要还没有推送到远程，就有一个不被他人发觉你的疏忽的补救方法——</p>
<p>首先，把失误修正之后提交，可以用与上次提交同样的信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006774598"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后，终端中执行命令 <code>git rebase -i [SHA]</code>，其中 SHA 是上一次提交之前的那次提交的，在这里是 <code>3b22372</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最后，这样就将两次提交的节点合并成一个，甚至能够修改提交信息！</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986354"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>谁说历史不可篡改了？前提是，<strong>想要合并的那几次提交还没有推送到远程！</strong></p>
<h3>推送</h3>
<p>当自己一个人进行开发时，在功能完成之前不要急着创建远程分支。</p>
<h3>拉取</h3>
<p>请读张文钿所写的《<a href=""https://ihower.tw/blog/archives/3843"" rel=""nofollow noreferrer"">使用 git rebase 避免無謂的 merge</a>》。</p>
<h3>合并</h3>
<p>在将其他分支的代码合并到当前分支时，如果那个分支是当前分支的父分支，为了保持图表的可读性和可追踪性，可以考虑用 <code>git rebase</code> 来代替 <code>git merge</code>；反过来或者不是父子关系的两个分支以及互相已经 <code>git merge</code> 过的分支，就不要采用 <code>git rebase</code> 了，避免出现重复的冲突和提交节点。</p>
<h2>分支管理</h2>
<p>Git 的一大特点就是可以创建很多分支并行开发。正因为它的灵活性，团队中如果没有一个成熟的分支模型的话，那将会是一团糟。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986361"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>要是谁真把这么乱的提交图表摆在我面前，就给他一个上勾拳！</p>
<h3>分支模型</h3>
<p>有个很成熟的叫「<a href=""http://nvie.com/posts/a-successful-git-branching-model/"" rel=""nofollow noreferrer"">Git Flow</a>」的分支模型，它能够应对 99% 的场景，剩下的那 1% 留给几乎不存在的极度变态的场景。</p>
<p>需要注意的是，<strong>它只是一个模型，而不是一个工具；你可以用工具去应用这个模型，也可以用最朴实的命令行。所以，重要的是理解概念，不要执着于实行的手段。</strong></p>
<p>简单说来，Git Flow 就是给原本普普通通的分支赋予了不同的「职责」：</p>
<ul>
<li><p><strong>master</strong>——最为稳定功能最为完整的随时可发布的代码；</p></li>
<li><p>hotfix——修复线上代码的 bug；</p></li>
<li><p><strong>develop</strong>——永远是功能最新最全的分支；</p></li>
<li><p>feature——某个功能点正在开发阶段；</p></li>
<li><p>release——发布定期要上线的功能。</p></li>
</ul>
<p>看到上面的「master」和「develop」加粗了吧？代表它们是「主要分支」，其他的分支是基于它们派生出来的。<strong>主要分支每种类型只能有一个，派生分支每个类型可以同时存在多个。</strong>各类型分支之间的关系用一张图来体现就是：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986363"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>更多信息可参考 <a href=""https://github.com/xirong"" rel=""nofollow noreferrer"">xirong</a> 所整理的《<a href=""https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md"" rel=""nofollow noreferrer"">Git工作流指南</a>》。</p>
<h3>工具选择</h3>
<p>一直不喜欢「＊＊最好用」这种命题，主观性太强，不会有一个结论。对于工具的选择，我一直都是秉承「哪个能更好地解决问题就用哪个」这个原则。所以，只要不影响到团队，用什么工具都是可以接受的。但根据多数开发人员的素质情况来看，建议使用图形化工具，例如 <a href=""https://www.sourcetreeapp.com"" rel=""nofollow noreferrer"">SourceTree</a>。如果想用命令行，可以啊！先在心里问下自己：「我 Git 牛逼不？会不会惹麻烦给别人？」</p>
<p>在团队中应用 Git Flow 时，推荐使用 SourceTree 与 <a href=""https://gitlab.com"" rel=""nofollow noreferrer"">GitLab</a> 配合的形式：</p>
<ol>
<li><p>用 SourceTree 创建 feature 等分支以及本地的分支合并、删除；</p></li>
<li><p>用 GitLab 做代码审核和远程的分支合并、删除。</p></li>
</ol>
<p>SourceTree 和 GitLab 应该是相辅相成的存在，而不是互相取代。</p>
<h2>事前准备</h2>
<p>为了将一些规范性的东西和 Git Flow 的部分操作自动化处理，要对 SourceTree 和 GitLab 进行一下配置。</p>
<h3>SourceTree</h3>
<p>按下 <code>command</code> + <code>,</code> 调出「Preferences」界面并切换到「Git」标签，勾选「Use rebase instead of merge by default for tracked branches」和「Do not fast-forward when merging, always create commit」。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986366"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这样设置之后，在点「Pull」按钮拉取代码时会自动执行 <code>git pull --rebase</code>；并且，每次合并时会自动创建新的包含分支信息的提交节点。</p>
<p>接下来，点击工具栏中的「Git Flow」按钮将相关的流程自动化。如果没有特殊需求，直接按下对话框中的「OK」就好了。初始化完成后会自动切换到 develop 分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986367"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这下再点「Git Flow」按钮所弹出的对话框就是选择创建分支类型的了。</p>
<h3>GitLab</h3>
<p>在创建项目仓库后一定要把主要分支，也就是 master 和 develop 给保护起来。为它们设置权限，只有项目负责人可以进行推送和删除等操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986369"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>被保护的分支在列表中会有特殊的标记进行区分。</p>
<h2>开发流程</h2>
<p>在引入 Git Flow 之后，所有工作都要围绕着它来展开，将原本的流程与之结合形成「基于 Git Flow 的开发流程」。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986371"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>开发功能</h3>
<p>在确定发布日期之后，将需要完成的内容细分一下分配出去，负责某个功能的开发人员利用 SourceTree 所提供的 Git Flow 工具创建一个对应的 feature 分支。如果是多人配合的话，创建分支并做一些初始化工作之后就推送创建远程分支；否则，直到功能开发完毕要合并进 develop 前，不要创建远程分支。</p>
<p>功能开发完并自测之后，先切换到 develop 分支将最新的代码拉取下来，再切换回自己负责的 feature 分支把 develop 分支的代码合并进来。合并方式参照上文中的「合并」，如果有冲突则自己和配合的人一起解决。</p>
<p>然后，到 GitLab 上的项目首页创建合并请求（merge request）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986373"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>「来源分支」选择要被合并的 feature 分支且「目标分支」选择 develop 分支后点击「比较分支」按钮，在出现的表单中将处理人指派为项目负责人。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986375"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>项目负责人在收到合并请求时，应该先做下代码审核看看有没有明显的严重的错误；有问题就找负责开发的人去修改，没有就接受请求并删除对应的 feature 分支。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004986377"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在将某次发布的所需功能全部开发完成时，就可以交付测试了。</p>
<h3>测试功能</h3>
<p>负责测试的人创建一个 release 分支部署到测试环境进行测试；若发现了 bug，相应的开发人员就在 release 分支上或者基于 release 分支创建一个分支进行修复。</p>
<h3>发布上线</h3>
<p>当确保某次发布的功能可以发布时，负责发布的人将 release 分支合并进 master 和 develop 并打上 tag，然后打包发布到线上环境。</p>
<p>建议打 tag 时在信息中详细描述这次发布的内容，如：添加了哪些功能，修复了什么问题。</p>
<h3>修复问题</h3>
<p>当发现线上环境的代码有小问题或者做些文案修改时，相关开发人员就在本地创建 hotfix 分支进行修改，具体操作参考「开发功能」。</p>
<p>如果是相当严重的问题，可能就得回滚到上一个 tag 的版本了。</p>
<h2>额外说明</h2>
<p>这里所提到的事情，虽非必需，但知道之后却会如虎添翼。</p>
<h3>分支命名</h3>
<p>除了主要分支的名字是固定的之外，派生分支是需要自己命名的，这里就要有个命名规范了。强烈推荐用如下形式：</p>
<ul>
<li><p>feature——按照功能点（而不是需求）命名；</p></li>
<li><p>release——用发布时间命名，可以加上适当的前缀；</p></li>
<li><p>hotfix——GitLab 的 issue 编号或 bug 性质等。</p></li>
</ul>
<p>另外还有 tag，用<a href=""http://semver.org/lang/zh-CN/"" rel=""nofollow noreferrer"">语义化的版本号</a>命名。</p>
<h3>发布日期</h3>
<p>发布频率是影响开发人员与测试人员的新陈代谢和心情的重要因素之一，频繁无规律的发布会导致内分泌失调、情绪暴躁，致使爆粗口、砸电脑等状况出现。所以，确保一个固定的发布周期至关重要！</p>
<p>在有一波或几波需求来临之时，想挡掉是不太可能的，但可以在评审时将它（们）分期，在某个发布日之前只做一部分。这是必须要控制住的！不然任由着需求方说「这个今天一定要上」「那个明天急着用」的话，技术人员就等着进医院吧！</p>

                ", 团队中的 Git 实践,1531977983,353,1,981,1,1,https://segmentfault.com/a/1190000004963641
220,1,0,7,"
                    
<h2>系统环境配置</h2>
<p>要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！</p>
<h3>安装Node.js</h3>
<p><a href=""https://nodejs.org/download/"" rel=""nofollow noreferrer"">下载Node.js</a><br>参考地址：<a href=""http://www.w3cschool.cc/nodejs/nodejs-install-setup.html"" rel=""nofollow noreferrer"">安装Node.js</a></p>
<h3>安装Git</h3>
<p>下载地址：<a href=""http://git-scm.com/download/"" rel=""nofollow noreferrer"">http://git-scm.com/download/</a></p>
<h3>安装Hexo</h3>
<pre><code class=""bash"">$ cd d:/hexo
$ npm install hexo-cli -g
$ hexo init blog
$ cd blog
$ npm install
$ hexo g # 或者hexo generate
$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</code></pre>
<p>这里有必要提下Hexo常用的几个命令：</p>
<ol>
<li><p>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</p></li>
<li><p>hexo server (hexo s) 启动本地web服务，用于博客的预览</p></li>
<li><p>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</p></li>
</ol>
<p>另外还有其他几个常用命令：</p>
<pre><code class=""bash"">$ hexo new ""postName"" #新建文章
$ hexo new page ""pageName"" #新建页面</code></pre>
<p>常用简写</p>
<pre><code class=""bash"">$ hexo n == hexo new
$ hexo g == hexo generate
$ hexo s == hexo server
$ hexo d == hexo deploy</code></pre>
<p>常用组合</p>
<pre><code class=""bash"">$ hexo d -g #生成部署
$ hexo s -g #生成预览</code></pre>
<p>现在我们打开<a href=""http://localhost:4000/"" rel=""nofollow noreferrer"">http://localhost:4000/</a> 已经可以看到一篇内置的blog了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006776519"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>目前我安装所用的本地环境如下：(可以通过hexo -v查看)</p>
<pre><code>hexo: 3.2.0
hexo-cli: 1.0.1
os: Windows_NT 6.3.9600 win32 x64
http_parser: 2.5.2
node: 4.4.1
v8: 4.5.103.35
uv: 1.8.0
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 56.1
modules: 46
openssl: 1.0.2g
</code></pre>
<h2>Hexo主题设置</h2>
<p>这里以主题yilia为例进行说明。</p>
<h4>安装主题</h4>
<pre><code class=""bash"">$ hexo clean
$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre>
<h4>启用主题</h4>
<p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。</p>
<h4>更新主题</h4>
<pre><code class=""bash"">$ cd themes/yilia
$ git pull
$ hexo g # 生成
$ hexo s # 启动本地web服务器</code></pre>
<p>现在打开<a href=""http://localhost:4000/"" rel=""nofollow noreferrer"">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。</p>
<h2>Github Pages设置</h2>
<h3>什么是Github Pages</h3>
<p><a href=""https://pages.github.com/"" rel=""nofollow noreferrer"">GitHub Pages</a> 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>
<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=""http://username.github.io"" rel=""nofollow noreferrer"">http://username.github.io</a> 来访问你的个人主页。</p>
<p>这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。</p>
<h3>创建自己的Github Pages</h3>
<p>注册GitHub及使用Github Pages的过程已经有很多文章讲过，在此不再详述，可以参考：</p>
<p><a href=""http://pchou.info/web-build/2013/01/03/build-github-blog-page-01.html"" rel=""nofollow noreferrer"">一步步在GitHub上创建博客主页 全系列</a></p>
<p><a href=""http://www.jianshu.com/p/05289a4bc8b2"" rel=""nofollow noreferrer"">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></p>
<p>在这里我创建了一个github repo叫做 <a href=""https://github.com/jiji262/jiji262.github.io"" rel=""nofollow noreferrer"">jiji262.github.io</a>. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接<a href=""http://jiji262.github.io/"" rel=""nofollow noreferrer"">http://jiji262.github.io/</a> 访问了。（现在还没有内容，别着急）</p>
<h2>部署Hexo到Github Pages</h2>
<p>这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过<a href=""http://jiji262.github.io/"" rel=""nofollow noreferrer"">http://jiji262.github.io/</a>访问了。不过很多教程文章对这个步骤语焉不详，这里着重说下。</p>
<p>首先需要明白所谓部署到github的原理。</p>
<ol>
<li><p>之前步骤中在Github上创建的那个特别的repo（jiji262.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接<a href=""http://jiji262.github.io"" rel=""nofollow noreferrer"">http://jiji262.github.io</a>来直接访问。</p></li>
<li><p>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。</p></li>
<li><p>需要将hexo生成的静态网站，提交(git commit)到github上。</p></li>
</ol>
<p>明白了原理，怎么做自然就清晰了。</p>
<h3>使用hexo deploy部署</h3>
<p>hexo deploy可以部署到很多平台，具体可以<a href=""https://hexo.io/docs/deployment.html"" rel=""nofollow noreferrer"">参考这个链接</a>. 如果部署到github，需要在配置文件_config.xml中作如下修改：</p>
<pre><code>deploy:
  type: git
  repo: git@github.com:jiji262/jiji262.github.io.git
  branch: master</code></pre>
<p>然后在命令行中执行</p>
<pre><code>hexo d</code></pre>
<p>即可完成部署。</p>
<p>注意需要提前安装一个扩展：</p>
<pre><code>$ npm install hexo-deployer-git --save</code></pre>
<h3>使用git命令行部署</h3>
<p>不幸的是，上述命令虽然简单方便，但是偶尔会有莫名其妙的问题出现，因此，我们也可以追本溯源，使用git命令来完成部署的工作。</p>
<h4>clone github repo</h4>
<pre><code>$ cd d:/hexo/blog

$ git clone https://github.com/jiji262/jiji262.github.io.git .deploy/jiji262.github.io</code></pre>
<p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。</p>
<h4>创建一个deploy脚本文件</h4>
<pre><code>hexo generate
cp -R public/* .deploy/jiji262.github.io
cd .deploy/jiji262.github.io
git add .
git commit -m “update”
git push origin master</code></pre>
<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至jiji262.github.io的git目录下，然后使用git commit命令提交代码到jiji262.github.io这个repo的master branch上。</p>
<p>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>
<h2>Hexo 主题配置</h2>
<p>每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。<br>以我们使用的yilia主题为例，其提供如下的配置项（themeyilia_config.yml）：</p>
<pre><code># Header
menu:
  主页: /
  所有文章: /archives
  # 随笔: /tags/随笔

# SubNav
subnav:
  github: ""#""
  weibo: ""#""
  rss: ""#""
  zhihu: ""#""
  #douban: ""#""
  #mail: ""#""
  #facebook: ""#""
  #google: ""#""
  #twitter: ""#""
  #linkedin: ""#""

rss: /atom.xml

# Content
excerpt_link: more
fancybox: true
mathjax: true

# Miscellaneous
google_analytics: ''
favicon: /favicon.png

#你的头像url
avatar: """"
#是否开启分享
share: true
#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key
#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论
duoshuo: true
#是否开启云标签
tagcloud: true

#是否开启友情链接
#不开启——
#friends: false

#是否开启“关于我”。
#不开启——
#aboutme: false
#开启——
aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…
</code></pre>
<h2>其他高级使用技巧</h2>
<h4>绑定独立域名</h4>
<p><a href=""http://www.net.cn/"" rel=""nofollow noreferrer"">购买域名</a><br>在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址<a href=""https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/"" rel=""nofollow noreferrer"">点击</a>，进入source目录下，添加CNAME文件</p>
<pre><code class=""bash"">$ cd source/
$ touch CNAME
$ vim CNAME # 输入你的域名
$ git add CNAME
$ git commit -m ""add CNAME""</code></pre>
<h4>使用图床</h4>
<p>使用<a href=""http://www.qiniu.com/"" rel=""nofollow noreferrer"">七牛云存储</a><br>自己在github上搭建的图床：<a href=""http://jiji262.github.io/qiniuimgbed/"" rel=""nofollow noreferrer"">http://jiji262.github.io/qiniuimgbed/</a> ，需要首先注册七牛账号使用。</p>
<h4>添加插件</h4>
<p>添加sitemap和feed插件</p>
<pre><code class=""bash"">$ npm install hexo-generator-feed
$ npm install hexo-generator-sitemap</code></pre>
<p>修改_config.yml，增加以下内容</p>
<pre><code># Extensions
Plugins:
- hexo-generator-feed
- hexo-generator-sitemap

#Feed Atom
feed:
  type: atom
  path: atom.xml
  limit: 20

#sitemap
sitemap:
  path: sitemap.xml</code></pre>
<p>配完之后，就可以访问<code>http://jiji262.github.io/atom.xml</code>和<code>http://jiji262.github.io/sitemap.xml</code>，发现这两个文件已经成功生成了。</p>
<h4>添加404公益页面</h4>
<p>GitHub Pages有提供制作404页面的指引：<a href=""https://help.github.com/articles/custom-404-pages"" rel=""nofollow noreferrer"">Custom 404 Pages</a>。</p>
<p>直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p>
<p>推荐使用<a href=""http://www.qq.com/404/"" rel=""nofollow noreferrer"">腾讯公益404</a>。</p>
<h4>添加about页面</h4>
<pre><code class=""bash"">$ hexo new page ""about""</code></pre>
<p>之后在sourceaboutindex.md目录下会生成一个index.md文件，打开输入个人信息即可，如果想要添加版权信息，可以在文件末尾添加：</p>
<pre><code class=""html"">&lt;div style=""font-size:12px;border-bottom: #ddd 1px solid; BORDER-LEFT: #ddd 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #ddd 1px solid; BORDER-RIGHT: #ddd 1px solid""&gt;
&lt;div style=""MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px""&gt;
&lt;IMG alt="""" src=""https://avatars1.githubusercontent.com/u/168751?v=3&amp;s=140"" width=90 height=100&gt;
&lt;/div&gt;
&lt;div style=""LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000""&gt;
本文链接：&lt;a href=""&lt;%= post.link %&gt;""&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;br/&gt;
作者： 
&lt;a href=""http://jiji262.github.io/""&gt;令狐葱&lt;/a&gt; &lt;br/&gt;出处： 
&lt;a href=""http://jiji262.github.io/""&gt;http://jiji262.github.io/&lt;/a&gt;
&lt;br/&gt;本文基于&lt;a target=""_blank"" title=""Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)"" href=""http://creativecommons.org/licenses/by-sa/4.0/""&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;
国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 
&lt;a href=""http://jiji262.github.io/""&gt;令狐葱&lt;/a&gt;及链接。
&lt;/div&gt;
&lt;/div&gt;</code></pre>
<h4>添加Fork me on Github</h4>
<p><a href=""https://github.com/blog/273-github-ribbons"" rel=""nofollow noreferrer"">获取代码</a>，选择你喜欢的代码添加到hexo/themes/yilia/layout/layout.ejs的末尾即可，注意要将代码里的you改成你的Github账号名。</p>
<h4>添加支付宝捐赠按钮及二维码支付</h4>
<h5>支付宝捐赠按钮</h5>
<p>在D:hexothemesyilialayout_widget目录下新建一个zhifubao.ejs文件，内容如下</p>
<pre><code class=""html"">&lt;p class=""asidetitle""&gt;打赏他&lt;/p&gt;
&lt;div&gt;
&lt;form action=""https://shenghuo.alipay.com/send/payment/fill.htm"" method=""POST"" target=""_blank"" accept-charset=""GBK""&gt;
    &lt;br/&gt;
    &lt;input name=""optEmail"" type=""hidden"" value=""your 支付宝账号"" /&gt;
    &lt;input name=""payAmount"" type=""hidden"" value=""默认捐赠金额(元)"" /&gt;
    &lt;input id=""title"" name=""title"" type=""hidden"" value=""博主，打赏你的！"" /&gt;
    &lt;input name=""memo"" type=""hidden"" value=""你Y加油，继续写博客！"" /&gt;
    &lt;input name=""pay"" type=""image"" value=""转账"" src=""http://7xig3q.com1.z0.glb.clouddn.com/alipay-donate-website.png"" /&gt;
&lt;/form&gt;
&lt;/div&gt;</code></pre>
<p>添加完该文件之后，要在D:/hexo/themes/yilia/_config.yml文件中启用，如下所示，添加zhifubao</p>
<pre><code class=""bash"">widgets:
- category
- tag
- links
- tagcloud
- zhifubao
- rss</code></pre>
<h5>二维码捐赠</h5>
<p>首先需要到<a href=""https://qr.alipay.com/paipai/open.htm"" rel=""nofollow noreferrer"">这里</a>获取你的支付宝账户的二维码图片，支付宝提供了自定义功能，可以添加自定义文字。</p>
<p>我的二维码扫描捐赠添加在about页面，当然你也可以添加到其它页面，在D:hexoblogsourceabout下有index.md，打开，在适当位置添加</p>
<pre><code class=""html"">&lt;center&gt;
欢迎您捐赠本站，您的支持是我最大的动力！
![][http://7xsxyo.com1.z0.glb.clouddn.com/2016/04/15/FoJ1F6Ht0CNaYuCdE2l52F-Fk9Vk202.png]
&lt;/center&gt;
&lt;br/&gt;</code></pre>
<p><code>&lt;center&gt;</code>可以让图片居中显示，注意将图片链接地址换成你的即可。</p>
<h4>添加百度站内搜索</h4>
<p><a href=""http://zhanzhang.baidu.com/guide/index"" rel=""nofollow noreferrer"">点击进入</a>，点击其它工具-&gt;站内检索-&gt;现在使用-&gt;新建搜索引擎-&gt;查看代码，将代码里的id值复制，打开/d/hexo/themes/jacman/_config.xml，配置成如下即可。</p>
<pre><code>baidu_search:     ## http://zn.baidu.com/
  enable: true
  id: ""1433674487421172828"" ## e.g. ""783281470518440642""  for your baidu search id
  site: http://zhannei.baidu.com/cse/search ## your can change to your site instead of the default site</code></pre>
<h4>使用不蒜子添加访客统计</h4>
<p>详情参考<a href=""http://ibruce.info/2015/04/04/busuanzi/"" rel=""nofollow noreferrer"">搞定你的网站计数</a>，具体做法很简单，就是在你的<code>themes/your themes/layout/_partial/footer.ejs</code>底部加入这段脚本</p>
<pre><code class=""javascript"">&lt;script async src=""//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js""&gt;&lt;/script&gt;</code></pre>
<p>然后在<code>&lt;p class=""copyright""&gt;&lt;/p&gt;</code>中间添加如下统计信息即可</p>
<pre><code class=""html"">本站总访问量 &lt;span id=""busuanzi_value_site_pv""&gt;&lt;/span&gt; 次, 访客数 &lt;span id=""busuanzi_value_site_uv""&gt;&lt;/span&gt; 人次, 本文总阅读量 &lt;span id=""busuanzi_value_page_pv""&gt;&lt;/span&gt; 次</code></pre>
<p>不蒜子的官方服务网站是<a href=""http://service.ibruce.info/"" rel=""nofollow noreferrer"">不蒜子</a>，目前最大的弊端就是不开放注册，所以对于运行了一段时间的网站，不蒜子的数据都是从1开始，没办法设置，只有等后期开放注册之后，登入网站才能对统计计数进行设置。</p>
<h2>参考链接</h2>
<p><a href=""https://hexo.io/"" rel=""nofollow noreferrer"">Hexo主页</a><br><a href=""http://ibruce.info/2013/11/22/hexo-your-blog/"" rel=""nofollow noreferrer"">hexo你的博客</a><br><a href=""http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/"" rel=""nofollow noreferrer"">Github Pages个人博客，从Octopress转向Hexo</a><br><a href=""http://www.jianshu.com/p/05289a4bc8b2"" rel=""nofollow noreferrer"">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=""https://wingjay.com/2015/12/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%A4%A9%E4%B9%8B%E5%86%85%E6%90%AD%E5%BB%BA%E4%BB%A5%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%90%8D%E5%AD%97%E4%B8%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E5%BE%88cool%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"" rel=""nofollow noreferrer"">如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客</a><br><a href=""http://mp.weixin.qq.com/s?__biz=MzI4MzE2MTQ5Mw==&amp;mid=401679929&amp;idx=1&amp;sn=bd752ae5ac550b4bf4dcccb1c12aa2b1&amp;scene=18#wechat_redirect"" rel=""nofollow noreferrer"">手把手教你建github技术博客by hexo</a><br><a href=""http://wowubuntu.com/markdown/index.html"" rel=""nofollow noreferrer"">Markdown 语法说明 (简体中文版)</a></p>
<blockquote><p>本文原始链接：<a href=""http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/"" rel=""nofollow noreferrer"">手把手教你使用Hexo + Github Pages搭建个人独立博客</a>  <br>作者：<a href=""https://github.com/jiji262"" rel=""nofollow noreferrer"">令狐葱</a>  <br>本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 <a href=""https://github.com/jiji262"" rel=""nofollow noreferrer"">令狐葱</a>及链接。</p></blockquote>

                ", 手把手教你使用Hexo + Github Pages搭建个人独立博客,1531977985,246,1,843,1,1,https://segmentfault.com/a/1190000004947261
221,1,0,7,"
                    
<h2>问题描述</h2>
<p>有时候我们需要在GIT里面创建一个空分支，该分支不继承任何提交，没有父节点，完全是一个干净的分支，例如我们需要在某个分支里存放项目文档。<br>使用传统的git checkout命令创建的分支是有父节点的，意味着新branch包含了历史提交，所以我们无法直接使用该命令。</p>
<h2>解决方法</h2>
<h3>创建分支</h3>
<p>使用 git checkout的--orphan参数:</p>
<pre><code class=""bash"">git checkout --orphan doc</code></pre>
<p>该命令会创建一个名为doc的分支，并且该分支下有前一个分支下的所有文件。<br>查看--orphan的帮助：</p>
<blockquote><p>Create a new orphan branch, named &lt;new_branch&gt;, started from &lt;start point&gt; and switch to it. The first commit made on the new branch will have no parents and it will be the root of a new history totally disconnected from all the other branchs and commits.</p></blockquote>
<p>这里的start point指的是你执行git checkout命令时的那个分支，当然新的分支不会指向任何以前的提交，就是它没有历史，如果你提交当前内容，那么这次提交就是这个分支的首次提交。</p>
<h3>删除所有内容</h3>
<p>我们不想提交任何内容，所以我们需要把当前内容全部删除，用git命令：</p>
<pre><code class=""bash"">git rm -rf .</code></pre>
<h3>提交分支</h3>
<p>使用commit命令来提交分支</p>
<pre><code class=""bash"">git commit -am ""new branch for documentation""</code></pre>
<p>如果没有任何文件提交的话，分支是看不到的，可以创建一个新文件后再次提交则新创建的branch就会显示出来。<br>使用branch来查看分支是否创建成功</p>
<pre><code class=""bash"">git branch -a</code></pre>

                ", 在GIT中创建一个空分支,1531977986,585,1,820,1,1,https://segmentfault.com/a/1190000004931751
222,1,0,7,"
                    
<p>git hooks想必很多攻城狮都不陌生，官方对于hooks有详细的<a href=""https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks"" rel=""nofollow noreferrer"">文档</a>，也有站内网友的文章<a href=""https://segmentfault.com/a/1190000000356485"" rel=""nofollow noreferrer"">Git Hooks (1)：介绍</a>,<a href=""https://segmentfault.com/a/1190000000356487"" rel=""nofollow noreferrer"">GIt Hooks (2)：脚本分类</a>，说的非常详细了，这里就不多做介绍，这里主要介绍一下如何写一个hook。</p>
<h2>一个基本的git hook长什么样？</h2>
<p>对git-hooks有一个入门认识的朋友都知道，hooks存放在git仓库的<code>.git/hooks</code>目录下，其中包括很多hooks，这些是在git 仓库创建的时候自动生成的，后缀名统一都是<code>.sample</code>，表示这些hooks都是默认不启用的，当把后缀名去掉之后，就变成了可以使用的hook。</p>
<h3>举个栗子</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVuNGr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>pre-commit这个hook是在<code>git commit</code>的时候触发的hook，这个hook里面写了什么呢？代码我就不贴了，没啥劲，主要的几点就是：</p>
<ol>
<li><p>这是一个shell脚本</p></li>
<li><p>这个脚本运行了一些东西然后退出了</p></li>
<li><p>退出的时候退出的错误码不是确定的</p></li>
</ol>
<p>这就是一个hook的最基本的组成：在命令行执行git操作的时候，自动执行hooks目录下相应的可执行脚本，然后根据脚本的退出状态决定此次操作是否成功。当退出的错误码不为0的时候，表示失败，操作终止，否则操作继续。</p>
<h3>模拟场景</h3>
<p>如果现在有这样一个场景，在你的git仓库里，要求不允许提交<code>dist</code>目录，并且通过<code>mocha</code>的测试，否则不允许提交，用git hook 怎么做呢？</p>
<p>首先，这是在提交的时候的一个限制，所以应该考虑使用<code>pre-commit</code>这个hook，代码就不写了（不会写shell... Orz），整个过程如下：</p>
<ol>
<li><p>检查是否有<code>dist</code>目录，如果没有的话下一步，否则退出，错误码置为1。</p></li>
<li><p>执行mocha命令进行测试，如果测试全部通过的话，退出，错误码为0，否则错误码为1，同样退出。</p></li>
</ol>
<p>这样，当上述任何一步没有通过的时候，这个hook就会被终止，git-commit就无法通过，也就达到了限制提交的目的。</p>
<h2>shell脚本的局限性——不会写</h2>
<p>作为一名普通的前端，兼，一名不太合格的工程师，我对于shell脚本实在是不熟悉，连Linux命令都玩不转，别说写出666的shell脚本了，囧~ 所以要另辟巧径做这件事。</p>
<p>前端仔们对js应该是非常熟练的，所以如果能用js写hooks，那不就爽了？而Node.JS正好给了我们希望，感激涕零的话就不多说了，绝对感动到哭！</p>
<p><span class=""img-wrap""><img data-src=""/img/bVuNJ5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""20151004154819_vcYJV.thumb.224_0.jpeg"" title=""20151004154819_vcYJV.thumb.224_0.jpeg""></span></p>
<p>Node.js写起脚本来也非常简单，比如一个最简单的脚本</p>
<pre><code>#!/usr/bin/env node

console.log('Hello World!');</code></pre>
<p>给脚本赋予可执行权限之后就完全可以当做shell脚本来跑了，麻麻再也不用担心我不会shell了。同样的，在hooks中我们也可以这样用。再举个栗子</p>
<p><span class=""img-wrap""><img data-src=""/img/bVuNKy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""060cc75c10385343024d82b79513b07ecb808848.jpg"" title=""060cc75c10385343024d82b79513b07ecb808848.jpg""></span></p>
<p>还是刚才的场景，不允许有<code>dist</code>目录，同时通过所有mocha测试，用Node就可以这样写（这次我能show出代码了）</p>
<pre><code class=""javascript"">#!/usr/bin/env node
var fs = require('fs'),
    spawnSync = require('child_process').spawnSync;
if(fs.existsSync('./dist')){
    console.log('Commit Abort!Please remove dist directory.');
    process.exit(1);
}
// 使用同步方法spawnSync执行mocha，测试的结果在result.status中，通过为0，不通过为1
var result = spawnSync('./node_modules/.bin/mocha',['test']); 
if(result.status){
    console.log('Commit Abort!Test failure.');
}
process.exit(result.status);</code></pre>
<p>这就是一个用Node.JS实现的基本的git-hook。</p>
<h2>Node.JS的局限性——不能动</h2>
<p>client-side hook的一个问题就是没法在随着仓库变动，如果项目成员多的话，每个人都需要在自己本地添加一次，hooks有变动了更新也比较麻烦。</p>
<h4>解决方案</h4>
<p>我个人对这个问题有一个简单解决方案，我做了一个仓库<a href=""https://github.com/y8n/git-hooks-node"" rel=""nofollow noreferrer"">git-hooks-node</a>，每次写好git hooks之后通过自己写的工具进行build，生成一个类似于安装器的文件，然后提交到远程仓库，如<a href=""https://github.com/y8n/git-hooks-node/blob/master/xgfe-ma/pre-commit.js"" rel=""nofollow noreferrer"">pre-commit.js</a>是hook具体的内容，<a href=""https://github.com/y8n/git-hooks-node/blob/master/xgfe-ma/pre-commit.installer.js"" rel=""nofollow noreferrer"">pre-commit.installer.js</a>是生成的安装文件，也是一个脚本，github上的每一个文件都有相应的raw地址，如这个安装文件的地址为<a href=""https://raw.githubusercontent.com/y8n/git-hooks-node/master/xgfe-ma/pre-commit.installer.js"" rel=""nofollow noreferrer"">raw pre-commit.installer.js</a>，然后mac OS下的用户就可以使用<code>curl</code>获取脚本并运行，如下：</p>
<pre><code>curl https://raw.githubusercontent.com/y8n/git-hooks-node/master/xgfe-ma/pre-commit.installer.js | node</code></pre>
<p>安装效果如下</p>
<p><span class=""img-wrap""><img data-src=""/img/bVuNNb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这样只要写好一个hook并发布，项目成员只要知道地址就可以一键安转（想想还有点小激动呢）。这样虽然没有解决hook不会随着仓库移动的问题，但也提供了一种在项目组里通用一套hook的方案。</p>
<h4>其他解决方法</h4>
<p><a href=""https://github.com/typicode/husky"" rel=""nofollow noreferrer"">husky</a>是GitHub上一个开源项目，它的做法是在<code>npm install</code>这个模块的时候自动在<code>.git/hooks</code>目录下创建很多hooks，然后再在package.json中指定每一个hook的执行脚本，如下</p>
<pre><code>""scripts"": {
    ""precommit"": ""npm test"",
    ""prepush"": ""npm test"",
    ""commit-msg"": ""./validate-commit-msg.js"",
    ""..."": ""...""
  }</code></pre>
<p>这样就可以把hooks随着项目变动，真正做到项目成员共用一个git hook，但问题就是必须在项目中依赖husky，不过想想这样的方法也比上面我的方法高明许多 -.-!</p>

                ", 不会写shell的程序员照样是好前端——用Node.JS实现git hooks,1531977987,500,1,256,1,1,https://segmentfault.com/a/1190000004918996
223,1,0,7,"
                    
<p>由于最近团队代码库从coding迁移到github，在CI工具的选型上尝试了<a href=""http://travis-ci.com/"" rel=""nofollow noreferrer"">travis-ci</a>和<a href=""https://circleci.com/"" rel=""nofollow noreferrer"">circle-ci</a>，最后决定自己搭建CI服务器，而我也有幸认领了这个任务的调研，因此有了这篇文章。</p>
<blockquote><p>之前写过一篇文章<a href=""https://segmentfault.com/a/1190000004639923"" rel=""nofollow noreferrer"">浅谈Jenkins+Node.js持续集成</a>，那真的是浅谈，Jenkins包含的东西实在太多了，作为从hudson分支出来的开源免费的版本，插件与hudson通用，有更快的迭代速度和稳定性。</p></blockquote>
<h3>为什么选择Jenkins</h3>
<p>答案简单：因为免费，学习资料多。</p>
<h3>开始吧</h3>
<p>安装配置这里就不赘述了，移步<a href=""http://www.jianshu.com/p/64b498304d07"" rel=""nofollow noreferrer"">浅谈Jenkins+Node.js持续集成</a></p>
<h4>0. 准备</h4>
<p>因为要与Github通信，所以需要准备一台服务器，该服务器能访问到Github，Github能访问到它。<br>为了这个测试，我特地在<a href=""https://bandwagonhost.com/aff.php?aff=5443"" rel=""nofollow noreferrer"">搬瓦工VPS</a>买了服务器，顺便介绍一下这个高性价比的vps供应商，$2.99约合人民币18元每个月，可一键搭建shadowsocks。但是记得有个坑就是购买的时候一定要选好机房，之前买过洛杉矶的卡的要死，打条命令之后要等好久才显示，对它失去信心不想用它了，后来听一个朋友说<em>亚利桑那州</em>（<em>Arizona</em>）的机房挺稳定的，再给它一次机会，这次买了Arizona机房的果然速度挺快的?</p>
<h4>1. 安装<a href=""https://wiki.jenkins-ci.org/display/JENKINS/Github+Plugin"" rel=""nofollow noreferrer"">GitHub Plugin</a>
</h4>
<p>直接安装Github Plugin, jenkins会自动帮你解决其他插件的依赖，直接安装该插件Jenkins会自动帮你安装<a href=""https://wiki.jenkins-ci.org/display/JENKINS/Plain+Credentials+Plugin"" rel=""nofollow noreferrer"">plain-credentials</a> 、<a href=""https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin"" rel=""nofollow noreferrer"">git</a> 、 <a href=""https://wiki.jenkins-ci.org/display/JENKINS/Credentials+Plugin"" rel=""nofollow noreferrer"">credentials</a> 、 <a href=""https://wiki.jenkins-ci.org/display/JENKINS/GitHub+API+Plugin"" rel=""nofollow noreferrer"">github-api</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDen"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-ff8c8744ed7ade0d.png"" title=""436630-ff8c8744ed7ade0d.png""></span></p>
<h4>2. 配置Github插件</h4>
<blockquote><p>系统管理 &gt;&gt; 系统设置 &gt;&gt; GitHub Plugin Configuration</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-51fc12339df533e8.png"" title=""436630-51fc12339df533e8.png""></span><br>首先点击<a href=""https://github.com/settings/tokens/new"" rel=""nofollow noreferrer"">personal access token</a>到github上<br>也就是github上用户Settings &gt;&gt; personal access tokens</p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>勾选给Jenkins的访问权限，Github plugin的帮助信息里说要admin:repo_hook、repo和repo:status权限，其实repo:status是包含在repo里的，详见<a href=""https://developer.github.com/v3/oauth/#scopes"" rel=""nofollow noreferrer"">这里</a>。 点击Generate token创建一个token</p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-943711ff2a74919d.png"" title=""436630-943711ff2a74919d.png""></span><br>复制这个token，回到Jenkins点击Add按钮</p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-96badf78f80a6a4f.png"" title=""436630-96badf78f80a6a4f.png""></span><br>选择Secret text，粘贴token，添加描述，点击添加。<br>点击Verify credentials测试token，显示Credentials verified for user xxx, rate limit: xxxx，说明配置完成了，这样你的Jenkins就具有访问你的github的权限了。</p>
<h4>3. 创建一个freestyle任务</h4>
<ul><li><p>填写GitHub project URL￼￼￼, 也就是你的项目主页<br><a href=""https://github.com/%08your_name/your_repo_name/"" rel=""nofollow noreferrer"">https://github.com/your_name/your_repo_name</a></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>
<p>配置源码管理<br><span class=""img-wrap""><img data-src=""/img/bVtDeR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-3c8bcba3348a283b.png"" title=""436630-3c8bcba3348a283b.png""></span></p>
<ol>
<li><p>填写项目的git地址, eg. <a href=""https://github.com/"" rel=""nofollow noreferrer"">https://github.com/</a>your_name/your_repo_name.git</p></li>
<li><p>添加github用户和密码</p></li>
<li><p>选择githubweb源码库浏览器，并填上你的项目URL，这样每次构建都会生成对应的changes，可直接链到github上看变更详情</p></li>
</ol>
</li>
<li><p>构建触发器<br>勾选Build when a change is pushed to GitHub，这样该仓库的每一次push或者pull request都会触发build</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVtDeW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-b9999a73f4b23fff.png"" title=""436630-b9999a73f4b23fff.png""></span></p>
<ul><li><p>配置构建步骤<br>随后配置构建环境、构建步骤和构建后步骤</p></li></ul>
<p>安装了Github Plugin之后在构建步骤和构建后操作会多两个设置，用于在构建时和构建后同步构建状态到Github的，后面有效果图<br><span class=""img-wrap""><img data-src=""/img/bVtDe5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-f099cad93e9cc19f.png"" title=""436630-f099cad93e9cc19f.png""></span></p>
<h4>4. 配置Github仓库的Webhook</h4>
<p>仓库的创建人在仓库的Settings &gt;&gt; Webhooos &amp; services添加<br>我们只需要push事件触发就可以了，选中Just the push event<br>点击Add webhook<br>yes，与github集成的Jenkins CI环境就配置好了<br><span class=""img-wrap""><img data-src=""/img/bVtDfb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-1dbb649d8ae063b3.png"" title=""436630-1dbb649d8ae063b3.png""></span></p>
<h4>5. 效果</h4>
<p>每次push都会触发一次build，pull request的话还会在该界面直接显示build结果</p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDfe"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-86ef016dfdd1a523.png"" title=""436630-86ef016dfdd1a523.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bVtDfi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""436630-9d004c31031465b2.png"" title=""436630-9d004c31031465b2.png""></span></p>
<h3>最后</h3>
<p>整个环境终于搭好了，中间遇到了蛮多大坑小坑的，有些记录了下来，后续整理好再发上来。<br>这段时间学习Jenkins收获蛮多的，只是到现在也只学了些皮毛，写出来的东西也颇有些晦涩。<br>接下来要做的实验是通过Jenkins实现自动远程部署。</p>

                ", Jenkins+Github持续集成,1531977989,231,1,951,1,1,https://segmentfault.com/a/1190000004640060
224,1,0,7,"
                    
<blockquote><p>原文链接：<a href=""http://huang-jerryc.com/2016/01/15/%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8GitHub%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"" rel=""nofollow noreferrer"">BlueSun | 如果你用GitHub，可以这样提高效率</a></p></blockquote>
<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。</p>
<p>但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。<br>作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>
<h3>版本管理 — Git~Hub</h3>
<blockquote><p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p></blockquote>
<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人......</p>
<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=""http://www.jianshu.com/p/104fa8b15d1e"" rel=""nofollow noreferrer"">「企业级开发：Gitflow Workflow工作流」</a></p>
<p>Coding真的是一款很不错的产品，可称为业届良心。</p>
<p>为什么当初没有直接用GitHub，因为私有仓库贵啊......</p>
<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午.....</p>
<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>
<p>于是乎，我们浩浩荡荡的迁移代码库。</p>
<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>
<h3>武装GitHub — ZenHub</h3>
<blockquote><p><a href=""https://www.zenhub.io/"" rel=""nofollow noreferrer"">ZenHub</a>     <br>Project management inside GitHub    <br>Transform your GitHub issues</p></blockquote>
<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>
<p>如果你用了ZenHub，它会提供给你：</p>
<ol>
<li><p><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</p></li>
<li><p><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</p></li>
<li><p><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</p></li>
<li><p><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</p></li>
</ol>
<h3>持续集成 — TravisCI</h3>
<blockquote><p><a href=""https://travis-ci.org/"" rel=""nofollow noreferrer"">TravisCI</a>    <br>Test and Deploy with Confidence    <br>Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p></blockquote>
<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>
<p><a href=""https://travis-ci.org/expressjs/express"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/bVtA2h?w=90&amp;h=20"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Build Status"" title=""Build Status""></span></a></p>
<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>
<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。    <br>合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>
<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>
<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。    <br>如果你觉得贵，这里还有一个可以代替的：<strong><a href=""https://circleci.com/"" rel=""nofollow noreferrer"">CircleCI</a></strong>    <br>TravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。</p>
<h3>代码Review — Reviewable</h3>
<blockquote><p><a href=""https://reviewable.io/"" rel=""nofollow noreferrer"">Reviewable</a><br>GitHub code reviews done right</p></blockquote>
<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。<br>当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008513169?w=3120&amp;h=548"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>点击进入Reviewable的页面对应的PR进行review。</p>
<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>
<h3>代码覆盖率 — Coveralls</h3>
<blockquote><p><a href=""http://coveralls.io/"" rel=""nofollow noreferrer"">Coveralls</a>    <br>We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p></blockquote>
<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>
<p><a href=""https://coveralls.io/github/strongloop/express?branch=master"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/bVtA2T?w=106&amp;h=20"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Coverage Status"" title=""Coverage Status""></span></a></p>
<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>
<h3>快速进行沟通 — Slack</h3>
<blockquote><p><a href=""https://slack.com/"" rel=""nofollow noreferrer"">Slack</a>    <br>A messaging app for teams who see through the Earth</p></blockquote>
<p>相信大部分团队都是使用微信进行沟通的，    <br>再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>
<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>
<p>助你时刻掌控项目动态。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008513170?w=4596&amp;h=3400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  </p>
<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>
<h3>最后</h3>
<p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>
<hr>
<p>如果本文对您有用<br>请不要吝啬你们的Follow与Start<br>这会大大支持我们继续创作</p>
<p><strong>「Github」</strong><br>MZMonster ：<a href=""https://github.com/MZMonster/"" rel=""nofollow noreferrer"">@MZMonster</a><br>JC_Huang ：<a href=""https://github.com/JerryC8080"" rel=""nofollow noreferrer"">@JerryC8080</a></p>

                ", 如果你用GitHub，可以这样提高效率,1531977990,595,1,288,1,1,https://segmentfault.com/a/1190000004619665
225,1,0,7,"
                    
<h2>背景</h2>
<p>我在2011年底做测试的时候开始接触Android，于2012年5月初加入薄荷才开始真正的从事Android开发的职位，但是因为没有任何计算机方面的知识，自学也只是学了点基础，很多时候都是边学边做，所以我在一开始工作效率很低，很多东西都是搜索现学现做，因为那个时候移动开发本身就刚起来，人才也比较稀缺，所以公司也比较容忍。就这样摸爬滚打做了半年多，总觉得自己进步很慢，那个时候公司有人写博客，所以就萌生了写博客的念头。</p>
<h2>GitHub Pages</h2>
<p>有了写博客的念头之后，在哪里开比较纠结，那时流行在CSDN、博客园上开博客，但是我觉得在CSDN、博客园上点进去一大堆广告，阅读体验太差了，而且显得有点low，一开始就想可不可以自己搭建个博客呢，当时自己刚好也在做Ruby On Rails，自己写个博客也不是不可以，但是自己定制那些样式什么的太麻烦了，直到有一天我跟同事交流，知道了GitHub Pages这东西，各种样式模板，还可以免费托管，我12年9月份注册的GitHub，没想到GitHub还有这功能，想都没想就去折腾了这玩意，当时流行Octopress，花了好几天才把博客折腾好，博客跑起来的那一瞬间，我才知道这才是我想要的博客。</p>
<p>所以从我的博客「时间线」上能看到12年的11月21日我发布了第一篇博客「搭建Octopress」，只不过经过时间的演变后来流行Jekyll，我又折腾换到了Jekyll，找了一个简洁的主题，做了些我自己的定制，也就是我现在博客的模样，现在最流行Hexo，基于Node的框架，速度更快，更多样式选择，如果现在你要是想搭建属于你自己的博客，推荐Hexo。</p>
<h2>有态度的博客</h2>
<p>博客搭建好之后，我就坚持每周写博客，不管再忙，当时在做Ruby，所以看到一开始的博客内容都是关于Ruby On Rails的，但是一直做的都不是很好，直到后来公司又重启Android业务，我又自愿做回了Android，再回来做Android的时候依然遇到问题去搜索，一开始还是用百度，当时关于Android相关的资料本身就比较少，搜出来的东西还千篇一律，很多博客都是互相copy，根本就没有自己亲自验证与实践，于是我就决定自己的博客一定要有态度，写的东西一定是自己亲自经历或研究的东西，就这样一直到现在，4年多的时间过去了，我依然坚持这种态度。</p>
<h2>惊喜</h2>
<p>就这样我就一直这样闷头好好工作，认真写博客，突然有一天我遇到个问题，就突然用Google搜了搜，看到一篇文章好熟悉，点进去一看竟然是我博客的一篇文章，当时我就惊呆了，原来我的博客在Google上有点权重了，于是顺手搜了下stormzhang这个id，我的博客地址直接就出来了，真是兴奋了好几天，我自己坚持写高质量的博客的动力一下又提升了。</p>
<h2>Android学习之路</h2>
<p>大概到14年中旬，我做Android也一年多的时间了，感觉也收集积累了不少东西，自己也是自学过来的，走过了不少弯路，想着能把这些经验整理分享出来帮助更多的人岂不更好，于是<a href=""http://stormzhang.com/android/2014/07/07/learn-android-from-rookie"" rel=""nofollow noreferrer"">Android学习之路</a>这篇博客诞生了，我在博客发布之后在微博上就随手@了几个大V，没想到这一下就爆发了，被各种转发，可能对这么详细、系统的学习Android的博客期盼太久了，微博粉丝也从几十个直接增加到几千人，那条微博阅读量几天之内达到100w。突然之间我就火了，用现在的话说我就是当时的「网红」。后来这篇文章被各大网站转载，不少培训过的人给我说很多培训机构的讲师都是按照我这篇博客去讲解的，我收到无数人的感谢信，说我的这篇博客帮助他们太多，时至今日，我没法统计这篇博客影响了多少Android开发者。</p>
<h2>人红是非多</h2>
<p>人红之后，各种事情都找到你了。比如各大出版社找到我，说让我写本Android的书籍，他们免费帮我出版、宣传。我一开始觉得挺好的，想着写本书提升下名气，顺便还能赚点稿费。但是后来了解到写书很费精力，我是不想影响到我的工作的，职业发展的初期，精力还是要投入到工作与提升自己为好，关键最让我反感的是出版社对写书要求有一定的页数限制，因为他们是按照页数去定价的，他们想赚钱就必须把价格定高点。这让我彻底打消了这个念头，我一直认为一本书的好坏决不能按照页数去定义，精炼的表达能让别人理解是最好的。所以你们可以看到现在市面上很多书都比较厚，文字啰嗦，甚至拿图片来凑页数，我看不惯这种做法，所以选择拒绝。</p>
<p>现在比较火的在线教育，比如慕课网、极客学院，这些在线视频网站很早就找到我，说让我录关于Android的视频教程，直到现在也依然在联系我，给我开的报酬还不低，如果我愿意，我可以轻松靠录制视频月赚不少，录制视频按小时付费，所以各种要求，语速过快不行，过慢也不行，还要各种剪辑，也要一本正经，了解我的人知道我就是比较随和幽默的人，这种风格不适合我，关键还比较费精力。</p>
<p>我个人风格比较自由，不喜欢各种限制，现在薄荷的弹性工作制就是我提出来的，所以对我有约束的事情我都不喜欢去做。而且目前这个时期我还是想把大量精力投入到工作中，需要我花不少精力去做的业余项目我也会拒绝，即使能赚钱。</p>
<h2>Facebook的邀请邮件</h2>
<p>就这样名气越来越大了，在GitHub开源的一个教大家使用Android Studio与Gradle实践的一个小项目9GAG也被关注起来了，这个项目在现在不算什么，但在当时Android Studio在国内还是刚起步阶段，这方面的资料真是少之又少。</p>
<p>大概在14年8月份的时候我收到了一封来自Facebook Android Team的面试邀请，简直是吓死宝宝了。虽然最终没有去面试，但是这件事情让我在公司出名了，公司层面意识到原来我已经到达这种高度了，再也不是一名默默无闻的初中级Android程序员了，之后升职加薪，对我加以重用，给我更多的权利去管理Android团队，我想这应该算是我坚持写博客的意外收获吧。</p>
<h2>微信公众号</h2>
<p>不管多忙，博客还是坚持写下去，目前为止博客更新了144篇，我的「Android Studio教程系列」应该算是国内最早一批的AS详细教程，多少公司在开始准备使用AS的时候是看的我的这个系列教程，多少开发者接触AS是从我的博客开始的，某种意义上Android Studio能在国内这么普及，我应该起到了一点推动作用。16年初，我决定在公众号上写文章，一方面是因为之前博客文章被各种转载不署名，让我对版权问题有了意识，另一方面公众号推出了「赞赏」、「广告」等功能支持鼓励原创作者，突然觉得做着喜欢的事，还能靠他赚点外快何乐而不为呢？</p>
<h2>关于打赏</h2>
<p>我不知道你们对「打赏」这个功能是什么态度，「打赏」我没放出来的时候一直有人问我怎么没有这个功能，想打赏支持下，等我有了该功能并把他放出来的第一天我号召大家「求打赏一元，看人气」，后来晚上被打赏的人数吓到了，当晚就有200多人打赏，当然大部分都是响应我的号召赏了1块，之后我就再没有要求大家给我打赏过，打赏是你们自愿就好，觉得对你们有帮助就象征性的意思下以表支持与鼓励，我觉得打赏的意义在于人气，金额多少看您自己的情况就好，不希望看到一些穷学生就为了纯支持我给了大额打赏。</p>
<p>其实我本质上当然希望能通过这个公众号赚点零花钱，因为觉得靠自己能力，牺牲自己业余的时间给你们分享的同时能有点回报是最好的结果，我想最高兴的不是我，而是我媳妇吧。而如果只靠「打赏」的话那我的希望恐怕要破灭了，微信已经邀请我开通了「流量主」功能，申请通过以后你们就可以帮我点击底部广告，赚取那些无良商家的钱了，哈哈，想想就开心。偶尔也会有一些合作商找我发布软文，也是一个渠道吧，还请以后你们多多理解与支持。</p>
<h2>总结</h2>
<p>说了这么多，我自己的亲身经历告诉你们要写博客，并且要坚持写下去，有这些优点：</p>
<p>1.知识的总结<br>项目开发中也许学到了一个技能，或者一个知识点，但是通过写博客会加深巩固自己学习的东西，自己写不出来可能说明你对这个知识点理解还不够深入。</p>
<p>2.表达能力的提升<br>程序员大都不善于沟通，是因为表达能力不行，但是通过坚持写博客，自己的表达能力与表达逻辑会慢慢锻炼出来，逐渐的就会影响自己的沟通交流能力，这点我深有体会。</p>
<p>3.面试加分<br>假设我们同时面试了两个人，两人各方面能力差不多，但是一个写博客，一个不写，我想我肯定优先选择坚持写博客的人。他能坚持写博客，起码知道他善于经验总结，很勤快，因为大部分人不写博客很大原因是因为懒。</p>
<p>4.提升写作能力<br>写的多了，写作能力也就提升了，比如我，相信我的写作能力应该比大部分程序员要优秀，你们认同么？</p>
<p>5.提升名气<br>如果持续产出高质量的博客，被越来越多的人知道，那名气就会上升了，有了名气自身的价值一下就提升了，我深有感受，自从有了名气之后，每天都能收到各大猎头、CEO等的各种优越条件的邀请，选择接受或拒绝是一回事，但是有没有收到邀请就是另一回事了。</p>
<p>6.赚取外快<br>这个容易理解，有了名气之后就可以有办法赚取各种外快，而且本身也并不可耻，不偷不抢，靠自身技术赚点零花钱有何不可？比如我，如果哪一天我很缺钱了（虽然现在也缺），我可以立刻想办法花点精力去赚更多的钱，只不过现在我选择了我最喜欢，最不受约束的方式而已。</p>
<p>最后奉劝大家，如果你还没有写博客，那从现在开始开通个博客，走出第一步，如果你已经开始写博客了，不要去奢望靠写博客去赚钱，安心的写博客提升自己能力，总结经验，把它看成一种投资自己的手段，别把目标搞错了，也许有一天你会突然发现，原来你已经走了这么远，而且还有意外收获！</p>
<p>勿忘初心，才能方得始终！</p>

                ", 我为什么坚持写博客？,1531977992,394,1,528,1,1,https://segmentfault.com/a/1190000004613367
226,1,0,7,"
                    
<p>听说好的程序员都在用github。</p>
<p>用github有一阵子了，因为不会用Git，所以一直是通过GUI客户端程序去同步代码的，这样明显很low。而且，好多地方都没搞清楚，比如，Issue用来干什么？Pull Request怎么使用？</p>
<p>拒绝GUI，必须命令行。</p>
<p>看了《Github入门与实践》一书，经过一番梳理和实践，这次我终于懂得用Git和Github了。</p>
<h2>思维导图</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVtuBu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Git</h2>
<h3>Git是什么？</h3>
<blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.<br>[译：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。]</p></blockquote>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git可以帮助我们管理代码，它是一个分布式版本控制系统。它设计了仓库（版本库）这样一种管理机制；同时，不同于SVN,CVS集中式的版本控制理念，Git是分布式版本控制。</p>
<p>两者的区别可以阅读廖雪峰老师的文章：<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000"" rel=""nofollow noreferrer"">集中式vs分布式</a>。</p>
<p>而且，Git是通过命令行操作的。</p>
<h3>基本操作</h3>
<p>这里只简单罗列几条命令，具体操作在下面通过Git创建本地仓库会介绍到。</p>
<ul>
<li><p><code>git init</code>：初始化仓库</p></li>
<li><p><code>git status</code>：查看仓库状态</p></li>
<li><p><code>git add</code>：向暂存区中添加文件</p></li>
<li><p><code>git commit</code>：保存仓库的历史记录</p></li>
<li><p><code>git log</code>：查看提交日志</p></li>
<li><p><code>git diff</code>：查看更改前后的差别</p></li>
<li><p><code>git branch</code>：显示分支一览表</p></li>
<li><p><code>git checkout -b</code>：创建并切换分支</p></li>
<li><p><code>git checkout</code>：切换分支</p></li>
<li><p><code>git merge</code>：合并分支</p></li>
<li><p><code>git reset</code>：回溯历史版本</p></li>
<li><p><code>git remote add</code>：添加远程仓库</p></li>
<li><p><code>git push</code>：推送至远程仓库</p></li>
<li><p><code>git clone</code>：获取远程仓库</p></li>
</ul>
<h3>分支</h3>
<p>在进行多个并行作业时，我们会用到分支。</p>
<p>master分支是Git默认创建的分支，它就像河流的主干，而我们根据需要，创建的一个个分支，就相当于河流分化出来的一个个小分流。</p>
<p>我们在分支上进行编程作业（例如，每个负责项目的一个模块开发），当完成之后，进行审核无误，再合并到主分支master上，这样就能合理高效地实现多人并行开发。</p>
<h4>特性分支</h4>
<p>特性分支，是集中实现单一特性（主题），除此之外不进行任何作业的分支。</p>
<p>在日常开发过程中，我们常常会创建数个特性分支，同时在保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由master担当。</p>
<p>假设我们创建了一个feature-a分支，这一分支主要实现feature-a，除feature-a的实现之外不进行任何作业。即便在开发过程中发现了Bug，也需要再创建新的分支，在新分支中进行修正。</p>
<h2>Github</h2>
<h3>Github是什么？</h3>
<p>Github是一个网站。<br><span class=""img-wrap""><img data-src=""/img/bVtsfL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>一些开发者在使用Git以后，找不到好的Git托管网站，于是Tom Preston Werner 和 Chris Wanstrath 就开发了Github出来，提供Git仓库托管服务。</p>
<p>所以，在我看来，它们两者的关系就是：Git是一个系统，相当于一个工具，而Github就是基于这样一个系统的平台，让开发者更高效地使用Git去托管自己的代码。</p>
<h3>如何使用Github？</h3>
<p>因为Git是使用仓库进行版本控制的，所以我们在Github的操作也是围绕着仓库展开。</p>
<p>当我们想管理一个项目的代码时，我们就在Github上创建一个仓库，然后上传项目代码，就实现了代码托管。</p>
<p>所以，一般我们的开发流程是这样的：</p>
<ol>
<li><p>在本地通过Git建立一个仓库，我们称之为“本地仓库”，然后进行我们的编程工作。使用Git，可以帮助实现版本控制。</p></li>
<li><p>在Github上建立一个仓库，我们称之为“远程仓库”，然后将本地仓库的内容推送到远程仓库，同步代码，这样就实现了托管功能。</p></li>
</ol>
<p>或者，如果是先在Github上建立了仓库，设置好了项目，那么就将远程仓库的项目克隆到本地仓库，同理。</p>
<p>我个人的理解是，远程仓库——操作Github；本地仓库——操作Git。</p>
<h3>本地仓库</h3>
<h4>创建——初始化仓库</h4>
<p>要使用Git进行版本管理，必须先初始化仓库。</p>
<ol>
<li><p>建立一个目录，并初始化仓库。<span class=""img-wrap""><img data-src=""/img/bVtsOL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>  如果初始化成功，执行了<code>git init</code>命令的目录下就会生成.git目录。这个.git目录里存着管理当前目录内容所需的仓库数据。我们将这个目录的内容成为“附属于该仓库的工作树”。</p></li>
<li><p>查看仓库状态。<span class=""img-wrap""><img data-src=""/img/bVtsPe"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>   工作树和仓库在被操作过程中，状态会不断变化，所以需要经常用<code>gti status</code>查看当前状态。</p></li>
</ol>
<h4>提交——版本更新</h4>
<p>编辑完代码后，一个完整的提交流程应该是：<code>git status</code> -&gt;  <code>git add</code> -&gt; <code>git commit</code>。</p>
<ol>
<li><p><code>git status</code>——查看仓库状态： <span class=""img-wrap""><img data-src=""/img/bVtsZ5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>  Untracked files表示修改过的文件尚未追踪，即尚未成为仓库的管理对象（加入到工作树中）。</p></li>
<li><p><code>git add</code>——加入暂存区：暂存区是提交之前的一个临时区域。<code>git add</code>将其加入暂存区，为保存到工作树中做准备。<span class=""img-wrap""><img data-src=""/img/bVts0D"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span>此时再运行<code>git status</code>，提示“Change to be committed”，说明是提交状态。</p></li>
<li><p><code>git commit</code>——保存仓库的历史记录：将刚刚的提交状态保存，这样就算完成了一个版本控制。<span class=""img-wrap""><img data-src=""/img/bVts1l"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>  -m 参数后的字符串称作提交信息，是对这个提交的描述。</p></li>
</ol>
<h4>查看——仓库状态</h4>
<ol>
<li><p>git log——查看提交日志：查看以往仓库中提交的日志，什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。<br><span class=""img-wrap""><img data-src=""/img/bVts2g"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li>
<p>git diff——查看更改前后的差别：查看工作树、暂存区、最新提交之间的差别。</p>
<ul>
<li><p>查看工作树和暂存区的区别：在test.html中写点东西，先不用<code>git add</code>,直接运行<code>git diff</code>查看，此时显示的是工作树与最新提交状态之间的差别。<span class=""img-wrap""><img data-src=""/img/bVts22"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>查看工作树与最新提交的差别：先执行<code>git add</code>将修改提交到暂存区；如果此时执行<code>git diff</code>,会发现没有任何显示，这是因为执行了<code>git add</code>后工作树和暂存区的状态并无差别。要查看与最新提交的差别，要执行<code>git diff HEAD</code>。<span class=""img-wrap""><img data-src=""/img/bVts3j"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ul>
</li>
</ol>
<h3>远程仓库</h3>
<h4>准备</h4>
<ol>
<li><p>创建账户：如果你还没有Github账户，那么你需要先<a href=""https://github.com/join?source=login"" rel=""nofollow noreferrer"">创建一个账户</a>。<br>登录后，即可使用Github的功能，创建仓库。<span class=""img-wrap""><img data-src=""/img/bVtsho"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li>
<p>设置SSH Key：Github上仓库与本地仓库连接，是通过使用了SSH的公开秘钥认证方式进行的。所以，得现在本地生成SSH Key，然后设置到Github上，才能实现仓库的远程连接。</p>
<ul>
<li><p>打开Git Bash，创建SSH Key。<br>  运行命令：<code>ssh-keygen -t rsa -C ""your_email@example.com""</code><span class=""img-wrap""><img data-src=""/img/bVtsGF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span> 输入密码后，会出现以下结果，表明创建成功：<span class=""img-wrap""><img data-src=""/img/bVtsHd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span> id_rsa是私有密钥，id_rsa.pub是公开密钥。</p></li>
<li><p>在Github中添加公开密钥。<span class=""img-wrap""><img data-src=""/img/bVtsEQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtsHR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ul>
</li>
</ol>
<h4>创建——建立远程仓库</h4>
<ol>
<li><p>创建：<br><span class=""img-wrap""><img data-src=""/img/bVtsIs"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li>
<p>仓库配置：<br><span class=""img-wrap""><img data-src=""/img/bVtsJw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ul>
<li><p>如果想向Github添加手中已有的Git仓库，建议不要勾选<code>Initialize this repository with a README</code>选项；</p></li>
<li><p>Add.gitignore：可以在初始化时生成.gitignore文件，这个设定会帮我们把不需要在Git仓库中进行版本管理的文件记录在.gitignore文件中，省去了每次根据框架进行设置的麻烦。若不使用任何框架，则可不选择。</p></li>
<li><p>Add a license：选择要添加的许可协议文件，一般可不选。</p></li>
</ul>
</li>
<li><p>创建成功：<br><span class=""img-wrap""><img data-src=""/img/bVtsKf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<h4>克隆——获取远程仓库</h4>
<p>当你是先在Github上创建好项目仓库时，此时需要把远程仓库克隆到本地，创建一个本地仓库。</p>
<ol>
<li><p>复制HTTPS链接：<span class=""img-wrap""><img data-src=""/img/bVtsLA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>打开Git Bash，进入要作为仓库的文件目录：<span class=""img-wrap""><img data-src=""/img/bVtsMm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>运行命令：<code>git clone https://github.com/Monkey626/test.git</code><span class=""img-wrap""><img data-src=""/img/bVtsMq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>克隆成功：<span class=""img-wrap""><img data-src=""/img/bVtsMs"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>进入仓库：查看当前仓库分支信息。<span class=""img-wrap""><img data-src=""/img/bVtsMF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<p>执行git clone命令后，我们会默认处于master分支下，同时系统会自动将origin设置成该远程仓库的标识符（即origin代表了该远程仓库）。</p>
<h4>同步——更新代码（从本地仓库传到远程仓库）</h4>
<p>当在本地完成好编程作业时，此时需要将代码同步到远程仓库，以实现托管。</p>
<ol>
<li><p>添加远程仓库：你需要将远程仓库与本地仓库连接起来，我们用<code>git remote add</code>命令来设置本地仓库的远程仓库。 <span class=""img-wrap""><img data-src=""/img/bVtuzU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>推送至远程仓库：如果想将当前本地仓库分支下的内容推送给远程仓库，要用<code>git push</code>命令。假定我们在master分支（如果是其他分支，最后的参数就改为其它分支对应名称）下操作<br><span class=""img-wrap""><img data-src=""/img/bVtuBp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtuBo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<h4>同步——更新代码（从远程仓库拉到本地仓库）</h4>
<p>当你的队友将完成了编程作业，将其代码推送到远程仓库后，此时，你可能需要将代远程仓库队友更新后的代码拉到本地，这时要用到<code>git pull</code>命令。</p>
<ol>
<li><p>运行命令行<code>git pull</code>：<span class=""img-wrap""><img data-src=""/img/bVtsNM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>拉取成功：<span class=""img-wrap""><img data-src=""/img/bVtsNQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<h3>Github几大功能</h3>
<h4>Issue</h4>
<p>在软件开发过程中，开发者们为了跟踪BUG及进行软件相关讨论，进而方便管理，创建了Issue。</p>
<p>在Github上，可以将它作为开发者之间的交流工具，多多加以利用。</p>
<p>Issue可以在以下情况使用：</p>
<ul>
<li><p>发现软件的Bug并报告；</p></li>
<li><p>有事想向作者询问、探讨；</p></li>
<li><p>事先列出今后准备实施的任务。</p></li>
</ul>
<p>Issue支持markdown语法，也支持添加标签便于管理。</p>
<p>在Issue里可以添加图片，可以使用表情。</p>
<h4>Pull Request</h4>
<p>Pull Request是用户修改代码后向对方仓库发送采纳请求的功能，也是Github的核心功能。</p>
<p>Pull Request的流程：</p>
<ol>
<li><p>Fork：将你要修改代码的项目仓库Fork到自己的Github账号上，创建一个属于你的仓库；<span class=""img-wrap""><img data-src=""/img/bVtuk5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtuk8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>Clone：将其clone到本地  <span class=""img-wrap""><img data-src=""/img/bVtulu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>Branch：在本地仓库创建一个特性分支（有了更明确的主题，也便于对方了解自己修改代码的意图），用于本次代码修改。 <span class=""img-wrap""><img data-src=""/img/bVtulI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>Commit：提交修改  <span class=""img-wrap""><img data-src=""/img/bVtumg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>Push：要从Github发送Pull Ruquest，Github端的仓库必须有一个包含了修改后代码的分支。所以，要创建本地特性分支的相应远程分支。 <span class=""img-wrap""><img data-src=""/img/bVtulq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtulr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtumr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>Send：发送Pull Request。 <span class=""img-wrap""><img data-src=""/img/bVtumw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtums"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><span class=""img-wrap""><img data-src=""/img/bVtumz"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<p>这样，就是一个完整的发送Pull Request流程。</p>
<h4>Wiki</h4>
<p>Wiki是一个使用简单的语法就能编写文档的功能。</p>
<p>所有有权限的人都可以对文中进行修改。</p>
<p>Wiki多被用于编写博客文章、教程、使用手册。</p>

                ", Github入门与实践,1531977994,468,1,858,1,1,https://segmentfault.com/a/1190000004606816
227,1,0,7,"
                    
<p>作为一个前端程序员，要学的东西很多，要看的技术书籍也不少。各种层出不穷的框架和工具出现，出现百花齐放的景象。</p>
<p>为了保持竞争力，还是要多读书，多尝试新的框架和工具，多撸代码。练就一双强壮的麒麟臂，才能在江湖留得一席之地。</p>
<p>列出一些书单，工具集和要掌握的知识。</p>
<h3>书单：</h3>
<ul>
<li><p>《JavaScript权威指南》</p></li>
<li><p>《JavaScript高级程序设计》</p></li>
<li><p>《JavaScript模式》</p></li>
<li><p>《JavaScript设计模式》</p></li>
<li><p>《高性能JavaScript》</p></li>
<li><p>《深入浅出nodeJS》</p></li>
<li><p>《Javascript语言精粹》</p></li>
<li><p>《图解CSS3》</p></li>
<li><p>......</p></li>
</ul>
<h3>工具：</h3>
<ul>
<li><p>Sublime Text &amp; Atom &amp; Webstorm &amp; VS code  //编辑器、IDE</p></li>
<li><p>SVN &amp; Git  //代码管理、版本控制</p></li>
<li><p>Chrome Dev Tools &amp; FireFox Developer Edition //浏览器开发者工具</p></li>
<li><p>ESLint &amp; JSLint //JavaScript代码语法检查</p></li>
<li><p>ironNode    //NodeJS代码调试</p></li>
<li><p>less &amp; sass</p></li>
<li><p>React DevTools //react调试工具</p></li>
<li><p>Grunt &amp; Gulp &amp; browserify &amp; Webpack + Hot module replacement //代码打包及热部署工具</p></li>
<li><p>Redux DevTools    //redux调试工具</p></li>
<li><p>Babel //ES6、react等语法转换工具，将代码转换成ES5</p></li>
<li><p>forever * pm2 //nodejs项目部署工具</p></li>
<li><p>karma &amp; mocha &amp; PhantomJS //自动化测试工具</p></li>
<li><p>......</p></li>
</ul>
<h3>框架、库</h3>
<ul>
<li><p>jQuery</p></li>
<li><p>Backbone</p></li>
<li><p>Ember</p></li>
<li><p>Angular &amp; Angular2</p></li>
<li><p>React</p></li>
<li><p>Vue &amp; Vue2</p></li>
<li><p>Ionic &amp; Ionic2</p></li>
<li><p>React Native</p></li>
<li><p>Weex</p></li>
<li><p>Electron</p></li>
<li><p>...</p></li>
</ul>
<h3>知识</h3>
<ul>
<li><p>JavaScript(ECMAScript)，ES5 &amp; ES6 &amp; ES7</p></li>
<li><p>HTML5 API &amp; CSS3</p></li>
<li><p>SVG &amp; Canvas</p></li>
<li><p>WebGL &amp; D3.js</p></li>
<li><p>CMD &amp; AMD &amp; CommonJS规范</p></li>
<li><p>RequireJS &amp; SeaJS</p></li>
<li><p>CoffeeScript &amp; TypeScript</p></li>
<li><p>NodeJS &amp; Express &amp; Koa</p></li>
<li><p>延时加载、延时请求</p></li>
<li><p>HTTP &amp; WebSocket &amp; TCP 协议</p></li>
<li><p>性能优化</p></li>
<li><p>......</p></li>
</ul>
<p>待续。。。如有错误或不足，请指正，谢谢。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQneb?w=900&amp;h=324"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", 前端工程师之路,1531977995,593,1,174,1,1,https://segmentfault.com/a/1190000004505023
228,1,0,7,"
                    
<h2>ToDo</h2>
<ul>
<li><p>方便的 blame 一行代码是谁改的</p></li>
<li><p>blame 一行代码的改动历史（可能有多个人改过多次，有时候只看最后的改动不够）</p></li>
</ul>
<h2>简单 blame</h2>
<pre><code>$ git blame &lt;filename&gt;
$ git blame -L 100,100 &lt;filename&gt;
$ git blame -L 100,+10 &lt;filename&gt;</code></pre>
<p>在 Sublime Text 中可以直接 blame，<code>Shift</code> + <code>Cmd</code> + <code>P</code> --&gt; <code>blame</code> 来使用 Git blame，且选中几行的时候可以只 blame 这几行。</p>
<h2>使用 log 来查看某一行的所有操作</h2>
<p>这里最后实际没有用 blame，而是用了 log 命令。这样可以看到对这一行进行操作过的所有 commit。</p>
<pre><code>$ git log -L start,end:file
$ git log -L 155,155:git-web--browse.sh</code></pre>
<p>Sublime Text 里面的 log 不是很好用，不能看到细节，也不能 log 某一行。</p>
<h2>在 Github 里面查看修改的那一次 Commit</h2>
<p>大概是如下的格式：</p>
<pre><code>https://github.com/&lt;user_name&gt;/&lt;project_name&gt;/commit/&lt;commit hash id&gt;</code></pre>
<p>在以上页面中还可以顺藤摸瓜找到对应的那次 PR 的内容。</p>
<h2>参考</h2>
<ul>
<li><p><a href=""http://stackoverflow.com/questions/8435343/retrieve-the-commit-log-for-a-specific-line-in-a-file"" rel=""nofollow noreferrer"">git - Retrieve the commit log for a specific line in a file? - Stack Overflow</a></p></li>
<li><p><a href=""https://git-scm.com/docs/git-blame"" rel=""nofollow noreferrer"">Git - git-blame Documentation</a></p></li>
<li><p><a href=""http://gitbook.liuhui998.com/5_5.html"" rel=""nofollow noreferrer"">Git Book 中文版 - 查找问题的利器 - Git Blame</a></p></li>
<li><p><a href=""http://www.cnblogs.com/lanxuezaipiao/p/3552805.html"" rel=""nofollow noreferrer"">每一行代码都有记录—如何用git一步步探索项目的历史 - Alexia(minmin) - 博客园</a></p></li>
</ul>
<h2>扩展</h2>
<ul><li><p><a href=""https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95"" rel=""nofollow noreferrer"">Git - 使用 Git 调试</a></p></li></ul>

                ", git blame 小记,1531977997,546,1,557,1,1,https://segmentfault.com/a/1190000004446181
229,1,0,7,"
                    
<p>Web本身就是跨平台的，这意味着这中间存在着无限的可能性。</p>
<p>我是一名Web Developer，对于我来能用Web开发的事情就用Web来完成就好了——不需要编译，不需要等它编译完。我想到哪我就可以写到哪，我改到哪我就可以发生哪发生了变化。</p>
<p>最近我在写Growth——一个帮助开发人员成长的应用，在近一个月的业余时间里，完成了这个应用的：</p>
<ul>
<li><p>移动应用版：Android、Windows Phone、iOS（等账号和上线）</p></li>
<li><p>Web版</p></li>
<li><p>桌面版：Mac OS、Windows、GNU/Linux</p></li>
</ul>
<p>截图合并如下：</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/growth-full-platforms.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""growth-full-platforms.png"" title=""growth-full-platforms.png""></span></p>
<p>而更重要的是它们使用了同一份代码——除了对特定设备进行一些处理就没有其他修改。相信全栈的你已经看出来了：</p>
<p>Web = Chrome + Angular.js + Ionic</p>
<p>Desktop = Electron + Angular.js + Ionic</p>
<p>Mobile = Cordova + Angular.js + Ionic</p>
<p>除了前面的WebView不一样，后面都是Angular.js + Ionic。</p>
<h2>从Web到混合应用，再到桌面应用</h2>
<p>在最打开的时候它只是一个单纯的混合应用，我想总结一下我的学习经验，分享一下学习的心得，如：</p>
<ul>
<li><p>完整的Web开发,运维,部署,维护介绍</p></li>
<li><p>如何写好代码——重构、测试、模式</p></li>
<li><p>遗留代码、遗留系统的形成</p></li>
<li><p>不同阶段所需的技能</p></li>
<li><p>书籍推荐</p></li>
<li><p>技术栈推荐</p></li>
<li><p>Web应用解决方案</p></li>
</ul>
<p>接着我用Ionic创建了这个应用，这是一个再普通不过的过程。在这个过程里，我一直使用Chrome在调度我的代码。因为我是Android用户，我有Google Play的账号，便发布了Android版本。这时候遇到了一个问题，我并没有Apple Developer账号(现在在申请ing。。)，而主要的用户对象程序员，这是一群<strong>不土</strong>的土豪。</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/iphone.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""iPHONE"" title=""iPHONE""></span></p>
<p>偶然间我才想到，我只要上传Web版本的代码就可以暂时性实现这个需求了。接着找了个AWS S3的插件，直接上传到了AWS S3上托管成静态文件服务。</p>
<p>几天前在Github上收到一个issue——关于创造桌面版， 我便想着这也是可能的，我只需要写一个启动脚本和编译脚本即可。</p>
<p>所以，最后我们的流程图就如下所示：</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/growth-arch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Growth Arch"" title=""Growth Arch""></span></p>
<p>除了显示到VR设备上，好像什么也不缺了。并且在我之前的文章《<a href=""https://github.com/phodal/oculus-nodejs-threejs-example"" rel=""nofollow noreferrer"">Oculus + Node.js + Three.js 打造VR世界</a>》，也展示了Web在VR世界的可能性。</p>
<p>在这实现期间有几个点可以分享一下：</p>
<ol>
<li><p>响应式设计</p></li>
<li><p>平台/设备特定代码</p></li>
</ol>
<h2>响应式设计</h2>
<p>响应式设计可以主要依赖于Media Query，而响应式设计主要要追随的一点是不同的设备不同的显示，如：</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/full-platforms.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""full-platforms.jpg"" title=""full-platforms.jpg""></span></p>
<p>这也意味着，我们需要对不同的设备进行一些处理，如在大的屏幕下，我们需要展示菜单：</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/gnu-linux.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gnu-linux.png"" title=""gnu-linux.png""></span></p>
<p>而这可以依赖于Ionic的<strong>expose-aside-when=""large""</strong>，而并非所有的情形都是这么简单的。如我最近遇到的问题就是图片缩放的问题，之前的图片针对的都是手机版——经过了一定的缩放。</p>
<p>这时在桌面应用上就会出现问题，就需要限定大小等等。</p>
<p>而这个问题相比于平台特定问题则更容易解决。</p>
<h2>平台特定代码</h2>
<p>对于特定平台才有的问题就不是一件容易解决的事，分享一下：</p>
<h3>存储</h3>
<p>我遇到的第一个问题是<strong>数据存储</strong>的问题。最开始的时候，我只需要开始混合应用。因此我可以用<strong>Preferences</strong>、或者<strong>SQLite</strong>来存储数据。</p>
<p>后来，我扩展到了Web版，我只好用LocalStoarge。于是，我就开始抽象出一个<strong>$storageServices</strong>来做相应的事。接着遇到一系列的问题，我舍弃了原有的方案，直接使用LocalStoarge。</p>
<h3>数据分析</h3>
<p>为了开发方便，我使用Google Analytics来分析用户的行为——毕竟数据对我来说也不是特别重要，只要可以看到有人使用就可以了。</p>
<p>这时候遇到的一个问题是，我不需要记录Web用户的行为，但是我希望可以看到有这样的请求发出。于是对于Web用户来说，只需要：</p>
<pre><code class=""js"">        trackView: function (view) {
          console.log(view);
        }</code></pre>
<p>而对于手机用户则是:</p>
<pre><code class=""js"">      trackView: function (view) {
        $window.analytics.startTrackerWithId('UA-71907748-1');
        $window.analytics.trackView(view)
      }</code></pre>
<p>这样在我调试的时候我只需要打个Log，在产品环境时就会Track。</p>
<h3>更新</h3>
<p>同样的，对于Android用户来说，他们可以选择自行下载更新，所以我需要针对Android用户有一个自动更新：</p>
<pre><code>var isAndroid = ionic.Platform.isAndroid();
if(isAndroid) {
  $updateServices.check('main');
}</code></pre>
<h3>桌面应用</h3>
<p>对于桌面应用来说也会有类似的问题，我遇到的第一个问题是Electron默认开启了AMD。于是，直接删之：</p>
<pre><code class=""html"">&lt;script&gt;
//remove module for electron
if(typeof module !== 'undefined' &amp;&amp; module &amp;&amp; module.exports){
  delete module;
}
&lt;/script&gt;</code></pre>
<p>类似的问题还有许多，不过由于应用内容的限制，这些问题就没有那么严重了。</p>
<p>如果有一天，我有钱开放这个应用的应用号，那么我就会再次献上这个图：</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/hexoarch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""六边形架构"" title=""六边形架构""></span></p>
<h2>未来</h2>
<p>我就开始思索这个问题，未来的趋势是合并到一起，而这一个趋势在现在就已经是完成时了。</p>
<p>那么未来呢？你觉得会是怎样的？</p>
<p>项目源码: <a href=""https://github.com/phodal/growth"" rel=""nofollow noreferrer""></a><a href=""https://github.com/phodal/growth"" rel=""nofollow noreferrer"">https://github.com/phodal/growth</a></p>
<p>更多内容请关注我的微信公众号：phodal</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsHJ9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 一份代码构建移动、桌面、Web全平台应用,1531977998,360,1,490,1,1,https://segmentfault.com/a/1190000004417979
230,1,0,7,"
                    
<p>好久没写博客了，趁着年前空闲的时间来一篇轻松点的东西。<br>最近工作中积累了一些Angular组件打算整一整把他们开源了，既然要开源那么代码可靠性就很重要了，单测不能少，为了保证每次提交的代码都能很好的运行，持续集成不能少。之前看到很多开源项目介绍中都有一些单测覆盖率和build结果的图标，就像这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsGKF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>觉得挺酷的。打算在自己的开源组件中也整一套。<br>经过Google决定使用TravisCI来进行持续集成，Codecov来统计单测覆盖率。</p>
<h2>Travis CI</h2>
<p>Travis CI是国外新兴的开源持续集成构建项目，支持Github项目。使用十分方便。</p>
<ol>
<li><p>使用Github账号登录<a href=""https://travis-ci.org/"" rel=""nofollow noreferrer"">Travis CI</a>；</p></li>
<li><p>登录之后会自动同步Github项目，选择需要使用Travis CI的项目</p></li>
<li><p>在项目的根目录新增<code>.travis.yml</code>文件，内容如下：</p></li>
</ol>
<pre><code class=""yml"">#指定运行环境
language: node_js
#指定nodejs版本，可以指定多个
node_js:
  - 0.12.5

#运行的脚本命令
script:
  - npm run ci

#指定分支，只有指定的分支提交时才会运行脚本
branches:
  only:
    - master</code></pre>
<p>更多语法请看<a href=""https://docs.travis-ci.com/"" rel=""nofollow noreferrer"">这里</a>。使用起来非常方便，这样当你每次向github push代码的时候，Travis CI就会自动运行<code>.travis.yml</code>里面的<code>script</code>。自动进行编译以及运行单测。<br>由于Travis CI每次build之前都会运行<code>npm install</code>安装项目依赖的npm包，所以在提交代码的时候要保证把所有依赖的包都已经在<code>package.json</code>中声明了，否则build就会失败。</p>
<h2>Codecov</h2>
<p>Codecov是一个开源的测试结果展示平台，将测试结果可视化。Github上许多开源项目都使用了Codecov来展示单测结果。<br>Codecov跟Travis CI一样都支持Github账号登录，同样会同步Github中的项目。在nodejs环境下使用Codecov需要安装对于的npm包，运行下面这个命令进行安装：</p>
<pre><code class=""shell"">npm install codecov --save-dev</code></pre>
<p>这个包的作用是将我们运行单测产生的结果文件上传到Codecov上进行可视化展示。同时codecov支持的结果文件类型为<code>cobertura</code>。所以需要保证单测执行的结果文件的类型为<code>cobertura</code>。<br>前端项目进行单元测试推进<code>karma</code> + 'jasmine'的组合。这两个具体是什么东西大家Google一下就知道。使用<code>karma</code>可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：</p>
<pre><code class=""javascript"">// Karma configuration
// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    // 使用的测试框架jasmine, requirejs支持模块化加载
    frameworks: ['jasmine', 'requirejs'],


    // list of files / patterns to load in the browser
    files: [
        // karma中用到进行requirejs配置的文件
        'test/test-main.js',
        // 测试中需要用到的文件，includeed设为false表示在页面加载的时候不会加载相应的js文件，也就是可以通过requirejs进行异步加载
        {pattern: 'node_modules/jquery/dist/jquery.min.js', included: false},
        {pattern: 'node_modules/angular/angular.min.js', included: false},
        {pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false},
        {pattern: 'src/bg-single-selector.js', included: false},
        {pattern: 'test/selector.spec.js', included: false}
    ],


    // list of files to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    // 针对bg-single-selector.js生成单测覆盖率结果
    preprocessors: {
        'src/bg-single-selector.js': 'coverage'
    },


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    // 测试结果的几种输出方式
    reporters: ['progress', 'coverage', 'verbose'],
    // 测试结果报告的类型
    coverageReporter:{
        reporters: [{
            type:'text-summary'
        }, {
            type: 'html',
            dir: 'test/coverage'
        }, {
            // 这就是Codecov支持的文件类型
            type: 'cobertura',
            subdir: '.',
            dir: 'test/coverage'
        }]
    },

    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS'],
    // 运行测试依赖的插件
    plugins: [
        'karma-jasmine',
        'karma-coverage',
        'karma-verbose-reporter',
        'karma-phantomjs-launcher',
        'karma-requirejs'
    ],

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: true
  })
}
</code></pre>
<p>通过karma进行单元测试，将命令写到<code>.travis.yml</code>中就可以在每次build的时候运行单测，同时运行<code>codecov [cobertura-coverage.xml路径]</code>就会把单测结果上传到Codecov。在本地运行codecov会失败，需要将这个过程加入到Travis CI的build脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上Codecov提供的token。</p>
<h2>在github中加入图标</h2>
<p>到了最后一步，Travis CI和Codecov都提供图标链接来展示结果。我们只需要将图标链接加入到项目的README中就可以看到结果了。<br>对于Travis CI来说，点击下图中的图标：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsGOi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>就会弹出图标的地址。<br>对于Codecov来说，打开项目的设置列表就会看到，如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsGOj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>最后只需要将对应的链接加到README文件中就可以了。下面是最后的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsGOq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>是不是很赞！<br>项目地址：<a href=""https://github.com/GaojingComponent/BGSingleSelector"" rel=""nofollow noreferrer"">BGSingleSelector</a>，欢迎大家试用提意见，同时不要吝啬Star。</p>
<p>最后的最后，做一个广告。<a href=""http://gaojing.baidu.com/#/"" rel=""nofollow noreferrer"">百度告警平台</a>。这是一个智能的告警平台，提供实时精确的告警送达，故障的协作处理能力。再也不需要担心遗漏监控报警，解放运维人力。</p>
<h3>
<strong><em>最后，安利下我的个人博客，欢迎访问:</em></strong> <a href=""http://bin-playground.top"" rel=""nofollow noreferrer"">http://bin-playground.top</a>
</h3>

                ", Github装逼指南——Travis CI 和 Codecov,1531977999,354,1,114,1,1,https://segmentfault.com/a/1190000004415437
231,1,0,7,"
                    
<p>你应该见过不少对GitHub上等等开源项目进行的分析文章。据说国外甚至有人靠分析Github上的项目解决了毕业论文……（要是我的毕业论文也能这么解决就好了XD） 借助于Google Big Query和来自于<a href=""https://www.githubarchive.org/"" rel=""nofollow noreferrer"">GitHub Archive</a>的数据归档，对GitHub上的项目进行简单的数据分析并不困难。下文我将试图分析2015年GitHub上被收藏（starred）最多的5000个项目，进而求出2015年最受瞩目的编程语言排行。</p>
<p><a href=""https://www.githubarchive.org/"" rel=""nofollow noreferrer"">GitHub Archive</a>这个网站通过GitHub的API，定期抓取GitHub的<a href=""https://developer.github.com/v3/activity/events/types/"" rel=""nofollow noreferrer"">事件数据</a>，并上传到Google Big Query，供热心群众分析。它在官网上介绍了<a href=""https://www.githubarchive.org/#bigquery"" rel=""nofollow noreferrer"">如何用Google Big Query来分析数据</a>。</p>
<p>Google Big Query允许用户创建项目，上传数据归档，并通过SQL来查询这些数据。下图就是GitHub Archive在Big Query上，存储着2016-02-01这一天数据的<a href=""https://bigquery.cloud.google.com/table/githubarchive:day.events_20160201"" rel=""nofollow noreferrer"">项目</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsDbU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github-star-20160201"" title=""github-star-20160201""></span></p>
<p>我们可以看到它的schema定义，基本上类似于GitHub<a href=""https://developer.github.com/v3/activity/events/types/"" rel=""nofollow noreferrer"">事件API</a>返回的数据格式。其中一些重要的字段如下：</p>
<ul>
<li><p>type 事件类型。比如jeresig创建了项目processing-js，那么这个事件的类型就是CreateEvent。你可以上GitHub事件相关的文档里查到各种事件对应的类型。</p></li>
<li><p>repo.name 项目名，在上面例子中，是jeresig/processing-js</p></li>
<li><p>actor.login 该事件的主人公，在上面例子中，是jeresig</p></li>
</ul>
<p>于是我们小试牛刀，运行下面的Query，查询jeresig去年一年push的次数：（这里用<code>TABLE_DATE_RANGE</code>函数用于匹配从<code>githubarchive:day.events_20150101</code>到<code>githubarchive:day.evnets_20151231</code>所有的表）</p>
<pre><code>SELECT COUNT(*) FROM 
    TABLE_DATE_RANGE([githubarchive:day.events_], 
        TIMESTAMP('2015-01-01'), 
        TIMESTAMP('2015-12-31'))
    WHERE type = 'PushEvent' and actor.login = 'jeresig'</code></pre>
<p>得出的结果为</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsDbW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github-jeresig-push"" title=""github-jeresig-push""></span></p>
<p>稍微复杂点，运行下面的Query，查询jeresig去年一年内提了Pull Request的项目和各自提的次数：</p>
<pre><code>SELECT COUNT(*) AS num, repo.name FROM 
    TABLE_DATE_RANGE([githubarchive:day.events_], 
        TIMESTAMP('2015-01-01'), 
        TIMESTAMP('2015-12-31'))
    WHERE type = 'PullRequestEvent' and actor.login = 'jeresig'
    GROUP BY repo.name ORDER BY num DESC</code></pre>
<p>把关注点从人转向项目，让我们回归主题，查询去年一年间最受瞩目的那些项目们，并粗略地分析下它们。通过查GitHub的API文档，我们知道用户star一个项目时会触发一个<a href=""https://developer.github.com/v3/activity/events/types/#watchevent"" rel=""nofollow noreferrer"">WatchEvent</a>（对的，就是WatchEvent）。所以我们可以遍历下去年所有的WatchEvent事件，按repo_name进行分组，计算每组的数目，并截取前5000名。写出来的Query如下：</p>
<pre><code>SELECT COUNT(*) AS star, repo.name FROM 
      TABLE_DATE_RANGE([githubarchive:day.events_], 
        TIMESTAMP('2015-01-01'), 
        TIMESTAMP('2015-12-31'))
      WHERE type = 'WatchEvent' 
      GROUP BY repo.name ORDER BY star DESC LIMIT 5000</code></pre>
<p>我把Big Query查询到的数据保存成<code>github-star-2015.csv</code>，分享到百度网盘上，有需要的人可以下载：<a href=""http://pan.baidu.com/s/1dElWKHr"" rel=""nofollow noreferrer"">http://pan.baidu.com/s/1dElWKHr</a></p>
<p>现在，我宣布，2015年最受瞩目的项目前十的名单新鲜出炉啦！（请脑补最应景的BGM）</p>
<pre><code>~/doc head -11 github-star-2015.csv 
star,repo_name
38318,FreeCodeCamp/FreeCodeCamp
25861,facebook/react-native
25479,apple/swift
24344,sindresorhus/awesome
22917,facebook/react
22093,jlevy/the-art-of-command-line
20401,NARKOZ/hacker-scripts
19736,twbs/bootstrap
17885,google/material-design-lite
17568,airbnb/javascript</code></pre>
<p>初看这份名单，你会发现去年是React年。前十的名单里，React就占了两。你也许会想起，swift在这一年里开源了（果粉的力量真强大，同样也是去年搬到GitHub的golang就挤不进前十名～）。仔细分析下各个项目，你会发现，涨star最快的项目有不少是代码无关的项目。比如第一名FreeCodeCamp，第四名awesome，第六名the-art-of-command-life，第十名airbnb/javascript（airbnb内部的javascript编程规范）等等，都是如此。另外，一个显著的发现是，前十名中，前端的项目占了三个，这还不计算半个前端项目的react-native和前端编码规范的airbnb/javascript。前端项目三分天下有其一，准确来讲，已经接近撑起半边天了。如果说前几年的GitHub是Ruby开发者的GitHub，那么如今的GitHub无疑是前端的GitHub。</p>
<p>借助GitHub的API，我们来看看前5000名项目的编程语言使用情况。题外话，如果GitHub提供了项目所有者可以给自己的项目打标签，那么我们除了分析下编程语言，还可以分析下更多方面的内容，比如去年哪一方面的项目最受瞩目。要是有机会给GitHub产品部门提意见，我一定会写上这一点。不过目前就只能分析分析下编程语言了。</p>
<p>由于GitHub设置了API调用限制，我们需要先注册应用，获取对应的<code>client_id</code>和<code>client_secret</code>，才能有足够的调用数量。注册地址见 <a href=""https://github.com/settings/applications/new"" rel=""nofollow noreferrer"">https://github.com/settings/applications/new</a>，里面的数据不需要审核，我当时是乱填一通的=_=</p>
<p>GitHub提供了查询某个项目的编程语言使用情况的<a href=""https://developer.github.com/v3/repos/#list-languages"" rel=""nofollow noreferrer"">API</a>，借此写出了下面的脚本，统计前5000个项目中编程语言的占比：</p>
<pre><code>#!/usr/bin/env ruby
# encoding: UTF-8

require 'json'
require 'net/http'
require 'set'

def get_language_ingredient(repo)
  url = ""https://api.github.com/repos/#{repo}/languages""
  # 请改成你自己的 client_id 和 client_secret
  client_id = '05500dd030f3a5690d8e'
  client_secret = 'b8ba63550e07dd3bf7b5b467824ee9ced1c61192'
  url += ""?client_id=#{client_id}&amp;client_secret=#{client_secret}""
  res = Net::HTTP.get_response(URI(url))
  if res.code == '200'
    JSON.parse(res.body)
  else
    puts res.msg
    {}
  end
end

def sum_star_number_per_language(result, repo, star)
  ingredient = get_language_ingredient(repo)
  puts ""The language ingredient of #{repo}: #{ingredient}""
  return if ingredient.length == 0
  sum = ingredient.reduce(0){|total, pair| total += pair[1]}
  # 去掉占比不到1%的语言
  ingredient.reject!{|_, bytes| bytes &lt; sum * 0.01}
  # 如果剩下的语言正好是 JavaScript/CSS/HTML，
  # 则表示它很可能是代码无关的项目，直接忽略掉
  if Set.new(ingredient.keys) == Set.new(['JavaScript', 'CSS', 'HTML'])
    # CSS框架除外。考虑到有些静态网站也是CSS比JS多，这里要求CSS比JS和HTML多得多。
    # 下面的公式随手写的，没有什么特殊意义，只是强调CSS一定要占大多数。
    unless ingredient['CSS'] &gt; 2 * ingredient['JavaScript'] + ingredient['HTML']
      return
    end
  end
  # 剩下的按比例分了star数
  sum = ingredient.reduce(0){|total, pair| total += pair[1]}
  ingredient.each_pair do |language, bytes|
    result[language] = result.fetch(language, 0) + (bytes.fdiv(sum) * star).round
  end
end

def output_star_number_per_language(result)
  sum = result.reduce(0){|total, pair| total += pair[1]}
  output = ''
  result.sort {|a, b| b[1] &lt;=&gt; a[1]}.each_with_index do |e, idx|
    output += format(""%-4d %-40s %.2f%\n"", idx+1, e[0], e[1].fdiv(sum).round(4) * 100)
  end
  output + ""\n""
end

result = {}
output = {}
checkpoints = [50, 100, 200, 500, 1000, 2000, 5000]
f = File.new('github-star-2015.csv').each
f.next
f.each_with_index do |line, idx|
  step = idx + 1
  star, repo = line[0...-1].split(',')
  star = star.to_i
  puts format(""%-4d %-40s %d"", step, repo, star)
  sum_star_number_per_language(result, repo, star)
  puts ""The result after #{repo}: #{result}\n\n""
  if checkpoints.include?(step)
    output[step] = output_star_number_per_language(result)
    puts ""first #{step}""
    puts output[step]
  end
end
puts ''

output.each_pair do |step, rank|
    puts ""first #{step}""
    puts rank
end</code></pre>
<p>注意两点：</p>
<ol>
<li><p>获取了每个项目的语言成分后，去掉占比不到1%的语言，剩下的语言按比例分掉star数。之所以不直接把star分到占比最大的语言，是因为有些项目用到多种语言且比例相当，如facebook/react-native.</p></li>
<li><p>去掉1%之后，如果剩下的语言正好是JavaScript，CSS和HTML，那么该项目很可能是代码无关的（比如一个收集各类资料的静态网站）。显然大家关注它的缘故跟任何一门编程语言无关，所以不列入统计之中。但是考虑到CSS框架也正好会有这三门语言，所以当CSS占比较高时可以豁免。</p></li>
</ol>
<p>下面是最终的结果：</p>
<pre><code>...
first 5000
1    JavaScript                               26.38%
2    Java                                     13.33%
3    Objective-C                              8.21%
4    Python                                   8.09%
5    Go                                       5.44%
6    Swift                                    4.63%
7    C                                        3.88%
8    HTML                                     3.84%
9    C++                                      3.82%
10   Ruby                                     3.60%
11   CSS                                      3.28%
12   PHP                                      2.99%
13   Shell                                    2.67%
14   CoffeeScript                             1.51%
15   C#                                       1.19%
16   VimL                                     0.90%
17   TypeScript                               0.63%
18   Scala                                    0.59%
19   Lua                                      0.46%
20   Clojure                                  0.44%
21   Rust                                     0.39%
22   Haskell                                  0.28%
23   Makefile                                 0.22%
24   Objective-C++                            0.21%
25   Emacs Lisp                               0.21%
26   Jupyter Notebook                         0.21%
27   Perl                                     0.20%
28   TeX                                      0.17%
29   Elixir                                   0.16%
30   Groff                                    0.16%
31   Groovy                                   0.14%
32   R                                        0.12%
33   OCaml                                    0.11%
34   PowerShell                               0.10%
35   Batchfile                                0.10%
36   ApacheConf                               0.08%
37   Erlang                                   0.08%
38   Cucumber                                 0.08%
39   Assembly                                 0.07%
40   Crystal                                  0.06%
41   PureBasic                                0.05%
42   QML                                      0.05%
43   Visual Basic                             0.04%
44   PLpgSQL                                  0.04%
45   Tcl                                      0.04%
46   Dart                                     0.04%
47   Vue                                      0.04%
48   CMake                                    0.03%
49   PLSQL                                    0.03%
50   XSLT                                     0.03%
...</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVsDbX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github-star-cake"" title=""github-star-cake""></span></p>
<p>一个显而易见的结论：GitHub上不小一部分的热门项目，是由JavaScript写的。JavaScript一门语言的占比，比第二名和第三名加起来还多出个第六名。这还不包括第十四名的CoffeeScript和第十七名的TypeScript（它们可以编译成JavaScript，严格来说也是JavaScript大家族的一员）。<br>另外从每个checkpoint时输出的数据可见，排名靠前的项目中，JavaScript占的比例要比全部项目中的高。如果我们选择的样本变小，JavaScript的占比还会升高（都稳拿第一名，排名就不可能升高了）。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsDbY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github-star-js-trending"" title=""github-star-js-trending""></span></p>
<p>另一个结论是，Go（第五名）和Swift（第六名）这两门语言正处于快速发展的时期。虽然实际应用的情况不如前十名中其它语言广泛，但是从star数中可见，开发者们非常看好这两门语言，关注了许多这方面的项目，同时用这两门语言编写的高质量项目也越来越多。</p>
<p>前十名中其它语言的排名倒是一点也不出乎意料。Java和Objective-C分居榜眼和探花。剩下几位自然包括了C/C++/Python等等。令人意外的是，C#（第十五名）居然没能排进前十名。按理说，C#的使用量肯定能排在前十。也许C#生态圈里面主要使用的都是微软的商业产品？</p>
<p>最后，我想感谢<a href=""https://www.githubarchive.org"" rel=""nofollow noreferrer"">GitHub Archieve</a>提供的数据归档，没有这些数据就没有本篇分析。</p>

                ", GitHub Archive分析 - 2015最受瞩目的项目们,1531978001,454,1,791,1,1,https://segmentfault.com/a/1190000004401498
232,1,0,7,"
                    
<p>最近在给同学看我的github时，突然发现我的Contributions Graph上一篇空白居然只有两三个小绿块，因为自己平时在公司工作的记录会显示在自己的Contribution Graph上，所以一直没发现个人repo的commit记录都没有被记录，于是外事不决问Google，发现原来是因为git初始化设定时没有设定正确的用户名和邮箱（主要是邮箱），具体可以参考Github官方写的help文档</p>
<h2>为什么你的 Contributions 没有在你的 Profile 里显示？</h2>
<p>那么问题来了，什么是Contributions呢，Github官网上有这么一句话：</p>
<blockquote>
<p>Your profile contributions graph is a record of contributions you've made to GitHub repositories. Contributions are only counted if they meet certain criteria. In some cases, we may need to rebuild your graph in order for contributions to appear.</p>
<p>你的个人简介中的贡献图记录的是你给Github上的仓库的贡献。它仅仅只记录某些符合标准的commits。在某些情况下，我们需要重新建立你的贡献图以便让所有的贡献都显示出来。</p>
</blockquote>
<h2>什么样的贡献才会被Github统计?</h2>
<p>英语好的同学请移步 <a href=""https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/"" rel=""nofollow noreferrer"">Why are my contributions not showing up on my profile?</a></p>
<h3>Issues 和 pull requests</h3>
<ul>
<li><p>这个操作是在一年之内</p></li>
<li><p>这个操作是针对一个独立的仓库，不能是fork</p></li>
</ul>
<h3>Commits</h3>
<p>当你的commits满足以下条件时，它才会被展示出来：</p>
<ul>
<li><p>一年之内提交的commits</p></li>
<li><p>commits使用的email地址是与你的Github账号相关联的</p></li>
<li><p>这些commits是在一个独立的仓库而不是fork仓库</p></li>
<li>
<p>这些commits是在：</p>
<ul>
<li><p>在默认分支上（通常是<code>master</code>）</p></li>
<li><p>在<code>gh-pages</code>分支(包含 <a href=""https://help.github.com/articles/user-organization-and-project-pages/#project-pages"" rel=""nofollow noreferrer"">Project Pages sites</a> 的仓库)</p></li>
</ul>
</li>
</ul>
<p>此外，至少满足下面条件中的一个（主要针对你Commit的仓库不是你创建的）：</p>
<ul>
<li><p>你是这个仓库的协作者，或者是这个版本库的拥有组织中的一员</p></li>
<li><p>你fork过这个仓库</p></li>
<li><p>你对这个仓库发起过pull request或者issue</p></li>
<li><p>你对这个仓库标记了Star</p></li>
</ul>
<blockquote><p><strong>注意：</strong>私有库的贡献仅仅对私有库成员显示</p></blockquote>
<h3>Contributions未被Github计入的几个常见原因</h3>
<ul>
<li><p>进行Commits的用户没有被关联到你的Github帐号中。</p></li>
<li><p>不是在这个版本库的默认分支进行的Commit。</p></li>
<li><p>这个仓库是一个Fork仓库，而不是独立仓库。</p></li>
</ul>
<h2>如何排查</h2>
<p>你可以在你的本地repo里用<code>git log</code>命令查看commit记录上的个人邮箱是否正确，像我就是因为之前切换到Mac平台开发之后用户名没有配置，所以我之后的commit记录上的邮箱一直是<code>Leo@Leo-MacBook-Pro.local</code>，所以Github就会认为这些commits都不是你提交的！</p>
<h2>补救措施</h2>
<p>然而这也并不是没有补救办法的，Github官网上就有给出详细的补救过程，英语好的同学请自行移步 <a href=""https://help.github.com/articles/changing-author-info/"" rel=""nofollow noreferrer"">Changing author info</a>，下面是我翻译自Github Help的简要步骤：</p>
<h3>变更作者信息</h3>
<p>为改变已经存在的 commits 的用户名和/或邮箱地址，你必须重写你 Git repo 的整个历史。</p>
<blockquote><p><strong>警告：</strong> 这种行为对你的 repo 的历史具有破坏性。如果你的 repo 是与他人协同工作的，重写已发布的历史是一种不好的习惯。仅限紧急情况执行该操作。</p></blockquote>
<p>使用脚本改变你 repo 的 Git 历史<br>我们写了一段能把 commit 作者旧的邮箱地址修改为正确用户名和邮箱的脚本。</p>
<h4>使用脚本来改变某个repo的Git历史</h4>
<p>我们已经创建了一个脚本，使用正确的姓名和电子邮件地址提交后，你以前提交的所有的commits中的作者信息及提交者字段中的旧的用户名和邮箱地址都将被更正</p>
<blockquote><p><strong>注意：</strong> 执行这段脚本会重写 repo 所有协作者的历史。完成以下操作后，任何 fork 或 clone 的人必须获取重写后的历史并把所有本地修改 rebase 入重写后的历史中。</p></blockquote>
<p>在执行这段脚本前，你需要准备的信息：</p>
<ol>
<li><p>Mac、Linux下打开Terminal，Windows下打开命令提示符（command prompt）</p></li>
<li><p>给你的repo创建一个全新的clone<br>git clone --bare <a href=""https://github.com/user/repo.git"" rel=""nofollow noreferrer"">https://github.com/user/repo.git</a><br>cd repo.git</p></li>
<li>
<p>复制粘贴脚本，并根据你的信息修改以下变量：<code>旧的Email地址</code>，<code>正确的用户名</code>，<code>正确的邮件地址</code></p>
<pre><code>#!/bin/sh
git filter-branch --env-filter '
OLD_EMAIL=""旧的Email地址""
CORRECT_NAME=""正确的用户名""
CORRECT_EMAIL=""正确的邮件地址""
if [ ""$GIT_COMMITTER_EMAIL"" = ""$OLD_EMAIL"" ]
then
    export GIT_COMMITTER_NAME=""$CORRECT_NAME""
    export GIT_COMMITTER_EMAIL=""$CORRECT_EMAIL""
fi
if [ ""$GIT_AUTHOR_EMAIL"" = ""$OLD_EMAIL"" ]
then
    export GIT_AUTHOR_NAME=""$CORRECT_NAME""
    export GIT_AUTHOR_EMAIL=""$CORRECT_EMAIL""
fi
' --tag-name-filter cat -- --branches --tags</code></pre>
</li>
<li><p>按 <code>Enter键</code> 执行脚本。</p></li>
<li><p>用<code>git log</code>命令看看新 Git 历史有没有错误</p></li>
<li>
<p>把正确历史 push 到 Github</p>
<pre><code class=""shell"">git push --force --tags origin 'refs/heads/*'</code></pre>
</li>
<li>
<p>删掉刚刚临时创建的 clone</p>
<pre><code class=""shell"">cd ..
rm -rf repo.git</code></pre>
</li>
</ol>
<h2>如何正确设置你的 git 个人信息</h2>
<p>接下来全局设置好你的正确信息，以后就放心的用Github进行版本管理吧 <code>^_^</code></p>
<pre><code class=""shell"">git config --global user.email ""你的邮件地址""
git config --global user.name ""你的Github用户名""</code></pre>
<p>更多配置可以参考<a href=""https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git"" rel=""nofollow noreferrer"">Pro Git 8.1自定义 Git - 配置 Git</a></p>
<p>转载请注明原文链接：<a href=""http://xunli.xyz/2016/01/09/github-not-count/"" rel=""nofollow noreferrer"">http://xunli.xyz/2016/01/09/g...</a></p>

                ", 为什么Github没有记录你的Contributions,1531978002,535,1,331,1,1,https://segmentfault.com/a/1190000004318632
233,1,0,7,"
                    
<p>GitHub提供的Gist服务简直是<strong>保存代码段的神器</strong>！可以把gist当做一个小型仓库，具有版本控制，markdown。从网上的搜索的结果来看，好像在10年就推出了这项服务，真是知道的太晚了！请允许我大呼<strong>『工具改变生活！』『工具改变程序员的生活！』</strong></p>
<p>项目中会有很多情况下可以直接复用以前写好的代码，之前是怎么保存并查找这些代码片段呢？我基本上是凭着记忆翻之前的工程然后拷贝，或者保存代码文件到云笔记中。<strong>效率肥肠低</strong>。</p>
<p>目前Gist提供搜索服务，但使用仍然不便，比如没有标签，也就没法子便捷地管理。但是存在一款 web app，名叫 GistBox（英雄并不总是孤独的）。在了解gistbox以下几个特性之后，你肯定会爱上它（分分钟上手，肥肠懂你）！</p>
<ul>
<li><p>web app 跨平台，只要有浏览器就可以；</p></li>
<li><p>它提供<strong>标签管理</strong>功能；</p></li>
<li><p>点击一下『copy』就可以拷走代码段；</p></li>
<li>
<p>它的chrome浏览器插件（GistBox Clipper）提供了<strong>3种便捷方式</strong>，可以在当前的网页上弹出『新建一条gist』的编辑对话框，使你免于登陆web app：</p>
<ul>
<li><p><strong>自动识别网页中的代码段</strong>，会在代码段右上角显示gistbox logo，点击它；</p></li>
<li><p>选中网页中的文本，右键弹出的菜单中，点击“save as gist”；</p></li>
<li><p>直接点击位于chrome导航栏上的 gistbox 按钮；</p></li>
</ul>
</li>
</ul>
<p>下面的截图来自官网。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsdtl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>gistbox使管理、添加、使用gist（代码段）变得肥肠容易（前提是利用好搜索、定义好标签），长时间积累必定受益匪浅。<br>当然除了保存代码段之外，可以在gist保存你想保存的任何东西，比如技术总结、填过的坑。但是感觉保存代码段才能体现它的优势。</p>
<hr>
<ul><li><p>官方说明：<a>GitHub - About gists</a></p></li></ul>
<blockquote><p>Gists are a great way to share your work. You can share single files, parts of files, or full applications. You can access gists at <a href=""https://gist.github.com."" rel=""nofollow noreferrer"">https://gist.github.com.</a><br>Every gist is a Git repository, which means that it can be forked, cloned, and manipulated in every way.</p></blockquote>
<ul>
<li><p><a>GixBox 官网</a></p></li>
<li><p><a>Here's a quick tutorial on how to save code snippets with the extension</a></p></li>
</ul>
<hr>
<p>版权声明：《保存代码段的利器 Gist &amp; GistBox》由 <a>WeiYi.Li</a> 在 2016年01月13日写作。著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 <br>文章链接：<a href=""http://li2.me/2016/01/the-beautiful-way-to-organize-code-snippets.html"" rel=""nofollow noreferrer"">http://li2.me/2016/01/the-beautiful-way-...</a></p>

                ", 保存代码段的利器Gist &amp; GistBox,1531978004,129,1,829,1,1,https://segmentfault.com/a/1190000004302628
234,1,0,7,"
                    
<p>尽管之前已经有一篇非常不错的关于《<a href=""https://www.phodal.com/blog/how-to-improve-impact/"" rel=""nofollow noreferrer"">如何提高影响力</a>》的文章，但是那篇文章缺少一些理论的支持。</p>
<p>不知道你发现了没有你在Github上的代码并不比别人差，但是无论你怎么努力你都换取不了同样的关注。当别人开始使用微信公众号的时候，你也开始使用，但是你怎么努力也不及别人的百分之一的阅读量。</p>
<p>然而尽管你觉得非常不爽，但是你并不知道为什么！我记得mruby刚刚只写了一个README.md的时候，就获得了上千个star。</p>
<p>因为松本行弘很有影响力，也因为它也很有影响力。</p>
<p>这也算得上是<strong>粉丝经济</strong>，在这方面做得最好的有:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004836565"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""smartisan"" title=""smartisan""></span></p>
<p>而作为一个程序员，可以有怎样的『粉丝经济』呢？</p>
<p>阮一峰与《ECMAScript 6入门》就是一个很好的例子，尽管我见过的阮一峰的技术博客都写得很浅、不够深入。我也见过很多写得比他好的，但是阅读量却远远不及。</p>
<p><strong>THE WORLD IS CHANGED</strong></p>
<p>所以，有时候并不是你实力够了就行了。现在已经比过去好了许多，但是还是不够。</p>
<blockquote><p>影响力方程式： IMPACT = C  x ( R + E + A + T + E)</p></blockquote>
<p>尽管这是一本书的名字，但是我们还是稍微展开一下：</p>
<ul>
<li><p>C: 对比度</p></li>
<li><p>R: 触及率</p></li>
<li><p>E:曝光度</p></li>
<li><p>A:表达方式</p></li>
<li><p>T:信任度</p></li>
<li><p>E:共鸣水平</p></li>
</ul>
<h3>对比度——证明你写的代码比别人好！</h3>
<p>什么算得上是对比度？</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004836567"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Python框架对比"" title=""Python框架对比""></span></p>
<p>如上图所示的Python框架中的性能对比算是一个很不错的对比。尽管我是一个重度Django爱好者，和一个轻度Flask爱好者。但是他们的目的是不一样，在后来我需要一个RESTful API的时候，我选择了Falcon，因为上图表明了Flacon的性能更好！</p>
<p>如果你正在写一个框架，而且你发现这个时候已经有别的轮子存在了，而且用户很多。那么你有多大的把握把用户拉过来？</p>
<p>jQuery框架就是一个很受欢迎的前端框架。那么谁做到了可以替换jQuery？</p>
<ul>
<li><p>Zepto：更小的jQuery</p></li>
<li><p>React：更快的DOM操作</p></li>
</ul>
<p>又比如，已经有人写了一系列的ES6教程，那么你怎么超越他？连Google在显示搜索结果的时候，也会删除内容重复。机器是如此，更何况是人呢。试试不同的角度，不再是只写ES6的语法，而是实战之类的。</p>
<p>这就是为什么在上述的表达式中，如果对比度为零，那么整个结果就是零。如果你不能证明你和别人有差异，那么你就很难有明显的影响力。</p>
<p>如果你在一个领域没有啥想法，而另外一个领域是空白的，不凡去试试这个领域。</p>
<h3>表达方式——简单即是好</h3>
<p>与代码相比，这点更适合在写博客上。通常来说，受欢迎的博客都是那些能轻轻松松地帮助别人解决问题的博客。</p>
<p>工作的时候，我们并不没有那些时间去看别人的长篇大论，我们要做的是：</p>
<ul>
<li><p>搜索某个关键词</p></li>
<li><p>点击相应的结果</p></li>
<li><p>然后离开</p></li>
</ul>
<p>如下图所示，打开第一个结果，然后离开。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004836581"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Search Result"" title=""Search Result""></span></p>
<p>因为这存在一个能力的金字塔模型，处于底层的人往往更多，如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004836583"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""70"" title=""70""></span></p>
<p>而那对于大部分的初学者来说，一篇简单易懂的博客、一行简单易读的代码就可以帮他们的代码。甚至是我在平时的时候，也会直接Copy/Paste，尽管会对长的代码做一些Review，但是短的瞬间就能理解了。</p>
<p>并且对于程序员来说，表达的问题足以让多数人不愿意写博客。而写简单的博客往往更易受欢迎，因为可以帮人解决问题。</p>
<h3>触及率——你的发声平台</h3>
<p>在开始尝试这一点之间，你需要有一个Unique ID。它用来说明我是谁，你在xx网站上看到的那个xx就是我。所以我在后来的经验中学会了这一点，不管在哪里，我都用phodal这个ID。</p>
<ul>
<li><p><a href=""http://www.phodal.com/"" rel=""nofollow noreferrer""></a><a href=""http://www.phodal.com/"" rel=""nofollow noreferrer"">http://www.phodal.com/</a></p></li>
<li><p><a href=""http://weibo.com/phodal"" rel=""nofollow noreferrer""></a><a href=""http://weibo.com/phodal"" rel=""nofollow noreferrer"">http://weibo.com/phodal</a></p></li>
<li><p><a href=""http://www.zhihu.com/people/phodal"" rel=""nofollow noreferrer""></a><a href=""http://www.zhihu.com/people/phodal"" rel=""nofollow noreferrer"">http://www.zhihu.com/people/phodal</a></p></li>
<li><p><a href=""http://github.com/phodal"" rel=""nofollow noreferrer""></a><a href=""http://github.com/phodal"" rel=""nofollow noreferrer"">http://github.com/phodal</a></p></li>
<li><p><a href=""http://segmentfault.com/u/phodal"" rel=""nofollow noreferrer""></a><a href=""http://segmentfault.com/u/phodal"" rel=""nofollow noreferrer"">http://segmentfault.com/u/phodal</a></p></li>
<li><p><a href=""http://www.douban.com/people/phodal/"" rel=""nofollow noreferrer""></a><a href=""http://www.douban.com/people/phodal/"" rel=""nofollow noreferrer"">http://www.douban.com/people/phodal/</a></p></li>
<li><p>...</p></li>
</ul>
<p>我就是Phodal，你在哪看到的Phodal都是我。</p>
<p>而这是一个很漫长的过程，开发人员通常喜欢在不同的社区聚集。这就意味着，当我们完成某个软件、文章的时候，我们需要去让不同的人看到。</p>
<p>我们先在我们的公众平台、博客上发，然后是知乎、CSDN、图灵等等专栏，最后推荐到如掘金、开发者头条、极客头条这样的聚合网站上。</p>
<p>我们就可以慢慢地积累人气。</p>
<h3>曝光度——让自己无处不在</h3>
<p>这是一个非常有意思的话题。如果我们每天都可以上头条，那么我们的粉丝肯定会一直往上走。而如果我们很久一句话也不说，那么会掉很多关注。</p>
<p>而对于程度员来说，这点还算很难。如果你一直在加班，那么你会有时间去发这些么？对于这一点来说，还是有几个不错的东西可以做的~~</p>
<ol>
<li><p>针对不同的平台有不同的内容。如我喜欢在我的微博发一些Github上有意思的项目，在我的博客上发一些解决问题的博客。</p></li>
<li><p>整理一些电子书。如果你也写了很多文章，那么要整理出一本电子书一定是一件很容易的事——我整理了《一步步搭建物联网》、《GitHub漫游指南》</p></li>
<li><p>避免内容多平台同步。当你来到一个新的平台的时候， 这个策略是相当有效的。但是到了后期就不是了，用户在不同的地方都看到了相同的内容。</p></li>
</ol>
<p>接着就是不断地坚持下去，去年我写了127篇博客。然后已经在GitHub上刷了461天，你呢?</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006912788?w=600&amp;h=238"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Github 461"" title=""Github 461""></span></p>
<p>坚持比完美更重要哦！</p>
<h3>信任度——跟着你就是对的！</h3>
<p>人们为什么就相信罗永浩能做出好的手机？因为人们相信他。</p>
<p>人们为什么跟随你？因为相信你能写一些有意思的玩意儿、能帮助他们成长、能看到更广阔的世界。</p>
<p>而人们由粉转黑的原因往往是因为你错了：</p>
<ul>
<li><p>Angular 2.0的升级把很多人坑了，所以多了很多黑粉。</p></li>
<li><p>Ruby on Rails的后期维护把很多人坑了，所以多了很多黑粉。</p></li>
<li><p>Node.js把TJ坑了，所以他转向了GO。</p></li>
</ul>
<p>让人们相信你 ，就是最好的事，而这一点则是另外一个持久的过长。而影响力都是持久的过程，不是么？？</p>
<h3>共鸣水平——你说得对！</h3>
<p>我希望我码了这么多次，你可以回一个你说得对！这就说明了我们是有共鸣的。而引起共鸣的很多原因，则是因为我们分享了我们的真实体验、感受。</p>
<ul>
<li><p>使用Python来玩大数据和机器学习就是那么爽。</p></li>
<li><p>使用JavaScript来开发Web、移动应用就是那么快。</p></li>
</ul>
<p>而如果你不是出自于提高影响力的目的来看此文，那么只会是这是一篇瞎扯的文章——因为从一开始我们就没有共同话题。</p>
<p>我想说Node.js的回调是一个大坑，但是你却觉得Node.js的回调让人爽爆了。那我怎么指望你能和我同一路。</p>
<p>当我们试图去分享一个内容的时候，我们也希望别人能引起共鸣。当我写一篇说Java在架构模式中的应用时，我就指望读者说：你说得对！</p>
<p>React.js引起了大家巨大的共鸣，所以它也就有了更大的影响力。</p>
<h2>TODO</h2>
<p>那么，我应该怎么做？</p>
<ul>
<li><p>创建自己的博客分享自己的心得</p></li>
<li><p>回答别人的问题</p></li>
<li><p>。。。</p></li>
</ul>
<p>帮助别人才是提高影响力的基础。</p>

                ", 程序员如何提高影响力2.0 ,1531978006,350,1,716,1,1,https://segmentfault.com/a/1190000004291196
235,1,0,7,"
                    
<p>前几天在 SF 问答上回答了这个问题：<a href=""http://sfau.lt/bNrXjL"" rel=""nofollow noreferrer"">正确使用Github 的方法是什么？</a></p>
<h2>原回答</h2>
<blockquote>
<ul><li><p>Explore GitHub：看看最近在流行什么<br><a href=""https://github.com/explore"" rel=""nofollow noreferrer"">https://github.com/explore</a></p></li></ul>
<ul><li>
<p>Awesome 系列</p>
<ul>
<li><p><a href=""https://github.com/geekan/awesome-awesome-awesome"" rel=""nofollow noreferrer"">https://github.com/geekan/awesome-awesome-awesome</a></p></li>
<li><p><a href=""https://github.com/sindresorhus/awesome"" rel=""nofollow noreferrer"">https://github.com/sindresorhus/awesome</a></p></li>
<li><p><a href=""http://git.io/vu3Qq"" rel=""nofollow noreferrer"">http://git.io/vu3Qq</a></p></li>
</ul>
</li></ul>
<ul><li><p>使用 GitHub Pages 搭建静态网站、博客（自动分配 username.github.io 的域名，也可绑自己的域名（CNAME））<br><a href=""https://pages.github.com/"" rel=""nofollow noreferrer"">https://pages.github.com/</a></p></li></ul>
<ul><li>
<p>impress.js/reveal.js + GitHub Pages = 在线 PPT</p>
<ul>
<li><p><a href=""https://github.com/impress/impress.js"" rel=""nofollow noreferrer"">https://github.com/impress/impress.js</a></p></li>
<li><p><a href=""https://github.com/hakimel/reveal.js"" rel=""nofollow noreferrer"">https://github.com/hakimel/reveal.js</a></p></li>
</ul>
</li></ul>
<ul><li><p>GitHub 功能集成工具（包括 Travis CI、Code Climate、Gitter 等）<br><a href=""https://github.com/integrations"" rel=""nofollow noreferrer"">https://github.com/integrations</a></p></li></ul>
<ul><li>
<p>为第三方包管理平台提供代码托管</p>
<ul>
<li><p>NPM: <a href=""https://www.npmjs.com/"" rel=""nofollow noreferrer"">https://www.npmjs.com/</a></p></li>
<li><p>Gems: <a href=""https://rubygems.org/"" rel=""nofollow noreferrer"">https://rubygems.org/</a></p></li>
<li><p>Docker Hub: <a href=""https://github.com/docker-library"" rel=""nofollow noreferrer"">https://github.com/docker-library</a></p></li>
<li><p>Homebrew: <a href=""https://github.com/Homebrew/homebrew"" rel=""nofollow noreferrer"">https://github.com/Homebrew/homebrew</a></p></li>
<li><p>Atom: <a href=""https://atom.io/packages"" rel=""nofollow noreferrer"">https://atom.io/packages</a></p></li>
<li><p>SublimeText: <a href=""https://packagecontrol.io/"" rel=""nofollow noreferrer"">https://packagecontrol.io/</a></p></li>
</ul>
</li></ul>
<ul><li><p>GitHub OAuth 做第三方登录<br><a href=""https://developer.github.com/v3/oauth/"" rel=""nofollow noreferrer"">https://developer.github.com/v3/oauth/</a></p></li></ul>
<ul><li><p>GitHub URL 短网址<br><a href=""http://git.io/"" rel=""nofollow noreferrer"">http://git.io/</a></p></li></ul>
<ul><li><p>GitHub Webhooks 自动部署<br><a href=""https://developer.github.com/webhooks/"" rel=""nofollow noreferrer"">https://developer.github.com/webhooks/</a></p></li></ul>
<ul><li><p>GitHub 简历<br><a href=""http://resume.github.io/"" rel=""nofollow noreferrer"">http://resume.github.io/</a></p></li></ul>
<ul><li><p>GitHub 学生大礼包（包含 GitHub 私有仓库、DO $50 券等）<br><a href=""https://education.github.com/pack"" rel=""nofollow noreferrer"">https://education.github.com/pack</a></p></li></ul>
<ul><li><p>将停止维护的 Google Code 代码导到 GitHub<br><a href=""https://code.google.com/export-to-github/"" rel=""nofollow noreferrer"">https://code.google.com/export-to-github/</a></p></li></ul>
<blockquote><p>附上本人 GitHub 账号，求 follow：<a href=""https://github.com/mdluo"" rel=""nofollow noreferrer"">https://github.com/mdluo</a></p></blockquote>
</blockquote>
<p>同时针对这个问题写一些关于 Git 和 GitHub 的教程、手册和技巧等资源链接。</p>
<p>建议学习路线：先参考 GitHub 教程通过在 GitHub 上发布代码实际操作，使用 <a href=""https://windows.github.com/"" rel=""nofollow noreferrer"">Github for Windows</a> 或者 <a href=""https://mac.github.com/"" rel=""nofollow noreferrer"">Github for Mac</a> 来管理代码。熟悉 GitHub 使用后学习 Git ，主要使用命令行来进行操作，可以做很多 GitHub 客户端或者网站不能完成的操作。</p>
<h2>扩展阅读</h2>
<h4>Git</h4>
<ul>
<li><p><a href=""http://git-scm.com/book/zh/v1"" rel=""nofollow noreferrer"">Git-Book</a>  ( Git 官方教程中文版 )</p></li>
<li><p><a href=""http://gitbook.liuhui998.com/index.html"" rel=""nofollow noreferrer"">Git Community Book 中文版</a></p></li>
<li><p><a href=""https://git-reference.readthedocs.org/en/latest/"" rel=""nofollow noreferrer"">Pro Git book — git-reference 0.1 文档</a></p></li>
<li><p><a href=""http://rogerdudler.github.io/git-guide/"" rel=""nofollow noreferrer"">git - the simple guide - no deep shit!</a>  ( 最简单的 Git 教程 )</p></li>
<li><p><a href=""http://www-cs-students.stanford.edu/~blynn//gitmagic/"" rel=""nofollow noreferrer"">Git Magic</a>  ( Stanford 出品 )</p></li>
<li><p><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">Git 教程</a>  ( 廖雪峰出品 )</p></li>
<li><p><a href=""http://pcottle.github.io/learnGitBranching/"" rel=""nofollow noreferrer"">learnGitBranching</a>  ( 互动游戏学 Git 分支 )</p></li>
</ul>
<h4>GitHub</h4>
<ul>
<li><p><a href=""https://help.github.com/"" rel=""nofollow noreferrer"">GitHub Help</a>  ( GitHub 官方帮助文档 )</p></li>
<li><p><a href=""http://www.worldhello.net/gotgithub/"" rel=""nofollow noreferrer"">GotGitHub</a>  ( 非常全面的 GitHub 中文教程 )</p></li>
<li><p><a href=""http://www.yanyulin.info/pages/2013/11/github.html"" rel=""nofollow noreferrer"">Github 简明教程</a></p></li>
<li><p><a href=""http://www.yanyulin.info/pages/2013/11/githubM.html"" rel=""nofollow noreferrer"">Github上如何给别人贡献代码</a></p></li>
<li><p><a href=""http://www.yangzhiping.com/tech/github.html"" rel=""nofollow noreferrer"">如何高效利用 GitHub</a></p></li>
<li><p><a href=""https://github.com/tiimgreen/github-cheat-sheet"" rel=""nofollow noreferrer"">GitHub Cheat Sheet</a>  ( GitHub 技巧大全 )</p></li>
</ul>

                ", 正确使用Github 的方法 + Git 和 GitHub 教程和技巧,1531978007,523,1,618,1,1,https://segmentfault.com/a/1190000004260265
236,1,0,7,"
                    
<h2>译者说</h2>
<p><code>Tornado 4.3</code>于2015年11月6日发布，该版本正式支持<code>Python3.5</code>的<code>async</code>/<code>await</code>关键字，并且用旧版本CPython编译Tornado同样可以使用这两个关键字，这无疑是一种进步。其次，这是最后一个支持<code>Python2.6</code>和<code>Python3.2</code>的版本了，在后续的版本了会移除对它们的兼容。现在网络上还没有<code>Tornado4.3</code>的中文文档，所以为了让更多的朋友能接触并学习到它，我开始了这个翻译项目，希望感兴趣的小伙伴可以一起参与翻译，项目地址是<a href=""https://github.com/tao12345666333/tornado-zh"" rel=""nofollow noreferrer"">tornado-zh on Github</a>，翻译好的文档在<a href=""https://tornado-zh.readthedocs.org/"" rel=""nofollow noreferrer"">Read the Docs上</a>直接可以看到。欢迎Issues or PR。</p>
<h1>协程</h1>
<p>Tornado中推荐使用<strong>协程</strong>写异步代码. 协程使用了Python的<code>yield</code>关键字代替链式回调来将程序挂起和恢复执行(像在 <a href=""http://www.gevent.org"" rel=""nofollow noreferrer"">gevent</a>中出现的轻量级线程合作方式有时也被称为协程,但是在Tornado中所有的协程使用明确的上下文切换,并被称为异步函数).</p>
<p>使用协程几乎像写同步代码一样简单, 并且不需要浪费额外的线程. 它们还通过减少上下文切换来 <a href=""https://glyph.twistedmatrix.com/2014/02/unyielding.html"" rel=""nofollow noreferrer"">使并发编程更简单</a>.</p>
<p>例子:</p>
<pre><code class=""python"">    from tornado import gen

    @gen.coroutine
    def fetch_coroutine(url):
        http_client = AsyncHTTPClient()
        response = yield http_client.fetch(url)
        # 在Python 3.3之前, 在generator中是不允许有返回值的
        # 必须通过抛出异常来代替.
        # 就像 raise gen.Return(response.body).
        return response.body</code></pre>
<h1>Python 3.5:<code>async</code>和<code>await</code>
</h1>
<p>Python 3.5引入了<code>async</code>和<code>await</code>关键字(使用这些关键字的函数也被称为""原生协程"").从Tornado 4.3,你可以用它们代替<code>yield</code>为基础的协程.只需要简单的使用<code>async def foo()</code>在函数定义的时候代替<code>@gen.coroutine</code>装饰器,用<code>await</code>代替yield. 本文档的其他部分会继续使用<code>yield</code>的风格来和旧版本的Python兼容, 但是如果<code>async</code>和<code>await</code>可用的话，它们运行起来会更快:</p>
<pre><code class=""python"">
    async def fetch_coroutine(url):
        http_client = AsyncHTTPClient()
        response = await http_client.fetch(url)
        return response.body</code></pre>
<p><code>await</code>关键字比<code>yield</code> 关键字功能要少一些.例如,在一个使用 <code>yield</code> 的协程中，你可以得到<code>Futures</code> 列表, 但是在原生协程中,你必须把列表用 <code>tornado.gen.multi</code> 包起来. 你也可以使用 <code>tornado.gen.convert_yielded</code>来把任何使用<code>yield</code>工作的代码转换成使用<code>await</code>的形式.</p>
<p>虽然原生协程没有明显依赖于特定框架(例如它们没有使用装饰器,例如<code>tornado.gen.coroutine</code>或<code>asyncio.coroutine</code>), 不是所有的协程都和其他的兼容. 有一个<em>coroutine runner</em>在第一个协程被调用的时候进行选择, 然后被所有用<code>await</code>直接调用的协程共享. Tornado的协程执行者(coroutine runner)在设计上是多用途的,可以接受任何来自其他框架的awaitable对象;其他的协程运行时可能有很多限制(例如,<code>asyncio</code>协程执行者不接受来自其他框架的协程).基于这些原因,我们推荐组合了多个框架的应用都使用Tornado的协程执行者来进行协程调度.为了能使用Tornado来调度执行asyncio的协程, 可以使用<code>tornado.platform.asyncio.to_asyncio_future</code>适配器.</p>
<h1>它是如何工作的</h1>
<p>包含了<code>yield</code>关键字的函数是一个<strong>生成器(generator)</strong>.所有的生成器都是异步的;当调用它们的时候,会返回一个生成器对象,而不是一个执行完的结果.<code>@gen.coroutine</code>装饰器通过<code>yield</code>表达式和生成器进行交流, 而且通过返回一个<code>.Future</code>与协程的调用方进行交互.</p>
<p>下面是一个协程装饰器内部循环的简单版本:</p>
<pre><code class=""python"">    # tornado.gen.Runner 简化的内部循环
    def run(self):
        # send(x) makes the current yield return x.
        # It returns when the next yield is reached
        future = self.gen.send(self.next)
        def callback(f):
            self.next = f.result()
            self.run()
        future.add_done_callback(callback)</code></pre>
<p>装饰器从生成器接收一个<code>Future</code>对象, 等待(非阻塞的)这个<code>Future</code>对象执行完成, 然后""解开(unwraps)""这个<code>Future</code>对象，并把结果作为<code>yield</code> 表达式的结果传回给生成器.大多数异步代码从来不会直接接触<code>Future</code>类.除非 <code>Future</code>立即通过异步函数返回给<code>yield</code>表达式.</p>
<h1>如何调用协程</h1>
<p>协程一般不会抛出异常: 它们抛出的任何异常将被<code>.Future</code>捕获直到它被得到.这意味着用正确的方式调用协程是重要的, 否则你可能有被忽略的错误:</p>
<pre><code class=""python"">    @gen.coroutine
    def divide(x, y):
        return x / y

    def bad_call():
        # 这里应该抛出一个 ZeroDivisionError 的异常, 但事实上并没有
        # 因为协程的调用方式是错误的.
        divide(1, 0)</code></pre>
<p>几乎所有的情况下, 任何一个调用协程的函数都必须是协程它自身, 并且在调用的时候使用<code>yield</code>关键字. 当你复写超类中的方法, 请参阅文档,看看协程是否支持(文档应该会写该方法""可能是一个协程""或者""可能返回一个 <code>Future</code>类 ""):</p>
<pre><code class=""python"">    @gen.coroutine
    def good_call():
        # yield 将会解开 divide() 返回的 Future 并且抛出异常
        yield divide(1, 0)</code></pre>
<p>有时你可能想要对一个协程""一劳永逸""而且不等待它的结果. 在这种情况下,建议使用<code>.IOLoop.spawn_callback</code>, 它使得<code>.IOLoop</code> 负责调用. 如果它失败了, <code>.IOLoop</code>会在日志中把调用栈记录下来:</p>
<pre><code class=""python"">    # IOLoop 将会捕获异常,并且在日志中打印栈记录.
    # 注意这不像是一个正常的调用, 因为我们是通过
    # IOLoop 调用的这个函数.
    IOLoop.current().spawn_callback(divide, 1, 0)</code></pre>
<p>最后, 在程序顶层, <em>如果<code>.IOLoop</code>尚未运行,</em> 你可以启动<code>.IOLoop</code>,执行协程,然后使用<code>.IOLoop.run_sync</code>方法停止<code>.IOLoop</code>. 这通常被用来启动面向批处理程序的<code>main</code>函数:</p>
<pre><code class=""python"">    # run_sync() 不接收参数,所以我们必须把调用包在lambda函数中.
    IOLoop.current().run_sync(lambda: divide(1, 0))</code></pre>
<h1>协程模式</h1>
<h2>结合 callback</h2>
<p>为了使用回调代替<code>.Future</code>与异步代码进行交互, 把调用包在<code>.Task</code>类中. 这将为你添加一个回调参数并且返回一个可以yield的<code>.Future</code> :</p>
<pre><code class=""python"">    @gen.coroutine
    def call_task():
        # 注意这里没有传进来some_function.
        # 这里会被Task翻译成
        #   some_function(other_args, callback=callback)
        yield gen.Task(some_function, other_args)</code></pre>
<h2>调用阻塞函数</h2>
<p>从协程调用阻塞函数最简单的方式是使用<code>concurrent.futures.ThreadPoolExecutor</code>, 它将返回和协程兼容的<code>Futures</code>:</p>
<pre><code class=""python"">    thread_pool = ThreadPoolExecutor(4)

    @gen.coroutine
    def call_blocking():
        yield thread_pool.submit(blocking_func, args)</code></pre>
<h2>并行</h2>
<p>协程装饰器能识别列表或者字典对象中各自的 <code>Futures</code>, 并且并行的等待这些 <code>Futures</code> :</p>
<pre><code class=""python"">    @gen.coroutine
    def parallel_fetch(url1, url2):
        resp1, resp2 = yield [http_client.fetch(url1),
                              http_client.fetch(url2)]

    @gen.coroutine
    def parallel_fetch_many(urls):
        responses = yield [http_client.fetch(url) for url in urls]
        # 响应是和HTTPResponses相同顺序的列表

    @gen.coroutine
    def parallel_fetch_dict(urls):
        responses = yield {url: http_client.fetch(url)
                            for url in urls}
        # 响应是一个字典 {url: HTTPResponse}</code></pre>
<h2>交叉存取</h2>
<p>有时候保存一个 <code>.Future</code> 比立即yield它更有用, 所以你可以在等待之前<br>执行其他操作:</p>
<pre><code class=""python"">    @gen.coroutine
    def get(self):
        fetch_future = self.fetch_next_chunk()
        while True:
            chunk = yield fetch_future
            if chunk is None: break
            self.write(chunk)
            fetch_future = self.fetch_next_chunk()
            yield self.flush()</code></pre>
<h2>循环</h2>
<p>协程的循环是棘手的, 因为在Python中没有办法在<code>for</code>循环或者<code>while</code>循环<code>yield</code>迭代器,并且捕获yield的结果. 相反,你需要将循环条件从访问结果中分离出来, 下面是一个使用<a href=""http://motor.readthedocs.org/en/stable"" rel=""nofollow noreferrer"">Motor</a>的例子:</p>
<pre><code class=""python"">    import motor
    db = motor.MotorClient().test

    @gen.coroutine
    def loop_example(collection):
        cursor = db.collection.find()
        while (yield cursor.fetch_next):
            doc = cursor.next_object()</code></pre>
<h2>在后台运行</h2>
<p><code>PeriodicCallback</code>通常不使用协程. 相反,一个协程可以包含一个<code>while True:</code>循环并使用<code>tornado.gen.sleep</code>:</p>
<pre><code class=""python"">    @gen.coroutine
    def minute_loop():
        while True:
            yield do_something()
            yield gen.sleep(60)

    # Coroutines that loop forever are generally started with
    # spawn_callback().
    IOLoop.current().spawn_callback(minute_loop)</code></pre>
<p>有时可能会遇到一个更复杂的循环. 例如, 上一个循环运行每次花费<code>60+N</code>秒,其中<code>N</code>是<code>do_something()</code>花费的时间. 为了准确的每60秒运行,使用上面的交叉模式:</p>
<pre><code class=""python"">    @gen.coroutine
    def minute_loop2():
        while True:
            nxt = gen.sleep(60)   # 开始计时.
            yield do_something()  # 计时后运行.
            yield nxt             # 等待计时结束.</code></pre>

                ", Tornado 4.3文档翻译: 用户指南-协程,1531978008,571,1,158,1,1,https://segmentfault.com/a/1190000004240817
237,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/ca27c97075a1e30342a26ea914bd9aed.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>开篇</h2>
<p>如今，Git 大行其道，颇有一统天下之势。<br>如果你的技能树上 Git 和 Github 的图标还没有点亮的话，你都不好意思说你是程序员。<br>别说互联网企业，我接触到的许多传统企业都在从 SVN，Clear Case 等迁移到 Git 上，甚至大厂还会有一个团队去定制适合自己企业的 Git 服务器。</p>
<p>很多人简历上写的「精通 Git 与 Github」，但如果你问他熟悉到什么程度的话，回答通常是「就是会用常用的 <code>add</code>，<code>commit</code>，<code>push</code> 操作」。</p>
<p>但工作中我们会遇到一些更加复杂的场景：</p>
<pre><code>* 忽略某些文件
* 创建，删除分支
* 找到最后修改某行代码的人
* commit 后发现里边包含一个不应该提交的文件
* commit 后发现少提交了一些文件
* 一个文件中的多次有改动，怎么做到只提交其中的一部分？
* 怎样整理提交记录使其更加整洁？
* 快速定位是哪一次提交引入了 bug
* ...</code></pre>
<p>作为一线程序员，我们要如何快速学习 Git 以发挥其最大威力呢？</p>
<p>今天我就要向大家介绍一个工具，准确说应该是「游戏」，名字叫<a href=""https://github.com/Gazler/githug"" rel=""nofollow noreferrer"">「githug」</a>，它把平常可能遇到的一些场景都实例化，变成一个一个的关卡，一共有 55 个关卡：</p>
<pre><code>#1: init
#2: config
#3: add
#4: commit
#5: clone
#6: clone_to_folder
#7: ignore
#8: include
#9: status
#10: number_of_files_committed
#11: rm
#12: rm_cached
#13: stash
#14: rename
#15: restructure
#16: log
#17: tag
#18: push_tags
#19: commit_amend
#20: commit_in_future
#21: reset
#22: reset_soft
#23: checkout_file
#24: remote
#25: remote_url
#26: pull
#27: remote_add
#28: push
#29: diff
#30: blame
#31: branch
#32: checkout
#33: checkout_tag
#34: checkout_tag_over_branch
#35: branch_at
#36: delete_branch
#37: push_branch
#38: merge
#39: fetch
#40: rebase
#41: repack
#42: cherry-pick
#43: grep
#44: rename_commit
#45: squash
#46: merge_squash
#47: reorder
#48: bisect
#49: stage_lines
#50: find_old_branch
#51: revert
#52: restore
#53: conflict
#54: submodule
#55: contribute</code></pre>
<h2>安装</h2>
<p>首先我们需要来安装这个游戏，<code>githug</code> 是用 Ruby 编写的，可通过如下命令安装：<br><code>gem install githug</code></p>
<p>如果遇到权限问题，请加上<code>sudo</code>：<br><code>sudo gem install githug</code></p>
<p>安装成功后，在 Terminal 里进入你常用的目录，输入<code>githug</code>，会提示游戏目录不存在，是否要创建一个，输入<code>y</code>然后回车：<br><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/8382bc7aa8c54340e2af44eada2942de.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>根据提示<code>cd git_hug</code> 进入游戏目录，准备开始游戏。</p>
<h2>基本命令</h2>
<p>在开始前我们还需要了解游戏的一些基本操作：</p>
<ul>
<li><p>play - 默认命令，检查是否过关</p></li>
<li><p>hint - 显示过关提示</p></li>
<li><p>reset - 重启本关，或者重启到指定的某关</p></li>
<li><p>levels - 显示关卡列表</p></li>
</ul>
<p>来试一下，<code>githug reset</code>：<br><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/0dd2f290ffa3d9d332663652f7e2a3de.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>示例</h2>
<p>我以第一关为例子给大家演示一下玩法。</p>
<p>第一关的名称是：<code>init</code>，提示是：「一个新目录 git_hug 被创建了，请把它初始化为一个空仓库」。<br>假设现在我不知道该怎么过关，我可以查看过关提示：<br><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/d353432d63653c8f5904d6a8fbe1fcee.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>指示是：「你可以输入 <code>git</code> 命令来查看 <code>git</code> 命令列表」。<br><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/1dec22641d98b2ecd72c56703db68804.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>看最后一行，原来用 <code>git init</code> 就可以初始化一个空仓库，接着输入 <code>githug</code> 进行过关检测：<br><span class=""img-wrap""><img data-src=""http://codingstyle-cn.b0.upaiyun.com/photo/2015/94b84a9793eaf1a705bd22d3fc6b6696.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>太棒了！顺利进入第二关！</p>
<p>怎么样？明白了吗？后面的 54 关就靠你自己了哦！</p>
<h2>友情提示</h2>
<p>在闯关过程中，尽量使用 <code>githug hint</code>，<code>git help subcommand</code> 获取帮助，也可以根据下面的两个教程来系统学习。<br><a href=""http://backlogtool.com/git-guide/cn/"" rel=""nofollow noreferrer"">猴子都能懂的 git 入门</a><br><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰的 git 教程</a></p>
<p>为保大家都能顺利通关，学到所有的知识点，接下来我会写过关攻略，详细介绍每一关的玩法。<br>并且我不会直接给答案，而是演示整个过关的过程。</p>
<p>祝你好运！我们明天见。</p>
<blockquote><p><a href=""http://codingstyle.cn"" rel=""nofollow noreferrer"">「软件匠艺社区」</a>旨在传播匠艺精神，通过分享好的「工作方式」和「习惯」以帮助程序员更加快乐高效地编程。</p></blockquote>

                ", 闯过这 54 关，点亮你的 Git 技能树,1531978009,193,1,932,1,1,https://segmentfault.com/a/1190000004222489
238,1,0,7,"
                    
<blockquote><p>原文： <a href=""https://blog.coding.net/blog/git-workflow"" rel=""nofollow noreferrer"">https://blog.coding.net/blog/git-workflow</a><br>作者：<a href=""https://blog.coding.net/author/wzw"" rel=""nofollow noreferrer"">wzw@Coding</a></p></blockquote>
<p>深圳的秋天，比全国大多数地方都来得更晚。在经过忽冷忽热的挣扎中，天气渐渐转凉。<br>这天是周末，晚上天气凉爽，小刘，小李，小高，小陈四个人，约好一起来撸串。他们是大学同学，学的是计算机，毕业后都到了深圳，目前都以写程序为生，加入了程序员大军。</p>
<p>程序员的聚餐节目是固定的，几口大腰子下去，再加上几杯啤酒下肚，几个人不约而同的开始各种吐槽，从骂老板，骂上司，骂产品，骂设计，骂到最后，大家都懂。所谓的程序员的聊天以骂老板开始，以撕编程语言结束。</p>
<p>但是今天他们又开了一个新的话题，那就是代码托管的工作流。</p>
<p>小刘率先发言， git 这货 跟 svn 没啥差别，我一贯还是按照以往的，写完了就提交，我们三五个人的小团队也都这样，除了可以在本地不连服务器上也能提交代码这点之外，跟 svn 没啥差别，我们就只有一个主分支跟 svn 的主干是一样的，大家都在这上面工作，团队协作沟通非常高效。</p>
<h3>小刘所讲的工作流 -- Centralized Workflow</h3>
<p>￼<br><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/feebbee4-43de-487d-bedb-cc12a1e7c91e.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>这套流程讲究的就是快速，简单，这对于大多数个人开发者和小型团队来说是最好的选择，往往是维护一个 App ，个人博客，或者一个小型网站之类的。总结下来适用场景和基本特点是：<br>￼</p>
<ol>
<li><p>团队人数少</p></li>
<li><p>开发不是很频繁</p></li>
<li><p>团队沟通方便</p></li>
<li><p>不需同时维护多个版本</p></li>
</ol>
<p>继续说回我们的故事。<br>小陈听不下去了，说道：我们团队都推行使用一个 git 的插件，叫做 git-flow ， 所有成员，都按照这个软件规定的标准流程进行协作，每次改动，我们都根据不同的情形，使用 git-flow 工具来新建相应的流程。大家都按照这个流程来，虽然繁琐，但是我们三十几个开发团队共同维护几个项目，从来都是运行平稳，从未出事，就你们那几个人三天两头代码库被新手搞乱，居然还好意思叫团队协作沟通高效？我看是搞笑吧，哈哈。</p>
<p>小刘气的脸通红，又没啥话好说，只好忍了。</p>
<h3>小陈所讲的工作流 -- Git-flow Workflow</h3>
<p>￼<br><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/b84291d9-e16d-4af0-9149-2ae6faeea134.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>这套工作流讲究的是平稳，有序， Git-flow 工作流在 Git 分支标签等概念的基础上，添加了一些 Feature ， Release ， Hotfix 等概念，用以精确描述代码版本控制的一些流程，所有协作者在放弃一些个人效率的基础上，统一开发流程，最终带来的是整体的规模化的团队的整体效率提升。其缺点是上手较难一点，需要一些基础知识培训，适用场景如下：</p>
<ol>
<li><p>认为额外学习 Git-Flow 不是什么问题的</p></li>
<li><p>有专门的代码仓库管理员的</p></li>
<li><p>开发团队相对固定，而且有一定规模</p></li>
<li><p>常常有并行开发需求</p></li>
<li><p>团队对于 Release ， Bug ， Feature 这些概念有统一定义标准的</p></li>
</ol>
<p>继续说回我们的故事。<br>这时小李淡定的拿出一串羊肉，吃了一口，说道：我不知道你们说的是什么玩意，但是我作为一个自由职业者，维护着一个开源软件，平时也给一些开源软件贡献些代码，从来都是 Github 上 fork 完了，再提交 Pull Request 的， Pull Request 会被开源软件的维护者评审，如果评审通过，就会合并到源项目。我作为一个开源软件的维护者，既评审着别人给我的贡献，也贡献给别人评审，这是一个非常理想的生态循环，我不知道你们扯那些破玩意有啥用。</p>
<h3>小李所讲工作流 -- Fork Workflow</h3>
<p>￼￼<br><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/0d3c05db-1ee9-430b-973e-f370ccd0b97e.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>这套流程是专门为开源软件量身打造的一套流程，最早的发明者是 Github ， Github 是世界知名开源软件仓库。这个流程的最大特点就是，开发参与者可以不直接参与到项目中来，想贡献代码，只要 fork 目标项目后，就可以得到一个一模一样的自有项目，做完修改后，提交 Pull Request 给原项目，如原项目的维护者采纳了，即算贡献完成。图中看一看到，每个开发者（团队）都拥有自己维护的一个项目，跟别人项目之间的联系通过 Pull Request 形式解决。总结下来适用场景是：</p>
<ol>
<li><p>常用于开源软件</p></li>
<li><p>开发者有需要衍生出自己的衍生版的</p></li>
<li><p>开发者不固定，可能是任意一个网友</p></li>
</ol>
<p>继续说回我们的故事。<br>小高是个胖子，每次撸串最能吃，基本上聊天的时候都是偶尔插一句话。但是这时候，听完这一顿撕，也忍不了了，用纸巾擦掉嘴上的辣椒说道：我们公司，跟你们选择的都不同，我们公司使用基于 git-flow 简化的一个模型来协同工作，不需要安装什么 git 插件。版本库有一个默认分支 master ，需要 release 的时候，就将默认分支打一个标签，用作 release 。使用 Coding 提供的保护分支功能， master 指定若干管理员，其他人有任何修改都在默认分支 master 的基础上新开分支，提交代码，然后到 Coding 上向 master 提交合并请求，并可以指定若干团队成员作为评审者，评审通过后就可以合并到 master 上了。也从来都运转平稳，从未出事。</p>
<h3>小高所讲工作流 -- Feature Branch Workflow</h3>
<p>￼￼<br><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/a60eb8f5-330d-4c2f-a347-ac47dba0e440.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>这套流程属于 Git-Flow 的简化版，不再需要安装额外 Git 插件，基于代码托管平台提供的一些基础功能来实现，主要流程分 Feature 流程和 Bug 流程。这个流程是适用于大多数团队人数在 5 人以上，有很多并行开发需求，切更新频繁，开发任务重的协作团队。其适用场景是：</p>
<ol>
<li><p>开发团队相对固定，而且有一定规模</p></li>
<li><p>常常有多个功能，多个问题并行开发</p></li>
<li><p>对代码审查有较高要求</p></li>
<li><p>更注重团队效率</p></li>
</ol>
<p>小刘，这时才从小陈的话中缓过神来，对小陈说道，我们虽然是出过新手搞乱了代码库的问题，但是 git 都是有历史的，并非不可恢复，关键是我们流程简便，从来有任何问题都是快速响应，不像有些公司，修个 bug ，居然要等一周才能上线。</p>
<p>小李又说道，有啥好吵，都是没啥卵用的玩意，你就按照 fork / pull request 来搞就行了。</p>
<p>你一句，我一句，七嘴八舌的，吵得不可开交。<br>。。。。。。</p>
<p>这四位的争论越来越激烈，没办法，程序员的争论都是撕破脸皮，面红耳赤，直至烧烤店快要打烊了。最后惊动了烧烤店的老板娘。老板娘听罢争论，笑眯眯的走过来说：年轻人莫要激动，我虽然不知道讲什么，但这世间万物，都有适用范围，没有什么是绝对好的，也没有什么是绝对坏的。就好比你们吃烧烤的辣椒，放在这烤肉上，味道就非常不错，但是你见过哪家冷饮店放辣椒的么？</p>
<p>几人听完，瞬间觉得卫生阿姨就好比金庸小说扫地僧那般神奇，细思恐极，赶紧结了账，匆匆离开了。</p>
<p>============ 这是分割线 ============</p>
<p>是啊，没什么是绝对好的，也没什么是绝对坏的，每样东西都有适用范围。</p>
<p>以上，适用场景并不定死，是灵活多变的，甚至于我们可以超出以上四种模型，取其精华，弃其糟粕，自己创造出新的模型来。总之，希望这篇文章能帮助你找到属于符合自己的模型的 git 工作流。</p>

                ", 大话 Git 工作流,1531978011,536,1,846,1,1,https://segmentfault.com/a/1190000004211312
239,1,0,7,"
                    
<p>一直用 Sketch 做设计，Sketch 的插件通常都是从 github 上直接 clone 下来安装的，一个插件对应一个 repo。随着插件越来越多，每次更新都得手动一个个 <code>git pull</code> 很麻烦，于是弄了个 bash 小脚本来批量更新：</p>
<pre><code>#!/bin/sh
for dir in $(ls -d */)
do
  if [ -d ""$dir""/.git ]; then
    echo ""$dir"" &amp;&amp; cd ""$dir"" &amp;&amp; git pull &amp;&amp; cd ..
  fi
done</code></pre>
<p>小脚本虽然解决了最原始的需求，但是仍然不是很好用。于是在网上又搜刮了一遍发现了 git-repo-updater （简称：<a href=""https://github.com/earwig/git-repo-updater"" rel=""nofollow noreferrer"">gitup</a>） 这个小工具。</p>
<p>用 homebrew 进行安装，很简单执行 <code>brew install gitup</code> 即可安装。</p>
<p>Sketch 的插件都在 <code>&lt;dir&gt;/plugin</code> 目录下，所以我们进入 <code>&lt;dir&gt;/plugin</code> 目录，在该目录下执行 <code>gitup .</code> 即可，终端里会实时显示更新进度，不一会儿就更新完成了，省时省力。</p>
<hr>
<p>当然，还有更高级的用法：</p>
<pre><code># 更新 foo, bar, baz 这几个 repo
gitup ~/repos/foo ~/repos/bar ~/repos/baz

# 更新 repos 目录下的所有 repo
gitup ~/repos</code></pre>
<p>你还可以将这些 repo 放进收藏夹：</p>
<pre><code>gitup --add ~/repos/foo ~/repos/bar ~/repos/baz
gitup --add ~/repos</code></pre>
<p>然后运行 <code>gitup</code>（不加任何参数）就行更新收藏夹下的所有 repo。还有一些其他用法：</p>
<pre><code># 删除收藏夹
gitup --delete ~/repos

# 查看当前收藏夹
gitup --list</code></pre>
<p>嗯，是不是很有用啊，了解更多，请上传送门 <a href=""https://github.com/earwig/git-repo-updater"" rel=""nofollow noreferrer"">https://github.com/earwig/git-repo-updater</a></p>

                ", gitup: 批量更新多个 git 代码库的小工具,1531978012,182,1,834,1,1,https://segmentfault.com/a/1190000004169139
240,1,0,7,"
                    
<h2>译者说</h2>
<p><code>Tornado 4.3</code>于2015年11月6日发布，该版本正式支持<code>Python3.5</code>的<code>async</code>/<code>await</code>关键字，并且用旧版本CPython编译Tornado同样可以使用这两个关键字，这无疑是一种进步。其次，这是最后一个支持<code>Python2.6</code>和<code>Python3.2</code>的版本了，在后续的版本了会移除对它们的兼容。现在网络上还没有<code>Tornado4.3</code>的中文文档，所以为了让更多的朋友能接触并学习到它，我开始了这个翻译项目，希望感兴趣的小伙伴可以一起参与翻译，项目地址是<a href=""https://github.com/tao12345666333/tornado-zh"" rel=""nofollow noreferrer"">tornado-zh on Github</a>，翻译好的文档在<a href=""https://tornado-zh.readthedocs.org/"" rel=""nofollow noreferrer"">Read the Docs上</a>直接可以看到。欢迎Issues or PR。</p>
<h2>介绍</h2>
<p><a href=""http://www.tornadoweb.org"" rel=""nofollow noreferrer"">Tornado</a> 是一个Python web框架和异步网络库起初由 <a href=""http://friendfeed.com"" rel=""nofollow noreferrer"">FriendFeed</a>开发. 通过使用非阻塞网络I/O, Tornado 可以支持上万级的连接，处理<a href=""http://en.wikipedia.org/wiki/Push_technology#Long_polling"" rel=""nofollow noreferrer"">长连接</a>,<a href=""http://en.wikipedia.org/wiki/WebSocket"" rel=""nofollow noreferrer"">WebSockets</a>, 和其他需要与每个用户保持长久连接的应用.</p>
<p>Tornado 大体上可以被分为4个主要的部分:</p>
<ul>
<li><p>web框架 (包括创建web应用的 <code>RequestHandler</code> 类，还有很多其他支持的类).</p></li>
<li><p>HTTP的客户端和服务端实现 (<code>HTTPServer</code> and <code>AsyncHTTPClient</code>).</p></li>
<li><p>异步网络库 (<code>IOLoop</code> and <code>IOStream</code>),<br>  为HTTP组件提供构建模块，也可以用来实现其他协议.</p></li>
<li><p>协程库 (<code>tornado.gen</code>) 允许异步代码写的更直接而不用链式回调的方式.</p></li>
</ul>
<p>Tornado web 框架和HTTP server 一起为<a href=""http://www.python.org/dev/peps/pep-3333/"" rel=""nofollow noreferrer"">WSGI</a>提供了一个全栈式的选择.<br>在WSGI容器 (<code>.WSGIAdapter</code>) 中使用Tornado web框架或者使用Tornado HTTP server作为一个其他WSGI框架(<code>.WSGIContainer</code>)的容器,这样的组合方式都是有局限性的.为了充分利用Tornado的特性,你需要一起使用Tornado的web框架和HTTP server.</p>

                ", Tornado 4.3文档翻译: 用户指南-介绍,1531978014,545,1,859,1,1,https://segmentfault.com/a/1190000004140540
241,1,0,7,"
                    
<h2>1 Git Flow</h2>
<hr>
<p>一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景，Git Flow是构建在Git之上的一个组织软件开发活动的模型，Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。在此介绍Git Flow是由于walle依赖它的思想进行持续部署。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmwPi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>开发过程中可能出现的git flow</p>
<h3>1.1 Git Flow中的分支</h3>
<hr>
<p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。分支的名字是一种共识，更重要的是它承担的责任。</p>
<h3>1.2 主分支</h3>
<hr>
<p>主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支分为master分支和development分支。</p>
<h4>1.2.1 master分支</h4>
<hr>
<p>master分支上存放的应该是随时可供在生产环境中部署的代码，它承担的责任就是：仅在发布新的可供部署的代码时才更新到master分支上的代码。当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG）。</p>
<h4>1.2.2 develop分支</h4>
<hr>
<p>develop分支是保存当前最新开发成果的分支，它承担的责任就是功能开发完毕等待最后QA的验收，通常这个分支上的代码也是可进行每日夜间发布的代码。当代码已经足够稳定时，就可以将所有的开发成果合并回master分支了。</p>
<h3>1.3辅助分支</h3>
<hr>
<p>辅助分支是用于组织解决特定问题的各种软件开发活动的分支，它的生存周期伴随着它的功能完成而消失。辅助分支包括：</p>
<ul>
<li><p>用于并行开发新功能时所使用的feature分支；</p></li>
<li><p>用于辅助版本发布的release分支；</p></li>
<li><p>用于修正生产代码中的缺陷的hotfix分支。</p></li>
</ul>
<p>当这些分支完成它的使命之后在merge到主分支之后，也将被删除。</p>
<p>Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱，各自开发团队根据自己的特点和节奏自行剪裁或扩展。</p>
<h2>2 Walle介绍</h2>
<hr>
<h3>2.1是什么？</h3>
<hr>
<p>Walle 一个web部署系统工具，可能也是个持续发布工具，配置简单、功能完善、界面流畅、开箱即用！支持git、svn版本管理，支持各种web代码发布，静态的HTML、动态PHP、需要编译的JAVA等，用户权限管理，各种自定义高级任务。一键上线、回滚。</p>
<p>项目地址：<a href=""https://github.com/meolu/walle-web"" rel=""nofollow noreferrer"">walle-瓦力</a>，上线开源两个月，目前已支持超过十家企业线上部署使用，每周更新一个版本，持续带来新特性。</p>
<h3>2.2 walle的组件关系、原理</h3>
<hr>
<p>walle部署在一台宿主机提供一个web UI，方便用户自主更新代码部署到目标机群。Walle是一个跑在LNMP(LAMP)上的PHP服务，宿主机与目标机群建立信任，通过操作bash命令来实现代码同步、自定义高级任务。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrcZ8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>宿主机、目标机群、操作用户关系</p>
<h3>2.3配置</h3>
<hr>
<p>用户的项目可自定义git/svn代码托管地址、宿主机、目标机群、高级任务等。配置完成后可快速复制当前配置、检测配置是否正常、以及该项目的审核管理员和成员。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrc0b"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>3 walle与Git的配合</h2>
<hr>
<p>walle的持续部署与Git Flow思想一致，在不同的环境部署不同的分支。划分三个环境：测试环境、预发布环境、生产环境。测试环境和预发布环境推荐分支部署，生产环境推荐tag部署。当然，这更适合milestone开发方式，如果是每天快速迭代多个版本，打tag成本就有点高了。</p>
<h3>3.1 部署环境</h3>
<hr>
<h4>3.1.1 测试环境</h4>
<hr>
<ul>
<li><p>开发者的feature分支开发、自测验收通过后，merge到测试环境的develop分支，（QA）部署到测试环境，等待QA验收。</p></li>
<li><p>QA提bug issue，开发者从develop切分支修正再次合并、部署、验收。</p></li>
</ul>
<h4>3.1.2 预发布环境</h4>
<hr>
<ul>
<li><p>测试环境验收通过之后，合并到预发布环境的master，部署预发布环境</p></li>
<li><p>QA全面回归，发现问题提bug issue，开发者从master切分支修正再次合并、部署、验收。</p></li>
<li><p>回归完毕打tag，准备上线</p></li>
</ul>
<h4>3.1.3 生产环境</h4>
<hr>
<ul>
<li><p>上线验收通过的tag</p></li>
<li><p>回归测试，发现问题开发者从master切分支hotfix修正。</p></li>
</ul>
<h3>3.2 环境上线流程</h3>
<hr>
<p>开发者选择要上线的项目，选择要上线的分支和版本提交上线单，项目管理员审核通过后，开发者发起上线。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrc0c"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>4 Walle的部署流程</h2>
<hr>
<p>部署是在一台宿主机拉取代码，做编译、配置后，向目标机群分发，执行相关目标机群任务。部署流程拆分为以下6个环节，其中1-5为在宿主机进行，6在目标机群执行。</p>
<ol>
<li><p>权限、目录检查，开辟一个上线的独立空间以并行发布，防止同时部署出现代码污染</p></li>
<li><p>pre-deploy任务，代码检出前的一些操作任务，如环境检查</p></li>
<li><p>代码从git/svn版本库中检出</p></li>
<li><p>post-deploy任务，代码检出之后操作任务，如java的mvn编译，php的composer插件安装</p></li>
<li><p>保留在独立空间的代码均会被同步至目标机群的一个版本库中</p></li>
<li><p>全量更新：当所有机器都分发完毕，开始做pre-release任务（java暂停服务）、切换版本软链、post-release任务（ java启动服务）</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVrc0d"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>为保证服务的完整性，先同步代码，后切换服务。部署发布每次都会有版本记录保留，版本上线事故一旦发生，回滚可瞬间完成。可配置线上版本最大保留数，过期的版本被会删除，同时也就不能回滚被删除的版本。对于需要编译、自定义多任务辅助，可配置前置、后置操作自定义任务；同时提供一些预置变量（{WORKSPACE}宿主机的当前独立空间、目标机webroot，{VERSION}版本库目录）方便用户操作自定义任务。</p>
<p>上线过程直到目标机群全部完成之前，如有任一环节失败将会回滚，需要重新上线，同时会把错误信息提示用户。</p>
<h2>5 Todo list</h2>
<hr>
<ul>
<li><p>支持Docker</p></li>
<li><p>开放接口</p></li>
<li><p>支持第三方hook</p></li>
</ul>
<h2>6 了解更多</h2>
<hr>
<p>项目地址：<a href=""https://github.com/meolu/walle-web"" rel=""nofollow noreferrer"">walle-瓦力</a>，<a href=""http://www.huamanshu.com/walle.html"" rel=""nofollow noreferrer"">官方主页-花满树</a>。欢迎了解、star、fork。</p>

                ", walle-瓦力自动化部署工具,1531978016,560,1,162,1,1,https://segmentfault.com/a/1190000003998103
242,1,0,7,"
                    
<h2>自己写标签： 实时刷新、 免F5、 gulp + browser-sync</h2>
<p>开门见山，首先讲明一下本文的定位吧：<br>写这篇文章是因为自己在平时的学习中，一次次试验了很多的前端实时刷新工具，有顺手的，有蹩脚的，有简单的，有麻烦的，安装完又折腾，折腾完又卸载，体验完这些也着实花费了不少时间，就在昨天又刚刚折腾完<code>gulp</code>+<code>browser-sync</code>的方法，估计可以让我消停一阵子了。这篇文章主要介绍和汇总一下我用过和见过的前端页面实时刷新工具（就是ctrl+s之后实现页面刷新的意思，觉得F5刷新也不麻烦的朋友们就可以不必往下读了哈），希望能为你挑选自己喜欢的工具节省些时间，也少些纠结，闲言少叙，下面开始</p>
<h2>工具列表（顺序：从安装方便到功能强大）</h2>
<h3>1.自带及时预览功能的编辑器：</h3>
<p><code>Atom</code>    <code>brackets</code>     <code>webstorm</code><br>上述三者都是大名鼎鼎的编辑器，插件众多，功能强大，为前端开发人员们在工作中立下汗马功劳，也深受开发人员们的喜爱，因此也是教程众多，我就不再多说了。google一下，你就知道如何使用它们的及时预览功能了。但是这些工具的及时预览有一点不爽：预览界面内嵌在编辑器界面内，减小了对整张网页的视觉效果，Atom和Brackets都存在这样的问题（当然这也不算是问题了，全看个人喜好）。如Atom编辑器使用atom-preview-html实现的效果：<span class=""img-wrap""><img data-src=""/img/bVqSHv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>而webstorm实现预览的效果是很赞的，右上角会有多个浏览器的logo图标，想在哪个浏览器打开就点击哪个就好了，挺方便。webstorm本身也是算是前端人员熟知的编辑器中体量和功能相当强大的了，除了打开速度有点慢之外，没啥说的。</p>
<h3>2.sublime text3</h3>
<ul>
<li><p>把<code>sublime text3</code>单独拿出来说是有原因的，首先它是我长期使用的第一款编辑器，有个人情愫在其中难免没有偏爱之心。最喜欢的就是它超快的打开响应速度，有种说干就干的爽快劲儿，即便安装了一大堆的插件儿也丝毫没有觉得变缓慢，点个赞。<br>说到插件就不得不说sublime编辑器是没有自带及时预览功能的，但是可以通过插件来实现：比如<code>sidebarEnhancement</code>，在html文件名上右键打开open in Browser就可以查看效果了，这其实就是最传统的 ctrl+s+F5刷新预览大法，只不过直接在编辑器上打开浏览器了而已。</p></li>
<li><p>还可以使用<code>livereload</code>方法，但是比较古老了，感兴趣的话可以google一下（如果你可以忍受各种各样的V1推广，V2推广等不相关内容强占你的页面，当然也可以用百度啦）</p></li>
<li><p>以前作为新手，对于命令行操作的工具有畏惧感，所以接触到<a href=""http://getf5.com/"" rel=""nofollow noreferrer"">“F5免刷新工具的时候”(点击进入它的官网可下载)</a>一下子被其可视化的界面操作吸引了，用它在浏览器中打开文件之后，在编辑器中编辑完代码，ctrl+s即可实现自动刷新，很方便，用了很长一段时间都觉得十分方便，但是最近发现它总是在没有进行任何操作的时候自动刷新一遍，在浏览器中找好的节点位置一下子又不见了，搞得正在盯着屏幕看代码的我很诧异，有种正津津有味看着大片儿一下子电脑黑屏的赶脚，看了下工具作者好多年没更新了，只好依依不舍地先弃掉这一工具另谋它法。</p></li>
</ul>
<blockquote><p><strong>在网上百般寻找，最后找到了这么一款工具：</strong><a href=""http://www.browsersync.cn/"" rel=""nofollow noreferrer"">browser-sync</a></p></blockquote>
<p>Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。您可以想象一下：“假设您的桌子上有pc、ipad、iphone、android等设备，同时打开了您需要调试的页面，当您使用browsersync后，您的任何一次代码保存，以上的设备都会同时显示您的改动”。无论您是前端还是后端工程师，使用它将提高您30%的工作效率。<br><span class=""img-wrap""><img data-src=""/img/bVqTvR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>有了它，您不用在多个浏览器、多个设备间来回切换，频繁的刷新页面。更神奇的是您在一个浏览器中滚动页面、点击等行为也会同步到其他浏览器和设备中，这一切还可以通过可视化界面来控制。<br><span class=""img-wrap""><img data-src=""/img/bVqTvQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>以上是中文网站上的介绍，很是吸引我，果断决定就用它了！（其实国内也有一款之类似的工具<a href=""http://leeluolee.github.io/2014/10/24/use-puer-helpus-developer-frontend/"" rel=""nofollow noreferrer"">puer</a> ,二者功能接近，但BrowserSync更强大，我就主要介绍他了</p>
<h3>开始安装：</h3>
<p>1.下载安装node.js  <br>2.安装 BrowserSync</p>
<p>您可以选择从Node.js的包管理（NPM）库中 安装BrowserSync。打开一个终端窗口，运行以下命令：</p>
<pre><code>npm install -g browser-sync</code></pre>
<p>这条命令相当于告诉包管理器下载BrowserSync文件，并在全局下安装它们，您可以在所有项目(任何目录)中使用。</p>
<p>当然您也可以结合gulpjs或gruntjs构建工具来使用，在您需要构建的项目里运行下面的命令:</p>
<pre><code>npm install --save-dev browser-sync</code></pre>
<p>3.启动 BrowserSync<br>一个基本用途是，如果您只希望在对某个css文件进行修改后会同步到浏览器里。那么您只需要运行命令行工具，进入到该项目（目录）下，并运行相应的命令：</p>
<h4>静态网站</h4>
<p>如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。</p>
<pre><code>// --files 路径是相对于运行该命令的项目（目录）
browser-sync start --server --files ""css/*.css""</code></pre>
<p>如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件</p>
<pre><code>// --files 路径是相对于运行该命令的项目（目录）
browser-sync start --server --files ""css/*.css, *.html""
// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。
browser-sync start --server --files ""**/*.css, **/*.html""</code></pre>
<p>我们做了一个静态例子的示范，您可以下载示例包，文件您可以解压任何盘符的任何目录下，不能是中文路径。打开您的命令行工具，进入到BrowsersyncExample目录下，运行以下其中一条命令。Browsersync将创建一个本地服务器并自动打开你的浏览器后访问<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:3000 地址， 这一切都会在命令行工具里显示。如果遇到can not GET/这样的提示，说明你在当前文件夹下没有index.html文件，如果想查看的是当前目录下的css文件夹下面的某html5.html文，要更改访问地址为：<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:3000/css/html5.html ，这样就能正常访问了。<br>你也可以查看Browsersync静态示例视频：</p>
<p><a href=""http://www.browsersync.cn/example/video/browsersync1.mp4"" rel=""nofollow noreferrer"">不明白上述教程一定要点开看这个链接！！！这里视频演示的是使用方法</a></p>
<pre><code>// 监听css文件
browser-sync start --server --files ""css/*.css""
// 监听css和html文件
browser-sync start --server --files ""css/*.css, *.html""</code></pre>
<h4>动态网站</h4>
<p>如果您已经有其他本地服务器环境PHP或类似的，您需要使用代理模式。 BrowserSync将通过代理URL(localhost:3000)来查看您的网站。</p>
<pre><code>// 主机名可以是ip或域名
browser-sync start --proxy ""主机名"" ""css/*.css""</code></pre>
<p>在本地创建了一个PHP服务器环境，并通过绑定Browsersync.cn来访问本地服务器，使用以下命令方式，Browsersync将提供一个新的地址localhost:3000来访问Browsersync.cn，并监听其css目录下的所有css文件。</p>
<pre><code>browser-sync start --proxy ""Browsersync.cn"" ""css/* .css""</code></pre>
<h2>一点建议，其实也是gulp+browser-sync方法的介绍，算是本文核心（我现在用的方法）</h2>
<p>我们建议您结合gulp或grunt来使用，我们这里有详细说明Gulp文档、Grunt文档。如果您还没有使用gulp或grunt，那么可以通过以上方式创建Browsersync<br>鉴于browser-sync中文网站上给出的教程已经很去那面细致了，我就照搬了部分过来，但是实际使用browser-sync之后，估计你会发现，每次启动都要打开git bash或者其他命令窗工具，输入</p>
<pre><code>browsersync start --server --file ""/.html，/*.css""</code></pre>
<p>命令行的方法太冗长，所以我就研究了下搭配gulp使用的方法，实际证明官方推荐的方法确实蛮省劲儿的，但是他们没有给出具体详细的设置方法，我在这里写点更为详细的方法好了：<br>肯定有对<code>gulp</code>工具不是很熟悉的人看这篇文，一次都没接触过也不用怕，他就像个大管家，是来统筹管理前端各类比较杂的工具的大总管，你是主人，有什么需要提前给他吩咐好，他会去让各种工具有序干活儿。所以这里可以理解为把启动browser-sync的命令交由gulp去完成，我们的目标是只要在命令框里输入个gulp就能执行browser-sync。<br><a href=""http://www.ydcss.com/archives/18"" rel=""nofollow noreferrer"">这里推荐一篇学习gulp的文章,注意学习其中对于命令行参数的解释</a><br>在上面的教程中的gulpfile.js文件中写好如下内容：</p>
<pre><code>var gulp        = require('gulp');
var browserSync = require('browser-sync').create();

// Static server
gulp.task('browser-sync', function() {
    var files = [
    '**/*.html',
    '**/*.css',
    '**/*.js'
    ];
    browserSync.init(files,{
        server: {
            baseDir: ""./""
        }
    });
});

// Domain server
//gulp.task('browser-sync', function() {
//    browserSync.init({
//        proxy: ""yourlocal.dev""
//    });
//});
gulp.task('default',['browser-sync']); //定义默认任务</code></pre>
<p>上面的代码中Domain server部分是针对启用了本地服务器的设置方法，注意proxy：  <code>""yourlocal.dev""</code>   中的<code>dev</code>有很重要的作用哦！下面引用一段stackoverflow上人们的评论看下</p>
<p><strong><em><em><em></em>stackoverflow commits start</em></em></strong></p>
<blockquote>
<p>QUESTION:    BrowserSync extremely slow???</p>
<p>The solution is quite simple - but illogical imho. I had my local instance running under <a href=""http://project.local."" rel=""nofollow noreferrer"">http://project.local.</a> Changing it to <a href=""http://project.dev"" rel=""nofollow noreferrer"">http://project.dev</a> solved the issue. I'm running OS X.</p>
<p>Works. But... but... why? – henrijs Nov 7 '14 at 8:42</p>
<p>:-) If you are running OS X as well, I guess it has something to do with DNS lookups (Bonjour is using the .local domain as well). – Rico Leuthold Nov 7 '14 at 16:01</p>
<p>Amazing tip for mac users. Thanks so much! – Armel Larcier Nov 15 '14 at 16:13</p>
<p>Had the same issue on Linux Ubuntu 14 and changing my URL from 'local.domain.co.uk' to 'domain.dev' worked perfectly! So thank you as never would of solved it otherwise. – Josh Davies Mar 26 at 11:44</p>
<p>This works on Ubuntu 14.10. An explanation as to why a .com slows browserSync down would be nice though. – fauxnoir Jun 11 at 21:10</p>
</blockquote>
<p><strong><em><em><em></em>stackoverflow commits end</em></em></strong></p>
<p>然后重新打开命令行工具，键入“gulp""，然后回车，稍等会儿，看看是不是就能打开browser-sync了？<br>这里其实就是把browser-sync设置为了gulp的默认任务了而已，等你需要用到gulp调用其他工具的时候，可以再作修改。</p>

                ", 前端开发：实时刷新（及时预览）工具小汇总，兼有gulp+browser-sync设置方法,1531978017,407,1,377,1,1,https://segmentfault.com/a/1190000003987581
243,1,0,7,"
                    
<blockquote><p>什么时候需要 Subtree ？   <br>1、当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候   <br>2、把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</p></blockquote>
<h2>背景</h2>
<p>有赞微商城曾经是一个很大的前后端代码都包含在里面的 Git 项目，为了方便管理我们把前后端代码分离成2个 Git 仓库，进而再作分项目拆分成多个Git 仓库。</p>
<p>于是，就需要有好的方式同步各个项目共用的Css库、JS库、PHP库（他们都是以独立的 Git 仓库的形式存在）。而且由于开发节奏极快，我们需要这些库是<strong>可以在不同项目间双向同步的而不是单向同步</strong>。<strong>而且，最好能做到被迁移的这部分代码在新的git仓库里保留原有的历史提交记录。</strong></p>
<p>举个栗子：A项目需要在给某个子项目W里添加一个文件，最方便的方式自然是直接在A项目里改W子项目对应的目录里的代码，然后测试通过后，把这个更改提交到W子项目的 Git仓库里。如果这时候还要先单独更新W子项目的代码然后提交到 Git 服务器，再在A项目里把W子项目的代码更新过来，显然是很麻烦的，更麻烦的是如果发现代码有bug，还得再走一遍这个流程。</p>
<h2>有什么方案？</h2>
<ul>
<li><p><a href=""http://git-scm.com/docs/git-submodule"" rel=""nofollow noreferrer"">Git Submodule</a>：这是Git官方以前的推荐方案</p></li>
<li><p><a href=""https://medium.com/@porteneuve/mastering-git-Subtrees-943d29a798ec"" rel=""nofollow noreferrer"">Git Subtree</a>：从 <a href=""http://lwn.net/Articles/235109/"" rel=""nofollow noreferrer"">Git 1.5.2</a> 开始，Git 新增并推荐使用这个功能来管理子项目</p></li>
<li><p><a href=""https://www.npmjs.com/"" rel=""nofollow noreferrer"">npm</a>：node package manager，实际上不仅仅是 node 的包管理工具</p></li>
<li><p><a href=""https://getcomposer.org/"" rel=""nofollow noreferrer"">composer</a>：暂且认为他是php版npm、php版Maven吧</p></li>
</ul>
<p>虽然 npm、composer、maven 等更侧重于包的依赖管理，以上几个方案都是能够做到在不同项目中同步同一块代码的，但没法双向同步，更适用于子项目代码比较稳定的情形。</p>
<p>Git Submodule 和 Git Subtree 都是官方支持的功能，不具有依赖管理的功能，但能满足我们的要求。Git Subtree相对来说会<a href=""http://somethingsinistral.net/blog/git-submodules-are-probably-not-the-answer/"" rel=""nofollow noreferrer"">更好一些</a> 。</p>
<h2>Git Subtree 好在哪里</h2>
<p>用一句话来描述 Git Subtree 的优势就是：</p>
<blockquote><p>经由 Git Subtree 来维护的子项目代码，对于父项目来说是透明的，所有的开发人员<strong>看到的就是一个普通的目录，原来怎么做现在依旧那么做</strong>，只需要维护这个 Subtree 的人在合适的时候去做同步代码的操作。</p></blockquote>
<p>它是怎么做到的呢？简单说下原理</p>
<h2>Git Subtree 的原理</h2>
<p>首先，你有两个伟大的项目——我们叫他P1项目、P2项目，还有一个牛逼的要被多个项目共用的项目——我们叫他S项目。我们通过简要讲解使用Subtree来同步代码的过程来解释Subtree的原理</p>
<h3>1、初始化子项目Subtree</h3>
<p>通过</p>
<pre><code class=""shell"">cd P1项目的路径
git subtree add --prefix=用来放S项目的相对路径 S项目git地址 xxx分支</code></pre>
<p>这样的命令，把S项目（我们姑且叫他S项目）的代码下载到--prefix所指定的目录——我们姑且叫他S目录把，并在P1项目里自动产生一个commit（就是把S目录的内容提交到P1项目里）。</p>
<p><em>对于P2项目也做同样的操作</em></p>
<h3>2、像往常一样更新代码</h3>
<p>大家在P1项目里各种提交commit，其中有些commit会涉及到S目录的更改，正如前面提到的，这是没任何关系的，大家也不会感受到有任何不一样。</p>
<h3>3、提交更改到子项目的Git服务器</h3>
<p><strong>关键的地方来了：</strong><br>当维护这个S项目 Subtree 的人希望把最近这段时间对S目录的更改提交到S项目的 Git 服务器上时，他执行一段类似于这样的命令：</p>
<pre><code class=""shell"">cd P1项目的路径
git subtree push --prefix=S项目的路径 S项目git地址 xxx分支</code></pre>
<p>Git 会遍历所有的commit，从中找出针对S目录的更改，然后把这些更改记录提交到S项目的Git服务器上</p>
<h3>4、更新子项目新的代码到父项目</h3>
<p>OK，现在S项目有大量的新代码了，P2项目也想使用这些新代码，维护P2这个Subtree的人只要执行：</p>
<pre><code class=""shell"">git subtree pull --prefix=S项目的路径 S项目git地址 xxx分支</code></pre>
<p>这样就可以将P2项目里S项目目录里的内容更新为S项目xxx分支的最新代码了。</p>
<h2>我总结的 Git Subtree 简明使用手册</h2>
<p>假设，你要在各个项目里的<em>components/zenjs</em>这个目录对 <em><a href=""http://github.com/youzan/zenjs.git"" rel=""nofollow noreferrer"">http://github.com/youzan/zenjs.git</a></em> 这个项目做Subtree</p>
<p>1.首先必须确保各个项目已经添加zenjs 这个 remote（关于remote是什么可以看<a href=""http://git-scm.com/docs/git-remote"" rel=""nofollow noreferrer"">这里</a>）:</p>
<pre><code class=""shell"">git remote add zenjs http://github.com/youzan/zenjs.git</code></pre>
<p>2.将zenjs添加到各个项目里</p>
<pre><code class=""shell"">git subtree add --prefix=components/zenjs zenjs master  </code></pre>
<p>3.各项目更新zenjs代码的方法:</p>
<pre><code class=""shell"">git subtree pull --prefix=components/zenjs zenjs master</code></pre>
<p>4.各项目提交zenjs代码的方法:</p>
<pre><code class=""shell"">git subtree push --prefix=components/zenjs zenjs hotfix/zenjs_xxxx</code></pre>
<p>这会在远程的zenjs的仓库里生成一个叫 hotfix/zenjs_xxxx 的的分支，包含了你过去对components/zenjs 所有的更改记录</p>
<p>5.把hotfix/zenjs_xxx分支更新并合并到master并提交</p>
<p>这样其他工程就可以更新到你提交的代码了。</p>
<blockquote>
<p>有人可能会问，只用master分支，不管版本，太有风险了。</p>
<p>对的，正如我们前面说到的那样，subtree的方案适用的场景是：各个项目共用一个库，而这个库正在快速迭代更新的过程中。如果追求稳定，只需要给库拉出一个如v0.1.0这样的版本号命名的稳定分支，subtree只用这个分支即可。</p>
<p>我们现在使用的方式就是：A项目经常会对zenjs做更新，所以A项目用subtree来双向同步；B项目只是使用，所以用bower用来按版本来更新代码。</p>
</blockquote>
<h2>高阶功能</h2>
<p>重新split出一个新起点（这样，每次提交subtree的时候就不会从头遍历一遍了）</p>
<pre><code class=""shell"">git subtree split --rejoin --prefix=components/zenjs --branch new_zenjs
git push zenjs new_zenjs:master</code></pre>
<blockquote><p>本文首发于我的<br>个人技术博客：<a href=""http://delai.me/code/git-subtree/"" rel=""nofollow noreferrer"">http://delai.me/code/git-subtree/</a><br>SegmentFault专栏：<a href=""http://segmentfault.com/a/1190000003969060"" rel=""nofollow noreferrer"">http://segmentfault.com/a/1190000003969060</a><br>转载请注明出处</p></blockquote>
<hr>
<p>2016年3月3日，update，补充 subtree 的使用场景</p>

                ", 用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册,1531978019,291,1,381,1,1,https://segmentfault.com/a/1190000003969060
244,1,0,7,"
                    
<p>在解决git merge的冲突时，有时我总忍不住吐槽git实在太不智能了，明明仅仅是往代码里面插入几行，没想到合并就失败了，只能手工去一个个确认。真不知道git的合并冲突是怎么判定的。</p>
<p>在一次解决了涉及几十个文件的合并冲突后（整整花了我一个晚上和一个早上的时间！），我终于下定决心，去看一下git merge代码里面冲突判定的具体实现。正所谓冤有头债有主，至少下次遇到同样的问题时就可以知道自己栽在谁的手里了。于是就有了这样一篇文章，讲讲git merge内部的冲突判定机制。</p>
<h2>recursive three-way merge和ancestor</h2>
<p><a>git的源码</a><br>先用<code>merge</code>作关键字搜索，看看涉及的相关代码。<br>找了一段时间，找到了git merge的时候，比较待合并文件的函数入口：<a href=""https://github.com/git/git/blob/74301d6edeb0e081a4ef864057952b6a7ff2b4be/ll-merge.c"" rel=""nofollow noreferrer"">ll_merge</a>。另外还有一份<a href=""https://github.com/git/git/blob/master/Documentation/technical/api-merge.txt"" rel=""nofollow noreferrer"">文档</a>，它也指出<code>ll_merge</code>正是合并实现的入口。</p>
<p>从函数签名可以看到，mmfile_t应该就代表了待合并的文件。有趣的是，这里待合并的文件并不是两份，而是三份。</p>
<pre><code>int ll_merge(mmbuffer_t *result_buf,
         const char *path,
         mmfile_t *ancestor, const char *ancestor_label,
         mmfile_t *ours, const char *our_label,
         mmfile_t *theirs, const char *their_label,
         const struct ll_merge_options *opts)</code></pre>
<p>看过<code>git help merge</code>的读者应该知道，<code>ours</code>表示当前分支，<code>theirs</code>表示待合并分支。看得出来，这个函数就是把某个文件在不同分支上的版本合并在一起。那么<code>ancestor</code>又是位于哪个分支呢？倒过来从调用方开始阅读代码，可以看出大体的流程是这样的，<code>git merge</code>会找出三个commit，然后对每个待合并的文件调用<code>ll_merge</code>，生成最终的合并结果。按注释的说法，<code>ancestor</code>是后面两个commit（<code>ours</code>和<code>theirs</code>）的公共祖先（ancestor）。另外前面提到的<a href=""https://github.com/git/git/blob/master/Documentation/technical/api-merge.txt"" rel=""nofollow noreferrer"">文档</a>也说明，git合并的时候使用的是<code>recursive three-way merge</code>。</p>
<p><span class=""img-wrap""><img data-src=""https://upload.wikimedia.org/wikipedia/commons/b/b6/Three-way-merge-parallelgram.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""three-way merge"" title=""three-way merge""></span></p>
<p>关于<code>recursive three-way merge</code>， wikipedia上有个相关的<a href=""https://en.wikipedia.org/wiki/Merge_(version_control"" rel=""nofollow noreferrer"">介绍</a>#Recursive_three-way_merge)。就是在合并的时候，将ours，theirs和ancestor三个版本的文件进行比较，获取ours和ancestor的diff，以及theirs和ancestor的diff，这样做能够发现两个不同的分支到底做了哪些改动。毕竟后面git需要判定冲突的内容，如果没有原初版本的信息，只是简单地比较两个文件，是做不到的。</p>
<p>鉴于我的目标是发掘git判定冲突的机制，所以没有去看git里面查找ancestor的实现。不过只需肉眼在图形化界面里瞅上一眼，就可以找到ancestor commit。（比如在gitlab的network界面中，回溯两个分支的commit线，一直到岔路口）</p>
<p>有一点需要注意的是，revert一个commit不会改变它的ancestor。所谓的revert，只是在当前commit的上面添加了新的undo commit，并没有改变“岔路口”的位置。不要想当然地认为，revert之后ancestor就变成上一个commit的ancestor了。尤其是在revert merge commit的时候，总是容易忘掉这个事实。假如你revert了一个merge commit，在重新merge的时候，git所参照的ancestor将不是merge之前的ancestor，而是revert之后的ancestor。于是就掉到坑里去了。建议所有读者都看一下git官方对于<code>revert merge commit</code>潜在后果的说法：<a href=""https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt"" rel=""nofollow noreferrer"">https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt</a> <br>结论是，如果一个merge commit引入的bug容易修复，请不要轻易revert一个merge commit。</p>
<h2>剖析xdiff</h2>
<p>从<code>ll_merge</code>往下追，可以看到后面出了一条旁路：<code>ll_binary_merge</code>。这个函数专门处理bin类型文件的合并。它的实现简单粗暴，如果你没有指定合并策略（theris或ours），直接报Cannot merge binary files错误。看来在git看来，二进制文件并没有diff的价值。</p>
<p>主路径从<code>ll_xdl_merge</code>到<code>xdl_merge</code>，进到一个叫xdiff的库中。终于找到git merge的具体实现了。</p>
<p>平心而论，xdiff的代码风格十分糟糕，不仅注释太少，而且结构体成员变量居然使用类似i1、i2这样的命名，看得我头昏脑胀、心烦意燥。</p>
<p>吐槽结束，先讲下<code>xdl_merge</code>的流程。<code>xdl_merge</code>做了下面四件事：</p>
<ol>
<li><p>由<code>xdl_do_diff</code>完成two-way diff（ours和ancestor，theirs和ancestor）,生成修改记录，存储到<code>xdfenv_t</code>中。</p></li>
<li><p><code>xdl_change_compact</code>压缩相邻的修改记录，再用<code>xdl_build_script</code>建立xdchange_t链表，记录双方修改。xdchange_t主要包括了修改的起始行号和修改范围。</p></li>
<li><p>这时候分三种情况，其中两种是只有一方有修改（只有ours或theirs一条链表），直接退出。最后一种是双方都有修改，需要合并修改记录。由于修改记录是按行号有序排列的，所以直接合并两个链表。修改记录如果没有重叠部分，按先后顺序标记为我方修改/他方修改。如果发生了重叠，就表示发生了冲突。之后会重新过一遍两个待合并链表，对于那些标记为冲突的部分，比较它们是否相等的，如果是，标记为双方修改。</p></li>
<li><p>由<code>xdl_fill_merge_buffer</code>输出合并结果。如果有冲突，调用<code>fill_conflict_hunk</code>输出冲突情况。如果没有冲突（标记为我方修改/他方修改/双方修改），则合并ancestor的原内容和修改记录，按标记的类型取修改后的内容，并输出。</p></li>
</ol>
<p>输出冲突情况的代码位于<code>fill_conflict_hunk</code>中。它的实现很简单，毕竟此时我们已经有了双方修改的内容，现在只需要同时输出冲突内容，供用户取舍。（这便是那次花了一个晚上和一个早上改掉的冲突的源头，凶手就是你，哼）。</p>
<p>输出格式恐怕大家都很熟悉。该函数会先打印若干个<code>&lt;</code>，个数由DEFAULT_CONFLICT_MARKER_SIZE决定，也即是7个。然后是ours分支名。接着输出我方的修改，然后输出若干个<code>=</code>。最后是他方的修改，以及若干个<code>&gt;</code>。这个就是折磨人的合并冲突了：</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
3
=======
2
&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch1</code></pre>
<h2>总结</h2>
<p>git merge的冲突判定机制如下：先寻找两个commit的公共祖先，比较同一个文件分别在ours和theirs下对于公共祖先的差异，然后合并这两组差异。如果双方同时修改了一处地方且修改内容不同，就判定为合并冲突，依次输出双方修改的内容。</p>

                ", git merge是怎样判定冲突的？,1531978020,426,1,666,1,1,https://segmentfault.com/a/1190000003966242
245,1,0,7,"
                    
<h2>Git配置</h2>
<p><span class=""img-wrap""><img data-src=""http://7xnxzw.com1.z0.glb.clouddn.com/git%E9%85%8D%E7%BD%AE.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git配置"" title=""git配置""></span></p>
<h2>基本使用流程</h2>
<p><span class=""img-wrap""><img data-src=""http://7xnxzw.com1.z0.glb.clouddn.com/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""基本使用流程"" title=""基本使用流程""></span></p>
<h2>文件管理</h2>
<p><span class=""img-wrap""><img data-src=""http://7xnxzw.com1.z0.glb.clouddn.com/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""文件管理"" title=""文件管理""></span></p>
<h2>分支管理</h2>
<p><span class=""img-wrap""><img data-src=""http://7xnxzw.com1.z0.glb.clouddn.com/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""文件管理"" title=""文件管理""></span></p>
<h2>标签管理</h2>
<p><span class=""img-wrap""><img data-src=""http://7xnxzw.com1.z0.glb.clouddn.com/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""标签管理"" title=""标签管理""></span></p>

                ", Git基本命令学习,1531978021,264,1,159,1,1,https://segmentfault.com/a/1190000003965799
246,1,0,7,"
                    
<p>用 git 用着用着手残了？没事，还好 git 给我们机会重新来过，这里记录了一些修改 git 的历史提交记录的方式，从此再也不怕手残~</p>
<h3>初级选手 <code>git amend</code>
</h3>
<p>如果仅仅是在提交之后发现自己手残了，用<code>git commit --amend</code>就可以修改刚才的那一次提交。该命令在执行以后，会将刚刚的那一次提交从当前分支移除，把工作空间恢复到上次准备提交的状态（同时混合了上次提交之后的更改），然后显示出一个 vim 的界面让你去修改上次的提交信息。在vim 中保存后，就会把当前的所有修改一并用新的提交信息提交了。</p>
<p>该命令仅仅可以修改最后一次提交，一个命令相当于执行了如下一系列动作：</p>
<pre><code>    $ORIG_HEAD=`git show`#保存当前的这次提交的 commit 号
    $git reset --soft HEAD^#回到最后一次提交准备提交前的状态
    $...#做一些操作和修改
    $git commit -c $ORIG_HEAD#表示用最后一次提交的提交信息来做为提交信息，不过会调出编辑器界面</code></pre>
<h3>中级选手 <code>git rebase</code>
</h3>
<p>前面的<code>git commit --amend</code>仅仅可以修改最后一次提交，但是当自己一时兴起，手残了一路时，这个命令就无法拯救我们了，这个时候我们就要祭出<code>git rebase -i</code> 这个大杀器来帮我们修改那些不堪回首的往事。</p>
<p>实际上，<code>git rebase -i</code>并不是一个专门用来修改历史记录的命令，而是一个让我们可以交互式（就是一个个来） 进行衍合操作的命令，不过我们可以用这个命令来实现对于提交历史的修改。</p>
<p>该命令的使用方法是<code>git rebase -i &lt;指定提交号&gt;</code>,比如可以用<code>git rebase -i HEAD~3</code>来修改本次提交、上次提交、上上次提交共三次提交。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009755438?w=545&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>如图，我如果向修改这三次提交，输入<code>git rebase -i HEAD~3</code>，就会出现如下的界面：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009755439?w=593&amp;h=433"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>这是一个 vim 编辑器的界面，这里是让我们编辑这一段脚本，可以使用的命令有下方注释中的六个命令。当退出当前编辑其的页面后，git 就会根据这个脚本一个个的针对提交执行对应的操作（从最早的那次提交开始执行）。</p>
<p>如果仅仅是想修改提交信息，就把所有的 <em>pick</em> 改成 <em>r</em> ，然后<code>:wq</code>保存，接下来 <em>git</em>  就会让你一个个的从最早的提交信息开始修改。</p>
<p>剩余的命令中， <em>e</em> 是会在修改对应提交时跳出 <em>vim</em> 编辑器，此时 <em>HEAD</em> 指针指向这次提交，此时可以用<code>git commit --amend</code>对这次提交进行各种修改，然后执行 <code>git rebase --continue</code>就会继续下一次操作；<em>s</em> 则是会在修改对应提交的时候把这次的提交和其父提交合并为一次提交；<em>f</em> 是和<em>s</em>类似但是会忽略当前提交的信息，直接采用父提交的信息；<em>x</em> 是需要在 x 之后输入命令然后在 <em>HEAD</em> 指向这次提交的时候执行。利用这些命令还可以完成<a href=""https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#%E9%87%8D%E6%8E%92%E6%8F%90%E4%BA%A4"" rel=""nofollow noreferrer"">重排提交</a>、<a href=""https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#%E6%8B%86%E5%88%86%E6%8F%90%E4%BA%A4"" rel=""nofollow noreferrer"">拆分提交</a>的动作。</p>
<h3>终极杀手 <code>git filter-branch</code>
</h3>
<p>假如说我们提交了 N 多次以后，突然发现我们这些提交的邮箱都写错了(╯°□°）╯︵ ┻━┻，这个时候如果使用之前提到的命令，估计还没改完就要累死了。这个时候我们就可以使用<code>git filter-branch</code>来重写分支，其可以批量的对每个提交执行我们预设的操作。</p>
<p><code>git filter-branch</code>命令使用的基本使用格式是<code>git filter-branch --&lt;各种filer&gt; '命令' &lt;修改的范围&gt;</code> ，不同的 <em>filter</em> 会提供给命令不同的输入和输出。比如，<code>--msg-filter</code>表示修改提交信息，原提交信息从标准输入读入，新提交信息输出到标准输出；<code>--tree-filter</code>表示修改文件列表等等。最后会有一个重写的范围。比如，<code>git filter-branch --env-filter 'GIT_AUTHOR_EMAIL=john@example.com export GIT_AUTHOR_EMAIL' HEAD</code> 就可以用来重写邮箱。建议在调用命令之前先啦出一个分支做尝试再在自己要修改的分支上执行操作。</p>
<p>如果想知道更多关于该命令的信息和栗子，请戳<a href=""https://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html"" rel=""nofollow noreferrer"">这里</a>和<a href=""https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#%E6%A0%B8%E5%BC%B9%E7%BA%A7%E9%80%89%E9%A1%B9:-filter-branch"" rel=""nofollow noreferrer"">这里</a>。</p>

                ", 如何修改 git 记录？,1531978023,239,1,338,1,1,https://segmentfault.com/a/1190000003947100
247,1,0,7,"
                    
<p>好久没更新文章了，这边都快成荒地了。今天想到一个比较简单的问题，所以先处理了写篇文章上来，好给blog加点生机（<del>其实post里躺着不少草稿，不过一直没办法写完╮(╯▽╰)╭</del>）</p>
<p>很早之前我就记得某篇讲hexo的文章里提到<strong>每个GitHub只能拥有一个GitHub Pages页面</strong>，所以后来一直不敢在自己的帐号底下添加除blog外的其他GitHub Pages项目。直到今天仔细研究了下GitHub的规则，才发现上面那句话有很大的问题。</p>
<p>这篇文章主要是讲github下多个GitHub Pages项目相关以及自定义域名访问的问题，没太多技术上的东西，基本上都是属于GitHub的文档意译和解释，英语好的可以直接看这官网这两篇FAQ：</p>
<ol>
<li><p><a href=""https://help.github.com/articles/about-custom-domains-for-github-pages-sites/"" rel=""nofollow noreferrer"">About custom domains for GitHub Pages sites</a></p></li>
<li><p><a href=""https://help.github.com/articles/user-organization-and-project-pages/"" rel=""nofollow noreferrer"">User, Organization, and Project Pages</a></p></li>
</ol>
<hr>
<p>注：虽然全文基本上都在讲GitHub Pages，<strong>但我个人亲测这些规则也都适用于GitCafe Pages,两者没有本质区别。</strong> 所以像我一样双线部署blog的可以安心地把GitHub的东西搬到GitCafe来。不过为了行文方便，下文不再特意强调GitCafe Page，均以<code>GitHub Pages</code>代指(""Coding""的是否也如此并不清楚，有心人可以自测)</p>
<h2>场景</h2>
<p>以我个人为例，我在GitHub上已经有了一个和用户名同名的<a href=""https://github.com/chitanda/chitanda.github.io"" rel=""nofollow noreferrer"">GitHub Pages项目</a>当作个人主页(<a href=""http://chitanda.github.io"" rel=""nofollow noreferrer"">chitanda.github.io</a>),但是我现在又有了几个想法:</p>
<ol>
<li><p>再在GitHub上弄一个GitHub Pages项目当作我的demo页面展示,而不是在原先的blog项目下加子目录(一来访问url不好看，二来很多主题会强制对所有项目内的文件添加样式，影响展示效果)</p></li>
<li><p>同时demo页面的访问链接是我自定义的一个域名(如：是<code>demo.chitanda.me</code>或者<code>demo.chitanda.github.io</code>而不是<code>chitanda.github.io/demo</code>)</p></li>
</ol>
<p>那么上面两个要求，GitHub能否都满足呢？卖个关子先，结论放在<a>下文</a>。</p>
<h2>GitHub Pages的分类及区别</h2>
<p>根据<a href=""https://help.github.com/articles/user-organization-and-project-pages/"" rel=""nofollow noreferrer"">官方文档</a>，GitHub Pages分为两类:<strong>个人/组织主页</strong>以及<strong>项目主页</strong>，两者基本上没啥区别，但是有以下几点不同:（该文场景下个人和组织帐号没什么区别，所以下文为了行文方便将统一用<strong>个人主页</strong>代指）</p>
<ol>
<li><p><strong>个人主页</strong>必须要和用户的GitHub帐号同名，所以每个用户有且只能有一个repo作为个人主页，且必须是<code>&lt;username&gt;/&lt;username&gt;.github.io</code>的形式；而<strong>项目主页</strong>的命名则没有这种限制，且数量有任意多个。</p></li>
<li><p>不考虑绑定的自定义域名的前提下，<strong>个人主页</strong>的GitHub二级域名为<code>&lt;username&gt;.github.io</code>;<strong>项目主页</strong>的GitHub二级域名为<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>,没有<code>&lt;projectname&gt;.&lt;username&gt;.github.io</code>这种方式</p></li>
<li><p><strong>个人主页</strong>的展示内容以<code>master</code>分支里的文件为准；而<strong>项目主页</strong>的展示内容以<code>gh-pages</code>分支内的文件为准</p></li>
</ol>
<blockquote><p>从上面的分析可以发现两个问题已经解决掉一个半了。那么剩下来的问题就是如何配置一个项目主页并绑定自定义域名了。</p></blockquote>
<h2>项目主页的建立和自定义域名配置</h2>
<p><strong>注：配置过程和个人主页一模一样，如果之前配置过个人主页的，可以跳过这部分内容了</strong></p>
<h3>建立项目主页</h3>
<ol>
<li><p>新建一个repo，repo名字随意。</p></li>
<li><p>点进repo主页然后点击右面的<code>Settings</code>，页面往下拉到<strong>GitHub Pages</strong>部分，选择<code>Launch automatic page generator</code>&gt;<code>Continue to layouts</code>&gt;<code>Publish page</code>即可.（由于大部分情况下并不用默认的页面和样式，所以这里不需要太纠结于内容编辑）</p></li>
</ol>
<blockquote><p>这样一个项目主页就建立完成了，此时可以用<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>访问到了。</p></blockquote>
<h3>绑定自定义域名</h3>
<ol><li><p>在项目的repo里新建一个<code>CNAME</code>文件，并将不带协议名的裸域名写进去(<code>demo.chitanda.me</code>而不是<code>http://demo.chitanda.me/</code>)</p></li></ol>
<blockquote><p>这一步可以参考<a href=""https://help.github.com/articles/adding-a-cname-file-to-your-repository/"" rel=""nofollow noreferrer"">官方文档</a></p></blockquote>
<ol>
<li><p>到你域名的DNS服务商里给对应的二级域名添加<code>CNAME</code>解析到<code>&lt;username&gt;.github.io</code>(和个人主页的配置相同)</p></li>
<li><p>等待DNS生效，具体时间和服务商有关（十几分钟到几小时都有可能）。</p></li>
</ol>
<blockquote><p>如果不确定自己的解析是否生效了，可以在linux系统下用<code>dig</code>命令来检测.参考<a href=""https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider/#configuring-a-custom-subdomain-with-your-dns-provider"" rel=""nofollow noreferrer"">官方文档</a></p></blockquote>
<h2>GitHub和GitCafe双线部署的小tips</h2>
<p>上面的配置对于单线部署的来说已经完成了，不过对于双线部署的用户而言，有几个小问题需要注意下</p>
<ol>
<li><p>DNS服务商里要按照来源对对应的二级域名做分流配置。（具体过程可以参考<a href=""http://chitanda.me/2015/06/11/tips-for-setup-hexo/#%E5%8D%95%E5%9F%9F%E5%90%8D%E5%A4%9A%E7%BA%BF%E8%B7%AF%E8%A7%A3%E6%9E%90"" rel=""nofollow noreferrer"">此处</a></p></li>
<li><p>如果想要所有用户都可以用<code>example.com/project</code>的方式访问到repo，GitHub和GitCafe的repo名字必须相同，否则会导致有一边跳404</p></li>
</ol>
<blockquote><p>可以参考我这里的例子:GitHub上的<a href=""https://github.com/chitanda/demo"" rel=""nofollow noreferrer"">项目主页</a>名字为<code>demo</code>,GitCafe上的<a href=""https://gitcafe.com/chitanda/demos"" rel=""nofollow noreferrer"">项目主页</a>名字为<code>demos</code>,则不翻墙的情况下国内用户访问<a href=""http://chitanda.me/demo/"" rel=""nofollow noreferrer"">chitanda.me/demo</a>会跳404,而用<a href=""http://demo.chitanda.me/"" rel=""nofollow noreferrer"">demo.chitanda.me</a>则正常(另外同个链接在翻墙和不翻墙的情况下看到的页面不同，也是分线部署的功劳)</p></blockquote>
<h2>总结</h2>
<p>聊胜于无的总结。对于上面提到的几个问题，也有了答案：</p>
<ol>
<li><p>每个GitHub帐号下只能有<code>1</code>个<strong>个人主页</strong>repo，但是可以有<code>不限数量</code>的<strong>项目主页</strong>repo。</p></li>
<li><p>没有自定义域名的情况下，<strong>项目主页</strong>的访问链接只能是<code>&lt;username&gt;.github.io/&lt;projectname&gt;</code>而不是<code>&lt;projectname&gt;.&lt;username&gt;.github.io</code></p></li>
<li><p>GitCafe添加GitHub Pages后必须要自己本地同步文件上去，而不能像GitHub那样一键建站，GitCafe每个repo初始化页面的代码是有步骤略过去的，新手的话一开始可能同步不了。建议看他们的<a href=""https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki"" rel=""nofollow noreferrer"">帮助</a></p></li>
</ol>
<h2>参考文献</h2>
<ol>
<li><p><a href=""https://help.github.com/articles/about-custom-domains-for-github-pages-sites/"" rel=""nofollow noreferrer"">About custom domains for GitHub Pages sites</a></p></li>
<li><p><a href=""https://help.github.com/articles/user-organization-and-project-pages/"" rel=""nofollow noreferrer"">User, Organization, and Project Pages</a></p></li>
<li><p><a href=""https://help.github.com/articles/adding-a-cname-file-to-your-repository/"" rel=""nofollow noreferrer"">Adding a CNAME file to your repository</a></p></li>
<li><p><a href=""https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider/#configuring-a-custom-subdomain-with-your-dns-provider"" rel=""nofollow noreferrer"">Tips for configuring a CNAME record with your DNS provider</a></p></li>
<li><p><a href=""https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9"" rel=""nofollow noreferrer"">GitCage Pages-相关帮助</a></p></li>
<li><p><a href=""http://chitanda.me/2015/06/11/tips-for-setup-hexo/#%E5%8D%95%E5%9F%9F%E5%90%8D%E5%A4%9A%E7%BA%BF%E8%B7%AF%E8%A7%A3%E6%9E%90"" rel=""nofollow noreferrer"">单域名多线路解析</a></p></li>
</ol>
<hr>

                ", 单个GitHub帐号下添加多个GitHub Pages的相关问题,1531978024,235,1,297,1,1,https://segmentfault.com/a/1190000003946969
248,1,0,7,"
                    
<h2>Android MVP Pattern</h2>
<p>Android <strong>MVP 模式</strong><sup><a class=""footnote-ref"">1</a></sup> 也不是什么新鲜的东西了，我在自己的项目里也普遍地使用了这个设计模式。当项目越来越庞大、复杂，参与的研发人员越来越多的时候，<strong>MVP 模式</strong>的优势就充分显示出来了。</p>
<blockquote><p>导读：MVP模式是MVC模式在Android上的一种变体，要介绍MVP就得先介绍MVC。在MVC模式中，Activity应该是属于View这一层。而实质上，它既承担了View，同时也包含一些Controller的东西在里面。这对于开发与维护来说不太友好，耦合度大高了。把Activity的View和Controller抽离出来就变成了View和Presenter，这就是MVP模式。</p></blockquote>
<h2>基本信息</h2>
<ul>
<li><p>作者：<a href=""http://kaedea.com"" rel=""nofollow noreferrer"">Kaede</a></p></li>
<li><p>项目：<a href=""https://github.com/kaedea/Android-MVP-Pattern"" rel=""nofollow noreferrer"">Android-MVP-Pattern</a></p></li>
<li><p>出处：<a href=""http://kaedea.com/2015/10/11/android-mvp-pattern"" rel=""nofollow noreferrer"">Android MVP模式 简单易懂的介绍方式</a></p></li>
</ul>
<p>MVP模式（Model-View-Presenter）可以说是MVC模式（Model-View-Controller）在Android开发上的一种变种、进化模式。后者大家可能比较熟悉，就算不熟悉也可能或多或少地在自己的项目中用到过。要介绍MVP模式，就不得不先说说MVC模式。</p>
<h2>MVC模式</h2>
<p>MVC模式的结构分为三部分，实体层的Model，视图层的View，以及控制层的Controller。</p>
<p><span class=""img-wrap""><img data-src=""http://7xih5c.com1.z0.glb.clouddn.com/15-10-11/13126761.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MVC结构"" title=""MVC结构""></span></p>
<ul>
<li><p>其中View层其实就是程序的UI界面，用于向用户展示数据以及接收用户的输入</p></li>
<li><p>而Model层就是JavaBean实体类，用于保存实例数据</p></li>
<li><p>Controller控制器用于更新UI界面和数据实例</p></li>
</ul>
<p>例如，View层接受用户的输入，然后通过Controller修改对应的Model实例；同时，当Model实例的数据发生变化的时候，需要修改UI界面，可以通过Controller更新界面。（View层也可以直接更新Model实例的数据，而不用每次都通过Controller，这样对于一些简单的数据更新工作会变得方便许多。）</p>
<p>举个简单的例子，现在要实现一个飘雪的动态壁纸，可以给雪花定义一个实体类Snow，里面存放XY轴坐标数据，View层当然就是SurfaceView（或者其他视图），为了实现雪花飘的效果，可以启动一个后台线程，在线程里不断更新Snow实例里的坐标值，这部分就是Controller的工作了，Controller里还要定时更新SurfaceView上面的雪花。进一步的话，可以在SurfaceView上监听用户的点击，如果用户点击，只通过Controller对触摸点周围的Snow的坐标值进行调整，从而实现雪花在用户点击后出现弹开等效果。具体的MVC模式请自行Google。</p>
<h2>MVP模式</h2>
<p>在Android项目中，Activity和Fragment占据了大部分的开发工作。如果有一种设计模式（或者说代码结构）专门是为优化Activity和Fragment的代码而产生的，你说这种模式重要不？这就是MVP设计模式。</p>
<p>按照MVC的分层，Activity和Fragment（后面只说Activity）应该属于View层，用于展示UI界面，以及接收用户的输入，此外还要承担一些生命周期的工作。Activity是在Android开发中充当非常重要的角色，特别是TA的生命周期的功能，所以开发的时候我们经常把一些业务逻辑直接写在Activity里面，这非常直观方便，代价就是Activity会越来越臃肿，超过1000行代码是常有的事，而且如果是一些可以通用的业务逻辑（比如用户登录），写在具体的Activity里就意味着这个逻辑不能复用了。如果有进行代码重构经验的人，看到1000+行的类肯定会有所顾虑。因此，Activity不仅承担了View的角色，还承担了一部分的Controller角色，这样一来V和C就耦合在一起了，虽然这样写方便，但是如果业务调整的话，要维护起来就难了，而且在一个臃肿的Activity类查找业务逻辑的代码也会非常蛋疼，所以看起来有必要在Activity中，把View和Controller抽离开来，而这就是MVP模式的工作了。</p>
<p><span class=""img-wrap""><img data-src=""http://7xih5c.com1.z0.glb.clouddn.com/15-10-11/2114527.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MVP结构"" title=""MVP结构""></span></p>
<p>MVP模式的核心思想：</p>
<blockquote><p><strong>MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model</strong>。</p></blockquote>
<p>这就是MVP模式，现在这样的话，Activity的工作的简单了，只用来响应生命周期，其他工作都丢到Presenter中去完成。从上图可以看出，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。</p>
<h2>MVP模式的作用</h2>
<p>MVP的好处都有啥，谁说对了就给他 KIRA!!(&lt;ゝω·)☆</p>
<ul>
<li><p>分离了视图逻辑和业务逻辑，降低了耦合</p></li>
<li><p>Activity只处理生命周期的任务，代码变得更加简洁</p></li>
<li><p>视图逻辑和业务逻辑分别抽象到了View和Presenter的接口中去，提高代码的可阅读性</p></li>
<li><p>Presenter被抽象成接口，可以有多种具体的实现，所以方便进行单元测试</p></li>
<li><p>把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起内存泄露和OOM</p></li>
</ul>
<p>其中最重要的有三点：</p>
<h3>Activity 代码变得更加简洁</h3>
<p>相信很多人阅读代码的时候，都是从Activity开始的，对着一个1000+行代码的Activity，看了都觉得难受。</p>
<p>使用MVP之后，Activity就能瘦身许多了，基本上只有FindView、SetListener以及Init的代码。其他的就是对Presenter的调用，还有对View接口的实现。这种情形下阅读代码就容易多了，而且你只要看Presenter的接口，就能明白这个模块都有哪些业务，很快就能定位到具体代码。Activity变得容易看懂，容易维护，以后要调整业务、删减功能也就变得简单许多。</p>
<h3>方便进行单元测试</h3>
<p>一般单元测试都是用来测试某些新加的业务逻辑有没有问题，如果采用传统的代码风格（习惯性上叫做MV模式，少了P），我们可能要先在Activity里写一段测试代码，测试完了再把测试代码删掉换成正式代码，这时如果发现业务有问题又得换回测试代码，咦，测试代码已经删掉了！好吧重新写吧……</p>
<p>MVP中，由于业务逻辑都在Presenter里，我们完全可以写一个PresenterTest的实现类继承Presenter的接口，现在只要在Activity里把Presenter的创建换成PresenterTest，就能进行单元测试了，测试完再换回来即可。万一发现还得进行测试，那就再换成PresenterTest吧。</p>
<h3>避免 Activity 的内存泄露</h3>
<p>Android APP 发生OOM的最大原因就是出现内存泄露造成APP的内存不够用，而造成内存泄露的两大原因之一就是Activity泄露（Activity Leak）（另一个原因是Bitmap泄露（Bitmap Leak））。</p>
<blockquote><p>Java一个强大的功能就是其虚拟机的内存回收机制，这个功能使得Java用户在设计代码的时候，不用像C++用户那样考虑对象的回收问题。然而，Java用户总是喜欢随便写一大堆对象，然后幻想着虚拟机能帮他们处理好内存的回收工作。可是虚拟机在回收内存的时候，只会回收那些没有被引用的对象，被引用着的对象因为还可能会被调用，所以不能回收。</p></blockquote>
<p>Activity是有生命周期的，用户随时可能切换Activity，当APP的内存不够用的时候，系统会回收处于后台的Activity的资源以避免OOM。</p>
<p>采用传统的MV模式，一大堆异步任务和对UI的操作都放在Activity里面，比如你可能从网络下载一张图片，在下载成功的回调里把图片加载到 Activity 的 ImageView 里面，所以异步任务保留着对Activity的引用。这样一来，即使Activity已经被切换到后台（onDestroy已经执行），这些异步任务仍然保留着对Activity实例的引用，所以系统就无法回收这个Activity实例了，结果就是Activity Leak。Android的组件中，Activity对象往往是在堆（Java Heap）里占最多内存的，所以系统会优先回收Activity对象，如果有Activity Leak，APP很容易因为内存不够而OOM。</p>
<p>采用MVP模式，只要在当前的Activity的onDestroy里，分离异步任务对Activity的引用，就能避免 Activity Leak。</p>
<p>说了这么多，没看懂？好吧，我自己都没看懂自己写的，我们还是直接看代码吧。</p>
<h2>MVP模式的使用</h2>
<p><span class=""img-wrap""><img data-src=""http://7xih5c.com1.z0.glb.clouddn.com/15-10-12/94032090.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""简单MVP的UML"" title=""简单MVP的UML""></span></p>
<p>上面一张简单的MVP模式的UML图，从图中可以看出，使用MVP，至少需要经历以下步骤：</p>
<ol>
<li><p>创建IPresenter接口，把所有业务逻辑的接口都放在这里，并创建它的实现PresenterCompl（在这里可以方便地查看业务功能，由于接口可以有多种实现所以也方便写单元测试）</p></li>
<li><p>创建IView接口，把所有视图逻辑的接口都放在这里，其实现类是当前的Activity/Fragment</p></li>
<li><p>由UML图可以看出，Activity里包含了一个IPresenter，而PresenterCompl里又包含了一个IView并且依赖了Model。Activity里只保留对IPresenter的调用，其它工作全部留到PresenterCompl中实现</p></li>
<li><p>Model并不是必须有的，但是一定会有View和Presenter</p></li>
</ol>
<p>通过上面的介绍，MVP的主要特点就是把Activity里的许多逻辑都抽离到View和Presenter接口中去，并由具体的实现类来完成。这种写法多了许多IView和IPresenter的接口，在某种程度上加大了开发的工作量，刚开始使用MVP的小伙伴可能会觉得这种写法比较别扭，而且难以记住。其实一开始想太多也没有什么卵用，只要在具体项目中多写几次，就能熟悉MVP模式的写法，理解TA的意图，以及享♂受其带来的好处。</p>
<p>扯了这么多，但是好像并没有什么卵用，毕竟</p>
<blockquote><p>Talk is cheap, let me show you the code!</p></blockquote>
<p>所以还是来写一下实际的项目吧。</p>
<h2>MVP模式简单实例</h2>
<p><span class=""img-wrap""><img data-src=""http://7xih5c.com1.z0.glb.clouddn.com/15-10-12/87960424.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Login"" title=""Login""></span></p>
<p>一个简单的登录界面（实在想不到别的了╮(￣▽￣"")╭），点击LOGIN则进行账号密码验证，点击CLEAR则重置输入。</p>
<p><span class=""img-wrap""><img data-src=""http://7xih5c.com1.z0.glb.clouddn.com/15-10-12/63555794.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Login代码结构"" title=""Login代码结构""></span></p>
<p>项目结构看起来像是这个样子的，MVP的分层还是很清晰的。我的习惯是先按模块分Package，在模块下面再去创建<strong>model、view、presenter</strong>的子Package，当然也可以用<strong>model、view、presenter</strong>作为顶级的Package，然后把所有的模块的model、view、presenter类都到这三个顶级Package中，就好像有人喜欢把项目里所有的Activity、Fragment、Adapter都放在一起一样。</p>
<p>首先来看看LoginActivity</p>
<pre><code class=""java"">public class LoginActivity extends ActionBarActivity implements ILoginView, View.OnClickListener {

    private EditText editUser;
    private EditText editPass;
    private Button   btnLogin;
    private Button   btnClear;
    ILoginPresenter loginPresenter;
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //find view
        editUser = (EditText) this.findViewById(R.id.et_login_username);
        editPass = (EditText) this.findViewById(R.id.et_login_password);
        btnLogin = (Button) this.findViewById(R.id.btn_login_login);
        btnClear = (Button) this.findViewById(R.id.btn_login_clear);
        progressBar = (ProgressBar) this.findViewById(R.id.progress_login);

        //set listener
        btnLogin.setOnClickListener(this);
        btnClear.setOnClickListener(this);

        //init
        loginPresenter = new LoginPresenterCompl(this);
        loginPresenter.setProgressBarVisiblity(View.INVISIBLE);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.btn_login_clear:
                loginPresenter.clear();
                break;
            case R.id.btn_login_login:
                loginPresenter.setProgressBarVisiblity(View.VISIBLE);
                btnLogin.setEnabled(false);
                btnClear.setEnabled(false);
                loginPresenter.doLogin(editUser.getText().toString(), editPass.getText().toString());
                break;
        }
    }

    @Override
    public void onClearText() {
        editUser.setText("""");
        editPass.setText("""");
    }

    @Override
    public void onLoginResult(Boolean result, int code) {
        loginPresenter.setProgressBarVisiblity(View.INVISIBLE);
        btnLogin.setEnabled(true);
        btnClear.setEnabled(true);
        if (result){
            Toast.makeText(this,""Login Success"",Toast.LENGTH_SHORT).show();
            startActivity(new Intent(this, HomeActivity.class));
        }
        else
            Toast.makeText(this,""Login Fail, code = "" + code,Toast.LENGTH_SHORT).show();
    }


    @Override
    public void onSetProgressBarVisibility(int visibility) {
        progressBar.setVisibility(visibility);
    }
}</code></pre>
<p>从代码可以看出LoginActivity只做了findView以及setListener的工作，而且包含了一个ILoginPresenter，所有业务逻辑都是通过调用ILoginPresenter的具体接口来完成。所以LoginActivity的代码看起来很舒爽，甚至有点愉♂悦呢 (/ω＼*)。视力不错的你可能还看到了ILoginView接口的实现，如果不懂为什么要这样写的话，可以先往下看，这里只要记住<strong>LoginActivity实现了ILoginView接口</strong>。</p>
<p>再来看看ILoginPresenter</p>
<pre><code class=""java"">public interface ILoginPresenter {
    void clear();
    void doLogin(String name, String passwd);
    void setProgressBarVisiblity(int visiblity);
}</code></pre>
<pre><code class=""java"">public class LoginPresenterCompl implements ILoginPresenter {
    ILoginView iLoginView;
    IUser user;
    Handler    handler;

    public LoginPresenterCompl(ILoginView iLoginView) {
        this.iLoginView = iLoginView;
        initUser();
        handler = new Handler(Looper.getMainLooper());
    }

    @Override
    public void clear() {
        iLoginView.onClearText();
    }

    @Override
    public void doLogin(String name, String passwd) {
        Boolean isLoginSuccess = true;
        final int code = user.checkUserValidity(name,passwd);
        if (code!=0) isLoginSuccess = false;
        final Boolean result = isLoginSuccess;
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                iLoginView.onLoginResult(result, code);
            }
        }, 3000);

    }

    @Override
    public void setProgressBarVisiblity(int visiblity){
        iLoginView.onSetProgressBarVisibility(visiblity);
    }

    private void initUser(){
        user = new UserModel(""mvp"",""mvp"");
    }
}</code></pre>
<p>从代码可以看出，LoginPresenterCompl保留了ILoginView的引用，因此在LoginPresenterCompl里就可以直接进行UI操作了，而不用在Activity里完成。这里使用了ILoginView引用，而不是直接使用Activity，这样一来，如果在别的Activity里也需要用到相同的业务逻辑，就可以直接复用LoginPresenterCompl类了（一个Activity可以包含一个以上的Presenter，总之，需要什么业务就new什么样的Presenter，是不是很灵活（＠￣︶￣＠）），这也是MVP的核心思想</p>
<blockquote><p>通过IVIew和IPresenter，把Activity的<code>UI Logic</code>和<code>Business Logic</code>分离开来，Activity just does its basic job! 至于Model嘛，还是原来MVC里的Model。</p></blockquote>
<p>再来看看ILoginView，至于ILoginView的实现类呢，翻到上面看看LoginActivity吧</p>
<pre><code class=""java"">public interface ILoginView {
    public void onClearText();
    public void onLoginResult(Boolean result, int code);
    public void onSetProgressBarVisibility(int visibility);
}</code></pre>
<p>代码这种东西放在日志里讲好像除了把整个版面拉长没什么卵用，我把几种自己常用的MVP的写法写成一个Demo项目，欢迎围观和PullRequest：<a href=""https://github.com/kaedea/Android-MVP-Pattern"" rel=""nofollow noreferrer"">Android-MVP-Pattern</a>。</p>
<h2>后记</h2>
<p>以上就是我的MVP模式的一点理解，在MVVM模式还没有成熟的现在，我觉得没有比MVP模式更好的替代品了。当然今天写的只是MVP的基础使用，介绍的实例项目也非常简单，看不出MVP的优势，后面还会针对MVP模式写一些日志，就目前能想到的至少包括</p>
<ul>
<li><p>Android常规的开发模式经常被称为MV模式（Model-View），引入数据绑定后的MVVM模式（Model-View-ViewModel），与MVP模式的区别</p></li>
<li><p>目前我们写ListView的Adapter都喜欢把它写成一个内部类，如果有两个Activity里要用同一个Adapter就比较难了，通过MVP模式，能轻松地复用Adapter（你说已经不用ListView了，这不是重点不是么( ˃◡˂ )）</p></li>
<li><p>MVP模式需要多写许多新的接口，这也是其缺点所在，经过一段时间的实战，我自己已有一种优化的MVP模式，我会试着总结一下，把她拿出来说说</p></li>
</ul>
<hr>
<ol><li> 我也纠结过<strong>MVP模式</strong>或者<strong>MVP结构</strong>的说法那个跟准确一点，国外普遍的叫法是直接叫<strong>Android MVP</strong>，除此之外有叫<strong>MVP Pattern</strong>的也有叫<strong>MVP Framework/Architecture</strong>，个人认为这应该算是一种代码风格（Code Style），在分类上应该比较类似设计模式（Design Pattern），所以现在我一般称为模式，不过这不是重点，不是吗。( ˃◡˂ ) <a class=""footnote-backref"">↩</a>
</li></ol>

                ", Android MVP模式 简单易懂的介绍方式,1531978026,148,1,367,1,1,https://segmentfault.com/a/1190000003927200
249,1,0,7,"
                    
<blockquote><p>原文发表于 <a href=""http://ourai.ws/posts/deployment-with-git-hooks/"" rel=""nofollow noreferrer"">http://ourai.ws/posts/deployment-with-git-hooks/</a></p></blockquote>
<p>昨天开始接手开发公司前端团队的主页，在稍微修改点东西后推送到远程仓库想看下线上结果时发现并没有更改！询问一把手得知，居然还需要连接到服务器执行一下 <code>git pull</code> 才行……对于我这种怕麻烦的人来说，简直不能忍！</p>
<p>经过一番查找资料以及一顿折腾，终于让它能够自动跑起来了，真是高兴得我手舞足蹈啊！虽然弄了较长时间，在实践的过程中踩了点坑，但回过头来一看还是挺简单的。总的来说，就只是在服务器和本机都做一下配置。（这不废话么……）</p>
<p>由于公司的服务器是 CentOS，我所使用的电脑是 Mac OS X，故本文内容是基于这两个系统环境所写。GUI 在给用户带来很多便利的同时也隐藏了一些不便，如：需要下载应用软件及在操作界面交互。鉴于本文的中心是「自动化」，所以一切操作都采用命令行——</p>
<h2>远程连接服务器</h2>
<p>在搭建环境的整个过程中，有很多步骤是需要连接到服务器进行的，然而在每次访问的时候都需要输入用户名和密码，就像逢年过节回家聚会都会被亲戚朋友询问「什么时候结婚呀」「何时抱小孩啊」。这就是为什么要把这步放到前面——在自己脑门上写上计划的结婚生子时间，省得他们总问！</p>
<h3>生成 SSH 密钥</h3>
<p>密钥是免登录连接服务器的通行证，有种刷脸通行的感觉。<strong>如果本地已经存在并且不想另外生成的话，可以跳过此步。</strong></p>
<p><code>cd ~/.ssh</code> 切换目录后用 <code>ssh-keygen -t rsa -C ""用于区分密钥的标识""</code> 生成一对具有相同名字的密钥（默认为 <code>id_rsa</code> 和 <code>id_rsa.pub</code>）：用于本地的私钥和用于服务器的公钥（有 <code>.pub</code> 扩展名）。</p>
<p>如果私钥名字不是默认的话，需要手动加入到被「认证」的私钥列表中，否则每次连接服务器都会提示输入服务器的密码。在遇到了一些坑（文后有说明）后，我觉得设置 SSH config 最为靠谱！</p>
<p>编辑 <code>~/.ssh/config</code> 文件（如果不存在则 <code>touch ~/.ssh/config</code> 创建一下），添加以下内容：</p>
<pre><code class=""sh"">Host HOST_ALIAS                       # 用于 SSH 连接的别名，最好与 HostName 保持一致
  HostName SERVER_DOMAIN              # 服务器的域名或 IP 地址
  Port SERVER_PORT                    # 服务器的端口号，默认为 22，可选
  User SERVER_USER                    # 服务器的用户名
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/PRIVATE_KEY     # 本机上存放的私钥路径</code></pre>
<h3>服务器端认证</h3>
<p>先用 <code>pbcopy &lt; ~/.ssh/PRIVATE_KEY.pub</code> 将公钥复制到剪贴板；通过 <code>ssh USER@SERVER</code> 访问服务器，这时会提示输入密码（它也许只有这么一次「询问」的机会）；成功登录后 <code>vim ~/.ssh/authorized_keys</code>，在合适的位置 <kbd>cmd</kbd> + <kbd>V</kbd> 并保存退出（同时 <code>exit</code> 退出 SSH 连接）。</p>
<h2>配置 Git 仓库</h2>
<h3>创建服务器端仓库</h3>
<p>服务器上需要配置两个仓库，一个用于代码中转的远程仓库，一个用于用户访问的本地仓库。<strong>这里的「远程仓库」并不等同于托管代码的「中央仓库」</strong>，这两个仓库都是为了自动同步代码并部署网站而存在。</p>
<p>在存放远程仓库的目录中（假设是 <code>/home/USER/repos</code>）执行 <code>git init --bare BRIDGE_REPO.git</code> 会创建一个包含 Git 各种配置文件的「裸仓库」。</p>
<p>切换到存放用户所访问文件的目录（假设为 <code>/home/USER/www</code>，如果不存在则在 <code>/home/USER</code> 中执行 <code>mkdir www</code>）：</p>
<pre><code class=""sh"">git init
git remote add origin ~/repos/BRIDGE_REPO.git
git fetch
git checkout master</code></pre>
<h3>配置 Git Hook</h3>
<p>将目录切换至 <code>/home/USER/repos/BRIDGE_REPO.git/hooks</code>，用 <code>cp post-receive.sample post-receive</code> 复制并重命名文件后用 <code>vim post-receive</code> 修改。其内容大致如下：</p>
<pre><code class=""sh"">#!/bin/sh

unset GIT_DIR

NowPath=`pwd`
DeployPath=""../../www""

cd $DeployPath
git pull origin master

cd $NowPath
exit 0</code></pre>
<p>使用 <code>chmod +x post-receive</code> 改变一下权限后，服务器端的配置就基本完成了。</p>
<h3>更新本机的仓库源</h3>
<p>在原有的（托管代码的）仓库上加入刚才所配置的服务器上的远程仓库的地址为源，以后往那个源推送代码后就会自动部署了。</p>
<h2>总结</h2>
<p>在搭建环境时并没有一帆风顺，磕磕绊绊遇到不少问题，虽然很多不值得一提，但有的点还是有记录并分享的价值的！</p>
<h3>SSH 私钥「认证」</h3>
<p><a href=""http://segmentfault.com/q/1010000000835302/a-1020000000883441"" rel=""nofollow noreferrer"">将生成的私钥进行「认证」有不止一种方式</a>，然而，起初我用的是最挫最不靠谱的 <code>ssh-add ~/.ssh/PRIVATE_KEY</code>——只是在当前 session 有效，一重启就又会被「询问」了！</p>

                ", 用 Git Hooks 进行自动部署,1531978027,553,1,249,1,1,https://segmentfault.com/a/1190000003836345
250,1,0,7,"
                    
<p>给你一年的时间，你会怎样去提高你的水平？？？</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/github-365.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Github 365"" title=""Github 365""></span></p>
<p>正值这难得的sick leave（万恶的空气），码文一篇来记念一个过去的366天里。尽管想的是在今年里写一个可持续的开源框架，但是到底这依赖于一个好的idea。在我的<a href=""http://github.com/phodal/ideas"" rel=""nofollow noreferrer"">Github 孵化器</a> 页面上似乎也没有一个特别让我满意的想法，虽然上面有各种不样有意思的ideas。多数都是在过去的一年是完成的，然而有一些也是还没有做到的。</p>
<h2>说说标题</h2>
<p>尽管一直在Github上连击看上去似乎是没有多大必要的，但是人总得有点追求。如果正是漫无目的，却又想着提高技术的同时，为什么不去试试？毕竟技术非常好、不需要太多练习的人只是少数，似乎这样的人是不存在的。大多数的人都是经过练习之后，才会达到别人口中的“技术好”。</p>
<p>这让我想起了充斥着各种气味的知乎上的一些问题，在一些智商被完虐的话题里，无一不是因为那些人学得比别人早——哪来的天才？所谓的天才，应该是未来的智能生命一般，一出生什么都知道。如果并非如此，那只是说明他练习到位了。</p>
<p>练习不到位便意味着，即使你练习的时候是一万小时的两倍，那也是无济于事的。如果你学得比别人晚，在<strong>很长的一段时间里</strong>(可能直到进棺材)输给别人是必然的——落后就要挨打。就好像我等毕业于一所二本垫底的学校里，如果在过去我一直保持着和别人(各种重点)一样的学习速度，那么我只能一直是Loser。</p>
<p>需要注意的是，对你来说考上二本很难，并不是因为你比别人笨。教育资源分配不均的问题，在某种程度上导致了新的阶级制度的出现。如<a href=""https://www.phodal.com/"" rel=""nofollow noreferrer"">我的首页</a>说的那样: <strong>THE ONLY FAIR IS NOT FAIR</strong>——唯一公平的是它是不公平的。我们可以做的还有很多——<strong>CREATE &amp; SHARE</strong>。真正的不幸是，因为营养不良导致的教育问题。</p>
<p>于是在想明白了很多事的时候起，便有了Re-Practise这样的计划，而365天只是中间的一个产物。</p>
<h2>编程的基础能力</h2>
<p>虽说算法很重要，但是编码才是基础能力。算法与编程在某种程度上是不同的领域，算法编程是在编程上面的一级。算法写得再好，如果别人很难直接拿来复用，在别人眼里就是shit。想出能work的代码一件简单的事，学会对其重构，使之变得更易读就是一件有意义的事。</p>
<p>于是，在某一时刻在Github上创建了一个组织，叫<a href=""https://github.com/artisanstack"" rel=""nofollow noreferrer"">Artisan Stack</a>。当时想的是在Github寻找一些JavaScript项目，对其代码进行重构。但是到底是影响力不够哈，参与的人数比较少。</p>
<h3>重构</h3>
<p>如果你懂得如何写出高可读的代码，那么我想你是不需要这个的，但是这意味着你花了更多的时候在思考上了。当谈论重构的时候，让我想起了TDD(测试驱动开发)。即使不是TDD，那么如果你写着测试，那也是可以重构的。(之前写过一些利用Intellij IDEA重构的文章：<a href=""https://www.phodal.com/blog/intellij-idea-refactor-extract-method/"" rel=""nofollow noreferrer"">提炼函数</a>、<a href=""https://www.phodal.com/blog/intellij-idea-refactor-replace-temp-with-query/"" rel=""nofollow noreferrer"">以查询取代临时变量</a>、<a href=""https://www.phodal.com/blog/thoughtworks-refactor-and-intellij-idea/"" rel=""nofollow noreferrer"">重构与Intellij Idea初探</a>、<a href=""https://www.phodal.com/blog/intellij-idea-refactor-inline-method/"" rel=""nofollow noreferrer"">内联函数</a>)</p>
<p>在各种各样的文章里，我们看到过一些相关的内容，最好的参考莫过于《重构》一书。最基础不过的原则便是函数名，取名字很难，取别人能读懂的名字更难。其他的便有诸如长函数、过大的类、重复代码等等。在我有限的面试别人的经历里，这些问题都是最常见的。</p>
<h3>测试</h3>
<p>而如果没有测试，其他都是扯淡。写好测试很难，写个测试算是一件容易的事。只是有些容易我们会为了测试而测试。</p>
<p>在我写<a href=""https://github.com/echoesworks/echoesworks"" rel=""nofollow noreferrer"">EchoesWorks</a>和<a href=""https://github.com/phodal/lan"" rel=""nofollow noreferrer"">Lan</a>的过程中，我尽量去保证足够高的测试覆盖率。</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/lan.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""lan"" title=""lan""></span></p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/echoesworks.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""EchoesWorks"" title=""EchoesWorks""></span></p>
<p>从测试开始的TDD，会保证方法是可测的。从功能到测试则可以提供工作次效率，但是只会让测试成为测试，而不是代码的一部分。</p>
<p>测试是代码的最后一公里。所以，尽可能的为你的Github上的项目添加测试。</p>
<h3>编码的过程</h3>
<p>初到TW时，Pair时候总会有人教我如何开始编码，这应该也是一项基础的能力。结合日常，重新演绎一下这个过程：</p>
<ol>
<li><p>有一个可衡量、可实现、过程可测的目标</p></li>
<li><p>Tasking (即对要实现的目标过程进行分解)</p></li>
<li><p>一步步实现 (如TDD)</p></li>
<li><p>实现目标</p></li>
</ol>
<p>放到当前的场景就是：</p>
<ol>
<li><p>我想在Github上连击365天。对应于每一个时候段的目标都应该是可以衡量、测试的——即每天都会有Contributions。</p></li>
<li><p>分解就是一个痛苦的过程。理想情况下，我们应该会有每天提交，但是这取决于你的repo的数量，如果没有新的idea出现，那么这个就变成为了Contributions而Commit。</p></li>
<li><p>一步步实现</p></li>
</ol>
<p>在我们实际工作中也是如此，接到一个任务，然后分解，一步步完成。不过实现会稍微复杂一些，因为事务总会有抢占和优先级的。</p>
<h2>技术与框架设计</h2>
<p>在上上一篇博客中《<a href=""https://www.phodal.com/blog/after-500-blogposts-analytics-after-tech/"" rel=""nofollow noreferrer"">After 500: 写了第500篇博客，然后呢?</a>》也深刻地讨论了下这个问题，技术向来都是后发者优势。对于技术人员来说，也是如此，后发者占据很大的优势。</p>
<p>如果我们只是单纯地把我们的关注点仅仅放置于技术上，那么我们就不具有任何的优势。而依赖于我们的编程经验，我们可以在特定的时候创造一些框架。而架构的设计本身就是一件有意思的事，大抵是因为程序员都喜欢创造。(ps:之前曾经写过这样一篇文章，《<a href=""https://www.phodal.com/blog/sorry-i-don't-like-programming/"" rel=""nofollow noreferrer"">对不起，我并不热爱编程，我只喜欢创造</a>》)</p>
<p><strong>创造是一种知识的再掌握过程。</strong></p>
<p>回顾一下写echoesworks的过程，一开始我需要的是一个网页版的PPT，当然这类的东西已经有很多了，如impress.js、bespoke.js等等。分析一下所需要的功能：markdown解析器、键盘事件处理、Ajax、进度条显示、图片处理、Slide。我们可以在Github上找到各式各样的模块，我们所要做的就是将之结合在一样。在那之前，我试着用类似的原理写（组合）了<a href=""https://github.com/phodal/lettuce"" rel=""nofollow noreferrer"">Lettuce</a>。</p>
<p>组合相比于创造过程是一个更有挑战性的过程，我们需要在这过程去设计胶水来粘合这些代码，并在最终可以让他工作。这好比是我们在平时接触到的任务划分，每个人负责相应的模块，最后整合。</p>
<p>想似的我在写<a href=""https://github.com/phodal/lan"" rel=""nofollow noreferrer"">lan</a>的时候，也是类似的，但是不同的是我已经设计了一个清晰的架构图。</p>
<p><span class=""img-wrap""><img data-src=""https://www.phodal.com/static/media/uploads/lan-iot.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Lan IoT"" title=""Lan IoT""></span></p>
<p>而在我们实现的编码过程也是如此，使用不同的框架，并且让他们能工作。如早期玩的<a href=""https://github.com/echoesworks/moqi.mobi"" rel=""nofollow noreferrer"">moqi.mobi</a>，基于Backbone、RequireJS、Underscore、Mustache、Pure CSS。在随后的时间里，用React替换了View层，就有了<a href=""https://github.com/phodal/backbone-react"" rel=""nofollow noreferrer"">backbone-react</a>的练习。</p>
<p>技术同人一样，需要不断地往高一级前进。我们只需要不断地Re-Practise。</p>
<h2>领域与练习</h2>
<p>说业务好像不太适合程序员的口味，那就领域吧。不同行业的人，如百度、阿里、腾讯，他们的领域核心是不一样的。</p>
<p>而领域本身也是相似的，这可以解释为什么互联网公司都喜欢互相挖人，而一般都不会去华为、中兴等非互联网领域挖人。出了这个领域，你可能连个毕业生都不如。领域、业务同技术一样是不断强化知识的一个过程。Ritchie先实现了BCPL语言，而后设计了C语言，而BCPL语言一开始是基于CPL语言。</p>
<p>领域本身也在不断进化。</p>
<p>这也是下一个值得提高的地方。</p>
<h2>其他</h2>
<p>是时候写这个小结了。从不会写代码，到写代码是从0到1的过程，但是要从1到60都不是一件容易的事。无论是刷Github也好(不要是自动提交)，或者是换工作也好，我们都在不断地练习。</p>
<p>而练习是要分成不同的几个步骤，不仅仅局限于技术：</p>
<ol>
<li><p>编码</p></li>
<li><p>架构</p></li>
<li><p>设计</p></li>
<li><p>。。。</p></li>
</ol>
<p>原文: <a href=""https://www.phodal.com/blog/github-365-days-review/"" rel=""nofollow noreferrer""></a><a href=""https://www.phodal.com/blog/github-365-days-review/"" rel=""nofollow noreferrer"">https://www.phodal.com/blog/github-365-days-review/</a><br>欢迎微博关注: @<a href=""http://weibo.com/phodal"" rel=""nofollow noreferrer"">Phodal</a></p>

                ", Github 365天: 给你一年的时间，你会怎样去提高你的水平,1531978028,153,1,713,1,1,https://segmentfault.com/a/1190000003833183
251,1,0,7,"
                    
<p>本文为翻译文章。原文链接：<a href=""http://owenou.com/2012/01/13/ten-things-you-didnt-know-git-and-github-could-do.html"" rel=""nofollow noreferrer"">Ten Things You Didn't Know Git And GitHub Could Do</a></p>
<hr>
<p>Git 和 GitHub都是非常强大的工具。即使你已经使用他们很长时间，你也很有可能不知道每个细节。我整理了Git和GitHub可能提高日常效率的10个常用技巧。</p>
<h2>GitHub</h2>
<h3>快捷键: t 和 w</h3>
<p>在你的源码浏览页面，按<code>t</code>可以快速进入模糊文件名搜索模式：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>在你仓库主页，按<code>w</code>可以快速进行分支过滤：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>在任意GitHub页面中，按<code>?</code>展示当前页面可用的快捷键：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>忽略空格: ?w=1</h3>
<p>在任意的diff URL添加<strong>?w=1</strong>用来整理缩进:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefK"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>按范围过滤提交记录: master@{time}..master</h3>
<p>你可以创建一个对比页面通过使用URL <code>github.com/user/repo/compare/{range}</code>。范围(range)可以是两个SHA例如<code>sha1…sha2</code>或者两个分支名称例如<code>master…my-branch</code>。范围同时也非常智能的支持使用时间作为关注点。你可以通过<code>master@{1.day.ago}…master</code>过滤从昨天开始的提交。例如：链接，<code>https://github.com/rails/rails/compare/master@{1.day.ago}…master</code>显示Rails项目中全部昨天开始的提交记录和变化：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>按作者过滤提交记录: ?author=github_handle</h3>
<p>你可以通过在对比页面URL中增加<code>?author=github_handle</code>来按作者过滤提交记录。例如：链接<code>https://github.com/dynjs/dynjs/commits/master?author=jingweno</code>显示jingweno对<a href=""http://dynjs.org/"" rel=""nofollow noreferrer"">Dynjs</a> 的提交记录：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>.diff 和 .patch</h3>
<p>在比较页面、合并请求页面或者评论页面的URL后增加<code>.diff</code>或者<code>.patch</code>，可以得到diff或者patch的文本格式。例如：链接<code>https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch</code>显示Rails项目中全部昨天开始的提交记录和变化的文本格式：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqefZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>邮件回复</h3>
<p>你可以直接在收到的GitHub通知邮件进行评论，不必在网站页面中评论。GitHub会正确的处理你的评论：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqef2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>链接行</h3>
<p>在文件展示页面，点击某行或者通过按<code>SHIFT</code>选择多行，URL会有相应的改变。如果你要给你的队友分享一段代码是非常方便的：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqef4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>关注用户</h3>
<p>在合并请求、问题或者任何评论中中提到用户会使用户关注全部的后续通知：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqef5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>自动链接</h3>
<p>在合并请求、问题、或者任何评论中，sha和问题码(例如：#1)会被自动链接。并且，你也可以链接其它仓库的sha或者问题码，格式：<code>user/repo@sha1</code>或者<code>user/repo#1</code>。下面是一个评论中通过sha自动链接的例子：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqef6"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>hub</h3>
<p><a href=""https://github.com/defunkt/hub"" rel=""nofollow noreferrer"">Hub</a> 是 GitHub的命令行。它提供了Git和Github之间的集成。一个最有用的命令就是在命令行输入<code>hub pull-request</code>创建pull request。详见<a href=""https://github.com/defunkt/hub#commands"" rel=""nofollow noreferrer"">readme</a>.</p>
<h2>Git</h2>
<h3>git log -p FILE</h3>
<p>查看<code>README.md</code>的修改历史，例如：</p>
<pre><code>&gt; git log -p README.md</code></pre>
<h3>git log -S’PATTERN’</h3>
<p>例如，搜索修改符合<code>stupid</code>的历史：</p>
<pre><code>&gt; git log -S'stupid'</code></pre>
<h3>git add -p</h3>
<p>交互式的保存和取消保存变化，使用：</p>
<pre><code>&gt; git add -p</code></pre>
<h3>git rm –cached FILE</h3>
<p>这个命令只删除远程文件，例如：</p>
<pre><code>&gt; git rm --cached database.yml</code></pre>
<p>删除<code>database.yml</code>被保存的记录，但是不影响本地文件。这对删除已经推送过的忽略文件记录而且不影响本地文件是非常的方便的。</p>
<h3>git log ..BRANCH</h3>
<p>这个命令返回某个非HEAD分支的提交记录。假如你在一个功能分支，输入：</p>
<pre><code>&gt; git log ..master</code></pre>
<p>返回全部master分支的历史记录，包括未被合并到当前分支的提交记录。</p>
<h3>git branch –merged &amp; git branch –no-merged</h3>
<p>这个命令返回已合并分支列表或未合并的分支列表。这个命令对合并前检查非常有用。例如，在一个功能分支，输入</p>
<pre><code>&gt; git branch --no-merged</code></pre>
<p>返回未合并到该分支的分支列表。</p>
<h3>git branch –contains SHA</h3>
<p>返回包含某个指定sha的分支列表。例如：</p>
<pre><code>&gt; git branch --contains 2f8e2b</code></pre>
<p>显示全部包含提交<code>2f832b</code>的分支。这个命令对于验证<code>git cherry-pick</code>完成非常有帮助。</p>
<h3>git status -s</h3>
<p>返回一个简单版的git status。我设置这个命令为默认git status来减少噪音。</p>
<h3>git reflog</h3>
<p>显示你在本地已完成的操作列表。</p>
<h3>git shortlog -sn</h3>
<p>显示提交记录的参与者列表。和GitHub的参与者列表相同。</p>
<h2>Summary</h2>
<p>Git是一个设计良好的工具。了解它可以直接让你更有效率并成为一个更有才华的程序员。GitHub，在另一个方面，在Git基础上提供便利的团队合作特性。有能力使用GitHub也会提高你日常效率。</p>
<p>为了更好的加深你对的Git和Github了解，我推荐一些资料：</p>
<ul>
<li><p><a href=""http://git-scm.com/book"" rel=""nofollow noreferrer"">ProGit</a>, 最好的Git指南</p></li>
<li><p><a href=""https://peepcode.com/products/advanced-git"" rel=""nofollow noreferrer"">Advanced Git</a></p></li>
<li><p><a href=""http://zachholman.com/talk/git-github-secrets/"" rel=""nofollow noreferrer"">Git and GitHub Secrets</a></p></li>
</ul>

                ", 关于Git和Github你不知道的十件事,1531978029,448,1,394,1,1,https://segmentfault.com/a/1190000003830252
252,1,0,7,"
                    
<p><a href=""https://github.com/github/hub"" rel=""nofollow noreferrer"">hub</a> 是一个命令行工具, 高度集成 git, 顺便加了一些 github 的操作, 所以:</p>
<ul>
<li><p>安装: <code>brew update &amp;&amp; brew install hub</code></p></li>
<li><p>别名: <code>alias git=hub</code></p></li>
</ul>
<p>卧槽, 为什么别名那个看着那么屌, 直接这样真的好么? 我第一眼看到我也有点蛋疼, 犹豫该不该.<br>其实完全没有问题, 不用担心, relax~~~~, 顶多换了个机器有一些命令没法用而已, 但是原生的 git 命令是完全兼容的.</p>
<p><del>提一句, windows 貌似不适用, linux 和 OS X 可以尽情享用.</del><br>hub 1.x是ruby写的，2.x用go重写了，有官方windows release.</p>
<h2>我的用法</h2>
<ul>
<li><p>快速打开某个项目的 github 页面: <code>git browse falood/maru</code>, 注意这里是起过别名的 git. (我就是我是不一样的 git) 说实话这样挺爽, 特别是我经常要看几个项目的代码, 这样简直爽, 就是爽, 嗯, 爽.</p></li>
<li><p>clone 一个项目: <code>git clone falood/maru</code>, 看到没, 看到没, 不用输那么一长串地址了, 虽然平时使用也不输, 只是复制而已, 但是这样比复制还快啊</p></li>
<li><p>fork 一个项目, 然后进行 fork based development:</p></li>
</ul>
<pre><code class=""git"">git clone falood/maru
cd maru
git fork</code></pre>
<p>4不4很方便? 但是如果要用提 pr 的方法来进行开发的话还需要改个东西, 如果上面的命令你都敲了, 现在打开项目下的一个文件, 叫<code>.git/config</code>, 打开后长这样:</p>
<pre><code>[core]
       some code
[remote ""origin""]
        url = git://github.com/falood/maru.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch ""master""]
        remote = origin
        merge = refs/heads/master
[remote ""Cifer-Y""]
        url = git@github.com:Cifer-Y/maru.git
        fetch = +refs/heads/*:refs/remotes/Cifer-Y/*</code></pre>
<p>一般情况下, fork 代码之后要指定一个 upstream, 来获取原项目的更新, 要把上面<code>[remote ""origin""]</code>改成<code>[reomote ""upstream""]</code>, 最后把<code>[remote ""Cifer-Y""]</code>改成<code>[remote ""origin""]</code> 就好了.<br>然后就可以写代码了, 写完之后想给原项目作者提 pr 怎么办, 这样: <br><code>git pull-request -b falood:master -h Cifer-Y:master</code><br>给不想看文档的人简单说一下, -b 后面的是你 pr 的目的地, -h 后面的是你要提的东西所在的分支</p>
<ul><li><p>新建一个 github repo:</p></li></ul>
<pre><code>git init new_repo
cd new_repo
echo ""What's wrong?"" &gt;&gt; README.md
git add .
git commit -m ""relex~~~~~""
git create
git push -u origin master
git browse</code></pre>
<p>这段操作太基本, 我就不一一解释了</p>
<ul><li><p>还有很多有用的命令, 请运行 <code>man hub</code></p></li></ul>
<p>大半夜玩 hub 玩的不亦乐乎, 其实我觉得上面那几个用法足够日(小)常(白)使用了, 但是还有很多很屌的高级功能, 比如从别人的 fork 里 cherry-pick 一个 commit 放到自己的项目里...这种就等用到了再学吧</p>

                ", hub 小试,1531978031,418,1,665,1,1,https://segmentfault.com/a/1190000003817491
253,1,0,7,"
                    
<p>AngularJS 工具对你开发 AngularJS App 项目非常有帮助，下面的这些工具尤其适合用于创建单页面 WEB 应用。今天分享 11 个对WEB开发者非常有帮助的 AngularJS 工具，如果你还有其他很棒的工具，请在评论中留言让我们知道。</p>
<h2>1. <a href=""https://www.firebase.com/docs/web/libraries/angular/index.html"" rel=""nofollow noreferrer"">AngularFire</a>
</h2>
<p>AngularFire 提供了一种非常容易的创建 AngularJS 应用后台的方式，提供了灵活的API，3种方式的数据绑定，以及快速的开发能力。</p>
<h2>2. <a href=""http://angular.github.io/protractor/#/"" rel=""nofollow noreferrer"">Protractor</a>
</h2>
<p>Protractor 是一个 AngularJS 应用程序终端到终端的测试框架。Protractor 可以在真实的浏览器中运行测试你的程序。</p>
<h2>3. <a href=""http://www.aptana.com/"" rel=""nofollow noreferrer"">Aptana</a>
</h2>
<p>使用业界领先的WEB应用程序 IDE 来快速简便的构建 WEB 应用。Aptana Studio 利用了 Eclipse 的灵活性，并把它集成到一个功能强大的Web开发引擎。</p>
<h2>4. <a href=""http://ui.lumapps.com/"" rel=""nofollow noreferrer"">Lumx</a>
</h2>
<p>第一款基于 AngularJS 和 Google Material Design 的响应式前段框架。</p>
<h2>5. <a href=""http://mobileangularui.com/"" rel=""nofollow noreferrer"">Mobile Angular UI</a>
</h2>
<p>Mobile Angular UI 是一个使用BootStrap 3 和 AngularJS 创建 HTML5 应用的前段框架。</p>
<h2>6. <a href=""http://angular-ui.github.io/bootstrap/"" rel=""nofollow noreferrer"">UI Bootstrap</a>
</h2>
<p>由 AngularUI 团队开发的，纯 AngularJS 编写的 BootStrap 组件。这个库包含了一套基于 BootStrap 标记和CSS的AngularJS指令。</p>
<h2>7. <a href=""http://yeoman.io/"" rel=""nofollow noreferrer"">Yeoman</a>
</h2>
<p>Yeoman 帮你快速启动新的项目、提供最佳的实践以及使你保持高效的工具。</p>
<h2>8. <a href=""http://www.videogular.com/"" rel=""nofollow noreferrer"">Videogular</a>
</h2>
<p>Videogular 是一个由AngularJS 开发的支持PC端和移动端的视频应用框架。Videogular 使用 HTML5 的 video 标签，所以你可以添加任何你想要的。</p>
<h2>9. <a href=""https://appery.io/"" rel=""nofollow noreferrer"">Appery.io</a>
</h2>
<p>Appery 是一个基于云平台的，使用私有/公共云方案开发移动端响应式应用的框架。</p>
<h2>10. <a href=""http://codeorchestra.com/#/"" rel=""nofollow noreferrer"">Colt.io</a>
</h2>
<p>COLT 是一个小的程序，可以实时的测试、创建移动端、WEB端和基于桌面的应用程序。</p>
<h2>11. <a href=""https://angular-gettext.rocketeer.be/"" rel=""nofollow noreferrer"">Angular Gettext</a>
</h2>
<p>Angular gettext 是一个 AngularJS 超级简单的翻译支持。所有的都用英语编写，并且标记出哪部分需要翻译。</p>
<blockquote><p>via：<a href=""http://dzinepix.com/2015/best-angularjs-tools-for-web-developers"" rel=""nofollow noreferrer"">dzinepix</a>，由 <a href=""http://9iphp.com/"" rel=""nofollow noreferrer"">Specs</a> 翻译整理，发布在 <a href=""http://info.9iphp.com/2015-best-angularjs-tools-for-web-developers/"" rel=""nofollow noreferrer"">Coder资源网</a>，转载请注明来源。</p></blockquote>

                ", 11个很棒的 AngularJS 工具,1531978032,532,1,597,1,1,https://segmentfault.com/a/1190000003758046
254,1,0,7,"
                    
<h2><strong>Git的简史</strong></h2>
<p>　　同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>　　Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>　　到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者Linux Torvalds）基于使用 BitKcheper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p>
<ul>
<li><p>速度</p></li>
<li><p>简单的设计</p></li>
<li><p>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</p></li>
<li><p>完全分布式</p></li>
</ul>
<p>　　有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>　　自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p>
<p>　　Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<h2><strong>Git是什么？</strong></h2>
<p>　　Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>　　Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>　　最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面这个老土的样子了：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVpR5c"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""汇智网"" title=""汇智网""></span></p>
<h2><strong>Git特点</strong></h2>
<p>　　分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p>
<ul>
<li><p><strong>直接记录快照，而非差异比较</strong> ： Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。</p></li>
<li><p><strong>近乎所有操作都是本地执行</strong> ：在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。</p></li>
<li><p><strong>时刻保持数据完整性</strong> ：在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</p></li>
<li><p><strong>多数操作仅添加数据</strong> ：常用的 Git 操作大多仅仅是把数据添加到数据库。</p></li>
</ul>
<p>　　开发流程示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVpR5n"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""汇智网 开发流程图"" title=""汇智网 开发流程图""></span></p>
<h2><strong>集中版本控制</strong></h2>
<p>　　CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p>
<p>　　集中式版本控制系统，版本库是集中存放在中央服务器的，一起工作的人需要用自己的电脑从服务器上同步更新或上传自己的修改。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVpR5z"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""汇智网 版本控制"" title=""汇智网 版本控制""></span></p>
<p>　　但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。</p>
<p>　　而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。</p>
<h2><strong>分布式版本控制</strong></h2>
<p>　　那分布式版本控制系统与集中式版本控制系统有何不同呢？</p>
<p>　分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，不需要联网就可以工作。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你和同事在各自电脑修改相同文件，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>　　分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库。大家之间可以相互复制。</p>
<p>　　分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVpR5A"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""汇智网 版本控制"" title=""汇智网 版本控制""></span></p>
<h2><strong>安装Git</strong></h2>
<p>　　最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>　　在Linux上安装Git</p>
<p>　　首先，你可以试着输入git，看看系统有没有安装Git：</p>
<pre><code>$ git
</code></pre>
<p>　　像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>　　如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。如果想查看是否安装成功，通过git --version。</p>
<p>　　如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<p>　　安装完成后，还需要最后一步设置，在命令行输入：　　</p>
<pre><code>$ git config --global user.name ""Your Name""
$ git config --global user.email ""email@example.com""
</code></pre>
<p>　　因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。</p>
<p>　　注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。在此课程中，我们配置的环境中Git已安装好，我们课程提供也是在Linux系统中命令进行操作。</p>
<h2><strong>什么是版本库？</strong></h2>
<p>　　版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>　　所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/home/hubwiz/learngit
</code></pre>
<p>　　pwd命令用于显示当前目录。在环境中这个仓库位于/home/hubwiz/learngit。</p>
<p>　　通过git init命令把这个目录变成Git可以管理的仓库：</p>
<pre><code>$ git init
Initialized empty Git repository in /home/hubwiz/learngit/.git/
</code></pre>
<p>　　瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>　　如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<h2><strong>添加文件</strong></h2>
<p>　　我们了解下版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>　　为了简明起见，我们创建一个readme.txt作为练习：</p>
<pre><code>echo ""Git is a version control system."" &gt; readme.txt
// 输入这句话保存到创建的readme.txt文件中
echo "" Git is free software."" &gt;&gt; readme.txt
// 输入此内容追加到readme.txt中
</code></pre>
<p>　　一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>　　用命令git add告诉Git，把文件添加到仓库：</p>
<pre><code>$ git add readme.txt
</code></pre>
<p>　　git add 实际上是个脚本命令，没有任何显示，说明添加成功。</p>
<h2><strong>提交文件</strong></h2>
<p>　　用命令git commit告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m ""wrote a readme file""
[master (root-commit) cb926e7] wrote a readme file
1 file changed, 2 insertions(+)
create mode 100644 readme.txt
</code></pre>
<p>　　简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>　　git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>　　为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m ""add 3 files.""
</code></pre>
<h2><strong>小结</strong></h2>
<p>此节知识点我们所学习的内容：</p>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<p>第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；<br>第二步，使用命令git commit，完成。</p>
<p>网站上还有更多内容和对应每一小节的在线练习大家可以去试试。<br><a href=""http://www.hubwiz.com/course/55d301543ad79a1b05dcc4e2/"" rel=""nofollow noreferrer"">http://www.hubwiz.com/course/55d301543ad79a1b05dcc4e2/</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVpR5F"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""汇智网 git"" title=""汇智网 git""></span></p>

                ", Git  简介,1531978033,397,1,331,1,1,https://segmentfault.com/a/1190000003743788
255,1,0,7,"
                    
<p>基础知识和命令先参考：<a href=""http://segmentfault.com/a/1190000003728094"" rel=""nofollow noreferrer"">使用git和github管理自己的项目---基础操作学习</a></p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000"" rel=""nofollow noreferrer"">13.分支管理策略</a></h2>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<ul>
<li><p><code>git checkout -b dev</code> 创建并切换到dev分支</p></li>
<li><p><code>vim readme.txt</code> 修改readme.txt文件</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""add merge""</code> 提交一个新的commit</p></li>
<li><p><code>git checkout master</code> 切回master分支</p></li>
<li><p><code>git merge --no-ff -m ""merge with with no-ff"" dev</code> 准备合并dev分支，注意<code>--no-ff</code>参数表示禁用Fast forward，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p></li>
<li><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 合并后查看分支历史</p></li>
</ul>
<p>合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000"" rel=""nofollow noreferrer"">14.分支策略</a></h2>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<ul>
<li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活</p></li>
<li><p>那在哪里干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如2.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发新版本</p></li>
<li><p>你和你的小伙伴每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时往<code>dev</code>分支上合并就可以了</p></li>
</ul>
<p>所以，团队合作的分支看起来就像这个样子：<br><span class=""img-wrap""><img data-src=""/img/bVcc7H"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000"" rel=""nofollow noreferrer"">15.Bug分支</a></h2>
<p>软件开发中，bug就像是家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你街道一个修复代号为101的bug的任务的时候，很自然的，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<ul><li><p><code>git status</code> 查看状态</p></li></ul>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<ul>
<li><p><code>git stash</code> 用该命令查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心的创建分支来修复bug了。</p></li>
<li><p><code>git checkout master</code> 从dev分支切换回master</p></li>
<li><p><code>git checkout -b issue-101</code>  假定需要在master分支上修复，就从<code>master</code>创建临时分支</p></li>
<li><p>假设现在修复好了bug，本例中，就假如在readme.txt文件中做了修改</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""fic bug 101""</code> 修改之后提交</p></li>
<li><p><code>git checkout master</code> 从issue-101切换回master</p></li>
<li><p><code>git merge --no-ff -m ""merged bug fix 101"" issue-101</code> 合并分支选择不适用Fast forward模式，然后添加必要的描述信息</p></li>
<li><p><code>git branch -d issue-101</code> 删除issue-101这个临时bug修复分支</p></li>
<li><p>太棒了，bug搞定了，现在可以回到<code>dev</code>分支干活了</p></li>
<li><p><code>git checkout dev</code> 切换回dev分支</p></li>
<li><p><code>git status</code> 可以看出工作区是干净的，那么刚才的工作现场存在哪里呢？</p></li>
<li><p><code>git stash list</code> 看到工作现场还在，Git吧stash内容存在某个地方了，但是需要恢复一下</p></li>
<li><p>方法一<code>git stash apply</code>，但是回复后，stash内容并不删除，你需要使用<code>git stash drop</code>来删除</p></li>
<li><p>方法二<code>git stash pop</code>，恢复的同时也把stas内容删除了</p></li>
<li><p><code>git stash list</code> 再用git stash list查看，就看不到任何stash内容了</p></li>
<li><p>你可以多次<code>stash</code>，恢复的时候，先用<code>giit stash list</code> 查看，然后恢复指定的stash，使用如下的命令</p></li>
<li><p><code>git stash apply stash@{0}</code></p></li>
</ul>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除。</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376026233004c47f22a16d1f4fa289ce45f14bbc8f11000"" rel=""nofollow noreferrer"">16.Feature分支</a></h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。于是开始准备工作</p>
<ul>
<li><p><code>git checkout -b feature-vulcan</code> 在dev分支上创建并且换到feature-vulcan分支，用来开发新功能</p></li>
<li><p>假如现在经过一定的时间后，工作完成了</p></li>
<li><p><code>git add vulcan.py</code></p></li>
<li><p><code>git status</code> 查看状态</p></li>
<li><p><code>git commit -m ""add feature vulcan""</code> 提交</p></li>
<li><p><code>git checkout dev</code> 切换回dev分支</p></li>
<li><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁，不要再合并了:</p></li>
<li><p><code>git branch -d feature-vulcan</code> 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</p></li>
<li><p><code>git branch -D feature-vulcan</code></p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013760174128707b935b0be6fc4fc6ace66c4f15618f8d000"" rel=""nofollow noreferrer"">17.多人协作</a></h2>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p><strong>推送分支</strong></p>
<ul>
<li><p><code>git remote</code> 查看远程库的信息</p></li>
<li><p><code>git remote -v</code> 显示更为详细的信息</p></li>
<li><p><code>git push origin master</code> 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p></li>
<li><p><code>git push origin dev</code> 也可以推送到其他的分支，比如dev分支</p></li>
<li><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p></li>
</ul>
<p><strong>抓取分支</strong></p>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<ul>
<li><p><code>git clone git@github.com:michaelliao/learngit.git</code>  现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆。</p></li>
<li><p><code>git branch</code> 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支，所以执行这条命令只能看到master分支</p></li>
<li><p><code>git checkout -b dev origin/dev</code> 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支</p></li>
<li><p><code>git commit -m ""add /usr/bin/env""</code> 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。</p></li>
<li><p><code>git add hello.py</code> <code>git commit -m ""add coding: utf-8""</code> <code> git push origin dev</code> 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突。</p></li>
<li><p><code>git pull</code> 解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p></li>
<li><p><code>git branch --set-upstream dev origin/dev</code> git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。</p></li>
<li><p><code>git pull</code> 再次pull，这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样</p></li>
<li><p><code>git commit -m ""merge &amp; fix hello.py""</code> <code>git push origin dev</code> 解决冲突后，再提交，再push</p></li>
</ul>
<p><strong>因此，多人协作的工作模式通常是这样的：</strong></p>
<ul>
<li><p>首先，可以试图用<code>git push origin branch-name</code> 推送自己的修改</p></li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并</p></li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交</p></li>
<li><p>没有冲突或者解决掉冲突之后，再用<code>git push origin branch-name</code>推送就能成功</p></li>
<li><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。<strong>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</strong></p></li>
</ul>
<h2>18.标签管理</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<strong>所以，标签也是版本库的一个快照。</strong></p>
<p><strong>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</strong></p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951758572072ce1dc172b4178b910d31bc7521ee4000"" rel=""nofollow noreferrer"">19.创建标签</a></h2>
<ul>
<li><p><code>git branch</code> 查看当前有哪些分支</p></li>
<li><p><code>git checkout master</code> 在Git中打标签非常简单，首先，切换到需要打标签的分支上</p></li>
<li><p><code>git tag tagnamev1.0</code> 打一个新标签</p></li>
<li><p><code>git tag</code> 查看所有标签</p></li>
<li><p>默认标签是打在最新提交的commit上的（也就是<code>HEAD</code>）。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p></li>
<li><p><code>git log --pretty=oneline --abbrev-commit</code> 方法是找到历史提交的commit id，然后打上就可以了，这时候显示了提交的历史信息 ，假如有这么一条就是你想打标签的历史commit：<code>6224937 add merge</code></p></li>
<li><p><code>git tag tagnamev2.0 6224937</code> 就可以给这次提交打标签了</p></li>
<li><p><code>git tag</code> 可以查看标签信息，注意，标签不是按时间顺序列出，而是按字母排序的</p></li>
<li><p><code>git show tagnamev2.0</code> 查看具体的某个标签的信息</p></li>
<li><p><code>git tag -a v0.1 -m ""version 0.1 released"" 3628164</code> 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</p></li>
<li><p><code>git show v0.1</code> 查看具体的某个标签的信息，可以看到说明文字</p></li>
<li><p><code>git tag -s v0.2 -m ""signed version 0.2 released"" fec145a</code> 还可以通过-s用私钥签名一个标签，签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错</p></li>
<li><p><code>git show v0.2</code>  用命令git show &lt;tagname&gt;可以看到PGP签名信息，用PGP签名的标签是不可伪造的，因为可以验证PGP签名。</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951885068a0ac7d81c3a64912b35a59b58a1d926b000"" rel=""nofollow noreferrer"">20.操作标签</a></h2>
<ul>
<li><p><code>git tag -d v0.1</code> 假如标签打错了，也可以删除，因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li>
<li><p><code>git push origin v1.0</code> 要推送某个标签到远程</p></li>
<li><p><code>git push origin --tags</code> 或者，一次性推送全部尚未推送到远程的本地标签</p></li>
<li><p><code>git tag -d v0.9</code> 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除</p></li>
<li><p><code>git push origin :refs/tags/v0.9</code> 然后，从远程删除。删除命令也是push，但是格式要注意</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000"" rel=""nofollow noreferrer"">21.使用Github</a></h2>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架。</p>
<ul>
<li><p>你可以访问它的项目主页<a href=""https://github.com/twbs/bootstrap"" rel=""nofollow noreferrer"">https://github.com/twbs/boots...</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库</p></li>
<li><p><code>git clone git@github.com:yourname/bootstrap.git</code> 然后，从自己的账号下clone</p></li>
<li><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p></li>
</ul>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：<br><span class=""img-wrap""><img data-src=""/img/bVpQU9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p><strong>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</strong></p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下廖雪峰的仓库：<a href=""https://github.com/michaelliao/learngit"" rel=""nofollow noreferrer"">https://github.com/michaellia...</a>，创建一个<code>your-github-id.txt</code>的文本文件，比如我的：<code>xumenger.txt</code>，写点自己学习Git的心得，然后推送一个pull request给他，他会视心情而定是否接受。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137621280731812dec22ecc9b44f4b2ca1c680f181a5b000"" rel=""nofollow noreferrer"">22.自定义Git</a></h2>
<p>之前已经说过在使用之前必须先配置<code>user.name</code>和<code>user.email</code>，否则后面commit的时候可能会有错误，实际上git还有很多可配置的：</p>
<ul><li><p><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目，自己去试试一些git命令的输出看看是不是有色！</p></li></ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000"" rel=""nofollow noreferrer"">23.忽略特殊文件</a></h2>
<p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href=""https://github.com/github/gitignore"" rel=""nofollow noreferrer"">https://github.com/github/git...</a></p>
<p><strong>忽略文件的原则是：</strong></p>
<ul>
<li><p>忽略操作系统自动生成的文件，比如缩略图等；</p></li>
<li><p>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</p></li>
<li><p>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></li>
</ul>
<p><strong>举个例子</strong></p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
</code></pre>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p>
<pre><code># Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
</code></pre>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini

# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build

# My configurations:
db.ini
deploy_key_rsa
</code></pre>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令还会不会再说working directory clean。<strong>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</strong></p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<blockquote><p>再次建议：有钱的买mac，没钱的用ubuntu--或者其他的linux发行版、被逼无奈的用Windows--但是被逼之余的自主时间一定要远离Windows。</p></blockquote>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000"" rel=""nofollow noreferrer"">24.配置别名</a></h2>
<blockquote><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p></blockquote>
<ul>
<li><p><code>git config --global alias.st status</code> 有没有经常敲错命令？比如git status？status这个单词真心不好记。如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p></li>
<li><p><code>git config --global alias.co checkout</code></p></li>
<li><p><code>git config --global alias.ci commit</code></p></li>
<li><p><code>git config --global alias.br branch</code></p></li>
<li><p>很多人都用co表示checkout，ci表示commit，br表示branch</p></li>
<li><p><code>git ci -m ""bala bala bala...""</code> 以后提交就可以简写成这样</p></li>
<li><p><code>git config --global alias.unstage 'reset HEAD'</code> 在<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000"" rel=""nofollow noreferrer"">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名</p></li>
<li><p><code>git unstage test.py</code> 当你敲入此命令，实际上Git执行的是：<code>git reset HEAD test.py</code></p></li>
<li><p><code>git config --global alias.last 'log -1'</code> 配置一个git last，让其显示最后一次提交信息</p></li>
<li><p><code>git config --global alias.lg ""log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit""</code> 甚至还有人这样的配置，那么，这时候<code>git lg</code>的效果是这样的<br><span class=""img-wrap""><img data-src=""/img/bVpQW9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ul>
<p><strong>配置文件</strong></p>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<pre><code>$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote ""origin""]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch ""master""]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
</code></pre>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<pre><code>$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
</code></pre>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000"" rel=""nofollow noreferrer"">25.搭建Git服务器</a></h2>
<p>如果需要的话，请自己参考<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000"" rel=""nofollow noreferrer"">廖雪峰的教程</a></p>

                ", 使用git和github管理自己的项目---真实开发环境的策略,1531978035,301,1,834,1,1,https://segmentfault.com/a/1190000003739324
256,1,0,7,"
                    
<p>我是通过看<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰的git教程</a>学习的，真的是极好的，以下是我学习过程中的总结，记录下来，方便自己参考以熟悉git和github的使用。</p>
<p>除了廖雪峰的教程，还比较推荐在看完廖雪峰的教程之后，再看这样一篇文章：<a href=""http://segmentfault.com/a/1190000002413519"" rel=""nofollow noreferrer"">使用git和github进行协同开发流程</a>，和我的另一篇git的笔记：<a href=""http://segmentfault.com/a/1190000003739324"" rel=""nofollow noreferrer"">使用git和github管理自己的项目---真实开发环境的策略</a> ，深入了解github和git怎么在具体的项目开发中管理项目、有什么好的规范！</p>
<p>我这里记录git的学习笔记，方便随时参考，具体的<strong>git的原理</strong>、<strong>github的原理</strong>、<strong>集中式和分布式版本控制的区别</strong>、<strong>版本控制的概念和原理</strong>、<strong>Git和其他版本控制工具比如SVN的区别</strong>、以及更多的相关<strong>概念讲解</strong>，请自己参见<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰的git教程</a>。</p>
<blockquote><p>我强烈推荐先看廖雪峰的git教程来系统化认识和学习git，然后自己整理一份具体的步骤方便平时开发时快速参考，或者直接参考我的。</p></blockquote>
<p>先说一个比较好笑的事：廖雪峰的git教程中，刚开始的部分的浏览量有38万，但是最后一页教程的网页的浏览量是1万多。</p>
<p>以前因为觉得git、github比较难，所以一直拖着不学，现在去尝试学习，一晚上就OK了</p>
<ul>
<li><p>重点之一是找到全面的、详细的、生动的、高质量的教程。廖雪峰的git教程是我目前找到的最好的一个。之前找到的讲解git用法的书<a href=""http://git-scm.com/book/zh/v1%E3%80%81"" rel=""nofollow noreferrer"">《pro git》</a>现在看来是没有必要再看了！</p></li>
<li><p>重点之二就是自己立即去学，其实没什么难的，不要被貌似难的表象、概念唬住。</p></li>
<li><p>重点之三是最好能自己做简单的、系统的整理，方便自己随时再回来查看、复习、参考，不至于出现这样的情况：学完以后过一段时间之后再用，但是这时候发现忘了差不多了！</p></li>
<li><p>重点之四就是立即动手去用，否则学完很快就忘了。</p></li>
</ul>
<blockquote><p>有钱的买mac，没钱的用ubuntu--或者其他的linux发行版、被逼无奈的用Windows--但是被逼之余的自主时间一定要远离Windows。</p></blockquote>
<p>现在我的测试环境是ubuntu。</p>
<p>以对一个文件的管理为例，简单说明git的使用。另外需要说明的是下面的实验过程主要是只针对一个文件、并且修改的次数往往只有一次，而在真正的项目中，往往有大量的文件，也可能多次修改后才合并，合并时候的冲突可能也不只一两个，等等。不过原理都是一样的，我想说的是，不要局限在这个教程的示例上，请自己通过教程掌握基本的远原理之后，自己推广、去大量的实践，最重要的是要制定一个好的版本控制的策略（合理分工、安排，还是尽可能的避免冲突为好），这个可以参考：<a href=""http://segmentfault.com/a/1190000002413519"" rel=""nofollow noreferrer"">使用git和github进行协同开发流程</a>以及我的学习笔记<a href=""http://segmentfault.com/a/1190000003739324"" rel=""nofollow noreferrer"">使用git和github管理自己的项目---真实开发环境的策略</a>。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000"" rel=""nofollow noreferrer"">1.创建版本库</a></h2>
<ul>
<li><p><code>sudo apt-get install git</code> 先安装git</p></li>
<li><p>先创建目录，作为仓库</p></li>
<li><p><code>git init</code> 初始化仓库，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了</p></li>
<li><p><code>vim readme.txt</code> 新建一个文本文件，比如往里面添加简单的一行字符串</p></li>
<li><p><code>git add readme.txt</code> 添加一个文件，比如readme.txt，如果目录里面的所有文件都要添加，可以<code>git add *</code></p></li>
<li><p><code>git commit-m ""添加一个readme.txt文件""</code> 将文件提交到仓库，并加上说明（这时候是版本1）</p></li>
<li><p>如果是第一次使用git，那么git commit可能报错，所以需要你配置一些个人信息</p></li>
<li><p><code>git config --global user.email ""you@example.com""</code> 配置邮件</p></li>
<li><p><code>git config --global user.name ""Your Name""</code> 配置用户名</p></li>
<li><p>必须配置，否则后面的commit、push到远程库都会失败</p></li>
<li><p>然后再次<code>git commit -m ""添加一个readme.txt文件""</code> 才会成功</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000"" rel=""nofollow noreferrer"">2.提交修改</a></h2>
<ul>
<li><p>假如此时<strong>第一次</strong>修改了readme.txt文件</p></li>
<li><p><code>git status</code> 让我们时刻掌握仓库当前的状态。这时告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p></li>
<li><p><code>git diff readme.txt</code> 查看对readme.txt做了什么修改</p></li>
<li><p><code>git add readme.txt</code> 提交修改和提交新文件是一样，先git add</p></li>
<li><p><code>git status</code> 可以再用git status查看仓库的当前状态，告诉我们，将要被提交的修改包括readme.txt</p></li>
<li><p><code>git commit-m ""第一次修改""</code>  然后再git commit，并添加修改的描述（这时候是版本2）</p></li>
<li><p><code>git status</code> 可以再执行git status看仓库状态，因为所有的都提交了，Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000"" rel=""nofollow noreferrer"">3.版本回退</a></h2>
<ul>
<li><p>你可以像上面所说的那样不停的提交新的文件、提交对文件的修改</p></li>
<li><p>这时候第二次修改readme.txt文件</p></li>
<li><p><code>git add readme.txt</code> 先git add</p></li>
<li><p><code>git commit -m ""第二次修改""</code>  提交第二次修改（这时候是版本3）</p></li>
<li><p><code>git log</code> 显示从最近到最远的提交日志，具体显示的内容自己试一试看看</p></li>
<li><p><code>git log --pretty=oneline</code> 如果嫌输出信息太多，看得眼花缭乱，试试加上--pretty=oneline参数</p></li>
<li><p>看<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000"" rel=""nofollow noreferrer"">这篇教程</a>去理解为什么Git的版本号要这么长，Git的版本号类似：3628164fb26d48395383f8f31179f24e0882e1e0 这样的特别长的十六进制数。</p></li>
<li><p><code>git reset --hard HEAD^</code> 会回退到上一个版本，也就是从版本3回退到版本2</p></li>
<li><p>在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</p></li>
<li><p><code>vim readme.txt</code> 可以看到此时的readme.txt文件就是版本2时候的内容，回退成功！</p></li>
<li><p><code>git log</code> 此时看到版本3的信息没有了</p></li>
<li><p><code>git reset --hard 3628164</code> 通过命令行上的历史信息（假如你没清屏的话），找到版本3 的版本号，不一定要全部的版本号，就像这个命令的例子，只要前面的约7、8位这样就可以指定回到版本3</p></li>
<li><p><code>vim readme.txt</code> 看到的是第三版本的readme.txt文件的内容，所以又回来了</p></li>
<li><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向你要回退的那个版本</p></li>
<li><p><code>git reflog</code> 记录你的每一次命令，最先显示的是这个命令执行之后的版本的版本号的前七位，这样就算你清屏了或者重启了，也能找到某个版本的版本号，就可以轻松回退到那个版本</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000"" rel=""nofollow noreferrer"">4.工作区、版本库和暂存区</a></h2>
<p><strong>工作区</strong>：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。</p>
<p><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p><strong>暂存区</strong>：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ol>
<li><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p></li>
<li><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li>
</ol>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>详细知识见<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000"" rel=""nofollow noreferrer"">这篇教程</a>。必须理解暂存区、工作区、版本库。这些都是是Git非常重要的概念，弄明白了这些概念，就弄明白了Git的很多操作到底干了什么。<strong>没弄明白的话，请反复看！！</strong></p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374829472990293f16b45df14f35b94b3e8a026220c5000"" rel=""nofollow noreferrer"">5.管理修改</a></h2>
<p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>通过实例讲解什么叫跟踪修改，要想理解，请参考<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374829472990293f16b45df14f35b94b3e8a026220c5000"" rel=""nofollow noreferrer"">原文</a>结合暂存区的知识理解：</p>
<ul>
<li><p><code>vim readme.txt</code> 编辑文件，比如添加新的一行</p></li>
<li><p><code>git add readme.txt</code> 添加，但是不提交</p></li>
<li><p><code>vim readme.txt</code> 再编辑文件，比如再添加一行</p></li>
<li><p><code>git commit -m ""修改两次，添一次，提交一次""</code> 提交</p></li>
<li><p><code>git status</code> 看到的效果是：只提交了第一次的修改，第二次的修改没有提交</p></li>
</ul>
<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，也就是<code>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</code>，就相当于把两次修改合并后一块提交了。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000"" rel=""nofollow noreferrer"">6.撤销修改</a></h2>
<p><strong>第一种情况</strong></p>
<ul>
<li><p>修改了readme.txt文件，还没有git add 和git commit</p></li>
<li><p>但是在你提交之前发现这次修改有问题。既然错误发现得很及时，就可以很容易地纠正它。你可以手动把文件恢复到上一个版本的状态。</p></li>
<li><p><code>git checkout -- readme.txt</code> 也可以通过命令撤销修改，这条命令的意思就是，把readme.txt文件在工作区的修改全部撤销</p></li>
<li><p>无论是文件修改后值存在于工作区还没有放到暂存区，还是已经添加到暂存区，总之这个命令就是让这个文件回到最近一次git commit或git add时的状态。</p></li>
<li><p>查看文件，内容果然复原了。git checkout -- file命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p></li>
</ul>
<p><strong>第二种情况</strong></p>
<ul>
<li><p>修改了readme.txt文件，而且执行了<code>git add readme.txt</code></p></li>
<li><p>庆幸的是你在 git commit 之前发现了这个问题</p></li>
<li><p><code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交</p></li>
<li><p><code>git reset HEAD readme.txt</code> 可以把暂存区的修改撤销掉，重新放回工作区。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p></li>
<li><p><code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改</p></li>
<li><p><code>git checkout -- readme.txt</code> 还记得第一种情况中如何丢弃工作区的修改吧</p></li>
</ul>
<p><strong>第三种情况</strong></p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p>
<p>还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把错误的修改（如果是影响很大的错误）提交推送到远程版本库，你就真的惨了……</p>
<p>区别对待本地版本库和远程版本库！</p>
<h2>7.删除文件</h2>
<p>在Git中，删除也是一个修改操作</p>
<ul>
<li><p>添加一个新的文件 test.txt</p></li>
<li><p><code>git add test.txt</code></p></li>
<li><p><code>git commit test.txt -m ""再次新增一个文件""</code></p></li>
<li><p>一般情况下，你通常会在文件管理器中把没用的文件删除，或者直接<code>rm test.txt</code></p></li>
<li><p><code>git status</code> 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p></li>
<li><p>现在你有两个选择，一是确实从版本库中删除该文件，那就<code>git rm test.txt</code>，然后<code>git commit</code> 文件就从版本库中删除了</p></li>
<li><p>另一种情况是删除错了，因为版本库里还有，所以可以轻松地将误删除的文件恢复到最新版本<code>git checkout -- test.txt</code> git checkout其实使用版本库中的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013752340242354807e192f02a44359908df8a5643103a000"" rel=""nofollow noreferrer"">8.添加远程库</a></h2>
<p>要想学习这部分的知识，请先参考下面的：<strong>a.配置连接远程仓库Github</strong>。</p>
<ul>
<li><p>假如现在你已经配置好github，并且在github上添加了<code>learngit</code>仓库。</p></li>
<li><p><code>git remote add origin git@github.com:michaelliao/learngit.git</code>  这个命令是在本地的learngit仓库下执行的，前面通过learngit仓库为例我们已经讲过在本地创建和操作git仓库。这两个地方的仓库名不需要相同，因为会通过在本地的仓库目录下执行这条命令（命令中包含远程库的名字）已经将两者建立了联系</p></li>
<li><p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p></li>
<li><p><code>git push -u origin master</code> 把本地库的所有内容推送到远程库上。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li>
<li><p>然后去Github对应的远程库看看，都已经推送上去了。</p></li>
<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</p></li>
</ul>
<blockquote><p>这样你就可以在Github上托管你的项目代码、vim的配置文件和插件、重要的文档……</p></blockquote>
<p>现在我的vim的配置文件和插件已经同步到Github上了：<a href=""https://github.com/xumenger/myVimConfig"" rel=""nofollow noreferrer""></a><a href=""https://github.com/xumenger/myVimConfig"" rel=""nofollow noreferrer"">https://github.com/xumenger/m...</a></p>
<p>另外推荐我的关于vim配置的文章：：<a href=""http://segmentfault.com/a/1190000003722928"" rel=""nofollow noreferrer""></a><a href=""http://segmentfault.com/a/1190000003722928"" rel=""nofollow noreferrer"">http://segmentfault.com/a/119...</a></p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375233990231ac8cf32ef1b24887a5209f83e01cb94b000"" rel=""nofollow noreferrer"">9.从远程库克隆</a></h2>
<ul>
<li><p>假设我的github上面有一个远程库，但是本地没有，需要克隆到本地，远程库的名字叫'gitskills'</p></li>
<li><p><code>git clone git@github.com:michaelliao/gitskills.git</code> 克隆一个本地库</p></li>
<li><p><code>cd gitskills</code> 进入克隆下来的本地库，默认的名字是和github上的一样的</p></li>
<li><p><code>ls -al</code> 可以看到本地的克隆库里面是和远程库里面的一样的</p></li>
<li><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p></li>
</ul>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href=""https://github.com/michaelliao/gitskills.git"" rel=""nofollow noreferrer"">https://github.com/michaellia...</a>这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743862006503a1c5bf5a783434581661a3cc2084efa000"" rel=""nofollow noreferrer"">10.分支管理</a></h2>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000"" rel=""nofollow noreferrer"">11.创建和合并分支</a></h2>
<p>首先教程中会详细讲解分支的原理（分支、指针、工作区……），一定要好好看！！看完之后你才能对你的创建分支和合并分支的操作不只是会用，更能在用的时候没有任何疑惑！反正能学到更多的知识，何乐而不为！</p>
<p>另外推荐这样的博客：<a href=""http://segmentfault.com/a/1190000002413519"" rel=""nofollow noreferrer"">使用git和github进行协同开发流程</a>以及我的学习笔记<a href=""http://segmentfault.com/a/1190000003739324"" rel=""nofollow noreferrer"">使用git和github管理自己的项目---真实开发环境的策略</a>。</p>
<p>在<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000"" rel=""nofollow noreferrer"">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，我们练习的learngit，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>开始实战：</p>
<ul>
<li><p><code>git checkout -b dev</code> 创建一个新的分支：dev，并且会切换到dev分支。所以这条命令有两个作用。git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<code>git branch dev</code> 和 <code>git checkout dev</code></p></li>
<li><p>补充：所有的git管理的项目刚开始时候默认有一条分支：master</p></li>
<li><p><code>git branch</code> 查看当前所在的分支。git branch命令会列出所有分支，当前分支前面会标一个*号。</p></li>
<li><p>因为切换到dev分支，所以我们现在可以在dev分支上正常提交，比如对readme.txt做一个修改</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""提交到dev分支""</code></p></li>
<li><p><code>git checkout master</code> 现在，dev分支的工作完成，我们就可以切换回master分支</p></li>
<li><p><em>*注意</em>:*切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变</p></li>
<li><p><code>git merge dev</code> 这是在master分支上执行的命令，作用是：把dev分支上的工作成果合并到master分支上</p></li>
<li><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。</p></li>
<li><p><code>git branch -d dev</code> 合并完成之后，可以放心的删除dev分支了</p></li>
<li><p><code>git branch</code> 删除后，查看branch，只剩下master了</p></li>
</ul>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000"" rel=""nofollow noreferrer"">12.解决冲突</a></h2>
<p>教程中有详细的图文说明，很形象，很好！一定要参考！</p>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<ul>
<li><p><code>git checkout -b feature1</code> 创建新的分支feature1，并且换到这个分支，进行新的实验</p></li>
<li><p>在feature1分支下，假如将readme.txt的最后一行由""test branch"" 改为""test feature1""</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""在feature1上修改readme.txt的最后一行""</code> 在feature1分支上提交</p></li>
<li><p><code>git checkout master</code> 切换到master分支。Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p></li>
<li><p>在master分支下，假如将readme.txt的最后一行由""test branch"" 改为""test master""因为上面的是在feature1上进行的修改，所以切换回master之后，看到的文件并不是在feature1上修改后的文件</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""又在master上修改了readme.txt文件""</code>  在master上也提交修改</p></li>
<li><p>现在，master分支和feature1分支各自都分别有新的提交</p></li>
<li><p><code>git merge feature1</code> 在master分支上执行该命令，与feature1分支合并。这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交</p></li>
<li><p><code>git status</code> git status也可以告诉我们冲突的文件</p></li>
<li><p>这时候使用vim等编辑器打开readme.txt文件可以看到已经在readme.txt文件中将冲突的信息已经添加到里面了，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p></li>
<li><p>然后我们编辑readme.txt文件，处理冲突，将内容改成我们想要的样子</p></li>
<li><p><code>git add readme.txt</code></p></li>
<li><p><code>git commit -m ""解决冲突""</code> 在master上提交</p></li>
<li><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 用带参数的git log可以看到分支的合并情况。用<code>git log --graph</code>命令可以看到分支合并图。</p></li>
<li><p><code>git branch -d feature1</code> 最后删除feature分支，完成工作。</p></li>
</ul>
<p>2015.09.09 今天就学到这里，实在太晚了，赶紧睡觉，明天还得工作！什么都没有身体重要！<br>明天继续：<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000"" rel=""nofollow noreferrer"">分支管理策略</a></p>
<h2><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000"" rel=""nofollow noreferrer"">a.配置连接远程仓库Github</a></h2>
<p>首先看这篇文章了解git和SVN的区别，毕竟现在必须在工作中使用的就是SVN，所以还是弄清楚两者的区别。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<ol>
<li><p>创建SSH Key。在<code>用户目录</code>下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key，输入命令<code>ssh-keygen -t rsa -C ""youremail@example.com""</code>,你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></li>
<li><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面.然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：<br><span class=""img-wrap""><img data-src=""/img/bVpN2Q"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
<li><p>点“Add Key”，你就应该看到已经添加的Key：<br><span class=""img-wrap""><img data-src=""/img/bVpN2U"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p></li>
</ol>
<p>注意现在的Github的页面的布局可能和图片中显示有细小的差别，不过相信你能找到对应的操作！</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。具体可以见<a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013752340242354807e192f02a44359908df8a5643103a000"" rel=""nofollow noreferrer"">教程</a>。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><span class=""img-wrap""><img data-src=""/img/bVpN31"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVpN39"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>

                ", 使用git和github管理自己的项目---基础操作学习,1531978037,593,1,285,1,1,https://segmentfault.com/a/1190000003728094
257,1,0,7,"
                    
<p>我自己搭服务器的偏好是 CentOS，每次开新服都要执行一遍环境配置，步骤繁多难免遗漏，总是发现缺东西了再去安装。备个忘，再不烦恼。</p>
<p>本文介绍的组件包括：<code>git</code>, <code>nginx</code>, <code>nodejs</code>, <code>fishshell</code>，环境是 DigitalOcean 的 CentOS 7 镜像（6就不管了，初建服务器你还不用最新版是何居心？）。</p>
<blockquote><p>小安利下，我的<a href=""https://www.digitalocean.com/?refcode=e6a0e1aca03a"" rel=""nofollow noreferrer"">DigitalOcean 推荐链接</a>，注册即得10美元（推荐双方都有），开服愉快！</p></blockquote>
<h1>CentOS 新服务器</h1>
<p>首先安装 epel-release，各种软件包都依赖于这个软件源</p>
<pre><code class=""bash"">$ yum update -y
$ yum install -y epel-release
$ yum install -y git</code></pre>
<h3>一点安全措施</h3>
<ul>
<li><p>启用 SSH 密钥登陆。编辑 <code>~/.ssh/authorized_keys</code>，添加自己的公钥进去。</p></li>
<li><p>禁用密码登陆。编辑 <code>/etc/ssh/sshd_config</code>，启用以下几行：</p></li>
</ul>
<pre><code>PubkeyAuthentication            yes
AuthorizedKeyFile               .ssh/authorized_keys
PasswordAuthentication          no
ChallengeResponseAuthentication no</code></pre>
<p>然后重启 sshd 服务：</p>
<pre><code class=""bash"">$ service sshd reload</code></pre>
<p><a href=""https://www.liberiangeek.net/2014/07/enable-ssh-key-logon-disable-password-password-less-logon-centos/"" rel=""nofollow noreferrer"">https://www.liberiangeek.net/2014/07/enable-ssh-key-logon-disable-password-password-less-logon-centos/</a><br><a href=""http://serverfault.com/questions/285800/how-to-disable-ssh-login-with-password-for-some-users"" rel=""nofollow noreferrer"">http://serverfault.com/questions/285800/how-to-disable-ssh-login-with-password-for-some-users</a><br><a href=""http://askubuntu.com/questions/387892/how-to-deny-root-ssh-login-require-ssh-key-for-user"" rel=""nofollow noreferrer"">http://askubuntu.com/questions/387892/how-to-deny-root-ssh-login-require-ssh-key-for-user</a></p>
<h1>nginx 启动！</h1>
<pre><code class=""bash"">$ yum install nginx -y</code></pre>
<p><a href=""http://www.rackspace.com/knowledge_center/article/centos-adding-an-nginx-init-script"" rel=""nofollow noreferrer"">http://www.rackspace.com/knowledge_center/article/centos-adding-an-nginx-init-script</a></p>
<h1>Node 和它的朋友们</h1>
<pre><code class=""bash"">$ yum install nodejs -y
$ curl https://www.npmjs.com/install.sh | sh
$ npm install -g n pm2</code></pre>
<p>最后，需要在 ghost 的 nginx 配置中添加一行 <code>client_max_body_size 10G;</code> 像这样：</p>
<pre><code>server {
    listen       80;
    server_name  ~b(log)*.amio.us$;

    client_max_body_size 256M;
    
    # ...
}</code></pre>
<h1>Oh-my-fish!</h1>
<p>下面是一些个人喜好，装个 fish shell。</p>
<pre><code class=""bash"">$ yum install yum-utils
$ yum-config-manager --add-repo http://fishshell.com/files/linux/RedHat_RHEL-6/fish.release:2.repo
# CentOS 7 用这个地址：
# http://download.opensuse.org/repositories/shells:fish:release:2/CentOS_7/shells:fish:release:2.repo
$ yum install fish -y

# 把默认 shell 改为 fish
$ chsh -s /usr/bin/fish

</code></pre>
<h3>如果 fish 报告错误：</h3>
<pre><code>fish: Tried to print invalid wide character string</code></pre>
<p>则编辑此文件：</p>
<pre><code>$ vim /etc/sysconfig/i18n
# 把其中的 LANG=C 改为 LANG=en_GB.UTF-8</code></pre>
<p><a href=""http://serverfault.com/questions/275403/how-do-i-change-my-locale-to-utf-8-in-centos"" rel=""nofollow noreferrer"">http://serverfault.com/questions/275403/how-do-i-change-my-locale-to-utf-8-in-centos</a></p>

                ", 前端 CentOS7 新服配置参考,1531978039,495,1,938,1,1,https://segmentfault.com/a/1190000003509484
258,1,0,7,"
                    
<p><a href=""http://www.phodal.com/blog/why-you-should-work-hard-with-github/"" rel=""nofollow noreferrer"">为什么你应该试试Github？</a></p>
<p>在我大四找工作的时候，试图去寻找一份硬件、物联网相关的工作(ps: 专业是电子信息工程)。尽管简历上写得满满的各种经历、经验，然而并没有卵用。跑了几场校园招聘会后，十份简历(ps: 事先已经有心里准备)一个也没有投出去——因为学校直接被拒。我对霸面什么的一点兴趣都没有，千里马需要伯乐。后来，我加入了Martin Flower所在的公司，当然这是后话了。</p>
<p>这是一个残酷的世界，在学生时代，如果你长得不帅不高的话，那么多数的附加技能都是白搭(ps: 通常富的是看不到这篇文章的)。在工作时期，如果你上家没有名气，那么将会影响你下一份工作的待遇。而，很多东西却会改变这些，Github就是其中一个。</p>
<h2>我与Github的故事</h2>
<p>注册Github的时候大概是大二的时候，我熟悉的时候已经是大四了，现在已经毕业一年了。在过去的近两年里，我试着以几个维度在Github上创建项目:</p>
<ol>
<li><p>快速上手框架来实战，即demo</p></li>
<li><p>重构别人的代码</p></li>
<li><p>创建自己可用的框架</p></li>
<li><p>快速构建大型应用</p></li>
<li><p>构建通用的框架</p></li>
</ol>
<h3>Github与收获</h3>
<p>先说说**与技能无关的收获**吧，毕业设计做的是一个《<a href=""https://github.com/phodal/iot"" rel=""nofollow noreferrer"">最小物联网系统</a>》，考虑到我们专业老师没有这方面知识，答辩时会带来问题，尽量往这方面靠拢。当我毕业后，这个项目已经有过百个star了，这样易上手的东西还是比较受欢迎的(ps: 不过这种硬件相关的项目通常受限于Github上硬件开发工程师比较少的困扰)。</p>
<p>毕业后一个月收到PACKT出版社的邮件(ps: 他们是在github上找到我的)，内容是关于Review一本<a>物联网</a>书籍，即在《<a href=""http://www.phodal.com/blog/review-it-books-with-translate-book/"" rel=""nofollow noreferrer"">从Review到翻译IT书籍</a>》中提到的《Learning Internet of Things》。作为一个四级没过的""物联网专家""，去审阅一本英文的物联网书籍。。。当然，后来是审阅完了，书上有我的英文简介。</p>
<p>一个月前，收到MANNING出版社的邮件(ps: 也是在github上)，关于Review一本<a>物联网</a>书籍的目录，并提出建议。</p>
<p>也因此带来了其他更多的东西，当然不是这里的主题。在这里，我们就不讨论各种骚扰邮件，或者中文合作。从没有想象过，我也可以在英语世界有一片小天地。</p>
<p>这些告诉我们，Github上找一个你擅长的主题，那么会有很多人找上你的。</p>
<h3>Github与成长</h3>
<p>过去写过一篇《<a href=""http://www.phodal.com/blog/use-github-grow-self/"" rel=""nofollow noreferrer"">如何通过github提升自己</a>》的文章，现在只想说三点:</p>
<ol>
<li><p>测试</p></li>
<li><p>更多的测试</p></li>
<li><p>更多的、更多的、更多的测试</p></li>
</ol>
<p>没有测试的项目是很扯淡的，除非你的项目只有一个函数，然后那个函数返回<code>`Hello,World</code>`。</p>
<p>如果你的项目代码有上千行，如果你能保证测试覆盖率可以达到95%以的话，那么我想你的项目不会有太复杂的函数。假使有这样的函数，那么他也是被测试覆盖住的。</p>
<p>如果你在用心做这个项目，那么你看到代码写得不好也会试着改进，即重构。当有了一些，你的技能会不断提升。你开始会试着接触更多的东西，如stub，如mock，如fakeserver。</p>
<p>有一天，你会发现你离不开测试。</p>
<p>然后就会相信: <strong>那些没有写测试的项目都是在耍流氓</strong></p>
<h2>为什么你应该深入Github</h2>
<p>上面我们说的都是我们可以收获到的东西，我们开始尝试就意味着我们知道它可能给我们带来好处。上面已经提到很多可以提升自己的例子了，这里再说说其他的。</p>
<h3>方便工作</h3>
<p>我们可以从中获取到不同的知识、内容、信息。每个人都可以从别人的代码中学习，当我们需要构建一个库的时候我们可以在上面寻找不同的库和代码来实现我们的功能。如当我在实现一个库的时候，我会在Github上到相应的组件:</p>
<ul>
<li><p>Promise 支持</p></li>
<li><p>Class类(ps:没有一个好的类使用的方式)</p></li>
<li><p>Template 一个简单的模板引擎</p></li>
<li><p>Router 用来控制页面的路由</p></li>
<li><p>Ajax 基本的Ajax Get/Post请求</p></li>
</ul>
<h3>获得一份工作</h3>
<p>越来越多的人因为Github获得工作，因为他们的做的东西正好符合一些公司的要求。那么，这些公司在寻找代码的时候，就会试着邀请他们。</p>
<p>因而，在Github寻找合适的候选人，已经是一种趋势。</p>
<h3>扩大人脉</h3>
<p>如果我们想创造出更好、强大地框架时，那么认识更多的人可能会带来更多的帮助。有时候会同上面那一点一样的效果。</p>
<h3>其他</h3>
<p>实际上，这也是一个和影响力有关的话题。只有更多的提高自己的曝光度，才有机会去接触更多的人。</p>
<h2>Github项目分析</h2>
<p>对于Github来说，你并不需要创造一个特别好的框架，你只需要一个好的主题，或者你一个好的Demo。目测，当前在国内最受欢迎的就是各种Android、iOS的库。</p>
<p>之前曾经分析过一些Github的用户行为，现在我们先来说说Github上的Star吧。(截止: 2015年3月9日23时。)</p>
<table>
<thead><tr>
<th>用户</th>
<th>项目名</th>
<th>Language</th>
<th>Star</th>
<th>Url</th>
</tr></thead>
<tbody>
<tr>
<td>twbs</td>
<td>Bootstrap</td>
<td>CSS</td>
<td>78490</td>
<td><a href=""https://github.com/twbs/bootstrap"" rel=""nofollow noreferrer"">https://github.com/twbs/bootstrap</a></td>
</tr>
<tr>
<td>vhf</td>
<td>free-programming books</td>
<td>-</td>
<td>37240</td>
<td><a href=""https://github.com/vhf/free-programming-books"" rel=""nofollow noreferrer"">https://github.com/vhf/free-programming-books</a></td>
</tr>
<tr>
<td>angular</td>
<td>angular.js</td>
<td>JavaScript</td>
<td>36,061</td>
<td><a href=""https://github.com/angular/angular.js"" rel=""nofollow noreferrer"">https://github.com/angular/angular.js</a></td>
</tr>
<tr>
<td>mbostock</td>
<td>d3</td>
<td>JavaScript</td>
<td>35,257</td>
<td><a href=""https://github.com/mbostock/d3"" rel=""nofollow noreferrer"">https://github.com/mbostock/d3</a></td>
</tr>
<tr>
<td>joyent</td>
<td>node</td>
<td>JavaScript</td>
<td>35,077</td>
<td><a href=""https://github.com/joyent/node"" rel=""nofollow noreferrer"">https://github.com/joyent/node</a></td>
</tr>
</tbody>
</table>
<p>只要有下面这些类型</p>
<ul>
<li><p>库和框架: 和<code>`jQuery</code>`</p></li>
<li><p>系统: 如<code>`Linux</code>`、<code>`hhvm</code>`、<code>`docker</code>`</p></li>
<li><p>配置集: 如<code>`dotfiles</code>`</p></li>
<li><p>辅助工具: 如<code>`oh-my-zsh</code>`</p></li>
<li><p>工具: 如<code>`Homewbrew</code>`和<code>`Bower</code>`</p></li>
<li><p>资料收集: 如<code>`free programming books</code>`，<code>`You-Dont-Know-JS</code>`，<code>`Font-Awesome</code>`</p></li>
<li><p>其他:简历如<code>`Resume</code>`</p></li>
</ul>
<p>一个好的主题可容易在短期受欢迎，一个库主要依赖于长期的增长，除非有很高的曝光率。</p>
<h2>其他</h2>
<p>我的Github: <a href=""https://github.com/phodal"" rel=""nofollow noreferrer"">https://github.com/phodal</a> （ps: 已经连击316天，欢迎共勉。）</p>

                ", 为什么你应该深入Github,1531978040,503,1,491,1,1,https://segmentfault.com/a/1190000003365213
259,1,0,7,"
                    
<blockquote><p>博客原文地址: <a href=""http://blog.mexiqq.com/index.php/archives/3/"" rel=""nofollow noreferrer"">http://blog.mexiqq.com/index.php/archives/3/</a></p></blockquote>
<p>题记：团队中大多数成员使用 sourceTree 和 github 两款 git 工具，然而大家对于图形化工具提供的 reset,checkout,revert 功能点并不是很了解，甚至于混淆,然后凭借猜测去使用。功夫不负有心人，在尝试过多次冲突处理或分支开发的坑后，终于形成了自己的一套使用方式，可喜可贺。然而问题的解决方案的并不是效率最高的，内部的执行过程我们也不清楚，这对于一个自律的程序艺术家是无法接受的。基于这个问题，翻译这篇博客，为 git 中高级用户的 undo 操作提供参考。鼓励在熟悉命令行操作再通过图形化工具提高开发效率。<code>水平有限，释疑为主，翻译为辅</code></p>
<h1>Reset  Checkout  and Revert</h1>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/hero.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>原文地址：<a href=""https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting"" rel=""nofollow noreferrer"">https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting</a></p></blockquote>
<p>git reset, git checkout, git revert  命令是最有用的三条 git 命令。他们可以帮助你撤销 repo 的一些操作，并且前两条命令既可以用于 commit 级别，也可以用于 file 级别。</p>
<p>因为他们很相似，所以很容易混淆。这片文章，我们将比较他们的相同和不同之处。</p>
<p>阅读本文前需要了解 git  repo  的三大 components，分别是 <code>working directory</code>(代码仓库)  <code>staged snapshot</code>(快照:add的缓存库)  <code>commit history</code>(commit历史) ，这将更好的帮助你理解这三条命令。</p>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/01.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<h1>commit 级别的操作</h1>
<p>传递给 <code>git reset</code> 和  <code>git checkout</code>的参数会决定命令的作用范围。当命令并不包括含一个文件路径时，命令作用于整个 <code>commit</code>。</p>
<h2>Reset:</h2>
<p>在 <code>commit</code> 级别上，<code>git reset</code> 命令移动 <code>HEAD</code> 到当前分支的一个 <code>commit</code>， 这可以用来撤销当前分支的一些 <code>commit</code> 。 </p>
<p>例如，下面的命令会让 ｀hotfix｀ 分支回退两个 commits</p>
<blockquote><p>git checkout hotfix</p></blockquote>
<p>git reset HEAD~2</p>
<p>先前在 HEAD 之前的两次 commit 现在处在 HEAD 之后，这意味着他们在下一次 git 提交时被作为垃圾删掉，换句话说这两次提交会被抛弃。如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/02.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<p>git reset用于撤销未被提交到远端的改动。除了可以移动当前分支的HEAD，你可以通过不同的标记选择修改 staged snapshot 或者 working directory</p>
<ul>
<li><p><code>--soft</code>： <code>staged snapshot</code> 和 <code>working directory</code> 都未被改变 (建议在命令行执行后，再输入 git status 查看状态)</p></li>
<li><p><code>--mixed</code>： <code>staged snapshot</code> 被更新， <code>working directory</code> 未被更改。【这是默认选项】（建议同上)</p></li>
<li><p><code>--hard</code>：  <code>staged snapshot</code> 和 <code>working directory</code>  都将回退。</p></li>
</ul>
<blockquote><p>--hard 很危险，它会直接回退你之前所有的修改，使用前，可以事先保存 commit id.</p></blockquote>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/03.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<p>【这些标记经常和<code>HEAD</code>一起使用。例如，<code>git reset --mixed HEAD</code>可撤销所有缓存改动，但是保留他们在工作目录下。<code>git reset --hard HEAD</code>可彻底删除没有提交的改动。】</p>
<h2>checkout</h2>
<p>到现在为止，你应该已经熟悉 <code>commit</code> 级别的 <code>git checkout</code> 了。当你传送一个 <code>branch name</code> 名字时,你将更换当前的分支.</p>
<blockquote><p>git checkout hotfix</p></blockquote>
<p>上面的命令会切换 HEAD 到不同的分支，并且更新当前的 <code>working directory</code> 去匹配。因为会覆盖当前的本地更改，所以更换分支前<code>git</code>强制你彻底放弃或者提交存储当前的更改。不同于 <code>git reset</code>, <code>git checkout</code> 不会废弃任何分支或提交。</p>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/04.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<p>你也可以 <code>checkout</code> 到任何一次 <code>commit</code>，通过提供 <code>commit Id</code> 作为参数. </p>
<p>比如下面的命令。</p>
<blockquote><p>git checkout HEAD~2/[commit id]</p></blockquote>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/05.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<p>这对于 <code>review</code> repo 的某个 version 的代码很有用。然而，如果再次添加新的提交就无法返回原先的状态。因此，你应该在修改前总是创建一个新的分支。</p>
<h2>Revert</h2>
<p><code>git revert</code> 命令通过创建一次新的 <code>commit</code> 来撤销一次 <code>commit</code> 所做出的修改。这种撤销的方式是安全的，因为它并不修改 <code>commitm history</code>, 比如下边的命令将会查出倒数第二次（即当前commit的往前一次）提交的修改，并创建一个新的提交，用于撤销当前提交的上一次 <code>commit</code>。</p>
<blockquote><p>git checkout hotfix</p></blockquote>
<p>git revert HEAD~2</p>
<p>如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/06.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<h1>File 级别的操作</h1>
<p><code>git reset</code> 和 <code>git checkout</code> 命令同样可以接受一个可选的文件路径作为参数,这样可以将操作限制在一个单独的文件中。</p>
<h2>Reset:</h2>
<p>当调用一个文件路径时，<code>git reset</code> 命令会更新 <code>staged snapshot</code> 去匹配某次 <code>commit</code>。 下面的命令将会使文件回退一个 <code>commit</code>。</p>
<blockquote><p>git reset  HEAD~1 ［文件］（不建议使用）</p></blockquote>
<p><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/07.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<p>【--soft、--mixed、--hard标记此时不起作用，会更新staged snapshot，但不更新working directory】</p>
<h2>Checkout</h2>
<p><code>git checkout</code> 命令 和  <code>git reset</code>  类似，除了它会更新 <code>working directory</code>, 而不是 <code>staged snapshot</code> </p>
<p>如下命令将会更新 <code>working directory</code> 去匹配某次 <code>commit</code></p>
<p><code>git checkout HEAD~1 [文件]</code><br><span class=""img-wrap""><img data-src=""http://7xiqe5.com1.z0.glb.clouddn.com/08.svg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述"" title=""请输入图片描述""></span></p>
<h2>Summary:</h2>
<table>
<thead><tr>
<th>commands</th>
<th>scope</th>
<th>common user cases</th>
</tr></thead>
<tbody>
<tr>
<td>git reset</td>
<td>Commit</td>
<td>Discard commits in a private branch or throw away uncommited changes</td>
</tr>
<tr>
<td>git reset</td>
<td>File</td>
<td>Unstage a file</td>
</tr>
<tr>
<td>git checkot</td>
<td>Commit</td>
<td colspan=""2"">switch between branches or inspect old snapshot</td>
</tr>
<tr>
<td>git checkout</td>
<td>File</td>
<td>Discard changes in  the  working directory</td>
</tr>
<tr>
<td>git revert</td>
<td>commit</td>
<td>Undo commits in a public branch</td>
</tr>
<tr>
<td>git revert</td>
<td>File</td>
<td>不支持</td>
</tr>
</tbody>
</table>

                "," git reset, git checkout, git revert 区别 (译)",1531978041,432,1,438,1,1,https://segmentfault.com/a/1190000003102737
260,1,0,7,"
                    
<h2>HEXO</h2>
<p>经过各种找资料，踩过何种坑，终于搭建好了hexo，域名目前用得时github的，我的hexo是3.1.1版本，hexo不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p>
<p><a href=""http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"" rel=""nofollow noreferrer"">原文链接：HEXO搭建个人博客</a>，有问题可以来我的个人博客里咨询。</p>
<h2>正文：</h2>
<p>这边教程是针对与Mac的，<a href=""http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool"" rel=""nofollow noreferrer"">参考链接</a>，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p>
<p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客（在我的友情链接里有），貌似都是用hexo写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p>
<h2>配置环境</h2>
<h3>安装Node（必须）</h3>
<p>作用：用来生成静态页面的<br>到Node.js<a href=""https://nodejs.org/"" rel=""nofollow noreferrer"">官网</a>下载相应平台的最新版本，一路安装即可。</p>
<h3>安装Git（必须）</h3>
<p>作用：把本地的hexo内容提交到github上去.<br>安装Xcode就自带有Git，我就不多说了。</p>
<h3>申请GitHub（必须）</h3>
<p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。<br><a href=""https://github.com/"" rel=""nofollow noreferrer"">github</a>账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p>
<h3>正式安装HEXO</h3>
<p>Node和Git都安装好后，可执行如下命令安装hexo：</p>
<pre><code class=""bash"">sudo npm install -g hexo</code></pre>
<h3>初始化</h3>
<p>然后，执行init命令初始化hexo到你指定的目录，我是直接cd到目标目录执行hexo init的。命令：</p>
<pre><code class=""bash"">hexo init</code></pre>
<p>好啦，至此，全部安装工作已经完成！</p>
<h3>生成静态页面</h3>
<pre><code class=""bash"">hexo generate （hexo g  也可以）</code></pre>
<h3>本地启动</h3>
<p>启动本地服务，进行文章预览调试，命令：</p>
<pre><code class=""bash"">hexo server</code></pre>
<p>浏览器输入<a>http://localhost:4000</a><br>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>
<p>我把我报的一些错，和解决方式列出来：</p>
<h2>一</h2>
<pre><code class=""bash"">ERROR Plugin load failed: hexo-server</code></pre>
<p>原因：</p>
<pre><code class=""bash"">Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.</code></pre>
<h3>解决方法，执行命令：</h3>
<pre><code class=""bash"">sudo npm install hexo-server</code></pre>
<h2>二</h2>
<p>执行命令hexo server，有如下提示：<br>Usage: hexo&lt;Command&gt;<br>....<br>原因：<br>我认为是没有生成本地服务<br>解决方法，执行命令：</p>
<pre><code class=""bash"">npm install hexo-server --save</code></pre>
<p>提示：hexo-server@0.1.2 node_modules/hexo-server<br>.... <br>表示成功了<a href=""https://hexo.io/zh-cn/docs/server.html"" rel=""nofollow noreferrer"">参考</a></p>
<p>这个时候再执行：</p>
<pre><code class=""bash"">hexo-server</code></pre>
<p>得到:</p>
<pre><code class=""bash"">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></pre>
<p>这个时候再点击<a href=""http://0.0.0.0:4000"" rel=""nofollow noreferrer"">http://0.0.0.0:4000</a>，正常情况下应该是最原始的画面，但是我看到的是：<br>白板和Cannot GET /   几个字<br>原因：<br>由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>
<pre><code class=""bash"">npm install hexo-renderer-ejs --save</code></pre>
<pre><code class=""bash"">npm install hexo-renderer-stylus --save</code></pre>
<pre><code class=""bash"">npm install hexo-renderer-marked --save</code></pre>
<p>这个时候再重新生成静态文件，命令：</p>
<pre><code class=""bash"">hexo generate （或hexo g）</code></pre>
<p>启动本地服务器：</p>
<pre><code class=""bash"">hexo server （或hexo s）</code></pre>
<p>再，点击网址<a href=""http://0.0.0.0:4000"" rel=""nofollow noreferrer"">http://0.0.0.0:4000</a> OK终于可以看到属于你自己的blog啦，?，虽然很简陋，但好歹有了一个属于自己的小窝了。<a href=""https://disqus.com/home/discussion/bsspirit/hexogithubweb/"" rel=""nofollow noreferrer"">参考链接</a>，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。</p>
<h2>配置Github</h2>
<h3>建立Repository</h3>
<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法<br>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>
<pre><code class=""bash"">_config.yml    node_modules    public        source
db.json        package.json    scaffolds    themes</code></pre>
<p>现在我们需要_config.yml文件，来建立关联，命令：</p>
<pre><code class=""bash"">vim _config.yml</code></pre>
<p>翻到最下面，改成我这样子的</p>
<pre><code class=""bash"">deploy:
  type: git
  repository: https://github.com/leopardpan/leopardpan.github.io.git
  branch: master</code></pre>
<p>网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。<br>忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。<br>然后，执行配置命令：</p>
<pre><code class=""bash"">hexo deploy</code></pre>
<p>然后再浏览器中输入<a href=""http://leopardpan.github.io/"" rel=""nofollow noreferrer"">http://leopardpan.github.io/</a>就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了</p>
<h3>部署步骤</h3>
<p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code class=""bash"">hexo clean
hexo generate
hexo deploy</code></pre>
<p>一些常用命令：</p>
<pre><code class=""bash"">hexo new ""postName"" #新建文章
hexo new page ""pageName"" #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本</code></pre>
<p>这里有大量的<a href=""https://github.com/hexojs/hexo/wiki/Themes"" rel=""nofollow noreferrer"">主题列表</a>使用方法里面<br>都有详细的介绍，我就不多说了。<br>我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，?<br><a href=""https://github.com/daisygao/hexo-themes-cover"" rel=""nofollow noreferrer"">Cover</a> - A chic theme with facebook-like cover photo<br><a href=""https://github.com/henryhuang/oishi"" rel=""nofollow noreferrer"">Oishi</a> - A white theme based on Landscape plus and Writing.<br><a href=""https://github.com/hardywu/hexo-theme-sidebar"" rel=""nofollow noreferrer"">Sidebar</a> - Another theme based on Light with a simple sidebar <br><a href=""https://github.com/SuperKieran/TKL"" rel=""nofollow noreferrer"">TKL</a> - A responsive design theme for Hexo. 一个设计优雅的响应式主题<br><a href=""https://github.com/levonlin/Tinnypp"" rel=""nofollow noreferrer"">Tinnypp</a> - A clean, simple theme based on Tinny<br><a href=""https://github.com/yunlzheng/hexo-themes-writing"" rel=""nofollow noreferrer"">Writing</a> - A small and simple hexo theme based on Light<br><a href=""https://github.com/litten/hexo-theme-yilia"" rel=""nofollow noreferrer"">Yilia</a> - Responsive and simple style 优雅简洁响应式主题，我用得就是这个。<br><a href=""https://github.com/Voidly/pacman"" rel=""nofollow noreferrer"">Pacman voidy</a> - A theme with dynamic tagcloud and dynamic snow</p>
<h2>一些基本路径</h2>
<p>文章在source/_posts，如果你不怕麻烦的话可以跟我一样直接用vim去编辑，支持markdown语法，你有好的编辑软件，给我也推荐下，感激不尽?。如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接，之类的都在这里，修改名字在public/index.html里修改，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。</p>
<h2>Markdown语法参考链接</h2>
<p><a href=""https://www.zybuluo.com/mdeditor"" rel=""nofollow noreferrer"">很实用的例子</a><br>转载请注明原地址，潘柏信的博客：<a href=""http://leopardpan.github.io"" rel=""nofollow noreferrer"">http://leopardpan.github.io</a> 谢谢！</p>

                ", 最新版HEXO配置，HEXO+Github，搭建自己的博客,1531978042,153,1,266,1,1,https://segmentfault.com/a/1190000003088603
261,1,0,7,"
                    
<h2>使用场景</h2>
<p>基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，但是这个<code>library</code>怎么和<code>git</code>在一起方便管理呢？<br>我们需要解决下面几个问题：</p>
<ul>
<li><p>如何在git项目中导入<code>library库</code>?</p></li>
<li><p><code>library库</code>在其他的项目中被修改了可以更新到远程的代码库中?</p></li>
<li><p>其他项目如何获取到<code>library库</code>最新的提交?</p></li>
<li><p>如何在clone的时候能够自动导入<code>library库</code>?</p></li>
</ul>
<p>解决以上问题，可以考虑使用git的 <code>Submodule</code>来解决。</p>
<h2>什么是Submodule?</h2>
<p><code>git Submodule</code> 是一个很好的多项目使用共同类库的工具，他允许类库项目做为<code>repository</code>,子项目做为一个单独的<code>git项目</code>存在父项目中，子项目可以有自己的独立的<code>commit</code>，<code>push</code>，<code>pull</code>。而父项目以<code>Submodule</code>的形式包含子项目，父项目可以指定子项目<code>header</code>，父项目中会的提交信息包含<code>Submodule</code>的信息，再<code>clone父项目</code>的时候可以把<code>Submodule</code>初始化。</p>
<h2>在项目中使用Submodule</h2>
<p>使用<code>git</code>命令可以直接添加<code>Submodule</code>：</p>
<blockquote><p>git submodule add git@github.com:jjz/pod-library.git pod-library</p></blockquote>
<p>使用 <code>git status</code>命令可以看到</p>
<blockquote><p>git status</p></blockquote>
<pre><code>    On branch master
    Changes to be committed:
    
        new file:   .gitmodules
        new file:   pod-library</code></pre>
<p>可以看到多了两个需要提交的文件：<code>.gitmodules</code>和 <code>pod-library</code> <br><code>.gitmodules</code> 内容包含<code>Submodule</code>的主要信息，指定<code>reposirory</code>,指定路径:</p>
<pre><code>    [submodule ""pod-library""]
        path = pod-library
        url = git@github.com:jjz/pod-library.git</code></pre>
<p>可以看到记录了子项目的目录和子项目的<code>git</code>地址信息。<br><code>pod-libray</code>内容只保护子项目的<code>commit id</code>，就能指定到对于的<code>git header</code>上,例如:</p>
<blockquote><p>Subproject commit 4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5</p></blockquote>
<p><code>4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5</code>就是子项目的<code>commit id</code>，父项目的git并不会记录<code>Submodule</code>的文件变动，它是按照<code>commit git</code>指定<code>Submodule</code>的<code>git header</code>。</p>
<p>另外,<em>这两个文件都需要提交到父项目的git中</em>。</p>
<p>还可以这样使用命令添加<code>Submodule</code></p>
<pre><code>git add .gitmodules pod-ibrary
git commit -m ""pod-library submodule""
git submodule init</code></pre>
<h2>修改Submodule</h2>
<p><strong>首先需要确认有对Submodule的commit权限</strong>。<br>进入<code>Submodule</code>目录里面:</p>
<blockquote><p>cd pod-library/</p></blockquote>
<p>修改其中的一个文件看下文件的可以用<code>git status</code>查看变动:</p>
<blockquote><p>git status</p></blockquote>
<pre><code>modified:   pod-library/UseAFHTTP.h</code></pre>
<p>提交<code>Submodule</code>的更改内容：</p>
<blockquote><p>git commit -a -m'test submodule'</p></blockquote>
<p>然后<code>push</code> 到远程服务器:</p>
<blockquote><p>git push</p></blockquote>
<p>然后再回到父目录,提交<code>Submodule</code>在父项目中的变动：</p>
<blockquote><p>cd ..</p></blockquote>
<p>git status<br>on branch master</p>
<pre><code>modified:   pod-library (new commits)</code></pre>
<p>可以看到<code>pod-library</code>中已经变更为<code>Submodule</code>最新的<code>commit id</code>:</p>
<pre><code>Subproject commit 330417cf3fc1d2c42092b20506b0d296d90d0b5f</code></pre>
<p>需要把<code>Submodule</code>的变动信息推送到父项目的远程服务器</p>
<blockquote><p>git commit -m'update submodule'</p></blockquote>
<p>git push</p>
<p>这样就把子模块的变更信息以及子模块的变更信息提交到远程服务器了，从远程服务器上更新下来的内容就是最新提交的内容了。</p>
<h2>更新Submodule</h2>
<p>更新<code>Submodule</code>有两种方式:<br> 在父项目的目录下直接运行</p>
<blockquote><p>git submodule foreach git pull</p></blockquote>
<p>在Submodule的目录下面更新</p>
<pre><code>&gt;cd pod-library
git pull
</code></pre>
<p>可以看到在<code>Submodule</code>的目录中,使用<code>git</code>和单独的一个项目是一样的,注意更新<code>Submodule</code>的时候如果有新的<code>commit id</code>产生，需要在父项目产生一个新的提交，pod-libray文件中的 <code>Subproject commit</code>会变为最新的<code>commit id</code>。</p>
<h2>clone Submodule</h2>
<p><code>clone Submodule</code>有两种方式 一种是采用递归的方式clone整个项目，一种是clone父项目，再更新子项目。</p>
<ol><li><p>采用递归参数 <code>--recursive</code></p></li></ol>
<blockquote><p>git clone git@github.com:jjz/pod-project.git --recursive</p></blockquote>
<p>输出结果：</p>
<pre><code>    loning into 'pod-project'...
    remote: Counting objects: 57, done.
    remote: Compressing objects: 100% (45/45), done.
    remote: Total 57 (delta 13), reused 49 (delta 8), pack-reused 0
    Receiving objects: 100% (57/57), 18.79 KiB | 0 bytes/s, done.
    Resolving deltas: 100% (13/13), done.
    Checking connectivity... done.
    Submodule 'pod-library' (git@github.com:jjz/pod-library.git) registered for path 'pod-library'
    Cloning into 'pod-library'...
    remote: Counting objects: 34, done.
    remote: Compressing objects: 100% (25/25), done.
    remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0
    Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.
    Resolving deltas: 100% (8/8), done.
    Checking connectivity... done.
    Submodule path 'pod-library': checked out '330417cf3fc1d2c
    
    42092b20506b0d296d90d0b5f'</code></pre>
<p>可以看到<code>init Submodule</code> 会自动被<code>clone</code>下来</p>
<ol><li><p>第二种方法先clone父项目，再初始化<code>Submodule</code></p></li></ol>
<blockquote><p>git clone git@github.com:jjz/pod-project.git<br>cd pod-project</p></blockquote>
<p>git submodule init</p>
<p>输出:</p>
<pre><code>    Submodule 'pod-library' (git@github.com:jjz/pod-library.git) 
    registered for path 'pod-library'</code></pre>
<p>更新<code>Submodule</code>:</p>
<blockquote><p>git submodule update</p></blockquote>
<p>运行结果：</p>
<pre><code>  Cloning into 'pod-library'...
  remote: Counting objects: 34, done.
  remote: Compressing objects: 100% (25/25), done.
  remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0
  Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.
  Resolving deltas: 100% (8/8), done.
  Checking connectivity... done.
  Submodule path 'pod-library': checked out '330417cf3fc1d2c42092b20506b0d296d90d0b5f'</code></pre>
<h2>删除Submodule</h2>
<p><code>git</code> 并不支持直接删除<code>Submodule</code>需要手动删除对应的文件:</p>
<blockquote>
<p>cd pod-project</p>
<pre><code>git rm --cached pod-library
rm -rf pod-library
rm .gitmodules
</code></pre>
<p>更改git的配置文件<code>config</code>:<br>vim .git/config</p>
</blockquote>
<p>可以看到<code>Submodule</code>的配置信息：</p>
<pre><code>[submodule ""pod-library""]
  url = git@github.com:jjz/pod-library.git</code></pre>
<p>删除submodule相关的内容,然后提交到远程服务器:</p>
<blockquote><p>git commit -a -m 'remove pod-library submodule'</p></blockquote>
<p>代码地址:<br>父项目:<a href=""https://github.com/jjz/pod-project"" rel=""nofollow noreferrer"">https://github.com/jjz/pod-pr...</a><br>子项目:<a href=""https://github.com/jjz/pod-library"" rel=""nofollow noreferrer"">https://github.com/jjz/pod-li...</a></p>

                ", 使用Git  Submodule管理子模块,1531978044,353,1,997,1,1,https://segmentfault.com/a/1190000003076028
262,1,0,7,"
                    
<p>先描述下场景。<br>
A在<code>master</code>基础上创建了个新的branch <code>fix_bug</code>, 并在<code>fix_bug</code>上进行了1次对<code>foo.py</code>的修改并提交78d4c5。<br>
B在master上直接进行了1次对<code>foo.py</code>的修改并提交4dd14b。<br>
现在，AB两人都使得他们自己的两个branch向前推进了一步。<br>
这时候C在master上，要把A的工作合并到<code>master</code>上来，他选择了<code>rebase</code>。会发生什么呢？</p>

<pre><code>git checkout master
git rebase fix_bug
</code></pre>

<p>git是这么处理rebase这件事情的，先把4dd14b撤销掉，把它作为patch放进<code>.git/rebase</code>目录，然后把<code>master</code>分支更新为最新的<code>fix_bug</code>分支，然后再把4dd14b这个patch打上来。<br>
这时候会爆出冲突，打patch的时候发现<code>foo.py</code>这个文件冲突了。<br>
假设C说，我觉得A的工作是有意义的，我保留A的，放弃B的。他应该如何做呢？<br><code>git checkout</code>给了我们2个可选参数,分别是<code>--ours</code>和<code>--theirs</code>。<br>
第一反应下，我们会觉得，我是在<code>master</code>上对<code>fix_bug</code>进行rebase，那自然ours就是master，theirs就是fix_bug咯...然而事实告诉我们，其实并不是这样。<br>
仔细回忆刚才说的打patch的过程，我们其实是把<code>master</code>的变更作为patch打进来，所以这时候如果指定ours，那么保留的是A的工作。而指定theirs才是保留B的（在master上）工作。<br>
C选择了A的工作后，git发现说，那你就是说B这个patch不要了是吧。</p>

<blockquote>
  <p>If you prefer to skip this patch, run ""git rebase --skip"" instead.</p>
</blockquote>

<p>所以C这时候应该执行skip来跳过B的工作。至此，rebase完成，push吧~<br>
ps. 在把握不好哪个是ours的时候，有个简单的方法就是打开那个文件，HEAD代表ours。</p>

                ", 浅谈git rebase和git checkout --ours(theirs) ,1531978045,525,1,391,1,1,https://segmentfault.com/a/1190000003015386
263,1,0,7,"
                    
<p>原文链接：<a href=""http://tabalt.net/blog/use-git-in-project/"" rel=""nofollow noreferrer"">http://tabalt.net/blog/use-gi...</a></p>
<p>关于是用git还是svn的争论，我想不用多聊了，总的来说，git是更稳定、更强大、更现代的分布式版本控制工具，值得大家去尝试与应用。</p>
<h3>一、准备工作</h3>
<ul>
<li>
<p>配置个人信息</p>
<p>git config --global user.name ""$username""<br>git config --global user.email ""$email""<br>git config --global push.default simple<br>git config --global color.ui true</p>
</li>
<li>
<p>git仓库的创建与授权</p>
<pre><code>git仓库一般由管理员创建好了，如果是github网站，直接点击右上角的“ + ”号，选择 “New repository”，填写信息并创建即可。

git服务器普遍使用ssh公钥来授权访问。unix系列环境下，使用ssh-keygen命令创建。
</code></pre>
<p>ssh-keygen<br>cd ~/.ssh<br>ls id_rsa.pub</p>
<pre><code>将id_rsa.pub文件发给git服务器的管理员，或复制文件中的内容在github的Settings -&gt; SSH keys 页面中添加即可：
</code></pre>
<p><a href=""https://github.com/settings/ssh"" rel=""nofollow noreferrer"">https://github.com/settings/ssh</a></p>
<pre><code>如何创建、管理一个git仓库，是git服务器运维的问题了，这里不做过多的探讨。

</code></pre>
</li>
<li>
<p>初始化项目</p>
<p>cd ~/dev/<br>git clone git@127.0.0.1:path/to/git_test.git<br>cd ~/dev/git_test<br>git status</p>
</li>
</ul>
<h3>二、本地分支开发</h3>
<p>当有一些紧急bug需要修复或者一些小功能的改动，一个人就能轻松搞定，可以使用本地分支来开发。</p>
<ul>
<li>
<p>更新本地master分支为最新</p>
<pre><code>cd ~/dev/git_test
git checkout master
git pull
</code></pre>
</li>
<li>
<p>建立本地开发分支</p>
<pre><code>git branch -b dev1011
</code></pre>
</li>
<li>
<p>在本地开发分支上修改代码</p>
<pre><code>echo ""hello git"" &gt; hello.txt
git add hello.txt
git commit -am 'add test file hello.txt'
echo ""test"" &gt; test.txt
git add test.txt
git commit -am 'add test file test.txt'
</code></pre>
</li>
<li>
<p>开发完毕后，合并代码到master</p>
<ul>
<li>
<p>他人可能在我们开发的时候提交了代码，因此先更新master分支的代码</p>
<p>git checkout master<br>git pull</p>
</li>
<li>
<p>以最新的master分支代码rebase本地开发分支，如果出现冲突请看第四节：git冲突处理。</p>
<p>git checkout dev1011<br>git rebase master</p>
</li>
<li>
<p>合并本地开发分支的代码到master</p>
<p>git checkout master<br>git merge dev1011<br>git push</p>
</li>
</ul>
</li>
</ul>
<h3>三、远程分支开发</h3>
<p>远程分支适用于多人协同开发同一个系统或功能的场景。使用远程分支开发，可以避免在master分支上引入不稳定的代码。</p>
<p>远程分支名可以根据开发的独立子系统或模块名称命名，如game、user、api、admin 等等。</p>
<ul>
<li>
<p>初始化远程user分支</p>
<ul>
<li>
<p>更新本地master分支为最新</p>
<p>cd ~/dev/git_test<br>git checkout master<br>git pull</p>
</li>
<li>
<p>以本地master分支为基准新建远程user分支</p>
<p>git push origin master:user</p>
</li>
</ul>
</li>
<li>
<p>在远程user分支开发（日常开发）</p>
<ul>
<li>
<p>将远程user分支checkout下来</p>
<p>git checkout user<br>git pull</p>
</li>
<li>
<p>在本地建立属于自己的开发分支</p>
<p>git checkout -b userdev</p>
</li>
<li>
<p>编写代码</p>
<p>echo 'hello user' &gt; user.txt</p>
</li>
<li>
<p>提交到本地开发分支</p>
<p>git add user.txt<br>git commit -am 'add user.txt'</p>
</li>
<li>
<p>其他人可能修改了代码，先合并user上变动的内容到本地自己的开发分支</p>
<p>git checkout user<br>git pull<br>git checkout userdev<br>git rebase user</p>
</li>
<li>
<p>合并本地自己的开发分支的代码到远程user分支</p>
<p>git checkout user<br>git merge userdev<br>git push</p>
</li>
<li>
<p>切换到本地userdev开发分支，继续开发</p>
<p>git checkout userdev<br>//coding...</p>
</li>
</ul>
<p>可以看到，这小节的操作步骤，和使用本地分支开发时几乎完全一样，只是将基于master的操作，换成基于user的操作。</p>
</li>
<li><p>合并user分支到master</p></li>
</ul>
<pre><code>    git checkout master
    git pull
    git checkout user
    git rebase master

    git checkout master
    git merge user
    git push
</code></pre>
<ul><li>
<p>更新远程user分支的代码</p>
<p>这时，远程的master，本地的master，本地的develop保持一致；但如果master里被人修改了代码（如修改紧急bug等），远程的user分支的代码并不是最新的了。</p>
<ul>
<li>
<p>借用本地master的代码更新远程user分支：</p>
<p>git push origin master:user</p>
</li>
<li>
<p>开发完毕后，可以直接删除远程user分支</p>
<p>git push origin :user</p>
</li>
<li>
<p>开发完毕后，可以删除本地分支</p>
<p>git branch -D user</p>
</li>
</ul>
</li></ul>
<h3>四、git冲突处理</h3>
<p>使用git merge 、git rebase、git pull等命令时，都有可能和别人修改的代码发生冲突。</p>
<p>从本质上说，都是merge 和 patch（应用补丁）时产生冲突。rebase是重新设置基准，然后应用补丁的过程，所以也会冲突。git pull会自动merge，repo sync会自动rebase，所以git pull和repo sync也会产生冲突。</p>
<ul>
<li>
<p>逻辑冲突</p>
<p>逻辑冲突实际上git是发现不了的。git merge 或者path成功，但是生成的代码逻辑是有问题的，需要通过完备自动化测试等方式来保障。</p>
<p>可能造成逻辑冲突的情况：</p>
<ul>
<li><p>其他人修改了文件名，我在老文件里做改动</p></li>
<li><p>函数参数、返回值等变化，调用方未做相应修改等</p></li>
</ul>
</li>
<li>
<p>树冲突</p>
<p>两个用户同时修改文件名造成的冲突，称为树冲突。下面是一个用户修改a.txt为b.txt，另一个用户修改a.txt为c.txt造成冲突的情况：</p>
<pre><code>$ git status
    added by us:    b.txt
    both deleted:   a.txt
    added by them:  c.txt
</code></pre>
<p>如果最终确定使用b.txt，执行如下操作：</p>
<pre><code>git rm a.txt
git rm c.txt
git add b.txt
git commit
</code></pre>
<p>树冲突也可以用git mergetool来解决，用d 删除不要的文件，用c保留需要的文件，最后执行git commit提交。</p>
</li>
<li>
<p>内容冲突</p>
<p>内容冲突是最常见的情况，两个用户修改了同一个文件的同一块区域，git会报告内容冲突。</p>
<p>一般情况下，出现冲突时都会有“CONFLICT”字样，并提示哪些文件有冲突。</p>
<p>当repo sync报错时，可能并不直接提示冲突，而是下面这样：</p>
<pre><code>error: project mini/sample
</code></pre>
<p>可以通过rebase解决：</p>
<pre><code>git rebase remote-branch-name
</code></pre>
<p><strong>merge/patch的冲突解决</strong></p>
<p>当某个文件有冲突产生时，git会在冲突的地方做标记。下面是一个有冲突的文件，冲突标记&lt;&lt;&lt;&lt;&lt;&lt;&lt; （7个&lt;）与=======之间的内容是我的修改，=======与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是别人的修改；此外，没有任何其它垃圾文件产生。</p>
<pre><code>$ vim conflict.txt
    
    &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
    //my changes
    =======
    //other's changes
    &gt;&gt;&gt;&gt;&gt;&gt;&gt; commit log
</code></pre>
<p>直接编辑文件中被标记的地方，将不需要的代表和冲突标记删除。并执行 add、commit操作</p>
<pre><code>git add conflict.txt
git commit
        
</code></pre>
<p><strong>rebase的冲突解决</strong></p>
<p>rebase的冲突解决过程，就是解决每个应用补丁冲突的过程。</p>
<p>按照上面的操作编辑每一个冲突文件，并一一执行git add 的操作，然后执行下面的命令继续rebase操作：</p>
<pre><code>git rebase --continue
</code></pre>
<p>有冲突继续解决，重复这这些步骤，直到rebase完成。</p>
<p>如果中间遇到某个补丁不需要应用，可以用下面命令忽略：</p>
<pre><code>git rebase --skip
</code></pre>
<p>如果想回到rebase执行之前的状态，可以执行：</p>
<pre><code>git rebase --abort
</code></pre>
<p>rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。</p>
</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009593826?w=560&amp;h=220"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""打赏作者"" title=""打赏作者""></span></p>
<p>原文链接：<a href=""http://tabalt.net/blog/use-git-in-project/"" rel=""nofollow noreferrer"">http://tabalt.net/blog/use-gi...</a></p>

                ", 分布式版本控制系统git在项目开发中的使用,1531978047,480,1,88,1,1,https://segmentfault.com/a/1190000003012030
264,1,0,7,"
                    
<p>背景<br>-<br>公司之前的版本控制工具一直用的<code>svn</code>，最近开发的新项目，代码准备改换到了<code>gitlab</code>上进行管理。而我自己平时写的一些代码是放在<code>github</code>上进行托管的，这二者都是基于<code>git</code>的开源分布式版本控制系统，在本地可以通过ssh进行远程登录验证和数据传输（关于ssh的详细介绍可以参考这篇博文：<code>http://blog.csdn.net/macrossdzh/article/details/5691924</code>）。</p>
<p>具体操作是利用ssh在本地生成一对公私秘钥（keys），然后将公钥添加到注册的gitlab/github账户配置ssh key的地方即可。默认情况下本地生成的秘钥位于<code>/Users/mac用户名/.ssh/</code>（mac平台，本文针对os x系统介绍）。</p>
<p>But,问题来了：默认情况下每个账户生成的秘钥位置和名称都是相同的，这样后生成的秘钥就会覆盖前面的秘钥导致其失效。解决的办法就是在生成后一个秘钥的时候对其重新命名，以避免冲突，同时将不同的秘钥配置到相对应的Host上面，这样在访问不同的远程仓库时调用不同的key,冲突也就解决了。具体操作如下：</p>
<p>生成gitlab秘钥<br>-<br>默认你已经注册了gitlab/github账户，以我自己为例，公司项目用的gitlab，自己代码托管在github。先进行公司账号的设置：</p>
<p>本地生成ssh keys命令：<code>ssh-keygen -t rsa -C ""注册的gitlab邮箱""</code>，生成的公司秘钥会提示是否需要重命名，公司gitlab的秘钥我们就使用默认名称，直接回车跳过，另外还会提示你设置密码,设置密码的话后续登陆会比较麻烦，也直接跳过。成功后大概是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI6H"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>查看 .ssh/目录，可以看到公私秘钥已经生成，名称分别为<code>id_rsa.pub、id_rsa</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI7f"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>执行命令查看公钥内容：<code>cat ~/.ssh/id_rsa.pub</code>，或者直接用<code>nano</code>编辑期打开<code>id_rsa.pub</code>。公钥大概是这个样子：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI7N"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>将这部分代码添加到到<code>gitlab</code>账户的的<code>SSH Keys</code>中即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI8p"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>生成github秘钥<br>-<br>终端执行命令：<code>ssh-keygen -t rsa -C ""注册的github邮箱""</code>，这次一定要注意，对生成定的秘钥进行重命名，这里暂且重命名为<code>id_rsa_home</code>,同样不设置密码。可以看到生成的公私秘钥已经分别被重命名为<code>id_rsa_home.pub</code>和<code>id_rsa_home</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI89"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以查看公钥里面的内容：<code>cat ~/.ssh/id_rsa_home.pub</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVmI90"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>不要忘记将其拷到github的SSH Keys里~<br>gitlab和github的秘钥是分开生成了，可怎么让这两份秘钥分别对应到相应的远程仓库呢？就是让<code>id_rsa.pub</code>认得<code>gitlab</code>,让<code>id_rsa_home.pub</code>认得<code>github</code>。既然不能自动识别，那就只好手动设置了：</p>
<p>配置config<br>-<br>在.ssh/目录下新建config文件：<code>touch config</code>，通过nano编辑器进行如下配置：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmJc8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>其中<code>Host</code>对应的名称是一个别名，命名可以随意，用来进行远程连接，当然使用真实的主机名称也是可以的。<code>HostName</code>和<code>IdentityFile</code>就是各自主机名称以及对应的秘钥文件了~<br>这样配置之后，两份秘钥也就对应到各自相应的仓库上了。通过设置别名，也就可以设置任意多的账户了~</p>
<p>最后利用别名检测下配置是否成功~</p>
<p>检测<br>-<br>检测<code>github</code>连接，如果提示是否建立连接，直接yes就行：<br><span class=""img-wrap""><img data-src=""/img/bVmJd7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>检测<code>gitlab</code>连接：<br><span class=""img-wrap""><img data-src=""/img/bVmJed"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>不报错的话，就说明设置成功了！</p>

                ", gitlab/github 多账户下设置 ssh keys,1531978049,517,1,439,1,1,https://segmentfault.com/a/1190000002994742
265,1,0,7,"
                    
<p>现在程序猿标配GIT作为代码管理，但是从SVN到GIT学习中，其中GIT的冲突是一个难点，常常会导致Push不上去,Pull不下来，很尴尬的地步，还不知道自己写的代码被覆盖没，废话不多说，直接上干货！</p>
<hr>
<h2>亮点</h2>
<p>采用<code>SourceTree插件</code>和<code>BeyondCompare</code> 可视化解决冲突</p>
<h2>方法</h2>
<h3>构造冲突</h3>
<ul>
<li><p>A 修改了conflict.file 中第1行内容并且提交到git上</p></li>
<li><p>B 这个时候也修改了confilct.file中第一行内容准备提交，这个时候git就会提示</p></li>
</ul>
<pre><code>To git@192.168.x.xxx:xxx/server-aggregator.git
 ! [rejected]        develop -&gt; develop (fetch first)
error: failed to push some refs to 'git@192.168.xx.xx:xxx/server-aggregator.git'

hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</code></pre>
<p>提示远程已经有更新了，本地版本太低，让我们先pull拉取最新的代码。</p>
<ul><li><p>我们pull一下，这个时候由于本地有修改这个文件，就会在本地产生冲突文件</p></li></ul>
<p><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/74789568.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>配置外部比较工具</h3>
<ul>
<li><p>下载<a href=""http://www.scootersoftware.com/download.php"" rel=""nofollow noreferrer"">Beyond Compare</a></p></li>
<li><p>打开SourceTree-&gt;工具-&gt;选项-&gt;比较-&gt;外部差异对比合并-&gt;选择BeyondCompare</p></li>
</ul>
<h3>解决冲突</h3>
<ul>
<li><p>在本地副本-&gt;右键-&gt;解决冲突-&gt;打开外部合并工具<br><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/63473198.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p></li>
<li><p>和svn一样解决好冲突保存更改，退出即可<br><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/92149529.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/2384601.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p></li>
</ul>
<h3>另外一种情况</h3>
<ul><li><p>拉取时出现如下提示：</p></li></ul>
<pre><code>it -c diff.mnemonicprefix=false -c core.quotepath=false pull local-server-aggregator develop
/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell:3: warning: Insecure world writable dir /usr in PATH, mode 040777
From 192.168.0.200:weitoo/server-aggregator
 * branch            develop    -&gt; FETCH_HEAD
Updating b0c5c94..40cef3b
error: Your local changes to the following files would be overwritten by merge:
    server/conflict.file
Please, commit your changes or stash them before you can merge.
Aborting</code></pre>
<p><strong>提示需要暂存本地修改，才能拉取服务器上新的代码</strong></p>
<ul>
<li><p>点击贮存(英文版:Stash),随便起一个名字，里面存的都是距离上次服务器版本到本地修改之间的差异，千万别删掉了,合并成功无误了再删掉。</p></li>
<li><p>pull拉取服务器代码，这个时候，本地的代码变成了服务器上的代码。</p></li>
<li><p>点击贮藏-&gt;应用贮藏区 ，这个时候是把之前的修改合并到本地上，这个时候会提示冲突。</p></li>
</ul>
<pre><code>git -c diff.mnemonicprefix=false -c core.quotepath=false stash apply stash@{0}
Auto-merging server/conflict.file
CONFLICT (content): Merge conflict in server/conflict.file</code></pre>
<p>可以在sourcetree里看到有感叹号，代表冲突文件，和上面解决冲突方法类似，但是稍微不同，最左边成了远程版本，中间为远程上一个版本，最后才是本地修改。<br>这个是和我们操作方式有关：<strong>我们是先暂存本地修改，先拉取远程代码，这个时候local 就成了远程代码，最后我们用暂存的合并进去，remote就成了本地修改</strong></p>
<p><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/63052008.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-7-1/51143764.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>多余的.orig文件</h3>
<p>这个是由于git自身造成的 它会解决冲突后 生成一个原来冲突的备份，我们可以去掉</p>
<p><code>git config --global mergetool.keepBackup false</code></p>
<hr>
<p>感谢您的耐心阅读，如果您发现文章中有一些没表述清楚的，或者是不对的地方，请给我留言，你的鼓励是作者写作最大的动力，<br>如果您认为本文质量不错，读后觉得收获很大，不妨小额赞助我一下，让我更有动力继续写出高质量的文章。</p>
<ul>
<li><p>支付宝 <br><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-10-14/18963137.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p></li>
<li><p>微信 <br><span class=""img-wrap""><img data-src=""http://7xjl4u.com1.z0.glb.clouddn.com/15-10-14/34122370.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p></li>
</ul>
<p>作 者 : <a href=""http://weibo.com/mousycoder"" rel=""nofollow noreferrer"">@mousycoder</a></p>
<p>原文出处 : <a href=""http://mousycoder.com/2015/10/14/git-source-conflict-reslove-solution/"" rel=""nofollow noreferrer"">http://mousycoder.com/2015/10/14/git-source-conflict-reslove-solution/</a></p>
<p>创作时间：2015-6-15</p>
<p>更新时间：2015-10-16</p>

                ", 「GIT SourceTree冲突」解决方案,1531978051,591,1,771,1,1,https://segmentfault.com/a/1190000002951154
266,1,0,7,"
                    
<h2>GitHub Top Users Objective-C World</h2>

<p>这是GitHub在世界范围内排名前50的Objective-C程序员，并且列出相关信息，从而可以走近他们的程序世界。</p>

<p>数据来自GitHub的API以及自己整理的相关内容。</p>

<p>原文链接:<br><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md"">Objective-C top 50 GitHub developers</a></p>

<table>
<thead><tr>
<th>Rank</th>
  <th>Users</th>
  <th>基本信息</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
  <td>
<strong>Wei Wang</strong><br><a rel=""nofollow"" href=""https://github.com/onevcat"">onevcat</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1019875?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""onevcat""></span>
</td>
  <td>name: ""Wei Wang""<br>company: ""LINE Corp.""<br>blog: ""<a rel=""nofollow"" href=""http://onevcat.com/"">http://onevcat.com/</a>""<br>location: ""Kawasaki, Japan""<br>email: ""onev@onevcat.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""http://swifter.tips/buy"">《Swifter - 100 个 Swift 必备 tips》</a><br><a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter-Xcode</a>:Xcode plug-in which helps you write Javadoc style documents easier.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/onevcat"">Wei Wang</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/onevcat"">https://twitter.com/onevcat</a>
</td>
</tr>
<tr>
<td>2</td>
  <td>
<strong>Sam Soffes</strong><br><a rel=""nofollow"" href=""https://github.com/soffes"">soffes</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/52870?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""soffes""></span>
</td>
  <td>name: ""Sam Soffes""<br>company: ""Venmo""<br>blog: ""<a rel=""nofollow"" href=""http://soff.es"">http://soff.es</a>""<br>location: ""San Francisco""<br>email: ""sam@soff.es""</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/steipete"">Sam Soffes</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/soffesX"">https://twitter.com/soffesX</a>28Xabout:<a rel=""nofollow"" href=""http://soff.es/about"">http://soff.es/about</a>
</td>
</tr>
<tr>
<td>3</td>
  <td>
<strong>Nick Lockwood</strong><br><a rel=""nofollow"" href=""https://github.com/nicklockwood"">nicklockwood</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/546885?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""nicklockwood""></span>
</td>
  <td>name: ""Nick Lockwood""<br>company: ""Charcoal Design""<br>blog: ""<a rel=""nofollow"" href=""http://charcoaldesign.co.uk"">http://charcoaldesign.co.uk</a>""<br>location: ""UK""<br>email: ""support@charcoaldesign.co.uk""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/nicklockwood/iCarousel"">iCarousel</a>:A simple, highly customisable, data-driven 3D carousel for iOS and Mac OS<br><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/nicklockwood"">https://twitter.com/nicklockwood</a>
</td>
</tr>
<tr>
<td>4</td>
  <td>
<strong>Peter Steinberger</strong><br><a rel=""nofollow"" href=""https://github.com/steipete"">steipete</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/58493?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""steipete""></span>
</td>
  <td>name: ""Peter Steinberger""<br>company: ""PSPDFKit GmbH""<br>blog: ""<a rel=""nofollow"" href=""http://petersteinberger.com"">http://petersteinberger.com</a>""<br>location: ""Vienna, Austria""<br>email: ""steipete@gmail.com""</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/steipete"">Peter Steinberger</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/steipete"">https://twitter.com/steipete</a>
</td>
</tr>
<tr>
<td>5</td>
  <td>
<strong>Erica Sadun</strong><br><a rel=""nofollow"" href=""https://github.com/erica"">erica</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/32688?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""erica""></span>
</td>
  <td>name: ""Erica Sadun""<br>blog: ""<a rel=""nofollow"" href=""http://ericasadun.com"">http://ericasadun.com</a>""<br>location: ""Denver, CO""<br>email: ""erica@ericasadun.com""<br>
</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/ericasadun"">https://twitter.com/ericasadun</a>
</td>
</tr>
<tr>
<td>6</td>
  <td>
<strong>Max Howell</strong><br><a rel=""nofollow"" href=""https://github.com/mxcl"">mxcl</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/58962?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mxcl""></span>
</td>
  <td>name: ""Max Howell""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""https://github.com/Homebrew/homebrew/commit/29d85578e75170a6c0eaebda4d701b46f1acf446"">mxcl's blog</a>""<br>location: ""Chicago""<br>email: ""mxcl@me.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/Homebrew"">Homebrew</a>:The missing package manager for OS X.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/maxhowell"">Max Howell</a>
</td>
</tr>
<tr>
<td>7</td>
  <td>
<strong>Mike Ash</strong><br><a rel=""nofollow"" href=""https://github.com/mikeash"">mikeash</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/350427?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mikeash""></span>
</td>
  <td>name: ""Mike Ash""<br>company: null<br>blog: ""<a rel=""nofollow"" href=""http://mikeash.com/"">http://mikeash.com/</a>""<br>location: null<br>email: ""mike@mikeash.com""</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/mikeash"">https://twitter.com/mikeash</a>
</td>
</tr>
<tr>
<td>8</td>
  <td>
<strong>M了个J</strong><br><a rel=""nofollow"" href=""https://github.com/CoderMJLee"">CoderMJLee</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/3817366?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""CoderMJLee""></span>
</td>
  <td>name: ""M了个J""<br>company: ""小码哥 <a rel=""nofollow"" href=""http://www.520it.com"">http://www.520it.com</a>""<br>blog: ""<a rel=""nofollow"" href=""http://www.weibo.com/exceptions"">http://www.weibo.com/exceptions</a>""<br>location: ""Guangzhou, China""<br>email: ""richermj123go@vip.qq.com""</td>
  <td>作品：<br><a rel=""nofollow"" href=""https://github.com/CoderMJLee/MJRefresh"">MJRefresh</a>:The easiest way to use pull-to-refresh</td>
</tr>
<tr>
<td>9</td>
  <td>
<strong>Tang Qiao</strong><br><a rel=""nofollow"" href=""https://github.com/tangqiaoboy"">tangqiaoboy</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/733097?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""tangqiaoboy""></span>
</td>
  <td>name: ""Tang Qiao""<br>company: ""yuantiku.com""<br>blog: ""<a rel=""nofollow"" href=""http://devtang.com"">http://devtang.com</a>""<br>location: ""Beijing, China""</td>
  <td>作品:<br><a rel=""nofollow"" href=""http://book.douban.com/subject/26287173/"">《iOS 开发进阶》</a>
</td>
</tr>
<tr>
<td>10</td>
  <td>
<strong>marcoarment</strong><br><a rel=""nofollow"" href=""https://github.com/marcoarment"">marcoarment</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/366193?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""marcoarment""></span>
</td>
  <td></td>
  <td></td>
</tr>
<tr>
<td>11</td>
  <td>
<strong>Justin Spahr-Summers</strong><br><a rel=""nofollow"" href=""https://github.com/jspahrsummers"">jspahrsummers</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/432536?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jspahrsummers""></span>
</td>
  <td>name: ""Justin Spahr-Summers""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://jspahrsummers.com"">http://jspahrsummers.com</a>""<br>location: ""San Francisco, CA""<br>email: ""justin@jspahrsummers.com""</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/jspahrsummers"">https://twitter.com/jspahrsummers</a>
</td>
</tr>
<tr>
<td>12</td>
  <td>
<strong>Matt Gemmell</strong><br><a rel=""nofollow"" href=""https://github.com/mattgemmell"">mattgemmell</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/144873?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mattgemmell""></span>
</td>
  <td>name: ""Matt Gemmell""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://mattgemmell.com/"">http://mattgemmell.com/</a>""<br>location: ""Edinburgh, Scotland""<br>email: ""matt@mattgemmell.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/mattgemmell"">Matt Gemmell</a>
</td>
</tr>
<tr>
<td>13</td>
  <td>
<strong>Lex Tang</strong><br><a rel=""nofollow"" href=""https://github.com/lexrus"">lexrus</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/219689?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""lexrus""></span>
</td>
  <td>name: ""Lex Tang""<br>company: ""XinweiCook.com""<br>blog: ""<a rel=""nofollow"" href=""http://lexrus.com/"">http://lexrus.com/</a>""<br>location: ""Shanghai China""<br>email: ""lexrus@gmail.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/lexrus/LTMorphingLabel"">LTMorphingLabel</a>:Graceful morphing effects for UILabel written in Swift.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/lexrus"">Lex Tang</a>
</td>
</tr>
<tr>
<td>14</td>
  <td>
<strong>Robbie Hanson</strong><br><a rel=""nofollow"" href=""https://github.com/robbiehanson"">robbiehanson</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/304604?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""robbiehanson""></span>
</td>
  <td>name: ""Robbie Hanson""<br>blog: ""<a rel=""nofollow"" href=""http://deusty.blogspot.com/"">http://deusty.blogspot.com/</a>""<br>location: ""Bend, Oregon""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaAsyncSocket"">CocoaAsyncSocket</a>:Asynchronous socket networking library for Mac and iOS<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/robbie-hanson/28/142/298/zh-cn"">Robbie Hanson</a>
</td>
</tr>
<tr>
<td>15</td>
  <td>
<strong>Roman Efimov</strong><br><a rel=""nofollow"" href=""https://github.com/romaonthego"">romaonthego</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/481100?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""romaonthego""></span>
</td>
  <td>name: ""Roman Efimov""<br>company: ""Yahoo! Inc.""<br>blog: ""twitter.com/romaonthego""<br>location: ""San Francisco Bay Area""<br>email: ""romefimov@gmail.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/romaonthego/RESideMenu"">RESideMenu</a>:iOS 7/8 style side menu with parallax effect.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/romanefimov"">https://www.linkedin.com/in/romanefimov</a>
</td>
</tr>
<tr>
<td>16</td>
  <td>
<strong>Sam Vermette</strong><br><a rel=""nofollow"" href=""https://github.com/samvermette"">samvermette</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/265901?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""samvermette""></span>
</td>
  <td>name: ""Sam Vermette""<br>company: ""Transit App""<br>blog: ""<a rel=""nofollow"" href=""http://samvermette.com"">http://samvermette.com</a>""<br>location: ""Montréal""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/samvermette/SVPullToRefresh"">SVPullToRefresh</a>:Give pull-to-refresh &amp; infinite scrolling to any UIScrollView with 1 line of code.</td>
</tr>
<tr>
<td>17</td>
  <td>
<strong>Ash Furrow</strong><br><a rel=""nofollow"" href=""https://github.com/ashfurrow"">ashfurrow</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/498212?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ashfurrow""></span>
</td>
  <td>name: ""Ash Furrow""<br>company: ""Artsy""<br>blog: ""<a rel=""nofollow"" href=""http://ashfurrow.com"">http://ashfurrow.com</a>""<br>location: """"<br>email: ""ash@ashfurrow.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/ash-furrow/26/871/78"">Ash Furrow</a>
</td>
</tr>
<tr>
<td>18</td>
  <td>
<strong>Ryan Petrich</strong><br><a rel=""nofollow"" href=""https://github.com/rpetrich"">rpetrich</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/142515?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rpetrich""></span>
</td>
  <td>name: ""Ryan Petrich""<br>company: null<br>blog: ""<a rel=""nofollow"" href=""http://rpetri.ch/"">http://rpetri.ch/</a>""<br>location: """"<br>email: ""rpetrich@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/rpetrich"">https://twitter.com/rpetrich</a>
</td>
</tr>
<tr>
<td>19</td>
  <td>
<strong>Jack</strong><br><a rel=""nofollow"" href=""https://github.com/xhzengAIB"">xhzengAIB</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1969908?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""xhzengAIB""></span>
</td>
  <td>name: ""Jack""<br>company: ""JackTeam &amp;&amp; duowan""<br>blog: ""<a rel=""nofollow"" href=""http://www.pailixiu.com/Jack/personal/"">http://www.pailixiu.com/Jack/personal/</a>""<br>location: ""China GuangDong (广州)""<br>email: ""xhzengAIB@gmail.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>20</td>
  <td>
<strong>Jeff Verkoeyen</strong><br><a rel=""nofollow"" href=""https://github.com/jverkoey"">jverkoey</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/45670?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jverkoey""></span>
</td>
  <td>name: ""Jeff Verkoeyen""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://JeffVerkoeyen.com/"">http://JeffVerkoeyen.com/</a>""<br>location: ""New York, NY""<br>email: ""jverkoey@gmail.com"",</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">nimbus</a>:The iOS framework that grows only as fast as its documentation<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/jeffverkoeyen"">https://www.linkedin.com/in/jeffverkoeyen</a>
</td>
</tr>
<tr>
<td>21</td>
  <td>
<strong>Mugunth Kumar</strong><br><a rel=""nofollow"" href=""https://github.com/MugunthKumar"">MugunthKumar</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/129776?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MugunthKumar""></span>
</td>
  <td>name: ""Mugunth Kumar""<br>company: ""Steinlogic Consulting and Training Pte Ltd""<br>blog: ""<a rel=""nofollow"" href=""http://blog.mugunthkumar.com/"">http://blog.mugunthkumar.com/</a>""<br>location: ""Singapore""<br>email: ""mugunth@steinlogic.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/MugunthKumar/MKNetworkKit"">MKNetworkKit</a>:ARC ready Networking Framework with built in authentication and HTTP 1.1 caching standards support for iOS 5+ devices<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/mugunthkumar"">https://www.linkedin.com/in/mugunthkumar</a>
</td>
</tr>
<tr>
<td>22</td>
  <td>
<strong>Loren Brichter</strong><br><a rel=""nofollow"" href=""https://github.com/atebits"">atebits</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/40109?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""atebits""></span>
</td>
  <td>name: ""Loren Brichter""<br>company: ""atebits""<br>blog: ""<a rel=""nofollow"" href=""http://www.atebits.com/news/"">http://www.atebits.com/news/</a>""<br>location: ""Philly""<br>email: ""loren.brichter@atebits.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/lorenb"">https://twitter.com/lorenb</a>
</td>
</tr>
<tr>
<td>23</td>
  <td>
<strong>Josh Abernathy</strong><br><a rel=""nofollow"" href=""https://github.com/joshaber"">joshaber</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/13760?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""joshaber""></span>
</td>
  <td>name: ""Josh Abernathy""<br>company: ""GitHub""<br>blog: ""<a rel=""nofollow"" href=""http://twitter.com/joshaber"">http://twitter.com/joshaber</a>""<br>location: ""The Gem City""<br>email: ""joshaber@gmail.com""</td>
  <td></td>
</tr>
<tr>
<td>24</td>
  <td>
<strong>Orta</strong><br><a rel=""nofollow"" href=""https://github.com/orta"">orta</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/49038?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""orta""></span>
</td>
  <td>name: ""Orta""<br>company: ""Artsy.net &amp;&amp; CocoaPods""<br>blog: ""<a rel=""nofollow"" href=""http://orta.github.io"">http://orta.github.io</a>""<br>location: ""Manchester / NYC""<br>email: ""orta.therox@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/orta"">https://twitter.com/orta</a>
</td>
</tr>
<tr>
<td>25</td>
  <td>
<strong>Oliver Drobnik</strong><br><a rel=""nofollow"" href=""https://github.com/Cocoanetics"">Cocoanetics</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/333270?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Cocoanetics""></span>
</td>
  <td>name: ""Oliver Drobnik""<br>company: ""Drobnik KG""<br>blog: ""<a rel=""nofollow"" href=""http://www.cocoanetics.com"">http://www.cocoanetics.com</a>""<br>location: ""Vienna, Austria""<br>email: ""oliver@cocoanetics.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>26</td>
  <td>
<strong>Jonathan 'Wolf' Rentzsch</strong><br><a rel=""nofollow"" href=""https://github.com/rentzsch"">rentzsch</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2971?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rentzsch""></span>
</td>
  <td>name: ""Jonathan 'Wolf' Rentzsch""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://rentzsch.com"">http://rentzsch.com</a>""<br>location: ""Chicagoland+WI""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/rentzsch"">https://twitter.com/rentzsch</a>
</td>
</tr>
<tr>
<td>27</td>
  <td>
<strong>Ryan Nystrom</strong><br><a rel=""nofollow"" href=""https://github.com/rnystrom"">rnystrom</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/739696?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rnystrom""></span>
</td>
  <td>name: ""Ryan Nystrom""<br>company: ""Facebook""<br>blog: ""whoisryannystrom.com""<br>location: ""San Francisco, CA""<br>email: ""rnystrom@whoisryannystrom.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/ryannystrom"">https://www.linkedin.com/in/ryannystrom</a>
</td>
</tr>
<tr>
<td>28</td>
  <td>
<strong>Olivier Poitrey</strong><br><a rel=""nofollow"" href=""https://github.com/rs"">rs</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/68232?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rs""></span>
</td>
  <td>name: ""Olivier Poitrey""<br>company: ""Dailymotion""<br>blog: ""<a rel=""nofollow"" href=""http://www.dailymotion.com"">http://www.dailymotion.com</a>""<br>location: ""Silicon Valley, California, USA""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a>:Asynchronous image downloader with cache support with an UIImageView category<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/rsoliv"">https://www.linkedin.com/in/rsoliv</a>
</td>
</tr>
<tr>
<td>29</td>
  <td>
<strong>honcheng</strong><br><a rel=""nofollow"" href=""https://github.com/honcheng"">honcheng</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/208827?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""honcheng""></span>
</td>
  <td>name: ""honcheng""<br>company: ""buUuk Pte Ltd""<br>blog: ""<a rel=""nofollow"" href=""http://honcheng.com"">http://honcheng.com</a>""<br>location: ""Singapore""<br>email: ""honcheng@gmail.com""</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/honcheng"">https://twitter.com/honcheng</a>
</td>
</tr>
<tr>
<td>30</td>
  <td>
<strong>Marin Usalj</strong><br><a rel=""nofollow"" href=""https://github.com/supermarin"">supermarin</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/627285?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""supermarin""></span>
</td>
  <td>name: ""Marin Usalj""<br>company: ""Lyft""<br>blog: ""supermar.in""<br>location: ""San Francisco, CA""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/supermarin/Alcatraz"">Alcatraz</a>:Package manager for Xcode<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/marinusalj"">https://www.linkedin.com/in/marinusalj</a>
</td>
</tr>
<tr>
<td>31</td>
  <td>
<strong>shu223</strong><br><a rel=""nofollow"" href=""https://github.com/shu223"">shu223</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/587614?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""shu223""></span>
</td>
  <td>name: ""shu223""<br>company: ""Freelancer""<br>blog: ""<a rel=""nofollow"" href=""http://d.hatena.ne.jp/shu223/"">http://d.hatena.ne.jp/shu223/</a>""<br>location: ""Tokyo, Japan""<br>email: ""shuichi0526@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/shuichi-tsutsumi/5b/b75/525"">https://www.linkedin.com/pub/shuichi-tsutsumi/5b/b75/525</a> <br>twitter:<a rel=""nofollow"" href=""https://twitter.com/shu223"">https://twitter.com/shu223</a>
</td>
</tr>
<tr>
<td>32</td>
  <td>
<strong>Krzysztof Zabłocki</strong><br><a rel=""nofollow"" href=""https://github.com/krzysztofzablocki"">krzysztofzablocki</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1468993?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""krzysztofzablocki""></span>
</td>
  <td>name: ""Krzysztof Zabłocki""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://merowing.info"">http://merowing.info</a>""<br>location: ""Warsaw, Poland""<br>email: ""krzysztof.zablocki@me.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/krzysztof-zab%C5%82ocki/26/200/442"">Krzysztof Zabłocki</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/merowing_"">https://twitter.com/merowing_</a>
</td>
</tr>
<tr>
<td>33</td>
  <td>
<strong>Andy Matuschak</strong><br><a rel=""nofollow"" href=""https://github.com/andymatuschak"">andymatuschak</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2771?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""andymatuschak""></span>
</td>
  <td>name: ""Andy Matuschak""<br>company: ""Khan Academy""<br>blog: ""<a rel=""nofollow"" href=""http://andymatuschak.org"">http://andymatuschak.org</a>""<br>location: ""San Francisco, CA""<br>email: ""andy@andymatuschak.org""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/andy_matuschak"">https://twitter.com/andy_matuschak</a>
</td>
</tr>
<tr>
<td>34</td>
  <td>
<strong>Brad Larson</strong><br><a rel=""nofollow"" href=""https://github.com/BradLarson"">BradLarson</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/954279?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""BradLarson""></span>
</td>
  <td>name: ""Brad Larson""<br>company: ""Sunset Lake Software LLC""<br>blog: ""<a rel=""nofollow"" href=""http://www.sunsetlakesoftware.com"">http://www.sunsetlakesoftware.com</a>""<br>location: ""Madison, WI USA""<br>email: ""contact@sunsetlakesoftware.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/BradLarson/GPUImage"">GPUImage</a>:An open source iOS framework for GPU-based image and video processing<br>about:<a rel=""nofollow"" href=""http://www.sunsetlakesoftware.com/about"">Brad Larson</a>
</td>
</tr>
<tr>
<td>35</td>
  <td>
<strong>James Tang</strong><br><a rel=""nofollow"" href=""https://github.com/jamztang"">jamztang</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/852375?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jamztang""></span>
</td>
  <td>name: ""James Tang""<br>blog: ""<a rel=""nofollow"" href=""http://jamztang.com"">http://jamztang.com</a>""<br>location: ""Hong Kong""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/jamztang"">https://twitter.com/jamztang</a>
</td>
</tr>
<tr>
<td>36</td>
  <td>
<strong>kishikawa katsumi</strong><br><a rel=""nofollow"" href=""https://github.com/kishikawakatsumi"">kishikawakatsumi</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/40610?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""kishikawakatsumi""></span>
</td>
  <td>name: ""kishikawa katsumi""<br>company: ""Realm""<br>blog: ""<a rel=""nofollow"" href=""http://kishikawakatsumi.com"">http://kishikawakatsumi.com</a>""<br>location: ""Tokyo""<br>email: ""kishikawakatsumi@mac.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/kishikawakatsumi/UICKeyChainStore"">UICKeyChainStore</a>:UICKeyChainStore is a simple wrapper for Keychain on iOS. Makes using Keychain APIs as easy as NSUserDefaults.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/kishikawakatsumiX"">https://www.linkedin.com/in/kishikawakatsumiX</a>456Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/k_katsumiX"">https://twitter.com/k_katsumiX</a>457X简历:<a rel=""nofollow"" href=""http://kishikawakatsumi.com/#resume"">http://kishikawakatsumi.com/#resume</a>
</td>
</tr>
<tr>
<td>37</td>
  <td>
<strong>Meng To</strong><br><a rel=""nofollow"" href=""https://github.com/MengTo"">MengTo</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1065452?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MengTo""></span>
</td>
  <td>name: ""Meng To""<br>blog: ""<a rel=""nofollow"" href=""http://mengto.com/"">http://mengto.com/</a>""<br>email: ""shadownessguy@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/mengtoX"">https://twitter.com/mengtoX</a>471X简历:<a rel=""nofollow"" href=""http://mengto.com/img/Resume.pdf"">http://mengto.com/img/Resume.pdf</a>
</td>
</tr>
<tr>
<td>38</td>
  <td>
<strong>Indragie Karunaratne</strong><br><a rel=""nofollow"" href=""https://github.com/indragiek"">indragiek</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/353158?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""indragiek""></span>
</td>
  <td>name: ""Indragie Karunaratne""<br>blog: ""<a rel=""nofollow"" href=""http://indragie.com"">http://indragie.com</a>""<br>location: ""Edmonton, AB""<br>email: ""i@indragie.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/indragie"">https://twitter.com/indragie</a>
</td>
</tr>
<tr>
<td>39</td>
  <td>
<strong>Cédric Luthi</strong><br><a rel=""nofollow"" href=""https://github.com/0xced"">0xced</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/51363?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""0xced""></span>
</td>
  <td>name: ""Cédric Luthi""<br>blog: ""<a rel=""nofollow"" href=""http://0xced.blogspot.com"">http://0xced.blogspot.com</a>""<br>location: ""Geneva, Switzerland""<br>email: ""cedric.luthi@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/0xcedX"">https://www.linkedin.com/in/0xcedX</a>495Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/0xced"">https://twitter.com/0xced</a>
</td>
</tr>
<tr>
<td>40</td>
  <td>
<strong>Jiangang Zhu</strong><br><a rel=""nofollow"" href=""https://github.com/levey"">levey</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/629136?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""levey""></span>
</td>
  <td>name: ""Jiangang Zhu""<br>company: ""Bindo Labs""<br>blog: ""<a rel=""nofollow"" href=""http://www.golevey.com"">http://www.golevey.com</a>""<br>location: ""New York""<br>email: ""levey.zhu@gmail.com""</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/LeveyZhu"">https://twitter.com/LeveyZhu</a>
</td>
</tr>
<tr>
<td>41</td>
  <td>
<strong>Ole Zorn</strong><br><a rel=""nofollow"" href=""https://github.com/omz"">omz</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/82469?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""omz""></span>
</td>
  <td>name: ""Ole Zorn""<br>company: ""omz:software""<br>blog: ""<a rel=""nofollow"" href=""http://omz-software.com"">http://omz-software.com</a>""<br>location: ""Berlin, Germany""</td>
  <td></td>
</tr>
<tr>
<td>42</td>
  <td>
<strong>Dan Abramov</strong><br><a rel=""nofollow"" href=""https://github.com/gaearon"">gaearon</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/810438?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gaearon""></span>
</td>
  <td>name: ""Dan Abramov""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://twitter.com/dan_abramov"">http://twitter.com/dan_abramov</a>""<br>location: ""St. Pete""<br>email: ""dan.abramov@me.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>43</td>
  <td>
<strong>Choi</strong><br><a rel=""nofollow"" href=""https://github.com/equus12"">equus12</a> <br>
</td>
  <td>name: ""Choi""<br>
</td>
  <td></td>
</tr>
<tr>
<td>44</td>
  <td>
<strong>Jonathan Wight</strong><br><a rel=""nofollow"" href=""https://github.com/schwa"">schwa</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/20267?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""schwa""></span>
</td>
  <td>name: ""Jonathan Wight""<br>blog: ""<a rel=""nofollow"" href=""http://toxicsoftware.com/"">http://toxicsoftware.com/</a>""<br>location: ""Berkeley CA""<br>email: ""schwa@toxicsoftware.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/jwight"">https://www.linkedin.com/in/jwight</a>
</td>
</tr>
<tr>
<td>45</td>
  <td>
<strong>Dustin L. Howett</strong><br><a rel=""nofollow"" href=""https://github.com/DHowett"">DHowett</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/189190?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""DHowett""></span>
</td>
  <td>name: ""Dustin L. Howett""<br>company: ""HowettNET""<br>blog: ""<a rel=""nofollow"" href=""http://howett.net"">http://howett.net</a>""<br>location: ""Berkeley, CA""<br>email: ""dustin@howett.net""<br>
</td>
  <td></td>
</tr>
<tr>
<td>46</td>
  <td>
<strong>Zheng Zhu</strong><br><a rel=""nofollow"" href=""https://github.com/MartianZ"">MartianZ</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/979135?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MartianZ""></span>
</td>
  <td>name: ""Zheng Zhu""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://MartianZ.cn"">http://MartianZ.cn</a>""<br>location: ""UESTC""<br>email: ""fzyadmin@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/_MartianZ"">https://twitter.com/_MartianZ</a>
</td>
</tr>
<tr>
<td>47</td>
  <td>
<strong>Brian Gesiak</strong><br><a rel=""nofollow"" href=""https://github.com/modocache"">modocache</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/552921?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""modocache""></span>
</td>
  <td>name: ""Brian Gesiak""<br>company: ""Facebook""<br>blog: ""<a rel=""nofollow"" href=""http://modocache.io"">http://modocache.io</a>""<br>location: ""Brooklyn, NY""<br>email: ""modocache@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/bgesiakX"">https://www.linkedin.com/in/bgesiakX</a>579Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/modocache"">https://twitter.com/modocache</a>
</td>
</tr>
<tr>
<td>48</td>
  <td>
<strong>Dave DeLong</strong><br><a rel=""nofollow"" href=""https://github.com/davedelong"">davedelong</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/112699?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""davedelong""></span>
</td>
  <td>name: ""Dave DeLong""<br>blog: ""<a rel=""nofollow"" href=""http://davedelong.com/"">http://davedelong.com/</a>""<br>location: ""Santa Clara, CA""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/davedelongX"">https://www.linkedin.com/in/davedelongX</a>591Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/davedelongX"">https://twitter.com/davedelongX</a>592Xstackoverflow:<a rel=""nofollow"" href=""http://stackoverflow.com/users/115730/dave-delong"">dave-delong</a>
</td>
</tr>
<tr>
<td>49</td>
  <td>
<strong>Qitao Yang</strong><br><a rel=""nofollow"" href=""https://github.com/KittenYang"">KittenYang</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/5517281?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""KittenYang""></span>
</td>
  <td>name: ""Qitao Yang""<br>company: ""Smartisan Software Co., Ltd.""<br>blog: ""<a rel=""nofollow"" href=""http://kittenyang.com"">http://kittenyang.com</a>""<br>location: ""Beijing,China""<br>email: ""kittenyang@icloud.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/%E9%AA%91%E6%BB%94-%E6%9D%A8/a2/781/15"">杨骑滔 (KittenYang)</a>
</td>
</tr>
<tr>
<td>50</td>
  <td>
<strong>Jesse Squires</strong><br><a rel=""nofollow"" href=""https://github.com/jessesquires"">jessesquires</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2301114?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jessesquires""></span>
</td>
  <td>name: ""Jesse Squires""<br>company: ""Hexed Bits""<br>blog: ""www.jessesquires.com""<br>location: ""San Francisco, CA""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/jessesquires/JSQMessagesViewController"">JSQMessagesViewController</a>:An elegant messages UI library for iOS<br><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/jesse_squires"">https://twitter.com/jesse_squires</a>
</td>
</tr>
</tbody>
</table>
<p>转载请带上本文链接:</p>

<p><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md""></a><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md"">https://github.com/coderyi/Monkey/blob/master/github_top_users_reposit...</a></p>

                ", GitHub排名前50的Objective-C开发者,1531978052,355,1,927,1,1,https://segmentfault.com/a/1190000002944692
267,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVmvG8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>互联网发展这么多年，让人感到可怕的增长之外，信息量已经让每个现代人觉得繁重，我们每天都要处理大量的信息，而且信息的来源都是不一样的，更会让人觉得身心疲惫。在工作中也是一样，每天处理大量的信息会很容易分心，很容易把事情变得复杂。</p>

<p>在这么多信息的干扰下，把工作变得简单会显得非常需要，这决定了你能否充分利用工作时间，给自己更多可用的时间，而不是每天都在应付工作。可以尝试用一些习惯和工具来改善这些问题。</p>

<h2>1、特定时间处理特定信息</h2>

<p>这个适用于一些处理固定信息的场景，比如：筛选简历、Review 工作进度、审批进度、分配任务、审查代码。比如说：</p>

<ul>
<li>每天早上上班第一个半小时是定制一天的计划</li>
<li>每天中午下班最后半小时前用来分配新的工作任务</li>
<li>每天下午下班最后一个小时用来审核代码和 Review 工作进度</li>
<li>每天晚上拿一个小时用来筛选简历</li>
</ul>
<p>这种工作安排是一种比较容易确定的，非常容易提升效率。但比较难的就在于控制外界条件对自己的干扰，和如果打乱如何去安排。</p>

<p>我曾经一段时间要练习翻译，就花了一个多月每天晚上 10 点到 11 点去翻译一些很好的英文文章放到简书，刚开始坚持是很难的，经常会被一些事情打断。慢慢的说服自己去坚持，明白自己坚持背后是为了什么，打打鸡血咬咬牙就过去了；然后把自己封闭到一个环境内，不要去想任何其它的，收个新闻，看个手机都不要去想，专心花一个小时去搞定。这是一个考验耐心的环节。</p>

<h2>2、把信息聚合到一起</h2>

<p>现在我们每天接触信息非常分散，来自于各种不同的地方，我会用各种各样的工具去解决信息太分散的问题，我的解决手段主要就是聚合。比如：</p>

<ul>
<li>常见的新闻类，肯定会用 RSS 阅读器，比如 <a rel=""nofollow"" href=""http://reederapp.com/"">Reeder</a>
</li>
<li>想收藏的信息都通过一个 <a rel=""nofollow"" href=""https://getpocket.com/"">Pocket</a> 来收藏 </li>
<li>每个项目要使用的文件都用 <a rel=""nofollow"" href=""https://dropbox.com/"">Dropbox</a> 这样的服务放到一个文件夹</li>
<li>任务管理尽量不要使用多个平台，如果必须，建立通过 API 聚合到一起</li>
</ul>
<p>这样其实已经可以把信息的处理尽量放在一起，而不用到处去找，或者切换各种应用或网页去获取信息。已经可以解决很多信息分散的问题。</p>

<h2>3、和团队共享信息</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVmvG9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>团队协作是非常重要的，协作就离不开信息共享，信息不能流通起来就很难把信息同步给大家，造成团队合作不畅。可以尝试使用这些方式：</p>

<ul>
<li>用 <a rel=""nofollow"" href=""https://trello.com"">Trello</a> 或 <a rel=""nofollow"" href=""https://tower.im"">Tower</a> 这样的工具来管理好任务和文件等</li>
<li>用 <a rel=""nofollow"" href=""https://gmail.com"">Gmail</a> 或者 <a rel=""nofollow"" href=""https://outlook.com"">Outlook</a> 等日历来共享日程信息</li>
<li>用 <a rel=""nofollow"" href=""https://quip.com"">Quip</a> 、<a rel=""nofollow"" href=""https://docs.google.com"">Google Docs</a> 或 <a rel=""nofollow"" href=""https://shimo.im"">石墨</a> 来共享文档</li>
<li>用 <a rel=""nofollow"" href=""https://slack"">Slack</a> 或我们的产品 <a rel=""nofollow"" href=""https://pubu.im"">瀑布IM</a> 来共享信息流，甚至可以来接入以上所有的服务</li>
</ul>
<p>把信息共享解决后，基本的工作环节都会打通，也会减少很多不必要的沟通。多出来的时间可以和团队做些更有意义的沟通，让整个团队氛围变得生动和开放。工作才会变得简单，问题更容易解决。</p>

<h2>写在最后</h2>

<p>让工作变得简单有很多方式，但最终离不开的就是对信息的获取和处理。我们现在全部都再用 <a rel=""nofollow"" href=""https://pubu.im"">瀑布IM</a> 来进行办公，邮件基本抛开，也不用经常去找信息，因为信息自然会流进来。再加上自己开发的一些 API 接口，可以解决信息流中 80% 的需求，整个工作会变得非常简单。</p>

                ", 在互联网时代如何工作得更简单,1531978054,327,1,233,1,1,https://segmentfault.com/a/1190000002942710
268,1,0,7,"
                    
<p>个人在学习git工作流的过程中，从原有的 SVN 模式很难完全理解git的协作模式，直到有一天我看到了下面的文章，好多遗留在心中的困惑迎刃而解，于是我将这部分资料进行整理放到了github上，欢迎star查看最新更新内容， <a rel=""nofollow"" href=""https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md"">https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md</a></p>

<ul>
<li>我们以使用SVN的工作流来使用git有什么不妥？</li>
<li>git 方便的branch在哪里，团队多人如何协作？冲突了怎么办？如何进行发布控制？</li>
<li>经典的master-发布、develop-主开发、hotfix-不过修复如何避免代码不经过验证上线？</li>
<li>如何在github上面与他人一起协作，star-fork-pull request是怎样的流程？</li>
</ul>
<p>我个人很感激这篇文章，所以进行了整理，希望能帮到更多的人。整篇文章由 <a rel=""nofollow"" href=""https://github.com/xirong"">xirong</a> 整理自 <a rel=""nofollow"" href=""https://github.com/oldratlee"">oldratlee</a> 的github，方便统一的学习回顾，在此感谢下面两位的贡献。</p>

<p>原文链接：<a rel=""nofollow"" href=""https://www.atlassian.com/git/workflows"">Git Workflows and Tutorials</a><br>
简体中文：由 <a rel=""nofollow"" href=""https://github.com/oldratlee"">oldratlee</a> 翻译在 github 上 <a rel=""nofollow"" href=""https://github.com/oldratlee/translations/tree/master/git-workflows-and-tutorials"">git-workflows-and-tutorials</a></p>

<hr>
<p>
</p>
<ul>
<li><a>一、译序</a></li>
<li>
<a>二、Git工作流指南</a><ul>
<li>
<a>2.1 集中式工作流</a><ul>
<li><a>2.1.1 工作方式</a></li>
<li><a>2.1.2 冲突解决</a></li>
<li>
<a>2.1.3 示例</a><ul>
<li><a>有人先初始化好中央仓库</a></li>
<li><a>所有人克隆中央仓库</a></li>
<li><a>小明开发功能</a></li>
<li><a>小红开发功能</a></li>
<li><a>小明发布功能</a></li>
<li><a>小红试着发布功能</a></li>
<li><a>小红在小明的提交之上rebase</a></li>
<li><a>小红解决合并冲突</a></li>
<li><a>小红成功发布功能</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a>2.2 功能分支工作流</a><ul>
<li><a>2.2.1 工作方式</a></li>
<li><a>2.2.2 Pull Requests</a></li>
<li>
<a>2.2.3 示例</a><ul>
<li><a>小红开始开发一个新功能</a></li>
<li><a>小红要去吃个午饭</a></li>
<li><a>小红完成功能开发</a></li>
<li><a>小黑收到Pull Request</a></li>
<li><a>小红再做修改</a></li>
<li><a>小红发布她的功能</a></li>
<li><a>与此同时，小明在做和小红一样的事</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a>2.3 Gitflow工作流</a><ul>
<li><a>2.3.1 工作方式</a></li>
<li><a>2.3.2 历史分支</a></li>
<li><a>2.3.3 功能分支</a></li>
<li><a>2.3.4 发布分支</a></li>
<li><a>2.3.5 维护分支</a></li>
<li>
<a>2.3.6 示例</a><ul>
<li><a>创建开发分支</a></li>
<li><a>小红和小明开始开发新功能</a></li>
<li><a>小红完成功能开发</a></li>
<li><a>小红开始准备发布</a></li>
<li><a>小红完成发布</a></li>
<li><a>最终用户发现Bug</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a>2.4 Forking工作流</a><ul>
<li><a>2.4.1 工作方式</a></li>
<li><a>2.4.2 正式仓库</a></li>
<li><a>2.4.3 Forking工作流的分支使用方式</a></li>
<li>
<a>2.4.4 示例</a><ul>
<li><a>项目维护者初始化正式仓库</a></li>
<li><a>开发者fork正式仓库</a></li>
<li><a>开发者克隆自己fork出来的仓库</a></li>
<li><a>开发者开发自己的功能</a></li>
<li><a>开发者发布自己的功能</a></li>
<li><a>项目维护者集成开发者的功能</a></li>
<li><a>开发者和正式仓库做同步</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a>2.5 Pull Requests</a><ul>
<li><a>2.5.1 解析Pull Request</a></li>
<li><a>2.5.2 工作方式</a></li>
<li><a>2.5.3 在功能分支工作流中使用Pull Request</a></li>
<li><a>2.5.4 在Gitflow工作流中使用Pull Request</a></li>
<li><a>2.5.5 在Forking工作流中使用Pull Request</a></li>
<li>
<a>2.5.6 示例</a><ul>
<li><a>小红fork正式项目</a></li>
<li><a>小红克隆她的Bitbucket仓库</a></li>
<li><a>小红开发新功能</a></li>
<li><a>小红push功能到她的Bitbucket仓库中</a></li>
<li><a>小红发起Pull Request</a></li>
<li><a>小明review Pull Request</a></li>
<li><a>小红补加提交</a></li>
<li><a>小明接受Pull Request</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>一、译序</h1>

<p>工作流其实不是一个初级主题，背后的本质问题其实是有效的项目流程管理和高效的开发协同约定，不仅是<code>Git</code>或<code>SVN</code>等<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6""><code>VCS</code></a>或<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86""><code>SCM</code></a>工具的使用。</p>

<p>这篇指南以大家在<code>SVN</code>中已经广为熟悉使用的集中式工作流作为起点，循序渐进地演进到其它高效的分布式工作流，还介绍了如何配合使用便利的<code>Pull Request</code>功能，体系地讲解了各种工作流的应用。</p>

<p>行文中实践原则和操作示例并重，对于<code>Git</code>的资深玩家可以梳理思考提升，而新接触的同学，也可以跟着step-by-step操作来操练学习并在实际工作中上手使用。</p>

<p>关于<code>Git</code>工作流主题，网上体系的中文资料不多，主要是零散的操作说明，希望这篇文章能让你更深入理解并在工作中灵活有效地使用起来。</p>

<p><strong><em>PS</em></strong>：</p>

<p>文中<code>Pull Request</code>的介绍用的是<code>Bitbucket</code>代码托管服务，由于和<code>GitHub</code>基本一样，如果你用的是<code>GitHub</code>（我自己也主要使用<code>GitHub</code>托管代码），不影响理解和操作。</p>

<p><strong><em>PPS</em></strong>：</p>

<p>本指南循序渐进地讲解工作流，如果<code>Git</code>用的不多，可以从前面的讲的工作流开始操练。操作过程去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。</p>

<p><code>Gitflow</code>工作流是经典模型，体现了工作流的经验和精髓。随着项目过程复杂化，会感受到这个工作流中深思熟虑和威力！</p>

<p><code>Forking</code>工作流是协作的（<code>GitHub</code>风格）可以先看看<code>Github</code>的Help：<a rel=""nofollow"" href=""https://help.github.com/articles/fork-a-repo/"">Fork A Repo</a>和<a rel=""nofollow"" href=""https://help.github.com/articles/using-pull-requests/"">Using pull requests</a> 。照着操作，给一个<code>Github</code>项目贡献你的提交，有操作经验再看指南容易意会。指南中给了<a rel=""nofollow"" href=""https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-forking.md#%E5%BC%80%E5%8F%91%E8%80%85fork%E6%AD%A3%E5%BC%8F%E4%BB%93%E5%BA%93"">自己实现<code>Fork</code>的方法</a>：<code>Fork</code>就是服务端的克隆。在指南的操练中使用代码托管服务（如<code>GitHub</code>、<code>Bitbucket</code>），可以点一下按钮就让开发者完成仓库的<code>fork</code>操作。</p>

<p>:see_no_evil: <a rel=""nofollow"" href=""http://weibo.com/oldratlee"">自己</a>理解粗浅，翻译中不足和不对之处，欢迎建议（<a rel=""nofollow"" href=""https://github.com/oldratlee/translations/issues"">提交Issue</a>）和指正（<a rel=""nofollow"" href=""https://github.com/oldratlee/translations/fork"">Fork后提交代码</a>）！</p>

<h1>二、<code>Git</code>工作流指南</h1>

<p>:point_right: 工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览公司团队中最常用的几种<code>Git</code>工作流让大家可以上手使用。</p>

<p>在阅读的过程中请记住，本文中的几种工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git_workflow.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Workflows""></span></p>

<h2>2.1 集中式工作流</h2>

<p>如果你的开发团队成员已经很熟悉<code>Subversion</code>，集中式工作流让你无需去适应一个全新流程就可以体验<code>Git</code>带来的收益。这个工作流也可以作为向更<code>Git</code>风格工作流迁移的友好过渡。<br><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Workflows: SVN-style""></span></p>

<p>转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上<code>Git</code>带来的收益。团队可以用和<code>Subversion</code>完全不变的方式来开发项目。</p>

<p>但使用<code>Git</code>加强开发的工作流，<code>Git</code>有相比<code>SVN</code>的几个优势。<br>
首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分修改独立开来 ——<br>
即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。</p>

<p>其次，<code>Git</code>提供了强壮的分支和合并模型。不像<code>SVN</code>，<code>Git</code>的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。</p>

<h3>2.1.1 工作方式</h3>

<p>像<code>Subversion</code>一样，集中式工作流以中央仓库作为项目所有修改的单点实体。相比<code>SVN</code>缺省的开发分支<code>trunk</code>，<code>Git</code>叫做<code>master</code>，所有修改提交到这个分支上。本工作流只用到<code>master</code>这一个分支。</p>

<p>开发者开始先克隆中央仓库。在自己的项目拷贝中像<code>SVN</code>一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。</p>

<p>要发布修改到正式项目中，开发者要把本地<code>master</code>分支的修改『推』到中央仓库中。这相当于<code>svn commit</code>操作，但<code>push</code>操作会把所有还不在中央仓库的本地提交都推上去。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-push-local.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git-workflow-svn-push-local""></span></p>

<h3>2.1.2 冲突解决</h3>

<p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。如果开发者本地的提交历史和中央仓库有分歧，<code>Git</code>会拒绝<code>push</code>提交否则会覆盖已经在中央库的正式提交。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-managingconflicts.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git-workflow-svn-managingconflicts""></span></p>

<p>在开发者提交自己功能修改到中央库前，需要先<code>fetch</code>在中央库的新增提交，<code>rebase</code>自己提交到中央库提交历史之上。<br>
这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的<code>SVN</code>的工作流中一样。</p>

<p>如果本地修改和上游提交有冲突，<code>Git</code>会暂停<code>rebase</code>过程，给你手动解决冲突的机会。<code>Git</code>解决合并冲突，用和生成提交一样的<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!status""><code>git status</code></a>和<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!add""><code>git add</code></a>命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，<code>Git</code>可以很简单中止整个<code>rebase</code>操作，重来一次（或者让别人来帮助解决）。</p>

<h3>2.1.3 示例</h3>

<p>让我们一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。</p>

<h4>有人先初始化好中央仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-initialize.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>第一步，有人在服务器上创建好中央仓库。如果是新项目，你可以初始化一个空仓库；否则你要导入已有的<code>Git</code>或<code>SVN</code>仓库。</p>

<p>中央仓库应该是个裸仓库（<code>bare repository</code>），即没有工作目录（<code>working directory</code>）的仓库。可以用下面的命令创建：</p>

<pre><code>bash</code><code>ssh user@host
git init --bare /path/to/repo.git
</code></pre>

<p>确保写上有效的<code>user</code>（<code>SSH</code>的用户名），<code>host</code>（服务器的域名或IP地址），<code>/path/to/repo.git</code>（你想存放仓库的位置）。<br>
注意，为了表示是一个裸仓库，按照约定加上<code>.git</code>扩展名到仓库名上。</p>

<h4>所有人克隆中央仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-clone.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>下一步，各个开发者创建整个项目的本地拷贝。通过<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!clone""><code>git clone</code></a>命令完成：</p>

<pre><code>bash</code><code>git clone ssh://user@host/path/to/repo.git
</code></pre>

<p>基于你后续会持续和克隆的仓库做交互的假设，克隆仓库时<code>Git</code>会自动添加远程别名<code>origin</code>指回『父』仓库。</p>

<h4>小明开发功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>在小明的本地仓库中，他使用标准的<code>Git</code>过程开发功能：编辑、暂存（<code>Stage</code>）和提交。<br>
如果你不熟悉暂存区（<code>Staging Area</code>），这里说明一下：<strong>暂存区</strong>的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。<br>
这样你可以创建一个高度聚焦的提交，尽管你本地修改很多内容。</p>

<pre><code>bash</code><code>git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
</code></pre>

<p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作。<br>
对需要多个更简单更原子分块的大功能，这个做法是很有用的。</p>

<h4>小红开发功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。和小明一样，她也不关心中央仓库有没有新提交；<br>
当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。</p>

<h4>小明发布功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其它团队成员可以看到他的修改。他可以用下面的<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!push""><code>git push</code>命令</a>：</p>

<pre><code>bash</code><code>git push origin master
</code></pre>

<p>注意，<code>origin</code>是在小明克隆仓库时<code>Git</code>创建的远程中央仓库别名。<code>master</code>参数告诉<code>Git</code>推送的分支。<br>
由于中央仓库自从小明克隆以来还没有被更新过，所以<code>push</code>操作不会有冲突，成功完成。</p>

<h4>小红试着发布功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-4.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一起来看看在小明发布修改后，小红<code>push</code>修改会怎么样？她使用完全一样的<code>push</code>命令：</p>

<pre><code>bash</code><code>git push origin master
</code></pre>

<p>但她的本地历史已经和中央仓库有分岐了，<code>Git</code>拒绝操作并给出下面很长的出错消息：</p>

<pre><code>error: failed to push some refs to '/path/to/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>

<p>这避免了小红覆写正式的提交。她要先<code>pull</code>小明的更新到她的本地仓库合并上她的本地修改后，再重试。</p>

<h4>小红在小明的提交之上<code>rebase</code>
</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-5.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>小红用<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!pull""><code>git pull</code></a>合并上游的修改到自己的仓库中。<br>
这条命令类似<code>svn update</code>——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：</p>

<pre><code>bash</code><code>git pull --rebase origin master
</code></pre>

<p><code>--rebase</code>选项告诉<code>Git</code>把小红的提交移到同步了中央仓库修改后的<code>master</code>分支的顶部，如下图所示：</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-6.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>如果你忘加了这个选项，<code>pull</code>操作仍然可以完成，但每次<code>pull</code>操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。<br>
对于集中式工作流，最好是使用<code>rebase</code>而不是生成一个合并提交。</p>

<h4>小红解决合并冲突</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-7.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>rebase</code>操作过程是把本地提交一次一个地迁移到更新了的中央仓库<code>master</code>分支之上。<br>
这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。<br>
这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入<code>Bug</code>的分析，如果有必要，回滚修改也可以做到对项目影响最小。</p>

<p>如果小红和小明的功能是相关的，不大可能在<code>rebase</code>过程中有冲突。如果有，<code>Git</code>在合并有冲突的提交处暂停<code>rebase</code>过程，输出下面的信息并带上相关的指令：</p>

<pre><code>CONFLICT (content): Merge conflict in &lt;some-file&gt;
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-8.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>Git</code>很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!status""><code>git status</code></a>命令来查看哪里有问题。<br>
冲突文件列在<code>Unmerged paths</code>（未合并路径）一节中：</p>

<pre><code># Unmerged paths:
# (use ""git reset HEAD &lt;some-file&gt;..."" to unstage)
# (use ""git add/rm &lt;some-file&gt;..."" as appropriate to mark resolution)
#
# both modified: &lt;some-file&gt;
</code></pre>

<p>接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase""><code>git rebase</code></a>完成剩下的事：</p>

<pre><code>bash</code><code>git add &lt;some-file&gt; 
git rebase --continue
</code></pre>

<p>要做的就这些了。<code>Git</code>会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。</p>

<p>如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!pull""><code>git pull --rebase</code></a>命令前的样子：</p>

<pre><code>bash</code><code>git rebase --abort
</code></pre>

<h4>小红成功发布功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-svn-9.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>小红完成和中央仓库的同步后，就能成功发布她的修改了：</p>

<pre><code>bash</code><code>git push origin master
</code></pre>

<p>如你所见，仅使用几个<code>Git</code>命令我们就可以模拟出传统<code>Subversion</code>开发环境。对于要从<code>SVN</code>迁移过来的团队来说这太好了，但没有发挥出<code>Git</code>分布式本质的优势。</p>

<p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下 <code>功能分支工作流</code> 的收益。<br>
通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。</p>

<hr>
<h2>2.2 功能分支工作流</h2>

<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用<code>Pull Requests</code>的方式讨论变更。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature_branch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Workflows: Feature Branch""></span></p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦你玩转了<a rel=""nofollow"">集中式工作流</a>，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。</p>

<p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在<code>master</code>分支上。<br>
这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。<br>
另外，也保证了<code>master</code>分支的代码一定不会是有问题的，极大有利于集成环境。</p>

<p>功能开发隔离也让<a rel=""nofollow""><code>pull requests</code>工作流</a>成功可能，<br><code>pull requests</code>工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。<br>
另外，如果你在功能开发中有问题卡住了，可以开一个<code>pull requests</code>来向同学们征求建议。<br>
这些做法的重点就是，<code>pull requests</code>让团队成员之间互相评论工作变成非常方便！</p>

<h3>2.2.1 工作方式</h3>

<p>功能分支工作流仍然用中央仓库，并且<code>master</code>分支还是代表了正式项目的历史。<br>
但不是直接提交本地历史到各自的本地<code>master</code>分支，开发者每次在开始新功能前先创建一个新分支。<br>
功能分支应该有个有描述性的名字，比如<code>animated-menu-items</code>或<code>issue-#1061</code>，这样可以让分支有个清楚且高聚焦的用途。</p>

<p>在<code>master</code>分支和功能分支之间，<code>Git</code>是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。</p>

<p>另外，功能分支也可以（且应该）<code>push</code>到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。<br>
由于<code>master</code>仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题。当然，这样做也可以很方便地备份各自的本地提交。</p>

<h3>2.2.2 <code>Pull Requests</code>
</h3>

<p>功能分支除了可以隔离功能的开发，也使得通过<a rel=""nofollow""><code>Pull Requests</code></a>讨论变更成为可能。<br>
一旦某个开发完成一个功能，不是立即合并到<code>master</code>，而是<code>push</code>到中央仓库的功能分支上并发起一个<code>Pull Request</code>请求去合并修改到<code>master</code>。<br>
在修改成为主干代码前，这让其它的开发者有机会先去<code>Review</code>变更。</p>

<p><code>Code Review</code>是<code>Pull Requests</code>的一个重要的收益，但<code>Pull Requests</code>目的是讨论代码一个通用方式。<br>
你可以把<code>Pull Requests</code>作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行<code>Code Review</code>。<br>
比如，一个开发者开发功能需要帮助时，要做的就是发起一个<code>Pull Request</code>，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。</p>

<p>一旦<code>Pull Request</code>被接受了，发布功能要做的就和集中式工作流就很像了。<br>
首先，确定本地的<code>master</code>分支和上游的<code>master</code>分支是同步的。然后合并功能分支到本地<code>master</code>分支并<code>push</code>已经更新的本地<code>master</code>分支到中央仓库。</p>

<p>仓库管理的产品解决方案像<a rel=""nofollow"" href=""http://bitbucket.org/""><code>Bitbucket</code></a>或<a rel=""nofollow"" href=""http://www.atlassian.com/stash""><code>Stash</code></a>，可以良好地支持<code>Pull Requests</code>。可以看看<code>Stash</code>的<a rel=""nofollow"" href=""https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash""><code>Pull Requests</code>文档</a>。</p>

<h3>2.2.3 示例</h3>

<p>下面的示例演示了如何把<code>Pull Requests</code>作为<code>Code Review</code>的方式，但注意<code>Pull Requests</code>可以用于很多其它的目的。</p>

<h4>小红开始开发一个新功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>在开始开发功能前，小红需要一个独立的分支。使用下面的命令<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!checkout"">新建一个分支</a>：</p>

<pre><code>bash</code><code>git checkout -b marys-feature master
</code></pre>

<p>这个命令检出一个基于<code>master</code>名为<code>marys-feature</code>的分支，<code>Git</code>的<code>-b</code>选项表示如果分支还不存在则新建分支。<br>
这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：</p>

<pre><code>bash</code><code>git status
git add &lt;some-file&gt;
git commit
</code></pre>

<h4>小红要去吃个午饭</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>早上小红为新功能添加一些提交。<br>
去吃午饭前，<code>push</code>功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到小红的提交。</p>

<pre><code>bash</code><code>git push -u origin marys-feature
</code></pre>

<p>这条命令<code>push</code> <code>marys-feature</code>分支到中央仓库（<code>origin</code>），<code>-u</code>选项设置本地分支去跟踪远程对应的分支。<br>
设置好跟踪的分支后，小红就可以使用<code>git push</code>命令省去指定推送分支的参数。</p>

<h4>小红完成功能开发</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-4.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>小红吃完午饭回来，完成整个功能的开发。<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!merge"">在合并到<code>master</code>之前</a>，<br>
她发起一个<code>Pull Request</code>让团队的其它人知道功能已经完成。但首先，她要确认中央仓库中已经有她最近的提交：</p>

<pre><code>bash</code><code>git push
</code></pre>

<p>然后，在她的<code>Git</code> <code>GUI</code>客户端中发起<code>Pull Request</code>，请求合并<code>marys-feature</code>到<code>master</code>，团队成员会自动收到通知。<br><code>Pull Request</code>很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。</p>

<h4>小黑收到<code>Pull Request</code>
</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-5.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>小黑收到了<code>Pull Request</code>后会查看<code>marys-feature</code>的修改。决定在合并到正式项目前是否要做些修改，且通过<code>Pull Request</code>和小红来回地讨论。</p>

<h4>小红再做修改</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-6.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>要再做修改，小红用和功能第一个迭代完全一样的过程。编辑、暂存、提交并<code>push</code>更新到中央仓库。小红这些活动都会显示在<code>Pull Request</code>上，小黑可以断续做评注。</p>

<p>如果小黑有需要，也可以把<code>marys-feature</code>分支拉到本地，自己来修改，他加的提交也会一样显示在<code>Pull Request</code>上。</p>

<h4>小红发布她的功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-feature-branch-7.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦小黑可以的接受<code>Pull Request</code>，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：</p>

<pre><code>bash</code><code>git checkout master
git pull
git pull origin marys-feature
git push
</code></pre>

<p>无论谁来做合并，首先要检出<code>master</code>分支并确认是它是最新的。然后执行<code>git pull origin marys-feature</code>合并<code>marys-feature</code>分支到和已经和远程一致的本地<code>master</code>分支。<br>
你可以使用简单<code>git merge marys-feature</code>命令，但前面的命令可以保证总是最新的新功能分支。<br>
最后更新的<code>master</code>分支要重新<code>push</code>回到<code>origin</code>。</p>

<p>这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。<br>
但如果你偏爱线性的提交历史，可以在执行合并时<code>rebase</code>新功能到<code>master</code>分支的顶部，这样生成一个快进（<code>fast-forward</code>）的合并。</p>

<p>一些<code>GUI</code>客户端可以只要点一下『接受』按钮执行好上面的命令来自动化<code>Pull Request</code>接受过程。<br>
如果你的不能这样，至少在功能合并到<code>master</code>分支后能自动关闭<code>Pull Request</code>。</p>

<h4>与此同时，小明在做和小红一样的事</h4>

<p>当小红和小黑在<code>marys-feature</code>上工作并讨论她的<code>Pull Request</code>的时候，小明在自己的功能分支上做完全一样的事。</p>

<p>通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。</p>

<p>到了这里，但愿你发现了功能分支可以很直接地在 <code>集中式工作流</code> 的仅有的<code>master</code>分支上完成多功能的开发。<br>
另外，功能分支还使用了<code>Pull Request</code>，使得可以在你的版本控制<code>GUI</code>客户端中讨论某个提交。</p>

<p>功能分支工作流是开发项目异常灵活的方式。问题是，有时候太灵活了。对于大型团队，常常需要给不同分支分配一个更具体的角色。<br><code>Gitflow</code>工作流是管理功能开发、发布准备和维护的常用模式。</p>

<hr>
<h2>2.3 <code>Gitflow</code>工作流</h2>

<p><code>Gitflow</code>工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-gitflow.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Git Workflows: Gitflow Cycle""></span></p>

<p>这节介绍的<a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/""><code>Gitflow</code>工作流</a>借鉴自在<a rel=""nofollow"" href=""http://nvie.com/"">nvie</a>的<em>Vincent Driessen</em>。</p>

<p><code>Gitflow</code>工作流定义了一个围绕项目发布的严格分支模型。虽然比<a rel=""nofollow"">功能分支工作流</a>复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。</p>

<p><code>Gitflow</code>工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。<br>
除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。<br>
当然你可以用上功能分支工作流所有的好处：<code>Pull Requests</code>、隔离实验性开发和更高效的协作。</p>

<h3>2.3.1 工作方式</h3>

<p><code>Gitflow</code>工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并<code>push</code>分支到要中央仓库中。</p>

<h3>2.3.2 历史分支</h3>

<p>相对使用仅有的一个<code>master</code>分支，<code>Gitflow</code>工作流使用2个分支来记录项目的历史。<code>master</code>分支存储了正式发布的历史，而<code>develop</code>分支作为功能的集成分支。<br>
这样也方便<code>master</code>分支上的所有提交分配一个版本号。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-1historical.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>剩下要说明的问题围绕着这2个分支的区别展开。</p>

<h3>2.3.3 功能分支</h3>

<p>每个新功能位于一个自己的分支，这样可以<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!push""><code>push</code>到中央仓库以备份和协作</a>。<br>
但功能分支不是从<code>master</code>分支上拉出新分支，而是使用<code>develop</code>分支作为父分支。当新功能完成时，<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!merge"">合并回<code>develop</code>分支</a>。<br>
新功能提交应该从不直接与<code>master</code>分支交互。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-2feature.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>注意，从各种含义和目的上来看，功能分支加上<code>develop</code>分支就是功能分支工作流的用法。但<code>Gitflow</code>工作流没有在这里止步。</p>

<h3>2.3.4 发布分支</h3>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-3release.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦<code>develop</code>分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从<code>develop</code>分支上<code>fork</code>一个发布分支。<br>
新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——<br>
这个分支只应该做<code>Bug</code>修复、文档生成和其它面向发布任务。<br>
一旦对外发布的工作都完成了，发布分支合并到<code>master</code>分支并分配一个版本号打好<code>Tag</code>。<br>
另外，这些从新建发布分支以来的做的修改要合并回<code>develop</code>分支。</p>

<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。<br>
这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。</p>

<p>常用的分支约定：</p>

<pre><code>用于新建发布分支的分支: develop
用于合并的分支: master
分支命名: release-* 或 release/*
</code></pre>

<h3>2.3.5 维护分支</h3>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-4maintenance.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>维护分支或说是热修复（<code>hotfix</code>）分支用于生成快速给产品发布版本（<code>production releases</code>）打补丁，这是唯一可以直接从<code>master</code>分支<code>fork</code>出来的分支。<br>
修复完成，修改应该马上合并回<code>master</code>分支和<code>develop</code>分支（当前的发布分支），<code>master</code>分支应该用新的版本号打好<code>Tag</code>。</p>

<p>为<code>Bug</code>修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。<br>
你可以把维护分支想成是一个直接在<code>master</code>分支上处理的临时发布。</p>

<h3>2.3.6 示例</h3>

<p>下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。</p>

<h4>创建开发分支</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-5createdev.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>第一步为<code>master</code>分支配套一个<code>develop</code>分支。简单来做可以<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!branch"">本地创建一个空的<code>develop</code>分支</a>，<code>push</code>到服务器上：</p>

<pre><code>bash</code><code>git branch develop
git push -u origin develop
</code></pre>

<p>以后这个分支将会包含了项目的全部历史，而<code>master</code>分支将只包含了部分历史。其它开发者这时应该<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!clone"">克隆中央仓库</a>，建好<code>develop</code>分支的跟踪分支：</p>

<pre><code>bash</code><code>git clone ssh://user@host/path/to/repo.git
git checkout -b develop origin/develop
</code></pre>

<p>现在每个开发都有了这些历史分支的本地拷贝。</p>

<h4>小红和小明开始开发新功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-6maryjohnbeginnew.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于<code>master</code>分支，而是应该<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!checkout"">基于<code>develop</code>分支</a>：</p>

<pre><code>bash</code><code>git checkout -b some-feature develop
</code></pre>

<p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：</p>

<pre><code>bash</code><code>git status
git add &lt;some-file&gt;
git commit
</code></pre>

<h4>小红完成功能开发</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-7maryfinishes.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>添加了提交后，小红觉得她的功能OK了。如果团队使用<code>Pull Requests</code>，这时候可以发起一个用于合并到<code>develop</code>分支。<br>
否则她可以直接合并到她本地的<code>develop</code>分支后<code>push</code>到中央仓库：</p>

<pre><code>bash</code><code>git pull origin develop
git checkout develop
git merge some-feature
git push
git branch -d some-feature
</code></pre>

<p>第一条命令在合并功能前确保<code>develop</code>分支是最新的。注意，功能决不应该直接合并到<code>master</code>分支。<br>
冲突解决方法和<a rel=""nofollow"">集中式工作流</a>一样。</p>

<h4>小红开始准备发布</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-8maryprepsrelease.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。<br>
像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：</p>

<pre><code>bash</code><code>git checkout -b release-0.1 develop
</code></pre>

<p>这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。</p>

<p>只要小红创建这个分支并<code>push</code>到中央仓库，这个发布就是功能冻结的。任何不在<code>develop</code>分支中的新功能都推到下个发布循环中。</p>

<h4>小红完成发布</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-release-cycle-9maryfinishes.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦准备好了对外发布，小红合并修改到<code>master</code>分支和<code>develop</code>分支上，删除发布分支。合并回<code>develop</code>分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。<br>
另外，如果小红的团队要求<code>Code Review</code>，这是一个发起<code>Pull Request</code>的理想时机。</p>

<pre><code>bash</code><code>git checkout master
git merge release-0.1
git push
git checkout develop
git merge release-0.1
git push
git branch -d release-0.1
</code></pre>

<p>发布分支是作为功能开发（<code>develop</code>分支）和对外发布（<code>master</code>分支）间的缓冲。只要有合并到<code>master</code>分支，就应该打好<code>Tag</code>以方便跟踪。</p>

<pre><code>bash</code><code>git tag -a 0.1 -m ""Initial public release"" master
git push --tags
</code></pre>

<p><code>Git</code>有提供各种勾子（<code>hook</code>），即仓库有事件发生时触发执行的脚本。<br>
可以配置一个勾子，在你<code>push</code>中央仓库的<code>master</code>分支时，自动构建好对外发布。</p>

<h4>最终用户发现<code>Bug</code>
</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflow-gitflow-enduserbug.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个<code>Ticket</code>抱怨当前版本的一个<code>Bug</code>。<br>
为了处理<code>Bug</code>，小红（或小明）从<code>master</code>分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回<code>master</code>分支：</p>

<pre><code>bash</code><code>git checkout -b issue-#001 master
# Fix the bug
git checkout master
git merge issue-#001
git push
</code></pre>

<p>就像发布分支，维护分支中新加这些重要修改需要包含到<code>develop</code>分支中，所以小红要执行一个合并操作。然后就可以安全地<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!branch"">删除这个分支</a>了：</p>

<pre><code>bash</code><code>git checkout develop
git merge issue-#001
git push
git branch -d issue-#001
</code></pre>

<p>到了这里，但愿你对<a rel=""nofollow"">集中式工作流</a>、<a rel=""nofollow"">功能分支工作流</a>和<code>Gitflow</code>工作流已经感觉很舒适了。<br>
你应该也牢固的掌握了本地仓库的潜能，<code>push</code>/<code>pull</code>模式和<code>Git</code>健壮的分支和合并模型。</p>

<p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用<code>Git</code>不可违逆的条例。<br>
所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让<code>Git</code>为你所用。</p>

<hr>
<h2>2.4 <code>Forking</code>工作流</h2>

<p><code>Forking</code>工作流是分布式工作流，充分利用了<code>Git</code>在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（<code>developer</code>），并能接受不信任贡献者（<code>contributor</code>）的提交。</p>

<p><code>Forking</code>工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个<code>Git</code>仓库而不是1个：一个本地私有的，另一个服务端公开的。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>Forking</code>工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能<code>push</code>代码到仅有的中央仓库中。<br>
开发者<code>push</code>到自己的服务端仓库，而只有项目维护者才能<code>push</code>到正式仓库。<br>
这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。</p>

<p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。<br>
也让这个工作流成为开源项目的理想工作流。</p>

<h3>2.4.1 工作方式</h3>

<p>和其它的<code>Git</code>工作流一样，<code>Forking</code>工作流要先有一个公开的正式仓库存储在服务器上。<br>
但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是<code>fork</code>正式项目在服务器上创建一个拷贝。</p>

<p>这个仓库拷贝作为他个人公开仓库 ——<br>
其它开发者不允许<code>push</code>到这个仓库，但可以<code>pull</code>到修改（后面我们很快就会看这点很重要）。<br>
在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!clone""><code>git clone</code>命令</a>克隆仓库到本地机器上，作为私有的开发环境。</p>

<p>要提交本地修改时，<code>push</code>提交到自己公开仓库中 —— 而不是正式仓库中。<br>
然后，给正式仓库发起一个<code>pull request</code>，让项目维护者知道有更新已经准备好可以集成了。<br>
对于贡献的代码，<code>pull request</code>也可以很方便地作为一个讨论的地方。</p>

<p>为了集成功能到正式代码库，维护者<code>pull</code>贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，<br><a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!merge"">合并变更到自己本地的<code>master</code>分支</a>，<br>
然后<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!push""><code>push</code></a><code>master</code>分支到服务器的正式仓库中。<br>
到此，贡献的提交成为了项目的一部分，其它的开发者应该执行<code>pull</code>操作与正式仓库同步自己本地仓库。</p>

<h3>2.4.2 正式仓库</h3>

<p>在<code>Forking</code>工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。<br>
从技术上来看，各个开发者仓库和正式仓库在<code>Git</code>看来没有任何区别。<br>
事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。</p>

<h3>2.4.3 <code>Forking</code>工作流的分支使用方式</h3>

<p>所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。<br>
各个开发者应该用分支隔离各个功能，就像在<a rel=""nofollow"">功能分支工作流</a>和<a rel=""nofollow""><code>Gitflow</code>工作流</a>一样。<br>
唯一的区别是这些分支被共享了。在<code>Forking</code>工作流中这些分支会被<code>pull</code>到另一个开发者的本地仓库中，而在功能分支工作流和<code>Gitflow</code>工作流中是直接被<code>push</code>到正式仓库中。</p>

<h3>2.4.4 示例</h3>

<h4>项目维护者初始化正式仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>和任何使用<code>Git</code>项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。<br>
通常这个仓库也会作为项目维护者的公开仓库。</p>

<p><a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!init"">公开仓库应该是裸仓库</a>，不管是不是正式代码库。<br>
所以项目维护者会运行像下面的命令来搭建正式仓库：</p>

<pre><code>bash</code><code>ssh user@host
git init --bare /path/to/repo.git
</code></pre>

<p><code>Bitbucket</code>和<code>Stash</code>提供了一个方便的<code>GUI</code>客户端以完成上面命令行做的事。<br>
这个搭建中央仓库的过程和前面提到的工作流完全一样。<br>
如果有现存的代码库，维护者也要<code>push</code>到这个仓库中。</p>

<h4>开发者<code>fork</code>正式仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>其它所有的开发需要<code>fork</code>正式仓库。<br>
可以用<code>git clone</code>命令<a rel=""nofollow"" href=""https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git"">用<code>SSH</code>协议连通到服务器</a>，<br>
拷贝仓库到服务器另一个位置 —— 是的，<code>fork</code>操作基本上就只是一个服务端的克隆。<br><code>Bitbucket</code>和<code>Stash</code>上可以点一下按钮就让开发者完成仓库的<code>fork</code>操作。</p>

<p>这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。</p>

<h4>开发者克隆自己<code>fork</code>出来的仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的<code>git clone</code>命令。</p>

<p>在这个示例中，假定用<code>Bitbucket</code>托管了仓库。记住，如果这样的话各个开发者需要有各自的<code>Bitbucket</code>账号，<br>
使用下面命令克隆服务端自己的仓库：</p>

<pre><code>bash</code><code>git clone https://user@bitbucket.org/user/repo.git
</code></pre>

<p>相比前面介绍的工作流只用了一个<code>origin</code>远程别名指向中央仓库，<code>Forking</code>工作流需要2个远程别名 ——<br>
一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用<code>origin</code>作为远程克隆的仓库的别名<br>
（这个别名会在运行<code>git clone</code>自动创建），<code>upstream</code>（上游）作为正式仓库的别名。</p>

<pre><code>bash</code><code>git remote add upstream https://bitbucket.org/maintainer/repo
</code></pre>

<p>需要自己用上面的命令创建<code>upstream</code>别名。这样可以简单地保持本地仓库和正式仓库的同步更新。<br>
注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：</p>

<pre><code>bash</code><code>git remote add upstream https://user@bitbucket.org/maintainer/repo.git
</code></pre>

<p>这时在克隆和<code>pull</code>正式仓库时，需要提供用户的密码。</p>

<h4>开发者开发自己的功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-4.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-basics#!commit"">提交修改</a>和<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!branch"">新建分支</a>：</p>

<pre><code>bash</code><code>git checkout -b some-feature
# Edit some code
git commit -a -m ""Add first draft of some feature""
</code></pre>

<p>所有的修改都是私有的直到<code>push</code>到自己公开仓库中。如果正式项目已经往前走了，可以用<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!pull""><code>git pull</code>命令</a>获得新的提交：</p>

<pre><code>bash</code><code>git pull upstream master
</code></pre>

<p>由于开发者应该都在专门的功能分支上工作，<code>pull</code>操作结果会都是<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches#!merge"">快进合并</a>。</p>

<h4>开发者发布自己的功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-5.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>一旦开发者准备好了分享新功能，需要做二件事。<br>
首先，通过<code>push</code>他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。<br>
他的<code>origin</code>远程别名应该已经有了，所以要做的就是：</p>

<pre><code>bash</code><code>git push origin feature-branch
</code></pre>

<p>这里和之前的工作流的差异是，<code>origin</code>远程别名指向开发者自己的服务端仓库，而不是正式仓库。</p>

<p>第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。<br><code>Bitbucket</code>和<code>Stash</code>提供了<a rel=""nofollow"" href=""https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash""><code>Pull Request</code></a>按钮，弹出表单让你指定哪个分支要合并到正式仓库。<br>
一般你会想集成你的功能分支到上游远程仓库的<code>master</code>分支中。</p>

<h4>项目维护者集成开发者的功能</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-6.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>当项目维护者收到<code>pull request</code>，他要做的是决定是否集成它到正式代码库中。有二种方式来做：</p>

<ol>
<li>直接在<code>pull request</code>中查看代码</li>
<li>
<code>pull</code>代码到他自己的本地仓库，再手动合并</li>
</ol>
<p>第一种做法更简单，维护者可以在<code>GUI</code>中查看变更的差异，做评注和执行合并。<br>
但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中<a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/remote-repositories#!fetch""><code>fetch</code></a>功能分支，<br>
合并到他本地的<code>master</code>分支，解决冲突：</p>

<pre><code>bash</code><code>git fetch https://bitbucket.org/user/repo feature-branch
# 查看变更
git checkout master
git merge FETCH_HEAD
</code></pre>

<p>变更集成到本地的<code>master</code>分支后，维护者要<code>push</code>变更到服务器上的正式仓库，这样其它的开发者都能访问到：</p>

<pre><code>bash</code><code>git push origin master
</code></pre>

<p>注意，维护者的<code>origin</code>是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。</p>

<h4>开发者和正式仓库做同步</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/git-workflows-forking-7.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>由于正式代码库往前走了，其它的开发需要和正式仓库做同步：</p>

<pre><code>bash</code><code>git pull upstream master
</code></pre>

<p>如果你之前是使用<code>SVN</code>，<code>Forking</code>工作流可能看起来像是一个激进的范式切换（paradigm shift）。<br>
但不要害怕，这个工作流实际上就是在<a rel=""nofollow"">功能分支工作流</a>之上引入另一个抽象层。<br>
不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。</p>

<p>示例中解释了，一个贡献如何从一个开发者流到正式的<code>master</code>分支中，但同样的方法可以把贡献集成到任一个仓库中。<br>
比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。</p>

<p>这使得<code>Forking</code>工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。</p>

<hr>
<h2>2.5 <code>Pull Requests</code>
</h2>

<p><code>Pull requests</code>是<code>Bitbucket</code>提供的让开发者更方便地进行协作的功能，提供了友好的<code>Web</code>界面可以在提议的修改合并到正式项目之前对修改进行讨论。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-bitbucket.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>开发者向团队成员通知功能开发已经完成，<code>Pull Requests</code>是最简单的用法。<br>
开发者完成功能开发后，通过<code>Bitbucket</code>账号发起一个<code>Pull Request</code>。<br>
这样让涉及这个功能的所有人知道要去做<code>Code Review</code>和合并到<code>master</code>分支。</p>

<p>但是，<code>Pull Request</code>远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。<br>
如果变更有任何问题，团队成员反馈在<code>Pull Request</code>中，甚至<code>push</code>新的提交微调功能。<br>
所有的这些活动都直接跟踪在<code>Pull Request</code>中。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-overview.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>相比其它的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。<br><code>SVN</code>和<code>Git</code>都能通过一个简单的脚本收到通知邮件；但是，讨论变更时，开发者通常只能去回复邮件。<br>
这样做会变得杂乱，尤其还要涉及后面的几个提交时。<br><code>Pull Requests</code>把所有相关功能整合到一个和<code>Bitbucket</code>仓库界面集成的用户友好<code>Web</code>界面中。</p>

<h3>2.5.1 解析<code>Pull Request</code>
</h3>

<p>当要发起一个<code>Pull Request</code>，你所要做的就是请求（<code>Request</code>）另一个开发者（比如项目的维护者）<br>
来<code>pull</code>你仓库中一个分支到他的仓库中。这意味着你要提供4个信息以发起<code>Pull Request</code>：<br>
源仓库、源分支、目的仓库、目的分支。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-anatomy.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这几值多数<code>Bitbucket</code>都会设置上合适的缺省值。但取决你用的协作工作流，你的团队可能会要指定不同的值。<br>
上图显示了一个<code>Pull Request</code>请求合并一个功能分支到正式的<code>master</code>分支上，但可以有多种不同的<code>Pull Request</code>用法。</p>

<h3>2.5.2 工作方式</h3>

<p><code>Pull Request</code>可以和<a rel=""nofollow"">功能分支工作流</a>、<a rel=""nofollow""><code>Gitflow</code>工作流</a>或<a rel=""nofollow""><code>Forking</code>工作流</a>一起使用。<br>
但一个<code>Pull Request</code>要求要么分支不同要么仓库不同，所以不能用于<a rel=""nofollow"">集中式工作流</a>。<br>
在不同的工作流中使用<code>Pull Request</code>会有一些不同，但基本的过程是这样的：</p>

<ol>
<li>开发者在本地仓库中新建一个专门的分支开发功能。</li>
<li>开发者<code>push</code>分支修改到公开的<code>Bitbucket</code>仓库中。</li>
<li>开发者通过<code>Bitbucket</code>发起一个<code>Pull Request</code>。</li>
<li>团队的其它成员<code>review</code> <code>code</code>，讨论并修改。</li>
<li>项目维护者合并功能到官方仓库中并关闭<code>Pull Request</code>。</li>
</ol>
<p>本文后面内容说明，<code>Pull Request</code>在不同协作工作流中如何应用。</p>

<h3>2.5.3 在功能分支工作流中使用<code>Pull Request</code>
</h3>

<p>功能分支工作流用一个共享的<code>Bitbucket</code>仓库来管理协作，开发者在专门的分支上开发功能。<br>
但不是立即合并到<code>master</code>分支上，而是在合并到主代码库之前开发者应该开一个<code>Pull Request</code>发起功能的讨论。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-feature-branch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>功能分支工作流只有一个公开的仓库，所以<code>Pull Request</code>的目的仓库和源仓库总是同一个。<br>
通常开发者会指定他的功能分支作为源分支，<code>master</code>分支作为目的分支。</p>

<p>收到<code>Pull Request</code>后，项目维护者要决定如何做。如果功能没问题，就简单地合并到<code>master</code>分支，关闭<code>Pull Request</code>。<br>
但如果提交的变更有问题，他可以在<code>Pull Request</code>中反馈。之后新加的提交也会评论之后接着显示出来。</p>

<p>在功能还没有完全开发完的时候，也可能发起一个<code>Pull Request</code>。<br>
比如开发者在实现某个需求时碰到了麻烦，他可以发一个包含正在进行中工作的<code>Pull Request</code>。<br>
其它的开发者可以在<code>Pull Request</code>提供建议，或者甚至直接添加提交来解决问题。</p>

<h3>2.5.4 在<code>Gitflow</code>工作流中使用<code>Pull Request</code>
</h3>

<p><code>Gitflow</code>工作流和功能分支工作流类似，但围绕项目发布定义一个严格的分支模型。<br>
在<code>Gitflow</code>工作流中使用<code>Pull Request</code>让开发者在发布分支或是维护分支上工作时，<br>
可以有个方便的地方对关于发布分支或是维护分支的问题进行交流。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/gitflow-workflow-pull-request.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>Gitflow</code>工作流中<code>Pull Request</code>的使用过程和上一节中完全一致：<br>
当一个功能、发布或是热修复分支需要<code>Review</code>时，开发者简单发起一个<code>Pull Request</code>，<br>
团队的其它成员会通过<code>Bitbucket</code>收到通知。</p>

<p>新功能一般合并到<code>develop</code>分支，而发布和热修复则要同时合并到<code>develop</code>分支和<code>master</code>分支上。<br><code>Pull Request</code>可能用做所有合并的正式管理。</p>

<h3>2.5.5 在<code>Forking</code>工作流中使用<code>Pull Request</code>
</h3>

<p>在<code>Forking</code>工作流中，开发者<code>push</code>完成的功能到他自己的仓库中，而不是共享仓库。<br>
然后，他发起一个<code>Pull Request</code>，让项目维护者知道他的功能已经可以<code>Review</code>了。</p>

<p>在这个工作流，<code>Pull Request</code>的通知功能非常有用，<br>
因为项目维护者不可能知道其它开发者在他们自己的仓库添加了提交。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-forking-workflow-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>由于各个开发有自己的公开仓库，<code>Pull Request</code>的源仓库和目标仓库不是同一个。<br>
源仓库是开发者的公开仓库，源分支是包含了修改的分支。<br>
如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是<code>master</code>分支。</p>

<p><code>Pull Request</code>也可以用于正式项目之外的其它开发者之间的协作。<br>
比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个<code>Pull Request</code>，<br>
用团队成员的<code>Bitbucket</code>仓库作为目标，而不是正式项目的仓库。<br>
然后使用相同的功能分支作为源和目标分支。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-forking-workflow-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>2个开发者之间可以在<code>Pull Request</code>中讨论和开发功能。<br>
完成开发后，他们可以发起另一个<code>Pull Request</code>，请求合并功能到正式的<code>master</code>分支。<br>
在<code>Forking</code>工作流中，这样的灵活性让<code>Pull Request</code>成为一个强有力的协作工具。</p>

<h3>2.5.6 示例</h3>

<p>下面的示例演示了<code>Pull Request</code>如何在在<code>Forking</code>工作流中使用。<br>
也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。</p>

<p>在示例中，小红是个开发，小明是项目维护者。他们各自有一个公开的<code>Bitbucket</code>仓库，而小明的仓库包含了正式工程。</p>

<h4>小红<code>fork</code>正式项目</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>小红先要<code>fork</code>小明的<code>Bitbucket</code>仓库，开始项目的开发。她登陆<code>Bitbucket</code>，浏览到小明的仓库页面，<br>
点<code>Fork</code>按钮。</p>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>然后为<code>fork</code>出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。</p>

<h4>小红克隆她的<code>Bitbucket</code>仓库</h4>

<p><span class=""img-wrap""><img data-src=""http://static.ixirong.com/pic/gitflow/pull-request-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>下一步，小红克隆自己刚才<code>fork</code>出来的<code>Bitbucket</code>仓库，以在本机上准备出工作拷贝
                ", 深入理解学习Git工作流（git-workflow-tutorial）,1531978055,448,1,183,1,1,https://segmentfault.com/a/1190000002918123
269,1,0,7,"
                    
<p>最近学习了一下git命令来操作一下库，发现git命令虽然不多（当然也不算少），但是它们组合起来功能很强大，更重要的是很多命令在不同的状态下发挥的效果不一样，本博文总结了一下git命令，并详细说明了一些命令的使用场景。</p>

<h2>命令小结</h2>

<table>
<thead><tr>
<th>命令</th>
  <th>功能</th>
</tr></thead>
<tbody>
<tr>
<td>git init</td>
  <td>把当前文件夹初始化为默认的git库</td>
</tr>
<tr>
<td>git add 文件名</td>
  <td>向git库中添加一个文件</td>
</tr>
<tr>
<td>git rm 文件名</td>
  <td>从git库中删除一个文件</td>
</tr>
<tr>
<td>git status</td>
  <td>查看当前库中进行的任务</td>
</tr>
<tr>
<td>git diff 文件名</td>
  <td>add前查看工作区和暂存区的差别</td>
</tr>
<tr>
<td>git commit -m ""修改内容""</td>
  <td>把修改内容提交上去，用于区别版本</td>
</tr>
<tr>
<td>git checkout -- 文件名</td>
  <td>在add之前把文件恢复到上次交付，在commit之前恢复到暂存区的状态</td>
</tr>
<tr>
<td>git log [--pretty=oneline]</td>
  <td>显示这个库里都干过啥</td>
</tr>
<tr>
<td>git relog</td>
  <td>查看命令历史，以便确定要回到未来的哪个版本</td>
</tr>
<tr>
<td>git reset HEAD 文件名</td>
  <td>可以把暂存区的修改撤销掉</td>
</tr>
<tr>
<td>git reset --hard HEAD^</td>
  <td>回退到上一个版本</td>
</tr>
<tr>
<td>git reset --hard 版本号</td>
  <td>回退到某个版本</td>
</tr>
</tbody>
</table>
<p>注意如果一个库里的很多文件是合用一个版本号的，也就是说变更版本号后，对应的所有的文件都会回退;</p>

<h2>基本命令</h2>

<p>git 建立库，我们是在工作区中修改文件的,工作区可以有很多文件；<br>
git add 可以把工作区（working tree）下修改的文件或添加的文件添加到暂时存储的区域(index file)；<br>
git commit 做的事情是把index file中修改提交到分支里，默认的分区是master；</p>

<h2>git diff</h2>

<p>diff 就是difference的意思，查看不同，根据工作区（working tree）、缓存区（index file）和版本区(master)的不同，药效不一样哦 -_-!</p>

<ol>
<li>git diff 文件名：是查看working tree与index file  的差别的。也就是说修改之后add之前可以用这个看改了什么;</li>
<li>git diff -- cached：是查看index file与master的差别的。add之后，如果你忘记所有文件做的修改是什么，用这个;</li>
<li>git diff HEAD 文件名：是查看working tree和master的差别的。add之后，可以用这个看具体每个文件改了什么;      </li>
</ol>
<h2>举个栗子</h2>

<p>在工作区新建一个文件hello.cpp</p>

<pre><code>cpp</code><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
        cout&lt;&lt;""快使用""&lt;&lt;endl;
        return 0;
}
</code></pre>

<p>然后添加到版本库里面</p>

<pre><code>git</code><code>$ git add hello.cpp 
$ git commit -m ""新建hello.cpp""
[master 86a0afb] 新建hello.cpp
 1 file changed, 7 insertions(+)
 create mode 100644 hello.cpp
$ git status
位于分支 master
无文件要提交，干净的工作区

</code></pre>

<p>然后修改hello.cpp文件</p>

<pre><code>cpp</code><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
        cout&lt;&lt;""快使用双截棍""&lt;&lt;endl;
        return 0;
}
</code></pre>

<p>添加到暂存区里</p>

<pre><code>git</code><code>$ git add hello.cpp 
$ git status
位于分支 master
要提交的变更：
  （使用 ""git reset HEAD &lt;file&gt;..."" 撤出暂存区）

    修改：     hello.cpp

</code></pre>

<p>再修改hello.cpp文件</p>

<pre><code>cpp</code><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
        cout&lt;&lt;""快使用双截棍，嗯哪咋地""&lt;&lt;endl;
        return 0;
}
</code></pre>

<p>这时候工作区、暂存区、版本区的文件都不一样啦</p>

<pre><code>git</code><code>$ git status
位于分支 master
要提交的变更：
  （使用 ""git reset HEAD &lt;file&gt;..."" 撤出暂存区）

    修改：     hello.cpp

尚未暂存以备提交的变更：
  （使用 ""git add &lt;file&gt;..."" 更新要提交的内容）
  （使用 ""git checkout -- &lt;file&gt;..."" 丢弃工作区的改动）

    修改：     hello.cpp

</code></pre>

<p>使用git diff命令来一一查看哈</p>

<pre><code>git</code><code>$ git diff hello.cpp
diff --git a/hello.cpp b/hello.cpp
index 4cbc284..32531fa 100644
--- a/hello.cpp
+++ b/hello.cpp
@@ -2,6 +2,6 @@
 using namespace std;
 int main()
 {
-       cout&lt;&lt;""快使用双截棍""&lt;&lt;endl;
+       cout&lt;&lt;""快使用双截棍,嗯哪咋地""&lt;&lt;endl;
        return 0;
 }

</code></pre>

<p>上面第10行是暂存区中的内容，而第11行是工作区中的内容，说明git diff 文件名 比较的是暂存区与工作区的内容。其实这里如果用git diff -- 文件名也能达到相同的效果，关于 -- 的用法会在后面相信讨论。</p>

<pre><code>git</code><code>$ git diff --cached
diff --git a/hello.cpp b/hello.cpp
index 4cadd9e..4cbc284 100644
--- a/hello.cpp
+++ b/hello.cpp
@@ -2,6 +2,6 @@
 using namespace std;
 int main()
 {
-       cout&lt;&lt;""快使用""&lt;&lt;endl;
+       cout&lt;&lt;""快使用双截棍""&lt;&lt;endl;
        return 0;
 }

</code></pre>

<p>第10行是版本库的内容，第11行是暂存区中的内容，说明git diff --cached比较的是版本库与暂存区的内容</p>

<pre><code>git</code><code>$ git diff HEAD hello.cpp
diff --git a/hello.cpp b/hello.cpp
index 4cadd9e..32531fa 100644
--- a/hello.cpp
+++ b/hello.cpp
@@ -2,6 +2,6 @@
 using namespace std;
 int main()
 {
-       cout&lt;&lt;""快使用""&lt;&lt;endl;
+       cout&lt;&lt;""快使用双截棍,嗯哪咋地""&lt;&lt;endl;
        return 0;
 }

</code></pre>

<p>比较的是版本库与工作区的内容;</p>

<h2>git checkout -- 文件名</h2>

<p>case 1. git checkout -- 文件名,在修改文件后add到暂存区之前用版本区的文件替换工作区的</p>

<p>case 2. 在add到缓存区后，commit到版本区之前，再一次修改文件，就用暂存区中的文件覆盖工作区</p>

<pre><code>git</code><code>$ git checkout -- hello.cpp
$ cat hello.cpp
#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;""快使用双截棍""&lt;&lt;endl;
    return 0;
}
dragon@dragon-virtual-machine:~/code/learngit$ 

</code></pre>

<p>case 3.在add到缓存区后，commit到版本区之前，再一次修改文件，如果想用版本区的文件覆盖可以有两种做法：</p>

<p>方法一：</p>

<pre><code>git</code><code>$ git checkout HEAD hello.cpp
$ cat hello.cpp
#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;""快使用""&lt;&lt;endl;
    return 0;
}
$ git status
位于分支 master
无文件要提交，干净的工作区

</code></pre>

<p>HEAD是当前版本库的意思，这种做法顺便将暂存区清空了</p>

<p>方法二：</p>

<pre><code>git</code><code>$ git reset HEAD 
重置后撤出暂存区的变更：
M   hello.cpp
$ git checkout -- hello.cpp
$ cat hello.cpp 
#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;""快使用""&lt;&lt;endl;
    return 0;
}


</code></pre>

<p>先清空暂存区，然后再使用git checkout -- 文件名，用版本去来替换工作区，相当于case 1.；</p>

<h2>git的删除与恢复操作</h2>

<p>在工作区，我们可以直接rm命令手动删除一个文件，但是这样在版本库里面并没有变化。所以我们如果想在版本库里面删除这个文件。可以不用手动删除，直接用git rm 文件名<br>
然后git commit -m "" 删除。。。""来提交到版本库；但是如果出现勿删还是可以恢复的</p>

<p>case 1.手动删除没有提交到暂存区，使用git checkout -- 文件名，用版本区文件覆盖工作区</p>

<p>case 2.使用git rm删除.还没有提交</p>

<pre><code>git</code><code><br>$ ls
hehe  hello.cpp  readme.txt
$ git rm hello.cpp 
rm 'hello.cpp'
$ ls
hehe  readme.txt
t$ git status
位于分支 master
要提交的变更：
  （使用 ""git reset HEAD &lt;file&gt;..."" 撤出暂存区）

    删除：     hello.cpp

$ git checkout HEAD hello.cpp
$ ls
hehe  hello.cpp  readme.txt
$ git status
位于分支 master
无文件要提交，干净的工作区
</code></pre>

<p>当然也可以使用git checkout 的第二种方法</p>

<p>case 3. 提交删除，可以使用版本回退的方法来恢复文件，键上面git命令表格里的git reset</p>

                ", Git 命令使用心得,1531978057,241,1,331,1,1,https://segmentfault.com/a/1190000002896037
270,1,0,7,"
                    
<blockquote>
  <p>影响力，让梦想离你更近。</p>
</blockquote>

<p>试想一下，有一天你开发了一个新的语言。它比现有的某某主流软件，运行效率将提高了50%，开发效率提高了100%。接着，你在github上release了0.1，但是由于出现某个开发难题，你需要别人的帮助。而这时，你找不到有效的途径去找到那些真正会用它的人。接着出现了一个新的语言可以达到一样的效果，而这个项目就死于腹中，我记得<a rel=""nofollow"" href=""https://github.com/mruby/mruby"">mruby</a>刚刚只写了一个<code>README.md</code>的时候，就获得了上千个star。</p>

<h1><a rel=""nofollow"" href=""http://www.phodal.com/blog/how-to-improve-impact/"">如何提高影响力，为自己代言</a></h1>

<p><span class=""img-wrap""><img data-src=""http://www.phodal.com/static/media/uploads/impact.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""impact""></span></p>

<p>每个人都可以是一个品牌，对于一个程序员来说，我们的ID就是我们的品牌。而构成品牌的有多个要素:</p>

<ul>
<li>博客</li>
<li>Github</li>
<li>Weibo(or Twitter)</li>
<li>StackOverflow(or SegmentFault, Zhihu)</li>
</ul>
<p>等等。</p>

<h3>搭建一个跨平台的平台</h3>

<blockquote>
  <p>连接各个平台的核心是我们的ID。</p>
</blockquote>

<p>第一个平台指的是不同的网站，如我们的博客、Github、知乎等等，第二个平台指的是我们的影响力。</p>

<p>So，在开始的时候我们需要有一个统一的ID，来标识我们的身份:我是谁，你在xx网站上看到的那个xx就是我。刚开始的时候，我在CSDN、Github上的ID(gmszone)和我的博客的域名(Phodal)是不一样的，因为当时的域名(gmszone.com)握在别人的手上，于是我便想办法将两个ID改了过来（ps: github提供迁移)。后来，Phodal就成了我的发声平台:</p>

<ul>
<li>
<a rel=""nofollow"" href=""http://www.phodal.com/""></a><a rel=""nofollow"" href=""http://www.phodal.com/"">http://www.phodal.com/</a>
</li>
<li>
<a rel=""nofollow"" href=""http://weibo.com/phodal""></a><a rel=""nofollow"" href=""http://weibo.com/phodal"">http://weibo.com/phodal</a>
</li>
<li>
<a rel=""nofollow"" href=""http://www.zhihu.com/people/phodal""></a><a rel=""nofollow"" href=""http://www.zhihu.com/people/phodal"">http://www.zhihu.com/people/phodal</a>
</li>
<li>
<a rel=""nofollow"" href=""http://github.com/phodal""></a><a rel=""nofollow"" href=""http://github.com/phodal"">http://github.com/phodal</a>
</li>
<li>
<a rel=""nofollow"" href=""http://segmentfault.com/u/phodal""></a><a rel=""nofollow"" href=""http://segmentfault.com/u/phodal"">http://segmentfault.com/u/phodal</a>
</li>
<li>
<a rel=""nofollow"" href=""http://www.douban.com/people/phodal/""></a><a rel=""nofollow"" href=""http://www.douban.com/people/phodal/"">http://www.douban.com/people/phodal/</a>
</li>
<li>...</li>
</ul>
<p>于是，这时就可以开始使用跨平台的平台了。</p>

<h2>构建平台</h2>

<blockquote>
  <p>小博客也会有成长的一天。</p>
</blockquote>

<p>对于像我这样一个个默默无闻地人来说，用户可能会有下面几种不同的方法来知道我:</p>

<p><span class=""img-wrap""><img data-src=""http://www.phodal.com/static/media/uploads/live.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""live example""></span></p>

<ul>
<li>用户 -&gt; 搜索{谷歌,百度,必应} -&gt; 博客 -&gt; {Weibo,Github}</li>
<li>用户 -&gt; 微博 -&gt; {Github, 博客}</li>
<li>用户 —&gt; Github -&gt; 博客</li>
<li>用户 -&gt; {知乎, SegmentFault} -&gt; {Weibo,Github,博客}</li>
</ul>
<h3>博客</h3>

<p>刚开始在CSDN上写博客的时候，一开始的访问量很少，慢慢地就多了。有一天发现这样的博客不是自己想要的，于是建了自己的博客，一开始的流量是0。像CSDN这样的网站推荐一些文章到首页，如果能这样便是幸运的。在经历大半年的几乎零流量之后，开始慢慢增长了。到了今天，一共有470篇博客(有一些是出于测试SEO目的写成多篇文章)。一天的PageView大平均有五百左右，主要来源是搜索引擎，百度200左右，谷歌50左右，必应10左右。</p>

<h4>用户故事</h4>

<p>对于一个程序员来说，必须在某种程度上熟悉怎么搜索自己想要的内容，即<strong>关键字</strong>。如我们想要知道如何在OpenWRT OS上用Python，那么我们会搜索<code>OpenWRT Python</code>。于是，这个时候我们博客的标题带有OpenWRT Python，那么我们可能就中奖了。</p>

<p>故事，告诉我们<strong>好的标题很重要</strong>。<strong>重复这个主题</strong>也很重要，会有一个更好的排名。至于，如何更好地排到第一，就是SEO(搜索引擎优化)的话题了。</p>

<h4>笔记</h4>

<p>一开始要写一个博客是比较难的，没有流量、没有评论。所以，一个好的切入点是: <code>笔记</code>。最好是那种网上很少的内容的笔记，虽说很多人不愿意去做这个，但是这是一个很好的方向。</p>

<p>一个技术博客里面的内容应该是两种类型:</p>

<ul>
<li>技术</li>
<li>理论</li>
</ul>
<p>技术型可以带来流量，理论型的可以带来评论。理想的话，两者会相辅相成的，但是在我们刚处于学习期的时候。那么那些Note，可以给我们带来一些流量，也带来一些信心。如果，只是想着一开始我就只写一些长篇大论的话，那么只是就是拿了80%的时间做了20%的事。</p>

<p>以用户搜索的过程来说，用户是<code>有目的的进行搜索</code>。换句话说，在我们日常工作的时候，我们只关心和我们工作相关的内容。而在受众来，正常情况下，技术型的博文、笔记可以带来流量的主要原因是: <code>大部分人都是初学者</code>。</p>

<p><span class=""img-wrap""><img data-src=""http://www.phodal.com/static/media/uploads/70.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""70 percent""></span></p>

<p>理论性的内容，更适合更高级别的开发者，这样的受众较少。</p>

<h4>上头条</h4>

<p>而在今天有其他的平台，可以借用来推销自己的:</p>

<ul>
<li>开发者头条</li>
<li>极客头条</li>
<li>掘金稀土</li>
<li>...</li>
</ul>
<p>网上的IT新闻、博客都是互相Copy，对于一些软文(如本文)来说。这也是期触及率高的原因，通常来说这样可以带来大量的流量。记得在原文中留个原文链接，附张图片(自己博客的图片)来保证:Google把原文指向你的博客，而不是免费为别人打工。</p>

<h4>提升</h4>

<p>除了是一个很好的展示平台，也是一个很好的测试平台。作为一个Web Developer，测试过</p>

<ul>
<li>Nginx Log分析(~600M)</li>
<li>New Relic</li>
<li>SEO</li>
<li>AutoComplete</li>
<li>重构网站</li>
<li>...</li>
</ul>
<h3>Github</h3>

<p>将自己尝试的不同技术栈的内容丢到Github上，加上适当地文档、博客，就变成了一个很好的Demo。然而，不止于此，越来越多地人开始在Github寻找人才，因为他们乐于付出，也乐于分离。曾经因为Github上的项目:</p>

<ul>
<li>申请WebStorm开源License</li>
<li>Review英文版书籍</li>
<li>...(有些不方便透露)</li>
</ul>
<p>而在Github上的项目其实不仅仅只有一些库:</p>

<ul>
<li>库和框架: 和<code>jQuery</code> </li>
<li>系统: 如<code>Linux</code>、<code>hhvm</code>、<code>docker</code>
</li>
<li>配置集: 如<code>dotfiles</code>
</li>
<li>辅助工具: 如<code>oh-my-zsh</code>
</li>
<li>工具: 如<code>Homewbrew</code>和<code>Bower</code>
</li>
<li>资料收集: 如<code>free programming books</code>，<code>You-Dont-Know-JS</code>，<code>Font-Awesome</code>
</li>
<li>其他:简历如<code>Resume</code>，<code>博客</code>
</li>
</ul>
<p>所以，可以尝试不同的切入点使用Github。</p>

<p>在某种程度上来说，一个人在Gihub上的粉丝数量会帮助他的项目在初期获取更多的人气。这样就有助于其下一步开展项目，当然也会在某种程度上更好看Blabla。</p>

<h4>提升</h4>

<p>之前写过一篇<a rel=""nofollow"" href=""http://www.phodal.com/blog/use-github-grow-self/"">《如何通过github提升自己》</a>中说到了一些细节，大致上还是那些东西，Github与Trello、Travis-CI、Coveralls、SauceLabs、Code Climate，配合得很好。已经可以接近于我们在一些项目上用到的功能，因此拿他们搭建一个好的开发环境完全不是问题。</p>

<ul>
<li>Travis CI:支持Node.js、Python、Ruby、PHP等二十几种语言，也支持MySQL、PostgreSQL、MongoDB、Redis等数据库。</li>
<li>Coveralls:可以用来查看代码的测试覆盖率。</li>
<li>SauceLabs:可以用来跑Selenium功能测试等等</li>
<li>Code Climate:查看代码的坏味道。</li>
</ul>
<p>在我们试着去保证测试覆盖率、代码质量等等的时候，我们就可以学到一些知识，如使用不同语言测试框架的Mock、Stub、FakeServer等等。</p>

<h3>扩大影响力</h3>

<p>上面的两部分属于打造平台部分，而如Weibo、知乎等则属于扩大影响力。</p>

<p>在某种时候，博客、Github都更像是个人的平台。如Weibo、知乎、SegmentFault、CSDN等等的开发者社区，也可以为自己的博客、Github带来流量，而这一些都是互相促进的。如果我们在其中的一个网站上表现得很好的话，那么在另外一个网站上我们也很容易聚集同样的粉丝。如，我最常用的一个作法是: 将自己写得相对比较好的一些博客复制到CSDN、SegemntFault、图灵社区等等，并适当地推到CSDN首页、开发者头条等等。</p>

<p>由于写作的开发人员是有限的，所以通常在某某头条上的推荐，会成为某博客园上的新闻，接着会有成群接队的小站开始Copy。同时，这些文章又会推到他们的微博上，接着还可能是微信平台。毕竟，对于大部分的网络来说，大部分的流量是流向他们的网站的，所以他们不太会在乎其中的外链等等。故而，通常来说: 不是某某东西突然火了，而是突然没有别的新闻了。通常来说一个好的作法是，试着将你的博客分享到微博上，然后@那些愿意帮你分享的平台。这样，你可以有更多的阅读、更多的粉丝，当然好的内容是前提。</p>

<p>其中还有若干其它的好处:</p>

<ul>
<li>更大的曝光率，会带来更多的机会</li>
<li>更有机会参与一些未公开互联网产品的试用</li>
<li>各种精美小礼物</li>
<li>翻译、出版机会</li>
</ul>
<h2>TODO</h2>

<p>只需要简单地几步就可以开始提高我们的影响力:</p>

<ul>
<li>在不同的网站上使用一个ID</li>
<li>创建一个博客</li>
<li>开始创作内容、提交代码、分享</li>
<li>持续Impact</li>
</ul>

                ", 程序员如何提高影响力,1531978058,584,1,684,1,1,https://segmentfault.com/a/1190000002867799
271,1,0,7,"
                    
<blockquote><a href=""http://microjs.com/#"" rel=""nofollow noreferrer"">http://microjs.com/#</a></blockquote>
<p>该网站的资源都托管到了<code>github</code>，<code>microjs.com</code>是一个可以让你选择微型的<code>js</code>类库的网站，该网站里的<code>js</code>库都是压缩后不大于5KB的，非常实用</p>
<h2><span class=""img-wrap""><img data-src=""/img/bVmlRU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></h2>
<blockquote>
<a href=""https://plainjs.com/"" rel=""nofollow noreferrer"">https://plainjs.com/</a>（10.22更新）</blockquote>
<p>The Vanilla JavaScript Repository，该仓库都是用原生<code>js</code>写的插件和组件，很实用。里面的项目也都托管到了github</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqu3G"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>综合/资源</h2>
<ul><li>
<a href=""https://github.com/dypsilon/frontend-dev-bookmarks"" rel=""nofollow noreferrer"">frontend-dev-bookmarks</a> 一个巨大的前端开发资源清单。<code>star:15000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/foru17/front-end-collect"" rel=""nofollow noreferrer"">front-end-collect</a> 分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者。<code>star:860</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/hawx1993/Front-end-Interview-questions"" rel=""nofollow noreferrer"">Front-end-Interview-questions</a>   史上最全前端开发面试问题及答案</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/lvwzhen/f2e-hub"" rel=""nofollow noreferrer"">f2e-hub</a> 包含<code>Animation，UI，dialog，Carousels，color，image，workflow</code>等。<code>star:100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/sorrycc/awesome-javascript"" rel=""nofollow noreferrer"">awesome-javascript</a> 一系列很棒的<code>javascript</code> 库，资源。<code>star:3100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/JacksonTian/fks"" rel=""nofollow noreferrer"">fks</a>  前端技能汇总，包含前端知识架构，后端知识，<code>linux</code>，书籍推荐等。<code>star:4000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/youyudehexie/node123"" rel=""nofollow noreferrer"">node123</a> <code>node.js</code>中文资料导航。<code>star:1200</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/hoosin/mobile-web-favorites"" rel=""nofollow noreferrer"">mobile-web-favorites</a> 移动端web开发收藏夹。<code>star:200</code>
</li></ul>
<p><br></p>
<li><ul><li>
<a href=""https://github.com/nimojs/gulp-book"" rel=""nofollow noreferrer"">gulp-book</a> <code>Gulp</code> 入门指南</li></ul></li>
<ul><li>
<a href=""https://github.com/AutumnsWind/Front-end-tutorial"" rel=""nofollow noreferrer"">Front-end-tutorial</a> 最全的资源教程-前端涉及的所有知识体系。（12.25更新）</li></ul>
<h2>样式/UI/css</h2>
<ul><li>
<a href=""https://github.com/Semantic-Org/Semantic-UI"" rel=""nofollow noreferrer"">Semantic-UI</a> 让你使用任何<code>HTML</code>标签 来表现UI控件。</li></ul>
<p>这是一款语义化设计的前端框架，为攻城师而制作的可复用的开源前端框架。<code>star:17500</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVmu8w"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ul><li>
<a href=""https://github.com/primer/primer"" rel=""nofollow noreferrer"">primer</a>   <code>CSS</code>风格指南。<code>star:3600</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/jorgebastida/glue#glue"" rel=""nofollow noreferrer"">glue</a> 一个生成CSS sprites的简单的命令行工具。star:2.5K (7.19更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/postcss/postcss#plugins"" rel=""nofollow noreferrer"">postcss</a> 用js插件来对css进行转换，类似Sass的预编译器，但实现了模块化，并且更加强大。<code>star:4.5K</code>(7.31更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/lojjic/PIE"" rel=""nofollow noreferrer"">css3 PIE</a> 允许在IE上使用<code>CSS3</code>绝大部分的酷炫功能。官网：<a href=""http://css3pie.com/"" rel=""nofollow noreferrer"">http://css3pie.com/</a>
</li></ul>
<p><br></p>
<li><ul><li>
<a href=""https://github.com/muicss/mui"" rel=""nofollow noreferrer"">mui</a> 轻量级css框架。<code>star:1.5K</code>(10.15更新)</li></ul></li>
<ul><li>
<a href=""https://github.com/javierbyte/img2css"" rel=""nofollow noreferrer"">img2css</a> 将图片转为纯css的黑科技。<code>star:1.5K</code>（12.25更新）</li></ul>
<h2>测试/工具</h2>
<ul><li>
<a href=""https://github.com/mochajs/mocha"" rel=""nofollow noreferrer"">mocha</a> 一个简单、灵活有趣的 <code>JavaScript</code> 测试框架，用于 <code>Node.js</code> 和浏览器上的 <code>JavaScript</code> 应用测试。 <code>star:6680</code>
</li></ul>
<p><span class=""img-wrap""><img data-src=""/img/bVlVky"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""687474703a2f2f662e636c2e6c792f6974656d732f336c316b306e32413155334d3149314c323130702f53637265656e25323053686f74253230323031322d30322d32342532306174253230322e32312e3433253230504d2e706e67"" title=""687474703a2f2f662e636c2e6c792f6974656d732f336c316b306e32413155334d3149314c323130702f53637265656e25323053686f74253230323031322d30322d32342532306174253230322e32312e3433253230504d2e706e67""></span></p>
<ul><li>
<a href=""https://github.com/zmoazeni/csscss"" rel=""nofollow noreferrer"">csscss</a> css代码冗余分析仪，用于分析冗余 。<code>star:2800</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/addyosmani/es6-tools"" rel=""nofollow noreferrer"">es6-tools</a>  <code>es6</code> 工具集，包括<code>Grunt Tasks，Gulp Plugins，Broccoli Plugins，Brunch Plugins，Webpack plugins</code>等等。<code>star:1860</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/caolan/async"" rel=""nofollow noreferrer"">async</a> 一个工具模块，提供了直接而强大的 <code>JavaScript</code> 异步功能。虽然是为 <code>Node.js</code> 设计的，但是它也可以直接在浏览器中使用。<code>star:13000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/mycolorway/simditor"" rel=""nofollow noreferrer"">simditor</a> 团队协作工具 <code>Tower</code> 使用的富文本编辑器。<code>star:1300</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/yaniswang/HTMLHint"" rel=""nofollow noreferrer"">HTMLHint</a> <code>HTML</code> 静态代码分析工具，可以集成到<code>IDE</code>环境或编译系统中。<code>star:900</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/jshint/jshint"" rel=""nofollow noreferrer"">jshint</a> <code>js</code>静态代码分析工具，可以帮你检测<code>js</code>语法错误和潜在的问题。<code>star:5100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/CSSLint/csslint"" rel=""nofollow noreferrer"">csslint</a> 分析和优化你的<code>CSS</code>样式表的工具。由[Nicholas C.<br>  Zakas][30]所写。<code>star:2700</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/angular/protractor"" rel=""nofollow noreferrer"">protractor</a> 一款端对端的<code>angular apps</code> 测试框架。<code>star:4K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/n1k0/casperjs"" rel=""nofollow noreferrer"">casperjs</a> 一个基于<code>PhantomJS</code>的开源导航脚本和测试工具。<code>star:4.8K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/karma-runner/karma"" rel=""nofollow noreferrer"">Karma</a> 自动化完成单元测试，允许你在多个浏览器里执行<code>js</code>代码。让你的<code>TDD</code>变得简单，快速，有趣。<code>star:5.3K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/jasmine/jasmine"" rel=""nofollow noreferrer"">jasmine</a>  是一个简易的<code>JS</code>单元测试框架， 用来测试<code>Javascript</code>代码。<code>star:9.1K</code>（6.28更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/chaijs/chai"" rel=""nofollow noreferrer"">chai</a> 一个针对 <code>Node.js</code> 和浏览器的<code>TDD</code>(测试驱动开发)/<code>BDD</code>(行为驱动开发)的断言框架，可与任何 <code>JavaScript</code> 测试框架集成。<code>star:2K</code>（6.29更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/jquery/qunit"" rel=""nofollow noreferrer"">Qunit</a> 一个很容易使用的js单元测试框架，该框架是由<code>jQuery</code>团队的成员所开发，并且是<code>jQuery</code>的官方测试套件。<code>star:3.3K</code>（6.29更新）</li></ul>
<h2>Workflow/构建工具</h2>
<ul><li>
<a href=""https://github.com/gruntjs/grunt"" rel=""nofollow noreferrer"">Grunt</a> 基于<code>Node.js</code>的项目构建工具。拥有数量庞大的插件，是一款优秀的前端自动化工具。<code>star:9500</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/yeoman/yo"" rel=""nofollow noreferrer"">yeoman</a> 一个强健的工具，库，及工作流程的组合。<code>star:960</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/gulpjs/gulp"" rel=""nofollow noreferrer"">gulp</a> 基于<code>node.js</code>流的新一代前端构建系统。<code>star:14000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/spmjs/spm"" rel=""nofollow noreferrer"">spm</a> 是 <code>CMD</code> 的包管理工具，需要和 <code>Sea.js</code> 配合使用。</li></ul>
<h2>canvas/数据可视化</h2>
<ul><li>
<a href=""https://github.com/ecomfe/echarts"" rel=""nofollow noreferrer"">echarts</a> 基于<code>Canvas</code>，纯<code>Javascript</code>图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。<code>star:6900</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nnnick/Chart.js"" rel=""nofollow noreferrer"">Chart.js</a> 使用<code>&lt;canvas&gt;</code>标签的简易HTML5图表。<code>star:14600</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/soulwire/sketch.js"" rel=""nofollow noreferrer"">sketch.js</a> 跨平台<code>JavaScript</code>创意编码框架，<code>gzip</code>压缩后仅有2kb。<code>star:1500</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/mbostock/d3"" rel=""nofollow noreferrer"">d3</a> 一个基于数据操作文档的<code>js</code>数据可视化框架，最流行的可视化库之一。<code>star:38000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/ecomfe/zrender"" rel=""nofollow noreferrer"">zrender</a> 一个轻量级的<code>Canvas</code>类库，MVC封装，数据驱动，提供类<code>DOM</code>事件模型，让<code>canvas</code>绘图大不同！<code>star:850</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/masayuki0812/c3"" rel=""nofollow noreferrer"">c3</a> 一个基于 <code>D3.js</code> 的可重用 <code>JavaScript</code> 图表库。几乎零学习曲线。<code>star:4.5K</code>（6.28更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/javierbyte/img2css"" rel=""nofollow noreferrer"">img2css</a> 将图片转为纯css代码。（11.3更新）</li></ul>
<h2>模块管理/加载器</h2>
<ul><li>
<a href=""https://github.com/ecomfe/esl"" rel=""nofollow noreferrer"">ESL</a>   是一个浏览器端、符合<code>AMD</code>的标准加载器，适合用于现代<code>Web</code>浏览器端应用的入口与模块管理。</li></ul>
<p><code>ESL</code> vs <code>RequireJS</code></p>
<pre><code>体积更小 (Smaller)
性能更高 (Higher performance)
更健壮 (More Robustness)
不支持在非浏览器端使用 (Browser only)
依赖模块用时定义 (Lazy define)
</code></pre>
<ul><li>
<a href=""https://github.com/seajs/seajs"" rel=""nofollow noreferrer"">seajs</a> 一个遵循<code>CommonJS</code>规范的<code>JavaScript</code>模块加载器。提供简单、极致的模块化开发体验。<code>star:4100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/component"" rel=""nofollow noreferrer"">Component</a> 一个模块化的<code>JavaScript</code>框架，同时也是面向前端的包管理器。</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/webpack/webpack"" rel=""nofollow noreferrer"">webpack</a>一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。<code>star:9K</code>
</li></ul>
<h2>动画</h2>
<ul><li>
<a href=""https://github.com/daneden/animate.css"" rel=""nofollow noreferrer"">animate.css</a> 一个跨浏览器的<code>CSS</code>动画库。简单易用易上手。<code>star:23000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/visionmedia/move.js"" rel=""nofollow noreferrer"">move.js</a> 极小的 <code>JavaScript</code> 库,支持 <code>CSS3</code> 的动画效果,非常简单优雅。<code>star：2600</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/CreateJS/TweenJS"" rel=""nofollow noreferrer"">TweenJS</a> 是一个简单但强大的 <code>Javascript</code> 动画库。<code>CreateJS</code> 套件的一部分。<code>star:1500</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tictail/bounce.js"" rel=""nofollow noreferrer"">bounce.js</a> 一个用于制作漂亮的 <code>CSS3</code> 关键帧动画的 <code>JavaScript</code><br>  库,使用其特有的方式生成的动画效果。<code>star:3600</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/thebird/Swipe"" rel=""nofollow noreferrer"">Swipe</a> 号称最精确的<code>Slider</code>触摸库，专为移动设备优化。<code>star:4.7K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tweenjs/tween.js"" rel=""nofollow noreferrer"">tween.js</a> 一款可生成平滑动画效果的<code>js</code>动画库。<code>tween.js</code>允许你以平滑的方式修改元素的属性值。它可以通过设置生成各种类似CSS3的动画效果。<code>star:2.5K</code>(7.15更新)</li></ul>
<p><br></p>
<li><ul><li>
<a href=""https://github.com/wagerfield/parallax"" rel=""nofollow noreferrer"">parallax.js</a>轻量级的的视差引擎，能对智能设备的方向作出反应。。<code>star:9K</code> （10.17更新）</li></ul></li>
<ul><li>
<a href=""https://github.com/julianshapiro/velocity"" rel=""nofollow noreferrer"">Velocity</a> 是一款和jQuery的<code>$.animate()</code>有相同API的动画引擎。很适合移动端的动画开发，还打包了颜色动画，转换，循环，easing效果，类动画、滚动等功能。<code>star：9.5K</code>(12月25更新)</li></ul>
<h2>插件</h2>
<ul><li>
<a href=""https://github.com/yanhaijing/zepto.fullpage"" rel=""nofollow noreferrer"">zepto.fullpage</a> 专注于移动端的全屏滚动插件。<code>star:510</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/alvarotrigo/fullPage.js"" rel=""nofollow noreferrer"">fullPage.js</a> pc端的全屏滚动插件。 <code>star:9500</code> <a href=""http://alvarotrigo.com/fullPage/#firstPage"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/peachananr/onepage-scroll"" rel=""nofollow noreferrer"">onepage-scroll</a> 可以轻松建立一个动感的响应式的滚动效果页面，比较适用于单页面的专题站。支持现代浏览器和IE8以上版本。<a href=""http://www.thepetedesign.com/demos/onepage_scroll_demo.html"" rel=""nofollow noreferrer"">View demo</a> 。<code>star:7700</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/kenwheeler/slick"" rel=""nofollow noreferrer"">slick</a> 一款完全响应式的 <code>jQuery</code> 图片滚动插件，能够根据容器自动适应宽度。<code>star:10000</code> <a href=""http://kenwheeler.github.io/slick/"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nicinabox/superslides"" rel=""nofollow noreferrer"">superslides</a> 致力于解决网站大部分特效展示问题。网站上常用的“焦点图/幻灯片”“Tab标签切换”“图片滚动”“无缝滚动”等只需要一个<code>SuperSlide</code>即可解决！ <a href=""http://nicinabox.com/superslides"" rel=""nofollow noreferrer"">view demo</a> <code>star:1100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/davist11/jQuery-One-Page-Nav"" rel=""nofollow noreferrer"">jQuery-One-Page-Nav</a> 当用户滚动网页时，实现平滑滚动和智能导航。<code>star:1100</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/jssor/slider"" rel=""nofollow noreferrer"">slider</a> 一个<code>jquery</code>完全开源的<code>JavaScript</code>代码库，用户可以开发，调试和深度定制自己的滑块。<code>star:850</code> <a href=""http://www.jssor.com/demos/index.html"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/Justineo/github-hovercard"" rel=""nofollow noreferrer"">github-hovercard</a> github 鼠标悬停显示用户，仓库等摘要信息。(10.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/peachananr/onepage-scroll"" rel=""nofollow noreferrer"">onepage-scroll</a> 一款带有背景视觉差效果的<code>jQuery</code>整页滚动特效插件。star：8K （10.17更新）<a href=""http://www.htmleaf.com/Demo/201412311045.html"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<li><ul><li>
<a href=""https://github.com/fhopeman/justlazy"" rel=""nofollow noreferrer"">justlazy.js</a> 轻量级js图片延迟加载插件。（10.22更新）</li></ul></li>
<ul><li>
<a href=""https://github.com/stefanbuck/awesome-browser-extensions-for-github"" rel=""nofollow noreferrer"">awesome-browser-extensions-for-github</a> 收集关于github上优秀的浏览器插件。非常实用。star:200 (12.25更新)</li></ul>
<h2>框架、库和组件</h2>
<ul><li>
<a href=""https://github.com/Polymer/polymer"" rel=""nofollow noreferrer"">polymer</a> <code>web</code>组件构建框架。一套以“一切皆组件、最少化代码量、最少框架限制”为设计理念的<code>Web UI</code>框架。 <code>star:9900</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/bartaz/impress.js"" rel=""nofollow noreferrer"">impress.js</a> 创建令人兴奋的演示。使用<code>CSS3</code>的转换和过渡，这个库允许你创建令人印象深刻的演示文稿。<a href=""http://bartaz.github.io/impress.js/#/bored"" rel=""nofollow noreferrer"">view demo</a>。<code>star:24300</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/driftyco/ionic"" rel=""nofollow noreferrer"">ionic</a> 先进的<code>HTML5</code> 移动端开发框架。帮助开发者使用HTML5, CSS3和<code>js</code>做出不可思议的<code>hybrid app</code>。<code>star:17000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/hakimel/reveal.js"" rel=""nofollow noreferrer"">reveal.js</a> 基于<code>CSS3</code>的3D幻灯片工具。能够制作绚丽的演示文稿并生成<code>HTML</code>格式，将它发布到web上。<code>star:21500</code> <a href=""http://lab.hakim.se/reveal-js/#/"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/yahoo/pure/"" rel=""nofollow noreferrer"">pure.css</a> 一组很小的，响应式的<code>css</code>组件，你可以在网页的项目上到处使用。<code>star:12000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/mrdoob/three.js"" rel=""nofollow noreferrer"">three.js</a> 是<code>JavaScript</code>编写的<code>WebGL</code>第三方库。提供了非常多的3D显示功能。<code>star:20000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/NUKnightLab/TimelineJS"" rel=""nofollow noreferrer"">TimelineJS</a> 轻松制作时间轴。<code>star:8000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/defunkt/jquery-pjax"" rel=""nofollow noreferrer"">jquery-pjax</a> 对<code>ajax</code> 和 <code>pushState</code>的封装，让你可以很方便的使用<code>pushState</code>技术，用以实现页面无刷新加载。<code>star:11500</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/isagalaev/highlight.js"" rel=""nofollow noreferrer"">highlight.js</a> <code>javascript</code>语法高亮。既可以运行在浏览器端也可以运行在服务端。<code>star:5500</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tj/commander.js"" rel=""nofollow noreferrer"">commander.js</a> <code>Node.js</code>命令行工具。<code>star:3800</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/mozilla/togetherjs"" rel=""nofollow noreferrer"">togetherjs</a> 由<code>Mozilla</code>打造的一款可以给网站添加实时协作功能的<code>JavaScript</code>库。<code>star:5K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nbubna/HTML"" rel=""nofollow noreferrer"">HTML.js</a> 轻量级的简化与<code>DOM</code>操作的js库。<a href=""http://nbubna.github.io/HTML/"" rel=""nofollow noreferrer"">view demo</a> <code>star:1.5K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/meanjs/mean"" rel=""nofollow noreferrer"">MEAN.JS</a> 全栈式javascript，使用`MongoDB, Express,<br>  AngularJS<code> 和 </code>Node.js<code>。</code>star:2.2K`</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/sofish/wechat.js"" rel=""nofollow noreferrer"">wechat.js</a> 微信相关的 js 操作：分享、网络、菜单。<code>star:700</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/blueimp/JavaScript-Load-Image"" rel=""nofollow noreferrer"">JavaScript-Load-Image</a> 一个<code>js</code>加载和转换图像文件的库。 <code>star:1.2K</code> [view<br>  demo][95]</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/usablica/progress.js"" rel=""nofollow noreferrer"">progress.js</a> 一个 <code>js</code> 和 <code>CSS3</code>的库，帮助开发人员为网页上的每个对象创建和管理进度条效果。<code>star:1.6K</code> <a href=""http://usablica.github.io/progress.js/"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/zurb/foundation"" rel=""nofollow noreferrer"">foundation</a> 号称世界上最先进的响应式前端框架，也是一款<code>Mobile First</code>的框架。<code>star:21K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/andrewplummer/Sugar"" rel=""nofollow noreferrer"">Sugar</a> 一个<code>JavaScript</code>库。它扩展了现有的<code>JS</code>对象的方法，让你可以用更少的代码做更多的事情。<code>star:2.8K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tastejs/todomvc"" rel=""nofollow noreferrer"">todomvc</a> 帮你挑选一款MV*框架，它使用不同的最流行的<code>js MV*</code>框架实现了一个相同的<code>Todo</code>应用。<code>star:13K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/SlexAxton/yepnope.js"" rel=""nofollow noreferrer"">yepnope.js</a> 这是一个异步的条件加载框架，速度超快，只为用户加载需要的脚本。使用非常简单，非常有用！<code>star:2.5K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/callemall/material-ui"" rel=""nofollow noreferrer"">Material UI</a> 是一个 <code>CSS</code> 框架和一组实现谷歌 Material Design 设计规范的 React<br>  组件。<code>star:8.8K</code>（6.28更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/dbushell/Pikaday"" rel=""nofollow noreferrer"">Pikaday</a> 是一个 <code>JavaScript</code> 日期选择器，特点是轻量级、无依赖和模块化的<br><code>CSS</code>。<code>star:2.8K</code> [view demo]<a>104</a>
</li></ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmxon"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><br></p>
<ul><li>
<a href=""https://github.com/yyx990803/vue"" rel=""nofollow noreferrer"">vuejs</a> 用于构建交互式的 Web 界面的库。它提供了 <code>MVVM</code> 数据绑定和一个可组合的组件系统,具有简单、灵活的 API。<code>star:6K</code>（7.12更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/meteor/meteor"" rel=""nofollow noreferrer"">meteor</a> 超简单的，数据库无处不在的，用于自动化和简化实时运行的 <code>Web</code> 应用程序的开发。纯<code>JavaScript</code>的Web框架。<code>star:27K</code>（7.12更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/fex-team/webuploader"" rel=""nofollow noreferrer"">webuploader</a><br>  一个简单的以<code>HTML5</code>为主，<code>FLASH</code>为辅的现代文件上传组件。支持大文件分片并发上传，极大的提高了文件上传效率。<code>star:1.8K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/ftlabs/fastclick"" rel=""nofollow noreferrer"">fastclick</a>触摸UI上的消除点击延迟js库。<code>star:1W</code>(10.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/wangfupeng1988/wangEditor"" rel=""nofollow noreferrer"">wangEditor</a> 轻量级web富文本框。 (10.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/bestiejs/benchmark.js"" rel=""nofollow noreferrer"">benchmark.js</a>是强大的基准测试库，几乎适用于所有<code>JavaScript</code>平台。支持<code>high-resolution</code>定时器，并返回重要的统计结果。<code>star:1.7k</code>(10.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/WickyNilliams/headroom.js"" rel=""nofollow noreferrer"">headroom.js</a>是一个轻量级、纯 JS 组件,用来隐藏或展现页面上的元素,为你的页面留下更多展示内容的空间。<code>star:7.5K</code> (10.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/egoist/tooling"" rel=""nofollow noreferrer"">tooling</a> 快速开发web app</li></ul>
<h2>移动端</h2>
<ul><li>
<a href=""https://github.com/thebird/swipe"" rel=""nofollow noreferrer"">Swipe</a> 加速移动触摸滑块与硬件之间的转换。<code>star:5000</code>。</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/hammerjs/hammer.js"" rel=""nofollow noreferrer"">hammer.js</a> 一个支持多点触摸的手势库。<code>star:11000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/am-team/amDoc"" rel=""nofollow noreferrer"">amDoc</a> 无线<code>Web</code>解决方案 - 文档规范指南</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/allmobilize/amazeui"" rel=""nofollow noreferrer"">amazeui</a>  移动优先的跨屏前端框架。面向<code>HTML5</code>开发，使用<code>css3</code>做动画和交互。<code>star:4.1K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/madrobby/zepto/"" rel=""nofollow noreferrer"">Zepto</a>  一款面向移动端设备、<code>API</code>与<code>jQuery</code>兼容的基础库。</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/dcloudio/mui"" rel=""nofollow noreferrer"">mui</a> 最接近原生APP体验的高性能框架 。<code>star:1.1K</code>（6.28更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nolimits4web/Swiper"" rel=""nofollow noreferrer"">Swiper</a>纯<code>javascript</code>打造的滑动特效插件，面向手机、平板电脑等移动终端。能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。<code>star:6K</code>(10月18更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/sdc-alibaba/SUI-Mobile"" rel=""nofollow noreferrer"">SUI-Mobile</a>由阿里巴巴国际UED前端出品的移动端UI库，轻量精美 <code>star:2K</code>(2016.1.14更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/amfe/lib-flexible"" rel=""nofollow noreferrer"">lib-flexible</a> 淘宝出品的移动端可伸缩布局方案。<code>star:1.3K+</code>（2016.1.14更新）</li></ul>
<h2>Node.js相关</h2>
<p><a href=""http://nodeframework.com/"" rel=""nofollow noreferrer""></a><a href=""http://nodeframework.com/"" rel=""nofollow noreferrer"">http://nodeframework.com/</a> 专门收集<code>node.js</code>的<code>web</code>框架的网站。其项目同样均托管在<code>github</code>上。<br><span class=""img-wrap""><img data-src=""/img/bVmWrA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><br></p>
<ul><li>
<a href=""https://github.com/cnodejs/nodeclub"" rel=""nofollow noreferrer"">nodeclub</a> 使用 <code>Node.js</code> 和 <code>MongoDB</code> 开发的社区系统。<code>star:3000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nswbmw/N-chat"" rel=""nofollow noreferrer"">N-chat</a> 使用 <code>Express + Socket.IO</code> 搭建的多人聊天室 。<code>star:300</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nswbmw/N-blog"" rel=""nofollow noreferrer"">N-blog</a> 使用 <code>Express + MongoDB</code> 搭建多人博客。<code>star:1800</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/node-inspector/node-inspector"" rel=""nofollow noreferrer"">node-inspector</a> 基于<code>Blink</code>开发者工具的<code>Node.js</code>调试器。<code>star:7000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/alsotang/node-lessons"" rel=""nofollow noreferrer"">node-lessons</a>：<code>Node.js</code>包教不包会。<code>star:2.5K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/ksky521/nodePPT"" rel=""nofollow noreferrer"">nodePPT</a>  使用<code>nodejs</code>写的网络幻灯片。可能是迄今为止最好的网页版<code>PPT</code>。<code>star:1.6K</code> <a href=""http://qdemo.sinaapp.com/"" rel=""nofollow noreferrer"">view demo</a>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/hexojs/hexo"" rel=""nofollow noreferrer"">hexo</a> 一款快捷，简单，强大的博客框架，基于<code>Nodejs</code>。<code>star:5.2K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/koajs/koa"" rel=""nofollow noreferrer"">koa</a> 下一代<code>Node.js</code>  Web 框架。由 <code>Express</code> 团队设计。<code>star:6.3K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/sindresorhus/awesome-nodejs"" rel=""nofollow noreferrer"">awesome-nodejs</a> 关于<code>Nodejs</code> 包和资源的收集。<code>star:7K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/senchalabs/connect"" rel=""nofollow noreferrer"">connect</a> <code>Node</code>平台的中间件框架。<code>Express</code>就是基于<code>Connect</code>开发的。<code>star:5.6K</code>（6.29更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tj/n"" rel=""nofollow noreferrer"">n</a> node版本管理，tj大神所写。<code>star:2.7K</code>
</li></ul>
<p><br></p>
<ul>
<li>
<a href=""https://github.com/creationix/nvm"" rel=""nofollow noreferrer"">nvm</a> node版本管理，通过bash脚本来管理。<code>star:7.5K</code>
</li>
<li>
<a href=""https://github.com/remy/nodemon"" rel=""nofollow noreferrer"">nodemon</a>这个库是专门调试时候使用的，它会自动检测 node.js 代码的改动，然后帮你自动重启应用。star:7K+。（2.24.16）</li>
<li>
<a href=""https://github.com/visionmedia/supertest"" rel=""nofollow noreferrer"">supertest</a>API使用流利的API测试<code>node.js</code> http 服务器。3.1K+</li>
</ul>
<h2>React相关</h2>
<ul><li>
<a href=""https://github.com/js-next/react-style"" rel=""nofollow noreferrer"">react-style</a> 是 <code>React.js</code> 可维护的样式组件</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/react-component"" rel=""nofollow noreferrer"">react-component</a>  基于<code>reactjs</code>的组件。</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/facebook/react-native"" rel=""nofollow noreferrer"">react-native</a> 一个用<code>React</code>构建<code>native apps</code>的框架。<code>star:15000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/ele828/react-native-guide"" rel=""nofollow noreferrer"">react-native-guide</a>  汇集了<code>react-native</code>学习资源与各类开源app。<code>star:850</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/enaqx/awesome-react"" rel=""nofollow noreferrer"">awesome-react</a> 关于<code>react</code>的工具，资源，视频的集合。<code>star:700</code>
</li></ul>
<p><br></p>
<ul>
<li>
<a href=""https://github.com/facebook/flux"" rel=""nofollow noreferrer"">Flux</a> 是一个<code>Facebook</code>开发的、利用单向数据流实现的应用架构，用于<br><code>React</code>。<code>Flux</code>应用有三个主要的部分组成：调度程序、存储和视图（React 组件）。<code>star:6.8K</code>（6.28更新）</li>
<li>
<a href=""https://github.com/cubiq/iscroll/"" rel=""nofollow noreferrer"">iscroll</a> 高性能，体积小，无外部依赖，跨平台的滚动组件 <code>star:6K</code>（7.19更新）</li>
<li>
<a href=""https://github.com/JedWatson/react-tappable"" rel=""nofollow noreferrer"">react-tappable</a> Tappable component for React.(2016,1.4更新)</li>
<li>
<a href=""https://github.com/vczero/react-native-lesson"" rel=""nofollow noreferrer"">react-native-lesson</a> <code>react-native</code>入门指南.<code>star:1.3K</code>(2016,1.4更新)</li>
</ul>
<h2>HTML5</h2>
<ul>
<li>
<a href=""https://github.com/h5bp/html5-boilerplate/"" rel=""nofollow noreferrer"">html5-boilerplate</a> 一套专业的前端模版，主要用于开发快速、健壮、适应性强的app或网站。<code>star:27K</code> （12.25更新）</li>
<li>
<a href=""https://github.com/mozilla/BrowserQuest"" rel=""nofollow noreferrer"">Browserquest</a> <code>Mozilla</code>开发的<code>HTML5</code>多人在线游戏。<code>star:5200</code>
</li>
<li>
<a href=""https://github.com/videojs/video.js"" rel=""nofollow noreferrer"">video.js</a> 开源的HTML5和Flash视频播放器。支持自定义进度条、按钮以及工具栏的底色。<code>star:9.1K</code>
</li>
</ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/aFarkas/html5shiv"" rel=""nofollow noreferrer"">html5shiv</a> 主要解决<code>HTML5</code>提出的新的元素不被<code>IE6-9</code>识别。<code>star:6K</code>(7.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/brunch/brunch/"" rel=""nofollow noreferrer"">brunch</a> 快速的前端 <code>HTML5</code> 构建工具。star:4.5K（7.19更新）</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/uikit/uikit"" rel=""nofollow noreferrer"">ulkit</a> 一个轻量级的、模块化前端框架，它被用于快速开发强大的web界面。也是一款优秀的响应式HTML5 框架。<code>star:5.3K</code> (8.3更新)</li></ul>
<h2>模板引擎</h2>
<ul><li>
<a href=""https://github.com/wycats/handlebars.js"" rel=""nofollow noreferrer"">Handlebars.js</a> 一个<code>js</code>语义模板库，能让你轻松高效的编写语义化模板。<code>star:8.6K</code>(6.29 update)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/aui/artTemplate"" rel=""nofollow noreferrer"">artTemplate</a>  性能卓越的 <code>js</code> 模板引擎。<code>star:1.7K</code>
</li></ul>
<p><br></p>
<li><ul><li>
<a href=""https://github.com/jadejs/jade"" rel=""nofollow noreferrer"">jade</a> 一款高性能简洁易懂的模板引擎，<code>Jade</code>是<code>Haml</code>的<code>Javascript</code>实现。<code>star:8.7K</code>
</li></ul></li>
<ul><li>
<a href=""https://github.com/tj/ejs"" rel=""nofollow noreferrer"">ejs</a> tj大神写的嵌入javascript的模板引擎，主要用于Node</li></ul>
<h2>浏览器兼容方案</h2>
<ul><li>
<a href=""https://github.com/paulmillr/es6-shim"" rel=""nofollow noreferrer"">es6-shim</a> 提供兼容性垫片，使ES6能兼容于传统的<code>JavaScript</code>引擎。<code>star:1.5K</code>(7.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/Modernizr/Modernizr"" rel=""nofollow noreferrer"">Modernizr</a> 用来检测浏览器功能支持情况的<code>JavaScript</code>库,可以检测18项<code>CSS3</code>功能以及40多项关于<code>HTML5</code>的功能。<code>star:16000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/necolas/normalize.css"" rel=""nofollow noreferrer"">normalize.css</a> 一个可定制的 <code>CSS</code> 文件，使浏览器呈现的所有元素，更一致和符合现代标准。支持IE8+。<code>star:17000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/aFarkas/html5shiv"" rel=""nofollow noreferrer"">html5shiv</a> 主要解决<code>HTML5</code>提出的新的元素不被<code>IE6-9</code>识别。<code>star:6K</code>(7.15更新)</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/paulirish/css3please"" rel=""nofollow noreferrer"">css3please</a> 跨浏览器自动生成<code>css3</code>前缀</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/babel/babel/"" rel=""nofollow noreferrer"">Babel</a> 是一款为了写下一代js的编译器，无需等待浏览器支持就可以使用新的语法。<code>star：8.3K</code> (7.29更新)</li></ul>
<h2>高产大牛</h2>
<ul><li>
<a href=""https://github.com/yyx990803"" rel=""nofollow noreferrer"">Evan You</a>  前端轻量级框架<code>MVVM</code>框架<code>vue.js</code>作者，前<code>Google</code>工程师。<code>followers:1.6K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/tj"" rel=""nofollow noreferrer"">TJ Holowaychuk</a>  Luna 编程语言, <code>Koa, Express, Stylus, Cluster, Mocha, Jade, node-canvas, component</code> 等知名开源项目的创建和贡献者。 <code>followers:14.1K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/paulirish"" rel=""nofollow noreferrer"">PaulIrish</a> 著名的前端开发工程师，同时他也是<code>Chrome</code>开发者关系团队成员，jQuery团队成员，<code>Modernizr、Yeoman、CSS3 Please</code>和<code>HTML5 Boilerplate</code>的<code>lead developer</code>。<code>followers:15.7K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/mbostock"" rel=""nofollow noreferrer"">Mike Bostock</a> 知名可视化库 <code>D3.js</code>的主要作者。<code>followers:8.3K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/necolas"" rel=""nofollow noreferrer"">Nicolas Gallagher</a> <code>Normalize.css</code> 作者。<code>followers:3.6K</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/RubyLouvre"" rel=""nofollow noreferrer"">司徒正美</a> 前端迷你<code>MVVM</code>框架<code>Avalon</code>作者。<code>followers:2.1K</code>
</li></ul>
<h2>其他</h2>
<ul><li>
<a href=""https://github.com/airbnb/javascript"" rel=""nofollow noreferrer"">javascript-style-guide</a> 最合理的使用<code>javascript</code>的方法。 <code>star:18000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/AlloyTeam/Mars"" rel=""nofollow noreferrer"">Mars</a> 腾讯移动<code>Web</code>前端知识库。<code>star:1600</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/adobe/brackets"" rel=""nofollow noreferrer"">brackets</a> 一款使用 HTML，CSS，JavaScript 创建的开源的针对 Web 开发的编辑器。<code>star:23000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/TryGhost/Ghost"" rel=""nofollow noreferrer"">Ghost</a> <code>Node.js</code>开发最新博客系统, 简单简洁, 响应式设计, 支持完全自定义, 免费, 专注博客。<code>star:16000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/nodejs/io.js"" rel=""nofollow noreferrer"">io.js</a>  从<code>NodeJS</code>里分离出来的一条分支。<code>star:13000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/gabrielecirulli/2048"" rel=""nofollow noreferrer"">2048 游戏</a> <a href=""http://gabrielecirulli.github.io/2048/"" rel=""nofollow noreferrer"">view demo</a> <code>star:7000</code>
</li></ul>
<p><br></p>
<ul><li>
<a href=""https://github.com/fex-team/ueditor"" rel=""nofollow noreferrer"">ueditor</a> 百度前端团队出品的富本文编辑器。<code>star:1.1K</code>
</li></ul>
<h2>优秀开源组织</h2>
<ul>
<li>
<a href=""https://github.com/AlloyTeam"" rel=""nofollow noreferrer"">AlloyTeam</a> 腾讯 <code>Web</code> 前端团队。</li>
<li>
<a href=""https://github.com/fex-team"" rel=""nofollow noreferrer"">fex-team</a> 百度前端团队。</li>
</ul>
<ul><li>文章已推送至我的<code>github</code>，欢迎<code>pullrequest</code>：<a href=""https://github.com/hawx1993/github-FE-project"" rel=""nofollow noreferrer"">https://github.com/hawx1993/g...</a>
</li></ul>
<p>PS：文章在github更新，本篇文章停止更新</p>

                ", github上值得关注的前端项目,1531978060,374,1,344,1,1,https://segmentfault.com/a/1190000002804472
272,1,0,7,"
                    
<p>原文：<a rel=""nofollow"" href=""http://liujin.me/blog/2015/05/25/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"">Git 常用命令</a></p>

<p>从设计转型开发的第一天起，老大只教我一件事，使用 Git。<br>
比起一上来就给我各种任务写 HTML/CSS/JS 调各种 Bug, 让我熟练掌握 Git 这件事至今我都非常感激。<br>
毫无疑问地说，Git 是当今编程学习里最基本的必备技能。</p>

<p>我记得很清楚，当时我问他，假如全世界的工具你只能保留一个在电脑，你的选择是什么？<br>
Git，老大很肯定地回答，当时我很不解。<br>
3 年后，如果现在要我回答这个问题，我会给出同样的答案。</p>

<p>Git 的强大一本书都不足以全部说明，更何况一篇博客。<br>
本文记录了我 3 年来使用 Git 最频繁的命令（不包括最基本的add/commit/push/pull等），<br>
很负责地说，学会这些基本也就能快乐地玩转 Git 了 <strong>（持续整理更新中）</strong>。</p>

<p>Hope you enjoy!</p>

<h2>1. 超实用 Alias</h2>

<pre><code>bash</code><code>alias g=""git""
alias gb=""git branch""
alias gco=""git checkout""
alias gcmsg=""git commit -m""
alias gamend=""git commit --amend -C HEAD""
alias gst=""git status""
alias log=""git log --oneline --graph --decorate --color=always""
alias logg=""git log --graph --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)—     %an%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative""
</code></pre>

<h2>2. 取回远端 <code>master</code> 与本地 <code>master</code> 分支合并</h2>

<pre><code>bash</code><code>gco master

g fetch --all 或者
g fetch origin master

g reset --hard origin/master(本地没有修改，所以完全覆盖也没关系) 或者
g rebase origin/master（本地有修改还没push）
</code></pre>

<h2>3. 推送分支到远端</h2>

<p>假设现在所在的分支是<code>import</code>，指定推送到远端分支<code>liujin-import</code></p>

<pre><code>bash</code><code>g push origin import:liujin-import
</code></pre>

<p>假如远端的 <code>liujin-import</code> 分支已经不需要，可以直接覆盖掉</p>

<pre><code>bash</code><code>g push -f origin import:liujin-import
</code></pre>

<h2>4. 追加文件到某个 commit</h2>

<p>有时候修完某功能并提交了 commit 之后才发现还有一点小修改，这时候又不想再提交一个commit，可以追加这个文件到前一个commit，步骤如下：</p>

<pre><code>bash</code><code>git add 你要追加修改的文件
git commit --amend -C HEAD 或者 gamend
</code></pre>

<h2>5. 查找包含某文件的 commit</h2>

<pre><code>git log 文件路径
git show commit_id
</code></pre>

<p>或者</p>

<pre><code>git log --follow filename(绝对路径)
</code></pre>

<p>Ref: <a rel=""nofollow"" href=""http://stackoverflow.com/questions/3701404/list-all-commits-for-a-specific-file"">List all commit for a specific file</a></p>

<h2>6. 把一个 commit 分拆为两个 commit</h2>

<p>老大常说要养成一个小改动对应一个commit的习惯，但是有时候写得太乱懒得去分割就把很多改动做成了一个commit，这样子增加了以后维护的难度，所以要把一个 commit 分拆为多个 commit 怎么办呢？</p>

<ul>
<li>首先把你要分拆的 file reset 了：</li>
</ul>
<pre><code>git reset HEAD~1 path/to/file
# This doesn't delete your changes to path/to/file
</code></pre>

<ul>
<li>接着修改当前这个 commit 的 message，命令是：</li>
</ul>
<pre><code>git commit --amend -v
# -v参数是打开editor编辑
</code></pre>

<ul>
<li>然后就可以把 reset 出来那个 file 新建一个 commit，命令是：</li>
</ul>
<pre><code>git commit -v path/to/file
</code></pre>

<p>这样就把一个 commit 分拆为两个啦，^_^</p>

<h2>7. 删除某些 commit</h2>

<pre><code>git rebase -i HEAD~10
</code></pre>

<h2>8. 追加修改到之前某个 commit</h2>

<p>假如 <code>gst</code> 发现已经有文件被修改，这时候需要把修改暂存起来。</p>

<pre><code>git stash
</code></pre>

<p>接着找到你需要追加修改的那个commit id，如<code>4b739bb</code></p>

<pre><code>g rebase 4b739bb~ -i 或者
g rebase -i HEAD~5 #列出最近5个commit
</code></pre>

<p>这时候会自动打开编辑器，把你需要修改的 commit 前面的 <code>pick</code> 改成 <code>edit</code>，保存，关闭编辑器，这时候会回到终端，再输入:</p>

<pre><code>g stash pop
</code></pre>

<p>把暂存的修改读出来，然后做修改，<code>g add .</code>，最后</p>

<pre><code>g rebase --continue
</code></pre>

<h2>9. 查找含有特定关键字的 commit</h2>

<ul>
<li>
<code>git log --grep</code><br>
最基本的用法</li>
<li><p><code>git log --grep=frotz --grep=nitfol --since=1.month</code><br>
查找一个月以内commit log message里含有 <code>frotz</code> 或者 <code>nitfol</code> 的 commits</p></li>
<li><p><code>git log --grep=frotz --author=Linus</code><br>
查找指定作者</p></li>
<li><p><code>git grep -l -e frotz --and -e nitfol</code><br>
查找同一行含有 <code>frotz</code> 和 <code>nitfol</code> 的文件</p></li>
<li><p><code>git grep -l --all-match -e frotz -e nitfol</code><br>
查找文件里面含有 <code>frotz</code> 和 <code>nitfol</code> 的文件（不局限于同一行）</p></li>
</ul>
<h2>10. 清空 git working copy 还没追踪的文件</h2>

<ul>
<li><p><code>git clean -f</code></p></li>
<li><p><code>git clean -f -d</code><br>
如果还想删除目录</p></li>
<li><p><code>git clean -f -X</code><br>
如果只是想删除忽略的文件</p></li>
<li><p><code>git clean -f -x</code><br>
如果想删除忽略和非忽略的文件</p></li>
</ul>
<h2>11. 清理本地仓库</h2>

<p>长时间做一个项目，经常需要 <code>git fetch</code>，这样做每次都会拉回远端的全部分支。<br>
即使远端有些分支已经删除，但是运行<code>git branch -a</code>还是会显示已删除的分支，<br>
长时间下来这个列表就会很长很长，这时候就需要清理一下本地的仓库了：</p>

<pre><code>bash</code><code>git remote prune origin
# `prune`会删除任何不存在于远端仓库的分支，这样运行 `git branch -a`命令的时候顿时就清静了
</code></pre>

<h2>12. 创建追踪远端分支的本地分支</h2>

<pre><code>bash</code><code>gb dev origin/r1-dev
#Branch dev set up to track remote branch r1-dev from origin.
</code></pre>

<h2>13. 分支移动</h2>

<pre><code>bash</code><code>g branch -f master HEAD~3
# 把 master 分支强制移到 HEAD 前面第三个 commit
</code></pre>

<h2>14. Revert一个 Merge</h2>

<p><code>git revert -m 1 M</code> -&gt; W</p>

<p><code>---o---o---o---M---x---x---W
               /
       ---A---B</code></p>

<h2>15. 获取短的 commit hash</h2>

<pre><code>bash</code><code>git rev-parse --short HEAD
</code></pre>

<h2>16. commit 了以后才记起来忘了创建 <code>.gitignore</code>, 垃圾文件都已经提交</h2>

<p>比如说一个nodejs项目，一开始的时候就忘记了创建<code>.gitnore</code>文件忽略掉<code>node_modules</code>的内容，所以其中的内容就已经被提交了。</p>

<p>即使紧接着你在<code>.gitignore</code>加了一行<code>node_modules</code>, 已经被提交的文件是不会自动删除的。</p>

<p>这时候你就需要做的就是：</p>

<pre><code>bash</code><code>git rm --cached path/to/ignored
#nodejs案例就是
git rm -r --cached node_modules
</code></pre>

<h2>17. 提交所有被删除的文件</h2>

<pre><code>$ git add -u
</code></pre>

<p>这个命令告诉 git 自动更新已跟踪的文件, 包括被删除的已跟踪文件。</p>

<p>如果你用的是 git 2.0</p>

<pre><code>$ git add -u :/
</code></pre>

<p>友情提示：从 git 2.0(2013年中)开始，以上命令会 stage 整个 working tree 的文件。<br>
如果你只是想 stage 当前目录的文件，应该这么用：</p>

<pre><code>$ git add -u .
</code></pre>

<p>详情可以去搜 ""“git add -A” 和 “git add .” 的区别"".</p>

<p>Ref: <a rel=""nofollow"" href=""http://stackoverflow.com/questions/1402776/how-do-i-commit-all-deleted-files-in-git"">StackOverflow</a></p>

<h2>18. 撤销上一次 <code>git add .</code> 操作</h2>

<p>这种情况通常是因为忘记添加<code>.gitignore</code>文件，或者一时手快把一些非必要的文件（如<code>node_modules</code>)跟踪了, 解决办法：</p>

<pre><code>bash</code><code>git reset
</code></pre>

<p>该命令会 unstage 你上一个 commit 增加的所有文件。</p>

<p>如果你只想 unstage 某些文件:</p>

<pre><code>git reset -- &lt;file 1&gt; &lt;file 2&gt; &lt;file n&gt;
</code></pre>

<p>还可以 unstage 文件里某处的改动：</p>

<pre><code>git reset -p
</code></pre>

                ", Git 常用命令,1531978062,312,1,426,1,1,https://segmentfault.com/a/1190000002796568
273,1,0,7,"
                    
<p>一直以来对<code>git push</code>与<code>git pull</code>命令的默认行为感觉混乱，今天抽空总结下。</p>

<h2>git push</h2>

<p>通常对于一个本地的新建分支，例如<code>git checkout -b develop</code>, 在develop分支commit了代码之后，如果直接执行<code>git push</code>命令，develop分支将不会被push到远程仓库（但此时<code>git push</code>操作有可能会推送一些代码到远程仓库，这取决于我们本地git config配置中的<code>push.default</code>默认行为，下文将会逐一详解）。</p>

<p>因此我们至少需要显式指定将要推送的分支名，例如<code>git push origin develop</code>，才能将本地新分支推送到远程仓库。</p>

<p>当我们通过显式指定分支名进行初次push操作后，本地有了新的commit，此时执行<code>git push</code>命令会有什么效果呢？</p>

<p>如果你未曾改动过git config中的<code>push.default</code>属性，根据我们使用的git不同版本（Git 2.0之前或之后），<code>git push</code>通常会有两种截然不同的行为:</p>

<ol>
<li>develop分支中本地新增的commit被push到远程仓库</li>
<li>push失败，并收到git如下的警告</li>
</ol>
<pre><code>fatal: The current branch new has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin develop
</code></pre>

<p>为什么git版本不同会有两种不同的push行为？</p>

<p>因为在<a rel=""nofollow"" href=""http://git-scm.com/docs/git-config"">git的全局配置中，有一个push.default</a>属性，其决定了<code>git push</code>操作的默认行为。在Git 2.0之前，这个属性的默认被设为'matching'，2.0之后则被更改为了'simple'。</p>

<p>我们可以通过<code>git version</code>确定当前的git版本（如果小于2.0，更新是个更好的选择），通过<code>git config --global push.default 'option'</code>改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p>

<p><strong>push.default</strong> 有以下几个可选值：<br><strong>nothing, current, upstream, simple, matching</strong></p>

<p>其用途分别为：</p>

<ul>
<li><p><strong>nothing</strong> - push操作无效，除非显式指定远程分支，例如<code>git push origin develop</code>（我觉得。。。可以给那些不愿学git的同事配上此项）。</p></li>
<li><p><strong>current</strong> - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。</p></li>
<li><p><strong>upstream</strong> - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。</p></li>
<li><p><strong>simple</strong> - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程<br>
upstream分支同名，否则会拒绝push操作。</p></li>
<li><p><strong>matching</strong> - push所有本地和远程两端都存在的同名分支。</p></li>
</ul>
<p>因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。</p>

<h2>upstream &amp; downstream</h2>

<p>说到这里，需要解释一下<a rel=""nofollow"" href=""http://stackoverflow.com/questions/2739376/definition-of-downstream-and-upstream"">git中的upstream到底是什么</a>：</p>

<blockquote>
  <p>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。</p>
</blockquote>

<p>初次提交本地分支，例如<code>git push origin develop</code>操作，并不会定义当前本地分支的upstream分支，我们可以通过<code>git push --set-upstream origin develop</code>，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如<code>git push -u origin develop</code>，这个操作在push的同时会指定当前分支的upstream。</p>

<p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p>

<h2>git pull</h2>

<p>弄清楚<code>git push</code>的默认行为后，再来看看<code>git pull</code>。</p>

<p>当我们未指定当前分支的upstream时，通常<code>git pull</code>操作会得到如下的提示：</p>

<pre><code>There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/&lt;branch&gt; new1
</code></pre>

<p><code>git pull</code>的默认行为和<code>git push</code>完全不同。当我们执行<code>git pull</code>的时候，实际上是做了<code>git fetch + git merge</code>操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p>

<p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p>

<pre><code>git branch --set-upstream-to=origin/&lt;branch&gt; develop
// 或者git push --set-upstream origin develop 
</code></pre>

<p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置，我们可以通过配置下面的内容指定某个分支的默认merge操作</p>

<pre><code>[branch ""develop""]
    remote = origin
    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?
</code></pre>

<p>或者通过command-line直接设置：</p>

<pre><code>git config branch.develop.merge refs/heads/develop
</code></pre>

<p>这样当我们在develop分支git pull时，如果没有指定upstream分支，git将根据我们的config文件去<code>merge origin/develop</code>；如果指定了upstream分支，则会忽略config中的merge默认配置。</p>

<p>以上就是git push和git pull操作的全部默认行为，如有错误，欢迎斧正</p>

<hr>
<p>[1] 为什么merge = refs/heads/develop 而不是refs/remotes/develop?<br>
因为这里merge指代的是我们想要merge的远程分支，是remote上的refs/heads/develop，文中即是origin上的refs/heads/develop，这和我们在本地直接执行<code>git merge</code>是不同的(本地执行<code>git merge origin/develop</code>则是直接merge refs/remotes/develop)。</p>

<p>refs:<br><a rel=""nofollow"" href=""http://git-scm.com/book/en/v2/Git-Internals-The-Refspec"">http://git-scm.com/book/en/v2/Git-Internals-The-Refspec</a><br><a rel=""nofollow"" href=""http://stackoverflow.com/questions/658885/how-do-you-get-git-to-always-pull-from-a-specific-branch"">http://stackoverflow.com/questions/658885/how-do-you-get-git-to-always...</a><br><a rel=""nofollow"" href=""http://stackoverflow.com/questions/17096311/why-do-i-need-to-explicitly-push-a-new-branch"">http://stackoverflow.com/questions/17096311/why-do-i-need-to-explicitl...</a><br><a rel=""nofollow"" href=""http://www.gitguys.com/topics/the-configuration-file-branch-section/"">http://www.gitguys.com/topics/the-configuration-file-branch-section/</a></p>

<p><em>by <a rel=""nofollow"" href=""http://blog.angular.in/git-pushmo-ren-fen-zhi/"">Abruzzi's blog</a></em></p>

                ", Git push与pull的默认行为,1531978063,153,1,765,1,1,https://segmentfault.com/a/1190000002783245
274,1,0,7,"
                    
<p>在尝试过用 GitHub 部署静态 HTML 网页后，觉得其实挺容易的，这里简单说说如何用 GitHub 来完成部署。</p>

<h2>1.新建版本库</h2>

<pre><code>首先咱们新建了一个版本库作为 demo，然后点击""settings""
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLuk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>2.<code>Automatic page generator</code>
</h2>

<pre><code>我们选择 ""GitHub Pages"" 的 ""Automatic page generator""
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>3.自由配置信息</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>4.<code>Continue to layouts</code>
</h2>

<pre><code>这里的google分析可以不填，咱们先把页面跑起来，点击""Continue to layouts""
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>5.选择模板</h2>

<pre><code>这里github给你提供了一些模板，我选了第一个模板，点击""Publish page""
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>6.注意分支</h2>

<pre><code>发布成功，这里是咱们的""gh-pages分支""
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>7.访问页面</h2>

<pre><code>点击""settings""，访问刚刚发布的静态页面链接
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>8.查看部署结果</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlLvS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>9.自定义你的页面</h2>

<pre><code>我们修改它的模板 ""index.html""

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=""en""&gt;
    &lt;meta charset=""UTF-8""&gt;
    &lt;title&gt;html5&lt;/title&gt;
    &lt;style type=""text/css""&gt;
    .theme{
      display: block;
      width: 200px;
      font-size: 30px;
      margin: 100px auto;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=""theme""&gt;
  Hello, world.
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>10.<code>add -&gt; commit -&gt; push</code>
</h2>

<p>这里要注意一下，我是直接新建的库，然后发布的，所以，没有master分支，只有<code>gh-pages分支</code>，github只会将你的<code>gh-pages分支</code>部署上去，不会动你的其他分支的东西。所以，我们要将改动提交到gh-pages分支上，再push。</p>

<pre><code>qianjiahaodeMacBook-Pro:HowToDeployHTML qianjiahao$ git branch
* gh-pages

qianjiahaodeMacBook-Pro:HowToDeployHTML qianjiahao$ git commit -a -m ""first commit""
[gh-pages cc8c864] first commit
 1 file changed, 23 insertions(+), 65 deletions(-)
 rewrite index.html (98%)

qianjiahaodeMacBook-Pro:HowToDeployHTML qianjiahao$ git push origin gh-pages
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 523 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:qianjiahao/HowToDeployHTML.git
   3d6ebe7..cc8c864  gh-pages -&gt; gh-pages
</code></pre>

<h2>11.确认结果</h2>

<pre><code>提交成功，我们看看咱们的网页，熟悉的 `Hello,world`
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlLwF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>12.demo</h2>

<blockquote>
  <p>到此为止，差不多讲完了，这个是<a rel=""nofollow"" href=""https://github.com/qianjiahao/HowToDeployHTML"">demo的地址</a></p>
</blockquote>

<h2>13.默认目录</h2>

<blockquote>
  <p>它帮我们生成的目录结构其实不太好，咱们可以自己定义自己的目录结构，之前的一个<a rel=""nofollow"" href=""https://github.com/qianjiahao/PlanDesigner"">项目</a>目录结构是这样的</p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVlLwT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>14.要注意的是：</h2>

<blockquote>
  <p>它会认准你的<code>index.html</code>页面，当做初始界面，我试过将它的index.html放入我的目录结构中，后来我部署发布后，<code>github</code>又自动给我生成了一个index.html页面，这个问题当时没有发现，导致出现了<code>更新无效等奇葩的情况</code>，疑惑了半天。还有<code>params.json</code>会配置github给你生成的模板信息。</p>
</blockquote>

<h2>15.修改默认目录</h2>

<blockquote>
  <p>如果是将已有的（静态）项目部署上线，建议自己修改目录结构</p>
</blockquote>

<pre><code>改改更健康""꒰･◡･๑꒱""
</code></pre>

<h2>16.<code>google analytics</code>
</h2>

<blockquote>
  <p>github推荐使用<a rel=""nofollow"" href=""https://www.google.com/analytics/"">google analytics</a>，在登录之后点击<code>管理</code>的<code>跟踪信息</code>，会看到它给你提供的id和code，把code粘贴到你的代码里，就可以了</p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVlLyf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>17.分析和统计</h2>

<blockquote>
  <p><code>google analytics</code>会帮你自动的做分析和统计</p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVlLyp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2><code>完~</code></h2>

                ", 用 GitHub 来部署静态网页 ꒰･◡･๑꒱,1531978064,159,1,382,1,1,https://segmentfault.com/a/1190000002765287
275,1,0,7,"
                    
<p>今天是我连续泡在Github上的第200天，也是蛮高兴的，终于达了:</p>

<p><span class=""img-wrap""><img data-src=""http://www.phodal.com/static/media/uploads/github-200-days.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Github 200 days""></span></p>

<p>故事的背影是: 去年国庆完后要去印度接受毕业生培训——就是那个神奇的国度。但是在去之前已经在项目待了九个多月，项目上的挑战越来越少，在印度的时间又算是比较多。便给自己设定了一个长期的goal，即100~200天的longest streak。</p>

<p>或许之前你看到过一篇文章<a rel=""nofollow"" href=""https://github.com/phodal/github-roam/blob/master/chapters/12-streak-your-github.md"">让我们连击</a>，那时已然140天，只是还是浑浑噩噩。到了今天，渐渐有了一个更清晰地思路。</p>

<p>先让我们来一下ShowCase，然后再然后，下一篇我们再继续。</p>

<h2>一些项目简述</h2>

<p>上面说到的培训一开始是用Java写的一个网站，有自动测试、CI、CD等等。由于是内部组队培训，代码不能公开等等因素，加之做得无聊。顺手，拿Node.js +RESTify 做了Server，Backbone + RequireJS + jQuery 做了前台的逻辑。于是在那个日子里，也在维护一些旧的repo，如<a rel=""nofollow"" href=""https://github.com/phodal/iot-coap"">iot-coap</a>、<a rel=""nofollow"" href=""https://github.com/phodal/iot"">iot</a>，前者是我拿到WebStorm开源License的Repo，后者则是毕业设计。</p>

<p>对于这样一个项目也需要有测试、自动化测试、CI等等。CI用的是Travics-CI。总体的技术构架如下:</p>

<h4>技术栈</h4>

<p>前台:</p>

<ul>
<li>Backbone </li>
<li>RequireJS</li>
<li>Underscore</li>
<li>Mustache</li>
<li>Pure CSS</li>
</ul>
<p>后台:</p>

<ul>
<li>RESTify</li>
</ul>
<p>测试:</p>

<ul>
<li>Jasmine</li>
<li>Chai</li>
<li>Sinon</li>
<li>Mocha</li>
<li>Jasmine-jQuery</li>
</ul>
<p>一直写到五星期的培训结束， 只是没有自动部署。想想就觉得可以用github-page的项目多好~~。</p>

<p>过程中还有一些有意思的小项目，如:</p>

<h3>google map solr polygon 搜索</h3>

<p><a rel=""nofollow"" href=""http://www.phodal.com/blog/google-map-width-solr-use-polygon-search/"">google map solr polygon 搜索</a></p>

<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509231928125"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Google Map Solr""></span></p>

<p>代码: <a rel=""nofollow"" href=""https://github.com/phodal/gmap-solr""></a><a rel=""nofollow"" href=""https://github.com/phodal/gmap-solr"">https://github.com/phodal/gmap-solr</a></p>

<h3>技能树</h3>

<p>这个可以从两部分说起:</p>

<h4>重构Skill Tree</h4>

<p>原来的是</p>

<ul>
<li>Knockout</li>
<li>RequireJS</li>
<li>jQuery</li>
<li>Gulp</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509232606537"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Skill Tree""></span></p>

<p>代码: <a rel=""nofollow"" href=""https://github.com/phodal/skillock""></a><a rel=""nofollow"" href=""https://github.com/phodal/skillock"">https://github.com/phodal/skillock</a></p>

<h4>技能树Sherlock</h4>

<ul>
<li>D3.js</li>
<li>Dagre-D3.js</li>
<li>jquery.tooltipster.js</li>
<li>jQuery</li>
<li>Lettuce</li>
<li>Knockout.js</li>
<li>Require.js</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509232331470"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""技能树 Sherlock""></span></p>

<p>代码: <a rel=""nofollow"" href=""https://github.com/phodal/sherlock""></a><a rel=""nofollow"" href=""https://github.com/phodal/sherlock"">https://github.com/phodal/sherlock</a></p>

<h3>Django Ionic ElasticSearch 地图搜索</h3>

<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509233119830"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Django Ionic ElasticSearch""></span></p>

<ul>
<li>ElasticSearch</li>
<li>Django</li>
<li>Ionic</li>
<li>OpenLayers 3</li>
</ul>
<p>代码: <a rel=""nofollow"" href=""https://github.com/phodal/django-elasticsearch""></a><a rel=""nofollow"" href=""https://github.com/phodal/django-elasticsearch"">https://github.com/phodal/django-elasticsearch</a></p>

<h3>简历生成器</h3>

<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509233651677"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Resume Generator""></span></p>

<ul>
<li>React</li>
<li>jsPDF</li>
<li>jQuery</li>
<li>RequireJS</li>
<li>Showdown</li>
</ul>
<p>代码: <a rel=""nofollow"" href=""https://github.com/phodal/resume""></a><a rel=""nofollow"" href=""https://github.com/phodal/resume"">https://github.com/phodal/resume</a></p>

<h3>Nginx 大数据学习</h3>

<p><span class=""img-wrap""><img data-src=""http://img.blog.csdn.net/20150509233836197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""nginx pig elastic search""></span></p>

<ul>
<li>ElasticSearch</li>
<li>Hadoop</li>
<li>Pig</li>
</ul>
<p>代码: <a rel=""nofollow"" href=""http://www.phodal.com/static/media/uploads/xnginx_pig.jpg.pagespeed.ic.SwlfwmhKtf.webp""></a><a rel=""nofollow"" href=""https://github.com/phodal/learning-data/tree/master/nginx"">https://github.com/phodal/learning-data/tree/master/nginx</a></p>

<h3>其他</h3>

<p>虽然技术栈上主要集中在Python、JavaScript，当然还有一些Ruby、Pig、Shell、Java的代码，只是我还是习惯用Python和JavaScript。一些用到觉得不错的框架:</p>

<ul>
<li>Ionic: 开始Hybird移动应用。</li>
<li>Django: Python Web开发利器。</li>
<li>Flask: Python Web开发小刀。</li>
<li>RequireJS: 管理js依赖。</li>
<li>Backbone: Model + View + Router。</li>
<li>Angluar: ...。</li>
<li>Knockout: MVV*。</li>
<li>React: 据说会火。</li>
<li>Cordova: Hybird应用基础。</li>
</ul>
<p>还应该有:</p>

<ul>
<li>ElasticSearch</li>
<li>Solr</li>
<li>Hadoop</li>
<li>Pig</li>
<li>MongoDB</li>
<li>Redis</li>
</ul>

                ", Github连击200天(1)——ShowCase,1531978065,291,1,997,1,1,https://segmentfault.com/a/1190000002749974
276,1,0,7,"
                    
<blockquote>
  <p>Docker 这个工具已经出现很长一段时间了，但是可能还有很多人对 Docker 的概念不太清楚，因此这次翻译 <a rel=""nofollow"" href=""http://blog.greenpages.com/miscellaneous-it/8-things-you-may-not-know-about-docker/"">8 个你可能不知道的 Docker 知识</a> 这篇文章，和大家介绍一下生产环境中的 Docker 用例。</p>
</blockquote>

<p>自从上世纪 90 年代硬件虚拟化被主流的技术广泛普及之后，对数据中心而言，发生的最大的变革莫过于容器和容器管理工具，例如：Docker。在过去的一年内，Docker 技术已经逐渐走向成熟，并且推动了大型初创公司例如 Twitter 和 Airbnb 的发展，甚至在银行、连锁超市、甚至 NASA 的数据中心都赢得了一席之地。当我几年前第一次直到 Docker 的时候，我还对 Docker 的未来持怀疑的态度，我认为他们是把以前的 Linux 容器的概念拿出来包装了一番推向市场。但是使用 Docker 成功进行了几个项目 例如 <a rel=""nofollow"" href=""http://www.spantree.net/"">Spantree</a> 之后，我改变了我的看法：Docker 帮助我们节省了大量的时间和经历，并且已经成为我们技术团队中不可或缺的工具。</p>

<p>GitHub 上面每天都会催生出各式各样的工具、形态各异的语言和千奇百怪的概念。如果你和我一样，没有时间去把他们全部都测试一遍，甚至没有时间去亲自测试 Docker，那么你可以看一下我的这篇文章：我将会用我们在 Docker 中总结的经验来告诉你什么是 Docker、为什么 Docker 会这么火。</p>

<h2>Docker 是容器管理工具</h2>

<p>Docker 是一个轻量级、便携式、与外界隔离的容器，也是一个可以在容器中很方便地构建、传输、运行应用的引擎。和传统的虚拟化技术不同的是，Docker 引擎并不虚拟出一台虚拟机，而是直接使用宿主机的内核和硬件，直接在宿主机上运行容器内应用。也正是得益于此，Docker 容器内运行的应用和宿主机上运行的应用性能差距几乎可以忽略不计。</p>

<p>但是 Docker 本身并不是一个容器系统，而是一个基于原有的容器化工具 LXC 用来创建虚拟环境的工具。类似 LXC 的工具已经在生产环境中使用多年，Docker 则基于此提供了更加友好的镜像管理工具和部署工具。</p>

<h2>Docker 不是虚拟化引擎</h2>

<p>Docker 第一次发布的时候，很多人都拿 Docker 和虚拟机 VMware、KVM 和 VirtualBox 比较。尽管从功能上看，Docker 和虚拟化技术致力于解决的问题都差不多，但是 Docker 却是采取了另一种非常不同的方式。虚拟机是虚拟出一套硬件，虚拟机的系统进行的磁盘操作，其实都是在对虚拟出来的磁盘进行操作。当运行 CPU 密集型的任务时，是虚拟机把虚拟系统里的 CPU 指令“翻译”成宿主机的CPU指令并进行执行。两个磁盘层，两个处理器调度器，两个操作系统消耗的内存，所有虚拟出的这些都会带来相当多的性能损失，一台虚拟机所消耗的硬件资源和对应的硬件相当，一台主机上跑太多的虚拟机之后就会过载。而 Docker 就没有这种顾虑。Docker 运行应用采取的是“容器”的解决方案：使用 namespace 和 CGroup 进行资源限制，和宿主机共享内核，不虚拟磁盘，所有的容器磁盘操作其实都是对 <code>/var/lib/docker/</code> 的操作。简言之，Docker 其实只是在宿主机中运行了一个受到限制的应用程序。</p>

<p>从上面不难看出，容器和虚拟机的概念并不相同，容器也并不能取代虚拟机。在容器力所不能及的地方，虚拟机可以大显身手。例如：宿主机是 Linux，只能通过虚拟机运行 Windows，Docker 便无法做到。再例如，宿主机是 Windows，Windows 并不能直接运行 Docker，Windows上的 Docker 其实是运行在 VirtualBox 虚拟机里的。</p>

<h2>Docker 使用层级的文件系统</h2>

<p>前面提到过，Docker 和现有容器技术 LXC 等相比，优势之一就是 Docker 提供了镜像管理。对于 Docker 而言，镜像是一个静态的、只读的容器文件系统的快照。然而不仅如此，Docker 中所有的磁盘操作都是对特定的Copy-On-Write文件系统进行的。下面通过一个例子解释一下这个问题。</p>

<p>例如我们要建立一个容器运行 JAVA Web 应用，那么我们应该使用一个已经安装了 JAVA 的镜像。在 Dockerfile（一个用于生成镜像的指令文件）中，应该指明“基于 JAVA 镜像”，这样 Docker 就会去 Docker Hub Registry 上下载提前构建好的 JAVA 镜像。然后再 Dockerfile 中指明下载并解压 Apache Tomcat 软件到 <code>/opt/tomcat</code> 文件夹中。这条命令并不会对原有的 JAVA 镜像产生任何影响，而仅仅是在原有镜像上面添加了一个改动层。当一个容器启动时，容器内的所有改动层都会启动，容器会从第一层中运行 <code>/usr/bin/java</code> 命令，并且调用另外一层中的 <code>/opt/tomcat/bin</code> 命令。实际上，Dockerfile 中每一条指令都会产生一个新的改动层，即便只有一个文件被改动。如果用过 Git 就能更清楚地认识这一点，每条指令就像是每次 commit，都会留下记录。但是对于 Docker 来说，这种文件系统提供了更大的灵活性，也可以更方便地管理应用程序。</p>

<p>我们Spantree的团队有一个自己维护的含有 Tomcat 的镜像。发布新版本也非常简单：使用 Dockerfile 将新版本拷贝进镜像从而创建一个新镜像，然后给新镜像贴上版本的标签。不同版本的镜像的不同之处仅仅是一个 90 MB 大小的 WAR 文件，他们所基于的主镜像都是相同的。如果使用虚拟机去维护这些不同的版本的话，还要消耗掉很多不同的磁盘去存储相同的系统，而使用 Docker 就只需要很小的磁盘空间。即便我们同时运行这个镜像的很多实例，我们也只需要一个基础的 JAVA / TOMCAT 镜像。</p>

<h2>Docker 可以节约时间</h2>

<p>很多年前我在为一个连锁餐厅开发软件时，仅仅是为了描述如何搭建环境都需要写一个 12 页的 Word 文档。例如本地 Oracle 数据库，特定版本的 JAVA，以及其他七七八八的系统工具和共享库、软件包。整个搭建过程浪费掉了我们团队每个人几乎一天的时间，如果用金钱衡量的话，花掉了我们上万美金的时间成本。虽然客户已经对这种事情习以为常，甚至认为这是引入新成员、让成员适应环境、让自己的员工适应我们的软件所必须的成本，但是相比较起来，我们宁愿把更多的时间花在为客户构建可以增进业务的功能上面。</p>

<p>如果当时有 Docker，那么构建环境就会像使用自动化搭建工具 Puppet / Chef / Salt / Ansible 一样简单，我们也可以把整个搭建时间周期从一天缩短为几分钟。但是和这些工具不同的地方在于，Docker 可以不仅仅可以搭建整个环境，还可以将整个环境保存成磁盘文件，然后复制到别的地方。需要从源码编译 Node.js 吗？Docker 做得到。Docker 不仅仅可以构建一个 Node.js 环境，还可以将整个环境做成镜像，然后保存到任何地方。当然，由于 Docker 是一个容器，所以不用担心容器内执行的东西会对宿主机产生任何的影响。</p>

<p>现在新加入我们团队的人只需要运行 <code>docker-compose up</code> 命令，便可以喝杯咖啡，然后开始工作了。</p>

<h2>Docker 可以节省开销</h2>

<p>当然，时间就是金钱。除了时间外，Docker 还可以节省在基础设施硬件上的开销。高德纳和麦肯锡的研究表明，数据中心的利用率在 6% - 12% 左右。不仅如此，如果采用虚拟机的话，你还需要被动地监控和设置每台虚拟机的 CPU 硬盘和内存的使用率，因为采用了静态分区(static partitioning)所以资源并不能完全被利用。。而容器可以解决这个问题：容器可以在实例之间进行内存和磁盘共享。你可以在同一台主机上运行多个服务、可以不用去限制容器所消耗的资源、可以去限制资源、可以在不需要的时候停止容器，也不用担心启动已经停止的程序时会带来过多的资源消耗。凌晨三点的时候只有很少的人会去访问你的网站，同时你需要比较多的资源执行夜间的批处理任务，那么可以很简单的便实现资源的交换。</p>

<p>虚拟机所消耗的内存、硬盘、CPU 都是固定的，一般动态调整都需要重启虚拟机。而用 Docker 的话，你可以进行资源限制，得益于 CGroup，可以很方便动态调整资源限制，让然也可以不进行资源限制。Docker 容器内的应用对宿主机而言只是两个隔离的应用程序，并不是两个虚拟机，所以宿主机也可以自行去分配资源。</p>

<h2>Docker 有一个健壮的镜像托管系统</h2>

<p>前面提到过，这个托管系统就叫做 Docker Hub Registry。截止到 2015年4月29日，互联网上大约有 14000 个公共的 Docker，而大部分都被托管在 Docker Hub 上面。和 Github 已经很大程度上成为开源项目的代表一样，Docker 官方的 Docker Hub 则已经是公共 Docker 镜像的代表。这些镜像可以作为你应用和数据服务的基础。</p>

<p>也正是得益于此，你可以随意尝试最新的技术：说不定有些人就把图形化数据库的实例打包成了 Docker 镜像托管在上面。再例如 Gitlab，手工搭建 Gitlab 非常困难，译者不建议普通用户去手工搭建，而如果使用 Docker Gitlab，这个镜像则会五秒内便搭建完成。再例如特定 Ruby 版本的 Rails 应用，再例如 Linux 上的 .NET 应用，这些都可以使用简单的一条 Docker 命令搭建完成。</p>

<blockquote>
  <p>Docker 官方镜像都有 official 标签，安全性可以保证。但是第三方镜像的安全性无法保证，所以请谨慎下载第三方镜像。生产环境下可以只使用第三方提供的 Dockerfile 构建镜像。</p>
  
  <p><a rel=""nofollow"" href=""http://www.oschina.net/p/docker-gitlab"">Docker Github 介绍：5 秒内搞定一个 Gitlab</a></p>
  
  <p>关于 Linux 上的 .NET 应用和 Rails 应用，将会在以后的文章中做详细介绍。</p>
</blockquote>

<h2>Docker 可以避免产生 Bug</h2>

<p>Spantree 一直是“固定基础设置”（immutable infrastructure）的狂热爱好者。换句话说，除非有心脏出血这种漏洞，我们尽量不对系统做升级，也尽量不去改变系统的设置。当添加新服务器的时候，我们也会从头构建服务器的系统，然后直接将镜像导入，将服务器放入负载均衡的集群里，然后对要退休的服务器进行健康检查，检查完毕后移除集群。得益于 Docker 镜像可以很轻松的导入导出，我们可以最大程度地减少因为环境和版本问题导致的不兼容，即便有不兼容了也可以很轻松地回滚。当然，有了 Docker，我们在生产、测试和开发中的运行环境得到统一。以前在协同开发时，会因为每个人开发的电脑配置不同而导致“在我的电脑上是能运行的，你的怎么不行”的情况，而如今 Docker 已经帮我们解决了这个问题。</p>

<h2>Docker 目前只能运行在 Linux 上</h2>

<p>前面也提到过，Docker 使用的是经过长时间生产环境检验的技术，虽然这些技术已经都出现很长时间了，但是大部分技术都还是 Linux 独有的，例如 LXC 和 Cgroup。也就是说，截止到现在，Docker 容器内只能在 Linux 上运行 Linux 上的服务和应用。Microsoft 正在和 Docker 紧密合作，并且已经宣布了下一个版本的 Windows Server 将会支持 Docker 容器，并且命名为 Windows Docker，估计采用的技术应该是Hyper-V Container，我们有望在未来的几年内看到这个版本。</p>

<p>除此之外，类似 boot2docker 和 Docker Machine 这种工具已经可以让我们在 Mac 和 Windows 下通过虚拟机运行 Docker 了。</p>

<h2>后记</h2>

<p>悄悄的说一句，前文中提到的 <a rel=""nofollow"" href=""http://segmentfault.com/a/1190000002711327"">Docker 安装</a>、<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000002711327"">Docker 操作</a>、<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000002711357"">Dockerfile</a>、<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000002711379"">Docker Hub</a>、搭建 Rails 环境、甚至搭建 .NET 环境，SegmentFault 正在组织编写相关的文档，欢迎关注我们，及时获取更多最新的教程。</p>

                ", 8 个你可能不知道的 Docker 知识,1531978066,520,1,489,1,1,https://segmentfault.com/a/1190000002734062
277,1,0,7,"
                    
<h2>安装基本系统与依赖包</h2>

<h3>安装 Gitlab 依赖的工具</h3>

<pre><code>bash</code><code>yum -y update
yum -y groupinstall 'Development Tools'
yum -y install readline readline-devel ncurses-devel gdbm-devel glibc-devel tcl-devel openssl-devel curl-devel expat-devel db4-devel byacc sqlite-devel libyaml libyaml-devel libffi libffi-devel libxml2 libxml2-devel libxslt libxslt-devel libicu libicu-devel system-config-firewall-tui git redis ruby sudo wget crontabs logwatch logrotate perl-Time-HiRes
</code></pre>

<h3>安装 Redis</h3>

<p>访问 <a rel=""nofollow"" href=""http://www.redis.io/download""></a><a rel=""nofollow"" href=""http://www.redis.io/download"">http://www.redis.io/download</a>，下载 <strong>Redis</strong> 源代码。</p>

<pre><code>bash</code><code>wget http://download.redis.io/releases/redis-3.0.0.tar.gz
tar zxvf redis-3.0.0.tar.gz
cd redis-3.0.0
make
</code></pre>

<blockquote>
  <p>若在编译过程中出错，则可以执行下面的命令：</p>

<pre><code>bash</code><code>sudo make test
</code></pre>
</blockquote>

<h4>安装：</h4>

<pre><code>bash</code><code>sudo make install
sudo ./utils/install_server.sh
</code></pre>

<h4>配置</h4>

<p>创建 <code>/etc/init.d/redis</code> 并使用下面的代码作为启动脚本。</p>

<p>添加如下内容：</p>

<pre><code>bash</code><code>###########################
PATH=/usr/local/bin:/sbin:/usr/bin:/bin

REDISPORT=6379
EXEC=/usr/local/bin/redis-server
REDIS_CLI=/usr/local/bin/redis-cli

PIDFILE=/var/run/redis.pid
CONF=""/etc/redis/6379.conf""

case ""$1"" in
    start)
        if [ -f $PIDFILE ]
        then
                echo ""$PIDFILE exists, process is already running or crashed""
        else
                echo ""Starting Redis server...""
                $EXEC $CONF
        fi
        if [ ""$?""=""0"" ]
        then
              echo ""Redis is running...""
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
                echo ""$PIDFILE does not exist, process is not running""
        else
                PID=$(cat $PIDFILE)
                echo ""Stopping ...""
                $REDIS_CLI -p $REDISPORT SHUTDOWN
                while [ -x ${PIDFILE} ]
               do
                    echo ""Waiting for Redis to shutdown ...""
                    sleep 1
                done
                echo ""Redis stopped""
        fi
        ;;
   restart|force-reload)
        ${0} stop
        ${0} start
        ;;
  *)
    echo ""Usage: /etc/init.d/redis {start|stop|restart|force-reload}"" &gt;&amp;2
        exit 1
esac
##############################
</code></pre>

<p>保存后，添加可执行权限：</p>

<pre><code>sudo chmod +x /etc/init.d/redis
</code></pre>

<p>确保 <code>redis</code> 能随系统启动：</p>

<pre><code>vi /etc/rc.d/rc.local
</code></pre>

<p>在文件末尾添加下面这行：</p>

<pre><code>service redis start
</code></pre>

<p>然后使用上面同样的命令启动 <code>redis</code> 服务：</p>

<pre><code>service redis start
</code></pre>

<h3>安装邮件服务器</h3>

<pre><code>yum -y install postfix
</code></pre>

<h3>安装Git</h3>

<p>先删除系统中原有的老版本 <code>git</code>：</p>

<pre><code>bash</code><code>yum -y remove git
yum install zlib-devel perl-CPAN gettext curl-devel expat-devel gettext-devel openssl-devel
</code></pre>

<p>从官方网站下载源代码进行：</p>

<pre><code>bash</code><code>curl --progress https://www.kernel.org/pub/software/scm/git/git-2.4.0.tar.gz | tar xz
cd git-2.4.0/
./configure
make
make prefix=/usr/local install
</code></pre>

<p>然后使用下面这个命令检测安装是否有效：</p>

<pre><code>which git
</code></pre>

<h2>安装 ruby</h2>

<p>如果 ruby 的版本低于 <code>2.0</code> 的话，则需要重新安装 <code>ruby</code>。</p>

<pre><code>bash</code><code>cd ~
curl --progress ftp://ftp.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz | tar xz
cd ruby-2.2.2
./configure --disable-install-rdoc
make
make prefix=/usr/local install
</code></pre>

<h2>为 Gitlab 添加系统用户</h2>

<pre><code>adduser --system --shell /bin/bash --comment 'GitLab' --create-home --home-dir /home/git/ git
</code></pre>

<p>为了包含/usr/local/bin到git用户的$PATH，一个方法是编辑超级用户文件。以管理员身份运行：</p>

<pre><code>visudo
</code></pre>

<p>然后搜索：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin
</code></pre>

<p>将其改成：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
</code></pre>

<h2>安装数据库</h2>

<p>MySQL 已经不再包含在 CentOS 7 的源中，而改用了 MariaDB，先搜索 <code>MariaDB</code> 现有的包：</p>

<pre><code>rpm -qa | grep mariadb
</code></pre>

<p>然后全部删除：</p>

<pre><code>rpm -e --nodeps mariadb-*
</code></pre>

<p>然后创建 <code>/etc/yum.repos.d/MariaDB.repo</code>：</p>

<pre><code>vi /etc/yum.repos.d/MariaDB.repo
</code></pre>

<p>将以下内容添加至该文件中：</p>

<pre><code># MariaDB 10.0 CentOS repository list - created 2015-05-04 19:16 UTC
# http://mariadb.org/mariadb/repositories/
[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.0/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
</code></pre>

<p>然后运行下面命令安装 <code>MariaDB 10.0</code>：</p>

<pre><code>sudo yum install MariaDB-server MariaDB-client
</code></pre>

<p>然后启动 MariaDB 服务：</p>

<pre><code>service mysql start
</code></pre>

<p>接着运行 <code>mysql_secure_installation</code>：</p>

<pre><code>mysql_secure_installation
</code></pre>

<p>登录 MariaDB 并创建相应的数据库用户与数据库：</p>

<pre><code>mysql -uroot -p
CREATE USER 'git'@'localhost' IDENTIFIED BY '$password';
SET storage_engine=INNODB;
CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;
GRANT SELECT, LOCK TABLES, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO 'git'@'localhost';
\q
</code></pre>

<p>尝试使用新用户连接数据库：</p>

<pre><code>sudo -u git -H mysql -u git -p -D gitlabhq_production
\q
</code></pre>

<h2>安装 Gitlab</h2>

<h3>克隆源</h3>

<pre><code>sudo -u -git cd /home/git
sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-ce.git -b 7-10-stable gitlab
</code></pre>

<h3>配置</h3>

<pre><code>cd /home/git/gitlab

# Copy the example GitLab config
# 复制GitLab的示例配置文件
sudo -u git -H cp config/gitlab.yml.example config/gitlab.yml

# Make sure to change ""localhost"" to the fully-qualified domain name of your host serving GitLab where necessary
# 确保修改“localhost”为你的GitLab主机的FQDN
#
# If you want to use https make sure that you set `https` to `true`. See #using-https for all necessary details.
# 如果你想要使用https确保你设置了`https`为`true`。具体必要的细节参见#using-https
#
# If you installed Git from source, change the git bin_path to /usr/local/bin/git
# 如果你从源代码安装了Git，修改git的bin_path为/usr/local/bin/git
sudo -u git -H editor config/gitlab.yml

# Make sure GitLab can write to the log/ and tmp/ directories
# 确保GitLab可以写入log/和temp/目录
chown -R git {log,tmp}
chmod -R u+rwX  {log,tmp}

# Create directory for satellites
# 为卫星(?)创建目录
sudo -u git -H mkdir /home/git/gitlab-satellites
chmod u+rwx,g+rx,o-rwx /home/git/gitlab-satellites

# Make sure GitLab can write to the tmp/pids/ and tmp/sockets/ directories
# 确保GitLab可以写入tmp/pids/和temp/sockets/目录
chmod -R u+rwX  tmp/{pids,sockets}

# Make sure GitLab can write to the public/uploads/ directory
# 确保GitLab可以写入public/uploads/目录
chmod -R u+rwX  public/uploads

# Copy the example Unicorn config
# 复制Unicorn的示例配置文件
sudo -u git -H cp config/unicorn.rb.example config/unicorn.rb

# Enable cluster mode if you expect to have a high load instance
# Ex. change amount of workers to 3 for 2GB RAM server
# 启用集群模式如果你期望拥有一个高负载实例
# 附：修改worker的数量到3用于2GB内存的服务器
sudo -u git -H editor config/unicorn.rb

# Copy the example Rack attack config
# 复制Rack attack的示例配置文件
sudo -u git -H cp config/initializers/rack_attack.rb.example config/initializers/rack_attack.rb

# Configure Git global settings for git user, useful when editing via web
# Edit user.email according to what is set in config/gitlab.yml
# 为git用户配置Git全局设定，当通过web修改时有用
# 修改user.email根据config/gitlab.yml中的设定
sudo -u git -H git config --global user.name ""GitLab""
sudo -u git -H git config --global user.email ""gitlab@localhost""
sudo -u git -H git config --global core.autocrlf input
</code></pre>

<h2>数据库配置</h2>

<pre><code># MySQL only:
# 仅限MySQL：
sudo -u git cp config/database.yml.mysql config/database.yml

# MySQL and remote PostgreSQL only:
# Update username/password in config/database.yml.
# You only need to adapt the production settings (first part).
# If you followed the database guide then please do as follows:
# Change 'secure password' with the value you have given to $password
# You can keep the double quotes around the password
# 仅限MySQL和远程PostgreSQL：
# 在config/database.yml中更新用户名/密码；
# 你只需要适配生产设定（第一部分）；
# 如果你跟从数据库向导，请按以下操作：
# 修改'secure password'使用你刚才设定的$password；
# 你可以保留密码两端的双引号。
sudo -u git -H editor config/database.yml

# PostgreSQL and MySQL:
# Make config/database.yml readable to git only
# PostgreSQL和MySQL：
# 设置config/database.yml仅对git可读。
sudo -u git -H chmod o-rwx config/database.yml
</code></pre>

<h3>安装 Gems</h3>

<pre><code>cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source ""http://ruby.taobao.org"" // 原始 source ""https://rubygems.org/""

# For MySQL (note, the option says ""without ... postgres"")
sudo -u git -H bundle install --deployment --without development test postgres aws
</code></pre>

<h2>Install GitLab shell</h2>

<h3>安装GitLab Shell</h3>

<p>GitLab Shell是一个专门为GitLab开发的SSH访问和源管理软件。</p>

<pre><code># Go to the Gitlab installation folder:
# 转到GitLab安装目录：
cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source ""http://ruby.taobao.org"" // 原始 source ""https://rubygems.org/""

# Run the installation task for gitlab-shell (replace `REDIS_URL` if needed):
# 运行gitlab-shell的安装任务（替换`REDIS_URL`如果有需要的话）：
sudo -u git -H bundle exec rake gitlab:shell:install[v1.9.6] REDIS_URL=redis://localhost:6379 RAILS_ENV=production

# By default, the gitlab-shell config is generated from your main gitlab config.
# 默认的，gitlab-shell的配置文件是由你的gitlab主配置文件生成的。
#
# Note: When using GitLab with HTTPS please change the following:
# - Provide paths to the certificates under `ca_file` and `ca_path options.
# - The `gitlab_url` option must point to the https endpoint of GitLab.
# - In case you are using self signed certificate set `self_signed_cert` to `true`.
# See #using-https for all necessary details.
# 提示：当通过HTTPS使用GitLab时，请做出如下更改：
# - 提供证书的路径在`ca_file`和`ca_path`选项；
# - `gitlab_url`选项必须指向GitLab的https端点；
# - 如果你使用自签名的证书，设置`self-signed_cert`为`true`。
# 所有必需的具体细节参见#using-https
#
# You can review (and modify) it as follows:
# 你可以检查（并修改该）通过以下方法：
sudo -u git -H editor /home/git/gitlab-shell/config.yml

# Ensure the correct SELinux contexts are set
# Read http://wiki.centos.org/HowTos/Network/SecuringSSH
# 确保正确的SELinux上下文被设置
# 阅读http://wiki.centos.org/HowTos/Network/SecuringSSH
restorecon -Rv /home/git/.ssh
</code></pre>

<h3>初始化数据库和激活高级功能</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production
# Type 'yes' to create the database tables.
# When done you see 'Administrator account created:'
</code></pre>

<p>提示：你可以设置管理员密码通过在环境变量GITLAB_ROOT_PASSWORD中提供，例如：</p>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production GITLAB_ROOT_PASSWORD=newpassword
</code></pre>

<h3>安装初始化脚本</h3>

<p>下载初始化脚本（将放在/etc/init.d/gitlab）：</p>

<pre><code>sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab
chmod +x /etc/init.d/gitlab
chkconfig --add gitlab
</code></pre>

<p>设置GitLab开机启动：</p>

<pre><code>chkconfig gitlab on
</code></pre>

<p>设置日志翻转</p>

<pre><code>cp lib/support/logrotate/gitlab /etc/logrotate.d/gitlab
</code></pre>

<h3>检查应用状态</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production
</code></pre>

<h3>编译静态文件</h3>

<pre><code>sudo -u git -H bundle exec rake assets:precompile RAILS_ENV=production
</code></pre>

<h3>启动实例</h3>

<pre><code>/etc/init.d/gitlab start
</code></pre>

                ", CentOS 7 安装 Gitlab,1531978068,408,1,515,1,1,https://segmentfault.com/a/1190000002729796
278,1,0,7,"
                    
<blockquote>
  <p>原文出處：<a rel=""nofollow"" href=""http://blog.amowu.com/2015/04/devops-continuous-integration-delivery-docker-circleci-aws-beanstalk.html"">DevOps：持續整合＆持續交付（Docker、CircleCI、AWS）</a></p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""cover""></span></p>

<p>這篇文章將一步一步介紹如何使用 Docker、GitHub Flow、CircleCI、AWS Elastic Beanstalk 與 Slack 來完成<strong>持續整合</strong>與<strong>持續交付</strong>的開發流程。</p>

<h2>前言</h2>

<h3>什麼是持續整合＆持續交付？</h3>

<p>持續整合＆持續交付（Continuous Integration &amp; Continous Delivery），簡稱 CI &amp; CD，具體介紹可以參考「<a rel=""nofollow"" href=""http://blog.eavatar.com/post/2013/10/continuous-integration-deployment-delivery/"">山姆鍋對持續整合、持續部署、持續交付的定義</a>」這篇文章。</p>

<p>簡單來說就是盡量減少手動人力，將一些日常工作交給自動化工具。例如：環境建置、單元測試、日誌紀錄、產品部署。</p>

<h3>我使用了哪些工具？</h3>

<ul>
<li>
<a rel=""nofollow"" href=""http://git-scm.com/"">Git</a> - 版本管理</li>
<li>
<a rel=""nofollow"" href=""https://github.com/"">GitHub</a> - 程式碼託管、審查</li>
<li>
<a rel=""nofollow"" href=""https://circleci.com/"">CircleCI</a> - 自動化建置、測試、部署</li>
<li>
<a rel=""nofollow"" href=""https://www.docker.com/"">Docker</a> - 可攜式、輕量級的執行環境</li>
<li>
<a rel=""nofollow"" href=""https://aws.amazon.com/elasticbeanstalk/"">AWS Elastic Beanstalk</a> - 雲端平台</li>
<li>
<a rel=""nofollow"" href=""https://slack.com/"">Slack</a> - 團隊溝通、日誌、通知</li>
</ul>
<h3>看完這篇你可以學到什麼？</h3>

<ul>
<li>瞭解 GiHub 的工作流程（<a rel=""nofollow"" href=""https://guides.github.com/introduction/flow/"">GitHub Flow</a>），利用 <strong>Pull Request</strong> 以及<strong>分支</strong>來完成<strong>代碼審查</strong>（Code Review）與<strong>環境配置</strong>，例如：開發版（development）、測試版（testing/QA）、上線產品（staging/production）。</li>
<li>使用 Docker，統一開發者、測試人員、以及產品的執行環境。</li>
<li>使用 EB CLI 將應用程式部署到 AWS Elastic Beanstalk 平台上。</li>
<li>使用 CircleCI 將以上工作全部自動化。偵測 GitHub 分支上的程式碼，若有更新則觸發：建置 Docker 環境、單元測試、然後自動部署新版本到 AWS EB。</li>
<li>使用 Slack，讓團隊成員能夠即時接收 GitHub 與 CircleCI 每一項動作的通知。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVlxhq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""sequence-diagram""></span></p>

<h2>內容大綱</h2>

<ul>
<li>
<a rel=""nofollow"">Node.js</a><br><br><ul>
<li>在本地端執行 Node.js</li>
<li>在本地端測試 Node.js</li>
</ul>
</li>
<li><a rel=""nofollow"">GitHub</a></li>
<li>
<a rel=""nofollow"">CircleCI</a><br><br><ul>
<li>在 CircleCI 測試 Node.js</li>
</ul>
</li>
<li><a rel=""nofollow"">Code Review with GitHub Flow</a></li>
<li>
<a rel=""nofollow"">Docker</a><br><br><ul>
<li>在 Docker 執行 Node.js</li>
<li>在 CircleCI 測試 Docker</li>
</ul>
</li>
<li>
<a rel=""nofollow"">AWS Elastic Beanstalk</a><br><br><ul>
<li>在本地端部署 AWS</li>
<li>在 CircleCI 部署 AWS</li>
</ul>
</li>
<li><a rel=""nofollow"">Slack</a></li>
</ul>
<h2>Node.js</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlxht"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""node""></span></p>

<blockquote>
  <p>安裝：</p>
  
  <ul>
<li>
<a rel=""nofollow"" href=""https://nodejs.org/"">node</a>: 0.10</li>
  </ul>
</blockquote>

<p>這篇文章以 Node.js 的應用程式作為範例，其他語言（Ruby on Rails、Python、PHP）也同樣適用此工作流程。</p>

<h3>建立新專案</h3>

<ol>
<li>
<p>建立一個專案資料夾（這裡以 <code>hello-ci-workflow</code> 為例）：</p>

<pre><code>bash</code><code>$ mkdir hello-ci-workflow
$ cd hello-ci-workflow
</code></pre>
</li>
</ol>
<h3>在本地端執行 Node.js</h3>

<ol>
<li>
<p>初始化 Node.js 的環境，填寫一些資料之後會在目錄下產生一個 <code>package.json</code> 的檔案：</p>

<pre><code>bash</code><code>$ npm init
</code></pre>
</li>
<li>
<p>安裝 Node.js 的 web framework，以 <a rel=""nofollow"" href=""http://expressjs.com/"">Express</a> 為例：</p>

<pre><code>bash</code><code>$ npm install express --save
</code></pre>

<blockquote>
  <p><code>--save</code>：寫入 <code>package.json</code> 的 dependencies。</p>
</blockquote>
</li>
<li>
<p>完成之後，<code>package.json</code> 大概會長這個樣子：</p>

<pre><code>json</code><code>// package.json
{
  ""name"": ""hello-ci-workflow"",
  ""main"": ""index.js"",
  ""dependencies"": {
    ""express"": ""^4.12.3""
  },
  ""scripts"": {
    ""start"": ""node index.js""
  }
}
</code></pre>
</li>
<li>
<p>在 <code>index.js</code> 裡寫一段簡單的 Hello World! 的程式：</p>

<pre><code>javascript</code><code>// index.js
var express = require('express');
var app = express();

app.get('/', function (req, res) {
  res.send('Hello World!');
});

var server = app.listen(3000, function () {

  var host = server.address().address;
  var port = server.address().port;

  console.log('Example app listening at http://%s:%s', host, port);

});
</code></pre>
</li>
<li>
<p>執行 <code>npm start</code> 或 <code>node index.js</code>：</p>

<pre><code>bash</code><code>$ npm start
</code></pre>
</li>
<li>
<p>打開瀏覽器 <code>http://localhost:3000</code> 看結果：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""01""></span></p>
</li>
</ol>
<h3>在本地端測試 Node.js</h3>

<ol>
<li>
<p>安裝 Node.js 的單元測試，以 <a rel=""nofollow"" href=""http://mochajs.org/"">Mocha</a> 為例：</p>

<pre><code>bash</code><code>$ npm install mocha --save-dev
</code></pre>

<blockquote>
  <p><code>--save-dev</code>: 寫入 <code>package.json</code> 的 devDependencies，正式上線環境不會被安裝。</p>
</blockquote>

<pre><code>json</code><code>// package.json
{
  ""name"": ""hello-ci-workflow"",
  ""main"": ""index.js"",
  ""dependencies"": {
    ""express"": ""^4.12.3""
  },
  ""devDependencies"": {
    ""mocha"": ""^2.2.4""
  },
  ""scripts"": {
    ""start"": ""node index.js""
  }
}
</code></pre>
</li>
<li>
<p>根目錄 <code>test</code> 資料夾，並新增一個測試腳本 <code>test.js</code>：</p>

<pre><code>bash</code><code>$ mkdir test
$ cd test
$ touch test.js
</code></pre>
</li>
<li>
<p>加入一筆錯誤的測試 <code>assert.equal(1, [1,2,3].indexOf(0))</code>：</p>

<pre><code>javascript</code><code>// test/test.js
var assert = require(""assert"")
describe('Array', function(){
  describe('#indexOf()', function(){
    it('should return -1 when the value is not present', function(){
      assert.equal(1, [1,2,3].indexOf(0));
    })
  })
})
</code></pre>
</li>
<li>
<p>執行 mocha 測試：</p>

<pre><code>bash</code><code>$ ./node_modules/.bin/mocha


  Array
    #indexOf()
      1) should return -1 when the value is not present


  0 passing (9ms)
  1 failing
</code></pre>

<p>結果顯示 <code>1 failing</code>，測試沒通過，因為 <code>[1,2,3].indexOf(0)</code> 回傳的值不等於 <code>-1</code>。</p>
</li>
<li>
<p>將 <code>test.js</code> 的測試修正：</p>

<pre><code>javascript</code><code>// test/test.js
assert.equal(-1, [1,2,3].indexOf(0));
</code></pre>
</li>
<li>
<p>再次執行 mocha 測試：</p>

<pre><code>bash</code><code>$ ./node_modules/.bin/mocha


  Array
    #indexOf()
      ✓ should return -1 when the value is not present


  1 passing (6ms)
</code></pre>

<p>結果顯示 <code>1 passing</code>，通過測試。</p>
</li>
</ol>
<h2>GitHub</h2>

<p><span class=""img-wrap""><img data-src=""http://3.bp.blogspot.com/-saBab53n15w/VTpQvQI7f6I/AAAAAAAAkcU/Fp8e4aaFy8E/s1600/github.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""github""></span></p>

<p>安裝：<a rel=""nofollow"" href=""http://git-scm.com/"">git</a>: 2.3<br>
帳號：<a rel=""nofollow"" href=""https://github.com/"">GitHub</a></p>

<ol>
<li>
<p>初始化 git 環境：</p>

<pre><code>bash</code><code>$ git init .
</code></pre>
</li>
<li>
<p>輸入 <code>git status</code> 會顯示目前哪些檔案有過更動：</p>

<pre><code>bash</code><code>$ git status
On branch master

Initial commit

Untracked files:
  (use ""git add &lt;file&gt;..."" to include in what will be committed)

  index.js
  node_modules/
  package.json
  test/
</code></pre>
</li>
<li>
<p>將 <code>node_modules</code> 加到 <code>.gitignore</code> 黑名單，因為這個資料夾是由 <code>npm install</code> 自動產生的，不需要放到 GitHub 上：</p>

<pre><code>yaml</code><code># .gitignore

# Dependency directory
# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
node_modules
</code></pre>
</li>
<li>
<p>將更動 commit：</p>

<pre><code>bash</code><code>$ git add .
$ git commit -m ""first commit""
</code></pre>
</li>
<li>
<p>打開 GitHub，新增一個 repository：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""02""></span></p>
</li>
<li>
<p>輸入 repository 的名稱，以 <code>hello-ci-workflow</code> 為例：</p>

<p><span class=""img-wrap""><img data-src=""http://3.bp.blogspot.com/-JysiO9Ff45I/VTpUfAfgE2I/AAAAAAAAke0/BFYGaMZ9MU0/s1600/03.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""03""></span></p>
</li>
<li>
<p>使用 <code>git remote add</code> 將新創建的 GitHub repository 加入到 remote：</p>

<pre><code>bash</code><code>$ git remote add origin https://github.com/&lt;USER_NAME&gt;/hello-ci-workflow.git
</code></pre>

<blockquote>
  <p><code>&lt;USER_NAME&gt;</code> 改成自己的帳號。</p>
</blockquote>
</li>
<li>
<p>使用 <code>git push</code> 將程式碼傳到 GitHub：</p>

<pre><code>bash</code><code>$ git push -u origin master
</code></pre>

<p>成功之後前往 <code>https://github.com/&lt;USER_NAME&gt;/hello-ci-workflow</code> 就可以看到剛才上傳的檔案：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""04""></span></p>
</li>
</ol>
<h2>CircleCI</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""circleci""></span></p>

<p>帳號：<a rel=""nofollow"" href=""https://circleci.com/"">CircleCI</a></p>

<h3>加入 GitHub repository</h3>

<ol>
<li>
<p>點選左邊欄的 <code>Add Projects</code> 按鈕：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""05""></span></p>
</li>
<li>
<p>選擇自己的 GitHub 帳號：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""06""></span></p>
</li>
<li>
<p>搜尋要加入的 GitHub repository，然後點選 <code>Build project</code> 按鈕，以 <code>hello-ci-workflow</code> 為例：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""07""></span></p>
</li>
<li>
<p>完成之後 CircleCI 就會自動執行第一次的建構，不過因為還沒加入測試腳本，所以建構結果會顯示 no test：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiJ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""08""></span></p>
</li>
</ol>
<h3>在 CircleCI 測試 Node.js</h3>

<ol>
<li>
<p>在專案根目錄底下建立一個 <code>circle.yml</code>，並加入 mocha test：</p>

<pre><code>yaml</code><code># circle.yml
machine:
  node:
    version: 0.10

test:
  override:
    - ./node_modules/.bin/mocha
</code></pre>
</li>
<li>
<p>完成之後將檔案 push 上 GitHub：</p>

<pre><code>bash</code><code>$ git add circle.yml
$ git cimmit ""add circle.yml""
$ git push
</code></pre>
</li>
<li>
<p>Push 成功之後，CircleCI 會自動觸發建構和測試：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""09""></span></p>
</li>
<li>
<p>測試通過，建置成功：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""10""></span></p>
</li>
</ol>
<h2>代碼審查（Code Review）with GitHub Flow</h2>

<p>目前開發中比較常用的 workflow 有 <a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">Git flow</a> 和 <a rel=""nofollow"" href=""https://guides.github.com/introduction/flow/"">GitHub flow</a> 兩種，可以參考以下幾篇文章：</p>

<p>Git flow：</p>

<ul>
<li><a rel=""nofollow"" href=""https://ihower.tw/blog/archives/5140"">Git flow 開發流程</a></li>
<li><a rel=""nofollow"" href=""https://danielkummer.github.io/git-flow-cheatsheet/"">git-flow cheatsheet</a></li>
<li><a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">A successful Git branching model</a></li>
</ul>
<p>GitHub flow：</p>

<ul>
<li><a rel=""nofollow"" href=""https://guides.github.com/introduction/flow/"">Understanding the GitHub Flow</a></li>
<li><a rel=""nofollow"" href=""http://www.arthurtoday.com/2015/02/git-flow-vs-github-flow.html"">Git Flow 和 Github Flow 的不同</a></li>
<li><a rel=""nofollow"" href=""http://blog.krdai.info/post/17485259496/github-flow"">在 GitHub 當中使用的 work flow</a></li>
</ul>
<p>這裡我們使用 GitHub flow，它的核心精神是：</p>

<ul>
<li>所有在 master 分支上的程式都一定要是通過測試，可以部署的產品版本。</li>
<li>要開發功能、修復 Bug、做任何事情，都要從 master 開一條新的分支。</li>
<li>隨時 commit 和 push 你的程式碼到 GitHub 上，與大家討論。</li>
<li>功能完成時，使用 pull request 讓大家作 code review。</li>
<li>確認沒問題之後才可以 merge 回 master，並且部屬新版本到線上。 </li>
</ul>
<h3>建立一條分支</h3>

<ol>
<li>
<p>為了確保 master 這條主線上的程式碼都是穩定的，所以建議開發者依照不同的功能、建立不同的分支，這裡以 <code>test-github-flow</code> 為例，使用 <code>git branch</code> 新增分支、然後 <code>git checkout</code> 切換分支：</p>

<pre><code>bash</code><code>$ git branch test-github-flow
$ git checkout test-github-flow
</code></pre>
</li>
</ol>
<h3>加入 commits</h3>

<ol>
<li>
<p>在 <code>test.js</code> 裡加入一行錯誤的測試 <code>assert.equal(3, [1,2,3].indexOf(5))</code>：</p>

<pre><code>javascript</code><code>// test/test.js
// ...
assert.equal(3, [1,2,3].indexOf(5));
</code></pre>

<pre><code>bash</code><code>$ git add test/test.js
$ git commit -m ""add a error test case""
</code></pre>
</li>
</ol>
<h3>新增一個 Pull Request</h3>

<ol>
<li>
<p>Push 到 GitHub 的 test-github-flow 分支：</p>

<pre><code>bash</code><code>$ git push -u origin test-github-flow
</code></pre>
</li>
<li>
<p>打開 GitHub 之後，會出現 <code>test-github-flow</code> 分支的 push commits，點選旁邊的 <code>Compare &amp; pull request</code> 按鈕：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""13""></span></p>
</li>
<li>
<p>點選之後會進入 Open a pull request 的填寫頁面，選擇想要 merge 的分支、輸入描述之後，點選 <code>Create pull request</code> 按鈕：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""14""></span></p>
</li>
</ol>
<h3>檢視＆討論你的程式碼</h3>

<ol>
<li>
<p>新增一個 pull request 之後，其他人就會在 GitHub 上出現通知：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""15""></span></p>
</li>
<li>
<p>點進去之後可以看見相關的 commits 與留言，但是下面有一個紅紅大大的叉叉；因為每次 GitHub 只要有新的 push，就會觸發 CircleCI 的自動建置和測試，並且顯示結果在 GitHub 上：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""18""></span></p>
</li>
<li>
<p>點選叉叉，前往 CircleCI 查看錯誤原因：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""19""></span></p>
</li>
<li>
<p>就會發現剛剛 push 到 test-github-flow 的測試沒通過：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""12""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""11""></span></p>

<p>回到 GitHub，因為測試沒通過，所以審查者不能讓這筆 pull request 被 merge 回 master。</p>
</li>
<li>
<p>找到剛剛 commit 的那段程式碼，留言告知請開發者修正錯誤之後，再重新 commit push 上來：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""21""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""22""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxiZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""23""></span></p>
</li>
<li>
<p>修正 <code>test.js</code> 的測試腳本：</p>

<pre><code>javascript</code><code>// test/test.js
// ...
assert.equal(-1, [1,2,3].indexOf(5));
</code></pre>
</li>
<li>
<p>再次 commit &amp; push：</p>

<pre><code>bash</code><code>$ git add test/test.js
$ git commit -m ""fix error test case""
$ git push
</code></pre>
</li>
<li>
<p>回到 GitHub 的 pull request 頁面，可以看到最新一筆的 commit 成功通過 CircleCI 的測試了：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxi1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""26""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxi4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""24""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxi5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""25""></span></p>
</li>
</ol>
<h3>Merge＆部署</h3>

<ol>
<li>
<p>審查之後，確定沒有問題，就可以點選 <code>Merge pull request</code> 的按鈕，將 <code>test-github-flow</code> 的程式碼 merge 回主線 <code>master</code>：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxi9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""27""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxja"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""28""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjc"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""29""></span></p>
</li>
</ol>
<h2>Docker</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""docker""></span></p>

<blockquote>
  <p>安裝：</p>
  
  <ul>
<li>
<a rel=""nofollow"" href=""https://github.com/boot2docker/boot2docker"">boot2docker</a>: 1.5（Mac only）</li>
  <li>
<a rel=""nofollow"" href=""https://www.docker.com/"">docker</a>: 1.5</li>
  </ul>
</blockquote>

<p>什麼是 Docker？為什麼要用它？</p>

<p>因為 Docker 最近很火，所以網路上不缺關於介紹它的文章，原諒我這裡只稍微提一下：</p>

<p>以往開發人員面對開發環境不同的問題，常常出現「明明在我的電腦上可以跑」的囧境，所以為了解決這類問題，通常會使用虛擬機器（VM）搭配一些工具（<a rel=""nofollow"" href=""https://www.vagrantup.com/"">Vagrant</a>、<a rel=""nofollow"" href=""https://www.chef.io/"">Chef</a>）來協助統一開發人員、測試人員、上線產品的執行環境。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vm-vs-docker""></span></p>

<p>Docker 也是類似的解決方案，不同於 VM 的是，Docker 運行起來更輕巧、可攜度更高。配置好一份設定之後，就可以讓大家馬上進入開發狀況，減少不必要的環境問題，提升效率。</p>

<h3>在 Docker 執行 Node.js</h3>

<ol>
<li>
<p>在專案根目錄底下建立一個 <code>Dockerfile</code>：</p>

<pre><code>yaml</code><code># Dockerfile

# 從 [Docker Hub](https://hub.docker.com/) 安裝 Node.js image。
FROM node:0.10

# 設定 container 的預設目錄位置
WORKDIR /hello-ci-workflow

# 將專案根目錄的檔案加入至 container
# 安裝 npm package
ADD . /hello-ci-workflow
RUN npm install

# 開放 container 的 3000 port
EXPOSE 3000
CMD npm start
</code></pre>
</li>
<li>
<p>使用 <code>docker build</code> 建構您的 image：</p>

<pre><code>bash</code><code>$ docker build -t hello-ci-workflow .
</code></pre>

<blockquote>
  <p><code>-t hello-ci-workflow</code> 是 image 名稱。</p>
</blockquote>
</li>
<li>
<p>使用 <code>docker run</code> 執行您的 image：</p>

<pre><code>bash</code><code>$ docker run -p 3000:3000 -d hello-ci-workflow
</code></pre>

<blockquote>
  <p><code>-d</code> 在背景執行 node，可以使用 <code>docker logs</code> 看執行結果。</p>
</blockquote>
</li>
<li>
<p>打開瀏覽器 <code>http://localhost:3000</code> 看結果：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxhv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""01""></span></p>

<blockquote>
  <p>其實每一次都要 <code>build</code> 和 <code>run</code> 還蠻麻煩的，推薦可以試試 <a rel=""nofollow"" href=""https://github.com/docker/compose"">Docker Compose</a>，用起來有點像 <a rel=""nofollow"" href=""https://www.vagrantup.com/"">Vagrant</a>。</p>
</blockquote>
</li>
</ol>
<h3>在 CircleCI 測試 Docker</h3>

<ol>
<li>
<p>修改 <code>circle.yml</code>：</p>

<pre><code>yaml</code><code># circle.yml
machine:
  # 環境改成 docker
  services:
    - docker

dependencies:
  override:
    # 建構方式使用 docker build
    - docker build -t hello-ci-workflow .

test:
  override:
    - ./node_modules/.bin/mocha
    # 使用 curl 測試 docker 是否有順利執行 node
    - docker run -d -p 3000:3000 hello-ci-workflow; sleep 10
    - curl --retry 10 --retry-delay 5 -v http://localhost:3000
</code></pre>
</li>
<li>
<p>Push 更新到 GitHub：</p>

<pre><code>bash</code><code>$ git add Dockerfile circle.yml
$ git commit -m ""add Docker""
$ git push
</code></pre>
</li>
<li>
<p>查看 CircleCI 建構＆測試結果：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""30""></span></p>
</li>
</ol>
<h2>AWS Elastic Beanstalk</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjs"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""beanstalk""></span></p>

<blockquote>
  <p>帳號：<a rel=""nofollow"" href=""https://aws.amazon.com/"">Amazon Web Services</a><br>
  安裝：<a rel=""nofollow"" href=""http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3-getting-set-up.html#eb_cli3-install-with-pip"">AWS EB CLI</a>: 3.x</p>
</blockquote>

<p>最後要將程式上線啦！現在 PaaS 雲端平台的選擇非常多（<a rel=""nofollow"" href=""https://www.heroku.com/"">Heroku</a>、<a rel=""nofollow"" href=""https://cloud.google.com/appengine/"">Google App Engine</a>、<a rel=""nofollow"" href=""http://azure.microsoft.com/z"">Azure</a>、<a rel=""nofollow"" href=""https://www.openshift.com/"">OpenShift</a>、<a rel=""nofollow"" href=""https://www.linode.com/"">Linode</a>），這裡我選擇 Amazon 推出的 Elastic Beanstalk 當作範例，以下是它的特色：</p>

<ul>
<li>支援的開發環境多（Java、.NET、PHP、Node.js、Python、Ruby、GO），重點是有支援 Docker！</li>
<li>只需要上傳程式碼，Elastic Beanstalk 即可幫你完成從容量配置、負載均衡（load balancing）、自動擴展（auto scaling）到應用程式的運行狀況監控的部署。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVlxju"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""aws-eb""></span></p>

<ol>
<li>
<p>初始化 EB 環境：</p>

<pre><code>bash</code><code>$ eb init -p docker
</code></pre>

<blockquote>
  <p><code>-p</code> 可以指定 EB 的應用平台，例如 php 之類；這裡使用 docker。</p>
</blockquote>

<p>該命令將提示您配置各種設置。 按 Enter 鍵接受預設值。</p>

<blockquote>
  <p>如果你已經存有一組 AWS EB 權限的憑證，該命令會自動使用它。<br>
  否則，它會提示您輸入 <code>Access key ID</code> 和 <code>Secret access key</code>，必須前往 AWS IAM 建立一組。</p>
</blockquote>
</li>
<li>
<p>初始化成功之後，可以使用 <code>eb create</code> 快速建立各種不同的環境，例如：development, staging, production；這裡我們以 <code>env-development</code> 為例：</p>

<pre><code>bash</code><code>$ eb create env-development
</code></pre>

<p>等待 Elastic Beanstalk 完成環境的建立。 當它完成之後，您的應用已經備有負載均衡（load-balancing）與自動擴展（autoscaling）的功能了。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""31""></span></p>
</li>
<li>
<p>使用 <code>eb open</code> 前往目前版本的執行結果：</p>

<pre><code>bash</code><code>$ eb open env-development
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""32""></span></p>
</li>
</ol>
<h3>在本地端部署 AWS</h3>

<ol>
<li>
<p>稍微修改 <code>index.js</code>：</p>

<pre><code>javascript</code><code>// index.js
// ...
app.get('/', function (req, res) {
  res.send('Hello env-development!');
});
// ...
</code></pre>
</li>
<li>
<p>執行 <code>eb deploy</code> 部署新版本到 AWS Elastic Beanstalk：</p>

<pre><code>bash</code><code>$ eb deploy env-development
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""34""></span></p>
</li>
<li>
<p>部署完成之後，執行 <code>eb open</code> 打開網頁：</p>

<pre><code>bash</code><code>$ eb open env-development
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""33""></span></p>

<p><code>env-development</code> 上的應用程式更新完成。</p>
</li>
</ol>
<h3>在 CircleCI 部署 AWS</h3>

<ol>
<li>
<p><code>git checkout</code> 將分支切換回主線 master：</p>

<pre><code>bash</code><code>$ git checkout master
</code></pre>
</li>
<li>
<p><code>eb create</code> 新增一組新的環境，作為產品上線用，命名為 <code>env-production</code>：</p>

<pre><code>bash</code><code>$ eb create env-production
</code></pre>

<pre><code>bash</code><code>$ eb open env-production
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjK"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""35""></span></p>
</li>
</ol>
<p>這樣就成功啟動第二組機器了，目前我們有 <code>env-development</code> 和 <code>env-production</code> 兩組環境。</p>

<h3>前往 <a rel=""nofollow"" href=""https://console.aws.amazon.com/iam/home"">AWS IAM</a> 新增一組帳號給 CircleCI 使用：</h3>

<ol>
<li>
<code>Dashboard</code> &gt; <code>Users</code>
</li>
<li><code>Create New Users</code></li>
<li>Enter User Names: <strong>CircleCI</strong> &gt; <code>Create</code>
</li>
<li><code>Download Credentials</code></li>
<li>
<code>Dashboard</code> &gt; <code>Users</code> &gt; <code>CircleCI</code>
</li>
<li><code>Attach Pollcy</code></li>
<li>
<code>AWSElasticBeanstalkFullAccess</code> &gt; <code>Attach Pollcy</code>
</li>
</ol>
<p>前往 CircleCI，設定您的 AWS 權限：</p>

<ol>
<li><code>Project Settings</code></li>
<li>
<code>Permissions</code> &gt; <code>AWS Permissions</code>
</li>
<li>打開剛才下載的 <code>credentials.csv</code>，輸入 <code>Access Key ID</code> &amp; <code>Secret Access Key</code>
</li>
<li><code>Save AWS keys</code></li>
</ol>
<p>然后</p>

<ol>
<li>
<p>在 <code>.elasticbeanstalk</code> 目錄底下，建立 <code>config.global.yml</code>：</p>

<pre><code>yaml</code><code># .elasticbeanstalk/config.global.yml
global:
  application_name: hello-ci-workflow
  default_region: us-west-2 # EB 所在的 region，預設是 us-west-2
</code></pre>
</li>
<li>
<p>修改 <code>circle.yml</code>：</p>

<pre><code>yaml</code><code># circle.yml
machine:
  # 安裝 eb 需要 python
  python:
    version: 2.7
  services:
    - docker

dependencies:
  pre:
    # 安裝 eb
    - sudo pip install awsebcli
  override:
    - docker build -t hello-ci-workflow .

test:
  override:
    - npm test
    - docker run -d -p 3000:3000 hello-ci-workflow; sleep 10
    - curl --retry 10 --retry-delay 5 -v http://localhost:3000

# 新增一筆部署腳本
deployment:
  production:
    branch: master
    commands:
      - eb deploy env-production
</code></pre>

<p>這樣就能在 GitHub 的 master 支線有更新時，觸發 CircleCI 的自動建置、測試、然後部署。</p>
</li>
<li>
<p>接下來馬上來試試看流程，修改 <code>index.js</code>：</p>

<pre><code>javascript</code><code>// index.js
// ...
app.get('/', function (req, res) {
  res.send('Hello env-production!');
});
// ...
</code></pre>
</li>
<li>
<p>Commit &amp; Push：</p>

<pre><code>bash</code><code>$ git add .
$ git cimmit ""test deploy production""
$ git push
</code></pre>
</li>
<li>
<p>前往 CircleCI 看結果：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""36""></span></p>
</li>
<li>
<p>部署成功，<code>eb open</code> 打開瀏覽器來看看結果：</p>

<pre><code>bash</code><code>$ eb open env-production
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""37""></span></p>
</li>
</ol>
<h2>Slack</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""slack""></span></p>

<blockquote>
  <p>帳號：<a rel=""nofollow"" href=""https://slack.com/"">Slack</a></p>
</blockquote>

<p>到這邊其實已經差不多結束了，最後來講講 Slack 吧。</p>

<p>Slack 是一款給團隊使用的即時溝通工具，類似的產品還有 <a rel=""nofollow"" href=""https://gitter.im/"">Gitter</a> 與 <a rel=""nofollow"" href=""https://www.hipchat.com/"">HipChat</a>。</p>

<p>至於跟 Skype、Lync 這些軟體有什麼不一樣的地方呢？</p>

<p>它們整合了許多開發工具（GitHub、CircleCI）的服務，例如 GitHub 有新的 push、pull request、issue；CircleCI 的單元測試沒有通過之類的通知，會即時出現在你的團隊的 Slack 上面，既然我們已經將大部分的工作自動化，勢必需要讓相關人員知道這些工具發生了哪些事情，所以使用 Slack 是必要的。</p>

<ol>
<li>登入 Slack 頁面</li>
<li>點選 <code>Configure Integrations</code> &gt; <code>CircleCI</code>
</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVlxjR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""38""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""39""></span></p>

<ol>
<li>選擇要接收 CircleCI 通知的 channel </li>
<li>點選 <code>Add CircleCI Integration</code> 按鈕</li>
<li>
<p>複製畫面上的 <code>webhook URL</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""40""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxjZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""44""></span></p>
</li>
<li><p>返回 CircleCI</p></li>
<li>點選 <code>Project settings</code> &gt; <code>Chat Notifications</code>
</li>
<li>
<p>貼上將複製的 <code>Webhook URL</code> &gt; <code>Save</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxj0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""41""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxj1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""42""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxj3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""43""></span></p>
</li>
<li>
<p>類似的步驟，將 GitHub 的通知加入 Slack：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxj4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""45""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxj9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""46""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxka"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""47""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxkb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""48""></span></p>
</li>
<li>
<p>測試 Slack 通知，是否能夠順利運作，新增一條 <code>test-slack</code> 分支：</p>

<pre><code>bash</code><code>$ git branch test-slack
$ git checkout test-slack
</code></pre>
</li>
<li>
<p>修改 <code>index.js</code>：</p>

<pre><code>javascript</code><code>// index.js
// ...
app.get('/', function (req, res) {
  res.send('Hello Slack!');
});
// ...
</code></pre>
</li>
<li>
<p>Commit &amp; Push：</p>

<pre><code>bash</code><code>$ git add index.js
$ git commit -m ""index.js: update to test slack""
$ git push -u origin test-slack
</code></pre>
</li>
<li><p>CircleCI 通過測試，開啟一個 Pull Request</p></li>
<li>將 <code>test-slack</code> merge 回 <code>master</code>，觸發 CircleCI 自動部署</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVlxkf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""50""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxkh"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""51""></span></p>

<p>That’s it! On your next build, you’ll start seeing CircleCI build notifications in your Slack chatroom.</p>

<p>結束！可以看見 Slack channel 會顯示每一個步驟的通知過程：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlxki"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""49""></span></p>

<p><code>eb open</code> 打開瀏覽器查看結果，成功自動部署新版本：</p>

<pre><code>bash</code><code>$ eb open env-production
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlxkj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""52""></span></p>

<h2>結語</h2>

<blockquote>
  <p>「書山有路勤為徑，學海無涯苦作舟。」——韓愈</p>
</blockquote>

<p>DevOps 的開發流程與工具每天都在不斷推陳出新，請站在巨人的肩膀上、保持一顆「活到老、學到老」的心。</p>

<p>我將這個範例的程式碼放在 <a rel=""nofollow"" href=""https://github.com/amowu/hello-ci-workflow"">GitHub</a> 上，有興趣的人可以參考看看。</p>

<p>文章若有需要改進的地方，還請不吝指教，感激不盡。</p>

<h2>參考</h2>

<ul>
<li>
<a rel=""nofollow"" href=""https://en.wikipedia.org/wiki/DevOps"">DevOps - Wikipedia</a> [<a rel=""nofollow"" href=""https://zh.wikipedia.org/zh/DevOps"">中文</a>]</li>
<li>
<a rel=""nofollow"" href=""https://en.wikipedia.org/wiki/Continuous_integration"">Continuous integration（持續整合）- Wikipedia</a> [<a rel=""nofollow"" href=""https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88"">中文</a>]</li>
<li><a rel=""nofollow"" href=""https://en.wikipedia.org/wiki/Continuous_delivery"">Continuous delivery（持續交付）- Wikipedia</a></li>
<li><a rel=""nofollow"" href=""http://blog.eavatar.com/post/2013/10/continuous-integration-deployment-delivery/"">山姆鍋對持續整合、持續部署、持續交付的定義</a></li>
<li><a rel=""nofollow"" href=""http://rettamkrad.blogspot.tw/2014/11/integrate-circleci-with-github.html"">Integrate CircleCI with GitHub</a></li>
<li><a rel=""nofollow"" href=""https://guides.github.com/introduction/flow/"">Understanding the GitHub Flow · GitHub Guides</a></li>
<li><a rel=""nofollow"" href=""https://docs.docker.com/examples/nodejs_web_app"">Dockerizing a Node.js Web App</a></li>
<li><a rel=""nofollow"" href=""https://circleci.com/integrations/docker"">Integration with Docker Containers - CircleCI</a></li>
<li><a rel=""nofollow"" href=""https://circleci.com/docs/docker"">Continuous Integration and Delivery with Docker</a></li>
<li><a rel=""nofollow"" href=""http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3-getting-started.html"">Getting Started with EB CLI 3.x</a></li>
<li><a rel=""nofollow"" href=""http://blog.circleci.com/slack-integration/"">Slack Integration | The Circle Blog</a></li>
<li>
<a rel=""nofollow"" href=""https://realpython.com/blog/python/docker-in-action-fitter-happier-more-productive/"">Docker in Action - Fitter, Happier, More Productive</a> [<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000002598713"">中文</a>]</li>
<li><a rel=""nofollow"" href=""http://qiita.com/sawanoboly/items/28e98827bc044abdc32f"">CircleCIからAWS Elastic Beanstalkにpush</a></li>
<li><a rel=""nofollow"" href=""http://waytothepiratecove.blogspot.tw/2015/03/delivery-pipeline-and-zero-downtime.html"">Delivery pipeline and zero downtime release</a></li>
<li><a rel=""nofollow"" href=""http://sauceio.com/index.php/2014/12/ci-cd-with-docker-beanstalk-circleci-slack-gantree/"">Re-Blog: CI &amp; CD With Docker, Beanstalk, CircleCI, Slack, &amp; Gantree</a></li>
<li><a rel=""nofollow"" href=""http://mherman.org/blog/2015/03/06/node-with-docker-continuous-integration-and-delivery"">Node With Docker - Continuous Integration and Delivery</a></li>
<li><a rel=""nofollow"" href=""http://www.infoq.com/cn/articles/docker-integrated-test-and-deployment"">深入浅出Docker（四）：Docker的集成测试部署之道</a></li>
</ul>

                ", DevOps：持續整合 &amp; 持續交付（Docker、CircleCI、AWS）,1531978069,274,1,457,1,1,https://segmentfault.com/a/1190000002710669
279,1,0,7,"
                    
<blockquote>
  <p>转自：<a rel=""nofollow"" href=""http://zhuanlan.zhihu.com/FrontendMagazine/20002850"">前端外刊评论</a><br>
  非常感谢，翻译的很好，受益很多，转到此处让前端小伙伴们也惊呆下........</p>
</blockquote>

<p>上次我写<a rel=""nofollow"" href=""http://rmurphey.com/blog/2012/04/12/a-baseline-for-front-end-developers/"">《前端工程师必知必会》</a>已经是三年前了，那是我写过最火的文章了。三年了，我仍然会在<code>Twitter</code>上收到关于这篇文章的消息。</p>

<p>从<code>2012</code>年到现在，一篇文章都没发过让我觉得有点羞羞哒。三年是一段很长的时间，很多东西都发生了改变。<code>2012</code>年，我鼓励同学们去学习浏览器开发者工具和模块化；虽然有很多同学会觉得CSS预编译和客户端模板引擎并不靠谱，但我仍然想要说一说它们；还有<code>JSHint</code>，虽然有#<code>getoffmylawn</code>（滚出我的地盘）的警告，但依然无法阻止<code>JSHint</code>成为一个受欢迎的理念（准确的说，<code>JSLint</code>真的（只是）存在过）。</p>

<p>已经是<code>2015</code>年了，我想写一篇新的，但是当我坐下来开始动笔的时候，想到了两个事情。一，这些东西被称作“必知必会”可能有人会觉得不太公平——如果你已经觉得<a rel=""nofollow"" href=""http://rmurphey.com/blog/2012/04/12/a-baseline-for-front-end-developers/"">2012年的那篇文章</a>如此，那本文也是一样的了。也许有同学会说，我们应该把 “足够应付业务需求的技能” 作为 “前端必须掌握的知识”，但考虑到前端行业里也有各种各样的工作可供选择，这么做也只能得到一个并不适合所有人的 “前端基础知识”。对于我来说，我需要的不是工作，我想要的是被邀请去做一份牛逼的工作。我想要的不只是去干活而已，而是想和一群牛逼的人一起做牛逼的事。我不想仅仅满足于用已有的知识来完成现在的工作，而是希望掌握更多的知识来解决未来将会面对的问题。</p>

<p>第二，我现在已经完全把<code>Javascript</code>作为我的核心了：<code>CSS</code>知识只有在必须关注性能问题时才会用到，其他场景已经用的越来越少。我知道有很多牛逼的前端同学并不是这样的，但我也意识到，关注<code>JS</code>的同学和关注<code>CSS</code>的同学之间的距离也越来越远。这可能需要在另起一篇文章来讨论，不过我想说的是，这篇文章中不会有介绍<code>CSS</code>技能标准的内容，因为我还远远没有达到能那么做的水平。</p>

<p>总之，就算这个技能列表并不适合你的前端工作，没关系，不要有压力，地球也不会爆炸。</p>

<h2>Javascript</h2>

<p>回想<code>2009</code>年，那时候当你知道 <code>HTML5</code> 在<code>2014</code>年才能用的时候，你是不是觉得这辈子基本上都用不到它了？如果是，那么你需要准备好接受进展缓慢但是已经趋于稳定的ES6了，它也是下一代的<code>Javascript</code>（现在叫 <code>ES2015</code> 了，嗯，这名字至少表示今年就能用了）。就我而言，<code>ES6</code>，额，<code>ES2015</code> 无疑是我个人现在最关注的 <code>Javascript</code> 内容。在 <code>ES6</code> 中将会出现一些比较大的变化：类，真正的私有，经过改进更易用的函数和参数设定，可导入的模块，等等等等。那些掌握和理解新的语法的同学以后将会在 <code>JS</code> 社区牛逼闪闪。相关阅读：</p>

<ul>
<li>
<a rel=""nofollow"" href=""https://leanpub.com/understandinges6/read/"">Understanding ES6</a>，Nicholas Zakas 正在写的书。</li>
<li>BabelJS，一个可以把你写的 ES6 的代码编译成 ES5 并在现代浏览器中运行的工具。他们也有一个不错的介绍 <a rel=""nofollow"" href=""http://babeljs.io/docs/learn-es6/"">ES6</a> 的文档。</li>
<li>
<a rel=""nofollow"" href=""http://es6rocks.com/"">ES6 Rocks</a>，里面有大量的文章探索 ES6 的特性，语义和缺陷。</li>
</ul>
<p>你也许会问：那我需要成为一个 <code>ES6</code> 专家么？也许现在不需要，但至少你得和你的同事懂的一样多吧？或者比他们稍微多一点？当然，如果能在你的下一个新项目中作为一个娱乐性的技术尝试也是不错的，做好准备肯定没错的，因为我们永远不知道下一刻会发生什么。</p>

<p>先不说新的语言特性，使用回调和 <code>promises</code> 管理异步 <code>Javascript</code> 至少得背的滚瓜烂熟吧。浏览器端应用加载，以及应用间通信策略得形成一套自己的观点吧。而且你应该知道哪种框架最适合你，而不是现在还把时间花在理解各种框架的实现原理和该选择哪种框架上。</p>

<h2>模块化和构建工具</h2>

<p>毫无疑问，模块化是构建 <code>Web</code> 客户端应用的基石。回到<code>2012</code>年，关于使用哪种模块化（<a rel=""nofollow"" href=""https://github.com/amdjs/amdjs-api/blob/master/AMD.md"">AMD</a>/<a rel=""nofollow"" href=""http://webpack.github.io/docs/commonjs.html"">CommonJS</a>）方案构建浏览器端应用还存在很多争论。而最近慢慢火起来的 <a rel=""nofollow"" href=""https://github.com/umdjs/umd"">UMD</a> 则在保证代码可复用的前提下尝试避免这样的问题。 其实也没什么好争得，毕竟这俩玩意儿之间也就差几个字符吧？</p>

<p>我觉得类似这样的争论其实并不都需要有一个答案，这也是我觉得从2012年到现在我们发生的最大的转变，当然，也许只是我自己这么认为。因为我觉得与其说“我再也不用 AMD 了”之类的话，倒不如多去讨论 “在开发和打包过程中使用 CommonJS 和 npm 遇到的各种难题” 来的更有价值。</p>

<p>虽然很感激 <a rel=""nofollow"" href=""http://requirejs.org/"">RequireJS</a> 曾经对模块化做出的贡献，不过现在我开始有点迷恋 <code>webpack</code> 了。 <a rel=""nofollow"" href=""http://webpack.github.io/"">webpack</a> 的构建配置比 <code>RequireJS</code> 更加易于理解，也更具访问性。通过它的热插拔特性和内置的本地静态服务器可以让发布更加便捷。它并不强制要求使用 <code>AMD</code> 或者 <code>CommonJS</code> – 两个它都支持。它还实现了一大堆加载器，用来完成常见的繁琐工作。 <a rel=""nofollow"" href=""http://browserify.org/"">Browserify</a> 也值得去了解一下，不过我个人认为它比 <code>Webpack</code> 落后很多。一些靠谱的朋友告诉我说 <a rel=""nofollow"" href=""https://github.com/systemjs/systemjs"">systemjs</a> 也是这个领域的竞争者，不过我还没有用过，而且它的文档烂的我连看都不想看。不过我觉得它的好基友 <a rel=""nofollow"" href=""http://jspm.io/"">jspm</a> (包管理器)比较有趣，jspm 可以让你从各种包管理服务器加载你需要的各种组件，(组件必须是符合 <code>ES6</code>, <code>AMD</code>, <code>CommonJS</code> <code>and</code> <code>globals</code> 规范的)，包括 npm, <code>github</code> 等，但是我对于这两个玩意的合体还是有点不太理解。啊，还有，虽然我说了这么多关于模块化之外的内容，但我从来没想过放弃 <code>AMD</code>，我们边走边看吧。</p>

<p>我觉得如果要停止对模块化和构建工具的争论，形成统一的模块化系统，并且在这个系统里面，任何项目的代码都可以共享，而且还不需要 <code>UMD</code> 这样额外的补丁工具，我们还有很长的路要走。理想状况下，<a rel=""nofollow"" href=""http://www.2ality.com/2014/09/es6-modules-final.html"">ES6 modules</a> 的到来会解决这些问题，不过在这一天到来之前，类似 <code>UMD</code> 之类的转换器会填补这些空缺，不过貌似这样做我们又把事情变得复杂了，好像我们也总喜欢把事情弄得复杂。</p>

<p>与此同时，前端开发人员也需要对构建工具，各种模块化系统有自己的见解和知识储备。不管是好是坏，根据 <code>Javascript</code> 现在的进度，你的模块化策略会对你的项目有比较大的影响。</p>

<h2>测试</h2>

<p>客户端的代码测试变得越来越普遍，最近也诞生了一些新的测试框架： <a rel=""nofollow"" href=""http://karma-runner.github.io/0.12/index.html"">Karma</a>，<a rel=""nofollow"" href=""https://theintern.github.io/"">Intern</a> 。我发现基于 <code>promise</code> 的 <code>Intern</code> 的异步测试方法相当优雅。不过可能是因为习惯，我大多数情况下还是用 <code>Mocha</code> 写测试用例。</p>

<p>测试的主要障碍其实是前端开发者的代码编写方式。我在<code>2012</code>年发表过一个关于<a rel=""nofollow"" href=""https://www.youtube.com/watch?v=OzjogCFO4Zo"">《编写可测试的Javascript》</a>下载地址的演讲，紧接着几个月后又发表了一篇<a rel=""nofollow"" href=""http://alistapart.com/article/writing-testable-javascript"">相关的文章</a>。</p>

<p>测试的第二大障碍是工具。<code>Webdriver</code> 是一个艰难而巨大的工作。目前在各个浏览器端做持续集成的 <code>UI</code> 自动化测试基本上是不可能的，更不用说移动端了。我们仍然停留在局限于某一小部分浏览器和设备上做轻量级的自动化功能测试，尽我们所能去研究怎样快速，低成本的进行这种测试的阶段。</p>

<p>如果你对如何改进代码的可测试性感兴趣的话，那么唯一一本最值得看的书是 <a rel=""nofollow"" href=""http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052"">Working Effectively with Legacy Code</a> （<a rel=""nofollow"" href=""http://www.ituring.com.cn/book/536"">中译版：《修改代码的艺术》</a>。作者 Michael Feathers 定义了“遗留代码”的概念：任何未经测试的代码都是遗留代码。在测试领域，最基本的要素就是上面这句话，尽管你可能不这么认为。</p>

<h2>流程自动化</h2>

<p>你首先会想到 <a rel=""nofollow"" href=""http://gruntjs.com/"">Grunt</a>，这也是理所当然的。而 <a rel=""nofollow"" href=""http://gulpjs.com/"">Gulp</a> 和 <a rel=""nofollow"" href=""http://broccolijs.com/"">Broccoli</a> 的自动化构建方式也别具匠心。我没用过<code>Broccoli</code>，只玩过<code>Gulp</code>，我也开始意识到<code>Grunt</code>对于依赖其他服务的复杂任务的自动化工作存在局限性，尤其是当这种任务每天需要运行上千次的时候。</p>

<p><a rel=""nofollow"" href=""http://yeoman.io/"">Yeoman</a>是在我写完<code>2012</code>年的那篇文章仅仅<code>45</code>天之后发布的，我承认当时我并没有及时去尝试一下。不过最近我开始启动一些新项目，这些新项目有两个特点<br><code>a)</code> 这些项目都是从零开始<br><code>b)</code> 尝试用一些不同的技术方案，试图通过这种方式找到 <code>Bazaarvoice</code>（提供第三方点评服务）上第三方 <code>JS</code> 应用的规范化的开发方式。<br><code>Yeoman</code> 在这两方面做的都很好。一个简单的 <code>yo react-webpack</code> 命令就可以为你初始化好你的项目，然后各种你想要的玩具也都应有尽有：生成测试用例，本地静态服务器，<code>hello world</code> 入门程序，等等等等。如果 <code>React</code> 和 <code>webpack</code> 不是你想要的，也许你会在 <code>Yeoman</code> 的 <code>generators</code>（项目生成器）里面找到一个你想要的，当然，自己自定义一个这样的构建包也是比较容易的。</p>

<p>鉴于 <code>Yeoman</code> 只是一个在项目开始时才会用到的构建工具，并且鉴于我们并不是总是做新项目，所以大多情况下了解一下就够了。除非，你也想去规范整个项目开发过程，那么它可能会更有价值一点。</p>

<p><code>Broccoli</code> 已经得到了 <code>ember-cli</code> 的采纳，我觉得他们的配对可能会有一个新名字，这样在未来才比较方便和 <code>Grunt /Yeoman</code> 对抗。而 <code>Grunt</code> 和 <code>Yeoman</code> 的开发进度也放缓了，所以未来会发生什么，我们还是静观其变吧。</p>

<h2>代码质量</h2>

<p>如果你像我一样，一看见违反代码规范的代码时就开始抓狂，那么 <a rel=""nofollow"" href=""http://jscs.info/"">JSCS</a> 和<br><a rel=""nofollow"" href=""http://eslint.org/"">ESLint</a> 就是老天赐给你的礼物，而2012压根就没这些玩意。他们都提供了自定义代码规范的方式，并且可以在代码提交前对你的代码做自动化校验。这让我想起了…</p>

<h2>Git</h2>

<p>从2012年到现在，<code>github</code> 的使用流程并没有发生很大的变化，比如在 <code>pull request</code> 页面连个分支名都没有（只是恶搞一下）。</p>

<p>你应该非常清楚和流畅地使用功能分支（<code>feature branches</code>）, 使用 <code>rebase</code> 合并别人的代码干活，使用交互式 <code>rebase</code> 命令和 <code>squash</code> 合并提交记录，或者尽可能细颗粒度的划分项目内容，避免引起代码冲突。另一个可用的 Git 工具是钩子，具体而言，就是你可以在 push 前，<code>commit</code> 前，执行你的各种测试用例，检查代码质量。你可以自己写钩子，也可以使用 <code>ghooks</code> ，由于 <a rel=""nofollow"" href=""https://www.npmjs.com/package/ghooks"">ghooks</a> 使钩子工作变得非常简单，所以你简直没有理由不用它。</p>

<h2>客户端模板</h2>

<p>这可能是我在<code>2012</code>年的那篇文章中写的最烂的内容了，某种意义上的“烂”。客户端模板还是很有价值的，而且它已经被内置到 <code>ES2015</code> 里面了，这不仅仅只是一件好事而已。这些年也有一些惨重的教训，不少团队把所有的渲染工作全部丢到浏览器端去做，结果产生了严重的性能问题，所以 “在浏览器端渲染生成所有 <code>HTML</code>” 的做法理所当然的被摒弃了。 而更为聪明的做法则是，把 <code>HTML</code> 生成放在服务器端，或者通过预编译的方式，先将模板做为静态资源储存起来，在需要时快速的编译成 <code>HTML</code>，需要更新时也可以直接在客户端更新模板。</p>

<p>这里会有一些新的展望，不仅是对我自己，也是对所有人，当你在考虑性能问题时，也许没必要把自己完全限定在浏览器范围内。所以，这又让我想起了……</p>

<h2>Node</h2>

<p>听说你懂 <code>Javascript</code>，那么我觉得你也应该懂 <code>Node</code>，至少在遇到 <code>Node</code> 问题是能帮得上忙的，如果连忙都帮不上，那也至少深入研究一下吧：<code>Node</code> 的文件系统，流，服务器，完全不同于前端的一些开发模式等等。对后端敬而远之只会限制我们前端的发展潜力。</p>

<p>即使你的真实生产环境中后端不用 <code>Node</code>，当你的工作被后端限制或阻碍的时候，<code>Node</code> 也是一个非常有用的工具。最起码，你也应该熟悉怎么去初始化一个 <code>Node</code> 项目，怎么用 <code>Express</code> 搭建服务器设置路由，怎么使用请求模块代理请求。</p>

<h2>最后</h2>

<p>感谢 <code>Paul</code>, <code>Alex</code>, <code>Adam</code>, <code>Ralph</code> 对本文的 <code>Review</code>，感谢他们毫不吝啬的指出我的不足之处，并给我提了很好的意见。</p>

<p>就这样，祝你好运。也许，三年之后我们会再见。</p>

<p>原文链接: <a rel=""nofollow"" href=""http://rmurphey.com/blog/2015/03/23/a-baseline-for-front-end-developers-2015/"">A Baseline for Front-End ‘JS’ Developers: 2015</a></p>

                ", [ 学习路线 ] 2015 前端(JS)工程师必知必会 (2),1531978071,523,1,369,1,1,https://segmentfault.com/a/1190000002678515
280,1,0,7,"
                    
<p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p>

<p>GitHub 地址:<a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md"">https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md</a><br><strong>若有任何疑问可通过微博<a rel=""nofollow"" href=""http://weibo.com/jinfali"">@李锦发</a>联系我</strong></p>

<table>
<thead><tr>
<th>项目名称</th>
  <th>项目信息</th>
</tr></thead>
<tbody>
<tr>
<td>1. <a rel=""nofollow"" href=""https://github.com/AFNetworking/AFNetworking"">AFNetworking</a>
</td>
  <td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td>
</tr>
<tr>
<td>2. <a rel=""nofollow"" href=""https://github.com/BradLarson/GPUImage"">GPUImage</a>
</td>
  <td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a rel=""nofollow"" href=""http://stackoverflow.com/users/19679/brad-larson"">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td>
</tr>
<tr>
<td>3. <a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a>
</td>
  <td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td>
</tr>
<tr>
<td>4. <a rel=""nofollow"" href=""https://github.com/RestKit/RestKit"">RestKit</a>
</td>
  <td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td>
</tr>
<tr>
<td>5. <a rel=""nofollow"" href=""https://github.com/ReactiveCocoa/ReactiveCocoa"">ReactiveCocoa</a>
</td>
  <td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 ""An open source project that exemplifies this brave new era for Objective-C"", 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a rel=""nofollow"" href=""http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction"">文章</a>
</td>
</tr>
<tr>
<td>6. <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20"">three20</a>
</td>
  <td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269"">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>, 算是 three20 的一个替代品</td>
</tr>
<tr>
<td>7. <a rel=""nofollow"" href=""https://github.com/jdg/MBProgressHUD"">MBProgressHUD</a>
</td>
  <td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td>
</tr>
<tr>
<td>8. <a rel=""nofollow"" href=""https://github.com/magicalpanda/MagicalRecord"">MagicalRecord</a>
</td>
  <td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td>
</tr>
<tr>
<td>9. <a rel=""nofollow"" href=""https://github.com/ccgus/fmdb"">FMDB</a>
</td>
  <td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td>
</tr>
<tr>
<td>10. <a rel=""nofollow"" href=""https://github.com/Mantle/Mantle"">Mantle</a>
</td>
  <td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td>
</tr>
<tr>
<td>11. <a rel=""nofollow"" href=""https://github.com/Grouper/FlatUIKit"">FlatUIKit</a>
</td>
  <td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td>
</tr>
<tr>
<td>12. <a rel=""nofollow"" href=""https://github.com/pokeb/asi-http-request"">ASIHTTPRequest</a>
</td>
  <td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td>
</tr>
<tr>
<td>13. <a rel=""nofollow"" href=""https://github.com/path/FastImageCache"">FastImageCache</a>
</td>
  <td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td>
</tr>
<tr>
<td>14. <a rel=""nofollow"" href=""https://github.com/Masonry/Masonry"">Masonry</a>
</td>
  <td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td>
</tr>
<tr>
<td>15. <a rel=""nofollow"" href=""https://github.com/facebook/Shimmer"">Shimmer</a>
</td>
  <td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td>
</tr>
<tr>
<td>16. <a rel=""nofollow"" href=""https://github.com/TransitApp/SVProgressHUD"">SVProgressHUD</a>
</td>
  <td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td>
</tr>
<tr>
<td>17. <a rel=""nofollow"" href=""https://github.com/jigish/slate"">Slate</a>
</td>
  <td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td>
</tr>
<tr>
<td>18. <a rel=""nofollow"" href=""https://github.com/johnezang/JSONKit"">JSONKit</a>
</td>
  <td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td>
</tr>
<tr>
<td>19. <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>
</td>
  <td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td>
</tr>
<tr>
<td>20. <a rel=""nofollow"" href=""https://github.com/CocoaLumberjack/CocoaLumberjack"">CocoaLumberjack</a>
</td>
  <td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td>
</tr>
<tr>
<td>21. <a rel=""nofollow"" href=""https://github.com/facebook/facebook-ios-sdk"">Facebook SDK for iOS</a>
</td>
  <td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td>
</tr>
<tr>
<td>22. <a rel=""nofollow"" href=""https://github.com/facebook/AsyncDisplayKit"">AsyncDisplayKit</a>
</td>
  <td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td>
</tr>
<tr>
<td>23. <a rel=""nofollow"" href=""https://github.com/supermarin/Alcatraz"">Alcatraz</a>
</td>
  <td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td>
</tr>
<tr>
<td>24. <a rel=""nofollow"" href=""https://github.com/Inferis/ViewDeck"">ViewDeck</a>
</td>
  <td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td>
</tr>
<tr>
<td>25. <a rel=""nofollow"" href=""https://github.com/jessesquires/JSQMessagesViewController"">JSQMessagesViewController</a>
</td>
  <td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td>
</tr>
<tr>
<td>26. <a rel=""nofollow"" href=""https://github.com/Flipboard/FLEX"">FLEX</a>
</td>
  <td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td>
</tr>
<tr>
<td>27. <a rel=""nofollow"" href=""https://github.com/facebook/xctool"">Xctool</a>
</td>
  <td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a rel=""nofollow"" href=""https://travis-ci.org"">Travis CI</a>, <a rel=""nofollow"" href=""http://oclint.org"">OCLint</a> 等测试工具</td>
</tr>
<tr>
<td>28. <a rel=""nofollow"" href=""https://github.com/OpenEmu/OpenEmu"">OpenEmu</a>
</td>
  <td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td>
</tr>
<tr>
<td>29. <a rel=""nofollow"" href=""https://github.com/nicklockwood/iCarousel"">iCarousel</a>
</td>
  <td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td>
</tr>
<tr>
<td>30. <a rel=""nofollow"" href=""https://github.com/romaonthego/RESideMenu"">RESideMenu</a>
</td>
  <td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td>
</tr>
<tr>
<td>321 <a rel=""nofollow"" href=""https://github.com/kevinzhow/PNChart"">PNChart</a>
</td>
  <td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td>
</tr>
<tr>
<td>31.2<a rel=""nofollow"" href=""https://github.com/square/PonyDebugger"">PonyDebugger</a>
</td>
  <td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td>
</tr>
<tr>
<td>33. <a rel=""nofollow"" href=""https://github.com/jverdi/JVFloatLabeledTextField"">JVFloatLabeledTextField</a>
</td>
  <td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td>
</tr>
<tr>
<td>34. <a rel=""nofollow"" href=""https://github.com/CEWendel/SWTableViewCell"">SWTableViewCell</a>
</td>
  <td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td>
</tr>
<tr>
<td>35. <a rel=""nofollow"" href=""https://github.com/levey/AwesomeMenu"">AwesomeMenu</a>
</td>
  <td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td>
</tr>
<tr>
<td>36. <a rel=""nofollow"" href=""https://github.com/tonymillion/Reachability"">Reachability</a>
</td>
  <td>Reachablity 是用于检测 iOS 设备网络环境的库</td>
</tr>
<tr>
<td>37. <a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter-Xcode</a>
</td>
  <td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td>
</tr>
<tr>
<td>38. <a rel=""nofollow"" href=""https://github.com/google/physical-web"">The Physical Web</a>
</td>
  <td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td>
</tr>
<tr>
<td>39. <a rel=""nofollow"" href=""https://github.com/samuelclay/NewsBlur"">NewsBlur</a>
</td>
  <td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td>
</tr>
<tr>
<td>40. <a rel=""nofollow"" href=""https://github.com/cocos2d/cocos2d-spritebuilder"">Cocos2D-SpriteBuilder</a>
</td>
  <td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td>
</tr>
<tr>
<td>41. <a rel=""nofollow"" href=""https://github.com/TTTAttributedLabel/TTTAttributedLabel"">TTTAttributedLabel</a>
</td>
  <td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td>
</tr>
<tr>
<td>42. <a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaAsyncSocket"">CocoaAsyncSocket</a>
</td>
  <td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td>
</tr>
<tr>
<td>43. <a rel=""nofollow"" href=""https://github.com/devinross/tapkulibrary"">TapkuLibrary</a>
</td>
  <td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td>
</tr>
<tr>
<td>44. <a rel=""nofollow"" href=""https://github.com/CanvasPod/Canvas"">Canvas</a>
</td>
  <td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td>
</tr>
<tr>
<td>45. <a rel=""nofollow"" href=""https://github.com/square/SocketRocket"">SocketRocket</a>
</td>
  <td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td>
</tr>
<tr>
<td>46. <a rel=""nofollow"" href=""https://github.com/ECSlidingViewController/ECSlidingViewController"">ECSlidingViewController</a>
</td>
  <td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td>
</tr>
<tr>
<td>47. <a rel=""nofollow"" href=""https://github.com/stig/json-framework"">Json Framework</a>
</td>
  <td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td>
</tr>
<tr>
<td>48. <a rel=""nofollow"" href=""https://github.com/facebook/Tweaks"">Tweaks</a>
</td>
  <td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td>
</tr>
<tr>
<td>49. <a rel=""nofollow"" href=""https://github.com/realm/realm-cocoa"">realm-cocoa</a>
</td>
  <td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td>
</tr>
<tr>
<td>50. <a rel=""nofollow"" href=""https://github.com/zwaldowski/BlocksKit"">BlocksKit</a>
</td>
  <td>一个开源的与 Cocoa 紧密集合的基础性框架</td>
</tr>
<tr>
<td>51. <a rel=""nofollow"" href=""https://github.com/arashpayan/appirater"">Appirater</a>
</td>
  <td>一款用于提醒用户给你的 App 打分的工具</td>
</tr>
<tr>
<td>52. <a rel=""nofollow"" href=""https://github.com/kif-framework/KIF"">KIF</a>
</td>
  <td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td>
</tr>
<tr>
<td>53. <a rel=""nofollow"" href=""https://github.com/slackhq/SlackTextViewController"">SlackTextViewController</a>
</td>
  <td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td>
</tr>
<tr>
<td>54. <a rel=""nofollow"" href=""https://github.com/IFTTT/JazzHands"">JazzHands</a>
</td>
  <td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td>
</tr>
<tr>
<td>55. <a rel=""nofollow"" href=""https://github.com/BoltsFramework/Bolts-iOS"">Bolts-iOS</a>
</td>
  <td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td>
</tr>
<tr>
<td>56. <a rel=""nofollow"" href=""https://github.com/eczarny/spectacle"">Spectacle</a>
</td>
  <td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td>
</tr>
<tr>
<td>57. <a rel=""nofollow"" href=""https://github.com/tombenner/nui"">nui</a>
</td>
  <td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td>
</tr>
<tr>
<td>58. <a rel=""nofollow"" href=""https://github.com/Induction/Induction"">Induction</a>
</td>
  <td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td>
</tr>
<tr>
<td>59. <a rel=""nofollow"" href=""https://github.com/icanzilb/JSONModel"">JSONModel</a>
</td>
  <td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td>
</tr>
<tr>
<td>60. <a rel=""nofollow"" href=""https://github.com/Cocoanetics/DTCoreText"">DTCoreText</a>
</td>
  <td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td>
</tr>
<tr>
<td>61. <a rel=""nofollow"" href=""https://github.com/schneiderandre/popping"">Popping</a>
</td>
  <td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td>
</tr>
<tr>
<td>62. <a rel=""nofollow"" href=""https://github.com/KrauseFx/TSMessages"">TSMessages</a>
</td>
  <td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td>
</tr>
<tr>
<td>63. <a rel=""nofollow"" href=""https://github.com/facebook/KVOController"">KVOController</a>
</td>
  <td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td>
</tr>
<tr>
<td>64. <a rel=""nofollow"" href=""https://github.com/mwaterfall/MWPhotoBrowser"">MWPhotoBrowser</a>
</td>
  <td>一款简单的 iOS 照片浏览控件</td>
</tr>
<tr>
<td>65. <a rel=""nofollow"" href=""https://github.com/mutualmobile/MMDrawerController"">MMDrawerController</a>
</td>
  <td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td>
</tr>
<tr>
<td>66. <a rel=""nofollow"" href=""https://github.com/escoz/QuickDialog"">QuickDialog</a>
</td>
  <td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td>
</tr>
<tr>
<td>67. <a rel=""nofollow"" href=""https://github.com/samvermette/SVPullToRefresh"">SVPullToRefresh</a>
</td>
  <td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td>
</tr>
<tr>
<td>68. <a rel=""nofollow"" href=""https://github.com/nothingmagical/cheddar-ios"">cheddar-ios</a>
</td>
  <td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td>
</tr>
<tr>
<td>69. <a rel=""nofollow"" href=""https://github.com/XVimProject/XVim"">XVim</a>
</td>
  <td>一款在 Xcode 上实现了 Vim 功能的插件</td>
</tr>
<tr>
<td>70. <a rel=""nofollow"" href=""https://github.com/enormego/EGOTableViewPullRefresh"">EGOTableViewPullRefresh</a>
</td>
  <td>一款提供下拉刷新的控件, 最后更新时间是一年前</td>
</tr>
<tr>
<td>71. <a rel=""nofollow"" href=""https://github.com/gimenete/iOS-boilerplate"">iOS-boilerplate</a>
</td>
  <td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td>
</tr>
<tr>
<td>72. <a rel=""nofollow"" href=""https://github.com/gotosleep/JASidePanels"">JASidePanels</a>
</td>
  <td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td>
</tr>
<tr>
<td>73. <a rel=""nofollow"" href=""https://github.com/mattt/FormatterKit"">FormatterKit</a>
</td>
  <td>收集了很多构思优秀的 NSFormatter 子类</td>
</tr>
<tr>
<td>74. <a rel=""nofollow"" href=""https://github.com/erichoracek/MSDynamicsDrawerViewController"">MSDynamicsDrawerViewController</a>
</td>
  <td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td>
</tr>
<tr>
<td>75. <a rel=""nofollow"" href=""https://github.com/boctor/idev-recipes"">idev-recipes</a>
</td>
  <td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td>
</tr>
<tr>
<td>76. <a rel=""nofollow"" href=""https://github.com/robbiehanson/XMPPFramework"">XMPPFramework</a>
</td>
  <td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td>
</tr>
<tr>
<td>77. <a rel=""nofollow"" href=""https://github.com/MacGapProject/MacGap1"">MacGap1</a>
</td>
  <td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td>
</tr>
<tr>
<td>78. <a rel=""nofollow"" href=""https://github.com/nicklockwood/FXBlurView"">FXBlurView</a>
</td>
  <td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td>
</tr>
<tr>
<td>79. <a rel=""nofollow"" href=""https://github.com/shu223/iOS7-Sampler"">iOS7-Sampler</a>
</td>
  <td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>80. <a rel=""nofollow"" href=""https://github.com/mxcl/PromiseKit"">PromiseKit</a>
</td>
  <td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td>
</tr>
<tr>
<td>81. <a rel=""nofollow"" href=""https://github.com/facebook/origami"">Origami</a>
</td>
  <td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td>
</tr>
<tr>
<td>82. <a rel=""nofollow"" href=""https://github.com/fpillet/NSLogger"">NSLogger</a>
</td>
  <td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td>
</tr>
<tr>
<td>83. <a rel=""nofollow"" href=""https://github.com/ksuther/KSImageNamed-Xcode"">KSImageNamed-Xcode</a>
</td>
  <td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td>
</tr>
<tr>
<td>84. <a rel=""nofollow"" href=""https://github.com/smileyborg/PureLayout"">PureLayout</a>
</td>
  <td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td>
</tr>
<tr>
<td>85. <a rel=""nofollow"" href=""https://github.com/tomaz/appledoc"">AppleDoc</a>
</td>
  <td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td>
</tr>
<tr>
<td>86. <a rel=""nofollow"" href=""https://github.com/gnachman/iTerm2"">iTerm2</a>
</td>
  <td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td>
</tr>
<tr>
<td>87. <a rel=""nofollow"" href=""https://github.com/kiwi-bdd/Kiwi"">Kiwi</a>
</td>
  <td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td>
</tr>
<tr>
<td>88. <a rel=""nofollow"" href=""https://github.com/alloy/terminal-notifier"">terminal-notifier</a>
</td>
  <td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td>
</tr>
<tr>
<td>89. <a rel=""nofollow"" href=""https://github.com/uranusjr/macdown"">MacDown</a>
</td>
  <td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td>
</tr>
<tr>
<td>90. <a rel=""nofollow"" href=""https://github.com/twitter/twui"">TwUI</a>
</td>
  <td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td>
</tr>
<tr>
<td>91. <a rel=""nofollow"" href=""https://github.com/honcheng/PaperFold-for-iOS"">PaperFold for iOS</a>
</td>
  <td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td>
</tr>
<tr>
<td>92. <a rel=""nofollow"" href=""https://github.com/vfr/Reader"">Reader</a>
</td>
  <td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td>
</tr>
<tr>
<td>93. <a rel=""nofollow"" href=""https://github.com/marcuswestin/WebViewJavascriptBridge"">WebViewJavascriptBridge</a>
</td>
  <td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td>
</tr>
<tr>
<td>94. <a rel=""nofollow"" href=""https://github.com/shu223/iOS8-Sampler"">iOS8-Sampler</a>
</td>
  <td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>95. <a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaHTTPServer"">CocoaHTTPServer</a>
</td>
  <td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td>
</tr>
<tr>
<td>96. <a rel=""nofollow"" href=""https://github.com/rsms/kod"">Kod</a>
</td>
  <td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td>
</tr>
<tr>
<td>97. <a rel=""nofollow"" href=""https://github.com/michaeltyson/TPKeyboardAvoiding"">TPKeyboardAvoiding</a>
</td>
  <td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td>
</tr>
<tr>
<td>98. <a rel=""nofollow"" href=""https://github.com/MugunthKumar/MKNetworkKit"">MKNetworkKit</a>
</td>
  <td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td>
</tr>
<tr>
<td>99. <a rel=""nofollow"" href=""https://github.com/pkluz/PKRevealController"">PKRevealController</a>
</td>
  <td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td>
</tr>
<tr>
<td>100. <a rel=""nofollow"" href=""https://github.com/AlanQuatermain/AQGridView"">AQGridView</a>
</td>
  <td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td>
</tr>
</tbody>
</table>

                ", GitHub 上排名前 100 的 Objective-C 项目简介,1531978072,225,1,297,1,1,https://segmentfault.com/a/1190000002665904
281,1,0,7,"
                    
<p>如何保持效率，不仅仅是个人的挑战，这对一个组织或公司而言也至关重要，这也与公司的信息流动和沟通交流密切相关。在科技型创业公司，效率会变得更致命，因为这些公司通常都运作得非常快，而且还常常面临着巨大的压力（例如产品发布日期，资金的运转等）。</p>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/dea49138746d4142a47c147dc772dc06/ef7cf149-aa33-4549-a82d-4ac6a292ad5e.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p>所以，这就需要在创业公司所有成员之间要保持高度的一致性，去确保产品适应市场，后期的平稳运行，和公司的整体透明度。</p>

<p>在 Worktile 这一年的创业旅程中，我们遇到很多值得学习的优秀产品，我们也希望将Worktile打造成一款优秀的效率工具，再这里，我们希望将我们这一年的经验和我们认为非常值得使用的工具分享给大家。</p>

<p>在我们开始之前，我们首先要明确典型的科技初创公司的几点需求：基本上，一般有四种需求：</p>

<ul>
<li>团队内部以及与外部的沟通需求；</li>
<li>用于跟踪和协调的工作流程和任务的需要；</li>
<li>提升协作效率的需求；</li>
<li>扁平化和足够的透明度。</li>
</ul>
<h2><strong>Toolbox for Tech Startup</strong></h2>

<h3><strong><a rel=""nofollow"" href=""https://slack.com"">Slack</a> for 沟通</strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/7b527706-6a36-4049-b768-bbcbcf21cb97.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p>好吧，我承认，最近快要被 Slack 各种叼爆天的新闻刷屏了。但追求极致，简单干脆满足人类沟通需求的 Slack 确实太有魅力。在Slack中你可以跟你的团队成员进行高效的内部沟通，还可以对团队成员以及各成员分享的文件，文档进行搜索。你可以创建一些基于你们需要讨论各种话题的工作和任务，也可以有专门的主题内容，如聚会，开发，设计等等。除了这些，Slack 还整合了 Twitter、Zendesk、Crashlytics 和 Heroku 等服务，将它们的通知提醒、Bug 追踪等数据融入到公司内的信息流中。让整个公司的内部交流只关注于跟工作有关的信息流，极大地提高了沟通效率。就像 Slack 的 Slogan 一样：<strong>Be less busy！</strong></p>

<h3><strong>文件存储的 <a rel=""nofollow"" href=""https://www.dropbox.com/"">Dropbox</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/dea49138746d4142a47c147dc772dc06/693d2ca1-40d7-4c6e-9106-78eb8b0584ba.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p>Dropbox 在存储方面展现的魅力已无需多言（对 Tech Startup 来说，被墙完全不是个问题好吧）全世界数以亿计的用户正在使用Dropbox，这可以让我们在电脑、手机、平板，甚至服务器上同步、备份或共享文件资料。文件的管理与共享在团队效率方面有着最明显的表现，版本控制，文件查找再也不会成为绊脚石了。</p>

<h3><strong>针对中小团队的团队协同工具 <a rel=""nofollow"" href=""https://worktile.com/"">Worktile</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/dea49138746d4142a47c147dc772dc06/b375701e-a299-4b1a-9047-142b07f230fb.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p><a rel=""nofollow"" href=""https://worktile.com/"">Worktile</a>，正是我远程实习的一家科技创业公司，是面向中小团队的协同工具。提倡通过任务驱动来连接团队在执行项目的过程中的事和事，人和事，人和人。在实习过程中，我们之间的任务分配和协调工作都是在 Worktile 上完成的。在 Worktile ，你可以根据公司不同的部门创建不同的项目，如“店小二”的运营部，苦逼的开发部等。得益于 Worktile 的看板式任务列表和不同层级权限管理机制，我们的工作效率得到大大的提升，知道Worktile每两周甚至每周就升级版本的秘诀么？就是Worktile带给我们的：不知不觉就提高了工作效率。如果正打算使用Worktile，那么，上吧！你将享受到一种前所未有的协同工作方式，就算是异地办公也是毫无压力（PS：我就是异地办公）。还有一点就是，Worktile有一个非常有爱的<a rel=""nofollow"" href=""https://worktile.com/club"">用户社区</a>，你可以在社区提一些建议或者分享一些关于协同工作的干货等，而一旦你在社区发帖，我们Worktile的官方人员会竭诚为你“秒回”！这个得点32个赞！快来点赞</p>

<h3><strong>可爱的大象头 <a rel=""nofollow"" href=""https://www.yinxiang.com/"">Evernote</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/8ac982e5-5e83-46e6-ac32-845f31a056fd.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Workitle""></span></p>

<p>在我看来是一个更偏向于个人使用的工具，我们团队中很多人也是它的付费用户，主要是负责管理一些私人的日记和记录一些牛逼的灵感，在产品上，Evernote 的极致追求我们作为用户是切实的感受到了！我最初使用Evernote是在2012年，当时Evernote已经宣布对所有用户提供最基础免费空间和功能。而在全平台支持的Evernote上，我一般使用的是Web版，因为对于我个人来说，我使用Evernote的时候无非就是编辑一下日记而已，没用上很多Evernote在微信推送的高大上功能，所以我基本是懒得下PC端，直接在Web上使用就很完美。</p>

<h3><strong>在线作图工具 <a rel=""nofollow"" href=""http://www.processon.com/"">ProcessOn</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/4dbeee3e-722f-4db1-ad4a-009ab90a03ed.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Worktile""></span></p>

<p><a rel=""nofollow"" href=""http://www.processon.com/"">ProcessOn</a>是国内目前做得比较好的在线作图协作平台。在创业的过程中，难免会有一些图表，像流程图，图表式的Roadmap等，既然我们的重心是在产品上，那么我向你推荐ProcessOn，它可以快速地制作出你想要的各种图。而且，ProcessOn还支持协作画图，你可以跟你的小伙伴们一边作图，一边沟通交流。这不是跟我们倡导的理念一样么？哇哈哈。</p>

<h3><strong>大百度的思维导图 <a rel=""nofollow"" href=""http://naotu.baidu.com/"">百度脑图</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/dd057d25-21f0-4c5c-ab37-598648c7ec4b.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p>百度脑图的功能不算很多，但足够日常使用了，我通常是在总结工作和理清代码思路的时候用它。优点蛮多：支持随处拖拽，云储存，不占用硬盘空间，一键分享给你们的小伙伴，你甚至还可以导入百度的Doc文件……而其中最赞的功能莫过于百度脑图支持多格式保存文件，你既可以到出成「.xmind」格式，也可以导出成「.mm」格式，也可以导出成「.km」格式……这样导出的思路脑图就可以在你的电脑客户端完美进行在编辑了，如果你需要的话。<em>（大百度也还是有如此精致的产品嘛）</em></p>

<h3><strong>PDF Word Excel转换 <a rel=""nofollow"" href=""http://convertii.com/pdf-to-word"">Convertii</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/d19e7545-06d2-44e9-adb4-7d2ef32d20d9.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pdf""></span></p>

<p>我只是默默将这个链接分享给你。这样的工具有很多，但首先还是推荐这个，界面简洁，支持直接拖拽文件上传等，各种用户体验都非常好，你可以「PDF转Word」，还可以转Excel，转Text等。你不用安装任何Adobe Acrobat XI Pro或者类似的软件了，直接将文件拖入到这个网页的就可以见证奇迹了。Yeah~~~</p>

<h3><strong>数据统计可视化工具 <a rel=""nofollow"" href=""https://infogr.am/"">infogr.am</a></strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/c99be877-8a92-4d5d-8237-a3ad667b7b19.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p><a rel=""nofollow"" href=""https://infogr.am/"">infogr.am</a> 是一个很强大的数据可视化图表创作平台，这是我老大@小泽马君给我推荐的工具，你可以在上面创建很多种表格，包括常见的圆饼图，条形图，柱状图和一些炫酷吊炸天信息图表（一共14种）。还在为数据可视化烦恼？小白不懂D3.js？不用怕，现在你只要注册一个 <a rel=""nofollow"" href=""https://infogr.am/"">infogr.am</a>账号可以分分钟创作出各种亮瞎的数据图表了。这对于一些产品经理来说不就是一个开挂的工具么？不过......它不是免费的，你可能需要每月交上几美元。</p>

<h3><strong><a rel=""nofollow"" href=""http://defonic.com/"">Defonic</a> for Relax</strong></h3>

<p><span class=""img-wrap""><img data-src=""https://wt-prj.oss.aliyuncs.com/3e8b4f54c9314fc0b7f935f3c9f22e35/75e81922-4283-453f-a6d3-3890fa35e2e7.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""替代文字""></span></p>

<p>说了这么多生产工具，最后分享一个让你放松的网站：<a rel=""nofollow"" href=""http://defonic.com/"">Defonic</a> ,我通常会在工作累了的时候或者有时候直接一边写东西一边放背景音乐。这是一个能产生环境音效的线上服务，公提供24种不同的环境声音，包括海洋、河流、雨滴、森林、篝火、闪电、风声、夜晚、浪涛等等，你无需下载或暗转任何软件，只要将网页打开，点击你想播放的声音按钮就行。</p>

<blockquote>
  <p>Tips：<a rel=""nofollow"" href=""http://defonic.com/"">Defonic </a>默认情况下是不显示背景的高清大图的，你需要点击右上的HD小按钮才会出现如此的身临其境的图片。</p>
</blockquote>

<p>整体来说，Defonic 提供的音效品质相当好，即使有背景音乐搭配播放，也不会有很吵杂、难以忍受的感觉。强烈推荐各种设计师，工程师到上面放松自己</p>

<h2><strong>痛并快乐着</strong></h2>

<p>对于怀揣着梦想的创业者们，大家享受着这旅程上的一切惊奇与喜悦，也承担着巨大压力与质疑。我们希望将这些实用的工具分享给大家，多少可以减轻些工作中的负担，减少重复性工作，将精力放到更加重要的或者我们更享受的事情上，拼尽全力的去追寻各自心中的秘宝！</p>

                ", 科技创业公司的效率工具箱,1531978073,331,1,477,1,1,https://segmentfault.com/a/1190000002656795
282,1,0,7,"
                    
<h2>1、设置Git的user name和email：(如果是第一次的话)</h2>

<pre><code>linux</code><code>    $ git config --global user.name ""humingx""
    $ git config --global user.email ""humingx@yeah.net""
</code></pre>

<h2>2、生成密钥</h2>

<pre><code>linux</code><code>    $ ssh-keygen -t rsa -C ""humingx@yeah.net""
</code></pre>

<p>连续3个回车。如果不需要密码的话。<br>
最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlgoL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<hr>
<p>如果不是第一次，就选择<code>overwrite</code>.<br><span class=""img-wrap""><img data-src=""/img/bVlgpi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>3、添加密钥到ssh-agent</h2>

<p>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p>

<pre><code>linux</code><code>    # start the ssh-agent in the background
    eval ""$(ssh-agent -s)""
    Agent pid 59566
</code></pre>

<p>添加生成的 SSH key 到 ssh-agent。</p>

<pre><code>linux</code><code>    $ ssh-add ~/.ssh/id_rsa
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVlgpk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>4、登陆Github, 添加 ssh 。</h2>

<p>把<code>id_rsa.pub</code>文件里的内容复制到这里</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlgoO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVlgoP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVlgoQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVlgoR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVlgoS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>5、测试：</h2>

<pre><code>linux</code><code>    $ ssh -T git@github.com
</code></pre>

<p>你将会看到：</p>

<pre><code>    The authenticity of host 'github.com (207.97.227.239)' can't be established.
    RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
    Are you sure you want to continue connecting (yes/no)?
</code></pre>

<p>选择 <code>yes</code></p>

<pre><code>    Hi humingx! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>

<p>如果看到<code>Hi</code>后面是你的用户名，就说明成功了。<br><span class=""img-wrap""><img data-src=""/img/bVlgoM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>6、修改<code>.git</code>文件夹下<code>config</code>中的<code>url</code>。</h2>

<p>修改前</p>

<pre><code>    [remote ""origin""]
    url = https://github.com/humingx/humingx.github.io.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>

<p>修改后</p>

<pre><code>    [remote ""origin""]
    url = git@github.com:humingx/humingx.github.io.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>

<h2>7、发布</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlgoT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

                ", git-ssh 配置和使用,1531978075,126,1,462,1,1,https://segmentfault.com/a/1190000002645623
283,1,0,7,"
                    
<blockquote>
  <p>PS：最近又换回了 <code>Linux Mint</code>，作为一个 <code>Linux 桌面黑</code>，有点尴尬。。。：）</p>
</blockquote>

<p>换行符是 *nux 与 Windows 系及其他系的各种不兼容问题的代表之一，于是，在不同平台使用 Git 时经常碰到 <code>git status</code> 列出一大串修改过的文件，<code>git diff</code> 查看一下其实只是换行符问题。不多扯了，直接上解决方案：</p>

<h3>方案1： 增加 .gitattribute 文件</h3>

<p>在 repo 目录下新建 <code>.gitattribute</code> 文件，内容为：</p>

<pre><code>* text eol=lf
</code></pre>

<h3>方案2： 修改 Git 配置</h3>

<pre><code>git config --global core.autocrlf false
git config --global core.safecrlf true
</code></pre>

<p>如果只需要修改当前仓库，去掉 <code>--global</code>。</p>

<h3>方案3： 行政命令</h3>

<p>下令：一律使用 unix 换行符，违者男的穿裙子，女的不许穿！</p>

<h3>参考：</h3>

<ul>
<li><a rel=""nofollow"" href=""https://help.github.com/articles/dealing-with-line-endings/#platform-all"">Dealing with line endings</a></li>
</ul>

                ", Git 处理换行符问题,1531978076,379,1,903,1,1,https://segmentfault.com/a/1190000002624278
284,1,0,7,"
                    
<blockquote>
  <p>译者注：看到一篇介绍能简单自建git托管服务的项目—— Gogs ——的文章，感觉这个项目很棒，翻译给大家参考一下。<br>
  这个项目的四位主要开发者都是中国人，该项目今天蝉联 GitHub Go 语言 Trending 第一。(づ￣3￣)づ莫名的自豪感油然而生。希望能有更多优秀的国产项目出现~</p>
</blockquote>

<p><a rel=""nofollow"" href=""https://gitlab.com/"">Gitlab</a>是一个很棒的Git托管服务，几乎像<a rel=""nofollow"" href=""https://github.com/"">GitHub</a>一样强大。 但是，有没有能和Gitlab/Github媲美但操作更简单的项目呢？我认为 <a rel=""nofollow"" href=""http://gogs.io/"">Gogs</a> 是很好的选择。</p>

<h2>简介</h2>

<p>现在，GitHub已经成为首选的代码托管平台。 因为它又很多很棒的功能，操作简单，几乎所有的开发者都喜欢它。</p>

<p>同时，<a rel=""nofollow"" href=""http://arstechnica.com/information-technology/2015/03/google-to-close-google-code-open-source-project-hosting/"">谷歌的代码托管项目准备关闭</a>，你可以把项目转移到这里。</p>

<p>但如果你在写Android应用程序，或者正在创建下一个伟大的iOS游戏，或者不想让别人看到你的代码没，该怎么办？</p>

<p>你当然可以购买私人GitHub库，但你肯定更想把资金投资到更紧迫的事情上。</p>

<p>这就是 Gitlab 和 Gogs 这样的软件诞生的原因。</p>

<p>他们提供的服务和GitHub非常相似，不同的是，你可以把项目放在你自己的服务器上，甚至是自己的工作站上。</p>

<p>下面一起来进行更深入的了解。</p>

<h2>Gitlab</h2>

<p>Gitlab是一个强大的git服务，基本功能和对手GitHub一样。 这是一个成熟的项目和并且在不断更新。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVk5Pp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>他们最近收购了<a rel=""nofollow"" href=""https://gitorious.org/"">Gitorius</a>（另一个类似GitHub的服务），所以功能将有望得到扩展（<a rel=""nofollow"" href=""http://thenextweb.com/insider/2015/03/03/gitlab-acquires-rival-gitorious-will-shut-june-1/"">查看有关收购的新闻剪辑</a>）。</p>

<p>以前是手动安装，很耗时间，问题也很多。最近安装过程有所改善。</p>

<p>现在有 Linux DEB／RPM 的安装包可用（称为Omnibus），解决了所有的依赖问题，简化了安装过程。</p>

<p>升级是一个复杂的事情，尤其是从较早的版本升级到最新版，但也没那么复杂。</p>

<p>然而，你可以感受到很多东西是在后台执行的。 你可以运行 Sidekiq、Unicorn、Nginx、Ruby (包括 gems) 和 Gitlab本身。</p>

<p>自定义安装不是那么简单，有很多不确定因素，如果出了什么差错，要自己一个个排查。</p>

<h2>输入二进制包</h2>

<p>现在，我们有了<a rel=""nofollow"" href=""http://gogs.io/"">Gogs</a>。 你所要做的就是运行一个的二进制包。</p>

<p>它是用<a rel=""nofollow"" href=""https://golang.org/"">Go</a>语言写的，能兼容各个系统。</p>

<p>它能运行于 Windows，MAC，Linux，ARM 等。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVk5Pr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>安装时只需要把压缩包解压到选定的文件夹中。 就是这样。 升级也一样：只要解压压缩包即可。</p>

<p>这就是<a rel=""nofollow"" href=""https://golang.org/"">Go语言二进制开发</a>的美，你可以轻松在多个平台下开发。</p>

<p>Gogs占用资源少，所以它很容易在系统资源上运行（它可以在<a rel=""nofollow"" href=""http://www.raspberrypi.org/"">Raspberry Pi</a>运行）。</p>

<p>你可以用默认的配置运行，或做一些小调整。</p>

<p>默认的配置文件位于安装文件夹的<code>/conf/app.ini</code>，文档建议把自定义配置写到<code>/custom/conf/app.ini</code>，这样升级就不会覆盖配置。</p>

<p>有三个可自定义的东西：</p>

<ul>
<li>
<p>库的位置</p>

<pre><code>[repository]
ROOT = !! 库的地址 !!
</code></pre>
</li>
<li>
<p>数据库位置</p>

<pre><code>[database]
PATH = !! 数据库地址 !!
</code></pre>
</li>
<li><p>公钥</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVk5Pt"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>注意：目前，你需要运行一个SSH服务器（OpenSSH也很好），这和gitlab相同。</p>

<h2>比较</h2>

<p>让我们比较一下这两个产品。 我将以GitHub作为参考。<br></p>
<table>
<thead><tr>
<th>特性</th>
  <th>Gogs</th>
  <th>Gitlab</th>
  <th>Github</th>
</tr></thead>
<tbody>
<tr>
<td>Dashboard &amp; File Browser</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Issue Tracking, Milestones &amp; Commit keywords</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Organizations support</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Wiki</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Code Review</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Code Snippets</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Web Hooks</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>Git Hooks</td>
  <td>Y</td>
  <td>* Enterprise</td>
  <td>* Enterprise</td>
</tr>
<tr>
<td>LDAP Login</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
</tr>
<tr>
<td>LDAP Group Sync</td>
  <td>N</td>
  <td>* Enterprise</td>
  <td>* Enterprise</td>
</tr>
<tr>
<td>Branded Login Page</td>
  <td>N</td>
  <td>* Enterprise</td>
  <td>* Enterprise</td>
</tr>
<tr>
<td>Language</td>
  <td>Go</td>
  <td>Ruby</td>
  <td>Ruby</td>
</tr>
<tr>
<td>Platform</td>
  <td>Cross-Platform</td>
  <td>Linux</td>
  <td>* Virtual Machine</td>
</tr>
<tr>
<td>License</td>
  <td>MIT</td>
  <td>MIT</td>
  <td>Proprietary</td>
</tr>
<tr>
<td>Resource Usage</td>
  <td>Low</td>
  <td>Medium/High</td>
  <td>Medium/High</td>
</tr>
</tbody>
</table>
<p>代码审查（拉取请求）可以说是缺失的最重要的功能。 这是 Gogs 在<a rel=""nofollow"" href=""https://github.com/gogits/gogs/issues/5"">Github issues</a> 里首要问题，Gogs的主要开发者正在尽力开发中。</p>

<p>但总的来说，这是一个功能丰富的、私有的Git托管服务。</p>

<h2>运行一个 Gogs docker</h2>

<p>我<a rel=""nofollow"" href=""http://www.apertoire.net/dockeritazion"">以前描述</a>我如何我的服务器环境docker化，所以我也会把gogs作为Docker容器来运行</p>

<p>让我们一步一步来做。</p>

<p>假设我有一个应用程序的文件在我的服务器根目录<code>/home/kayak/apps</code>，给每个作为Docker容器的应用创建子目录。</p>

<p>下载并解压最新版本gogs。</p>

<pre><code>$ cd /home/kayak/apps
$ wget http://gogs.dn.qbox.me/gogs_v0.5.13_linux_amd64.zip
$ unzip gogs_v0.5.13_linux_amd64.zip
$ rm gogs_v0.5.13_linux_amd64.zip
</code></pre>

<p>自定义配置</p>

<pre><code>$ cd gogs
$ mkdir -p custom/conf
$ cd custom/conf
$ nano app.ini
[repository]
ROOT = !! this is the location where you want to keep the repositories !!

[database]
PATH = !! this is the location of your database (sqlite3 by default) !!
</code></pre>

<p>注： 你也可以不把gogs作为docker容器，直接运行。</p>

<p>现在让我们创建dockerfile</p>

<pre><code>$ cd /home/kayak/apps/gogs
$ nano Dockerfile

FROM ubuntu:14.04

ENV DEBIAN_FRONTEND noninteractive

RUN sed 's/main$/main universe multiverse/' -i /etc/apt/sources.list &amp;&amp; \
    apt-get update &amp;&amp; apt-mark hold initscripts &amp;&amp; \
    apt-get install -y sudo openssh-server git &amp;&amp; \
    apt-get clean

EXPOSE 22 3000

RUN addgroup --gid 501 kayak &amp;&amp; adduser --uid 501 --gid 501 --disabled-password --gecos 'kayak' kayak &amp;&amp; adduser kayak sudo

WORKDIR /home/kayak
ENV HOME /home/kayak

ENTRYPOINT [""/home/kayak/boot""]
</code></pre>

<p>dockerfile是基于最新的Ubuntu LTS版服务器（14.04）。</p>

<p>然后安装 sudo, openssh 和 git，暴露端口22（用于SSH）和3000（给gogs的Web界面）。</p>

<p>另外，我通常会创建一个用户（这里用 kayak），它具有与我的Max box用户相同的UID/GID，以防止访问权限问题。</p>

<p>最后，启动shell脚本运行。</p>

<pre><code>$ touch boot
$ chmod +x boot
$ nano boot
#!/bin/bash

sudo -u kayak -H touch /home/kayak/.ssh/authorized_keys
chmod 700 /home/kayak/.ssh &amp;&amp; chmod 600 /home/kayak/.ssh/authorized_keys

# start openssh server
mkdir /var/run/sshd
/usr/sbin/sshd -D &amp;

exec sudo -u kayak /home/kayak/gogs web
</code></pre>

<p>这样就运行了ssh守护进程和gogs。现在是以kayak用户运行，这样比用默认的root用户好一些。</p>

<p>建立镜像</p>

<pre><code>$ cd /home/kayak/apps/gogs
$ docker build --rm -t apertoire/gogs .
</code></pre>

<p>镜像建立好就可以运行了</p>

<pre><code>$ docker run -d --name gogs \
-v /etc/localtime:/etc/localtime:ro \
-v /home/kayak/apps/gogs:/home/kayak \
-p 62723:22 \
-p 3000:3000 \
apertoire/gogs
</code></pre>

<p>可以在命令行查看运行情况。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVk5R1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>现在可以打开网页界面，它会显示一个安装页面（首次运行）。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVk5R2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>安装完成后，就搭建好一个功能丰富的Gogs了。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVk5R3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<h2>总结</h2>

<p>Gogs 是一个轻量级的、易于设置、跨平台的Git托管服务，不逊色于 Gitlab 和 GitHub。</p>

<p>虽然不比这二者成熟，但它有很大的潜力。</p>

<p>它是开源的，所以你可以帮助改善它。</p>

<p>我用Gogs取代Gitlab几个月了，感觉不错。</p>

<p>我创建42个库，感觉它的性能非常好。</p>

<p>我绝对推荐Gogs作为你的Git自托管服务。</p>

<h2>附该项目在Github上的4位开发者：</h2>

<table>
<thead><tr>
<th><span class=""img-wrap""><img data-src=""/img/bVk5U5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></th>
  <th><span class=""img-wrap""><img data-src=""/img/bVk5U8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></th>
  <th><span class=""img-wrap""><img data-src=""/img/bVk5U9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></th>
  <th><span class=""img-wrap""><img data-src=""/img/bVk5Uw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></th>
</tr></thead>
<tbody><tr>
<td><a rel=""nofollow"" href=""http://weibo.com/Obahua#_rnd1426665680212"">无闻Unknwon</a></td>
  <td><a rel=""nofollow"" href=""https://github.com/slene"">Liu Peng</a></td>
  <td><a rel=""nofollow"" href=""http://weibo.com/xiaolunwen"">Lunny Xiao</a></td>
  <td><a rel=""nofollow"" href=""http://weibo.com/fuxiaohei/"">傅小黑</a></td>
</tr></tbody>
</table>
<hr>
<p>英文原文 <a rel=""nofollow"" href=""http://www.apertoire.net/gogs-an-alternative-to-gitlab/"">Gogs, an alternative to Gitlab</a><br>
整理编译 <a rel=""nofollow"" href=""http://segmentfault.com/blog/news/1190000002605142"">SegmentFault</a></p>

                ", Gogs：可能是比Gitlab更好的选择,1531978077,498,1,359,1,1,https://segmentfault.com/a/1190000002605142
285,1,0,7,"
                    
<h2>前言</h2>

<p>平时我们在提交的时候，肯定是会对自己所做的事情做一些或多或少的说明。但怎么写好就不是那么容易了。于是就跑到github上看看人家是怎么写的，或者Google下，看看有没有什么好的实践经验。特此做了总结，希望能抛砖引玉。</p>

<h2>坏栗子</h2>

<p>我们从坏栗子开讲，这样就有的对比了，也好对号入座。正如这个命令，10个人有9个绝对写过。</p>

<pre><code>git commit -m ""Fix login bug""
</code></pre>

<p>我们还会这么写。</p>

<pre><code>git commit -am ""Fix login bug""
</code></pre>

<p>也会这样。</p>

<pre><code>git commit -am ""Fix bug!""
</code></pre>

<p>很明显，你是在说这个提交是在修改一个登录的BUG，因为没有拼写错误所以我能大概看明白。但我要是管理员我就难过了，会有一大堆的问题席卷而来。心理会想<code>大哥，你修得这个BUG是哪个？哪个登录的？什么样的？怎么改的？</code>。~~然后你后脊梁骨发凉，因为有人在骂街。~~</p>

<p>你也可以这么想，管理员可以耐着性子把我的修改看完，这样就不就行了？不好意思，这样的话管理员会疯的，所以不可以这么做。</p>

<h2>提倡的做法</h2>

<h3>粒度</h3>

<p>说的是做的修改的粒度。如果你一天做了很多的修改，但是就只提交了一次，那么你的粒度就有点大了。这样在你描述你的行为的时候就会显得模糊，如果你详细描述的话，提交信息会变得长篇大论。但也不要做一点提交一点，这样粒度就会变得太小，会导致一天到晚在写提交信息，没有必要。</p>

<p>在我看来，这个事情真的只能凭感觉提交，用经验来做判断。因为一个BUG可能可大可小，大的话，你就得分割修复。如果小，那么就一次提交修复就可。</p>

<p>粒度的掌握绝对会影响你的提交信息，因为二者是一一对应的。</p>

<h3>段落</h3>

<p>还记得上学的时候，写英语作文的三段法吗？和那个差不多，开头阐明观点，中间论述观点，最后总结。<br>
这里我们把提交信息也分为三段，具体如下。</p>

<pre><code>refactor($browser): remove private polling mechanism

The only feature of Angular using this mechanism was `$cookies`,
which no longer mirrors the browser cookie values and so does not
need to poll.

Closes #11222
</code></pre>

<p>感觉如何？该有的有，该没得没。做了什么？为什么这么做？影响了什么？可以说是一目了然。</p>

<p>现在我们来说说为什么这样做好。</p>

<h3>开头</h3>

<p>首先，开头部分单起一行，这在git中就会做为默认显示的部分，在你查看提交信息的时候就会显示这行，其他的部分则在进一步查看的时候才会显示。</p>

<p>你可以指定模块，或者说明动作（Add - Update - Delete）。</p>

<h3>中间</h3>

<p>其次，在中间的部分就是你的详细说明，这个时候就要你做一个全面的说明了。说说你大概搞了什么东西，是怎么搞的。</p>

<h3>最后</h3>

<p>最后的这句话有妙用，他会根据你提到的issue编号自动地关闭你的issue。当然这个和你使用的git服务端有关系，在gitlab中会用Fix来进行关闭。实现了一定的自动化，然后你的团队的成员就会受到通知，多么美好。</p>

<h3>实际运用</h3>

<p>三段式在通常情况下是标配，当然也有例外。在没有相关issue的时候，最后部分可以省略掉。在标题解释了所有的事情的时候，中间的部分可以省略，如你重命名了一个文件，或者是删除了一个文件的时候。所以说只写一个标题也是可以的，前提是够准确。</p>

<p>像是这样</p>

<pre><code>Rename cropper.css -&gt; cropper.scsss
</code></pre>

<p>或是</p>

<pre><code>Add calendar setting file
</code></pre>

<h3>宽度</h3>

<p>是的，是宽度，不是长度。和代码一样，如果你平时注意的话，就不要让你的代码在一行上超过80，不然谁读代码都不好受，包括你自己。所以提交信息的宽度也有限制。</p>

<p>分别是标题不要超过<code>50</code>，内容部分不要超过<code>70</code>。你可能会想，写的时候还要查字数好难过。其实稍微配置一下就可以了，具体操作会在后面说道。</p>

<h3>统一</h3>

<p>只要统一了格式，那么团队的各位都会明白你要表达的意思，所以你完全可以撇开上面的建议自己另起一套。</p>

<p>规范提交信息的格式的目的就是能快速准确的表达信息，只要达到了这个目的就可以。习惯而已。</p>

<h2>小技巧</h2>

<h3>配置提交信息的宽度</h3>

<p>我随时可能忘记宽度的限制，所以要做一个设置，这样就能自动的对提交信息做格式化了。对于这样的设置要取决于你的git默认选择的编辑器是什么，一般都是vim什么的。</p>

<p>在 <code>~/.vimrc</code> 里加上下面的命令，然后就会有神奇的事情发生了。</p>

<p>例如我用webstorm就集成了这个功能，我也就没有太折腾。</p>

<pre><code>autocmd Filetype gitcommit setlocal spell textwidth=72
</code></pre>

<h3>不要使用 -m 或者 --message 做提交</h3>

<p>这个命令让你能够在一次操作中就把信息提交了。看起来很好，但事实上就是这个命令让大家懒惰了。真正好的提交信息真的很难用用一句话说好，你不是在给一行代码做注释，你是在给一连串的改变做出解释。做了什么？为什么这么做？影响了什么？至少得把这三个问题给回答了。当你认知在编辑器里写提交信息的时候，你会想起很多事，经验之谈。</p>

<h2>好栗子</h2>

<p>其实大家也是满随意的，但又很统一。</p>

<h3>Jquery</h3>

<pre><code>shell</code><code>CSS: Restore the hack to get pixels for .css('width') etc.

This hack turns out to be needed by Android 4.0-4.3.

Add a support test so that the hack is invoked only where needed.

Refs gh-1815
Refs gh-1820
Closes gh-1842
</code></pre>

<h3>angular</h3>

<pre><code>fix(filterFilter): Fix filtering using an object expression when the …
…filter value is undefined

Fixes #10419
Closes #10424
</code></pre>

<h3>backbone</h3>

<pre><code>Merge pull request #3443 from jridgewell/history-root

History's root
</code></pre>

<h3>react</h3>

<pre><code>Sync out another jsx transform test.

We added this test internally and it never got added here. We haven't broken it
with any transforms *yet* but it's still good to actually run all of our tests
here too.
</code></pre>

<h2>结语</h2>

<p>不一定要把上面提到的所有的要求都强制的推给团队的所有人，要因地制宜，但一定要规范。正如代码的注释，合适就好。但这个合适要让人明白和清楚，没有额外的废话。</p>

<blockquote>
  <p>没有最好的，只有合适的。</p>
</blockquote>

<p>望大家看完可以做点评。</p>

<h2>相关</h2>

<ul>
<li><a rel=""nofollow"" href=""http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines"">http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines</a></li>
<li><a rel=""nofollow"" href=""https://wiki.duraspace.org/display/FCREPO/Git+Guidelines+and+Best+Practices"">https://wiki.duraspace.org/display/FCREPO/Git+Guidelines+and+Best+Practices</a></li>
<li><a rel=""nofollow"" href=""https://wiki.gnome.org/Git/CommitMessages"">https://wiki.gnome.org/Git/CommitMessages</a></li>
<li><a rel=""nofollow"" href=""https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message"">https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message</a></li>
<li><a rel=""nofollow"" href=""https://wiki.openstack.org/wiki/GitCommitMessages"">https://wiki.openstack.org/wiki/GitCommitMessages</a></li>
<li><a rel=""nofollow"" href=""http://www.slideshare.net/TarinGamberini/commit-messages-goodpractices"">http://www.slideshare.net/TarinGamberini/commit-messages-goodpractices</a></li>
<li><a rel=""nofollow"" href=""http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html"">http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a></li>
<li><a rel=""nofollow"" href=""https://github.com/thoughtbot/guides/tree/master/code-review"">https://github.com/thoughtbot/guides/tree/master/code-review</a></li>
</ul>

                ", Git - 如何写好你的提交信息？,1531978078,575,1,821,1,1,https://segmentfault.com/a/1190000002583308
286,1,0,7,"
                    
<p>看到一个很棒的时间轴工具，分享一下：<br>
github地址 <a rel=""nofollow"" href=""https://github.com/sbstjn/timesheet.js"">https://github.com/sbstjn/timesheet.js</a><br>
主页地址：<a rel=""nofollow"" href=""http://sbstjn.github.io/timesheet.js/"">http://sbstjn.github.io/timesheet.js/</a></p>

<h2>项目介绍</h2>

<p>通过html5和CSS3，把数据和事件进行可视化处理，用JavaScript创建事件轴，用CSS美化样式，还有适合移动端的方法。</p>

<p>作者最近一直在更新，github上有超过4500个star、300多fork，还是比较值得信赖的。</p>

<h2>效果图</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVkZNO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<h2>使用</h2>

<p>只需要引入 Timesheet.js 和配置你的数据，不依赖别的库，不需要 jQuery 、Angular.JS。只是用几行JavaScript去创建HTML5布局的界面、用CSS自定义界面样式。</p>

<pre><code>&lt;script src=""timesheet.js"" type=""text/javascript"" /&gt;
&lt;link href=""timesheet.js""  type=""text/css""&gt;
</code></pre>

<p>创建简单的时间轴只需要一个保存事件的JS数组：</p>

<pre><code>new Timesheet('timesheet-default', 2002, 2013, [
  ['2002', '09/2002', 'A freaking awesome time', 'lorem'],
  ['06/2002', '09/2003', 'Some great memories', 'ipsum'],
  ['2003', 'Had very bad luck'],
  ['10/2003', '2006', 'At least had fun', 'dolor'],
  ['02/2005', '05/2006', 'Enjoyed those times as well', 'ipsum'],
  ['07/2005', '09/2005', 'Bad luck again', 'default'],
  ['10/2005', '2008', 'For a long time nothing happened', 'dolor'],
  ['01/2008', '05/2009', 'LOST Season #4', 'lorem'],
  ['01/2009', '05/2009', 'LOST Season #4', 'lorem'],
  ['02/2010', '05/2010', 'LOST Season #5', 'lorem'],
  ['09/2008', '06/2010', 'FRINGE #1 &amp; #2', 'ipsum']
]);
</code></pre>

<h2>使用Bower安装</h2>

<pre><code>$ &gt; bower install https://github.com/sbstjn/timesheet.js.git
</code></pre>

<p>·</p>

                ", 很棒的时间轴插件：Timesheet.js,1531978080,241,1,658,1,1,https://segmentfault.com/a/1190000002581952
287,1,0,7,"
                    
<blockquote>
  <p>译注：Github Blog 发表了一篇文章 <a rel=""nofollow"" href=""https://github.com/blog/1943-how-to-write-the-perfect-pull-request"">How to write the perfect pull request</a>，对书写 Pull Request 文案给了些相当不错的建议。祝愿大家都能写一手好文档，沟通愉快！</p>
</blockquote>

<p>随着公司规模增长，人和项目都在变化。在 Github，我们的经验是经常提醒自己沟通的目标非常有助于保持沟通的高效率，为此我们最近提出了一份关于提交 Pull Request 的指南，帮助大家在使用 Pull Request 时能更好地协作。</p>

<h2>撰写 Pull Request</h2>

<ul>
<li>要涵盖此次 Pull Request 的目标，例如：<br><code>尝试用 XXX 方法实现……</code><br><code>优化……</code><br><code>修复在 XX 状态下对 XX 的异常处理</code>
</li>
<li>可以提供一份关于这些工作起因的说明（包含上相关链接）。不要假定对方已经熟悉这些事情的前因后果。</li>
<li>记住公司里任何人都有可能来阅读这个 Pull Request，所以内容和语气都需要面向那些未参与工作内容的人，现在和未来的。</li>
<li>如果有的话，请详述你需要的反馈，如：快速过目一下代码/讨论某项技术实现/对设计的意见等等。</li>
<li>明确你<em>何时</em>需要反馈。如果这个 PR 还在没有完成，就需要这么注明一下。给标题加上<code>[WIP]</code>（施工中）的前缀也是个简便快捷的方法。</li>
<li>
<a rel=""nofollow"" href=""https://github.com/blog/821"">@艾特</a> 需要特别指明加入讨论的人，并说明原因（“/cc <a href=""/u/hax"" rel=""nofollow noreferrer"">@hax</a> 麻烦来看下这个逻辑对么？”）。</li>
<li>同样的方法也可以艾特团队（“/cc @baixing/sa 这么做没安全问题吧？”）。</li>
</ul>
<h2>提供反馈</h2>

<ul>
<li>首先要了解下此 PR 的前情提要。</li>
<li>如果你有强烈的反对意见，多花几分钟审视下自己的意见再做反馈。Think Twice。</li>
<li>询问，不要指点。（“为什么你要……”而非“不要……”）</li>
<li>解释你提出修改意见的原因。（和代码规范不符？个人喜好？）</li>
<li>提供简化或改进代码的方法。</li>
<li>在提到别人的工作成果时避免使用贬义词（愚蠢什么的）。</li>
<li>谦逊。（“我不很确定，不过可以试试……”）</li>
<li>不要夸张。（“任何时候绝对……”）</li>
<li>评论旨在提高专业技能、产品质量，达成团队共识。</li>
<li>在线交流时要当心负面歧义（如果文字内容中性，我们倾向认为语气偏负面），尽量使用积极的语气而非中性的。</li>
<li>善用表情符号美化语气。（感受一下 “看起来不错。” 和 “看起来不错 ^O^”）[译注1]</li>
</ul>
<h2>对反馈的回复</h2>

<ul>
<li>考虑以感激作为开场白，尤其是当反馈混杂了各种意见的时候。</li>
<li>如有不明白的地方，请求进一步澄清。（“我不大明白，你能再解释一下么？”）</li>
<li>提供澄清。解释对方询问的实现方案是如何决策的。</li>
<li>尽量回复所有评论。</li>
<li>链接到相关的后续提交。（“好建议！a1da2324ca 已搞定 :D”）</li>
<li>如果疑惑和争论持续扩大，首先审视自己在前面的讨论中是否表达良好，尝试面对面做充分沟通，之后把线下沟通的内容汇总回复（便于其他人跟踪进展或未来了解详情）。</li>
</ul>
<p>这份指南部分受到了 ThoughtBot 的 <a rel=""nofollow"" href=""https://github.com/thoughtbot/guides/tree/master/code-review"">Code Review 指南</a>的启发。</p>

<p>这份指南很适合我们的工作方式，以及我们想要建立的协作文化，希望对你也有帮助。</p>

<p>沟通愉快！</p>

<p>[译注1]: Github Blog 原文使用了 emoji 语气无比欢快可爱，sf.com 暂不支持，请至原文感受那两句 <a rel=""nofollow"" href=""https://github.com/blog/1943-how-to-write-the-perfect-pull-request"">“looks good”</a> 的区别。</p>

                ", 如何写就完美 Pull Request,1531978081,309,1,234,1,1,https://segmentfault.com/a/1190000002575050
288,1,0,7,"
                    
<h2>场景</h2>

<p>大前提，你用的版本工具是git。</p>

<p>你正在开开心心的coding，东写写西改改。突然！一个人对你说道“改个BUG”。如果这个BUG和你正在搞的代码可能相关。怎么办？立马改，为自己埋了一个雷。过会改，处理不当，BUG高于需求。</p>

<p>此场景稀松平常。BUG随时有，但你能做到随时改吗？<code>git stash</code>拯救你。git的强大就是让你各种切换，伸缩自如。</p>

<h2>使用</h2>

<h3>保存</h3>

<p>使用<code>git stash</code>保存当前的操作，如果不这么做，你在切换到别的分支之前就一定要提交已经有的改动。但你当前的操作尚未完成，所以要暂时保存起来。</p>

<h3>查看</h3>

<p>直接使用<code>git stash list</code>就可以了。</p>

<pre><code>shell</code><code>MyPC:project limi$ git stash list
stash@{0}: WIP on master: 3d72f0b clear file
stash@{1}: WIP on start-test: fabaa87 fix bug
</code></pre>

<h3>恢复</h3>

<p>用<code>git stash pop stash@{num}</code>，<code>num</code> 是你要恢复的操作的序号，所以你最好在回复前用<code>git stash list</code>查看一下。</p>

<p><code>git stash pop</code>命令是恢复stash队列中的<code>stash@{0}</code>，然后从记录就删除，就是常规的<code>pop</code>操作。</p>

<h3>删除</h3>

<p>stash存的不要过多，不然你也不知道哪个是哪个，最好随时清一清。<br>
把所有的记录都清空掉用<code>git stash clear</code>。</p>

<h2>UPDATE</h2>

<p>谢谢<a rel=""nofollow"" href=""http://segmentfault.com/u/lilydjwg"">依云</a>的补充说明</p>

<blockquote>
  <p>git stash save some_msg 这样就比较容易区分了。另外 git stash 是个一堆合并提交的分支，可以在 tig 里慢慢看。其实 git-stash 就一 shell 脚本……。</p>
</blockquote>

                ", Git - stash用法,1531978082,538,1,272,1,1,https://segmentfault.com/a/1190000002554160
289,1,0,7,"
                    
<p>如果我们仅仅是将自己的代码<code>commit</code>、<code>push</code>到github上，那么对于我们的技术不会有太多的提升。我们所做的仅仅只是将github当成了我们的网盘。</p>

<p>我们每发布一个版本的时候，是不是也就意味着给用户一个新的版本——持续交付。</p>

<h3>敏捷软件开发</h3>

<p>显然我是在扯淡，这和敏捷软件开发没有什么关系。不过我也不知道瀑布流是怎样的。说说我所知道的一个项目的组成吧:</p>

<ul>
<li>看板式管理应用程序(如trello，简单地说就是管理软件功能)</li>
<li>CI(持续集成)</li>
<li>测试覆盖率</li>
<li>代码质量(code smell)</li>
</ul>
<p>对于一个不是远程的团队(如只有一个人的项目) 来说，Trello、Jenkin、Jira不是必需的:</p>

<blockquote>
  <p>你存在，我深深的脑海里</p>
</blockquote>

<p>当只有一个人的时候，你只需要明确知道自己想要什么就够了。我们还需要的是CI、测试，以来提升代码的质量。</p>

<h2>测试</h2>

<p>通常我们都会找Document，如果没有的话，你会找什么?看源代码，还是看测试?</p>

<pre><code>it(""specifying response when you need it"", function (done) {
    var doneFn = jasmine.createSpy(""success"");

    lettuce.get('/some/cool/url', function (result) {
        expect(result).toEqual(""awesome response"");
        done();
    });

    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/some/cool/url');
    expect(doneFn).not.toHaveBeenCalled();

    jasmine.Ajax.requests.mostRecent().respondWith({
        ""status"": 200,
        ""contentType"": 'text/plain',
        ""responseText"": 'awesome response'
    });
});
</code></pre>

<p>代码来源: <a rel=""nofollow"" href=""https://github.com/phodal/lettuce""></a><a rel=""nofollow"" href=""https://github.com/phodal/lettuce"">https://github.com/phodal/lettuce</a></p>

<p>上面的测试用例，清清楚楚地写明了用法，虽然写得有点扯。</p>

<p>等等，测试是用来干什么的。那么，先说说我为什么会想去写测试吧:</p>

<ul>
<li>我不希望每次做完一个个新功能的时候，再手动地去测试一个个功能。(自动化测试)</li>
<li>我不希望在重构的时候发现破坏了原来的功能，而我还一无所知。</li>
<li>我不敢push代码，因为我没有把握。</li>
</ul>
<p>虽然，我不是TDD的死忠，测试的目的是保证功能正常，TDD没法让我们写出质量更高的代码。但是有时TDD是不错的，可以让我们写出逻辑更简单地代码。</p>

<p>也许你已经知道了<code>Selenium</code>、<code>Jasmine</code>、<code>Cucumber</code>等等的框架，看到过类似于下面的测试</p>

<pre><code> Ajax
   ✓ specifying response when you need it
   ✓ specifying html when you need it
   ✓ should be post to some where
 Class
   ✓ respects instanceof
   ✓ inherits methods (also super)
   ✓ extend methods
 Effect
   ✓ should be able fadein elements
   ✓ should be able fadeout elements
</code></pre>

<p>代码来源: <a rel=""nofollow"" href=""https://github.com/phodal/lettuce""></a><a rel=""nofollow"" href=""https://github.com/phodal/lettuce"">https://github.com/phodal/lettuce</a></p>

<p>看上去似乎每个测试都很小，不过补完每一个测试之后我们就得到了测试覆盖率</p>

<table>
<thead><tr>
<th>File</th>
  <th>Statements</th>
  <th>Branches</th>
  <th>Functions</th>
  <th>Lines</th>
</tr></thead>
<tbody><tr>
<td>lettuce.js</td>
  <td>98.58% (209 / 212)</td>
  <td>82.98%(78 / 94)</td>
  <td>100.00% (54 / 54)</td>
  <td>98.58% (209 / 212)</td>
</tr></tbody>
</table>
<p>本地测试都通过了，于是我们添加了<code>Travis-CI</code>来跑我们的测试</p>

<h2>CI</h2>

<p>虽然node.js不算是一门语言，但是因为我们用的node，下面的是一个简单的<code>.travis.yml</code>示例:</p>

<pre><code>language: node_js
node_js:
    - ""0.10""

notifications:
    email: false

before_install: npm install -g grunt-cli
install: npm install
after_success: CODECLIMATE_REPO_TOKEN=321480822fc37deb0de70a11931b4cb6a2a3cc411680e8f4569936ac8ffbb0ab codeclimate &lt; coverage/lcov.info
</code></pre>

<p>代码来源: <a rel=""nofollow"" href=""https://github.com/phodal/lettuce""></a><a rel=""nofollow"" href=""https://github.com/phodal/lettuce"">https://github.com/phodal/lettuce</a></p>

<p>我们把这些集成到<code>README.md</code>之后，就有了之前那张图。</p>

<p>CI对于一个开发者在不同城市开发同一项目上来说是很重要的，这意味着当你添加的部分功能有测试覆盖的时候，项目代码会更加强壮。</p>

<h2>代码质量</h2>

<p>像<code>jslint</code>这类的工具，只能保证代码在语法上是正确的，但是不能保证你写了一堆bad smell的代码。</p>

<ul>
<li>重复代码</li>
<li>过长的函数</li>
<li>等等</li>
</ul>
<p><code>Code Climate</code>是一个与github集成的工具，我们不仅仅可以看到测试覆盖率，还有代码质量。</p>

<p>先看看上面的ajax类:</p>

<pre><code>Lettuce.get = function (url, callback) {
    Lettuce.send(url, 'GET', callback);
};

Lettuce.send = function (url, method, callback, data) {
    data = data || null;
    var request = new XMLHttpRequest();
    if (callback instanceof Function) {
        request.onreadystatechange = function () {
            if (request.readyState === 4 &amp;&amp; (request.status === 200 || request.status === 0)) {
                callback(request.responseText);
            }
        };
    }
    request.open(method, url, true);
    if (data instanceof Object) {
        data = JSON.stringify(data);
        request.setRequestHeader('Content-Type', 'application/json');
    }
    request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    request.send(data);
};
</code></pre>

<p>代码来源: <a rel=""nofollow"" href=""https://github.com/phodal/lettuce""></a><a rel=""nofollow"" href=""https://github.com/phodal/lettuce"">https://github.com/phodal/lettuce</a></p>

<p>在<a rel=""nofollow"" href=""https://codeclimate.com/github/phodal/lettuce/src/ajax.js"">Code Climate</a>在出现了一堆问题</p>

<ul>
<li>Missing ""use strict"" statement. (Line 2)</li>
<li>Missing ""use strict"" statement. (Line 14)</li>
<li>'Lettuce' is not defined. (Line 5)</li>
</ul>
<p>而这些都是小问题啦，有时可能会有</p>

<ul>
<li>Similar code found in two :expression_statement nodes (mass = 86)</li>
</ul>
<p>这就意味着我们可以对上面的代码进行重构，他们是重复的代码。</p>

<h2>重构</h2>

<p>不想在这里说太多关于<code>重构</code>的东西，可以参考Martin Flower的《重构》一书去多了解一些重构的细节。</p>

<p>这时想说的是，只有代码被测试覆盖住了，那么才能保证重构的过程没有出错。</p>

<h1>如何通过github提升</h1>

<p>上面所说的只是一堆堆地工具，以及一堆堆的方法，真正需要的是实践。</p>

<p>我们需要有测试，有CI，这样我们才能提高自己。</p>

<p><a rel=""nofollow"" href=""http://www.xuntayizhan.com/person/ji-ke-ai-qing-zhi-er-shi-dai-wo-dai-ma-bian-cheng-qu-ni-wei-qi-ke-hao-wan/"">待我代码编成，娶你为妻可好</a></p>

<p>Follow me: <a rel=""nofollow"" href=""https://github.com/phodal""></a><a rel=""nofollow"" href=""https://github.com/phodal"">https://github.com/phodal</a></p>

                ", 如何通过github提升自己,1531978083,347,1,944,1,1,https://segmentfault.com/a/1190000002543980
290,1,0,7,"
                    
<h2>将你的代码托管到github</h2>

<p><code>github</code>是程序猿的代码托管平台，也是基于git的开源分布式版本控制系统。然而，当你登陆github官网时，它并没有为你准备一个很好的代码上传的系统，这是因为它是基于<code>git</code>的分布式版本管理系。那么，如何更快更有效的将本地代码上传到<code>github</code>呢？首先，我们需要在本地安装<code>git</code>，这样才能在本地环境中使用<code>git</code>命令行，（例如：<code>$ git add index.html</code>）其次是要连接到你的<code>github</code>账户上，这样才能把你的代码文件上传上去，而每一次的更改都会形成一个版本记录，这样对团队协作是很有帮助的。</p>

<h2>安装 Git</h2>

<p>这里主要讲的是<code>mac</code>系统，<code>windows</code>也是一样的，只不过<code>mac</code>是在终端下进行，而<code>windows</code>是在<code>cmd</code>下进行的。安装<code>git</code>，这里推荐安装<code>Apple</code>公司的<code>Xcode</code>，<code>Xcode</code>集成了<code>Git</code>，最新版的<code>Xcode</code>已经默认安装好了<code>git</code>。完成安装之后，就可以使用 <code>git</code> 的命令行工具。</p>

<p>当然，首先你需要注册一个<code>github</code>账户。</p>

<h3>配置帐号信息</h3>

<p>在<code>cmd</code>或者终端下输入以下命令行：</p>

<pre><code>git config --global user.name trigkit4
git config --global user.email 345823102@qq.com
</code></pre>

<p>当然，这是我的账户信息，你需要将他们换成你自己的。</p>

<h2>创建本地ssh</h2>

<p>这是一种传输代码的方法，速度快又安全。<code>SSH</code> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p>

<p>在终端或<code>cmd</code>输入以下命令行：</p>

<pre><code>ssh-keygen -t rsa -C ""345823102@qq.com"" 
</code></pre>

<p>当然，邮箱依然换成你注册<code>github</code>时所用的邮箱。如下图所示：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkM97"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p><strong>路径选择 :</strong> 使用该命令之后, 会出现提示选择<code>ssh-key</code>生成路径, 这里直接点回车默认即可, 生成的<code>ssh-key在</code>默认路径中;<br><strong>密码确认 :</strong> 这里我们不使用密码进行登录, 用密码太麻烦;就一路回车下去</p>

<h3>将ssh配置到GitHub中</h3>

<p>在<code>mac os X</code> 下前往文件夹，<code>/Users/自己电脑用户名/.ssh</code>。</p>

<p><code>windows</code>应该是（<code>C:\Documents and Settings\Administrator\.ssh</code> （或者 <code>C:\Users\自己电脑用户名\.ssh</code>）中）。</p>

<p>然后用记事本打开<code>id_rsa.pub</code>，将里面的全部代码复制到<code>github</code>的<code>SSH</code>中。</p>

<p><code>id_rsa.pub</code> 文件内容 :</p>

<pre><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDS0qLtpontavr43AQntX4oBOsg2R3QlWubMYvfgJsIDX6NWd5RaIDLBLEMwIFLDcpvpQKvk5S/bTy4vTuWqeY6fkQ/tZBKksQn1WuYDcSfjLF8BuPMfdkboTh9NaKESKnsiWdranEVbmB5vOAHm8T+HFGdzG7Tz4ygzCnTwvdpBYrd/4jgeazws2d7CuMeuyb+FxdDTQy9YmJJm+82ypfR//bLyzRJo3SYadnPO3VdOAZCO1Isky+p/0nNN/obC4t2y2+oHBAqJV9h37f9S8UShgDmZoVLicRi4poni0i70xj+t/hnOsT8fmEc+vM9USyN+ndawz2oWjikKgln1jOB 345823102@qq.com
</code></pre>

<p>登陆<code>github</code>网站，点击<code>Settings</code>——<code>SSH keys</code>——点击右侧的<code>Add SSH key</code> ，接下去你懂得。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkNat"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p><strong>验证是否配置成功 :</strong><br>
复制如下代码:</p>

<pre><code>ssh -T git@github.com
</code></pre>

<p>然后出现如下信息：</p>

<pre><code>Warning: Permanently added the RSA host key for IP address '192.30.252.131' to the list of known hosts.

Hi hawx1993! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>

<p>验证时可能让你输入<code>YES</code>，当出现以上信息时，说明配置成功，可以连接上<code>GitHub</code>;</p>

<h2>创建版本库</h2>

<p>第一步，在本地创建一个版本库，代码如下：</p>

<pre><code>$ mkdir test   #test是你的文件夹的名字
$ cd test     #进入test所在目录
$ pwd        #pwd命令用于显示当前目录    
/Users/trigkit4/test #这是在我的Mac上的目录
</code></pre>

<p>第二步，通过<code>git init</code>命令把这个目录变成<code>Git</code>可以管理的仓库：</p>

<pre><code>$ git init
</code></pre>

<p>然后会输出以下信息：</p>

<pre><code>Initialized empty Git repository in /Users/trigkit4/banner/.git/
</code></pre>

<p>这里的<code>.git</code>目录是<code>Git</code>用来跟踪管理版本库的，默认是隐藏的。</p>

<p>第三部，接着，在<code>github</code>上创建一个你自己的<code>new repository</code>，然后下一步，</p>

<pre><code>mkdir test  
cd test   
git init    
# initialize your git repository  
touch README  
# create a file named README  
git add README    
# add README to cache  
git commit -m 'first commit'  
# commit your files to local repository  
</code></pre>

<p>然后我们将本地的文件传送至<code>github</code>中，使用如下命令：</p>

<pre><code>git remote add origin https://github.com/yourname/test.git  
git push -u origin master  
</code></pre>

<h2>从现有仓库克隆</h2>

<pre><code>git clone git://github.com/yourname/test.git
git clone git://github.com/yourname/grit.git mypro#克隆到自定义文件夹
</code></pre>

<h3>本地</h3>

<pre><code>git add *#跟踪新文件

rm *&amp;git rm *#移除文件
git rm -f *#移除文件
git rm --cached *#取消跟踪
git mv file_from file_to#重命名跟踪文件

git log#查看提交记录

git commit#提交更新
git commit -m 'message'
git commit -a#跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交
git commit --amend#修改最后一次提交

git reset HEAD *#取消已经暂存的文件

git checkout -- file#取消对文件的修改（从暂存区去除file）
git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支
git checkout -- .#从暂存区去除文件覆盖工作区
</code></pre>

<h3>分支</h3>

<pre><code>git branch#列出本地分支
git branch -r#列出远端分支
git branch -a#列出所有分支
git branch -v#查看各个分支最后一个提交对象的信息
git branch --merge#查看已经合并到当前分支的分支
git branch --no-merge#查看为合并到当前分支的分支

git branch test#新建test分支
git checkout test#切换到test分支
git checkout -b test#新建+切换到test分支
git checkout -b test dev#基于dev新建test分支，并切换

git branch -d test#删除test分支
git branch -D test#强制删除test分支

git merge test#将test分支合并到当前分支
git rebase master#将master分之上超前的提交，变基到当前分支
</code></pre>

<h2>常见错误</h2>

<p>第一个：</p>

<pre><code>error: src refspec master does not match any.
error: failed to push some refs to 'https://github.com/yourname/test.git'
</code></pre>

<p>输入如下代码：</p>

<pre><code>$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git push origin master
</code></pre>

<p>第二个：</p>

<pre><code>git push -u origin master fatal: unable to access 'https://github.com/ZeyuChen/TPlus.git/': SSLRead() return error -9806
</code></pre>

<p>这种错误就是<code>https</code>挂了，解决方案就是在<code>project</code>目录里面的<code>.git/config</code>文件里面，修改<code>repo</code>的<code>url</code>连接，从<code>https</code>修改为git协议就可以了。</p>

<p>本来是<code>url = https://github.com/ZeyuChen/TPlus.git</code></p>

<p>修改为</p>

<pre><code>[remote ""origin""]
    url = ssh://git@github.com/ZeyuChen/TPlus.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>

<p>再次<code>push</code>就ok了。</p>

<h2>Git 命令详解</h2>

<pre><code>现在我们有了本地和远程的版本库，让我们来试着用用Git的基本命令：

git pull：从其他的版本库（既可以是远程的也可以是本地的）将代码更新到本地，例如：'git pull origin master'就是将origin这个版本库的代码更新到本地的master主枝，该功能类似于SVN的update

git add：是 将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，例如'git add app/model/user.rb'就会增加app/model/user.rb文件到Git的索引中，该功能类似于SVN的add

git rm：从当前的工作空间中和索引中删除文件，例如'git rm app/model/user.rb'，该功能类似于SVN的rm、del

git commit：提交当前工作空间的修改内容，类似于SVN的commit命令，例如'git commit -m story #3, add user model'，提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit

git push：将本地commit的代码更新到远程版本库中，例如'git push origin'就会将本地的代码更新到名为orgin的远程版本库中

git log：查看历史日志，该功能类似于SVN的log

git revert：还原一个版本的修改，必须提供一个具体的Git版本号，例如'git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20'，Git的版本号都是生成的一个哈希值
</code></pre>

<p><span class=""img-wrap""><img data-src=""/img/bVla2H"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>git思维导图</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVG9M"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVmNPi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

                ", 如何在本地环境配置github,1531978084,430,1,762,1,1,https://segmentfault.com/a/1190000002533334
291,1,0,7,"
                    
<blockquote>
  <p>转自 <a rel=""nofollow"" href=""http://xydudu.calepin.co/git-server-and-hook.html"">http://xydudu.calepin.co/git-server-and-hook.html</a></p>
</blockquote>

<p>我喜欢 github，我现在的个人代码全部是托管在上面了，但是一些公司或者某些项目不适合放入github中，你希望能有一个完全私有的仓库，如果你有一台服务器，这显然是很容易办到的事。</p>

<p>下面简单的描述我在某个项目中布署的一个git服务，并且本地提交更新后，服务器将自动更新代码到在线代码的仓库。</p>

<h2>创建用户并使客户机可通过密钥登录服务器</h2>

<h3>服务器中操作</h3>

<p>root 用户ssh登录服务器，创建一个新用户用来给git登录及其操作，比如这里我创建一个名为“git”的用户：</p>

<pre><code>$ sudo add user git
</code></pre>

<p>进入到 /home/git 文件夹中，查看是否有 .ssh/ 目录， 如没有：</p>

<pre><code>$ mkdir .ssh
</code></pre>

<p>进入 /home/git/.ssh 文件夹中，创建文件 authorized_keys</p>

<p>等待</p>

<h3>客户机中操作</h3>

<p>进入 ~/.ssh/ 目录，查看是否有 id_rsa.pub 文件，如没有：</p>

<pre><code>$ ssh-keygen
</code></pre>

<p>一路回车，完成后，便可发现 ~/.ssh/ 目录中有 id_rsa.pub， 复制其内容，粘贴到上面操作服务器的 authorized_keys 文件中</p>

<p>测试是否密钥登录成功</p>

<pre><code>$ ssh git@yourserverip
</code></pre>

<h2>创建git服务器远程仓库</h2>

<p>进入 /opt/git 目录， 如没有，创建之<br>
建立仓库文件夹，比如：</p>

<pre><code>path:/opt/git $ mkdir gitdemo
</code></pre>

<p>将gitdemo用户组设置为当前用户git<br>
初始化为远程仓库</p>

<p>$ <code>git init --bare</code><br>
上面的步骤已经完成了git远程仓库的创建，此时你只要将你本地的git代码仓库 <code>git remote add git@yourserverip:/opt/git/gitdemo</code>，便可提交与更新代码了。</p>

<p>比如我机器上的开发目录为：~/www/gitdemodev， 进行下面操作：</p>

<pre><code>$ cd ~/www/gitdemodev 
$ git init  #建一个文件，写点东西进去 
$ touch README | echo 'hello git' &gt; READEME
$ git add README 
$ git remote add origin git@yourserverip:/opt/git/gitdemo 
$ git commit -m 'first commit' 
$ git push origin master
</code></pre>

<p>现在你已经本地的代码成功的提交到了远程仓库中，只需在你团队成员电脑上作相同操作，便可利用git协同开发了，注意把各自电脑的 id_rsa.pub 内容复制进服务器的 authorized_keys 文件中。</p>

<h2>git hook 自动布署代码</h2>

<p>假设你的项目也是跑在此台服务器上，那自动布署代码就很简单了，比如你的在线服务代码在 /var/www/demo 文件夹中。</p>

<p>/var/www/demo也要有写权限</p>

<p>你先初始化代码库：</p>

<pre><code>$ git clone /opt/git/gitdemo /var/www/demo
</code></pre>

<p>然后你可以通过 <code>git pull</code> 来更新代码。</p>

<p>当然这样是手动了，我想要的是本地提交更新后，服务器能自动的 git pull代码到最新，于是我们就要借助 <code>git hook</code>了。</p>

<p>进入到 /opt/git/gitdemo 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。</p>

<pre><code>$ mv post-update.sample post-update $ vim post-update
</code></pre>

<p>可以看到里面其实就是一些shell脚本，你要做的就是把 git pull写进去。当用户提交后，便会调用post-update脚本的。</p>

<p>比如我在服务器的代码库更新后，要求对应的服务代码也要更新（进行pull操作），<br>
则在bare仓库的hooks中的post-receive添加如下内容即可</p>

<pre><code>#!/bin/sh 
unset $(git rev-parse --local-env-vars)
cd WEB_DIR
git pull
</code></pre>

<p>这些脚本显然是可以做很多事的，只要你想得到，要了解各脚本何时调用，google吧。</p>

<blockquote>
  <p>注：服务器中与git用户有关的文件夹及文件，请：</p>

<pre><code>$ chown -Rh git:git /your/git/dirs
</code></pre>
</blockquote>

                ", 【转】搭建git服务器及利用git hook自动布署代码,1531978085,327,1,970,1,1,https://segmentfault.com/a/1190000002528674
292,1,0,7,"
                    
<blockquote>
  <p>译注：来自 Hacker School 的 Mary Rose Cook 实现了一个纯 JavaScript 写就的 Git：<a rel=""nofollow"" href=""http://gitlet.maryrosecook.com/"">Gitlet</a>，包含了最主要的一些命令。这个项目一是为了了解 Git 内部原理，二是希望写一篇深入浅出解释 Git 核心概念的短文。学习一件东西的原理最好的方法就是去亲自实现它，而设计精巧的 Git 核心功能代码也不过 300 行。这就是这篇精巧的小文：<a rel=""nofollow"" href=""http://maryrosecook.com/blog/post/git-in-six-hundred-words"">Git in 600 words</a>，相应的代码<a rel=""nofollow"" href=""https://github.com/maryrosecook/gitlet"">在 Github 上</a>。短文很有趣，思路清晰也足够深入，值得一看。</p>
</blockquote>

<p>设想你现在位于 <code>alpha/</code> 目录下，这里有一个文本文件 <code>number.txt</code>，里面的内容只有一个词：“first”。</p>

<p>现在执行 <code>git init</code> 将这个 alpha 文件夹初始化为 Git 仓库。</p>

<p>执行 <code>git add number.txt</code> 会将 <code>number.txt</code> 添加到 Git 的索引（index）中。这个索引记录了所有 Git 保持追踪的文件，现在它有了一个映射记录 <code>number.txt -&gt; first</code>，同时 <code>add</code> 命令还会把一个包含了 <code>first</code> 字符串的二进制对象加入 Git 的对象数据库里。</p>

<p>现在执行 <code>git commit -m first</code>。这条命令会做三件事情。首先在对象数据库内创建一个树对象，用以记录 <code>alpha</code> 目录下的文件列表，这个对象有一个指针指向前面 <code>git add</code> 命令创建的 <code>first</code> 二进制对象；第二，这条命令还会创建一个 commit 对象用以代表刚刚提交的版本，它包含一个指针指向刚刚的树对象；第三，master 分支也会指向这个新创建的 commit 对象。</p>

<p>现在执行 <code>git clone . ../beta</code>。它会创建一个新目录 beta 并将其初始化为 Git 仓库，然后把 alpha 仓库的对象数据库中所有对象拷贝给 beta 的对象数据库，将 beta 的 master 分支像 alpha 的 master 一样指向相应的对象。它还根据 <code>first</code> 提交的内容配置索引，并根据索引更新目录下的文件——也就是 <code>number.txt</code>。</p>

<p>现在切换到 beta 目录，修改 <code>number.txt</code> 的内容为“second”，执行 <code>git add number.txt</code> 和 <code>git commit -m second</code>，新创建的提交对象 second（译注：姑且称之为 second）会有一个指向父提交（first）的指针，表示 second 继承自 first，而 master 分支则指向 second 提交。</p>

<p>回到 alpha 目录，执行 <code>git remote add beta ../beta</code>，将 beta 仓库设为远程仓库。然后执行 <code>git pull beta master</code>。</p>

<p>在这条命令背后，它其实会执行 <code>git fetch beta master</code>，从 beta 仓库中找到 second 提交的相关对象拷贝到 alpha 仓库；把 alpha 中关于 beta 的 master 分支记录指向这个 second 提交；更新 <code>FETCH_HEAD</code> 指向刚刚从 beta 仓库拉取的 master 分支，还是这个 second 提交。</p>

<p>此外，<code>pull</code> 命令还会执行 <code>git merge FETCH_HEAD</code>。从 <code>FETCH_HEAD</code> 得知最近拉取的分支是 beta 仓库的 master 分支，据此拿到相应的对象，也就是 second 提交对象。此时 alpha 的 master 分支指着 first 提交，正好是 second 的祖先提交，于是对于 merge 命令来说只需要将 master 分支指向 second 提交即可。接下来 <code>merge</code> 命令还会更新索引以匹配 second 提交的内容，并且相应更新工作目录中的文件。</p>

<p>现在执行 <code>git branch red</code>，创建一个名为“red”、指向 second 提交的新分支。</p>

<p>然后执行 <code>git checkout red</code>。在 checkout 之前，<code>HEAD</code> 指向 master 分支，执行命令之后它就指向了 red 分支，使得 red 成为当前分支。</p>

<p>接下来把 <code>number.txt</code> 的内容修改为 “third”，执行 <code>git add numbers.txt</code> 和 <code>run git commit -m third</code>。</p>

<p>之后再执行 <code>git push beta red</code>，这条命令会把 alpha 仓库内跟 third 提交相关的对象拷贝至 beta 仓库，并且将（alpha 仓库内记录的）beta 仓库 red 分支指向 third 提交。就酱。</p>

                ", 六百字读懂 Git,1531978087,524,1,140,1,1,https://segmentfault.com/a/1190000002514702
293,1,0,7,"
                    
<p>好东西，收藏。转<a rel=""nofollow"" href=""http://sspai.com/27888"">干掉鼠标！用这 4 款 App 大幅提升 Mac 键盘效率</a></p>

<p>在一开始，个人电脑是不支持「鼠标」的，所有用户必须通过输入单调、复杂的命令，才能实现最基本的功能，也正是这个原因，当时的科学家急需要发展出一个更加简单易用的衍生品，降低「电脑」的使用门槛并面向大众。所以，鼠标就诞生了。的确，它的出现不仅让电脑成为一个遍及全球的人性化工具，同时也造就了更多当时想都不敢想的产品，比如你可能正在使用的 Trackpad、Magic Mouse 多点触控设备，或是电容手写笔，或是像 <a rel=""nofollow"" href=""http://www.3dconnexion.com.cn/"">3DConnexion</a> 那样的全功能鼠标等。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>可是，很多时候，鼠标并不见得有那么好用。对大部分人而言，想要关闭一个窗口、打开一款程序、移动一组文件、激活一项功能，似乎都离不开鼠标。理由也很简单，因为鼠标使用起来非常方便，用的时间久了，难免会产生一种依赖感，让人欲罢不能。毋庸置疑，这是最正常不过的表现：什么东西好用，人们就会很自然地将其列为「常用工具」。但很多人没有想过，随着科学技术的发展，键盘的作用发生了根本性的转变，它，也一直在进步，可习惯了「鼠标」的用户哪里还会考虑这位昔日的「老友」呢？</p>

<p>按照最寻常的使用习惯，Mac 用户想要打开一款应用程序，首先要做得就是移动鼠标，然后在 Dock 栏（或是进入 Launchpad 界面）找寻目标并点击，完成一套连贯的操作。排除可能存在的干扰因素，整个过程大约需要 2~3 秒左右。如果改用 Spotlight 操作，其实时间也差不多，没有明显地提升效率。那么这时候，就有必要去考虑第三方应用了。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<hr>
<h1><a rel=""nofollow"" href=""http://manico.im/"">Manico</a></h1>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>由国内独立开发者制作的 Launcher &amp; Switcher 应用。通过它，我们可以经由键盘组合键，快速打开已经设置过的 Apps 列表，代替鼠标操作。只要你能牢记快捷键方案，那么整个过程只需 0.5~1 秒。虽然是个非常短暂的时间，但每人每天需要打开的应用数量可以高达几十次，因此综合统计后，它也能有效地提高效率。</p>

<hr>
<h1><a rel=""nofollow"" href=""http://www.alfredapp.com/"">Alfred</a></h1>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>由国外开发商制作的 Launcher, Workflows &amp; Manager 应用。如果 Manico 的功能不够丰富，或者你也可以说「它的功能是非常有限的」，那么 Alfred 则是个更好的选择。除了单纯的应用启动，它还能进行提取，以运行更多关联的操作，例如：打开方式、添加至 Email 附件、移动、拷贝、删除等。整个过程同样只靠键盘实现，而达到的目的却和鼠标完全相同。基于这些条件，Alfred 也当之无愧地成为了效率用户皆知的「神级」工具。</p>

<p><strong>关联阅读：</strong></p>

<ul>
<li><a rel=""nofollow"" href=""http://sspai.com/27900"">《OS X 效率启动器 Alfred 详解与使用技巧》</a></li>
<li><a rel=""nofollow"" href=""http://sspai.com/27854"">《OS X 效率启动器 Alfred 的 5 个实用扩展推荐》</a></li>
</ul>
<hr>
<h1><a rel=""nofollow"" href=""http://www.bettertouchtool.net/"">BetterTouchTool</a></h1>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p><strong>在对比了很多已上市，或正在测试的操作系统，不难发现 OS X 从一开始就希望用户把重点从「鼠标」转至「键盘」。</strong>你看，每款应用的菜单栏里，开发者都会尽可能地为其赋予快捷键，并让它们可视化。尽管有很多方案显得滑稽可笑又难用，但同时也侧面点明了 Apple 对于「人性化操作」的定义。而 Option 键作为开启 App 另一面的神奇钥匙，既可以让用户多一些选择，也强化了 Select 与 Click 的区别（相信你能明白我的意思）。不得不说，Apple 下的这盘棋真的是太大了！</p>

<p>刚才说过，有时你难免会碰到一些啼笑皆非的操作方案，可笑过之后，该面对的还是必须得去面对。<strong>此时作为用户的我们，还能完成些其它有实际帮助的举措吗？当然，比如一款叫 <a rel=""nofollow"" href=""http://www.bettertouchtool.net/"">BetterTouchTool</a> 的第三方应用。</strong>概括地说，它允许使用者针对应用、系统的每个操作进行定制，其范围大到可以同时包含鼠标、触摸板、键盘、遥控器、伴随应用，甚至是体感控制器。只要能提取到快捷键，那就可以直接无视指定操作，然后随心所欲地进行修改，Just like God。</p>

<p><strong>关联阅读：</strong></p>

<ul>
<li><a rel=""nofollow"" href=""http://sspai.com/27094"">《Mac 触摸板增强神器：BetterTouchTool 上手指南》</a></li>
<li><a rel=""nofollow"" href=""http://sspai.com/27105"">《Mac 触摸板增强神器：BetterTouchTool 进阶指南》</a></li>
</ul>
<p><a rel=""nofollow"" href=""http://cdn.sspai.com/attachment/thumbnail/2015/01/07/160e58e93972635283a4061a27210076_mw_800_wm_1_wmp_3.png""><img alt=""""></a></p>

<hr>
<h1><a rel=""nofollow"" href=""https://shortcatapp.com/"">Shortcat</a></h1>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpx"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>BetterTouchTool 的效率确实很高，可仍有不乏极端的人会反驳到：<strong>要是你不知道默认快捷键，那就没办法修改，也提高不了效率，最后还是白搭，不是嘛？</strong>对此，我也会极（rèn）端（xìng）地回答道：那是因为你不知道 Mac 上还有款叫 <a rel=""nofollow"" href=""https://shortcatapp.com/"">Shortcat</a> 的软件。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p><strong>看到官方标语了嘛？Killing Mice，直接翻译过来就是：干掉老鼠（鼠标）。</strong>我猜，这应该就是开发商把图标做成「猫」的原因吧。既然目标已经明确，那它的实际表现如何呢？类似于 Alfred 应用，Shortcat 同样以「小窗口」为中心，通过分析用户输入的关键字/词，查找当前界面中的所有相关元素，再通过即时生成的快捷键，模拟鼠标操作，最后实现点击。因此，我们也可以把 Shortcat 理解为：可以控制鼠标的工具。开发商美其名曰：<strong>Click with the keyboard。</strong></p>

<p><span class=""img-wrap""><img data-src=""/img/bVkzpE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<hr>
<p>不得不承认，就目前的发展趋势观望，键盘很难代替鼠标，而在个人电脑领域，触摸屏的加入无疑让这件事变得更加多元化，从细节讨论，<a rel=""nofollow"" href=""https://itunes.apple.com/us/app/popclip/id445189367?mt=12&amp;uo=4&amp;at=10lJSw"">PopClip for Mac</a> 不正是为此量身打造的嘛？在程序员的世界里，他们很讨厌在敲码的过程中接触鼠标，这不仅会让人分心，更容易在相对的情况下浪费本可以节省的时间。而另一个极端环境就是，设计师在制图时可以做到完全不用键盘......</p>

<p><strong>如果你是位用键盘多于鼠标、重视整体效率的用户，那就非常有必要去琢磨，应该如何避免在设备间反复切换，反之亦此。</strong></p>

<hr>
<h3>其他相关阅读：</h3>

<ul>
<li><a rel=""nofollow"" href=""http://sspai.com/26632"">OS X 是了不起的操作系统：效率启动器 Launchbar 6 体验详解</a></li>
<li><a rel=""nofollow"" href=""http://sspai.com/27512"">LaunchBar 6 的六个实用小技巧</a></li>
<li><a rel=""nofollow"" href=""http://sspai.com/27842"">LaunchBar 6 实用技巧：全能搜索、优化系统声音控制</a></li>
<li><a rel=""nofollow"" href=""http://sspai.com/27734"">让 Mac 上的 Spotlight 更强大：Flashlight 拓展插件</a></li>
</ul>

                ", 干掉鼠标！用这 4 款 App 大幅提升 Mac 键盘效率,1531978088,487,1,750,1,1,https://segmentfault.com/a/1190000002487969
294,1,0,7,"
                    
<p>这里是我的笔记，记录一些git常用和一些记不住的命令，这个笔记原本是基于 <a href=""http://yanhaijing.com/git/2014/11/01/my-git-note"" rel=""nofollow noreferrer"">颜海镜的文章</a>增加的，后面慢慢增加了许多内容，可以看出的的学习轨迹。分享出来方便自己查看，也许能帮助到你。</p>
<p>笔记在这里持续更新 <a href=""https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md"" rel=""nofollow noreferrer"">Git常用命令清单笔记</a></p>
<h2>参考资料</h2>
<ul>
<li><a href=""http://git-scm.com/"" rel=""nofollow noreferrer"">Git官网</a></li>
<li><a href=""https://try.github.io"" rel=""nofollow noreferrer""><strong>Github 15分钟学习Git</strong></a></li>
<li><a href=""http://gitref.org/zh/index.html"" rel=""nofollow noreferrer"">Git参考手册</a></li>
<li><a href=""http://www.mceiba.com/tool/git-cheat-sheet.html"" rel=""nofollow noreferrer"">Git简明手册</a></li>
<li><a href=""http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/"" rel=""nofollow noreferrer"">Git Magic</a></li>
<li><a href=""http://gitbook.liuhui998.com/index.html"" rel=""nofollow noreferrer"">Git Community Book 中文版</a></li>
<li><a href=""http://git-scm.com/book/en/v2"" rel=""nofollow noreferrer"">Pro Git</a></li>
<li><a href=""http://marklodato.github.io/visual-git-guide/index-zh-cn.html"" rel=""nofollow noreferrer"">图解Git</a></li>
<li><a href=""http://rogerdudler.github.io/git-guide/index.zh.html"" rel=""nofollow noreferrer"">git-简明指南</a></li>
<li><a href=""http://pcottle.github.io/learnGitBranching/"" rel=""nofollow noreferrer"">learnGitBranching 在线学习工具</a></li>
<li><a href=""http://rogerdudler.github.io/git-guide/index.zh.html"" rel=""nofollow noreferrer"">初级教程</a></li>
<li><a href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"" rel=""nofollow noreferrer"">廖雪峰的Git教程</a></li>
<li><a href=""http://www.worldhello.net/gotgithub/"" rel=""nofollow noreferrer"">蒋鑫老师将带你入github的大门</a></li>
<li><a href=""http://www.open-open.com/lib/view/open1328069609436.html"" rel=""nofollow noreferrer"">git详解</a></li>
<li><a href=""http://git.oschina.net/progit/"" rel=""nofollow noreferrer"">oschina教程</a></li>
<li><a href=""https://github.com/blog/2019-how-to-undo-almost-anything-with-git"" rel=""nofollow noreferrer"">How to undo (almost) anything with Git撤销一切，汇总各种回滚撤销的场景，加强学习。</a></li>
<li><a href=""http://www.runoob.com/git/git-tutorial.html"" rel=""nofollow noreferrer"">Git 教程 | 菜鸟教程runoob.com</a></li>
</ul>
<h2>配置</h2>
<p>首先是配置帐号信息  <br><code>ssh -T git@github.com</code> #登陆github</p>
<h2>修改项目中的个人信息</h2>
<p><code>$ git config --global user.name ""wirelessqa""</code>  <br><code>$ git config --global user.email wirelessqa.me@gmail.com</code></p>
<h3>config</h3>
<p><code>git config --global user.name JSLite</code> #设置提交用户名  <br><code>git config --global user.email JSLite@yeah.net</code> #设置提交邮箱  <br><code>git config --list</code> #查看配置的信息  <br><code>git remote remove origin</code> #删除该远程路径  <br><code>git remote add origin git@jslite.github.com:JSLite/JSLite.git</code> #添加远程路径</p>
<h3>help</h3>
<p><code>git help config</code> #获取帮助信息</p>
<h3>配置自动换行（自动转换坑太大）</h3>
<p><code>git config --global core.autocrlf input</code> #提交到git是自动将换行符转换为lf</p>
<h3>配置密钥</h3>
<p><code>ssh-keygen -t rsa -C JSLite@yeah.net</code> #生成密钥  <br><code>ssh -T git@github.com</code> #测试是否成功</p>
<h2>多账号ssh配置</h2>
<h3>1.生成指定名字的密钥</h3>
<p><code>ssh-keygen -t rsa -C ""邮箱地址"" -f ~/.ssh/github_jslite</code>  <br>会生成 <code>github_jslite</code> 和 <code>github_jslite.pub</code> 这两个文件</p>
<h3>2.密钥复制到托管平台上</h3>
<p><code>vim ~/.ssh/github_jslite.pub</code>   <br>打开公钥文件 <code>github_jslite.pub</code> ，并把内容复制至代码托管平台上</p>
<h3>3.修改config文件</h3>
<p><code>vim ~/.ssh/config</code> #修改config文件，如果没有创建 <code>config</code></p>
<pre><code>Host jslite.github.com
HostName github.com
User git
IdentityFile ~/.ssh/github_jslite

Host abc.github.com
HostName github.com
User git
IdentityFile ~/.ssh/github_abc</code></pre>
<h3>4.测试</h3>
<p><code>ssh -T git@jslite.github.com</code> # <code>@</code>后面跟上定义的Host</p>
<h2>Git推向3个库</h2>
<h3>增加3个远程库地址</h3>
<p><code>git remote add origin https://github.com/JSLite/JSLite.git</code>   <br><code>git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git</code>   <br><code>git remote set-url --add origin https://oschina.net/wang/JSLite.js.git</code></p>
<h3>删除其中一个 set-url 地址</h3>
<pre><code class=""shell"">usage: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]
   or: git remote set-url --add &lt;name&gt; &lt;newurl&gt;
   or: git remote set-url --delete &lt;name&gt; &lt;url&gt;</code></pre>
<p><code>git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git</code></p>
<h3>push</h3>
<p><code>git push origin master</code>  <br><code>git push -f origin master</code>  #强制推送</p>
<ol>
<li>缩写 -f</li>
<li>全写--force</li>
<li>注：强制推送文件没有了哦</li>
</ol>
<h3>pull</h3>
<p>只能拉取 <code>origin</code> 里的一个url地址，这个fetch-url  <br>默认为你添加的到 <code>origin</code>的第一个地址  </p>
<p><code>git pull origin master</code>   <br><code>git pull --all</code> #获取远程所有内容包括tag  <br><code>git pull origin next:master</code> #取回origin主机的next分支，与本地的master分支合并  <br><code>git pull origin next</code> #远程分支是与当前分支合并  </p>
<p>上面一条命令等同于下面两条命令   <br><code>git fetch origin</code>  <br><code>git merge origin/next</code>  </p>
<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。  <br>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>
<pre><code>$ git pull -p
# 等同于下面的命令
$ git fetch --prune origin 
$ git fetch -p</code></pre>
<h3>更改pull</h3>
<p>只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。</p>
<h2>新建仓库</h2>
<h3>init</h3>
<p><code>git init</code> #初始化</p>
<h3>status</h3>
<p><code>git status</code> #获取状态</p>
<h3>add</h3>
<p><code>git add file</code> #.或*代表全部添加  <br><code>git rm --cached &lt;added_file_to_undo&gt;</code> 在commit之前撤销git add操作  <br><code>git reset head</code> 好像比上面<code>git rm --cached</code>更方便</p>
<h3>commit</h3>
<p><code>git commit -m ""message""</code> #此处注意乱码</p>
<h3>remote</h3>
<p><code>git remote add origin git@github.com:JSLite/test.git</code> #添加源</p>
<h3>push</h3>
<p><code>git push -u origin master</code> #push同事设置默认跟踪分支  <br><code>git push origin master</code></p>
<h2>从现有仓库克隆</h2>
<p><code>git clone git://github.com/JSLite/JSLite.js.git </code>  <br><code>git clone git://github.com/JSLite/JSLite.js.git mypro</code> #克隆到自定义文件夹  <br><code>git clone [user@]example.com:path/to/repo.git/</code> #SSH协议还有另一种写法。  </p>
<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。<code>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></p>
<pre><code>$ git clone http[s]://example.com/path/to/repo.git/
$ git clone ssh://example.com/path/to/repo.git/
$ git clone git://example.com/path/to/repo.git/
$ git clone /opt/git/project.git 
$ git clone file:///opt/git/project.git
$ git clone ftp[s]://example.com/path/to/repo.git/
$ git clone rsync://example.com/path/to/repo.git/</code></pre>
<h2>submodule</h2>
<p><code>git submodule add --force 仓库地址 路径</code>   <br>其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。  <br>注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）  <br><code>git submodule init</code> 初始化submodule   <br><code>git submodule update</code> 更新submodule(必须在根目录执行命令)  </p>
<p>当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：   <br><code>git submodule update --init --recursive</code> 下载的工程带有submodule   </p>
<p><code>git submodule foreach git pull</code> submodule 里有其他的 submodule 一次更新  <br><code>git submodule foreach git pull origin master</code> submodule更新  </p>
<p><code>git submodule foreach --recursive git submodule init</code>   <br><code>git submodule foreach --recursive git submodule update</code></p>
<h2>本地</h2>
<h3>add</h3>
<p><code>git add *</code> #跟踪新文件   <br><code>git add -u [path]</code> #添加[指定路径下]已跟踪文件</p>
<h3>rm</h3>
<p><code>rm *&amp;git rm *</code> #移除文件  <br><code>git rm -f *</code> #移除文件  <br><code>git rm --cached *</code> #取消跟踪  <br><code>git mv file_from file_to</code> #重命名跟踪文件  <br><code>git log</code> #查看提交记录</p>
<h3>commit</h3>
<p><code>git commit</code> #提交更新   <br><code>git commit -m 'message'</code> #提交说明   <br><code>git commit -a</code> #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交   <br><code>git commit --amend</code> #修改最后一次提交   <br><code>git commit log</code> #查看所有提交，包括没有push的commit    <br><code>git commit -m ""#133""</code> #关联issue 任意位置带上<code>#</code> 符号加上issue号码  <br><code>git commit -m ""fix #133""</code> commit关闭issue  <br><code>git commit -m '概要描述'$'\n\n''1.详细描述'$'\n''2.详细描述'</code> #提交简要描述和详细描述</p>
<h3>reset</h3>
<p><code>git reset HEAD</code> *#取消已经暂存的文件   <br><code>git reset --mixed HEAD </code> *#同上   <br><code>git reset --soft HEAD </code> *#重置到指定状态，不会修改索引区和工作树   <br><code>git reset --hard HEAD </code> *#重置到指定状态，会修改索引区和工作树   <br><code>git reset -- files</code> *#重置index区文件   <br>那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue:</p>
<ol>
<li>fixes #xxx</li>
<li>fixed #xxx</li>
<li>fix #xxx</li>
<li>closes #xxx</li>
<li>close #xxx</li>
<li>closed #xxx</li>
</ol>
<h3>revert</h3>
<p><code>git revert HEAD</code> #撤销前一次操作   <br><code>git revert HEAD~</code> #撤销前前一次操作   <br><code>git revert commit</code> ##撤销指定操作</p>
<h3>checkout</h3>
<p><code>git checkout -- file</code> #取消对文件的修改（从暂存区——覆盖worktree file）  <br><code>git checkout branch|tag|commit -- file_name</code> #从仓库取出file覆盖当前分支   <br><code>git checkout HEAD~1 [文件]</code> #将会更新 working directory 去匹配某次 commit   <br><code>git checkout -- .</code> #从暂存区取出文件覆盖工作区   <br><code>git checkout -b gh-pages  0c304c9</code>  这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages</p>
<h3>diff</h3>
<p><code>git diff file</code> #查看指定文件的差异   <br><code>git diff --stat</code> #查看简单的diff结果   <br><code>git diff</code> #比较Worktree和Index之间的差异   <br><code>git diff --cached</code> #比较Index和HEAD之间的差异   <br><code>git diff HEAD</code> #比较Worktree和HEAD之间的差异   <br><code>git diff branch</code> #比较Worktree和branch之间的差异   <br><code>git diff branch1 branch2</code> #比较两次分支之间的差异   <br><code>git diff commit commit</code> #比较两次提交之间的差异   <br><code>$ git diff master..test</code> #上面这条命令只显示两个分支间的差异  <br><code>git diff master...test</code> #你想找出‘master’,‘test’的共有 父分支和'test'分支之间的差异，你用3个‘.'来取代前面的两个'.'</p>
<h3>stash</h3>
<p><code>git stash</code> #将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。   <br><code>git stash list</code> #查看保存的工作现场   <br><code>git stash apply</code> #恢复工作现场   <br><code>git stash drop</code> #删除stash内容   <br><code>git stash pop</code> #恢复的同时直接删除stash内容   <br><code>git stash apply stash@{0}</code> #恢复指定的工作现场，当你保存了不只一份工作现场时。</p>
<h3>merge</h3>
<p><code>git merge --squash test</code> ##合并压缩，将test上的commit压缩为一条</p>
<h3>cherry-pick</h3>
<p><code>git cherry-pick commit</code> #拣选合并，将commit合并到当前分支   <br><code>git cherry-pick -n commit</code> #拣选多个提交，合并完后可以继续拣选下一个提交</p>
<h3>rebase</h3>
<p><code>git rebase master</code> #将master分之上超前的提交，变基到当前分支  <br><code>git rebase --onto master 169a6</code> #限制回滚范围，rebase当前分支从169a6以后的提交  <br><code>git rebase --interactive</code> #交互模式，修改commit   <br><code>git rebase --continue</code> #处理完冲突继续合并   <br><code>git rebase --skip</code> #跳过   <br><code>git rebase --abort</code> #取消合并</p>
<h2>分支branch</h2>
<h3>删除</h3>
<p><code>git push origin :branchName</code> #删除远程分支  <br><code>git push origin --delete new</code> #删除远程分支<code>new</code>   <br><code>git branch -d branchName</code> #删除本地分支，强制删除用-D  <br><code>git branch -d test</code> #删除本地test分支   <br><code>git branch -D test</code> #强制删除本地test分支</p>
<h3>提交</h3>
<p><code>git push -u origin branchName</code> #提交分支到远程origin主机中</p>
<h3>拉取</h3>
<p><code>git fetch -p</code> #拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。</p>
<h3>分支合并</h3>
<p><code>git merge branchName</code> #合并分支 - 将分支branchName和当前所在分支合并   <br><code>git merge origin/master</code> #在本地分支上合并远程分支。   <br><code>git rebase origin/master</code> #在本地分支上合并远程分支。   <br><code>git merge test</code> #将test分支合并到当前分支</p>
<h3>重命名</h3>
<p><code>git branch -m old new</code> #重命名分支</p>
<h3>查看</h3>
<p><code>git branch</code> #列出本地分支   <br><code>git branch -r</code> #列出远端分支   <br><code>git branch -a</code> #列出所有分支   <br><code>git branch -v</code> #查看各个分支最后一个提交对象的信息   <br><code>git branch --merge</code> #查看已经合并到当前分支的分支   <br><code>git branch --no-merge</code> #查看为合并到当前分支的分支</p>
<h3>新建</h3>
<p><code>git branch test</code> #新建test分支  <br><code>git checkout -b newBrach origin/master</code> #取回远程主机的更新以后，在它的基础上创建一个新的分支</p>
<h3>连接</h3>
<p><code>git branch --set-upstream dev origin/dev</code> #将本地dev分支与远程dev分支之间建立链接  <br><code>git branch --set-upstream master origin/next</code> #手动建立追踪关系</p>
<h3>分支切换</h3>
<p><code>git checkout test</code> #切换到test分支   <br><code>git checkout -b test</code> #新建+切换到test分支   <br><code>git checkout -b test dev</code> #基于dev新建test分支，并切换</p>
<h2>远端</h2>
<p><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code>  #fetch取回所有分支（branch）的更新  <br><code>git fetch origin remotebranch[:localbranch]</code> # 从远端拉去分支[到本地指定分支]   <br><code>git merge origin/branch</code> #合并远端上指定分支   <br><code>git pull origin remotebranch:localbranch</code> # 拉去远端分支到本地分支   <br><code>git push origin branch</code> #将当前分支，推送到远端上指定分支   <br><code>git push origin localbranch:remotebranch</code> #推送本地指定分支，到远端上指定分支   <br><code>git push origin :remotebranch</code> #删除远端指定分支   <br><code>git checkout -b [--track] test origin/dev</code> 基于远端dev分支，新建本地test分支[同时设置跟踪]</p>
<h3>撤销远程记录</h3>
<p><code>git reset --hard HEAD~1</code> #撤销一条记录   <br><code>git push -f origin HEAD:master</code> #同步到远程仓库</p>
<h2>忽略文件</h2>
<p><code>echo node_modules/ &gt;&gt; .gitignore</code></p>
<h2>删除文件</h2>
<p><code>git rm -rf node_modules/</code></p>
<h2>源remote</h2>
<p>git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。  <br>个人开发时，多源用的可能不多，但多源其实非常有用。  <br><code>git remote add origin1 git@github.com:yanhaijing/data.js.git</code>  <br><code>git remote</code> #显示全部源  <br><code>git remote -v</code> #显示全部源+详细信息  <br><code>git remote rename origin1 origin2</code> #重命名  <br><code>git remote rm origin</code> #删除  <br><code>git remote show origin</code> #查看指定源的全部信息</p>
<h2>同步一个fork</h2>
<p><a href=""https://help.github.com/articles/syncing-a-fork/"" rel=""nofollow noreferrer"">github教程</a>  <br><a href=""http://www.miss77.net/549.html"" rel=""nofollow noreferrer"">在github上同步一个分支(fork)</a></p>
<h3>设置</h3>
<p>在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。</p>
<pre><code class=""shell"">$ git remote -v
# List the current remotes （列出当前远程仓库）
# origin  https://github.com/user/repo.git (fetch)
# origin  https://github.com/user/repo.git (push)
$ git remote add upstream https://github.com/otheruser/repo.git
# Set a new remote (设置一个新的远程仓库)
$ git remote -v
# Verify new remote (验证新的原唱仓库)
# origin    https://github.com/user/repo.git (fetch)
# origin    https://github.com/user/repo.git (push)
# upstream  https://github.com/otheruser/repo.git (fetch)
# upstream  https://github.com/otheruser/repo.git (push)</code></pre>
<h3>同步</h3>
<p>同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。</p>
<p>从上游的存储库中提取分支以及各自的提交内容。 <code>master</code> 将被存储在本地分支机构 <code>upstream/master</code></p>
<pre><code class=""shell"">git fetch upstream
# remote: Counting objects: 75, done.
# remote: Compressing objects: 100% (53/53), done.
# remote: Total 62 (delta 27), reused 44 (delta 9)
# Unpacking objects: 100% (62/62), done.
# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY
#  * [new branch]      master     -&gt; upstream/master</code></pre>
<p>检查你的 fork's 本地 <code>master</code> 分支</p>
<pre><code class=""shell"">git checkout master
# Switched to branch 'master'</code></pre>
<p>合并来自 <code>upstream/master</code> 的更改到本地 master  分支上。  这使你的前 fork's <code>master</code> 分支与上游资源库同步，而不会丢失你本地修改。</p>
<pre><code class=""shell"">git merge upstream/master
# Updating a422352..5fdff0f
# Fast-forward
#  README                    |    9 -------
#  README.md                 |    7 ++++++
#  2 files changed, 7 insertions(+), 9 deletions(-)
#  delete mode 100644 README
#  create mode 100644 README.md</code></pre>
<h2>标签tag</h2>
<p>当开发到一定阶段时，给程序打标签是非常棒的功能。  <br><code>git tag</code> #列出现有标签   <br><code>git tag v0gi.1</code> #新建标签   <br><code>git tag -a v0.1 -m 'my version 1.4'</code> #新建带注释标签   <br><code>git checkout tagname</code> #切换到标签   <br><code>git push origin v1.5</code> #推送分支到源上   <br><code>git push origin --tags</code> #一次性推送所有分支   <br><code>git tag -d v0.1</code> #删除标签   <br><code>git push origin :refs/tags/v0.1</code> #删除远程标签   <br><code>git pull --all</code> #获取远程所有内容包括tag  <br><code>git --git-dir='&lt;绝对地址&gt;/.git' describe --tags HEAD</code> #查看本地版本信息</p>
<h2>日志log</h2>
<p><code>git config format.pretty oneline</code>  #显示历史记录时，每个提交的信息只显示一行   <br><code>git config color.ui true</code> #彩色的 git 输出   <br><code>git log</code> #查看最近的提交日志   <br><code>git log --pretty=oneline</code> #单行显示提交日志   <br><code>git log --graph --pretty=oneline --abbrev-commit</code>   <br><code>git log -num</code> #显示第几条log（倒数）   <br><code>git reflog</code> #查看所有分支的所有操作记录   <br><code>git log --since=1.day</code> #一天内的提交；你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。   <br><code>git log --pretty=""%h - %s"" --author=自己的名字</code> #查看自己的日志   <br><code>git log -p -2</code> #展开两次更新显示每次提交的内容差异   <br><code>git log --stat</code> #要快速浏览其他协作者提交的更新都作了哪些改动   <br><code>git log --pretty=format:""%h - %an, %ar : %s""</code>#定制要显示的记录格式   <br><code>git log --pretty=format:'%h : %s' --date-order --graph</code>#拓扑顺序展示   <br><code>git log --pretty=format:'%h : %s - %ad' --date=short</code> #日期YYYY-MM-DD显示   <br><code>git log &lt;last tag&gt; HEAD --pretty=format:%s</code> 只显示commit</p>
<table>
<thead><tr>
<th>选项</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>%H</td>
<td>提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h</td>
<td>提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T</td>
<td>树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t</td>
<td>树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P</td>
<td>父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p</td>
<td>父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）的名字</td>
</tr>
<tr>
<td>%ae</td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 -date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn</td>
<td>提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce</td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd</td>
<td>提交日期</td>
</tr>
<tr>
<td>%cr</td>
<td>提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<h2>重写历史</h2>
<p><code>git commit --amend</code> #改变最近一次提交  <br><code>git rebase -i HEAD~3</code> #修改最近三次的提交说明，或者其中任意一次  <br><code>git commit --amend</code> #保存好了，这些指示很明确地告诉了你该干什么  <br><code>git rebase --continue</code> 修改提交说明，退出编辑器。</p>
<pre><code>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
<p>改成</p>
<pre><code>pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</code></pre>
<h2>查看某个文件历史</h2>
<p><code>git log --pretty=oneline 文件名</code> #列出文件的所有改动历史  <br><code>git show c178bf49</code> #某次的改动的修改记录  <br><code>git log -p c178bf49 </code> #某次的改动的修改记录  <br><code>git blame 文件名</code> #显示文件的每一行是在那个版本最后修改。  <br><code>git whatchanged 文件名</code> #显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节）</p>
<h2>打造自己的git命令</h2>
<pre><code class=""sh"">git config --global alias.st status
git config --global alias.br branch
git config --global alias.co checkout
git config --global alias.ci commit</code></pre>
<p>配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：</p>
<pre><code class=""sh"">git st</code></pre>
<h2>总结</h2>
<p><code>git help *</code> #获取命令的帮助信息  <br><code>git status</code> #获取当前的状态，非常有用，因为git会提示接下来的能做的操作</p>
<h2>报错</h2>
<ol>
<li>
<code>git fatal: protocol error: bad line length character: No s</code> 解决办法：更换remote地址为 <code>http/https</code> 的</li>
<li>
<code>The requested URL returned error: 403 Forbidden while accessing</code>解决github push错误的办法</li>
</ol>
<p>解决方案：</p>
<pre><code class=""bash"">#vim 编辑器打开 当前项目中的config文件
vim .git/config

#修改
[remote ""origin""]  
    url = https://github.com/jaywcjlove/example.git  

#为下面代码
[remote ""origin""]  
    url = https://jaywcjlove@github.com/jaywcjlove/example.git  </code></pre>

                ", Git常用命令清单笔记,1531978089,314,1,531,1,1,https://segmentfault.com/a/1190000002479970
295,1,0,7,"
                    
<p>原文：<a href=""https://github.com/blog/1939-how-github-uses-github-to-document-github"" rel=""nofollow noreferrer"">https://github.com/blog/1939-...</a><br>译者：@公子</p>
<hr>
<p>一份好的文档能够帮助人们理解，使用以及贡献代码到你的项目中，但这只是一个生成文档的方程式的一半。生成文档的底层系统使得人们，无论是你还是一块和你工作的团队，撰写文档变得更加容易。</p>
<p>撰写文档最难的一部分既不是编写配置工具，也不是说明项目应该如何搭建和升级，而应该是文档的遣词造句。Github 文档团队的成员大多都是有使用XML文档生成工具和复杂的CMS系统背景的。正因为他们饱受了这些工具的折磨，所以为了不再使用这些工具我们花费了大量的时间去思考我们自己的文档生成流程和设置。</p>
<p>我们之前已经讨论过我们如何使用 Github 建立 Github 了。在这里我们将着重讨论一下我们如何使用 <a href=""https://pages.github.com/"" rel=""nofollow noreferrer"">Github Page</a> 服务运行 <a href=""https://help.github.com/"" rel=""nofollow noreferrer"">Github 帮助文档</a> （目前每月有上百万的访问量）的。</p>
<h2>我们以前的流程</h2>
<p>几个月前，我们把帮助文档的地层从 <a href=""http://rubyonrails.org/"" rel=""nofollow noreferrer"">Rails</a> 程序迁移到 <a href=""http://jekyllrb.com/"" rel=""nofollow noreferrer"">Jekyll</a> 托管在了 Github Pages 上。之前我们的帮助文档需要两个相互独立的项目仓库：</p>
<ul>
<li>用于托管维护网站、管理网站所用资源和文档搜索增强的 Rails 应用程序</li>
<li>用户托管由一大堆 Markdown 文件组成的网站具体内容</li>
</ul>
<p>我们的 Rails 应用程序托管在一个第三方平台上。随着对代码的日益升级，我们将它部署在了 <a href=""https://hubot.github.com/"" rel=""nofollow noreferrer"">Hubot</a> ，这些都是我们在维护 Github 主站的闲暇之余完成的。（译者注：Hubot 是 Github 开源的一款自动化智能化执行命令的机器人项目，具体刻参考 Hubot 的主页。）</p>
<p>我们正常的撰写流程可能是这个样子的：</p>
<ol>
<li>当有新特征开发出来的时候文档团队首先编写好文档内容</li>
<li>创建一个新的 issue 去追踪这个特征</li>
<li>当文档更新完毕一切就绪之后，我们会发起一个 pull request 去迭代更新文档内容。</li>
<li>PR 发起成功后，我们会使用 @ 方式提醒团队（比如 @github/docs ）并会让队友们审查一下我们的内容。</li>
<li>当这个特征开发完毕已经上线的时候，我们会合并之前创建的 PR。 使用 <a href=""https://developer.github.com/webhooks/"" rel=""nofollow noreferrer"">webhook</a> 能够帮助我们在 内容仓库 快速激活我们部署的 Rails 应用程序。webhook 承担了负责更新数据库的任务。</li>
</ol>
<p>下面是一个简单的示例给我们展示了一下我们正常的工作流程：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVkxji"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""e65dc512-94eb-11e4-8fff-8e02f9bed3d4.png"" title=""e65dc512-94eb-11e4-8fff-8e02f9bed3d4.png""></span></p>
<p>使用 PR 进行工作是非常神奇的，因为它正好和我们在团队中使用的 <a href=""https://guides.github.com/introduction/flow/"" rel=""nofollow noreferrer"">Github 工作流程</a>是一致的。并且我们喜欢用 Markdown 语言书写，更因为 Markdown 的语法能让我们不用花费多少时间就有效的描述新特征的所有内容。</p>
<p>然而，我们的 Rails 增强程序安装设置起来却非常的麻烦：</p>
<ul>
<li>由于我们依赖外部主机，所以我们需要专门的员工在我们的工程，运维和安全团队中监控站点和他们发起的响应事件。</li>
<li>我们的文档团队并不能方便的在本地观察内容的变化。虽然我们使用的是 Markdown 编写的内容，可以实时预览，但是我们能忍需要配置一个本地的 Rails 应用服务去运行脚本将内容导入到数据库中然后观察其在网站上的最终效果。</li>
<li>虽然我们不断的调整 Rails 的服务器，但是我们注意到用户的请求依旧使得网站访问变得非常缓慢。由于 HTML 页面是动态生成的，这就需要对数据库进行请求，这就耗费了很多时间。为了加快访问速度，我们还需要找寻更强大的缓存策略。</li>
</ul>
<p>我们知道我们是时候做出改变做的更好了。</p>
<h2>我们的新流程</h2>
<p>当 <a href=""https://github.com/blog/1867-github-pages-now-runs-jekyll-2-2-0"" rel=""nofollow noreferrer"">Jekyll 2.0</a> 发布的时候，我们看到了曙光，是时候该把我们这套该死的流程换成纯静态站了！特别是新增加的 <a href=""http://jekyllrb.com/docs/collections/"" rel=""nofollow noreferrer"">Collections</a> 文档类型能让你定义你需要的文件结构。另外，Jekyll 2.0 还增加了 <a href=""http://sass-lang.com/"" rel=""nofollow noreferrer"">Sass</a> 和 <a href=""http://coffeescript.org/"" rel=""nofollow noreferrer"">CoffeeScript</a> 的支持，这将使得编写前端代码变的更为简单便捷。</p>
<p>开源的好处在于它是开放的。我们迁移到 Jekyll 后，我们也向 Jekyll 发起了很多 <a href=""https://github.com/search?utf8=%E2%9C%93&amp;q=author:jglovier%20author:benbalter%20author:gjtorikian%20user:jekyll%20is:merged%20created:2014-04-01..2014-12-15"" rel=""nofollow noreferrer"">PR</a> 使得它能更好的服务 Github Pages 的用户。</p>
<p>使用了 Jekyll 之后，我们的工作流程发生了小小的变化。我们仍然使用 Markdown 并且我们仍然需要将内容 PR 到仓库以便其它人审查。但是当我们发起的 PR 被合并之后，Github Pages 网站将会在几秒内自动快速创建并部署。</p>
<p>下面是我们就如何使用 Jekyll 的核心功能以及我们使用的一些强化 Github 帮助文档站点的插件列了一个简单的纲要。</p>
<h3>我们使用的 Gems</h3>
<p>我们尽可能的依赖 Jekyll 代码本身的功能去尽可能减小我们依赖自己维护的自定义插件，这样可以减少我们的额外压力。</p>
<p>Jekyll 2.0 内自带的新的插件 <a href=""http://jekyllrb.com/docs/plugins/#converters"" rel=""nofollow noreferrer"">Converter</a> 使得用户可以将任何 标记语言书写的文件转换成 HTML。这样用户可以随便创作它的内容，Jekyll 只负责运行最后生成的 HTML文件就好了。举个例子，只要你会，你甚至可以使用 <a href=""https://github.com/asciidoctor/jekyll-asciidoc"" rel=""nofollow noreferrer"">AsciiDoc</a> 语法书写你的内容。</p>
<p>最后，我们开发了 <a href=""https://github.com/gjtorikian/jekyll-html-pipeline"" rel=""nofollow noreferrer"">jekyll-html-pipeline</a> 插件，是我们之前开源的 <a href=""https://github.com/jch/html-pipeline"" rel=""nofollow noreferrer"">html-pipeline</a> 在 Jekyll 上的增强版。这个确保了我们的帮助站点的内容在 Github 上的任何地方看起来都是一样的。我们同时也开发了我们自己的 <a href=""https://github.com/gjtorikian/extended-markdown-filter"" rel=""nofollow noreferrer"">Markdown filter</a> 插件去提供一些语法扩展使得我们编写文档更方便。</p>
<h3>搜索</h3>
<p>老流程的 Rails 网站中，我们使用了 <a href=""http://www.elasticsearch.org/"" rel=""nofollow noreferrer"">ElasticSearch</a> 对我们的数据库进行索引并增强了 Github 帮助文档的搜索系统。</p>
<p>现在，我们使用 <a href=""http://lunrjs.com/"" rel=""nofollow noreferrer"">lunr-js</a> 提供一个更快速的客户端搜索体验。当然我们也通过筛选分析发现绝大多数用户都会依赖外部的搜索服务进入我们的文档。所以，在新流程迁移完成之后，维护一个服务端的搜索引擎的解决方案看起来已经没有多大的意义了。</p>
<h3>内容引用</h3>
<p>文档团队希望在编写文档的时候使用“内容引用”。内容引用允许你书写一次某大段文字然后在网站的任何地方直接复用它。（这个灵感来自于 <a href=""http://dita.xml.org/arch-conref"" rel=""nofollow noreferrer"">the DITA standard</a>。 ）</p>
<p>旧的 Rails 系统并不能允许我们书写可复用的内容，但是现在我们有了强大的 Jekyll，它支持用户自定义 <a href=""http://jekyllrb.com/docs/datafiles/"" rel=""nofollow noreferrer"">data files</a> 。举个例子，我们已经创建了一个叫做<code>conrefs.yml</code>的文件，并且我们有一系列字符串形式的键值对集合像如下这样：</p>
<pre><code>repositories:
    create_new:
        1. In the upper-right corner of any page, click {{ octicon-plus Plus symbol }}, and then click **New repository**.
           ![New repository menu](/assets/images/help/repository/repo-create.png)
           </code></pre>
<p>此时我们的键为 <code>repositories.create_new</code>，其对应的值为下方的 Markdown 源代码（及 ""In the upper-right corner...""）。我们现在只需要简单一步就能在多个页面内容中复用这段内容：</p>
<pre><code>To start the process:

{{ site.data.conrefs.repositories.create_new }}
2. Do something else.
3. You're done!
</code></pre>
<p>随着 Github UI 的变化，我们也许需要修改图片或者重新定义某些地方的指向。这个时候，我们仅仅只需要修改一个地方就能完成我们的变化，比起以前需要修改所有的地方简直不知道方便了多少倍。</p>
<h3>版本化显示文档</h3>
<p>另一个随着此次变化带来的好处就是我们现在能够显示多版本的帮助文档。随着 <a href=""https://github.com/blog/1918-a-faster-more-flexible-github-enterprise"" rel=""nofollow noreferrer"">Github 企业版 2.0.0</a> 的发布，我们对<a href=""https://help.github.com/enterprise/11.10.340/user/"" rel=""nofollow noreferrer"">之前的 11.10.3 版本</a> 和<a href=""https://help.github.com/enterprise/2.0/user/"" rel=""nofollow noreferrer"">现在的 2.0 版本</a>这两个不同版本提供了不同的帮助文档内容。为了达到这个目的，我们在 Jekyll 站点内容使用了一个特别的 <code>audience</code> 变量，并在我们的 Pages 仓库生成 HTML 的时候检查这个变量。</p>
<p>例如，在我们的 <code>config.yml</code> 文件中，我们设置了一个键叫做 <code>audience</code> 其值为 <code>11.10.340</code>。如果某个特征存在在新版本的 2.0 中但是不存在于老版本的 11.10.340 中，我们会使用如下语法标记上这一部分：</p>
<pre><code>{% if site.audience != '11.10.340' %}
 
This new feature...

{% endif %}
</code></pre>
<p>当然更使我们高兴的是，以上的实现都是基于 Jekyll 的核心功能，我们不需要为此创建或者维护任何其它的东西。</p>
<h3>测试我们的站点</h3>
<p>静态站点并不意味着我们可以不为它开发测试驱动。</p>
<p>我们的第一个测试内容的工具是 <a href=""https://github.com/gjtorikian/html-proofer"" rel=""nofollow noreferrer"">html-proofer</a>。这个工具通过测试我们网站的每一个 URL 帮助我们核实我们的链接和图片都是正常的。</p>
<p>Ruby 的使用者们更熟悉使用 <a href=""https://jnicklas.github.io/capybara/"" rel=""nofollow noreferrer"">Capybara</a> 在他们的测试中模拟网站的交互。在我们的静态站点实现一个类似的工具这个主意看起来很疯狂？并不！ Github 的 <a href=""https://github.com/bkeepers"" rel=""nofollow noreferrer"">bkeepers</a> <a href=""http://opensoul.org/2010/05/11/capybaras-eating-cucumbers/"" rel=""nofollow noreferrer"">4年前的一篇文章</a> 已经谈论过这个问题了。当时，我们创建了更强大的测试工具，它涵盖了我们的内容测试和网站行为测试。举个例子来说，我们通过检查 YAML 文件中的键是否存在来确认某个内容引用是否有效，又或者说我们会测试我们的 JavaScript 代码是否运行良好。</p>
<p>我们的帮助文档在 CI（译者注：持续集成系统）上运行，这样确保了用户不会拿到损坏的内容。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVkxx1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""7adf83be-84a3-11e4-8c41-1b3448a2f7df.png"" title=""7adf83be-84a3-11e4-8c41-1b3448a2f7df.png""></span></p>
<h3>速度</h3>
<p>正如我们之前提到的，新的流程使得我们的 Pages 服务比之前使用 Rails 系统的时候有了标志性的加快。这其中一部分原因当然是因为新站点是一堆静态的 HTML 文件的集成——我们不需要向数据库获取任何内容。更值得注意的是，<a href=""https://github.com/blog/search?q=github%20pages"" rel=""nofollow noreferrer"">我们花费了大量的时间配置我们的 Pages 服务使得任何人运行它都是一样的快速</a>。我们有的好处，比如使用 CDN 分布式部署站点资源等，这些对每一个 Github 用户来说也同样是可用的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVkxyd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""576d7e46-849d-11e4-8986-0bb86c2a58d5.png"" title=""576d7e46-849d-11e4-8986-0bb86c2a58d5.png""></span></p>
<h2>让 Github Pages 为你工作</h2>
<p>文档团队通过 Github 利用 Github 的工作流程（译者注：即前文提到的 Markdown 编写内容，PR 提交等），Jekyll 以及 Github Pages 服务来提供一个高质量的文档。Github Pages 提供给我们文档团队的好处同样对每一个运行 Github Pages 的站点都是可用的。</p>
<p>随着我们将文档迁移到 Pages，我们再也不用重建任何新的组件了。我们花费了更少的时间建立一些东西并且更多的时间去讨论我们的团队和公司应该有什么样的工作流程。通过使用和 Github 用户一样的托管系统，我们能够提供更好更快的文档系统。我们内部的工作流程是的我们变得更有成效，并且是的我们从未如此方便的提供版本特征，例如版本化内容。</p>
<p>如果你对 Github 文档流程的简历有任何的疑问，无论何时，<a href=""https://github.com/contact?form%5Bsubject%5D=I%20have%20a%20question%20about%20your%20amazing%20Help%20site"" rel=""nofollow noreferrer"">Github 都非常乐于帮助大家</a>！</p>

                ", Github 是如何用 Github 撰写 Github 文档的,1531978091,511,1,285,1,1,https://segmentfault.com/a/1190000002473246
296,1,0,7,"
                    
<h2>为什么 Coding 不是中国的 Github ？</h2>

<p>自 Coding 上线以来，我听到最多的评价是 “yo，又一个 github”，我一般对这样的评价不做回应，原因有二：<br>
1. 中国的 github 这个印象非常直观，似乎有利于 Coding 的推广<br>
2. 我很难在短时间内去说服别人我们的情怀和 github 不一样<br>
所以我选择沉默，希望能用产品告诉用户，我们想做的是一个云端开发平台，不是 Github。</p>

<h2>Github 是什么 ？</h2>

<p>我觉得要讲清楚这件事，有必要先讲讲 Github 究竟是啥。Github.com 从功能上讲，是一个带有简单社交功能的云端代码仓库服务。经过了六年的发展，Github 已经成为这个领域事实上的标准。全世界绝大部分开源项目托管在 Github 上面，包括 Linux，OpenStack，Docker 等重量级项目。开源这几年蓬勃发展，极大的推动了 IT 行业的发展。很显然，计算机软件在人类生活中将会扮演越来越重要的角色，而 Github 就是人类软件的基因库。</p>

<p><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/81540a0d-3581-42b1-b541-97b256fbd333.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在这里输入图片描述""></span></p>

<p>Github 发明了两个碉堡了的功能，Fork 和 Pull Request。这两个功能创造了整个 Github 生态系统，使得“基因”得以繁衍和进化，充满了生命力。基因通过 Fork 被复制，而 Pull Request 使得基因得以进化。好的基因会被大量的 Fork，从而实现了优胜劣汰。这一整套体系才是精华所在，说 Github 是代码仓库显然太肤浅了。</p>

<p>Github 的基因库在近两年正在爆炸式的增长（见下图），现在哪个软件不或多或少的从 Github 找点现成的代码或者组件来用用呢？码农，人类软件的工程师，在绝大多数情况下，都会从 Github 上找一些基因片段，然后用自己的智慧进行一定的拼凑，加工和演绎，培育出一个能用的虚拟肉体，完成一定的任务。</p>

<p><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/1f0124a0-557d-4a87-bd76-91740028b420.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在这里输入图片描述""></span></p>

<p>我觉得我已经讲的很明白了，再往下就要开始科幻小说情节了，就此打住，回归正题。</p>

<h2>中国的 Github ？</h2>

<p>我们来说说中国的 Github 这个东东到底是否存在或者可能存在？我的答案是：否。虽然“墙”的存在，使得各种 Copy to China 的项目有了存在的理由，但在 Github 这个领域不成立。最简单的原因是，代码不分国界，无论你的母语是啥，但是写出来的代码是全世界通用的。而且在生态系统层面，已经不可能再培育出另外一个“基因库”。我认为不论是中国的 Github 还是印度的 Github 都不可能存在。</p>

<p>国内的代码托管服务总是希望开源软件作者能把开源项目放在国内的平台上，但这显然是一厢情愿。充其量，国内的平台只是个备胎，小三都算不上。严肃的开源软件就应该放在 Github 上面，这是其得到繁衍和发展的唯一机会，其他平台均没有这样的土壤。</p>

<p>那么，问题来了，既然 Github 这么碉堡，我们还做 Coding 为毛？因为私有库。Github 的牛逼是建立在开源项目之上的，我并不认为 Github 能为私有库提供很大的价值。私有库往往是团队在用，在语言，习惯，访问速度，以及协作方面都有不同的体验要求。在这一点上，我认为做一个超越 Github 的服务是有可能的。我们做 Coding 就是希望能给开发者提供极致的云端开发体验，强调的是私有库，强调团队协作，强调整合体验，强调访问速度。</p>

<p><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/32c37272-12a2-4fcf-a57f-d369900002b0.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在这里输入图片描述""></span></p>

<p>虽然 Coding 也提供公开项目服务，但是老实说，那从来都不是我们的重点。我们在开发 Coding 的时候是没有公开项目功能的，这个功能是为了方便推广在上线前加上去的。虽然我说出来这个事实有可能会导致我们损失一部分用户，但我还是想强调：严肃的开源项目就应该放在 Github 上面。当然如果你认为 Coding 已经能满足你的需求，我们也欢迎你放在 Coding 上。</p>

<p>我从来不认为我们跟 Github 有什么竞争。Coding 已经上线了 Github 登陆功能，其他的功能整合也在规划当中。由于 Github 在国内访问的不稳定导致这些功能一直无法上线。说到这里我想起来一件事。在我们拿到 A 轮投资的时候，有人建议我用一部分钱去 lobby 中国政府把 Github 彻底封了……然后，就没有然后了。</p>

<h2>那么 Coding 是什么？</h2>

<p>OK，Coding 不是中国的 Github，那么 Coding 是什么？<br>
随着互联网，云计算的发展，越来越多的软件被服务化，操作系统的概念被不断的弱化，软件开发的方式也正在进行深度的变革。我一直认为人类生活的云端化是不可逆转的大趋势。在这样的大趋势下，软件开发也在云端化。想象一下这样的场景，你从 Github 获取了一些代码片段，或者模块，通过一个云端开发平台（比如 Coding），生产出来了一个软件，打包成了一个 package （比如 app 或者 Docker Image），然后存放在某个 warehouse（比如 app store 或者 Docker Hub），需要运行的时候推送到适当的 runtime（比如手机或者 Docker Container），Bingo！发现了么？整个过程不落地，全在云端完成。碉堡了，有木有？！</p>

<p><span class=""img-wrap""><img data-src=""https://dn-coding-net-production-pp.qbox.me/e8edf95e-46ed-40c6-bc02-6c0aca0c05e0.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在这里输入图片描述""></span></p>

<p>在这样的场景中，Coding 想做的就是帮助开发者能够高效的在云端完成软件开发的工作。我们做的代码托管，项目管理，演示平台，质量管理等等都是为了帮助开发者在云端完成一系列高难度的软件开发动作。现状也许不够好，但是我们一直在努力。</p>

<p>Hi Github, I'm Coding :)</p>

<p>最后，我们的 Slogan：Coding，让开发更简单！</p>

<hr>
<p><strong>本文作者: Coding CEO <a rel=""nofollow"" href=""https://coding.net/u/zhlmmc"">张海龙</a></strong></p>

<p><strong>本文出自: Coding 官方技术博客: <a rel=""nofollow"" href=""http://blog.coding.net/"">http://blog.coding.net/</a></strong></p>

<p>【Coding 官方技术博客是 Coding 内部小伙伴在平时的工作学习过程中关于技术、产品、设计等等方面的积累和分享，希望大家共同学习共同进步!如转载，请注明出处与作者，谢谢!】</p>

                ", 为什么 Coding 不是中国的 Github ？,1531978092,569,1,927,1,1,https://segmentfault.com/a/1190000002450783
297,1,0,7,"
                    
<h2>译者序​</h2>

<p>Git是一个分布式版本控制系统，拥有许多神奇而易用的特性（比如：分支），这让它可以轻松适应各种工作流程。这篇文章不涉及Git的基本使用，而是介绍了一些高级却有用的小技巧。让我们一起来看看高富帅们的Git技巧，准备好逆袭吧！</p>

<h2>以“块”形式暂存你的改动</h2>

<p>你肯定已经很熟悉的使用git add命令来将改动暂存到暂存区（staging area）了。你可能也会偶然因为两个不同的原因而做了一次改动，却没有分别提交（仅仅提交了一次），所以，当你执行git log时，会看到诸如这样的提交信息：“修改X，改动无关的Y”。如果这看起来像是你的工作方式，交互式add将是你的有力工具。</p>

<p>交互式add（或者叫add块），将会一个块一个快的循环你的改动。使用命令git add -p时，你可以在每个改动“块”（即：连续的改动会被组织到一起）时进行一些选择，比如：切分当前块为更小的块、跳过一个改动块、甚至手动的编辑该块，你可以敲入?来查看所有该命令提供的选项。</p>

<p>开始以“块”形式暂存改动简单到只需一条命令（括号部分替换为特定文件）：</p>

<pre><code>git add -p (path/file)
</code></pre>

<p>译者注：感觉这条命令平常用的较少，我遇到需要分别提交的情况时，都是手动来add然后提交，该命令是这种方法的高级版本。我们平常可能对提交历史的重视比较低，常常出现一些无用的、无意义的提交信息，可以试试这条命令。</p>

<h2>切换到最后所在分支</h2>

<p>作为一个善良的码农，当你需要快速做些修正或是清理工作时，你都应该花些时间来对待。如果你的工作流程是十分依赖分支的话（译者注：强烈建议如此），你可能不希望无关的修正影响到现在正在进行功能开发的分支。这意味着，你应该使用git stash命令来暂时存放你的改动，然后切到master分支（译者注：或是其它啥分支，我一般是取名为fix），在那个分支进行修正。（译者注：修正完了，可以切回正在进行功能开发的分支，执行git stash pop来弹出之前暂存的改动，继续进行开发）。在不同分支间切换很乏味，幸好这里有个快捷命令可以切换到你最后所在的分支：</p>

<pre><code>git checkout -
</code></pre>

<p>这个语法对于使用linux的高富帅们来说一定不陌生，cd命令有个类似的缩写cd -，表示切换到你最后所在的目录。当你需要切回功能开发分支时，你根本不用关心那个分支是啥名，只需git checkout -。</p>

<p>译者注：感觉tab键的自动补全也挺好用的，不过这条命令可以少敲点字。有了这条命令，妈妈再也不用担心我的分支切换了。</p>

<h2>显示哪些分支被合并了（或是哪些没有被合并）</h2>

<p>在使用git时，你可能会创建许多分支，导致执行git branch命令列出分支时变得有些杂乱。于是，你想处理那些已经合并到master分支的无用分支，但是，当你执行git checkout -d 来删除分支时可能会遇到“麻烦”（译者注：git会拒绝删除未合并的分支并提示你），如果使用以下命令，你将不再需要三思而后删，可以自信的处理那些已经合并了的分支。</p>

<p>如果你想要看看你的本地分支里哪些分支是已经合并进你当前所在的分支时，可以使用：</p>

<pre><code>git branch --merged
</code></pre>

<p>反过来，如果需要查看哪些分支还没有合并进当前所在的分支，可以使用：</p>

<pre><code>git branch --no-merged
</code></pre>

<p>结合高富帅的UNIX工具，你可以轻松的删除那些已经合并了的分支：</p>

<pre><code>git branch --merged | xargs git branch -d
</code></pre>

<p>译者注：xargs是UNIX平台的一个工具，它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。如果git branch --merged显示的是a，b，c三个分支已经合并，上面的命令会转换为：git branch -d a b c。更多xargs的信息：<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/Xargs"">http://zh.wikipedia.org/wiki/Xargs</a></p>

<h2>从另一分支获取文件内容而不用切换分支</h2>

<p>设想你正在进行重构，你创建了好几个分支并在各分支下进行改动。这时，你想把另一个分支里某一个文件的改动引入到当前工作的分支里，为了达到目的你可能需要好几步：git stash你的改动；切换到那个分支；获取文件的改动；切回工作分支（当然是使用git checkout -）；继续进行编辑（译者注：别忘了git stash pop）。但是，你也可以直接检出另一分支的文件，并且合并到你当前所在的工作分支，使用命令（括号部分替换为对应的分支和文件）：</p>

<pre><code>git checkout (branch) -- (path/file)
</code></pre>

<h2>以最后提交排序的Git分支</h2>

<p>想必你已经使用上面的tip处理了杂乱的分支，有一些是用--merged选项标志来清理的吧。那其它的分支咋办呢？你咋知道哪些是有用的，哪些是完全过期无用的呢？git for-each-ref命令可以打印出一个列表，该列表显示每个分支最后一次提交的引用（reference）信息。我们可以自定义输出来包含一些有用的信息，更重要的是我们还可以按日期排序。可以使用下面的命令来输出一个列表，该表将显示按时间先后排序的每个分支的最后提交信息、提交者等信息：</p>

<pre><code>git for-each-ref --sort=-committerdate --format=""%(committername)@%(refname:short) [%(committerdate:short)] %(contents)""
</code></pre>

<p>还可以把它定义在gitconfig里：</p>

<pre><code>[alias]
  latest = for-each-ref --sort=-committerdate --format=\""%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\""
</code></pre>

<p>译者注：定义后就只需执行git latest了。注意双引号需要转义！</p>

<h2>在玻璃房内的人们别用git blame</h2>

<p>或者说，在玻璃房内的人们不应该直接使用git blame而不带下文的选项标志。（译者注：玻璃房内的人是完全能被别人看到的人。这里的意思应该是想说，你每一次提交的变动都会被记录到git仓库的历史，对于git仓库来说，你就像是住在玻璃房里的人，没有任何秘密，你根本逃不过git的”责问“）git blame是很有用的命令，它就像使用科学来证明你是正确的！但是请注意，许多文件的变动是很表面的，发现问题的来源需要更多的探索。像是移除空白、移动内容到新行、移动内容到另一文件等动作都可以使用选项来忽略掉，以便更容易的找到代码变动的始作俑者。</p>

<p>在你blame（责备）他人前，记得用以下命令看看结果：</p>

<pre><code>git blame -w  # 忽略移除空白这类改动
git blame -M  # 忽略移动文本内容这类改动
git blame -C  # 忽略移动文本内容到其它文件这类改动
</code></pre>

<p>译者注：git blame用来显示一份文件每一行的最近一次提交的提交hash值和提交者。当你跟别人说“我真的没改过这个文件啊”之前，就得git blame下。</p>

<h2>在整个git仓库提交历史中找寻内容（然后删掉它）</h2>

<p>你有时可能需要查找一行你写的代码，但是就是无法找到。它可能安放在了一些已经被遗忘的分支，或是删除了很久，又或是就在那显而易见的地方。无论哪种方式，你都可以通过一些命令在整个git仓库的历史中搜寻特定的字符串。</p>

<p>首先，我们需要拿到所有的提交，然后，使用git grep来搜寻特定的字符串。如下：</p>

<pre><code>git rev-list --all | xargs git grep -F '搜寻的字符串'
</code></pre>

<p>你可能有一个粗心的朋友不小心在仓库里提交了诸如，用户名、密码、外婆的大蒜食谱等敏感信息。首先，他们得更改用户名、密码（并向外婆道歉）。然后，你需要搜寻这些得罪人的文件，并将他们从整个仓库的历史里抹去（这听起来好像很容易）。经过这个处理，那些执行git pull的伙计们就会发现所有提交中包含的敏感信息都被清理干净了，而那些没有合并你的远程改动的家伙还是拥有敏感信息（所以，千万别忘记先改用户名和密码）。我们来看看怎么操作。</p>

<p>首先，重写每个分支的历史，移除敏感信息：</p>

<pre><code>git filter-branch --index-filter 'git rm --cached --ignore-unmatch (filename)' --prune-empty --tag-name-filter cat -- --all
</code></pre>

<p>然后，将记录敏感信息的文件增加到.gitignore文件，并提交（括号部分替换为对应文件名）：</p>

<pre><code>echo (filename) &gt;&gt; .gitignore
git add .gitignore
git commit -m ""Add sensitive (filename) file to gitignore""
</code></pre>

<p>接着，由于我们改写了历史，我们需要“强制”的将改动推到远程：</p>

<pre><code>git push origin master --force
# 译者注：还可以使用命令
git push origin +master
</code></pre>

<p>最后，这个文件还在你的本地仓库里，还需要将它完全抹除：</p>

<pre><code>rm -rf .git/refs/original/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now
</code></pre>

<p>你这粗心的朋友从敏感文件的危机中解脱，而你用你高超的git知识成功逆袭，成为了他的英雄！</p>

<p>译者注：一天，妹子叫我去她家帮她把她的三围信息从git仓库的历史里完全删除，我研究了很久不得要领。妹子说，不如我们做点其它的事吧。我觉得我的git知识被她鄙视了，坚定的说，我一定要把它删掉！然后，就没有然后了… …</p>

<h2>忽略文件跟踪</h2>

<p>在和他人合作时可能常常意味着你需要更改一些配置才能让应用在环境里跑起来，这时，常常会不小心把这些只对你有意义的配置文件也给提交了。为了不再常常关注这些文件，看着它们在git status时放肆的显示“modified”，你可以告诉git忽略它们的改动。这种方式，可以看成是一种和仓库绑定的gitignore文件（括号部分替换为对应文件）：</p>

<pre><code>  git update-index --assume-unchanged (path/file)
</code></pre>

<p>译者注：感觉，.gitignore文件更方便和好理解。</p>

<h2>让分支的历史归零</h2>

<p>不管出于啥理由，有时从头开始正是你需要的。也许是你接手了一个不确信能安全开源的代码仓库；也许是你要着手做些全新的事情；也许是你想创建用于其它目的一个新分支，又希望继续在仓库里维护它（比如：github页面，项目的文档一类的东西）。上述的情形下，你可以非常简单的创建一个没有提交历史的分支（括号部分替换为对应分支）：</p>

<pre><code>  git checkout --orphan (branch)
</code></pre>

<p>译者注：我们知道，分支只是对提交的一个引用，所以，每当从当前分支创建一个分支时，被创建的分支都会延续之前的历史，但是这种方式却不会，是一个完完全全干净的git分支，没有任何的提交！</p>

<h2>你一定离不开的别名</h2>

<p>不讨论能节省大量敲击时间的“git别名（git alias）”技巧的git文章一定都是在耍流氓。停止输入冗长的命令，使用超级有用的别名吧！git别名可以加到.gitconfig文件里，或是使用命令（译者注：本质就是改写.gitconfig命令）来增加（括号部分替换为别名和对应的命令）：</p>

<pre><code>    git config --global alias.(name) ""(command)""
</code></pre>

<ol>
<li>
<p>在依赖分支的工作流程中，你常常要在不同分支间切换，每次敲击节约你6个字母。</p>

<pre><code>co = checkout
</code></pre>
</li>
<li>
<p>在提交前瞧瞧你将要提交的都有什么改动是一个好习惯，这可以帮助你发现拼写错误、不小心的提交敏感信息、将代码组织成符合逻辑的组。使用git add暂存你的改动，然后使用git ds查看你将要提交的改动动。</p>

<pre><code>ds = diff --staged
</code></pre>
</li>
<li>
<p>你可能十分熟悉git输出的详细状态信息了，当到达一定境界时，你可能需要忽略所有那些描述，直击问题的核心。这个别名输出将输出git status的简短形式和分支的详细信息。</p>

<pre><code>st = status -sb
</code></pre>
</li>
<li>
<p>你是否在提交后才发现忘记git add某个文件了，或是提交了才想再改动些啥？amend（修正）暂存区到最近的一次提交吧。（译者注：这个命令不太好理解，--amend是重写提交历史，-C是重用某次提交的提交信息。场景是当你提交完了发现还有些改动没提交，又不想写什么“改动了X，再次提交”这种狗血的提交信息。重新git add并git amend后，重用上次的提交信息再次提交，替换上次的不完整提交。特别注意--amend重写了提交，如果你已经push到远程了，慎用这条命令！）</p>

<pre><code>amend = commit --amend -C HEAD
</code></pre>
</li>
<li>
<p>有时上面的修正可能不好使了，你需要undo（撤销）。undo会回退到上次提交，暂存区也会回退到那次提交时的状态。你可以进行额外的改动，用新的提交信息来再次进行提交。</p>

<pre><code>undo = reset --soft HEAD^
</code></pre>
</li>
<li>
<p>维护一个多人编辑的代码仓库常常意味着试着发现何人在改动什么，这个别名可以输出提交者和提交日期的log信息。</p>

<pre><code>ls = log --pretty=format:'%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green) [%cn]' --decorate --date=short
</code></pre>
</li>
<li>
<p>这个别名用来在一天的开启时回顾你昨天做了啥，或是在早晨刷新你的记忆（括号内替换为自己的email）。</p>

<pre><code>standup = log --since '1 day ago' --oneline --author (YOUREMAIL)
</code></pre>
</li>
<li>
<p>一个复杂的仓库可能很难用直线式的输出来查看，这个别名可以用图表的形式向你展示提交是怎样及何时被加到当前分支的。</p>

<pre><code>graph = log --graph --pretty=format:'%C(yellow)%h %C(blue)%d %C(reset)%s %C(white)%an, %ar%C(reset)'
</code></pre>
</li>
</ol>
<p>译者注：我根据上面的别名进行了一些整理修改，这是我现在的.gitconfig里的别名配置：</p>

<pre><code>[alias]
  st = status -sb
  co = checkout
  br = branch
  mg = merge
  ci = commit
  ds = diff --staged
  dt = difftool
  mt = mergetool
  last = log -1 HEAD
  latest = for-each-ref --sort=-committerdate --format=\""%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\""
  ls = log --pretty=format:\""%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\"" --decorate --date=short
  hist = log --pretty=format:\""%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\"" --topo-order --graph --date=short
  type = cat-file -t
  dump = cat-file -p
</code></pre>

<p>via <a rel=""nofollow"" href=""http://mux.alimama.com/posts/711"">alimama mux</a><br>
作者：Chris Kelly  译者：栖邀<br><a rel=""nofollow"" href=""http://net.tutsplus.com/tutorials/tools-and-tips/git-tips-from-the-pros/"">英文原文</a></p>

                ", 高富帅们的Git技巧,1531978093,137,1,558,1,1,https://segmentfault.com/a/1190000002448847
298,1,0,7,"
                    
<p>统计某人的代码提交量，包括增加，删除：<br><code>git log --author=""$(git config --get user.name)"" --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf ""added lines: %s removed lines : %s total lines: %s\n"",add,subs,loc }' -</code><br>
仓库提交者排名前 5（如果看全部，去掉 head 管道即可）：<br><code>git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5</code><br>
仓库提交者（邮箱）排名前 5：这个统计可能不会太准，因为很多人有不同的邮箱，但会使用相同的名字<br><code>git log --pretty=format:%ae | gawk -- '{ ++c[$0]; } END { for(cc in c) printf ""%5d %s\n"",c[cc],cc; }' | sort -u -n -r | head -n 5</code> <br>
贡献者统计：<br><code>git log --pretty='%aN' | sort -u | wc -l</code><br>
提交数统计：<br><code>git log --oneline | wc -l</code> <br>
添加或修改的代码行数：<br><code>git log --stat|perl -ne 'END { print $c } $c += $1 if /(\d+) insertions/;</code><br>
 </p>

<blockquote>
  <p>git log 参数说明：<br>
  --author   指定作者<br>
  --stat   显示每次更新的文件修改统计信息，会列出具体文件列表<br>
  --shortstat    统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：  <br>
  --numstat   统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：<br>
   <br>
     <br>
  -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新<br>
         例如：git log -p  -2<br>
  --name-only 仅在提交信息后显示已修改的文件清单<br>
  --name-status 显示新增、修改、删除的文件清单<br>
  --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符<br>
  --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）<br>
  --graph 显示 ASCII 图形表示的分支合并历史<br>
  --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）<br>
         例如： git log --pretty=oneline ; git log --pretty=short ; git log --pretty=full ; git log --pretty=fuller<br>
  --pretty=tformat:   可以定制要显示的记录格式，这样的输出便于后期编程提取分析<br>
         例如：git log --pretty=format:""""%h - %an, %ar : %s""""<br>
         下面列出了常用的格式占位符写法及其代表的意义。                   <br>
         选项       说明                  <br>
         %H      提交对象（commit）的完整哈希字串               <br>
         %h      提交对象的简短哈希字串               <br>
         %T      树对象（tree）的完整哈希字串                   <br>
         %t      树对象的简短哈希字串                    <br>
         %P      父对象（parent）的完整哈希字串               <br>
         %p      父对象的简短哈希字串                   <br>
         %an     作者（author）的名字              <br>
         %ae     作者的电子邮件地址                <br>
         %ad     作者修订日期（可以用 -date= 选项定制格式）                   <br>
         %ar     作者修订日期，按多久以前的方式显示                    <br>
         %cn     提交者(committer)的名字                <br>
         %ce     提交者的电子邮件地址                    <br>
         %cd     提交日期                <br>
         %cr     提交日期，按多久以前的方式显示              <br>
         %s      提交说明  <br>
  --since  限制显示输出的范围，<br>
         例如： git log --since=2.weeks    显示最近两周的提交<br>
         选项 说明                <br>
         -(n)    仅显示最近的 n 条提交                    <br>
         --since, --after 仅显示指定时间之后的提交。                    <br>
         --until, --before 仅显示指定时间之前的提交。                  <br>
         --author 仅显示指定作者相关的提交。                <br>
         --committer 仅显示指定提交者相关的提交。<br>
   <br>
      一些例子： git log --until=1.minute.ago // 一分钟之前的所有 log git log --since=1.day.ago //一天之内的log git log --since=1.hour.ago //一个小时之内的 log git log --since=`.month.ago --until=2.weeks.ago //一个月之前到半个月之前的log git<br>
  log --since ==2013-08.01 --until=2013-09-07 //某个时间段的 log   git blame<br>
  看看某一个文件的相关历史记录<br>
         例如：git blame index.html --date short</p>
</blockquote>

                ", Git代码行统计命令集,1531978094,481,1,948,1,1,https://segmentfault.com/a/1190000002434755
299,1,0,7,"
                    
<p><a rel=""nofollow"" href=""http://fir.im"">FIR.im</a> 一直在尽量兼容不同使用习惯的版本号形式, 但是在使用中我们发现好多开发者对怎么更好的用版本号来标示应用很陌生. 这是篇基础文章, 简单介绍 iOS 的版本号.</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FoSuESkBT9ubPjLRJm6c57uFe0m4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-1.jpg""></span></p>



<h2>名词解释</h2>

<ul>
<li>Version, 通常说的版本号, 是应用向用户宣传说明时候用到的标识. 一般有2段或者3段式, 如:<code>2.1</code>,<code>8.1.2</code>
</li>
</ul>
<p><code>Version</code> 一般由产品部门确定, 完全迥异的更新需要改变主版本号, 比如 <code>QQ 4.0</code> 的变化非常大, 主版本的变化会更加吸引用户的眼球,所以有的应用会频繁的更新主版本号, 比如 <code>FireFox 20.0</code> . 两段式的副版本号既包含小功能更新也会包含 bug 修复等,三段式副版本基本都是新功能添加和大问题修复,第三段则表示稳定版本基本都是修复 bug</p>

<ul>
<li>Build , 编译号指一次唯一编译标识, 通常是一个递增整数(安卓强制为数字, iOS 可以是字符串)</li>
</ul>
<p><code>Build</code> 都是给内部使用, 用来确定一个唯一版本. 与前面提到的 Version 不会有太大联系.</p>

<p><strong>iOS 开发中,这个2个号码都可以任意字符串或数字.</strong></p>

<p>我们目前遇到的情况有:</p>

<ul>
<li>忽略了 Version 或 Build. 这两个号中的一个常年的不会发生变化.</li>
<li>颠倒了 Version 和 Build.</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FvIegW3X0g5_RWpXduMzb3kRyIJF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-2.jpg""></span></p>

<p>获取方法也很简单:</p>

<pre><code>NSDictionary *info= [[NSBundle mainBundle] infoDictionary];

info[@""CFBundleShortVersionString""]; //Version
info[@""CFBundleVersion""]; // Build
</code></pre>

<h2>为什么使用版本号</h2>

<h3>1. 方便标示和沟通</h3>

<p>前面提到 版本号更新会给推广产生一定的积极作用. 所以版本号不要太长, 如果像这样 ""我们隆重推出了 某某某 1.7.14.19257 !"", 这个会让用户感觉很乏味很像电视购物,而且也不利于传播. 如果是 ""某某 3.0, 大有不同 !""可能就会产生更好的沟通效果.</p>

<h3>2. 方便追踪 Bug</h3>

<p>一个应用有 Bug 是肯定的, 但是很快的定位解决问题却体现出团队和程序员的能力. 我们经常遇到有开发者说我提交一个版本, 但是下载下来有还是旧的. 我们帮他解决问题的时候,他自己都搞不清哪个是哪个了, 如果能在""关于""之类的地方显示当前的版本, 就会容易找到问题.</p>

<p>或者是测试团队的同事, 可能手里同时有几个不同分支的版本在测试, 他们需要精确的描述一个测试版本.</p>

<h2>自动改变 Build 号</h2>

<p>前面提到, <code>Version</code> 是不需要自动变化的, 根据产品或者市场部门的需求,适时的手动改一下就好.</p>

<h3>1. agvtool (Apple-generic versioning tool)</h3>

<p><a rel=""nofollow"" href=""https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/agvtool.8.html"">agvtool</a>, 是苹果的命令行工具, 也是集成在 Xcode 中最方便的工具.  我们在自动编译 SDK 的脚本中用的就是这个方法. 其实就用了一行(其他的高级用法可以参考前面的链接):</p>

<pre><code>agvtool next-version
</code></pre>

<p>使用前需要在 Xcode 里简单配置一下, 如图:</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FitXOnXNdQbUpoRRWuiCa9VgtfmF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-3.jpg""></span></p>

<h3>2. 基于SCM的版本控制号</h3>

<p>SCM 现在常用的有 Git 和 SVN, 还有一些相对小众的比如 hg 这里就不多做介绍了.<br>
如果用 Git/SVN 来管理代码(相信已经没有人不用了) 我们可以用代码的提交次数来代替Build号.</p>

<ul>
<li>Git</li>
</ul>
<pre><code>REV=`git rev-list HEAD | wc -l | awk '{print $1}'`
</code></pre>

<p>其中 <code>HEAD</code>是分支名, 代表当前分支, 可以直接替换成其他分支名, 比如<code>master</code>,<code>dev</code>.<br>
这个脚本放到</p>

<ul>
<li>SVN</li>
</ul>
<pre><code>REV=`svnversion -nc | sed -e 's/^[^:]*://;s/[A-Za-z]//'`
</code></pre>

<p>后面都是一样的:</p>

<pre><code>/usr/libexec/PlistBuddy -c ""Set :CFBundleVersion ${REV}"" ""${TARGET_BUILD_DIR}""/${INFOPLIST_PATH}
</code></pre>

<p>这样每次编译app的时候就自动把版本号加到Info.plist的<code>CFBundleVersion</code>键值下</p>

<p>把上面2行代码 加到 ""Build Phase &gt; Run Script""就可以了:</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FsHdTgeR_CAVjwTQTz0N9j-R1ZIV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-4.jpg""></span></p>

<h3>3. 基于日期时间</h3>

<p>用发布日期作为版本好也是许多应用常用的方式, 因为好记好理解. 这里直接附上代码:</p>

<pre><code>REV=`date +%y%m%d`  #输出格式141120的六位日期格式,可以根据自己喜欢改变格式
</code></pre>

<p>后面都是一样的:</p>

<pre><code>/usr/libexec/PlistBuddy -c ""Set :CFBundleVersion ${REV}"" ""${TARGET_BUILD_DIR}""/${INFOPLIST_PATH}
</code></pre>

<p>使用方法同上.</p>

<h2>怎么使用</h2>

<p>只要配置好了版本号, 其他的事情就不需要人工干预了, 这里介绍2种使用场景.</p>

<h3>1. Crash 收集</h3>

<p>收集 Crash 是应用开发必要的环节, 通过分析和修复 Crash 信息可以大大提高应用的稳定性而不会让更多的用户失望甚至删除应用.<br>
目前有很多收集工具, 比如 FIR.im 旗下的<a rel=""nofollow"" href=""http://bughd.com/demo/ios"">BugHD</a>, Crashlytics等.</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/Fk8-VkIqnU7M1a9XQdTPrHOP-_Ns"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-5.jpg""></span></p>

<h3>2. 用户反馈</h3>

<p>能主动反馈问题的用户都是极品用户, 不管要求是不是合理我们都要认真对待.<br>
不管是用各种 SDK 还是用 Email 都要尽量的带上版本号, 系统信息, 方便确认用户需求.最不济也要在""关于""里面能让用户找到相关的版本信息以便描述问题.</p>

                ", 浅谈 iOS 版本号 ,1531978096,141,1,388,1,1,https://segmentfault.com/a/1190000002423661
300,1,0,7,"
                    
<p><strong>作者</strong>：戴嘉华</p>

<p><strong>转载请注明出处，保留原文链接和作者信息</strong></p>

<hr>
<h2>目录</h2>

<ul>
<li>前言</li>
<li>仓库（Repository）<br><br><ul>
<li>源仓库</li>
<li>开发者仓库</li>
</ul>
</li>
<li>分支（Branch）<br><br><ul>
<li>永久性分支</li>
<li>暂时性分支</li>
</ul>
</li>
<li>工作流（workflow）</li>
<li>总结</li>
<li>参考资料</li>
</ul>
<h2>前言</h2>

<p>（本文假设各位已经对基本git的基本概念、操作有一定的理解，如无相关git知识，可以参考<a rel=""nofollow"" href=""http://git-scm.com/book/zh/"">Pro Git</a>这本书进行相关的学习和练习）</p>

<p>很多项目开发都会采用git这一优秀的分布式版本管理工具进行项目版本管理，使用github开源平台作为代码仓库托管平台。由于git的使用非常灵活，在实践当中衍生了很多种不同的工作流程，不同的项目、不同的团队会有不同的协作方式。</p>

<p>本文将介绍一种前人已经在各种大小项目中经过千锤百炼总结出来的一种比较成功的git工作流，这种工作流已经被成功用于许多团队开发当中。掌握git，掌握这种工作流，对大家以后的学习、开发工作大有好处。</p>

<p>先上一张图吓大家一下：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/centr-decentr@2x.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""workflow""></span></p>

<p>上面一张图展示了一种使用git进行项目协同开发的模式，接下来会进行详细介绍。</p>



<h2>仓库（Repository）</h2>

<p>在项目的开始到结束，我们会有两种仓库。一种是源仓库（origin），一种是开发者仓库。上图中的每个矩形都表示一个仓库，正中间的是我们的源仓库，而其他围绕着源仓库的则是开发者仓库。</p>

<h3>源仓库</h3>

<p>在项目的开始，项目的发起者构建起一个项目的最原始的仓库，我们把它称为<code>origin</code>，例如我们的PingHackers网站，<code>origin</code>就是这个<a rel=""nofollow"" href=""https://github.com/PingHackers/blog"">PingHackers/blog</a>了。源仓库的有两个作用：</p>

<ol>
<li>汇总参与该项目的各个开发者的代码</li>
<li>存放趋于稳定和可发布的代码  </li>
</ol>
<p>源仓库应该是受保护的，开发者不应该直接对其进行开发工作。只有项目管理者（通常是项目发起人）能对其进行较高权限的操作。</p>

<h3>开发者仓库</h3>

<p>上面说过，任何开发者都不会对源仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库的“复制”一份，作为自己日常开发的仓库。这个复制，也就是github上面的<code>fork</code>。</p>

<p>每个开发者所fork的仓库是完全独立的，互不干扰，甚至与源仓库都无关。每个开发者仓库相当于一个源仓库实体的影像，开发者在这个影像中进行编码，提交到自己的仓库中，这样就可以轻易地实现团队成员之间的并行开发工作。而开发工作完成以后，开发者可以向源仓库发送<code>pull request</code>，请求管理员把自己的代码合并到源仓库中，这样就实现了<strong>分布式开发工作</strong>，和最后的集中式的管理。</p>

<h2>分支（Branch）</h2>

<p>分支是git中非常重要的一个概念，也是git这一个工具中的大杀器，必杀技。在其他集中式版本管理工具（SVN/CVS）把分支定位为高级技巧，而在git中，分支操作则是每个开发人员日常工作流。利用git的分支，可以非常方便地进行开发和测试，如果使用git没有让你感到轻松和愉悦，那是因为你还没有学会使用分支。不把分支用出一点翔来，不要轻易跟别人说你用过git。</p>

<p>在文章开头的那张图中，每一个矩形内部纷繁的枝蔓便是git的分支模型。可以看出，每个开发者的仓库都有自己的分支路线，而这些分支路线会通过代码汇总映射到源仓库中去。</p>

<p>我们为git定下一种分支模型，在这种模型中，分支有两类，五种</p>

<ul>
<li>永久性分支<br><br><ul>
<li>
<code>master branch</code>：主分支</li>
<li>
<code>develop branch</code>：开发分支</li>
</ul>
</li>
<li>临时性分支<br><br><ul>
<li>
<code>feature branch</code>：功能分支</li>
<li>
<code>release branch</code>：预发布分支</li>
<li>
<code>hotfix branch</code>：bug修复分支</li>
</ul>
</li>
</ul>
<h3>永久性分支</h3>

<p>永久性分支是寿命无限的分支，存在于整个项目的开始、开发、迭代、终止过程中。永久性分支只有两个<code>master</code>和<code>develop</code>。</p>

<p><strong>master</strong>：主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，<code>master</code>存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持<code>master</code>仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。<code>master</code>分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次<code>master</code>更新的时候都应该用git打上<code>tag</code>，说明你的产品有新版本发布了。</p>

<p><strong>develop</strong>：开发分支，一开始从master分支中分离出来，用于开发者存放基本稳定代码。之前说过，每个开发者的仓库相当于源仓库的一个镜像，每个开发者自己的仓库上也有<code>master</code>和<code>develop</code>。开发者把功能做好以后，是存放到自己的<code>develop</code>中，当测试完以后，可以向管理者发起一个<code>pull request</code>，请求把自己仓库的<code>develop</code>分支合并到源仓库的<code>develop</code>中。</p>

<p>所有开发者开发好的功能会在源仓库的<code>develop</code>分支中进行汇总，当<code>develop</code>中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把<code>develop</code>分支合并到<code>master</code>分支中，发布一个新版本。所以，一个产品不断完善和发布过程就正如下图：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/main-branches@2x.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""master &amp; develop""></span></p>

<p>注意，任何人不应该向<code>master</code>直接进行无意义的合并、提交操作。正常情况下，<code>master</code>只应该接受<code>develop</code>的合并，也就是说，<code>master</code>所有代码更新应该源于合并<code>develop</code>的代码。</p>

<h3>暂时性分支</h3>

<p>暂时性分支和永久性分支不同，暂时性分支在开发过程中是一定会被删除的。所有暂时性分支，一般源于<code>develop</code>，最终也一定会回归合并到<code>develop</code>。</p>

<p><strong>feature</strong>：功能性分支，是用于开发项目的功能的分支，是开发者主要战斗阵地。开发者在本地仓库从<code>develop</code>分支分出功能分支，在该分支上进行功能的开发，开发完成以后再合并到<code>develop</code>分支上，这时候功能性分支已经完成任务，可以删除。功能性分支的命名一般为<code>feature-*</code>，*为需要开发的功能的名称。</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/fb@2x.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""feature branch""></span></p>

<p>举一个例子，假设我是一名PingHackers网站的开发者，已经把源仓库fork了，并且clone到了本地。现在要开发PingHackers网站的“讨论”功能。我在本地仓库中可以这样做：</p>

<p>step 1: 切换到<code>develop</code>分支</p>

<pre><code>    &gt;&gt;&gt; git checkout develop
</code></pre>

<p>step 2: 分出一个功能性分支</p>

<pre><code>    &gt;&gt;&gt; git checkout -b feature-discuss
</code></pre>

<p>step 3: 在功能性分支上进行开发工作，多次commit，测试以后...</p>

<p>step 4: 把做好的功能合并到<code>develop</code>中</p>

<pre><code>    &gt;&gt;&gt; git checkout develop

    # 回到develop分支

    &gt;&gt;&gt; git merge --no-ff feature-discuss
    # 把做好的功能合并到develop中

    &gt;&gt;&gt; git branch -d feature-discuss
    # 删除功能性分支

    &gt;&gt;&gt; git push origin develop
    # 把develop提交到自己的远程仓库中

</code></pre>

<p>这样，就完成一次功能的开发和提交。</p>

<p><strong>release</strong>：预发布分支，当产品即将发布的时候，要进行最后的调整和测试，这时候就可以分出一个预发布分支，进行最后的bug fix。测试完全以后，发布新版本，就可以把预发布分支删除。预发布分支一般命名为<code>release-*</code>。</p>

<p><strong>hotfix</strong>：修复bug分支，当产品已经发布了，突然出现了重大的bug。这时候就要新建一个<code>hotfix</code>分支，继续紧急的bug修复工作，当bug修复完以后，把该分支合并到<code>master</code>和<code>develop</code>以后，就可以把该分支删除。修复bug分支命名一般为<code>hotfix-*</code></p>

<p><code>release</code>和<code>hotfix</code>分支离我们还比较遥远。。就不详述，有兴趣的同学可以参考本文最后的参考资料进行学习。</p>

<h2>工作流（Workflow）</h2>

<p>啰嗦讲了这么多，概念永远是抽象的。对于新手来说，都喜欢一步一步的步骤傻瓜教程，接下来，我们就一步一步来操作上面所说的工作流程，大家感受一下：</p>

<h3>Step 1：源仓库的构建</h3>

<p>这一步通常由项目发起人来操作，我们这里把管理员设为PingHackers，假设PingHackers已经为我们建立起了一个源仓库<a rel=""nofollow"" href=""https://github.com/PingHackers/git-demo"">PingHackers/git-demo</a>，并且已经初始化了两个永久性分支<code>master</code>和<code>develop</code>，如图：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-branch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""origin""></span></p>

<h3>Step 2：开发者fork源仓库</h3>

<p>源仓库建立以后，每个开发就可以去复制一份源仓库到自己的github账号中，然后作为自己开发所用的仓库。假设我是一个项目中的开发者，我就到<a rel=""nofollow"" href=""https://github.com/PingHackers/git-demo"">PingHackers/git-demo</a>项目主页上去<code>fork</code>：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-fork.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""fork""></span></p>

<p><code>fork</code>完以后，我就可以在我自己的仓库列表中看到一个和源仓库一模一样的复制品。这时就应该感叹，你以后要和它相依为命了：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-fork-origin.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""fork-origin""></span></p>

<h3>Step 3：把自己开发者仓库clone到本地</h3>

<p>这一步应该不用教，git clone</p>

<h3>Step 4：构建功能分支进行开发</h3>

<p>进入仓库中，按照前面说所的构建功能分支的步骤，构建功能分支进行开发、合并，假设我现在要开发一个“讨论”功能：</p>

<pre><code>    &gt;&gt;&gt; git checkout develop
    # 切换到`develop`分支

    &gt;&gt;&gt; git checkout -b feature-discuss
    # 分出一个功能性分支

    &gt;&gt; touch discuss.js
    # 假装discuss.js就是我们要开发的功能

    &gt;&gt; git add .
    &gt;&gt; git commit -m 'finish discuss feature'
    # 提交更改

    &gt;&gt;&gt; git checkout develop
    # 回到develop分支

    &gt;&gt;&gt; git merge --no-ff feature-discuss
    # 把做好的功能合并到develop中

    &gt;&gt;&gt; git branch -d feature-discuss
    # 删除功能性分支

    &gt;&gt;&gt; git push origin develop
    # 把develop提交到自己的远程仓库中
</code></pre>

<p>这时候，你上自己github的项目主页中<code>develop</code>分支中看看，已经有<code>discuss.js</code>这个文件了：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-push.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""push""></span></p>

<h3>Step 5：向管理员提交pull request</h3>

<p>假设我完成了“讨论”功能（当然，你还可能对自己的<code>develop</code>进行了多次合并，完成了多个功能），经过测试以后，觉得没问题，就可以请求管理员把<strong>自己仓库的develop分支</strong>合并到<strong>源仓库的develop</strong>分支中，这就是传说中的<code>pull request</code>。</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-pull-request.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pull-request""></span></p>

<p>点击上图的绿色按钮，开发者就可以就可以静静地等待管理员对你的提交的评审了。</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-pull-request-origin.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pull-finished""></span></p>

<h3>Step 6 管理员测试、合并</h3>

<p>接下来就是管理员的操作了，作为管理员的PingHackers登陆github，便看到了我对源仓库发起的<code>pull request</code>。</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/pull-request-origin.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pull-request-origin""></span></p>

<p>这时候PingHackers需要做的事情就是：</p>

<ol>
<li>
<strong>对我的代码进行review</strong>。github提供非常强大的代码review功能：<br><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-demo-review.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""reivew""></span>
</li>
<li>
<p><strong>在他的本地测试新建一个测试分支</strong>，测试我的代码：</p>

<pre><code>&gt;&gt; git checkout develop
# 进入他本地的develop分支

&gt;&gt; git checkout -b livoras-develop
# 从develop分支中分出一个叫livoras-develop的测试分支测试我的代码

&gt;&gt; git pull https://github.com/livoras/git-demo.git develop
# 把我的代码pull到测试分支中，进行测试
</code></pre>
</li>
<li>
<p><strong>判断是否同意合并到源仓库的<code>develop</code>中</strong>，如果经过测试没问题，可以把我的代码合并到源仓库的<code>develop</code>中：</p>

<pre><code>&gt;&gt; git checkout develop
&gt;&gt; git merge --no-ff livoras-develop
&gt;&gt; git push origin develop
</code></pre>
</li>
</ol>
<p>注意，PingHakers一直在操作的仓库是源仓库。所以我们经过上面一系列操作以后，就可以在源仓库主页中看到：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/merge.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""merge""></span></p>

<p>经过辗转曲折的路程，我们的<code>discuss.js</code>终于从我的开发仓库的功能分支到达了源仓库的<code>develop</code>分支中。以上，就是一个git &amp; github协同工作流的基本步骤。</p>

<h2>总结</h2>

<p>git这一个工具博大精深，很难想象竟然有使用如此恶心而又如此灵活和优雅的工具存在；此又为一神器，大家还是多动手，多查资料，让git成为自己的一项基本技能，帮助自己处理各种项目团队协同工作的问题，成为一个高效的开发者、优秀的项目的管理者。送大家一张神图，好好领悟：</p>

<p><span class=""img-wrap""><img data-src=""https://raw.githubusercontent.com/livoras/blog-images/master/git/git-model@2x.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Overview""></span></p>

<p>最后给出一些参考资料，供参考学习。</p>

<h2>参考资料</h2>

<ul>
<li><a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">A Successful Git Branching Model</a></li>
<li><a rel=""nofollow"" href=""https://sandofsky.com/blog/git-workflow.html"">Understanding the Git Workflow</a></li>
<li><a rel=""nofollow"" href=""http://scottchacon.com/2011/08/31/github-flow.html"">Github flow</a></li>
<li><a rel=""nofollow"" href=""http://git-scm.com/book/zh/"">Pro Git</a></li>
<li><a rel=""nofollow"" href=""http://www.ruanyifeng.com/blog/2012/07/git.html"">Git分支管理策略</a></li>
</ul>

                ", 使用git和github进行协同开发流程,1531978097,143,1,484,1,1,https://segmentfault.com/a/1190000002413519
301,1,0,7,"
                    
<p>From: (<a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary"">https://github.com/xiaobeicn/programming-skills-summary</a>)</p>

<p>为了方便快速编写代码，创建了这个公开库。旨在提高编写效率和编写质量，避免多次google一样的代码。这是一个在线公开笔记，也是一个提高自己能力的文档，会收集大量优秀的代码片段。</p>

<h4>贡献方式：</h4>

<ul>
<li>
<a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/fork""><code>fork</code></a> 项目，然后推送给我</li>
<li>创建 <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/issues/new""><code>issues</code></a> ,我会及时处理</li>
</ul>
<h4>贡献要求</h4>

<ul>
<li>在对应文件夹内创建单独文件(推荐)或在文件夹内<code>README.md</code>中直接扩充</li>
<li>文件内容不宜过大，最好控制在百行以内</li>
<li>如果是多个片段一个归属类，最好只创建一个文件</li>
<li>代码质量要高，可以是自己代码的提炼，也可以是开源优秀代码段</li>
</ul>
<h3>列表状态</h3>

<ul>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/api"">api</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/git"">git</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/html-css"">html-css</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/js"">js</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/markdown"">markdown</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/mysql"">mysql</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/nosql"">nosql</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/php"">PHP</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/server"">server</a>
</li>
<li>[x] <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/tree/master/open-source"">open-source</a>
</li>
<li>[ ] other</li>
</ul>
<h4>开源协议</h4>

<p>基于 <a rel=""nofollow"" href=""https://github.com/xiaobeicn/programming-skills-summary/blob/master/LICENSE"">MIT License</a> 开源，使用代码只需说明来源即可。</p>

                ", 编程技巧汇总,1531978098,131,1,906,1,1,https://segmentfault.com/a/1190000002395881
302,1,0,7,"
                    
<blockquote>
  <p>本文最初发布于我的个人博客：<a rel=""nofollow"" href=""http://jerryzou.com/posts/gitForSAE/"">http://jerryzou.com/posts/gitForSAE/</a></p>
</blockquote>

<p>我花了一些时间自己写了一个能够极速地将一个git项目部署到SAE的svn服务器上的脚本。代码不是复杂，也没有很深的技术。但确实是个好用的小工具，至少对我来说，不用把我的git项目打包成zip再上传了，确实提高了超多效率！我将首先介绍一下脚本如何使用，再介绍我是如何实现这个shell脚本的。项目地址：<a rel=""nofollow"" href=""https://github.com/zry656565/git-for-SAE""></a><a rel=""nofollow"" href=""https://github.com/zry656565/git-for-SAE"">https://github.com/zry656565/git-for-SAE</a></p>

<h1>功能</h1>

<ul>
<li>一个脚本搞定将git项目部署到SAE的svn服务器上</li>
<li>可以很方便地管理SAE上的1-10版本</li>
<li>自动将缓存文件夹 <code>.svn</code> 加入 <code>.gitignore</code>
</li>
</ul>
<h1>安装</h1>

<ul>
<li>第一步，将本项目clone到本地并checkout到release分支，这么做的话你在想要更新到最新版本时可以随时获得更新。或者你直接<a rel=""nofollow"" href=""https://github.com/zry656565/git-for-SAE/archive/release.zip"">下载zip包</a>。假设你将项目放到了如<code>/Users/Jerry/Dev/git-for-SAE/</code>这样的路径下。</li>
<li>第二步，将以下内容添加到<code>~/.bash_profile</code>下</li>
</ul>
<pre><code># Git for SAE
export GIT_FOR_SAE_ROOT=/Users/Jerry/Dev/git-for-SAE/ #此处就是你刚刚放置clone下来的项目路径
export PATH=$GIT_FOR_SAE_ROOT:$PATH
</code></pre>

<ul>
<li>第三步，应用新的<code>.bash_profile</code>
</li>
</ul>
<pre><code>Terminal$ source ~/.bash_profile
</code></pre>

<h1>如何使用</h1>

<p>如果svn服务器是:<code>https://svn.sinaapp.com/sjtubus/</code>，那么下面的第一个参数请填写: <code>sjtubus</code><br>
如果通过上面那种方式安装好后，你可以进入你自己项目的根目录，接着这样使用：</p>

<pre><code>#部署
#第一个参数是SAE上的项目名
#第二个数字表示版本号，SAE支持1-10
Terminal$ sae-push.sh sjtubus 1

#清空本地svn缓存
Terminal$ sae-clean.sh
</code></pre>

<h1>成功案例</h1>

<ul>
<li>将交大校园巴士时刻表部署到SAE上</li>
<li>Github: <a rel=""nofollow"" href=""https://github.com/zry656565/SJTU-Bus""></a><a rel=""nofollow"" href=""https://github.com/zry656565/SJTU-Bus"">https://github.com/zry656565/SJTU-Bus</a>
</li>
<li>SAE: <a rel=""nofollow"" href=""http://sjtubus.sinaapp.com/""></a><a rel=""nofollow"" href=""http://sjtubus.sinaapp.com/"">http://sjtubus.sinaapp.com/</a>
</li>
</ul>
<h1>如何实现</h1>

<p>简单来说就分为以上四步:<br>
1. checkout SAE上的svn项目<br>
2. 清除svn项目中的文件<br>
3. 将git项目中的文件拷贝到svn项目中<br>
4. 提交至SAE服务器</p>

<h3>1.checkout SAE上的svn项目</h3>

<p>首先，我在git项目的根目录下创建<code>.svn</code>文件夹用于存放SAE的svn项目，如果识别到已经创建了就跳过这个步骤，否则创建好<code>.svn</code> 后，执行 <code>svn checkout $svn_repo_url</code> (地址由参数生成)。</p>

<h3>2.清除svn项目中的文件</h3>

<p>接着为了防止之前的文件对git项目产生影响，我会将它们全部删除。反正既然采用这种管理手段，代码版本管理都在git项目中，所以应该不会造成不好的影响。但有一点需要注意的是根目录下的<code>config.yaml</code>文件是不能删除的，必须保留下来。需要执行的指令如下：</p>

<pre><code>mv config.yaml ../config.yaml
rm -rf *
mv ../config.yaml config.yaml
svn st | awk '{print $2}' | xargs svn delete
svn commit -m ""clean""
</code></pre>

<h3>3.将git项目中的文件拷贝到svn项目中</h3>

<p>接着就把git项目中的所有文件拷贝到<code>.svn</code>文件夹下的项目中，执行如下指令：</p>

<pre><code>mv -f .svn ../.svn
cp -rf * ""../.svn/$svn_dir_name""
mv -f ../.svn .svn
</code></pre>

<h3>4.提交至SAE服务器</h3>

<p>通过<code>awk</code>判断svn项目中所有文件的状态，对所有<code>?</code>状态的文件，将它们加入到svn的版本管理中，并提交。</p>

<pre><code>svn st | awk '{if ( $1 == ""?"") { print $2 }}' | xargs svn add
svn commit -m ""modify""
</code></pre>

<p>就这样大功告成啦，总共源码也只有60多行，有兴趣的朋友可以去看看源码，也可以fork<a rel=""nofollow"" href=""https://github.com/zry656565/git-for-SAE"">我的项目</a>并做一些贡献。</p>

                ", 极速地将git项目部署到SAE的svn服务器上,1531978099,179,1,115,1,1,https://segmentfault.com/a/1190000000788572
303,1,0,7,"
                    
<p><a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/GitHub"">Github</a> 相信已经成为家喻户晓的代码托管工具, 但访问了多位周围编程爱好者后发现, 对其的使用还仅限于 <strong>下载项目源码</strong> 和 <strong>备份项目源码</strong> 的程度, 今天我就来介绍一下一个比较重要的使用场景 <strong>贡献代码</strong></p>

<p>以 <a rel=""nofollow"" href=""https://github.com/swoole/swoole-src"">swoole</a> 为例:</p>

<h2>Fork 项目</h2>

<ul>
<li>首先需要fork这个项目, 进入项目页面, 点击右上角的Fork按钮</li>
<li>你的 github 帐号中会出现 swoole/swoole-src 这个项目</li>
<li>在本地电脑(Linux)上使用以下命令: 得到一个 swoole-src 文件夹</li>
</ul>
<pre><code>git clone git@github.com:samt42/swoole-src.git 
</code></pre>

<h2>获取原项目代码</h2>

<ul>
<li>进入 swoole-src 文件夹, 添加 swoole 的远程地址</li>
</ul>
<pre><code>git remote add upstream https://github.com/swoole/swoole-src.git
</code></pre>

<ul>
<li>获取 swoole 最新源码</li>
</ul>
<pre><code>git pull upstream master
</code></pre>

<p>现在我们在 fork 来的 master 分支上, 这个 master 留作跟踪 upstream 的远程代码...</p>

<h2>创建分支</h2>

<ul>
<li>
<p>好了, 现在可以开始贡献我们的代码了<br>
按照国际惯例, 我们一般不在 master 上提交新代码, 而需要为新增的功能或者fixbug建立新分支, 再合并到 master 上, 使用以下代码创建分支</p>

<pre><code>git checkout -b branch1
</code></pre>

<p>现在我们可以在分支上更改代码了</p>
</li>
<li>
<p>假设我们已经添加了一些代码, 提交到代码库</p>

<pre><code>git commit -a -m ""new commit""
</code></pre>
</li>
</ul>
<h2>合并修改</h2>

<ul>
<li><p>一个常见的问题是远程的 upstream (swoole/swoole-src) 有了新的更新, 从而会导致我们提交的 Pull Request 时会导致冲突, 因此我们可以在提交前先把远程其他开发者的commit和我们的commit合并.</p></li>
<li>
<p>使用以下代码切换到 master 分支:</p>

<pre><code>git checkout master
</code></pre>
</li>
<li>
<p>使用以下代码拉出远程的最新代码:</p>

<pre><code>git pull upstream master
</code></pre>
</li>
<li>
<p>切换回 branch1:</p>

<pre><code>git checkout branch1
</code></pre>

<pre><code>&gt; 如果忘记自己之前建的分支名可以用 `git branch` 查看
</code></pre>
</li>
<li>
<p>把 master 的 commit 合并到 branch1:</p>

<pre><code>git rebase master
</code></pre>
</li>
<li>
<p>把更新代码提交到自己的 branch1 中:</p>

<pre><code>git push origin branch1
</code></pre>
</li>
</ul>
<h2>Pull Request</h2>

<ul>
<li>提交 Pull Request<br>
你可以在你的 github 代码仓库页面切换到 branches 页面点击 branch1 分支后点击 <code>New pull request</code> 按钮, 添加相关注释后提交.<br>
OR<br>
切换到 branch1 分支的代码仓库点击 <code>Compare &amp; pull request</code> 按钮, 添加相关注释后提交.</li>
</ul>

                ", 如何优雅地在github上贡献代码,1531978101,501,1,574,1,1,https://segmentfault.com/a/1190000000736629
304,1,0,7,"
                    
<h1>主要内容</h1>

<ul>
<li>版本回退</li>
<li>工作区和暂存区 </li>
<li>管理修改 </li>
<li>撤销修改 </li>
<li>删除文件</li>
</ul>
<h1>一、两条基本查看命名</h1>

<h2>查看状态命令:<code>git status</code>
</h2>

<h2>查看修改内容命令：<code>git diff</code>
</h2>

<h2>实例</h2>

<p><strong>思路：</strong>修改<code>readme.txt</code>文本内容 -&gt; 查看状态：<code>git status</code> -&gt; 查看具体内容：<code>git diff</code> -&gt; 了解修改内容后提交：<code>git -add</code> -&gt; 再查看仓库的当前状态</p>

<blockquote>
  <p><code>git diff</code>顾名思义就是查看different，显示的格式正是Unix通用的diff格式。</p>
</blockquote>

<h2>小结</h2>

<ul>
<li>要随时掌握工作区的状态，使用git status命令。</li>
<li>如果git status告诉你有文件被修改过，用git diff可以查看内容。</li>
</ul>
<h1>二、版本回退</h1>

<h2>历史版本还原命令：<code>git reset --hard commit_id</code>
</h2>

<h2>查看提交历史命令：<code>git log</code>
</h2>

<h2>恢复先前版本命令：<code>git reflog</code> + <code>git reset</code>
</h2>

<h2>实例</h2>

<p>对先前的<code>myrepo/readme.txt</code>进行修改，然后把修改提交到Git版本库。</p>

<p>修改readme.txt文件如下：</p>

<p><code>Git is a distributed version control system.</code><br><code>Git is free software distributed under the GPL.</code></p>

<p>然后尝试提交：</p>

<p><code>$ git add readme.txt</code><br><code>$ git commit -m ""append GPL""</code><br><code>[master 3628164] append GPL</code><br><code>1 file changed, 1 insertion(+), 1 deletion(-)</code></p>

<blockquote>
  <p>不断地对文件进行修改，然后不断提交到修改到版本库里，就好比玩游戏里的存档，如果某一关没过去，可以选择读取前一关的状态。</p>
</blockquote>

<blockquote>
  <p>有些时候，在Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“<strong>保存一个快照</strong>”，这个快照在Git中被称为<strong>commit</strong>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
</blockquote>

<p>在Git中，我们可以用<code>git log</code>命令来查看readme.txt文件一共有几个版本被提交到Git仓库里：</p>

<p><code>$ git log</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVddRA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>如果觉得输入信息太多，看的眼花缭乱，可以试试加上<code>--pretty=oneline</code>参数：</p>

<p><code>$ git log --pretty=oneline</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVddRB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<blockquote>
  <p>注意：前面看到的一大串类似于“1396b...74ele5”的是commit id（版本号），和SVN不一样，Git的commit id不是1,2,3...递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。</p>
</blockquote>

<blockquote>
  <p>为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本系统，后面还有多人在同一个版本库里工作，如果大家都用1,2,3...作为版本号，那肯定就冲突了。</p>
</blockquote>

<blockquote>
  <p>每提交一个新版本，实际上Git就把它们自动串成一条时间线。</p>
</blockquote>

<p>好了，现在我们来启动时光机！把<code>readme.txt</code>回退到上一个版本，也就是“add distributed”的版本。</p>

<blockquote>
  <p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“59877e...cfe6”，上一个版本是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上写100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
</blockquote>

<p>现在，我们把当前版本“append GPL”回退到上一个版本“add distributed”:</p>

<p><code>$ git reset --hard HEAD^</code><br><code>HEAD is now at 1396b06 append GPL</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVdd4l"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>查看<code>readme.txt</code>的内容是不是版本“add distribute”:</p>

<p><code>$ cat readme.txt</code></p>

<p><span class=""img-wrap""><img data-src=""/img/bVdd4t"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>是的。</p>

<p>还可以继续回退到上一个版本“wrote a readme file”，但需先用git log查看现在版本库的状态。</p>

<p>你会发现最新的那个版本“append GPL”已经看不到了。好比你从21世纪坐时光穿梭机来到了19世纪，想回去已经回不到了，肿么办？</p>

<p>解决办法：只要上面的命令窗口还没有被关掉，可以顺着网上找，找到那个版本的 commit id 然后输入版本号的前几位数字，Git就会自动去找，再<code>git reset</code>一下就回来。</p>

<blockquote>
  <p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>，改为指向<code>add distributed</code>，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVdd4J"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVdd4K"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>另外，Git还提供了一个命令<code>git reflog</code>用来记录你的每一条命令。可以从显示信息里面找到忘记了的想回退的新版本的<code>commit id</code>。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVdd4R"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>小结</h2>

<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h1>三、工作区和暂存区</h1>

<blockquote>
  <p>Git和其它版本控制系统如SVN的一个不同之处就是有<strong>暂存区</strong>的概念。</p>
</blockquote>

<h2>工作区（<em>Working Directory</em>）</h2>

<blockquote>
  <p>工作区就是你在电脑里能看到的目录，比如<code>myrepo</code>文件夹就是一个工作区。</p>
</blockquote>

<h2>版本库（<em>Repository</em>）</h2>

<blockquote>
  <p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是git的版本库。</p>
</blockquote>

<blockquote>
  <p>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
</blockquote>

<p><span class=""img-wrap""><img data-src=""/img/bVddOP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<p>第一步：用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>

<p>第二步：用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>

<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVddOW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p><span class=""img-wrap""><img data-src=""/img/bVddOX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<h2>小结</h2>

<blockquote>
  <p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
</blockquote>

<h1>四、管理修改</h1>

<p>下面我们来讨论的是，为什么Git比其它版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>

<h2>实例</h2>

<p><strong>思路</strong>：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>

<p>说明：Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>

<blockquote>
  <p>提示：用<code>git diff HEAD --readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p>
</blockquote>

<h2>小结</h2>

<p>从以上实例可以知道Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>

<h1>五、撤销修改</h1>

<h2>丢弃工作区修改的命令：<code>git checkout --file</code>
</h2>

<p>命令<code>git checkout --readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>

<ul>
<li><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li>
<li><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。</p></li>
</ul>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>

<blockquote>
  <p>注意：<code>git checkout --file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“创建一个新分支”的命令，在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
</blockquote>

<h2>撤销暂存区修改的命令（unstage）：<code>git reset HEAD file</code>
</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVdd6c"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<blockquote>
  <p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改会退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
</blockquote>

<h2>小结</h2>

<ul>
<li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout --file</code>。</p></li>
<li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p></li>
<li><p>场景3：已经提交了不适合的修改到版本库时，想要撤销本次提交，参考<code>版本回退</code>一节，不过<strong>前提是没有推送到远程库</strong>。</p></li>
</ul>
<h1>六、删除文件</h1>

<h2>删除命令：<code>git rm</code>
</h2>

<h2>实例</h2>

<p>在Git中，删除也是一个修改操作。首先，我们先添加一个新文件<code>test.txt</code>到Git并且提交：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVdd6S"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>

<p><code>$ rm test.txt</code></p>

<blockquote>
  <p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了。</p>
</blockquote>

<p>现在你有两个选择：</p>

<ul>
<li><p>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且commit。</p></li>
<li><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p></li>
</ul>
<p><code>$ git checkout -- test.txt</code></p>

<blockquote>
  <p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“<strong>一键还原</strong>”。</p>
</blockquote>

<h2>总结</h2>

<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，<strong>你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容</strong>。</p>

<hr>
<p>详细教程请戳这里：<a rel=""nofollow"" href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"">Git教程 - 廖雪峰的官方网站</a></p>

                ", Git 进阶 —— 时光穿梭机,1531978102,481,1,814,1,1,https://segmentfault.com/a/1190000000730170
305,1,0,7,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVbWVk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""cheat 小漫画""></span></p>

<blockquote>
  <p>cheat是一个相当不错的开源项目，关键在于其实用性。</p>
</blockquote>

<h3>cheat究竟用来干嘛？</h3>

<p>如同上述幽默的配图一样，我们虽然能够使用man和--help来帮助我们查看命令使用方式，但是很多工程师都觉得，他们显然还不够man!</p>

<h3>看看cheat是怎么man的</h3>

<p>当我敲下cheat tar的时候，我看到的是很多实用的example，事实上，这种帮助信息更容易记忆，值得一提的是，cheat甚至还会输出一些高级用法！</p>

<p><span class=""img-wrap""><img data-src=""/img/bVc3Xa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""cheat 示例""></span></p>

<h3>cheat 安装</h3>

<h4>安装依赖</h4>

<pre><code class=""lang-bash"">pip install docopt
</code></pre>

<blockquote>
  <p>git clone</p>
</blockquote>

<pre><code class=""lang-bash"">git clone https://github.com/chrisallenlane/cheat.git
</code></pre>

<h4>进入到目录下</h4>

<pre><code>python setup.py install
</code></pre>

<blockquote>
  <p>pip</p>
</blockquote>

<pre><code class=""lang-bash"">pip install cheat
</code></pre>

<h3>cheat 使用</h3>

<pre><code class=""lang-bash"">cheat tar
</code></pre>

<blockquote>
  <p>输出结果</p>
</blockquote>

<pre><code># To extract an uncompressed archive:
tar -xvf /path/to/foo.tar

# To create an uncompressed archive:
tar -cvf /path/to/foo.tar /path/to/foo/

# To extract a .gz archive:
tar -xzvf /path/to/foo.tgz

# To create a .gz archive:
tar -czvf /path/to/foo.tgz /path/to/foo/

# To list the content of an .gz archive:
tar -ztvf /path/to/foo.tgz

# To extract a .bz2 archive:
tar -xjvf /path/to/foo.tgz

# To create a .bz2 archive:
tar -cjvf /path/to/foo.tgz /path/to/foo/

# To list the content of an .bz2 archive:
tar -jtvf /path/to/foo.tgz

# To create a .gz archive and exclude all jpg,gif,... from the tgz
tar czvf /path/to/foo.tgz --exclude=\*.{jpg,gif,png,wmv,flv,tar.gz,zip} /path/to/foo/
</code></pre>

<h3>更多cheat command</h3>

<pre><code class=""lang-bash"">cheat &lt;cheatsheet&gt;
cheat -e &lt;cheatsheet&gt;
cheat -s &lt;keyword&gt;
cheat -l
cheat -d
cheat -v
</code></pre>

<h3>cheat 源码</h3>

<p><a rel=""nofollow"" href=""https://github.com/chrisallenlane/cheat"" title=""Github"">Github</a></p>

                ", ［极客工具］cheat-linux命令行实用助记工具,1531978103,514,1,751,1,1,https://segmentfault.com/a/1190000000691131
306,1,0,7,"
                    <p>本来已经不写文字博客了，一般心得都录成了视频（这在我看来是更好的方式），但是今天遇到一个关于 Git 的问题不太好重现也不便于录制视频，加上它本身很具有代表性也很有用，所以还是记录于此。</p>

<h2>背景</h2>

<p>一个中型规模项目，开始规划时就打算采用 C/S 架构，后端是单纯的 API 服务，前端在 Web 上搞一个 SPA，之后再搞其他端也就顺理成章了。只可以第一次弄没经验，有些细节最初没有考虑到。</p>

<p>创建项目的时候前后端真是完全分离的，分成了两个目录，创建了两个 <em>repos</em>。一开始只有一个人干的时候倒也没什么，开两个窗口切来切去也就罢了，后来一是部署起来麻烦，二来主要是其他开发者加入后，代码的版本管理、提交、合并、审核等等等等都变得越来越繁琐。</p>

<p>后来一想：架构上分离而已，干嘛非要两个目录两个 <em>repos</em>？真是自找麻烦！于是就开始考虑整合。</p>

<h2>要求</h2>

<p>把两个目录并成一个倒不难，但是要完整保留双方的历史记录就有些麻烦了，这也是唯一一个必须要实现的目标。</p>

<h2>过程</h2>

<p>首先为了便于描述，约定整合前两个目录分别叫做 <code>frontend</code> 和 <code>backend</code>，合并后的结构与名称应当如下：</p>

<pre><code>- project/                  =&gt; 即最开始的 frontend，整合完后更名
  - .gitignore              =&gt; 合并两个 repos 的忽略文件
  - .git/                   =&gt; 最终仅余一个 repo
  + client/                 =&gt; 对应 frontend
  + server/                 =&gt; 对应 backend
</code></pre>

<p>以下步骤是以 <code>frontend</code> 为基点，把 <code>backend</code> 移进来，实际上反过来也是一样的，自行替换对应的名称即可。在开始之前先清理两个 <em>repos</em> 里的工作记录，该提交的提交，该备份的备份，保持干净。</p>

<pre><code class=""lang-bash"">1. $ [~] cd frontend
2. $ [frontend] git remote add -f backend /fullpath/to/backend
3. $ [frontend] git merge --strategy ours --no-commit backend/master
4. $ [frontend] mkdir -p server
5. $ [frontend] git read-tree --prefix=server/ -u backend/master
6. $ [frontend] git commit --message '完成 backend 的迁移，新目录为 server'
7. $ [frontend] mkdir -p client
8. # 拷贝 frontend 的原始项目文件（除了 .git/ 和 .gitignore 以外）至 client/
9. $ [frontend] cd ..; mv frontend/ project/; cd project
10. $ [project] cat server/.gitignore &gt;&gt; .gitignore
11. # 整理合并后的 .gitignore，修复其中的路径缺失并保存；修复各种项目依赖的缺失，本地测试。
12. $ [project] git add --all; git commit --message '迁移整合完成！'
</code></pre>

<p>以上是完整的步骤先列出来方便参考，下面做一个详细的解释。</p>

<p>整个过程中主要用到的工具是 <em>merge</em> 和 <em>read-tree</em>，前者用于合并历史记录并且中断在最后提交之前，所产生的文件冲突不会被写入硬盘；然后利用后者重写整个文件树并把读取到的内容（读取的目标是 <code>backend</code>）写入新的路径下。最后提交以结束合并。</p>

<p>第<code>2</code>步里，我们把 <code>backend</code> 作为 <em>remote server</em> 添加到 <code>frontend</code> 库中。<code>-f</code> 的作用是在添加后立刻 <code>fetch</code>。要注意一定得使用绝对路径来引用 <code>backend</code> 库。</p>

<p>第<code>3</code>步里，<code>--strategy ours</code> 比较难以理解，且听我详细道来：一般来说当合并两个文件树时，如果遇到冲突我们是需要手动去解决它的，但是目前我们要做的不是解决冲突，而是在引入 <code>backend</code> 历史记录的前提下完整保留 <code>frontend</code> 的内容。冲突肯定是会有的，即使两个不同的项目也是如此，比方说两边都有 <code>README.md</code>、<code>app/</code>、<code>config/</code> 等文件或目录，但是我们不关心冲突，我们只要保留 <code>frontend</code> 的文件树并且把 <code>backend</code> 的历史记录合并进来。</p>

<p><code>--strategy ours</code> 会完成全部的合并解析，但是所有的冲突都以“我”为准，不允许外来的冲突覆盖“我”的文件内容。最终的结果就是：</p>

<ol>
<li><code>backend</code> 的历史记录被合并到 <code>frontend</code> 的历史记录中</li>
<li><code>backend</code> 的文件树被读取并和 <code>frontend</code> 的文件树比对进行冲突解析：<br>
<br>
<ul>
<li>如果发现冲突，以 <code>frontend</code> 为准，丢弃所有内容变更</li>
<li>没冲突的则保留（但是我们也不要的，见后面的内容）</li>
</ul></li>
</ol>

<p>这也是后面紧接着使用 <code>--no-commit</code> 的原因，该选项会在合并解析完成后中断，停留在最后的提交步骤之前。我们知道，只要你还没 <em>commit</em>，那么 <em>merge</em> 的结果就暂时保存在缓存区中，只有完成提交步骤合并才算彻底完成（文件树被正式改变）。这就给我们一个机会来重新读取 <code>backend</code> 的文件树，并改写其保存的位置。不过在此之前，第<code>4</code>步先要创建目标子目录（很重要！）。</p>

<p>第<code>5</code>步开始 <em>read-tree</em> 了，<code>--prefix</code> 用于指定文件树读取后保存的路径，相对于当前路径并且一定要追加 <code>/</code>。<code>-u</code> 是说在读取后更新 <em>index</em>，使得 <em>working tree</em> 与 <em>index</em> 保持同步。如果你不小心忘了加 <code>-u</code>，可以在这一步之后执行 <code>git add --update</code>，一样的效果。</p>

<p>这一步在背后有些细节比较抽象，之前的 <em>merge</em> 也曾读取过 <code>backend</code> 的文件树，但经过冲突解析之后已经面目全非，分析如下：</p>

<ul>
<li>有冲突的被丢弃，因此一部分文件／目录其实已经不存在了</li>
<li>没冲突的被保留，但是路径还在 <code>frontend</code> 的根路径下</li>
</ul>

<p>经过再次 <em>read-tree</em>，上面的“遗迹”得以修复，结果如下：</p>

<ul>
<li>有冲突的因为已被丢弃，所以直接从本次读取中获得，且路径前面追加 <code>--prefix</code> 选项的值</li>
<li>没冲突的虽然被保留，但是由于本次读取追加了 <em>prefix</em>，所以它们的路径也被改变，相当于在缓存里做了一次 <code>git mv</code></li>
</ul>

<p>好了，重点就是这些，之后的步骤都很寻常，只要小心操作就没什么难理解的。</p>

                ", 如何用 Git 合并两个库（合并历史记录，解决冲突／改写路径）,1531978104,178,1,303,1,1,https://segmentfault.com/a/1190000000678808
307,1,0,7,"
                    <p>不错的Git常用命令图解：<br><span class=""img-wrap""><img data-src=""/img/bVtnx7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
                ", Git 常用命令图片展示,1531978105,454,1,850,1,1,https://segmentfault.com/a/1190000000669548
308,1,0,7,"
                    
<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>

<pre><code>git clone
git remote
git fetch
git pull
git push
</code></pre>

<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>

<p>一、git clone</p>

<p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>

<p>$ git clone &lt;版本库的网址&gt;</p>

<p>比如，克隆jQuery的版本库。</p>

<p>$ git clone <a rel=""nofollow"" href=""https://github.com/jquery/jquery.git"">https://github.com/jquery/jquery.git</a></p>

<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>

<p>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p>

<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>

<p>$ git clone http[s]://example.com/path/to/repo.git/<br>
$ git clone ssh://example.com/path/to/repo.git/<br>
$ git clone git://example.com/path/to/repo.git/<br>
$ git clone /opt/git/project.git<br>
$ git clone file:///opt/git/project.git<br>
$ git clone ftp[s]://example.com/path/to/repo.git/<br>
$ git clone rsync://example.com/path/to/repo.git/</p>

<p>SSH协议还有另一种写法。</p>

<p>$ git clone [user@]example.com:path/to/repo.git/</p>

<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。<br>
二、git remote</p>

<p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p>

<p>不带选项的时候，git remote命令列出所有远程主机。</p>

<p>$ git remote<br>
origin</p>

<p>使用-v选项，可以参看远程主机的网址。</p>

<p>$ git remote -v<br>
origin  git@github.com:jquery/jquery.git (fetch)<br>
origin  git@github.com:jquery/jquery.git (push)</p>

<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>

<p><a rel=""nofollow"" href=""http://codecloud.net/git-1419.html"">摘自程序员的资料库</a></p>

                ", Git远程操作详解,1531978106,161,1,605,1,1,https://segmentfault.com/a/1190000000581485
309,1,0,7,"
                    
<p>那些可能用到的好工具<br><figure><blockquote>
    <p>本文介绍的东西都是平时可能用到的，cool stuff</p>
  </blockquote>
  
  <h2>画图工具，uml,原型等</h2>
  
  <p>写论文或者是文档的时候，有的时候需要各种图，uml,原型等等,<br>
  这时候很需要一个好的app可以轻松搞定这些东西。</p>
  
  <p><a rel=""nofollow"" href=""http://www.processon.com/diagrams"">processon</a> 免费，貌似是国产</p>
  
  <h2>幻灯片制作</h2>
  
  <p>还在用powerpoint?<br>
  一直以来觉得ppt就应该让你更关注与内容，而不是动画，好在有<br>
  不错的app。</p>
  
  <p><a rel=""nofollow"" href=""https://slidebean.com/"">slidebean</a> 缺点: 免费版无法下载</p>
  
  <p><a rel=""nofollow"" href=""http://remarkjs.com/"">remarkjs</a> 使用markdown写ppt 缺点：需要使用现代浏览器</p>
  
  <p>给一个remarkjs用例<a rel=""nofollow"" href=""https://github.com/duoduo369/techdict_paper"">链接</a>,注意<br>
  里面的字体20M(娃娃体), 只需修改index.html即可。</p>
  
  <p><a rel=""nofollow"" href=""https://speakerdeck.com/"">speakerdeck</a> 这里有很多很赞的ppt</p>
  
  <h2>梯子</h2>
  
  <p>上不了google(还在用百度么亲)</p>
  
  <p><a rel=""nofollow"" href=""https://github.com/goagent/goagent"">goagent</a></p>
  
  <h2>团队合作|todolist</h2>
  
  <p><a rel=""nofollow"" href=""https://fengcheco.com/"">风车</a></p>
  
  <p>个人用,每月10元，UI超赞,支持markdown, github动态<br>
    缺点，付费方式比较麻烦，需要信用卡</p>
  
  <p>其他可选(免费)</p>
  
  <p><a rel=""nofollow"" href=""https://www.teambition.com/"">teambition</a> 不用风车的话首选</p>
  
  <p><a rel=""nofollow"" href=""www.tower.im"">tower</a> 缺点，同时只能有一个任务能是进行中</p>
  
  <h2>记事本</h2>
  
  <p><a rel=""nofollow"" href=""http://www.yinxiang.com/"">印象笔记</a>　非常强大的东西手机端做的也很棒</p>
  
  <p><a rel=""nofollow"" href=""http://maxiang.info/"">马克飞象</a> 专为印象笔记打造的Markdown编辑器</p>
  
  <h2>域名</h2>
  
  <p><a rel=""nofollow"" href=""http://www.godaddy.com/"">godaddy</a> 喜闻乐见的可以中支付宝,不要去万网, 要不等着照相吧，你懂得</p>
  
  <h2>互联网招聘</h2>
  
  <p><a rel=""nofollow"" href=""http://www.neitui.me/"">内推</a></p>
  
  <p><a rel=""nofollow"" href=""http://www.lagou.com/"">拉勾</a></p>
  
  <h2>社区</h2>
  
  <p><a rel=""nofollow"" href=""http://segmentfault.com/"">segmentfault</a> 中国的<a rel=""nofollow"" href=""http://stackoverflow.com/"">stackoverflow</a></p>
  
  <p><a rel=""nofollow"" href=""http://www.oschina.net/"">开源中国</a> 活跃的社区</p>
  
  <p><a rel=""nofollow"" href=""http://www.v2ex.com/"">v2ex</a> 不错的社区</p>
  
  <p><a rel=""nofollow"" href=""https://ruby-china.org/"">ruby-china</a> 非常活跃的ruby社区,为python社区心酸</p>
  
  <p><a rel=""nofollow"" href=""http://www.zhihu.com/"">知呼</a> 优质问答</p>
  
  <p><a rel=""nofollow"" href=""http://www.appletuan.com/"">苹果团</a> 买苹果，到这里</p>
  
  <h2>FM</h2>
  
  <p><a rel=""nofollow"" href=""http://teahour.fm/"">teahour</a>　硬货超多的一个FM, 讲的都是程序员的那些事儿</p>
  
  <p><a rel=""nofollow"" href=""http://jing.fm/"">jing.fm</a> 一个很有意思的电台</p>
  
  <p>程序员部分</p>
</figure></p>

<h2>编辑器</h2>

<p>vim 不喜欢按ctrl(emacs)</p>

<h2>版本控制</h2>

<p>git, 用户体验远超svn</p>

<p><a rel=""nofollow"" href=""http://git.oschina.net/progit/"">Pro Git中文</a></p>

<p><a rel=""nofollow"" href=""https://github.com/"">github</a></p>

<h2>api设计</h2>

<p>REST | restful</p>

<p><a rel=""nofollow"" href=""https://github.com/interagent/http-api-design"">http-api-design</a> 你该这么设计api</p>

<p>前端部分<br><figure><p>注重用户体验并且不注重IE的请看这里</p>
  
  <h2>用coffee替代js</h2>
  
  <p><a rel=""nofollow"" href=""http://coffeescript.org/"">coffeescript</a> 原生的js写起来很麻烦，建议用coffee写, 上手迅速</p>
  
  <h2>使用html5的新标签</h2>
  
  <h2>选一个MVC框架简化你的工作</h2>
  
  <p>backbone资料众多，并且可以直接从dom上进行一些操作，推荐<br>
  缺点，作者文档写的很烂，需要读源码。</p>
  
  <p><a rel=""nofollow"" href=""http://chaplinjs.org/"">chaplin</a>　backbone的一个框架，弥补backbone的不足</p>
  
  <p><a rel=""nofollow"" href=""https://github.com/duoduo369/chaplin_boilerplate"">脚手架</a></p>
  
  <h2>构建工具和包管理器</h2>
  
  <p><a rel=""nofollow"" href=""http://brunch.io/"">brunch</a> 前端构建工具, 缺点，配置文件没有非常详细的教程(中文), css编译时顺序不知道怎么配置。</p>
  
  <p><a rel=""nofollow"" href=""http://bower.io/"">bower</a> 包管理器，让你摆脱手工下载一个个依赖文件的东西。</p>
  
  <p>python部分</p>
</figure></p>

<h2>python包管理器</h2>

<p><a rel=""nofollow"" href=""https://pypi.python.org/pypi/pip/"">pip</a> python的包无需手动下载,copy,只需要pip install 你的包</p>

<h2>python环境管理工具</h2>

<p><a rel=""nofollow"" href=""https://virtualenv.pypa.io/en/latest/"">virtualenv</a> 让你机器可以运行多个不同的python版本，例如一台linux可能需要django 1.5\1.6</p>

<h2>python编码规范</h2>

<p><a rel=""nofollow"" href=""http://legacy.python.org/dev/peps/pep-0008/"">PEP8</a></p>

<p><a rel=""nofollow"" href=""https://pypi.python.org/pypi/pylint"">pylint</a> 代码评估工具，可以让你写出一手更好的代码</p>

<h2>rest api</h2>

<p><a rel=""nofollow"" href=""http://www.django-rest-framework.org/"">django rest</a> 轻松用django实现rest api,有很棒的权限系统</p>

<h2>脚本</h2>

<p><a rel=""nofollow"" href=""https://github.com/docopt/docopt"">docopt</a>　更容易的写命令提示<br><a rel=""nofollow"" href=""https://github.com/mitsuhiko/click"">click</a> 很火的一个项目，号称比docopt等更适合写脚本</p>

<h2>服务器</h2>

<p><a rel=""nofollow"" href=""http://gunicorn.org/"">gunicorn</a> 优点: 配置简单</p>

<p><a rel=""nofollow"" href=""http://nginx.org/"">nginx</a> 一般的web服务器处理静态文件都可以算作一个瓶颈问题，nginx是专业的，可以大大提高并发数，响应速度。</p>

<p><a rel=""nofollow"" href=""https://github.com/Supervisor/supervisor"">supervisor</a> 进程管理工具，可以方便的部署项目，并且做到开机自动启动你的配置项目等</p>

<p><a rel=""nofollow"" href=""http://www.fabfile.org/"">fabric</a> ssh工具，可以简单化项目部署</p>

<h1>last</h1>

<p><a rel=""nofollow"" href=""https://github.com/duoduo369/skill_issues"">skill_issues</a> 本文所记录的工具在这里面基本都有详细的使用说明，以及遇到问题的解决方案,具体代码在我其他的项目中也都有实现，需要的化可以看下。</p>

<p><a rel=""nofollow"" href=""https://github.com/duoduo369/skill_issues/blob/master/skill/good_tools.md"">本文最新地址</a> 文章放在git上，博客可能不更新，但是git会</p>

                ", 那些可能用到的好工具,1531978107,387,1,816,1,1,https://segmentfault.com/a/1190000000578478
310,1,0,7,"
                    
<p>考虑到自己维护 Git 服务器的成本，以及国内的类 GitHub 平台的安全顾虑和对钩子、CI 等功能的支持度。。。最后我们团队还是用了 GitHub 的付费 plan。</p>

<h2>CircleCI</h2>

<p>有了 GitHub 这么屌的平台，当然也要上个很屌的 CI 啦。留意到了一个 <a rel=""nofollow"" href=""https://circleci.com/"">CircleCI</a>，相比 Travis CI 有几个不错的地方：</p>

<ul>
<li>可以 SSH 到测试容器，方便在出问题的时候上去调试找原因（咦，好像想到了什么……啊我什么都没说！方校长手下留情！！）</li>
<li>私有项目的 plan 比 Travis CI 便宜啊！</li>
</ul>
<h2>于是就这么决定了</h2>

<p>如何集成到 GitHub，这个和 Travis CI 是一样的，启用一下就行了。GitHub 对它也有比较好的支持，和 Travis CI 没什么差别。</p>

<p>首先建议看两篇文档：</p>

<ul>
<li><a rel=""nofollow"" href=""https://circleci.com/docs/configuration"">Configuring CircleCI</a></li>
<li><a rel=""nofollow"" href=""https://circleci.com/docs/environment"">Test environment</a></li>
</ul>
<p>关于 Android 项目的配置，<a rel=""nofollow"" href=""https://circleci.com/docs/android"">官方文档</a>说得几乎等于没说。好吧，虽然 Gradle 项目丢上去不用配置它也知道怎么跑，但是默认环境还是缺了点东西，自己写下配置吧。</p>

<pre><code class=""lang-yaml"">machine:
  java:
    version: oraclejdk8
  environment:
    ANDROID_HOME: /usr/local/android-sdk-linux

dependencies:
  override:
    - echo y | android update sdk --no-ui --filter ""android-19""
    - echo y | android update sdk --no-ui --filter ""build-tools-19.1.0""
    - echo y | android update sdk --no-ui --filter ""extra-android-m2repository""
    - echo y | android update sdk --no-ui --filter ""extra-android-support""
    - echo y | android update sdk --no-ui --filter ""extra-google-m2repositor""

test:
  override:
    - ./gradlew build
  post:
    - cp -R ./XXXXXXXX/build/apk $CIRCLE_ARTIFACTS
</code></pre>

<p>简单说一下。首先 <code>machine</code> 节点里，我把 JDK 版本指定了 Oracle JDK 8（默认是 OpenJDK 7）。然后又加了一个 <code>ANDROID_HOME</code> 的环境变量指向 Android SDK 的位置（TMD，既然你文档里都说了 Android SDK 在这个路径，竟然不给我配好环境变量）。</p>

<p><code>dependencies</code> 节点，如果它识别到你是 Gradle 项目，默认情况下只是 <code>gradle dependencies</code>。于是结果显而易见——至少也要把 Android SDK Build-tools 装上吧 XD</p>

<p>对了，它自带的 Gradle 版本是 1.10，有点旧了。而且习惯上我们应该用自己的 wrapper 来跑的（Travis CI 在这点就做得很好，如果判断到你的项目里有 <code>./gradlew</code> 就会用里的 wrapper 来跑，而不是系统的 <code>gradle</code> 命令）。</p>

<h2>屌炸天的重点来了</h2>

<p>CircleCI 提供了一个归档功能……就是说，你只要在运行完毕之后把需要收集的文件拷贝到 <code>$CIRCLE_ARTIFACTS</code> 这个目录，它就会帮你收集保存下来给你下载……屌炸天了对不？</p>

<p>上面我在 <code>test</code> 节点挂了个 <code>post</code> 钩子，收集编译好的 APK。同理，你也可以收集 ProGuard 的 Mapping 日志（用于跟踪混淆后的代码），可以收集 Lint 报告、覆盖率报告等等等等！</p>

                ", 初涉 GitHub + CircleCI,1531978109,462,1,169,1,1,https://segmentfault.com/a/1190000000578286
311,1,0,7,"
                    
<blockquote><p>Git 是在linux下开发的，而 Linux 的编码方式是基于 UTF-8 的，所以移植到 Windows 之后难免会存在编码冲突，导致乱码。Git 在 Windows 下有多种乱码情况，请按具体情况操作～<br>假设 Git 安装目录为 <code>C:\Git</code></p></blockquote>
<h2>1.使用 git add 命令添加文件名含中文字符的文件时</h2>
<h5>1.1 乱码类似：</h5>
<pre><code>    \316\304\261\276\316\304\265\265.txt
</code></pre>
<h5>1.2 解决方案：</h5>
<p>编辑 <code>C:\Git\etc\inputrc</code> 文件中对应的行，查找以下2行，并修改其值，<br>原先：</p>
<pre><code>    
    set output-meta off
    set convert-meta on</code></pre>
<p>改为：</p>
<pre><code>    
    set output-meta on
    set convert-meta off
</code></pre>
<h2>2.使用git log查看含有中文的log信息时</h2>
<h5>2.1 乱码类似：</h5>
<pre><code>    &lt;E4&gt;&lt;BF&gt;&lt;AE&gt;&lt;E6&gt;&lt;94&gt;&lt;B9&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E6&gt;&lt;9C&gt;&lt;AC&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E6&gt;&lt;A1&gt;&lt;A3&gt;
</code></pre>
<h5>2.2 解决方案：</h5>
<p>在Bash提示符下输入：</p>
<pre><code>
    git config --global i18n.commitencoding utf-8
    git config --global i18n.logoutputencoding gbk
</code></pre>
<p>注：设置 commit 提交时使用 utf-8 编码，可避免 Linux 服务器上乱码；同时设置在执行 <code>git log</code> 时将 utf-8 编码转换成 gbk 编码，以解决乱码问题。<br>编辑 <code>C:\Git\etc\profile</code> 文件，添加如下一行：</p>
<pre><code>    export LESSCHARSET=utf-8
</code></pre>
<p>注：以使git log可以正常显示中文（需要配合：<code>i18n.logoutputencoding gbk</code>）</p>
<h2>3.使用ls命令查看含有中文的文件名乱码时</h2>
<h5>3.1 乱码类似：</h5>
<pre><code>    
    ????.txt
    ???????.md
</code></pre>
<h5>3.2 解决方案：</h5>
<p>使用  <strong>ls --show-control-chars</strong>  命令来强制使用控制台字符编码显示文件名，即可查看中文文件名。<br>为了方便使用，可以编辑 C:Gitetcgit-completion.bash 文件，添加如下一行：</p>
<pre><code>    alias ls=""ls --show-control-chars""
</code></pre>
<h2>4.在Git Gui中查看UTF-8编码的文本文件时</h2>
<h5>4.1 乱码类似：</h5>
<pre><code>    锘夸腑鏂囨枃妗￡
</code></pre>
<h5>4.2 解决方案：</h5>
<p>在Bash提示符下输入：</p>
<pre><code>    git config --global gui.encoding utf-8
</code></pre>
<p>注：通过上述设置，UTF-8 编码的文本文件可以正常查看，但是 GBK 编码的文件将会乱码，所以还是没有从根本上解决问题。</p>
<p>可行的方法之一为：将所有文本文件的编码统一为 UTF-8 或 GBK，然后设置相应的<code>gui.encoding</code> 参数为 <code>utf-8</code> 或 <code>gbk</code>。</p>
<p><strong>注：本文参考他人成功，非完全原创。</strong></p>

                ", Git for windows 中文乱码解决方案,1531978110,498,1,851,1,1,https://segmentfault.com/a/1190000000578037
312,1,0,7,"
                    
<p>我们在使用 Git 进行版本控制的时候，有些文件是无需纳入 Git 管理的，通常都是些自动               生成的文件，像日志或者编译过程中创建的文件。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件来解决这个问题。<br>
来看一个简单的例子</p>

<pre><code>    # cat .gitignore
    *.[oa]
    *~
</code></pre>

<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。<br>
第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>

<p>文件 .gitignore 的格式规范如下：<br>
所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br>
可以使用标准的 glob 模式匹配。<br>
匹配模式最后跟反斜杠（/）说明要忽略的是目录。<br>
要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p>

<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。<br>
星号（*）匹配零个或多个任意字符；<br>
[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；<br>
问号（?）只匹配一个任意字符；<br>
如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>

<p>我们再看一个 .gitignore 文件的例子：</p>

<pre><code># 忽略所有 .a 结尾的文件
*.a

# 但 lib.a 除外
!lib.a

# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO

# 忽略 build/ 目录下的所有文件
build/

# 会忽略 doc/notes.txt 但不包括 doc/server/notes.txt
doc/notes.txt
</code></pre>

<p>其他信息可以直接 man gitignore 查看。</p>

<p>此外推荐一个自动生成 .gitignore 文件的网址：<a rel=""nofollow"" href=""http://www.gitignore.io/"">http://www.gitignore.io/</a><br>
对于iOS开发者，推荐一个 gist ：<a rel=""nofollow"" href=""https://gist.github.com/mmorey/6931793"">https://gist.github.com/mmorey/6931793</a></p>

                ", .gitignore 文件使用说明,1531978111,590,1,791,1,1,https://segmentfault.com/a/1190000000522997
313,1,0,7,"
                    
<blockquote>
  <p>本文面向<strong>初次</strong>接触版本控制系统的Git用户，旨在介绍一些关于版本控制和Git的简单概念。</p>
  
  <p>文中并不涉及过多的Git实际操作，文末推荐更多的Git学习资源。</p>
</blockquote>

<h3>导言</h3>

<p>Git是目前最先进的版本控制系统，拥有最多的用户数量并管理着数量庞大的实际软件项目。风靡全球的Github更是让Git版本控制系统名声大震。本文以“版本控制系统”为切入点，介绍相关概念和简单的Git用法。</p>

<h3>什么是版本控制系统？</h3>

<p>如果对“版本控制”没有概念，那真是没法用Git。</p>

<p>所以我们来看一个例子：假设大四毕业生小张在写毕业论文，写好初稿后经常删改，甚至还会在第二天把前一天删掉的东西找回来。如果他动点脑子，就不会只在一个文档中改来改去，而会在文件夹中有：</p>

<pre><code>毕业论文_初稿.doc
毕业论文_修改1.doc
毕业论文_修改2.doc
毕业论文_修改3.doc
毕业论文_完整版1.doc
毕业论文_完整版2.doc
毕业论文_完整版3.doc
毕业论文_最终版1.doc
毕业论文_最终版2.doc
……
</code></pre>

<p>看起来是不是很郁闷啊？小张当然也郁闷了，因为自己总是改不好，所以他把自己的论文发给女朋友（是学霸），求帮忙；与此同时他自己也在继续修改。第二天就有了：</p>

<pre><code>毕业论文_最终版3.doc
毕业论文_女友版1.doc
</code></pre>

<p>他女友毕竟是学霸，当然给他的论文做了比较大的修改，此时小张虽然看到了希望，但还要纠结着做一件事情：把上面两个版本的论文合并成：</p>

<pre><code>毕业论文_死也不改版.doc
</code></pre>

<p>等合并好，已是凌晨三点半。小张无比怨念：这样子真是没法和女友开心的玩耍了呢！</p>

<p><strong>怎么办？</strong></p>

<p>小张想，如果能有个什么东西来帮忙控制一下这该死的版本，那真是谢天谢地了！就像这样：</p>

<table>
<thead><tr>
<th>版本</th>
  <th>修改人</th>
  <th>说明</th>
  <th>日期</th>
</tr></thead>
<tbody>
<tr>
<td>初稿</td>
  <td>小张</td>
  <td>这是初稿</td>
  <td>Day1</td>
</tr>
<tr>
<td>修改1</td>
  <td>小张</td>
  <td>修改目录</td>
  <td>Day2</td>
</tr>
<tr>
<td>修改2</td>
  <td>小张</td>
  <td>合并段落</td>
  <td>Day3</td>
</tr>
<tr>
<td>……</td>
  <td>……</td>
  <td>……</td>
  <td>……</td>
</tr>
<tr>
<td>最终版2</td>
  <td>小张</td>
  <td>xxx</td>
  <td>Day7</td>
</tr>
<tr>
<td>死也不改版</td>
  <td>女友</td>
  <td>balabala</td>
  <td>Day8</td>
</tr>
</tbody>
</table>
<p>这样就不用手动控制那么多版本啦！</p>

<p><strong>所以，所谓“版本控制系统”，就是来解决这类问题的。</strong></p>

<h3>Git又是什么？</h3>

<p>没错，Git就是一个版本控制软件。在进行软件开发时，一个团队的人靠使用Git，就能轻松管理好项目版本，做好项目的追踪和辅助进度控制。确切的讲，Git是一款分布式版本控制系统。这个“分布式”，要和“集中式”放在一起理解。</p>

<p>所谓“集中式版本控制”，就好比这一个团队中，<strong>版本库</strong>都集中在一台服务器上，每个开发者都要从服务器上获取最新的版本库后才能进行开发，开发完了再把新的版本提交回去。</p>

<p>而“分布式版本控制”，则是这个团队中每个人的电脑上都会有一份完整的<strong>版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>

<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>

<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>

<h3>版本库是咋回事？</h3>

<p>版本，不是文件的版本么？这个版本库是什么意思？</p>

<p>如果能意识到控制的是文件的版本，那就离理解版本库只差一步了（最关键的一步）。</p>

<p>程序要记录项目的版本号，最简单的方法就是把版本相关的信息放在某文件里，持续写入文件便视为版本更新。所以，当我们在一个目录中运行命令：</p>

<pre><code>$ git init
# Git初始化的命令，用于新建版本库
</code></pre>

<p>这个目录中就会默认产生一个新目录：</p>

<pre><code>.git/
</code></pre>

<p>没错，这就是我们刚刚新建的版本库，它将默认记录当前目录（直接包含<code>.git</code>的这个目录，下文中叫做“项目目录”）中任何文件的改动。如果把这个版本库删除了，这里面记录的文件版本就都没有了，项目目录中的文件当前是什么样子，那就一直是什么样子，没法恢复到以前的版本了。如果想让Git忽视项目目录中的什么文件（比如程序缓存等），可以在<code>.gitignore</code>中写清楚那些文件。</p>

<h3>那么，Git怎么用？</h3>

<p>在实际应用中，Git有非常多的用法，而本文是面向Git完全初学者，所以我们要从最基本的开始做。<br>
比如，在刚才建好的版本库中，A新建了README文件，并在里面写了东西。写好后他想给项目做个版本，就需要这样：</p>

<pre><code>$ git add README
$ git commit -m ""add README""
</code></pre>

<p>第一个命令是告诉Git要追踪什么文件，第二个命令是进行提交，并对此次提交做个简答说明。当然，今后他再对README做什么修改，都可以这样做。Git会自动为此次提交生成一个16进制的版本号。</p>

<p>如果此时他查看本地的版本库，就会发现最新的一次提交是在刚才，提交说明为：<code>add README</code>。</p>

<p>然后，他要把<strong>项目的版本库</strong>更新到Github上，当然这时候项目本身已经在Github上建立好了。他只需要：</p>

<pre><code>$ git push origin master
</code></pre>

<p>这行命令应该这样理解：A已经在本地把项目最新的版本做好了，他要发到Github上，以便团队里其他人都能收到这个新的版本，于是他运行<code>git push</code>；push的目的地是<code>origin</code>，这其实是个名字，意义为该项目在Github上的地址；推送的是本地的<code>master</code>分支。</p>

<p>这个时候，Github上项目的版本号与A本地的最新版本号一致。</p>

<blockquote>
  <p>分支是版本控制里面的一个概念：在项目做大了之后，如果要在原基础上进行扩展开发，最好新建一个分支，以免影响原项目的正常维护，新的分支开发结束后再与原来的项目分支合并；而在一个项目刚开始的时候，大家一般会在同一个分支下进行开发.这是一种相对安全便捷的开发方式。</p>
</blockquote>

<p>此时，小组里成员B对项目其他文件做了一些更改，同样也在本地做了一次提交，然后也想推到Github上面。他运行了<code>git push origin master</code>命令，结果发现提交被拒绝。这要做如何解释？</p>

<p>仔细想想，最开始的时候，A和B是在同一个版本号上做不同的更改，这就会分别衍生出两个不同的版本号。A先把自己的版本推到Github上，此时Github上的版本库与B本地版本库相比，差异很大，主要在于B这里没有A的版本记录，如果B这时把自己的版本强制<strong>同步</strong>到Github上，就会把A的版本覆盖掉，这就出问题了。</p>

<p>所以B进行了如下操作：</p>

<pre><code>$ git pull
</code></pre>

<p>这样子，B先把Github上的版本库和自己的版本库做一个合并，这个合并的意义在于：B通过Github，把A刚才添加的版本加了进来，此时B本地的版本库是整个项目最新的，包括项目之前的版本、刚刚A添加的版本和B自己添加的版本。</p>

<p>这之后，B再次运行<code>git push origin master</code>，成功地把自己的版本推到了Github上。如果A想要推送新的版本，也要像B之前这样折腾一番才行。</p>

<h3>还能再给力点么？</h3>

<p>当然可以！</p>

<p>这里有两个在线代码托管平台：</p>

<ul>
<li><a rel=""nofollow"" href=""https://github.com"">Github</a></li>
<li><a rel=""nofollow"" href=""https://gitcafe.com"">GitCafe</a></li>
</ul>
<p>还有一些优秀的Git在线资料：</p>

<ul>
<li><a rel=""nofollow"" href=""http://www.bootcss.com/p/git-guide/"">Git使用简易指南</a></li>
<li><a rel=""nofollow"" href=""http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000"">Git教程-廖雪峰</a></li>
<li><a rel=""nofollow"" href=""https://gitcafe.com/grant/GitTips"">更多资料</a></li>
</ul>
<p>最后还有一本不错的中文书籍：</p>

<ul>
<li><a rel=""nofollow"" href=""http://book.douban.com/subject/6526452/"">《Git权威指南》（蒋鑫）</a></li>
</ul>
<p>不过，本文就要到此为止了，因为再往下写就会涉及更多更深的Git操作实践，而这些内容在上面给出的资料中已经整理好。</p>

<h3>最后</h3>

<p>本文的目的在于解决身边乃至更多开发者同时入门版本控制和Git时候遇到的困惑，希望能对各位初学者起到积极的作用。</p>

<p>如果您有更好的意见或建议，欢迎与我讨论：）</p>

                ", Git入门指引,1531978113,285,1,974,1,1,https://segmentfault.com/a/1190000000514886
314,1,0,7,"
                    
<p>Donnie Berkholz 分析了 GitHub 的数据，试图通过 GitHub 新建代码仓库的比例，分析编程语言的热度：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcgYD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>说明</h2>

<p>关于这张图，有几点需要说明的：</p>

<ul>
<li>只统计新项目，不包括fork。</li>
<li>包括了 2008-2013 年期间在 GitHub 位居前 10 的语言（不包括编辑器配置语言）。</li>
<li>GitHub 最早主要是 Rails 社区在用。</li>
<li>2009年，Perl 暴涨，这是因为 <a rel=""nofollow"" href=""https://github.com/schwern/gitpan/blob/master/README"">GitPAN</a> 项目把所有的 CPAN 模块都导入了 GitHub。</li>
<li>GitHub 的语言检测是根据代码的行数。所以一个项目如果将大量的 JavaScript 库拷贝进去的话，可能会被误认为是 JavaScript 项目。</li>
<li>这里显示的是百分比，而不是数量。所以下降的曲线并不意味着更少的新项目，而是意味着其他语言的增长更快。</li>
</ul>
<h2>趋势</h2>

<p>下面我们就每个语言单独给出统计图，以便更清楚地显示单个语言的趋势：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcgYZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>从这些曲线中，我们可以看到这些趋势：</p>

<ul>
<li>
<strong>GitHub 成为主流：</strong> Ruby 曲线的下降，Java、PHP、Python 等曲线的上扬，意味着 GitHub 从 Rails 社区走向主流。</li>
<li>
<strong>JavaScript 的崛起：</strong> JavaScript 的增长是最明显的趋势。这部分归功于 Node 的兴起。当然，正如我们上面分析的，其中也包含一些误判的仓库。</li>
<li>
<strong>Windows 和 iOS 开发默默无闻：</strong> 令人惊讶的是，C# 和 Objective-C 所占比例很低，而且几乎看不出增长。这说明这两个社区的生态不鼓励开源。</li>
</ul>
<h2>push</h2>

<p>如果不从新建项目的角度来观察，而是从 push 数目来考察，又会有什么结果呢？答案是趋势和新建项目基本一致，只有两处不同：Perl 在 2009 年的 push 数比例增长了 4.1%，而 Ruby 在 2008 年 减少了 3.5%。</p>

<p>这可能是因为项目的主要开发集中在第一年，绝大多数项目 （98%） 只在创建的第 1 年有提交，然后就再也没有修改了。以前的<a rel=""nofollow"" href=""http://redmonk.com/dberkholz/2013/04/22/the-size-of-open-source-communities-and-its-impact-upon-activity-licensing-and-hosting/"">另一项研究</a>表明， 87% 的项目的贡献者不超过 5 人。由于贡献者稀缺，因此项目很难得到长期维护。</p>

<h2>issue</h2>

<p>从 issue 提交的数目则可以看出使用情况。让我们看一下各语言的 issue 提交趋势：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcgZW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这些图形和根据新项目统计的结果相当接近。Ruby、Python、C++ 的峰值应当归功于 GitHub 早期的一些超级流行的项目，当时的 GitHub 上的项目总数还不大，所以统计结果会受这些明星项目的影响较大。</p>

<p>撇开这些不论，我们仍能看出一些趋势（侧重于和新项目分析不同的地方）：</p>

<ul>
<li>
<strong>JavaScript 增长趋缓：</strong> JavaScript 一直在增长，但是增速有所放缓，趋向于稳定在 25% 左右的比例。从新建项目的统计中也能看出这一点，但是在这里更明显。</li>
<li>
<strong>Ruby 在 2009 年后显著下降：</strong> 这应该可以从上文所说的 GitHub 走向主流得到解释。</li>
<li>
<strong>Java 和 PHP 经过增长之后已趋于稳定：</strong> 经过增长之后，两者的比例都稳定在 10% 左右。</li>
</ul>
<h2>用户</h2>

<p>如果我们统计使用某语言为主要语言的新用户数，又会有什么结果呢？从这个角度统计，更能反映每个用户的偏好，而不会偏向创建大量仓库、提交大量 issue 的活跃用户。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcg0o"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>从上图中我们可以看到一些趋势：</p>

<ul>
<li>
<strong>长期而言，几乎所有语言都呈现下降趋势：</strong> 除了 Java 和 CSS 之外，大部分语言都呈现下降趋势。可能的愿意是：使用非主流语言的用户越来越多，有些浅度用户不提交代码，无法判断他们使用的语言，而随着 GitHub 日趋主流，这两类用户越来越多。</li>
<li>
<strong>就长期而言，Java呈现增长态势：</strong> 这是唯一从长期来看呈现增长态势的语言，这点意味着 GitHub 被越来越多的企业用户使用。</li>
</ul>
<h2>比较</h2>

<p>将以上的统计结果合并在一起，更方便对比，也更容易排除偶然因素的影响：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcg0C"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>从中很明显的可以看出，GitHub 上主流的语言只有五种： JavaScript、Ruby、Java、PHP 和 Python。此外，CSS 有挤入主流的趋势，C 和 C++ 勉强可以算主流。除此以外的语言所占比例都很低，即使<a rel=""nofollow"" href=""http://redmonk.com/dberkholz/2014/03/18/go-the-emerging-language-of-cloud-infrastructure/"">增速极其迅猛的Go</a>目前而言仍然不算主流，还要看未来一两年的发展。</p>

<h2>碎片化</h2>

<p>接下来我们统计上述12种语言之外的语言，结果发现，无论是新增用户数、新项目数，还是 issue 数，总体而言都有明显的增长。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcg0N"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>注意，新用户的增速相比其他两者要高很多，这很可能是因为上面提到的浅度用户增长迅速的原因。</p>

<p>总体来说，编程语言日趋碎片化，GitHub 则日趋主流。</p>

<p><a rel=""nofollow"" href=""https://docs.google.com/spreadsheet/ccc?key=0AoKvP9o3WWBxdFo4dW9XYmNEbS03bi1qQ0JDVWZuS1E&amp;usp=sharing"">原始数据</a></p>

<hr>
<p>原文 <a rel=""nofollow"" href=""http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/"">GitHub language trends and the fragmenting landscape</a><br>
编译 <a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a></p>

                ", 利用 GitHub 统计分析编程语言发展趋势,1531978114,189,1,357,1,1,https://segmentfault.com/a/1190000000502996
315,1,0,7,"
                    
<p><a rel=""nofollow"" href=""https://github.com/atom/atom-shell"">atom-shell</a>是 GitHub 随 Atom 一起开源的跨操作系统（Windows，Linux，MacOS X）的利用 Web 技术（Node.js、JavaScript、HTML 5）开发桌面应用的框架。Atom即构建在 atom-shell 之上。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcfNS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>与 Node-Webkit 的区别</h2>

<p>atom-shell 和 <a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000355134"">Node-Webkit</a> 很像，那么两者有什么区别呢？</p>

<h3>1. 程序入口</h3>

<p>Node-Webkit 的程序入口是一个网页，你在 <code>package.json</code> 中指定主页，然后这个主页会在浏览器中打开，作为应用程序的主窗口。</p>

<p>atom-shell 的程序入口则是一个 JavaScript 脚本，而不是直接指定一个 URL。你需要手动创建浏览器窗口，并通过相应的 API 加载 html 文件。你同时需要监听窗口事件以便决定何时退出应用。</p>

<p>因此，atom-shell 更接近 Node.js 运行时，API 也更加底层，你可以利用 atom-shell 进行 web 测试，类似 <a rel=""nofollow"" href=""http://phantomjs.org/"">phantomjs</a>。</p>

<h3>2. 编译系统</h3>

<p>atom-shell 使用 <a rel=""nofollow"" href=""https://github.com/brightray/libchromiumcontent"">libchromiumcontent</a> 访问 Chromium 的 Content API，这样编译 atom-shell 的时候就不用编译整个 Chromium （编译 Chromium 非常费时）。</p>

<p>顺便提一下，GitHub 开发者还创建了 <a rel=""nofollow"" href=""https://github.com/brightray/brightray"">brightray</a> 库，让 libchromiumcontent 的使用更方便。</p>

<h3>3. Node 集成</h3>

<p>Node-Webkit 的 Node 集成需要给 Chromium 打补丁才能工作。atom-shell 通过集成 libuv loop 和 平台的 message loop 避免给 Chromium 打补丁。</p>

<h3>4. Multi-context</h3>

<p>Node-Webkit 创造了 Node context 和 web context 的概念，而 atom-shell 没有引入新的 context，而是直接使用 Node 的 Multi-context 特性（这一特性是 Atom 开发者赞助 Node 添加的）。</p>

<h2>作者</h2>

<p>GitHub 最初考察了 Node-Webkit，但是最终还是决定雇佣 <a rel=""nofollow"" href=""https://github.com/zcbenz"">@zcbenz</a> 来开发想要的框架。于是 atom-shell 诞生了。</p>

<p>@zcbenz 真名赵成，是<a rel=""nofollow"" href=""http://segmentfault.com/e/hang-js-2014"">杭 JS</a> 的讲师，有兴趣和他交流的可以<a rel=""nofollow"" href=""http://segmentfault.com/e/hang-js-2014"">报名 杭JS</a>哦。</p>

<h2>相关链接</h2>

<ul>
<li><a rel=""nofollow"" href=""https://github.com/atom/atom-shell"">atom-shell GitHub 主页</a></li>
<li><a rel=""nofollow"" href=""https://github.com/atom/atom-shell/releases"">下载 atom-shell</a></li>
<li><a rel=""nofollow"" href=""https://github.com/atom/atom-shell/tree/master/docs"">atom-shell API 文档</a></li>
</ul>
<hr>
<p>编撰 <a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a></p>

                ", atom-shell： GitHub 开源的跨平台桌面应用框架（基于 Node.js 和 HTML 5）,1531978115,137,1,584,1,1,https://segmentfault.com/a/1190000000498344
316,1,0,7,"
                    
<p>GitHub 目前的新项目已经转用　<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000430027"">CoffeeScript</a> 了。CoffeeScript 比　JavaScript　要简洁优雅得多。同样地，GitHub　也觉得 YAML 不够简洁优雅，因此捣鼓出了一个　<a rel=""nofollow"" href=""https://github.com/mojombo/toml"">TOML</a>。</p>

<p>TOML　的全称是　Tom's Obvious, Minimal Language，因为它的作者是 GitHub　联合创始人　Tom Preston-Werner 。</p>

<h2>TOML 的目标</h2>

<p>TOML 的目标是成为一个极简的配置文件格式。TOML 被设计成可以无歧义地被映射为哈希表，从而被多种语言解析。</p>

<h2>例子</h2>

<pre><code>title = ""TOML 例子""

[owner]
name = ""Tom Preston-Werner""
organization = ""GitHub""
bio = ""GitHub Cofounder &amp; CEO\nLikes tater tots and beer.""
dob = 1979-05-27T07:32:00Z # 日期时间是一等公民。为什么不呢？

[database]
server = ""192.168.1.1""
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # 你可以依照你的意愿缩进。使用空格或Tab。TOML不会在意。
  [servers.alpha]
  ip = ""10.0.0.1""
  dc = ""eqdc10""

  [servers.beta]
  ip = ""10.0.0.2""
  dc = ""eqdc10""

[clients]
data = [ [""gamma"", ""delta""], [1, 2] ]

# 在数组里换行没有关系。
hosts = [
  ""alpha"",
  ""omega""
]
</code></pre>

<p>TOML 是大小写敏感的。</p>

<h2>注释</h2>

<p>使用 <code>#</code> 表示注释：</p>

<pre><code># I am a comment. Hear me roar. Roar.
key = ""value"" # Yeah, you can do this.
</code></pre>

<h2>字符串</h2>

<p>字符串和 JSON 的定义一致，只有一点除外：　TOML 要求使用　UTF-8 编码。</p>

<p>注释以引号包裹，里面的字符必须是　UTF-8 格式。引号、反斜杠和控制字符（U+0000 到 U+001F）需要转义。</p>

<pre><code>""I'm a string. \""You can quote me\"". Name\tJos\u00E9\nLocation\tSF.""
</code></pre>

<p>常用的转义序列：</p>

<pre><code>\b     - backspace       (U+0008)
\t     - tab             (U+0009)
\n     - linefeed        (U+000A)
\f     - form feed       (U+000C)
\r     - carriage return (U+000D)
\""     - quote           (U+0022)
\/     - slash           (U+002F)
\\     - backslash       (U+005C)
\uXXXX - unicode         (U+XXXX)
</code></pre>

<p>使用保留的特殊字符，TOML　会抛出错误。例如，在　Windows 平台上，应该使用两个反斜杠来表示路径：</p>

<pre><code>wrong = ""C:\Users\nodejs\templates"" # 注意：这不会生成合法的路径。
right = ""C:\\Users\\nodejs\\templates""
</code></pre>

<p>二进制数据建议使用　Base64　或其他合适的编码。具体的处理取决于特定的应用。</p>

<h2>整数</h2>

<p>整数就是一些没有小数点的数字。想用负数？按直觉来就行。整数的尺寸最小为64位。</p>

<h2>浮点数</h2>

<p>浮点数带小数点。小数点两边都有数字。64位精度。</p>

<pre><code>3.1415
-0.01
</code></pre>

<h2>布尔值</h2>

<p>布尔值永远是小写。</p>

<pre><code>true
false
</code></pre>

<h2>日期时间</h2>

<p>使用　ISO 8601　完整格式。</p>

<pre><code>1979-05-27T07:32:00Z
</code></pre>

<h2>　数组</h2>

<p>数组使用方括号包裹。空格会被忽略。元素使用逗号分隔。注意，不允许混用数据类型。</p>

<pre><code>[ 1, 2, 3 ]
[ ""red"", ""yellow"", ""green"" ]
[ [ 1, 2 ], [3, 4, 5] ]
[ [ 1, 2 ], [""a"", ""b"", ""c""] ] # 这是可以的。
[ 1, 2.0 ] # 注意：这是不行的。
</code></pre>

<p>数组可以多行。也就是说，除了空格之外，方括号间的换行也会被忽略。在关闭方括号前的最终项后的逗号是允许的。</p>

<h2>表格</h2>

<p>表格（也叫哈希表或字典）是键值对的集合。它们在方括号内，自成一行。注意和数组相区分，数组只有值。</p>

<pre><code>[table]
</code></pre>

<p>在此之下，直到下一个　table 或　EOF 之前，是这个表格的键值对。键在左，值在右，等号在中间。键以非空字符开始，以等号前的非空字符为结尾。键值对是无序的。</p>

<pre><code>[table]
key = ""value""
</code></pre>

<p>你可以随意缩进，使用 Tab 或空格。为什么要缩进呢？因为你可以嵌套表格。</p>

<p>嵌套表格的表格名称中使用<code>.</code>。你可以任意命名你的表格，只是不要用点，点是保留的。</p>

<pre><code>[dog.tater]
type = ""pug""
</code></pre>

<p>以上等价于如下的 JSON 结构：</p>

<pre><code class=""lang-json"">{ ""dog"": { ""tater"": { ""type"": ""pug"" } } }
</code></pre>

<p>如果你不想的话，你不用声明所有的父表。TOML　知道该如何处理。</p>

<pre><code># [x] 你
# [x.y] 不需要
# [x.y.z] 这些
[x.y.z.w] # 可以直接写
</code></pre>

<p>空表是允许的，其中没有键值对。</p>

<p>只要父表没有被直接定义，而且没有定义一个特定的键，你可以继续写入：</p>

<pre><code>[a.b]
c = 1

[a]
d = 2
</code></pre>

<p>然而你不能多次定义键和表格。这么做是不合法的。</p>

<pre><code># 别这么干！

[a]
b = 1

[a]
c = 2
</code></pre>

<pre><code># 也别这个干

[a]
b = 1

[a.b]
c = 2
</code></pre>

<h2>表格数组</h2>

<p>最后要介绍的类型是表格数组。表格数组可以通过包裹在双方括号内的表格名来表达。使用相同的双方括号名称的表格是同一个数组的元素。表格按照书写的顺序插入。双方括号表格如果没有键值对，会被当成空表。</p>

<pre><code>[[products]]
name = ""Hammer""
sku = 738594937

[[products]]

[[products]]
name = ""Nail""
sku = 284758393
color = ""gray""
</code></pre>

<p>等价于以下的　JSON 结构：</p>

<pre><code>{
  ""products"": [
    { ""name"": ""Hammer"", ""sku"": 738594937 },
    { },
    { ""name"": ""Nail"", ""sku"": 284758393, ""color"": ""gray"" }
  ]
}
</code></pre>

<p>表格数组同样可以嵌套。只需在子表格上使用相同的双方括号语法。每一个双方括号子表格回从属于最近定义的上层表格元素。</p>

<pre><code>[[fruit]]
  name = ""apple""

  [fruit.physical]
    color = ""red""
    shape = ""round""

  [[fruit.variety]]
    name = ""red delicious""

  [[fruit.variety]]
    name = ""granny smith""

[[fruit]]
  name = ""banana""

  [[fruit.variety]]
    name = ""plantain""
</code></pre>

<p>等价于如下的　JSON 结构：</p>

<pre><code>{
  ""fruit"": [
    {
      ""name"": ""apple"",
      ""physical"": {
        ""color"": ""red"",
        ""shape"": ""round""
      },
      ""variety"": [
        { ""name"": ""red delicious"" },
        { ""name"": ""granny smith"" }
      ]
    },
    {
      ""name"": ""banana"",
      ""variety"": [
        { ""name"": ""plantain"" }
      ]
    }
  ]
}
</code></pre>

<p>尝试定义一个普通的表格，使用已经定义的数组的名称，将抛出一个解析错误：</p>

<pre><code># 不合法的　TOML

[[fruit]]
  name = ""apple""

  [[fruit.variety]]
    name = ""red delicious""

  # 和上面冲突了
  [fruit.variety]
    name = ""granny smith""
</code></pre>

<h2>来真的？</h2>

<p>是的。</p>

<h2>但是为什么？</h2>

<p>因为我们需要一个像样的人类可读的格式，同时能无歧义地映射到哈希表。然后　YAML 的规范有 80 页那么长，真是发指！不，不考虑　JSON 。你知道为什么。</p>

<h2>天哪，你是对的！</h2>

<p>哈哈！想帮忙么？发合并请求过来。或者编写一个解析器。勇敢一点。</p>

<h2>实现</h2>

<p>如果你有一个实现，请发一个合并请求，把你的实现加入到这个列表中。请在你的解析器的 README 中标记你的解析器支持的 提交SHA1 或 版本号。</p>

<ul>
<li>C#/.NET - <a rel=""nofollow"" href=""https://github.com/LBreedlove/Toml.net"">https://github.com/LBreedlove/Toml.net</a>
</li>
<li>C#/.NET - <a rel=""nofollow"" href=""https://github.com/rossipedia/toml-net"">https://github.com/rossipedia/toml-net</a>
</li>
<li>C#/.NET - <a rel=""nofollow"" href=""https://github.com/RichardVasquez/TomlDotNet"">https://github.com/RichardVasquez/TomlDotNet</a>
</li>
<li>C (@ajwans) - <a rel=""nofollow"" href=""https://github.com/ajwans/libtoml"">https://github.com/ajwans/libtoml</a>
</li>
<li>C++ (@evilncrazy) - <a rel=""nofollow"" href=""https://github.com/evilncrazy/ctoml"">https://github.com/evilncrazy/ctoml</a>
</li>
<li>C++ (@skystrife) - <a rel=""nofollow"" href=""https://github.com/skystrife/cpptoml"">https://github.com/skystrife/cpptoml</a>
</li>
<li>Clojure (@lantiga) - <a rel=""nofollow"" href=""https://github.com/lantiga/clj-toml"">https://github.com/lantiga/clj-toml</a>
</li>
<li>Clojure (@manicolosi) - <a rel=""nofollow"" href=""https://github.com/manicolosi/clojoml"">https://github.com/manicolosi/clojoml</a>
</li>
<li>CoffeeScript (@biilmann) - <a rel=""nofollow"" href=""https://github.com/biilmann/coffee-toml"">https://github.com/biilmann/coffee-toml</a>
</li>
<li>Common Lisp (@pnathan) - <a rel=""nofollow"" href=""https://github.com/pnathan/pp-toml"">https://github.com/pnathan/pp-toml</a>
</li>
<li>Erlang - <a rel=""nofollow"" href=""https://github.com/kalta/etoml.git"">https://github.com/kalta/etoml.git</a>
</li>
<li>Erlang - <a rel=""nofollow"" href=""https://github.com/kaos/tomle"">https://github.com/kaos/tomle</a>
</li>
<li>Emacs Lisp (@gongoZ) - <a rel=""nofollow"" href=""https://github.com/gongo/emacs-toml"">https://github.com/gongo/emacs-toml</a>
</li>
<li>Go (@thompelletier) - <a rel=""nofollow"" href=""https://github.com/pelletier/go-toml"">https://github.com/pelletier/go-toml</a>
</li>
<li>Go (@laurent22) - <a rel=""nofollow"" href=""https://github.com/laurent22/toml-go"">https://github.com/laurent22/toml-go</a>
</li>
<li>Go w/ Reflection (@BurntSushi) - <a rel=""nofollow"" href=""https://github.com/BurntSushi/toml"">https://github.com/BurntSushi/toml</a>
</li>
<li>Haskell (@seliopou) - <a rel=""nofollow"" href=""https://github.com/seliopou/toml"">https://github.com/seliopou/toml</a>
</li>
<li>Haxe (@raincole) - <a rel=""nofollow"" href=""https://github.com/raincole/haxetoml"">https://github.com/raincole/haxetoml</a>
</li>
<li>Java (@agrison) - <a rel=""nofollow"" href=""https://github.com/agrison/jtoml"">https://github.com/agrison/jtoml</a>
</li>
<li>Java (@johnlcox) - <a rel=""nofollow"" href=""https://github.com/johnlcox/toml4j"">https://github.com/johnlcox/toml4j</a>
</li>
<li>Java (@mwanji) - <a rel=""nofollow"" href=""https://github.com/mwanji/toml4j"">https://github.com/mwanji/toml4j</a>
</li>
<li>Java - <a rel=""nofollow"" href=""https://github.com/asafh/jtoml"">https://github.com/asafh/jtoml</a>
</li>
<li>Java w/ ANTLR (@MatthiasSchuetz) - <a rel=""nofollow"" href=""https://github.com/mschuetz/toml"">https://github.com/mschuetz/toml</a>
</li>
<li>Julia (@pygy) - <a rel=""nofollow"" href=""https://github.com/pygy/TOML.jl"">https://github.com/pygy/TOML.jl</a>
</li>
<li>Literate CoffeeScript (@JonathanAbrams) - <a rel=""nofollow"" href=""https://github.com/JonAbrams/tomljs"">https://github.com/JonAbrams/tomljs</a>
</li>
<li>node.js - <a rel=""nofollow"" href=""https://github.com/aaronblohowiak/toml"">https://github.com/aaronblohowiak/toml</a>
</li>
<li>node.js/browser - <a rel=""nofollow"" href=""https://github.com/ricardobeat/toml.js"">https://github.com/ricardobeat/toml.js</a> (npm install tomljs)</li>
<li>node.js - <a rel=""nofollow"" href=""https://github.com/BinaryMuse/toml-node"">https://github.com/BinaryMuse/toml-node</a>
</li>
<li>node.js (@redhotvengeance) - <a rel=""nofollow"" href=""https://github.com/redhotvengeance/topl"">https://github.com/redhotvengeance/topl</a> (topl npm package)</li>
<li>node.js/browser (@alexanderbeletsky) - <a rel=""nofollow"" href=""https://github.com/alexanderbeletsky/toml-js"">https://github.com/alexanderbeletsky/toml-js</a> (npm browser amd)</li>
<li>Objective C (@mneorr) - <a rel=""nofollow"" href=""https://github.com/mneorr/toml-objc.git"">https://github.com/mneorr/toml-objc.git</a>
</li>
<li>Objective-C (@SteveStreza) - <a rel=""nofollow"" href=""https://github.com/amazingsyco/TOML"">https://github.com/amazingsyco/TOML</a>
</li>
<li>Ocaml (@mackwic) <a rel=""nofollow"" href=""https://github.com/mackwic/to.ml"">https://github.com/mackwic/to.ml</a>
</li>
<li>Perl (@alexkalderimis) - <a rel=""nofollow"" href=""https://github.com/alexkalderimis/config-toml.pl"">https://github.com/alexkalderimis/config-toml.pl</a>
</li>
<li>Perl - <a rel=""nofollow"" href=""https://github.com/dlc/toml"">https://github.com/dlc/toml</a>
</li>
<li>PHP (@leonelquinteros) - <a rel=""nofollow"" href=""https://github.com/leonelquinteros/php-toml.git"">https://github.com/leonelquinteros/php-toml.git</a>
</li>
<li>PHP (@jimbomoss) - <a rel=""nofollow"" href=""https://github.com/jamesmoss/toml"">https://github.com/jamesmoss/toml</a>
</li>
<li>PHP (@coop182) - <a rel=""nofollow"" href=""https://github.com/coop182/toml-php"">https://github.com/coop182/toml-php</a>
</li>
<li>PHP (@checkdomain) - <a rel=""nofollow"" href=""https://github.com/checkdomain/toml"">https://github.com/checkdomain/toml</a>
</li>
<li>PHP (@zidizei) - <a rel=""nofollow"" href=""https://github.com/zidizei/toml-php"">https://github.com/zidizei/toml-php</a>
</li>
<li>PHP (@yosymfony) - <a rel=""nofollow"" href=""https://github.com/yosymfony/toml"">https://github.com/yosymfony/toml</a>
</li>
<li>Python (@socketubs) - <a rel=""nofollow"" href=""https://github.com/socketubs/pytoml"">https://github.com/socketubs/pytoml</a>
</li>
<li>Python (@f03lipe) - <a rel=""nofollow"" href=""https://github.com/f03lipe/toml-python"">https://github.com/f03lipe/toml-python</a>
</li>
<li>Python (@uiri) - <a rel=""nofollow"" href=""https://github.com/uiri/toml"">https://github.com/uiri/toml</a>
</li>
<li>Python - <a rel=""nofollow"" href=""https://github.com/bryant/pytoml"">https://github.com/bryant/pytoml</a>
</li>
<li>Python (@elssar) ) <a rel=""nofollow"" href=""https://github.com/elssar/tomlgun"">https://github.com/elssar/tomlgun</a>
</li>
<li>Python (@marksteve) - <a rel=""nofollow"" href=""https://github.com/marksteve/toml-ply"">https://github.com/marksteve/toml-ply</a>
</li>
<li>Python (@hit9) - <a rel=""nofollow"" href=""https://github.com/hit9/toml.py"">https://github.com/hit9/toml.py</a>
</li>
<li>Ruby (@jm) - <a rel=""nofollow"" href=""https://github.com/jm/toml"">https://github.com/jm/toml</a> (toml gem)</li>
<li>Ruby (@eMancu) - <a rel=""nofollow"" href=""https://github.com/eMancu/toml-rb"">https://github.com/eMancu/toml-rb</a> (toml-rb gem)</li>
<li>Ruby (@charliesome) - <a rel=""nofollow"" href=""https://github.com/charliesome/toml2"">https://github.com/charliesome/toml2</a> (toml2 gem)</li>
<li>Ruby (@sandeepravi) - <a rel=""nofollow"" href=""https://github.com/sandeepravi/tomlp"">https://github.com/sandeepravi/tomlp</a> (tomlp gem)</li>
<li>Scala - <a rel=""nofollow"" href=""https://github.com/axelarge/tomelette"">https://github.com/axelarge/tomelette</a>
</li>
</ul>
<h2>校验</h2>

<p>@BurntSushi) - <a rel=""nofollow"" href=""https://github.com/BurntSushi/toml/tree/master/tomlv"">https://github.com/BurntSushi/toml/tree/master/tomlv</a></p>

<h2>TOML 测试套件 （语言无关）</h2>

<ul>
<li>toml-test (@BurntSushi) - <a rel=""nofollow"" href=""https://github.com/BurntSushi/toml-test"">https://github.com/BurntSushi/toml-test</a>
</li>
</ul>
<h2>编辑器支持</h2>

<ul>
<li>Emacs (@dryman) - <a rel=""nofollow"" href=""https://github.com/dryman/toml-mode.el"">https://github.com/dryman/toml-mode.el</a>
</li>
<li>Sublime Text 2 &amp; 3 (@lmno) - <a rel=""nofollow"" href=""https://github.com/lmno/TOML"">https://github.com/lmno/TOML</a>
</li>
<li>TextMate (@infininight) - <a rel=""nofollow"" href=""https://github.com/textmate/toml.tmbundle"">https://github.com/textmate/toml.tmbundle</a>
</li>
<li>Vim (@cespare) - <a rel=""nofollow"" href=""https://github.com/cespare/vim-toml"">https://github.com/cespare/vim-toml</a>
</li>
</ul>
<h2>编码器</h2>

<ul>
<li>PHP (@ayushchd) - <a rel=""nofollow"" href=""https://github.com/ayushchd/php-toml-encoder"">https://github.com/ayushchd/php-toml-encoder</a>
</li>
</ul>
<hr>
<p>原文 <a rel=""nofollow"" href=""https://github.com/mojombo/toml"">TOML README</a><br>
翻译 <a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a></p>

                ", TOML： GitHub 这是要革 YAML 的命呀！,1531978117,202,1,198,1,1,https://segmentfault.com/a/1190000000477752
317,1,0,7,"
                    
<p><a rel=""nofollow"" href=""https://github.com"">GitHub</a> 大家常上吧？可是使用 GitHub 的各种小窍门你就不一定知道了。本文将各种使用 GitHub 的小窍门分享给大家。</p>

<h2>diff时忽略空格</h2>

<p>有些修改只是增减了空格，在URL中添加<code>?w=1</code>就可以忽略。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9aT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>查看某个作者的提交历史</h2>

<p>在URL中添加<code>?author=username</code>，例如：</p>

<pre><code>https://github.com/rails/rails/commits/master?author=dhh
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9aY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>比较版本</h2>

<p>使用类似如下的URL比较分支：</p>

<pre><code>https://github.com/rails/rails/compare/master...4-1-stable
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9aZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>同样可以使用一下格式：</p>

<pre><code>https://github.com/rails/rails/compare/master@{1.day.ago}...master
https://github.com/rails/rails/compare/master@{2014-10-04}...master
</code></pre>

<p>如果想和派生仓库比较，加上派生仓库名作前缀即可：</p>

<pre><code>https://github.com/rails/rails/compare/byroot:master...master
</code></pre>

<h2>通过 HTML 方式嵌入 Gist</h2>

<p><a rel=""nofollow"" href=""https://gist.github.com/"">Gists</a>是 GitHub 推出的基于 Git 的代码片段服务。Gists页面提供JavaScript代码，可以将 Gist 嵌入到其他站点。但是很多站点粘贴 JavaScript 无效，这时候你可以在 Gist URL 后附加<code>.pibb</code>，得到一个纯 HTML 的版本，然后就可以复制粘贴 HTML 源码到其他网站了。例如 <a rel=""nofollow"" href=""https://gist.github.com/tiimgreen/10545817.pibb"">https://gist.github.com/tiimgreen/10545817.pibb</a></p>

<h2>Git.io</h2>

<p><a rel=""nofollow"" href=""http://git.io/"">Git.io</a> 是适用于 GitHub 的短网址服务。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9a4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>当然，为了<del>逼格</del>方便，也可以使用Curl访问：</p>

<pre><code class=""lang-sh"">$ curl -i http://git.io -F ""url=https://github.com/...""
HTTP/1.1 201 Created
Location: http://git.io/abc123

$ curl -i http://git.io/abc123
HTTP/1.1 302 Found
Location: https://github.com/...
</code></pre>

<p>你甚至可以指定短网址的字段：</p>

<pre><code>$ curl -i http://git.io -F ""url=https://github.com/technoweenie"" \
    -F ""code=t""
HTTP/1.1 201 Created
Location: http://git.io/t
</code></pre>

<h2>高亮行</h2>

<p>例如，在 URL 中加上 <code>#L52</code> 可以高亮第52行。或者你也可以直接点击行数。</p>

<p>多行高亮同样支持。你可以使用类似<code>#L53-L60</code>格式，或者在按住shift的同时点击。</p>

<pre><code>https://github.com/rails/rails/blob/master/activemodel/lib/active_model.rb#L53-L60
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9bn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>快速引用</h2>

<p>你可以选中别人的评论文字，然后按<code>r</code>，这些内容会以引用的形式被复制在文本框中：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9bw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>任务列表</h2>

<p>在工单或合并请求中，你可以使用任务列表语法：</p>

<pre><code>- [ ] Be awesome
- [ ] Do stuff
- [ ] Sleep
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9by"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>勾选之后，会更新 Markdown：</p>

<pre><code>- [x] Be awesome
- [x] Do stuff
- [ ] Sleep
</code></pre>

<h2>合并请求的 diff 和 patch</h2>

<p>可以在 URL 后添加 <code>.diff</code> 和 <code>.patch</code>，以对应的模式查看合并请求:</p>

<pre><code>https://github.com/tiimgreen/github-cheat-sheet/pull/15
https://github.com/tiimgreen/github-cheat-sheet/pull/15.diff
https://github.com/tiimgreen/github-cheat-sheet/pull/15.patch
</code></pre>

<p>结果是纯文本的：</p>

<pre><code>diff --git a/README.md b/README.md
index 88fcf69..8614873 100644
--- a/README.md)
+++ b/README.md
@@ -28,6 +28,7 @@ All the hidden and not hidden features of Git and GitHub. This cheat sheet was i
 - [Merged Branches](#merged-branches)
 - [Quick Licensing](#quick-licensing)
 - [TODO Lists](#todo-lists)
+- [Relative Links](#relative-links)
 - [.gitconfig Recommendations](#gitconfig-recommendations)
     - [Aliases](#aliases)
     - [Auto-correct](#auto-correct)
@@ -381,6 +382,19 @@ When they are clicked, they will be updated in the pure Markdown:
 - [ ] Sleep

(...)
</code></pre>

<hr>
<p>编撰 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a><br>
参考 <a rel=""nofollow"" href=""https://github.com/tiimgreen/github-cheat-sheet"">github-cheat-sheet</a></p>

                ", 少有人知的 GitHub 使用技巧,1531978118,172,1,575,1,1,https://segmentfault.com/a/1190000000475547
318,1,0,7,"
                    
<p>每次打开谷歌浏览器的About页面更新的时候，总是期待着一个新版本的到来，新的东西总是让人感到Amazing。这样久了之后心中不免产生一个疑问，什么时候该发布一个新版本了，有什么规律么？平时的小更新总是版本号后面无关仅要的数字的增长，当这个数字增长到何时可以让主版本号加1？</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb9an"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>语义化版本号</h2>

<p>当我在发布jQuery插件时，发现其<a rel=""nofollow"" href=""http://plugins.jquery.com/docs/publish/"">官方页面</a>上提供了一个帮助我们更好地命名软件版本号的概念""<a rel=""nofollow"" href=""http://semver.org/"">semver</a>""，即Semantic Versioning语义化的版本。看了下其规则觉得很nice。</p>

<p>关于软件的版本号，向来没有统一或者严格的规定，对于大型软件产品，其开发团队内部或许维护了自己的一套规则来界定软件开发到何时可以发布新版本，何时又只是增加次版本号，也或许在遵循一些现成的大家认可的规范；更多情况是对个人开发者而言，在自己捣腾一些小东西时，这样的版本号规则就更自由了，完全视软件作者的水平而良莠不齐。有的作者或许学习过版本相关的知识，知道遵循一些现成的规范，更多的新手比如像我这样，完全是随毫无规则地在使用版本号。今天开发完一个功能，那就发布一个版本叫做0.1吧，下午发现个bug并修复之再发个版本0.2吧。如此显然不好，无规矩不成方圆啊，我们已经饱受各浏览器不完全遵循W3C规范而带来的各种跨浏览器前端问题了，血的教训，历史告诉我们，不能让悲剧重演，所以迫切需要一个好的准则来指导大家更好地使用软件版本号。</p>

<p>语义化版本号的作者正是抱着这样的希望创造了它。</p>

<p><a rel=""nofollow"" href=""http://semver.org/"">语义化版本号</a>是由<a rel=""nofollow"" href=""http://tom.preston-werner.com/"">Tom Preston-Werner</a> 发起的一个关于软件版本号的命名规范，关于这个规范详细的说明可以在<a rel=""nofollow"" href=""http://semver.org/"">官网</a>查看，也可访问其<a rel=""nofollow"" href=""https://github.com/mojombo/semver"">GitHub项目页面</a>，而关于该规范的中文版本，可以访问我<a rel=""nofollow"" href=""https://github.com/Wayou/semver_zh_CN/blob/master/semver_zh_CN.md"">fork的版本</a>，由官网繁体中文转换而来，并稍加修改以更符合大陆用语。顺便提句，该规范的作者是<a rel=""nofollow"" href=""http://en.gravatar.com/"">Gravatars</a>创办者同时是GitHub联合创始人。你或许不知道gravatar但作为程序员你肯定知道GitHub。</p>

<h2>基本规则</h2>

<p>顾名思义，语义化的版本就是让版本号更具语义化，可以传达出关于软件本身的一些重要信息而不只是简单的一串数字。</p>

<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>

<ol>
<li>主版本号：当你做了不兼容的API 修改</li>
<li>次版本号：当你做了向下兼容的功能性新增</li>
<li>修订号：当你做了向下兼容的问题修正</li>
</ol>
<p>先行版（预览版）版本号及版本编译信息可以加到""主版本号.次版本号.修订号""的后面，作为延伸。</p>

<h2>具体规范</h2>

<p>具体详尽的规范可以参见其官网，当然也可以访问中文版本。这里简单总结一下。</p>

<ul>
<li>版本号是以点隔开的形式'X.Y.Z' 且XYZ为正整数，数字前面不加0， 也就是说v0.1.0不能写成v0.10.0</li>
<li>一般软件开发过程中以0.1.0 版本开始，开发过程中不断增加新功能，则增加次版本号比如变成0.2.0，然后期间的问题及bug修复体现在修订号上，比如版本号变成0.1.12。这一阶段的版本视为不稳定版本，一般也未对外发布</li>
<li>主版本号表示正式版的形成，也即如果你开发的是供大家使用的软件或插件，那就标致本软件公共API的形成，比如新浪微博API v1.0.0发布，大家就可以在自己网站上调用了，这是个正式而稳定的版本。所以这里有个规定，版本一旦发布，不允许对软件做任何修改。任何改过之后的代码都应标记新的版本号在下次发布中体现</li>
<li>主版本号的增加可以是次版本号以有修订号增加到一定数量后的结果，也可以是有不兼容旧版的新功能或API加入的结果，并且主版本增加后次版本号和修订号归零</li>
<li>次版本号表示有兼容旧版本的功能或API增加，而修订号表示bug修复并且这种修复一般是对代码结果不正确的修复而且一定是兼容旧版本的，如果你修复bug越改越大结果不兼容旧版本了，则需要增加主版本号</li>
<li>其他信息比如预览版，先行版或者软件编译信息可以跟随在修订号之后。示例：1.0.0-alpha+001、1.0.0+20130313144700、 1.0.0-beta+exp.sha.5114f85</li>
</ul>
<h2>使用语义化版本号的好处</h2>

<p>也即原规范中对为何要使用语义化版本号的描述。在我看来，无非就是在遵循了本规范后，透过版本号，你可以非常清楚地了解到你手头拿到的软件版本相比于上一个版本发生了怎样的变化，所以你在使用的时候可以更注意一下这些变化，以免出现不兼容的情况。</p>

<p>比如如果主版本号升级了，可以知道软件新增了功能且该功能或者重大问题修复，且都是与旧版本不兼容的。好比大家热切推崇的文本编辑器Sublimetext2和3，他的很多插件在这两个版本间无法兼容使用，所以一般要标明插件是使用在Sublimetext2还是3中。同时主版本号的更新也可以表明是次版本号更新到了一定程序，比如新增功能数量达到了一定指标，我们可以认为可以升级一下主版本号了，毕竟一个可以copy as rtf，带项目文件管理sidebar，更换主题的文本编辑器和Windows自带文本编辑器在功能上还是有质的区别的。</p>

<p>如果次版本更新了，我们可以知道有小部分新功能添加，或者修订号更新，有小部分bug被修复，而在获取这些信息时完全还没有查看change log。这正是语义化的好处，版本号就告诉你大部分信息了，当然更具体的参见change log吧。</p>

<p>另外个好处就是当大家都在遵循一个规范的时候，无疑扫清了一些认知上的障碍，将事情简单化，大家也心照不宣地能看懂每个人代码中的版本号的意思，初学者也很容易掌握这方面的知识。</p>

<h2>一些问题</h2>

<h3>各版本优先级</h3>

<p>也即如何判定哪个版本版次更高。下面是来自原规范的解释，已经够详尽就不另外阐述。</p>

<p>判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以ASCII的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0。</p>

<h3>如何界定正式版1.0.0的发布</h3>

<p>这个正是我在开发自己的jQuery插件时面临的问题。如上面规范所述，软件最初开发阶段一般以0.1.0开始。当软件基本正式功能全部完成且测试通过，对外公共API完成可以用于实际线上环境了，则可以形成1.0.0的正式版了。</p>

<p>更多关于本规范的常见问题还是请查看文档，上面的FAQ列出的问题很实在，可以解决使用本版本号命名中的疑惑。</p>

<p> </p>

<h2>参考</h2>

<ul>
<li>Semver 简体中文版本：<a rel=""nofollow"" href=""https://github.com/Wayou/semver_zh_CN/blob/master/semver_zh_CN.md""></a><a rel=""nofollow"" href=""https://github.com/Wayou/semverX"">https://github.com/Wayou/semverX</a>11Xzh_CN/blob/master/semver_zh_CN.md</li>
<li>Semver GitHub项目地址：<a rel=""nofollow"" href=""https://github.com/mojombo/semver""></a><a rel=""nofollow"" href=""https://github.com/mojombo/semver"">https://github.com/mojombo/semver</a>
</li>
<li>semver 官方文档页：<a rel=""nofollow"" href=""http://semver.org/""></a><a rel=""nofollow"" href=""http://semver.org/"">http://semver.org/</a>
</li>
</ul>
<hr>
<p>by <a rel=""nofollow"" href=""http://www.cnblogs.com/Wayou/p/semver.html"">刘哇勇</a></p>

                ", 语义化的软件版本号规则 你是否真的了解软件的版本号,1531978119,297,1,875,1,1,https://segmentfault.com/a/1190000000474841
319,1,0,7,"
                    
<p>去年秋天我的<a rel=""nofollow"" href=""https://github.com/jeresig"">支线代码项目</a> 遇到了一些问题，项目进展不足，而且我没法找到一个完成更多代码的方法（在不影响我在<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469838"">Khan Academy</a>方面的工作的前提下）。</p>

<p>我主要在周末进行我的支线，当然有时候也在晚上进行。这个方法对我而言效果不佳。我的压力太重了，我需要在周末努力完成尽可能多的工作（如果没做到，我会为此感到挫败）。还有一个问题是我无法保证每个周末都有空，而且我也不想把周末所有的时间都花在编程上（失去一切放松娱乐的机会）。</p>

<p>此外，每隔一周进行编码的话，间隙太长了。太容易忘记你正在做什么，或者你还需要做什么了（即使你有笔记）。如果你错过了一个周末的话，问题就更严重了，间隔一下子变成两周了。多周的上下文切换可能是致命的（我有很多支线项目因为这类注意力缺乏而死亡了）。</p>

<p><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469637"">Jennifer Dewalt</a> 去年通过在 180 天创建 180 个网站的方式来自学编程，她的做法启发了我。我决定采用一个简单的策略：每天编码。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/SsevWYY.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>我决定为自己定下一些规则：</p>

<ol>
<li>每天必须写代码。我可以写文档、写博客或者写其他东西，但是这些不能代替写代码。 </li>
<li>代码必须是实际起作用的。调整缩进、重新排版不算。如果有可能，重构也不算。（可以进行这些事情，但这些不能是一天唯一的编码。） </li>
<li>所有代码必须在午夜之前完成。 </li>
<li>代码必须是开源的，放在Github上。</li>
</ol>
<p>有些规则比较武断。比如代码其实不用在午夜前写完的。但我担心熬夜导致代码质量下降。同样，代码也不用开源，或者放在GitHub上。我这么做是想强迫自己写代码的时候上点心（考虑可读性，同时较早地考虑模块化）。</p>

<p>到目前为止这个策略很有效。我基本保持了20周的连续工作。我之所以写这篇博客，正是因为它完全改变了我编写代码的方式，更重要的是影响了我生活和心智。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb8mG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这个习惯的改变产生了一些有趣的结果：</p>

<p><strong>最小可行的编码。</strong> 我强迫自己每天花不少于半个小时来写代码（如果少于这个时间就很难写出有价值的代码了，特别是回忆前一天写了什么还要花一点时间）。工作日的时候我有时写得多一点（一般不超过一个小时），周末我有时整天写代码。</p>

<p><strong>写代码成为习惯。</strong> 值得一提的是我并不是特别在乎上面的Github图形。我觉得这是这个实验最值得借鉴的一点：这是你为自己做的一个改变，而不是为了满足别人对你工作的评价。节食和锻炼也是一个道理：如果你不在乎提升自己，那么你永远都不会取得成功。</p>

<p><strong>与焦虑作斗争。</strong> 在开始这个实验之前，我时常为没有完成足够的工作或取得足够进展而感到焦虑（工作和进展都难以量化，因为我的支线项目没有死限）。我意识到，感觉到进展和实际推进工作同样重要。这令我大开眼界。一旦我每天持续地推进项目，我的焦虑就开始消散了。我对自己的工作量很心安，我再也没有那种难以承受的渴望，想要疾风骤雨式地推进项目的渴望。</p>

<p><strong>周末。</strong> 以前，在周末完成工作绝对是前进的关键动力（因为通常而言这是我唯一大量推进支线项目工作的机会。）现在情况不一样了——这是件好事。期望在一个周末完成一周的所有工作只会让我失望。我极少很完成工作，因此为了完成更多工作而拒绝了其他喜欢的周末活动（例如吃 dim sum，参观博物馆，去公园游玩，陪伴我的伴侣等）。我深深地感到，虽然支线项目是非常重要的，但是它们不应该是生活的全部。</p>

<p><strong>后台处理。</strong> 每天编写支线项目代码的一个有趣的副作用是你当前的任务时常在你大脑的后台运行。因此当我去散步或沐浴的时候，或者进行其他不费脑的活动的时候，我在思考我接下来将做哪些编码，寻找解决问题的好方法。我以前一周或两周编码一次的时候可不是这样。当时时间被花费在思考其他一些事情上，通常是在为没法完成任何支线项目而感到焦虑。</p>

<p><strong>上下文切换。</strong> 拾起支线项目工作的时候总会有上下文开销的。很不幸，重拾整整一周前的思考是极其困难的。每天做一点对此很有帮助，因为间隔时间大大缩短了，让我很容易想起在做什么。</p>

<p><strong>平衡工作。</strong> 这个改变最重要的方面之一是我已经简单地学会了如何更好地平衡工作、生活和支线项目。我知道自己每天都要做支线项目，因此我需要更好地管理时间。如果我计划晚上出去，并且很晚才能回家，那么我需要在早上为支线项目工作，在开始为我主业Khan Academy工作之前。同样的，如果我在外面，而我还没有完成我的工作，时间已经很晚了，那么我需要尽快赶回家去完成工作（以免错过一天）。我需要指出的是我发现自己把更少的时间花在爱好上了（例如木版画），但是这是一个合理的代价，我得接受这个。</p>

<p><strong>对外沟通。</strong> 跟外界沟通自己的新习惯是很有好处的。我的伴侣理解每都必须完成工作，因此有活动安排有时需要据此作出调整。这样我就可以很方便地说：“是的，我们可以出去/看个电影/等等。但是我之后需要写代码。”我的伴侣会理解我，并在安排活动时考虑到这点。</p>

<p><strong>我写了多少代码？</strong> 我很难相信自己在过去的几个月写了这么多的代码。我新建了几个网站，重写了一些框架，并创建了大量node模块。我写了如此之多的代码以至于我有时我都忘记自己做了写什么——几周前的工作感觉是很久远的记忆。我非常非常高兴自己能写这么多代码。</p>

<p>我认为这个习惯的改变是一个巨大的成功。我希望自己能持续保持这个习惯。同时，我尽力向其他希望能完成大量的支线项目的人推荐这个策略。<a rel=""nofollow"" href=""http://ejohn.org/about/"">告诉我这个策略对你而言是有效还是无效</a>。我很希望能从你那里听到一些有意思的东西。</p>

<h2>关于作者</h2>

<p><a rel=""nofollow"" href=""http://ejohn.org/"">John Resig</a>， <a rel=""nofollow"" href=""http://jquery.com/"">jQuery</a>之父，同时也是<a rel=""nofollow"" href=""http://jspro.org/"">Pro Javascript Techniques</a>和<a rel=""nofollow"" href=""http://jsninja.com/"">Secrets of the JavaScript Ninja</a>的作者。他目前主持 <a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469838"">Khan Academy</a> 的开发工作。</p>

<hr>
<p>原文 <a rel=""nofollow"" href=""http://ejohn.org/blog/write-code-every-day/"">Write Code Every Day</a><br>
翻译 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", jQuery之父：每天写代码,1531978120,313,1,153,1,1,https://segmentfault.com/a/1190000000469890
320,1,0,7,"
                    
<h1>Why</h1>

<p>之前我一直在使用<code>wordpress</code>（下称wp），就在前些日子，我爱上了markdown，但在wp上又没找到完美一点兼容markdown的插件。慢慢地，越来越觉得wp很臃肿，最终，我选择了放弃它了。现在，我选择了一个基于node.js的小萝莉<code>hexo</code>。</p>

<hr>
<h1>静态博客</h1>

<p>hexo相对于wp，最大的区别就是它是一个静态博客。静态博客有什么特点？<br>
- 不用配置服务器<br>
- 不用数据库<br>
- 访问速度相当快<br>
- 没有安全性可言<br>
- 使用户可更注重博客内容<br>
- 支持markdown</p>

<p>然而，现在我们还是使用<code>github pages</code>来搭建，意味着什么？就是免费。娃哈哈。当然，<code>七牛</code>等一系列云产品也是可以搭建的。</p>

<p>以上说的都是有点，至于缺点呢。缺点就不说那么多了，总得来说就是麻烦一些。</p>

<p>静态博客也有很多，例如<code>github pages</code> 推荐使用的<code>jekyll</code>。</p>

<p>而hexo相对而言还是轻巧一些的，生成文章的速度也较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢）。</p>

<hr>
<h1>开始hexo</h1>

<p>首先本地得装上了<code>node.js</code>、<code>gi</code>t和<code>hexo</code></p>

<p>吓？这么火爆的nodejs和最流行的版本控制器git都不知道？ 没关系，经过这次，多少也会了解到一点点点，也可自行谷歌看看去。</p>

<p>安装git：<a rel=""nofollow"" href=""http://git-scm.com/"">git</a></p>

<p>安装nodejs：<a rel=""nofollow"" href=""http://nodejs.org/"">node.js官网</a></p>

<p>hexo：<a rel=""nofollow"" href=""http://hexo.io/"">hexo官网</a></p>

<p>hexo使用npm安装，Quick Start 说得很清楚，我这里就不复制黏贴了。</p>

<p>Install --&gt; Setup --&gt; Generate --&gt; 启动Server</p>

<p>默认监听<code>4000</code>端口，现在，打开浏览器，输入 <code>localhost:4000</code> 就可以看到一个漂亮的博客出现在你眼前啦，耶~~~。</p>

<p><code>hexo</code>的使用可参详官网的文档。</p>

<hr>
<h1>部署到github</h1>

<p>现在，到<code>github</code>新建一个项目，项目名为：<code>你的用户名.github.io</code><strong>必须为这个名字</strong></p>

<p>然后，配置文件<code>_config.yml</code></p>

<pre><code>deploy:
  type: github
  repository: git@github.com:你的帐号/你的帐号.github.com.git
  例如我的：repository: git@github.com:zhongbaitu/zhongbaitu.github.com.git
  branch: master
</code></pre>

<p>然后执行命令：</p>

<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre>

<p>此时，在博客的根目录下会生成一个文件夹：<code>.deploy</code></p>

<p>然后我们把这个文件夹里面的文件都<code>push</code>到刚才新建那个项目就OK了。几分钟过后，就可以打开<code>你的用户名.github.io</code>看到你的博客了。</p>

<hr>
<h1>绑定个性域名</h1>

<p>在项目的根目录，新建名为<code>CNAME</code>的文件，内容为：<code>你的域名</code>，例如我的就是：hackeris.me</p>

<p>再到把你的域名指向<code>你的用户名.github.io</code>，几分钟过后，就可以看到成功的诞生了。</p>

<hr>
<blockquote>
  <p>我的博客</p>
</blockquote>

<blockquote>
  <p><a rel=""nofollow"" href=""http://www.hackeris.me"">hackeris.me</a></p>
</blockquote>

                ", 使用Github搭建静态博客（Hexo）,1531978122,181,1,283,1,1,https://segmentfault.com/a/1190000000458953
321,1,0,7,"
                    
<p>很早以前就想写自己的IM软件了（谁让现在的IM都各种残缺呢！），但是目前技术实在是太弱这个想法就一直搁置了。前几天放假突然想到写一个公共聊天室的WebIM的想法（不要问我为什么有这么个想法，我也不造啊），然后这几天放假就都在干这个了OAQ。不管怎么说先来个截图预览一下吧：</p>
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb5wH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""预览"" title=""预览""></span></p>
<p>好吧，其实预览也没有什么可以看啦。简单说一下功能吧：</p>
<ol>
<li>自动获取你的SF信息，未登录的则为游客。</li>
<li>发送消息同步到其它页面</li>
<li>消息是Markdown语法，支持代码高亮</li>
<li>支持发送消息，颜文字表情和粘贴传图（复制图片后<code>Ctrl+V</code>到聊天窗口即可）</li>
<li>页面离开后支持消息通知</li>
<li>
<code>Enter</code>是发送快捷键，<code>Ctrl+Up</code>和<code>Ctrl+Down</code>是快速开启和关闭聊天窗口。</li>
</ol>
<p>大概的功能就这些，有些小的我可能没说全。做的比较仓促，如果有什么问题欢迎反馈。另外，我把插件的代码开源到了Github上头，这里是地址：<a href=""https://github.com/lizheming/chatonline"" rel=""nofollow noreferrer"">https://github.com/lizheming/...</a>。个人现在觉得UI很挫，如果想要和我一块开发这个插件的我也非常欢迎fork。</p>
<p>最后感谢 @naturefeng 和 @skylarkyn 一块帮我测试这个插件。感谢 <a href=""https://github.com/turingou/o3o"" rel=""nofollow noreferrer"">turingou</a> 项目提供的颜表情库，感谢Pagedown和GooglePrettify。</p>
<h2>更新</h2>
<h3>0.4版</h3>
<p>修改了一下气泡背景色等界面问题，修改消息发送快捷键为Enter，同时<code>Ctrl+Enter</code>为换行功能。简单的集成了官方的@功能。修改了后端部分，老版本需要升级才能正常使用。</p>
<h3>0.5版</h3>
<ul>
<li>修复了之前的一些bug（包括历史消息和样式表问题）</li>
<li>新增选项界面可以自定义设置消息背景，发送快捷键和窗口透明度等功能</li>
<li>新增自动升级功能（如果生效的话你们应该不用再每次自己下载升级了）</li>
<li>新增命令操作，输入<code>/help</code>可以查看当前支持的命令</li>
<li>输入<code>/users</code>命令显示所有在线人员，名称列表点击能快速@对方。</li>
<li>输入<code>/clear</code>命令可以清空当前对话框</li>
<li>点击头像也能快速@。</li>
</ul>
<h3>0.5.1版</h3>
<ul><li>修复上个版本的一些bug</li></ul>
<h3>0.6版</h3>
<ul>
<li>增加鼠标拖拽修改聊天窗口大小</li>
<li>消息推送方式由之前的长轮询修改为现在的WebSocket</li>
</ul>
<h3>0.6.1版</h3>
<ul>
<li>修复拖拽改变大小的一个bug</li>
<li>修改Socket连接的一些问题</li>
</ul>
<p>下载地址：<a href=""https://raw.githubusercontent.com/lizheming/chatonline/master/SF%20ChatOnline.crx"" rel=""nofollow noreferrer"">Github</a></p>

                ", SF ChatOnline插件,1531978123,461,1,721,1,1,https://segmentfault.com/a/1190000000458838
322,1,0,7,"
                    
<p><strong>注：译文出自 <a rel=""nofollow"" href=""https://github.com/edx/edx-platform/wiki/%E5%8F%98%E5%9F%BA%E6%8C%87%E5%8D%97"">GitHub edx</a>，经作者 <a rel=""nofollow"" href=""http://segmentfault.com/u/whilgeek"">@whilgeek</a> 提醒，对一些错误已纠正。</strong></p>

<hr>
<h2>一些说明</h2>

<p><a rel=""nofollow"" href=""https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request"">英文原文在此</a></p>

<h3>一些词汇表</h3>

<ul>
<li>rebase 变基</li>
<li>pull request 拉取请求 </li>
<li>merge 合并</li>
<li>repository 仓库</li>
<li>commit 提交</li>
<li>squash 压缩，挤压</li>
</ul>
<h3>另外</h3>

<p>有些词翻译过来反而不如原文精彩，就保留了，比如<code>fork</code>，<code>push</code>等等。</p>

<hr>
<p>(OK正文开始)</p>

<p>当很多人同时在一个工程上工作的时候，一个拉取请求也许很快就会过时。一个“过时”的拉取请求就是一个不再和开发主线保持同步的开发分支，它在合并到工程里面之前需要被更新。拉取请求之所以会过时的最常见原因是因为冲突的存在：如果两个拉取请求修改了同一个文件中的相同的几行，一个拉取请求被合并之后，没被合并的拉取请求和工程之间就会存在一个冲突。有时候，一个拉取请求在没有冲突的情况下也会过时。或许是代码基础中的一个不同文件发生了改动，需要你在拉取请求中做出相应的改变，以保证和新架构一致。又或许是某人意外将失败了的单元测试代码合并进了主分支时创建了新分支。不管是什么原因，如果你的拉取请求已经过时了，在你的分支能被合并之前，你需要将你的分支变基到主分支最新版本。<br><br></p>

<h2>什么是变基呢？</h2>

<p><span class=""img-wrap""><img data-src=""https://github.com/edx/edx-platform/wiki/git-diagrams/master.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Alt text""></span></p>

<p>为了理解这个，我们需要首先理解一点git运行的原理。一个git仓库是一个树形结构，树上的每个点都代表一个提交。这里有一个简单的关于仓库的例子：在主分支上它有4个提交，每个提交都有一个ID（在这里个例子中，ID是<code>a</code>,<code>b</code>,<code>c</code>和<code>d</code>）。你会注意到<code>d</code>目前是主分支中最新的提交（或者称为<code>HEAD</code>）。</p>

<p><span class=""img-wrap""><img data-src=""https://github.com/edx/edx-platform/wiki/git-diagrams/branch.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Alt text""></span></p>

<p>这里我们有两个分支，<code>master</code>和<code>my-branch</code>。你会看到<code>master</code>和<code>my-branch</code>中都包含<code>a</code>和<code>b</code>提交。然后它们开始分叉：<code>master</code>包含<code>c</code>和<code>d</code>，而<code>my-branch</code>包含<code>e</code>和<code>f</code>。<code>b</code>就是所谓的<code>my-branch</code>相对于<code>master</code>的<code>合并基础</code>，或者更一般的说，就是<code>基础</code>。这很有意义：你可以看到<code>my-branch</code>是基于<code>master</code>的一个早期版本。</p>

<p>所以我们称<code>my-branch</code>是过时的，而且你想让它和<code>master</code>分支的最新版本保持同步。换种说法，<code>my-branch</code>需要包含<code>c</code>和<code>d</code>。你可以做一个合并操作，但是这会让这个分支包含一些怪异的合并提交，让代码审查更为困难。为了不这样，你可以做一个<a rel=""nofollow"" href=""http://www.git-scm.com/book/en/Git-Branching-Rebasing""><code>rebase</code></a>操作。</p>

<p><span class=""img-wrap""><img data-src=""https://github.com/edx/edx-platform/wiki/git-diagrams/rebase.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Alt text""></span></p>

<p>当你变基的时候，git会找到你分支的base（在这个例子中是<code>b</code>）以及base和HEAD中的所有提交历史（在这个例子中是<code>e</code>和<code>f</code>）。并且将这些提交历史在你要变基进去的分支（在这个例子中是master）的HEAD（头提交）上<em>重演</em>一遍。参照你的修改，git创建了一些看起来就像是在master分支顶部进行修改的提交历史：在这个图中，这些提交被叫做<code>e</code>和<code>f</code>。git并不会擦除你之前的提交：<code>e</code>和<code>f</code>不会有人动的，而且如果在变基过程中出现了某些错误，你完全可以回到之前的状态，就像没变过基一样。</p>

<p>然而，另外需要注意的一点就是，git只把分支当作是标签。主分支就是主标签指向的，同时也是所有提交的祖先。当你给一个分支变基的时候，git移动分支标签指向新创建的分支，<code>my-branch</code>现在不再指向<code>f</code>，而是指向<code>f'</code>。退回到之前状态的方式，仅仅是改变了分支标签，所以它后退并指向了<code>f</code>。</p>

<h3>修改历史</h3>

<p>你会注意到从<code>f</code>到<code>f'</code>没有一条直接的通路，在其他人看来，历史好像被突然改变了。<code>c</code>和<code>d</code>被有效注入了<code>my-branch</code>分支，就好像它们一直在那里一样。不像其他的版本控制系统，git允许你修改你的项目的历史 -- 但是对这种允许一定要谨慎。我们稍后会讲到这一点。<br><br></p>

<h2>我怎么才能变基呢？</h2>

<p>好吧，现在你知道变基是什么了，下一步就是学习如何去变。假定你已经fork了<code>edx-platform</code>，而且你创建了一个分支。就像这样：</p>

<pre><code>git clone https://github.com/my-username/dex-platform.git
cd edx-platform
git checkout -b my-branch
</code></pre>

<p>在你的分支里你已经做了一些提交，并且将它们push到了Github上，并创建了一个拉取请求。你经历了代码审查，回应了别人的评论，然后某人要求你将你的拉取请求变基，下面是你要做的：</p>

<h3>将官方repo作为一个远程分支（仅仅在第一次的时候这样）</h3>

<p>在git的定义中，远程分支就是你能提交修改的仓库的克隆。当你从官方的<code>edx/edx-platform</code>中克隆出一份后。你创建了一个新的，名叫<code>your-username/edx-platform</code>的仓库<br>
，但是这两个仓库可以共享所作的提交。<br>
为了将<code>edx</code>添加为一个远程分支，在你的本地仓库中运行：</p>

<pre><code>git remote add edx https://github.com/edx/dex-platform.git
</code></pre>

<p>你可以运行<code>git remote -v</code>来验证是否成功，你应该看到<code>edx</code>在你的远程分支列表中。记住：这一步在每个克隆过程中只需要执行一次。</p>

<h3>抓取主分支的最新版本</h3>

<p>你的计算机需要从Github上下载关于这个官方仓库的信息，这样它就会知道主分支的最新版本。然后你的远程分支就建立好了，这很简单。在你的本地仓库中运行：</p>

<pre><code>get fetch edx
</code></pre>

<h3>Squash你做的改变（可选的）</h3>

<p>这一步是可选的，但是很建议你走这一步。这涉及到你在你的分支上所作的所有提交，然后将他们压缩成一个大点的提交。这样做的目的是为了在变基的时候可以更简单地结局冲突，以及让我们来审查你的拉取请求。</p>

<p>为了这样做，我们将会做一个<a rel=""nofollow"" href=""https://help.github.com/articles/interactive-rebase"">交互式的变基</a>。首先，找到你分支的基础。你可以这样来找：</p>

<pre><code>git merge-base my-branch master
</code></pre>

<p>这条命令会返回一个提交哈希。在下面这条命令中使用你得到的哈希：</p>

<pre><code>git rebase --interactive $${HASH}
</code></pre>

<p>举例来说，如果你合并的基础是<code>abc123</code>，你会运行<code>git rebase --interactive abc123</code>。你的文本编辑器会打开一个文本文件，其中列举了你对你的分支所作的所有提交。 而且，在每个提交之前都有一个写作<code>pick</code>的单词。就像这样：</p>

<pre><code>pick 1fc6c95 do something
pick 6b2481b do something else
pick dd1475d changed some things
pick c619268 fixing typos
</code></pre>

<p>你需要将除了第一行外所有的行之前的“pick”换做“squash”，做完的时候，应当是这样的：</p>

<pre><code>pick 1fc6c95 do something
squash 6b2481b do something else
squash dd1475d changed some things
squash c619268 fixing typos
</code></pre>

<p>保存并关闭这个文件，稍等片刻，一个新的文件会在你的编辑器中弹出来：包含着所有提交的所有信息。随意修改这些提交信息，同样的保存并关闭这个文件。保存的这些提交信息会变成一条提交信息，这是由那多条合并而来的。一旦你保存并关闭了这个文件你的这些提交就要被压缩成一个，这一步就完成了！</p>

<h3>终于开始变基了！</h3>

<p>在你本地分支中运行</p>

<pre><code>git rebase edx/master
</code></pre>

<p>git会开始在主分支的最新版本上重演你的提交。这一步你可能会遇到冲突：如果确实遇到了的话，git会暂停并让你在继续之前先解决冲突。就像在合并的时候解决冲突一样：你可以用<code>git status</code>来看哪些文件存在冲突，编辑这些文件以解决冲突，然后<code>git add</code>来表示冲突已经解决了。然而，你要运行<code>git rebase --continue</code>而不是<code>git commit</code>来告诉git可以继续来重演提交了。如果在做这一步之前，你已经压缩了你的提交，你可以一次性地解决冲突 -- 如果你没有压缩，你会多次解决冲突。</p>

<h3>用强推的方式来更新你的拉取请求</h3>

<p>就像上面解释的，当你变基的时候，你在修改你的分支的历史。结果就是，如果你在变基之后做一个普通的<code>git push</code>，git会拒绝它，因为在服务器的分支和你的分支之间没有一条直接的通路。所以，你要使用<code>-f</code>或<code>--force</code>标志来告诉git你知道你正在做什么。当你在做强制推送的时候，强烈建议你将你的<code>push.default</code>设置改为Git2.0中默认的<code>simple</code>。为了确保你的配置是正确的，运行：</p>

<pre><code>git config --global push.default simple
</code></pre>

<p>一旦修改正确，你就可以运行：</p>

<pre><code>git push -f
</code></pre>

<p>然后你检查一下你的拉取请求，它应该已经更新啦！</p>

                ", 变基指南,1531978124,536,1,864,1,1,https://segmentfault.com/a/1190000000456077
323,1,0,7,"
                    
<h1>快速搭建 Node.js 开发环境以及加速 npm</h1>

<p>在公交车上刷微博，还是有很多同学在咨询:</p>

<ul>
<li>如何快速搭建 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 开发环境</li>
<li>
<a rel=""nofollow"" href=""https://www.npmjs.org"">npm</a> 超慢</li>
<li>
<a rel=""nofollow"" href=""https://github.com"">github</a> 无法打开的问题</li>
</ul>
<p>于是我觉得应该写一篇文章解答所有这些起步问题，让新同学也能顺顺利利入门。</p>

<h2>快速搭建 <a rel=""nofollow"" href=""http://nodejs.org"">Node.js</a> 开发环境</h2>

<p>如果你想长期做 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 开发, 或者想快速更新 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 版本, 或者想快速切换 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 版本,<br>
那么在<strong>非 Windows(如 osx, linux)</strong> 环境下, 请使用 <a rel=""nofollow"" href=""https://github.com/creationix/nvm"">nvm</a> 来安装你的 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 开发环境, 保持系统的干净.</p>

<p>如果你使用 <strong>Windows</strong> 做开发, 那么你可以使用 <a rel=""nofollow"" href=""https://github.com/hakobera/nvmw"">nvmw</a> 来替代 <a rel=""nofollow"" href=""https://github.com/creationix/nvm"">nvm</a></p>

<h2>osx, linux 环境</h2>

<p>如果你是 windows 环境开发, 请跳过这里, 直接查看下一章.</p>

<h3>git clone <a rel=""nofollow"" href=""https://github.com/creationix/nvm"">nvm</a>
</h3>

<p>直接从 github clone nvm 到本地, 这里假设大家都使用 <code>~/git</code> 目录存放 git 项目:</p>

<pre><code class=""lang-bash"">$ cd ~/git
$ git clone https://github.com/creationix/nvm.git
</code></pre>

<p>配置终端启动时自动执行 <code>source ~/git/nvm/nvm.sh</code>,<br>
在 <code>~/.bashrc</code>, <code>~/.bash_profile</code>, <code>~/.profile</code>, 或者 <code>~/.zshrc</code> 文件添加以下命令:</p>

<pre><code class=""lang-bash"">source ~/git/nvm/nvm.sh
</code></pre>

<p>重新打开你的终端, 输入 <code>nvm</code></p>

<pre><code class=""lang-bash"">$ nvm

Node Version Manager

Usage:
    nvm help                    Show this message
    nvm --version               Print out the latest released version of nvm
    nvm install [-s] &lt;version&gt;  Download and install a &lt;version&gt;, [-s] from source
    nvm uninstall &lt;version&gt;     Uninstall a version
    nvm use &lt;version&gt;           Modify PATH to use &lt;version&gt;
    nvm run &lt;version&gt; [&lt;args&gt;]  Run &lt;version&gt; with &lt;args&gt; as arguments
    nvm current                 Display currently activated version
    nvm ls                      List installed versions
    nvm ls &lt;version&gt;            List versions matching a given description
    nvm ls-remote               List remote versions available for install
    nvm deactivate              Undo effects of NVM on current shell
    nvm alias [&lt;pattern&gt;]       Show all aliases beginning with &lt;pattern&gt;
    nvm alias &lt;name&gt; &lt;version&gt;  Set an alias named &lt;name&gt; pointing to &lt;version&gt;
    nvm unalias &lt;name&gt;          Deletes the alias named &lt;name&gt;
    nvm copy-packages &lt;version&gt; Install global NPM packages contained in &lt;version&gt; to current version

Example:
    nvm install v0.10.24        Install a specific version number
    nvm use 0.10                Use the latest available 0.10.x release
    nvm run 0.10.24 myApp.js    Run myApp.js using node v0.10.24
    nvm alias default 0.10.24   Set default node version on a shell

Note:
    to remove, delete or uninstall nvm - just remove ~/.nvm, ~/.npm and ~/.bower folders
</code></pre>

<h3>通过 <a rel=""nofollow"" href=""https://github.com/creationix/nvm"">nvm</a> 安装任意版本的 <a rel=""nofollow"" href=""http://nodejs.org"">node</a>
</h3>

<p>nvm 默认是从 <a rel=""nofollow"" href=""http://nodejs.org/dist/"">http://nodejs.org/dist/</a> 下载的, 国外服务器, 必然很慢,<br>
好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:</p>

<pre><code class=""lang-bash"">$ NVM_NODEJS_ORG_MIRROR=http://dist.u.qiniudn.com nvm install 0.11.11
</code></pre>

<p>于是你就会看到一段非常快速进度条:</p>

<pre><code>######################################################################## 100.0%
Now using node v0.11.11
</code></pre>

<p>如果你不想每次都输入环境变量 <code>NVM_NODEJS_ORG_MIRROR</code>, 那么我建议你加入到 <code>.bashrc</code> 文件中:</p>

<pre><code class=""lang-bash""># nvm
export NVM_NODEJS_ORG_MIRROR=http://dist.u.qiniudn.com
source ~/git/nvm/nvm.sh
</code></pre>

<p>然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:</p>

<pre><code>$ nvm ls
         nvm
     v0.8.26
    v0.10.26
    v0.11.11
-&gt;  v0.11.12
</code></pre>

<h2>windows 环境</h2>

<h3>git clone <a rel=""nofollow"" href=""https://github.com/hakobera/nvmw"">nvmw</a>
</h3>

<p>直接从 github clone nvmw 到本地, 这里假设大家都使用 <code>d:\git</code> 目录存放 git 项目:</p>

<pre><code class=""lang-bash"">$ d:
$ cd git
$ git clone https://github.com/hakobera/nvmw.git
</code></pre>

<p>在我提交的 <a rel=""nofollow"" href=""https://github.com/hakobera/nvmw/pull/21"">pl#21</a> 没有合并之前, 是不会有镜像功能的.<br>
大家可以从我的分支进行安装:</p>

<pre><code class=""lang-bash"">$ git clone https://github.com/fengmk2/nvmw.git -b custom-mirror
</code></pre>

<p>设置 <code>d:\git\nvmw</code> 目录到你的 <code>PATH</code> 环境变量中:</p>

<pre><code class=""lang-bash"">set ""PATH=d:\git\nvmw;%PATH%""
</code></pre>

<p>重新打开你的终端, 输入 <code>nvmw</code></p>

<pre><code class=""lang-bash"">$ nvmw

Usage:
  nvmw help                    Show this message
  nvmw install [version]       Download and install a [version]
  nvmw uninstall [version]     Uninstall a [version]
  nvmw use [version]           Modify PATH to use [version]
  nvmw ls                      List installed versions

Example:
  nvmw install v0.6.0          Install a specific version number
  nvmw use v0.6.0              Use the specific version
</code></pre>

<h3>通过 <a rel=""nofollow"" href=""https://github.com/hakobera/nvmw"">nvmw</a> 安装任意版本的 <a rel=""nofollow"" href=""http://nodejs.org"">node</a>
</h3>

<p>nvmw 默认是从 <a rel=""nofollow"" href=""http://nodejs.org/dist/"">http://nodejs.org/dist/</a> 下载的, 国外服务器, 必然很慢,<br>
好在 <a rel=""nofollow"" href=""https://github.com/hakobera/nvmw"">nvmw</a> 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:</p>

<pre><code class=""lang-bash"">$ set ""NVMW_NODEJS_ORG_MIRROR=http://dist.u.qiniudn.com""
$ nvmw install 0.11.11
</code></pre>

<p>于是你就会看到一段非常快速进度条:</p>

<pre><code>######################################################################## 100.0%
Now using node v0.11.11
</code></pre>

<p>如果你不想每次都输入环境变量 <code>NVMW_NODEJS_ORG_MIRROR</code>, 那么我建议你在全局环境变量中增加它.</p>

<p>然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:</p>

<pre><code>$ nvmw ls

v0.10.26
v0.11.12
Current: v0.11.12
</code></pre>

<p>到此, 无论是 windows 环境, 还是 osx, linux 环境, 都能快速安装多个版本的 node 了.</p>

<h2>使用 <a rel=""nofollow"" href=""http://cnpmjs.org"">cnpm</a> 加速 <a rel=""nofollow"" href=""https://www.npmjs.org"">npm</a>
</h2>

<p>同理 nvm , npm 默认是从国外的源获取和下载包信息, 不慢才奇怪.<br>
可以通过简单的 <code>---registry</code> 参数, 使用国内的镜像 <a rel=""nofollow"" href=""http://r.cnpmjs.org"">http://r.cnpmjs.org</a> :</p>

<pre><code class=""lang-bash"">$ npm --registry=http://r.cnpmjs.org install koa
</code></pre>

<p>于是屏幕又哗啦哗啦地一大片输出:</p>

<pre><code class=""lang-bash"">$ npm --registry=http://r.cnpmjs.org install koa
npm http GET http://r.cnpmjs.org/koa
npm http 200 http://r.cnpmjs.org/koa
npm http GET http://r.cnpmjs.org/koa/download/koa-0.5.2.tgz
npm http 200 http://r.cnpmjs.org/koa/download/koa-0.5.2.tgz
npm http GET http://r.cnpmjs.org/escape-html
npm http GET http://r.cnpmjs.org/statuses
...
npm http 200 http://r.cnpmjs.org/negotiator
npm http 200 http://r.cnpmjs.org/keygrip
koa@0.5.2 node_modules/koa
├── koa-compose@2.2.0
├── statuses@1.0.2
├── finished@1.1.1
├── escape-html@1.0.1
├── only@0.0.2
├── debug@0.8.0
├── fresh@0.2.2
├── type-is@1.0.1
├── delegates@0.0.3
├── mime@1.2.11
├── co@3.0.5
├── accepts@1.0.1 (negotiator@0.4.2)
└── cookies@0.4.0 (keygrip@1.0.0)
</code></pre>

<p>但是毕竟镜像跟官方的 npm 源还是会有一个同步时间差异, 目前 cnpm 的默认同步时间间隔是 15 分钟.<br>
如果你是模块发布者, 或者你想马上同步一个模块, 那么推荐你安装 <a rel=""nofollow"" href=""http://cnpmjs.org"">cnpm</a> cli:</p>

<pre><code class=""lang-bash"">$ npm --registry=http://r.cnpmjs.org install cnpm -g
</code></pre>

<p>通过 cnpm 命令行, 你可以快速同步任意模块:</p>

<pre><code class=""lang-bash"">$ cnpm sync koa connect mocha
</code></pre>

<p>呃, 我就是不想安装 cnpm cli 怎么办? 哈哈, 早就想到你会这么懒了, 于是我们还有一个 web 页面:</p>

<p>例如我想马上同步 koa, 直接打开浏览器: <a rel=""nofollow"" href=""http://cnpmjs.org/sync/koa"">http://cnpmjs.org/sync/koa</a></p>

<p>或者你是命令行控, 通过 open 命令打开:</p>

<pre><code class=""lang-bash"">$ open http://cnpmjs.org/sync/koa
</code></pre>

<p>如果你安装的模块依赖了 C++ 模块, 需要编译, 肯定会通过 <a rel=""nofollow"" href=""https://github.com/TooTallNate/node-gyp"">node-gyp</a> 来编译,<br><a rel=""nofollow"" href=""https://github.com/TooTallNate/node-gyp"">node-gyp</a> 在第一次编译的时候, 需要依赖 <a rel=""nofollow"" href=""http://nodejs.org"">node</a> 源代码, 于是又会去 node dist 下载,<br>
于是大家又会吐槽, 怎么 npm 安装这么慢...</p>

<p>好吧, 于是又要提到 <code>--disturl</code> 参数, 通过七牛的镜像来下载:</p>

<pre><code class=""lang-bash"">$ npm --registry=http://r.cnpmjs.org --disturl=http://dist.u.qiniudn.com install microtime
</code></pre>

<p>再次要提到 cnpm cli, 它已经默认将 <code>--registry</code> 和 <code>--disturl</code> 都配置好了, 谁用谁知道<br>
.<br>
写到这里, 就更快疑惑那些不想安装 cnpm cli 又吐槽 npm 慢的同学是基于什么考虑不在本地安装一个 cnpm 呢?</p>

<h2>github 好慢</h2>

<p>好了, 看到这里大家应该对 node 和 npm 已经没有速度慢的问题了.</p>

<p>github 慢, 或者说是它的资源 host 被堵而已, 大家可以通过简单的 hosts 映射解决:</p>

<pre><code>185.31.16.184 github.global.ssl.fastly.net
</code></pre>

<h2>为何最近访问国外网站这么慢?</h2>

<p>听说是 APCN2 又断了: <a rel=""nofollow"" href=""http://weibo.com/1415338244/ACTYkq8xK"">http://weibo.com/1415338244/ACTYkq8xK</a></p>

<p><span class=""img-wrap""><img data-src=""http://ww4.sinaimg.cn/large/545c5904gw1eeu7h63hxvj20qs0mp78p.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1""></span></p>

<h2>有爱</h2>

<p>希望文本对你有用. :)</p>

                ", 快速搭建 Node.js 开发环境以及加速 npm,1531978125,376,1,832,1,1,https://segmentfault.com/a/1190000000454456
324,1,0,7,"
                    
<p>下午更新了 <a rel=""nofollow"" href=""http://cirru.org"">http://cirru.org</a> , 整个页面的文档都是通过抓 GitHub README 生成的,</p>

<h4>已经失效的直接 GET 的方法</h4>

<p>抓 READMD 原来是有个简单的思路, 通过 HTTP 请求直接拿 raw 的文件,<br>
比如 cirru.org 项目的 README 文件, 原来的网址是这样的:<br><a rel=""nofollow"" href=""https://github.com/Cirru/cirru.org/blob/master/README.md"">https://github.com/Cirru/cirru.org/blob/master/README.md</a><br>
页面上代码右上角又个 raw 的链接, 可以获取纯文本的内容:<br><a rel=""nofollow"" href=""https://raw.githubusercontent.com/Cirru/cirru.org/master/README.md"">https://raw.githubusercontent.com/Cirru/cirru.org/master/README.md</a><br>
不过这个链接做了跨域限制, 不能直接用...</p>

<p>我记得早先的网址, 其实更短一些, 是这样的:<br><a rel=""nofollow"" href=""https://raw.github.com/Cirru/cirru.org/master/README.md"">https://raw.github.com/Cirru/cirru.org/master/README.md</a><br>
这个网址的特别之处在于, 通过去掉两个字母可以获得允许直接调用的网址:<br><a rel=""nofollow"" href=""http://rawgithub.com/Cirru/cirru.org/master/README.md"">http://rawgithub.com/Cirru/cirru.org/master/README.md</a><br>
不知什么缘故, 这个网址现在是个重定向, 内容有拿不到了</p>

<h4>通过 GitHub API</h4>

<p>通过查文档, 确认 GitHub 是有获取 README 的 API 的:<br><a rel=""nofollow"" href=""http://developer.github.com/v3/repos/contents/#get-the-readme"">http://developer.github.com/v3/repos/contents/#get-the-readme</a></p>

<pre><code>GET /repos/:owner/:repo/readme
</code></pre>

<p>不过网址没明确写, 搜索加猜测找到网站是这样的:<br><a rel=""nofollow"" href=""https://api.github.com/repos/Cirru/cirru.org/readme"">https://api.github.com/repos/Cirru/cirru.org/readme</a></p>

<p>从返回结果看, 里边没有 README 的文本内容, 而是包含一段 base64 字符,<br>
搜索可以知道 JS 里可以通过 <code>atob</code> 函数进行解码:<br><a rel=""nofollow"" href=""https://developer.mozilla.org/en-US/docs/Web/API/Window.atob"">https://developer.mozilla.org/en-US/docs/Web/API/Window.atob</a><br>
于是, 就能够通过获取 README 真实的文本内容了.</p>

<h4>两个注意的地方</h4>

<p>GitHub API 单个 IP 的访问数量存在限制, 需要通过注册应用来解决:<br><a rel=""nofollow"" href=""https://github.com/settings/applications/"">https://github.com/settings/applications/</a><br>
具体做法是在请求的 url 后面加上注册好的 key<br><a rel=""nofollow"" href=""http://developer.github.com/v3/#oauth2-keysecret"">http://developer.github.com/v3/#oauth2-keysecret</a></p>

<pre><code>$ curl 'https://api.github.com/users/whatever?client_id=xxxx&amp;client_secret=yyyy'
</code></pre>

<p>(我图方便直接在网页上使用了, 可能存在问题...)</p>

<p>另一个是我使用中发现非 ASCII 的字符, 比如国际音标, 显示为乱码<br>
估计是 base64 编码过程的问题, 我没想到好的办法..<br>
中文没有测试, 估计也会出现问题...<br>
我发了对应的问题,: <a rel=""nofollow"" href=""http://segmentfault.com/q/1010000000451621"">http://segmentfault.com/q/1010000000451621</a></p>

                ", Note: 通过 GitHub API 拿 GitHub README,1531978127,485,1,636,1,1,https://segmentfault.com/a/1190000000449969
325,1,0,7,"
                    
<p>“PHP是最好的编程语言” ;-) 那么PHPer习惯使用什么样的代码规范呢？<a rel=""nofollow"" href=""http://sideeffect.kr"">sideeffect.kr</a>通过分析GitHub上托管的开源代码，得出了一些<a rel=""nofollow"" href=""http://sideeffect.kr/popularconvention#php"">有趣的结果</a>，让我们一起来看看吧。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbST5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""code convention""></span></p>

<h2>缩进</h2>

<p>空格（70.172 %），Tab（29.828 %）</p>

<p>基于 600,614 次提交统计。</p>

<h2>定义类时大括号的位置</h2>

<p>独占一行（55.703 %）</p>

<pre><code class=""lang-php"">class Foo
{
  // ...
}
</code></pre>

<p>不独占一行（44.297 %）</p>

<pre><code class=""lang-php"">class Foo {
  // ...
}
</code></pre>

<p>基于 68,516 次提交统计。</p>

<h2>控制语句大括号的位置</h2>

<p>同一行（65.937 %）</p>

<pre><code class=""lang-php"">if($baz) {
  // ..
} elseif($bar) {
  // ..
} else {
  // ..
}

while ($i &lt;= 10) {
  // ..
}

switch($beer) {
  // ..
}
</code></pre>

<p>不同行 （34.063 %）</p>

<pre><code class=""lang-php"">if($baz)
{
  // ..
}
elseif($bar)
{
  // ..
}
else
{
  // ..
}

while ($i &lt;= 10)
{
  // ..
}

switch($beer)
{
  // ..
}
</code></pre>

<p>基于 292,588 次提交统计。</p>

<h2>方法定义大括号的位置</h2>

<p>同一行（64.442 %）</p>

<pre><code class=""lang-php"">function bar($baz) {
  // ...
}
</code></pre>

<p>不同行（35.558 %）</p>

<pre><code class=""lang-php"">function bar($baz)
{
  // ...
}
</code></pre>

<p>基于 65,030 次提交统计。</p>

<h2>条件语句周围空格</h2>

<p>有空格 （89.979 %）</p>

<pre><code class=""lang-php"">if ($baz) {
  // ...
} elseif ($bar) {
  // ...
} else {
  // ...
}

while ($i &lt;= 10) {
  // ...
}

switch ($beer) {
  // ...
}
</code></pre>

<p>无空格 （10.021 %）</p>

<pre><code class=""lang-php"">if($baz){
  // ...
}elseif($bar){
  // ...
}else{
  // ...
}

while($i &lt;= 10){
  // ...
}

switch($beer){
  // ...
}
</code></pre>

<p>基于 219,583 次提交统计。</p>

<h2>条件语句内部空格</h2>

<p>无空格（82.808 %）</p>

<pre><code class=""lang-php"">if ($baz) {
  // ...
} elseif ($bar) {
  // ...
}

while ($i &lt;= 10) {
  // ...
}

switch ($beer) {
  // ...
}
</code></pre>

<p>有空格（17.192 %）</p>

<pre><code class=""lang-php"">if ( $baz ) {
  // ...
} elseif ( $bar ) {
  // ...
}

while ( $i &lt;= 10 ) {
  // ...
}

switch ( $beer ) {
  // ...
}
</code></pre>

<p>基于 296,011 次提交统计。</p>

<h2>方法声明参数外部</h2>

<p>无空格（82.407 %）</p>

<pre><code class=""lang-php"">function bar($baz){
  // ...
}
</code></pre>

<p>有空格 （17.593 %）</p>

<pre><code class=""lang-php"">function bar ($baz) {
  // ...
}
</code></pre>

<p>基于 15,519 次提交统计</p>

<h2>方法声明参数内部</h2>

<p>无空格（84.828 %）</p>

<pre><code class=""lang-php"">function bar($baz){
  // ...
}
</code></pre>

<p>有空格（15.172 %）</p>

<pre><code class=""lang-php"">function bar( $baz ){
  // ...
}
</code></pre>

<p>基于 52,324 次提交统计</p>

<h2>类名</h2>

<p>PascalCase （75.973 %）</p>

<pre><code class=""lang-php"">class FooBarBaz {
  // ...
}
</code></pre>

<p>Snake_Pascal_Case （14.564 %）</p>

<pre><code class=""lang-php"">class Foo_Bar_Baz {
  // ...
}
</code></pre>

<p>snake_case （6.025 %）</p>

<pre><code class=""lang-php"">class foo_bar_baz {
  // ...
}
</code></pre>

<p>camelCase （2.851 %）</p>

<pre><code class=""lang-php"">class fooBarBaz {
  // ...
}
</code></pre>

<p>Snake_first_letter_uppercase （0.299 %）</p>

<pre><code class=""lang-php"">class Foo_bar_baz {
  // ...
}
</code></pre>

<p>CAPS_SNAKE_CASE （0.287 %）</p>

<pre><code class=""lang-php"">class FOO_BAR_BAZ {
  // ...
}
</code></pre>

<p>基于 60,467 次提交统计。</p>

<h2>常量</h2>

<p>CAPS_SNAKE_CASE （97.511 %）</p>

<pre><code class=""lang-php"">const BAR_BAZ = 0;

define('BAR_BAZ', 0);
</code></pre>

<p>snake_case （1.088 %）</p>

<pre><code class=""lang-php"">const bar_baz = 0;

define('bar_baz', 0);
</code></pre>

<p>camelCase （0.842 %）</p>

<pre><code class=""lang-php"">const barBaz = 0;

define('barBaz', 0);
</code></pre>

<p>PascalCase （0.507 %）</p>

<pre><code class=""lang-php"">const BarBaz = 0;

define('BarBaz', 0);
</code></pre>

<p>Snake_Pascal_Case （0.052 %）</p>

<pre><code class=""lang-php"">const Bar_Baz = 0;

define('Bar_Baz', 0);
</code></pre>

<p>基于 30,144 次提交统计。</p>

<h2>函数名</h2>

<p>camelCase （74.26 %）</p>

<pre><code class=""lang-php"">function barBaz(){
  // ...
}
</code></pre>

<p>snake_case （23.644 %）</p>

<pre><code class=""lang-php"">function bar_baz(){
  // ...
}
</code></pre>

<p>PascalCase （1.868 %）</p>

<pre><code class=""lang-php"">function BarBaz(){
  // ...
}
</code></pre>

<p>CAPS_SNAKE_CASE （0.14 %）</p>

<pre><code class=""lang-php"">function BAR_BAZ(){
  // ...
}
</code></pre>

<p>Snake_Pascal_Case （0.087 %）</p>

<pre><code class=""lang-php"">function Bar_Baz(){
  // ...
}
</code></pre>

<p>基于 185,946 次提交统计</p>

<h2>方法声明</h2>

<p>static在可见性之后（85.272 %）</p>

<pre><code class=""lang-php"">class Foo
{
  public static function bar($baz)
  {
    // ...
  }
}
</code></pre>

<p>abstract（或final）在可见性之前（7.483 %）</p>

<pre><code class=""lang-php"">class Foo
{
  abstract public function bar($baz);
  // ...
}
</code></pre>

<p>static在可见性之前（5.519 %）</p>

<pre><code class=""lang-php"">class Foo
{
  static public function bar($baz)
  {
    // ...
  }
}
</code></pre>

<p>abstract（或final）在可见性之后（1.726 %）</p>

<pre><code class=""lang-php"">class Foo
{
  public abstract function bar($baz);
  // ...
}
</code></pre>

<p>基于 45,467 次提交统计。</p>

<p><em>译注：此处统计归类不当。应当拆分成两类分别统计。</em></p>

<h2>最大行宽</h2>

<p>80字符 （90.269 %）</p>

<p>120字符 （7.074 %）</p>

<p>150字符 （2.657 %）</p>

<p>基于 636,577 次提交统计</p>

<hr>
<p>编译 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", 最流行的PHP 代码规范,1531978128,121,1,867,1,1,https://segmentfault.com/a/1190000000443795
326,1,0,7,"
                    
<p>本文介绍我一年前在自己的项目（包括工作项目和私人项目）中引入的git分支模式，这个模式很成功。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbYDS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>主要分支</h2>

<p>中央仓库中有两个长期的分支：</p>

<ul>
<li>master</li>
<li>develop</li>
</ul>
<p><code>master</code>用作生产分支，里面的代码是准备部署到生产环境的。</p>

<p><code>develop</code>是可交付的开发代码，也可以看成是用于集成分支，每晚构建从<code>develop</code>获取代码。</p>

<p>当<code>develop</code>分支中的代码足够稳定的时候，就将改动合并到<code>master</code>分支，同时打上一个标签，标签的名称为发布的版本号。</p>

<h2>辅助分支</h2>

<p>通过辅助分支来帮助并行开发，和主要分支不同，这些分支的生命周期是有限的：</p>

<ul>
<li>特性分支</li>
<li>发布分支</li>
<li>紧急修复分支</li>
</ul>
<h3>特性分支</h3>

<p>特性分支可能从<code>develop</code>分支分出，最终<strong>必须</strong>合并回<code>develop</code>。</p>

<p>特性分支（也叫主题分支）用于开发新特性。每个新特性开一个新分支，最终会合并回<code>develop</code>（当特性开发完毕的时候），或者放弃（如果最终决定不开发这个特性）。</p>

<p>特性分支只存在于开发者的仓库中。</p>

<h4>创建一个特性分支</h4>

<p>从<code>develop</code>分支分出：</p>

<pre><code class=""lang-sh"">$ git checkout -b myfeature develop
</code></pre>

<h4>合并回<code>develop</code>
</h4>

<p>完成的特性需要合并回<code>develop</code>：</p>

<pre><code class=""lang-sh"">$ git checkout develop
$ git merge --no-ff myfeature
$ git branch -d myfeature
$ git push origin develop
</code></pre>

<p>使用<code>--no-ff</code>确保总是新生成一个提交，避免丢失曾经存在一个特性分支的历史信息，也能够方便地看出哪些提交属于同一个特性。比较：</p>

<p>![merge --no-ff]<a rel=""nofollow"" href=""http://segmentfault.com/img/bVbYDZ"">http://segmentfault.com/img/bVbYDZ</a></p>

<h3>发布分支</h3>

<p>发布分支可能从<code>develop</code>分出，最终<strong>必须</strong>合并回1<code>develop</code>和<code>master</code>。发布分支以<code>release-*</code>的方式命名。</p>

<p>发布分支为新的发布版本作准备，包括一些小bug的修正和发布的元信息（版本号、发布日期等）的添加。这样<code>develop</code>分支就可以接受针对以后的发布的新特性。</p>

<p>在代码基本可以发布的时候从<code>develop</code>分支分出发布分支。这时要确保此次发布包括的特性都已经合并到<code>develop</code>分支了（同时，为下一版发布准备的特性不能合并到<code>develop</code>分支，必须等待发布分支分出后才能合并）。</p>

<h4>创建发布分支</h4>

<pre><code class=""lang-sh"">$ git checkout -b release-1.2 develop
$ ./bump-version.sh 1.2
$ git commit -a -m ""Bumped version number to 1.2""
</code></pre>

<p><code>bump-version.sh</code>是一个脚本，修改相应文件的信息，以体现版本号已经改变了。</p>

<h4>完成发布分支</h4>

<p>当发布分支中的代码可以发布的时候，将代码合并到<code>master</code>分支，并打上相应的标签。同时还需要合并到<code>develop</code>分支，因为发布分支里可能包含一些修正bug的代码，合并回去可以确保以后的版本也包含这些修正。</p>

<pre><code class=""lang-sh"">$ git checkout master
$ git merge --no-ff release-1.2
$ git tag -a 1.2

$ git checkout develop
$ git merge --no-ff release-1.2
</code></pre>

<p>注意，合并回<code>develop</code>分支很可能导致合并冲突，我们需要手工修复一下，然后提交。之后可以删除发布分支：</p>

<pre><code class=""lang-sh"">$ git branch -d release-1.2
</code></pre>

<h3>紧急修复分支</h3>

<p>可能从<code>master</code>分出，<strong>必须</strong>合并回<code>develop</code>和<code>master</code>。分支名以<code>hotfix-*</code>开头。</p>

<p>紧急修复分支和发布分支很像，只不过它们是意料之外的。如果生产系统里有一个紧急的bug，必须马上修复的话，我们就从<code>master</code>里分出一个紧急修复分支。</p>

<p>这样，某个人修复紧急bug的同时，团队其他成员可以继续在<code>develop</code>分支上开发。</p>

<h4>创建紧急修复分支</h4>

<pre><code class=""lang-sh"">$ git checkout -b hotfix-1.2.1 master
$ ./bump-version.sh 1.2.1
$ git commit -a -m ""Bumped version number to 1.2.1""
</code></pre>

<p>修复bug并提交</p>

<pre><code class=""lang-sh"">$ git commit -m ""Fixed severe production problem""
</code></pre>

<h4>完成紧急修复分支</h4>

<p>修复bug之后，需要合并回<code>master</code>，同时也需要合并回<code>develop</code>。</p>

<pre><code class=""lang-sh"">$ git checkout master
$ git merge --no-ff hotfix-1.2.1
$ git tag -a 1.2.1

$ git checkout develop
$ git merge --no-ff hotfix-1.2.1
</code></pre>

<p>以上情况假定不存在发布分支。假设存在发布分支的话，代码不应该合并回<code>develop</code>，而应该合并回发布分支，确保正在准备的发布分支也能收到这个补丁（由于发布分支最终会合并到<code>develop</code>，因此这时不用再另外合并到<code>develop</code>）。</p>

<p>最后，删除这个紧急修复分支：</p>

<pre><code class=""lang-sh"">$ git branch -d hotfix-1.2.1
</code></pre>

<hr>
<p>原文 <a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">A successful Git branching model</a><br>
翻译 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", git分支最佳实践,1531978129,457,1,450,1,1,https://segmentfault.com/a/1190000000434973
327,1,0,7,"
                    
<p>本文同步自我的博客园：<a rel=""nofollow"" href=""http://hustskyking.cnblogs.com"">http://hustskyking.cnblogs.com</a></p>

<p>主要是 windows 用户会遇到很多纠结的问题，linux/unix 用户属于这方面的高端用户，应该有能力处理此类问题，而且网络上也有很多解决方案，本文的受众是 windows 用户。由于今天配置了一下午，虽说配置过程基本搞清楚，懒得重新配置一遍，所以文中皆以文字形式叙述，没有截图。</p>

<h2>一、概念的解释</h2>

<h3>1. rsa 与 rsa.pub</h3>

<p>网上很容易搜到的东西我就不说了，我们知道，通过：</p>

<pre><code>ssh-keygen -t rsa -C ""something""
</code></pre>

<p>可以生成两个文件，这两个文件的命名默认是 id_rsa 和 id_rsa.pub，如果你在键入上述命令回车之后，重新输入了命名，那此时生成的两个文件就是 <code>[命名]</code> 和 <code>[命名].pub</code>，这个好理解。</p>

<p>主要是解释下生成了两个什么东西。id_rsa 可以称之为私有密钥，id_rsa.pub 可以称之为公有密钥。我们会把公有密钥交给服务端，当需要从服务端请求内容的时候，要带上私有密钥。此时，服务器会通过一定的算法计算私有密钥，并判断计算的结果是否与公有密钥一样，如果不一样则响应请求失败。</p>

<pre><code>+-----------+                           +-----------+
|           |                           |           |
|           |    enc(rsa) == rsa.pub    |           |
|  client   | ------------------------&gt; |   server  |
|           |             ?             |           |
|           |                           |           |
+-----------+                           +-----------+
</code></pre>

<p>rsa.pub 里面是个什么东西，其实很简单：</p>

<pre><code>ssh-rsa base64(加密内容) ""something""
</code></pre>

<p>而 rsa 中是：</p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
base64(私有密钥的一些处理)
-----END RSA PRIVATE KEY-----
</code></pre>

<h3>2. 验证程序</h3>

<p>在使用 git 命令与服务端进行交互之前，我们可以先验证下服务器和客户端是否握手成功了。</p>

<pre><code>ssh -T git@xxx.com
</code></pre>

<p>如果是 github，就可以直接写 git@github.com, 如果是 aaa.bbb.com，就可以写 git@aaa.bbb.com。 如果成功，你会看到 success 之类的字眼。</p>

<h3>3. known_hosts 文件</h3>

<p>这是个什么文件呢？一般情况下 windows 下不会产生这个文件，先说说他是干什么的。当我们成功与服务端进行连接时，ssh 会记录服务端的 Host、IP 以及 rsa 文件，当连接过程中出现：</p>

<pre><code>Permanently added '10.0.0.0' (RSA) to the list of known hosts.
</code></pre>

<p>如果你选择 Yes，那这个 known_hosts 文件中就会多出一条记录。windows 是不会自动产生这个文件的，也可能是程序产生了，但是没权限写入，所以我们没有在 .ssh/ 目录下看到这个文件。但如果我们创建了这个文件，会发现里面的内容会随着我们的验证慢慢增加。</p>

<p>搞清楚了这些概念，我们再说说会遇到的问题。</p>

<h2>二、常见问题</h2>

<h3>1. git@xxx.com 输入密钥</h3>

<p>当你键入 <code>ssh -T git@xxx.com</code> 这条命令之后，程序提示要你输入 git@xxx.com 的密码，那不用想了，程序没找到你的私有密钥。在哪些情况下会这样呢？</p>

<p>我们在生成这两个密钥的时候，程序可能没有帮我们在根目录下(C:/Users/yourName)新建一个 .ssh/ 文件夹，而他在建立连接的时候会默认寻找 <code>~/.ssh/id_rsa</code>，如果没有新建一个这样的文件夹很显然是找不到的。你可以在根目录下通过命令行来新建一个文件夹</p>

<pre><code>mkdir .ssh
</code></pre>

<p>之所以要用命令行是因为有时候浏览器不让你在文件夹名第一位放点号。</p>

<p>当然也有可能是因为你没有把创建的两个密钥放到 .ssh/ 目录下，而是直接扔在根目录下。</p>

<h3>2. Host key verification failed</h3>

<p>""Host key verification failed."" 相信你也撞到了这个问题，主机的密钥验证失败，主机就是你的机器，密钥验证失败有两个原因，一个是 RSA 做了更改，另一个原因是在 known_hosts 中存在一个缓存的记录，如果确认了 RSA 没有错误，那你就应该去 known_hosts 中删掉对应的那个记录（这个记录可以当做是缓存，是对验证做了一次缓存，缓存的作用是减少验证次数，不需要每次都验证，读取缓存就行了）。</p>

<p>当然，你也可以直接删除这个 known_hosts 文件。</p>

<h3>3. Permission denied (publickey)</h3>

<p>""Permission denied (publickey)."" 这个问题其实和上面的 2 差不多，当你出现过 ""Host key verification failed.""，然后继续执行程序，如执行 <code>ssh -T git@xxx.com</code> 的时候就会出现这个问题提醒。说到底就是没有找到你的 rsa 私有密钥，或者 rsa 密钥匹配出错。</p>

<h2>三、windows 下让人纠结的问题</h2>

<h3>1. 找不到根目录</h3>

<p>生成密钥默认放在 ""~/.ssh/"" 下，但是在 cmd 下操作会找不到 ""~/"" 这个根目录，因为这是 windows 不是 linux/unix，有些童鞋可能装了 cygwin，在这个环境下操作可以 ""cd ~""，git bash 下当然也是可以的。</p>

<p>如果不知道有这个问题的存在，你会碰到上述问题一，程序直接让你输入密码，但不过你输入什么密码都是错误的。输入三次之后状态为 <code>Permission denied</code>，这里的原因就是没找到 <code>~/.ssh/id_rsa</code> ，cmd 下她根本就不认识 ""~/"" 这个目录。</p>

<h3>2. 多个服务端的维护</h3>

<p>很常见的问题。上面我们说到了，程序会默认寻找 <code>~/.ssh/id_rsa</code> 这个文件，同一目录下显然不能有两个重名文件，也就是说当我们去认证 github 和另外一个 git 服务器的时候，我们需要把两个 rsa 私有密钥的名字换来换去，想用谁就把谁改成 id_rsa。特别麻烦，那肿么办？</p>

<p>之前在网上看到说是对 ssh_config 进行配置，配置内容是：</p>

<pre><code>Host github.com
    User boy-a
    IdentifyFile ~/.ssh/github
Host xxx.com
    User boy-b
    IdentifyFile ~/.ssh/xxx
</code></pre>

<p>这里的 ""~/.ssh/github"" 和 ""~/.ssh/xxx"" 都是 rsa 文件，文件的命令可以直接改，也可以在开始生成的时候设定，命名对内容没有任何影响。项目的几行代码应该也是十分清晰的，针对不同的 git 服务器，使用不用的 IdentifyFile。</p>

<p>但是你会发现，你的设置毫无用处，因为你把文件名搞错了！在 linux/unix 下可能是使用 ssh_config 这个文件名，但是在 windows 下是使用 config 作为文件名放在 ~/.ssh/ 目录中！</p>

<h2>四、小结</h2>

<p>这东西我纠结了一个下午，花了将近三个多小时才解决问题，真心快吐血了！说到底就是一个 config 的配置问题，遇到这种问题最快捷的方式并不是在网上疯狂的搜索答案，而是静下心来看看 rsa | git | ssh 的基础知识，了解每个参数及其用途，对症下药！</p>

                ", git/ssh捋不清的几个问题,1531978130,557,1,571,1,1,https://segmentfault.com/a/1190000000430544
328,1,0,7,"
                    
<p><a rel=""nofollow"" href=""http://legacy.python.org/dev/peps/pep-0008/"">PEP 8</a>等规范性文件试图统一Python的编码风格，那么实际效果到底如何呢？</p>

<p><a rel=""nofollow"" href=""http://sideeffect.kr"">sideeffect.kr</a>通过分析GitHub上托管的开源代码，得出了<a rel=""nofollow"" href=""http://sideeffect.kr/popularconvention#python"">一些有趣的结果</a>。一起来看看吧。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbST5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""code convention""></span></p>

<h2>使用空格还是Tab缩进</h2>

<p>空格（95.037%）</p>

<p>Tab（4.963 %）</p>

<p>基于1,721,799次提交统计</p>

<h2>最大行宽</h2>

<p>80字符（93.184 %）</p>

<p>120字符（5.544 %）</p>

<p>150字符（1.272 %）</p>

<p>基于1,846,169次提交统计</p>

<h2>是否一行一import</h2>

<p>每个import独占一行（96.081 %）</p>

<pre><code class=""lang-python"">import os
import sys
</code></pre>

<p>不独占一行（3.919 %）</p>

<pre><code class=""lang-python"">import sys, os
</code></pre>

<h2>表达式和语句中的空格</h2>

<h2>避免过多的空格 （79.04 %）</h2>

<pre><code class=""lang-python"">spam(ham[1], {eggs: 2})

if x == 4: print x, y; x, y = y, x

spam(1)

dict['key'] = list[index]

x = 1
y = 2
long_variable = 3
</code></pre>

<h2>更多地使用空格（20.96 %）</h2>

<pre><code class=""lang-python"">spam( ham[ 1 ], { eggs: 2 } )

if x == 4 : print x , y ; x , y = y , x

spam (1)

dict ['key'] = list [index]

x             = 1
y             = 2
long_variable = 3
</code></pre>

<p>看来基本上大多数Pythoner都遵循PEP 8风格编程，在空格的使用上稍微有些分歧——可能不少程序员觉得多加一些空格更美观吧。</p>

<hr>
<p>编撰 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", 最流行的Python代码规范,1531978132,174,1,403,1,1,https://segmentfault.com/a/1190000000417283
329,1,0,7,"
                    
<p>什么是最佳的JavaScript代码编程规范？这可能是一个众口难调的问题。那么，不妨换个问题，什么代码规范最流行？</p>

<p><a rel=""nofollow"" href=""http://sideeffect.kr"">sideeffect.kr</a>通过分析GitHub上托管的开源代码，得出了<a rel=""nofollow"" href=""http://sideeffect.kr/popularconvention#javascript"">一些有趣的结果</a>。一起来看看吧。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbST5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""code convention""></span></p>

<h2>行末逗号对行首逗号</h2>

<p>行末引号：</p>

<pre><code class=""lang-js"">var foo = 1,
    bar = 2,
    baz = 3;

var obj = {
    foo: 1,
    bar: 2,
    baz: 3
};
</code></pre>

<p>行首引号：</p>

<pre><code class=""lang-js"">var foo = 1
  , bar = 2
  , baz = 3;

var obj = {
    foo: 1
  , bar: 2
  , baz: 3
};
</code></pre>

<p>行末，92.345%；行首，7.655%。（基于1,100,251次提交统计。）</p>

<h2>空格和Tab</h2>

<p>这年头大家都爱用空格了。使用空格缩进可以保证不同的开发者、不同的编辑器设置下看到的结果是一样的。</p>

<p>空格，81.1 %；Tab，18.9 %。（基于2,019,550次提交统计。）</p>

<h2>函数后是否添加空格</h2>

<p>无空格</p>

<pre><code class=""lang-js"">function foo() {
  return ""bar"";
}
</code></pre>

<p>有空格</p>

<pre><code class=""lang-js"">function foo () {
  return ""bar"";
}
</code></pre>

<p>无空格，67.424 %；有空格，32.576 %。（基于1,212,488次提交统计。）</p>

<h2>参数与括号间是否有空格</h2>

<p>无空格</p>

<pre><code class=""lang-js"">function fn(arg1, arg2) {
//or
if (true) {
</code></pre>

<p>有空格</p>

<pre><code class=""lang-js"">function fn( arg1, arg2 ) {
  // ...
}

if ( true ) {
  // ...
}
</code></pre>

<p>无空格，94.31 %；有空格，5.69 %。（基于1,514,971次提交统计。）</p>

<h2>对象字面量中冒号周围是否有空格</h2>

<p>冒号后有空格</p>

<pre><code class=""lang-js"">{
  foo: 1,
  bar: 2,
  baz: 3
}
</code></pre>

<p>冒号后无空格</p>

<pre><code class=""lang-js"">{
  foo:1,
  bar:2,
  baz:3
}
</code></pre>

<p>冒号前后均有空格</p>

<pre><code class=""lang-js"">{
  foo : 1,
  bar : 2,
  baz : 3
}
</code></pre>

<p>后空格，62.955 %；无空格，22.891 %；前后空格，14.154 %。（基于1,300,035次提交统计。）</p>

<p>个人觉得，无空格太挤了，不利于快速分清key和value。前后空格的话，恐怕需要对齐冒号，看起来才美观，从统计数据来看，大部分程序员懒得对齐冒号（还是说，大部分程序员的IDE或编辑器不够智能？）</p>

<h2>条件语句</h2>

<p>有空格</p>

<pre><code class=""lang-js"">if (true) {
  //...
}

while (true) {
  //...
}

switch (v) {
  //...
}
</code></pre>

<p>无空格</p>

<pre><code class=""lang-js"">if(true) {
  //...
}

while(true) {
  //...
}

switch(v) {
  //...
}
</code></pre>

<p>有空格，78.276 %；无空格，21.724 %。（基于1,163,316次提交。）</p>

<h2>单引号、双引号</h2>

<p>单引号，56.791 %；双引号，43.209 %。（基于1,705,910次提交。）</p>

<h2>总结</h2>

<p>所以说，最流行的代码规范是:</p>

<ul>
<li>行末逗号</li>
<li>空格缩进</li>
<li>函数名称后无空格</li>
<li>函数参数与括号间无空格</li>
<li>对象字面量的冒号后加空格，冒号前不加</li>
<li>条件语句关键字后加空格</li>
</ul>
<p>流行的不一定是好的（比如流行性感冒），但是从交流的角度来说，按照流行的风格编写代码，可以让你的代码在大多数人看起来更习惯。</p>

<hr>
<p>编撰 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", 最流行的JavaScript代码规范,1531978133,529,1,182,1,1,https://segmentfault.com/a/1190000000410316
330,1,0,7,"
                    
<p>系列文章传送门：</p>

<p><a rel=""nofollow"" href=""http://skyinlayer.com/blog/2014/01/25/jekyll-1/"">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a rel=""nofollow"" href=""http://skyinlayer.com/blog/2014/01/27/jekyll-2/"">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a rel=""nofollow"" href=""http://skyinlayer.com/blog/2014/02/06/jekyll-3/"">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p>今天又滚出去野了一天，打牌输了，好在输的不多，聊天聊到了以后的路子，不太好走啊...</p>

<h2>使用Category分类</h2>

<p>一般来说，一个个人博客的文章会分为很多种，比如说有记录生活情感的、技术交流的、转载他人的等等，而在jekyll中，可以使用Category进行分类，使用方法非常简单</p>

<h3>为文章定义分类</h3>

<p>首先要确定文章属于哪个分类。这个配置可以设置在文章的头信息中，使用category或者categories确定，如文章属于“test”类别：</p>

<pre><code>---
layout: MyTemplate
title: Category Sample
category: test
---
</code></pre>

<p>或者使用categories，这个属性接受一个数组，代表这篇文章所述的类，如文章属于“test”和“sample”类别：</p>

<pre><code>---
layout: MyTemplate
title: Category Sample
categories: [test, sample]
---
</code></pre>

<p>加入这些信息后，文章所属分类就定义好了。但是还需要在页面（或者模板）中输出分类所有的文章才能完成以分类为基础的索引功能</p>

<h3>输出所有分类</h3>

<p>所有的分类信息都被存储在site对象的categories中，所以可以通过liquid的for标签进行输出：</p>

<pre><code class=""lang-html"">{% for category in site.categories %}
&lt;h2&gt;{{ category | first }}&lt;/h2&gt;
&lt;/span&gt;{{ category | last | size }}&lt;/span&gt;
&lt;ul class=""arc-list""&gt;
    {% for post in category.last %}
        &lt;li&gt;{{ post.date | date:""%d/%m/%Y""}}&lt;a href=""{{ post.url }}""&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
{% endfor %}
</code></pre>

<p>上面代码可以看到，首先从site中取出所有categories的信息，分别输出。categories的元素为一个两个元素的数组，第一个元素为category的名字，第二个元素则为一个数组，保存有该分类下文章的列表</p>

<p>于是乎就很简单了：<br>
*  使用<code>{{ category | first }}</code>输出分类的名称<br>
*  使用<code>{{ category | last | size }}</code>输出该分类下文章的数目<br>
*  遍历category.last输出所有文章的信息，构建到该文章的索引</p>

<p>这样就完成了在一个页面上输出所有分类，及其所有文章索引的方法了。但是需要注意的是，这种方式只能获取所有分类，而不能获取某个单一分类下的文章。毕竟jekyll编译完成后是静态页面，没有办法动态生成（除非为每一个分类都创建一个html文件，并在首页上创建一大堆通向这些html文件的a标签）。事实上，这个问题有一个解决方法是使用jekyll插件去解决。但是github不支持三方jekyll插件。所以必须绕个弯子来实现这种方式</p>

<h3>输出单个分类下的所有文章</h3>

<p>我们可以轻松获得所有分类下的所有文章，但是没有办法只输出一个分类下的文章。</p>

<p>首先可以想到的解决方法方法：首先把所有分类和所有文章的html生成好，然后全部隐藏。把需要显示的分类的名称放在url中，使用javascript读取名称出来后根据名称显示该分类。这样做有一个坏处：如果文章数较多，而每个文章都有很多分类，那么就会出现html文件很大，加载很慢的情况。</p>

<p>于是乎又想到一种方法，将所有的数据压缩在JSON中，然后通过javascript解析JSON对象，然后动态生成html。这种方法不过是一个折中，如果需要生成的html较为复杂，完全可以使用第一种方法。但如果只是简单的索引，这种方法就足够了。根据需要考量吧。下面放一点简单的源码来介绍一下这种方法：</p>

<pre><code class=""lang-javascript"">var dataStr = '{ {% for cat in site.categories %}{% if cat[0] != site.categories.first[0] %},{% endif %}""{{ cat[0] }}"":[{% for post in cat[1] %}{% if post != cat[1].first %},{% endif %}{""url"":""{{post.url}}"", ""title"":""{{post.title}}"", ""date"":""{{post.date | date:""%d/%m/%Y""}}""}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get(""cat""),
    archieves = data[curTag];
</code></pre>

<p>首先通过上面介绍过的方法构建JSON字符串，这里只是一个模板，读取了所有分类，并以分类名称为key，文章列表为value构建了一个对象。文章列表的元素也是一个对象，有date，url，title三个值，分别表示文章的日期、url路径、标题，帮助生成索引。解析完之后就可以通过url中的category的名称取出来了。这里使用了一个叫jQuery.query的插件，专门取url的参数并进行包装。</p>

<p>综上所述，比如只显示单一分类的页面叫showCategory.html，要显示java分类，那么首页中给个a标签，href为<code>/showCategory.html?cat=java</code>就行了，方便快捷（笑）</p>

<h3>类别为中文时问题</h3>

<p>Windows下，使用UTF-8编码时当category为中文时，在通过url进入文章时，会出现如下错误</p>

<pre><code>Internal Server Error
""\xAE\xBE"" from GBK to UTF-8
</code></pre>

<p>我并不知道这个编码为何会需要从GBK转换为UTF-8，所以只能通过其他方式进行避开。网上应该会有人解答这个问题，需要进一步去查了，这里讲一下我怎么避开的吧</p>

<p>首先介绍一下jekyll的Permalinks这个配置，这个配置定义了文章被jekyll处理后生成结果的最终路径，默认为<code>/:categories/:year/:month/:day/:title.html</code>，也就是说，如一篇文章叫“2014-2-6-this-is-a-title.md”，在文章中定义的文类为[测试, new]，那么最终这篇文章的路径将会是“_site/测试/new/2014/02/06/this-is-a-title.html”，也就是说如果category为中文名称的话，中文将会出现在url中。然后就会根据中文去jekyll的action中索引，然后导致错误。</p>

<p>避开方法就是去掉根据permlinks中的categories，因为一般情况下根据时间来生成文件夹就已经够了，在_config.yml中新增一行：</p>

<pre><code>permalink: /:year/:month/:day/:title
</code></pre>

<p>规则可以自己定，具体参照<a rel=""nofollow"" href=""http://jekyllrb.com/docs/permalinks/"">jekyll的Permlinks配置介绍页面</a>，别出现categories就行了</p>

<h2>使用文章标签索引文章</h2>

<p>现在很多博客都支持给文章添加标签，表示这篇文章具体是哪几方面的技术。jekyll也是支持标签的，而且不需要额外的插件。使用方法和categories类似</p>

<h3>给文章添加标签</h3>

<p>文章中的标签配置使用tags来定义，内容为一个数组，放在文章的头中，如本文的标签定义：</p>

<pre><code>---
layout: MyTemplate
title: 使用Jekyll在Github上搭建个人博客（文章分类索引）
tags: [github, jekyll]
---
</code></pre>

<h3>输出所有标签</h3>

<p>一般情况下，标签与文章为很复杂的多对多关系，所以如果生成所有标签及含有该标签的所有文章，html将会非常庞大，所以一般只是生成所有的标签，然后通过点击标签到达该标签的索引页面，页面中仅显示含有该标签的文章。</p>

<p>输出所有标签，可以通过liquid的for标签遍历site.tags来实现：</p>

<pre><code class=""lang-html"">{% for tag in site.tags %}
    &lt;a href=""/show_by_tag.html?tag={{ tag[0] }}""&gt; {{ tag[0] }}&lt;/a&gt;
{% endfor %}
</code></pre>

<p>tag[0]是标签的名称</p>

<h3>输出含有某标签的所有文章数</h3>

<p>实现思路和上面categories一样，先生成JSON字符串再通过javascript动态生成html，具体代码：</p>

<pre><code class=""lang-javascript"">var dataStr = '{ {% for tag in site.tags %}{% if tag[0] != site.tags.first[0] %},{% endif %}""{{ tag[0] }}"":[{% for post in tag[1] %}{% if post != tag[1].first %},{% endif %}{""url"":""{{post.url}}"", ""title"":""{{post.title}}"", ""date"":""{{post.date | date:""%d/%m/%Y""}}""}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get(""tag""),
    archieves = data[curTag];
</code></pre>

<p>这里还是一样，使用jQuery.query插件获取url中的参数，和上面的<code>&lt;a href=""/show_by_tag.html?tag={{ tag[0] }}""&gt; {{ tag[0] }}&lt;/a&gt;</code>相对应</p>

<p>标签没有字符集问题，放心使用吧</p>

<h2>总结</h2>

<p>文章的分类其实实现并不难，但是需要绕点小弯子。如果有更好的不需要使用插件的方法希望能告知我，感激不尽</p>

                ", 使用Jekyll在Github上搭建个人博客（文章分类索引）,1531978134,467,1,656,1,1,https://segmentfault.com/a/1190000000406017
331,1,0,7,"
                    
<p>系列文章传送门：</p>

<p><a rel=""nofollow"" href=""http://skyinlayer.com/blog/2014/01/25/jekyll-1/"">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p>这篇文章主要介绍博客内容的编写及本地测试，内容主要来自<a rel=""nofollow"" href=""http://jekyllrb.com/docs/home/"">Jekyll的文档</a>、<a rel=""nofollow"" href=""http://docs.shopify.com/themes/liquid-basics"">Liquid的文档</a></p>

<h2>##创建项目</h2>

<p>到想要创建项目的文件夹下（如d:/），运行命令：</p>

<pre><code class=""lang-shell"">jekyll new blog
</code></pre>

<p>这样就会创建一个新文件夹d:/blog，其结构如下：<br>
1. 文件夹_layouts：用于存放模板的文件夹，里面有两个模板，default.html和post.html<br>
2. 文件夹_posts：用于存放博客文章的文件夹，里面有一篇markdown格式的文章--2014-01-27-welcome-to-jekyll.markdown<br>
3. 文件夹css：存放博客所用css的文件夹<br>
4. .gitignore：可以删掉，后面会将项目添加到git项目，所以这个不需要了<br>
5. _coinfig.yml：jekyll的配置文件，里面可以定义相当多的配置参数，具体配置参数可以参照其<a rel=""nofollow"" href=""http://jekyllrb.com/docs/configuration/"">官网</a><br>
6. index.html：项目的首页</p>

<p>根据实际需要，可能还需要创建如下文件或文件夹：<br>
1. _includes:用于存放一些固定的HTML代码段，文件为.html格式，可以在模板中通过liquid标签引入，常用来在各个模板中复用如 导航条、标签栏、侧边栏 之类的在每个页面上都一样不变的内容，需要注意的是，这个代码段也可以是未被编译的，也就是说也可以使用liquid标签放在这些代码段中<br>
2. image和js等自定义文件夹：用来存放一些需要的资源文件，如图片或者javascript文件，可以任意命名<br>
3. CNAME文件：用来在github上做域名绑定的，将在后面介绍<br>
4. favicon.ico：网站的小图标<br>
5.<br>
....</p>

<p>创建完需要的文件夹之后，首先需要修改的就是jekyll的配置文件_config.yml，这个配置文件的内容相当多，详细见<a rel=""nofollow"" href=""http://jekyllrb.com/docs/configuration/"">官方文档</a>，如果没有太多的额外需求，只需要设定两个参数就行了，一个是编码的字符集，一个是项目的路径，我这里是这么设定的：</p>

<pre><code>baseurl: /
encoding: utf-8
</code></pre>

<p>这样一个博客项目就创建完成了</p>

<h2>##编写博文</h2>

<p>大致上jekyll生成html的流程，jekyll首先会读取如下内容进入内存中：<br>
1. _posts及文件夹下的所有文章，将其参数和文章内容组织保存在内存中，所有的文章的内容、参数都在site.posts对象（其他文件夹下的文章不会放入site.posts中）<br>
2. _layouts文件夹下的所有模板<br>
3. _includes文件夹下的所有需要被引入的内容</p>

<p>然后根据每一篇需要编译的文章选择的其参数定义的模板来创建一个模板，并将当前文章的内容、参数等进行扩展后放在page对象、content对象中，然后进行模板的编译，生成html文件，并按照一定规则放在_site文件夹下。也就是说在创建一篇文章时，其实所有文章的内容都已经被读取出来了，这也为文章相互之间的关联提供了可能</p>

<p>可以看一下_posts下的jekyll给的例子：</p>

<pre><code class=""lang-markdown"">---
layout: post
title:  ""Welcome to Jekyll!""
date:   2014-01-27 21:57:11
categories: jekyll update
---

You'll find this post in your `_posts` directory - edit this post and re-build (or run with the `-w` switch) to see your changes!
To add new posts, simply add a file in the `_posts` directory that follows the convention: YYYY-MM-DD-name-of-post.ext.

Jekyll also offers powerful support for code snippets:

{% highlight ruby %}
def print_hi(name)
  puts ""Hi, #{name}""
end
print_hi('Tom')
#=&gt; prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll's GitHub repo][jekyll-gh].

[jekyll-gh]: https://github.com/mojombo/jekyll
[jekyll]:    http://jekyllrb.com
</code></pre>

<p>可以看到在博文的最上方有被两个<code>---</code>包裹起来的一段，这里就定义了文章的一些参数，更多参数在<a rel=""nofollow"" href=""http://jekyllrb.com/docs/frontmatter/"">FrontMatter</a>和<a rel=""nofollow"" href=""http://jekyllrb.com/docs/variables/"">Variables</a>获取，简单的只需要关注几个就好：<br>
1. title：文章的标题<br>
2. date：文章的日期<br>
3. categories：定义了文章所属的目录，一个list，将会根据这个目录的list来创建目录并将文章html放在生成的目录下，文章分类时候用，这里就不使用了<br>
4. layout：文章所使用的模板名称，也就是_layouts中定义的模板的文件名去掉.html<br>
5. tags：例子中没有，定义了文章的标签，也是一个list，文章分类时候用，这里就不使用了</p>

<p>这里就写一个最简单的文章，只是用其中的两个参数：layout，title，如下：</p>

<pre><code>---
layout: mylayout
title: hello-jekyll
---

Hello jekyll!
</code></pre>

<p>将这个写完的文章保存为  “年-月-日-标题.markdown”的名字形式，因为如果不修改permlinks，jekyll会根据文章的标题来创建文件夹，如2014-01-27-hello会创建成/2014/01/27/hello.html。这里就保存成2014-01-27-hello.markdown</p>

<p>ps：文章的文件名不要使用中文，否则会出现bug，因为在url中会escape，而服务器查找却是按照escape后的字符串去查找<br>
，就会出现找不到文章的情况，使用英文代替就好，定义了title变量就无所谓文件名中标题的内容了</p>

<p>博客不能没有主页，所以我们修改index.html文件如下：</p>

<pre><code class=""lang-html"">---
layout: mylayout
title: Hello Jekyll!
---
&lt;ul class=""posts""&gt;
{% for post in site.posts %}
  &lt;li&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;raquo; &lt;a href=""{{ post.url }}""&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>

<p>还是使用我们刚才的模板，这回编译完成后生成的结果如下：</p>

<pre><code class=""lang-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8""&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello Jekyll!
        &lt;ul class=""posts""&gt;
          &lt;li&gt;&lt;span&gt;27 Jan 2014&lt;/span&gt; &amp;raquo; &lt;a href=""/2014/01/27/hello.html""&gt;hello-jekyll&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>由于index文件名中没有时间，所以时间直接被忽略了，而内容段则通过liquid的for标签进行了迭代，遍历了_posts下的所有文章，将其文章的时间、路径、标题组织成html文件，生成指向博文的连接</p>

<h2>##创建模板</h2>

<p>我们可以打开jekyll给的例子default.html看一看模板的结构:</p>

<pre><code class=""lang-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8""&gt;
        &lt;meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""&gt;
        &lt;title&gt;{{ page.title }}&lt;/title&gt;
        &lt;meta name=""viewport"" content=""width=device-width""&gt;

        &lt;!-- syntax highlighting CSS --&gt;
        &lt;link rel=""stylesheet"" href=""/css/syntax.css""&gt;

        &lt;!-- Custom CSS --&gt;
        &lt;link rel=""stylesheet"" href=""/css/main.css""&gt;

    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class=""site""&gt;
          &lt;div class=""header""&gt;
            &lt;h1 class=""title""&gt;&lt;a href=""/""&gt;{{ site.name }}&lt;/a&gt;&lt;/h1&gt;
            &lt;a class=""extra"" href=""/""&gt;home&lt;/a&gt;
          &lt;/div&gt;

          {{ content }}

          &lt;div class=""footer""&gt;
            &lt;div class=""contact""&gt;
              &lt;p&gt;
                Your Name&lt;br /&gt;
                What You Are&lt;br /&gt;
                you@example.com
              &lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=""contact""&gt;
              &lt;p&gt;
                &lt;a href=""https://github.com/yourusername""&gt;github.com/yourusername&lt;/a&gt;&lt;br /&gt;
                &lt;a href=""https://twitter.com/yourusername""&gt;twitter.com/yourusername&lt;/a&gt;&lt;br /&gt;
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>可以看到，模板和普通的html文件几乎是一样的。jekyll使用的是一个叫liquid的模板引擎创建html文件，这个模板引擎也有<a rel=""nofollow"" href=""http://docs.shopify.com/themes/liquid-basics"">详细的文档</a>，现在就只关注其中比较核心的部分，文章的标题和文章的内容</p>

<p>可以看到模板的有这么两句{{ page.title }}, {{ content }}，这两句就分别是文章标题和文章内容的占位符，如果有文章使用了这个模板，如过使用上面写的那篇hello的文章，标题就是hello-jekyll，content就是Hello jekyll!，这里定义一个自己的新模板，保存为mylayout.html</p>

<pre><code class=""lang-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8""&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
          {{ page.title }}
          {{ page.date }}
          {{ content }}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>第一行是标题，然后是博文时间（在文件名中定义），然后是博文内容<br>
这样一个简单的模板就创建好了</p>

<h2>##调试</h2>

<p>在博客文件夹下，在命令行中输入<code>jekyll build --trace</code>就可以将所有文章文件根据其模板进行编译，生成结果，放在根目录下的_site中，这里我们使用后，会出现如下结果：\blog\_site\2014\01\27文件夹下有一个hello.html，其内容为：</p>

<pre><code class=""lang-html"">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8""&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
          hello-jekyll
          2014-01-27 00:00:00 +0800
          &lt;p&gt;Hello jekyll!&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>可以看到，这就是编译完的博文文件，如我们设定的，第一行是标题，然后是文件名定义的时间，然后是博文内容，如果编译错误，将会在命令行中看到一个错误栈，可以方便调试，具体哪里出错了，如果不需要看错误栈，直接使用<code>jekyll build</code>就行了</p>

<p>如果想要在本地开启一个服务器查看效果，可以使用命令<code>jekyll serve</code>，这样会开启一个监听端口4000的服务器，浏览器中查看localhost:4000，则会进入index.html的内容中，点击文章的标题就可以跳转到具体的博文了</p>

                ", 使用Jekyll在Github上搭建个人博客（博客编写）,1531978135,525,1,633,1,1,https://segmentfault.com/a/1190000000406013
332,1,0,7,"
                    
<p><strong>知乎</strong>，这个社区我想SF很多人都熟知。但是个人觉得网页版的UI一直追不上客户端的UI，因此便萌生了通过Chrome Extension的方式来改造知乎现有的UI。</p>

<hr>
<p>目前计划分为两个阶段：</p>

<h1>1.基本界面改造</h1>

<p>通过JQuery修改CSS来改变视觉效果，从而改变现有的厚重感。利用扁平化的设计，简洁明了的展示功能选项。</p>

<p><em>目前只改造了导航栏，头像那边的分割线还有待考究改进。</em></p>

<h1>2.交互改进</h1>

<p>这个目前我还没着手改造。因为这几天生病，昨天下午突发奇想做这个项目。<br>
这个大家可以发散思维来改造。</p>

<hr>
<p><strong>目前项目仍处于基本阶段。而且因为本人发烧生病和本身能力有限，无法写出好看漂亮的代码...希望大家见谅了！</strong></p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbRl4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<hr>
<p><a rel=""nofollow"" href=""https://github.com/Lec2cn/zhihu_ext"">知乎界面改造计划项目地址-Github</a></p>

                ", 知乎界面改造计划 - 开源项目一起来努力！,1531978137,320,1,702,1,1,https://segmentfault.com/a/1190000000404365
333,1,0,7,"
                    
<p>由于历史原由，git一直是被黑成比较难用的版本控制器。其实近年来git的用户界面已经被简化的非常简单了，配上github、bitbucket等<a rel=""nofollow"" href=""https://git.wiki.kernel.org/index.php/GitHosting"">hosting</a>,已接近完美。<br>
git其实挺简单的，本文用了约150行golang代码实现了git checkout功能，阅读代码之前，您应该读过<a rel=""nofollow"" href=""http://git-scm.com/book/en/Git-Internals"">《Git Pro》中的git内部原理</a>一节。</p>

<h1>1. 数据定义：</h1>

<pre><code class=""lang-go"">type blob struct {
    sha1     string
    filename string
}
type tree struct {
    b     []*blob
    name  string
    child []*tree
}
type commit struct {
    sha1   string
    tree   *tree
    parent *commit
}
</code></pre>

<p>其中blob定义一个文件 ,sha1是文件的sha1值,filename是不包括路径的文件名。<br>
tree定义相当于目录，b是目录下的文件，name是当前目录名，不包括父路径，child是目录下的目录。<br>
commit是一次提交，sha1是提交的sha1值，tree指向一要树形的根节点，沿此根结点可以检出所有的文件。<br>
对照下面这副图就比较容易理解:<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQ1d"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h1>2. 工具函数</h1>

<pre><code class=""lang-go"">func readSha1FileReader(sha1 string) (reader io.Reader, err error) {

    f, err := os.Open(getSha1FilePath(sha1))
    if err != nil{
        return
    }
    return zlib.NewReader(f)
}

func readSha1FileContent(sha1 string) (content []byte, err error) {

    if reader, err := readSha1FileReader(sha1);err == nil{
        buf := new(bytes.Buffer)
        buf.ReadFrom(reader)
        content = buf.Bytes()
    }
    return
}

func getSha1FileContentBody(content []byte) []byte {
    i := bytes.IndexByte(content, 0)
    return content[i+1:]
}

func getSha1FilePath(sha1 string) string {
    return "".git/objects/"" + sha1[0:2] + ""/"" + sha1[2:]
}
</code></pre>

<ul>
<li>getSha1FilePath           根据sha1值取得对应的object路径。</li>
<li>readSha1FileReader        根据sha1值读取object内容，注意原始内容是经过压缩的，调用zlib是为了对其解压。</li>
<li>readSha1FileContent       对readSha1FileReader的一层封装，返回的是byte数组</li>
<li>getSha1FileContentBody    返回object的内容的body部分，header的内容我们直接忽略了</li>
</ul>
<blockquote>
  <p>上面提到的object是位于路径.git/objects/路径下的文件</p>
</blockquote>

<h1>3. 构建树</h1>

<pre><code class=""lang-go"">func BuildTree(sha1 string) *tree {
    all, err := readSha1FileContent(sha1)
    if err != nil {
        log.Fatal(""BuildTree error:"", err)
        return nil
    }

    content := getSha1FileContentBody(all)
    start := 0
    tree := tree{}
    for i := 0; i &lt; len(content); {
        if content[i] == 0 {
            line := content[start : i+21]
            _type := line[:6]
            id := line[i-start+1:]
            obj_sha1 := fmt.Sprintf(""%x"", id)
            switch string(_type[0:3]) {
            //BLOB
            case ""100"":
                name := string(line[7 : i-start])
                b := blob{sha1: obj_sha1, filename: name}
                tree.b = append(tree.b, &amp;b)
                break
            //TREE
            case ""400"":
                name := string(line[6 : i-start])
                child := BuildTree(obj_sha1)
                child.name = name
                tree.child = append(tree.child, child)
                break
            }
            i += 21
            start = i
        } else {
            i++
        }
    }
    return &amp;tree
}
</code></pre>

<p>以上便是检出git的库的核心函数，其入参是一次Commit的Sha1值。要理解这个函数，需要知道<a rel=""nofollow"" href=""http://icattlecoder.qiniudn.com/Git_Data_Formats.txt.zip"">tree文件的格式定义</a>（《Git Pro》一书中没有）：</p>

<pre><code>&lt;TREE&gt;
    :   _deflate_( &lt;OBJECT_HEADER&gt; &lt;TREE_CONTENTS&gt; )
    |   &lt;COMPACT_OBJECT_HEADER&gt; _deflate_( &lt;TREE_CONTENTS&gt; )
    ;

&lt;TREE_CONTENTS&gt;
    :   &lt;TREE_ENTRIES&gt;
    ;

&lt;TREE_ENTRIES&gt;
    # Tree entries are sorted by the byte sequence that comprises
    # the entry name. However, for the purposes of the sort
    # comparison, entries for tree objects are compared as if the
    # entry name byte sequence has a trailing ASCII '/' (0x2f).
    :   ( &lt;TREE_ENTRY&gt; )*
    ;

&lt;TREE_ENTRY&gt;
    # The type of the object referenced MUST be appropriate for
    # the mode. Regular files and symbolic links reference a BLOB
    # and directories reference a TREE.
    :   &lt;OCTAL_MODE&gt; &lt;SP&gt; &lt;NAME&gt; &lt;NUL&gt; &lt;BINARY_OBJ_ID&gt;
    ;
</code></pre>

<p>通过<code>getSha1FileContentBody</code>函数即可取得<code>TREE_CONTENTS</code>,<code>TREE_CONTENTS</code>包括一个或多个<code>TREE_ENTRY</code>,<code>TREE_ENTRY</code>的格式如下：</p>

<pre><code>&lt;OCTAL_MODE&gt; &lt;SP&gt; &lt;NAME&gt; &lt;NUL&gt; &lt;BINARY_OBJ_ID&gt;
</code></pre>

<p><code>OCTAL_MODE</code>的前三个字节定义了object类型，<code>""100""</code>为Blob，<code>""400""</code>为Tree，如果是Tree对像，则需要递归调用。</p>

<h1>4. 检出文件</h1>

<p>BuildTree根据指定的Commit构建出所有文件形成的树型结构，有了它，就很容易检出文件。</p>

<pre><code>func (b *blob) checkout(prefix string) {
    if content, err := readSha1FileContent(b.sha1);err!=nil{
        log.Fatal(""blob checkout error:"", err)
    }else{
        body := getSha1FileContentBody(content)
        filename := prefix + ""/"" + b.filename
        log.Println(""WriteFile:"",filename)
        if err = ioutil.WriteFile(filename, body, 0644);err!=nil{
            log.Fatal(""blob checkout error:"", err)
        }
    }
}

func (t *tree) checkout(path string) {
    if _, err := os.Stat(path); os.IsNotExist(err) {
        log.Println(""Mkdir:"",path)
        if err := os.Mkdir(path, 0777); err != nil {
            log.Fatal(""mkdir error:"", err)
            return
        }
    }
    for _, v := range t.b {
        v.checkout(path)    //BLOB checkout
    }
    for _, v := range t.child {
        v.checkout(path + ""/"" + v.name)     //TREE checkout
    }
}

func (c *commit) CheckOut() {
    if pwd, err := os.Getwd();err==nil{
        c.tree.checkout(pwd)
    }else{
        log.Fatal(""commit checkout error:"", err)
    }
}
</code></pre>

<p>以上三个函数的调用顺序为<code>commit.CheckOUt</code>-&gt;<code>tree.checkout</code>-&gt;<code>blob.checkout</code>.<br>
如果有目录，<code>tree.checkout</code>会生成目录。<code>blob.checkout</code>则会生成文件。</p>

<h1>5. 示例</h1>

<p>完整的代码见<a rel=""nofollow"" href=""http://github.com/icattlecoder/gogit.git"">这里</a></p>

<h2>编译</h2>

<pre><code>~/tmp$ git clone git@github.com:icattlecoder/gogit.git
~/tmp$ cd gogit
~/tmp$ go build gogit.go
</code></pre>

<h2>检出示例库的代码</h2>

<pre><code>~/tmp$ git clone git@github.com:icattlecoder/jsfiddle.git
~/tmp$ cd jsfiddle
~/tmp$ rm -Rf ajaxupload/ formupload/ resumbleupload/ uptoken/
~/tmp$ mv ../gogit/gogit .
~/tmp$ ./gogit
~/tmp$ ls
ajaxupload     formupload   resumbleupload uptoken
</code></pre>

<p>在运行gogit之前，删除了本地文件，而运行gogit后，所有文件又恢复了，因此实现了<code>git checkout</code>功能。</p>

<p><strong>注意：本文的git checkout不能处理压缩过的git库</strong></p>

                ", 150行Go代码实现git checkout功能,1531978138,238,1,701,1,1,https://segmentfault.com/a/1190000000403067
334,1,0,7,"
                    
<p>github一直都是在上面拿资源。感觉有点愧对大众。是不是应该奉献自己的力量给github来推动开源的发展呢。<br>
在两个月前第一次在github新建项目，并且push了一套比赛的源码。但。。。今天竟然忘了怎么用git了。又复习了一次。所以这次打算在这里作个笔记。给自己做个的或是给git新手做的也好吧。为互联网贡献一点力量。</p>

<p>一：<br>
    安装git和配置就不说了。</p>

<p>二：<br>
    进入到等下要push的代码的目录文件夹，打开bash<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbN91"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<pre><code>进入到等下要push的代码的目录文件夹，打开bash
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbN97"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<pre><code>初始化
</code></pre>

<pre><code class=""lang-git"">    git init
</code></pre>

<pre><code>初始化后在本地代码库会自动创建一个.git隐藏文件，这个就是本地代码库
</code></pre>

<p>三：<br>
    加载文件</p>

<pre><code class=""lang-git"">    git add .

</code></pre>

<p>. 是把文件夹里面的所有文件都加载进来</p>

<p>还可以单个加载</p>

<pre><code class=""lang-git"">    git add index.html,test.html
</code></pre>

<p>四：</p>

<p>提交文件，创建时间点</p>

<pre><code class=""lang-git"">    git commit -m ""init commit""
</code></pre>

<p>-m ""这里的文件是注释""</p>

<p>创建之后可以随时回到这个时间点，可以看到有4个文件被修改了，47个插入，51个删除<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbOam"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>可以随时用</p>

<pre><code class=""lang-git"">git status
</code></pre>

<p>查看git的状态</p>

<p>五：<br>
推送代码</p>

<p>第一次推送的时候要添加远程的代码库到配置</p>

<pre><code class=""lang-git"">git remote add origin master https://github.com/zhong635725959/droplook.git
</code></pre>

<p>origin可变，随自己喜欢</p>

<p>推送代码：</p>

<pre><code class=""lang-git"">git push origin master
</code></pre>

<p>然后会要求输入github的帐号和密码（不可见的）<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbOaz"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
OK,成功</p>

<p>问题：<br>
    在这成功之前遇到了一个问题。update were rejected because the tip of your current branch is behind ....</p>

<p>原因是远程的的代码库比我本地的代码库要新。所以需要在远程代码库pull一次下来。再修改代码。再push。成功。解决了。<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbOaA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>—————————————华丽的分割线——————————————————————</p>

<p>这是我第一次写技术博客。不知道这种算不算是技术博客呢。欢迎吐槽哈。应该有好多问题的。</p>

<p>之前在csdn看到一牛人的一个提升自我能力的一个建议就是写技术博客。</p>

<p>已经想动手久了。但一直没动。这次终于动手了。希望可以坚持下去。加油</p>

<p>—————————————华丽的分割线——————————————————————</p>

                ", git之github使用（一）：push代码到github,1531978139,571,1,410,1,1,https://segmentfault.com/a/1190000000392120
335,1,0,7,"
                    
<h3>SegmentFault 团队的价值观以及生产力工具</h3>
<h4>公司文化，团队价值观</h4>
<ul>
<li><p>相信技术能让世界变的更美好！</p></li>
<li><p>在这里，让你发现科技、技术、编程的美</p></li>
<li><p>诚实守信、热爱、开放、透明、有爱、有活力、有干劲</p></li>
<li><p>要青春有活力，做事的方式要体现我们年轻人的节奏：我们团队非常的年轻，创始人团队是有一个疯狂滴90后以及两个85后骚年！我们目前的10人团队平均年龄才只有21-23岁！</p></li>
</ul>
<h4>工作方式</h4>
<p>我们特别注重团队成员的长期发展，并认为这是公司长期发展的根基，我们也愿意花大量的精力用在团队建设上面，比如 1 对 1 的Mentor</p>
<p>指导、定期邀请行业人士来公司分享、前往各大技术公司、技术盛会交流学习的机会；同时相比工作经验，我们也更加注重强调学习能力和潜力，让你有全方位了解产品的运作，跟随公司的业务一起成长，对于编程的同学不仅仅是要做好编程，还要去了解产品、运营相关的事情，同理市场运营也要多思考产品以及技术实现相关，自学一些编程知识。</p>
<ul>
<li><p>公司软硬件：公司提供舒适的办公环境，为员工提供喜爱的机械键盘等设备；定期的内部学习分享，Team Buliding</p></li>
<li><p>移动办公：任务驱动型，结果导向，不必每天坐班</p></li>
<li><p>无障碍沟通：如果你讨厌传统办公室里的屏障，这里很适合你</p></li>
<li><p>自由的时间：每个人都有时间静下来思考，你并不是在盲目的工作</p></li>
<li><p>志同道合的人：每一个SF的成员对我们在做和将要做的事情都充满激情</p></li>
</ul>
<p>《<a href=""http://blog.segmentfault.com/sunny/1190000000324815"" rel=""nofollow noreferrer"">SegmentFault 团队建设 - 国庆前夕厦门7日游</a>》</p>
<h5>我们的生产力工具</h5>
<ul>
<li><p><strong>GitHub</strong>：我们用Git来控制代码版本，我们公司所有人员包括运营人员都必须有一定的编程基础，熟练使用GitHub、MarkDown编辑，反馈问题等等</p></li>
<li><p><strong>微信、QQ</strong>：我们使用微信以及QQ群保证员工远程协作之间无缝的沟通，在室内协作要求面对面沟通。</p></li>
<li><p><strong>Google企业版</strong>：我们使用了Google企业版，最好用，没有之一！</p></li>
<li><p><strong>Gmail</strong>：这个世界上最好用邮件系统了，没有之一！他的功能强大之处，足够我再重新写一篇文章。</p></li>
<li><p><strong>Google Dirve</strong>：我们用Google Dirve进行实时在线的协作编辑文档，沉淀团队知识库系统。</p></li>
<li><p><strong>Google 日历</strong>：我们用Google 日历来进行安排自己的重要的活动出行事宜。</p></li>
<li><p><strong>Google Keep</strong>：我们用Google Keep来及时记录与分享自己的灵感，最简单好用！</p></li>
<li><p><strong>Dropbox、百度个人云</strong>：我们用Dropbox来共享一些大的文件</p></li>
<li><p><strong>BaseCamp</strong>：用来管理和讨论一些新的功能，沉淀一些文档，不过最近靠谱切换一些新的服务使用</p></li>
<li><p><strong>谷哥以及百度分析</strong>：我们用这两者进行网站的比对数据分析，当然我们也有自己后台数据库的分享做对比。</p></li>
<li><p><strong>百度相册</strong>：我们用手机拍摄活动照片等，随时随时地通过百度相册上传，速度快支持高清是最重要的。地址：<a href=""http://xiangce.baidu.com/sunshineg"" rel=""nofollow noreferrer"">http://xiangce.baidu.com/sunshineg</a></p></li>
</ul>
<p>我们希望能用最好的工具以及产品，去开发出面向开发者的好的产品，我们一直坚信只有用了更好的产品才能开发出更好的产品来！</p>
<h3><a href=""http://blog.segmentfault.com/sunny/1190000000382187"" rel=""nofollow noreferrer"">一个创业企业需要什么样子的员工？</a></h3>

                ", SegmentFault 团队的价值观以及生产力工具,1531978140,334,1,936,1,1,https://segmentfault.com/a/1190000000391120
336,1,0,7,"
                    
<h2>准备工作：</h2>

<ol>
<li>一个远程服务器来托管你的站点。</li>
<li>通过SSH访问远程服务器。</li>
<li>在远程服务器上安装Git（通过指令git --version来检查是否安装）。</li>
<li>如果需要，请<a href=""https://help.github.com/articles/generating-ssh-keys"" rel=""nofollow noreferrer"">生成一个SSH key</a>。</li>
</ol>
<h2>在服务器端</h2>

<p>设置无密码的SSH访问</p>

<p>首先，你需要通过SSH连接到你的服务器，如果有提示的话请输入密码。</p>

<pre><code>ssh user@hostname
</code></pre>

<p>如果在你的用户的主目录中没有<code>~/.ssh</code>目录，请创建一个：<code>mkdir ~/.ssh</code></p>

<p>接下来，你需要复制你的公共SSH key（请看<a href=""https://help.github.com/articles/generating-ssh-keys"" rel=""nofollow noreferrer"">生成一个SSH key</a>）到你的服务器。这样你就可以通过SSH连接，并且不需要每次都输入密码。</p>

<p>在你的本地 - 假设你的公共key可以在<code>~/.ssh/id_rsa.pub</code>找到 - 使用正确的用户和主机名称输入下面的指令。它将会把你的公共秘钥（key）添加到远程服务器的<code>authorized_keys</code>文件。</p>

<pre><code>ssh user@hostname 'cat &gt;&gt; ~/.ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub
</code></pre>

<p>如果你关闭连接，并且尝试建立SSH访问，你应该不再会被提示输入密码。</p>

<h2>创建远程目录</h2>

<p>你需要为每个域名建立2个目录。一个作为Git的仓库，另一个包含其他信息。</p>

<p>举个栗子，如果你的域名是<code>example.com</code>，并且你想要建立一个环境，那么你需要在你的服务器上建立这些目录：</p>

<pre><code>mkdir ~/example.com ~/example.git
mkdir ~/staging.example.com ~/staging.example.git
</code></pre>

<p>初始化空的Git仓库</p>

<p>在服务器上创建空的Git仓库，也就是把本地文件（资源）传送到服务器储存的地方。但是你不想要的文件在这里,这就是为什么这是一个空的仓库。</p>

<pre><code>cd ~/example.git
git init --bare
</code></pre>

<blockquote>
  <p>如果你想的话，你可以重复此步骤。</p>
</blockquote>

<h2>写一个发送-接收钩子</h2>

<p>一个发送-接收钩子可以让你在Git仓库接收到commits后运行指令。这样，你可以改变Git的工作目录，从<code>example.git</code> 到 <code>example.com</code>，并且检查在<code>example.com</code>目录下的副本。</p>

<p>工作目录的位置可以使用<code>GIT_WORK_TRE</code>E在per-command的基础上设置，<a rel=""nofollow"" href=""http://git-scm.com/2010/04/11/environment.html"">Git的环境变量</a>中其中一个或者<code>work-tree</code>选项。</p>

<pre><code>cat &gt; hooks/post-receive
#!/bin/sh
WEB_DIR=/path/to/example.com

# remove any untracked files and directories
git --work-tree=${WEB_DIR} clean -fd

# force checkout of the latest deploy
git --work-tree=${WEB_DIR} checkout --force
</code></pre>

<blockquote>
  <p>确保hook上的文件权限正确。</p>
</blockquote>

<pre><code>chmod +x hooks/post-receive
</code></pre>

<p>如果你需要使一些文件不被Git清理（比如<code>.htpasswd</code>文件），你可以使用--exclude选项。这需要在你的服务器上安装Git 1.7.3或者以上版本。</p>

<pre><code>git --work-tree=${WEB_DIR} clean -fd --exclude=&lt;pattern&gt;
</code></pre>

<blockquote>
  <p>如果你想的话，可以重复此步骤。</p>
</blockquote>

<h2>在本地机器上操作</h2>

<p>现在，服务器配置已经完成，你想要为静态站点部署build assets（不是源码）。</p>

<h2>构建和部署任务</h2>

<p>我正在使用生成文件（Makefile），但是你可以使用任何你擅长的。下面是我想要自动化完成的基本工作流程。</p>

<ol>
<li>
<p>建立静态站点的生产版本。</p>

<p><code>make build</code></p>
</li>
<li>
<p>初始化一个新的Git repo在构建目录中。 我不想尝试合并到之前部署的文件，尤其是对于分段域(staging domain)。</p>

<p><code>git init ./build</code></p>
</li>
<li><p>远程部署<br><code>cd ./build
git remote add origin ssh://user@hostname/~/example.git</code></p></li>
<li><p>commit repo中的所有内容<br><code>cd ./build
git add -A
git commit -m ""Release""</code></p></li>
<li><p>强制转换远程主分支, 如果丢失的话，则创建它。<br><code>cd ./build
git push -f origin +master:refs/heads/master</code></p></li>
<li><p>在源repo中标记出检查commit的SHA，于是我可以看到哪个是最新部署。<br><code>git tag -f production</code></p></li>
</ol>
<p>使用一个生成文件:</p>

<pre><code>BUILD_DIR := ./build
STAGING_REPO = ssh://user@hostname/~/staging.example.git
PROD_REPO = ssh://user@hostname/~/example.git

install:
    npm install

# Deploy tasks

staging: build git-staging deploy
    @ git tag -f staging
    @ echo ""Staging deploy complete""

prod: build git-prod deploy
    @ git tag -f production
    @ echo ""Production deploy complete""

# Build tasks

build: clean
    # whatever your build step is

# Sub-tasks

clean:
    @ rm -rf $(BUILD_DIR)

git-prod:
    @ cd $(BUILD_DIR) &amp;&amp; \
    git init &amp;&amp; \
    git remote add origin $(PROD_REPO)

git-staging:
    @ cd $(BUILD_DIR) &amp;&amp; \
    git init &amp;&amp; \
    git remote add origin $(STAGING_REPO)

deploy:
    @ cd $(BUILD_DIR) &amp;&amp; \
    git add -A &amp;&amp; \
    git commit -m ""Release"" &amp;&amp; \
    git push -f origin +master:refs/heads/master

.PHONY: install build clean deploy git-prod git-staging prod staging
</code></pre>

<p>分阶段部署:</p>

<pre><code>make staging
</code></pre>

<p>部署生产:</p>

<pre><code>make prod
</code></pre>

<p>使用Make，，因为<code>cd</code>命令在子流程中。但是你需要确保后来的命令在同一行中。举个栗子：如果没有在命令中加入<code>&amp;&amp;</code> 或 <code>;</code>，那么<code>deploy</code>任务会强制推送到你源代码的远程主分支。</p>

<p>我把我的站点源码传到了BitBucket一个私人的仓库。BitBucket其中一个很不错的地方在于可让你选择防止误删除或者重写分支。</p>

<p>本文翻译自<a rel=""nofollow"" href=""http://nicolasgallagher.com/simple-git-deployment-strategy-for-static-sites/"">《A simple Git deployment strategy for static sites》</a></p>

                ", 通过Git简易的部署静态站点,1531978141,543,1,415,1,1,https://segmentfault.com/a/1190000000385705
337,1,0,7,"
                    <p><a rel=""nofollow"" href=""http://gitcafe.com"">GitCafe</a>是一个基于代码托管服务打造的技术协作与分享平台，最近刚刚获得景林资产300万人民币天使轮投资。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJOD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gitcafe""></span></p>

<p>Git是目前世界上最流行最优秀的项目版本控制系统之一，Cafe的意思为咖啡馆，象征着程序员文化。GitCafe是一个基于代码托管服务打造的技术协作与分享平台，程序开发爱好者们可以通过使用代码版本控制系统git来将他们所写的开源或专有项目的代码托管在GitCafe上，与其他程序员针对这些项目在线协作开发。</p>

<p>GitCafe界面十分简洁清爽，左右分栏的设计，使得浏览仓库代码十分便利。提供工单、wiki和页面服等功能。支持在线编辑功能，代码的修改、提交和合并请求，都可以在浏览器中完成。</p>

<p>GitCafe的公有仓库免费，私有仓库需付费。付费功能使用极特币(gitcoin)，是一个很有趣的设计。通过gitcoin，用户在按需付费的同时，很容易预估每月的开销。遇到喜欢的开源项目，还可以使用gitcoin捐赠开发者。</p>

<p>GitCafe项目创立的目标是为了促进国内IT行业的积极及良性地发展，一方面能够让在校学生以及开源爱好者能够接触到尽可能多优秀好玩的软件项目，另一方面可以让使用、开发开源技术的企业获得一个强有力的企业级技术推广平台。最后，GitCafe还会与国际的知名开源项目机构与企业合作，为国内引进优秀的开源项目参与机会。</p>

<p>目前，GitCafe上托管了大量开源项目，也有不少付费用户。一些充满创意的用户开始在GitCafe上<a rel=""nofollow"" href=""https://gitcafe.com/Superwyh/OutOfMemory"">连载小说</a>，将GitCafe当成了<a rel=""nofollow"" href=""https://gitcafe.com/shell909090/five"">五子棋对战平台</a>。</p>

<p><a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a>采访了GitCafe的创始人Thomas Yao（真名姚欣宇，网络ID <a rel=""nofollow"" href=""http://www.ghostunix.org/"">ghosTM55</a>），带大家走进GitCafe的幕后。</p>

<h2>基于Rails和MongoDB打造</h2>

<p>GitCafe基于<a rel=""nofollow"" href=""http://rubyonrails.org"">Ruby on Rails</a>和<a rel=""nofollow"" href=""http://www.mongodb.org"">MongoDB</a>打造。</p>

<p>Rails是非常流行的开源web框架，推崇DRY（不要重复自己）和CoC（约定优于配置）的理念，针对开发者的乐趣和可持续的开发效率作了优化。Rails开发已经形成非常成熟的生态系统，基于Rails开发，可以整合大量开源模块（<a rel=""nofollow"" href=""http://rubygems.org"">gems</a>），将精力集中在核心业务逻辑的开发上，大大提升了开发效率。GitCafe高速的开发节奏，部分归功于Rails开发的高效。</p>

<p>MongoDB是一个面向文件的开源数据库，也是目前最著名的NoSQL数据库。和传统的基于表的关系型数据库不同，MongoDB使用BSON结构。BSON是一个类似JSON的文件格式，其无模式的特性，使得数据和应用的集成更容易。MongoDB也支持二进制文件的存储。Git代码仓库里有大量的源代码文件，还有一些二进制文件，使用MongoDB存储十分合适。</p>

<p>GitCafe非常重视测试，良好的测试可以保证代码代码质量，提升代码的可维护性。GitCafe测试框架采用了<a rel=""nofollow"" href=""http://rspec.info"">RSpec</a>. 这是一款BDD(行为驱动开发）的测试框架，扩展了Ruby的<code>Test::Unit</code>中提供的方法。得益于Ruby灵活的语法和强大的元编程能力，RSpec的测试使用Ruby的内部DSL编写，非常接近英语，例如：</p>

<pre><code class=""lang-ruby"">describe GitCafe do
  it ""is cool"" do
    GitCafe.cool?.should be_true
  end
end
</code></pre>

<h2>GitCafe团队</h2>

<p>GitCafe的团队成员是一群充满活力的geek，大部分是Rubist，使用Mac OS X/Linux和Sublime Text/Vim。（GitCafe所用的<a rel=""nofollow"" href=""https://gitcafe.com/ghosTM55/sublime3-config"">Sublime配置文件也放在GitCafe上</a>，各位sublimer可以去围观哦～</p>

<p>创业过程中，GitCafe团队经常会一起打游戏和做头脑风暴，大家每次交流都能有非常有意思的笑点，这有助于团队的团结、促进大家互相了解。GitCafe有大量的游戏设备，还购买了60寸IPS屏电视，这样一起打游戏也不会因为屏幕小而挤成一团。GitCafe团队经常一起打游戏，并为此写了程序统计汇总各种竞技游戏的比分和积分。GitCafe还出品了一款基于Leap Motion手势操控的网页乒乓游戏<a rel=""nofollow"" href=""https://gitcafe.com/ghosTM55/LMPP"">Leap Motion Ping Pong</a>，使用手掌在Leap Motion上操作左右两个球拍的高低度，简单而有趣。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJOO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""game""></span></p>

<p>GitCafe的创始人Thomas Yao对计算机技术有着狂热的热爱与追求，爱好书法，带领过自己班级拿到高中校篮球赛冠军。观察与思考是大脑始终执行着的守护进程。19 岁开始接手管理 SHLUG 至今。</p>

<p>LUG，全称Linux User Group，即Linux用户组，全世界主流的城市里，都会有一个LUG。SHLUG于1997年7月成立于上海，是中国最早的LUG。Thomas19岁接手SHLUG的组织管理工作至今，其出色的组织能力，得到了大家一致的认可。因此，2011年开始创业的时候，Thomas就希望做出一个能够帮助到国内热衷于开源事业的技术团队以及企业的服务平台，这个平台就是现在的GitCafe。当时冯大辉和Thomas说，在国内最难伺候的用户是程序员群体，这个群体刁蛮的人最多，也相对比较聪明，要做好这类人的服务，面向这个群体创业是非常困难的，他自己不是很看好。在刚开始做GitCafe的时候，和Thomas相熟的投资人也经常问知道不知道这个市场有多大，Thomas实话实说不知道，于是就会被建议“Thomas我认为你的能力完全可以做面向用户群体更广以及更大的东西”。但是Thomas还是坚持“在Hard模式的国家尝试一下Hard模式的创业”，背后的原因就是希望能促进国内IT行业和IT教育的良性发展，在国内推广开源的理念。</p>

<h2>创业与开源</h2>

<p>创业和组织开源社区有很多不同的地方，但也有相通之处。Thomas如是说：</p>

<blockquote>
  <p>开源社区中，我的身份并不是发薪水的老板，只是志愿者负责管理好社区，在一些模棱两可的问题上，需要说服社区自己为何做出这样的决策，此外需要保证技术社区的纯粹，尽可能少地与钱产生关系。</p>
</blockquote>

<blockquote>
  <p>经营企业与经营社区很大的不同的两点在于你需要站在利益的角度让团队中的每个人都尽可能满意，此外与技术社区不同，公司需要有盈利方向与目标，要做好产品，并且能够卖出去。</p>
</blockquote>

<blockquote>
  <p>相通的地方就是大家都是理解黑客文化的工程师，热爱自己的事业和在玩的东西，我努力将自己的团队打造成一个有工程师文化的同时也注重其他各方向积累的公司。</p>
</blockquote>

<h2>创业之路</h2>

<p>GitCafe刚起步时做的很辛苦，不断遇到挫折，最艰难的时刻甚至要借钱发工资。“团队的磨合以及技术上的突破是创业过程中遇到的两大难题。”Thomas说。团队的磨合花了很多时间，GitCafe对人的要求非常严格，只招既有能力又有想法的人，而团队的管理却非常松散，不规定上下班时间，不规定开发Deadline，看每个人自己的表现。经过这样的方式过滤的人，都是非常有激情和自我推动力的工程师。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJOV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""office""></span></p>

<p>GitCafe有一个充满激情的稳定团队，现在又拿到了景林资产300万人民币天使轮投资,可以预计它将有更好更快的发展。Thomas说：“我们下一步就是将GitCafe与一些现有的云服务进行整合，打造完善的产品生态链。”结合了云服务的GitCafe，能为开发者提供一站式的服务。我们拭目以待。</p>

<p>SegmentFault也希望，以后能涌现更多的类似GitCafe的创业公司，服务开发者，一起打造属于开发者的时代！</p>

                ", 代码协作平台GitCafe获景林资产300万人民币天使轮投资,1531978143,102,1,770,1,1,https://segmentfault.com/a/1190000000375396
338,1,0,7,"
                    <p>12月30日 2013年，作者 Alex MacCaw, 翻译：myownghost</p>

<p><em>编者注：下面这篇文章从面试官的角度介绍到面试时可能会问到的一些问题。</em></p>

<p>我在Twitter和Stripe的一部分工作内容是面试前端工程师。其实关于面试你可能很有自己的一套，这里我想跟你们分享一下我常用的方法。</p>

<p>不过我想先给你们一个忠告，招聘是一件非常艰巨的任务，在45分钟内指出一名侯选人是否合适是你需要完成的任务。不过面试的最大问题是每个人都会想着去雇佣他们自己，任何通过我面试的人想法大都跟我差不多（注：因为你总会问你自己关心和知道的问题），这其实不是一件好事。因此我之前的决定都有很大碰运气的成分。不过，这也是一个良好的开端。</p>

<p>最理想的情况下是侯选人有一个全面的Github“简历”，这样我们可以同时通过他们的开源项目了解他们。我经常会浏览他们的代码然后针对一些特定的代码设计问一些问题。如果侯选人有非常好的开源项目记录，接下来的面试会直接去检验他们的团队协作精神。否则，我不得不去问他们一些代码方面的问题了。</p>

<p>我的面试非常有实践性，全部是写代码。没有抽象和理论上的东西（注：作者是个行业派），其他的面试官很可能会问这些问题，但是我认为他们前端编程的能力是值得商榷的。我问的问题大多看上去非常简单，但是每组问题都能让我考查侯选人某一方面JavaScript的知识。</p>

<h3>第一部分：Object Prototypes (对象原型)</h3>

<p>刚开始很简单。我会让侯选人去定义一个方法，传入一个string类型的参数，然后将string的每个字符间加个空格返回，例如：</p>

<pre><code>spacify('hello world') // =&gt; 'h e l l o  w o r l d'    
</code></pre>

<p>尽管这个问题似乎非常简单，其实这是一个很好的开始，尤其是对于那些未经过电话面试的侯选人——他们很多人声称精通JavaScript，但通常连一个简单的方法都不会写。</p>

<p>下面是正确答案，有时侯选人可能会用一个循环，这也是一种可接受的答案。</p>

<pre><code>function spacify(str) {
  return str.split('').join(' ');
}
</code></pre>

<p>接下来，我会问侯选人，如何把这个方法放入String对象上面，例如：</p>

<pre><code>'hello world'.spacify();
</code></pre>

<p>问这个问题可以让我考察侯选人是否对function prototypes(方法原型)有一个基本的理解。这个问题会经常引起一些有意思的讨论：直接在对象的原型（prototypes）上添加方法是否安全，尤其是在Object对象上。最后的答案可能会像这样：</p>

<pre><code>String.prototype.spacify = function(){
  return this.split('').join(' ');
};
</code></pre>

<p>到这儿，我通常会让侯选人解释一下函数声明和函数表达式的区别。</p>

<h3>第二部分：参数 arguments</h3>

<p>下一步我会问一些简单的问题去考察侯选人是否理解参数（arguments）对象。我会让他们定义一个未定义的log方法作为开始。</p>

<pre><code>log('hello world')
</code></pre>

<p>我会让侯选人去定义log，然后它可以代理console.log的方法。正确的答案是下面几行代码，其实更好的侯选人会直接使用apply.</p>

<pre><code>function log(msg)　{
  console.log(msg);
}
</code></pre>

<p>他们一旦写好了，我就会说我要改变我调用log的方式，传入多个参数。我会强调我传入参数的个数是不定的，可不止两个。这里我举了一个传两个参数的例子。</p>

<pre><code>log('hello', 'world');
</code></pre>

<p>希望你的侯选人可以直接使用apply。有时人他们可能会把apply和call搞混了，不过你可以提醒他们让他们微调一下。传入console的上下文也非常重要。</p>

<pre><code>function log(){
  console.log.apply(console, arguments);
};
</code></pre>

<p>接下来我会让侯选人给每一个log消息添加一个""(app)""的前辍，比如：</p>

<pre><code>'(app) hello world'
</code></pre>

<p>现在可能有点麻烦了。好的侯选人知道arugments是一个伪数组，然后会将他转化成为标准数组。通常方法是使用Array.prototype.slice，像这样：</p>

<pre><code>function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift('(app)');

  console.log.apply(console, args);
};
</code></pre>

<h3>第三部分：上下文</h3>

<p>下一组问题是考察侯选人对上下文和this的理解。我先定义了下面一个例子。注意count属性不是只读取当前下下文的。</p>

<pre><code>var User = {
  count: 1,

  getCount: function() {
    return this.count;
  }
};
</code></pre>

<p>我又写了下面几行，然后问侯选人log输出的会是什么。</p>

<pre><code>console.log(User.getCount());

var func = User.getCount;
console.log(func());
</code></pre>

<p>这种情况下，正确的答案是1和undefined。你会很吃惊，因为有很多人被这种最基础的上下文问题绊倒。func是在winodw的上下文中被执行的，所以会访问不到count属性。我向侯选人解释了这点，然后问他们怎么样保证User总是能访问到func的上下文，即返回正即的值：1</p>

<p>正确的答案是使用Function.prototype.bind，例如：</p>

<pre><code>var func = User.getCount.bind(User);
console.log(func());
</code></pre>

<p>接下来我通常会说这个方法对老版本的浏览器不起作用，然后让侯选人去解决这个问题。很多弱一些的侯选人在这个问题上犯难了，但是对于你来说雇佣一个理解apply和call的侯选人非常重要。</p>

<pre><code>Function.prototype.bind = Function.prototype.bind || function(context){
  var self = this;

  return function(){
    return self.apply(context, arguments);
  };
}
</code></pre>

<h3>第四部分：弹出窗口（Overlay library）</h3>

<p>面试的最后一部分，我会让侯选人做一些实践，通过做一个‘弹出窗口’的库。我发现这个非常有用，它可以全面地展示一名前端工程师的技能：HTML,CSS和JavaScript。如果侯选人通过了前面的面试，我会马上让他们回答这个问题。</p>

<p>实施方案是由侯选人自己决定的，但是我也希望他们能通过以下几点来实现：</p>

<p>在遮罩中最好使用position中的fixed代替absolute属性，这样即使在滚动的时侯，也能始终让遮罩始盖住整个窗口。当侯选人忽略时我会提示他们这一点，并让他们解释fixed和absolute定位的区别。</p>

<pre><code>.overlay {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  background: rgba(0,0,0,.8);
}
</code></pre>

<p>他们如何让里面的内容居中也是需要考察的一点。一些侯选人会选择CSS和绝对定位，如果内容有固定的宽、高这是可行的。否则就要使用JavaScript.</p>

<pre><code>.overlay article {
  position: absolute;
  left: 50%;
  top: 50%;
  margin: -200px 0 0 -200px;
  width: 400px;
  height: 400px;
}
</code></pre>

<p>我也会让侯选人确保当遮罩被点击时要自动关闭，这会很好地考查事件冒泡机制的机会。通常侯选人会在overlay上面直接绑定一个点击关闭的方法。</p>

<pre><code>$('.overlay').click(closeOverlay);
</code></pre>

<p>这是个方法，不过直到你认识到点击窗口里面的东西也会关闭overlay的时侯——这明显是个BUG。解决方法是检查事件的触发对象和绑定对象是否一致，从而确定事件不是从子元素里面冒上来的，就像这样：</p>

<pre><code>$('.overlay').click(function(e){
  if (e.target == e.currentTarget)
    closeOverlay();
});
</code></pre>

<h3>其他方面</h3>

<p>当然这些问题只能覆盖前端一点点的知识的，还有很多其他的方面你有可能会问到，像性能，HTML5 API, AMD和CommonJS模块模型，构造函数（constructors），类型和盒子模型（box model）。根据侯选人的情况，我经常会随机提些问题。</p>

<hr>

<p>原文：<a rel=""nofollow"" href=""http://blog.sourcing.io/interview-questions"">Interviewing a front-end developer</a><br>
转载自：<a rel=""nofollow"" href=""http://ourjs.com/detail/52c4145d7986593603000009"">OurJS</a></p>

                ", 如何面试前端工程师：GitHub 很重要,1531978144,554,1,677,1,1,https://segmentfault.com/a/1190000000375138
339,1,0,7,"
                    
<p>以GitHub为代表的新一代代码协作平台开创了协同开发的新时代。开发者之间基于代码的协作从来没有像今天这样顺畅。GitHub上向你发送合并请求的开发者，可能和你分处大洋两岸，也可能和你同在一间办公室。上个礼拜，GitHub<a rel=""nofollow"" href=""https://github.com/blog/1724-10-million-repositories"">宣布其上托管的git仓库已经突破一千万大关</a>！</p>

<p>国内也有不少代码协作平台，本文介绍国内几个主要的代码协作平台，一起来看看吧。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJut"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git""></span></p>

<h2>GitCafe</h2>

<p><a rel=""nofollow"" href=""http://gitcafe.com"">GitCafe</a>是一个基于代码托管服务打造的技术协作与分享平台，最近刚刚获得景林资产300万人民币天使轮投资。</p>

<p>Git是目前世界上最流行最优秀的项目版本控制系统之一，Cafe的意思为咖啡馆，象征着程序员文化。</p>

<p>GitCafe界面十分简洁清爽，左右分栏的设计，使得浏览仓库代码十分便利。提供工单、wiki和页面服务。支持在线编辑功能，代码的修改、提交和合并请求，都可以在浏览器中完成。GitCafe的公有仓库免费，私有仓库需付费。付费功能使用极特币(gitcoin)，是一个很有趣的设计。</p>

<p>GitCafe目前还缺乏Webhook和API功能，因此其他应用或服务要支持GitCafe非常困难。</p>

<h2>gitshell</h2>

<p><a rel=""nofollow"" href=""https://gitshell.com/"">gitshell</a>是基于django开发的git代码协作平台。</p>

<p>GitShell的设计，有一个显著的特点，就是专注于git代码仓库本身，也就是UNIX哲学的“只做一件事，并且把它做好”。虽然GitShell自身不提供维基、工单等项目协作常用的功能，但是GitShell支持webhook，可以与第三方的代码协作应用服务（包括维基、工单等）无缝结合。</p>

<p>GitShell可以直接使用GitHub账号登录，新建项目的时候可以导入其他git仓库，其webhook服务也与GitHub兼容，方便新用户使用和旧项目的迁移。</p>

<p>代码是程序员最宝贵的资产，因此GitShell还提供Dropbox备份。</p>

<p>GitShell上可以免费创建公有和私有项目。</p>

<h2>CSDN</h2>

<p><a rel=""nofollow"" href=""http://code.csdn.net"">code.csdn</a>是CSDN推出的代码协作平台。基于Gitlab搭建，支持维基、工单等功能。</p>

<p>CSDN是国内最大的程序员社区，然而却常常给人老旧、笨重的感觉，总之就是和酷字不沾边。不过code.csdn的设计还不错，特别是它提供了代码片段功能，而且代码片段与CSDN的博客实现了双向绑定，在CSDN的博客中可以很方便地引用code.csdn中的代码片段，同时，在CSDN博客中插入的代码片段也会自动保存到code.csdn。</p>

<h2>京东</h2>

<p><a rel=""nofollow"" href=""https://code.jd.com"">code.jd</a>是京东（是的，你没看错，就是那个卖东西的京东，他们也开始提供代码托管了……）提供的代码协作平台，功能和界面和CSDN比较接近，应该也是基于Gitlab搭建的。由于功能、设计和CSDN大同小异，这里就不重复介绍了。</p>

<p>CSDN和京东都可以免费创建公开和私有项目。</p>

<h2>oschina</h2>

<p><a rel=""nofollow"" href=""http://git.oschina.net"">oschina的git代码托管服务</a>公开、私有项目均免费，功能也比较全面。oschina支持GitHub、Google、weibo、Windows Live账户登录，比较方便。</p>

<p>oschina刚上线的时候，直接用了GitHub的样式——不是模仿，也不是像素级拷贝，而是字面意义上的“直接用了”，甚至连css中的<code>github</code>字样也没有修改。</p>

<p>即使是现在，整个oschina的用户界面设计布局也和GitHub十分相像——GitHub用户使用git.oschina，会有强烈的既视感。</p>

<p>除了细节处理没有GitHub精美外，GitHub的各种酷炫的交互设计，比如键盘快捷键操作工单、唤出命令接口等功能oschina都没有采用。</p>

<p>毕加索有一句名言：”Bad artists copy, great artists steal.“（劣工摹其形，巧匠摄其魂。）虽然git.oschina样式布局方面大量拷贝GitHub，但显然没有偷到GitHub界面设计的精髓。</p>

<h2>gitcd</h2>

<p><a rel=""nofollow"" href=""http://www.gitcd.com"">gitcd.com</a>是基于gitc的代码协作平台。gitc使用Java开发，技术设计上有一些值得关注的特性，例如：</p>

<ul>
<li>gitc的ssh服务使用apache sshd，自行解析upload-pack和receive-pack的报文格式。</li>
<li>使用jgit读取git仓库信息。</li>
<li>页面展示部分使用了lucene搜索引擎，对每个分支最近一次RevCommit进行索引，该技术的应用，使得gitcd.com上仓库各个分支树在网页上浏览速度平均&lt;200毫秒(实际一般是80毫秒左右)。</li>
</ul>
<p>gitcd同样支持webhook，还可以设置SMS提醒。gitcd的权限控制粒度较细，可以限制分支提交，对某些流程严格的企业而言十分有用。</p>

<p>gitcd的界面比较简陋，用户注册的流程也很麻烦，注册成功的邮件给出的链接无法访问，而且需要绑定手机才能创建项目。</p>

<p>目前支付宝的团队使用gitcd托管代码，除此以外，gitcd.com上其他的公开项目很少，活跃用户也很少。</p>

<h2>svnchina</h2>

<p><a rel=""nofollow"" href=""http://www.svnchina.com"">svnchina</a>于2006年成立，是国内第一家支持私有项目的SVN源代码托管平台。</p>

<p>svnchina的收费策略为项目创建者需交纳年费，项目协作者免费。项目创建者交纳99元的年费后，可创建任意数量的项目，但空间使用不能超过1G.如果需要更多的空间，可以选择更高的年费。</p>

<p>svnchina最初的创始人为冯华君，其开发的FIT输入法曾是中国市场占有率最高的Mac系统第三方中文输入法。</p>

<h2>geakit</h2>

<p><a rel=""nofollow"" href=""https://geakit.com"">集盒</a>是2012年推出的基于git的代码协作平台。提供项目、工单等功能。集盒有一个非常方便、有用的特性——项目分组功能，可以通过分组功能对自己创建、参与、关注的项目进行分类。这个分类功能对于组织仓库非常方便。CSDN的代码协作平台在2013年11月底也加上了这个功能。</p>

<p>可惜的是2013年以来集盒的开发趋于停滞。目前，网站引用的css等静态资源已经无法访问，https的证书也已经过期。</p>

<h2>TaoCode</h2>

<p><a rel=""nofollow"" href=""http://code.taobao.org"">TaoCode</a>是淘宝推出的开源项目协作平台。目前bug不少，注册、创建、删除项目常出问题。其上的活跃用户主要是阿里内部人员。</p>

<h2>灰狐</h2>

<p>2011年，盛大创新院推出免费开源代码托管平台TeamHost，该平台基于Redmine进行二次开发。最初有很多计划，除了常见的代码托管功能外，还希望集成测试、持续构建、freelancer、招聘、IM、微博、P2P等功能。</p>

<p>后来Teamhost项目的所有成员都离开了盛大创新院，于是站点搬到了灰狐社区赞助的服务器上。然而随着团队成员工作的日益繁忙，Teamhost的开发趋于停滞状态，在2013年7月11日正式宣布关闭。</p>

<p>关闭之后，灰狐接手了Teamhost的代码和用户，继续运作。由于teamhost.org域名为盛大所有，而盛大DNS已经停止解析这个域名，所以启用了新域名 <a rel=""nofollow"" href=""http://code.huihoo.com"">code.huihoo.com</a>。</p>

<p>然而灰狐的开发也并不活跃，甚至连注册页面也仍然引用了teamhost旧域名的邮件地址。</p>

<p><strong>Update</strong> 后起之秀 <a rel=""nofollow"" href=""https://coding.net"">Coding.net</a> 值得一试，我的印象是它的迭代速度十分迅猛，有<a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform/1190000002389696"">演示平台</a>和代码质量分析（虽然我试下来对 Ruby 的效果很一般），私有仓库免费，有 <a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform/1190000002429065"">Android 和 iOS 的客户端</a>（开源的哦！）。以后有时间我会补上相关的评测，目前可以看 <a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform"">Coding.net 在此开的博客</a> 了解详情。</p>

<hr>
<p>欢迎分享使用这些平台的体验！你可以直接在下面评论。</p>

<p>撰文 <a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a></p>

                ", 细数国内代码协作平台,1531978145,112,1,540,1,1,https://segmentfault.com/a/1190000000374128
340,1,0,7,"
                    <p><strong>编者注：我们发现了有趣的系列文章<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000349384"">《30天学习30种新技术》</a>，正在翻译，一天一篇更新，年终礼包。下面是第 29 天的内容。</strong></p>

<hr>

<p>今天的<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000349384"">《30天学习30种新技术》</a>，我决定去学习如何写一个 Chrome 扩展程序。在做了一些<a rel=""nofollow"" href=""http://www.alolo.co/blog/2013/10/30/building-a-chrome-extension-with-yeoman"">搜索</a>之后，我发现一个 Yeoman 生成器可以用来写 Chrome 扩展程序。我们在这篇要写的扩展程序是一个可以在工作时间内，把 Facebook、Twitter、LinkedIn 等等的社交网站屏蔽掉的插件。这篇文章不会说到 Yeoman 的基本知识，你可以阅读<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000368881"">第 24 天</a>的内容了解一下 Yeoman。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbIK2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3>Chrome 扩展程序用例</h3>

<p>我们会写一个在办公时间内（早上 9 点到下午 6 点），禁止我们访问类似 Facebook、Twitter 这样的社交网站的一个简单的插件。如果用户访问 facebook 或者 twitter，他会看到下面的页面：<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbILf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
我没有屏蔽 Google + :)</p>

<h3>安装 Yeoman</h3>

<p>执行下面的命令安装 yeoman。这个命令默认你已经安装了 Node 和 Npm：</p>

<pre><code>$ npm install -g yeoman
</code></pre>

<p>上面的命令会全局安装 yeoman。<code>-g</code> 选项是指明全局安装的意思。如果你的机器上没安装 Grunt 和 bower，那么这个命令也会自动帮你安装这两个软件。</p>

<h3>GitHub</h3>

<p>今天这个演示应用的代码可以在 GitHub 上得到：<a rel=""nofollow"" href=""https://github.com/shekhargulati/day29-chrome-extension"">github: day29-chrome-extension</a>。</p>

<h3>创建 Chrome 扩展程序</h3>

<p>现在，在已经说过所需的基础后，让我们开始进行 Chrome 扩展程序的开发。</p>

<p>在你文件系统上便利的地方，为你的扩展程序创建一个目录，然后把工作目录转到扩展程序目录下。</p>

<pre><code>$ mkdir no-socializing
$ cd no-socializing
</code></pre>

<p>接着运行 <code>yo chrome-extension</code> 命令，它会问你如下所示的几个问题。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJbd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
让我们一个个过一下这些问题：<br>
1. 它首先问一下我们要对这个扩展程序如何命名，默认的名字是文件夹名字。<br>
2. 接着它询问这个扩展程序的用处<br>
3. 然后，它询问我们要不要使用 UI Action。我们使用 Browser UI Action。Browser Action 允许我们在 Chrome 的 Omnibox 旁边放一个可以点击的图标。点击这个图标就可以打开一个 html 文件。<br>
4. 接着，它会问我们是否需要添加更多 UI 的功能。我们添加选项页（Option Page）和 Omnibox 特性。<br>
5. 最后，它询问我们要给这个扩展怎样的权限。请阅读<a rel=""nofollow"" href=""http://developer.chrome.com/extensions/declare_permissions.html"">文档</a>了解更多的细节。</p>

<p>你可以像下面那样安装未打包的扩展程序到 Chrome 上。勾选<code>开发者模式（Developer Mode）</code>然后点击<code>加载未打包的扩展（Load unpackaged extension）</code>，然后在 <code>no-socializing</code> 目录下给它 <code>app</code> 目录。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJbQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>安装之后，你可以看到下面那样：<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJbR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3>更新 Background.js</h3>

<p>这个 Chrome 扩展程序的行为是受在文件夹 <code>app/scripts</code> 下面的 <code>background.js</code> 控制的。复制下面的代码，然后替换 <code>background.js</code> 的源代码。</p>

<pre><code>'use strict';

chrome.webRequest.onBeforeRequest.addListener(
    function(details) {
        var currentTime = new Date();
        if(isOfficeTime(currentTime) &amp;&amp; isWeekday(currentTime)){
            return {redirectUrl: chrome.extension.getURL('index.html')};    
        }
        return details.url;
    },
    {
        urls: [
            ""*://*.facebook.com/*"",
            ""*://*.twitter.com/*"",
            ""*://*.gmail.com/*"",
        ],
        types: [""main_frame"", ""sub_frame"", ""stylesheet"", ""script"", ""image"", ""object"", ""xmlhttprequest"", ""other""]
    },
    [""blocking""]
);

function isOfficeTime(currentTime){
    var hour = currentTime.getHours();
    return hour &gt; 9 &amp;&amp; hour &lt; 18;
}

function isWeekday(currentTime){
    var dayOfWeek = currentTime.getDay();
    return dayOfWeek &gt;= 1 &amp;&amp; dayOfWeek &lt;= 5;
}
</code></pre>

<p>上面的代码做下面的事情：<br>
它监听 <code>onBeforeRequest</code> 事件，它触发将要出现的请求。<code>addListener</code> 函数接受三个参数：<br>
1. 一个回调（callback）函数，它会在事件触发时执行。<br>
2. <a rel=""nofollow"" href=""http://developer.chrome.com/extensions/webRequest.html#type-RequestFilter"">RequestFilter</a> 对象，是一个将 <code>webRequest</code> 事件过滤的过滤器。我们会列出一系列要被过滤掉 URL 模式。<br>
3. 一个包含 <code>blocking</code>字符串（只允许特定的事件）的数组，回调函数会被同时处理。</p>

<p>我们也另外定义了一些函数去查询当前的时间和当前日期是在一周中的哪一天。它只会在工作日的上午九点到下午六点之间屏蔽掉社交网站。</p>

<p>上面的代码使用 <code>WebRequest API</code>。我们需要让这个扩展程序访问 <code>chrome.webRequest</code> API。这要用到 <code>webRequest</code> 权限。由于这个扩展程序在屏蔽模块中使用了 <code>chrome.webRequest</code> API，所以我们也不得不赋予 <code>webRequestBlocking</code> 权限。打开 app 目录下的 <code>manifest.json</code> 文件，然后更新权限模块：</p>

<pre><code>""permissions"": [
    ""webRequest"",
    ""tabs"",
    ""http://*/*"",
    ""https://*/*"",
    ""webRequestBlocking""
  ]
</code></pre>

<p>我们最后要做的就是添加一个 <code>index.html</code>。这个是用户访问 facebook、twitter 等等网站时要渲染显示的。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;
  &lt;title&gt;No Socializing&lt;/title&gt;
  &lt;link rel=""stylesheet"" href=""/styles/main.css""&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;NO, Socializing&lt;/h1&gt;
  &lt;img src=""/images/no-social-media.jpg"" height=""450"" width=""450""&gt;
  &lt;h2&gt;It's Office Time  Dude&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>你可以在 <a rel=""nofollow"" href=""https://raw.github.com/shekhargulati/day29-chrome-extension/master/app/images/no-social-media.jpg"">GitHub 仓库</a>里下载图片</p>

<p>现在，重新加载这个扩展，然后打开 <a rel=""nofollow"" href=""http://facebook.com"">http://facebook.com</a> 或者 <a rel=""nofollow"" href=""http://twitter.com"">http://twitter.com</a> 。如果当前时间是工作日的上午九点到下午六点之间，你会看到下面的页面：<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbILf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>这就是今天的内容了，保持反馈。</p>

<hr>

<p>原文：<a rel=""nofollow"" href=""https://www.openshift.com/blogs/day-29-yeoman-chrome-generator-write-your-first-google-chrome-extension"">Day 29: Yeoman Chrome Generator--Write Your First Google Chrome Extension</a><br>
翻译：<a rel=""nofollow"" href=""http://segmentfault.com/"">Segmentfault</a></p>

                ", Day 29：编写你的第一个 Google Chrome 扩展程序,1531978147,238,1,426,1,1,https://segmentfault.com/a/1190000000371543
341,1,0,7,"
                    <p>当我刚刚开始使用Git的版本控制时，我根本不确定我付出那么多时间是不是会得到回报。Branch、Stage、Stash，这些Git名词对我来说都非常陌生。</p>

<p>而今天的我已不能想象生活没有Git会变成什么样。Git不仅提供了我非常需要的版本控制功能，还让我变成一个更优秀的程序员。</p>

<p>这里有一系列可以帮助你的小贴士，可以让Git成为你开发工作中非常重要的一部分。</p>

<h3>第一条：花时间去学习Git的基本操作</h3>

<p>学习Git的基本操作并不是要求你把整个Git文档从头到尾读完（但如果这就是你的方式，我也不会反对）。</p>

<p>Git里面有太多的教育内容，我很确定里面一定有对你胃口的最佳学习方式。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbIel"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gitimage0""></span></p>

<p>看一下以下这些Git学习资源吧：</p>

<ul>
<li><a rel=""nofollow"" href=""http://sixrevisions.com/web-development/easy-git-tutorial/"">怎么快速开始使用Git</a></li>
<li><a rel=""nofollow"" href=""http://try.github.io/levels/1/challenges/1"">试试Git</a> - 15分钟的Git交互教程</li>
<li><a rel=""nofollow"" href=""http://rypress.com/tutorials/git/tips-and-tricks.html"">提示和技巧</a>（Ry的Git教学）是常见Git功能的实践教程</li>
<li><a rel=""nofollow"" href=""http://rogerdudler.github.io/git-guide/"">Git简单指南</a></li>
<li><a rel=""nofollow"" href=""http://gitready.com/"">Git Ready</a>是一个收藏有许多简单而简短的Git提示的网站</li>
<li><a rel=""nofollow"" href=""http://www.git-tower.com/blog/git-cheat-sheet/"">Git作弊码</a></li>
<li><a rel=""nofollow"" href=""http://www.git-tower.com/learn/"">Git Tower学习区</a>是一个在我的网站上的Git学习资源列表</li>
<li><a rel=""nofollow"" href=""http://git-scm.com/docs/gittutorial"">Git官方教程</a></li>
<li><a rel=""nofollow"" href=""http://www.youtube.com/playlist?list=PLg7s6cbtAD165JTRsXh8ofwRw0PqUnkVH"">Training</a>: Git Basics (视频)是YouTube上的一个视频列表</li>
<li><a rel=""nofollow"" href=""http://git-scm.com/book"">Pro Git</a>一本让你深入了解Git的在线书籍</li>
</ul>

<h3>第二条：从简单的Git工作流开始</h3>

<p>少即是多。</p>

<p>常常的，Git会和一个复杂的工作流联系起来。不过我可以这么说：你还暂时不需要为了Git的诸多好处，而一下子变成Git大师。</p>

<p>Git的工作流是可以非常简单的 —- 而且在许多情况下你需要的就是这么简单。你当然可以用multiple remote repositories、issue pull request、rebase changes等等，但是你不想用这些的话完全可以不用。</p>

<p>从简单的工作流入手也会使日后添加复杂性或者使用Git高级功能变得简单。当你需要使用这些功能的时候，Git已经准备好了。</p>

<p>这里有一些不同的Git工作流的例子，你可以从他们的想法中得到启发</p>

<ul>
<li><a rel=""nofollow"" href=""http://blog.teamtreehouse.com/git-for-designers-part-1"">设计者的Git工作流</a></li>
<li><a rel=""nofollow"" href=""http://nuclearsquid.com/writings/git-tricks-tips-workflows/"">Markus Prinz的Git工作流</a></li>
<li><a rel=""nofollow"" href=""http://yehudakatz.com/2010/05/13/common-git-workflows/"">Yehuda Katz的普通Git工作流</a></li>
<li><a rel=""nofollow"" href=""http://reinh.com/blog/2009/03/02/a-git-workflow-for-agile-teams.html"">Agile团队的Git工作流</a></li>
</ul>

<p>总的来说：不要因为觉得Git什么都要学就压力很大，你完全可以从今天开始使用Git。</p>

<h3>第三条：不要再害怕犯错误</h3>

<p>Git最出色的一点是：它几乎是100%易上手容忍错误操作的。</p>

<p>记住以下几点会让你晚上睡得更香：</p>

<ol>
<li>Git基本上不删除数据。即使是那些看起来是删除数据的操作，实际上是为了让你更快的撤销删除，而在向系统添加数据。</li>
<li>Git基本可以撤销所有操作。我鼓励你更多的实验和探索你的想法，因为这就是使用版本控制系统系统的最主要的好处之一。</li>
<li>你团队的每一个成员都在他／她的计算机中有各自的副本。本质上这更像是整个版本控制项目中的冗余备份（包括包括整个历史纪录），你捅了大娄子而且还没办法还原这种情况是极其少见的。</li>
</ol>

<h3>第四条：理解分支概念</h3>

<p>在Git里面，分支这个概念是你一开始能学到的最有用的东西了。分支允许你隔离开发你的项目，而要想成为一个高效的Git用户，这是非常关键的一点。</p>

<p>一开始这听起来好像不是什么大事，但一旦你完全的理解了分支概念，你会开始想没有这个你怎么活下去。</p>

<p>尽管其他的版本控制系统也会使用分支概念，Git是第一个实现它，并让它变的好用的系统。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbIer"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Gitimage01""></span></p>

<p>这里有一些有助你了解Git分支概念的资源：</p>

<ul>
<li><a rel=""nofollow"" href=""http://pcottle.github.io/learnGitBranching/"">LearnGitBranching!</a>是一个Git分支的交互式教程</li>
<li><a rel=""nofollow"" href=""http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging"">Git基本分支和合并</a></li>
<li><a rel=""nofollow"" href=""http://www-cs-students.stanford.edu/~blynn/gitmagic/ch04.html"">分支术</a>是一个Git分支和合并的简短介绍</li>
<li><a rel=""nofollow"" href=""https://www.atlassian.com/git/tutorial/git-branches"">Git分支</a>是一个很多绘图的Git教程</li>
<li>一个成熟的<a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">Git分支模型</a></li>
</ul>

<h3>第五条：学习暂存区</h3>

<p>当你的提交里面只包含一些相关的变化时，版本控制会变的非常有用，它保证了你的提交可以被没有任何副作用的回滚，经常提交的习惯也可以让你的同事更好的了解你的进度。</p>

<p>Git有个功能叫暂存区让这一切都变为可能</p>

<p>学习使用暂存区，并爱上它，因为这是Git里面最重要最独立的一个模块。</p>

<ol>
<li><a rel=""nofollow"" href=""http://gitolite.com/concepts/uses-of-index.html"">为什么暂存区那么有用</a></li>
<li><a rel=""nofollow"" href=""http://programmers.stackexchange.com/questions/69178/what-is-the-benefit-of-gits-two-stage-commit-process-staging"">用暂存区的好处在哪</a> —- 一个有关Git暂存区的讨论主题</li>
<li><a rel=""nofollow"" href=""http://betterexplained.com/articles/aha-moments-when-learning-git/"">啊哈！学习Git的那些时候</a> —- 一篇博客文章</li>
<li><a rel=""nofollow"" href=""http://gitready.com/beginner/2009/01/18/the-staging-area.html"">Git上有关暂存区的简短教程</a></li>
</ol>

<h3>第六条：用Git图形界面</h3>

<p>尽管使用图形界面绝对不会是一个要求，但我还是高度推荐使用。</p>

<p>使用图形界面让大多数操作都变得简单，让你在项目开始时便占尽优势。</p>

<p>不管怎么说，使用Git不应该只是记住各种命令和参数，而是改进你的编程工作流。如果图形界面可以做到这一点的话，没有理由让简单的事变的困难嘛。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbIeu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Gitimage02""></span></p>

<p>看一下这些Git界面吧：</p>

<ul>
<li><a rel=""nofollow"" href=""https://code.google.com/p/tortoisegit/"">Tortoise Git</a> - Windows平台下的开源Git图形界面</li>
<li><a rel=""nofollow"" href=""http://gitx.laullon.com/"">GitX(L)</a> - Mac OS X下的开源Git客户端</li>
<li><a rel=""nofollow"" href=""http://www.sourcetreeapp.com/"">SourceTree</a> - Windows和Mac下的免费Git或Mecurial界面</li>
<li><a rel=""nofollow"" href=""http://git-cola.github.io/"">git-cola</a> - 一款开源Git界面</li>
<li><a rel=""nofollow"" href=""http://www.git-tower.com/"">Tower</a> - 我们公司为Mac用户所出的Git界面</li>
</ul>

<p>使用图形界面并不能减轻你学习Git基础的负担，不过一旦你快乐的征服了Git，使用这些工具会让你的生活变得更轻松。</p>

<h3>第七条：对自己承诺你会用Git</h3>

<p>使用一个新工具一开始会让人非常头疼，走过这条学习曲线的方法只有一个：继续走下去。</p>

<p>做一个充分的承诺，不要回头。在你平常的工作流里引入Git很快就会被证明这是你近期做的最大的，最有意义的决定。</p>

<p>避免这种情况：「我会在这个项目里使用Git，但其他项目就再说了。」至少一开始不要这样。</p>

<p>充分承诺的这种心态会让你有更多的机会去练习，让事情变得更加简单，因为你知道你现在这个项目用了版本控制系统。而更重要的是，让Git成为你的编程习惯。</p>

<p>未来不久，你就会看到只有那么一些情况不需要用到Git，</p>

<p>对自己做一个100%的承诺，作为Git征服之路的开始。</p>

<hr>

<p>原文：<a rel=""nofollow"" href=""http://sixrevisions.com/web-development/git-tips/"">7 Useful Git Tips for Beginners</a><br>
转载自：<a rel=""nofollow"" href=""http://blog.jobbole.com/50603/"">伯乐在线</a> - <a rel=""nofollow"" href=""http://blog.jobbole.com/author/nappp/"">吴鹏煜</a></p>

                ", 写给 Git 初学者的 7 个建议,1531978148,310,1,156,1,1,https://segmentfault.com/a/1190000000369293
342,1,0,7,"
                    
<p>最近我在尝试搭建一个利用Git直接部署生产代码的服务器，查了许多资料，了解到需要用到Git Hooks这一特性，就顺便看了一下。</p>

<h3>什么是Git Hooks？</h3>

<p>话说，如同其他许多的版本控制系统一样，Git也具有在特定事件发生<strong>之前</strong>或<strong>之后</strong>执行特定脚本代码功能（从概念上类比，就与监听事件、触发器之类的东西类似）。Git Hooks就是那些在Git执行特定事件（如commit、push、receive等）后触发运行的脚本。</p>

<p>按照Git Hooks脚本所在的位置可以分为两类：</p>

<ul>
<li>本地Hooks，触发事件如commit、merge等。</li>
<li>服务端Hooks，触发事件如receive等。</li>
</ul>
<h3>Git Hooks能做什么？</h3>

<p>Git Hooks是定制化的脚本程序，所以它实现的功能与相应的git动作相关；在实际工作中，Git Hooks还是相对比较万能的。下面仅举几个简单的例子：</p>

<ul>
<li>pre-commit: 检查每次的commit message是否有拼写错误，或是否符合某种规范。</li>
<li>pre-receive: 统一上传到远程库的代码的编码。</li>
<li>post-receive: 每当有新的提交的时候就通知项目成员（可以使用Email或SMS等方式）。</li>
<li>post-receive: 把代码推送到生产环境。（这就是我想要做的）</li>
<li>etc...</li>
</ul>
<p>更多的功能可以按照生产环境的需求写出来。</p>

<h3>Git Hooks是如何工作的？</h3>

<p>每一个Git repo下都包含有<code>.git/hoooks</code>这个目录（没错，本地和远程都是这样），这里面就是放置Hooks的地方。你可以在这个目录下自由定制Hooks的功能，当触发一些Git行为时，相应地Hooks将被执行。</p>

<p>这里是一个Git Hooks列表，现在如果觉得不是很明白，不用担心，以后我会继续讲：</p>

<ul>
<li>applypatch-msg</li>
<li>pre-applypatch</li>
<li>post-applypatch</li>
<li>pre-commit</li>
<li>prepare-commit-msg</li>
<li>commit-msg</li>
<li>post-commit</li>
<li>pre-rebase</li>
<li>post-checkout</li>
<li>post-merge</li>
<li>pre-receive</li>
<li>update</li>
<li>post-receive</li>
<li>post-update</li>
<li>pre-auto-gc</li>
<li>post-rewrite</li>
</ul>
<p><span class=""img-wrap""><img data-src=""https://gitcafe.com/PengEdy/PengEdy/raw/gitcafe-pages/images/git-hooks-i-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span><br>
图中是我一个本地repo的git hooks示例。</p>

<h3>如何开始使用Git Hooks？</h3>

<p>好了，前面啰嗦一大堆，这里才是重点。</p>

<p>如图中所示的文件，是由本地执行的脚本语言写成的，尽管这些文件默认会是<code>Shell Script</code>，你完全可以给它替换成自己喜欢的<code>Ruby</code>，<code>Python</code>或者<code>Perl</code>。</p>

<p>举个例子，它是这个样子的：</p>

<p><span class=""img-wrap""><img data-src=""https://gitcafe.com/PengEdy/PengEdy/raw/gitcafe-pages/images/git-hooks-i-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span></p>

<p>关于这些脚本文件的命名，细心的读者就会发现图中的文件都是上面Git行为列表中列出的名称加上后缀<code>.sample</code>。没错就是这样，把那些文件的后缀去掉，或者以列表中的名字直接命名，就会把该脚本绑定到特定的Git行为上。</p>

<p>所以说，Git Hooks的正确操作方式是：写脚本。</p>

<h3>Git Hooks项目介绍</h3>

<ul>
<li>
<a rel=""nofollow"" href=""https://npmjs.org/package/node-hooks"">node-hooks</a>: 一个命令行下的Git Hooks管理工具</li>
<li>
<a rel=""nofollow"" href=""https://github.com/icefox/git-hooks"">git-hooks</a>: 一个全面的Git Hooks管理工具</li>
<li>
<a rel=""nofollow"" href=""http://search.cpan.org/dist/Git-Hooks/"">Git::Hooks</a>: 一个实现Git Hooks的框架</li>
<li>etc...</li>
</ul>
<blockquote>
  <p>本篇完，第二篇在<a rel=""nofollow"" href=""http://blog.segmentfault.com/pengedy/1190000000356487"">这里</a>。</p>
</blockquote>

                ", Git Hooks (1)：介绍,1531978149,518,1,688,1,1,https://segmentfault.com/a/1190000000356485
343,1,0,7,"
                    
<p><strong>编者注：本文只是对原文内容作了文字版整理，未作任何更改，文章更注重对 Git 思想的阐述。下面是原文内容。</strong></p>

<blockquote>
  <p>助你开始使用 git 的简易指南，木有高深内容。 ;)<br>
  作者：罗杰·杜德勒<br>
  感谢：<a rel=""nofollow"" href=""http://www.twitter.com/tfnico"">@tfnico</a>，<a rel=""nofollow"" href=""http://www.twitter.com/fhd"">@fhd</a> and <a rel=""nofollow"" href=""http://www.namics.com/"">Namics</a><br>
  如有纰漏，请到 <a rel=""nofollow"" href=""https://github.com/rogerdudler/git-guide/issues"">github</a> 填报</p>
</blockquote>

<h2>安装</h2>

<ul>
<li><a rel=""nofollow"" href=""http://code.google.com/p/git-osx-installer/downloads/list?can=3"">下载 git OSX 版</a></li>
<li><a rel=""nofollow"" href=""http://code.google.com/p/msysgit/downloads/list?can=3"">下载 git Windows 版</a></li>
<li><a rel=""nofollow"" href=""http://book.git-scm.com/2_installing_git.html"">下载 git Linux 版</a></li>
</ul>
<h2>创建新仓库</h2>

<p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p>

<h2>检出仓库</h2>

<p>执行如下命令以创建一个本地仓库的克隆版本：</p>

<pre><code>git clone /path/to/repository 
</code></pre>

<p>如果是远端服务器上的仓库，你的命令会是这个样子：</p>

<pre><code>git clone username@host:/path/to/repository
</code></pre>

<h2>工作流</h2>

<p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbCpS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img-1""></span></p>

<h2>添加与提交</h2>

<p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p>

<pre><code>git add &lt;filename&gt;
git add *
</code></pre>

<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p>

<pre><code>git commit -m ""代码提交信息""
</code></pre>

<p>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p>

<h2>推送改动</h2>

<p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。执行如下命令以将这些改动提交到远端仓库：</p>

<pre><code>git push origin master
</code></pre>

<p>可以把 <em>master</em> 换成你想要推送的任何分支。</p>

<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>

<pre><code>git remote add origin &lt;server&gt;
</code></pre>

<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>

<h2>分支</h2>

<p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbCpT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img-2""></span></p>

<p>创建一个叫做“feature_x”的分支，并切换过去：</p>

<pre><code>git checkout -b feature_x
</code></pre>

<p>切换回主分支：</p>

<pre><code>git checkout master
</code></pre>

<p>再把新建的分支删掉：</p>

<pre><code>git branch -d feature_x
</code></pre>

<p>除非你将分支推送到远端仓库，不然该分支就是 <em>不为他人所见的</em>：</p>

<pre><code>git push origin &lt;branch&gt;
</code></pre>

<h2>更新与合并</h2>

<p>要更新你的本地仓库至最新改动，执行：</p>

<pre><code>git pull
</code></pre>

<p>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>
要合并其他分支到你的当前分支（例如 master），执行：</p>

<pre><code>git merge &lt;branch&gt;
</code></pre>

<p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <em>冲突（conflicts）</em>。 这时候就需要你修改这些文件来人肉合并这些 <em>冲突（conflicts）</em> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>

<pre><code>git add &lt;filename&gt;
</code></pre>

<p>在合并改动之前，也可以使用如下命令查看：</p>

<pre><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;
</code></pre>

<h2>标签</h2>

<p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 <em>1.0.0</em> 的标签：</p>

<pre><code>git tag 1.0.0 1b2e1d63ff
</code></pre>

<p><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：</p>

<pre><code>git log
</code></pre>

<p>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p>

<h2>替换本地改动</h2>

<p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p>

<pre><code>git checkout -- &lt;filename&gt;
</code></pre>

<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p>

<p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p>

<pre><code>git fetch origin
git reset --hard origin/master
</code></pre>

<p><br></p>

<h2>有用的 Tips</h2>

<p>内建的图形化 git：</p>

<pre><code>gitk
</code></pre>

<p>彩色的 git 输出：</p>

<pre><code>git config color.ui true
</code></pre>

<p>显示历史记录时，只显示一行注释信息：</p>

<pre><code>git config format.pretty oneline
</code></pre>

<p>交互地添加文件至缓存区：</p>

<pre><code>git add -i
</code></pre>

<h2>链接与资源</h2>

<h3>图形化界面</h3>

<ul>
<li><a rel=""nofollow"" href=""http://gitx.laullon.com/"">GitX (L) (OSX, open source)</a></li>
<li><a rel=""nofollow"" href=""http://www.git-tower.com/"">Tower (OSX)</a></li>
<li><a rel=""nofollow"" href=""http://www.sourcetreeapp.com/"">Source Tree (OSX, free)</a></li>
<li><a rel=""nofollow"" href=""http://mac.github.com/"">GitHub for Mac (OSX, free)</a></li>
<li><a rel=""nofollow"" href=""https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12"">GitBox (OSX)</a></li>
</ul>
<h3>指南与手册</h3>

<ul>
<li><a rel=""nofollow"" href=""http://book.git-scm.com/"">Git 社区参考书</a></li>
<li><a rel=""nofollow"" href=""http://progit.org/book/"">专业 Git</a></li>
<li><a rel=""nofollow"" href=""http://think-like-a-git.net/"">如 git 思考</a></li>
<li><a rel=""nofollow"" href=""http://help.github.com/"">GitHub 帮助</a></li>
<li><a rel=""nofollow"" href=""http://marklodato.github.com/visual-git-guide/index-en.html"">图形化的 Git 指南一则</a></li>
<li><a rel=""nofollow"" href=""http://git-scm.com/book/zh"">《Pro Git》</a></li>
</ul>
<hr>
<p>原文 <a rel=""nofollow"" href=""http://rogerdudler.github.io/git-guide/index.zh.html"">git - 简易指南</a><br>
整理 <a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a></p>

                ", Git - 简易指南,1531978150,299,1,524,1,1,https://segmentfault.com/a/1190000000346936
344,1,0,7,"
                    <p>Gitlab是一个用Ruby on Rails开发的开源项目管理程序，可以通过WEB界面进行访问公开的或者私人项目。它和Github有类似的功能，能够浏览源代码，管理缺陷和注释。</p>

<p>下面介绍如何在 Debian/Ubuntu 和 Centos 下搭建配置 GitLab。</p>

<h2>安装依赖</h2>

<p>Debian/Ubuntu下：</p>

<pre><code>sudo apt-get install -y build-essential zlib1g-dev libyaml-dev libssl-dev libgdbm-dev libreadline-dev libncurses5-dev libffi-dev curl openssh-server redis-server checkinstall libxml2-dev libxslt-dev libcurl4-openssl-dev libicu-dev logrotate
</code></pre>

<p>安装python(注意需要2.5以上版本)：</p>

<pre><code>sudo apt-get install -y python python-docutils
</code></pre>

<p>安装git（注意需要1.7.10以上版本）：</p>

<pre><code>sudo apt-get install -y git-core
</code></pre>

<p>Centos下官方仓库的软件比较老旧，推荐<a rel=""nofollow"" href=""http://blog.51yip.com/linux/1337.html"">先添加epel源</a>，然后再安装依赖：</p>

<pre><code>sudo yum install git patch gcc-c++ readline-devel zlib-devel libffi-devel openssl-devel make autoconf automake libtool bison libxml2-devel libxslt-devel libyaml-devel git python python-docutils
</code></pre>

<h2>安装 Ruby 2.0</h2>

<p>需要安装Ruby2.0，软件仓库中的Ruby 1.8不支持：</p>

<pre><code>mkdir /tmp/ruby &amp;&amp; cd /tmp/ruby
curl --progress ftp://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p353.tar.gz | tar xz
cd ruby-2.0.0-p353
./configure --disable-install-rdoc
make
sudo make install
</code></pre>

<p>安装Bundler Gem：</p>

<pre><code>sudo gem install bundler --no-ri --no-rdoc
</code></pre>

<h2>配置gitlab-shell</h2>

<p>创建git用户：</p>

<pre><code>sudo adduser --system --create-home --comment 'GitLab' git  
</code></pre>

<p>配置gitlab-shell</p>

<pre><code>su - git -c ""git clone https://github.com/gitlabhq/gitlab-shell.git""  
su - git -c ""cd gitlab-shell &amp;&amp; git checkout v1.3.0""  
su - git -c ""cp gitlab-shell/config.yml.example gitlab-shell/config.yml""  
sed -i ""s/localhost/gitlab.51yip.com/g"" /home/git/gitlab-shell/config.yml  
su - git -c ""gitlab-shell/bin/install""  
chmod 600 /home/git/.ssh/authorized_keys  
chmod 700 /home/git/.ssh
</code></pre>

<h2>数据库</h2>

<p>GitLab支持 MySQL 和 PostgreSQL 数据库。下面以 MySQL为例，介绍安装方法：</p>

<p>Debian/Ubuntu下使用如下命令安装：</p>

<pre><code>sudo apt-get install -y mysql-server mysql-client libmysqlclient-dev
</code></pre>

<p>Centos下使用如下命令：</p>

<pre><code>sudo yum install mysql-server 
sudo chkconfig mysqld on
</code></pre>

<p>配置MySQL：</p>

<pre><code>sudo echo ""CREATE DATABASE IF NOT EXISTS gitlabhq_production DEFAULT CHARACTER SET 'utf8' COLLATE 'utf8_unicode_ci';"" | mysql -u root 
sudo echo ""UPDATE mysql.user SET Password=PASSWORD('123456') WHERE User='root'; FLUSH PRIVILEGES;"" | mysql -u root 
</code></pre>

<p>注意，用你的密码替换<code>123456</code>。</p>

<p>安装配置 gitlab</p>

<pre><code>su - git -c ""git clone https://github.com/gitlabhq/gitlabhq.git gitlab""  
su - git -c ""cd gitlab;git checkout 5-1-stable""  
su git -c ""cp config/gitlab.yml.example config/gitlab.yml""  
su git -c ""mkdir /home/git/gitlab-satellites""  
su git -c ""mkdir public/uploads""  
su git -c ""mkdir -p tmp/sockets/""  
su git -c ""mkdir -p tmp/pids/""  
sed -i ""s/ host: localhost/ host: gitlab.segmentfault.com/g"" config/gitlab.yml  
sed -i ""s/from: gitlab@localhost/from: gitlab@gitlab.segmentfault.com/g"" config/gitlab.yml  
su git -c ""cp config/puma.rb.example config/puma.rb""  
su git -c 'git config --global user.name ""GitLab""'  
su git -c 'git config --global user.email ""gitlab@gitlab.segmentfault.com""'
</code></pre>

<p>注意将<code>gitlab.segmentfault.com</code>替换为你自己的内容。</p>

<p>配置数据库连接：</p>

<pre><code>sudo su git -c ""cp config/database.yml.mysql config/database.yml""
sudo sed -i ""s/secure password/mysql的root密码/g"" config/database.yml
</code></pre>

<p>安装MySQL需要的Gems</p>

<pre><code>sudo -u git -H bundle install --deployment --without development test postgres aws
</code></pre>

<p>初始化：</p>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production
sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab
sudo chmod +x /etc/init.d/gitlab
sudo update-rc.d gitlab defaults 21
</code></pre>

<p>查看是否配置妥当：</p>

<pre><code>sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production
</code></pre>

<p>重启GitLab：</p>

<pre><code>sudo service gitlab start
</code></pre>

<h2>配置Nginx</h2>

<p>Debian/Ubuntu下：</p>

<pre><code>sudo apt-get install -y nginx
</code></pre>

<p>CentOS下：</p>

<pre><code>sudo yum install nginx
</code></pre>

<p>下载配置文件样例：</p>

<pre><code>sudo cp lib/support/nginx/gitlab /etc/nginx/sites-available/gitlab
sudo ln -s /etc/nginx/sites-available/gitlab /etc/nginx/sites-enabled/gitlab
</code></pre>

<p>修改 <code>/etc/nginx/sites-available/gitlab</code>，特别留意将 <code>YOUR_SERVER_FQDN</code> 改成自己的。</p>

<p>重启nginx:</p>

<pre><code>sudo service nginx restart
</code></pre>

<p>好了，你可以登录GitLab了，默认安装后的用户名：<code>admin@local.host</code>，密码<code>5iveL!fe</code>。</p>

                ", 用GitLab搭建自己的私有GitHub,1531978151,241,1,877,1,1,https://segmentfault.com/a/1190000000345686
345,1,0,7,"
                    <p>SegmentFault用户，独立开发者，前支付宝前端开发工程师<a rel=""nofollow"" href=""http://segmentfault.com/u/guoyu"">郭宇</a>，为极客们准备的一个命令行工具，方便大家看btc各交易站实时价格：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbBvp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img-1""></span></p>

<h2>安装</h2>

<pre><code>$ [sudo] npm install btc -g  
</code></pre>

<h2>命令行界面</h2>

<p>只要运行<code>btc</code>，实时价格会自动显示</p>

<pre><code>$ btc 
</code></pre>

<h2>快捷键</h2>

<p>btc cli为您提供一些实用的快捷键：</p>

<pre><code>[enter]  -&gt;  refresh prices as you wish
[g]      -&gt;  go to current exchange market
[a]      -&gt;  autorefresh the current exchange market every 10 seconds, 
             press [a] to cancel or [enter] to cancel all
[q]      -&gt;  quit  
</code></pre>

<h2>实例</h2>

<pre><code>var btc = require('btc');

// fetch a prices list
btc.price(function(err, prices){
    console.log(prices);
});

// fetch a seleced exchanger
btc.price('btcchina', function(err, prices){
    console.log(prices);
});  
</code></pre>

<h2>添加你比特币的API</h2>

<p>可以随时增加你新的比特币api：</p>

<pre><code>$ git clone https://github.com/turingou/btc.git &amp;&amp; cd btc
$ vi ./libs/exchangers.js  
</code></pre>

<p>确保每个API都有其独特的<code>URL网站</code>，并填写参数<code>货币</code>。</p>

<h2>API</h2>

<p>请查看该文件：<a rel=""nofollow"" href=""https://github.com/turingou/btc/blob/master/index.js"">index.js</a></p>

<p>btc支持以下交易平台及方式：</p>

<ul>
<li><a rel=""nofollow"" href=""https://www.btcchina.com/"">btcchina</a>: 中国最大的比特币交易平台   </li>
<li><a rel=""nofollow"" href=""https://www.mtgox.com/"">mtgox</a>   </li>
<li><a rel=""nofollow"" href=""https://www.bitstamp.net/"">bitstamp</a></li>
<li><a rel=""nofollow"" href=""https://btc-e.com/"">btce</a>  </li>
<li><a rel=""nofollow"" href=""http://bitcoinwisdom.com/markets/796/futures"">futures796</a>  </li>
<li><a rel=""nofollow"" href=""https://www.okcoin.com/"">okcoin</a>  </li>
<li><a rel=""nofollow"" href=""https://www.chbtc.com/"">chbtc</a>  </li>
<li><a rel=""nofollow"" href=""http://www.fxbtc.com/"">fxbtc</a>  </li>
<li><a rel=""nofollow"" href=""http://www.btctrade.com/"">btctrade</a>  </li>
<li><a rel=""nofollow"" href=""https://btc100.org/"">btc100</a>   </li>
</ul>

<hr>

<p><br><br>
原文是 <a rel=""nofollow"" href=""http://segmentfault.com/u/guoyu"">郭宇</a> 发布在自己<a rel=""nofollow"" href=""https://github.com/turingou/btc"">github 项目</a>上的说明文档<br>
本文由 <a rel=""nofollow"" href=""http://segmentfault.com/"">segmentfault</a> 翻译</p>

                ", 一个查看各大BTC比特币交易站实时价格的命令行工具,1531978153,114,1,713,1,1,https://segmentfault.com/a/1190000000343448
346,1,0,7,"
                    
<h1>ChromeSnifferPlus</h1>
<p><a href=""https://github.com/justjavac/ChromeSnifferPlus"" rel=""nofollow noreferrer"">Chrome Sniffer Plus</a>： Chrome 探测器，可以探测正在使用的开源软件或者 js 类库，开发者必备。</p>
<p>通过本插件，您可以探测：</p>
<ul>
<li><p>javascript 库： jQuery、ExtJS、Angular 等。</p></li>
<li><p>常用的 web 服务： 百度统计、cnzz、Google Analytics 等。</p></li>
<li><p>Web 框架： WordPress、phpBB、Drupal、MediaWiki 等。</p></li>
<li><p>服务器环境： PHP、Apache、nginx 等。</p></li>
</ul>
<p>当你安装此插件去浏览网页时，还可以发现更多你未知的框架和库。</p>
<p>如果你发现了还不能探测的类库，可以在下面留言。</p>
<p>如果你是类库、框架的开发者，可以将你类库框架的探测方式通知我，让更多人的知道你的类库框架。</p>
<p>查看<a href=""https://github.com/justjavac/ChromeSnifferPlus/blob/master/changelog.md"" rel=""nofollow noreferrer"">更新日志</a></p>
<h3>安装</h3>
<p>本插件已经在 Chrome Web Store 上线。</p>
<p>安装地址： <a href=""https://chrome.google.com/webstore/detail/chrome-sniffer-plus/fhhdlnnepfjhlhilgmeepgkhjmhhhjkh"" rel=""nofollow noreferrer"">https://chrome.google.com/webstore/detail/chrome-sniffer-plus/fhhdlnnepfjhlhilgmeepgkhjmhhhjkh</a></p>
<h3>截图</h3>
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbztr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ChromeSnifferPlus效果截图"" title=""ChromeSnifferPlus效果截图""></span>    <br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbzts"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ChromeSnifferPlus效果截图"" title=""ChromeSnifferPlus效果截图""></span>    <br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbztt"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ChromeSnifferPlus效果截图"" title=""ChromeSnifferPlus效果截图""></span>    <br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbztu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ChromeSnifferPlus效果截图"" title=""ChromeSnifferPlus效果截图""></span></p>
<p>最后附一个 sf 的探测结果：</p>
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbzty"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ChromeSnifferPlus效果截图-sf"" title=""ChromeSnifferPlus效果截图-sf""></span></p>

                ", ChromeSnifferPlus 可以探测正在使用的开源软件或者 js 类库,1531978154,515,1,659,1,1,https://segmentfault.com/a/1190000000335632
347,1,0,7,"
                    <h2>代码管理</h2>

<h3>Git</h3>

<p>关于Git Workflow的讨论很多，最著名的当属<a rel=""nofollow"" href=""http://nvie.com/"">Vincent Driessen</a>的那篇博客<a rel=""nofollow"" href=""http://nvie.com/posts/a-successful-git-branching-model/"">A successful Git branching model</a>。Vincent的工作流的结构很棒，首先有2个主要分支，<code>master</code> 和 <code>develop</code>，分别是主分支和开发分支。然后还有3类次分支，它们可能数量很多，并且不会长时间存在，分别是开发新功能用的feature，发布用的release和修复bug用的hotfix。大致的Git操作可以理解为这样：</p>

<pre><code># create branch
git checkout -b develop master
git checkout -b feature develop
# commit something
git add widget.js
git commit -m ""add a function""
# merge to develop
git checkout develop
git merge --no-ff feature
# delete branch
git branch -d feature
</code></pre>

<p>首先创建开发分支 <code>develop</code> ，然后再从开发分支创建一个次分支，接着提交代码并注释提交，合并会开发分支 <code>develop</code> ，最后删除这个临时的次分支。--no-ff的意思是不使用快速合并。其他开发过程中也是大同小异，release分支还有hotfix分支可能需要在确认没问题时合并到develop和master两个分支中然后删除。</p>

<p>不过这个工作流是考虑到团队开发而设计的，很标准简约，但细节不足。而<a rel=""nofollow"" href=""https://sandofsky.com"">Benjamin Sandofsky</a>的文章<a rel=""nofollow"" href=""https://sandofsky.com/blog/git-workflow.html"">Understanding the Git Workflow</a>则更加趋向于对commit的管理，也许不能算做工作流，至少算是一种理念。他强调一定要保留有一个私人的分支只存在于本地，然后在合并到主分支时清除原本的commit log。这里会用到一个 <code>merge</code> 命令的参数 <code>--squash</code> 这样合并后不会带来任何commit log。</p>

<pre><code># create brach
git checkout -b private master
# commit something
git add widget.js
git commit -m ""add a function""
# merge brach but don't commit
git checkout master
git merge --squash private
# commit once
git commit -m ""only this commit""
</code></pre>

<p>但我认为Git工作流和其他一切工程过程一样，不存在银弹。不过这种合并的方式可以成为一种很好的操作流来完成属于每个人自己的工作流。另外从这两种不同风格的Git工作流中也许能找出一些有趣的点。以下是我的看法：</p>

<ul>
<li>主分支数由开发流程复杂度决定，而开发流程复杂度应该由项目主管根据项目规模确定，所以项目规模决定了主分支数，除了develop也许还需要test、build等等。</li>
<li>次分支数由人员和实际情况决定，bug数会决定hotfix的数量，也许产品经理会决定feature的数量，多个不同版本的同类产品也可能会增加release的数量。如果项目规模足够大时，几个小组解决一个问题时也会产生多个临时分支。</li>
<li>多人协作以及长时间开发都可能导致日志混乱无法管理，使用squash参数配合临时分支可以清理对别人不必要的commit信息。</li>
<li>应使用--no-ff可以避免快速合并，使每次合并等于一次提交，记录在log中，保持分支健康。</li>
</ul>

<p>因此，在实际开发的工作流中应该按照实际情况创建分支，但应按照以上规范合并分支。</p>

<h3>Github</h3>

<p>Github不止是每个Coder的FaceBook，还是一个非常棒的远程Git仓库，有很多小组将正式项目托管在上面。其实Github上和Git没有太多差别，只是多了一个远程仓库Remote的操作，另外相信每个初入Github的新手都为私钥公钥头疼了好久，下文将会讨论Github的仓库创建和日常操作两部分。</p>

<p>首先需要在本地建立与Github帐户的联系，在shell中安装SSH，然后像这样使用SSH安装SSH密钥(<a rel=""nofollow"" href=""https://help.github.com/articles/generating-ssh-keys"">帮助文档</a>)：</p>

<pre><code>ssh-keygen -t rsa -C ""your_email@example.com""
# Creates a new ssh key, using the provided email as a label
# Generating public/private rsa key pair.
# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
ssh-add id_rsa
</code></pre>

<p>然后会让你输入一个密码，随意输入就可以了，接着就会生成一个公钥一个私钥。在用户文件夹下的 <code>.ssh</code> 文件夹中找到id_rsa.pub，这个文件里就是公钥，复制里面的内容，然后在Github的Account Settings中的SSH Key页面，点击Add SSH Key按钮，输入一个用于说明的title，接着粘贴公钥到Key中就可以了。</p>

<p>然后必须在Github上点击 <code>Create a new repo</code> 按钮来创建一个空项目。当然如果选择适当的选项就可以自动生成README文件、Git忽略文件和版权分享声明文件。之后该项目会有一个仓库的地址，可以使用HTTPS和SSH，甚至还有SVN地址：</p>

<pre><code>https://github.com/&lt;username&gt;/&lt;reponame&gt;.git
git@github.com:&lt;username&gt;/&lt;reponame&gt;.git
https://github.com/&lt;username&gt;/&lt;reponame&gt;
</code></pre>

<p>以我的一个对话框jQ插件为例，首先在项目中初始化git，然后添加一个远程仓库，然后就可以往上面提交代码了。</p>

<pre><code>git remote add myGithub https://github.com/tychio/dialog.git
git push myGithub master
</code></pre>

<p>因为我使用的HTTPS方式提交，之后会需要输入用户名和密码，如果使用SSH方式则使用公钥然后会在链接时使用生成密钥时的密码。使用HTTPS纯属为了记住Github的密码，每天都在敲就不会忘记了。</p>

<h2>总结</h2>

<p>工作流应该是一个人最习惯和熟悉的流程，而不应该是照猫画虎，邯郸学步。还是那句话，不存在银弹，所以不会有万用的工作流，只能从中汲取有用的实践，完善改进自己的工作流，达到提高工作效率的目的。</p>

<p>和学习其他技术一样，应用于工作流之中的工具有无数种，但真正需要和适合的只有自己知道，发现问题，带着问题寻找工具才能真的改进工作流。如果仅仅为了使用前沿的工具而使用，只会使自己的工作效率大打折扣。记得两年前我还在疯狂的复制代码，每当我意识到不能再这样下去的时候，工作流就会自己进化，合适的工具近在眼前，工作效率逐渐提升。我发现问题实在是很好的老师，可以让一个人快速的成长，解决它就可以获得一次提升。</p>

<p>永远有人有跟你相同的问题，永远有能解决你当前问题的工具，善于使用问题来选择它们就能打造更完善的工作流。如果遇到没有工具能解决的问题，那说明造轮子的时机到了。</p>

<hr>

<p>我的前端开发工作流 系列文章：</p>

<ul>
<li><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000312931"">环境篇</a></li>
<li><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000312941"">自动化篇</a></li>
<li><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000312942"">工具篇</a></li>
<li><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000312944"">代码管理篇</a></li>
</ul>

<p>原文博客<a rel=""nofollow"" href=""http://www.tychio.net/tech/2013/09/25/improve-workflow.html"">http://www.tychio.net/tech/2013/09/25/improve-workflow.html</a></p>

                ", 我的前端开发工作流 - 代码管理篇,1531978155,329,1,687,1,1,https://segmentfault.com/a/1190000000312944
348,1,0,7,"
                    <p>git已经变成了很多程序员日常工具之一。<br>
git log是查看git历史的好工具，不过默认的格式并不是特别的直观。<br>
很多时候想要更简便的输出更多或者更少的信息，这里列出几个git log的format。<br>
可以根据自己的需要定制。</p>

<p>git log命令可一接受一个--pretty选项，来确定输出的格式.<br>
如果我们只想输出hash.   </p>

<pre><code>git log --pretty=format:""%h"" 
</code></pre>

<p>git用各种placeholder来决定各种显示内容： 
下面内容来自<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-show"">这里</a>  </p>

<ul>
<li>%H: commit hash</li>
<li>%h: 缩短的commit hash</li>
<li>%T: tree hash</li>
<li>%t: 缩短的 tree hash</li>
<li>%P: parent hashes</li>
<li>%p: 缩短的 parent hashes</li>
<li>%an: 作者名字</li>
<li>%aN: mailmap的作者名字 (.mailmap对应，详情参照<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-shortlog"">git-shortlog(1)</a>或者<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-blame"">git-blame(1)</a>)  </li>
<li>%ae: 作者邮箱</li>
<li>%aE: 作者邮箱 (.mailmap对应，详情参照<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-shortlog"">git-shortlog(1)</a>或者<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-blame"">git-blame(1)</a>) </li>
<li>%ad: 日期 (--date= 制定的格式)</li>
<li>%aD: 日期, RFC2822格式</li>
<li>%ar: 日期, 相对格式(1 day ago)</li>
<li>%at: 日期, UNIX timestamp</li>
<li>%ai: 日期, ISO 8601 格式</li>
<li>%cn: 提交者名字</li>
<li>%cN: 提交者名字 (.mailmap对应，详情参照<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-shortlog"">git-shortlog(1)</a>或者<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-blame"">git-blame(1)</a>) </li>
<li>%ce: 提交者 email</li>
<li>%cE: 提交者 email (.mailmap对应，详情参照<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-shortlog"">git-shortlog(1)</a>或者<a rel=""nofollow"" href=""http://linux.die.net/man/1/git-blame"">git-blame(1)</a>) </li>
<li>%cd: 提交日期 (--date= 制定的格式)</li>
<li>%cD: 提交日期, RFC2822格式</li>
<li>%cr: 提交日期, 相对格式(1 day ago)</li>
<li>%ct: 提交日期, UNIX timestamp</li>
<li>%ci: 提交日期, ISO 8601 格式</li>
<li>%d: ref名称</li>
<li>%e: encoding</li>
<li>%s: commit信息标题</li>
<li>%f: sanitized subject line, suitable for a filename</li>
<li>%b: commit信息内容</li>
<li>%N: commit notes</li>
<li>%gD: reflog selector, e.g., refs/stash@{1}</li>
<li>%gd: shortened reflog selector, e.g., stash@{1}</li>
<li>%gs: reflog subject</li>
<li>%Cred: 切换到红色</li>
<li>%Cgreen: 切换到绿色</li>
<li>%Cblue: 切换到蓝色</li>
<li>%Creset: 重设颜色</li>
<li>%C(...): 制定颜色, as described in color.branch.* config option</li>
<li>%m: left, right or boundary mark</li>
<li>%n: 换行</li>
<li>%%: a raw %</li>
<li>%x00: print a byte from a hex code</li>
<li>%w([<w>[,<i1>[,<i2>]]]): switch line wrapping, like the -w option of git-shortlog(1).</i2></i1></w></li>
</ul>

<p>除此之外， --graph选项可以显示branch的ascii图例。</p>

<p>如果你自己定制了一个喜欢的输出方案，可以保存到git config，或者设置alias以便日后使用。<br>
~/.gitconfig中加入:  </p>

<pre><code>[alias]
    lg = log --graph 
</code></pre>

<p>或者运行：</p>

<pre><code>git config --global alias.lg ""log --graph""
</code></pre>

<p>最后来一个<a rel=""nofollow"" href=""http://www.jukie.net/bart/blog/pimping-out-git-log"">别人分享</a>的例子，稍微有些慢，但是可以看下git log定制效果，效果很酷。。</p>

<pre><code>git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative
</code></pre>

<p>版权信息，转载请注明出处：<a rel=""nofollow"" href=""http://hisea.me"">http://hisea.me</a></p>

                ", 个性化你的Git Log的输出格式,1531978156,427,1,631,1,1,https://segmentfault.com/a/1190000000307435
