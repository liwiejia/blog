ID,已采,已发,pid,content,title,date,view,comment,thumbs,userid,type,PageUrl
1,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1221447?fromSource=waitui"" rel=""nofollow noreferrer"">一步 </a> 发表于<a href=""https://cloud.tencent.com/developer/column/1417?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<h2>介绍</h2>
<p>Apache HTTP服务器是世界上使用最广泛的Web服务器。它提供了许多强大的功能，包括可动态加载的模块，强大的媒体支持以及与其他流行软件的广泛集成。</p>
<p>在本文中，我们将介绍如何在腾讯云Ubuntu 18.04服务器上安装Apache Web服务器。</p>
<h2>必备条件</h2>
<p>在开始本文之前，腾讯云默认使用的是sudo的非root用户。此外，您做起码的还要启动防火墙，屏蔽一些不必要的端口。您可以按照我们<a href=""https://cloud.tencent.com/document/product/213/15377"" rel=""nofollow noreferrer"">腾讯云安全组配置</a>了解如何配置常规用户帐户并为您的服务器设置防火墙。</p>
<p>如果您有可用的帐户，请以非root用户身份登录以开始。</p>
<h2>第一步、安装Apache</h2>
<p>Apache可以在Ubuntu的默认软件存储库中使用，从而可以使用传统的包管理工具进行安装。  </p>
<p>先更新本地的软件包</p>
<pre><code>sudo apt update</code></pre>
<p>然后，安装：<code>apache2</code></p>
<pre><code>sudo apt install apache2</code></pre>
<p>确认安装后，<code>apt</code>将安装Apache和所有必需的依赖项。</p>
<h2>第二步、设置防火墙</h2>
<p>在测试Apache之前，有必要修改防火墙设置，以允许外部能访问默认的Web端口。</p>
<p>在安装过程中，Apache在UFW防火墙注册了自己，以及提供一些应用程序配置文件，这些配置文件可用于启用或禁用通过防火墙访问Apache。</p>
<p>输入以下内容列出应用程序配置ufw</p>
<pre><code>sudo ufw app list</code></pre>
<p>您将看到应用程序配置文件的列表：</p>
<pre><code>OutputAvailable application：
  Apache
  Apache Full
  Apache Secure
  OpenSSH</code></pre>
<p>如您所见，Apache有三种配置文件：</p>
<ul>
<li>Apache：此配置文件仅打开端口80（正常，未加密的Web流量）</li>
<li>Apache Full：此配置文件打开端口80（正常，未加密的Web流量）和端口443（TLS / SSL加密流量）</li>
<li>Apache Secure：此配置文件仅打开端口443（TLS / SSL加密流量）</li>
</ul>
<p>建议您启用限制性最强的配置文件，该配置文件仍要允许您配置的流量。由于我们尚未在本文中为我们的服务器配置SSL，因此我们只需要允许端口80上的流量：</p>
<pre><code>sudo ufw allow 'Apache'</code></pre>
<p>您可以输入以下内容来查看是否修改成功：</p>
<pre><code>sudo ufw status</code></pre>
<p>您应该在显示的输出中看到允许的HTTP流量：</p>
<pre><code>OutputStatus ：active

to                        action      From 
--                        ------      ----
OpenSSH ALLOW Anywhere                  
Apache ALLOW Anywhere                  
OpenSSH  （ v6 ）                ALLOW        Anywhere  （ v6 ）             
Apache  （ v6 ）                 Allow        Anywhere （ v6 ）</code></pre>
<p>如您所见，已经激活的配置文件，已允许访问Web服务器。</p>
<h2>第三步、检查Web服务器</h2>
<p>在安装过程结束时，Apache就会在Ubuntu 18.04运行。Web服务器应该已经启动并运行。</p>
<p>通过输入以下命令检查<code>systemd</code> init 系统以确保服务正在运行：</p>
<pre><code>sudo systemctl status apache2</code></pre>
<pre><code>Output● apache2.service - The Apache HTTP Server
   Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
  Drop-In: /lib/systemd/system/apache2.service.d
           └─apache2-systemd.conf
   Active: active (running) since Tue 2018-04-24 20:14:39 UTC; 9min ago
 Main PID: 2583 (apache2)
    Tasks: 55 (limit: 1153)
   CGroup: /system.slice/apache2.service
           ├─2583 /usr/sbin/apache2 -k start
           ├─2585 /usr/sbin/apache2 -k start
           └─2586 /usr/sbin/apache2 -k start</code></pre>
<p>从此输出中可以看出，该服务似乎已成功启动。但是，最佳的测试方法还是打开Apache的网页。</p>
<p>您可以访问默认的Apache登录页面，以确认软件是否通过您的IP地址正常运行。如果您不知道服务器的IP地址，可以从命令行获得几种不同的方法。</p>
<p>尝试在服务器的命令提示符下输入：</p>
<pre><code>hostname -I</code></pre>
<p>你会得到一些用空格分隔的地址。您可以在Web浏览器中尝试各自以查看它们是否有效。</p>
<p>另一种方法是输入下面这段命令，它应该帮您查到您的IP地址：</p>
<pre><code>curl - 4 icanhazip.COM</code></pre>
<p>获得服务器的IP地址后，将其输入浏览器的地址栏：</p>
<pre><code>http://your_server_ip</code></pre>
<p>您应该看可以到Ubuntu 18.04 Apache的默认页面：  </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015674840?w=745&amp;h=1034"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>small_apache_default</p>
<p>此页面表明Apache正常运行。它还包括有关重要Apache文件和目录位置的一些基本信息。</p>
<h2>第4步 - 管理Apache进程</h2>
<p>现在您已经启动并运行了Web服务器，让我们来看一些基本的管理命令。</p>
<p>要停止Web服务器，请输入：</p>
<pre><code>sudo systemctl stop apache2</code></pre>
<p>要在Web服务器停止时启动它，请输入：</p>
<pre><code>sudo systemctl start apache2</code></pre>
<p>要重启该服务，请输入：</p>
<pre><code>sudo systemctl restart apache2</code></pre>
<p>如果您只是进行配置更改，Apache通常可以在不丢弃连接的情况下重新加载。请使用以下命令：</p>
<pre><code>sudo systemctl reload apache2</code></pre>
<p>在默认情况下，Apache是默认开机启动的。如果不想开机启动，请输入以下命令：</p>
<pre><code>sudo systemctl disable apache2</code></pre>
<p>要重新开机启动Apache，请输入：</p>
<pre><code>sudo systemctl start apache2</code></pre>
<p>Apache现在应该能够开机启动了。</p>
<h2>第五步、设置虚拟主机</h2>
<p>使用Apache Web服务器时，您可以使用虚拟主机（类似于Nginx中的服务器块）来封装配置详细信息，并且可以服务器托管多个域名。我们将设置一个名为example.com的域名，但您应将其替换为您自己的域名。</p>
<p>Ubuntu 18.04上的Apache默认启用了一个服务器块，配置为从 /var/www/html/ 目录中提供文档。虽然这适用于单个站点，但如果您托管多个站点，这就有点困难了。与其修改/var/www/html/，还不如在/var/www/html/ 中为example.com站点内创建一个目录结构，如果客户端请求与任何其他站点不匹配，则将/var/www/html/作为默认的目录。</p>
<p>按如下所示为example.com创建目录，使用<code>-p</code>标志创建必需的父目录：</p>
<pre><code>sudo mkdir - p /var/www/example.com/html</code></pre>
<p>接下来，使用环境变量分配目录的所有权：$USER</p>
<pre><code>sudo chown - R $USER:$USER/var/www/xample.com/html</code></pre>
<p>如果您尚未修改您的值，则您的Web根目录的权限应该是正确的，通过下面的命令来给你的网站打上权限</p>
<pre><code>sudo chmod - R 755 /var/www/example.com</code></pre>
<p>接下来，您可以使用<code>nano</code>来编辑。</p>
<pre><code>nano /var/www/example.com/html/index.html</code></pre>
<p>添加以下代码到 <code>/var/www/example.com/html/index.html</code> 里：</p>
<pre><code>&lt;html&gt; 
    &lt;head&gt; 
        &lt;title&gt;Welcome to Example.com&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
        &lt;h1&gt;Success!  The example.com server block is working!&lt;/h1&gt; 
    &lt;/body&gt; 
&lt;/html&gt;</code></pre>
<p>完成后保存并关闭文件。</p>
<p>为了使Apache能够提供此内容，必须使用正确的指令创建虚拟主机文件。不要直接修改位于<code>/etc/apache2/sites-available/000-default.conf</code>的默认配置文件，而是在以下位置创建一个新文件：<code>/etc/apache2/sites-available/example.com.conf</code></p>
<pre><code>sudosudo nano /etc/apache2/sites-available/example.com.conf</code></pre>
<p>复制下面这段代码到<code>/etc/apache2/sites-available/example.com.conf</code>，并作出相对应的修改</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerAdmin admin@example.com
    ServerName example.com
    ServerAlias www.example.com
    DocumentRoot /var/www/example.com/html
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;</code></pre>
<p>请注意，我们已将<code>DocumentRoot</code>更新为新目录，将<code>ServerAdmin</code>更新为<code>example.com站</code>点管理员可以访问的电子邮件。 我们还添加了两个指令：<code>ServerName</code>它建立了应该与此虚拟主机定义匹配的基本域; <code>ServerAlias</code>它定义了应该匹配的更多名称，就像它们的名称一样。</p>
<p>完成后保存并关闭文件。</p>
<p>让我们使用该工具启用该文件：a2ensite</p>
<pre><code>sudo a2ensite example.com.conf</code></pre>
<p>禁用以下定义的默认站点：000-default.conf</p>
<pre><code>sudo a2dissite 000-default.conf</code></pre>
<p>接下来，让我们测试一下配置是否错误：</p>
<pre><code>sudo apache2ctl configtest</code></pre>
<p>您应该看到以下输出：</p>
<pre><code>OutputSyntax Ok</code></pre>
<p>重启Apache：</p>
<pre><code>sudo systemctl restart apache2</code></pre>
<p>Apache现在应该为您的域名服务。你可以通过导航来测试这个，你应该看到这样的东西：<a href=""http://example.com/"" rel=""nofollow noreferrer"">http://example.com</a>  </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015674841?w=690&amp;h=47"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>example</p>
<h2>第六步、熟悉的Apache文件和目录</h2>
<p>现在您已了解如何管理Apache服务本身，您应该花几分钟时间熟悉一些重要的目录和文件。</p>
<h3>内容</h3>
<ul><li>
<code>/var/www/html</code>：网页包括首页的其他文件都在这个目录下（默认情况下仅包含您之前看到的默认Apache页面）是在<code>/var/www/html</code>这个目录中的。这可以通过更改Apache配置文件来更改。</li></ul>
<h3>服务器配置</h3>
<ul>
<li>
<code>/etc/apache2</code>：Apache配置目录。所有Apache配置文件都驻留在此处。</li>
<li>
<code>/etc/apache2/apache2.conf</code>：主要的Apache配置文件。可以对其进行修改以更改Apache全局配置。该文件负责加载配置目录中的许多其他文件。</li>
<li>
<code>/etc/apache2/ports.conf</code>：此文件指定Apache将侦听的端口。默认情况下，Apache在端口80上侦听，并在启用提供SSL功能的模块时另外侦听端口443。</li>
<li>
<code>/etc/apache2/sites-available/</code>：可以存储所有虚拟主机站点的目录。Apache不会使用此目录中的配置文件，除非它们链接到<code>sites-enabled</code>目录。通常，所有服务器块配置都在此目录中完成，然后通过使用该<code>a2ensite</code>命令链接到其他目录。</li>
<li>
<code>/etc/apache2/sites-enabled/</code>：存储已启用的所有的虚拟主机站点的目录。通常，这些是通过链接到<code>sites-available</code>目录中的配置文件来创建的<code>a2ensite</code>。Apache在启动或重新加载以编译完整配置时读取此目录中的配置文件和链接。</li>
<li>
<code>/etc/apache2/conf-available/</code>，<code>/etc/apache2/conf-enabled/</code>：这些目录与<code>sites-available</code>和目录具有相同的关系<code>sites-enabled</code>，但用于存储不属于虚拟主机的配置片段。<code>conf-available</code>可以使用该<code>a2enconf</code>命令启用目录中的文件，并使用该命令禁用该文件<code>a2disconf</code>。</li>
<li>
<code>/etc/apache2/mods-available/</code>，<code>/etc/apache2/mods-enabled/</code>：这些目录分别包含可用和已启用的模块。带<code>.load</code>结尾的文件，包含用于加载特定模块的片段，而文件以<code>.conf</code>结尾的文件包含这些模块的配置。可以使用<code>a2enmod</code>和<code>a2dismod</code>命令启用和禁用模块。</li>
</ul>
<h3>服务器日志</h3>
<ul>
<li>
<code>/var/log/apache2/access.log</code>：默认情况下，除非将Apache配置为执行其他操作，否则对Web服务器的每个请求都将记录在此日志文件中。</li>
<li>
<code>/var/log/apache2/error.log</code>：默认情况下，所有错误都记录在此文件中。<code>LogLevel</code>：Apache配置中的指令，可以设置错误日志将包含多少详细信息。</li>
</ul>
<p>在Ubuntu 16.04上面搭建Apache网站服务器你学会了嘛？购买一台服务器试试吧：<a href=""https://cloud.tencent.com/product/cvm"" rel=""nofollow noreferrer"">https://cloud.tencent.com/pro...</a></p>
<hr>
<blockquote>
<p>参考文献：《How To Install the Apache Web Server on Ubuntu 18.04》</p>
<p>翻译：黄城浩，审校：Techeek</p>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/85027?fromSource=waitui"" rel=""nofollow noreferrer"">消失存储过程？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1158254?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云CIS入门——Kubernetes部署</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1139703?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云API：用Python使用腾讯云API（机器翻译实例）</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158625?fromSource=waitui"" rel=""nofollow noreferrer"">主机迁移实践分享</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1158260?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">云加社区</a>！</p>

                ", 快速上手：在CVM上安装Apache,1531977830,231,1,535,1,1,https://segmentfault.com/a/1190000015674837
2,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/2276073?fromSource=waitui"" rel=""nofollow noreferrer"">许登博 </a> 发表于<a href=""https://cloud.tencent.com/developer/column/4451?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p>原创声明：本文首发腾讯云·云+社区，未经允许，不得转载</p>
<h1>前言</h1>
<p>存储网络行业协会SNIA（StorageNetworking Industry Association）快照的定义：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。</p>
<p><strong>需要注意的是：快照是完全可用的拷贝，但不是一份完整的拷贝，至于为什么，后面会详细讲。</strong></p>
<h1>存储快照的使用场景</h1>
<p><strong>场景一：</strong></p>
<p>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护，通俗地讲，可以理解为----后悔药。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660529?w=1388&amp;h=275"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上图，假设在t0时刻，有一份完整的源数据，我们在t1时刻，针对这份源数据创建一份快照。</p>
<p>t2时刻，若因为各种原因（误操作、系统错误等）导致源数据损毁，那么，我们可以通过回滚（rollback）快照，将源数据恢复至快照创建时的状态（即t1时刻），这样，可以尽量降低数据损失（损失的数据，是t1到t2之间产生的数据）。</p>
<p>这种功能，常用于银行、公安户籍、科研单位等。操作系统、软件升级或机房设备更替，一般会选择在夜间或其他无生产业务时，进行高危操作，操作前会对数据进行快照，若操作失败，则将快照进行rollback，将源数据恢复至操作前的状态。</p>
<p><strong>场景2：</strong></p>
<p>前言中说过，快照是一份完全可用的副本，那么，它完全可以被上层业务当做源数据。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660530"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上图，针对源数据，创建快照后，将快照卷映射给其他上层业务，可以用于数据挖掘和开发测试等工作，针对快照的读操作不影响源卷的数据。</p>
<p>这种功能，常用于直播（视频&amp;图片）鉴黄、科研数据模拟开发测试等，比如，视频直播平台需要将某一段时间的视频提供给执法机构进行筛查分析，那么可以通过对特定时间点保存的数据创建快照，将快照映射给执法机构的业务主机去进行挖掘分析。</p>
<h1>存储快照的实现原理</h1>
<p>目前，快照的实现方式均由各个厂商自行决定，但主要技术分为2类，一种是写时拷贝COW（Copy On Write），另一种，是写重定向ROW（Redirect On Write）。</p>
<h3>写时拷贝COW</h3>
<p>COW(Copy-On-Write)，写时拷贝，也称为写前拷贝。</p>
<p>创建快照以后，如果源卷的数据发生了变化，那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中，然后再对源卷进行改写。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660531?w=1314&amp;h=789"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>写操作：</strong></p>
<p>如上图简要示例，<strong>快照创建以后</strong>，若上层业务对源卷写数据X，X在缓存中排队，快照系统将X即将写入的位置（逻辑地址）上的数据Y，拷贝到快照卷中对应的位置（逻辑地址）上，同时，生成一张映射表，表中一列记录源卷上数据变化的逻辑地址，另一列记录快照卷上数据变化的逻辑地址。我们可以看到，上层业务每下发一个数据块，存储上，发生了两次写操作：一次是源卷将数据写入快照卷（即图中Y），一次是上层业务将数据写入源卷（即图中X）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660532"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>读操作：</strong></p>
<p>如上图，快照卷若映射给上层业务进行数据分析等用途时，<strong>针对快照</strong>进行读操作时，首先由快照系统判断，上层业务需要读取的数据是否在快照卷中，若在，直接从快照卷读取，若不在，则查询映射表，去对应源卷的逻辑地中读取（这个查表并去源卷读的操作，也叫<strong>读重定向</strong>）。这一点，恰好就解释了为什么快照是一份完全可用的副本，它没有对源卷进行100%的拷贝，但对上层业务来说，却可以将快照看做是和源卷“一模一样”的副本。</p>
<p><strong>针对源卷</strong>进行读操作时，与快照卷没有数据交互。</p>
<p>我们可以看到，快照对源卷的数据具有很好的保护措施，快照可以单独作为一份可以读取的副本，但并没有像简单的镜像那样，一开始就占用了和源卷一样的空间，而是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。</p>
<p><strong>快照回滚（rollback）：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660533?w=1685&amp;h=789"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上图，回滚操作的前提条件是，锁定源卷（暂停对待回滚的逻辑地址上的IO操作），然后通过查映射表，将快照卷上的对应数据回拷到源卷中。</p>
<p><strong>快照删除：</strong></p>
<p>采用COW技术的快照，其源卷即保存着完整的实时数据，因此，删除快照时，直接销毁了快照卷和映射表，与源卷不存在数据交互。</p>
<h3>写时重定向ROW</h3>
<p>ROW(Redirect-on-write )，也称为写时重定向。</p>
<p>创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，直接将新的数据写入快照卷。上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660534?w=1807&amp;h=789"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>写操作：</strong></p>
<p>如上图简要示例，<strong>快照创建以后</strong>，若上层业务对源卷写数据X，X在缓存中排队，快照系统判断X即将写入源卷的逻辑地址，然后将数据X写入快照卷中预留的对应逻辑地址中，同时，将源卷和快照卷的逻辑地址写入映射表，即写重定向。我们可以看到，上层针对源卷写入一个数据块X，存储上只发生一次写操作，只是写之前进行了重定向。</p>
<p><strong>读操作：</strong></p>
<p>若<strong>快照创建以后</strong>，上层业务<strong>对源卷进行读</strong>，则有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么，上层就从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就查询映射表，从快照卷进行读取（即读重定向）。</p>
<p>若<strong>快照创建以后</strong>，上层业务<strong>对快照卷进行读</strong>，同样也有两种情况：1）若读取的数据，在创建快照前产生，数据是保存在源卷上的，那么上层就查询映射表，从源卷进行读取；2）若需要读取的数据是创建快照以后才产生的，那么上层就直接从快照卷进行读取。</p>
<p>我们可以看到，ROW快照也是根据创建快照后上层业务产生的数据，来实时占用必需的存储空间。</p>
<p><strong>快照回滚（rollback）：</strong></p>
<p>采用ROW技术的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中，因此，快照的回滚只是取消了对源卷的读重定向操作。通俗地说，就是源卷上没有进行任何数据操作，上层业务对源卷的读，仅限于读源卷（即不会去读取快照卷的数据）。</p>
<p><strong>快照删除：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660535"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>采用ROW技术的快照，其源卷始终保存着快照创建前的完整数据，快照创建后，上层业务产生的数据都写入了快照中。因此，若要删除快照，必然要先将快照卷中的数据，回拷到源卷中，拷贝完成才能删除，如上图。此时我们可以设想，如果，针对一份源数据，在18:00创建了快照，上层业务持续产生大量新的数据，19:00又创建了快照，20:00又创建了快照……那么，在有多份快照的情况下，如果需要删除快照，就会出现，多个快照向源卷回拷数据的情况，可能导致回拷量非常大，耗时很长。</p>
<h3>两种技术对比</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660536?w=1371&amp;h=763"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上表，COW的写时拷贝，导致每次写入都有拷贝操作，大量写入时，源卷的写性能会有所下降，而读源卷是不会受到任何影响的，删除快照时，只是解除了快照和源卷的关系，同时删除了快照卷的数据而已。ROW在每次写入仅做了重定向操作，这个操作耗时是几乎可以忽略不计的，源卷的写性能几乎不会受到影响，但读源卷时，则需要判断数据是创建快照前还是创建快照后，导致大量读时，性能受到一定影响，比较致命的是，若源卷有多个快照，在删除快照时，所有快照的数据均需要回拷到源卷才可以保证源卷数据的完整性。</p>
<h1>结语</h1>
<p>上面简单地介绍了存储快照的实现原理，实际上，快照特性应用广泛，其应用对象是很多的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015660537"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>目前，主流厂商在自研产品上，对上面的ROW和COW技术都有小范围的改动，也有一些新兴的快照技术已经诞生，但这个行业里，没有最好的快照技术。技术为业务服务，只有针对业务类型做好本地化适配，才能达到最佳效用。</p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/85027?fromSource=waitui"" rel=""nofollow noreferrer"">消失存储过程？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1158254?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云CIS入门——Kubernetes部署</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1139703?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云API：用Python使用腾讯云API（机器翻译实例）</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158625?fromSource=waitui"" rel=""nofollow noreferrer"">主机迁移实践分享</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1158686?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">云加社区</a>！</p>

                ", 快照是什么？揭秘存储快照的实现,1531977832,509,1,726,1,1,https://segmentfault.com/a/1190000015660526
3,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1205757?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯视频云终端团队 </a> 发表于<a href=""https://cloud.tencent.com/developer/column/1812?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<h2>Demo 体验</h2>
<p>升级微信到最新版本，发现页卡 =&gt; 小程序 =&gt; 搜索“腾讯视频云”，即可打开小程序Demo：</p>
<table>
<thead><tr>
<th>功能项</th>
<th>小程序组件</th>
<th>PC端体验页面</th>
<th>依赖的云服务</th>
<th>功能描述</th>
</tr></thead>
<tbody>
<tr>
<td>手机直播</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>N/A</td>
<td>直播+云通讯</td>
<td>演示基于小程序的个人直播解决方案</td>
</tr>
<tr>
<td>PC 直播</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>直播+云通讯</td>
<td>演示课堂直播和学生互动的相关功能（需要 PC 端配合）</td>
</tr>
<tr>
<td>双人通话</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>直播+云通讯</td>
<td>演示双人视频通话功能，可用于在线客服</td>
</tr>
<tr>
<td>多人通话</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>N/A</td>
<td>直播+云通讯</td>
<td>演示多人视频通话功能，可用于临时会议</td>
</tr>
<tr>
<td>WebRTC</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>实时音视频</td>
<td>演示小程序和 Chrome 浏览器的互通能力</td>
</tr>
<tr>
<td>RTMP推流</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>N/A</td>
<td>直播</td>
<td>演示基础的 RTMP 推流功能</td>
</tr>
<tr>
<td>直播播放器</td>
<td><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></td>
<td>N/A</td>
<td>直播</td>
<td>演示基于 RTMP 和 FLV 协议的直播播放功能</td>
</tr>
</tbody>
</table>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>注册小程序并开通相关接口</h2>
<p>出于政策和合规的考虑，微信暂时没有放开所有小程序对 &lt;live-pusher&gt; 和 &lt;live-player&gt; 标签的支持：</p>
<p>个人账号和企业账号的小程序暂时只开放如下表格中的类目：</p>
<table>
<thead><tr>
<th>主类目</th>
<th>子类目</th>
</tr></thead>
<tbody>
<tr>
<td>【社交】</td>
<td>直播</td>
</tr>
<tr>
<td>【教育】</td>
<td>在线教育</td>
</tr>
<tr>
<td>【医疗】</td>
<td>互联网医院，公立医院</td>
</tr>
<tr>
<td>【政务民生】</td>
<td>所有二级类目</td>
</tr>
<tr>
<td>【金融】</td>
<td>基金、信托、保险、银行、证券/期货、非金融机构自营小额贷款、征信业务、消费金融</td>
</tr>
</tbody>
</table>
<p>打开 <a href=""https://mp.weixin.qq.com/"" rel=""nofollow noreferrer"">微信公众平台</a> 注册并登录小程序，并在小程序管理后台的&lt;font color='red'&gt; “设置 - 接口设置” &lt;/font&gt;中自助开通该组件权限，如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015658522"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<blockquote>注意：如果以上设置都正确，但小程序依然不能正常工作，可能是微信内部的缓存没更新，请删除小程序并重启微信后，再进行尝试。</blockquote>
<h2>安装微信小程序开发工具</h2>
<p>下载并安装最新版本的<a href=""https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html"" rel=""nofollow noreferrer"">微信开发者工具</a>，使用小程序绑定的微信号扫码登录开发者工具。</p>
<p>&lt;img style=""border:0; max-width:100%; height:auto; box-sizing:content-box; box-shadow: 0px 0px 0px #ccc; margin: 0px 0px 0px 0px;"" src=""<a href=""https://main.qcloudimg.com/raw/8e1eeee23aec979f346d4b4c05e62571.png&amp;quot"" rel=""nofollow noreferrer"">https://main.qcloudimg.com/ra...</a>; /&gt;</p>
<h2>获取Demo源码并调试</h2>
<ul>
<li>step1: 访问 <a href=""https://cloud.tencent.com/document/product/454/7873#XiaoChengXu"" rel=""nofollow noreferrer"">SDK + Demo</a>，获取小程序 Demo 源码。</li>
<li>step2: 打开安装的微信开发者工具，点击【小程序项目】按钮。</li>
<li>step3: 输入小程序 AppID，项目目录选择上一步下载下来的代码目录（ <strong>注意：</strong> 目录请选择<strong>根目录</strong>，根目录包含有 <code>project.config.json</code>文件，请不要只选择 <code>wxlite</code> 目录！），点击确定创建小程序项目。</li>
<li>step4: 再次点击【确定】进入开发者工具。</li>
<li>step5: 请使用手机进行测试，直接扫描开发者工具预览生成的二维码进入。</li>
<li>step6: &lt;font color='red'&gt;开启调试模式&lt;/font&gt;，体验和调试内部功能。开启调试可以跳过把这些域名加入小程序白名单的工作。</li>
</ul>
<p>&lt;img style=""border:0; max-width:100%; height:auto; box-sizing:content-box; box-shadow: 0px 0px 0px #ccc; margin: 0px 0px 0px 0px;"" src=""<a href=""https://main.qcloudimg.com/raw/c05e7942a54a2ad41ec2066459edb528.png&amp;quot"" rel=""nofollow noreferrer"">https://main.qcloudimg.com/ra...</a>; /&gt;</p>
<h2>Demo访问的测试地址</h2>
<p>Demo小程序会访问如下表格中的测试服务器地址，这些服务器使用的云服务是我们为大家提供的一个体验账号，平时很多客户都会在上面做测试。如果您希望使用自己的后台服务器，以免被其他客户打扰，请关注文档后一节内容：</p>
<ul><li><strong>&lt;live-room&gt; 和 &lt;rtc-room&gt; 相关demo需要访问如下地址：</strong></li></ul>
<table>
<thead><tr>
<th>URL</th>
<th>对应的服务器地址</th>
<th>服务器的功能描述</th>
</tr></thead>
<tbody>
<tr>
<td><code>https://webim.tim.qq.com</code></td>
<td>IM云通讯后台服务地址</td>
<td>用于支持小程序里面的一些消息通讯功能</td>
</tr>
<tr>
<td><code>https://room.qcloud.com</code></td>
<td>RoomService后台服务地址</td>
<td>RoomService 是用于支撑  <span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span> （视频通话）和  [](<a href=""https://mp.weixin.qq.com/)"" rel=""nofollow noreferrer"">https://mp.weixin.qq.com/)</a> （直播连麦）的房间管理逻辑</td>
</tr>
</tbody>
</table>
<ul><li><strong>&lt;webrtc-room&gt; 相关demo需要访问如下地址：</strong></li></ul>
<table>
<thead><tr>
<th>URL</th>
<th>对应的服务器地址</th>
<th>服务器的功能描述</th>
</tr></thead>
<tbody>
<tr>
<td><code>https://webim.tim.qq.com</code></td>
<td>IM云通讯后台服务地址</td>
<td>用于支持小程序里面的一些消息通讯功能</td>
</tr>
<tr>
<td>
<code>https://yun.tim.qq.com/v4/</code> <code>openim/jsonvideoapp</code>
</td>
<td>WebRTC测试后台</td>
<td>用于请求进入<span class=""img-wrap""><img data-src=""/img/remote/1460000015658521?w=1363&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span> 所需的 userSig 和 privateMapKey</td>
</tr>
<tr>
<td>
<code>https://xzb.qcloud.com/webrtc/</code> <code>weapp/webrtc_room</code>
</td>
<td>WebRTC房间列表后台</td>
<td>一个简单的房间列表功能，方便Demo的测试和使用。</td>
</tr>
</tbody>
</table>
<h2>搭建自己的账号和后台服务器</h2>
<p>这部分我们将介绍如何将Demo默认的测试用服务器地址，换成您自己的服务器，这样一来，您就可以使用自己的腾讯云账号实现上述功能，同时也便于您进行二次开发。</p>
<h4>1. 搭建 &lt;webrtc-room&gt; 的服务器</h4>
<h5>1.1 这个服务器能做什么？</h5>
<ul>
<li>点击demo里的互动课堂 <strong>&lt;webrtc-room&gt;</strong> 功能，您会看到一个房间列表，这个房间列表是怎么实现的呢？</li>
<li>在看到视频房间列表以后，如果你要创建一个视频房间，或者进入一个其他人建好的视频房间，就需要为 [](<a href=""https://cloud.tencent.com/document/product/454/16914)"" rel=""nofollow noreferrer"">https://cloud.tencent.com/doc...</a> 所对应的几个属性（<code>sdkAppID</code>、<code>userID</code>、<code>userSig</code>、<code>roomID</code> 和 <code>privateMapKey</code>）传递合法的参数值，这几个参数值怎么获取呢？</li>
</ul>
<h5>1.2 这个服务器要怎么搭建？</h5>
<ul><li>下载 <a href=""https://github.com/TencentVideoCloudMLVBDev/webrtc_server_java"" rel=""nofollow noreferrer"">webrtc_server</a> ，这是一份 java 版本的实现，根据 README.md 中的说明就可以了解怎么使用这份源码。</li></ul>
<h5>1.3 服务器建好了我怎么用？</h5>
<ul>
<li>
<a href=""https://github.com/TencentVideoCloudMLVBDev/MiniProgram"" rel=""nofollow noreferrer"">小程序</a> 源码中，将 <code>wxlite/config.js</code> 文件中的 <code>webrtcServerUrl</code> 修改成：<a href=""https://%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/webrtc/weapp/webrtc_room"" rel=""nofollow noreferrer"">https://您自己的域名/webrtc/w...</a>
</li>
<li>小程序实现 WebRTC 能力肯定是为了跟 Chrome 浏览器进行视频通话，浏览器端的源代码可以点击 <a href=""https://github.com/TencentVideoCloudMLVBDev/webrtc_pc"" rel=""nofollow noreferrer"">Chrome(src)</a> 下载到，将 <code>component/WebRTCRoom.js</code> 文件中的<code>serverDomain</code>修改成：<a href=""https://%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/webrtc/weapp/webrtc_room"" rel=""nofollow noreferrer"">https://您自己的域名/webrtc/w...</a>
</li>
</ul>
<h4>2. 搭建 &lt;live-room&gt; 和 &lt;rtc-room&gt; 的服务器</h4>
<h5>2.1 这个服务器能做什么？</h5>
<ul><li>[](<a href=""https://cloud.tencent.com/document/product/454/15368)"" rel=""nofollow noreferrer"">https://cloud.tencent.com/doc...</a> （用于直播连麦）和 [](<a href=""https://cloud.tencent.com/document/product/454/15364)"" rel=""nofollow noreferrer"">https://cloud.tencent.com/doc...</a> （用于视频通话）都是基于腾讯云 LVB 和 IM 两个基础服务实现的扩展功能，需要一个叫做 RoomService 的后台组件配合才能运行。</li></ul>
<h5>2.2 这个服务器要怎么搭建？</h5>
<ul><li>下载 <a href=""https://github.com/TencentVideoCloudMLVBDev/rtcroom_server_java"" rel=""nofollow noreferrer"">RoomService</a> 的 java 版本源代码，根据 README.md 中的说明就可以了解怎么使用这份源码。</li></ul>
<h5>2.3 服务器建好了我怎么用？</h5>
<ul>
<li>
<a href=""https://github.com/TencentVideoCloudMLVBDev/MiniProgram"" rel=""nofollow noreferrer"">小程序</a> 源码中，将 <code>wxlite/config.js</code> 文件中的 <code>serverUrl</code>和 <code>roomServiceUrl</code> 修改成：<a href=""https://%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/roomservice/"" rel=""nofollow noreferrer"">https://您自己的域名/roomserv...</a>
</li>
<li>小程序如果使用 &lt;live-room&gt; 和 &lt;rtc-room&gt; 两个标签，在 PC 端就不能用 Chrome 浏览器配对了，需要改用 <a href=""https://cloud.tencent.com/document/product/454/17004"" rel=""nofollow noreferrer"">WebEXE</a> 混合解决方案。将 <a href=""https://github.com/TencentVideoCloudMLVBDev/webexe_web"" rel=""nofollow noreferrer"">GitHub(WebEXE)</a> 源码中 liveroom.html、double.html文件中的<code>RoomServerDomain</code>修改成:<a href=""https://%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/roomservice/"" rel=""nofollow noreferrer"">https://您自己的域名/roomserv...</a>
</li>
</ul>
<h4>3. Wafer 零成本服务器部署方案 （Node.js）</h4>
<p>如果您是一位资深的 Web 前端工程师，暂时找不到合适的服务器，但又想快速拥有自己的调试后台，可以使用腾讯云的 Wafer 功能进行零成本的一键部署方案（Wafer 只支持 Node.js 语言的后台代码），您需要你做的只是：</p>
<ul>
<li>step1: 下载 <a href=""https://github.com/TencentVideoCloudMLVBDev/MiniProgram"" rel=""nofollow noreferrer"">小程序</a> 源码。</li>
<li>step2: 根据<a href=""https://github.com/TencentVideoCloudMLVBDev/RTCRoomDemo/blob/master/doc/%25E4%25B8%2580%25E9%2594%25AE%25E9%2583%25A8%25E7%25BD%25B2_NodeJS.md"" rel=""nofollow noreferrer"">一键部署指引</a>完成部署。</li>
<li>step3: 将 <a href=""https://github.com/TencentVideoCloudMLVBDev/webexe_web"" rel=""nofollow noreferrer"">GitHub(WebEXE)</a> 源码中 liveroom.html、double.html文件中的<code>RoomServerDomain</code>修改成:<a href=""https://%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/roomservice/"" rel=""nofollow noreferrer"">https://您自己的域名/roomserv...</a>
</li>
</ul>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/126750?fromSource=waitui"" rel=""nofollow noreferrer"">小程序码测试？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1158021?fromSource=waitui"" rel=""nofollow noreferrer"">【转】腾讯云 API 3.0实践分享</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158234?fromSource=waitui"" rel=""nofollow noreferrer"">彭磊：TencentHub的架构实现</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158503?fromSource=waitui"" rel=""nofollow noreferrer"">MySQL 8.0 版本功能变更介绍</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1153619?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">云加社区</a>！</p>

                ", 教你从0到1搭建小程序音视频,1531977834,565,1,479,1,1,https://segmentfault.com/a/1190000015658517
4,1,0,9,"
                    
<p>一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。</p>
<h1>1、基本语法</h1>
<p>这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作 用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满 意，因为能看出你非常热衷研究技术。<br>最深入的一次，我记得面试官直接问到了我Volatile关 键字的底层实现原理(顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对 公司的好感，我最终选择的就是问了这个问题的公司)，不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。</p>
<h1>2、集合</h1>
<p>非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。<br>集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、 HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一 句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap， 我给网友朋友们提供三点回答或者是研究方向：<br>(1)ConcurrentHashMap的锁分段技术。<br>(2)ConcurrentHashMap的读是否要加锁，为什么。<br>(3)ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器。</p>
<h1>3、框架</h1>
<p>老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean 的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习 框架的使用细节自然都不成问题。<br>如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。我遇到的最变态的是让我画一下Spring的Bean工厂实 现的UML图，当然面对这样一个有深度的问题，我是答不出来的</p>
<h1>4、数据库</h1>
<p>数据库十有八九也都会问到。一些基本的像和 all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门 把SQL基础和SQL优化的内容准备一下。<br>不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。</p>
<h1>5、Web方面的一些问题</h1>
<p>Java主要面向Web端，因此Web的一些问题也是必问的。<br>我碰到过问得最多的两个问题是：<br>谈谈分布式Session的几种实现方式。(大家可以聊下你们知道的实现方法)<br>常用的四种能答出来自然是让面试官非常满意的。<br>另外一个常问的问题是：讲一下Session和Cookie的区别和联系以及Session的实现原理。这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。</p>
<h1>6、数据结构和算法分析</h1>
<p>数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较 重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和 我聊到了数据库的索引，他问我：你知道索引使用的是哪种数据结构实现吗?<br>我答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗?我答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面 前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了 为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢?<br>至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了 显示我的博学，对算法分析也有一定的研究(⊙﹏⊙)b，我还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下 Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。</p>
<h1>7、Java虚拟机</h1>
<p>出乎我的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，我去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与较佳实践》，我就读了不下五遍。<br>言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，我就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容：<br>(1)Java虚拟机的内存布局<br>(2)GC算法及几种垃圾收集器<br>(3)类加载机制，也就是双亲委派模型<br>(4)Java内存模型<br>(5)happens-before规则<br>(6)volatile关键字使用规则<br>也许面试无用，但在走向大牛的路上，不可不会。</p>
<h1>8、设计模式</h1>
<p>本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。<br>当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向：<br>(1)你的项目中用到了哪些设计模式，如何使用。<br>(2)知道常用设计模式的优缺点。<br>(3)能画出常用设计模式的UML图。</p>
<h1>9、多线程</h1>
<p>这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联 系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同。<br>说到这里顺便给大家推荐一个架构交流学习群：650385180，本文所罗列的技术点在群里面都有针对性的文档资料，里面也会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。最主要的是这些资料都是提供给大家免费下载的，这些只是技术知识点可能暂时用不到，但如果是打算走技术这条路线的话肯定都是要接触和涉及的，所以相信在这个群里会有你需要的内容。<br>总结起来是 这么一个意思：<br>假如有Thread1、Thread2、ThreaD3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现?<br>聪明的网友们对这个问题是否有答案呢?不难，java.util.concurrent下就有现成的类可以使用。(大家可以留言讨论下用的什么方法实现)<br>另外，线程池也是比较常问的一块，常用的线程池有几种?这几种线程池之间有什么区别和联系?线程池的实现原理是怎么样的?实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。<br>最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、 synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等。</p>
<h1>10、JDK源码</h1>
<p>要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。我面试过程中被问了不 少JDK源码的问题，其中最刁钻的一个问了我，String的hashCode()方法是怎么实现的，幸好我平时String源代码看得多，答了个大 概。<br>JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：<br>(1)List、Map、Set实现类的源代码<br>(2)ReentrantLock、AQS的源代码<br>(3)AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的<br>(4)线程池的实现原理<br>(5)Object类中的方法以及每个方法的作用<br>这些其实要求蛮高的，我去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。<br>最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。</p>

                ", 一名3年工作经验的java程序员应该具备的职业技能,1531977836,583,1,998,1,1,https://segmentfault.com/a/1190000015654304
5,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/667013?fromSource=waitui"" rel=""nofollow noreferrer"">织云平台团队 </a> 发表于<a href=""https://cloud.tencent.com/developer/column/1056?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648477?w=760&amp;h=508"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>2018世界杯鏖战正酣，在国内看直播的小伙伴想必也看得很过瘾，那么国内的小伙伴是如何收看到流畅、清晰的直播呢？腾讯视频云直播平台作为助力本次世界杯国内直播的重要PaaS平台，期待给大家带来优质的体验。下面我将从全球节点分布建设、智能路由、动态加速、混合云管理以及质量监控上报等方面来详细介绍我们是如何保障将数据在全球网络上高效稳定的传输。</p>
<p><strong>修路（全球节点覆盖）</strong></p>
<p>有句话说得好，“要想富，先修路”，其实对于我们的直播平台同样适用，要想提供优质的服务质量，把‘车’开得又稳又快，首先要有高速的‘路’, 但是要想修好路也不是一件容易的事。</p>
<p><strong>首先需要考虑如下问题：</strong></p>
<p>•  海外国家+城市成千上万，节点该建在哪里 </p>
<p>• 如何做到花更少的钱，做更好的事，平衡质量和成本</p>
<p><strong>从这些方面来应对：</strong></p>
<p>• 基于公有云厂商以及客户需求分布</p>
<p>• 综合考虑政策成本质量等因素来调整调度分布策略，eg：</p>
<p><strong>中东地区：</strong></p>
<p>首先迪拜被选覆盖点，但是接入质量不是特别理想，因为迪拜是一个有GFW防火墙的国家，目前只是将迪拜覆盖本地，接下来我们会在卡塔尔或者伊朗选点覆盖中东。</p>
<p><strong>印度和印尼地区：</strong></p>
<p>不仅国际出口不稳定，带宽成本更是其他地区的好几倍，所以目前只选择覆盖本地。</p>
<p><strong>澳大利亚地区：</strong></p>
<p>各大云厂商主流在悉尼和墨尔本等。</p>
<p>目前我们已经建成了了包括香港，新加坡，韩国，泰国，印度，德国，俄罗斯，美西/美东，加拿大等10大海外独立中心节点， 以及全球5大洲40多个上行加速节点：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648478?w=1034&amp;h=519"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>选路（全网动态调度）</strong></p>
<p>有了全球节点覆盖， 我们还应该意识到<strong>就近不一定最优</strong>， 所以还需要选路，实施全网动态调度，保障用户能够通过最短路径传输到源站，原理如图： </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648479?w=751&amp;h=447"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>1</p>
<p><strong>如何选取最优接入点？</strong> </p>
<p>海外不像国内，运营商和地区要复杂得多，首先解析要准确，美国需要解析到美国，最好能具体识别到洲，越细粒度越好，美东不能接入到美西去。我们采用腾讯GSLB全球IP地址库，可以精确到地区解析，质量较直接按国家级别来调度有很大提升，以美国地区为例：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>同时，通过大数据分析拨测各个边缘节点的质量，以便分配最优的点给到用户。</p>
<p>2</p>
<p><strong>如何选取最优传输路径？</strong> </p>
<p>在智能路由，全网调度方面又应该如何考量？大家都知道公网的网络经常波动，节点的容量和故障也都会影响传输质量， 所以一套能够帮助大家实时分析当前路由、链路质量、以及节点负载容量情况的路由质量评测系统就非常有必要了： </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648481"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>然后根据分析结果实时干预，实现全网智能调度：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648482"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>修车（协议优化）</strong></p>
<p>有了高速公路，以及最优路线图，我们还需要有一俩性能优秀的‘车’，可以从如下几个方面来改装优化，帮助其加速：</p>
<p>• 基于TCP RFC的用户态协议栈(保留公平性、友好性)</p>
<p>• 全链路加密，保证数据安全</p>
<p>• 多路复用（无Head-of-line blocking）</p>
<p>• RTT握手+秘钥协商</p>
<p>• 平滑发送（Pacing mechanism）</p>
<p>• 精准RTT测量。基于NACK的丢包发现</p>
<p>• TCP优化</p>
<p>• 连接无缝迁移</p>
<p>使用基于UDP的QUIC协议比使用标准的RTMP协议推流卡顿率更小，尤其是在网络丢包较大时, 卡顿率依然保持不变：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648483?w=587&amp;h=430"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648484"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>织云混合云管理</strong></p>
<p>前面说到“修路”，“修车”的问题，作为一个多面手的运维Sir，我们还需要保障这些不同国家和地区运营商的“路”能够统一升级、维护、有统一的运营标准。这里就是接下来我们要说到的混合云管理，那么当前混合云有哪些场景和各自的优缺点呢？ </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648485?w=825&amp;h=545"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>同时，这么多的云场景，给运维人员也带来了很多挑战，比如：</p>
<p>• <strong>机器环境不统一问题</strong></p>
<p>1 操作系统不一样</p>
<p>2 网卡命名不统一</p>
<p>3 内网IP冲突</p>
<p>• <strong>数据无法上报问题</strong></p>
<p>1 单机属性上报</p>
<p>2 多维属性上报分析</p>
<p>3 一致性上报</p>
<p>• <strong>业务部署发布问题</strong></p>
<p>1 程序装包和更新</p>
<p>2 配置下发</p>
<p>3 文件下发</p>
<p>• <strong>安全风险问题</strong></p>
<p>1 外网ssh开放</p>
<p>2 登录、shell审计</p>
<p>3 入侵检测</p>
<p>• <strong>网络质量问题</strong></p>
<p>1 跨网丢包延时大</p>
<p>2 网络抖动</p>
<p>3 监控告警</p>
<p>• <strong>运维其他操作问题</strong></p>
<p>1 防火墙修改</p>
<p>2 主机名修改</p>
<p>3 命令执行</p>
<p>4 文件传输</p>
<p>为了解决这些问题， 腾讯织云混合云解决方案是这样设计的：</p>
<p>1、功能设计：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648486?w=1080&amp;h=589"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>2、整体架构：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648487?w=1080&amp;h=571"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>腾讯视频云直播海外节点由多个云环境组成，包括腾讯云，腾讯自研环境、其他合作伙伴云厂商等，通过使用织云混合云管理方案，已实现混合云环境的自动化运维。比如包发布功能，全球节点一键发布：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648488"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在接到本次俄罗斯世界杯的紧急需求时，也能游刃有余的提供优质的服务。</p>
<p><strong>织云海外节点监控上报方案</strong></p>
<p>解决了上面的问题， 还需要解决各个节点的数据上报、网络链路监控告警等问题，如下：</p>
<p><strong>1、如何及时发现和跟踪海外各个节点的数据是否异常：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648489?w=930&amp;h=532"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>2、基于链路的网络质量监控系统：</strong></p>
<p>• 使用基于链路调度的监控方式来上报质量 </p>
<p>• 将网络丢包、延时等监控数据入库大数据分析网络情况，给到调度系统决策最优路径 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648490?w=718&amp;h=743"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015648491"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>小结</strong></p>
<p>通过前面的分析，我们可以看出，为了帮助用户实现告诉稳定的传输，首先在用户到边缘节点这里要全球部署，精准调度；其次，在加速节点之间要能智能选路，全网动态调度，协议优化；最后，在加速节点到原站这里，还要同城同运营商部署、智能选取最优出口。做到以上三段加速，基本上大家的海外运维之路已经迈开脚步了。</p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/123213?fromSource=waitui"" rel=""nofollow noreferrer"">使用<em>nlp</em>进行句子压缩？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1155113?fromSource=waitui"" rel=""nofollow noreferrer"">内行看门道：看似“佛系”的《QQ炫舞手游》，背后的音频技术一点都不简单</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158541?fromSource=waitui"" rel=""nofollow noreferrer"">2018世界杯用户行为新趋势洞察报告</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158064?fromSource=waitui"" rel=""nofollow noreferrer"">低于0.01%的极致Crash率是怎么做到的？</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1153388?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">云加社区</a>！</p>

                ", 看世界杯直播？海外运维实践了解一下,1531977837,229,1,682,1,1,https://segmentfault.com/a/1190000015648474
6,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1002332?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云数据库 TencentDB  </a> 发表于<a href=""https://cloud.tencent.com/developer/column/1551?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p>作者介绍：李明，腾讯云数据库架构师华南区负责人，曾在某专业数据库服务商、51job任职DBA。</p>
<h1>一、概述</h1>
<p>​       风险无处不在，包括自然灾害以及突发事件等，有时候我们无法预测到一些风险，比如天津港爆炸事件。IT领域也一样，总是有意想不到的事情，风险具有不可预测性，万全之策就是做好灾难应对的各种准备。</p>
<p>​      随着云计算如火如茶的进行，IT资源可进行快速部署，弹性扩容及超高的性价比，这对于我们创建本地IDC机房数据库容灾提供极大的便利性。如何利用云数据库做容灾成为DBA的基本功。</p>
<p>当前腾讯云已对外提供的腾讯云数据库（TencentDB）产品：</p>
<ul>
<li>关系型数据库：云数据库 MySQL、云数据库 MariaDB、云数据库 SQL Server、云数据库 PostgreSQL</li>
<li>云数据库 Redis</li>
<li>云数据库 MongoDB</li>
<li>分布式数据库</li>
<li>云数据库 Memcached</li>
<li>云数据库 HBase</li>
</ul>
<p>​         下文以腾讯云数据库 MySQL为例，介绍如何充分利用腾讯云的优势，减轻DBA的负担，轻松来搭建数据库（MySQL）的：同城同区灾备、同城不同区灾备、跨地域灾备。</p>
<h1>二、当前TencentDB所支持的架构部署</h1>
<p>​      针对业务连续服务和数据可靠性有强需求或是监管需要的场景，用户在购买云数据库 MySQL 时会默认提供灾备实例，帮助用户以较低的成本提升业务连续服务的能力，同时提升数据的可靠性。</p>
<h2>同地域同可用区部署</h2>
<p>​      云数据库 MySQL同可用区部署架构示意图</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644609?w=496&amp;h=436"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>云数据库MySQL 普通实例架构(同个可用区)</p>
<h2>同地域不同可用区部署</h2>
<p>​     云数据库 MySQL 同城灾备实例架构</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644610?w=451&amp;h=437"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>云数据库 MySQL 同城灾备实例架构（不同可用区）</p>
<p>​     说明：腾讯云数据库多可用区部署目前仅支持深圳金融专区，其他可用区的支持还在规划中。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644611"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>跨地域部署</h2>
<p>​      云数据库 MySQL 异地灾备实例架构</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644612"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>云数据库 MySQL 异地灾备实例架构</p>
<h1>三、构建云上灾备环境</h1>
<p>​       通过上面的介绍，我们基本了解云数据库 MySQL的架构，接下来我们来说说本地IDC的数据库怎么迁移到TencentDB上并建立同步关系。</p>
<p>第一步：首先确定本地IDC如何与腾讯云建立通信。</p>
<p>1、通过专线的方式；</p>
<p><a href=""https://cloud.tencent.com/document/product/216/541"" rel=""nofollow noreferrer"">https://cloud.tencent.com/doc...</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644613?w=533&amp;h=175"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>2、通过vpn的方式；</p>
<p><a href=""https://cloud.tencent.com/document/product/215/4956"" rel=""nofollow noreferrer"">https://cloud.tencent.com/doc...</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644614?w=618&amp;h=177"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>第二步：拉取本地IDC数据至云上，并建立同步关系。</p>
<p>1、创建DTS（数据传输服务）同步任务,这里假设CDB实例已申请购买完毕。</p>
<p>操作步骤：</p>
<p>新建 DTS 数据迁移服务</p>
<p>登录控制台，进入数据迁移页面，单击【新建任务】，输入相关信息及本地IDC实例的信息</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644615"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>选择目标实例实例，点击保存</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644616"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>选择同步类型，这里需要选【全量+增量数据迁移】，即一直与本地IDC的数据库保持同步关系</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015644617?w=554&amp;h=485"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/126750?fromSource=waitui"" rel=""nofollow noreferrer"">自适应数据库？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1158021?fromSource=waitui"" rel=""nofollow noreferrer"">【转】腾讯云 API 3.0实践分享</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158234?fromSource=waitui"" rel=""nofollow noreferrer"">彭磊：TencentHub的架构实现</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158503?fromSource=waitui"" rel=""nofollow noreferrer"">MySQL 8.0 版本功能变更介绍</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1158589?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">云加社区</a>！</p>

                ", 本地IDC机房数据库容灾解决方案,1531977839,155,1,402,1,1,https://segmentfault.com/a/1190000015644606
7,1,0,9,"
                    
<p>今天遇到一个关于PHP 嵌套使用条件运算符(<em>ternary expressions</em>)的问题</p>
<h2>现象</h2>
<p>先来看一段C语言代码(<strong>test.c</strong>):</p>
<pre><code>#include&lt;stdio.h&gt;
int main() {
  int x = 1;
  int shit = x == 1 ? 100 : 
     x == 2 ? 200 : 300;
  printf(""shit的值:%d\n"", shit);
  return 0;
}</code></pre>
<p>编译后运行一下</p>
<pre><code>root$ gcc test.c -o test &amp;&amp; ./test
shit的值:100</code></pre>
<p>答案在意料之中，因为x==1，所以100被赋值给shit。</p>
<p>但是如果我们用PHP重写一下上文的代码(<strong>test.php</strong>):</p>
<pre><code>&lt;?php
$x = 1;
$shit = $x == 1 ? 100 : 
   $x == 2 ? 200 : 300;
echo ""shit的值:$shit\n"";</code></pre>
<p>执行一下:</p>
<pre><code>root$ php test.php
shit的值:200</code></pre>
<p>我们发现返回的结果不一样了，这是为什么呢？</p>
<h2>排查</h2>
<p>首先怀疑可能是PHP中<strong>比较运算符</strong>(==)和<strong>条件运算符</strong>(?:)的优先级问题，我们查看一下<a href=""http://php.net/manual/en/language.operators.precedence.php"" rel=""nofollow noreferrer"">PHP官方文档</a><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015634599"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>==</strong>的优先级比<strong>?:</strong>更高(C语言也是这样)，所以</p>
<pre><code>$shit = $x == 1 ? 100 : 
   $x == 2 ? 200 : 300;</code></pre>
<p>等效于</p>
<pre><code>$shit = ($x == 1) ? 100 : 
   ($x == 2) ? 200 : 300;</code></pre>
<p>执行一遍也确实如此，可以排除掉是运算符优先级导致问题的可能性了。</p>
<p>但是<a href=""http://php.net/manual/en/language.operators.precedence.php"" rel=""nofollow noreferrer"">官方文档</a>里关于<strong>运算符结合方向</strong>的举例说明中出现了这么一句话：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015634600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>这跟上文描述的现象很相似，问题应该就在这了。一番查阅之后得到以下结论:</p>
<h2>结论</h2>
<ul><li>C语言的条件运算符(?:)的结合方向是<strong>从右往左</strong>，每次求值都是从最右边的子表达式开始算起，所以</li></ul>
<pre><code>int x = 1;

int shit = x == 1 ? 100 : 
     x == 2 ? 200 : 300;
//等效于
int shit = x == 1 ? 100 : 
     (x == 2 ? 200 : 300);
//等效于
int shit = x == 1 ? 100 : 
     (300);// 100</code></pre>
<ul><li>PHP的条件运算符(?:)的结合方向是<strong>从左往右</strong>，每次求值都是从最左边的子表达式开始算起，所以</li></ul>
<pre><code>$x = 1;
$shit = $x == 1 ? 100 : 
   $x == 2 ? 200 : 300;
//等效于
$shit = ($x == 1 ? 100 : 
   $x == 2) ? 200 : 300;
//等效于
$shit = (100) ? 200 : 300;// 200</code></pre>
<p><strong>介于PHP的条件运算符结合方向，我们无法像C/C++那样 通过嵌套条件运算符来达到if-elseif-elseif-else表达式的效果</strong>，除非我们在靠后的子表达式中加上括号，本例中就可以靠这种方式解决:</p>
<pre><code>$shit = $x == 1 ? 100 : 
   ($x == 2 ? 200 : 300);</code></pre>
<p>但在条件分支较多的情况下，就会出现代码可读性问题(堆积括号):</p>
<pre><code>$shit = $x == 1 ? 100 :
     ($x == 2 ? 200 :
     ($x== 3 ? 300 :
     ...
     ($x == 8 ? 800 : 900)))))));</code></pre>
<p>由于PHP不堆积括号的写法与C/C++在执行结果上是不一致的，并且只能通过加括号改变默认的结合方向 以达到预期的结果，所以PHP文档里干脆不建议嵌套使用条件运算符:</p>
<blockquote>Note:<br>It is recommended that you avoid ""stacking"" ternary expressions. PHP's <br>behaviour when using more than one ternary operator within a single statement is non-obvious</blockquote>
<h2>参考资料</h2>
<p><a href=""http://php.net/manual/en/language.operators.comparison.php#language.operators.comparison.ternary"" rel=""nofollow noreferrer"">PHP: Ternary Operator - Manual</a><br><a href=""http://php.net/manual/en/language.operators.precedence.php"" rel=""nofollow noreferrer"">PHP: Operator Precedence - Manual</a><br><a href=""https://stackoverflow.com/questions/20559150/ternary-operator-left-associativity"" rel=""nofollow noreferrer"">php - Ternary operator left associativity - Stack Overflow</a><br><a href=""https://stackoverflow.com/questions/6224330/understanding-nested-php-ternary-operator/6224398"" rel=""nofollow noreferrer"">Understanding nested PHP ternary operator - Stack Overflow</a><br><a href=""https://zh.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">C 运算符优先级- cppreference.com</a></p>

                ", PHP条件运算符的“坑”,1531977841,561,1,972,1,1,https://segmentfault.com/a/1190000015634596
8,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1024461?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯游戏云</a>发表于<a href=""https://cloud.tencent.com/developer/column/1349?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p>3月14日，腾讯旗下知名手游《QQ炫舞》正式上线各大应用商店，并迅速登上App Store免费游戏总榜第一位。作为一代玩家的青春记忆，早在游戏发布前，《QQ炫舞》手游全渠道预约人数就已突破2000W，其火爆程度不亚于腾讯旗下两款吃鸡手游。</p>
<p><strong>实时语音房间内高清音乐播放，腾讯音频技术解决业内难题</strong></p>
<p>《QQ炫舞》手游由端游原班人马打造，产品的核心体验与端游版本一致。此外，《QQ炫舞》手游还推出了弹珠模式、游戏音乐房间内实时语音等多种独创玩法。然而在创新的同时也带来了一些音频技术上的难题：比如游戏房间内支持高清背景音乐播放，开启实时语音后如何确保播放音乐效果的高音质，同时做到说话声音清晰且避免回音等。</p>
<p>游戏语音多应用在实时语音、多人会话、发送语音消息等场景，而《QQ炫舞》手游的游戏音乐房间内实时语音玩法在音频处理上的复杂度上远远超出了正常范畴。正常情况下，玩家在实时语音房间中启用电话音量模式，由于手机系统的回声消除、降噪模块的影响，房间内播放音乐音质会明显降低。玩家在实时语音房间中使用媒体音量模式播放高清音乐的同时，需要确保实时语音清晰并且避免回声。</p>
<p>这些技术难题对于《QQ炫舞》手游来说，无疑是一项重量级挑战。腾讯音视频实验室提供的游戏多媒体引擎GME（Game Multimedia Engine）作为游戏音乐房间内多人实时语音的解决方案，使得《QQ炫舞》手游呈现出的效果超乎预期：</p>
<p><a href=""https://v.qq.com/x/page/s0709emc7lh.html"" rel=""nofollow noreferrer"">https://v.qq.com/x/page/s0709...</a></p>
<p>视频内容</p>
<p>从视频可以看到，玩家在游戏音乐房间内实时语音时，使用手机的媒体音量（而非电话音量），绕过了手机系统的音频处理模块，播放效果达到QQ音乐一样的高清播放体验。当玩家说话时，说话声 “彼此隔离”，使每个声源都可以清晰呈现，且在混合发声时也不存在嘈杂感和回声，极大程度地提升玩家在游戏房间内播放音乐时的实时语音聊天体验。</p>
<p>对此，腾讯音视频实验室的技术专家们解释说：“这得益于GME强大音乐播放器能力，将背景音乐与实时语音完美融合。我们充分考虑到使用手机媒体音量模式的高清音乐播放效果，与房间内多人实时交流时产生的回声、噪声的影响，通过自研的高音质回声消除、噪声抑制处理技术，在保证游戏房间内音乐高音质播放的同时，减少回声、噪声对交流的影响。”</p>
<p>基于自研、优秀的高音质回声抵消技术，GME能保证玩家在多人实时语音场景下听清每个人说话的声音，且不会发生人声被剪切的情况。更富创意的是，如果玩家在其他玩家说话时，还能切换成电台的duking效果，提升观众与发声者的声音体验。</p>
<p>除此之外，GME的一些“看不见”的能力也为玩家所称道，比如为玩家提供30ms级别的超低延时耳返；此外，由于游戏音乐房间内实时语音场景对网络传输要求更高，对弱网、抗抖动的要求也更加苛刻，GME也很好地满足了这些需求。</p>
<p><strong>GME攻克音频难点，为游戏提供一站式游戏语音解决方案</strong></p>
<p>GME产品有着成熟的音频处理经验，特别在基础性能方面，已为400多个产品提供了音频技术支持，技术在业内可谓遥遥领先。GME支持语音开黑、休闲游戏等不同场景，在不同场景下提供不同的音质体验和不同的抗网络损伤技术，力求给用户带来最佳的游戏体验。实时语音音质在网络无损的场景下的平均MOS分达到4.38（满分5分），平均延时低于200ms；通过先进的丢包恢复技术、丢包补偿算法以及优秀的网络抗性，即使在50%以上丢包、1000ms的网络抖动下，也能保持顺畅的沟通和很好的音质。</p>
<p>对于游戏玩家很关心的流量消耗和CPU占用问题，GME也做了相应优化，例如MOBA类游戏中，在保证正常的语音沟通和良好的性能前提下，移动网络模式每分钟流量消耗低于500KB，CPU占用率平均在10%以下等。</p>
<p>值得一提的是，GME自研的3D实时语音技术，利用HRTF 算法对双耳之间的时间差异和频谱差异建立人耳获取声音模型，将无方位感的声音处理成带有声源方位感的声音，从而虚拟出空间中任意位置的声源对人耳造成的感觉。这种技术可以应用在“吃鸡”和棋牌类游戏场景上，通过提供听声辨位的能力，让玩家获得更好的游戏体验。</p>
<p>凭借语音效果好、接入门槛低的方案特点，GME覆盖了休闲社交类、MOBA类、MMORPG等多种游戏类型，提供实时语音、语音消息、语音转文本等功能。如今，通过针对游戏类型、游戏场景的深度优化，GME积累了深厚的技术底蕴，同时通过覆盖超过400+游戏产品的技术支持，不断积累技术经验，为玩家打造畅爽的游戏语音体验，展示了领先业内的技术实力。</p>
<p>游戏多媒体引擎GME 已正式登陆腾讯云，为广大游戏厂商开发者提供服务，详细信息可浏览：<a href=""https://cloud.tencent.com/product/tmg?idx=1"" rel=""nofollow noreferrer"">https://cloud.tencent.com/pro...</a></p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/45162?fromSource=waitui"" rel=""nofollow noreferrer"">HTML 5音频循环？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1158029?fromSource=waitui"" rel=""nofollow noreferrer"">【视频】云API实践教程（上）</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158070?fromSource=waitui"" rel=""nofollow noreferrer"">iOS Push详述，了解一下？</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1158054?fromSource=waitui"" rel=""nofollow noreferrer"">我们用超火的几款手游和应用助您提前了解Andriod P Beta 2的兼容性问题</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1155113?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong> </p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在云加社区！ <a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>

                ", 内行看门道：看似“佛系”的《QQ炫舞手游》，背后的音频技术一点都不简单,1531977842,209,1,724,1,1,https://segmentfault.com/a/1190000015600642
9,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1003483?fromSource=waitui"" rel=""nofollow noreferrer"">云计算小编 </a>发表于<a href=""https://cloud.tencent.com/developer/column/2305?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a><p>《QQ 炫舞手游》是腾讯游戏推出的音舞类游戏。据App Annie 数据显示， 自发布以来《QQ 炫舞手游》一直保持音舞类游戏排名第1，深受广大玩家欢迎。《QQ 炫舞手游》的一大特色玩法就是游戏内的K 歌功能， 玩家可以通过休闲大厅创建K 歌房， 选择伴奏进行K 歌。游戏多媒体引擎GME 的高音质、低延时及强网络抗性，为《QQ 炫舞手游》的音乐听感和K 歌效果提供了良好的支持。 GME 可以保证玩家在房间内播放背景音乐的同时， 实时语音沟通依然清晰流畅；当有玩家在房间内实时K 歌时， 听众听到的K歌效果也能保持极高的音质和极低的延时， 提供了良好的线上K 歌体验。那么，《QQ 炫舞手游》背后的音视频到底是什么呢？今天这篇文章将揭开音视频的神秘面纱。</p>
</blockquote>
<h2>腾讯音视频实验室</h2>
<p>说到音频，就不得不说腾讯音视频实验室了，腾讯音视频实验室，成立于2010年，八年间专注于音视频通信技术的前瞻性研究，包括全球实时音视频网络优化、音视频编解码前沿算法研究、计算机视觉图像处理、基于AI的音频语音增强、声音美化及音视频质量评测等。在服务于腾讯社交体系下的海量用户同时，在实时音视频通信、图像处理和音视频处理等技术领域积累了十几年的研究经验，拥有行业领先的技术水平。目前已为行业数百个产品提供了音视频技术支持与服务，如QQ电话、腾讯云、企业微信、QQ空间、全民K歌、快手、斗鱼、虎牙、蘑菇街等。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585605?w=960&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>游戏实时语音解决方案 GME</h2>
<p>游戏多媒体引擎（Game Multimedia Engine，简称：GME）是一个专门针对游戏场景定制的游戏多媒体引擎 SDK，支持休闲社交类、竞技游戏类（包括 MMORPG、MOBA、FPS 等类型）、大型国战等多种游戏类型，提供了包括多人实时语音、实时视频、语音消息、语音转文本等功能。 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585606?w=960&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>功能介绍</h3>
<h4>实时语音</h4>
<p><strong>麦序模式</strong></p>
<p>用户轮流语音上麦，音质高流畅性好，适用于语音狼人杀等场景。</p>
<p><strong>自由通话模式</strong></p>
<p>支持多人同时讲话，超低延迟，适用于多人组队开黑等竞技游戏场景。</p>
<p><strong>指挥模式</strong></p>
<p>针对一对多指挥作战、主播语音陪玩等场景，适合大型国战类游戏。</p>
<h4>语音消息和语音识别</h4>
<p>支持录制语音消息发送到游戏各频道并实时转换为文本消息这功能，音质清晰，语音识别准确率高。</p>
<h2>产品优势</h2>
<table>
<thead><tr>
<th>我们的优势</th>
<th>为什么选择腾讯云游戏多媒体引擎</th>
</tr></thead>
<tbody>
<tr>
<td><strong>游戏场景定制</strong></td>
<td>针对游戏场景对音视频编解码器进行深度优化，使其在码率、延时、系统资源消耗等关键技术指标达到业界领先</td>
</tr>
<tr>
<td><strong>顶级基础设施</strong></td>
<td>自建万兆云机房，配备 20 线 BGP 顶级网络，800+ 节点让玩家畅享稳定而极速的体验</td>
</tr>
<tr>
<td><strong>专业网络接入</strong></td>
<td>复用 QQ 接入部署和调度策略，有效解决弱网络环境下的连通问题，连通率高达 99.995%</td>
</tr>
<tr>
<td><strong>超强服务承载</strong></td>
<td>承载 QQ 服务支撑能力，支持亿级用户在线，亿级群数规模；实时监控，异地容灾，智能调度，保证服务安全可靠</td>
</tr>
<tr>
<td><strong>超低接入门槛</strong></td>
<td>通用游戏框架全覆盖，四行代码极速接入</td>
</tr>
<tr>
<td><strong>功能完善全面</strong></td>
<td>提供游戏场景常用功能：多人语音、实时视频、语音消息、语音转文本等多种功能</td>
</tr>
</tbody>
</table>
<h3>GME 超低接入门槛</h3>
<p>为方便开发者接入腾讯云游戏多媒体引擎产品，这里向您介绍适用于游戏多媒体引擎 SDK 的接入指引。</p>
<h4>使用 GME 有以下五个步骤：</h4>
<ol>
<li>
<a href=""https://cloud.tencent.com/document/product/607/10782#.E6.96.B0.E5.BB.BA.E6.9C.8D.E5.8A.A1"" rel=""nofollow noreferrer"">在腾讯云后台新建 GME 服务</a>;</li>
<li>
<a href=""https://cloud.tencent.com/document/product/607/10782#.E4.B8.8B.E8.BD.BD-sdk"" rel=""nofollow noreferrer"">下载对应版本的客户端 SDK</a>;</li>
<li>
<a href=""https://cloud.tencent.com/document/product/607/10782#.E7.9B.B8.E5.85.B3-sdk-.E6.8A.80.E6.9C.AF.E6.96.87.E6.A1.A3"" rel=""nofollow noreferrer"">参照接入 API 文档， 将 SDK 移植到工程</a>;</li>
<li>
<a href=""https://cloud.tencent.com/document/product/607/10782#.E6.8E.A7.E5.88.B6.E5.8F.B0.E7.94.A8.E9.87.8F.E7.BB.9F.E8.AE.A1"" rel=""nofollow noreferrer"">查看日常运营后台统计</a>;</li>
<li>
<a href=""https://cloud.tencent.com/document/product/607/10782#.E7.89.B9.E6.AE.8A.E9.97.AE.E9.A2.98.E5.A4.84.E7.90.86"" rel=""nofollow noreferrer"">接入过程中特殊问题自主排除与反馈</a>;</li>
</ol>
<h4>接入 SDK</h4>
<p>接入 SDK 需要使用腾讯云提供的 appid 及相关权限密钥。即应用管理列表中的 AppID 及 应用设置中的鉴权信息模块。</p>
<ul>
<li>接入实时语音时候会使用鉴权信息模块中的权限密钥。</li>
<li>接入离线语音时候会使用鉴权信息模块中的下载的公私钥。</li>
</ul>
<p>更多平台相关配置请参考各平台工程配置文档。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585607?w=960&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>GME 应用场景</h3>
<h4>电子竞技</h4>
<p>在电子竞技类游戏中，争斗局势瞬息万变，相同阵营的玩家之间，需要根据战局实时沟通对敌策略。通过腾讯云实现的超低时延、流畅优先的实时游戏语音自由对讲，可以帮助玩家间更好的进行沟通，体会对战游戏的乐趣。</p>
<h4>国战游戏</h4>
<p>国战游戏中的典型代表为 MMORPG，此类游戏中涉及团队副本、组队、帮派、国战指挥等多种玩法，对语音的时延要求也较高，腾讯云游戏多媒体引擎针对此类场景，实现实时自动上下麦及超低时延语音通话，高度适配超多人在线的国战类游戏玩家语音通话需求。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585608?w=960&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h4>休闲游戏</h4>
<p>在棋牌、K 歌、音乐等休闲类的游戏中，语音消息与语音对讲也是必不可少的需求，同时，部分休闲类游戏中，会有美女主播为玩家播放歌曲，或者通过歌曲伴奏进行 K 歌游戏。腾讯云提供的实时音视频能力保证了好友之间实时聊天沟通，同时提供包括耳返、变声的趣味化能力，保证最佳的休闲游戏体验。</p>
<h4>狼人杀</h4>
<p>目前，桌游类游戏狼人杀已经从传统的饭局延伸到了互联网，在狼人杀游戏中，玩家在开始前热场寒暄，在进行中按顺序发言，在结束后，盘点和回顾，这些环节，都离不开实时语音乃至视频的交互。腾讯云游戏多媒体引擎产品提供画面清晰度与音质优先的实时音视频服务，针对狼人杀场景特别定制，满足玩家所有音视频交互需求。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585609"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>基于语音的游戏内创新娱乐玩法</h2>
<h3>GME 支持基于位置的3D实时语音</h3>
<p>2017年一款游戏《绝地求生：大逃杀》，通过创新的百人大逃杀、胜者吃鸡玩法，短时间获得了全球玩家的青睐和追捧。除了游戏玩法本身的创意之外，游戏对于实时语音玩法也进行了颠覆式创新。<strong>游戏过程中玩家可以设置【全体模式】向附近的玩家喊话、挑衅、搭讪，</strong>这种语音模式可以与陌生人进行很有趣的沟通和互动。社交媒体上已经有很多用户基于这种语音模式，创作了很多趣味视频。</p>
<p><strong>而引入3D位置语音之后，玩家在喊话过程中会暴露自己的方位和位置信息，玩家的声音也会根据位置变化而实时改变。可以说，3D音效让《大逃杀》这种玩家间的沟通和战斗体验更真实，感受更加沉浸式、更加身临其境的吃鸡玩法。</strong></p>
<p>我们的3D音效技术，就是利用“头部关联传输函数”（HRTF 算法），对双耳之间的时间差异和频谱差异进行建模，形成有声源方位感的声音。同时我们还通过采样混响填补HRIR缺失的环境反射声，从而构建完整的声场模型。比如在一个小房间里，不仅可以听到两个人之间的对话，还可以听到声音从墙壁中反射的效果，增加沉浸感。 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585610?w=960&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>GME 支持游戏内K歌体验，提供变声趣味玩法</h3>
<p>《QQ炫舞》手游由端游原班人马打造，产品的核心体验与端游版本一致。此外，《QQ炫舞》手游还推出了弹珠模式、游戏内实时K歌房等多种独创玩法。然而在创新的同时也带来了一些音频技术上的难题：比如K歌时人声、伴奏与歌词的对齐，K歌场景下多人同时语音时，如何做到声音清晰且避免回音等。 </p>
<p>游戏语音多应用在实时语音、多人会话、发送语音消息等场景，而《QQ炫舞》手游的实时K歌玩法在音频处理上的复杂度上远远超出了正常范畴。正常情况下，玩家在K歌过程中，是听到伴奏之后再演唱，声音由麦克风收录后再输出。但由于游戏场景中系统采集播放模块存在延时，尤其是Android系统机型多、采集播放延时大等因素的影响，如果仅按照正常模式来进行合成，会出现明显的人声、伴奏和歌词不对齐的情况。一旦出现这种情况，再美妙的天籁歌声也会变成“车祸现场”，给玩家带来非常糟糕的游戏体验。 </p>
<p>这些技术难题对于《QQ炫舞》手游来说，无疑是一项重量级挑战。腾讯音视频实验室提供的游戏多媒体引擎GME（Game Multimedia Engine）作为游戏内K歌玩法和多人实时语音的解决方案，使得《QQ炫舞》手游呈现出的效果超乎预期： </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015585611"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>凭借语音效果好、接入门槛低的方案特点，GME覆盖了休闲社交类、MOBA类、MMORPG等多种游戏类型，提供实时语音、语音消息、语音转文本等功能。如今，通过针对游戏类型、游戏场景的深度优化，GME积累了深厚的技术底蕴，同时通过覆盖超过400+游戏产品的技术支持，不断积累技术经验，为玩家打造畅爽的游戏语音体验，展示了领先业内的技术实力。 </p>
<p><strong>游戏多媒体引擎 GME产品概述：</strong><a href=""https://cloud.tencent.com/document/product/607/10835"" rel=""nofollow noreferrer""><strong>https://cloud.tencent.com/document/product/607/10835</strong></a></p>
<p><strong>游戏多媒体引擎 GME接入指引：</strong><a href=""https://cloud.tencent.com/document/product/607/10782"" rel=""nofollow noreferrer""><strong>https://cloud.tencent.com/document/product/607/10782</strong></a></p>
<p><strong>游戏多媒体引擎 GME SDK文档：</strong><a href=""https://cloud.tencent.com/document/product/607/15232"" rel=""nofollow noreferrer""><strong>https://cloud.tencent.com/document/product/607/15232</strong></a></p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/123492?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云服务器？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1155295?fromSource=waitui"" rel=""nofollow noreferrer"">游戏人工智能 读书笔记（十一）游戏内容生成</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1152688?fromSource=waitui"" rel=""nofollow noreferrer"">游戏人工智能 读书笔记（八）游戏与强化学习</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1152119?fromSource=waitui"" rel=""nofollow noreferrer"">游戏人工智能 读书笔记 （七） 游戏与监督学习</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1157948?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong> </p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在云加社区！ <a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>

                ", 腾讯云游戏多媒体解决方案,1531977844,188,1,831,1,1,https://segmentfault.com/a/1190000015585602
10,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1205757?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯视频云终端团队 </a>发表于<a href=""https://cloud.tencent.com/developer/column/1812?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<h1>第一步 登录腾讯云官网，开通<a href=""https://console.cloud.tencent.com/video/license"" rel=""nofollow noreferrer"">短视频控制台</a>，申请license</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015583977?w=1432&amp;h=950"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>第二步  工程配置iOS或者Android</h1>
<p>工程配置iOS</p>
<h2>Xcode Project Settings</h2>
<h3>I. Supported Platform</h3>
<ul><li>SDK supports iOS 8.0 or above.</li></ul>
<h3>II. Development Environment</h3>
<ul>
<li>Xcode 8 or above</li>
<li>OS X 10.10 or above</li>
</ul>
<h3>III. Xcode Project Settings</h3>
<p>A simple iOS Application project is shown below to illustrate how to configure SDK in an Xcode project.</p>
<h3>1. Copy SDK File</h3>
<p>In this example, an iOS project named HelloSDK is created, and the downloaded <code>TXLiteAVSDK_UGC.framework</code> is copied to the project directory. The figure below shows the directory structure.</p>
<h3>2. Add Framework</h3>
<p>Add <code>TXLiteAVSDK_UGC.framework</code> to the project. At the same time, add the following dependent libraries:</p>
<blockquote>libz.tbd<p>Accelerate.framework </p>
<p>Bugly.framework</p>
</blockquote>
<p>After you've added the above libraries, the project dependency shows as follows:</p>
<h3>3. Add Header File</h3>
<p>Add the search path for header file to ""Build Settings"" -&gt; ""Search Paths"" -&gt; ""User Header Search Paths"". Please note that this operation is not required. If you do not add the header file search path for TXLiteAVSDK_UGC, ""TXLiteAVSDK_UGC/"" needs to be added before the SDK-related header file when the header file is referenced, as shown below:</p>
<pre><code>#import ""TXLiteAVSDK_UGC/TXUGCRecord.h""</code></pre>
<h3>IV. Verification</h3>
<p>Next, call the SDK API in the codes of HelloSDK to obtain SDK version information and verify whether the project is correctly configured.</p>
<h3>1. Reference the Header File</h3>
<p>Reference the SDK header file at the beginning of ViewController.m:</p>
<pre><code>#import ""TXLiteAVSDK_UGC/TXLiveBase.h""</code></pre>
<h3>2. Add Calling Code</h3>
<p>Add the following code to the viewDidLoad method:</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Print SDK version information
    NSLog(@""SDK Version = %@"", [TXLiveBase getSDKVersionStr]);
}</code></pre>
<h3>3. Compile and Run</h3>
<p>If all of the above steps are performed correctly, the HelloSDK project can be compiled successfully. Run the App in the Debug mode. SDK version information is output in Xcode's Console pane.</p>
<blockquote>2017-09-26 16:16:15.767 HelloSDK17929:7488566 SDK Version = 3.4.1761</blockquote>
<p>Now, the project configuration is completed.</p>
<h2>Printing LOG</h2>
<p>Configure whether to print log in the console and set the log level in TXLiveBase. Codes are described as follows:</p>
<ul>
<li>
<strong>setConsoleEnabled</strong> Configure whether to print the output of SDK in the Xcode console.</li>
<li>
<strong>setLogLevel</strong> Configure whether to allow SDK to print local log. By default, SDK writes log to the <strong>Documents/logs</strong> folder of the current App. For technical support, you are recommended to enable the sub-switch and provide the log file after a problem occurs. Thank you for your support.</li>
<li>
<strong>View log file</strong> To reduce the storage volume of logs, Mini LVB SDK encrypts the log files stored locally and limits the number of logs. Therefore, you need to use the log <a href=""http://dldir1.qq.com/hudongzhibo/log_tool/decode_mars_log_file.py"" rel=""nofollow noreferrer"">Decompression Tool</a> to view the text content of log.</li>
</ul>
<pre><code>[TXLiveBase setConsoleEnabled:YES];
[TXLiveBase setLogLevel:LOGLEVEL_DEBUG];</code></pre>
<p>工程配置Android</p>
<h2>1. System Requirement</h2>
<p>SDK can run on Android 4.0.3 (API 15) or above. However, hardware encoding can be enabled only on Android 4.3 (API 18) or above.</p>
<h2>2. Development Environment</h2>
<p>SDK development environment is described below. The App development environment does not need to be consistent with that of SDK, but it must be compatible with:</p>
<ul>
<li>Android NDK: android-ndk-r12b</li>
<li><p>Android SDK Tools: android-sdk_25.0.2</p></li>
<li><ul>
<li>minSdkVersion: 15</li>
<li>targetSdkVersion: 21</li>
</ul></li>
<ul><li>Android Studio (Android Studio is recommended, but you can also use Eclipse + ADT)</li></ul>
</ul>
<h2>3. Integration Guide (aar)</h2>
<h3>3.1 New Project</h3>
<h3>3.2 Copy Files</h3>
<p>Put the aar package under the project libs directory</p>
<h3>3.3 Project Configuration</h3>
<ul>
<li>Add the code that references aar package to build.gradle under the project app directory:dependencies {       <p>​       compile fileTree(dir: 'libs', include: ['*.jar'])       </p>
<p>​       // Import the short video SDK aar       </p>
<p>​       compile(name: 'LiteAVSDK_UGC_3.4.1757', ext: 'aar')  </p>
<p>}</p>
</li>
<li>Add flatDir to build.gradle under the project directory, and specify the local library in it:allprojects {<p>​       repositories {</p>
<p>​           jcenter()</p>
<p>​           flatDir {</p>
<p>​               dirs 'libs'</p>
<p>​           }</p>
<p>​       }</p>
<p>}</p>
</li>
<li>Specify ndk-compatible architecture in defaultConfig of build.gradle under the project directory:   defaultConfig {<p>​         applicationId ""com.tencent.liteav.demo""</p>
<p>​         minSdkVersion rootProject.ext.minSdkVersion</p>
<p>​         targetSdkVersion rootProject.ext.targetSdkVersion</p>
<p>​         versionCode 1</p>
<p>​         versionName ""2.0"" </p>
<p>​         ndk {</p>
<p>​             abiFilters ""armeabi"", ""armeabi-v7a""</p>
<p>​         }</p>
<p>​     }</p>
</li>
<li>Finally, compile Rebuild Project.</li>
</ul>
<h2>4 Integration Guide (jar)</h2>
<h3>4.1 Library Description</h3>
<p>Decompress LiteAVSDK_UGC_3.4.1757.zip to get the libs directory, which mainly includes a jar file, as shown below:</p>
<table>
<thead><tr>
<th>jar file</th>
<th>Description</th>
</tr></thead>
<tbody><tr>
<td>liteavsdk.jar</td>
<td>Mini LVB SDK android core library</td>
</tr></tbody>
</table>
<p>For library related to the upload of short videos, jar files and a so file for uploading short videos can be found in the <strong>Demoapplibs</strong> directory, as shown below:</p>
<table>
<thead><tr>
<th>jar file</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>sha1utils.jar</td>
<td>JAR package that implements SHA calculation of files to be uploaded. This component is used for short video upload (TXUGCPublish) feature</td>
</tr>
<tr>
<td>cos-sdk-android.1.4.3.11.jar</td>
<td>File upload package of Tencent Cloud COS. This component is used for short video upload (TXUGCPublish) feature</td>
</tr>
<tr>
<td>okio-1.6.0.jar</td>
<td>An excellent open source network I/O component</td>
</tr>
<tr>
<td>okhttp-3.2.0.jar</td>
<td>An excellent open source HTTP component</td>
</tr>
</tbody>
</table>
<table>
<thead><tr>
<th>so file</th>
<th>Description</th>
</tr></thead>
<tbody><tr>
<td>libTXSHA1.so</td>
<td>JAR package that implements SHA calculation of files to be uploaded. This component is used for short video upload (TXUGCPublish) feature</td>
</tr></tbody>
</table>
<h3>4.2 Copy Files</h3>
<p>If no jni loading path is previously specified in your project, we recommend that you put the jar package and so library under the <strong>/src/main/jniLibs</strong> directory, which is the default jni loading directory of android studio.</p>
<h3>4.3. Project Configuration</h3>
<p>Add the code that references jar package and so library to build.gradle under the project app directory:</p>
<pre><code>dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    // Import Tencent Cloud LVB SDK jar
    compile fileTree(dir: 'src/main/jniLibs', includes: ['*.jar'])
}</code></pre>
<h2>5. Configure App Permissions</h2>
<p>Configure App permissions in AndroidManifest.xml. Generally, video Apps require the following permissions:</p>
<pre><code>&lt;uses-permission android:name=""android.permission.INTERNET"" /&gt;
&lt;uses-permission android:name=""android.permission.ACCESS_NETWORK_STATE"" /&gt;
&lt;uses-permission android:name=""android.permission.ACCESS_WIFI_STATE"" /&gt;
&lt;uses-permission android:name=""android.permission.READ_PHONE_STATE"" /&gt;
&lt;uses-permission android:name=""android.permission.CALL_PHONE""/&gt;
&lt;uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE""/&gt;
&lt;uses-permission android:name=""android.permission.READ_LOGS"" /&gt;
&lt;uses-permission android:name=""android.permission.RECORD_AUDIO"" /&gt;
&lt;uses-permission android:name=""android.permission.CAMERA"" /&gt;
&lt;uses-feature android:name=""android.hardware.Camera""/&gt;
&lt;uses-feature android:name=""android.hardware.camera.autofocus"" /&gt;</code></pre>
<h2>6. Verify</h2>
<p>Call the SDK API in the project to get SDK version information and verify whether the project is correctly configured.</p>
<h3>6.1 Reference SDK</h3>
<p>Reference the class of SDK in MainActivity.java:</p>
<pre><code>import com.tencent.rtmp.TXLiveBase;</code></pre>
<h3>6.2 Call API</h3>
<p>Call the API getSDKVersioin in onCreate to get version number:</p>
<pre><code>String sdkver = TXLiveBase.getSDKVersionStr();
Log.d(""liteavsdk"", ""liteav sdk version is : "" + sdkver);</code></pre>
<h3>6.3 Compile and Run</h3>
<p>The demo project can be compiled successfully if all of the above steps are correctly performed. If you run the project, you can see the following log information in logcat:</p>
<p><code>09-26 19:30:36.547 19577-19577/ D/liteavsdk: liteav sdk version is : 3.4.1757</code></p>
<p><a> </a></p>
<h2>7. Print LOG</h2>
<p>Configure whether to print log in the console and set the log level in TXLiveBase. Codes are described as follows:</p>
<ul>
<li>
<strong>setConsoleEnabled</strong> Configure whether to print the output of SDK in the Android Studio console.</li>
<li>
<strong>setLogLevel</strong> Configure whether to allow SDK to print local log. By default, SDK writes log to the <strong>log / tencent / liteav</strong> folder on sdcard. For technical support, you are recommended to enable the switch and provide the log file after a problem occurs. Thank you for your support.</li>
<li>
<strong>View log file</strong> To reduce the storage volume of logs, Mini LVB SDK encrypts the log files stored locally and limits the number of logs. Therefore, you need to use the log <a href=""http://dldir1.qq.com/hudongzhibo/log_tool/decode_mars_log_file.py"" rel=""nofollow noreferrer"">Decompression Tool</a> to view the text content of log.</li>
</ul>
<pre><code>TXLiveBase.setConsoleEnabled(true);
TXLiveBase.setLogLevel(TXLiveConstants.LOG_LEVEL_DEBUG);</code></pre>
<h2>8. Troubleshooting</h2>
<h3>8.1 Compilation</h3>
<p>If the following errors occur when you compile/run the project after importing the SDK into it:</p>
<pre><code>Caused by: android.view.InflateException: 
Binary XML file #14:Error inflating class com.tencent.rtmp.ui.TXCloudVideoView</code></pre>
<p>Find the problem by following the steps below:</p>
<ul>
<li>Check whether you have placed the jar package and so library into the jniLibs directory.</li>
<li>If you are using the full version of aar integration mode, check whether the x64 ""so"" library has been filtered out in defaultConfig of build.gradle under the project directory. This is because the acoustic component library used by the joint broadcasting feature in full version does not support mobile phones with x64 architecture at the moment. defaultConfig {<p>​         applicationId ""com.tencent.liteav.demo""</p>
<p>​         minSdkVersion rootProject.ext.minSdkVersion</p>
<p>​         targetSdkVersion rootProject.ext.targetSdkVersion</p>
<p>​         versionCode 1</p>
<p>​         versionName ""2.0""</p>
<p>​          ndk { </p>
<p>​            abiFilters ""armeabi"", ""armeabi-v7a""</p>
<p>​         }</p>
<p>}</p>
</li>
<li>Check the proguard rules to confirm that the SDK-related package names have been added to the non-proguard list.-keep class com.tencent.<em>* { </em>; }</li>
</ul>
<h3>8.2 Short Video Publishing</h3>
<p>After a file is published, no error message or callback response is returned. The following appears when the log is printed:</p>
<pre><code> TaskManager: ExecutionException</code></pre>
<p>This is because the libTXSHA1.so used for upload has not been properly integrated into the project. For more information, please see <a href=""https://cloud.tencent.com/document/product/584/11631#4-.E9.9B.86.E6.88.90.E6.94.BB.E7.95.A5.EF.BC.88jar.EF.BC.89"" rel=""nofollow noreferrer"">Integration Guide</a>.</p>
<h1>第三步  完成工程配置后，可进行【视频录制】功能的集成</h1>
<p>如果你是iOS开发，可参考<a href=""https://cloud.tencent.com/document/product/584/9367"" rel=""nofollow noreferrer"">视频录制（iOS）</a></p>
<p>如果你是Android开发，可参考<a href=""https://cloud.tencent.com/document/product/584/9369"" rel=""nofollow noreferrer"">视频录制（Android）</a></p>
<h1>第四步  完成【视频录制】功能的集成后，可继续集成【视频剪辑】功能</h1>
<p>如果你是iOS开发，可参考<a href=""https://cloud.tencent.com/document/product/584/9375"" rel=""nofollow noreferrer"">视频编辑（iOS）</a></p>
<p>如果你是Android开发，可参考<a href=""https://cloud.tencent.com/document/product/584/9502"" rel=""nofollow noreferrer"">视频编辑（Android）</a></p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/123492?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云服务器？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1153619?fromSource=waitui"" rel=""nofollow noreferrer"">教你从0到1搭建小程序音视频</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1153618?fromSource=waitui"" rel=""nofollow noreferrer"">教你快速搭建一场发布会直播方案</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1148326?fromSource=waitui"" rel=""nofollow noreferrer"">移形换影 - 短视频色彩特效背后的故事</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1153620?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在云加社区！ <a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>

                ", 教你1天搭建自己的“微视”,1531977846,546,1,516,1,1,https://segmentfault.com/a/1190000015583974
11,1,0,9,"
                    
<h2>0 索引</h2>
<blockquote><ul>
<li>
<strong>JOIN</strong>语句的执行顺序</li>
<li>
<strong>INNER/LEFT/RIGHT/FULL JOIN</strong>的区别</li>
<li>
<strong>ON</strong>和<strong>WHERE</strong>的区别</li>
</ul></blockquote>
<h2>1 概述</h2>
<p>一个完整的SQL语句中会被拆分成多个子句，子句的执行过程中会产生虚拟表(vt)，但是结果只返回最后一张虚拟表。从这个思路出发，我们试着理解一下JOIN查询的执行过程并解答一些常见的问题。<br>如果之前对不同JOIN的执行结果没有概念，可以结合<a href=""https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins"" rel=""nofollow noreferrer"">这篇文章</a>往下看</p>
<h2>2 JOIN的执行顺序</h2>
<p>以下是JOIN查询的通用结构</p>
<pre><code>SELECT &lt;row_list&gt; 
  FROM &lt;left_table&gt; 
    &lt;inner|left|right&gt; JOIN &lt;right_table&gt; 
      ON &lt;join condition&gt; 
        WHERE &lt;where_condition&gt;</code></pre>
<p>它的执行顺序如下<strong>(SQL语句里第一个被执行的总是FROM子句)</strong>：</p>
<ul>
<li>
<strong>FROM</strong>:对左右两张表执行笛卡尔积，产生第一张表vt1。行数为n*m（n为左表的行数，m为右表的行数</li>
<li>
<strong>ON</strong>:根据ON的条件逐行筛选vt1，将结果插入vt2中</li>
<li>
<strong>JOIN</strong>:添加外部行，如果指定了<strong><em>LEFT JOIN</em></strong>(<strong><em>LEFT OUTER JOIN</em></strong>)，则先遍历一遍<strong>左表</strong>的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为<strong><em>NULL</em></strong>，形成vt3；如果指定了<strong><em>RIGHT JOIN</em></strong>也是同理。但如果指定的是<strong><em>INNER JOIN</em></strong>，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以<strong><em>INNER JOIN</em></strong>的过滤条件放在<strong><em>ON</em></strong>或<strong><em>WHERE</em></strong>里 执行结果是没有区别的，下文会细说）</li>
<li>
<strong>WHERE</strong>:对vt3进行条件过滤，满足条件的行被输出到vt4</li>
<li>
<strong>SELECT</strong>:取出vt4的指定字段到vt5</li>
</ul>
<p>下面用一个例子介绍一下上述联表的过程（这个例子不是个好的实践，只是为了说明join语法）</p>
<h2>3 举例</h2>
<p>创建一个用户信息表：</p>
<pre><code>CREATE TABLE `user_info` (
  `userid` int(11) NOT NULL,
  `name` varchar(255) NOT NULL,
  UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</code></pre>
<p>再创建一个用户余额表：</p>
<pre><code>CREATE TABLE `user_account` (
  `userid` int(11) NOT NULL,
  `money` bigint(20) NOT NULL,
 UNIQUE `userid` (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</code></pre>
<p>随便导入一些数据：</p>
<pre><code>select * from user_info;
+--------+------+
| userid | name |
+--------+------+
|   1001 | x    |
|   1002 | y    |
|   1003 | z    |
|   1004 | a    |
|   1005 | b    |
|   1006 | c    |
|   1007 | d    |
|   1008 | e    |
+--------+------+
8 rows in set (0.00 sec)

select * from user_account;
+--------+-------+
| userid | money |
+--------+-------+
|   1001 |    22 |
|   1002 |    30 |
|   1003 |     8 |
|   1009 |    11 |
+--------+-------+
4 rows in set (0.00 sec)</code></pre>
<p>一共8个用户有用户名，4个用户的账户有余额。<br><strong>取出userid为1003的用户姓名和余额，SQL如下</strong>：</p>
<pre><code>SELECT i.name, a.money 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON i.userid = a.userid 
        WHERE a.userid = 1003;</code></pre>
<h4>第一步：执行FROM子句对两张表进行笛卡尔积操作</h4>
<p>笛卡尔积操作后会返回两张表中所有行的组合，左表user_info有8行，右表user_account有4行，生成的虚拟表vt1就是8*4=32行：</p>
<pre><code>SELECT * FROM user_info as i LEFT JOIN user_account as a ON 1;
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1001 |    22 |
|   1003 | z    |   1001 |    22 |
|   1004 | a    |   1001 |    22 |
|   1005 | b    |   1001 |    22 |
|   1006 | c    |   1001 |    22 |
|   1007 | d    |   1001 |    22 |
|   1008 | e    |   1001 |    22 |
|   1001 | x    |   1002 |    30 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1002 |    30 |
|   1004 | a    |   1002 |    30 |
|   1005 | b    |   1002 |    30 |
|   1006 | c    |   1002 |    30 |
|   1007 | d    |   1002 |    30 |
|   1008 | e    |   1002 |    30 |
|   1001 | x    |   1003 |     8 |
|   1002 | y    |   1003 |     8 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   1003 |     8 |
|   1005 | b    |   1003 |     8 |
|   1006 | c    |   1003 |     8 |
|   1007 | d    |   1003 |     8 |
|   1008 | e    |   1003 |     8 |
|   1001 | x    |   1009 |    11 |
|   1002 | y    |   1009 |    11 |
|   1003 | z    |   1009 |    11 |
|   1004 | a    |   1009 |    11 |
|   1005 | b    |   1009 |    11 |
|   1006 | c    |   1009 |    11 |
|   1007 | d    |   1009 |    11 |
|   1008 | e    |   1009 |    11 |
+--------+------+--------+-------+
32 rows in set (0.00 sec)</code></pre>
<h4>第二步：执行ON子句过滤掉不满足条件的行</h4>
<p>ON i.userid = a.userid  过滤之后vt2如下：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+</code></pre>
<h4>第三步：JOIN 添加外部行</h4>
<p><strong>LEFT JOIN</strong>会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，<strong>RIGHT JOIN</strong>同理<br>本例中用的是<strong>LEFT JOIN</strong>，所以会将左表<strong>user_info</strong>剩下的行都添上 生成表vt3：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+</code></pre>
<h4>第四步：WHERE条件过滤</h4>
<p>WHERE a.userid = 1003  生成表vt4：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+</code></pre>
<h4>第五步：SELECT</h4>
<p>SELECT i.name, a.money  生成vt5：</p>
<pre><code>+------+-------+
| name | money |
+------+-------+
| z    |     8 |
+------+-------+</code></pre>
<p>虚拟表vt5作为最终结果返回给客户端</p>
<p>介绍完联表的过程之后，我们看看常用<strong>JOIN</strong>的区别</p>
<h2>4 INNER/LEFT/RIGHT/FULL JOIN的区别</h2>
<ul>
<li>
<strong>INNER JOIN...ON...</strong>: 返回 左右表互相匹配的所有行（因为只执行上文的第二步ON过滤，不执行第三步 添加外部行）</li>
<li>
<strong>LEFT JOIN...ON...</strong>: 返回左表的所有行，若某些行在右表里没有相对应的匹配行，则将右表的列在新表中置为NULL</li>
<li>
<strong>RIGHT JOIN...ON...</strong>: 返回右表的所有行，若某些行在左表里没有相对应的匹配行，则将左表的列在新表中置为NULL</li>
</ul>
<h4>INNER JOIN</h4>
<p>拿上文的第三步<strong>添加外部行</strong>来举例，若<strong>LEFT JOIN</strong>替换成<strong>INNER JOIN</strong>，则会跳过这一步，生成的表vt3与vt2一模一样：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+</code></pre>
<h4>RIGHT JOIN</h4>
<p>若<strong>LEFT JOIN</strong>替换成<strong>RIGHT JOIN</strong>，则生成的表vt3如下：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
+--------+------+--------+-------+</code></pre>
<p><strong>因为user_account（右表）里存在userid=1009这一行，而user_info（左表）里却找不到这一行的记录，所以会在第三步插入以下一行：</strong></p>
<pre><code>|   NULL | NULL |   1009 |    11 |</code></pre>
<h4>FULL JOIN</h4>
<p><a href=""https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins"" rel=""nofollow noreferrer"">上文引用的文章</a>中提到了标准SQL定义的<strong>FULL JOIN</strong>，这在mysql里是不支持的，不过我们可以通过<strong>LEFT JOIN + UNION + RIGHT JOIN</strong> 来实现<strong>FULL JOIN</strong>：</p>
<pre><code>SELECT * 
  FROM user_info as i 
    RIGHT JOIN user_account as a 
      ON a.userid=i.userid
union 
SELECT * 
  FROM user_info as i 
    LEFT JOIN user_account as a 
      ON a.userid=i.userid;</code></pre>
<p>他会返回如下结果：</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   NULL | NULL |   1009 |    11 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+</code></pre>
<p>ps：其实我们从语义上就能看出<strong>LEFT JOIN</strong>和<strong>RIGHT JOIN</strong>没什么差别，两者的结果差异取决于左右表的放置顺序，以下内容摘自mysql官方文档：</p>
<blockquote>RIGHT JOIN works analogously to LEFT JOIN. To keep code portable across databases, it is recommended that you use LEFT JOIN instead of RIGHT JOIN.</blockquote>
<p>所以当你纠结使用LEFT JOIN还是RIGHT JOIN时，尽可能只使用LEFT JOIN吧</p>
<h2>5 ON和WHERE的区别</h2>
<p>上文把JOIN的执行顺序了解清楚之后，ON和WHERE的区别也就很好理解了。<br>举例说明:</p>
<pre><code>SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;</code></pre>
<pre><code>SELECT * 
  FROM user_info as i
    LEFT JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;</code></pre>
<p>第一种情况<strong>LEFT JOIN</strong>在执行完第二步ON子句后，筛选出满足<strong>i.userid = a.userid and i.userid = 1003</strong>的行，生成表vt2，然后执行第三步JOIN子句，将外部行添加进虚拟表生成vt3即最终结果：</p>
<pre><code>vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   NULL |  NULL |
|   1002 | y    |   NULL |  NULL |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+</code></pre>
<p>而第二种情况<strong>LEFT JOIN</strong>在执行完第二步ON子句后，筛选出满足<strong>i.userid = a.userid</strong>的行，生成表vt2；再执行第三步JOIN子句添加外部行生成表vt3；然后执行第四步WHERE子句，再对vt3表进行过滤生成vt4，得的最终结果：</p>
<pre><code>vt2:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+
vt3:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1001 | x    |   1001 |    22 |
|   1002 | y    |   1002 |    30 |
|   1003 | z    |   1003 |     8 |
|   1004 | a    |   NULL |  NULL |
|   1005 | b    |   NULL |  NULL |
|   1006 | c    |   NULL |  NULL |
|   1007 | d    |   NULL |  NULL |
|   1008 | e    |   NULL |  NULL |
+--------+------+--------+-------+
vt4:
+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+</code></pre>
<p>如果将上例的<strong>LEFT JOIN</strong>替换成<strong>INNER JOIN</strong>，不论将条件过滤放到<strong>ON</strong>还是<strong>WHERE</strong>里，结果都是一样的，因为<strong>INNER JOIN不会执行第三步添加外部行</strong></p>
<pre><code>SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid and i.userid = 1003;</code></pre>
<pre><code>SELECT * 
  FROM user_info as i
    INNER JOIN user_account as a
      ON i.userid = a.userid where i.userid = 1003;</code></pre>
<p>返回结果都是:</p>
<pre><code>+--------+------+--------+-------+
| userid | name | userid | money |
+--------+------+--------+-------+
|   1003 | z    |   1003 |     8 |
+--------+------+--------+-------+</code></pre>
<h2>参考资料</h2>
<p>《MySQL技术内幕：SQL编程》<br><a href=""https://www.w3schools.com/sql/sql_join.asp"" rel=""nofollow noreferrer"">SQL Joins - W3Schools</a><br><a href=""https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join"" rel=""nofollow noreferrer"">sql - What is the difference between “INNER JOIN” and “OUTER JOIN”?</a><br><a href=""https://dev.mysql.com/doc/en/join.html"" rel=""nofollow noreferrer"">MySQL :: MySQL 8.0 Reference Manual :: 13.2.10.2 JOIN Syntax</a><br><a href=""https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins"" rel=""nofollow noreferrer"">Visual Representation of SQL Joins</a><br><a href=""https://en.wikipedia.org/wiki/Join_(SQL"" rel=""nofollow noreferrer"">Join (SQL) - Wikipedia</a>)</p>

                ", Mysql - JOIN详解,1531977848,439,1,856,1,1,https://segmentfault.com/a/1190000015572505
12,1,0,9,"
                    
<p><strong>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1601916?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯音视频实验室</a>发表于<a href=""https://cloud.tencent.com/developer/column/2355?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p>在线“看片”时，我们经常会遇到这些事情：视频画面突然卡住进入缓冲状态或者视频画面突然变得模糊而不忍直视。这些事情的背后很可能是网络环境突然变差了导致下载速度很慢，也可能是码率调整算法没有对当前环境做出合理的决策导致。 </p>
<p>事实上，如何感知网络环境的变化并作出合理的码率调整并非易事。目前很多视频播放的客户端都提供了几种码率档位（标清、高清、超清、蓝光等）供用户自主选择，在网络环境好时用户可以自主切到高码率档位，网络环境差时切到低码率档位。当然，有些主流的视频播放客户端也提供了自适应（自动）这个选项，比如YouTube，当用户选择这个选项后，运行在背后的码率自适应算法会根据当前的网络情况和播放缓冲区等信息去自适应调整视频档位，旨在给用户提供更好的视频观看体验。事实上，码率自适应算法是学术界近年来的一个研究热点，音视频实验室和企鹅电竞团队也在点播码率自适应方法上进行了尝试和实践。</p>
<h1>一、码率自适应技术简介</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572201?w=491&amp;h=146"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图1：码率自适应系统框架</p>
<p>码率自适应技术 (Adaptive Bitrate Streaming，ABR)是一种视频码率可以根据网络状况或客户端播放buffer情况自动调整的视频传输技术。如图1所示，一个视频源通过视频转码器转成不同的视频码率存储在web 服务器，同时每个码率的视频被切割成一个个小的视频分片，每个分片通常是可单独解码播放的视频内容，分片时长通常介于2秒到10秒之间。视频播放客户端首先获取不同码率的切片索引信息，然后根据当前的网络状况或者客户端的播放缓冲区情况自动选择档位最匹配的视频片段下载。</p>
<p>目前，基于HTTP的码率自适应技术的实现方式从标准的类型来看主要有两大类：如图2所示，一类是企业方案，即提供了整体的技术解决方案，如Apple Live Streaming技术；另一类是一些国际标准组制定的技术标准，如MPEG的DASH(Dynamic Adaptive Streamingover HTTP)。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572202"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图2: 码率自适应技术分类</p>
<h2>1.1 码率自适应算法的难点</h2>
<p>视频码率自适应的目的是为了提高（或者最大化）用户在线观看视频的体验质量（qualityof experience, QoE），但是用户体验质量的定量表达本身也是一个难点。许多研究表明视频的质量（比如码率）、卡顿时间以及切换频繁度都将影响到用户的体验质量。最大化用户体验质量可以认为：尽可能最大化视频码率的同时尽量减少视频卡顿和码率档位切换。而实际上，组成用户体验质量的这些因素之间是互相影响甚至存在矛盾，比如用户如果能长期收到高码率的视频，视频质量自然会更好，但这又很可能增加视频卡顿的风险（网络如果变差，播放速度快于后续片段的下载速度）。另外，码率自适应调整具有累积效应，前面的码率决策会影响到未来的码率的决策。因此，一个好的码率自适应算法要兼顾各项指标，快速响应环境变化做出尽可能最优的决策。</p>
<h2>1.2 码率自适应算法的分类</h2>
<p>码率自适应算法（ABR）一般通过当前的网络状态或客户端播放缓冲区情况来动态地调整未来视频片段的码率档位以期最大化用户的QoE，近年来的ABR算法主要分为三类：</p>
<ul>
<li>Rate-based: 基于预测的吞吐量去决策下一片段的码率档位，例如FESTIVE，这类方法的主要思想是通过历史视频分片下载期间的网络状况来预测未来的网络带宽，进而驱动视频码率决策，例如预测带宽高时选择高码率视频，预测带宽低时选择低码率视频。</li>
<li>Buffer-based: 基于客户端的播放缓冲区buffer情况决策下一片段的码率档位，例如BBA、BOLA。</li>
<li>Hybrid: 混合模式，同时考虑预测吞吐量和buffer信息决策下一片段的码率档位，例如MPC</li>
</ul>
<p>传统的码率自适应算法一般是基于人为设定的固定规则的来进行视频码率档位的动态调整。其中，单独基于buffer或者预测带宽的方法没有充分利用可用信息，而结合了两者信息的算法可以获得相对较好的效果，但其非常依赖于带宽预测信息，在带宽变化剧烈的场景中，准确预测带宽是非常困难的。基于混合模式的MPC（模型预测控制）算法虽然可以获得不错的结果，但其在求解最优解时计算耗时大，速度慢，在决策动作空间和优化区间步长稍大时，缺点显现出来。</p>
<p>反观码率自适应过程：首先，视频播放客户端会根据当前的网络情况、播放缓冲区大小等因素决定下一个片段的码率档位，然后客户端执行码率决策向CDN服务器请求对应质量的视频片段，进行下载，下载的过程中视频缓冲区也同时在播放消耗。下载完当前片段后，客户端进入了另外一种状态（播放缓冲区大小变化、是否卡顿等）且可以据此评价上一个动作的好坏，然后再重新进行新的决策，如此循环往复，直到结束。以上过程可以抽象成系统控制或者策略制定的问题。而相对于人为制定策略和控制规则而言，机器学习里的强化学习不需要人为地设定一些经验规则或策略逻辑，直接通过与环境的不断交互中去学习策略，在不断试错和经验总结中学到好的决策和控制模型。本文在研读业界近年来码率自适应算法的基础上，重点对基于强化学习的码率自适应算法进行了探索和研究。再进一步讨论之前，下面先简单介绍强化学习的基本概念。</p>
<h1>二、强化学习简介</h1>
<p>总所周知，近年来机器学习里的深度学习在计算机视觉、语音识别和自然语言处理等流域遍地开花，取得了很多突破性的进展。而机器学习从学习信号区分的话，可以分为：有监督学习、无监督学习和强化学习。强化学习是系统从环境学习以使得奖励期望最大的机器学习。强化学习和有监督学习的不同在于教师信号。强化学习的教师信号是动作的奖励，有监督学习的教师信号是正确的动作。举个例子，在猫狗分类时，对于一张图片是哪种动物，有监督学习给的信号是这张图片的真正label是猫或者狗。而基于强化学习的围棋AI中，在某种局面下，我们并没有确切的答案告诉你，一定要落子在哪里，而是可能会反馈给你落子在何处时的价值估计。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572203?w=403&amp;h=209"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图3: 强化学习基本框架</p>
<p>强化学习（Reinforcement learning, RL）的基本思路是通过最大化智能体（Agent）从环境中获得的累计奖赏值，以学习到完成目标的最优策略。强化学习侧重于学习解决问题的策略，是制定策略或者系统控制的通用框架，其通过和环境的不断交互和动作尝试来调整和优化策略决策，一般由智能体Agent、环境Environment、动作action、执行动作后环境反馈的观察状态S和立即奖惩reward组成，其学习的过程可以描述为：（1）在每个时刻，agent与环境交互得到一个环境的状态观察St，并利用DL（深度学习）等方法来感知观察，以得到状态S的抽象特征表示；（2）基于某种策略将当前状态映射为相应的动作，并基于期望回报来评价各动作的价值（3）环境对此动作做出反应，得到新的观察状态St+1并反馈上一个动作at的立即奖赏reward(rt)。通过不断循环以上过程，不断试错和学习，以期得到实现目标的最优策略。</p>
<h1>三、基于Actor-Critic框架的码率自适应算法</h1>
<p>近两年，随着深度学习的火热和应用领域的延伸，学术界也尝试利用机器学习的方法来解决码率自适应问题。其中，MIT的计算机科学和人工智能实验室在基于AI的码率自适应算法上做了创新性的尝试并取得了不错的结果，受到他们思路的启发，我们也在基于AI的码率自适应算法进行了实践探索。本文基于强化学习的码率自适应算法中采用的是Actor-Critic的策略梯度方法来进行策略的学习，下图4是基于Actor-Critic框架的码率自适应算法的模型框架。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572204?w=497&amp;h=253"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图4：基于Actor-Critic框架的ABR算法模型</p>
<p>在AC框架中，actor（演员）网络进行策略决策，学习状态state到动作的映射关系，而critic（评论家）负责价值估计，即估计价值函数。策略决策和价值估计需要在训练过程中迭代优化，一开始actor的策略可能随机，critic也没有好的打分规则。但是由于reward的存在，critic评分随着训练的进行会越来越准，actor的决策表现也会越来越好，最终学习到好的策略。</p>
<p>在模型训练过程中， reward信号的设计是非常重要的，在不同reward下模型学习到的策略也就会有差异。本文希望解决的问题是如何在点播系统中最大化视频观看用户的体验质量（QoE），而研究表明：视频的质量(码率高低)、rebuffering（重新缓冲）以及档位切换的平滑性都将影响到用户体验的质量，因此在设计reward时，可以由这些因素共同决定。</p>
<p>模型输入的状态信息也是非常重要的点，结合reward的设计，模型状态输入信息主要包括：吞吐量信息、播放缓冲区信息等。</p>
<p>如图4所示，输入状态经过actor网络和critic网络后输出的分别是策略动作（码率档位）和价值估计，而在实际部署只需要策略决策时，仅保留训练好的actor网络。在实际的模型训练时，采用的是A3C（Asynchronous AdvantageActor-Critic）架构进行快速有效的模型训练。</p>
<h1>四、预研结果和分析</h1>
<p>模型训练和测试的吞吐量数据由宽带网络数据和移动（3G4G）网络数据组成，训练集和测试集均包含了100多种网络数据。图5和图6展示了在该测试集上基于强化学习的模型1和模型2对比传统方法MPC(采用表现较好的robustMPC)的结果。总平均reward代表了在100多种网络情况下，视频播放过程中客户端的累计奖励值的平均。模型1和模型2相对于robustMPC分别有约6.4%和8.8%的提升。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572205?w=616&amp;h=308"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图5：100多种网络状态下(6种码率档位)的测试结果对比</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572206"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图6：100多种网络状态下(6种码率档位)的测试结果对比(reward组成因素分解)</p>
<p>图6中对组成总平均reward的各个因素进行分解，可以看到传统方法的robustMPC虽然在总平均码率奖励上比强化学习模型1和2要高，但与此同时带来的重新缓冲（rebuffering）的风险也更高，导致rebuffering的惩罚明显多于其他两种模型。而基于强化学习的ABR模型1和2能够更好地兼顾各项因素使得累计奖励到达更高。</p>
<p>图5和图6的结果都是基于数据库的带宽信息进行测试的，为了验证在实际场景中的应用效果，我们将强化学习的码率自适应算法应用于DASH点播系统中，在真实的网络损伤环境下验证各种算法模型的表现：在视频播放客户端和视频服务器之间的视频下载的网络链路上分别添加了限速、丢包、抖动和时延等损伤环境进行测试，结果如图7所示。相对而言，在真实的损伤场景中，模型1和模型2的整体表现比robustMPC稳定，在损伤场景的测试集上，模型1和模型2相对于robustMPC分别有约9.2%和8.9%的提升。结果和需要注意的是，我们的模型是离线使用数据库中有限的带宽数据进行模拟训练的，将其直接应用在实际环境中的表现说明了其具有不错的泛化性。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572207"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图7：真实系统和损伤网络环境测试集下模型的测试结果</p>
<h1>五、线上实践和效果</h1>
<p>在上述预研的基础上，我们将本文介绍的基于强化学习的码率自适应算法应用于企鹅电竞的点播业务（HTTP+HLS），用于决策客户端当前应该下载的视频片段的档位（例标清、高清、超清等）。为了提升用户体验，电竞团队联合腾讯云团队做了“帧对齐”的优化工作，实现点播过程的无缝切换效果。图8是针对电竞点播业务部署的点播AI流控系统，预测服务器负责码率决策和下发档位，并向训练服推送训练数据，训练服负责模型训练和模型同步。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572208"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>图8：点播AI流控系统</p>
<p>实际的线上数据统计对比如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572209"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>表1：流控后台打分算法统计的效果对比（对比传统算法）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572210"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>表2：流控后台打分算法统计的效果对比（对比非流控模式）</p>
<p>以上表格1和表格2结果显示:</p>
<p>•AI模型的总得分比传统MPC算法增加约6%, 超清档位占比增加约5%，且卡顿和切换惩罚更小</p>
<p>•AI模型的总得分比非流控模式增加约18%，超清档位占比增加约6%~14%左右，且卡顿和切换惩罚明显更小</p>
<p>注：表格2是关闭MPC传统算法后，AI模型算法对比非流控模式(用户自主选择档位)的统计数据。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015572211?w=647&amp;h=135"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>表3：电竞客户端打分算法统计的效果对比</p>
<p>以上表格3结果显示:</p>
<p>• AI流控的总分比非流控模式增加约4.9分</p>
<p>• 清晰度：超清档位占比增加约8.4%</p>
<p>• 流畅度：</p>
<p>1）AI流控较非AI无缓冲率得分高约12分，无缓冲率高约8%</p>
<p>2）AI流控较非AI二次缓冲每小时比率的得分高约8分</p>
<p>上述结果表明，基于强化学习的AI算法在点播流控的应用中，能够更好地兼顾码率、卡顿和切换因素，在提供更高清晰度体验的同时，也能更好地避免卡顿的产生，从而提供给用户更好的视频观看体验。</p>
<h1>六、小结和展望</h1>
<p>本文简要介绍了基于强化学习的码率自适应算法，在实践预研验证和分析的基础上，将该AI算法模型应用于实际项目。在音视频实验室和企鹅电竞团队等的共同努力下，在基于AI的点播流控探索和实践上，取得了初步的成效。而如何在直播、实时通话系统中进行更好的码率自适应调整值得我们进一步研究和探索。</p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/116884?fromSource=waitui"" rel=""nofollow noreferrer"">AI如何赋能物流？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1146686?fromSource=waitui"" rel=""nofollow noreferrer"">类守望先锋游戏AI设计</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1155251?fromSource=waitui"" rel=""nofollow noreferrer"">胡珀：从危到机，AI 时代下的安全挑战</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1157625?fromSource=waitui"" rel=""nofollow noreferrer"">反向传播算法推导-全连接神经网络</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1153315?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>
<p>海量技术实践经验，尽在云加社区！ <a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>

                ", AI让你看片更丝滑,1531977849,374,1,312,1,1,https://segmentfault.com/a/1190000015572198
13,1,0,9,"
                    
<p>首先要说，这并不是一篇教你如何学习的文章，因为到今天为止我也没有找到一种通用的方法来解决如何学习的问题。但是在探索的道路上，我确实产生过一些思路，我想把这些思考的过程分享出来让大家探讨。如果这对你有帮助的话，那我会非常高兴。</p>
<p>我最近在学习 Rust ，这是一门很酷但是相对冷门的语言（学习冷门语言可能是我的一大爱好，比如我就非常喜欢 CoffeeScript ，这是 JavaScript 的一门方言）。自从在某些语言的舒适区待久之后，经常会产生自己无所不能的错觉，这也是我不断想学习新语言的一大动力。</p>
<p>而我的学习过程跟大多数人类似，就是先在网上找文档然后自学。而在看文档的过程中，我就发现了一些问题。</p>
<h2>手册的作用</h2>
<p>“去看文档喽。”这是老鸟在面对新手时最喜欢扔的一句话，我通常也是这么扔给自己的。但当你打开一门语言的手册，你会发现它除了教你语法外，几乎没有教你什么其它东西。于是你会陷入这样一个境地：</p>
<p>“背下来了么？”<br>“背不下来，太难懂了。”<br>“再看一遍，给我背下来。”<br>。。。<br>“背下来了么？”<br>“大部分背下来了。”<br>“给我写个程序，实现个XX功能。”<br>“不会。。。”<br>“。。。”</p>
<p>在一个高级开发者眼里，你会了语法理所当然就应该会写程序了，但实际情况并非如此。这让我想起前段时间跟一个朋友关于目前编程教育市场的一个讨论。我出于自己的经验提出一个想法：让大牛开发者来教新手入门。在我的设想中，大牛开发者拥有强大的实战经验，以及丰富的专业知识，更是自带光环，这不比现在市场上那些半吊子的讲师好多了。在我为自己“伟大”的想法得意的时候，朋友给我浇了一盆冷水。他告诉我这样根本行不通，大牛根本不知道菜鸟需要什么知识，你可能以为基础语法讲清楚就好了，人家却连编辑器是什么都不清楚。设想一下，让一个大学教授去教一群小学生，这对两者来说都是一种灾难吧。</p>
<p>这些语言的创造者，或者文档的作者，无疑都是一些大神。它们在撰写一个语言手册的过程中，只能尽量负责地把这个语言的全貌准确地有组织地展现给你。然而这种全面的展现，对于一个没有任何引导的初学者来说并不完全是一件好事。简单来说就是，你会在一些次要的事情上浪费太多时间，而一些主要的概念又没有理解透彻。</p>
<h2>关于看真实代码</h2>
<p>当觉得文档满足不了你的时候，老鸟们往往会扔给你第二招：看代码。看什么代码呢？那还用说，当然是被业界奉为经典的，在 GitHub 上至少有一万颗星的知名开源项目代码啦。</p>
<p>当你怀着崇敬的心情，打开扔给你的网址，看着满屏幕的代码时，你会对自己问出那三个经典的哲学问题。这是什么东西？它是怎么做到的？为什么要这么写？搞不好某些人还会因为惊吓过度，从而失去了学习下去的信心。</p>
<p>那么让我们一起来看看这些代码里有什么鬼东西，会吓得新手信心不足。</p>
<h3>大段的注释</h3>
<p>说一件事你们不要笑，在我还是个萌新的时候，我曾经对这些穿插在代码中的神秘文字产生了深深的困惑，我还以为它们对代码有某种加成作用，以至于我还试验过把注释去掉会对代码执行产生什么影响。而现实中好的代码会让后面的维护者方便很多，但不好的甚至错误的注释会让人迷惑不已。</p>
<h3>语法糖</h3>
<p>语法糖是个好东西，它大大简化了我们的编程过程，高手用起语法糖写起代码来简直不要太爽，所以越强大的项目这玩意儿越多。但是对于初学者来说，语法糖隐藏了一些细节，而且让语法看起来很怪异。有些代码如果你用标准语法来写是很好懂的，但如果用语法糖来写的话很难让人一下子明白。</p>
<p>初学者为了弄懂这些语法往往要花大量时间，但其实这些时间在这个阶段是没必要的浪费。你看不懂它觉得它是一个很重要的东西，其实它只是一个做工精巧的小玩意儿，离开了它这些代码照样能工作。而随着你的经验丰富，也可以随时随地用起来，用的方法可能也不尽相同。</p>
<h3>代码里的重点</h3>
<p>对于一个开源项目来说，往往 50% 的代码可能都是在适配各种不同的运行环境，将系统的 API 抽象成项目里通用的接口，这部分代码除非你自己要做类似的项目，要不然的话对初学者来说参考意义不大。更何况，为了适配某些系统奇葩的运行环境，开发者往往会大开脑洞，创造出一些非常奇怪的代码。这些旁门左道充满了玄学和不确定性，初学者看多了可能会发生如武侠小说里练功出差错的结果：走火入魔。</p>
<p>剩下的代码里 20% 是项目内部的接口抽象和定义，最后 30% 才是真正值得看的东西，它们往往散落在各个地方，但又为了一个设计核心服务。让初学者识别出这些代码来，未免太强人所难。</p>
<h2>野文档</h2>
<p>这是我自己的一个定义，我把一切非官方的开发文档都称为野文档。初学者会在搜索引擎里得到大量的相关文档，他们很多是学习心得，很多人在写这篇文章时水平可能比你也高不了多少。这就造成了这些文档的水平参差不齐，所面向的重点也不同，也许你花了大把时间弄懂的是一个错误的或者过时的知识。而大部分号称教你入门的文章，可能也就是告诉了你如何搭建一个运行环境，这门语言的精髓和重点作者自己估计也没弄明白。</p>
<p>而如果你碰到一篇被奉为经典的好的入门文章，那你真的要好好感谢作者。因为这意味着作者付出了大量的深入思考，深入浅出这四个字说起来简单，做起来可是需要相当的功底的。</p>
<h2>相对较好的做法</h2>
<p>在这么多语言的学习过程中，我也总结了一些相对比较好的学习方法。我认为看代码是非常有必要的，因为光死记语法是无法掌握好这门语言的。但是去看一些大型项目代码的缺点我在上面也说了，到底该如何是好呢？</p>
<p>我建议大家可以去看官方给出的，专门供初学者学习的 Step-By-Step 代码，这种代码一般在官方的文档页就可以找到链接入口，它有如下好处：</p>
<ol>
<li>由浅入深，富有层次。这些代码往往是跟随者文档的深入，慢慢把语法细节展开的。不会一下给你展现太多，让你无法 GET 到重点。每段代码都会有一个重点要表现的特性，这样看起来会一目了然。</li>
<li>有质量保证。这些代码的撰写一般是官方人员负责，这可以在很大程度上保证准确性。</li>
<li>更新及时。我们知道很多语言的细节是会随着版本的升级有所改变的，而很多网上的第三方文档往往缺乏维护，但官方文档一般都会同步更新。</li>
</ol>
<p>我建议大家一边看手册一边看代码，这样印象会更深刻。眼睛看了之后，我认为要尽快找一些好的例子来练手，不需要一上来就搞比较复杂的大型项目，也是由浅入深。这种练手项目去哪里找呢，很多语言的 tutorial 板块就是干这个的，做的比较完善的甚至还提供在线的教学体验环境，大家应该好好利用。</p>
<h2>写在最后</h2>
<p>这篇讨论学习方法的文章引发了我的一些额外思考。我经常在开发者社区里看到老鸟和初学者互怼，写这篇文章的过程也让我理性思考了产生这些矛盾的原因。总的来说就是一些信息的不对称造成的。老鸟认为这个问题根本不是问题，网上一搜一大把，不愿多讲甚至冷嘲热讽。而初学者却觉得这些信息根本理解不能，老鸟的嘲讽就是一种羞辱。</p>
<p>我认为要打破这种不对称需要双方付出耐心，而这种耐心的付出是相互的，你付出的多回报的就越多。而最先迈出付出这一步的，应该是初学者，毕竟从情理上来说是你请求人家办事。而你需要付出的不过是把自己的问题讲明白，说出你的思考过程，附上必要的信息。一个好学的人是不会让人讨厌的，但前提是你得有一个不让人讨厌的姿态展现出来。</p>
<p><strong>拓展阅读</strong></p>
<ul><li><a href=""https://segmentfault.com/a/1190000015589926"" rel=""nofollow noreferrer"">对 SegmentFault 社区提问标准的一些解释</a></li></ul>

                ", 如何学习一门新的语言,1531977851,303,1,713,1,1,https://segmentfault.com/a/1190000015566529
14,1,0,9,"
                    
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer/?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1680532"" rel=""nofollow noreferrer"">宝哥@devops运维 </a>发表于<a href=""https://cloud.tencent.com/developer/column/3110"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<h2><strong>一、什么是容器？</strong></h2>
<p>容器这个词，当你第一眼看它或许脑子里是这东西：瓶瓶罐罐、装水、装其他东西的玩意。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015550626?w=523&amp;h=448"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>不管是什么，总的来说，容器给人第一印象就是——“装”。</p>
<p>那今天我们要说的容器技术是怎么一个概念呢？其实，IT里的容器技术是英文单词Linux Container的直译。container这个单词有集装箱、容器的含义（主要偏集装箱意思）。不过，在中文环境下，咱们要交流要传授，如果翻译成“集装箱技术” 就有点拗口，所以结合中国人的吐字习惯和文化背景，更喜欢用容器这个词。不过，如果要形象的理解Linux Container技术的话，还是得念成集装箱会比较好。我们知道，海边码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色，<strong>在于其格式划一，并可以层层重叠</strong>，所以可以大量放置在特别设计的远洋轮船中（早期航运是没有集装箱概念的，那时候货物杂乱无章的放，很影响出货和运输效率）。有了集装箱，那么这就更加快捷方便的为生产商提供廉价的运输服务。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015550627"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>因此，IT世界里借鉴了这一理念。早期，大家都认为硬件抽象层基于hypervisor的虚拟化方式可以最大程度上提供虚拟化管理的灵活性。各种不同操作系统的虚拟机都能通过hypervisor（KVM、XEN等）来衍生、运行、销毁。然而，随着时间推移，用户发现hypervisor这种方式麻烦越来越多。为什么？因为对于hypervisor环境来说，每个虚拟机都需要运行一个完整的操作系统以及其中安装好的大量应用程序。但实际生产开发环境里，我们更关注的是自己部署的应用程序，如果每次部署发布我都得搞一个完整操作系统和附带的依赖环境，那么这让任务和性能变得很重和很低下。</p>
<p>基于上述情况，人们就在想，有没有其他什么方式能让人更加的关注应用程序本身，底层多余的操作系统和环境我可以共享和复用？换句话来说，那就是我部署一个服务运行好后，我再想移植到另外一个地方，<strong>我可以不用再安装一套操作系统和依赖环境。</strong>这就像集装箱运载一样，我把货物一辆兰博基尼跑车（好比开发好的应用APP），打包放到一容器集装箱里，它通过货轮可以轻而易举的从上海码头（CentOS7.2环境）运送到纽约码头（Ubuntu14.04环境）。而且运输期间，我的兰博基尼（APP）没有受到任何的损坏（文件没有丢失），在另外一个码头卸货后，依然可以完美风骚的赛跑（启动正常）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015550628?w=924&amp;h=399"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>Linux Container容器技术的诞生（2008年）就解决了IT世界里“集装箱运输”的问题。Linux Container（简称LXC）它是一种<strong>内核轻量级的操作系统层</strong>虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。那么Namespace和Cgroup是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让A公司的货跟B公司的货混在一起，不然卸货就分不清楚了。那么Namespace也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等... 通用的，与此对应的Cgroup就负责资源管理控制作用，比如进程组使用CPU/MEM的限制，进程组的优先级控制，进程组的挂起和恢复等等。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015550629"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2><strong>二、容器技术的特点</strong></h2>
<p>容器的特点其实我们拿跟它跟硬件抽象层虚拟化hypervisor技术对比就清楚了，我们之前也提到过，传统的虚拟化（虚拟机）技术，创建环境和部署应用都很麻烦，而且应用的移植性也很繁琐，比如你要把vmware里的虚拟机迁移到KVM里就很繁琐（需要做镜像格式的转换）。那么有了容器技术就简单了，总结下容器技术主要有三个特点：</p>
<ul>
<li>1. 极其轻量：只打包了必要的Bin/Lib；</li>
<li>2. 秒级部署：根据镜像的不同，容器的部署大概在毫秒与秒之间（比虚拟机强很多）；</li>
<li>3. 易于移植：一次构建，随处部署；</li>
<li>4. 弹性伸缩：Kubernetes、Swam、Mesos这类开源、方便、好使的容器管理平台有着非常强大的弹性管理能力。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015550630"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2><strong>三、容器的标准化</strong></h2>
<p>当前，docker几乎是容器的代名词，很多人以为docker就是容器。其实，这是错误的认识，除了docker 还有coreos。所以，容器世界里并不是只有docker一家。既然不是一家就很容易出现分歧。任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。因此，在2015年，由Google，Docker、CoreOS、IBM、微软、红帽等厂商联合发起的OCI（Open Container Initiative）组织成立了，并于2016年4月推出了第一个开放容器标准。标准主要包括runtime运行时标准和image镜像标准。标准的推出，有助于替成长中市场带来稳定性，让企业能放心采用容器技术，用户在打包、部署应用程序后，可以自由选择不同的容器Runtime；同时，镜像打包、建立、认证、部署、命名也都能按照统一的规范来做。</p>
<p>两种标准主要包含以下内容：</p>
<ol><li>容器运行时标准 （runtime spec）</li></ol>
<p>a). creating：使用 create 命令创建容器，这个过程称为创建中 b). created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台 c). running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务 d). stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除</p>
<ol><li>容器镜像标准（image spec）</li></ol>
<p>a). 文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存哪些文件，怎么表示增加、修改和删除的文件等; b). config 文件：保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount 列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 docker inspect &lt;image_id&gt; 看到的内容; c). manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息; d). index 文件：可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引。</p>
<h2><strong>四、容器的主要应用场景</strong></h2>
<p>容器技术的诞生其实主要解决了PAAS的层的技术实现。像OpenStack、Cloudstack这样的技术是解决IAAS层的问题。IAAS层和PAAS层大家估计也听得很多了，关于他们的区别和特性我这里不在描述。那么容器技术主要应用在哪些场景呢？目前主流的有以下几种：</p>
<p>1. 容器化传统应用 容器不仅能提高现有应用的安全性和可移植性，还能节约成本。</p>
<p>每个企业的环境中都有一套较旧的应用来服务于客户或自动执行业务流程。即使是大规模的单体应用，通过容器隔离的增强安全性、以及可移植性特点，也能从 Docker 中获益，从而降低成本。一旦容器化之后，这些应用可以扩展额外的服务或者转变到微服务架构之上。</p>
<p>2. 持续集成和持续部署 (CI/CD) 通过 Docker 加速应用管道自动化和应用部署，交付速度提高至少 13 倍。</p>
<p>现代化开发流程快速、持续且具备自动执行能力，最终目标是开发出更加可靠的软件。通过持续集成 (CI) 和持续部署 (CD)，每次开发人员签入代码并顺利测试之后，IT 团队都能够集成新代码。作为开发运维方法的基础，CI/CD 创造了一种实时反馈回路机制，持续地传输小型迭代更改，从而加速更改，提高质量。CI 环境通常是完全自动化的，通过 git 推送命令触发测试，测试成功时自动构建新镜像，然后推送到 Docker 镜像库。通过后续的自动化和脚本，可以将新镜像的容器部署到预演环境，从而进行进一步测试。</p>
<p>3. 微服务 加速应用架构现代化进程。</p>
<p>应用架构正在从采用瀑布模型开发法的单体代码库转变为独立开发和部署的松耦合服务。成千上万个这样的服务相互连接就形成了应用。Docker 允许开发人员选择最适合于每种服务的工具或技术栈，隔离服务以消除任何潜在的冲突，从而避免“地狱式的矩阵依赖”。这些容器可以独立于应用的其他服务组件，轻松地共享、部署、更新和瞬间扩展。Docker 的端到端安全功能让团队能够构建和运行最低权限的微服务模型，服务所需的资源（其他应用、涉密信息、计算资源等）会适时被创建并被访问。</p>
<p>4. IT 基础设施优化 充分利用基础设施，节省资金。</p>
<p>Docker 和容器有助于优化 IT 基础设施的利用率和成本。优化不仅仅是指削减成本，还能确保在适当的时间有效地使用适当的资源。容器是一种轻量级的打包和隔离应用工作负载的方法，所以 Docker 允许在同一物理或虚拟服务器上毫不冲突地运行多项工作负载。企业可以整合数据中心，将并购而来的IT资源进行整合，从而获得向云端的可迁移性，同时减少操作系统和服务器的维护工作。</p>
<blockquote>
<h2><strong>问答</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/ask/111361?fromSource=waitui"" rel=""nofollow noreferrer"">docker和docker-compose有什么不同？</a></p>
<h2><strong>相关阅读</strong></h2>
<p><a href=""https://cloud.tencent.com/developer/article/1157265?fromSource=waitui"" rel=""nofollow noreferrer"">童航君：腾讯云CIS服务和clear container</a>  </p>
<p><a href=""https://cloud.tencent.com/developer/article/1157228?fromSource=waitui"" rel=""nofollow noreferrer"">小白也能玩转Kubernetes 你与大神只差这几步</a>  </p>
<p><a href=""https://cloud.tencent.com/developer/article/1156181?fromSource=waitui"" rel=""nofollow noreferrer"">王蕴达：腾讯云 Kubernetes 一键部署实践</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1116709?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a> </strong></p>
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer/?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", 十分钟明白什么是容器技术,1531977853,172,1,625,1,1,https://segmentfault.com/a/1190000015550623
15,1,0,9,"
                    
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer/?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1027752"" rel=""nofollow noreferrer"">CodeSheep </a>发表于<a href=""https://cloud.tencent.com/developer/column/2396"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548448?w=999&amp;h=666"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<hr>
<h2>概述</h2>
<p>性能监控是容器服务必不可少的基础设施，容器化应用运行于宿主机上，我们需要知道该容器的运行情况，包括 CPU使用率、内存占用、网络状况以及磁盘空间等等一系列信息。在我的前文<a href=""https://www.jianshu.com/p/9e47ffaf5e31"" rel=""nofollow noreferrer"">《Docker容器可视化监控中心搭建》</a>之中我们就实践过Docker容器的可视化监控，在那篇文章中我们是使用了 <strong>cAdvisor + influxdb + grafana</strong> 技术栈来完成的。然而容器化世界里向来不会只有一种方法来实现某项功能，可以说有一百条大路来通到罗马，因此本文再来探讨另一种称为 <strong>TICK</strong> 的技术栈方案来实现Docker容器的性能监控。</p>
<p>基于TICK技术栈实现的Docker容器可视化监控方案架构图如下所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548449?w=734&amp;h=512"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>TICK方案架构</p>
<ul>
<li>Telegraf：采用插件机制实现的数据采集服务，可以采集包含Docker容器在内的多种性能数据</li>
<li>InfluxDB：专门负责存储时序数据</li>
<li>Chronograf：基于React.js编写的性能数据可视化服务</li>
<li>Kapacitor：提供告警触发和处理功能</li>
</ul>
<p>这四个组件组成了性能监控的数据管道：Telegraf负责采集节点上的性能数据，然后放入InfluxDB数据库进行存储，Kapacitor通过监听InfluxDB的性能数据来对异常指标发出告警，而Chronograf用来展示集群实时的各项性能指标和状态，提供一个可视化的界面。</p>
<p>下面开始实践的过程！</p>
<hr>
<hr>
<h2>部署InfluxDB服务</h2>
<p>首先准备好 InfluxDB 配置文件：<code>influxdb.conf</code></p>
<pre><code>mkdir /etc/influxdb
cd /etc/influxdb
touch influxdb.conf</code></pre>
<pre><code>[meta]
  dir = ""/var/lib/influxdb/meta""
[data]
  dir = ""/var/lib/influxdb/data""
  wal-dir = ""/var/lib/influxdb/wal""</code></pre>
<p>然后利用Docker来启动InfluxDB服务：</p>
<pre><code>docker run -d \
--name influxdb \
-p 8086:8086 \
-v /etc/influxdb/influxdb.conf:/etc/influxdb/influxdb.conf \
-v /var/lib/influxdb:/var/lib/influxdb \
docker.io/influxdb</code></pre>
<hr>
<hr>
<h2>部署Telegraf服务</h2>
<p>Telegraf服务需要部署在需要采集数据的节点上。我们首先来准备Telegraf服务的配置文件<code>telegraf.conf</code></p>
<pre><code>[agent]
  interval = ""10s""
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = ""0s""
  flush_interval = ""10s""
  flush_jitter = ""0s""
  debug = false
  quiet = false
  hostname = ""www.codesheep.cn""
  omit_hostname = false

[[outputs.influxdb]]
  urls = [""http://192.168.31.177:8086""]
  database = ""telegraf""
  username = """"
  password = """"
  write_consistency = ""any""
  timeout = ""5s""

[[inputs.docker]]
  endpoint = ""unix:///var/run/docker.sock""
  container_names = []
  timeout = ""5s""
  perdevice = true
  total = false

[[inputs.cpu]]
[[inputs.system]]</code></pre>
<p>该配置文件比较简化，inputs插件是负责数据采集，可以看出来上面的配置说明了我们想采集节点的CPU、System以及Docker容器的各项性能数据；而outputs插件指明了我们将采集到的性能数据放入InfluxDB数据库进行存储。</p>
<p>然后同样利用Docker来启动Telegraf服务</p>
<pre><code>docker run -d \
--name telegraf \
--network host \
-v /etc/telegraf/telegraf.conf:/etc/telegraf/telegraf.conf \
docker.io/telegraf</code></pre>
<hr>
<hr>
<h2>Chronograf部署</h2>
<pre><code>docker run -d \
--name chronograf \
-p 8888:8888 \
-v /var/lib/chronograf:/var/lib/chronograf \
docker.io/chronograf \
--influxdb-url=http://192.168.31.177:8086</code></pre>
<p>注意从上面的指令我们可以看出，Chronograf服务是需要连接到InfluxDB服务中去的，服务启动以后利用浏览器访问8888端口可以打开Chronograf的可视化监控界面</p>
<hr>
<hr>
<h2>Kapacitor部署</h2>
<pre><code>docker run -d \
--name kapacitor \
-p 9092:9092 \
-v /var/lib/kapacitor:/var/lib/kapacitor \
docker.io/kapacitor</code></pre>
<p>好了，至此 <strong>TICK</strong> 组件已经部署完成，我们可以查看一下宿主机上的容器情况，发现服务都已经启动起来了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>容器运行情况</p>
<hr>
<hr>
<h2>实际试验</h2>
<p>浏览器打开：<code>localhost:8888</code>来访问 <strong>Chronograf</strong> 提供的可视化界面，后续所有的操作都基于该界面。</p>
<ul><li>点击 <strong>Chronograf</strong> 主界面左侧菜单的 <strong>Host List</strong>，可以看到被监控的节点信息：</li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548451?w=1226&amp;h=851"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>被监控的节点信息</p>
<p>然后我们点击节点名进入后，就可以查看从该节点上采集到的各项主要指标数据的图表：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548452?w=1208&amp;h=971"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>查看节点的各项性能数据</p>
<p>除此之外，我们还可以点击节点上的 <strong>Apps</strong> 具体监控小类，如 <code>docker</code>类别，这样可以得到仅仅与docker相关的性能数据展示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548453"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>查看docker小类的性能指标数据</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548454?w=1213&amp;h=962"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>docker小类的性能指标数据展示</p>
<ul><li>然后我们点击 <strong>Chronograf</strong> 主界面左侧菜单的 <strong>Data Explorer</strong>，可以看到从InfluxDB那里获得的数据表，以及存储于InfluxDB数据表中的各项具体指标</li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548455?w=1202&amp;h=835"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>Data Explorer</p>
<ul><li>最后我们来看一下如何利用Kapacitor来实现告警功能。</li></ul>
<p>点击 <strong>Chronograf</strong> 主界面左侧菜单的 <strong>Alert</strong>，可以自定义创建告警规则：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548456"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>自定义创建告警规则</p>
<p>这里给出一个规则配置示例：我们可以监控某个具体性能指标的变化，如配置一个告警规则等：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015548457?w=1215&amp;h=973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span>规则配置示例</p>
<hr>
<blockquote>
<strong>问答</strong><br><a href=""https://cloud.tencent.com/developer/ask/111361?fromSource=waitui"" rel=""nofollow noreferrer"">docker和docker-compose有什么不同？</a><br><strong>相关阅读</strong><br><a href=""https://cloud.tencent.com/developer/article/1157265?fromSource=waitui"" rel=""nofollow noreferrer"">童航君：腾讯云CIS服务和clear container</a><br><a href=""https://cloud.tencent.com/developer/article/1157228?fromSource=waitui"" rel=""nofollow noreferrer"">小白也能玩转Kubernetes 你与大神只差这几步</a><br><a href=""https://cloud.tencent.com/developer/article/1156181?fromSource=waitui"" rel=""nofollow noreferrer"">王蕴达：腾讯云 Kubernetes 一键部署实践</a>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1157231?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a> </strong></p>
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer/?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", Docker可视化监控?看这篇文章,1531977855,345,1,787,1,1,https://segmentfault.com/a/1190000015548444
16,1,0,9,"
                    
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer/?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>，获取更多腾讯海量技术实践干货哦~</strong></p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/1024461?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯游戏云</a>发表于<a href=""https://cloud.tencent.com/developer/column/1349?fromSource=waitui"" rel=""nofollow noreferrer"">云+社区专栏</a>
</blockquote>
<h2>0x0 前言</h2>
<p>最新发布的2018全球游戏市场报告指出，2018年全球的游戏玩家数达到23亿，他们在游戏上花费将达到1379亿美元，其中中国游戏市场规模将达到379亿美元，占全球游戏市场收入的25%以上，中国市场营在营收规模和玩家数量均排名第一。伴随着游戏业务的繁荣发展，针对游戏行业的DDoS攻击也在持续爆发，攻击峰值不断创记录。</p>
<p>掉线，闪退，卡顿，登录失败，这些糟糕的游戏体验有可能并不是跟你的网络环境有关。2018年，随着MEMCACHED反射手法被攻击者启用，全球DDoS攻击的峰值达到1.7Tbps，腾讯云上也出现Tbps级别的攻击，这意味着，对于无论是是安全从业者还是游戏行业本身，都是一个巨大的挑战。</p>
<p>此次的《2018上半年游戏行业DDoS态势报告》，依托腾讯云宙斯盾防护系统上半年攻防积累的大数据，分别从时间，地域，次数多个维度分析了上半年DDoS攻击态势，剖析了黑产链条和典型案例，并给游戏行业从业者提供了对应的策略和建议，以飨读者。</p>
<h2>0x01 2018年上半年DDoS攻击大盘：攻击次数略微下滑，攻击峰值大幅增长</h2>
<h3>1. DDoS攻击形势：Tb级时代</h3>
<p>2018年，全球最大DDoS攻击的峰值达到1.7Tbps，同比增长112%。随着带宽资源的不断丰富，各种设备、攻击软件的数量增长，一个即使“功力”没那么深厚的黑客也能轻松发起超大流量的DDoS攻击。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490046?w=680&amp;h=332"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>同期腾讯云上呈现的DDoS攻击态势可总结为：<strong>攻击次数略微下滑，攻击峰值大幅增长</strong>。结合上半年（截止到2018年6月25日数据），腾讯云总攻击次数同比略微下滑10%，攻击峰值也达到1.23Tbps，也是国内目前最大流量攻击，同比增长134%。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490047?w=551&amp;h=303"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>上半年超过100G的攻击1000+次，约为去年同期的1/4。2月份和3月份为大流量攻击爆发的月份，刚好处在春节假期时间和上班族返工之时。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490048?w=557&amp;h=250"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>100G以上的攻击中，大部分攻击的峰值在100G~200G区间，占比72%。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490049?w=559&amp;h=509"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>2.  DDoS攻击行业分布：游戏四面楚歌</h3>
<p>DDoS攻击的行业分布方面，游戏行业成为最大受害行业，占据近40%的攻击。此外，网络服务（占比4%）和企业门户（占比2%）也是攻击占比较高的行业。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490050?w=457&amp;h=359"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>3.  DDoS攻击地域分布：被攻击企业集中一线、新一线城市</h3>
<p>被攻击企业的地域分布与所在区域的经济发展水平高度重合，被攻击企业在东南沿海发达省份呈现明显的聚集，此外四川，陕西，河南，湖北，湖南等省份也有较多企业被攻击。</p>
<p>城市维度上，被攻击企业高度聚集在一线和新一线城市（占比达到78%）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490051?w=457&amp;h=347"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>0x2 2018年上半年DDoS黑产形势：国外攻击源占比41%</h2>
<h3>1. 攻击团伙</h3>
<p>通过监测发现，目前的DDoS黑产团伙呈现如下的3种形态：</p>
<p>1） 高级跨国DDoS团伙</p>
<p>此类团伙技术能力较强，并掌握众多攻击资源，核心人员隐匿在国外，以攻击游戏行业头部站点获取佣金为主要获利手段。团伙人员众多，分工明确，有专门的后勤，财务，技术等角色，可发起数百G甚至上T的超大流量攻击。今年4月份在深圳南山法院公开审理的“暗夜”攻击团伙就属于这一类。</p>
<p>2） 页端平台</p>
<p>通过购买国外的发包机（数台至数十台不等），搭建页端DDoS攻击平台，并吸引攻击手入驻，通过第三方支付平台充卡交易，目前活跃的此类攻击平台数量在数十家左右，为了防止竞争对手攻击，此类站点基本都会托管在cloudflare。</p>
<p>3） 游离的攻击手</p>
<p>这部分人员手头资源相对有限，以个人作案为主，通过网络支付交易。因业内存在诈骗现象（骗测试或者二手单），个人信用是交易是否成功的关键，对于陌生人会要求押金交易或者第三方担保交易，担保者可获得约10%的提成收入。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490052?w=1210&amp;h=690"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>2. 攻击资源</h3>
<p>据统计，2018上半年DDoS攻击源总数超过1500万，主要来自于国内，占比达到59%，主要聚集在3个区域：环渤海区域，江浙以及广东，其中山东省遥遥领先。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490053?w=459&amp;h=358"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>国外的攻击源占比41%，美国，俄罗斯，阿根廷是主要的来源国家。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490054?w=457&amp;h=388"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>3. 攻击手法</h3>
<p>整体来看，通过UDPFLOOD或者SYNFLOOD来造成带宽拥塞仍然是攻击者的首选策略。其中UDP反射放大攻击因为其可观的放大效果，以及可以隐藏行踪的特点，深受攻击者的青睐，在攻击手法占比接近60%。 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490055?w=403&amp;h=326"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>另外，随着各国对于通过DDoS攻击进行的犯罪活动呈现高压态势，躲避司法追捕成为攻击者确保的目标。2018上半年，共发现有3种可隐匿行踪的新攻击手法被攻击者发掘出来。</p>
<p>自1月份以来。MEMCACHED反射手法以其高达50000倍的放大效率，全球超过10万的可用主机，成为攻击者发起DDoS攻击的利器。从下图可以看出在短短6个月内，MEMCACHED反射手法的占比从不足1%迅速增长到31%，并制造了数次上Tb的DDoS攻击。根据某国外DDoS站点的统计，国外攻击者选用MEMCACHED反射手法的占比也高达54%。MEMCACHED反射手法的威力可见一斑。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490056?w=750&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>另外，今年3月份，基于IPMI协议的UDP反射攻击也被攻击者挖掘出来。此类攻击手法的特征为放大比例为1.1倍，攻击源绝大部分位于北美洲和欧洲等发达地区，IDC服务器占比达90%等。由于可以隐藏行踪，也被黑产攻击者挖掘出来。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490057?w=617&amp;h=302"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>特别的，之前的反射型攻击基本集中在UDP协议上，但是上半年出现了基于TCP协议的反射攻击。攻击者通过伪造受害者的IP作为源地址，向互联网上开放常见TCP端口的IP发送SYN包，引发受害者IP收到大量以上述端口为源端口的SYN_ACK包，导致被攻击服务器CPU飙升，网络拥塞，服务中断等严重后果。此外，发现这些源IP的攻击报文存在TCP超时重传等协议栈行为，防护难度更大 。</p>
<p>在一次针对某游戏行业客户的攻击中，经统计分析，攻击过程中共采集到近百万个攻击源，源端口聚集在常见的TCP端口：80/443/23/22/3389等端口（占比超过80%）。经过探测，发现绝大多数IP的对应端口都是存活的，很明显这个就是利用TCP协议发起的反射攻击。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490058?w=712&amp;h=601"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>0x03 2018年上半年游戏行业DDoS威胁分析</h2>
<h3>1. 游戏行业DDoS威胁概述</h3>
<p>1）攻击占比（39%）和攻击峰值（1.23Tbps）均为各行业第一</p>
<p>2）平均攻击峰值9.4G</p>
<p>3）平均持续时长1759秒</p>
<p>4）最长持续时长 766744秒</p>
<p>5）平均攻击成本 300元/次，高防用户攻击成本500元/次，棋牌类用户攻击成本 5000~10000元/天</p>
<h3>2.  DDoS攻击的游戏细分行业分布</h3>
<p>上半年，游戏行业的DDoS攻击占比接近40%。其中游戏行业细分行业中，手游（占比32%）和页游（占比15%）是攻击最多的品类。此外，棋牌类游戏的攻击占比为9%，也是DDoS攻击较多的细分行业。 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490059?w=465&amp;h=401"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>3. 游戏行业DDoS攻击的时间分布</h3>
<p>通过分析发现，绝大部分攻击的时长在5分钟以内（占比58%），但是也有5%的攻击成了持续时间超过12小时的持久战。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490060?w=463&amp;h=442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在攻击发起的时机方面，一年365天黑产攻击者都保持在线，并且在元旦，除夕等节假日，攻击者也会突然爆发。相对而言，每天的21点~23点成为攻击者最亢奋的时段。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490061?w=600&amp;h=310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490062?w=463&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>4.  游戏行业攻击案例</h3>
<p><strong>1）某热门端游炸房团伙的“炸房”对抗</strong></p>
<p>攻：代练团伙为确保游戏战绩，在战局不利时使用炸房外挂，调用国外第三方流量压测网站服务发起攻击，以UDP反射、UDP小包、业务报文回放等方式发起攻击，引发对局内玩家掉线，从而消除战败记录提升战绩。</p>
<p>防：依托行业领先的水印方案并加入动态防护特征，并通过四轮交锋，炸房攻击100%防护，并可识别出恶意玩家。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490063?w=401&amp;h=464"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>2）腾讯云成功防御国内已知最大流量DDoS攻击1.23Tbps</strong></p>
<p>攻：某游戏公司自18年初以来，连续2个多月遭到到不法份子的DDoS攻击，单月最多攻击次数超过1000次，攻击类型主要为拥塞带宽型+连接型攻击+应用层攻击。</p>
<p>防：指派DDoS防护专家成立应急响应专家小组，并与客户公司的运维团队一起，依据业务特点，引导用户接入腾讯云T级防护容量的高防节点，优化防护策略，多轮对抗，并在4月8日<a href=""https://cloud.tencent.com/developer/article/1155572"" rel=""nofollow noreferrer"">成功防御了1.23Tbps的</a>国内已知最大流量DDoS攻击。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015490064?w=578&amp;h=299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p><strong>3）未雨绸缪防范针对IPv6的攻击</strong></p>
<p>攻：今年4月，美国Neustar公司的网络专家发现，有1900个IPv6地址正在对公司的DNS服务器发起DDoS攻击，这是今年公开报导的互联网上首例针对IPv6目标的DDoS攻击。</p>
<p>防：腾讯云从去年就开始紧张有序部署新一代DDoS防护系统，同时对IPv6进行了适配。该方案基于双协议栈技术，同时支持IPv4/IPv6介入。</p>
<h2>0x04 游戏行业DDoS防护困境</h2>
<p><strong>1.攻击手法愈加复杂</strong></p>
<p>防护困境：攻击手法呈现多样化，复合化，并且不断有新攻击手法涌现。常规抗D产品样本少，迭代慢，另外中小企业的安全能力存在短板，DDoS对抗经验不足，业务很容易被打穿导致业务受损。</p>
<p>解决措施：腾讯云新一代游戏高防解决方案，依托有丰富对抗经验的专业团队，在为大量腾讯自营业务以及海量腾讯云用户服务时可收集大量的攻击样本，在第一时间感知到新威胁，可以快速迭代，给出最佳防护策略。</p>
<p><strong>2. 攻击流量节节攀升</strong></p>
<p>防护困境：目前攻击流量每年都有大幅增长，为了防范DDoS攻击就需要搭建较大的网络带宽和安全设备集群，对于成长型企业来说，面临的冲击和负担十分沉重。</p>
<p>解决措施：腾讯云新一代游戏高防解决方案在全国多个城市构建T级防护容量的高防节点，帮助用户成功防御了国内已知最大流量DDoS攻击。</p>
<p><strong>3. 黑产低门槛化，攻防成本不对等</strong></p>
<p>防护困境：部分手法可以将流量放大数十倍乃至数万倍，黑产工具由专业团伙开发，初中毕业的人员经过黑产团伙训练，即可发起数百G的攻击，动辄给被攻击企业造成数百万的损失。</p>
<p>解决措施：腾讯云对DDoS攻击相关的情报进行持续监测，对部分严重威胁到腾讯云用户以及对行业正常秩序的危害较大的DDoS黑产团伙，和国家有关部门一起，进行持续的刑事打击。</p>
<p><strong>0x05游戏行业DDoS攻击应对建议</strong></p>
<p><strong>1．标杆型客户</strong></p>
<p>1）建议配置BGP高防IP+三网高防IP，隐藏源站IP。用高防IP充足的带宽资源应对可能的大流量攻击行为，辅助IP自动调度能力。</p>
<p>2）建议通过共享防护包的方式，覆盖所有公网服务。</p>
<p>3）订阅云计算厂商的威胁情报。在行业内出现威胁爆发时进行必要的演练。</p>
<p>4）在面对高等级DDoS威胁时，接入云计算厂商的行业解决方案，必要时请求DDoS防护厂商的专家服务。</p>
<p><strong>2．成长型客户</strong></p>
<p>1）建议配置BGP高防IP+三网高防IP，隐藏源站IP。用高防IP充足的带宽资源应对可能的大流量攻击行为，辅助IP自动调度能力。</p>
<p>2）在发生超大流量攻击时购买超大容量三网高防，切换到三网高防。</p>
<p>3）面临超大流量攻击时封禁海外流量，或者封禁业务主要面向省份之外的攻击主要来源省份流量。</p>
<p><strong>3．传统端游客户</strong></p>
<p>1）建议配置BGP共享高防包产品，对服务器进行全面防护。</p>
<p>2）与云计算厂商合作，接入传统端游行业解决方案。</p>
<p>3）建议通过共享防护包的方式，覆盖所有公网服务。</p>
<p>4）新游发布，重点业务保障，可以考虑水印防护和高防IP方案。</p>
<p><strong>4．手游客户</strong></p>
<p>1）对核心服务开通一定容量的弹性防护的BGP高防包。</p>
<p>2）与云计算厂商合作，接入手游行业解决方案（集成网络加速，CDN等）。</p>
<p>3）建议通过共享防护包的方式，覆盖所有公网服务。</p>
<p>4）新游发布，重点业务保障，可以考虑水印防护和高防IP方案。</p>
<p>5）开通海外高防。</p>
<p>了解更多腾讯云新一代高防产品相关信息，请戳：<a href=""https://cloud.tencent.com/product/aegis?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/pro...</a></p>
<hr>
<blockquote>
<h3><strong>问答</strong></h3>
<p><a href=""https://cloud.tencent.com/developer/ask/122850?fromSource=waitui"" rel=""nofollow noreferrer"">是否有一种方法以编程方式测试浏览器GPU加速？</a> </p>
<h3><strong>相关阅读</strong></h3>
<p><a href=""https://cloud.tencent.com/developer/article/1087955?fromSource=waitui"" rel=""nofollow noreferrer"">深入浅出DDoS攻击防御</a> </p>
<p><a href=""https://cloud.tencent.com/developer/article/1040050?fromSource=waitui"" rel=""nofollow noreferrer"">让子弹多飞一会 | 论如何优化DDoS</a> </p>
<p><a href=""https://cloud.tencent.com/developer/article/1156822?fromSource=waitui"" rel=""nofollow noreferrer"">绝地求生外挂源代码被公布，或迎神仙大战时代？</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1155572?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", 2018上半年游戏行业DDoS态势报告,1531977856,417,1,174,1,1,https://segmentfault.com/a/1190000015490043
17,1,0,9,"
                    
<p>在JavaScript世界中，有些操作会让你无法理解，但是却无比优雅。比如下面这些：<br><span class=""img-wrap""><img data-src=""/img/bVbcLt1?w=225&amp;h=225"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""3e630000bc75493a7458"" title=""3e630000bc75493a7458""></span></p>
<p><strong>5种方式实现值交换</strong></p>
<p>下面几种方式都行</p>
<pre><code>1. var temp = a; a = b; b = temp; (传统，但需要借助临时变量)
2. a ^= b; b ^= a; a ^= b; (需要两个整数)
3. b = [a, a = b][0] (借助数组)
4. [a, b] = [b, a]; (ES6，解构赋值)
5. a = a + b; b = a - b; a = a - b; (小学奥赛题)
</code></pre>
<p><strong>去掉小数部分</strong><br>下面几种方式都行</p>
<pre><code>parseInt(num)
~~numnum &gt;&gt; 0num | 0
</code></pre>
<p><strong>判断 x 是否是整数</strong><br>下面几种方式都行</p>
<pre><code>function isInt(x) { return (x ^ 0) === x
}
// return Math.round(x) === x
// return (typeof x === 'number') &amp;&amp; (x % 1 === 0)
// ES6 -&gt; Number.isInteger()
</code></pre>
<p><strong>递归求阶乘</strong></p>
<pre><code>function factorial(n) { return (n &gt; 1) ? n * f(n - 1) : n
}
</code></pre>
<p><strong>判断符号是否相同</strong></p>
<pre><code>function sameSign(a, b) { return (a ^ b) &gt;= 0}
</code></pre>
<p><strong>克隆数组</strong></p>
<pre><code>arr.slice(0)
</code></pre>
<p><strong>数组去重</strong></p>
<pre><code>// ES6Array.from(new Set(arr))// ES5arr.filter(function(ele, index, array){ return index===array.indexOf(ele)
})
</code></pre>
<p><strong>数组最大值</strong></p>
<pre><code>function maxArr(arr) { return Math.max.apply(null, arr)
}
</code></pre>
<p><strong>数组最小值</strong></p>
<pre><code>function minArr(arr) { return Math.min.apply(null, arr)
}
</code></pre>
<p><strong>随机获取数组的一个成员</strong></p>
<pre><code>function randomOne(arr) { return arr[Math.floor(Math.random() * arr.length)]
}
</code></pre>
<p><strong>产生随机颜色</strong></p>
<pre><code>function getRandomColor() { return `#${Math.random().toString(16).substr(2, 6)}`}
</code></pre>
<p><strong>随机生成指定长度的字符串</strong></p>
<pre><code>function randomStr(n) { let standard = 'abcdefghijklmnopqrstuvwxyz9876543210'
let len = standard.length let result = ''
for (let i = 0; i &lt; n; i++) {
result += standard.charAt(Math.floor(Math.random() * len))
} return result
}
</code></pre>
<p><strong>深拷贝</strong></p>
<pre><code>JSON.parse(JSON.stringify(obj))
</code></pre>
<p><strong>打印出来看看</strong></p>
<pre><code>console.log(([][[]] + [])[+!![]] + ([] + {})[!+[] + !![]])
console.log((!(~+[]) + {})[--[~+''][+[]] * [~+[]] + ~~!+[]] + ({} + [])[[~!+[]] * ~+[]])
美化console
console.info(""%c哈哈"", ""color: #3190e8; font-size: 30px; font-family: sans-serif"");


</code></pre>
<blockquote>相信还是有想要学习或者了解web前端编程的小伙伴，可以来我的web前端学习裙哦575308719可以免费领取精品的web前端学习教程哦！</blockquote>

                ", JavaScript骚操作,1531977858,493,1,494,1,1,https://segmentfault.com/a/1190000015396476
18,1,0,9,"
                    
<blockquote>为打通游戏人生擂台赛与线下商家的O2O衔接，同时响应时下日臻火热的微信小程序，项目团队决定也开发一款针对性的微信小程序，以此方便商家在我们平台入驻并进行擂台赛事的创建和奖励的核销，进一步推广擂台赛的玩法模式和渠道来源。以下是我们作为部门团队内第一批吃螃蟹者，在这款微信小程序开发过程中踩过的一些坑以及总结，与大家一起分享，也欢迎指正和交流。</blockquote>
<p><strong>作者：一时两无 | 腾讯互娱高级开发工程师 本文由<a href=""https://cloud.tencent.com/developer/column/4005?fromsource=wechat"" rel=""nofollow noreferrer"">微信平台开发</a>发表在<a href=""https://cloud.tencent.com/developer?fromsource=wechat"" rel=""nofollow noreferrer"">腾讯云+社区</a></strong> </p>
<p>目前【腾讯游戏人生】小程序已经发布上线，大家可以扫小程序码进行体验。接下来主要介绍在开发该款小程序过程中的一些思考和积累。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393893"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>一、基础普及</h2>
<h3>1.1简介</h3>
<p>微信小程序是微信公众平台推出除<strong>服务号、订阅号、企业号</strong>外的第四种微信内应用类型，它是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的仿原生app的交互使用体验和实用功能。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393894?w=619&amp;h=278"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>我们可以方便的在微信公众平台进行小程序的注册和提交资料，与微信公众号的注册流程较为一致。</p>
<h3>1.2配置</h3>
<p>用户配置：小程序管理平台提供用户管理功能，支持添加1个<strong>管理员</strong>，根据帐号类型和是否认证分别支持配置不同数目的<strong>开发者</strong>和<strong>体验者</strong>帐号权限，这些配置在小程序开发和内测阶段十分有用，即是一个官方的白名单配置功能。</p>
<p>开发配置：与微信公众号其他帐号开发接入配置类似，需要分别设置<strong>开发者ID和密钥</strong>、<strong>服务器域名配置</strong>、<strong>开发消息接入地址</strong>等信息，可参考小程序开发文档逐一设置，对于有开发公众号经验的同学来说也比较快速入手，只是需要注意这里的域名接入都必须要是<strong>https的服务域名地址</strong>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393895"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>二、开发注意</h2>
<h3>2.1页面模型</h3>
<p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page组成，可以看做是<strong>一系列页面的组合</strong>集成，由<strong>一个全局app对象</strong>调度运行。页面模型是小程序里的一个很重要的概念，从小程序配置文件app.json中也可以看到(如下所示)，在app.json中注册的页面地址才可以被调用和打开展示。小程序的展示页面主要分为<strong>tabbar页</strong>和<strong>常规页</strong>两种，而只有tabbar页才会有底部tabbar显示，两类页面对应的跳转方式api也不同：</p>
<ul>
<li>对于tabbar页地址(例 page/xxx/xxx)，调用<strong>wx.switchTab(OBJECT)</strong>进行跳转；</li>
<li>对于常规页地址(例 page/xxx/x1)，调用<strong>wx.navigateTo(OBJECT)</strong>或<strong>wx.redirectTo(OBJECT)</strong>进行跳转</li>
</ul>
<pre><code class=""json"">{
  ""pages"": [
    ""page/xxx/x1"",
    ""page/yyy/y1""
  ],
  ""window"": {
    ""navigationBarTitleText"": ""test""
  },
  ""tabBar"": {
    ""list"": [{
      ""pagePath"": ""page/xxx/xxx"",
      ""iconPath"": ""image/xxx.png"",
      ""text"": ""tab1""
    }, {
      ""pagePath"": ""page/yyy/yyy"",
      ""iconPath"": ""image/yyy.png"",
      ""text"": ""tab2""
    }]
  },
  ""networkTimeout"": {
    ""request"": 10000,
    ""uploadFile"": 10000
  },
  ""debug"": true
}</code></pre>
<p>对于一个具体的页面模型，都有其内部独立的逻辑和数据作用域。主要包括四个组成文件，且必须要有<strong>相同的路径目录和文件名</strong>，例如：首页对应/page/index/目录下的index.js、index.wxml、index.wxss、index.json文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393896"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>页面的初始化、渲染、交互等逻辑都可以通过页面js进行事件监听和函数调用进行响应和处理，类似做web前端开发一样，只是需要特别注意该js开发与web前端js开发的部分不同之处：</p>
<ul>
<li>页面逻辑运行在Jscore中，非webview，<strong>无window、body、document</strong>等dom对象结构；</li>
<li>
<strong>无页面cookie</strong>，无法设置网络请求header的<strong>refer</strong>；</li>
<li>
<strong>不支持类似jquery、zepto</strong>等对象拾取插件和操作方式，视图更新通过数据绑定方式实现；</li>
<li>页面展示结构主要由官方<strong>原生组件</strong>拼装展示，并通过<strong>对应支持的有限的事件函数</strong>进行响应控制，扩展化较低；</li>
<li>页面数据的改变通过调用<strong>Page.setData</strong>函数回显页面组件展示，页面组件的动作事件值；<strong>e.detail.value</strong>可以传递给事件响应函数重设页面数据，以此达到页面数据和组件的<strong>联动绑定</strong>
</li>
</ul>
<h3>2.2生命周期</h3>
<p>小程序的运行和各页面的展示都有其特定的生命周期，并通过一系列的声明周期函数进行调度控制。例如app全局实例的onLaunch、onShow、onHide等监听函数来响应小程序初始化和显影时的控制逻辑。而对于page页面则拥有更为丰富的监听调控函数，实现页面生命周期中更多情况的控制处理。</p>
<table>
<thead><tr>
<th>函数定义</th>
<th>函数功能</th>
</tr></thead>
<tbody>
<tr>
<td>onLoad</td>
<td>生命周期函数--监听页面加载</td>
</tr>
<tr>
<td>onReady</td>
<td>生命周期函数--监听页面初次渲染完成</td>
</tr>
<tr>
<td>onShow</td>
<td>生命周期函数--监听页面显示</td>
</tr>
<tr>
<td>onHide</td>
<td>生命周期函数--监听页面隐藏</td>
</tr>
<tr>
<td>onUnload</td>
<td>生命周期函数--监听页面卸载</td>
</tr>
<tr>
<td>onPullDownRefresh</td>
<td>页面相关事件处理函数--监听用户下拉触底动作</td>
</tr>
<tr>
<td>onReachBottom</td>
<td>页面相关事件处理函数--监听用户上拉触底动作</td>
</tr>
</tbody>
</table>
<p>下图说明了小程序page页面实例的生命周期运作：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393897"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>而针对小程序内部的多个页面之间的切换展示管理，则由小程序框架路由和页面栈控制托管，并通过路由标签或<strong>导航方式api</strong>函数进行页面切换。需要注意的是页面初始化第一次onLoad后如果只是onHide在后台不展示而并未onUnload销毁，下次再切回该页面展示时，不会再触发onLoad监听，而是触发onShow监听；onShow在页面的初始化或每次展示时都会触发，因此这里有个小技巧，部分需要实时更新展示到页面的数据可在onShow中进行获取处理。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393898"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>三、数据处理</h2>
<h3>3.1数据请求</h3>
<p>小程序里的网络请求主要由<strong>wx.request(OBJECT)、wx.uploadFile(OBJECT)</strong>等api访问小程序配置的https域名url接口实现。前者类似于ajax请求，后者通常用来上传图片文件等。这里请求API有些坑需要注意：</p>
<ul>
<li>请求不支持设置header的refer；</li>
<li>请求url不允许带自定义端口，只能是默认80端口；</li>
<li>请求content-type默认为<strong>'application/json'</strong>，如需用POST请求则需改为<strong>'application/x-www-form-urlencoded'</strong>或<strong>'multipart/form-data'</strong>，否则后台请求里得不到post数据；</li>
<li>后台接收请求php里最好用json_decode（file_get_contents(""php://input"")）方式获取完整的post数据，否则如果传递较为复杂的多层post数据结构体，直接用$_POST等可能导致获取数据格式异常或失败</li>
</ul>
<p>小程序里的数据请求操作最好都需要进行登录态安全校验，我们在这里仿造之前做H5项目的微信授权校验方式，把调用微信登录和授权后获得的openid等数据进行加密获取一个ticket票据，并设有过期时间，小程序的每个数据请求则需要附加携带openid和该ticket参数在后台php里进行校验，成功则正常进行后续请求和返回数据，失败则告知小程序客户端重新登录和授权后再请求数据。校验的核心算法也较为简单，就是判断在ticket有效期时间内是否满足如下等式：</p>
<p>而登录和授权后初始的ticket生成也即用的该算法左式生成，并返回小程序本地缓存记录，下次请求可从缓存取出直接应用。</p>
<p>最后对小程序里的所有数据请求进行了处理，封装了GET/POST请求的header设置、登录态参数的附加和过期处理、请求loading效果的显隐控制等逻辑，并设置在app全局对象的暴露方法<strong>httpRequest</strong>中，方便在各子页面调用处理。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393899"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>由于我们的小程序需要根据用户身份展现不同状态的tabbar首页，因此需要把用户身份信息的请求前置，这里设计了一个loading过渡页面，且刚好在这个页面进行了微信登录和授权，并得到登录态参数初始化，然后请求了用户的身份后设置到app全局数据，并在tabbar首页进行对应判断和展示。</p>
<table>
<thead><tr>
<th> </th>
<th> </th>
<th> </th>
<th> </th>
</tr></thead>
<tbody><tr>
<td>首页-默认</td>
<td>首页-待审核</td>
<td>首页-已通过</td>
<td>首页-已被拒</td>
</tr></tbody>
</table>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h3>3.2页面通信</h3>
<p>我们的小程序里有需要商家注册和创建擂台的功能页面，需要填写的信息和层级较多，不足以一屏展示和填写，因此需要支持数据在跨页面间的传递和调用的通信能力，且对数据进行完整、有效和安全的管理，并实时响应页面更新展示。基于小程序本身提供的api和特点，也查阅了一些资料，主要得到如下几种思路和方法：</p>
<table>
<thead><tr>
<th>类别</th>
<th>说明</th>
<th>优点</th>
<th>缺点</th>
</tr></thead>
<tbody>
<tr>
<td>navigate跳转+url参数</td>
<td>利用navigate标签或api跳转时附加需要的数据作为url参数一起跳转</td>
<td>不需额外代码或插件，代码简单</td>
<td>参数较多时url过长混乱、tabbar页不支持url传参数</td>
</tr>
<tr>
<td>缓存数据存储公用</td>
<td>利用app的globalData全局数据或本地缓存Storage的api实现数据缓存和公用处理</td>
<td>全局或本地缓存数据获取和改写，操作便捷有条理，容易理解</td>
<td>需要在相关各页面注意全局或缓存数据的改写和销毁，保持数据安全一致，避免被随意改写污染。</td>
</tr>
<tr>
<td>PubSub或watcher机制</td>
<td>利用事件发布订阅或监听机制，开发对应插件，各页面引入插件对所需数据进行订阅或监听处理。</td>
<td>基于插件化数据驱动实现，页面可按需加入订阅或监听数据的处理，单一数据源，便于调试</td>
<td>需引入额外插件，且需解决页面多次show、hide等导致的重复订阅或监听绑定，有程序崩溃风险</td>
</tr>
<tr>
<td>页面路由栈</td>
<td>利用小程序自带getCurrentPages的api获取页面路由栈，并根据页面序号获取和操作所需页面对象</td>
<td>代码逻辑清晰，能更为便捷获取和处理所需页面对象的数据，数据只有原页面对象单独一份，且由其内部托管销毁，无数据污染风险。在目标页面对此数据的修改可通过setData实时响应更新到原页面展示</td>
<td>需要稍微注意页面栈深度变化和所需页面对象的获取</td>
</tr>
</tbody>
</table>
<p>我们考虑到表单数据较多，且产品需求表单需要本地草稿的功能，下次再打开可显示上次填写数据，无需重新再次填写，因此最终结合了缓存和页面路由栈的功能进行实现。在表单主页面A利用localStorage缓存托管表单全体数据formData，并在子页面B用页面栈getCurrentPages获取和操作主页面A的表单某块子数据formData.subData，子页面B的修改操作通过A.setData实时传递和通知主页面A的刷新展示，主页面A在onUnload中响应对localstoreage的修改保存，便于下次加载读取。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015393901"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>四、代码维护</h2>
<h3>4.1公用配置</h3>
<p>小程序代码中涉及的较多数据、参数、接口、文案等自定义信息，可做成统一本地化配置，放入app实例的全局数据中公用，便于各子页面获取处理，同时结合小程序loading初始化时进行远程请求更新配置。这样的好处是，可以兼容配置信息更新与否情况下的配置统一管理。当需要配置更新时，能从远程拉取替换，而不需要修改小程序的代码文件，重新再走代码发布及等待审核的流程。</p>
<h3>4.2传图组件</h3>
<p>小程序中注册商家资料和创建擂台时都涉及到了图片的上传处理，用到了小程序官方的传图样式组件和API，同时需要调用统一的后台上传图片生成URL的接口。因此这里有必要可以进行组件模块化封装的代码优化，便于在多个page页面内引入调用。</p>
<ul><li>picloader.wxml</li></ul>
<pre><code class=""js"">&lt;template name=""picloader""&gt;
    &lt;view class=""weui-cells weui-cells_after-title""&gt;
        &lt;view class=""weui-cell""&gt;
            &lt;view class=""weui-cell__bd""&gt;
                &lt;view class=""weui-uploader""&gt;
                    &lt;view class=""weui-uploader__hd""&gt;
                        &lt;view class=""weui-uploader__title""&gt;{{title}}&lt;/view&gt;
                    &lt;/view&gt;
                    &lt;view class=""weui-uploader__bd""&gt;
                        &lt;view class=""weui-uploader__files""&gt;
                            &lt;block wx:if=""{{picture}}""&gt;
                                &lt;view class=""weui-uploader__file"" bindtap=""previewImage"" data-obj=""{{name}}""&gt;
                                    &lt;image class=""weui-uploader__img"" src=""{{picture}}"" mode=""aspectFill"" /&gt;
                                &lt;/view&gt;
                            &lt;/block&gt;
                            &lt;input id=""{{name}}"" name=""{{name}}"" hidden=""{{true}}"" value=""{{picture}}""/&gt;
                        &lt;/view&gt;
                        &lt;view class=""weui-uploader__input-box""&gt;
                            &lt;view class=""weui-uploader__input"" bindtap=""chooseImage"" data-obj=""{{name}}""&gt;&lt;/view&gt;
                        &lt;/view&gt;
                    &lt;/view&gt;
                &lt;/view&gt;
            &lt;/view&gt;
            &lt;view class=""weui-cell__ft""&gt;&lt;icon type=""{{validate}}""/&gt;&lt;/view&gt;
        &lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;</code></pre>
<ul><li>picloader.js</li></ul>
<pre><code class=""js"">const app = getApp();

function init(pageDelegate) {
  //1.初始化图片上传种子HASH值
  app.httpRequest({
      url:app.Utils.getRequestUrl(""getUploadHash""),
      success: function( res ) {
          if(res.r== ""0""){
              pageDelegate.setData({
                  _hash:res._hash
              });
          }
      },
  },false);

  //2.绑定选择图片事件
  pageDelegate.chooseImage = function (e) {
    var that = this;
    var uploadUrl = app.Config.uploadBase;
    var obj = e.currentTarget.dataset.obj;//修改对象名
    if (e.currentTarget.dataset.ratio) {//尺寸比例限制
      uploadUrl += ""?size_ratio="" + e.currentTarget.dataset.ratio;
    }

    wx.chooseImage({
        sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有
        sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有
        count:1,
        success: function (res0) {
            // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片
            app.uploadRequest({
                url:uploadUrl,
                filePath: res0.tempFilePaths[0],
                data:{
                    _hash:that.data._hash
                },
                success:function(res){
                    var picurl = res.url || """";
                    var tmpData = {};
                    tmpData[""formData."" + obj] = picurl;
                    that.setData(tmpData);
                    app.Utils.checkValid(obj, picurl,that);
                    if (res.r != ""0"" &amp;&amp; res.msg){
                      wx.showModal({
                        title: '图片上传失败',
                        content: res.msg,
                        showCancel: false,
                        success: function (res) {
                        }
                      });
                    }
                }
            })
        }
    })
  }

  //3.绑定预览图片事件
  pageDelegate.previewImage = function (e) {
    var obj = e.currentTarget.dataset.obj;//修改对象名
    var pic = this.data.formData[obj] || """";
    if(pic == """"){
        return false;
    }
    
    wx.previewImage({
        current: e.currentTarget.id,
        urls: [pic] // 需要预览的图片http链接
    });
  }
}

//模块化
module.exports = {
  init: init
}</code></pre>
<ul><li>使用示例wxml中：</li></ul>
<pre><code class=""xml"">&lt;import src=""/page/common/picloader.wxml""/&gt;
&lt;template is=""picloader"" data=""{{title: '奖励图片上传',picture:formData.award_pic,validate:validate.award_pic,name:'award_pic'}}""/&gt;</code></pre>
<ul><li>使用示例js中：</li></ul>
<pre><code class=""js"">const app = getApp();
var picloader = require('/utils/picloader.js');

Page({
  data:{
      ...
  },
  onLoad:function(options){
      // 页面初始化 options为页面跳转所带来的参数

      //注册图片上传组件
      picloader.init(this);
  },
  ...
})</code></pre>
<h3>4.3分片模版</h3>
<p>小程序tabbar首页的需求是根据不同的用户身份展现不同状态的首页，有未入驻、待审核、审核通过、审核被拒四种状态，而都需要对应到同一个tabbar首页url。因此这里需要把四种状态的页面片段部分分别做成子模版wxml的形式，通过小程序的条件渲染（wx:if）机制根据用户身份情况按条件调用对应子模版进行展示。</p>
<p>同时小程序较多页面都有共同的头部（banner图）和尾部（联系客服）等片段展示，因此这里也考虑把其做成对应的公用head和foot子模版wxml，便于多页面include引用。</p>
<pre><code class=""xml"">&lt;view class=""page""&gt;
    &lt;include src=""/page/common/head.wxml""/&gt;
    &lt;view class=""weui-msg""&gt;
        &lt;include wx:if=""{{status == 1}}"" src=""subpage/wait.wxml""/&gt;
        &lt;include wx:elif=""{{status == 2}}"" src=""subpage/success.wxml""/&gt;
        &lt;include wx:elif=""{{status == 3}}"" src=""subpage/fail.wxml""/&gt;
        &lt;include wx:else src=""subpage/default.wxml""/&gt;
    &lt;/view&gt;
&lt;/view&gt;
&lt;include src=""/page/common/foot.wxml""/&gt;</code></pre>
<h2>五、总结体会</h2>
<p>【腾讯游戏人生】微信小程序开发已经结束，亟待补充产品条款以及发布审核上线。在整个摸索和开发过程中，碰到了许多与web开发不同的别扭之处，也填过不少坑，包括参与小程序实现的设计、重构和前端开发都是一个新的尝试与体验。也对此有一些思考和总结，具体如下归纳。目前感觉小程序比较适用于一些旨在更快速和有效推广自己轻量功能的小应用模式，不适合较大较重逻辑和功能的开发应用。但相信随着微信官方对小程序支持力度的不断增加，小程序的功能和推广也将得到进一步扩大，接入和开发成本的同步降低，也会受到越来越多的开发者欢迎和喜爱。</p>
<table>
<thead><tr>
<th>优势</th>
<th>劣势</th>
</tr></thead>
<tbody>
<tr>
<td>接入门槛低，参照公众号接入方便，当下热潮</td>
<td>官方设定的配置和开发模式严格，需限定范围内进行搭建</td>
</tr>
<tr>
<td>使用体验较H5好，流畅度高，体积小，传播效益快</td>
<td>功能体验限于限有组件交互，定制扩展化较弱，相比原生app体验及高级功能还是较少</td>
</tr>
<tr>
<td>学习成本低，代码组织清晰，开发灵活度高，开发文档明确</td>
<td>不支持web开发中部分常用的功能特性，有时开发有些不便和局限性。</td>
</tr>
<tr>
<td>微信官方支持度高，内嵌灵活，小程序闭环控制，数据隔离安全可靠</td>
<td>暂不支持跳转H5网页，以及外部APP等交互能力。</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1145916?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", 《腾讯游戏人生》微信小程序开发总结,1531977860,182,1,674,1,1,https://segmentfault.com/a/1190000015393890
19,1,0,9,"
                    
<p>要说起GO语言的优势，我们就得从GO语言的历史讲起了……</p>
<blockquote>本文由<a href=""https://cloud.tencent.com/developer/user/170434?fromsource=wechat"" rel=""nofollow noreferrer"">腾讯技术工程官方号</a>发表在<a href=""https://cloud.tencent.com/developer?fromsource=wechat"" rel=""nofollow noreferrer"">腾讯云+社区</a>
</blockquote>
<p><strong>2007年，受够了C++煎熬的Google首席软件工程师Rob Pike纠集Robert Griesemer和Ken Thompson两位牛人，决定创造一种新语言来取代C++, 这就是Golang。出现在21世纪的GO语言，虽然不能如愿对C++取而代之，但是其近C的执行性能和近解析型语言的开发效率以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发，不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。</strong></p>
<p><strong>被称为GO语言之父的Rob Pike说，你是否同意GO语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Rob Pike以一种非常朴素的方式，概括了GO语言的整个设计哲学--将简单、实用体现得淋漓尽致。</strong></p>
<p><strong>很多人将GO语言称为21世纪的C语言，因为GO不仅拥有C的简洁和性能，而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性，让开发者在语言级别就可以方便的得到自己想要的东西。</strong></p>
<h2><strong>发展历史</strong></h2>
<p>2007年9月，Rob Pike在Google分布式编译平台上进行C++编译，在漫长的等待过程中，他和Robert Griesemer探讨了程序设计语言的一些关键性问题，他们认为，简化编程语言相比于在臃肿的语言上不断增加新特性，会是更大的进步。随后他们在编译结束之前说服了身边的Ken Thompson，觉得有必要为此做一些事情。几天后，他们发起了一个叫Golang的项目，将它作为自由时间的实验项目。</p>
<p>2008年5月 Google发现了GO语言的巨大潜力，得到了Google的全力支持，这些人开始全职投入GO语言的设计和开发。</p>
<p>2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。</p>
<p>2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。</p>
<p>在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。</p>
<h2><strong>开发团队</strong></h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323553"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>GO语言的开发阵营可以说是空前强大，主要成员中不乏计算机软件界的历史性人物，对计算机软件的发展影响深远。Ken Thompson，来自贝尔实验室，设计了B语言，创立了Unix操作系统（最初使用B语言实现），随后在Unix开发过程中，又和Dennis Ritchie一同设计了C语言，继而使用C语言重构了Unix操作系统。Dennis Ritchie和Ken Thompson被称为Unix和C语言之父，并在1983年共同被授以图灵奖，以表彰他们对计算机软件发展所作的杰出贡献。Rob Pike，同样来自贝尔实验室，Unix小组重要成员，发明了Limbo语言，并且和Ken Thompson共同设计了UTF-8编码，《Unix编程环境》、《编程实践》作者之一。</p>
<p>可以说，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323554"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>大名鼎鼎的Docker，完全用GO实现，业界最为火爆的容器编排管理系统kubernetes，完全用GO实现，之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目如etcd/consul/flannel等等，均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代，但为什么不能换种说法，也是GO语言促使了云的发展？</p>
<p>除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p>
<h2><strong>GO语言关键特性</strong></h2>
<p>GO语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，跟随大师们的脚步，体验GO的设计哲学。 </p>
<p>GO语言的关键特性主要包括以下几方面：</p>
<ul>
<li>并发与协程</li>
<li>基于消息传递的通信方式</li>
<li>丰富实用的内置数据类型</li>
<li>函数多返回值</li>
<li>defer机制</li>
<li>反射(reflect)</li>
<li>高性能HTTP Server</li>
<li>工程管理</li>
<li>编程规范</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323555"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。</p>
<p>对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。</p>
<p><strong>基于消息传递的通信方式</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323556"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在异步的并发编程过程中，只能方便、快速的启动协程还不够。协程之间的消息通信，也是非常重要的一环，否则，各个协程就会成为脱缰的野马而无法控制。在GO语言中，使用基于消息传递的通信方式（而不是大多数语言所使用的基于共享内存的通信方式）进行协程间通信，并且将消息管道(channel)作为基本的数据类型，使用类型关键字(chan)进行定义，并发操作时线程安全。这点在语言的实现上，也具有革命性。可见，GO语言本身并非简单得没有底线，恰恰他们会将最实用、最有利于解决问题的能力，以最简单、直接的形式提供给用户。</p>
<p>Channel并不仅仅只是用于简单的消息通信，还可以引申出很多非常实用，而实现起来又非常方便的功能。比如，实现TCP连接池、限流等等，而这些在其它语言中实现起来并不轻松，但GO语言可以轻易做到。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323557"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>GO语言作为编译型语言，在数据类型上也支持得非常全面，除了传统的整型、浮点型、字符型、数组、结构等类型外。从实用性上考虑，也对字符串类型、切片类型(可变长数组)、字典类型、复数类型、错误类型、管道类型、甚至任意类型(Interface{})进行了原生支持，并且用起来非常方便。比如字符串、切片类型，操作简便性几乎和python类似。</p>
<p>另外，将错误类型(error)作为基本的数据类型，并且在语言级别不再支持try…catch的用法，这应该算是一个非常大胆的革命性创举，也难怪很多人吐槽GO语言不伦不类。但是跳出传统的观念，GO的开发者认为在编程过程中，要保证程序的健壮性和稳定性，对异常的精确化处理是非常重要的，只有在每一个逻辑处理完成后，明确的告知上层调用，是否有异常，并由上层调用明确、及时的对异常进行处理，这样才可以高程度的保证程序的健壮性和稳定性。虽然这样做会在编程过程中出现大量的对error结果的判断，但是这无疑也增强了开发者对异常处理的警惕度。而实践证明，只要严格按GO推荐的风格编码，想写出不健壮的代码，都很难。当然，前提是你不排斥它，认可它。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323558"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在语言中支持函数多返回值，并不是什么新鲜事，Python就是其中之一。允许函数返回多个值，在某些场景下，可以有效的简化编程。GO语言推荐的编程风格，是函数返回的最后一个参数为error类型（只要逻辑体中可能出现异常），这样，在语言级别支持多返回值，就很有必要了。</p>
<h2><strong>Defer延迟处理机制</strong></h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323559?w=1080&amp;h=517"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在GO语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。</p>
<p>可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323560"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>Golang作为强类型的编译型语言，灵活性上自然不如解析型语言。比如像PHP，弱类型，并且可以直接对一个字符串变量的内容进行new操作，而在编译型语言中，这显然不太可能。但是，Golang提供了Any类型(interface{})和强大的类型反射(reflect)能力，二者相结合，开发的灵活性上已经很接近解析型语言。在逻辑的动态调用方面，实现起来仍然非常简单。既然如此，那么像PHP这种解析型语言相比于GO，优势在那里呢？就我个人而言，写了近10年的PHP，实现过开发框架、基础类库以及各种公共组件，虽然执行性能不足，但是开发效率有余；而当遇上Golang，这些优势似乎不那么明显了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323561?w=1080&amp;h=354"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>作为出现在互联网时代的服务端语言，面向用户服务的能力必不可少。GO在语言级别自带HTTP/TCP/UDP高性能服务器，基于协程并发，为业务开发提供最直接有效的能力支持。要在GO语言中实现一个高性能的HTTP Server，只需要几行代码即可完成，非常简单。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323562"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在GO语言中，有一套标准的工程管理规范，只要按照这个规范进行项目开发，之后的事情（比如包管理、编译等等）都将变得非常的简单。</p>
<p>在GO项目下，存在两个关键目录，一个是src目录，用于存放所有的.go源码文件；一个是bin目录，用于存在编译后的二进制文件。在src目录下，除了main主包所在的目录外，其它所有的目录名称与直接目录下所对应的包名保持对应，否则编译无法通过。这样，GO编译器就可以从main包所在的目录开始，完全使用目录结构和包名来推导工程结构以及构建顺序，避免像C++一样，引入一个额外的Makefile文件。</p>
<p>在GO的编译过程中，我们唯一要做的就是将GO项目路径赋值给一个叫GOPATH的环境变量，让编译器知道将要编译的GO项目所在的位置。然后进入bin目录下，执行go build {主包所在的目录名}，即可秒级完成工程编译。编译后的二进制文件，可以推到同类OS上直接运行，没有任何环境依赖。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323563"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。</p>
<h2><strong>API快速开发框架实践</strong></h2>
<p>编程语言是一个工具，它会告诉我们能做什么，而怎么做会更好，同样值得去探讨。这部分会介绍用GO语言实现的一个开发框架，以及几个公共组件。当然，框架和公共组件，其它语言也完全可以实现，而这里所关注的是成本问题。除此之外，抛开GO语言本身不说，我们也希望可以让大家从介绍的几个组件中，得到一些解决问题的思路，那就是通过某种方式，去解决一个面上的问题，而非一味的写代码，最终却只是解决点上的问题。如果你认可这种方式，相信下面的内容也许会影响你之后的项目开发方式，从根本上提高开发效率。</p>
<h2><strong>我们为什么选择GO语言</strong></h2>
<p>选择GO语言，主要是基于两方面的考虑</p>
<ol>
<li>执行性能  缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。   依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。</li>
<li>开发效率 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。  通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。  能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323564"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>很多人在学习一门新语言或开启一个新项目时，都会习惯性的是网上找一个认为合适的开源框架来开始自己的项目开发之旅。这样并没有什么不好，但是个人觉得，了解它内部的实现对我们会更有帮助。或许大家已经注意到了，所说的MVC框架，其本质上就是对请求路径进行解析，然后根据请求路径段，路由到相应的控制器（C）上，再由控制器进一步调用数据逻辑(M)，拿到数据后，渲染视图（V），返回用户。在整个过程中，核心点在于逻辑的动态调用。</p>
<p>不过，对API框架的实现相对于WEB页面框架的实现，会更简单，因为它并不涉及视图的渲染，只需要将数据结果以协议的方式返回给用户即可。</p>
<p>使用GO语言实现一套完整的MVC开发框架，是非常容易的，集成HTTP Server的同时，整个框架的核心代码不会超过300行，从这里可以实际感受到GO的语言描述效率之高（如果有兴趣，可以参考Uwork开源项目seine）。</p>
<p>也有人说，在GO语言中，就没有框架可言，言外之意是说，引入一个重型的开源框架，必要性并不大，相反还可能把简单的东西复杂化。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323565"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在实际项目开发过程中，只有高效的开发语言还不够，要想进一步将开发效率扩大化，不断的沉淀公共基础库是必不可少的，以便将通用的基础逻辑进一步抽象和复用。</p>
<p>除此之外，通用组件能力是实现功能量产的根本，对开发效率会是质的提升。组件化的开发模式会帮忙我们将问题的解决能力从一个点上提升到一个面上。以下会重点介绍几个通用组件的实现，有了它们的存在，才能真正的解放程序员的生产力。而这些强有力的公共组件在Golang中实现起来并不复杂。同时，结合Golang的并发处理能力，相比于PHP的版本实现，执行效率也会有质的提升。这是组件能力和语言效率的完美结合。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323566"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>通用列表组件用于所有可能的二维数据源(如MySQL/MongoDB/ES等等)的数据查询场景，从一个面上解决了数据查询问题。在Uwork项目开发中，被大量使用，实现数据查询接口和页面查询列表的量产开发。它以一个JSON配置文件为中心，来实现对通用数据源的查询，并将查询结果以API或页面的形式自动返回给用户。整个过程中几乎没有代码开发，而唯一要做的只是以一种统一的规范编写配置文件(而不是代码)，真正实现了对数据查询需求的功能量产。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323567"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>以上是通用列表组件的构建过程，要实现这样一个功能强大的通用组件，是不是会给人一种可望而不可及的感觉？其实并非如此，只要理清了它的整个过程，将构建思路融入Golang中，并不是一件复杂的事情。在我们的项目中，整个组件的实现，只用了不到700行Go代码，就解决了一系列的数据查询问题。另外，通过Golang的并发特性，实现字段处理器的并行执行，进一步的提高了组件的执行效率。可以说，通用列表和Golang的融合，是性能和效率的完美结合。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>通用表单组件主要用于对数据库的增、删、改场景。该组件在Uwork的项目开发中，也有广泛的应用，与通用列表类似，以一个JSON配置文件为中心，来完成对数据表数据的增、删、改操作。特别是近期完成的部件级SDB管理平台，通过通用表单实现了对整个系统的数据维护，通过高度抽象化，做到了业务的无代码化生产。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>以上是通用表单的完整构建过程，而对于这个一个组件的实现，我们用了不到1000行的GO代码，就解决了对数据表数据维护整个面上的问题。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323570"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>GO语言本身支持协程并发，协程非常轻量，可以快速启动成千上万个协程工作单元。如果对协程任务的数量控制不当，最后的结果很可能适得其反，从而对外部或本身的服务造成不必要的压力。协程池可以在一定程度上控制执行单元的数量，保证执行的安全性。而在Golang中要实现这样一个协程池，是非常简单的，只需要对channel和goroutine稍加封装，就可以完成，整个构建过程不到80行代码。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323571?w=1080&amp;h=516"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在API开发过程中，数据校验永远是必不可或缺的一个环节。如果只是简单的数据校验，几行代码也许就完成了，可是当遇上复杂的数据校验时，很可能几百行的代码量也未必能完成，特别是遇到递归类型的数据校验，那简直就是一个噩梦。</p>
<p>数据校验组件，可以通过一种数据模板的配置方式，使用特定的逻辑来完成通用校验，开发者只需要配置好相应的数据模板，进行简单的调用，即可完成整个校验过程。而对于这样一个通用性的数据校验组件，在GO语言中只用了不到700行的代码量就完成了整个构建。</p>
<p><strong>小结</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323572"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在实际项目开发过程中，对开发效率提升最大的，无疑是符合系统业务场景的公共组件能力，这点也正好应证了Rob Pike那句话（Less is lessor Less is more），真正的高效率开发，是配置化的，并不需要写太多的代码，甚至根本就不需要写代码，即可完成逻辑实现，而这种方式对于后期的维护成本也是最优的，因为做到了高度的统一。 </p>
<p>GO的语言描述效率毋庸置疑，对上述所有公共组件的实现，均未超过1000行代码，就解决了某个面上的问题。</p>
<p>(以上的部分代码已经在Uwork开源项目seine中提供)</p>
<h2><strong>性能评测</strong></h2>
<p>压力测试环境说明：</p>
<ul>
<li>服务运行机器：单台空闲B6，24核CPU、64G内存。</li>
<li>PHP API环境：Nginx+PHP-FPM，CI框架。其中Nginx启动10个子进程，每个子进程最大接收1024个连接，php-fpm使用static模式，启动2000个常驻子进程。</li>
<li>Golang API环境：使用go1.8.6编译，直接拉起Golang API Server进程(HttpServer)，不考虑调优。</li>
<li>客户发起请求测试程序：使用Golang编写，协程并发，运行在独立的另外一台空闲B6上，24核CPU，64G内存，依次在1-2000个不同级别(并发数步长为50)的并发上分别请求20000次。</li>
</ul>
<p>压力测试结果对比</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015323573?w=1075&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>在Golang API框架中，当并发数&gt;50时，处理QPS在6.5w/s附近波动。表现稳定，压力测试过程无报错。</p>
<p>Nginx+php-fpm，只在index.php中输出exit('ok')，当并发数&gt;50时，处理QPS在1w/s附近波动。表现稳定，压力测试过程无报错。</p>
<p>Nginx+php-fpm+CI框架中，逻辑执行到具体业务逻辑点，输出exit('ok')，当并发数&gt;50时，处理QPS在750/s附近波动。并且表现不稳定，压力测试过程中随着并发数的增大，错误量随之增加。</p>
<p>通过压力测试可以发现，Golang和PHP在执行性能上，并没有什么可比性；而使用Golang实现的HTTP API框架，空载时单机性能QPS达到6.5w/s，还是非常令人满意的。</p>
<h2><strong>开发过程中需要注意的点</strong></h2>
<p>以下是在实际开发过程中遇到的一些问题，仅供参考： </p>
<p>异常处理统一使用error，不要使用panic/recover来模拟throw…catch，最初我是这么做的，后来发现这完全是自以为是的做法。</p>
<p>原生的error过于简单，而在实际的API开发过程中，不同的异常情况需要附带不同的返回码，基于此，有必要对error再进行一层封装。</p>
<p>任何协程逻辑执行体，逻辑最开始处必须要有defer recover()异常恢复处理，否则goroutine内出现的panic，将导致整个进程宕掉，需要避免部分逻辑BUG造成全局影响。</p>
<p>在Golang中，变量(chan类型除外)的操作是非线程安全的，也包括像int这样的基本类型，因此并发操作全局变量时一定要考虑加锁，特别是对map的并发操作。</p>
<p>所有对map键值的获取，都应该判断存在性，最好是对同类操作进行统一封装，避免出现不必要的运行时异常。</p>
<p>定义slice数据类型时，尽量预设长度，避免内部出现不必要的数据重组。</p>
<hr>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1145176?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", 你应该知道Go语言的几个优势 ,1531977861,348,1,220,1,1,https://segmentfault.com/a/1190000015323550
20,1,0,9,"
                    
<blockquote><strong>作者：<a href=""https://cloud.tencent.com/developer/user/1644408?fromsource=waitui"" rel=""nofollow noreferrer"">陈树义</a> | 该文来自<a href=""https://cloud.tencent.com/developer?fromsource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a> <a href=""https://cloud.tencent.com/developer/column/2451?fromsource=waitui"" rel=""nofollow noreferrer"">陈树义</a>的专栏</strong></blockquote>
<p>前几天线上一个项目监控信息突然报告异常，上到机器上后查看相关资源的使用情况，发现 CPU 利用率将近 100%。通过 Java 自带的线程 Dump 工具，我们导出了出问题的堆栈信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015320052?w=1620&amp;h=914"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>我们可以看到所有的堆栈都指向了一个名为 validateUrl 的方法，这样的报错信息在堆栈中一共超过 100 处。通过排查代码，我们知道这个方法的主要功能是校验 URL 是否合法。</p>
<p>很奇怪，一个正则表达式怎么会导致 CPU 利用率居高不下。为了弄清楚复现问题，我们将其中的关键代码摘抄出来，做了个简单的单元测试。</p>
<pre><code class=""java"">public static void main(String[] args) {
    String badRegex = ""^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\\\/])+$"";
    String bugUrl = ""http://www.fapiao.com/dddp-web/pdf/download?request=6e7JGxxxxx4ILd-kExxxxxxxqJ4-CHLmqVnenXC692m74H38sdfdsazxcUmfcOH2fAfY1Vw__%5EDadIfJgiEf"";
    if (bugUrl.matches(badRegex)) {
        System.out.println(""match!!"");
    } else {
        System.out.println(""no match!!"");
    }
}</code></pre>
<p>当我们运行上面这个例子的时候，通过资源监视器可以看到有一个名为 java 的进程 CPU 利用率直接飙升到了 91.4% 。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015320053?w=2278&amp;h=1074"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>看到这里，我们基本可以推断，这个正则表达式就是导致 CPU 利用率居高不下的凶手！</p>
<p>于是，我们将排错的重点放在了那个正则表达式上：</p>
<pre><code>^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\/])+$</code></pre>
<p>这个正则表达式看起来没什么问题，可以分为三个部分：</p>
<p>第一部分匹配 http 和 https 协议，第二部分匹配 www. 字符，第三部分匹配许多字符。我看着这个表达式发呆了许久，也没发现没有什么大的问题。</p>
<p>其实这里导致 CPU 使用率高的关键原因就是：<strong>Java 正则表达式使用的引擎实现是 NFA 自动机，这种正则表达式引擎在进行字符匹配时会发生回溯（backtracking）。</strong>而一旦发生回溯，那其消耗的时间就会变得很长，有可能是几分钟，也有可能是几个小时，时间长短取决于回溯的次数和复杂度。</p>
<p>看到这里，可能大家还不是很清楚什么是回溯，还有点懵。没关系，我们一点点从正则表达式的原理开始讲起。</p>
<h2>正则表达式引擎</h2>
<p>正则表达式是一个很方便的匹配符号，但要实现这么复杂，功能如此强大的匹配语法，就必须要有一套算法来实现，而实现这套算法的东西就叫做正则表达式引擎。简单地说，实现正则表达式引擎的有两种方式：<strong>DFA 自动机</strong>（Deterministic Final Automata 确定型有穷自动机）和 <strong>NFA 自动机</strong>（Non deterministic Finite Automaton 不确定型有穷自动机）。</p>
<p>对于这两种自动机，他们有各自的区别，这里并不打算深入将它们的原理。简单地说，DFA 自动机的时间复杂度是线性的，更加稳定，但是功能有限。而 NFA 的时间复杂度比较不稳定，有时候很好，有时候不怎么好，好不好取决于你写的正则表达式。但是胜在 NFA 的功能更加强大，所以包括 Java 、.NET、Perl、Python、Ruby、PHP 等语言都使用了 NFA 去实现其正则表达式。</p>
<p>那 NFA 自动加到底是怎么进行匹配的呢？我们以下面的字符和表达式来举例说明。</p>
<pre><code>text=""Today is a nice day.""
regex=""day""</code></pre>
<p>要记住一个很重要的点，即：NFA 是以正则表达式为基准去匹配的。也就是说，NFA 自动机会读取正则表达式的一个一个字符，然后拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符，否则继续和目标字符串的下一个字符比较。或许你们听不太懂，没事，接下来我们以上面的例子一步步解析。</p>
<ul>
<li>首先，拿到正则表达式的第一个匹配符：d。于是那去和字符串的字符进行比较，字符串的第一个字符是 T，不匹配，换下一个。第二个是 o，也不匹配，再换下一个。第三个是 d，匹配了，那么就读取正则表达式的第二个字符：a。</li>
<li>读取到正则表达式的第二个匹配符：a。那着继续和字符串的第四个字符 a 比较，又匹配了。那么接着读取正则表达式的第三个字符：y。</li>
<li>读取到正则表达式的第三个匹配符：y。那着继续和字符串的第五个字符 y 比较，又匹配了。尝试读取正则表达式的下一个字符，发现没有了，那么匹配结束。</li>
</ul>
<p>上面这个匹配过程就是 NFA 自动机的匹配过程，但实际上的匹配过程会比这个复杂非常多，但其原理是不变的。</p>
<h2>NFA自动机的回溯</h2>
<p>了解了 NFA 是如何进行字符串匹配的，接下来我们就可以讲讲这篇文章的重点了：回溯。为了更好地解释回溯，我们同样以下面的例子来讲解。</p>
<pre><code class=""java"">text=""abbc""
regex=""ab{1,3}c""</code></pre>
<p>上面的这个例子的目的比较简单，匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 对其解析的过程是这样子的：</p>
<ul>
<li>首先，读取正则表达式第一个匹配符 a 和 字符串第一个字符 a 比较，匹配了。于是读取正则表达式第二个字符。</li>
<li>读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 比较，匹配了。但因为 b{1,3} 表示 1-3 个 b 字符串，以及 NFA 自动机的贪婪特性（也就是说要尽可能多地匹配），所以此时并不会再去读取下一个正则表达式的匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 比较，发现还是匹配。于是继续使用 b{1,3} 和字符串的第四个字符 c 比较，发现不匹配了。此时就会发生回溯。</li>
<li>发生回溯是怎么操作呢？发生回溯后，我们已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符串的位置。之后，程序读取正则表达式的下一个操作符 c，读取当前指针的下一个字符 c 进行对比，发现匹配。于是读取下一个操作符，但这里已经结束了。</li>
</ul>
<p>下面我们回过头来看看前面的那个校验 URL 的正则表达式：</p>
<pre><code>^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\/])+$</code></pre>
<p>出现问题的 URL 是：</p>
<pre><code>http://www.fapiao.com/dzfp-web/pdf/download?request=6e7JGm38jfjghVrv4ILd-kEn64HcUX4qL4a4qJ4-CHLmqVnenXC692m74H5oxkjgdsYazxcUmfcOH2fAfY1Vw__%5EDadIfJgiEf</code></pre>
<p>我们把这个正则表达式分为三个部分：</p>
<ul>
<li>第一部分：校验协议。<code>^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)</code>。</li>
<li>第二部分：校验域名。<code>(([A-Za-z0-9-~]+).)+</code>。</li>
<li>第三部分：校验参数。<code>([A-Za-z0-9-~\\/])+$</code>。</li>
</ul>
<p>我们可以发现正则表达式校验协议 <code>http://</code> 这部分是没有问题的，但是在校验 www.fapiao.com 的时候，其使用了 <code>xxxx.</code> 这种方式去校验。那么其实匹配过程是这样的：</p>
<ul>
<li>匹配到 www.</li>
<li>匹配到 fapiao.</li>
<li>匹配到 <code>com/dzfp-web/pdf/download?request=6e7JGm38jf.....</code>，你会发现因为贪婪匹配的原因，所以程序会一直读后面的字符串进行匹配，最后发现没有点号，于是就一个个字符回溯回去了。</li>
</ul>
<p>这是这个正则表达式存在的第一个问题。</p>
<p>另外一个问题是在正则表达式的第三部分，我们发现出现问题的 URL 是有下划线（_）和百分号（%）的，但是对应第三部分的正则表达式里面却没有。这样就会导致前面匹配了一长串的字符之后，发现不匹配，最后回溯回去。</p>
<p>这是这个正则表达式存在的第二个问题。</p>
<h2>解决方案</h2>
<p>明白了回溯是导致问题的原因之后，其实就是减少这种回溯，你会发现如果我在第三部分加上下划线和百分号之后，程序就正常了。</p>
<pre><code class=""java"">public static void main(String[] args) {
    String badRegex = ""^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~_%\\\\/])+$"";
    String bugUrl = ""http://www.fapiao.com/dddp-web/pdf/download?request=6e7JGxxxxx4ILd-kExxxxxxxqJ4-CHLmqVnenXC692m74H38sdfdsazxcUmfcOH2fAfY1Vw__%5EDadIfJgiEf"";
    if (bugUrl.matches(badRegex)) {
        System.out.println(""match!!"");
    } else {
        System.out.println(""no match!!"");
    }
}</code></pre>
<p>运行上面的程序，立刻就会打印出<code>match!!</code>。</p>
<p>但这是不够的，如果以后还有其他 URL 包含了乱七八糟的字符呢，我们难不成还再修改一遍。肯定不现实嘛！</p>
<p>其实在正则表达式中有这么三种模式：<strong>贪婪模式、懒惰模式、独占模式。</strong></p>
<p>在关于数量的匹配中，有 <code>+ ? * {min,max}</code> 四种两次，如果只是单独使用，那么它们就是贪婪模式。</p>
<p><strong>如果在他们之后加多一个 ? 符号，那么原先的贪婪模式就会变成懒惰模式，即尽可能少地匹配。</strong>但是懒惰模式还是会发生回溯现象的。<strong>TODO</strong>例如下面这个例子：</p>
<pre><code>text=""abbc""
regex=""ab{1,3}?c""</code></pre>
<p>正则表达式的第一个操作符 a 与 字符串第一个字符 a 匹配，匹配成。于是正则表达式的第二个操作符 b{1,3}? 和 字符串第二个字符 b 匹配，匹配成功。因为最小匹配原则，所以拿正则表达式第三个操作符 c 与字符串第三个字符 b 匹配，发现不匹配。于是回溯回去，拿正则表达式第二个操作符 b{1,3}? 和字符串第三个字符 b 匹配，匹配成功。于是再拿正则表达式第三个操作符 c 与字符串第四个字符 c 匹配，匹配成功。于是结束。</p>
<p><strong>如果在他们之后加多一个 + 符号，那么原先的贪婪模式就会变成独占模式，即尽可能多地匹配，但是不回溯。</strong></p>
<p>于是乎，如果要彻底解决问题，就要在保证功能的同时确保不发生回溯。我将上面校验 URL 的正则表达式的第二部分后面加多了个 + 号，即变成这样：</p>
<pre><code>^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)
(([A-Za-z0-9-~]+).)++    ---&gt;&gt;&gt; （这里加了个+号）
([A-Za-z0-9-~\\/])+$</code></pre>
<p>这样之后，运行原有的程序就没有问题了。</p>
<p>最后推荐一个网站，这个网站可以检查你写的正则表达式和对应的字符串匹配时会不会有问题。</p>
<p><a href=""https://regex101.com/"" rel=""nofollow noreferrer"">Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript</a></p>
<p>例如我本文中存在问题的那个 URL 使用该网站检查后会提示：catastrophic backgracking（灾难性回溯）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015320054"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>当你点击左下角的「regex debugger」时，它会告诉你一共经过多少步检查完毕，并且会将所有步骤都列出来，并标明发生回溯的位置。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015320055"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>本文中的这个正则表达式在进行了 11 万步尝试之后，自动停止了。这说明这个正则表达式确实存在问题，需要改进。</p>
<p>但是当我用我们修改过的正则表达式进行测试，即下面这个正则表达式。</p>
<pre><code>^([hH][tT]{2}[pP]:\/\/|[hH][tT]{2}[pP][sS]:\/\/)(([A-Za-z0-9-~]+).)++([A-Za-z0-9-~\\\/])+$</code></pre>
<p>工具提示只用了 58 步就完成了检查。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015320056"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>一个字符的差别，性能就差距了好几万倍。</p>
<h2>树义有话说</h2>
<p>一个小小的正则表达式竟然能够把 CPU 拖垮，也是很神奇了。这也给平时写程序的我们一个警醒，遇到正则表达式的时候要注意贪婪模式和回溯问题，否则我们每写的一个表达式都是一个雷。</p>
<p>通过查阅网上资料，我发现深圳阿里中心 LAZADA 的同学也在 17 年遇到了这个问题。他们同样也是在测试环境没有发现问题，但是一到线上的时候就发生了 CPU 100% 的问题，他们遇到的问题几乎跟我们的一模一样。有兴趣的朋友可以点击阅读原文查看他们后期总结的文章：<a href=""http://www.cnblogs.com/study-everyday/p/7426862.html"" rel=""nofollow noreferrer"">一个由正则表达式引发的血案 - 明志健致远 - 博客园</a></p>
<p>虽然把这篇文章写完了，但是关于 NFA 自动机的原理方面，特别是关于懒惰模式、独占模式的解释方面还是没有解释得足够深入。因为 NFA 自动机确实不是那么容易理解，所以在这方面还需要不断学习加强。欢迎有懂行的朋友来学习交流，互相促进。</p>
<hr>
<blockquote>
<strong>问答</strong><p><a href=""https://cloud.tencent.com/developer/ask/61165?fromSource=waitui"" rel=""nofollow noreferrer"">如何了解正则表达式？</a> </p>
<p><strong>相关阅读</strong></p>
<p><a href=""https://cloud.tencent.com/developer/article/1129751?fromSource=waitui"" rel=""nofollow noreferrer"">正则表达式</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1119106?fromSource=waitui"" rel=""nofollow noreferrer"">正则扩展练习</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1129449?fromSource=waitui"" rel=""nofollow noreferrer"">C# 正则表达式</a></p>
</blockquote>
<p><strong>此文已由作者授权腾讯云+社区发布，原文链接：<a href=""https://cloud.tencent.com/developer/article/1148472?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></strong></p>
<p><strong>欢迎大家前往<a href=""https://cloud.tencent.com/developer?fromsource=waitui"" rel=""nofollow noreferrer"">腾讯云+社区</a>或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p>

                ", 一个正则表达式引发的血案，让线上CPU100%异常！ ,1531977863,600,1,799,1,1,https://segmentfault.com/a/1190000015320049
21,1,0,9,"
                    
<p>最近的状态感觉不是特别好，所以思考了很多东西，经过几番纠结，最终决定还是形成文字对自身的一些思考做一下记录。首先是换工作的事情，毕业三年，换了两份工作，目前是第三份工作。而如今这份工作是打算一直做下去，不打算换了，而这也是促使我思考这些事情的原因。我先说前两份工作的事情吧。</p>
<p>第一家公司待了两年时间，从刚开始加入公司时候的五六个人的技术团队到后续40来人的技术团队（当然一直都包含了产品和设计），也从一开始的愣头青到后来做了一年的管理，回忆起来，除了发年终奖时候的欢喜，过程中尝尝伴随着失眠。一开始是由于害怕自身能力的不足，到后来盘子越拉越大，担心撑不起整个团队以及自己的技术不足以支撑业务的发展。当然后续证明我想多了，直到如今，据说那家公司还是一台代码服务器，一台数据库服务器加cdn支撑起了一年一两亿的营业额。</p>
<p>至今想来，之前对于自身能力的怀疑也算是对于所处环境无法看清楚的原因，其实以那时候的情况，把产品bug降到最低，撸代码要撸得快就好了，反正根本没有什么人实实在在的在使用这个产品。但毕竟旁观者清，自身处于这种环境的时候是没法分清主要矛盾和次要矛盾的。而不管怎么说，在这家公司的两年，公司也给与了我很多的成长机会，压力纵然大，但我也感谢领导对我的包容吧。</p>
<p>而这次离职，对我来说，从另外一方面来说，算是一个让我对自身做更深层次反思的机会，而离职期间，也遇到了很多大牛和有意思的人，我在之前离职的时候写过一篇博客有做过说明。另外就是这次离职让我进入了一家虽然是做这个行业，但是体量似乎更大的公司。</p>
<p>但是，关于公司体量大与否的这个问题，在我真正加入后才发现要看具体的衡量标准，一开始在外部所见是整个产品相当强大，技术栈相当强大，而真正加入了后才发现并没有所谓的技术栈，也并没有多么强大的产品设计，有的只是十来年时间踩过的坑的积累，而另外真正强大的地方或许应该就是能真真切切的为用户服务，真真切切的有很多用户在使用这个产品，我想这是我加入这家公司后所看到的具有的最大的价值。另外我当时离职的时候，CTO对我说“不管你去哪，做啥，如果做的是为社会真真实实的创造价值，我都支持你。”，我不管这话的真与假，但是至少以我所见我愿意相信是真的。</p>
<p>最后我想聊一下关于我为什么上一份工作只工作了一年而到这里来的原因。</p>
<p>其实第一家公司离职后我都有意向来segmentfault了，当时也和joyqi聊了一些东西，当然那时候是围绕一些技术上的问题简单的聊了一下，然后就是我的一些想法。而经历了两家公司之后，我发觉不管我怎么换工作，除了可能去腾讯、阿里、百度可能会有不一样的区别之外，结合我去年面试的经验来看，其他公司估计状态都差不多，也没有太多必要。而此时我就诞生了重新加入一家创业公司，薪资这块不谈，只希望能找到一些共同且有意思的事情一起做下去。而segmentfault就是我所向往的地方，这的确是实话。在segmentfault这个平台上，虽然我与许许多多的大牛没法比，但是就我个人来说是非常喜欢这个平台的，大家都很乐意讨论问题，解答问题，做技术分享。</p>
<p>以上是关于换工作后的一些思考，另外是我自身对于最近所处状态的一些思考。</p>
<p>首先是对于未来的思考。以目前我所处的环境以及所了解的信息来看，未来估计都是巨头的世界，为富者越富。而至于我们，如果想真正的能实现梦想，除了给巨头打工之外，未来也许就只能更细化产品方向，做小众化产品，不求做个产品能上市，迎娶白富美，能增加自己的财富自由度，估计就是最好的状态了。</p>
<p>另外，未来的产品想要能突破，估计也就只有做数据上的产品，模式上的产品以我的看法，估计也开发得差不多了。</p>

                ", 换到第三份工作后做的一些反思和碎碎念,1531977865,532,1,210,1,1,https://segmentfault.com/a/1190000015187813
22,1,0,9,"
                    
<blockquote>Any fool can write code that a computer can understand. Good<br>programmers write code that humans can understand.</blockquote>
<p>普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。如何写出优雅整洁易懂的代码是一门学问，也是软件工程实践里重要的一环。笔者推荐三本经典的书籍《代码整洁之道 》、《编写可读代码的艺术》、《重构:改善既有代码的设计》，下文重点将从注释、命名、方法、异常、单元测试等多个方面总结了一些代码整洁最佳实践，大部分是笔者总结于以上三本书中的精华，也有部分是笔者工程实践的总结。篇幅有限，本文将总结性给出一些实践建议，后续会有文章来给出一些代码整洁之道的事例。</p>
<p><strong>注释</strong></p>
<ul>
<li>不要给不好的名字加注释，一个好的名字比好的注释更重要</li>
<li>不要“拐杖注释”，好代码 &gt; 坏代码 + 好注释</li>
<li>在文件/类级别使用全局注释来解释所有部分如何工作</li>
<li>一定要给常量加注释</li>
<li>团队统一定义标记</li>
</ul>
<p>TODO  待处理的问题<br>FIXME  已知有问题的代码<br>HACK 不得不采用的粗糙的解决方案</p>
<ul>
<li>在注释中用精心挑选的输入输出例子进行说明</li>
<li>注释应该声明代码的高层次意图，而非明显的细节</li>
<li>不要在代码中加入代码的著作信息，git可以干的事情不要交给代码</li>
<li>源代码中的html注释是一种厌物, 增加阅读难度</li>
<li>注释一定要描述离它最近的代码</li>
<li>注释一定要与代码对应</li>
<li>公共api需要添加注释，其它代码谨慎使用注释</li>
</ul>
<p>典型的烂注释</p>
<p>不恰当的信息<br>废弃的注释<br>冗余注释<br>糟糕的注释<br>注释掉的代码</p>
<ul><li>唯一真正好的注释是你想办法不去写的注释</li></ul>
<p>不要有循规式注释，比如setter/getter注释<br>不要添加日志式注释，比如修改时间等信息（git可以做的事情）<br>注释一定是表达代码之外的东西，代码可以包含的内容，注释中一定不要出现<br>如果有必要注释，请注释意图（why），而不要去注释实现（how)，大家都会看代码<br>适当添加警示注释</p>
<h2>命名</h2>
<ul>
<li>尽可能使用标准命名方法，比如设计模式，通用学术名词等</li>
<li>命名要找更有表现力的词</li>
</ul>
<p>使用更专业的词，比如不用get而使用fetch或者download<br>避免空泛的名字，像tmp<br>使用具体的名字来细致的描述事物<br>给变量名带上重要的细节，比如加上单位ms等<br>为作用域大的名字采用更长的名字，作用域小的使用短名字<br>变量类型为布尔值表达加上is，has，can，should这样的词会更明确</p>
<ul>
<li>变量名称长短应该与其作用域对应</li>
<li>别害怕长名称，长而具有描述性的名称比短而令人费解的名称好</li>
<li>函数名称应该说明副作用，名称应该表达函数，变量或类的一切信息，请不要掩盖副作用，比如CreateAndReturnXXX</li>
</ul>
<h2>方法</h2>
<ul><li>函数不应该有100行那么长，20行封顶最好</li></ul>
<p>if else while等控制语句其中代码块应该只有一行，也就是一个函数调用语句<br>函数的锁进层次不应该多于两层<br>一个函数只做一件事，一个函数不应该能抽象出另外一个函数</p>
<ul>
<li>某个公共函数调用的私有函数紧随其后</li>
<li>最理想的参数是零参数，最长不要超过三个入参，尽量不要输出参数</li>
</ul>
<p>如果函数传入三个及以上参数最好将其抽象为类<br>标识参数十分丑陋，向函数传入布尔值用于区分不同业务的做法很丑陋，应该拆分为多个函数</p>
<ul>
<li>别返回null值，抛出异常或者返回特殊对象，尽量避免NPE</li>
<li>别传入null值</li>
</ul>
<h2>异常与错误</h2>
<ul>
<li>抽离try catch包含的代码块，其中代码块抽象为一个函数</li>
<li>抛出的每个异常，都应当提供足够的环境说明，已便判断错误的来源与处所</li>
<li>不要将系统错误归咎于偶然事件</li>
</ul>
<h2>并发</h2>
<ul>
<li>分离并发相关代码与其它代码</li>
<li>严格限制对可能被共享的数据的访问</li>
<li>避免使用一个共享对象的多个同步方法</li>
<li>保持同步区域微小，尽可能少设计临界区</li>
</ul>
<h2>单元测试</h2>
<ul>
<li>不要怕单元测试的方法名字太长或者繁琐，测试函数的名称就像注释</li>
<li>不要追求太高的测试覆盖率，测试代码前面90%通常比后面10%花的时间少</li>
<li>使用最简单的并且能够完整运用代码的测试输入</li>
<li>给测试函数取一个完整性的描述性名字，比如  Test _</li>
<li>测试代码与生产代码一样重要</li>
<li>如果测试代码不能保证整洁，你就会很快失去他们</li>
<li>每个测试一个断言，单个测试中断言数量应该最小化也就是一个断言</li>
<li>FIRST原则</li>
</ul>
<h2>快速 Fast</h2>
<ul><li>独立 Independent  测试应该相互独立</li></ul>
<p>可重复 Repeatable  测试应当在任何环境中重复通过<br>自足验证 Self-Validating   测试应该有布尔值输出<br>及时  Timely   最好的方式是TDD</p>
<p>独立 Independent  测试应该相互独立<br>可重复 Repeatable  测试应当在任何环境中重复通过<br>自足验证 Self-Validating   测试应该有布尔值输出<br>及时  Timely   最好的方式是TDD</p>
<h2>代码结构</h2>
<ul>
<li>代码行长度控制在100-120个字符</li>
<li>可能用大多数为200行，最长500行的单个文件构造出色的系统</li>
<li>关系密切的代码应该相互靠近</li>
</ul>
<p>变量声明应该靠近其使用位置<br>若某个函数调用了另外一个，应该把他们放在一起，而且调用者应该放在被调用者上面<br>自上向下展示函数调用依赖顺序</p>
<ul>
<li>应该把解释条件意图的函数抽离出来，尽可能将条件表达为肯定形式</li>
<li>不要继承常量，比如接口中定义常量，不要使用继承欺骗编程语言的作用范围规则</li>
<li>模块不应了解它所操作对象的内部情况</li>
<li>DTO（Data Transfer Objects）是一个只有公共变量没有函数的类</li>
<li>对象暴露行为，隐藏数据</li>
<li>不要使用“尤达表示法” 如 if(null == obj)，现代编译器对if(obj = null)这样的代码会给出警告</li>
<li>一般情况使用if else，简单语句使用三目运算符</li>
<li>通常来讲提早返回可以减少嵌套并让代码整洁</li>
</ul>
<h2>设计</h2>
<ul><li>类应该足够短小</li></ul>
<p>类应该满足单一权责原则（SRP），类和模块只有一个修改理由<br>类应该只有少量的实体变量<br>类应该遵循依赖倒置原则 DIP（Dependency Inversion Principle），类应该依赖于抽象而不是依赖于具体细节<br>类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好</p>
<ul><li>通过减少变量的数量和让他们尽量“轻量级”来让代码更有可读性</li></ul>
<p>减少变量<br>缩小变量的作用域<br>只写一次的变量更好，如常量</p>
<ul><li>最好读的代码就是没有代码</li></ul>
<p>从项目中消除不必要的功能，不要过度设计<br>从新考虑需求，解决版本最简单的问题，只要能完成工作就行<br>经常性地通读标准库的整个API，保持对他们的熟悉程度</p>
<ul><li>简单设计</li></ul>
<p>运行所有测试<br>不可重复<br>表达了程序员的意图<br>尽可能减少类和方法的数量<br>以上规则按重要程度排列</p>
<ul>
<li>无论是设计系统或者单独模块，别忘了使用大概可工作的最简单方案</li>
<li>整洁的代码只提供一种而非多种做一件事的途径，他只有尽量少的依赖。明确定义并提供尽量少的API</li>
<li>减少重复代码，提高表达力，提早构建，简单抽象</li>
</ul>
<h2>小结</h2>
<p>作为代码整洁之道系列的第一篇，本文从注释、命名、方法，单元测试，并发等视角简单给出了一些最佳实践，下文我们会展开来从每个方面介绍更多的实践事例。相信每一个优秀的工程师都有一颗追求卓越代码的心，在代码整洁工程实践上你有哪些好的建议？数百人协作开发的代码如何保证代码整洁一致性？欢迎大家来讨论。</p>
<p>本文作者：竹涧</p>
<p><a href=""http://click.aliyun.com/m/51055/"" rel=""nofollow noreferrer"">阅读原文</a></p>
<p>本文为云栖社区原创内容，未经允许不得转载。</p>

                ", 聊聊代码整洁之道,1531977866,498,1,675,1,1,https://segmentfault.com/a/1190000015098729
23,1,0,9,"
                    
<p>跳出舒适区，程序员的工资可以翻上好几倍</p>
<p>一般说来，刚毕业，活力四射，总是有一股子冲劲，心里也梦，想把不懂的东西都先弄明白，充实而忙碌。就算每天需要占用吃饭、睡觉的时间去学习与努力，也不会觉得累，总之时刻都会激情高昂的样子。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAl?w=1024&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>后来，工作两年，有足够的能力应付自己的工作了，也没有之前那般拼命劲了。每天做的工作游刃有余，准时上班，准点下班。这个时候你要了解到有两种情况：<br>1、这个工作你已经胜任了，也证明了你的能力水平。<br>2、你的工作中出现瓶颈了，除了现有能够处理的工作，你没有一丝进展。面对这两种情况，你要思考是否是处在了舒适区。<br>尽管，你每天熟练的处理手头工作，日子过得也特别快，但是总会感觉着空虚感和焦虑感相互交叠。所以，我相信你此刻需要跳出舒适区了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAs?w=600&amp;h=449"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>每个人都想要成功，但也很容易沉溺于舒适的生活里。一份安稳的工作，朝九晚五，余下时间可以和朋友与家人一起吃喝玩乐。这样的日子无一不是大家所喜欢并期待的。但看到身边很多人都成功了，内心又有不甘，幻想着有朝一日能够和他们一样，出人头地，但你真的能够有勇气跳出舒适区吗？<br>首先，要重新去了解自己。了解自己就意味着什么呢？意味着接受。接受自己并不完美的一面。<br>1、 我并不完美，除了基础技术能力之外，其他一无所长。<br>2、 我并不成功，除了在现所处的公司，能应对一些基础问题之外，我的能力并没有优势。<br>3、 我真正想要的东西，似乎离自己越来越远。<br>4、 很久没有努力了，没有那种奋斗的精神。<br>5、 不知道从何开始，害怕现有的东西都会失去了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAA?w=1024&amp;h=735"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>当你习惯了很多东西之后，你明明在泥沼里，却以为在任天堂一般。作为一枚程序员还想着安逸，这就是你的不对了。互联网技术日新月异，程序员并不是只掌握一项技术就能够高枕无忧了。想要改变现状，可以从以下几个方面了解：</p>
<p>一、另一人生的开启，置之死地而后生<br>如果，没有曾经那种激情了，如果，不知道从何开始，那就先将自己处于危险之中，险中求生，对安逸的人来说是很大的挑战。<br>第一步，斩断后路，不管现在你多安逸，你都要思考接下来该不该继续安逸下来，跳出这个区域，你要思考接下来将遇到最大的危险是什么。比如说，现在的公司只能做手头现有的工作，没有办法提升能力，那么是不是应该去人才市场验证自己的能力和其他发展机会呢？倘若公司可以变通，那又应该怎样去做呢？可以直接跨入第二步。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAC?w=481&amp;h=311"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>第二步，行动如风，不管你是离职重新估量自己的能力，还是在现任岗位上进行提升，你都要明白自己现在有哪些问题，并且进行分析与解决。你可以进行职业规划和能力评估。又该怎样规划？首先，置于危险中并不是忽视后果，而是通过估量这个事情的危险系数有多大，再进行抉择，其次就是职业规划，你几年后，乃至这一辈子，你的职业规划是否适合，是否能够执行落地，你接下来要做的事情是否能够通过自身努力与坚持就能够实现，实现不了，将怎么办？这些都需要思考。<br>第三步，计划落地。不管怎样，你要面对的事情都不外乎是提升自己的能力。怎样实施落地，可以做年计划，半年计划，周计划、日计划等等，这些需要坚持下去，还要进行分析，并调整方向，而不是做了就放任不管，那跟在舒适区并没有什么特别之处，你要做的就是通过量变行动达到质变的效果。</p>
<p>二、掌握技术技能，提高软实力<br>别人都说35岁是程序员工作的终点。其实，也可以算是程序员的另一段人生的开始。以上几点问题，在这个年龄之前都要认真去思考解决。做好技术积累，构建个人核心竞争力是程序员最主要的能力，接下来就是个人软实力的塑造，有人说软实力是虚的，但事实证明“成大事者不拘专业，有软实力笑傲江湖!”</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAL?w=1606&amp;h=1200"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>那么该怎样做呢？<br>技术能力，是程序员不能丢的东西，你只有熟练操作技术能力，才能够深入解决技术层面需要面临的问题，以及该如何去解决。怎样提升技术能力，方式有很多，无非就是能够静下来，坐下去。只要你能在下班之后，认真多加一两个小时的班，将学习的知识融入实践中去，技术能力就能够提升上去。<br>软实力提升，可以从思维能力、沟通能力、表达能力、文化修养、学习能力、团队协作能力出发，这些方面都会在生活和工作中体现出来，可以阅读和学习相关知识，并通过刻意练习来提升相关能力。最主要的是，这些事情都有自己的线，而且时刻都要拽紧这根线，你才不会成为断线风筝，任意漂流。<br>古人云：“活到老，学到老。”你放弃学习，就等于慢性自杀。所以在没有很大进展的时刻，不如跳出来，看看世界。这个世界能给你带来哪些好处呢？</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbdAO?w=1000&amp;h=664"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如果你提升了自己的技术能力，你至少可以获得更多待遇更好的offer。那么你所面临的层次就更上一层楼。技术没有封顶，只有你触不到的境界，要想到高境界除了自身努力和引导人之外，还需要环境的塑造。软实力也是一样，你遇到的人和问题深度也不一样，自然解决的方式和效果也是不一样。</p>
<p>生活不可能是一帆风顺的，你怎么对它，它就一定会反馈给你。你努力奋斗所积累的能力，都会化作人民币回馈给你。比如说你的技术超厉害了，那么哪个HR会放过你呢？如果你的软实力比如说思维、沟通等能力能让你面前的问题全都解决掉，那又有哪个公司的老板不会拿高薪酬留住你呢？</p>
<p>内容来源：闯客网 <a href=""http://www.uuzcc.com/"" rel=""nofollow noreferrer"">http://www.uuzcc.com/</a></p>

                ", 跳出舒适区，程序员的工资可以翻上好几倍,1531977868,283,1,843,1,1,https://segmentfault.com/a/1190000015027853
24,1,0,9,"
                    
<h2>前言</h2>
<p>好几天没有提笔写文章了，原本今晚我也没打算写，当我关了电脑躺床上准备入睡了。此时不经意的一瞥（入睡前习惯刷刷微信），然后发现微信通讯录右上角有个小红点，对于这点，我已经司空见惯了。我知道是有童鞋关注了我的公众号，然后想加入前端圈群聊的，所以才加我。</p>
<p>于是我同意并发出邀请入群的请求。这个童鞋跟我打招呼的方式有点特别，“来自零零后的前端工程师前来报到~”，这条消息引起了我的好奇，一问才知道，芳龄仅仅16周岁而已，<strong>初中阶段便挣得人生第一桶金</strong>。不仅如此，现在他已经在北京的一家创业公司就职前端开发工程师（我们俗称码农）。惊叹年龄之余，我不禁对他的过往经历产生了好奇心。</p>
<p>于是我向他抛出了邀请：</p>
<blockquote>“ 我有个想法，想给你写个专访文章，然后推送到我公众号里，给大家分享一下你的从业经历，以及00后对这个行业的认知 ”</blockquote>
<p>于是，他有故事我有酒，一拍即合，便有了下面的文章。</p>
<p>接下来，正文从这儿开始~</p>
<h2>刷钻往事，开启了我的技术启蒙之旅</h2>
<p>大家好，我是零零后，来自东北。从小学六年级开始在某QQ群中看到，有个人发广告，上面写着qq钻，几毛一个月，我带着好奇的心，去问了他，他说让我给他打30块加盟费，就告诉我。</p>
<p>当时的我也不知道怎么把钱汇给他，他告诉我可以去手机店去买一个叫手机充值卡的东西，让我去买回来划开，给他把照片发过去就可以，然而上六年级的我哪有钱去买那个东东，但是好奇之心总不死。</p>
<p>有一天他无意间把钻的订单截图给我发了过来，上面浏览器中还携带着网址，我当时就打出网址放在浏览器中访问，访问后发现是一个叫卡盟的网站，然后我注册了一个账号，研究起了其中的奥秘，那个人也不断着催着我去给他买那手机充值卡，我便给他删掉，自己研究，研究差不多了给自己弄了一套qq套餐，那时才13块多，在腾讯购买是50元一套，包括会员，红钻，绿钻，蓝钻，黄钻等。</p>
<p>不久上了初一便给同学们刷了起来，赚起了小外快，后来才知道这个东西到月底会有个扫钻，刷上的钻会掉。我就不解，便去探索，才知道那种都是手机黑卡，发送代码到1069070069去开通，卡内话费几毛钱，等运营商和腾讯对不上账的时候，腾讯便会把刷上去的qq钻去掉。</p>
<p>爱钻研的我，便想着不能一直我花钱去别人的网站下单购物，我也要当个供货商。知道了钻都是用手机卡来刷，我便加了一堆群来找卖卡的，那时我爸说6当时买了几百张安徽电信2的电信卡，因手机不是三网通，我便和我爸爸去手机店买了一部老年电信小手机。</p>
<p><strong>我爸爸很支持我，这时我也在学校做起了我的小生意。</strong></p>
<p>在这里，先跟大家说下什么是刷钻。</p>
<blockquote>刷钻，通常指以绕过QQ付费信息的方法通过取消停留达到使QQ业务卡住，达到目的。手机刷钻利用的是移动、联通与腾讯之间的SP服务漏洞，从而不扣手机话费，得到刷钻效果。</blockquote>
<p><strong>当然我们并不提倡这种行为，这仅仅是00后码农痴迷于网络技术的过往经历，俗称启蒙阶段。</strong></p>
<h2>我在初中的一些回忆</h2>
<p>当时的我不是不爱学习，比如我就很喜欢英语，120分满分，我拿过116。因为不是很喜欢数学老师，所以成绩一直不怎样。初一是一个男老师教我历史，50分满分，我才拿了19分，到了初二是一位美女老师教历史，我拿了45分。</p>
<p>初中也比较喜欢打篮球，由于个子也不是很高，但是弹跳蛮好，我班有一个1米8的大高个我们一起打篮球，一次我们跳起夺球的时候，他不小心撞了我一下，我便飞出好几米，人生中第一次骨折，手腕的俩根骨头骨折，骨折的滋味很痛苦！</p>
<h2>线报，让我挣到人生第一桶金</h2>
<p>随着日子慢慢往后推移，刷钻这个行业不是那么顺了，手机卡运营商也开始实名制了。所以被逼无奈的我，偶尔在群里见到有人发扫码领取红包什么的，慢慢接触后，才知道了线报，俗称卷羊毛。</p>
<p>知道了这个是通过什么方式赚钱，大众赚钱方式就是拉人头的方式，慢慢加了很多大佬，看到他们的空间，知道了一些接码平台，打码平台，还能做软件自动化运行，这个东西利润还是很理想的，这个分首发还是传出来的，有的人得到了活动如果利润高，就会选择出售让人买。</p>
<p>当时小白的我都是等大佬们把这个活动快被玩黄了，我才得到这个活动才开始，慢慢我也研究起来怎么找首发，怎么做软件，知道他们做软件都是用易语言这个写，我边在网上找教程学习，当时学的蛮吃力的，学的是叫POST多线程注册，我学会后也做了一个软件，也找到几次首发，曾有一次一天赚了4000块。</p>
<p>我爷当时很反对我天天不出去就知道钻在家里摆弄电脑，那天我爷和我爸出去干活，他们回来后，我就和他们说了我今天赚了4000块，我爷很吃惊：“你弄这玩意能弄出来钱来？”  <strong>而我爸并不吃惊，因为我之前刷钻我爸就知道我很棒。</strong></p>
<p>在这里，给大家解释下，什么是线报。</p>
<blockquote>线报，意思是网络信息的分享。网络活动线报一般可以分为：有奖活动、免费赠品、免费试用、微博活动、有奖调查、免费资源等几大类，有很多专门从事这类活动线报发布的网站。</blockquote>
<p>它的一个发展趋势是，当今网络发展十分迅速，很多商家苦于活动无处推广，都会以线报的形式投递至线报网站以获得关注度、人气、浏览量等，随着活动的增多，线报类网站可以充分的减少网友查找活动的时间成本，会越来越受网友的追捧。</p>
<p>还记得第二天，我就去买了我人生中第一台笔记本电脑，华硕的飞行堡垒，花了6999，然而我的4000块是不够的。那时的我以为4000块足以买个配置很高的笔记本电脑了，但事实却非如此，我爸爸便给我添了一半，后来知道了一个软件叫fd......</p>
<p>我的故事有点长，未完待续</p>
<h2>后记</h2>
<p>这位来自东北的00后老铁，经历确实比按部就班的同龄人来说不太一样。关于他后来是如何自学做软件的，怎么阴差阳错地报名了某某培训机构继续深造技术的，又怎么在帝都北京以年仅16周岁的身份应聘到一家互联网创业公司的等等，我会在下篇继续跟大家聊聊。</p>
<h2>4年一路走来的故事，值得期待！</h2>
<p>最新文章都会第一时间更新在我的公众号&lt;<strong>闰土大叔</strong>&gt;里面，欢迎关注~</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbbctE?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 00后专访：我是如何初中毕业年仅16岁便踏入北漂码农行业的（一）,1531977870,460,1,792,1,1,https://segmentfault.com/a/1190000015023800
25,1,0,9,"
                    
<p>对于程序员来说，Hackathon 绝对是一项激动人心的活动。那么第一次参加 Hackathon 的话，需要提前知道和准备些什么呢？参赛的时候又有哪些需要注意的事情呢？参加 Hackathon 会有什么收获呢？</p>
<h2>Hackathon 的特点</h2>
<p>正所谓知己知彼，百战不殆。那么 Hackathon 有哪些特点呢？</p>
<ul>
<li>时间短：比如这次的 Hackathon 就只有 36 小时，除去吃饭和休息，留给大家开发的时间已经不多了。</li>
<li>强度高：开发过程中可能遇到各种各样的问题，这些问题都需要在短时间内快速解决，甚至还可能需要现学一门新技术新语言。总之，从 0 开始创造一个产品，时间短任务重，体力和脑力都需要爆发。</li>
<li>创造力：Hackathon 的精髓在于以自己想要的方式，去做任何自己想做的事情。不再受限于工作中的各种业务需求，用天马行空的脑洞，挑战已有的技术、理念，去创造新的产品，让世界变得更美好。</li>
<li>配合度：Hackathon 是一项团队赛，需要队员之间的积极配合和及时沟通，这是一场团战，参团协作很重要。切忌单打独斗。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVba5W7?w=800&amp;h=534"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Hackathon 神器推荐</h2>
<p>简单易用，你可能会用到。</p>
<ul>
<li>Node.js 网页应用程序模板：<a href=""https://github.com/sahat/hackathon-starter"" rel=""nofollow noreferrer"">hackathon-starter</a>
</li>
<li>再来一个 Laravel 的：<a href=""https://github.com/unicodeveloper/laravel-hackathon-starter"" rel=""nofollow noreferrer"">laravel-hackathon-starter</a>
</li>
</ul>
<h2>注意事项</h2>
<h4>0.需要准备什么？</h4>
<p>带上你和你的电脑，准时参赛。</p>
<h4>1.了解大赛规则</h4>
<p>需要了解的规则：</p>
<ul>
<li>不能违反的规则</li>
<li>评分规则</li>
</ul>
<h4>2.找准定位，明确分工</h4>
<p>根据自己的专业技能和个人特长明确自己的定位，是队长还是队员？是开发还是产品？确定每个人的职责和目标，然后尽情地发挥所长吧。</p>
<h4>3.合理分配资源，控制进度</h4>
<p>在比赛一开始就制定项目计划和开发流程很有必要。做什么不做什么，先做什么后做什么，什么时间节点应该完成什么功能等。</p>
<h4>4.适当的休息</h4>
<p>体能的分配也很重要，所谓磨刀不误砍柴工，充足的精力才能在高强度的开发环境下完成任务，尽量做到按时吃饭和休息，记得多喝水。</p>
<h4>5.快速迭代</h4>
<p>快速地完成第一个产品原型，然后再去增改其他功能。这个时候，代码优雅不优雅什么的就算了吧，先搞出来再说。（划掉）</p>
<h4>6.坚定目标，不忘初心</h4>
<p>比如遇到的困难太多，做着做着突然就不知道接下来该怎么办了，这个时候，一定要坚持！</p>
<h4>7.善于求助</h4>
<p>搞不定的部分要尽快向队友甚至别的团队求助，千万不要不好意思，团队之间不完全是竞争关系，也可以互相合作。</p>
<h4>8.产品演示</h4>
<p>酒香也怕巷子深，好的产品介绍很重要。真诚地向大家表达你们的想法，展示你们的成果。另外一份漂亮的 PPT 总是更能吸引人。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVba5WV?w=800&amp;h=533"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Hackathon 的收获</h2>
<h4>1.天使投资</h4>
<p>有的 Hackathon 会邀请很多投资人参加，如果你们是创业团队或者即将创业，那么 Hackathon 绝对是一个认识投资人并且展示自己实力的好机会。</p>
<h4>2.认识大牛</h4>
<p>除了同来参赛的开发者，你还可能遇到：主办方的大牛、来参赛的大牛（通常他们都很低调，可以事先问问主办方有哪些大牛来参赛）、嘉宾里的大牛、投资人、开场演讲的大牛（通常会是某某 CEO，比如这次就是我们的 Sunny） ，甚至还可能遇到潜伏进来挖人的 HR 等等。趁空隙时间多和大牛们交流，趁机向大牛们学习，会有很多不同的收获。</p>
<h4>3.做点好玩的东西</h4>
<p>天天被产品经理逼着改各种匪夷所思的需求，对于 coding 已经失去了最初的乐趣。那么这一次，你说了算！去做一个在你心目中真正想做的产品吧。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVba5WK?w=800&amp;h=460"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h4>4.一次难得的经历</h4>
<p>彼时热血方刚，挥斥方遒，手指与键盘共舞，代码与 idea 齐飞。将来的某一天回忆起来，这绝对是一场值得你怀念的经历。</p>
<p>最后的最后，Hackathon 是一种乐趣，而不是一个死气沉沉的编程比赛，让我们尽情地享受它吧。</p>
<p>Just enjoy it!</p>
<h2>SegmentFault Hackathon 往期精彩回顾</h2>
<ul>
<li><a href=""https://segmentfault.com/a/1190000003920404"" rel=""nofollow noreferrer"">SegmentFault 1024 Hackathon 优秀作品汇总</a></li>
<li><a href=""https://segmentfault.com/a/1190000003931548"" rel=""nofollow noreferrer"">SegmentFault Hackthon 2015 记录</a></li>
<li><a href=""https://segmentfault.com/a/1190000003929722"" rel=""nofollow noreferrer"">SegmentFault 黑客马拉松杭州站精彩回顾</a></li>
<li><a href=""https://segmentfault.com/a/1190000003916714"" rel=""nofollow noreferrer"">2015 杭州黑客马拉松赛后回顾</a></li>
</ul>
<h2>SegmentFault Hackathon 2018 杭州赛区即将开始</h2>
<p>让我们相约杭州，一起体验一场 Hackathon 吧~</p>
<blockquote><strong>大赛详情：<a href=""https://segmentfault.com/hackathon-2018"" rel=""nofollow noreferrer"">SegmentFault Hackathon 2018 大赛官网</a></strong></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVba5Wf?w=900&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", Hackathon 参赛指南——如何愉快地参加一场 Hackathon,1531977871,485,1,938,1,1,https://segmentfault.com/a/1190000014998482
26,1,0,9,"
                    
<p>""行成于思，毁于随""——韩愈</p>
<p>在阿里从一线前端工程师到技术 TL（Team Leader） 也三年有余了，最重要最难的就是做规划，你可能会遇到如下几个问题：</p>
<ul>
<li>业务压力巨大，前端是瓶颈，如何做合适的规划？</li>
<li>如何提高规划的成功率？</li>
<li>规划的雷区是什么？</li>
<li>如何寻找规划的线索？</li>
<li>我的老板不是前端，如何做出被认可的成绩？</li>
</ul>
<p>今年4月份参加了阿里集团前端委员会组织的 TL 培训（老师都是阿里的前端大牛），为期三天，收获颇丰，特别是关于前端 TL 如何做团队规划方面，整理课堂笔记时，就想结合自己这一年在阿里拍卖业务中的规划实践做下总结。</p>
<p>本文会引用课堂上多位阿里前端大牛老师的观点。</p>
<p>一般技术规划路径如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCt0?w=769&amp;h=341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>（蓝色部分为本文重点论述部分）</p>
<h2>一、先从团队特征说起</h2>
<p>做规划，先要定义清晰自己团队的特征与发展的阶段。因为特征不同与发展阶段不同，规划的选择就会截然不同。</p>
<p><strong>1. 识别团队特征</strong></p>
<p>在阿里梓骞老师关于建团队的论述中，有一块团队行为曲线的总结特别好，是团队比较核心的特征。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCt8?w=844&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>（上图来自梓骞老师 PPT ）</p>
<p>我的团队特征（某财年阿里拍卖业务前端团队）：</p>
<ul>
<li>背景：从淘宝技术部到垂直支撑业务</li>
<li>团队行为：处于潜在团队，共同目标不清晰、协同不够、缺乏长期目标</li>
<li>人员构成：6 人，平均层级偏低</li>
<li>业务发展情况：创业型，高速发展，局部瓶颈</li>
<li>业务重点关键字：DAU、用户体验（业务老大高频强调）</li>
<li>资源富裕度：负，人员严重不足，前端成为业务发展瓶颈</li>
<li>TL 汇报对象：产品经理</li>
</ul>
<p>当识别完团队特征，最迫切的事往往可以呼之欲出，比如招聘是第一等大事，“废话，给我找个不缺人的前端部门...”，莫急，本篇不讲招聘...</p>
<p>发现上个财年推进的事，印证了团队行为目标：努力将潜在团队引领成真正的团队。</p>
<p>如何做？</p>
<ul>
<li>寻找团队共同目标</li>
<li>增强团队协同</li>
<li>明确清晰短期目标与长期目标</li>
</ul>
<p>从团队特征中寻找规划的边界：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCuw?w=811&amp;h=358"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>清晰的边界与基准、对规划内容优先级判断，对落地成功率有至关重要影响。</p>
<h2>二、寻找规划线索</h2>
<p>寻找规划线索是最耗时间的阶段，作为 TL 你有可能每天都在观察寻找规划的线索。</p>
<p>寻找线索，除了 TL 本身的思考外，需要具备外交能力，多问，如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCuz?w=774&amp;h=396"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>可以从四个方向去寻找链接，聊得越多，聊得越透，线索会浮现得越多。</p>
<p>下面针对去年比较有体感的点展开论述。</p>
<p><strong>1. 向上管理</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCuM?w=429&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>向上管理是拔赤老师比较强调的内容，如果你的老板不是前端，向上管理特别有必要，你需要消除“语言差”、做必要的前端核心概念“科普”。</p>
<p>一般业务/产品老板的关注点是：流量、转化、跳失、体量、用户体验、规模化、模式/产品创新等，要了解清楚现阶段老板的关注点是什么，从自己团队的维度思考试图给出到达路径，这是非常重要的规划线索。</p>
<p>向上管理不是有事没事找老板唠嗑，而是注意沟通的有效与质量，提问题最好带着初步的解决方案，业务/产品老板的时间有限，又存在“语言差”，相对复杂的内容务必准备 PPT。</p>
<p><strong>2. 脑暴共创</strong><br>脑暴共创是非常好的，自下而上的输入方式，而且你可以观察出下属的关注点，为后面寻找规划项目执行者提供线索。</p>
<p>你可以挑个风和日丽的周末，一整天与团队同学们关在一个咖啡馆或风景不错的会议厅。</p>
<p>因为共创会的成本相对较高，所以需要注意必须是主题式的共创，可以安排上午人员做主题式汇报，下午讨论聚焦。</p>
<p>另外还需要一个控场能力比较强的主持人，防止主题失焦，控制时间，共创需要的是高密度的信息。</p>
<p>除了与下属的脑暴共创，也可以组织与协作方的共创，参加业务方的共创。</p>
<p><strong>3.关注业务痛点</strong><br>从业务痛点出发寻找的线索，确定规划后一般有充足的时间落地，是很靠谱的线索，但要注意抽象与提取，业务痛点更多是单点的现象，而我们需要做普适性的思考，这样才能充分发挥技术的价值，当然也要避免“过度设计”。</p>
<p>![图片上传中...]</p>
<h2>三、价值聚焦</h2>
<p><strong>1. 前端规划四问</strong></p>
<ul>
<li>要解决什么核心业务问题？</li>
<li>创造什么核心价值？</li>
<li>为什么要做这件事？为什么是我们做？</li>
<li>是单点，还是相对通用？</li>
<li>以什么样的模式和方式来解决问题或创造价值？</li>
<li>业务边界，系统边界如何取舍？</li>
<li>问题在集团的大图位置和现状是什么样的？</li>
<li>优势？劣势？</li>
<li>终局思考和实现路径是什么样的？</li>
</ul>
<p>结合前端，我个人认为有核心四问：</p>
<ul>
<li>做成了会如何？（核心价值、终局构想）</li>
<li>是我团队最重要的事吗？</li>
<li>有没有更简单的方案？</li>
<li>与业务的链接是什么？</li>
<li>终局构想特别重要，决定了规划内容的价值天花板，圆心老师给我们讲了案例，Pandora.js</li>
</ul>
<p>做规划时，就要求是开源的，要服务外部应用，这个定位改变了 Pandora.js 从 0 到 1 的结构，如果一开始只是定位于为集团<br>   node 应用服务，那么日后开源必然面临大量改造成本。</p>
<p>在前端团队多年，体感比较深刻有二点，前端容易将问题复杂化，喜欢用大的平台去解决小的问题，前端容易为了技术而技术，与业务“失联”。</p>
<p><strong>2.来自大牛灵魂的拷问</strong></p>
<ul>
<li>要让评审者学到点什么</li>
<li>在前端技术的横向影响</li>
<li>对业务中其他角色或业务的影响</li>
<li>对未来的判断</li>
<li>是否是重复造轮子</li>
<li>是否是“技术投机”，缺乏业务场景适用性思考</li>
</ul>
<p>解决问题与痛点，远比构思复杂技术方案更重要，避免无差异重复造轮子或“技术投机”，着重预判规划落地后的影响力与价值论证。</p>
<p><strong>3. 规划推导</strong><br>规划推导分正推：从线索-&gt;本质痛点或问题-&gt;解决方案-&gt;目标，反推：从目标-&gt;解决方案-&gt;本质痛点或问题-&gt;线索。</p>
<p>二个过程都需要，你需要通过反推，去论证推导与路径的正确性，比如你的目标是提高 50 张页面 50% 的性能，推到解决方案，发现只能提高 10 张页面 10 % 的性能，就会发现解决方案是不靠谱的，需要再思考。</p>
<p>所有的线索都是现象，你需要去剖析现象背后本质，思考：</p>
<ul>
<li>什么问题导致了出现这些现象？</li>
<li>痛点够不够痛？</li>
</ul>
<p>解决方案的设计要思考：</p>
<ul>
<li>调研是否充分，集团是否有现成方案？</li>
<li>是自己做，还是引进？还是引进后二次定制？</li>
<li>预计投入资源，投入产出比如何？</li>
</ul>
<p>目标的设计要思考：</p>
<ul>
<li>能够体现规划价值</li>
<li>可量化，可衡量，有影响</li>
<li>可达到</li>
</ul>
<p>一般写规划时候，我们是先写目标，再写解决方案，而在实际推导规划时，一般是有个大概的解决方案，然后预判可能达到的目标。</p>
<p>举个简单的推导例子（过程做了简化）：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCv7?w=872&amp;h=802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>线索大部分单点的，如果依照单一线索，做出来的规划也是单一价值，就会发现价值不够大，比如上图，如果只是为了解决设计师的痛点，只做品牌的优化，就会发现价值点很小，而只是解决前端研发效率的问题，又如何深化前端的价值。<br>所以最后决定打包在一块，项目名是业务有体感的体验升级，目标是业务有体感的跳失率，将前端技术体系的建设包在了里面，同时也解决其他协作方的痛点。</p>
<p><strong>4. 控制力</strong><br>如果一件事件你也能做，别人也能做，且比你做的好，那么就要想想要不要做这件事。</p>
<p>控制力还体现在边界梳理，能跟其他岗位或其他前端团队合作是非常好的，但一定要理清楚边界，权责清晰才能有效促进规划成功。</p>
<h2>四、规划落锤</h2>
<p>价值聚焦完后，已经识别出最有价值的事，但未必是团队当下最重要的事，所以有规划落锤阶段，有如下几件事：</p>
<ul>
<li>规划内容按照重要性排序</li>
<li>产出规划 PPT</li>
<li>产出关键里程牌时间点</li>
<li>排兵布阵、资源调度</li>
</ul>
<p>李牧老师说，“TL的核心素质是判断力与前瞻性”，这个阶段就很考验着二个能力。</p>
<p><strong>1. 长期规划</strong><br>价值聚焦完发现可做的事很多，如何办呢？这是好事，就可以试图做下长期规划，可以是三年规划、二年规划，并不是说非得一年建设完所有体系，罗马不是一天建成的，画张三年大图，给自己以指引。</p>
<p>明确团队技术体系的演进方向，穷尽所有高价值的事，每个季度复盘调整这张大图，让团队有共同的目标。</p>
<p>拔赤老师建议 “技术规划以一年为最小单位，每季度做详细复盘，跟的勤，就不怕跟丢”。</p>
<p><strong>2. 勇气与吸引力法则</strong><br>有时你认为最有价值也是团队最重要的事会受到其他人的挑战，比如有人坚持认为现在资源紧张，不应该额外投入资源去做这件事。</p>
<p>这时就是很考验人的勇气的时候，选择接受，那么这件事就从你的规划移除，人员轻松了，产品满意了，但技术体系、体验没发生变化；选择坚持，那么人员工作强度变很大，协作方说不定会投诉。</p>
<p>你肯定也有面临这种选择的时候，无关对错，但我们需要有勇气面对挑战，做对的事，不要怂。</p>
<p>吸引力法则（你关注什么，就会将什么吸引进你的生活）告诉我们，有勇气去要求，笃定你的判断，有策略的执行，周围自然会发生你所希望的变化。所以关注于对的事，别被困难吓倒。</p>
<p>还有个策略，跟你的老板或上游来个“对赌”吧？</p>
<h2>一定要发声营销</h2>
<p>技术团队的 PR 意识相对淡簿，而前端团队在业务的影响力又相对较弱，所以特别需要 PR。</p>
<p>发战报是最有效的营销方式，但需要注意个注意点，如果战报对象是业务方、协作方，不懂前端技术，战报需要包装，让他们能看的懂。</p>
<p>别写做了什么技术方案之类，别人看不懂，也没时间看。</p>
<p>技术产品宣传：<br>技术产品宣传分社区与公司内，办法很多，发放宣传礼品是个讨喜的办法。</p>
<p>去年自费做的二个宣传品：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbaCwm?w=897&amp;h=1381"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>本文作者：剑平<br><a href=""http://click.aliyun.com/m/49933/"" rel=""nofollow noreferrer"">原文链接</a><br>本文为云栖社区原创内容，未经允许不得转载。</p>

                ", 前端 Leader 如何做好团队规划？阿里内部培训总结公开,1531977872,378,1,537,1,1,https://segmentfault.com/a/1190000014885354
27,1,0,9,"
                    
<p>尽量降低视频码率又不影响视频的主观观看质量，这是视频平台最关心的问题之一，因为降低码率意味着视频播放带宽的下降，节约成本。</p>
<p>2018年3月，又拍云自研的“窄带高清”功能，通过码率控制优化，让视频在主观质量不受影响的情况下，高效降低30%视频码率。窄带高清通过视频内容复杂度算法来确定视频应用场景，继而确定该场景下最优视频编码参数，辅助于码率控制算法，最终达到视频码率控制与带宽优化这个目的。</p>
<p>窄带高清可以有效提升视频播放平台终端用户视频打开速度，并且减少视频分发在带宽成本的上的消耗。</p>
<h2>为什么窄带高清可以节省流量</h2>
<p>一般来说，视频转码所需的成本比视频播放带宽少很多。因此通过视频转码来降低带宽成本成为可能，窄带高清就是建立在这个大前提下的一个功能。通过窄带高清功能可以节省30%的视频码率，大大降低直播、点播等业务场景下的带宽成本。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014866103"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""△ 左为源视频，右为窄带高清（详见视频演示）"" title=""△ 左为源视频，右为窄带高清（详见视频演示）""></span></p>
<h2>窄带高清是如何实现</h2>
<p>实现窄带高清有两个优化方向，1.在相同码率的情况下提升视频质量；2.在主观质量不受损失的情况下，尽可能降低视频码率。</p>
<p>根据实际业务需求，又拍云的“窄带高清”功能采用了第二种思路，即保持视频质量，降低码率。</p>
<p><strong>场景划分</strong></p>
<p>首先我们需要对视频进行内容复杂度分析，获取场景信息，取得视频空间域的复杂度和时间域的复杂度，然后获得视频序列最终的复杂度，最终确定视频编码场景。</p>
<p><strong>为什么要进行场景划分呢？</strong></p>
<p>下文我们以场景运动剧烈和平缓的视频为例，跟大家解释一下场景划分的原因。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014866104"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""△ 平缓视频、剧烈视频的码率分析（psnr）"" title=""△ 平缓视频、剧烈视频的码率分析（psnr）""></span></p>
<p>从上图可以看出，在相同质量下，场景运动缓慢的视频比场景运动剧烈的视频，所需码率少很多，这就是场景划分的意义所在。</p>
<p><strong>目前我们对手机拍摄视频、动画、商业动作大片、影视剧、在线教育、综艺节目等视频场景进行测试，获取常见场景下视频内容的编码复杂度。</strong></p>
<p>另外在高码率的时候，码率增加对视频质量的提升比较少，因此只要找到合适码率，那么视频低码率下的质量和高码率下的质量是相差无几的，这是窄带高清的理论基石。</p>
<p><strong>码率控制算法研究</strong></p>
<p>码率控制算法是视频编码器中非常重要的部分，学术上，码率控制算法分为两种：CBR（Constant Bit Rate，恒定码率）和VBR（Variable Bit Rate，可变码率）。考虑到业务需求是在主观质量不变的情况下，降低视频文件大小，又拍云“窄带高清”功能采用VBR的方式，并做了如下设定提升整体画质的表现：</p>
<ul>
<li>视频运动缓慢的时候，使用更低的码率；运动剧烈的时候，使用更高的码率；</li>
<li>视频图像内部，静止的部分分配更少的码率；运动的部分分配更多的码率。</li>
</ul>
<p><strong>通俗的说，把码率放在该用的地方，不浪费每一个比特，实现更低的码率，更清晰的画质，更小的文件尺寸。</strong></p>
<p><strong>视频编码器优化</strong></p>
<p>如何对视频编码器进行优化，又拍云通过客观质量评价加主观质量评价想结合的办法来制定视频编码器优化标准。</p>
<p>视频质量评价作为视频领域热门的研究方向之一，分成<strong>主观质量评价和客观质量评价</strong>两类。</p>
<p>主观质量评价，即通过人工观察者直接观察视频，在主观打分，对视频质量的好坏进行分级，该方法必须严格的测试环境实施步骤复杂，而且对观察者要有一定的专业要求，因此实施起来需要巨大的代价，一般会用在科研机构小规模的算法验证。</p>
<p>而对海量视频数据和工业界来说，客观质量评价是更好的选择。PSNR(Peak Signal to Noise Ratio，峰值信噪比)，是基于数学统计特性的评价方法，基于独立的像素差值，忽略序列内容对失真可见度的影响，因而会出现和主观感知的视频质量的一致性存在差异。但是算法简单，易于操作，且大规模应用。</p>
<p>针对PSNR的缺点，Zhou Wang等人实现了亮度、对比度和结构失真相互独立的质量评价方法SSIM，得到更接近人眼视觉特性的评价指标。但是依然是过于简单，屏蔽掉了HVS的其他生理特性。</p>
<p>视频编码器的参数数量很多，纷繁复杂，为了得到最佳的优化组合，我们用了客观质量评价算法PSNR（Peak Signal to Noise Ratio，峰值信噪比）和SSIM（Structural SIMilarity，结构相似度），主观质量评价算法VMAF（Video Multi-Method Assessment Fusion），再配合人工主观质量评价的方式，获取了常见场景下视频编码器的参数优化方案。</p>
<p>又拍云窄带高清，融合了以上几种客观和主观的评价方法，在编码器优化过程中，获取码率和视频质量的平衡。</p>
<p>目前，绝大多数视频还是使用H.264/AVC视频编码标准，更先进的H.265/HEVC和VP9的普及度还不够。因此又拍云“窄带高清”功能优先支持了H.264视频编码格式，未来将支持H.265格式。</p>
<p>学术界还有许多码率方面的研究成果，比如基于ROI（Region of Interest，感兴趣区域）和HVS（Human Visual System，人眼视觉系统）的码率控制，这些成果和技术，又拍云也将积极融入到相关产品和解决方案中。</p>
<p><strong>推荐阅读：</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/297/%25E3%2580%2590%25E7%259C%2581%25E5%25B8%25A6%25E5%25AE%25BD%25E3%2580%2581%25E5%258E%258B%25E6%2588%2590%25E6%259C%25AC%25E4%25B8%2593%25E9%25A2%2598%25E3%2580%2591%25E7%2588%25B1%25E5%25A5%2587%25E8%2589%25BA%25E7%25AC%25AC%25E4%25B8%2580%25E5%25AD%25A3%25E5%25BA%25A6%25E5%258F%2588%25E7%2583%25A7%25E4%25BA%258611%25E4%25B8%25AA%25E4%25BA%25BF%25E5%2585%2583%25EF%25BC%258C%25E4%25BB%2580%25E4%25B9%2588%25E6%2597%25B6%25E5%2580%2599%25E6%2598%25AF%25E4%25B8%25AA%25E5%25A4%25B4%25EF%25BC%259F.html"" rel=""nofollow noreferrer"">爱奇艺第一季度又烧了11个亿元，什么时候是个头？</a><br><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/287/%25E5%25B9%25B3%25E5%259D%2587%25E8%258A%2582%25E7%259C%2581%25E6%25B5%2581%25E9%2587%258F%252030%2525%2520%25EF%25BC%258C%25E8%25BF%2599%25E9%25A1%25B9%25E8%25A7%2586%25E9%25A2%2591%25E4%25BA%2591%25E5%25A4%2584%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E6%2598%25AF%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259E%25E7%258E%25B0%25E7%259A%2584%25EF%25BC%259F.html"" rel=""nofollow noreferrer"">平均节省流量 30% ，这项视频云处理技术是如何实现的？​</a></p>

                ", 【省带宽、压成本专题】降低30%视频码率，深挖“窄带高清”的实现原理,1531977873,142,1,461,1,1,https://segmentfault.com/a/1190000014866098
28,1,0,9,"
                    
<p>（1）程序员的读书历程：x 语言入门 —&gt; x 语言应用实践 —&gt; x 语言高阶编程 —&gt; x 语言的科学与艺术 —&gt; 编程之美 —&gt; 编程之道 —&gt; 编程之禅—&gt; 颈椎病康复指南。</p>
<p>（2）程序员最讨厌的四件事：写注释、写文档、别人不写注释、别人不写文档……</p>
<p>（3）十行代码 九个警告 八个错误 竟然敢说七日精通 六天学会 五湖四海也不见如此 三心二意之项目经理 简直一等下流。</p>
<p>（4）世界上最遥远的距离不是生与死，而是你亲手制造的BUG就在你眼前，你却怎么都找不到她。</p>
<p>（5）世界上最远的距离，是我在if里你在else里，虽然经常一起出现，但却永不结伴执行。</p>
<p>（6）我很奇怪客栈这个词，难道后入住的必须先退房吗？</p>
<p>（7）作为IT人员，你觉得什么工具能大大提高你的工作效率？</p>
<blockquote>单身。</blockquote>
<p>（8）Android上能提高学习、工作效率的应用有哪些？</p>
<blockquote>关机。</blockquote>
<p>（9）为什么很多程序员、geek 都喜欢熬夜，而且在后半夜工作效率异常高？</p>
<blockquote>一个姑娘问我，搞学术的为什么都睡得那么晚，难道只有到晚上才有灵感？不是，姑娘，搞学术不靠灵感，靠的是碌碌无为的白天引发的愧疚心。</blockquote>
<p>（10）单身程序狗解决了一个技术难题后没有妹子可以炫耀或夸一下自己怎么办？</p>
<blockquote>现在你明白了吧，为什么那么多程序员要写技术博客。</blockquote>
<p>（11）程序员的核心竞争力是什么？为什么？</p>
<blockquote>“玩算法的码农，打拼靠蓝条，像是法师。数学就等于蓝条最大值，数学差，魔法值不高，很快就到瓶颈了。外语影响回蓝速度。经验和智力加急速和穿透的。不玩算法的码农，像是战士，打拼靠血条，体质加生命，精神加生命回复，经验和敏捷加急速和破甲。”</blockquote>
<p>（12）程序员最常说的谎言是什么？</p>
<blockquote>// TODO</blockquote>
<p>（13）程序员的鄙视链是什么？</p>
<blockquote>老婆漂亮的程序员，鄙视老婆不漂亮的程序员。 <br>有老婆的程序员，鄙视没有老婆的程序员。<br>没有老婆有女朋友的程序员，鄙视单身程序狗。<br>在单身狗之间，才有语言、编辑器和操作系统的互相鄙视。</blockquote>
<p>（14）女票允许我出轨，并且还介绍她闺密给我认识。在她真的很爱我的前提下，该如何理解她的行为？</p>
<blockquote>千万不要上当！！！Mac告诉你，我也可以装windows哦，但你真的装了，会用高发热来报复你的！</blockquote>
<p>（15）分手100天了，还没有走出来怎么办？</p>
<blockquote>替换文件永远比删除文件更彻底。</blockquote>
<p>（16）程序员夫妻结婚戒指刻什么字好？</p>
<blockquote>0 error 0 warning</blockquote>
<p><a href=""https://segmentfault.com/u/webing123"" rel=""nofollow noreferrer"">阅读更多</a></p>

                ", 关于程序员的段子，有没有get到你的点？,1531977875,323,1,724,1,1,https://segmentfault.com/a/1190000014818487
29,1,0,9,"
                    
<p>（1）入门期间不要盲目看太多书，找一本网上或身边有经验程序员推荐的教材，先系统的学习。</p>
<p>（2）不知怎么选技术书时就挑薄的。起码不会太贵，且你能看完。</p>
<p>（3）看得懂的书，仔细看；看不懂的书，硬着头皮也要看完。</p>
<p>（4）书读百遍其义自见，别指望读一遍就能掌握。</p>
<p>（5）菜鸟容易被对象、属性、方法等词汇迷惑？那是你连最基础知识都还没掌握。</p>
<p>（6）不要漏掉教程中任何一个习题——请全部做完并做好笔记。</p>
<p>（7）不要忽视没一个看起来不起眼的问题，经常总结做到举一反三。</p>
<p>（8）请把教程里的例子亲手实践下，即使案例中有完整源码。</p>
<p>（9）把在教程中看到的有意义的例子扩充；并将其切实的运用到自己的工作中。</p>
<p>（10）水平是在不断的实践中完善和发展的，你与大牛差的只是经验的积累。</p>
<p>（11）没积累足够知识和经验前，你是开发不出一个完整项目的。</p>
<p>（12）好的项目作风硬派，一键测试，一键发布，一键部署；烂的项目生性猥琐，口口相传，不立文字，神神秘秘。</p>
<p>（13）常充电。程序员只有一种死法：土死的。</p>
<p>（14）活到老学到老，只有一招半式是闯不了江湖的。</p>
<p>（15）提问前先做调研。问不到点上既被鄙视，又浪费自己的时间。</p>
<p>（16）遇到问题不要张口就问，要学会自己找答案，比如google和百度上都有很多编程相关资料，你只要输入关键字就能找到你的答案。</p>
<p>（17）普通程序员 + google = 超级程序员</p>
<p>（18）编码不要畏惧变化，要拥抱变化。</p>
<p>（19）编程之事，隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药。</p>
<p>（20）代码结构清晰，其它问题都不算事儿。</p>
<p>（21）一行代码一个兵。形成建制才能有战斗力。单位规模不宜过大，千人班，万人排易成万人坑。</p>
<p>（22）注释贵精不贵多。杜绝大姨妈般的“例注”。漫山遍野的碎碎念注释，实际就是背景噪音。</p>
<p>（23）注释是稍差的文档。更好的是清晰的命名。让代码讲自己的故事。</p>
<p>（24）重构/优化/修复Bug，同时只能做一件。</p>
<p>（25）重构是程序员的主力技能。</p>
<p>（26）忘掉优化写代码。过早优化等同恶意破坏；忘掉代码做优化。优化要基于性能测试，而不是纠结于字里行间。</p>
<p>（27）出现bug主动查，不管是不是你的。这能让你业务能力猛涨、个人形象飙升；如果你的bug被别人揪出来.....呵呵，那你会很被动≦(._.)≧</p>
<p>（28）最好的工具是纸笔；其次好的是markdown。</p>
<p>（29）最有用的语言是English。其次的可能是Python。</p>
<p>（30）git是最棒的。简单，可靠，免费。</p>
<p>（31）Leader问任务时间，若答不上来，可能是任务拆分还不够细。</p>
<p>（32）宁可多算一周，不可少估一天。过于“乐观”容易让boss受惊吓。</p>
<p>本文在GitHub的地址 <a href=""https://github.com/WEBING123/Work-study-skills"" rel=""nofollow noreferrer"">Work-study-skills</a></p>
<p><a href=""https://segmentfault.com/u/webing123"" rel=""nofollow noreferrer"">阅读更多</a></p>

                ", 老鸟程序猿总结的工作学习技巧，不看后悔！,1531977876,244,1,575,1,1,https://segmentfault.com/a/1190000014576332
30,1,0,9,"
                    
<h2>前言</h2>
<p>这里筑梦师,是一名正在努力学习的iOS开发工程师,目前致力于全栈方向的学习,希望可以和大家一起交流技术,共同进步,用简书记录下自己的学习历程.</p>
<blockquote>
<a href=""https://www.jianshu.com/p/19265c17f99b"" rel=""nofollow noreferrer"">个人学习方法分享</a><br><a href=""https://www.jianshu.com/p/84db083b2f06"" rel=""nofollow noreferrer"">2017年计算机系书单分享</a>
</blockquote>
<pre><code>本文阅读建议
1.一定要辩证的看待本文.
2.本书单原本打算在后半年才放出,但是因为抄袭,我觉得还是立即放出来给大家分享比较好.
3.本书单所涉及书籍如有需要,可以简信私我,仅供学习交流使用,如有侵权请与我联系.
4.2018年书单均为我在学习过程中所阅读书籍,可能会与17年书籍有所重复.本文将在年底结束更新.
5.觉得哪里不妥请在评论留下建议~
6.觉得还行的话就点个小心心鼓励下我吧~</code></pre>
<hr>
<pre><code>目录
1.实体书籍
2.学习方法相关书籍
3.程序员思想书籍
4.全栈必读书籍
5.全栈拓展书籍
6.写作书籍
7.其他书籍</code></pre>
<hr>
<h2>提示</h2>
<p>因为本人尚且还在搜集属于18年的新书籍,如果您有什么好书推荐,请不吝私信我,我将会添加到本书单~</p>
<hr>
<h2>实体书籍</h2>
<p>因为当当网书香节和京东读书月,我入手了我的第一批实体书,当阅读完以后,我会挨个发表读书笔记~希望各位继续关注~</p>
<p>本人挑选实体书两个准则:<br>1.<strong>近一年出版的书,网络上没有电子版.</strong><br>2.<strong>有电子版的书,但是需要反复研读的,例如CSS世界.</strong><br>3.<strong>工具书,需要随时可以进行翻看的.</strong></p>
<p>网络信息化时代,实体书存在的意义,便是阅读之后知识的沉淀,其吸收知识的效率,要比看视频和直播快.</p>
<pre><code class=""markdown"">基础类书籍
细说系列丛书:
1.细说网页制作
2.细说JavaScript
3.细说DOM
4.细说AJAX和JQuery
5.细说HTML5高级API
CSS实战手册
CSS权威指南
学习JavaScript数据结构与算法.
ES6标准入门
MySQL排错指南
Node.js设计模式

项目类&amp;实践类
CSS世界
B/S项目实战开发
疯狂前端开发讲义jQuery+AngularJS+Bootstrap前端开发实战
全栈开发之道:MongoDB+Express+AngularJS+Node.js
前端系列丛书:
深入浅出WebPack
前端工程师必备技能Vue
前端工程化:体系设计与实践
高效前端:Web高效编程与优化实践

iOS开发类:
iOS开发实战:从入门到上架AppStore
iOS11开发指南
Sketch &amp; Xcode 双剑合璧
动静之美Sketch移动UI与交互动效设计

励志类:
最怕你一生碌碌无为，还安慰自己平凡可贵
姑娘，脱贫比脱单更重要
好看的皮囊千篇一律，有趣的灵魂万里挑一
你要么出众,要么出局
你所谓的稳定,给不了你想过的生活</code></pre>
<p>有很多人会说,买这么多实体书,你看的完吗,我笑笑:<br><strong>脚踏实地,循序渐进</strong></p>
<p><strong><a href=""https://www.jianshu.com/u/6bb892b5d321"" rel=""nofollow noreferrer"">我的同事</a></strong>买的:</p>
<blockquote>CSS世界<br>Node.js区块链开发<br>Laravel入门与实战:构建主流PHP应用开发<br>HTML5+CSS3+jQuery Mobile轻松构造App与移动网站<br>HTML5游戏开发技术--Egret Engine<br>锋利的jQuery(第二版)<br>HTML5移动开发</blockquote>
<p>这些书的读书笔记可以关注一下我的同事.</p>
<h2>学习方法相关书籍</h2>
<pre><code>如何高效学习(斯科特.杨)
我也能做CTO之程序员职业规划</code></pre>
<hr>
<h2>程序员思想书籍</h2>
<pre><code>《人月神话》
《编译原理》
《事务处理》
《汇编语言程序设计》
《程序员的自我修养—链接、装载与库》</code></pre>
<hr>
<h2>全栈必读书籍</h2>
<pre><code>Head First HTML与CSS 第2版
Head First HTML5 Programming（中文版）
Head.First.PHP.&amp;.MySQL
Head First JavaScript
图解HTTP
PHP和MySQL.Web开发(原书第4版)
Head First 设计模式(中文版)
Head First Web设计(中文版)
Head First Jquery（中文版）
HTML5与CSS3权威指南(完整版)
JavaScript_DOM编程艺术第二版(中文)
JavaScript高级程序设计第3版
JavaScript设计模式与开发实践
php精要版(高洛峰)
深入PHP面向对象模式与实践
细说php第二版扫描
HTTP权威指南.David.Gourle
图解TCP_IP_第5版
TCP-IP详解三卷
---------以上为AMP入门必读---------</code></pre>
<hr>
<h2>项目开发必读书籍</h2>
<pre><code>App后台开发运维和架构实践
现代企业的Web架构、流程及组织
密码编码学与网络安全-原理与实践（原书第5版)
AliDouble11
阿里技术参考图册 研发篇&amp;算法</code></pre>
<hr>
<h2>全栈拓展书籍</h2>
<pre><code>CSS世界
SQL注入攻击与防御第2版
Head First Java 中文版(Java后台入门必读)
Head First Servlet and JSP(Java后台入门必读) 
Head First SQL(中文版)(Java后台入门必读)
Head First Python(中文版)(Python后台入门必读)</code></pre>
<hr>
<h2>写作书籍</h2>
<pre><code>文案创作完全手册/罗伯特·布莱
麦肯锡教我的写作武器/高杉尚孝
完全写作指南/劳拉·布朗</code></pre>
<hr>
<h2>其他书籍</h2>
<pre><code>《活法》/稻盛和夫
《干法》/稻盛和夫
《成功的真谛》/稻盛和夫
《阿米巴经营》/稻盛和夫
《精益创业》/埃里克·莱斯
《从0到1》/彼得·蒂尔
《黑天鹅》/纳西姆·尼古拉斯·塔勒布
《金字塔原理》/芭芭拉·明托
《无为》/森舸澜
《格调》/保罗·福赛尔
《这才是心理学》/基思·斯坦诺维奇
《输赢心理学》/波·布朗森&amp;阿什利·梅里曼
《社会性动物》/E·阿伦森
《人性的弱点》/戴尔·卡耐基
《时间简史》/斯蒂芬·霍金
《宇宙的尺度》/大卫·布拉特纳
《宇宙的琴弦》/布赖恩·格林</code></pre>
<hr>
<h2>结束语</h2>
<p>如果您对这篇文章有什么意见或者建议,请评论与我讨论.<br>如果您觉得还不错的话~可以点个喜欢鼓励我哦.<br>如果您想和我一起学习,请毫不吝啬的私信我吧~<br>介个是我的<a href=""https://dreamerwinston.github.io/blog/"" rel=""nofollow noreferrer"">个人博客</a>,欢迎参观哦~</p>

                ", 2018计算机系书单推荐(持续更新),1531977878,467,1,676,1,1,https://segmentfault.com/a/1190000014538266
31,1,0,9,"
                    
<h1>iOS开发学习路线</h1>
<h2>前言</h2>
<p>这里筑梦师,是一名正在努力学习的iOS开发工程师,目前致力于全栈方向的学习,希望可以和大家一起交流技术,共同进步,用简书记录下自己的学习历程.</p>
<blockquote><a href=""https://www.jianshu.com/p/19265c17f99b"" rel=""nofollow noreferrer"">个人学习方法分享</a></blockquote>
<pre><code>本文阅读建议
1.一定要辩证的看待本文.
2.本文主要是本人对iOS开发经验中总结的知识点
3.本文所有观点仅代表本人.
4.本文只阐述学习路线和学习当中的重点问题.需要读者自己使用百度进行拓展学习.
5.本文所表达观点并不是最终观点,还会更新,因为本人还在学习过程中,有什么遗漏或错误还望各位指出.
6.觉得哪里不妥请在评论留下建议~
7.觉得还行的话就点个小心心鼓励下我吧~</code></pre>
<hr>
<pre><code>目录
1.对本职业看法
2.学习方法
3.职业规划
4.iOS开发学习路线
5.iOS基础知识点
6.iOS中级知识点
7.iOS高级知识点
8.官方Kit</code></pre>
<hr>
<h2>对本职业看法</h2>
<p>16年我尝试加入各种iOS开发交流群,群里的气氛大致就是:学什么iOS,iOS完了,OC完了.群里大致三种人:谁有企业开发证书,马甲包了解一下,iOS某网课推广.至今,大部分iOS开发群还都是仅供吹水用,偶尔能碰见几个好心人解决一下问题.</p>
<hr>
<h3>个人观点</h3>
<p>个人观点:iOS开发这个职业,不是别人说完就完的,那些说完了的人都是因为技术菜,没有权威性,不想想自己为什么菜,为什么没有和唐巧王巍在一个高度,因为菜.</p>
<p>还没有到达一个高度就轻易否定一个职业,注定被这个职业淘汰.</p>
<p>所以,无视掉这种人这么荒谬的观点,那些真正有技术,懂得学习的iOS高级开发工程师,现在正在各大企业(腾讯百度阿里等),一句话,不要有比上不足比下有余的态度.努力学习.</p>
<p>真正会学习的人,不会说iOS完了,而是想着如何提升自己,你想想,真正牛逼的人,真的只会iOS开发这一种吗?</p>
<hr>
<h2>学习方法</h2>
<blockquote>面对有难度的功能,不要忙着拒绝,而是挑战一下,学习更多知识.<p>尽量独立解决问题,而不是在遇到问题的第一想法是找人.</p>
<p>多学习别人开源的第三方库,能够开源的库一定有值得学习的地方,多去看别的大神的博客.</p>
<p>作为一个程序员,如果你停止了学习,你也必将会被这个团队淘汰.</p>
<p>要把学习的技能当做兴趣,而不是为了挣钱去学习,是为了学习技能而学习.</p>
<p>有给自己定制一个详细的职业规划和人生规划,大到5~10年,小到近3年(并且细化到月)的计划.</p>
<p>不要盲目的面试,要针对即将面试的工作,准备面试.</p>
<p>首先针对一个自己没有接触到的知识,先使用 百度谷歌等网站搜索资料.然后进行学习</p>
<p>这是个好东西,我劝你多用用<a href=""https://developer.apple.com/search/"" rel=""nofollow noreferrer"">https://developer.apple.com/s...</a></p>
<p>尝试写一个demo,对新技术进行熟悉.</p>
<p>如果市面上有成熟的Demo或者第三方库,下载下来进行学习.</p>
<p>在熟悉的过程中,遇到了任何问题,再进行百度/谷歌,学习不同人的不同看法和解决方法.</p>
</blockquote>
<hr>
<h2>职业规划</h2>
<h3>个人观点</h3>
<p>首先是针对iOS这个行业,找不到工作要从自身找原因,为什么自己没有大公司的工作经历,为什么大公司会把自己毙掉,因为实力不够,因为你菜,你不够强.要从自身找原因,是,培训机构一阵子培训了一堆iOS开发工程师,但你不能从特么一堆菜鸟中杀出去,你就是菜鸟,不要怨天尤人了,好好努力学习.</p>
<p>不要只做到鹤立鸡群,而想着怎么离开这群鸡,重归鹤群.</p>
<p>针对程序员行业,这是一个需要努力奋斗的行业,也许他并不需要你有多高的文凭,好的文凭可以去大公司工作,没有好的文凭,但拥有丰富的工作经验,和开源库,也会是你本人实力的体现.所以,努力学习,路是自己走出来的,原地踏步谁也救不了你.</p>
<p>职业规划一般分为两种,横向和纵向,程序员行业横向走项目经理提成获得分红,纵向发展成为技术经理,必要时可以自行创业</p>
<hr>
<h2>iOS开发学习路线</h2>
<h3>iOS定位</h3>
<ul><li>
<p>iOS定位</p>
<ul>
<li>简介:这里的定位,仅仅代表我个人意见,仅符合本笔记如何学习从哪里开始学习,怎么去学习来说.</li>
<li>
<p>尚未入门</p>
<ul><li>
<p>如何判断自己是否入门</p>
<ul>
<li>是否了解Mac</li>
<li>是否了解Xcode</li>
<li>是否了解Objective-C</li>
<li>是否会使用UI控件.</li>
<li>如果上面的都不了解,那说明你还没有入门,请从iOS学习路线开始学习.</li>
</ul>
</li></ul>
</li>
<li>
<p>初级iOS开发</p>
<ul>
<li>说明:作为一名初级的iOS开发,你需要具备以下技能</li>
<li>
<p>必备技能(全部都会的情况下查看下一项)</p>
<ul>
<li>Xcode的使用</li>
<li>
<p>第三方库的灵活使用</p>
<ul>
<li>AFN</li>
<li>MJRefresh</li>
</ul>
</li>
<li>各种网站的使用</li>
</ul>
</li>
<li>
<p>如何判断是否可以升阶</p>
<ul>
<li>是否了解AFNetworking 的实现原理</li>
<li>是否了解SDAutolayout/Masonry 一种布局库的原理</li>
<li>是否能够处理基本的iOS崩溃原因/无法编译原因/无法上架原因?</li>
<li>是否拥有了一定的工作效率,稳定的工作效率.(而不是说,上面派了一个活下来,忙都忙不完,天天加班,还一堆bug)</li>
<li>是否能够处理第三方库引起的崩溃.</li>
<li>是否可以很好的融入工作环境,完成每一阶段的工作指标,而不会让自己疲惫不堪.</li>
</ul>
</li>
<li>
<p>结论</p>
<ul>
<li>iOS中级开发说白了,就是你学会了基本的UI界面搭建,上架,沉淀一段时间,你觉得自己还适合这门行业,还适合,还能接受 这个所谓的iOS开发工程师的行业.你就可以说是一名中级iOS开发.</li>
<li>这个沉淀时间 大约在1年的实际工作中,就可以完成.</li>
<li>如果你觉得这门行业不适合你,请仔细结合自身情况,是否转另一门计算机语言,还是彻底转行.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中级iOS开发</p>
<ul>
<li>说明:作为一名中级的iOS开发,你需要具备以下技能</li>
<li>
<p>必备技能(全部都会的情况下查看下一项)</p>
<ul>
<li>应用的内存处理</li>
<li>应用的推送处理</li>
<li>应用的模块化/单元测试</li>
<li>应用的第三方集成/集中化管理/稳定迭代</li>
<li>阅读强大的第三方源码/拥有快速上手新的第三方库的能力.</li>
<li>能够接受各种新功能的开发(这里是指,即使你没有做过,但是你仍然可以凭借着学习,解决任何业务需求:例如:蓝牙.AR.摄像头.硬件交互.等)</li>
<li>清楚明白数据的传递方式,应用与后台如何交换数据,交换数据的过程,结果,格式.</li>
<li>多线程的灵活使用.</li>
<li>各种并发事件的处理/以及界面的合理性/流畅度</li>
<li>设计模式的灵活使用.</li>
</ul>
</li>
<li>如何判断是否可以升阶</li>
<li>结论</li>
</ul>
</li>
<li>
<p>高级iOS开发</p>
<ul>
<li>说明:作为一名高级的iOS开发,你需要具备以下技能(我不是高级开发,所以这里只能给你们提供建议.)</li>
<li>
<p>必备技能</p>
<ul>
<li>应用的组件化/架构分层</li>
<li>数据结构，操作系统，计算机网络都有自己的了解和认知</li>
<li>Shell脚本/python/Ruby/JS 至少会一种.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li></ul>
<pre><code>***</code></pre>
<h3>详细学习路线</h3>
<ul><li>
<p>学习路线</p>
<ul>
<li>简介<br>这里只简单阐述一些概念性的东西,以及学习路线规划,真正的知识请从iOS基础知识点往下开始看.</li>
<li>
<p>Objective-C</p>
<ul>
<li>介绍</li>
<li>概念</li>
<li>编译原理</li>
</ul>
</li>
<li>
<p>程序启动原理</p>
<ul>
<li>
<p>App组成</p>
<ul>
<li>Info.plist</li>
<li>.pch</li>
</ul>
</li>
<li>打开程序</li>
<li>执行main函数</li>
<li>执行UIApplicationMain函数</li>
<li>初始化UIApplication(创建设置代理对象,开启事件循环)</li>
<li>监听系统事件</li>
<li>结束程序.</li>
</ul>
</li>
<li>
<p>语法.(此处定义可能略失严谨,口头教学为主)</p>
<ul>
<li>基础语法</li>
<li>对象.</li>
<li>属性</li>
<li>数据类型</li>
<li>方法</li>
<li>继承</li>
<li>Frame/CGRect/CGPoint和CGSize</li>
<li>内存(针对MRC下情况进行介绍)</li>
<li>ARC/MRC</li>
<li>弱引用/强引用</li>
<li>Assign,retain,copy,strong</li>
<li>import 和@class的区别</li>
</ul>
</li>
<li>
<p>Xcode使用</p>
<ul>
<li>首先是针对Xcode菜单栏,希望自己可以去翻译一下每个菜单里每项功能的英文都是什么意思,有助于自己熟悉并加深印象的使用Xcode.</li>
<li>熟悉Xcode的各个功能.</li>
</ul>
</li>
<li>UIKit控件.</li>
<li>
<p>界面分析(下载App进行学习).</p>
<ul>
<li>在这里推荐有兴趣的开发人员,下载并分析,AppStore中的每项分类的top50的应用,多学习大公司以及流行应用是如何开发应用的,其中流行的,新颖的开发界面的方式可以总结下来,猜想在大应用中,别的程序员是如何开发的.</li>
<li>界面适配</li>
</ul>
</li>
<li>
<p>代码架构.</p>
<ul><li>代码架构文章推荐:<a href=""https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html"" rel=""nofollow noreferrer"">https://casatwy.com/iosying-y...</a>
</li></ul>
</li>
<li>
<p>各种工具、第三方的使用.</p>
<ul><li>其实每个项目的建立都大致分为:项目框架搭建,原生界面搭建,嵌入第三方库.有很多功能都会用到第三方库,大多数第三方库都是本着快速开发,完整功能实现的目的存在的.需要开发人员能够根据业务逻辑不同,选择最好最优质的第三方库进行使用.</li></ul>
</li>
<li>
<p>代码封装</p>
<ul><li>当使用较多第三方库后,要求开发人员学习其开发特点,以及其封装手法,运用在自己的项目上,封装自己的代码.灵活运用.</li></ul>
</li>
<li>完整项目.</li>
<li>开发技巧</li>
<li>个人心得</li>
</ul>
</li></ul>
<hr>
<h2>iOS基础知识点</h2>
<ul><li>
<p>iOS基础知识点</p>
<ul>
<li>
<p>如何学习iOS</p>
<ul>
<li>
<p>刚刚入门(如何学习)</p>
<ul>
<li>打好基础,学习OC中各种常用语法.</li>
<li>学习如何上架,上架会因为什么被拒,了解App上架规则.</li>
<li>多学习官方说明文档.</li>
</ul>
</li>
<li>
<p>刚刚入职1年(如何稳定)</p>
<ul>
<li>多看开源或者注明的第三方库.</li>
<li>收藏并阅读各种大神的博客或者论坛.</li>
<li>开始考虑项目中的细节优化,内存处理和耗电情况</li>
</ul>
</li>
<li>
<p>入职3年(如何进阶)</p>
<ul><li>开始涉猎不止于iOS领域中的知识,会去了解相关职位的基础知识,例如前端和后台或者服务器运维,或者项目相关知识,具体往自己的职业规划靠拢</li></ul>
</li>
</ul>
</li>
<li>
<p>框架的学习</p>
<ul>
<li>苹果自带框架</li>
<li>
<p>第三方框架</p>
<ul>
<li>AFNetworking</li>
<li>SDAutoLayout</li>
<li>YYKit</li>
<li>SDWebImage</li>
<li>MJRefresh</li>
<li>MJExtension</li>
<li>Bugly</li>
<li>Qiniu</li>
<li>Masonry</li>
<li>TZImagePickerController</li>
<li>Hyphenate_CN</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基础UI控件</p>
<ul>
<li>UILabel  标题栏</li>
<li>UIButton  按钮</li>
<li>UIImageView  图片视图</li>
<li>UITextField  文本输入框</li>
<li>UITextView  文本展示视图</li>
<li>UIProgressView  进度条</li>
<li>UISlider  滑动开关</li>
<li>UIGesture 手势</li>
<li>UIActivityIndicator  菊花控件</li>
<li>UIAlertView(iOS8废除) 警告框</li>
<li>UIActionSheet(iOS8废除) 操作表单</li>
<li>UIAlertController(iOS8出现) 警告视图控制器</li>
<li>UIScrollView 滚动视图</li>
<li>UIPageControl 页面控制器</li>
<li>UISearchBar 搜索框</li>
<li>UITableView 表视图</li>
<li>UICollectionView集合视图</li>
<li>UIWebView网页浏览器</li>
<li>UISwitch开关</li>
<li>UISegmentControl选择按钮</li>
<li>UIPickerView选择器</li>
<li>UIDatePicker日期选择器</li>
<li>UIToolbar工具栏</li>
<li>UINavigationBar通知栏</li>
<li>UINavigationController通知视图控制器</li>
<li>UITabbarController选择视图控制器</li>
<li>UIImagePickerController相册</li>
<li>UIImage图片</li>
</ul>
</li>
<li>
<p>Xcode的使用</p>
<ul>
<li>基础操作 状态栏</li>
<li>偏好设置</li>
<li>Xcode Source Control 源代码管理器</li>
<li>Xcode workSpace工作组</li>
<li>Xcode Scheme 计划</li>
<li>Xcode AutoLayout 约束</li>
<li>Xcode CoreData数据库</li>
<li>LLDB 断点调试</li>
<li>StoryBoard</li>
<li>界面预览</li>
<li>界面适配</li>
<li>内存监测</li>
<li>全局断点</li>
<li>全局搜索替换</li>
</ul>
</li>
<li>
<p>数据存储</p>
<ul>
<li>plist</li>
<li>NSKeyedArchiver</li>
<li>SQLite</li>
<li>FMDB</li>
<li>CoreData</li>
<li>NSUserDefault</li>
<li>沙盒存储</li>
<li>NSDictionary归档</li>
</ul>
</li>
<li>
<p>App生命周期</p>
<ul>
<li>应用生命周期</li>
<li>
<p>控制器生命周期</p>
<ul>
<li>alloc</li>
<li>init</li>
<li>创建View</li>
<li>ViewDidLoad</li>
<li>ViewWillAppear</li>
<li>ViewDidAppear</li>
<li>
<p>ViewWillDisappear</p>
<ul><li>视图将要消失 (做一些视图将要消失时的UI的处理)</li></ul>
</li>
<li>
<p>ViewDidDisappear</p>
<ul>
<li>视图已经消失 (做一些视图消失之后数据的处理)</li>
<li>viewDidDisappear销毁定时器</li>
</ul>
</li>
<li>dealloc</li>
<li>didReceiveMemoryWarning</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开发者账号&amp;上架流程</p>
<ul>
<li>
<p>文章推荐:</p>
<ul>
<li><a href=""https://www.jianshu.com/p/6601a241da8e"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/660...</a></li>
<li><a href=""https://www.jianshu.com/p/7c98651d3532"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/7c9...</a></li>
<li><a href=""https://www.jianshu.com/p/9b994a019ee6"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/9b9...</a></li>
</ul>
</li>
<li>个人</li>
<li>公司</li>
<li>企业</li>
</ul>
</li>
<li>
<p>常用知识</p>
<ul>
<li>通信</li>
<li>NS系列</li>
<li>宏定义</li>
<li>视图层次</li>
<li>切换视图</li>
<li>深浅拷贝</li>
<li>对象序列化</li>
<li>写入文件</li>
<li>获取沙盒路径</li>
<li>翻转视图</li>
<li>延伸视图</li>
<li>九大基本数据类型</li>
<li>九宫格</li>
<li>坐标比较</li>
<li>UIColor 、CIColor和CGColor 之间的关系</li>
<li>画图</li>
<li>静态变量</li>
<li>tag值</li>
<li>延时执行方法</li>
<li>界面旋转+状态栏隐藏</li>
<li>plist文件</li>
<li>KVC/KVO</li>
<li>谓词NSPredicate</li>
<li>帧动画</li>
<li>AutoLayout</li>
<li>isKindOfClass 与 isMemberOfClass</li>
<li>Return/Break/Continue</li>
<li>Core Animation</li>
<li>CALayer</li>
<li>Quartz2D</li>
<li>真机调试</li>
<li>静态库</li>
<li>内存管理</li>
<li>iPad与iPhone的区别</li>
<li>响应链</li>
<li>异常捕捉</li>
<li>国际化</li>
<li>代码模块化</li>
<li>类别/扩展</li>
</ul>
</li>
</ul>
</li></ul>
<hr>
<h2>中级知识点</h2>
<ul>
<li>设计模式</li>
<li>UIScrollView/UITableView/UICollectionView 的嵌套</li>
<li>动态行高</li>
<li>通知/代理/block</li>
<li>程序启动原理</li>
<li>触摸事件/手势</li>
<li>图文混编</li>
<li>Runtime</li>
<li>NSRunLoop</li>
<li>GCD</li>
<li>ReactiveCocoa开发</li>
<li>3DTouch</li>
<li>界面渲染</li>
<li>Charles花瓶抓包</li>
<li>区分模拟器/真机项目</li>
<li>
<p>常用知识</p>
<ul>
<li>单例模式</li>
<li>多线程</li>
<li>网络请求</li>
<li>定位</li>
<li>源代码管理Git</li>
<li>真机调试</li>
<li>苹果内购/广告</li>
<li>推送/远程推送</li>
<li>音频/视频/二维码</li>
<li>Block</li>
<li>蓝牙/传感器</li>
<li>物理仿真器UIDynamic</li>
<li>通讯录获取</li>
</ul>
</li>
</ul>
<hr>
<h2>iOS高级知识点</h2>
<ul><li>
<p>iOS高级知识点</p>
<ul>
<li>Socket</li>
<li>XMPP</li>
<li>
<p>加密</p>
<ul>
<li>MD5详解</li>
<li>Base64加密解密</li>
<li>RSA非对称加密</li>
<li>AES对称加密</li>
</ul>
</li>
<li>
<p>音频</p>
<ul>
<li>基础</li>
<li>Core Audio</li>
<li>Audio Toolbox</li>
<li>OpenAL</li>
<li>AVFoundation</li>
<li>Speex语音聊天</li>
<li>AudioQueue/AudioSession</li>
<li>Speex简介</li>
</ul>
</li>
<li>
<p>视频</p>
<ul>
<li>AAC视频.H264推流</li>
<li>P2P传输</li>
</ul>
</li>
<li>
<p>直播</p>
<ul>
<li>直播的技术分析与实现</li>
<li>RTMP协议</li>
<li>RTMP直播应用与延时分析</li>
<li>如果做一款inke版的App</li>
<li>推流发布和播放RTMP</li>
<li>FFmpeg</li>
<li>基于FFmpeg的推流器</li>
<li>HLS流媒体传输协议(HTTP Live Streaming)</li>
<li>FFmpeg</li>
<li>ijkPlayer</li>
</ul>
</li>
<li>
<p>算法</p>
<ul>
<li>简介</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>二分查找</li>
<li>希尔排序</li>
<li>动态规划</li>
<li>堆排序</li>
</ul>
</li>
</ul>
</li></ul>
<hr>
<h2>官方Kit</h2>
<ul>
<li>ARKit.</li>
<li>SiriKit</li>
<li>HealthKit</li>
<li>HomeKit</li>
<li>SearchKit</li>
<li>IOKit</li>
<li>PDFKit</li>
<li>CloudKit</li>
<li>GameplayKit</li>
<li>SpriteKit</li>
<li>SceneKit</li>
<li>MusicKit</li>
<li>ResearchKit</li>
<li>MapKit</li>
<li>StoreKit</li>
<li>AVKit</li>
</ul>
<hr>
<h2>结束语</h2>
<p>如果您对这篇文章有什么意见或者建议,请评论与我讨论.<br>如果您觉得还不错的话~可以点个喜欢鼓励我哦.<br>如果您想和我一起学习,请毫不吝啬的私信我吧~<br>介个是我的<a href=""https://dreamerwinston.github.io/blog/"" rel=""nofollow noreferrer"">个人博客</a>,欢迎参观哦~</p>

                ", iOS开发学习路线,1531977880,372,1,442,1,1,https://segmentfault.com/a/1190000014517534
32,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014435116"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片来自网络"" title=""图片来自网络""></span></p>
<blockquote>最近公司的一个小项目尝试使用 .net core作为服务端进行开发，并顺利上线运行了一段时间，整体效果还是比较满意的。这里记录下整体开发过程，用于备忘和分享</blockquote>
<h2>背景</h2>
<p>项目需求其实很简单，类似于一个简单的审批+简单的任务管理系统，但需要同时有PC端和APP端。</p>
<p>由于项目规模不大，时间也比较宽裕，组内商量下来干脆全采用新技术来踩踩坑。这么一提，大家积极性比较高，既完成了任务同时也能学到新的知识。</p>
<p>前后端大家做了一个分工，前端讨论下来采用React+Ant Design（不是我所关注的），后端我们决定下来用 .net core开发并部署在docker下，这对我们来说还是有一定挑战的，一来是没底，毕竟周边没有一个成熟的项目使用，二来我们也不是很了解。</p>
<p>但经过调研发现，还是有很多成熟案例的，所以最终拍板下来就这样做了。</p>
<p>但从后面的开发经历来看，踩的坑真的不少。</p>
<h2>项目架构讨论</h2>
<p>这里只说后端部分，我们在讨论后端架构的同时，前端小伙伴已经着手开始搭建框架和设计原型了。</p>
<p>在架构方面其实大家基本观点一致的，虽然项目小，但五脏俱全，前端不仅有PC，还有APP。</p>
<p>对后端来说，首先，项目外网是可以访问的，得需要一个网关；用于提供功能需求的基础服务；用于异构解耦一些数据，得需要一个MQ（后来通过Redis和Job给替代了）;用于处理一些定时任务的Job。</p>
<p>在数据库选型方面基本就是Mysql+Redis了。</p>
<p>由于用户只给了我们两台服务器（配置也一般般），我们一直在纠结虚几个容器出来，达到资源利用最大化。</p>
<p>下图是我们这个项目的整体拆分，我主要负责的是服务和网关这块（后端部分）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014435117"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图1"" title=""图1""></span></p>
<h2>相关文章</h2>
<p>项目虽然结束了，期间也一直比较忙，项目上线后一直想找个时间把这次项目经历记录下来，一来是为了巩固和积累，二来也是锻炼下自己的写作总结能力。</p>
<p>文章陆陆续续在我的博客发布，相关链接如下：</p>
<ol>
<li><a href=""http://www.bug2048.com/netcore20180314/"" rel=""nofollow noreferrer"">docker + .net core开发环境搭建</a></li>
<li><a href=""http://www.bug2048.com/netcore20180321/"" rel=""nofollow noreferrer"">基于 .net core Restful API+Swagger搭建</a></li>
<li><a href=""https://www.bug2048.com/netcore20180321-2/"" rel=""nofollow noreferrer"">.net core下配置、数据库访问等操作实现</a></li>
<li><a href=""https://www.bug2048.com/netcore20180322/"" rel=""nofollow noreferrer"">.net core下对于Excel的一些操作及使用</a></li>
<li><a href=""https://www.bug2048.com/netcore20180325/"" rel=""nofollow noreferrer"">.net core下对于附件上传下载的实现</a></li>
<li><a href=""https://www.bug2048.com/netcore20180327/"" rel=""nofollow noreferrer"">.net core下访问控制层的实现</a></li>
<li><a href=""https://www.bug2048.com/netcore20180328/"" rel=""nofollow noreferrer"">.net core下验证码及二维码登录的实现</a></li>
<li><a href=""https://www.bug2048.com/netcore20180402/"" rel=""nofollow noreferrer"">.net core下定时任务的实现</a></li>
</ol>
<h2>开发环境</h2>
<p>项目的开发环境如下：</p>
<ul>
<li>操作系统： Win10（docker安装方便）</li>
<li>开发IDE：Visual Studio 2017</li>
<li>其他：Docker for Windows</li>
</ul>
<h2>总结</h2>
<p>最后，也希望大家有一颗学习和总结的心，期待更加完美的自己。</p>
<p>另外，需要源码的可关注我的微信公众号<code>Bug生活2048</code> 回复 <code>NetCore</code>即可获取</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014435118"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>

                ", .net core项目实战汇总,1531977882,198,1,995,1,1,https://segmentfault.com/a/1190000014435111
33,1,0,9,"
                    
<p>找工作的时候最痛苦的时候，莫过于看到心仪的公司在招人，简历投给hr，然而hr看了一眼然后没有下文，静静的等候STAR法则和不匹配。这种情况对于我这种没有大公司背景的人来说尤其容易发生。</p>
<p>那么怎么避免这种情况呢？努力做事，丰富简历是一个方法，然而更好的方法，就是不投简历，等他们来找你。</p>
<p>想要让他们来找你，需要解决两个问题，一个是让他们知道你的存在，另一个是让他们想要来找你。这篇文章就先解决第一个问题，这时候就需要我们懂点运营知识，打造自己的个人品牌了。</p>
<h4>个人品牌的好处</h4>
<p>有个有影响力的个人品牌的好处除了容易有面试机会，还可以给面试官更多机会去了解你，如果有优秀的文章或是项目，也会适当的加分。还可以认识一些优秀的朋友，多点交流的机会</p>
<p>打造个人品牌，我们可以有下面几个方法</p>
<ol>
<li>打造产品</li>
<li>github展现项目</li>
<li>搭建个人博客</li>
<li>在技术社区活跃</li>
<li>微信公众号</li>
</ol>
<h4>产品</h4>
<p>提起qq邮箱我们想起张小龙，提起wps我们想起求伯君，做为程序员，有个自己负责开发的，广为人知的产品，就是最好的背书。</p>
<p>虽然现在的时代越来越难发生一个程序员做好一个产品的情况了，但是作为一个程序员，如果能参与甚至主导一个小有名气的产品的开发，那对提升影响力很有帮助的。</p>
<h4>github项目</h4>
<p>现在的hr都懂得招人时github上star超过50的优先了，不少程序员也有着开源改变世界的梦想，都想在github上放些项目证明自己。</p>
<p>那么项目怎么来呢？可以是你学了新技术，把之前的老项目用新技术重新写一遍，并找出他们的不同，比如我学react时就把之前做的用vue写的项目重新用react写了一遍。也可以是做些仿站，vue版网易云音乐，滴滴打车什么的，可以让人了解到你是有独立做完整项目的能力的，也可以是一些工具。也可以是解决了工作中碰到的问题的工具。</p>
<h4>个人博客</h4>
<p>个人博客就是自己的独立天地，可以在上面放自己的作品，放自己的奇思妙想，自己的简历等等等。</p>
<p>搭建个人博客不是一件很难的事情，可以利用hexo工具来在github的github page上搭建技术博客，文章很多，我就不重复写了，可以看看<a href=""http://www.lovebxm.com/2017/05/30/buildBlog/"" rel=""nofollow noreferrer"">这篇文章</a>,博客可以使用主题，比较主流的就有next，<a href=""http://hpoenixf.com"" rel=""nofollow noreferrer"">我的技术博客</a>就是这样做的。</p>
<p>利用github page搭建的个人博客地址是类似于hpoenixf.github.io，总给人一种冗余的感觉。我们可以自己买一个域名，然后把这个地址重定向过去，价钱也不贵,我的网名对应的域名，最贵的.com也就五六十一年，便宜的几块钱一年也有。</p>
<p>github page有一点不好的地方是屏蔽了百度的爬虫，导致很少有来自百度的流量过来，解决方法有不少，我使用的方法是在自己的vps上重新部署一套博客，在dns控制台上配置，指定百度的爬虫去爬vps的地址。</p>
<h4>技术社区</h4>
<p>比较推荐的技术社区有掘金和segmentfault以及博客园等，个人博客上如果有写的不错的文章，可以同步分享过去。英文水平比较好的小伙伴还可以混混stackoverflow，帮人解答问题。</p>
<p>由于精力有限，目前我就只在掘金和segmentfault上分享文章，如果还有合适的技术社区，希望可以告知一下。</p>
<h4>微信公众号</h4>
<p>我觉得开微信公众号的好处有下面几个，一个是方便在微信上分享传播，另一个公众号可以主动去推送新的文章，不用让用户主动去浏览博客，可以有效增加文章的阅读量，从而增加影响。另外是粉丝多了，或许可以打点小广告赚点零花钱？</p>
<h4>最后</h4>
<p>以上几个方法其实都是互相联系的，不同的只是渠道，相同的核心还是要有自己的输出，可以是项目，也可以是心得文章。建议平衡好构建影响力与技术积累，毕竟获得面试机会只是一个开始，最终还是要有技术实力。</p>
<p>有人可能觉得运营自己，打造品牌可能会分心，影响技术方面的学习成长。我觉得还是要注意精力的分配，做好平衡。以我自己为例，在分享自己的文章后，发现有不少人观看，喜欢，也给我带来了一些面试机会，这也促进了我去学习积累，毕竟想要写文章也是要有自己的干货的。</p>
<p>本文章为<a href=""http://hpoenixf.com/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97-%E7%9B%AE%E5%BD%95.html"" rel=""nofollow noreferrer"">前端进阶系列</a>的一部分,<br>欢迎关注和<a href=""https://github.com/hpoenixf/hpoenixf.github.io"" rel=""nofollow noreferrer"">star</a>本博客或是关注我的<a href=""https://github.com/hpoenixf"" rel=""nofollow noreferrer"">github</a></p>

                ", 别再投简历了，让面试官来找你,1531977883,537,1,727,1,1,https://segmentfault.com/a/1190000014423864
34,1,0,9,"
                    
<p>随着公众对网络安全的日益关注，各种网络安全防护手段层出不穷。HTTPS Everywhere作为提升HTTPS安全性的有效手段，日前安全性与实用性再次得到了加强。</p>
<p>HTTPS虽然可以有效提升用户浏览网页的安全性，可是仍有问题存在会成为黑客窃取数据的漏洞。</p>
<p>针对现在HTTPS存在的部分缺陷，我们可以用浏览器插件进行补足，比如Chrome商店的HTTPS Everywhere ，能有效降低用户上网风险，但由于HTTPS Everywhere的扩展和规则是一体的，导致用户必须频繁更新到最新版的插件，影响用户的使用。</p>
<p>为了解决这个问题，EFF（电子前哨基金会）将会将规则集与扩展剥离，从而实现可持续的更新。扩展安装后，它会经常性地检查列表，并在可用时下载最新的列表。</p>
<p>通过这个方法可以将HTTPS的安全性再次提升，看到这里有的读者就要问了，HTTPS是什么，它为什么可以保护我们的数据安全？</p>
<h2><strong>HTTPS 是什么</strong></h2>
<p>HTTPS（Hypertext Transfer Protocol Secure ）是一种以计算机网络安全通信为目的的传输协议。在HTTP下加入了SSL层，从而具有了保护交换数据隐私和完整性和提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP 。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014408860"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""△ HTTP、HTTPS 差异"" title=""△ HTTP、HTTPS 差异""></span></p>
<h2><strong>HTTPS 访问过程</strong></h2>
<p>HTTPS在进行数据传输之前会与网站服务器和Web浏览器进行一次握手，在握手时确定双方的加密密码信息。</p>
<p>具体过程如下：</p>
<p>1.Web 浏览器将支持的加密信息发送给网站服务器；</p>
<p>2. 网站服务器会选择出一套加密算法和哈希算法，将验证身份的信息以证书（证书发布CA机构、证书有效期、公钥、证书所有者、签名等）的形式发送给Web浏览器；</p>
<p>3. 当 Web 浏览器收到证书之后首先需要验证证书的合法性，如果证书受到浏览器信任则在浏览器地址栏会有标志显示，否则就会显示不受信的标识。当证书受信之后，Web 浏览器会随机生成一串密码，并使用证书中的公钥加密。之后就是使用约定好的哈希算法握手消息，并生成随机数对消息进行加密，再将之前生成的信息发送给网站；</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014408861"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>4. 当网站服务器接收到浏览器发送过来的数据后，会使用网站本身的私钥将信息解密确定密码，然后通过密码解密Web浏览器发送过来的握手信息，并验证哈希是否与Web浏览器一致。然后服务器会使用密码加密新的握手信息，发送给浏览器；</p>
<p>5. 最后浏览器解密并计算经过哈希算法加密的握手消息，如果与服务发送过来的哈希一致，则此握手过程结束后，服务器与浏览器会使用之前浏览器生成的随机密码和对称加密算法进行加密交换数据。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014408862"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""△ HTTPS 握手过程"" title=""△ HTTPS 握手过程""></span></p>
<h2><strong>HTTPS 加密算法</strong></h2>
<p>为了保护数据的安全，HTTPS 运用了诸多加密算法：</p>
<p>1、对称加密：有流式、分组两种，加密和解密都是使用的同一个密钥。</p>
<p>例如：DES、AES-GCM、ChaCha20-Poly1305 等。</p>
<p>2、非对称加密：加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>
<p>例如：RSA、DSA、ECDSA、 DH、ECDHE 等。</p>
<p>3、哈希算法：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p>
<p>例如：MD5、SHA-1、SHA-2、SHA-256 等。</p>
<p>4、数字签名：签名就是在信息的后面再加上一段内容（信息经过 hash 后的值），可以证明信息没有被修改过。hash 值一般都会加密后（也就是签名）再和信息一起发送，以保证这个 hash 值不被修改。</p>
<h2><strong>HTTPS 网络访问安全性提升</strong></h2>
<p>除了EFF、Google等组织在让HTTPS更安全之外，又拍云也一直致力于提升HTTPS的安全性。</p>
<p>时至今日，又拍云HTTPS已经支持多种功能，感兴趣的朋友可以了解一下哦！</p>
<p><strong>HTTP/2</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/227/%25E4%25B8%2580%25E6%2596%2587%25E8%25AF%25BB%25E6%2587%2582%2520HTTP%252F2%2520%25E7%2589%25B9%25E6%2580%25A7.html"" rel=""nofollow noreferrer"">一文读懂 HTTP/2 特性</a></p>
<p><strong>TLS 1.3</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/276/%25E5%258F%2588%25E6%258B%258D%25E4%25BA%2591%2520CDN%2520%25E6%25AD%25A3%25E5%25BC%258F%25E6%2594%25AF%25E6%258C%2581%2520TLS%25201.3%2520%25E5%258A%25A0%25E5%25AF%2586%25E5%258D%258F%25E8%25AE%25AE%25EF%25BC%258C%25E4%25B8%2580%25E9%2594%25AE%25E5%25BC%2580%25E5%2590%25AF%25E6%259E%2581%25E9%2580%259F%2520HTTPS%2520%25E4%25BD%2593%25E9%25AA%258C.html"" rel=""nofollow noreferrer"">又拍云 CDN 正式支持 TLS 1.3 加密协议，一键开启极速 HTTPS 体验</a></p>
<p><strong>HSTS</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/242/%25E4%25BB%258E%2520HTTP%2520%25E5%2588%25B0%2520HTTPS%2520%25E5%2586%258D%25E5%2588%25B0%2520HSTS.html"" rel=""nofollow noreferrer"">从 HTTP 到 HTTPS 再到 HSTS</a></p>
<p><strong>ChaCha20-Poly1305</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/239/%2520%25E8%25AF%25A6%25E8%25A7%25A3%2520HTTPS%2520%25E7%25A7%25BB%25E5%258A%25A8%25E7%25AB%25AF%25E5%25AF%25B9%25E7%25A7%25B0%25E5%258A%25A0%25E5%25AF%2586%25E5%25A5%2597%25E4%25BB%25B6%25E4%25BC%2598%25E5%258C%2596.html"" rel=""nofollow noreferrer"">详解 HTTPS 移动端对称加密套件优化</a></p>
<p><strong>TLS Record Size</strong></p>
<p><a href=""https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/258/HTTPS%2520%25E4%25BC%25A0%25E8%25BE%2593%25E4%25BC%2598%25E5%258C%2596%25E8%25AF%25A6%25E8%25A7%25A3%25E4%25B9%258B%25E5%258A%25A8%25E6%2580%2581%2520TLS%2520Record%2520Size.html"" rel=""nofollow noreferrer"">HTTPS 传输优化详解之动态 TLS Record Size</a></p>

                ", 从让 HTTPS 更安全出发，聊聊 HTTPS,1531977885,334,1,425,1,1,https://segmentfault.com/a/1190000014408855
35,1,0,9,"
                    
<h2>前言</h2>
<p>这里筑梦师,是一名正在努力学习的iOS开发工程师,目前致力于全栈方向的学习,希望可以和大家一起交流技术,共同进步,用简书记录下自己的学习历程.</p>
<blockquote>
<a href=""https://www.jianshu.com/p/19265c17f99b"" rel=""nofollow noreferrer"">个人学习方法分享</a><br><a href=""https://www.jianshu.com/p/c7b33e4ccc52"" rel=""nofollow noreferrer"">2018年计算机系书单分享</a>
</blockquote>
<pre><code>本文阅读建议
1.一定要辩证的看待本文.
2.本文不允许转载,因为...因为我要提供网盘给大家..
3.本书单所涉及书籍如有需要,可以评论私信我,**无偿提供网盘**,仅供学习交流使用,如有侵权请与我联系.
4.因为本人才学会Markdown语法,故将17年书单重新更新排版.
5.如果您有什么书籍想要推荐,请不吝私信给我,我将更新本文.
6.文中提到的为重点书籍,并不包含网盘中所有书籍.
7.觉得哪里不妥请在评论留下建议~
8.觉得还行的话就点个小心心鼓励下我吧~</code></pre>
<hr>
<pre><code>目录
1.读书方法
2.基础书单
3.清华大学计算机系书单
4.C语言
5.C++
6.Java
7.Python
8.GO
9.计算机网络
10.算法
11.数据结构
12.程序设计
13.Unix/Linux
14.UML和面向对象
15.计算机组成/体系结构
16.分布式/架构
17.大数据/HADOOP
18.数学系列
19.Git
20.安卓
21.iOS
22.其他
23.CS系列书单(很详细)</code></pre>
<p>本文最后有:<strong>授人鱼不如授人以渔(找书方法)</strong></p>
<hr>
<h2>个人想法</h2>
<p>我想成为一名优秀的程序员，我虽然不是计算机系的学生，但我不能落后，我要努力成为优秀程序员的一员。我觉得每个人都有自己的想法和规划，一个理智的人会去分辨旁人的风言风语，把善意的话听进去，使自己成长。同时不受那些自己不上进也看不惯别人学习的人。时刻明确自己的目标，努力做好自己，在程序员这条路上，要谦虚要谨慎。话不多说。把我这几天准备的书单推荐给大家.</p>
<hr>
<h2>读书方法</h2>
<p>读书方法仅供参考,如果你有好的建议,请不吝评论交流哦.</p>
<hr>
<h3>循序渐进</h3>
<p>大家都知道,书籍方面,在各个分类中都有那么几本出名的书籍,但是学习成本和时间成本却很高,需要长时间去阅读吃透.</p>
<p>又或者说,我们总说数据结构要看,算法导论也要看,但往往看了50多页我们就放弃了.</p>
<p>如果你没有养成看书的习惯,以及自己的看书方法,建议不要一开始就阅读高难度的书籍,会直接破坏你对看书的兴趣.从而失去从书籍中获取知识的途径.</p>
<p>这么说吧,我之前看书也是不得其法,3个月看不了多少页,而且没有什么印象,喜欢咬文嚼字,后来发现,计算机系的书大多是理解为主,多次阅读进行深度体会,反而会更加得心应手.</p>
<p>而相对程序员思想这一类的书,则更加需要体会,拥有自己的理解.</p>
<hr>
<h3>思维拓展</h3>
<p>在看书进行学习的时候,一定要边看边实践,实践的同时,一定要发散性思维,去思考相关的知识.</p>
<p>如果你是刚步入计算机应用,或者编程语言类书籍的学习,可能不会考虑到业务逻辑,以及架构思想等,因为知识面还不够宽广.就多想一些基础问题.不论这个问题多么的奇怪,一定要去寻找答案,并解决,这样会更加的印象深刻.</p>
<p>如果你想在学习时拥有成熟的思想,我推荐你从以下几个方面思考每一个书中遇到的知识点(针对编程语言类书籍)</p>
<blockquote>工作层面:(可以直接百度 你所学的知识加上'开发'或者'工作中'等关键词进行学习)<p>业务逻辑实现:(生搬硬套不可取,而是如何灵活运用实现成熟的逻辑)</p>
<p>自我应用:(学习新的知识点以后,你可以自己思考应用在什么地方)</p>
</blockquote>
<p>当你使用百度去搜索知识时,别人可能会提到一些你不懂的知识点,不用很深入的再去百度一下.拓宽自己的知识面,使得所有的知识都不再是死的,而是灵活组合的,程序当中都是各自联系,成为一个体系的.都是有联系的.</p>
<hr>
<h3>三维笔记</h3>
<p>什么是三维笔记呢,也就是我个人的一个学习方法.</p>
<p>自学读书笔记+学习日志&amp;视频学习+成型的输出笔记.</p>
<blockquote>自学读书笔记:就是记录书中的知识点,用自己的理解整理知识点,而并非搬运书中的目录结构.并会记录每一个自己会思考到的问题,以及知识拓展.<p>学习日志&amp;视频学习:这里并不是强制让你搜罗视频学习,而是书是出版的,有些知识可能会过时,所以一定要结合实时知识,辩证的去理解每一个知识.学习日志是为了记录自己每天干了什么,不要虚度光阴,使自己可控.</p>
<p>成型的输出笔记:结合前两个笔记以后,将自己的笔记整理成可以写成文章的笔记,输出倒逼输入学习法,在输出文章的同时,自己会自然而然想要完善文章,达到面面俱到,进行学习补充.</p>
</blockquote>
<hr>
<h2>基础书单</h2>
<pre><code>1.算法导论
2.计算机算法基础
3.编译原理
4.操作系统-精髓与设计原理
5.数据库系统原理
6.离散数学及其应用
7.计算机网络
8.计算机组成原理
9.Essential C++（注释版）
10.java程序设计教材
11.数据结构
12.线性代数
13.高等数学
14.大学物理学
15.概率论
16.数理统计
17.模拟电子技术
18.电路原理
19.Linux服务器操作系统
20.网络设备与网络技术</code></pre>
<hr>
<h2>清华大学计算机系12门课程</h2>
<pre><code>1.数据结构 严蔚敏
2.编译原理 张素琴
3.内容中心网络体系架构
4.计算机系统结构
5.图论与代数结构
6.计算机组成与结构
7.80x86汇编语言程序设计
8.C语言程序设计
9.多媒体技术基础
10.数据库系统概论
11.C++语言程序设计
12.计算机局域网</code></pre>
<h2>知乎书单 by ZhiSheng</h2>
<p><a href=""https://github.com/zhisheng17/zhisheng/blob/master/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90%E5%8D%95.md"" rel=""nofollow noreferrer""><strong>这份书单</strong></a>可以说是很详细的涉及到了各个语言的好书，是我在某个问题回答里看到的。</p>
<blockquote>
<p>C语言</p>
<blockquote>《C程序设计语言》<br>《C语言参考手册》</blockquote>
<p>C++</p>
<blockquote>《Essential C++》<br>《C++ Primer》<br>《深度探索C++对象模型》<br>《C++程序设计语言》<br>《Think in C++ C++编程思想》</blockquote>
<p>Java</p>
<blockquote>《Java语言规范》<br>《Java并发编程实战》<br>《Java核心技术 卷1》<br>《Java核心技术 卷2》<br>《 Java编程思想》<br>《Effective Java》<br>《深入分析Java Web技术内幕》修订版<br>《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版</blockquote>
<p>Python</p>
<blockquote>《Python学习手册》<br>《Python核心编程》<br>《Python网络数据采集》<br>《Flask Web开发：基于Python的Web应用开》发实战</blockquote>
<p>GO</p>
<blockquote>《GO并发编程实践》</blockquote>
<p>Network</p>
<blockquote>《计算机网络自顶向下方法》<br>《计算机网络》<br>《计算机网络系统方法》<br>《TCP/IP详解卷1》<br>《TCP/IP详解卷2》<br>《TCP/IP详解卷3》</blockquote>
<p>算法</p>
<blockquote>《算法导论》<br>《算法》</blockquote>
<p>数据结构</p>
<blockquote>《数据结构与算法分析C语言描述》</blockquote>
<p>程序设计</p>
<blockquote>《程序设计实践》</blockquote>
<p>Unix/Linux</p>
<blockquote>《The Design Of The Unix Operating System》<br>《 Unix环境高级编程》<br>《Unix网络编程卷1》<br>《Unix网络编程卷2》<br>《Unix超级工具》<br>《Unix编程环境》<br>《Unix编程艺术》<br>《鸟哥私房菜——基础知识篇》<br>《鸟哥私房菜——服务器篇》<br>《Linux内核设计与实现》<br>《Linux系统编程》<br>《深入理解Linux内核》<br>《 Linux设备驱动》</blockquote>
<p>UML和面向对象</p>
<blockquote>《面向对象分析与设计》<br>《UML面向对象建模与设计》<br>《UML用户指南》<br>《设计模式》</blockquote>
<p>计算机组成/体系结构</p>
<blockquote>《深入理解计算机系统》<br>《计算机体系结构量化研究方法》<br>《计算机组成与设计：硬件/软件接口》<br>《计算机组成与嵌入式系统》<br>《MIPS体系结构透视》</blockquote>
<p>分布式/架构</p>
<blockquote>《分布式系统概念与设计》<br>《分布式系统原理与范型》<br>《大型网站技术架构：核心原理与案例分析》<br>《大型网站系统与Java中间件实践》</blockquote>
<p>大数据/HADOOP</p>
<blockquote>《Hadoop权威指南（中文第2版）》</blockquote>
<p>数学系列</p>
<blockquote>《数学分析新讲》<br>《数学之美》</blockquote>
<p>Git</p>
<blockquote>《Git 权威指南》</blockquote>
<p>安卓</p>
<blockquote>《第一行代码 android》<br>《Android 开发艺术探索》<br>《安卓群英传》</blockquote>
<p>iOS</p>
<blockquote>《Objective-C编程之道之IOS设计模式解析》<br>《Objective-C基础教程（第2版）》</blockquote>
<p>其他</p>
<blockquote>《人月神话》<br>《编译原理》<br>《事务处理》<br>《汇编语言程序设计》<br>《程序员的自我修养—链接、装载与库》<br>《代码揭秘----从c/c++角度探索计算机系统》<br>《编程之美》<br>《剑指offer》</blockquote>
</blockquote>
<hr>
<h2>知乎书单 By 箴光司</h2>
<p>这份书单主要是国外CMU大学课程表，是一份国外大学如何进行CS课程学习目录。从不同的学习方法以及角度，进行进一步的学习。</p>
<h3>CMU的课程计算机核心课程</h3>
<p><strong>（合计 17学分， 学分已经转化为成国内的算法，略有出入）如下：</strong></p>
<pre><code>15-128 Freshman Immigration Course （介绍类，时间很短）

15-122 命令式语言编程Principles of Imperative Computation （2.5学分，没有编程基础的同学）

15-150 函数式语言编程Principles of Functional Programming（2.5学分）

15-210 并行/串行数据结构 Parallel and Sequential Data Structures and Algorithms （3学分）

15-213 计算机系统基础Introduction to Computer Systems （3学分）

15-251 计算机理论基础Great Theoretical Ideas in Computer Science （3学分）

15-451 算法分析与设计 Algorithm Design and Analysis （3学分）</code></pre>
<h3>B: 一门技术交流课程One Communcations course:</h3>
<pre><code>15-221 计算机科学家技术交流Technical Communication for Computer Scientists（2学分，相当于我们的英文写作课程，也关注口头表达）</code></pre>
<h3>C: 从下面选择一门算法课程</h3>
<pre><code>15-354 计算离散数学Computational Discrete Mathematics （3学分）

15-355 现代计算机代数Modern Computer Algebra （2学分）

15-453 形式化语言与自动机Formal Languages, Automata, and Computability （2学分）

21-301 组合数学Combinatorics （2学分）

21-484 图理论Graph Theory （2学分）</code></pre>
<h3>D： 从下面选择一门应用类课程</h3>
<pre><code>05-391 人机交互 Designing Human Centered Software （3学分）

05-431 用户界面Software Structures for User Interfaces （1.5学分）

10-601 机器学习 Machine Learning （3学分）

11-411 自然语言处理 Natural Language Processing （3学分）

15-313 软件工程 Foundations of Software Engineering （3学分）

15-322 计算机音乐 Introduction to Computer Music （2学分）

15-323 计算机音乐和信息处理 Computer Music Systems and Information Processing （2学分）

15-381 人工智能 Artificial Intelligence: Representation and Problem Solving （2学分）

15-384 机器操作Robotic Manipulation （3学分）

15-385 计算机视觉Computer Vision （2学分）

15-415 数据库应用Database Applications （3学分）

15-462 计算机图像Computer Graphics （3学分）</code></pre>
<h3>E：从下面选择一门理论类课程</h3>
<pre><code>15-312 计算机语言基础 Foundations of Programming Languages （3学分）

15-317 构造逻辑 Constructive Logic （2学分）

15-414 计算机自动化验证 Bug Catching: Automated Program Verification and Testing （2学分）

21-300 基本逻辑 Basic Logic （2学分）

80-311 复杂性 Computability and Incompleteness （2学分）</code></pre>
<h3>F：从下面选择一门软件系统类课程</h3>
<pre><code>15-410 操作系统　Operating System Design and Implementation （３学分）

15-411 编译器　Compiler Design （３学分）

15-418 并行体系结构与编程　Parallel Computer Architecture and Programming （３学分）

15-440 分布式系统　Distributed Systems （３学分）

15-441 计算机网络　Computer Networks （３学分）</code></pre>
<hr>
<h2>授人鱼不如授人以渔(找书方法)</h2>
<p>本人连续4天趴在知乎上，等各大网站上进行搜书。可以说我是一时兴起。很多人都说 我搜这么多书，不会看的。我笑笑，对，我可能真的看不完，但我不会不看。这三份书单的书pdf版相关的，不相关的我都找了，同时结合着百度，知乎，豆瓣等各网站找到各个科目相关知名书籍的pdf。抱歉原英文本没有几个，因为我自己英语水平还看不懂外著。</p>
<p>这些书的pdf版可能会涉及到版权问题吧。我三份书单大概找了有16G的pdf书，都找齐了，有需要的可以简信给我，免费传阅。</p>
<p>妙，16G的书包含了（三份书单各个知识点各个语言的好书）。但是，作为一个读者，我只对其中一本书感兴趣，我才不要你的16G，一点用都没，除了装能干吗？说的好！如果你想自己搜，没问题。鱼竿给你。</p>
<hr>
<h3>搜索利器</h3>
<p>首先推荐无私奉献的脚本之家，这个站长呢唯一的要求可能就是，有的书需要你去关注公众号要百度盘密码，免费的。</p>
<p><a href=""http://www.jb51.net/"" rel=""nofollow noreferrer"">脚本之家--搜索框直接搜索</a></p>
<p>第二个就是 会报有危险的网盘网站，虽然我也不知道有什么危险，你们如果知道告诉我，我把这个删了</p>
<p><a href=""http://www.57fx.com/search/"" rel=""nofollow noreferrer"">搜索--点击资源--跳转百度盘</a></p>
<p>第三个就是  不知道在哪里淘的搜索网站 直接下载 用来下原英文本很不错哦</p>
<p><a href=""https://www.jiumodiary.com/"" rel=""nofollow noreferrer"">英文搜索网站</a></p>
<p>第四个就是 很有名的CSDN 资源搜索，我还买了个年会，为了下载舒服点。</p>
<p><a href=""http://download.csdn.net/"" rel=""nofollow noreferrer"">CSDN下载页--右边搜索栏使用就好</a></p>
<p>在这里点名三本书：《自然语言简明教程》《深入理解机器学习 原理及算法》《数据库系统设计实现与管理》这三本书在网上的pdf资源我没有找到，尽管我动用了谷歌什么的，都只能找到加密的。然后。。然后我买了。如果有需要这三本书的话，你就别买了，我给你。</p>
<p>感谢这两位以及各位大牛在网络上提供的答案，使我找到了这些书。</p>
<hr>
<h2>结束语</h2>
<p>如果您对这篇文章有什么意见或者建议,请评论与我讨论.<br>如果您觉得还不错的话~可以点个喜欢鼓励我哦.<br>如果您想和我一起学习,请毫不吝啬的私信我吧~<br>介个是我的<a href=""https://dreamerwinston.github.io/blog/"" rel=""nofollow noreferrer"">个人博客</a>,欢迎参观哦~</p>

                ", 2017计算机系书单推荐(排版更新),1531977887,205,1,176,1,1,https://segmentfault.com/a/1190000014361452
36,1,0,9,"
                    
<p>导读：阅读本文需要有足够的时间，笔者会由浅到深带你一步一步了解一个资深架构师所要掌握的各类知识点，你也可以按照文章中所列的知识体系对比自身，对自己进行查漏补缺，觉得本文对你有帮助的话，可以点赞关注一下。<br>目录：<br>一、基础篇<br>二、进阶篇<br>三、高级篇<br>四、架构篇<br>五、扩展篇<br>六、体系篇<br>七、推荐书籍<br>八、总结</p>
<h1>一、基础篇</h1>
<h2>JVM</h2>
<p>1、JVM内存结构<br>2、堆、栈、方法区、直接内存、堆和栈区别<br>3、Java内存模型<br>4、内存可见性、重排序、顺序一致性、volatile、锁、final<br>5、垃圾回收<br>6、内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定<br>7、JVM参数及调优<br>8、Java对象模型<br>9、oop-klass、对象头<br>10、HotSpot<br>11、即时编译器、编译优化<br>12、类加载机制<br>13、classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）<br>14、虚拟机性能监控与故障处理工具<br>jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler</p>
<h2>编译与反编译</h2>
<p>1、javac 、javap 、jad 、CRF</p>
<h2>Java基础知识</h2>
<p>1、阅读源代码<br>String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet<br>Java中各种变量类型<br>熟悉Java String的使用，熟悉String的各种函数<br>JDK 6和JDK 7中substring的原理及区别、<br>replaceFirst、replaceAll、replace区别、<br>String对“+”的重载、<br>String.valueOf和Integer.toString的区别、<br>字符串的不可变性<br>自动拆装箱<br>Integer的缓存机制<br>熟悉Java中各种关键字<br>transient、instanceof、volatile、synchronized、final、static、const 原理及用法。<br>集合类<br>常用集合类的使用<br>ArrayList和LinkedList和Vector的区别<br>SynchronizedList和Vector的区别<br>HashMap、HashTable、ConcurrentHashMap区别<br>Java 8中stream相关用法<br>apache集合处理工具类的使用<br>不同版本的JDK中HashMap的实现的区别以及原因<br>枚举<br>枚举的用法、枚举与单例、Enum类<br>Java IO&amp;Java NIO，并学会使用<br>bio、nio和aio的区别、三种IO的用法与原理、netty<br>Java反射与javassist<br>反射与工厂模式、 java.lang.reflect.*<br>Java序列化<br>什么是序列化与反序列化、为什么序列化<br>序列化底层原理<br>序列化与单例模式<br>protobuf<br>为什么说序列化并不安全<br>注解<br>元注解、自定义注解、Java中常用注解使用、注解与反射的结合<br>JMS<br>什么是Java消息服务、JMS消息传送模型<br>JMX<br>java.lang.management.<em>、 javax.management.</em><br>泛型<br>泛型与继承<br>类型擦除<br>泛型中K T V E<br>object等的含义、泛型各种用法<br>单元测试<br>junit、mock、mockito、内存数据库（h2）<br>正则表达式<br>java.lang.util.regex.*<br>常用的Java工具库<br>commons.lang, commons.*... guava-libraries netty<br>什么是API&amp;SPI<br>异常<br>异常类型、正确处理异常、自定义异常<br>时间处理<br>时区、时令、Java中时间API<br>编码方式<br>解决乱码问题、常用编码方式<br>语法糖<br>Java中语法糖原理、解语法糖</p>
<h2>Java并发编程</h2>
<p>什么是线程，与进程的区别<br>阅读源代码，并学会使用<br>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors<br>线程池<br>自己设计线程池、submit() 和 execute()<br>线程安全<br>死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系<br>锁<br>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁<br>死锁<br>volatile<br>happens-before、编译器指令重排和CPU指令重<br>synchronized<br>synchronized是如何实现的？<br>synchronized和lock之间关系<br>不使用synchronized如何实现一个线程安全的单例<br>sleep 和 wait<br>wait 和 notify<br>notify 和 notifyAll<br>ThreadLocal<br>写一个死锁的程序<br>写代码来解决生产者消费者问题<br>守护线程<br>守护线程和非守护线程的区别以及用法</p>
<h1>二、 进阶篇</h1>
<h2>Java底层知识</h2>
<p>字节码、class文件格式<br>CPU缓存，L1，L2，L3和伪共享<br>尾递归<br>位运算<br>用位运算实现加、减、乘、除、取余</p>
<h2>设计模式</h2>
<p>了解23种设计模式<br>会使用常用设计模式<br>单例、策略、工厂、适配器、责任链。<br>实现AOP<br>实现IOC<br>不用synchronized和lock，实现线程安全的单例模式<br>nio和reactor设计模式</p>
<h2>网络编程知识</h2>
<p>tcp、udp、http、https等常用协议<br>三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包<br>http/1.0 http/1.1 http/2之前的区别<br>Java RMI，Socket，HttpClient<br>cookie 与 session<br>cookie被禁用，如何实现session<br>用Java写一个简单的静态文件的HTTP服务器<br>实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则”<br>了解nginx和apache服务器的特性并搭建一个对应的服务器<br>用Java实现FTP、SMTP协议<br>进程间通讯的方式<br>什么是CDN？如果实现？<br>什么是DNS？<br>反向代理</p>
<h2>框架知识</h2>
<p>Servlet线程安全问题<br>Servlet中的filter和listener<br>Hibernate的缓存机制<br>Hiberate的懒加载<br>Spring Bean的初始化<br>Spring的AOP原理<br>自己实现Spring的IOC<br>Spring MVC<br>Spring Boot2.0<br>Spring Boot的starter原理，自己实现一个starter<br>Spring Security</p>
<h2>应用服务器</h2>
<p>JBoss<br>tomcat<br>jetty<br>Weblogic<br>工具<br>git &amp; svn<br>maven &amp; gradle</p>
<h1>三、 高级篇</h1>
<h2>新技术</h2>
<p>Java 8<br>lambda表达式、Stream API、<br>Java 9<br>Jigsaw、Jshell、Reactive Streams<br>Java 10<br>局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制<br>Spring 5<br>响应式编程<br>Spring Boot 2.0</p>
<h2>性能优化</h2>
<p>使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</p>
<h2>线上问题分析</h2>
<p>dump获取<br>线程Dump、内存Dump、gc情况<br>dump分析<br>分析死锁、分析内存泄露<br>自己编写各种outofmemory，stackoverflow程序<br>HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow<br>常见问题解决思路<br>内存溢出、线程死锁、类加载冲突<br>使用工具尝试解决以下问题，并写下总结<br>当一个Java程序响应很慢时如何查找问题、<br>当一个Java程序频繁FullGC时如何解决问题、<br>如何查看垃圾回收日志、<br>当一个Java应用发生OutOfMemory时该如何解决、<br>如何判断是否出现死锁、<br>如何判断是否存在内存泄露</p>
<h2>编译原理知识</h2>
<p>编译与反编译<br>Java代码的编译与反编译<br>Java的反编译工具<br>词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化</p>
<h2>操作系统知识</h2>
<p>Linux的常用命令<br>进程同步<br>缓冲区溢出<br>分段和分页<br>虚拟内存与主存</p>
<h2>数据库知识</h2>
<p>MySql 执行引擎<br>MySQL 执行计划<br>如何查看执行计划，如何根据执行计划进行SQL优化<br>SQL优化<br>事务<br>事务的隔离级别、事务能不能实现锁的功能<br>数据库锁<br>行锁、表锁、使用数据库锁实现乐观锁、<br>数据库主备搭建<br>binlog<br>内存数据库<br>h2<br>常用的nosql数据库<br>redis、memcached<br>分别使用数据库锁、NoSql实现分布式锁<br>性能调优</p>
<h2>数据结构与算法知识</h2>
<p>简单的数据结构<br>栈、队列、链表、数组、哈希表、<br>树<br>二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树<br>排序算法<br>各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列、贪心算法、KMP算法、hash算法、海量数据处理</p>
<h2>大数据知识</h2>
<p>Zookeeper<br>基本概念、常见用法<br>Solr，Lucene，ElasticSearch<br>在linux上部署solr，solrcloud，，新增、删除、查询索引<br>Storm，流式计算，了解Spark，S4<br>在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。<br>Hadoop，离线计算<br>HDFS、MapReduce<br>分布式日志收集flume，kafka，logstash<br>数据挖掘，mahout</p>
<h2>网络安全知识</h2>
<p>什么是XSS<br>XSS的防御<br>什么是CSRF<br>什么是注入攻击<br>SQL注入、XML注入、CRLF注入<br>什么是文件上传漏洞<br>加密与解密<br>MD5，SHA1、DES、AES、RSA、DSA<br>什么是DOS攻击和DDOS攻击<br>memcached为什么可以导致DDos攻击、什么是反射型DDoS<br>SSL、TLS，HTTPS<br>如何通过Hash碰撞进行DOS攻击<br>用openssl签一个证书部署到apache或nginx</p>
<h1>四、架构篇</h1>
<h2>分布式</h2>
<p>数据一致性、服务治理、服务降级<br>分布式事务<br>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC<br>Dubbo<br>服务注册、服务发现，服务治理<br>分布式数据库<br>怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase<br>分布式文件系统<br>mfs、fastdfs<br>分布式缓存<br>缓存一致性、缓存命中率、缓存冗余</p>
<h2>微服务</h2>
<p>SOA、康威定律<br>ServiceMesh<br>Docker &amp; Kubernets<br>Spring Boot<br>Spring Cloud</p>
<h2>高并发</h2>
<p>分库分表<br>CDN技术<br>消息队列<br>ActiveMQ</p>
<h2>监控</h2>
<p>监控什么<br>CPU、内存、磁盘I/O、网络I/O等<br>监控手段<br>进程监控、语义监控、机器资源监控、数据波动<br>监控数据采集<br>日志、埋点<br>Dapper</p>
<h2>负载均衡</h2>
<p>tomcat负载均衡、Nginx负载均衡</p>
<h2>DNS</h2>
<p>DNS原理、DNS的设计</p>
<h2>CDN</h2>
<p>数据一致性<br>想要了解更多Java架构技术的，可以关注我一下，我后续也会整理更多关于架构技术这一块的知识点分享出来，另外顺便给大家推荐一个架构交流学习群：650385180，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化，并发编程这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里一定有你需要的内容。</p>
<h1>五、 扩展篇</h1>
<h2>云计算</h2>
<p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p>
<h2>搜索引擎</h2>
<p>Solr、Lucene、Nutch、Elasticsearch</p>
<h2>权限管理</h2>
<p>Shiro</p>
<h2>区块链</h2>
<p>哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名<br>比特币<br>挖矿、共识机制、闪电网络、侧链、热点问题、分叉<br>以太坊<br>超级账本</p>
<h2>人工智能</h2>
<p>数学基础、机器学习、人工神经网络、深度学习、应用场景。<br>常用框架<br>TensorFlow、DeepLearning4J</p>
<h2>其他语言</h2>
<p>Groovy、Python、Go、NodeJs、Swift、Rust</p>
<h1>六、体系篇</h1>
<h2>1、性能调优</h2>
<p>不管是应付前端面试还是改进产品体验，性能优化都是躲不开的话题。<br>优化的目的是让用户有“快”的感受，那如何让用户感受到快呢？<br>加载速度真的很快，用户打开输入网址按下回车立即看到了页面<br>加载速度并没有变快，但用户感觉你的网站很快<br>性能优化取决于多个因素，包括垃圾收集、虚拟机和底层操作系统（OS）设置。有多个工具可供开发人员进行分析和优化时使用，你可以通过阅读 Java Tools for Source Code Optimization and Analysis 来学习和使用它们。<br>必须要明白的是，没有两个应用程序可以使用相同的优化方式，也没有完美的优化 java 应用程序的参考路径。使用最佳实践并且坚持采用适当的方式处理性能优化。想要达到真正最高的性能优化，你作为一个 Java 开发人员，需要对 Java 虚拟机（JVM）和底层操作系统有正确的理解。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV53qt?w=677&amp;h=341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>2、源码解读</h2>
<p>源码分析是一种临界知识，掌握了这种临界知识，能不变应万变，源码分析对于很多人来说很枯燥，生涩难懂。<br>源码阅读，我觉得最核心有三点：技术基础+强烈的求知欲+耐心。<br>我认为是阅读源码的最核心驱动力。我见到绝大多数程序员，对学习的态度，基本上就是这几个层次(很偏激哦)：<br>1.只关注项目本身，不懂就baidu一下。<br>2.除了做好项目，还会阅读和项目有关的技术书籍，看wikipedia。<br>3.除了阅读和项目相关的书外，还会阅读IT行业的书，比如学Java时，还会去了解函数语言，如LISP。<br>4.找一些开源项目看看，大量试用第三方框架，还会写写demo。<br>5.阅读基础框架、J2EE规范、Debug服务器内核。<br>大多数程序都是第1种，到第5种不光需要浓厚的兴趣，还需要勇气：我能读懂吗？其实，你能够读懂的。<br>耐心，真的很重要。因为你极少看到阅读源码的指导性文章或书籍，也没有人要求或建议你读。你读的过程中经常会卡住，而一卡主可能就陷进了迷宫。这时，你需要做的，可能是暂时中断一下，再从外围看看它：如API结构、框架的设计图。<br>下图是我总结出目前最应该学习的源码知识点：<br><span class=""img-wrap""><img data-src=""/img/bV7tKA?w=567&amp;h=580"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>3、分布式</h2>
<p>分布式系统是一个古老而宽泛的话题，而近几年因为 “大数据” 概念的兴起，又焕发出了新的青春与活力。除此之外，分布式系统也是一门理论模型与工程技法并重的学科内容。相比于机器学习这样的研究方向，学习分布式系统的同学往往会感觉：“入门容易，深入难”。的确，学习分布式系统几乎不需要太多数学知识。<br>分布式系统是一个复杂且宽泛的研究领域，学习一两门在线课程，看一两本书可能都是不能完全覆盖其所有内容的。<br>总的来说，分布式系统要做的任务就是把多台机器有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。如果一定要给近些年的分布式系统研究做一个分类的话，我个人认为大概可以包括三大部分：<br>1.分布式存储系统<br>2.分布式计算系统<br>3.分布式管理系统<br>下图是我总结近几年目前分布式最主流的技术：<br><span class=""img-wrap""><img data-src=""/img/bV7kdd?w=638&amp;h=559"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>4、微服务</h2>
<p>当前微服务很热，大家都号称在使用微服务架构，但究竟什么是微服务架构？微服务架构是不是发展趋势？对于这些问题，我们都缺乏清楚的认识。<br>为解决单体架构下的各种问题，微服务架构应运而生。与其构建一个臃肿庞大、难以驯服的怪兽，还不如及早将服务拆分。微服务的核心思想便是服务拆分与解耦，降低复杂性。微服务强调将功能合理拆解，尽可能保证每个服务的功能单一，按照单一责任原则（Single Responsibility Principle）明确角色。 将各个服务做轻，从而做到灵活、可复用，亦可根据各个服务自身资源需求，单独布署，单独作横向扩展。<br>下图是我总结出微服务需要学习的知识点：<br><span class=""img-wrap""><img data-src=""/img/bV66dM?w=698&amp;h=493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>5、工程化</h2>
<p>工欲善其事，必先利其器，不管是小白，还是资深开发，都需要先选择好的工具。提升开发效率何团队协作效率。让自己有更多时间来思考。<br><span class=""img-wrap""><img data-src=""/img/bV53qs?w=756&amp;h=514"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h1>七、 推荐书籍</h1>
<p>1、《深入理解Java虚拟机》<br>2、《Effective Java》<br>3、《深入分析Java Web技术内幕》<br>4、《大型网站技术架构》<br>5、《代码整洁之道》<br>6、《Head First设计模式》<br>7、《maven实战》<br>8、《区块链原理、设计与应用》<br>9、《Java并发编程实战》<br>10、《鸟哥的Linux私房菜》<br>11、《从Paxos到Zookeeper》<br>12、《架构即未来》</p>
<h1>八、总结：</h1>
<p>以上就是我总结的Java由浅入深的技术点，希望以上的内容可以帮助到正在默默艰辛，遇到瓶疾且不知道怎么办的Java程序员们，需要学习，获取资料的也可以加下上面推荐的那个群，希望可以帮助在这个行业发展的朋友和童鞋们，在论坛博客等地方少花些时间找资料，把有限的时间，真正花在学习上。<br>如若知识点总结的有不足的地方，欢迎各位朋友指正，觉得有收获的朋友也可以点赞关注一下。</p>

                ", 你和阿里资深架构师之间，差的不仅仅是年龄（进阶必看）,1531977889,356,1,996,1,1,https://segmentfault.com/a/1190000014351642
37,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV8cSY?w=576&amp;h=432"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>前言</strong></p>
<p>今天本是一个阳光明媚，鸟语花香的日子。于是我决定在逛街中感受春日的阳光~结果晚上七点的时候，蚂蚁金服后端大佬来了电话，要进行一轮的技术面试。我一脸黑人问号？？？现在的面试都流行突袭吗？</p>
<p>于是我的第一次面试之旅，就此壮烈的展开。</p>
<p><strong>自我介绍</strong></p>
<p>首先呢，大佬让我用两分钟自我介绍。我本以为自己能滔滔不绝，将对方视作相亲对象般全方位介绍自己。结果不到半分钟，我就介绍完了==。</p>
<p>五秒钟的沉默后，大佬嗯了一声。</p>
<p>感觉自己的脸上堆满了尴尬而不失礼貌的微笑。</p>
<p><strong>最近的项目经历</strong></p>
<p>这时大佬问我最近从事了什么项目，研究生阶段都进行了什么样的工作。</p>
<p>那必须吹一吹！从JAVA的起源到Spring的发展再到jenkin的使用顺便提一嘴dva+antd，结果半分钟一到，又说不下去了==</p>
<p>大佬很有耐心的听我说了一堆语无伦次的话，开始进入正题。</p>
<p><strong>Spring</strong></p>
<p>大佬：我看你用过这个Spring啊，你来聊聊为什么我们要使用Spring呢？</p>
<p>我：（因为大家都说好啊）首先呢，spring是一个庞大的框架，它封装了很多成熟的功能能够让我们无需重复造轮子。其次呢，它使用IOC进行依赖管理，我们就不用自己初始化实例啦。</p>
<p>大佬：（我就知道你会说IOC啦）那你解释一下IOC吧</p>
<p>我：IOC就是依赖控制转化，利用JAVA的反射机制，将实例的初始化交给Spring。Spring可以通过配置文件管理实例。</p>
<p>大佬：那我们可以直接使用工厂模式呀。工厂模式也可以管理实例的初始化呀，为什么一定要使用Spring呢？</p>
<p>我：啊........因为.......方便？（仿佛看到大佬凝固的表情，为了不那么尴尬，我决定转移话题）。而且spring的IOC是单例模式呢。</p>
<p>大佬：默认的是实现是单例模式吗？</p>
<p>我：对的。</p>
<p>这里查了一下为什么不用工厂模式而使用IOC。其实本质上还是因为IOC是通过反射机制来实现的。当我们的需求出现变动时，工厂模式会需要进行相应的变化。但是IOC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成的。</p>
<p><strong>数据库</strong></p>
<p>大佬：你使用过哪些数据库呀？</p>
<p>我：mysql还有sqlight。（被遗忘的mongodb在角落里无声哭泣）</p>
<p>大佬：那你使用的ORM框架除了hibernate还有哪些，比如IBatis？</p>
<p>我：我用过MyBatis</p>
<p>大佬：哦，那你能讲一下你对两个框架使用后的感受吗？</p>
<p>我：当时使用Mybaits的时候，也有去社区了解了一下两个框架的口碑，发现大家的战队都坚定而对立。对Hibernate的不满通常是因为它在复杂关联中往往会带来严重的性能问题，也就是N+1的问题。但是它是面向对象支持的最好的框架了。而Mybatis则相对而言比较易于使用，只需要会SQL语句就行了。但是也意味着会破坏一些面向对象的规则。</p>
<p>大佬：（似乎有点认可）那你了解数据库的事务吗？能讲一下数据库的事务级别吗？</p>
<p>我：（忘得一干二净）emmm不好意思我记不太清楚了。</p>
<p>大佬：那你还记得数据库的加锁吗？比如乐观锁，悲观锁？</p>
<p>我：（求您别问了T T）</p>
<p>大佬：（锲而不舍）那我现在假设有一张用户表，你也知道，正常的表只能存放大概一千万或是两千万左右的数据。但是阿里巴巴有上亿的用户？你会怎么存储呢？</p>
<p>我：可以纵向分割与横向分割。</p>
<p>大佬：那你觉得这里应该纵向还是横向呢？</p>
<p>我：纵向（载入史册的嘴瓢）</p>
<p>大佬：（很有耐心）可是这样我的数据库还是放不下啊</p>
<p>我：（仿佛突然睡醒）应该是横向分割，把表拆分成多个表然后分布式存储</p>
<p>大佬：那你觉得我们怎样分割比较合适呢？</p>
<p>我：（还能再问？）可以根据地域，但是根据用户分布的情况来说，还是会有某些地域访问稠密而有些地域比较稀疏的问题。难道按照用户等级？</p>
<p>大佬：不，用户等级会变动，不合适。你这个阶段暂时没有考虑这个问题</p>
<p>我：（谢谢您的台阶啊！）</p>
<p><strong>Linux</strong></p>
<p>大佬：你们服务器用的是什么操作系统啊？</p>
<p>我：（呀，送命题）我们用的是阿里云上的centos系统</p>
<p>大佬：那你对linux熟练吗？</p>
<p>我：不是很熟悉，仅仅是入门，能够敲一点指令。</p>
<p>大佬：好，那你知道库函数和内核调用吗？</p>
<p>我：内核调用是指进入内核态然后执行指令然后再回到用户态吗？</p>
<p>大佬：对</p>
<p>我：我知道的大概就这么多了，只了解一些概念上的内容。（凉凉送给自己）</p>
<p>大佬：那你知道如何查看进程吗？</p>
<p>我：啊...记不得了，我一般都查一下指令</p>
<p>（于是大佬果断放弃了其它linux问题）</p>
<p><strong>JVM</strong></p>
<p>大佬：你了解JAVA虚拟机吗？能解释一下底层的模块吗？</p>
<p>我：（如果你通知我明天面试，我就了解了&gt;&lt;）不好意思，这一块知识我不熟悉，但是我很愿意去了解（赶紧表忠心啊！）</p>
<p><strong>线程</strong></p>
<p>大佬：你知道什么是线程安全吗？</p>
<p>我：（乌鲁乌鲁说了一堆）就是比如如果同时有两个线程访问同一个变量，那么它们对变量造成的修改所带来的结果可能是不确定的。群：650385180，想要全面了解面试经验的，可以加入进来。</p>
<p>大佬：那你知道JAVA有什么方法来实现线程安全吗？</p>
<p>我：（前几天还翻译了博客，但是一问起来忘得比啥都快）首先是synchronized修饰词，然后JAVA还自己实现了一些封装好的类比如LatchDown，Atomic系列(????????后来一查是CountDownLatch!还有大明湖畔的final关键字呢？还有小明湖畔的Lock呢？还有那些实现线程的collections比如ConcurrentHashMap呢？)</p>
<p>（大佬果然开启了下一个问题）</p>
<p><strong>分布式</strong></p>
<p>大佬：你有写过分布式的业务吗？</p>
<p>我：我写过一个基于HDFS分布式存储的KVStore，上层使用Hadoop的API实现。</p>
<p>大佬：那个是分布式存储，我想了解一下分布式业务？</p>
<p>我：（赶紧纠正）那dubbo算吗？（于是介绍了一下自己了解的dubbo）</p>
<p>大佬：ok。那你觉得分布式的话会遇到什么问题呢？</p>
<p>我：那就是经典的CAP问题了。没有数据库能够同时满足这三个问题</p>
<p>大佬：那你能具体解释一下CAP代表什么吗？</p>
<p>我：（紧张到一片空白）Consistency？Atomic？P...Persistency？？？</p>
<p>大佬：.......</p>
<p>CAP: 是指Consistency一致性，Availability可用性，Partition Tolerance分区容忍性</p>
<p><strong>设计模式</strong></p>
<p>大佬：你了解过设计模式吗？</p>
<p>我：了解了解</p>
<p>大佬：那你了解过哪些设计模式呢？</p>
<p>我：blablabla</p>
<p>大佬：那你解释一下指令模式吧</p>
<p>我：这个有点像函数式编程的思想。指令模式就是指将各个操作封装为统一的接口，并且提供各个操作的实现类。这样我们只需要面向command接口编程，解除了调用类和指令之间的强耦合。</p>
<p><strong>总结</strong></p>
<p>最后当然和大佬话一话家常，进行最后的挣扎。总结来说，要想成功进行一次阿里巴巴的面试，你需要了解甚至掌握以下内容：</p>
<p>· JAVA语言，尤其是线程</p>
<p>· JVM原理</p>
<p>· 数据库（事务，加锁，ORM）</p>
<p>· Linux</p>
<p>· Spring（重点！）</p>
<p>· 分布式</p>
<p>· 设计模式</p>
<p>可以说是涉及范围非常广了。不过其实要想成为一名优秀的后端开发，是需要这些知识面的，只能说自己还是太菜了。要继续深入学习！如果你也想深入学习的话，可以加入进来，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多，以下的知识体系图也是在里面获取的。</p>
<p>推荐知识体系：</p>
<p>一、性能调优</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cP1?w=1180&amp;h=928"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>二、源码解读</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cP7?w=1180&amp;h=887"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>三、分布式</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cQb?w=1180&amp;h=968"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>四、微服务</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cQm?w=1180&amp;h=912"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>五、工程化</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cQH?w=1180&amp;h=926"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>六：双十一项目实战</p>
<p><span class=""img-wrap""><img data-src=""/img/bV8cQM?w=781&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>以上就是我要说的内容，希望以上的内容可以帮助到正在默默艰辛，遇到瓶疾且不知道怎么办的Java程序员们，我能帮你的只有这么多了，面试题已经总结完了，我能帮的，也只有这么多了，希望大家在往后的工作与面试中，一切顺利。</p>

                ", 记一次惨烈的阿里面试经历,1531977890,542,1,393,1,1,https://segmentfault.com/a/1190000014310441
38,1,0,9,"
                    
<h2>前言</h2>
<p>这里筑梦师,是一名正在努力学习的iOS开发工程师,目前致力于全栈方向的学习,希望可以和大家一起交流技术,共同进步,用SegmentFault记录下自己的学习历程</p>
<p><strong>本文阅读建议</strong><br>1.一定要辩证的看待本文.<br>2.在看完本文后总结适合自己的学习体系以及学习方法.<br>3.觉得哪里不妥请在评论留下建议~<br>4.觉得还行的话就点个赞鼓励下我吧~</p>
<hr>
<p><strong>目录</strong><br>1.是否适合做程序员<br>2.建立个人目标<br>3.学习途径<br>4.如何构建适合自己的学习体系<br>5.学习环境<br>6.学习方法<br>7.学习工具</p>
<h2>现状</h2>
<p>每次我曾经的同学打电话向我询问程序员这个行业怎么样,我都会很耐心的讲上一个半小时,谈人生谈理想,并判断他是否适合程序员这个行业.</p>
<p>每次看到群里有人问程序员好不好当啊,觉得有眼缘我就会加上好友,连麦讨论一下.</p>
<p>我为什么会这么做呢,因为目前市面上所存在的QQ交流群,一大半都是培训机构的人建立的,忽悠你去培训,还有小部分群,只要你进群问,XXX学了好不好找工作啊,全部都是劝退:<strong>不好!转行吧!</strong></p>
<p>这往往就会改变一个人的想法,也就改变了一个人的人生,有技术的没空引导新人,没技术的只会吹水误导新人.</p>
<p>所以,我将我之前每次都会进行的长篇大论,总结成为本文,供各位想要入行或者转行的大学生或者其他职业的你们借鉴.</p>
<h2>是否适合程序员</h2>
<p>首先,判断自己是否适合程序员这个职业.</p>
<p>在校大学生&amp;应届毕业生</p>
<blockquote>1.是否计算机相关专业?<br>如果不是计算机相关专业,判断自己是否会适合程序员或者计算机工作的学习.例如:打字速度,不会厌倦电脑,独立钻研的能力.<p>2.是否在学习C语言等计算机课程还算得心应手?<br>数学和英语能力,以及计算机基础学的是否扎实,都决定了以后你能达到的高度上限,如果你学的并不扎实,不用担心,你只是会比别人慢一点到达同样高度而已,只要努力学习.</p>
<p>3.是否对着程序员这行或者计算机语言有着浓厚的兴趣?<br>我个人看法,学习能力是一方面,在勤能补拙的基础上,往往兴趣却是能支持你在程序员道路上越走越长的核心.</p>
</blockquote>
<p>社会人士&amp;其他职业</p>
<blockquote>1.是否是发自内心的学习?<br>不是单纯的因为程序员行业工资高,而是想来学一门技术的.单纯把程序员当成挣钱的工具,会限制你以后能到达的高度.怎么限制?可能没有兴趣两年以后就转行了这种程度.<p>2.是否适合程序员行业?<br>挣钱的行业很多,不只程序员,程序员大多996模式,自己是否适应长时间在电脑前工作?</p>
<p>3.是否有着改变人生的想法?<br>往往社会人员进行转行时要比应届毕业生有着更大决心,否则你不会在这条路上走太远,你需要比大学生更有耐心和毅力进行学习.</p>
</blockquote>
<p>程序员需要<strong>谦虚、好学、内敛、成熟</strong>的人,因为不仅需要不断的学习,还需要<strong>人际交流、灵活变通、独立解决问题、主观意识</strong>.你才可以达到一般程序猿到达不了的高度.</p>
<p><strong>高工资是需要不断学习的,而不是空口白话就有的高工资</strong></p>
<h2>建立个人目标</h2>
<p>那么在判断自己适合程序员行业以后,我们就来指定一个目标吧~没有目标的程序员和咸鱼有什么区别?</p>
<p>我为什么当程序员呢,我想做一个自己的应用,很不巧,我也是一名非科班出身的人,经过自己的努力学习,成为了一名程序员.怎么样的学习呢,跟高考强度一样的历练吧~</p>
<p><strong>个人目标:</strong></p>
<blockquote>首先按照<strong>三月内、半年内、1年、2年、3年、5年</strong>指定人生规划.<br>例如:本人在三月内要进行XX语言的学习,半年内读什么书、1年内做到XX级别的开发.<br>个人规划一定要切合实际,要需要一定的努力才能实现.</blockquote>
<p>个人目标可以是车子,房子,票子.一定是要循序渐进达到的目标,规划则是实现目标的过程.</p>
<p>做不做的到是一回事,敢不敢想又是另一回事.这么说吧,<strong>去上海工作</strong>的事情,就是我上学想都不敢想的事.现在我随时都可以去上海找工作.</p>
<h2>学习途径</h2>
<p>规划了个人目标以后,我们可以开始程序员的学习了.那么怎么进行学习呢,我是一个小白,我怎么知道该学习什么呢.找个人带带吗?</p>
<p><strong>自学</strong>:</p>
<blockquote>自学往往需要一个良好的学习环境,以及高效的学习方法,往往需要大量的时间成本,大量时间成本最适合大三大四的学生,在最后的两年进行自学,完全可以达到毕业后寻找工作的程度.<p>但是你要做到不被寝室的人干扰哦.<br>自学大概需要2年的时间成本,社会人士0基础可能需要更长.请慎重考虑</p>
</blockquote>
<p><strong>找人带</strong>:</p>
<blockquote>相对社会转业人士,往往迫切的需要投入程序员行业开始赚钱.那么怎么办呢.这时候就体现你的人脉了.<p>首先寻找自己人脉中的程序员,看看有没有更好的推荐以及实习机会.找到人带,往往是最好的途径,可由于目前互联网经济快速发展,程序员并没有空带实习.大公司都喜欢培养985 211的迎接毕业生.</p>
<p>最快的方法是快速入门一门语言,然后找一个实习工作,看看人脉当中有没有这个机会.<br>如果没有,而且又想转行的,只能考虑下面这个了.</p>
</blockquote>
<p><strong>培训</strong>:</p>
<blockquote>首先说明一下,我并不推荐培训,为什么这么说呢.<p>个人看法:很多人都觉培训机构坑,是因为培训机构根本不会看你适不适合程序员这个行业,就会把你拉去学习,有些人对计算机一窍不通,听说高工资,被拉过去以后交了钱也学不会,这就是培训机构被骂的原因.培训机构只想挣钱,并没有在人上面进行把关.</p>
<p>如果你觉得自己的确适合程序员这个行业,而且还有着刻苦学习,克服困难的毅力,那我只能勉强同意你来培训机构进行学习.</p>
<p>如果没有,你还是选择别的行业吧,程序员真的不是随便培训一下,你就很厉害了.</p>
<p>在培训机构,还有一个重点就是,你不能被老师灌输思维,<strong>一定一定一定要有自己的理解和体会</strong>,不然出来也是废物.</p>
<p>培训机构的学习氛围还是不错的,大家都是交钱过来学习的,而不会在那里玩游戏.玩游戏注定被淘汰.<br>培训机构也有好坏,这里小提几个:<strong>黑马,小码哥,老男孩,兄弟连</strong>等.其他那几个知名,耳熟能详的不推荐,你懂我意思吧.</p>
</blockquote>
<h1>如何构建适合自己的学习体系</h1>
<p>好吧好吧,不管怎么样,你都已经选择程序员这条路了,那么我就告诉你,我是怎么学习的吧.</p>
<h2>学习方向</h2>
<p>首先,程序员这个行业分为很多子行业,每个子行业都是一门程序语言.大致列一下主流语言和行业,大家可以评论补充下:</p>
<blockquote>前端:HTML5 <br>后端:Java、PHP<br>移动开发: 安卓(Java) iOS(Objective-C)<br>游戏开发:Unity3D <br>云计算:Spark<br>服务器运维&amp;人工智能:Python<br>网络安全:C/C++</blockquote>
<p>语言有很多,这里只列举了我所知道的.<br>选择一门自己喜欢的工作语言进行学习,当你学习一门语言,熟悉之后,建议学习第二门语言,成为复合型人才.</p>
<p>当然,刚开始只是开发工程师,在你技术成熟以后,你可以考虑<strong>架构师、技术经理、产品经理</strong>进行转型.</p>
<h2>学习环境&amp;设备</h2>
<p>那么确定了学习方向,我们就准备一下学习环境吧.</p>
<p>首先一定要有一台趁手的电脑,<strong>工欲善其事必先利其器</strong>.</p>
<p>如果经济允许的话,个人推荐使用Mac电脑进行开发,但是这样成本可能会有点高哦,所以经济不允许就使用一台高配置的PC笔记本电脑.</p>
<p>配置只会影响到你的学习速度,以及学习体验,越好的笔记本在你不打游戏的前提下,只会提高你的工作效率以及学习效率.</p>
<p>系统的话,推荐装一个Linux系统,优雅的开发都是在基于Linux系统下的.别问我为什么,我只挺Shell.</p>
<p>设备有了,就准备一个适合学习的环境吧,如果你是大学生,那么请你不要受同宿舍打游戏的干扰,适当的远离他们,你的人生就越完整.</p>
<p>不要等到25岁了和人家20岁程序员交谈时:我20岁的时候还和寝室的人一起打游戏呢.</p>
<p>如果你在家自学的话,那么你需要提前和家里人说清楚,你需要什么样的环境,多久时间,不然一直被嫌弃,你反而会失去学习的动力,因为你在家里算闲人.</p>
<p>如果你在培训机构,那么请你勇夺第一,你在培训机构都当不了第一的话,那么你注定会被淘汰.做不做到是一回事,想都不敢想,你就输了.</p>
<p>QQ群,微信群,少加.或者自己去寻找高质量的交流群,什么叫做高质量?一般的交流群,大致分为三种人:培训机构打广告的,程序员劝退师,招聘外包接项目,吹水装逼的.</p>
<p><strong>高质量的群就是:严格的群规,小部分时间吹水,大部分交流技术.</strong></p>
<p><strong>重点:在确定了自己的路线后,不要被他人的风言风语所影响,努力学习,让那些不以为然的吹水货们刮目相看,实力是证明自己的最好方法</strong></p>
<h2>学习方法</h2>
<p>那么,学习环境有了,本文的重点来了,学习方法,是一个很重要的事.</p>
<p>程序员这个行业,有很多前人巨人铺路,网上有很多的资源,可是大多数人却不以为然,觉得网上没东西,没干货,是因为学习方法不对.<br>首先我要把我在网上看到好的方法,分享给大家~在这里要感谢一下Keegan小钢的文章,教会了我如何学习,下列方法结合了本人体会总结.</p>
<p><strong>学习方法:</strong></p>
<blockquote>
<p>1.学习力<br>学习力不同于学习能力,而是将知识资源转换为知识储备的能力,你看了多少书、文章,这是你的知识总量(阅读量),但不是你拥有的.你能够讲出来的知识,就是你所拥有的.</p>
<p>2.目标学习法<br>学习一定要找到难度适中,需要一定时间学习才能理解的知识.而且以后能用的上.<br>从遇到的问题出发，从能实践的领域出发去找适合的认知材料。<br>不要一上来就阅读<strong>数据结构、算法导论</strong>这种圣经类的书籍,而是一步一步来.</p>
<p>3.快速学习法<br>当我遇到一个自己不会的知识点时,我会进行百度,进行泛读,充分结合各个大神的文章,进行理解,重点是自己个人的理解.做笔记.辩证的看待每个人的文章,然后提炼到自己的笔记里.<br>遇到难点时,我会询问列表里的大神,是否在工作中也是这个做法.得到答案.<br>整理以后,可以用自己的话描述出这些知识点.<br>在讲的过程中,就会发现自己的话有瑕疵,就会去寻找正确的说法,不断修正自己.</p>
<p>4.输出倒逼输入<br>如何提高巩固自己的实力,也是本人最喜欢的一个学习方法,在整理自己的笔记之后,尝试把自己的笔记转成文章输出出来,放在博客,简书或者CSDN等技术论坛上.<br>在输出的同时,在追求完美的同时,就会发现自己的不足,搜罗各种知识点,结合自己的理解.<br>最后变成自己的输出文章.这就是输出倒逼输入.完美的文章逼着自己学习更多的知识.</p>
<p>5.快捷键&amp;笔记<br>那么高效的开发,为什么推荐Mac呢,因为快捷键太方便了,我会将常用的终端,文本编辑器设置快捷键,快速调用.<br>关于笔记,我本人会开启三个笔记窗口,使用的是Omni outliner.</p>
<blockquote>1.自学笔记,该笔记针对并记录在书中的问题,以及书中重点.<br>2.视频笔记+学习日志,该笔记针对每天的学习中遇到的问题,以及在各个视频当中汲取的知识点的笔记.<br>3.输出笔记,例如:全栈工程师开发入门笔记,该笔记按照文章输出规范整理,每一个知识点,都可以成为一篇文章输出,不整理好不写入笔记,这就是我的财富.一定要漂漂亮亮的.</blockquote>
</blockquote>
<p><strong>Github &amp; 个人博客</strong><br>这个东西一定要有吧,不仅是个人经验的体现,也是一个提高自己的途径.</p>
<p><strong>搜索引擎用法</strong><br>HTML开发 + ""空格"" + 知识点<br>JS开发 + ""空格"" + 效果实现<br>XXXX开发 + ""空格"" + ""你想搜索的""<br>重点关注<strong>简书、CSDN、github</strong>等技术网站的结果</p>
<h2>学习工具</h2>
<p>学习工具呢,因为本人是Mac系统,所以就先在这里说一下概念,以后有好的软件会更新.</p>
<p>学习工具的概念呢,就是电脑中所有利于提高你开发效率和学习效率的都是学习工具,不利的都可以卸载掉.做一个成熟的程序员~</p>
<p>学习工具每个人都是不同的,都需要自己去寻找合适自己的,例如学习前端时,大家都推荐sublime text3,但是我自己会去寻找例如<strong>Atom、VSCode、PHPStorm</strong>的工具,每个都配置一遍,在配置的过程中又会涉及到<strong>brew、curl、wget</strong>等知识点,根据百度这些关键词,我又会学到不少东西.</p>
<p>总之就是<strong>学习成本、时间成本</strong>的相互调配,请选择适合自己的工具和学习方法很重要.</p>
<h2>开始学习</h2>
<p>在这里,并不是抵制玩游戏,我也玩游戏,但是我劝你在有稳定的工作实力之前,卸载掉你电脑上的游戏,手机上的游戏,QQ别上了,微信别上了,没什么用,好好学习,你的人生就更加完整.</p>
<p>当你学会了学习方法后,你会觉得东西学不完.<br>如果你没有东西学不完的想法,说明你还没有找到合适学习方法哦.或者说,你不适合做程序员.</p>
<p>区块链理解吗,大数据是什么,人工智能怎么做,机器学习呢?不学习会被淘汰哦~</p>
<p><strong>余生,请君不留余力的学习</strong>.</p>
<h2>结束语</h2>
<p>如果您对这篇文章有什么意见或者建议,请评论与我讨论.<br>如果您觉得还不错的话~可以点个赞鼓励我哦.<br>如果您想和我一起学习,请毫不吝啬的私信我吧~<br>介个是我的<a href=""https://dreamerwinston.github.io/blog/"" rel=""nofollow noreferrer"">个人博客</a>,欢迎参观哦~</p>

                ", 如何做一个优雅的程序员,1531977892,200,1,478,1,1,https://segmentfault.com/a/1190000014297096
39,1,0,9,"
                    
<p>本文所要分享的是软件开发过程中，亲身经历过的“怪现象”。为什么说怪呢，人多力量大，似乎才符合常理，但是往往在软件项目开展的过程中会出现人多、事少、工作量大的情况，这跟我们以往的认知大相径庭。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV76fO?w=638&amp;h=322"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>首先，要解释下标题的意思。人多，指的是同一个项目团队、同一个小组或者同一个部门的范围内；事少， 指的是做出的效果，真正的产出少；工作量大，指的是，工作时间长，工作忙，实际的投入大。</p>
<p>其实，人多事少工作量大，说白了就是效率低，而影响效率的，原因千万种，有人员问题、沟通问题、流程问题、管理问题、技术问题，下面零散地列举下博主亲身经历过的问题：</p>
<p>文章基本纯文字，需要空闲的时候，精心阅读哦。</p>
<p>● 一线工作人员，没让专业的人做专业的事，导致效率低</p>
<p>没让专业的人做专业的事情， 是工作开展的大忌，在工业上，早已证明了一切，在工厂生产中，工人流水化作业，一个人只专注一件事情，会越做越熟练，越做越快，越做效率越高。</p>
<p>在软件开发分工越来越明确的今天，让后端人员抢前端人员的饭碗，去写网页、样式，效率能高吗？让后端人员去抢DBA的饭碗，去做数据库优化，效率能高吗？</p>
<p>不专业的人做不专业的事情，可能和公司的发展历程、组织架构、人员规划有关；也可能和任务安排有关。</p>
<p>公司发展初期，养不起很多专业的人，可能更需要“全栈”工程师，啥都一把捉；公司发展的过渡期，有点钱了，也意识到了要让专人做专业的事情，但是人员还没招齐，那没办法，你也得兼职着做各种各样的事情。如果公司有钱了，发展也成熟了，不是属于以上两种阶段，在IT组织中，连前端、后端、测试、架构、DBA、网络、服务器运维、技术支持、安全、产品，这些职能都没区分好的话，就会对工作效率有影响。IT一线工作人员，每个坑位，都需要一颗专业的螺丝钉。</p>
<p>● 开发人员不注重代码质量，导致后期返工，导致效率低</p>
<p>有时候，快即是慢，对于经验不足或者习惯不好的开发人员，开发前期，被迫或者自己没意识到，为了追求进度，逻辑没考虑周全，没做好自测，代码能跑起来就算完成任务了，表面上任务完成得很快。但是在项目后期，测试阶段，问题大规模爆发，甚至要返工，由于测试后期，离自己写代码的时候，可能隔了一段时间，有的东西自己都忘了，再回过头去重新“熟悉”，效率能不低吗？更为严重的后果是让项目进度不可控。因此，就算进度再紧张，也顶住压力，必须要做最基本的测试，再进入下一个任务点。</p>
<p>● 个体组织人员膨胀，出现沟通成本大的问题，导致效率低</p>
<p>沟通成本是人员膨胀后，暴露出来的首要问题。</p>
<p>举个简单的栗子，很多公司都有每天晨会习惯，如果一个组有5个人，开晨会汇报工作，平均一个人汇报2分钟，就需要10分钟，现在一个组增加到10个人，一人汇报两分钟，都要20分钟才能汇报完。时间就这样过去。</p>
<p>再举个栗子，30人天的工作，分给2个人做，可能需要15天，共耗费30人天，但是分给5个人做，6天能完成吗？</p>
<p>信息在沟通、传递的过程中，可能会“失真""，你想的，不一定能100%说出来，你说出来了，别人也不一定能100%理解，而且每个人的理解能力、知识体系都不一样，理解起来容易产生偏差，产生偏差就容易做错事情。</p>
<p>因此，如果人员出现膨胀，要以项目为单位，进行合理的项目拆分、人员拆分。同一个“小项目”最好不要超过4个人负责。沟通的时候，推荐使用口头+书面+复述，减少沟通过程中的信息失真。</p>
<p>● 上、下属之间相互不信任，做事有阻碍或者导致重复工作，导致效率低</p>
<p>上下属相互信任是一切工作的基础。如果上级不信任下属，不敢授权给下属，凡是都要自己过一遍，而上级往往是一对多的关系，这个时候，工作瓶颈会出现在上级身上；如果上级不信任下属，搞一堆监督机制，为了下属不做错事情，又让别人同事过一遍，又要耗费额外的成本，劳民伤财，而下级得不到信任，做事受阻，久而久之就会畏手畏脚，很难独当一面，或觉得自己有能力没地方使，干脆走人。</p>
<p>上级应该充分信任下级，放心授权让下级去做事情，但这些都一个前提就是要有一个较好的软件管理过程，包括开发环境和测试团队和在完成任务的过程中进行一些辅导和进行重要节点管控和监督。</p>
<p>上级不信任下级，经常碰到，而下级不信任上级也很要命。程序员是很有个性的工种，不好管理，往往特别多想法。就好像车轮子陷入泥潭中，上级说车子往前推，有的人又说，往后拉，各自发力，估计车子永远都摆脱不了泥潭，还谈何效率？</p>
<p>因此，如果有意见，前期可以提，但是解决方案一旦定下来，应该上下一心（即使有意见也埋在心底吧），朝着目标一起去努力。</p>
<p>● 不同部门之间沟通存在隔阂与障碍</p>
<p>软件开发过程中，在IT范畴内，不同部门难免有交集，例如开发与运维、开发与测试，不同岗位承担的责任、掌握的知识体系、考虑问题的角度往往不一样，导致处理事情受阻。</p>
<p>举个栗子，有一次，开发人员为了验证某个问题，需要运维人员协助重启某个站点。对于开发人员来说，这个站点，用的人比较少，而重启也是一瞬间的事情，风险为基本为0，但是由于运维人员掌握的知识体系不一样，怕重启了会造成很大影响，甚至害怕出了问题要自己承担责任，明明可以瞬间操作解决问题的，又要等到中午或者半夜三更没人的时候才敢重启，效率就是这样降低了。这个时候，需要运维人员，去学习一下相关知识，或者引入新流程，例如，重启站点，需要某个专业人士口头同意，即可立即执行。</p>
<p>因此，不同部门之间的人，应该互相学习，才能更好地沟通；做事情，尽量做轻量级的流程化、标准化。</p>
<p>● 上级工作安排不到位</p>
<p>上级工作安排不到位，也会导致工作效率低。有时候会有这种怪现象，可能很多事情没做，但是下面的人没事可做；或者有的人很忙，有的人很闲。</p>
<p>软件开发分工，不像搬砖头，一人搬一车就行了。软件开发，工作量化本身就是一个很难的地方，如果项目经理没有做项目计划，没有做工作点、任务点拆分工作就很难安排到位。特别是刚刚从程序员转型做项目经理的人，过程性思维，不会对项目做整体的把握、整体规划，想到哪里就做到哪里，想到什么就分配什么工作，最后一团糟，一会把下面的人累死，一会又让下面的人闲死。</p>
<p>想要了解更多软件研发过程的开发经验，可以加群：650385180，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，以下的资源都在群的共享区，目前受益良多。</p>
<p>● 需求传达不明确或者理解有偏差导致返工</p>
<p>探知客户内心潜在的需求很难，而需求确定后，信息传递的媒介，往往是需求文档。语言文字这种东西，传递的过程中容易失真，丢失原有的意思。这种情况尽可能比较，需求传递跨越太多层次才到最终到达开发人员身上。如果是这种结构，每层信息丢失2%都不得了，做错了，返工的效率和代价就十分巨大。</p>
<p>很多时候往往是这种传达方式：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV76gs?w=539&amp;h=371"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们需要的是这种方式：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV76gA?w=406&amp;h=268"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>最终的研发人员，应该接受到需求后，应该是反向和用户、产品经理、研发经理沟通，最终才能确定的。</p>
<p>● 技术架构过于落后、过于复杂</p>
<p>先进的技术架构、统一高效地开发标准，是系统建设的基石，会大大提高软件的生产力，让开发人员专注于实现业务、商业逻辑，做更有价值，更高产出的事情。</p>
<p>当你还在纠结页面兼容性，纠结这个界面必填怎么实现的的时候，人家通过工具简单配置，界面就自动生成了；当你还在纠结并发量大，分布式事务如何实现的时候，人家消息机制、两段式提交已经用的飞起来；当你还在纠结分布式系统，数据库拆分，如果做垮库查询的时候，人家ORM自动分库路由，数据分发机制已经用烂了；当扯不清、道不明各个系统之间的调用关系，猜不透单点改动的影响范围、运维上压力巨大的时候，人家服务治理框架应运而生。。。。。。。这所有的所有，都依赖于先进的软件架构，有现成的或者自主研发的。这一切的一切，都可以让开发人员如虎添翼，事半功倍。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV76gJ?w=1766&amp;h=510"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 为什么软件开发，人多，事少，还会工作量大？,1531977893,563,1,960,1,1,https://segmentfault.com/a/1190000014284777
40,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV7Viy?w=550&amp;h=405"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>主题</strong></p>
<p>又到面试季了，从群里，看到许多同学分享了自己的面试题目，我也抽空在网上搜索了一些许多公司使用的面试题，目前校招和社招的面试题基本都集中在几个大方向上，主要是：Java基础、并发、JVM、算法、数据库、一些框架、分布式集群 等。这里呢，单独就面试中的【并发】问题的准备和学习发表一下个人的见解。</p>
<p>现状</p>
<p>关于对并发的学习和理解，通过大家在课程群里的反馈，总结一下，主要包含以下几种：</p>
<p>完全不知道并发的存在</p>
<p>知道并发要学，但是不知道该学习什么</p>
<p>知道并发重要，自己买相关书籍学，但是看完了还是懵懵懂懂</p>
<p>知道并发重要，自己查资料学了一些，许多都学会了，但总能发现不会的，不知道并发到底都要学什么</p>
<p>已经完成进阶，并发的问题了然于胸，这样的小伙伴目前很少</p>
<p>首先说一下，为什么Java面试要考并发，而且并发相关的题目占比又是那么的高。对并发有一定了解的同学，应该都知道，大家平时 只要做Java项目就会涉及到并发 ，个别同学说自己从没接触过并发，这只是个人还没意识到而已。当你定义好一个可以调用的接口时，这时其实就已经和并发有关系了，因为任何一个接口都可能同时被请求多次。当你在项目中已经可以熟练的使用synchronized、volatile、static、final这些基本的Java关键字时，其实你对并发已经有一些基础了。大家总说的：面试造火箭、入职拧螺丝，其实有一部分原因也是因为你还没意识到面试考的这些东西其实一直就伴随着你的日常开发。</p>
<p>我不自量力的去列一下并发涉及到的关键字、类及可以考察的知识点：CPU缓存、Java内存模型JMM、atomic、AtomicInteger、AtomicLong、LongAdder、AtomicReference、AtomicBoolean、CAS原理、Unsafe、synchronized、volatile、final、static、ThreadLocal、AQS、J.U.C、CountDownLatch、Semaphore、CyclicBarrier、ReentrantLock、ReentrantReadWriteLock、StampLock、Condition、FutureTask、Fork/Join、BlockingQueue、ThreadPoolExecutor、ExecutorService、Thread、Runnable、Future、Callable、HashMap、 HashTable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、RateLimiter、SimpleDateFormat、StringBuffer、StringBuilder、ArrayList、Vector、HashSet、ConcurrentSkipListSet、Collections.synchronizedXXX、Guava Cache、Redis ... 我尝试去写出脑海里与并发有关的类和名词，我发现根本写！不！完！是的，并发的知识太多了，以致于很难给出一个完整的囊括。</p>
<p>因此呢，如果你盲目的一个知识点一个知识的去学，你就会发现你怎么都学不完，也很难在脑海里形成一个完整的知识体系，带来的最直接结果就是，你每次去面试时都要去把并发相关的再过一下，生怕自己被问到还没接触的。这时候，你要做的就是，先要在脑海里有一个完整的并发知识体系，然后根据这个体系去不断完善这个体系里每个模块的细节。想要详细了解并发编程知识体系的可以加群：650385180，以下的高清脑图已经放在群里面。</p>
<p><strong>并发</strong></p>
<p>关于并发的学习，可以从JDK提供的并发包为核心开始，许多其他的类和封装都是对其进行扩展或者补充，我们来看一下Java并发包(java.util.concurrent包，简称J.U.C)的构成：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV72bW?w=1989&amp;h=2297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>J.U.C核心由5大块组成：atomic包、locks包、collections包、tools包（AQS）、executor包（线程池）。大家平时遇到许多并发相关的类都可以从这里找到。但是呢，要想系统的掌握并发，不能是打开J.U.C这个包，挨个类去看，这里只是提供了五大块，代表核心的五个方向。要想系统的学习并发，可以加群650385180，并且还需要从并发的角度学习，过程中覆盖J.U.C的这些知识。这里我直接给出并发的学习步骤图（包含对当前面试常见考点的覆盖，比如对HashMap和ConcurrentHashMap的源码分析）：<br><span class=""img-wrap""><img data-src=""/img/bV72cc?w=640&amp;h=381"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这个之前呢，还需要对Java并发的基础进行细致的学习，比如CPU缓存和Java内存模型（JMM），许多关键字比如volatile、synchronized等的特性都是在JMM里规定好的。</p>
<p><strong>高并发</strong></p>
<p>我们这篇手记题目里提到的并发其实包含两部分：并发和高并发。手记讲到现在，其实我们讲的都是两部分里的第一部分：并发。那么并发和高并发到底有什么区别呢？许多小伙伴对这两个概念都是模糊的，我简单做一下区分。</p>
<p>当我们说多线程并发时，其实我们更多的是讨论多个线程操作了相同的资源，这时我们讨论点更多的是落在保证线程安全以及合理分配和使用资源上。而高并发主要指系统运行过程中遇到“短时间内遇到大量操作请求”的情况，主要发生在系统集中收到大量请求（例如：12306的抢票情况；天猫双十一活动）。当我们说高并发时，我们谈的是是如何提高现有程序的性能，更多的是对高并发场景的一些解决方案，思路啦、手段等等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。这里呢，我直接给出高并发场景通常都会考虑的一些解决思路和手段：<br><span class=""img-wrap""><img data-src=""/img/bV72cm?w=640&amp;h=406"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>结尾</strong></p>
<p>如何有效的准备面试中并发类问题，我已经给出我的理解。希望这些能帮大家在脑海里建立起大致的并发知识体系，然后根据这个知识体系有针对性的的去准备面试。预祝大家能高分通过面试，拿到高薪！</p>
<p>当然，光提概念光看图是没用的，还需要大家根据这些提纲去实际学习相关的知识点和类才行。我已经准备好了这些实际知识点学习的流程，相信聪明的你已经知道该怎么办了~</p>

                ", 聊聊面试中关于并发问题的应对方案,1531977895,188,1,800,1,1,https://segmentfault.com/a/1190000014269076
41,1,0,9,"
                    
<p>欢迎大家前往<a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">腾讯云</a><a href=""https://cloud.tencent.com/developer?fromSource=waitui"" rel=""nofollow noreferrer"">+社区</a>，获取更多腾讯海量技术实践干货哦~</p>
<blockquote>作者：林喜东 | 腾讯云高级工程师</blockquote>
<p>最近区块链有多火，已经无需过多阐述，无论你是主动了解，还是被比特币/加密猫/3点钟无眠区块链等刷屏，相信区块链概念已经在多数人心中萌芽。但区块链这么火，它能做什么？与我有什么关系？现实中有哪些应用？这些问题也困绕我许久，通过近期断断续续的关注和了解，略窥一二，分享给大家；因知识水平有限，难免存在错误，欢迎指正，一起学习，一起进步。</p>
<p>区块链的应用五花八门，有些是来割韭菜（目前币圈中绝大部分的ICO），有些是来蹭热点的（如区块链手机、区块链手表、区块链牙刷等），经过一番调查，我觉得比较有意义的应用可能包括但不限于以下七种：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187822?w=640&amp;h=367"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>备注：需要了解区块链是什么的，请出门百度/google搜索一下，有很多理解比我透彻，讲得比我好的，就不再普及了；下面直接进入各个应用场景。</p>
<h1>一、应用场景1：信息共享 -- 信息对齐、提高效率</h1>
<p>这应该是区块链最简单的应用场景，就是信息互通有无。</p>
<h2>1、传统的信息共享的痛点</h2>
<ul>
<li>要么是统一由一个中心进行信息发布和分发，要么是彼此之间定时批量对账（典型的每天一次），对于有时效性要求的信息共享，难以达到实时共享。</li>
<li>信息共享的双方缺少一种相互信任的通信方式，难以确定收到的信息是否是对方发送的。</li>
</ul>
<h2>2、区块链 + 信息共享</h2>
<p>首先，区块链本身就是需要保持各个节点的数据一致性的，可以说是自带信息共享功能；其次，实时的问题通过区块链的P2P技术可以实现；最后，利用区块链的不可篡改和共识机制，可构建其一条安全可靠的信息共享通道。</p>
<p>也行你会有这样的疑问：解决上面的问题，不用区块链技术，我自己建个加密通道也可以搞定啊！但我想说，既然区块链技术能够解决这些问题，并且增加节点非常方便，在你没有已经建好一套安全可靠的信息共享系统之前，为什么不用区块链技术呢？</p>
<h2>3、应用案例</h2>
<p>举下我们腾讯自己的应用--公益寻人链，借用如下一张好图，可以看到，区块链在信息共享中发挥的价值。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187823?w=640&amp;h=313"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>二、应用场景2：版权保护 -- 不可篡改、永久保存</h1>
<h2>1、传统鉴证证明的痛点</h2>
<ul>
<li>流程复杂：以版权保护为例，现有鉴证证明方式，登记时间长，且费用高。</li>
<li>公信力不足：以法务存证为例，个人或中心化的机构存在篡改数据的可能，公信力难以得到保证。</li>
</ul>
<h2>2、区块链 + 鉴证证明</h2>
<ul>
<li>流程简化：区块链应用到鉴证证明后，无论是登记还是查询都非常方便，无需再奔走于各个部门之间。</li>
<li>安全可靠：区块链的去中心化存储，保证没有一家机构可以任意篡改数据。</li>
</ul>
<h2>3、应用案例</h2>
<p>区块链在鉴权证明领域的应用有版权保护、法务存证等，下面以版权保护为例，简单说下如何区块链如何实现版权登记和查询。 （1）电子身份证：将“申请人+发布时间+发布内容”等版权信息加密后上传，版权信息用于唯一区块链ID，相当拥有了一张电子身份证。 （2）时间戳保护：版权信息存储时，是加上时间戳信息的，如右雷同，可用于证明先后。 （3）可靠性保证：区块链的去中心化存储、私钥签名、不可篡改的特性提升了鉴权信息的可靠性。</p>
<p>2016年8月，由Onchain、微软（中国）、法大大等多个机构在北京成立了电子存证区块链联盟“法链”。</p>
<p>2017年12月，微众银行、仲裁委（广州仲裁委）、杭州亦笔科技有限公司共同推出的仲裁联盟链，用于司法场景下的存证；2018年3月，广州首个“仲裁链”判决书出炉。</p>
<h1>三、应用场景3：物流链 -- 溯源防伪</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187824?w=640&amp;h=358"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>商品从生产商到消费者手中，需要经历多个环节（流程可能如上图所示），跨境购物则更加复杂；中间环节经常出问题，消费者很容易购买的假货。而假货问题正是困扰着各大商家和平台，至今无解。</p>
<h2>1、传统是防伪溯源手段</h2>
<p>以一直受假冒伪劣产品困扰的茅台酒的防伪技术为例，2000年起，其酒盖里有一个唯一的RFID标签，可通过手机等设备以NFC方式读出，然后通过茅台的APP进行校验，以此防止伪造产品。 咋一看，这种防伪效果非常可靠。但2016年还是引爆了茅台酒防伪造假，虽然通过NFC方式验证OK，但经茅台专业人士鉴定为假酒。后来，在“国酒茅台防伪溯源系统”数据库审计中发现80万条假的防伪标签记录，系防伪技术公司人员参与伪造；随后，茅台改用安全芯片防伪标签。</p>
<p>但这里暴露出来的痛点并没有解决，即防伪信息掌握在某个中心机构中，有权限的人可以任意修改。(备注：茅台的这种防伪方式，也衍生了旧瓶回收，旧瓶装假酒的产业，防伪道路任重而道远)。</p>
<p>2017年05月贵阳数博会上，小马哥就建议茅台防伪使用区块链；那么区块链和物流链的结合有什么优势呢？</p>
<h2>2、区块链+物流链</h2>
<ul>
<li>区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，大大提高伪造数据的成本。</li>
<li>区块链天生的开放、透明，使得任何人都可以公开查询，伪造数据被发现的概率大增。</li>
<li>区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。</li>
<li>物流链的所有节点上区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。</li>
</ul>
<h2>3、应用案例</h2>
<p>目前，入局物流链的玩家较多，包括腾讯、阿里、京东、沃尔玛等。 据说，阿里的菜鸟在海淘进口应用区块链上，走在了前面，已经初步实现海外商品溯源，国际物流及进口申报溯源、境内物流溯源；下一步就是生产企业溯源了。下图是网上流传的关于阿里的菜鸟在海淘场景运用区块链的示意图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187825?w=640&amp;h=388"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>另据最新消息，在3月份的第三届全球物流技术大会上，腾讯与中国物流与采购联合会（简称“中物联”）正式签署战略合作协议，并发布了区块链物流平台。强强联合，想象空间很大。</p>
<h1>四、应用场景4：供应链金融 -- 解决中小微企业融资难</h1>
<h2>1、传统的供应链单点融资</h2>
<p>在一般供应链贸易中，从原材料的采购、加工、组装到销售的各企业间都涉及到资金的支出和收入，而企业的资金支出和收入是有时间差的，这就形成了资金缺口，多数需要进行融资生产。我们先来看个简单的供应链(复杂的我也不了解(⊙o⊙))，如下图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187826?w=949&amp;h=314"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>我们再来看看图中各个角色的融资情况：</p>
<ul>
<li>核心企业或大企业：规模大、信用好，议价能力强，通过先拿货后付款，延长账期将资金压力传导给后续供应商；此外，其融资能力也是最强的。</li>
<li>一级供应商：通过核心企业的债权转让，可以获得银行的融资。</li>
<li>其他供应商（多数是中小微企业）：规模小、发展不稳定、信用低，风险高，难以获得银行的贷款；也无法想核心企业一样有很长的账期；一般越小的企业其账期越短，微小企业还需要现金拿货。这样一出一入对比就像是：中小微企业无息借钱给大企业做生意。</li>
</ul>
<h2>2、区块链+供应链金融</h2>
<p>面对，上述供应链里的中小微企业融资难问题，主要原因是银行和中小企业之间缺乏一个有效的信任机制。</p>
<p>假如供应链所有节点上链后，通过区块链的私钥签名技术，保证了核心企业等的数据可靠性；而合同、票据等上链，是对资产的数字化，便于流通，实现了价值传递。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187827?w=640&amp;h=365"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上图所示，在区块链解决了数据可靠性和价值流通后，银行等金融机构面对中小企业的融资，不再是对这个企业进行单独评估；而是站在整个供应链的顶端，通过信任核心企业的付款意愿，对链条上的票据、合同等交易信息进行全方位分析和评估。即借助核心企业的信用实力以及可靠的交易链条，为中小微企业融资背书，实现从单环节融资到全链条融资的跨越，从而缓解中小微企业融资难问题。</p>
<h2>3、应用案例</h2>
<p>比较成熟的还没看到，目前腾讯也已入局。</p>
<h1>五、应用场景5：跨境支付 -- 提高效率、降低费用</h1>
<h2>1、传统跨境支付</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187828?w=640&amp;h=381"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>跨境支付涉及多种币种，存在汇率问题，传统跨境支付非常依赖于第三方机构，大致的简化模型如上图所示，存在着两个问题；</p>
<ul>
<li>流程繁琐，结算周期长：传统跨境支付基本都是非实时的，银行日终进行交易的批量处理，通常一笔交易需要24小时以上才能完成；某些银行的跨境支付看起来是实时的，但实际上，是收款银行基于汇款银行的信用做了一定额度的垫付，在日终再进行资金清算和对账，业务处理速度慢。</li>
<li>手续费高：传统跨境支付模式存在大量人工对账操作，加之依赖第三方机构，导致手续费居高不下，麦肯锡《2016全球支付》报告数据显示，通过代理行模式完成一笔跨境支付的平均成本在25美元到35美元之间。</li>
</ul>
<h2>2、区块链+跨境支付</h2>
<p>这些问题的存在，很大原因还是信息不对称，没有建立有效的信任机制。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187829?w=640&amp;h=390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>如上图所示，区块链的引入，解决了跨境支付信息不对称的问题，并建立起一定程度的信任机制；带来了两个好处。</p>
<ul>
<li>效率提高，费用降低：接入区块链技术后，通过公私钥技术，保证数据的可靠性，再通过加密技术和去中心，达到数据不可篡改的目的，最后，通过P2P技术，实现点对点的结算；去除了传统中心转发，提高了效率，降低了成本(也展望了普及跨境小额支付的可能性)。</li>
<li>可追溯，符合监管需求：传统的点对点结算不能不规模应用，除了信任问题，还有就是存在监管漏洞（点对点私下交易，存在洗黑钱的风险），而区块链的交易透明，信息公开，交易记录永久保存实现了可追溯，符合监管的需求。</li>
</ul>
<h2>3、应用案例</h2>
<p>应用现状：Ripple、Circle、招商银行等已经入局。</p>
<h1>六、应用场景6：资产数字化 -- 便于资产流通</h1>
<h2>1、实体资产存在的问题</h2>
<ul>
<li>实体资产往往难以分割，不便于流通</li>
<li>实体资产的流通难以监控，存在洗黑钱等风险</li>
</ul>
<h2>2、区块链实现资产数字化</h2>
<ul>
<li>资产数字化后，易于分割、流通方便，交易成本低</li>
<li>用区块链技术实现资产数字化后，所有资产交易记录公开、透明、永久存储、可追溯，完全符合监管需求</li>
</ul>
<h2>3、应用案例</h2>
<p>还是以腾讯的微黄金应用为例，继续借用腾讯区块链官网（trustsql.qq.com）上的图片，可以看到，在资产数字化之后，流通更为方便了，不再依赖于发行机构；且购买0.001g黄金成为了可能，降低了参与门槛。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187830?w=640&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>七、应用场景7：代币 -- 去中介、去信任</h1>
<p>本来不像把代币加进来的，但说到区块链，始终绕不开代币；因区块链脱胎于比特币，天生具有代币的属性，目前区块链最成功的应用也正是比特币。</p>
<h2>1、传统货币存在的问题</h2>
<p>传统的货币发行权掌握在国家手中，存在着货币滥发的风险</p>
<ul>
<li>元朝自1271年建立后，依然四处征战，消耗大量的钱财和粮食，为了财政问题，长期滥发货币，造成严重通货膨胀，多数百姓生活在水生火热中，导致流民四起，国家大乱，1368年，不可一世的元朝成了只有97年短命鬼，走向了灭亡。</li>
<li>1980年津巴布韦独立，后因土改失败，经济崩溃，政府入不敷出，开始印钞；2001年时100津巴布韦币可兑换约1美元；2009年1月，津央行发行100万亿面值新津元（如下图）加速货币崩溃，最终津元被废弃，改用“美元化”货币政策。2017年津巴布韦发生政变，总统穆加贝被赶下台。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187831?w=640&amp;h=316"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>传统的记账权掌握在一个中心化的中介机构手中，存在中介系统瘫痪、中介违约、中介欺瞒、甚至是中介耍赖等风险。</p>
<p>2013年3月，塞浦路斯为获得救助，对银行储户进行一次性征税约58亿欧元, 向不低于10万欧元的存款一次性征税9.9%，向低于10万欧元的一次性征税6.75%。</p>
<p>2017年4月，民生银行30亿假理财事件暴露，系一支行行长伪造保本保息理财产品所致，超过150名投资者被套。</p>
<h2>2、区块链如何解决这些问题</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187832?w=640&amp;h=310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>比特币解决了货币在发行和记账环节的信任问题，我们来看下比特币是如何一一破解上面的两个问题。</p>
<p>滥发问题：比特币的获取只能通过挖矿获得，且比特币总量为2100万个，在发行环节解决了货币滥发的问题； 账本修改问题：比特币的交易记录通过链式存储和去中心化的全球节点构成网络来解决账本修改问题。</p>
<p>链式存储可以简单理解为：存储记录的块是一块连着一块的，形成一个链条；除第一个块的所有区块都的记录包含了前一区块的校验信息，改变任一区块的信息，都将导致后续区块校验出错。因为这种关联性，中间也无法插入其他块，所以修改已有记录是困难的。</p>
<p>而去中心化节点可以简单理解为：全球的中心节点都是平等的，都拥有一模一样的账本，所以，任一节点出问题都不影响账本记录。而要修改账本，必须修改超过全球一半的节点才能完成；而这在目前看来几乎不可能。 既然账本无法修改，那要是记账的时候作弊呢？ 首先，比特币的每条交易记录是有私钥签名的，别人伪造不了这个记录。你能修改的仅仅自己发起的交易记录。</p>
<p>其次，是关于记账权问题：比特币的记账权，通过工作量证明获得，可以简单理解为：通过算法确定同一时刻，全球只有一个节点获得了记账权，基本规律是谁拥有的计算资源越多，谁获得记账权的概率越大，只有超过全网一半的算力，才可能实现双花。</p>
<p>备注：比特币的模式是不可复制的，比特币已经吸引了全球绝大多数的算力，从而降低51%攻击发生等问题；其他的复制品基本无法获得相应的算力保证。</p>
<p>目前，比特币还存在着51%和效率低等问题有待解决，另外，关于交易本身的信任问题是个社会问题，比特币是没有解决的，也解决不了的。</p>
<h2>3、应用案例</h2>
<p>最具代表性的当然是比特币，也不用多说了。</p>
<p>备注：代币这块真的不看好，比特币目前吸引了全球绝大部分的算力，有独一无二的算力资源作为支撑还稍好一点，其他的代币和传统的货币相比，其背后缺乏国家和武力为其做信用背书，且夺取了国家发币带来的各种好处（如宏观调控），仔细想想就知道有多不靠谱。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187833?w=640&amp;h=417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>八、小结</h1>
<p>区块链应用的场景肯定还有很多，但很多都还不大明朗，暂时就先梳理以上7种场景，顺便归纳一下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014187834?w=640&amp;h=487"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>九、后话</h1>
<p>区块链这么火，但实际应用的案例却少之又少；我认为，并非区块链技术目前存在的问题阻碍了其大范围的应用，也不是区块链可以应用的场景非常少，区块链商用牵扯到各方的利益，其最大的难题可能远在技术之外。</p>
<p>此文已由作者授权腾讯云+社区发布，转载请注明<a href=""https://cloud.tencent.com/developer/article/1082599?fromSource=waitui"" rel=""nofollow noreferrer"">文章出处</a></p>
<p>原文链接：<a href=""https://cloud.tencent.com/developer/article/1082599?fromSource=waitui"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014106673?w=800&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>

                ", 拒绝“割韭菜”— 谈谈区块链正经的商用场景！,1531977897,129,1,306,1,1,https://segmentfault.com/a/1190000014187817
42,1,0,9,"
                    
<h2>写在前面</h2>
<p>不管是开发、测试、运维，每个技术人员心里多多少少都有一个成为技术大牛的梦，毕竟“梦想总是要有的，万一实现了呢”！正是对技术梦的追求，促使我们不断地努力和提升自己。<br>然而“梦想是美好的，现实却是残酷的”，很多同学在实际工作后就会发现，梦想是成为大牛，但做的事情看起来跟大牛都不沾边，例如，程序员说“天天写业务代码还加班，如何才能成为技术大牛”，测试说“每天都有执行不完的测试用例”，运维说“扛机器接网线敲shell命令，这不是我想要的运维人生”。<br>我也是一位程序员，所以我希望通过以下基于程序开发的一些例子，帮助大家解决这些困惑。大道理是相通的，测试、运维都可以借鉴。</p>
<h2>几个典型的误区</h2>
<p><strong>拜大牛为师</strong></p>
<p>有人认为想成为技术大牛最简单直接、快速有效的方式是“拜团队技术大牛为师”，让他们平时给你开小灶，给你分配一些有难度的任务。</p>
<p>我个人是反对这种方法的，主要的原因有几个：</p>
<ul>
<li>大牛很忙，不太可能单独给你开小灶，更不可能每天都给你开1个小时的小灶；而且一个团队里面，如果大牛平时经常给你开小灶，难免会引起其他团队成员的疑惑，我个人认为如果团队里的大牛如果真正有心的话，多给团队培训是最好的。然而做过培训的都知道，准备一场培训是很耗费时间的，课件和材料至少2个小时（还不能是碎片时间），讲解1个小时，大牛们一个月做一次培训已经是很高频了。</li>
<li>因为第一个原因，所以一般要找大牛，都是带着问题去请教或者探讨。因为回答或者探讨问题无需太多的时间，更多的是靠经验和积累，这种情况下大牛们都是很乐意的，毕竟影响力是大牛的一个重要指标嘛。然而也要特别注意：如果经常问那些书本或者google能够很容易查到的知识，大牛们也会很不耐烦的，毕竟时间宝贵。经常有网友问我诸如“jvm的-Xmn参数如何配置”这类问题，我都是直接回答“请直接去google”，因为这样的问题实在是太多了，如果自己不去系统学习，每个都要问是非常浪费自己和别人的时间的。</li>
<li>大牛不多，不太可能每个团队都有技术大牛，只能说团队里面会有比你水平高的人，即使他每天给你开小灶，最终你也只能提升到他的水平；而如果是跨团队的技术大牛，由于工作安排和分配的原因，直接请教和辅导的机会是比较少的，单凭参加几次大牛的培训，是不太可能就成为技术大牛的。</li>
</ul>
<p>综合上述的几个原因，我认为对于大部分人来说，要想成为技术大牛，首先还是要明白“主要靠自己”这个道理，不要期望有个像武功师傅一样的大牛手把手一步一步地教你。适当的时候可以通过请教大牛或者和大牛探讨来提升自己，但大部分时间还是自己系统性、有针对性的提升。</p>
<p><strong>业务代码一样很牛逼</strong></p>
<p>有人认为写业务代码一样可以很牛逼，理由是业务代码一样可以有各种技巧，例如可以使用封装和抽象使得业务代码更具可扩展性，可以通过和产品多交流以便更好的理解和实现业务，日志记录好了问题定位效率可以提升10倍等等。</p>
<p>业务代码一样有技术含量，这点是肯定的，业务代码中的技术是每个程序员的基础，但只是掌握了这些技巧，并不能成为技术大牛，就像游戏中升级打怪一样，开始打小怪，经验值很高，越到后面经验值越少，打小怪已经不能提升经验值了，这个时候就需要打一些更高级的怪，刷一些有挑战的副本了，没看到哪个游戏只要一直打小怪就能升到顶级的。成为技术大牛的路也是类似的，你要不断的提升自己的水平，然后面临更大的挑战，通过应对这些挑战从而使自己水平更上一级，然后如此往复，最终达到技术大牛甚至业界大牛的境界，写业务代码只是这个打怪升级路上的一个挑战而已，而且我认为是比较初级的一个挑战。</p>
<p>所以我认为：业务代码都写不好的程序员肯定无法成为技术大牛，但只把业务代码写好的程序员也还不能成为技术大牛。</p>
<p><strong>上班太忙没时间自己学习</strong></p>
<p>很多人认为自己没有成为技术大牛并不是自己不聪明，也不是自己不努力，而是中国的这个环境下，技术人员加班都太多了，导致自己没有额外的时间进行学习。</p>
<p>这个理由有一定的客观性，毕竟和欧美相比，我们的加班确实要多一些，但这个因素只是一个需要克服的问题，并不是不可逾越的鸿沟，毕竟我们身边还是有那么多的大牛也是在中国这个环境成长起来的。</p>
<p>我认为有几个误区导致了这种看法的形成：</p>
<p>1）上班做的都是重复工作，要想提升必须自己额外去学习</p>
<p>形成这个误区的主要原因还是在于认为“写业务代码是没有技术含量的”，而我现在上班就是写业务代码，所以我在工作中不能提升。</p>
<p>2）学习需要大段的连续时间</p>
<p>很多人以为要学习就要像学校上课一样，给你一整天时间来上课才算学习，而我们平时加班又比较多，周末累的只想睡懒觉，或者只想去看看电影打打游戏来放松，所以就没有时间学习了。</p>
<p>实际上的做法正好相反：首先我们应该在工作中学习和提升，因为学以致用或者有实例参考，学习的效果是最好的；其次工作后学习不需要大段时间，而是要挤出时间，利用时间碎片来学习。</p>
<h2>正确的做法</h2>
<p><strong>Do more</strong></p>
<p>做的更多，做的比你主管安排给你的任务更多。</p>
<p>我在HW的时候，负责一个版本的开发，这个版本的工作量大约是2000行左右，但是我除了做完这个功能，还将关联的功能全部掌握清楚了，代码（大约10000行）也全部看了一遍，做完这个版本后，我对这个版本相关的整套业务全部很熟悉了。经过一两次会议后，大家发现我对这块掌握最熟了，接下来就有趣了：产品讨论需求找我、测试有问题也找我、老大对外支撑也找我；后来，不是我负责的功能他们也找我，即使我当时不知道，我也会看代码或者找文档帮他们回答。最后我就成了我这个系统的“专家”了。虽然这个时候我还是做业务的，还是写业务代码，但是我已经对整个业务都很熟悉了。</p>
<p>以上只是一个简单的例子，其实就是想说：要想有机会，首先你得从人群中冒出来，要想冒出来，你就必须做到与众不同，要做到与众不同，你就要做得更多！</p>
<p>怎么做得更多呢？可以从以下几个方面着手：</p>
<p>1）熟悉更多业务，不管是不是你负责的；熟悉更多代码，不管是不是你写的</p>
<p>这样做有很多好处，举几个简单的例子：</p>
<ul>
<li>需求分析的时候更加准确，能够在需求阶段就识别风险、影响、难点</li>
<li>问题处理的时候更加快速，因为相关的业务和代码都熟悉，能够快速的判断问题可能的原因并进行排查处理</li>
<li>方案设计的时候考虑更加周全，由于有对全局业务的理解，能够设计出更好的方案</li>
</ul>
<p>2）熟悉端到端</p>
<p>比如说你负责web后台开发，但实际上用户发起一个http请求，要经过很多中间步骤才到你的服务器（例如浏览器缓存、DNS、nginx等），服务器一般又会经过很多处理才到你写的那部分代码（路由、权限等）这整个流程中的很多系统或者步骤，绝大部分人是不可能去参与写代码的，但掌握了这些知识对你的综合水平有很大作用，例如方案设计、线上故障处理这些更加有含金量的技术工作都需要综合技术水平。</p>
<p>“系统性”、“全局性”、“综合性”这些字眼看起来比较虚，但其实都是技术大牛的必备的素质，要达到这样的境界，必须去熟悉更多系统、业务、代码。</p>
<p>3）自学</p>
<p>一般在比较成熟的团队，由于框架或者组件已经进行了大量的封装，写业务代码所用到的技术确实也比较少，但我们要明白“唯一不变的只有变化”，框架有可能要改进，组件可能要替换，或者你换了一家公司，新公司既没有组件也没有框架，要你从头开始来做。这些都是机会，也是挑战，而机会和挑战只会分配给有准备的人，所以这种情况下我们更加需要自学更多东西，因为真正等到要用的时候再来学已经没有时间了。</p>
<p>以java为例，大部分业务代码就是if-else加个数据库操作，但我们完全可以自己学些更多java的知识，例如垃圾回收，调优，网络编程等，这些可能暂时没用，但真要用的时候，不是google一下就可以了，这个时候谁已经掌握了相关知识和技能，机会就是谁的。</p>
<p>以垃圾回收为例，我自己平时就抽时间学习了这些知识，学了1年都没用上，但后来用上了几次，每次都解决了卡死的大问题，而有的同学，写了几年的java代码，对于stop-the-world是什么概念都不知道，更不用说去优化了。</p>
<p><strong>Do better</strong></p>
<p>要知道这个世界上没有完美的东西，你负责的系统和业务，总有不合理和可以改进的地方，这些“不合理”和“可改进”的地方，都是更高级别的怪物，打完后能够增加更多的经验值。识别出这些地方，并且给出解决方案，然后向主管提出，一次不行两次，多提几次，只要有一次落地了，这就是你的机会。</p>
<p>例如：</p>
<ul>
<li>重复代码太多，是否可以引入设计模式？</li>
<li>系统性能一般，可否进行优化？</li>
<li>目前是单机，如果做成双机是否更好？</li>
<li>版本开发质量不高，是否引入高效的单元测试和集成测试方案？</li>
<li>目前的系统太庞大，是否可以通过重构和解耦改为3个系统？</li>
<li>阿里中间件有一些系统感觉我们也可以用，是否可以引入 ？</li>
</ul>
<p>只要你去想，其实总能发现可以改进的地方的；如果你觉得系统哪里都没有改进的地方，那就说明你的水平还不够，可以多学习相关技术，多看看业界其它优秀公司怎么做。</p>
<p>我2013年调配到九游，刚开始接手了一个简单的后台系统，每天就是配合前台做数据增删改查，看起来完全没意思，是吧？如果只做这些确实没意思，但我们接手后做了很多事情：</p>
<ul>
<li>解耦，将一个后台拆分为2个后台，提升可扩展性和稳定性；</li>
<li>双机，将单机改为双机系统，提高可靠性；</li>
<li>优化，将原来一个耗时5小时的接口优化为耗时5分钟</li>
</ul>
<p>还有其它很多优化，后来我们这个组承担了更多的系统，后来这个小组5个人，负责了6个系统。</p>
<p><strong>Do exercise</strong></p>
<p>在做职业等级沟通的时候，发现有很多同学确实也在尝试Do more、Do better，但在执行的过程中，几乎每个人都遇到同一个问题：光看不用效果很差，怎么办？</p>
<p>例如：</p>
<ul>
<li>学习了jvm的垃圾回收，但是线上比较少出现FGC导致的卡顿问题，就算出现了，恢复业务也是第一位的，不太可能线上出现问题然后让每个同学都去练一下手，那怎么去实践这些jvm的知识和技能呢？</li>
<li>我也看了，也了解了Reactor的原理，但是我不可能参与Netty开发，怎么去让自己真正掌握Reactor异步模式呢？</li>
<li>看了《高性能MySQL》，但是线上的数据库都是DBA管理的，测试环境的数据库感觉又是随便配置的，我怎么去验证这些技术呢？</li>
<li>框架封装了DAL层，数据库的访问我们都不需要操心，我们怎么去了解分库分表实现？</li>
</ul>
<p>诸如此类问题还有很多，我这里分享一下个人的经验，其实就是3个词：learning、trying、teaching！</p>
<p>1）Learning</p>
<p>这个是第一阶段，看书、google、看视频、看别人的博客都可以，但要注意一点是“系统化”，特别是一些基础性的东西，例如JVM原理、Java编程、网络编程，HTTP协议等等，这些基础技术不能只通过google或者博客学习，我的做法一般是先完整的看完一本书全面的了解，然后再通过google、视频、博客去有针对性的查找一些有疑问的地方，或者一些技巧。</p>
<p>2）Trying</p>
<p>这个步骤就是解答前面提到的很多同学的疑惑的关键点，形象来说就是“自己动手丰衣足食”，也就是自己去尝试搭建一些模拟环境，自己写一些测试程序。例如：</p>
<ul>
<li>垃圾回收：可以自己写一个简单的测试程序，分配内存不释放，然后调整各种jvm启动参数，再运行的过程中使用jstack、jstat等命令查看jvm的堆内存分布和垃圾回收情况。这样的程序写起来很简单，简单一点的就几行，复杂一点的也就几十行。</li>
<li>原理：自己真正去尝试写一个Reactor模式的Demo，不要以为这个很难，最简单的Reactor模式代码量（包括注释）不超过200行（可以参考Doug<br>  Lee的PPT）。自己写完后，再去看看netty怎么做，一对比理解就更加深刻了。</li>
<li>MySQL：既然有线上的配置可以参考，那可以直接让DBA将线上配置发给我们（注意去掉敏感信息），直接学习；然后自己搭建一个MySQL环境，用线上的配置启动；要知道很多同学用了很多年MySQL，但是连个简单的MySQL环境都搭不起来。</li>
<li>框架封装了DAL层：可以自己用JDBC尝试去写一个分库分表的简单实现，然后与框架的实现进行对比，看看差异在哪里。</li>
<li>用浏览器的工具查看HTTP缓存实现，看看不同种类的网站，不同类型的资源，具体是如何控制缓存的；也可以自己用Python写一个简单的HTTP服务器，模拟返回各种HTTP<br>  Headers来观察浏览器的反应。</li>
</ul>
<p>还有很多方法，这里就不一一列举，简单来说，就是要将学到的东西真正试试，才能理解更加深刻，印第安人有一句谚语：I hear and I forget. I see and I remember. I do and I understand ，而且“试试”其实可以比较简单，很多时候我们都可以自己动手做。</p>
<p>当然，如果能够在实际工作中使用，效果会更好，毕竟实际的线上环境和业务复杂度不是我们写个模拟程序就能够模拟的，但这样的机会可遇不可求，大部分情况我们还真的只能靠自己模拟，然后等到真正业务要用的时候，能够信手拈来</p>
<p>3）Teaching</p>
<p>一般来说，经过Learning和Trying，能掌握70%左右，但要真正掌握，我觉得一定要做到能够跟别人讲清楚。因为在讲的时候，我们既需要将一个知识点系统化，也需要考虑各种细节，这会促使我们进一步思考和学习。同时，讲出来后看或者听的人可以有不同的理解，或者有新的补充，这相当于继续完善了整个知识技能体系。</p>
<p>这样的例子很多，包括我自己写博客的时候经常遇到，本来我觉得自己已经掌握很全面了，但一写就发现很多点没考虑到；组内培训的时候也经常看到，有的同学写了PPT，但是讲的时候，大家一问，或者一讨论，就会发现很多点还没有讲清楚，或者有的点其实是理解错了。写PPT、讲PPT、讨论PPT，这个流程全部走一遍，基本上对一个知识点掌握就比较全面了。</p>
<h2>后记</h2>
<p>成为技术大牛梦想虽然很美好，但是要付出很多，不管是Do more还是Do better还是Do exercise，都需要花费时间和精力，这个过程中可能很苦逼，也可能很枯燥，这里我想特别强调一下：前面我讲的都是一些方法论的东西，但真正起决定作用的，其实还是我们对技术的热情和兴趣！</p>
<p>本文作者：李运华</p>
<p>详情请阅读<a href=""http://click.aliyun.com/m/45016/"" rel=""nofollow noreferrer"">原文</a></p>

                ", 如何快速成长为技术大牛？阿里资深技术专家的总结亮了,1531977898,128,1,639,1,1,https://segmentfault.com/a/1190000014135299
43,1,0,9,"
                    
<p>MySQL对于很多Linux从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。在进行MySQL的优化之前必须要了解的就是MySQL的查询过程，很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7mr8?w=565&amp;h=335"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>图 - MySQL查询过程</p>
<p>1.2 优化的哲学</p>
<p>优化有风险，涉足需谨慎</p>
<p>1.2.1 优化可能带来的问题</p>
<p>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统。</p>
<p>优化手段本来就有很大的风险，只不过你没能力意识到和预见到！</p>
<p>任何的技术可以解决一个问题，但必然存在带来一个问题的风险！</p>
<p>对于优化来说解决问题而带来的问题,控制在可接受的范围内才是有成果。</p>
<p>保持现状或出现更差的情况都是失败！</p>
<p>1.2.2 优化的需求</p>
<p>稳定性和业务可持续性,通常比性能更重要！</p>
<p>优化不可避免涉及到变更，变更就有风险！</p>
<p>优化使性能变好，维持和变差是等概率事件！</p>
<p>切记优化,应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化！</p>
<p>所以优化工作,是由业务需要驱使的！！！</p>
<p>1.2.3 优化由谁参与</p>
<p>在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。</p>
<p>1.3 优化思路</p>
<p>1.3.1 优化什么</p>
<p>在数据库优化上有两个主要方面：即安全与性能。</p>
<p>安全 ---&gt; 数据可持续性</p>
<p>性能 ---&gt; 数据的高性能访问</p>
<p>1.3.2 优化的范围有哪些</p>
<p>存储、主机和操作系统方面:</p>
<p>主机架构稳定性</p>
<p>I/O规划及配置</p>
<p>Swap交换分区</p>
<p>OS内核参数和网络问题</p>
<p>应用程序方面:</p>
<p>应用程序稳定性</p>
<p>SQL语句性能</p>
<p>串行访问资源</p>
<p>性能欠佳会话管理</p>
<p>这个应用适不适合用MySQL</p>
<p>数据库优化方面:</p>
<p>内存</p>
<p>数据库结构(物理&amp;逻辑)</p>
<p>实例配置</p>
<p>说明：不管是在，设计系统，定位问题还是优化，都可以按照这个顺序执行。</p>
<p>1.3.3 优化维度</p>
<p>数据库优化维度有四个:</p>
<p>硬件、系统配置、数据库表结构、SQL及索引</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7msg?w=558&amp;h=299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>优化选择</p>
<p>优化成本:硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引</p>
<p>优化效果:硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引</p>
<p>1.4 优化工具有啥？</p>
<p>1.4.1 数据库层面</p>
<p>检查问题常用工具</p>
<p>mysql msyqladmin mysql客户端，可进行管理操作 mysqlshow 功能强大的查看shell命令show [SESSION | GLOBAL] variables 查看数据库参数信息SHOW [SESSION | GLOBAL] STATUS 查看数据库的状态信息 information_schema 获取元数据的方法SHOW ENGINE INNODB STATUS Innodb引擎的所有状态SHOW PROCESSLIST 查看当前所有连接session状态explain 获取查询语句的执行计划show index 查看表的索引信息 slow-log 记录慢查询语句 mysqldumpslow 分析slowlog文件的<br>不常用但好用的工具</p>
<p>zabbix 监控主机、系统、数据库（部署zabbix监控平台） pt-query-digest 分析慢日志 mysqlslap 分析慢日志 sysbench 压力测试工具 mysql profiling 统计数据库整体状态工具 Performance Schema mysql性能状态统计的数据 workbench 管理、备份、监控、分析、优化工具（比较费资源）<br>1.4.2 数据库层面问题解决思路</p>
<p>一般应急调优的思路：</p>
<p>针对突然的业务办理卡顿，无法进行正常的业务处理！需要立马解决的场景！</p>
<p>1、show processlist</p>
<p>2、explain select id ,name from stu where name='clsn'; # ALL id name age sex</p>
<p>select id,name from stu where id=2-1 函数 结果集&gt;30;</p>
<p>show index from table;</p>
<p>3、通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题</p>
<p>4、show status like '%lock%'; # 查询锁状态</p>
<p>kill SESSION_ID; # 杀掉有问题的session</p>
<p>常规调优思路：</p>
<p>针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。</p>
<p>1、查看slowlog，分析slowlog，分析出查询慢的语句。</p>
<p>2、按照一定优先级，进行一个一个的排查所有慢语句。</p>
<p>3、分析top sql，进行explain调试，查看语句执行时间。</p>
<p>4、调整索引或语句本身。</p>
<p>1.4.3 系统层面</p>
<p>cpu方面</p>
<p>vmstat、sar top、htop、nmon、mpstat<br>内存</p>
<p>free 、ps -aux 、<br>IO设备（磁盘、网络）</p>
<p>iostat 、 ss 、 netstat 、 iptraf、iftop、lsof、<br>vmstat 命令说明：</p>
<p>Procs：r显示有多少进程正在等待CPU时间。b显示处于不可中断的休眠的进程数量。在等待I/O</p>
<p>Memory：swpd显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量</p>
<p>想要了解更多性能优化知识的，可以加群：650385180</p>
<p>Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1和s0最好是0</p>
<p>Io：每秒从设备中读入b1的写入到设备b0的数据块的数量。反映了磁盘I/O</p>
<p>System：显示了每秒发生中断的数量(in)和上下文交换(cs)的数量</p>
<p>Cpu：显示用于运行用户代码，系统代码，空闲，等待I/O的CPU时间</p>
<p>iostat命令说明</p>
<p>实例命令： iostat -dk 1 5</p>
<p>iostat -d -k -x 5 （查看设备使用率（%util）和响应时间（await））</p>
<p>tps：该设备每秒的传输次数。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。</p>
<p>iops ：硬件出厂的时候，厂家定义的一个每秒最大的IO次数</p>
<p>""一次传输""请求的大小是未知的。</p>
<p>kB_read/s：每秒从设备（drive expressed）读取的数据量；</p>
<p>KB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</p>
<p>kB_read：读取的总数据量；</p>
<p>kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</p>
<p>1.4.4 系统层面问题解决办法</p>
<p>你认为到底负载高好，还是低好呢？</p>
<p>在实际的生产中，一般认为 cpu只要不超过90%都没什么问题 。</p>
<p>当然不排除下面这些特殊情况：</p>
<p>问题一：cpu负载高，IO负载低</p>
<p>内存不够</p>
<p>磁盘性能差</p>
<p>SQL问题 ------&gt;去数据库层，进一步排查sql问题</p>
<p>IO出问题了（磁盘到临界了、raid设计不好、raid降级、锁、在单位时间内tps过高）</p>
<p>tps过高: 大量的小数据IO、大量的全表扫描</p>
<p>问题二：IO负载高，cpu负载低</p>
<p>大量小的IO 写操作：</p>
<p>autocommit ，产生大量小IO</p>
<p>IO/PS,磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的IO次数。</p>
<p>大量大的IO 写操作</p>
<p>SQL问题的几率比较大</p>
<p>问题三：IO和cpu负载都很高</p>
<p>硬件不够了或sql存在问题</p>
<p>1.5 基础优化</p>
<p>1.5.1 优化思路</p>
<p>定位问题点吮吸</p>
<p>硬件 --&gt; 系统 --&gt; 应用 --&gt; 数据库 --&gt; 架构（高可用、读写分离、分库分表）</p>
<p>处理方向</p>
<p>明确优化目标、性能和安全的折中、防患未然</p>
<p>1.5.2 硬件优化</p>
<p>主机方面：</p>
<p>根据数据库类型，主机CPU选择、内存容量选择、磁盘选择</p>
<p>平衡内存和磁盘资源</p>
<p>随机的I/O和顺序的I/O</p>
<p>主机 RAID卡的BBU(Battery Backup Unit)关闭</p>
<p>cpu的选择：</p>
<p>cpu的两个关键因素：核数、主频</p>
<p>根据不同的业务类型进行选择：</p>
<p>cpu密集型：计算比较多，OLTP 主频很高的cpu、核数还要多</p>
<p>IO密集型：查询比较，OLAP 核数要多，主频不一定高的</p>
<p>内存的选择：</p>
<p>OLAP类型数据库，需要更多内存，和数据获取量级有关。</p>
<p>OLTP类型数据一般内存是cpu核心数量的2倍到4倍，没有最佳实践。</p>
<p>存储方面：</p>
<p>根据存储数据种类的不同，选择不同的存储设备</p>
<p>配置合理的RAID级别(raid5、raid10、热备盘)</p>
<p>对与操作系统来讲，不需要太特殊的选择，最好做好冗余（raid1）（ssd、sas 、sata）</p>
<p>raid卡：主机raid卡选择：</p>
<p>实现操作系统磁盘的冗余（raid1）</p>
<p>平衡内存和磁盘资源</p>
<p>随机的I/O和顺序的I/O</p>
<p>主机 RAID卡的BBU(Battery Backup Unit)要关闭。</p>
<p>网络设备方面：</p>
<p>使用流量支持更高的网络设备（交换机、路由器、网线、网卡、HBA卡）</p>
<p>注意：以上这些规划应该在初始设计系统时就应该考虑好。</p>
<p>1.5.3 服务器硬件优化</p>
<p>1、物理状态灯：</p>
<p>2、自带管理设备：远程控制卡（FENCE设备：ipmi ilo idarc），开关机、硬件监控。</p>
<p>3、第三方的监控软件、设备（snmp、agent）对物理设施进行监控</p>
<p>4、存储设备：自带的监控平台。EMC2（hp收购了）， 日立（hds），IBM低端OEM hds，高端存储是自己技术，华为存储</p>
<p>1.5.4 系统优化</p>
<p>Cpu：</p>
<p>基本不需要调整，在硬件选择方面下功夫即可。</p>
<p>内存：</p>
<p>基本不需要调整，在硬件选择方面下功夫即可。</p>
<p>SWAP：</p>
<p>MySQL尽量避免使用swap。</p>
<p>阿里云的服务器中默认swap为0</p>
<p>IO ：</p>
<p>raid、no lvm、 ext4或xfs、ssd、IO调度策略</p>
<p>Swap调整(不使用swap分区)</p>
<p>/proc/sys/vm/swappiness的内容改成0（临时），/etc/sysctl.conf上添加vm.swappiness=0（永久）<br>这个参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。</p>
<p>当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。</p>
<p>修改MySQL的配置参数innodb_flush_method，开启O_DIRECT模式。</p>
<p>这种情况下，InnoDB的buffer pool会直接绕过文件系统cache来访问磁盘，但是redo log依旧会使用文件系统cache。</p>
<p>值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多</p>
<p>IO调度策略</p>
<h1>echo deadline&gt;/sys/block/sda/queue/scheduler 临时修改为deadline</h1>
<p>永久修改</p>
<p>vi /boot/grub/grub.conf<br>更改到如下内容:</p>
<p>kernel /boot/vmlinuz-2.6.18-8.el5 ro root=LABEL=/ elevator=deadline rhgb quiet<br>1.5.5 系统参数调整</p>
<p>Linux系统内核参数优化</p>
<p>vim /etc/sysctl.conf net.ipv4.ip_local_port_range = 1024 65535 # 用户端口范围  net.ipv4.tcp_max_syn_backlog = 4096 net.ipv4.tcp_fin_timeout = 30 fs.file-max=65535 # 系统最大文件句柄，控制的是能打开文件最大数量<br>用户限制参数（mysql可以不设置以下配置）</p>
<p>vim /etc/security/limits.conf  <em> soft nproc 65535   </em> hard nproc 65535   <em> soft nofile 65535   </em> hard nofile 65535<br>1.5.6 应用优化</p>
<p>业务应用和数据库应用独立,</p>
<p>防火墙：iptables、selinux等其他无用服务(关闭)：</p>
<p>chkconfig --level 23456 acpid off chkconfig --level 23456 anacron off chkconfig --level 23456 autofs off chkconfig --level 23456 avahi-daemon off chkconfig --level 23456 bluetooth off chkconfig --level 23456 cups off chkconfig --level 23456 firstboot off chkconfig --level 23456 haldaemon off chkconfig --level 23456 hplip off chkconfig --level 23456 ip6tables off chkconfig --level 23456 iptables off chkconfig --level 23456 isdn off chkconfig --level 23456 pcscd off chkconfig --level 23456 sendmail off chkconfig --level 23456 yum-updatesd off<br>安装图形界面的服务器不要启动图形界面 runlevel 3</p>
<p>另外，思考将来我们的业务是否真的需要MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p>
<p>1.6 数据库优化</p>
<p>SQL优化方向：</p>
<p>执行计划、索引、SQL改写</p>
<p>架构优化方向：</p>
<p>高可用架构、高性能架构、分库分表</p>
<p>1.6.1 数据库参数优化</p>
<p>调整：</p>
<p>实例整体（高级优化，扩展）：</p>
<p>thread_concurrency # 并发线程数量个数 sort_buffer_size # 排序缓存 read_buffer_size # 顺序读取缓存 read_rnd_buffer_size # 随机读取缓存 key_buffer_size # 索引缓存 thread_cache_size # (1G—&gt;8, 2G—&gt;16, 3G—&gt;32, &gt;3G—&gt;64)<br>连接层（基础优化）</p>
<p>设置合理的连接客户和连接方式</p>
<p>max_connections # 最大连接数，看交易笔数设置 max_connect_errors # 最大错误连接数，能大则大 connect_timeout # 连接超时 max_user_connections # 最大用户连接数 skip-name-resolve # 跳过域名解析 wait_timeout # 等待超时 back_log # 可以在堆栈中的连接数量<br>SQL层（基础优化）</p>
<p>query_cache_size： 查询缓存</p>
<blockquote><blockquote></blockquote></blockquote>
<p>OLAP类型数据库,需要重点加大此内存缓存，</p>
<p>但是一般不会超过GB</p>
<p>对于经常被修改的数据，缓存会立马失效。</p>
<p>我们可以实用内存数据库（redis、memecache），替代他的功能。</p>
<p>1.6.2 存储引擎层（innodb基础优化参数）</p>
<p>default-storage-engine innodb_buffer_pool_size # 没有固定大小，50%测试值，看看情况再微调。但是尽量设置不要超过物理内存70% innodb_file_per_table=(1,0) innodb_flush_log_at_trx_commit=(0,1,2) # 1是最安全的，0是性能最高，2折中 binlog_sync Innodb_flush_method=(O_DIRECT, fdatasync) innodb_log_buffer_size # 100M以下 innodb_log_file_size # 100M 以下 innodb_log_files_in_group # 5个成员以下,一般2-3个够用（iblogfile0-N） innodb_max_dirty_pages_pct # 达到百分之75的时候刷写 内存脏页到磁盘。 log_bin max_binlog_cache_size # 可以不设置 max_binlog_size # 可以不设置 innodb_additional_mem_pool_size #小于2G内存的机器，推荐值是20M。32G内存以上100M</p>
<p>1.6.3 想要了解更多性能优化知识的，可以关注我，后续也会给大家整理出来一份系统的关于性能优化的知识脑图，另外顺便给大家推荐一个交流学习群：650385180，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多，以下的结构体系图也是在群里获取。<br><span class=""img-wrap""><img data-src=""/img/bV53qt?w=677&amp;h=341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>1.7 参考文献</p>
<p>[1] <a href=""https://www.cnblogs.com/zishengY/p/6892345.html"" rel=""nofollow noreferrer"">https://www.cnblogs.com/zishe...</a></p>
<p>[2] <a href=""https://www.jianshu.com/p/d7665192aaaf"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/d76...</a></p>
<p>总结：以上就是我要说的写的内容，希望上面的内容可以帮助到正在默默艰辛，遇到瓶疾且不知道怎么办的Java程序员们，我能帮你的只有这么多了，关于MySQL性能调优的知识点已经总结完了，我能帮的，也只有这么多了，希望大家在往后的工作与面试中，一切顺利。</p>

                ", 性能优化之MySQL调优篇,1531977900,519,1,751,1,1,https://segmentfault.com/a/1190000014108616
44,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV7kd4?w=500&amp;h=253"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>一、分布式的两大场景</p>
<p>数据存储的分布式</p>
<p>服务的分布式</p>
<p>二、数据存储的分布式</p>
<p>比如海量数据，单机存储不下，需要多机，以集群的方式存储，即为数据的分布式存储，数据存储的分布式一般涉及如下几个方面</p>
<p>数据的分片策略</p>
<p>全局主键的实现机制</p>
<p>跨结点数据的聚合</p>
<p>分布式事务</p>
<p>数据容灾机制</p>
<p>2.1数据分片策略</p>
<p>2.1.1 基于数据范围来分</p>
<p>比如库1,存放id 1到1000w的数据，库2存放id 1000w到2000w的数据</p>
<p>优点 ：</p>
<p>单库数据规模提前预估。超规模后，加机器，不需要迁移数据。</p>
<p>且相邻数据大都存放在一个库上，查询时，可以减少跨库聚合。</p>
<p>缺点</p>
<p>容易出现热点数据，比如项目初期，只有库1被高频率访问</p>
<p>待解决问题 ：业务变更导致部分数据被删除后，如何做到数据容量的在平衡。一般也不用考虑这个问题。空间不值钱。</p>
<p>2.1.2 基于id hash来分</p>
<p>优点 ：hash分配，数据分布均匀不会出现数据热点问题</p>
<p>缺点</p>
<p>数据的查询聚合可能需要频繁跨库。解决办法：hash算法和用于计算hash的key去保证，将业务关心的数据分片到同一库，甚至同一张表</p>
<p>集群扩容时，会导致重新hash。可能面临部分数据的迁移</p>
<p>2.1.3 怎么解决扩容时，数据重新hash的问题</p>
<p>方法来至于58沈剑。主要思想：分布式存储的每个库，出于数据可用性的考虑，设置一个主从库，这使得一份数据，有两份存储。扩容时，将每个从库，变成主库。于是容量就扩容了一倍，修改后的hash算法，依然能正确路由。同时由于新的主库包含了完整的数据，所以不需要做数据迁移，只需要做冗余数据的清理。图例如下：</p>
<p>扩容之前的状态</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keh?w=560&amp;h=148"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>扩容，将从变主。%2=0的库，会变为%4=0与%4=2 。%2=1的部分，会变为%4=1与%4=3;</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7kek?w=588&amp;h=215"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>对扩容后的所有主数据库，新增从库，方便下次的翻倍扩容。删除冗余数据</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7kel?w=550&amp;h=273"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.2全局主键的实现机制</p>
<p>snowflake</p>
<p>2.3跨结点数据的聚合</p>
<p>对于跨节点聚合有两种思路，一是通过现有数据库，从查询算法上考虑。第二种，对于过于复杂的聚合统计查询，使用外置索引来实现，比如elasticsearch</p>
<p>第一种，几种跨库分页的方式</p>
<p><a href=""http://www.10tiao.com/html/249/201702/2651959942/1.html"" rel=""nofollow noreferrer"">http://www.10tiao.com/html/24...</a></p>
<p>第二种，索引外置，比如使用elasticsearch。参看elasticsearch 原理</p>
<p>三、服务的分布式</p>
<p>服务的分布式，一般涉及如下几个方面</p>
<p>服务注册</p>
<p>服务发现</p>
<p>负载均衡</p>
<p>分布式事务</p>
<p>服务的降级熔断</p>
<p>3.1服务的注册</p>
<p>3.2服务的发现</p>
<p>3.3负载均衡</p>
<p>以上三点的大概模式，可以参看之前的笔记微服务的注册与发现 <a href=""https://chen-jun.me/wei-fu-wu-de-zhu-ce-yu-fa-xian/"" rel=""nofollow noreferrer"">https://chen-jun.me/wei-fu-wu...</a></p>
<p>3.4分布式事务</p>
<p>3.5服务的降级熔断</p>
<p>服务的降级熔断，可以在两方面做文章。比如A服务调用B服务。当B服务处理失败，导致A服务故障时。在A端，可以设置熔断，当故障率达到一定，A服务可以有一个默认值，不在调用B服务。B服务本身，也可以在A调用自己出故障时，不走计算流程，直接返回一个默认值。这方面的框架有Spring Cloud Hystrix</p>
<p>Spring Cloud Hystrix是基于Netflix的开源框架Hystrix实现，该框架实现了服务熔断、线程隔离等一系列服务保护功能。</p>
<p>对于熔断机制的实现，Hystrix设计了三种状态：</p>
<p>1.熔断关闭状态（Closed）</p>
<p>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。</p>
<p>2.熔断开启状态（Open）</p>
<p>在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。</p>
<p>3.半熔断状态（Half-Open）</p>
<p>在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。</p>
<p>关系转换图如下</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7kem?w=619&amp;h=370"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>四、 分布式事务</p>
<p>4.1 CAP理论</p>
<p>CAP理论是 Eric Brewer提出的一种分布式状况下，面临的三个无法同时兼顾的问题</p>
<p>Consistency所有分布式节点，对同一份数据，拥有相同的副本。不会出现数据不一致的情况</p>
<p>Availability对数据的更新和读写，具有高可用性。即服务不能无响应，或出错</p>
<p>Partition Tolerance分区的容忍性，这里的分区不是指数据分布式存储中的shard分区。而是指，由于诸如网络等原因，导致分布式节点之间，无法正常同性时，导致的结点隔离，成为分区。在分区时，整个系统还能允许多大程度的对外服务，成为分区容忍性。</p>
<p>假设一个分布式系统中，有两个节点，处于分区状态。若允许分区中节点可以更新数据，那么会丧失一致性 C 。如果要保证一致性 C ，那处于分区状态的节点将不允许提供服务，这又会丧失可用性 A 。如果一定要保证 CA ，必须保证节点之间能够互相通信，那分区就不能容忍，就无从谈起分区容忍性 P</p>
<p>Eric Brewer提出，在分布式环境下，一个系统只能同时满足以上两点特性，而无法同时满足所有特性。在大多数的分布式系统设计中，人们多会选择满足 AP 两点特性。而放弃强一致性，转而追求最终一致性。这种选择还有另外一个描述叫： B asically A vailable, S oft-state, E ventually consistent 简称 BASE</p>
<p>以上CAP理论的简洁抽象，容易让人们大概理解分布式系统中的难处，但也容易产生一些误导。那就是CAP中的3选2，并不是绝对的。所有Eric Brewer后来又做了一次澄清解释。为什么有误导？</p>
<p>1、很多时候，如果我们不能保证P，那CA也无从谈起</p>
<p>比如用户是通过html访问服务的，这个服务对应的节点，出现分区，导致html都无法访问时。那CA 就不用提了。只有在html能在客户端缓存，支持用户离线模式，才可以说系统保证了 P ,同时保证了 A</p>
<p>2、保证AP,并不是完全放弃C，当恢复分区时，我们依然要采取各种方式解决分区导致的不一致。</p>
<p>由于网络延迟，或网络断连，甚至一个写请求，同步至所有节点，由于节点跨机房，写完成的时间不同步，都可能导致分区。只是分区的时间长短不一而已。为了解决最终的一致性，这就涉及到分布式事务。对于分布式数据库中，某个值的写，保证其一致性，可以使用paxos,raft协议算法。对于业务类型的事务。可以使用TCC或者消息通知的模式来进行事务管理</p>
<p>4.2 最终一致性方案——paxos,raft</p>
<p>zookeeper就是使用的paxos协议</p>
<p>4.3最终一致性方案——TCC</p>
<p>分为 T ry , C onfirm, C ancel ，简称TCC。</p>
<p>Try:尝试锁定事务涉及的资源，进行资源预留</p>
<p>Confirm:对预留的资源做确认提交</p>
<p>Cancel:如果confirm失败，则进行补偿操作，回滚业务处理，解锁预留资源</p>
<p>可以看到这种，try , confrm/cancel。也是两阶段。那跟传统JAT支持的两阶段事务有什么区别？</p>
<p>JTA支持的传统两阶段事务，需要涉及的资源支持XA协议标准，但TCC则需要遵循什么工业标准，可以是完全的业务实现。传统的两阶段提交，任然要求满足事务的ACID，这导致资源的可用性很差。</p>
<p>传统两阶段提交的特点：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7kev?w=587&amp;h=426"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keA?w=582&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>TCC事务的特点：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keB?w=595&amp;h=420"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4.4 最终一致性方案——消息通知</p>
<p>这类事务的特点是，需要借助消息通知，来使得事务涉及的多个分布式服务能够协调，完成业务期望。这种方式，也有几种细分的设计。</p>
<p>4.4.1 使用本地事务</p>
<p>同一个共用的消息表，来协调服务双方的业务执行状况</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keR?w=579&amp;h=289"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4.4.2 使用MQ</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keU?w=540&amp;h=390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4.4.3 另外一种使用MQ的方式</p>
<p><span class=""img-wrap""><img data-src=""/img/bV7keV?w=564&amp;h=408"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>想要了解更多分布式知识点的，可以关注我一下，我后续也会整理更多关于分布式架构这一块的知识点分享出来<br><span class=""img-wrap""><img data-src=""/img/bV7kdd?w=638&amp;h=559"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 干货：分布式系统学习笔记,1531977901,530,1,708,1,1,https://segmentfault.com/a/1190000014100096
45,1,0,9,"
                    
<p><em>原文地址： <a href=""https://www.quora.com/Despite-getting-very-high-marks-in-programming-85-100-my-professor-told-me-that-programming-is-not-for-me-He-has-even-commented-that-I-am-a-great-coder-Why-would-he-say-this-if-I-have-done-so-well"" rel=""nofollow noreferrer"">https://www.quora.com/Despite...</a></em></p>
<h2>问：</h2>
<p>Despite getting very high marks in programming (85 - 100), my professor told me that programming is not for me. He has even commented that I am a great coder. Why would he say this if I have done so well?</p>
<p>虽然我在编程课程里能拿到很高的分数（85-100），但我的教授却说我不适合编程，尽管他都承认我编码水平很不错了。我搞不懂，为什么我做得这么好了他却说这样的话？</p>
<h2>答：</h2>
<p>I’m gonna be up front and honest here, because this is the biggest problem I see with beginners/students coming into software development these days.</p>
<p><strong>IT’S NOT ABOUT THE CODE, OR YOUR ABILITY TO WRITE IT.</strong></p>
<blockquote>我得站出来跟你说实话。因为就我所见，如今在软件开发这块，初学者和学生遇到的最大的问题就是这个问题：<br><strong>你是否适合编程，这个事情跟你写出来的代码水平无关，也跟你能写代码的能力无关。</strong>
</blockquote>
<p>It’s very likely that while you might be very good at writing code, your professor spotted traits in your performance that would have meant you where no good at the soft skills.</p>
<p>A good software developer needs way more than just the ability to write good code. Here are some examples, of the skills you’ll need, in no particular order:</p>
<blockquote>我觉得很有可能，你的编码能力强，在教授眼里这是你的一个很突出的特点，但这恰好说明你在其他的软性技能方面非常欠缺。<br>一个好的开发者，光擅长写代码是不够的。我这里给出一些例子，这都是你以后还要学会的技能（顺序无关）：</blockquote>
<ol>
<li>The ability to disassemble a given problem domain down into it’s individual parts.</li>
<li>The ability to communicate very technical subjects, in simple English like terminology to non technical people.</li>
<li>The ability to think in an insanely and focused logical way.</li>
<li>The ability to look at any given scenario for a 1000ft view point and understand a bigger picture as a whole.</li>
<li>The ability to understand communications principles, not just digital ones but human ones too.</li>
<li>The ability to think in parallel while still keeping track on a given single solution point.</li>
<li>The ability to look at the many tools (Not just code) you have and decide what’s better to use to build a solution.</li>
<li>An innate ability to problem solve, on your feet, and in a very short space of time.</li>
<li>The ability to judge how long it will take to reach a conclusion, based on any given premise.</li>
<li>The ability to use multiple tools, in multiple places, along side each other, and in teams with multiple people.</li>
</ol>
<blockquote><ol>
<li>将问题分解，分而治之的能力；</li>
<li>以浅显易懂的方式，同非专业人士讨论技术话题的能力；</li>
<li>以常人所不能的、极端专注的逻辑思维方式进行思考的能力；</li>
<li>总揽全局、全盘思考、站在 1000 英尺高度理解问题的能力；</li>
<li>不但知道如何跟机器打交道，也要了解如何跟人打交道的能力；</li>
<li>在保持跟进单个解决方案的同时，时刻保持发散思维的能力；</li>
<li>审视众多可用的工具（不仅仅是代码）、并得出更好的解决方案的能力；</li>
<li>像有天赋一般的，立刻、快速的解决问题的能力；</li>
<li>在任何前提下都能判断、花多长时间能达成结论的能力；</li>
<li>在不同的地方、使用多种工具、同多个人一起，在团队中彼此协作的能力。</li>
</ol></blockquote>
<p>I could go on for another 10. Heck, I could go on for another 50 if I needed to.</p>
<p>The point is, a software developers life is about far more than just slinging out some code.</p>
<p>Many beginners fail to realize this.</p>
<p>Software development is a very hard career, and you never truly stop learning.</p>
<p>What you’ve learned so far, is ONLY the BEGINNING.</p>
<blockquote>这还远远不够，我还能再列十条、再列五十条都行。 <br>比起光写代码来，开发者的生涯所包含的内涵要多太多太多。这就是问题所在。<br>而很多初学者都是没办法意识到这个问题的。 <br>软件开发是一条艰难的路，你走上这条路，就不会停止学习。<br>你现在学到的，仅仅是万里长征第一步。</blockquote>
<p>You’ll spend the rest of your life, learning on the job, making new discoveries as you go along.</p>
<p>You’ll have very, very long periods where you have to concentrate and focus on what your doing, so hard that it almost hurts.</p>
<p>Burnout from this intense study &amp; concentration is an all too real problem with beginners, and many don’t make it more than a couple of years before they give up.</p>
<p>A good professor knows ALL OF THIS, especially if he’s been in the industry and on the front lines himself.</p>
<p>He’ll know what makes a good developer, and what doesn’t.</p>
<blockquote>当你走上这条路，你的余生都要花在不断的学习和发现上。<br>很多时候，你都必须在当前的问题上极其专注，哪怕让你痛苦不堪你也不能放弃。<br>初学者的热情很快就会被这种现实的困难消耗殆尽，很多人坚持不了几年就会放弃。<br>好的教授完全理解问题的所在，特别是有过从业经验，从事过一线开发的教授。<br>他懂得好的开发者需要哪些特质，以及不需要哪些特质。</blockquote>
<p>I routinely have to dish out similar advises to the students I teach, but I don’t do it with Malice, I do it because they need to hear the truth, and know what there going to walk into.</p>
<p>What you NEED TO DO, is ask your professor why he thinks you won’t make a good software developer, ask him to be 100% honest.</p>
<p>What he tells you might hurt, but the only way your going to know where you need to spend time improving is if he tells you.</p>
<blockquote>我对我的学生也是经常给出类似告诫。我这么做绝无恶意，我只想告诉他们真相，让他们看清自己要面对的是什么。<br>而<strong>你要做的</strong>，就是向教授问清楚，他为什么觉得你不适合做开发。你要诚心诚意的去问。<br>他的回答可能会伤你自尊，但只有这样你才能知道自己哪些地方需要改进。</blockquote>
<p>I see amazing coders all the time, but a great many of them simply do not have the mental discipline to sit for 18 hours and chew through solving a problem presented to them, from start to finish.</p>
<p>I see loads of silly students, who come to do “computers” cause they think it’s a laugh, many of them couldn’t code to save their life, but give them something that interests them, and let them get stuck in, and their ability to hammer down on the task and see it through, is incredible.</p>
<p>No one is trying to belittle you or destroy your self confidence, their just trying to prepare you for what’s about to come, and mark my words, when you get out there into the real world, it’ll hit you head on, like a 20 ton truck!!!</p>
<blockquote>我见过不少很棒的开发者，但是他们当中太多人也没有足够的毅力坐着花 18 个小时从头到尾来把问题嚼烂解决。<br>我也见过很笨的学生，因为觉得好玩就来“学电脑”。不少人没办法靠写代码为生，但他们只要对某事有兴趣，并且有机会钻进去，那么他们在问题面前，能展现出令人难以置信的执行力。<br>没人要贬低你或伤你的自尊，他们是帮你为面对将来的困难做准备。记住我的话：当你完成学业真正进入软件行业时，这些困难会像 20 吨的卡车一样砸在你头上！！！</blockquote>

                ", 【译】Quora 问答：为什么老师说我不适合编程？,1531977902,482,1,627,1,1,https://segmentfault.com/a/1190000014099544
46,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014076586?w=1920&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""nature-3054445_1920"" title=""nature-3054445_1920""></span></p>
<h3>前提</h3>
<p>好几周没更新博客了，对不断支持我博客的童鞋们说声：“抱歉了！”。自己这段时间确实比较忙，而且还在抽空完成学校的毕业设计。今天晚上抽空把大学期间写过的博客弄一个系列文章合集，算是对大学这四年的一个总结，证明自己没白过。</p>
<p>&lt;!-- more --&gt;</p>
<p>熟悉我的人都知道我写博客的时间比较早，而且坚持的时间也比较久，一直到现在也是一直保持着更新状态。最早最早开始写博客是在 CSDN 上写的，然后在简书也写过一段时间，后来放弃了简书转战了掘金，以下图片是自己在掘金这一年的成果，快 <strong>1.5 万</strong>关注了，哈哈哈。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014076587?w=2048&amp;h=658"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""21"" title=""21""></span></p>
<p>去年过年前还收到掘金送来的专属礼物，真是激动，感谢掘金，希望越办越好！</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014076588?w=2048&amp;h=2731"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IMG_20180206_125142"" title=""IMG_20180206_125142""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014076589?w=2048&amp;h=2731"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IMG_20180206_125159"" title=""IMG_20180206_125159""></span></p>
<p>细数文章后，发现自己在实习的这段时间写的博客也挺多的，而且质量还比较高，经常上开发者头条、掘金等平台的首页推荐。在此，感谢实习期间组内大佬们的各种帮助！</p>
<p>这里再次说下写博客的好处：</p>
<ul>
<li>很好的用来总结自己所学的知识</li>
<li>遇到那么一群也写博客的大佬，有共同话题聊了</li>
<li>面试加分（在简历上放上自己的个人网站链接，面试官就可以更好的了解你，知道你所学知识的深度和广度）</li>
</ul>
<p>不要小看你的每一篇不起眼博客，用一个蚂蚁金服大佬跟我说的话叫做：<strong>厚积薄发</strong>！</p>
<p>不多说了，如果想和我交流的可以加我 qq 群：<strong>528776268</strong>    和我的微信：<strong>zhisheng_tian</strong></p>
<h3>关注我</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012730965?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>转载请务必注明原创地址为：<a href=""http://www.54tianzhisheng.cn/2018/03/27/blogs/"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/2018/03/27/blogs/</a></p>
<h3>系列文章合集</h3>
<h4><strong>Spring Boot 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/"" rel=""nofollow noreferrer"">Spring Boot系列文章（一）：SpringBoot Kafka 整合使用</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/"" rel=""nofollow noreferrer"">Spring Boot系列文章（二）：SpringBoot Admin 使用指南</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/"" rel=""nofollow noreferrer"">Spring Boot系列文章（三）：SpringBoot RabbitMQ 整合使用</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/"" rel=""nofollow noreferrer"">Spring Boot系列文章（四）：SpringBoot ActiveMQ 整合使用</a></p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/"" rel=""nofollow noreferrer"">Spring Boot系列文章（五）：SpringBoot RabbitMQ 整合进阶版</a></p>
<p>6、<a href=""http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/"" rel=""nofollow noreferrer"">Spring Boot系列文章（六）：SpringBoot RocketMQ 整合使用和监控</a></p>
<p>7、更多请期待</p>
<h4><strong>Spring Boot 2.0 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/"" rel=""nofollow noreferrer"">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/"" rel=""nofollow noreferrer"">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解</a></p>
<p>3、后面绝对有更多文章出现的</p>
<h4><strong>Docker 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/11/26/Docker-harbor/"" rel=""nofollow noreferrer"">Docker系列文章（一）：基于 Harbor 搭建 Docker 私有镜像仓库</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2018/01/25/Docker-install/"" rel=""nofollow noreferrer"">Docker系列文章（二）：Mac 安装 Docker 及常用命令</a></p>
<p>3、同样，后面也会持续更新</p>
<h4><strong>ElasticSearch 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/09/08/Elasticsearch-analyzers/"" rel=""nofollow noreferrer"">Elasticsearch 系列文章（一）：Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a></p>
<p>2、 <a href=""http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/"" rel=""nofollow noreferrer"">Elasticsearch 系列文章（二）：全文搜索引擎 Elasticsearch 集群搭建入门教程</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/"" rel=""nofollow noreferrer"">Elasticsearch 系列文章（三）：ElasticSearch 集群监控</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/"" rel=""nofollow noreferrer"">Elasticsearch 系列文章（四）：ElasticSearch 单个节点监控</a></p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2017/12/25/ELK/"" rel=""nofollow noreferrer"">Elasticsearch 系列文章（五）：ELK 实时日志分析平台环境搭建</a></p>
<p>6、也有更多深入的文章</p>
<h4><strong>搭建博客系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E5%88%A9%E7%94%A8Github%20Page%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"" rel=""nofollow noreferrer"">利用Github Page 搭建个人博客网站</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/"" rel=""nofollow noreferrer"">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia/"" rel=""nofollow noreferrer"">Hexo + yilia 搭建博客可能会遇到的所有疑问</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/"" rel=""nofollow noreferrer"">Hexo + yilia 主题实现文章目录</a></p>
<p>5、这个系列看情况，可能还会有</p>
<h4><strong>Java 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/06/13/String-new/"" rel=""nofollow noreferrer"">关于String s = new String(""xyz""); 创建几个对象的问题</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Java-Thread/"" rel=""nofollow noreferrer"">《Java 多线程编程核心技术》学习笔记及总结</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/06/13/java-var/"" rel=""nofollow noreferrer"">从对象深入分析 Java 中实例变量和类变量的区别</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/06/13/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%A9%B6Java%20%E4%B8%AD%20finally%20%E8%AF%AD%E5%8F%A5%E5%9D%97/"" rel=""nofollow noreferrer"">深度探究Java 中 finally 语句块</a></p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2017/06/13/%E8%A7%A3%E5%86%B3jdk1.8%E4%B8%AD%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%A4%B1%E8%B4%A5%EF%BC%88handshake_failure%EF%BC%89%E9%97%AE%E9%A2%98/"" rel=""nofollow noreferrer"">解决jdk1.8中发送邮件失败（handshake_failure）问题</a></p>
<p>6、<a href=""http://www.54tianzhisheng.cn/2017/06/13/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20Web%20%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"" rel=""nofollow noreferrer"">深入分析 Java Web 中的中文编码问题</a></p>
<p>7、<a href=""http://www.54tianzhisheng.cn/2017/06/13/%E5%A5%87%E6%80%AA%E7%9A%84Java%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88128%20==%20128%E8%BF%94%E5%9B%9E%E4%B8%BAFalse%EF%BC%8C%E8%80%8C127%20==%20127%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%BATrue-/"" rel=""nofollow noreferrer"">奇怪的Java题：为什么128 == 128返回为False，而127 == 127会返回为True?</a></p>
<p>8、<a href=""http://www.54tianzhisheng.cn/2017/06/13/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"" rel=""nofollow noreferrer"">Java读取文件</a></p>
<p>9、<a href=""http://www.54tianzhisheng.cn/2017/06/13/HashMap-Hashtable/"" rel=""nofollow noreferrer"">HashMap、Hashtable、HashSet 和 ConcurrentHashMap 的比较</a></p>
<p>10、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Java%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"" rel=""nofollow noreferrer"">Java连接Oracle数据库的三种连接方式</a></p>
<p>11、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Java%20NIO%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"" rel=""nofollow noreferrer"">Java NIO 系列教程</a></p>
<p>12、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Java-16-lession/"" rel=""nofollow noreferrer"">《疯狂 Java 突破程序员基本功的 16 课》读书笔记</a></p>
<p>13、<a href=""http://www.54tianzhisheng.cn/2017/06/17/%E8%AF%A6%E7%BB%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20ClassLoader%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"" rel=""nofollow noreferrer"">详细深入分析 Java ClassLoader 工作机制</a></p>
<p>14、<a href=""http://www.54tianzhisheng.cn/2017/06/17/%E8%AF%A6%E8%A7%A3%20Filter%20%E8%BF%87%E6%BB%A4%E5%99%A8/"" rel=""nofollow noreferrer"">详解 Filter 过滤器</a></p>
<p>15、<a href=""http://www.54tianzhisheng.cn/2017/06/23/java-io/"" rel=""nofollow noreferrer"">Java IO流学习超详细总结（图文并茂）</a></p>
<p>16、<a href=""http://www.54tianzhisheng.cn/2017/07/09/servlet/"" rel=""nofollow noreferrer"">通过源码详解 Servlet</a></p>
<p>17、<a href=""http://www.54tianzhisheng.cn/2017/07/25/Java-performance-tuning/"" rel=""nofollow noreferrer"">Java 性能调优需要格外注意的细节</a></p>
<p>18、<a href=""http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/"" rel=""nofollow noreferrer"">Java 线程池艺术探索</a></p>
<p>19、<a href=""http://www.54tianzhisheng.cn/2017/06/13/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7jps%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%E3%80%81jstat%E7%AD%89%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"" rel=""nofollow noreferrer"">JVM性能调优监控工具jps、jstack、jmap、jhat、jstat等使用详解</a></p>
<p>20、这个必须的持续更新下去</p>
<h4><strong>Maven  系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/10/14/Nexus3-Maven/"" rel=""nofollow noreferrer"">Centos7 搭建最新 Nexus3 Maven 私服</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/11/11/Maven-dependencies-dependencyManagement/"" rel=""nofollow noreferrer"">Maven 中 dependencies 与 dependencyManagement 的区别</a></p>
<h4><strong>Kafka 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2018/01/04/Kafka/"" rel=""nofollow noreferrer"">Kafka 安装及快速入门</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/"" rel=""nofollow noreferrer"">Spring Boot系列文章（一）：SpringBoot Kafka 整合使用</a></p>
<h4><strong>Mybatis 系列文章</strong></h4>
<p>1、<a href=""http://blog.csdn.net/tzs_1041218129/article/details/53404326"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis&lt;一&gt;</a></p>
<p>2、<a href=""http://blog.csdn.net/tzs_1041218129/article/details/53449052"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis&lt;二&gt;</a></p>
<p>3、<a href=""http://blog.csdn.net/tzs_1041218129/article/details/53456677"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis&lt;三&gt;</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/06/15/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E5%9B%9B"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis（四)</a>/)</p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2017/06/13/MyBatis-foreach/"" rel=""nofollow noreferrer"">MyBatis的foreach语句详解</a></p>
<p>6、期待它的源码解析文章吗？</p>
<h4><strong>Nginx 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/08/18/Ubuntu-install-Nginx/"" rel=""nofollow noreferrer"">Ubuntu16.10 安装 Nginx</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/08/05/Nginx/"" rel=""nofollow noreferrer"">Nginx 基本知识快速入门</a></p>
<h4><strong>Python 爬虫系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%B8%96%E5%AD%90/"" rel=""nofollow noreferrer"">Python爬虫实战之爬取百度贴吧帖子</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Pyspider%E6%A1%86%E6%9E%B6%20%E2%80%94%E2%80%94%20Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%20V2EX%20%E7%BD%91%E7%AB%99%E5%B8%96%E5%AD%90/"" rel=""nofollow noreferrer"">Pyspider框架 —— Python爬虫实战之爬取 V2EX 网站帖子</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%AE%B5%E5%AD%90/"" rel=""nofollow noreferrer"">Python爬虫实战之爬取糗事百科段子</a></p>
<p>4、这个估计得等有机会再次学 Python 时再写</p>
<h4><strong>RocketMQ 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/"" rel=""nofollow noreferrer"">RocketMQ系列文章（一）：RocketMQ 初探</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/"" rel=""nofollow noreferrer"">RocketMQ系列文章（二）：RocketMQ 安装及快速入门</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/"" rel=""nofollow noreferrer"">RocketMQ系列文章（三）：RocketMQ 简单的消息示例</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/"" rel=""nofollow noreferrer"">Spring Boot系列文章（六）：SpringBoot RocketMQ 整合使用和监控</a></p>
<h4><strong>Spring MVC 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Spring%20MVC%20+%20Hibernate%20JPA%20+%20Bootstrap%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"" rel=""nofollow noreferrer"">Spring MVC系列文章（一）：Spring MVC + Hibernate JPA + Bootstrap 搭建的博客系统 Demo</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/06/13/Spring%20MVC+Hibernate%20JPA%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"" rel=""nofollow noreferrer"">Spring MVC系列文章（二）：Spring MVC+Hibernate JPA搭建的博客系统项目中所遇到的坑</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC01/"" rel=""nofollow noreferrer"">Spring MVC系列文章（三）：看透 Spring MVC 源代码分析与实践 —— 网站基础知识</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC02/"" rel=""nofollow noreferrer"">Spring MVC系列文章（四）：看透 Spring MVC 源代码分析与实践 —— 俯视 Spring MVC</a></p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2017/07/21/Spring-MVC03/"" rel=""nofollow noreferrer"">Spring MVC系列文章（五）：看透 Spring MVC 源代码分析与实践 —— Spring MVC 组件分析</a></p>
<p>6、<a href=""http://www.54tianzhisheng.cn/2017/06/16/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Spring%20MVC%EF%BC%88%E4%B8%80%EF%BC%89/"" rel=""nofollow noreferrer"">通过项目逐步深入了解Spring MVC（一）</a></p>
<h4><strong>Netty 系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/12/08/netty-01-env/"" rel=""nofollow noreferrer"">Netty系列文章（一）：Netty 源码阅读之初始环境搭建</a></p>
<p>2、这个系列迟早会更新的。</p>
<h4><strong>前端系列文章</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/06/18/Bootstrap%E5%85%A5%E9%97%A8%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"" rel=""nofollow noreferrer"">Bootstrap入门需掌握的知识点（一）</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/06/18/Bootstrap%E5%85%A5%E9%97%A8%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"" rel=""nofollow noreferrer"">Bootstrap入门需掌握的知识点（二）</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/12/09/CodeMirror/"" rel=""nofollow noreferrer"">使用 CodeMirror 打造属于自己的在线代码编辑器</a></p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/06/23/AJAX/"" rel=""nofollow noreferrer"">AJAX 学习</a></p>
<p>5、前端渣渣这个也要慢慢学习这块</p>
<h4><strong>面试经验系列</strong></h4>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/08/04/yaxin/"" rel=""nofollow noreferrer"">秋招第一站 —— 亚信科技</a></p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/08/04/iqiyi/"" rel=""nofollow noreferrer"">秋招第二站 —— 内推爱奇艺（一面二面）</a></p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/08/04/alibaba/"" rel=""nofollow noreferrer"">秋招第三站 —— 内推阿里（一面）</a></p>
<p>4、 <a href=""http://www.54tianzhisheng.cn/2017/09/17/Interview-summary/"" rel=""nofollow noreferrer"">面试过阿里等互联网大公司，我知道了这些套路</a></p>
<p>5、<a href=""http://www.54tianzhisheng.cn/2017/08/28/recommend-books/"" rel=""nofollow noreferrer"">那些年我看过的书 —— 致敬我的大学生活 —— Say Good Bye ！</a></p>
<h4><strong>其他</strong></h4>
<p>还有一些其他方面的技术文章，算不是系列文章，比较零散，还有就是一些随笔文章，就不把它们放在合集里了。</p>
<h3>总结</h3>
<p>用自己的一句话：<strong>坑要一个个填，路要一步步走！前人栽树，后人乘凉，学会感恩！</strong></p>
<p>建了个不错的微信群，如果有感兴趣的可以加我微信，对我回复  <strong>加群</strong> ，然后会拉你进群交流。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014076590"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1520091522031"" title=""1520091522031""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013590620?w=864&amp;h=486"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 写这么多系列博客，怪不得找不到女朋友,1531977903,205,1,184,1,1,https://segmentfault.com/a/1190000014076581
47,1,0,9,"
                    
<p>吉日噶拉（在外企、上市公司工作过，自己也创业失败过，遇到过很多失败挫折，甚至露宿街头，但是最后还是挺过来了），是一个十几年的程序员了，本文介绍了他的相关经历，以及他的一些经验，无论是对刚入门的程序员，还是工作了十年八年的程序员都有一些经验值得借鉴学习。</p>
<p>（一）三年前的一个项目经验</p>
<p>作者帮公司拉了一个政府的项目，但是由于经验较少，谈的价格很低，还有很多细节刚开始没有谈到，后面相当于收了很少的钱，給政府干了一个比较完善的项目，这节的经验就是：程序员一般不应该直接和客户谈项目，应该让专业的人去谈，他能把10万的项目谈到50万或更多。</p>
<p>（二）2005年我的第一次软件创业，烧掉30万，两年时间打水漂</p>
<p>（1）为什么要创业</p>
<p>教训1.手上有技术，但是没有客户，没有产品，就靠着一腔创业的热血和对软件行业的爱好！</p>
<p>教训2.团队不稳定，各种经费、杂费、水电给、租房费、设备费，制度不够完善，成本没有控制好。</p>
<p>教训3.自己辛苦培养出来的技术人才，被客户三两下就要走了！人员的思想工作要做好。</p>
<p>教训4.小公司创业不要把财务完全交给别人，熟人也不行。可能最后生意失败，自己一点钱都拿不到了！</p>
<p>教训5.做公司不是做技术，更多的是做人，我做人本就不到位，做公司必败！</p>
<p>教训6.创业注意的问题点：</p>
<p>（2）我是个有经营头脑的人吗</p>
<p>（3）如何判断一个项目是好项目</p>
<p>（4）财务预算和控制</p>
<p>（5）如何与人合伙</p>
<p>（6）把自己摆正位置</p>
<p>（7）创业其实改变不了一个失败的打工者</p>
<p>（8）对行业的认识，上游和下游的掌控</p>
<p>（9）害人之心不可有，防人之心不可无</p>
<p>（10）靠人的买卖是最不可靠的</p>
<p>（11）偶然和必然的概率。。。</p>
<p>（三）投递简历请换位思考及前台页面设计比后台实现更值钱</p>
<p>简历</p>
<p>一般要信息全面，排版工整。</p>
<p>前台设计</p>
<p>前台设计是艺术，这个是没那么容易学来的，越往后写程序的会越不值钱，设计的相对会值钱一点。程序是技术，设计是艺术。技术可以批量生产，但是艺术无法批量制造啊。</p>
<p>（四）团队工作氛围很重要，没有好的氛围难出好的产品和项目</p>
<p>一个开发团队、软件公司需要有一个 良好的氛围，大家人心稳定，每个人都在有条不紊地忙乎实际工作上的事情，每天都有一点点成果，大家平时工作开开心心，一步一个脚印的发展。项目做的有条理，客户也满意，收款也及时，这才是软件公司生存发展的硬道理。软件如果做不好，软件公司肯定是开不下去的！</p>
<p>（五）奔三的程序员，平时都忙啥？想些啥？以后有啥计划？</p>
<p>每个人总要给自己寻找个方向，每个人都需要有个信念，没有信念，活着就没意思，无聊，觉得没有奔头了。作者是比较喜欢做技术那种，可以做到五六十岁那种，并且看到过更老的程序员！</p>
<p>1.比较喜欢技术，会经常学习，人需要不断提高否则很容易落后</p>
<p>2.看一些技术方面的书，管理经营方面也看，毕竟以后很有可能走上这条路。</p>
<p>3.多关心人情世故，多联系朋友、同事、亲人，努力建设和谐社会！其实是因为人脉比技术更加重要！</p>
<p>4.沟通能力很重要，文笔也是需要一点的，写报告，各方面交流都是会有的，毕竟技术能力不低了。</p>
<p>5.参与公司部分销售工作，做技术销售也是很重要的，也要让客户知道我们公司的技术能力是很强的。</p>
<p>6.软件系统的核心部分、通用组件部分、关键部分、标准样式部分、标准框架部分，这些都是软件系统的核心，不能指望新手来完成。</p>
<p>7.编程不只是20来岁做的事情，。可以走管理路线，也可以一直坚持技术路线。</p>
<p>8.生活不止有眼前的苟且还有诗和远方！</p>
<p>（六）你要有大客户，要有经济效益好的客户，你赚穷人的钱是很难的。</p>
<p>离职了也别成敌人，开开心心的离职，将来还是会有合作机会的，说不定还很大的机会。</p>
<p>你要有过硬的技术，让客户相信你，觉得这个事情你是专家，让你来做没错，你要时刻让自己的技术超出常人的水平。</p>
<p>拉客户要有个过程，小事情干好了，人家才放心把大事交给你去做，不可能一步登天。</p>
<p>不要做过于廉价的劳动力，那是在破化市场，尊重自己尊重别人，免费給别人当然可以，但如果那样做，IT就更不值钱了。</p>
<p>赚钱的机会不是天天有年年有，要学会抓住机会，错过了这个村就没有这个店了。</p>
<p>大项目都是有比较的，不是随便给你的，价格也不是乱开的，别人赚的钱也不是天下漂下来的，你需要战胜对手，才能拿到机会。</p>
<p>（七）走火入魔闭门造车疯狂框架经验分享</p>
<p>好东西多得是，就看你如何看待它们。就像我下载的1G的C#文档一样，电子垃圾一大堆，天天跟在新技术屁股后面，也难提炼出个啥来。因为你永远跟不上时代的进步。你的积累也会变成你的包袱，除非你有惊人的毅力，不断完善你的积累，那最起码你要连续几年不打游戏，节省时间才能提炼出来，或公司出钱给你烧，也能烧出来。</p>
<p>不是新技术出来了，你以前的积累就推倒了，除非你以前的积累是经不起考验的，否则是不会被推倒的，新技术只是锦上添花而已。软件整体的开发不会轻易发生天大的变化，你需要的是不断吸收新技术，了解新技术的长处和定位，然后把需要的新技术消化好，用到自己的整体框架中。</p>
<p>（八）最近几年软件项目的心得体验</p>
<p>1.做软件外包的经验告诉我</p>
<p>做软件需要人海战术，做软件需要大量的体力劳动，而不是脑力劳动</p>
<p>2.我们技术副总的主导思想</p>
<p>客户的需求变来变去怎么办？客户的需求变了，并不是坏事，让客户填写好变更表，把工作量变化給客户确认，秋后算账。工作不就是干点活做点项目吗？哪里不一样，这个项目工作量越来越大，钱也是越来多，不是坏事。</p>
<p>3.我自己的主导思想</p>
<p>想多赚钱怎么办？直接找上级谈，你能干出啥来？想要多少钱？多长时间过好？对公司有啥好处？都谈明白了，老板也会答应的，大家都有好处，都在影响自己的心情，不能好好干活。</p>
<p>4.身边一直发生的事实告诉我</p>
<p>与领导沟通好，报告写好，比拼命干活效果好几十倍！别总埋头苦干，干得累死累活，没人知道你有多辛苦，及时向领导汇报情况交流。</p>
<p>5.我比较佩服的事业部经理告诉我</p>
<p>不能完成工作怎么办？最愚蠢的做法是通宵几天，突击几天，然后累死累活，最后还是没能按时完成，人也累趴下了。其实，不能按时完成工作多了去，这时要先分析清楚延时的原因，找上级说明原因，让他们认可你的理由。然后把接下来的工作合理的进行安排，有条理的一个个做好。</p>
<p>6.我的自身N年工作经验表明</p>
<p>做软件为什么那么累？因为软件是个细活，不是敷衍了事对付对付就可以的，需要一行行代码写出来，不能思路混乱，也不能偷工减料。不管是太理论也好，太理想化也好，总得有个理论指导实践的主导思想，否则这事就没法干了。</p>
<p>（九）不要給自己编织过多的理由，借口是永无止境的</p>
<p>工作要有力度，不能老是没完没了找借口，每个人都可以给自己编织出美丽的借口理由来，听起来事那么地有道理，其实理由都是給自己编的，自己给自己下的套。</p>
<p>（十）打工和创业不同的心态</p>
<p>这几年给人打工，感觉真是太幸福了，每个月不管业务好不好，不管客户给不给钱，老板都会按时给我发工资，卡里有钱了，不愁吃不愁喝，真幸福。</p>
<p>自己不开公司不知道赚钱有多难，自己不当老板不知道給员工的工资已经很高了。不要以为自己创业就比打工可以赚更多钱，我见过很多朋友，自己创业创得很辛苦，但是他们打工的活可以很轻松拿到10K以上的薪水，但是他们非要自己创业，非要往火坑里面跳。</p>
<p>（十一）IT创业光技术好，谋略定位不好，可能照样会死得很惨。</p>
<p>你可能有了一个很好的创业思路，就感觉用这个思路去创业，成本地，风险低，成功的概率高，你会跟你的好朋友探讨你的思路，会和你的好朋友讲解你的经营模式、经营理念，甚至带他到你的公司参观感受一下你的成功。这时候你很可能在做一个错误的决策，你的朋友也不是吃素的，他也会模仿你，抢你的生意，抢你的机会。</p>
<p>我觉得我的积累还可以，还做出了娱乐场的计费软件。我以前的合作伙伴偷了我的成果，销售了几十套。你的成果很容易被被人偷窃，你要学会保护你的劳动成果，你的劳动成果未必给你带来什么经济效益，确定给你的敌人带来更多的经济效益。</p>
<p>小结：</p>
<p>1.开公司首要的是要明白你做什么可以赚钱，而别人不知道，或者还没抓住。你程序写得好，项目写得好，算个屁啊！全国程序写得好的人多了去了。你努力啥的，更没用，天下努力的人多了去！</p>
<p>2.身边都是虎狼，都是人精，都想吸干你的血，都是指望着跟着你或者从你身上捞一把的人。</p>
<p>3.创业千万不要又出钱又技术。要么烧别人的钱，要么别人出技术。你全出了，风险大，压力也大，甚至都没有精力跑市场。</p>
<p>4.你要找比你强的人合作，你能从他身上学到东西，而不全是你给予别人。与比你强的人合作，你绝对不会损失啥。</p>
<p>5.创业了，玩人一定是比做项目、干活更重要的事</p>
<p>6.小公司把股份分掉，你就是不要股份又能怎么样？等你玩透了，自己再开间公司又能怎么样。你給员工1%的股份，他都会很开心。甚至你卖股份給员工，还可以融资一把。</p>
<p>（十二）为什么我们每做一个项目软件，总要被折腾得死去活来</p>
<p>1.软件是个庞大的工程，不像盖小民房，可以看得见摸得着，软件是一个看不见的庞大工程，所以一个像样的项目，一般没那么容易就能搞定的。</p>
<p>2.客户的需求变来变去，我们也要跟着被折腾来折腾去，没有一个很确定的功能需求。</p>
<p>3.我们的技术不过关，写的代码质量不过关，稀里糊涂，对付来对付去，我们的代码经不起客户的折腾，没折腾几下，就可能被客户的需求給弄死了！</p>
<p>4.客户的需求无边无际，没有一个明确的范围，其实客户的需求范围是需要限定再某个明确的范围内的，工作就在这个明确的范围内开展。</p>
<p>5.可能我们没有一个成熟的开发框架，每个人都在摸索，每个项目都在摸索，那是很浪费人力物力财力的。</p>
<p>6.我们没有严谨的分工分界思想，哪些功能应该是再哪些模块做，哪些功能是在哪个实现才对，哪些功能应该在前台做，哪些功能应该在后台做，可能都是混乱的。</p>
<p>7.我们一直追求“差的不多就可以”，导致我们做出来的程序不好用。漏洞百出，错误多多，无法将注意力都集中在客户的业务上。</p>
<p>8.公司没啥积累，一切都要重新来过，做一个项目走一批人，一年又一年，原地踏步。</p>
<p>9.项目组人员，同时负责好几个项目，东搞搞西搞搞，无法集中精力做好一个项目，哪个项目都是半成品，都是个噩梦！</p>
<p>10.拉一个项目，招聘一批人，各路神仙，思路不一样，做事风格不一样，写代码不一样，驴唇对不上马屁股，无法协调好！</p>
<p>11.老板不懂技术，以为有几个人就可以搞定，没有测试，没有质量管理，没有需求分析，瞎搞乱搞，折腾来折腾去。</p>
<p>12.软件不像其他行业，是需要每行代码仔细写的，仔细琢磨，不能靠吹就能吹出来的，需要精细的编写，最后才能出来结果，也不是买过来，卖过去那么简单！</p>
<p>13。公司大部分都是眼高手低的家伙，平时东扯淡西扯淡，不踏实干活，尽搞些虚无缥缈的东西，没人干实事。</p>
<p>14.公司里往往耕地的牛是不讨主人喜欢的，汪汪叫的小狗却会讨主人疼爱，主人更喜欢小狗。但是做项目需要的是牛，不是靠小狗叫叫就可以了。</p>
<p>15.公司氛围不好，心情也会不好，压力会增加，代码量也是会下降。</p>
<p>（十三）一个完整的软件项目，最起码要注意什么</p>
<p>1.项目是谁拉来的？如何拿到了这个项目？公司给了多少业务经费？如果自己是业务员，收入会如何？</p>
<p>2.客户谁说了算？谁是这个项目的关键人物？这个项目的关系人都有谁，他们在项目中起到了什么重用？</p>
<p>3.项目的工期是多久？都需要哪些功能？客户经理的理想工期是多久？客户的期望值是什么？</p>
<p>4.项目的成员是如何组织的？人员是如何管理的？项目里分工是如何划分的？</p>
<p>5.项目的预算是多少？预算谁说了算？计划工期是多少？</p>
<p>6.项目总开发中的错误是如何管理的？</p>
<p>7.项目中遇到的难题是怎么解决的？</p>
<p>8.项目里的都用了什么技术框架？</p>
<p>9.项目里的技术分层是如何实现的？</p>
<p>10.后期发生的问题，是怎么处理的</p>
<p>11.上线是如何进行的</p>
<p>12.后期有没有在挖掘这个客户，有没有在挖出个类似的啥项目来？</p>
<p>当然还有很多很多可以通过实际的项目过程学到的有价值的知识点。</p>
<p>（十四）学习提高要积极主动，诚信对待别人，别人也会诚信对待我们</p>
<p>在一定的瓶颈阶段，我们要学会想办法去提高自己，不管是向同事、朋友、网友，都可以进行交流学习，最好是找一段时间面对面的实际交流。并且要诚心诚意，要有交互的过程，不能只是别人教你知识，你也要有可以交换的知识，这样人家才愿意。</p>
<p>（十五）如何突破月薪大关</p>
<p>IT软件人生，人生的几次升华：</p>
<p>1.能独立完成任务，能做项目，升华一次。</p>
<p>2.技术过硬，思路严谨，升华一次</p>
<p>3.学会与别人工事，团队协作，升华一次。</p>
<p>4。当项目主管，升华一次。</p>
<p>5.经营一个公司，升华一次。</p>
<p>6.安稳下来，有自己的家，升华一次。</p>
<p>7.结婚，升华一次</p>
<p>8.当爸爸，养孩子升华一次！</p>
<p>如果能力不够还是要用力提升自己，能力够了可以向上级提出要求，或跳槽都会有薪资的提升。</p>
<p>（十六）辞职也要辞得帅，辞得大家开心</p>
<p>辞职要注意的事项：</p>
<p>1.辞职需要提前一个月说好，最好能有书面的的邮件方式給相关的领导。</p>
<p>2.辞职的时候，最好先跟部门的经理说一下，不要直接跟老板讲，管理上比较重视不要“越级”</p>
<p>3.辞职前，把手上的工作都整理好，把能结束的工作尽量结束。</p>
<p>4.如果是跳槽到到新单位上任，不要太急，最好等能最长的上岗时间，因为你跳槽了还需要办理很多事情，例如你的档案、养老金、公积金等等。而且规范的单位要初始上一个单位离职的证明，所以不要和上一个公司闹扳。</p>
<p>5.年底不要轻易辞职，一般很多单位都有年终奖，一般多少都会有一些。</p>
<p>6.不要和同事的关系闹僵，因为你的辞职，会导致有些事情要让别人擦屁股，还有些恩恩怨怨，积累多了，不太好，人总要有一些朋友的，如果你结婚或办什么喜事，想请一些朋友来乐一乐，也不会来几个。</p>
<p>7.需要有一颗感恩的♥，我们的技术、水平、机会，并不是靠自己的努力，很多是从同事那里学来的，是公司給的机会提高了我们的水平。</p>
<p>8.其实一个城市的IT圈子的不大的，很有可能你跳来跳去，还是跳到原来的公司，或者你以前的同事跳到了你公司当了部门主管。所以平时要注意不要得罪同事，不要以为好马不吃回头草，其实天下大也大，说小也很小。</p>
<p>9.有些机会是朋友、以前的同事、以前的客户提供的，所以要珍惜眼前的同事、朋友、客户。</p>
<p>10.不要说自己的公司的坏话，若你以前的公司很不好，那就代表着你也很一般。</p>
<p>11.就算辞职了，也要学会说人话，要感谢公司的培养，要感谢部门经理的栽培，要感谢同事的关系。你说点好话，公司领导也会另眼看你，说不定你在新单位混不好，混不开，还可以回到原来的单位工作！</p>
<p>12.其实这些软件公司的老板们相互之间也是一个朋友圈子，也经常有来往的，你跳槽到另一个公司，他们也会通过其他途径了解你在原工作单位的表现、为人、技术水平。</p>
<p>13.自己也曾经当过不成功的老板，也能感受到员工跳槽的痛，明明公司和客户有外包关系，一看对方的公司比自己的公司有实力，就跳槽到对方的公司。生意也受到损失，培养的员工也都跳槽到客户那里去了，还怎么赚客户的钱？所以要选择好及要的效果是损人利己还是损人损己？最好是哪个都不要损比较好。</p>
<p>14.跳槽从另一个层面考虑，也能变成好事情。</p>
<p>（1）从公司的角度考虑：这个公司不错，别人肯挖这个公司的员工，说明信任这个公司培养出来的员工。</p>
<p>（2）从员工同事的角度看：跟我们水平差不多的人可以进入更好的公司，能拿到更高的薪水，那以后有机会了，我们也能拿到更高的薪水，会有更好的前途。</p>
<p>15.总的来说，公司是你的跳板，是一个台阶，你需要有点感恩的♥。辞职时，跟部门里关系好的同事吃上一顿饭。</p>
<p>16.辞职从贬义理解就是</p>
<p>“逃避责任，逃避现实”</p>
<p>，其实不管是在哪个公司混，都差不多，我们比拼的就是技术能力、人品、为人处世而已。你在这个公司混不还，到另一个公司也是很难混得开。</p>
<p>17.辞职了，虽然脱离了苦海，但是很有可能进入另一个苦海。人走了，也不要一刀两断，能维护的，最好继续给维护，能交接的尽量交接。以前的工作都是你的血与汗，别白流了，能让后人重复利用，尽量重复利用。说白了，那也是你的孩子，你真的忍心抛弃你的孩子不管吗？</p>
<p>18.从原公司辞职，公积金、养老金停止缴纳了，最后一个月工资有争议了，到新公司，又有三个月的试用期打八折。其实仔细算一下，这个一来一往，差距还是比较大的，所以多给个四五百就别跳槽了。我曾经的原则就是要多给个2000到3000才考虑。</p>
<p>（十七）一个老程序员的未来十年计划及目标</p>
<p>废话不多说，把自己的目标列出来，给大家参考参考：</p>
<p>1.现在本科学历有点混不开了，我一直没有时间读硕士，应该抓紧时间读个硕士来，再考虑是否读个博士。不管是读在职的，还是花钱深造都是可以选择。否则有可能将来很不好混了，扫地的都是本科的了。</p>
<p>2.年纪也不小了，也该考虑，婚姻和孩子的事情了。</p>
<p>3.现在是公司的中层干部，争取通过努力工作，拼搏到公司的高层，年收入有个稳定的三十到五十万左右，养家糊口不成问题。</p>
<p>4.将自己的注意力从技术上转移到人的方面。更多的不是玩技术，而是关注技术和管理，关注身边的同事和客户，同事再技术方面也希望跟上发展的脚步，不要落后太多，最起码什么都懂一点。</p>
<p>5.劳逸结合，身体是革命的本钱，不能为了赚钱不要命，身体垮了，谈什么事业，谈什么将来。平时注意休息，锻炼，争取不得大病，小病也尽量避免。</p>
<p>6.做个全国行业内有点知名度的产品来</p>
<p>7.年纪大了，对泡妞也没兴趣了，总得有个喜欢的东西做做，例如钓鱼、收藏、那我就来个以做软件为兴趣爱好。打发打发时间。</p>
<p>8.要成为某个领域的专家，精通此行的管理（当然不能说是软件开发领域的专家，这个太不值钱，竞争也太激烈的，更新得又快）</p>
<p>9.开拓几个有实力的合作伙伴，也没有必要太多，精一些就可以了。</p>
<p>10.关注纯软件以外的知识领域，例如工业制造、数据采集，指纹系统，人工智能。也不指望深入底层，只要掌握一些集成的经验及应用就就可以了，毕竟技术有专攻，跟行家是没法比的。</p>
<p>（十八）我是如何学习一门开发语言的</p>
<p>1.每个年代学习的的途径不同。我按当时的方式来讲吧，想到图书馆去找，哪个本子都会翻翻看，然后哪个图解多，我就会有买哪个的意向。而且图解多的，看起来不累，还可以有个参考，就算没电脑再旁边，也会大致看明白啥意思。还是比较喜欢台湾人写的书，几乎全是图，没几个文字，而且学习的效果往往很好。还有就是，我一般购买</p>
<p>清华大学出版社</p>
<p>的书，相对质量会好点，其次是</p>
<p>人民邮电出版社</p>
<p>的。</p>
<p>2.学习也会很容易造成原地踏步的情况，因为你学前几本书的时候，学到的东西很多，当时后面看的很多书，内容会类似，所以需要自己把握好。</p>
<p>3.书都自己购买就太浪费钱了，所以我一般是从图书馆中借书来看。</p>
<p>4.参加工作后，我的学习方式就有些改变了，经常看网上的技术文章，看技术文章的时候心里会想着我也要成为别人羡慕的高手，这样就很有兴趣看技术文章了。</p>
<p>5.其实也不要怕买书浪费，你能收获到的知识的价值肯定比你买书的价值是要高很多了，前提是你买了就要看，不然就不要买。其次，不要买过时很久的书，因为现在知识更新还是蛮快的。</p>
<p>（十九）曾经想学很多很多，最后发现自己只能专心学好很少的那么几个必杀技</p>
<p>1.软件行业最终出来的还是产品，在某个领域不断地优化，干多久就优化多久。当然要有敏锐的洞察力，能想先知一样知道客户将来需要什么，会需要什么，那你就离成功不远了。</p>
<p>2.一把宝剑与1000把粗制滥造的刀比拼，最后哪个会胜利？1000把烂刀都拼不过人家一把宝剑。</p>
<p>3.十年后发现，很多东西，丢弃的丢弃，落后的落后，淘汰的淘汰，唯独这么一个轻量级的开发工具库一直伴随着我的茁壮成长起来。</p>
<p>（二十）程序员12点，你睡觉了吗</p>
<p>谈谈我的心得体会：</p>
<p>1.晚上熬夜，早上起不来，那就是天大的痛苦。早上赶车、挤车，因为你精神不够很容易出事，或被小偷光顾。</p>
<p>2.你的领导、同事、客户看到你平时工作精神不集中，对你的评价会比较糟糕，以后有好事情也一般轮不到你，这会影响你的前程。</p>
<p>3.由于晚上没休息好，工作效率会很低，思路会很混乱，该做的事情没仔细做好，迷迷糊糊、稀里糊涂的一天就过去了。</p>
<p>4.一个作息不规律，邋遢、做事稀里糊涂的人，我就是有个漂亮的妹妹也不会介绍给他。</p>
<p>5.不按时休息，很可能会影响家人。</p>
<p>6.晚上加班了，没几个人看到你加班，但是早上迟到了，所有的同事都看到你迟到了。</p>
<p>7.年轻时身体像铁一样，等过了30岁，通宵一晚上要痛苦三四天才能缓过来。若年轻时，不珍惜，过了30岁，啥病都找上门来了，赚的钱可能没药费多。</p>
<p>8.早上起来太晚，一般来不及洗脸刷牙，头发也没注意，形象还是要主意好的，能给别人好的印象。</p>
<p>同学们，经常熬夜真的会影响你的前程，还是按时休息吧，除非时要命的事。</p>
<p>（二十一）春节后被面试和面试别人的经历</p>
<p>1.被人面试</p>
<p>书中的作者，投递的简历方向都是十年左右的工作经验的岗位，基本都是有面试通知，接着就是成果讲解，项目介绍是少不了的。基本也是能上岗位，但是还是选择了稳定的一点的那个。</p>
<p>2.面试别人</p>
<p>主要从下面几个方面跟大家分享，对面试官和面试者都是有一定的借鉴价值：</p>
<p>（1）简历环节</p>
<p>①曾经跳槽单位不要过多，总要有几个待了很长时间的公司，否则很难有高薪的机会。</p>
<p>②项目经历不要写那些幼稚的学习项目，写上一百个都是没有用，一看就是入门糊弄小孩的项目。</p>
<p>③项目经验不要太假，工作才两年，上十个项目，这么可能啊？走马观花？能长啥经验？</p>
<p>④工作年限、期望工资写清楚。</p>
<p>⑤其他方面，比如个人的详细资料，联系方式都是要有的，并且排版整齐</p>
<p>（2）笔试环节</p>
<p>①我们不是研究高新技术的，我们考的是你的基础功，虽然面试题目很简单，但是需要仔细认真的写，代码也要写工整些。</p>
<p>②简单的题目不会做，难的题目更不会做，无聊的时候还是要翻翻基础语法的书，SQL的书等等。</p>
<p>③不要藐视简单的题目，一般都是暗有玄机</p>
<p>④我没见过笔试很糟糕的，真正干活却很厉害的人。我记忆中的同事，平时工作厉害，笔试也不差。</p>
<p>（3）面试环节</p>
<p>①首先你不能有口臭吧，再穷也要买个口香糖，把口臭问题解决掉。</p>
<p>②带上纸和笔方面不时之需。有厉害源码或项目的可以带上电脑。</p>
<p>③头发梳理干净，穿得像模像样，第一印象是很重要的</p>
<p>④无法表现出对编程的热爱，会是好员工吗？</p>
<p>⑤笔试不好可以理解，但是几乎没有一个说得出口的自己擅长的东西，是不行的。</p>
<p>⑥沟通能力不好，或者自己的思路表达不清楚，一般是很难找到合适的工作的。所以平时工作要学会多交流，别跟你旁边的同事Q来Q去，学会直接张口对话不时坏事。</p>
<p>⑦我们更愿意录用那些看上去顺眼，性情稳定，目标明确，有一计之长，工作经验丰富、有实际工作业绩证明的人。</p>
<p>（4）老板环节</p>
<p>①虽然前面两关过了基本上不会有啥问题，但是也不要太随意，上层领导更看重精气神的表现。</p>
<p>②一些细节也要注意到：比如，敲门进入，坐着不要翘起二郎腿。</p>
<p>③老板也会很在乎你的沟通能力，职业规划，价值观，知识等方面</p>
<p>（二十二）想快速提高技术水平吗？你需要找高手，给你的代码来个深入点评</p>
<p>1.我们国内的程序员大多都不善于交流，即使善于学习，提高的还是不明显。不少工作了五年的人与工作了一年多的人的水平本质没啥区别。这种原地踏步的状态，会让人感到迷茫。</p>
<p>2.我们大多喜欢看技术文章，但是不喜欢把自己的代码拿出来交流，让高手看。说白了，其实高手也懒得看菜鸟的代码，所以你得求人家看才行！因为大师給你点评，你就知道，你与他们的能力差距体现在哪里，哪些没有注意到。</p>
<p>3.记得刚开始工作的时候，别人指出我，有些命名习惯不好，有些逻辑思维判断可以更简单写，刚开始我是有点抵触的，但是，后面想想，很多最基础的东西都没做好，怎么能算一个好的程序员呢？直到我现在认为，哪怕是一个字母的大小写没弄好，或包名没设计好，都是很不应该，很幼稚的错误！</p>
<p>4.那些难以提高的人的特点：</p>
<p>（1）目中无人，自以为是的程序员</p>
<p>（2）听不进别人的意见，总想抢着讲自己的观点的程序员</p>
<p>（3）不关心别人，天天闭门研究，而且着手与研究十年八年才能成功的项目的程序员—世界很大，你正在研究的很多问题，别人做就解决了！</p>
<p>（4）工作中，没遇到大师和高手，想交流和切磋没办法，只能考网络学东学西，再买几本书看，难以掌握系统知识的程序员。</p>
<p>通常来说，拿来主义往往是见效最快的。有效的沟通交流，比自己努力强上至少5倍。很多时候，研究别人的成果比自己从头研究要节省很多的时间。程序员总不是靠吹出来的，还需要静心写一写，但别忽略了沟通交流的重要性。</p>
<p>（二十三）接近60岁的日本IT软件小老头在干什么？我们能从他身上学到什么？</p>
<p>很多软件开发人员，好像过了30岁就迷茫了，30岁没当上管理职位就面子过不去了。还记得在上海遇到一个60岁的IT小老头，看看人家在干什么：</p>
<p>1.整个系统构架，都是由他选型的。例如整个系统分几层，用什么开发语言大多，当然包括数据库的选型。</p>
<p>2.到底用哪些三方组件，例如报表、三方协议处理软件、展示控件，而且对他们了解非常深入。</p>
<p>3.整个系统的例子程序基本都是他写的。并不只是选择系统构架，他把构架选好，还能让它跑起来，并且把范例程序写好（大家都是安装他的写法写程序）</p>
<p>4.编码规范、注意事项，都是由他起草，并且写得很规范。</p>
<p>5.几乎所有的设计文档，包括页面的初步设计，都是他做的。他知道整个系统需要多少个页面，每个页面需要什么功能，有很明确的说明，很详细。</p>
<p>6.数据库的详细设计都是他负责的，包括每个表、每个字段的名称、类型、默认值等。</p>
<p>7.项目中难题的攻克，特别是控件上的特殊处理，都是这个老头在负责维护更新。</p>
<p>8.项目的验收、与客户的沟通问题，项目的进度的安排和跟进、费用的计算都是由这个老头来负责。</p>
<p>跟这样的人一比，那些十年八年的老程序员，简直是小菜。没有个二三十年工作经验，哪里来的那么强的技术能力。但是坚持学习二三十年的技术也不是一件容易坚持的事！</p>
<p>大家就当一个参考吧！</p>
<p>（二十四）技术人员需要先学会做人，在学会做事，之后才能成事。以成名得利。</p>
<p>1.其实两个人做项目，既能体验工作的乐趣，又能相互学东西，多了很多安全感，少了不少孤独感。</p>
<p>2.经历N多失败也不是什么坏事，只要你不被失败彻底打败就好。没有惨痛的教训，就没有深刻的体会。</p>
<p>3.以前总想用实力来证明自己是最强的。认为把实实在在的实力拿出来了，别人应该不得不承认你的能力。其实，好胜性格的人在刚开始工作往往会碰壁，身边的同事也大都反感。</p>
<p>4.不管做什么事情，我们要记住一点。首先要得到领导的认可，从上而下执行的事情，往往会跟顺利一些。</p>
<p>5.一些建议：</p>
<p>（1）压住好强心理。</p>
<p>（2）先不要急于做事，低调低调再低调。</p>
<p>（3）遇到事情不要马上就和同事沟通，想把思路捋好，试一试可行的办法先。不要浪费人家大把时间。</p>
<p>（二十五）程序员找老婆—相亲节目引发的一点思绪</p>
<p>简单的说吧，在大城市里面的程序员找老婆不容易！年纪大了，程序员很多都是会去相亲。</p>
<p>相亲方面的劣势：</p>
<p>一个方面性情不够开朗，兴趣不够广泛，物质条件优势不大。而且陪老婆的时间不会太多。</p>
<p>还记得看非诚勿扰，一个片段，一个相亲的男的说我是个PHP程序员，然后场上的灯，马上灭了一大片，像打机关枪一样，主持人都一脸懵逼。这个引人发笑，但是却是值得我们程序员深思的！</p>
<p>（二十六）技术水平很高，但是正规公司为什么还是不录用这些人？</p>
<p>其实公司都是希望来的都是大牛，但是也要合适的。</p>
<p>※ 不容易被录用的情况：</p>
<p>1.越是规范的大公司多来的人，越不容易被录用。因为大公司出来的人一般都只懂局限的一部分工作，综合实力相对很弱。</p>
<p>2.越是规范的的大公司过来的人，往往不喜欢啥都自己做，已经习惯了做单种工作。</p>
<p>3.越是大公司来的人，薪资要求越高。</p>
<p>4.越是大公司过来的人，资历高，眼界广，管理难，你怎么指挥人家未必会听。</p>
<p>5.一个人的力量毕竟往往是有限的，就是招聘了这么一个大牛，他也未必能在短时间内干出重大业绩来。</p>
<p>6.很多所谓的牛人，都是两手空空的牛人。</p>
<p>★ 容易被录用的情况：</p>
<p>7.至少有两年的工作经验。实习生是很折磨人的，学得不好，公司又不想要，学的好的，又很有可能不久就跳槽！</p>
<p>8.做过几个像样的项目，手上有实际工作成果演示。很多时候公司不是要你的代码，而是看你的工作能力。</p>
<p>9.笔试成绩好，思路严谨，程序也写得不错，数据库SQL语句也写的条理性很强。</p>
<p>10.行业开发经验越接近越好。</p>
<p>11.正规的大学本科毕业。</p>
<p>12.薪资要求合理。</p>
<p>13.长相虽然不要求很英俊，但是不能影响公司的形象，看上去干净整齐。</p>
<p>14.经历过一个完整的项目周期，从项目开始到项目结束为止，不仅会写代码，还能写一些相关的文档，有一定的设计能力，有一定的沟通表达能力。</p>
<p>15.肯努力工作，不时思路紊乱型的。水平差点，多教下，努力学习也是可以提高的。</p>
<p>其实程序员也就那么点工资，开始也不指望你做出什么惊天地的高深技术来。当然后期发展看个人情况。</p>
<p>（二十七）对普通员工而言，有效的沟通能力比技术能力更加重要</p>
<p>体现在下面几点：</p>
<p>1.有些有难度的东西搞不定，也不跟领导讲。不找同事问，不找技术领导问，只是自己闷头研究，好几天也弄不好。其实张张嘴，你身边闲着没事的</p>
<p>寂寞高手也是会愿意为你露一手的。这些人可都是过来人，都是有很多经验的。</p>
<p>2.程序模块写好了，也不跟领导讲一下。写好后接着闷头学习研究新技术，或看新闻等等。其实你的程序可能还有很多未知的问题，或要修改的逻辑。</p>
<p>3.修改了程序也不跟组员讲一下。想怎么改就怎么改。这回让程序代码后期维护很难。</p>
<p>4.修改了Bug也不跟领导讲一下。测试人员不知道，修改后量注解也不加上去。。。</p>
<p>5.工作任务无法完成也不跟领导说一下。不知道是处于面子问题，还是拍别人说自己能力不行，总之一大堆工作没办法按时完成，也不跟领导讲一下。</p>
<p>其实吧，任务完不成也是偶尔会有的情况，要提前说一下，好让领导有个充分的考虑，重新分配把一些任务，让别人来完成一些，以免耽误了项目的进度。 不能按时完成任务并不是天大的错误，没有及时汇报无法完成任务才是天大的错误。</p>
<p>6.技术不行，你可以学，可以模仿，可以copy过来修改。但是沟通能力不行，不时一天两天就可以改得来的。这就要求你平时要多注意有效的沟通技巧。</p>
<p>（二十八）从代码质量检查中感受生活的乐趣</p>
<p>由于没有代码检查这个步骤，很有可能导致最后的错误被放大很多倍。没有代码检查，既要耗费测试人员的时间，也耗费领导的时间，最后你还得改，可能有些功能自己都不太记得了！需要花一些时间理顺思路！</p>
<p>所以及时检查代码是很有必要的，要把自己的代码当成自己的孩子来看待，你会愿意自己的孩子，天生畸形吗？</p>
<p>代码检查的几个参考点：</p>
<p>1.要有比较可行的编码规范，这样可以统一规范大家，否则不知道谁说了算。</p>
<p>2.大家要有共识，有一个良好的代码质量互查氛围，每个人都有意识的相互检查。</p>
<p>3.程序如人。程序有无Bug与做人好坏是一样的道理，我写出来的代码程序就是我人的质量。不能容忍代码程序有瑕疵。</p>
<p>4.要有强烈的责任意识。我的软件有问题，哪里还能按时下班，安心的过生活？</p>
<p>5.检查代码也需要有高水平与高境界，不只是需要有这个意识。检查代码的能力也是可以提升的！</p>
<p>6.一个人努力做事情很重要，大家一起努力做事情更重要。</p>
<p>（二十九）谈某些程序顽固的思维方式</p>
<p>下面是一些程序员的顽固思想例子：</p>
<p>1.没有设计文档</p>
<p>误区：很多人会认为设计文档瞎耽误功夫。</p>
<p>其实吧，有设计文档还是好一点的。就像向有设计图纸，再有模型。。。设计的程序总要逻辑页面吧，还有必要的备注呢。若一个软件，连像样的设计文档都没有，以后怎么上层次，怎么有提高？</p>
<p>设计文档也是对自己思路的一种锻炼，不管是工具的使用，还是实际设计。。。</p>
<p>2.拒绝重构</p>
<p>程序里面有一大堆命名紊乱，功能重叠的代码和写错位置的代码，这些很多都是只有当事人才清楚的。</p>
<p>很多人认为程序稳定，不出问题就可以了，但是后期维护的？有时候辛苦的还是自己啊。</p>
<p>3.拒绝使用现在新的方法和框架</p>
<p>其实就是害怕学习，一般的来说，新的东西大都有它的价值，旧的东西会被慢慢取代。比如说现在相应式编程就很流行哦。要多听听比你经验丰富、能力更强的人的建议。</p>
<p>（三十）典型的国内小项目经验分享</p>
<p>国内项目的几个典型特点：</p>
<p>1.项目临时性比较严重，突然要开发。</p>
<p>2.项目工期短，总共也就两三个月时间。</p>
<p>3.项目人员变得大，开发人员不稳定。</p>
<p>4.项目成员少，有时是两个，有时是一个人开发。</p>
<p>（三十一）创业前，你要思考的问题</p>
<p>有些人头脑不冷静，盲目走上创业之路，创业后自己辛苦不说，生意难做，还会遇到很多生存问题，资金问题，人力资源问题，可持续发展等等诸多问题。</p>
<p>下面是创业需要谨慎问题：</p>
<p>1.同一个时间过一个项目时，人的精力会很集中，这样效率也会高。但是同时做好几个项目，人的精力就会分散，往往处于应付表面的状态，无法对项目进行有力的推动。</p>
<p>2.干自己的事情和干别人的事情境界完全不一样，往往给你干活的人或者与你合作干活的人，不会那么拼命，不要期望太高。</p>
<p>3.项目人员变动的可能性很大，开发的周期相对比较长。而且就算自己不出变故，很有可能客户会发生变故，整个项目的风险系数比较大。</p>
<p>4.刚创业时往往很难走产品路线，大多走的时项目路线。每一个项目的个性化需求，业务需求差异大，无法充分利用上一个项目的劳动成果。</p>
<p>5.为了可持续发展，就得一边做现有的项目，一边接洽下一个项目，这样会耗费很多时间，而且分散精力。</p>
<p>6.若项目不是自己带，往往很难控制它的规范性，严谨性，很容易进入一个一团糟的局面，后期收拾这个糟乱的局面，也要耗费N多精力和时间。</p>
<p>7.一个公司的房租成本、办公成本、日常经营成本、招待费、差旅费等等开支也不少。</p>
<p>8.接下来很可能在不同的城市和行业，要同时打赢好几场战争很不容易。</p>
<p>9.接一个项目容易，但是天天有项目不是那么容易的。开拓一个信任你的客户比抢别人的客户更难。</p>
<p>创业过程中一下子要花费几万块是很正常的事情，和可能折腾几下就亏空了。特别人没有明确产品方向的软件开发人员，创业还要谨慎。</p>
<p>（三十二）感受 结对编程 的威力</p>
<p>其实就是两个人编程。</p>
<p>一个人编程遇到一定的阶段难免会有松懈，并且思路相对狭窄一些。两个人编程可以一起交流，一起探讨并认自己的劳动成果时就不会那么无趣了。并且两个人一起编程，谁也不好意思偷懒，代码的检查率也高了不少，出错的概率会低很多。</p>
<p>亲自体验了一下结对编程的威力，不错，值得推广。</p>
<p>（三十三）用什么心态对待糟糕的程序员</p>
<p>这些年遇到不少糟糕的程序员。其实正在写程序的人，普通IT公司大概只有1/3，有2/3不适合当程序员。还有部分时比较糟糕的。</p>
<p>为了减少这些程序员的出现，可以注意下面几个方面：</p>
<p>1.招聘时一定要仔细看简历，核实简历的真实性，尽量防止把糟糕的程序员招聘到公司中。</p>
<p>2.招聘时一定要有笔试。笔试可以不难，就看基本功如何、表达能力是否可以，编程能力合格就行。</p>
<p>3.招聘时尽量别一个做主，尽量多做几轮面试。</p>
<p>4.招聘时一定要有试用期，如果时糟糕的程序员可以把试用期延长。</p>
<p>5.若一个程序员比较糟糕，赶紧向领导汇报情况。长痛不如短痛。</p>
<p>6.糟糕的程序员写出来的代码是很糟糕的，后期维护改进是永无止境的痛苦。</p>
<p>7.糟糕的程序员一般思路紊乱。而能把一个不靠谱的人培养成一个靠谱的人，需要遇到高手，如果没有这个能力还是让别人去培养吧。</p>
<p>8.遇到不靠谱的程序员，就委婉的建议它干其他行业。</p>
<p>9.一般来说，不靠谱的程序员与学历、工作年限是无关的。</p>
<p>（三十四）国内 IT生意难做，想生存发展大家还得多思考一下，出路在哪里？</p>
<p>国内项目的价格已经压得很低了，还有些公司不计成本，亏本的买卖也干，导致现在国内的项目生意是非常难做的。贱买贱卖的实在太多了。</p>
<p>希望中国IT行业的残酷的竞争环境能给那些想创业的开发人员泼个冷水，若是积累不过还是安心地好好打工吧，生活质量会更好。</p>
<p>（三十五）管理重要还是干活重要？</p>
<p>以前习惯了个人英雄主义，现在更多的是注重团队合作。当然，从心底重视团队合作与嘴上讲团队合作是两码事。</p>
<p>1.我们国家很可能做开发的人比美国多，但是由于管理水平没人家好，我们再辛苦，还是干不过别人，因为缺少正在核心的管理。</p>
<p>2.虽然我们国家缺少非常优秀的大牛，但是相对优秀的开发人员还是不难找的。</p>
<p>3.能把一个庞大的队伍带领好，指挥好，是非常有挑战性的，我们又有几个人能管理微软、Oracle、Google这样的公司呢？</p>
<p>作为一个又十几年检验的程序员，我也发现了，我们缺少的不是普通开发人员，缺的是有管理经营能力的人。</p>
<p>中国IT行业差的不是程序员，不是钱，而是精英管理人才。</p>
<p>（三十六）建议一个人做项目，也建议使用版本管理</p>
<p>项目管理的好处：</p>
<p>1.有时候由于操作失误，程序覆盖了，找不到原来正确的代码，那会很辛苦的。</p>
<p>2.若同行看到你自己一个人写代码都在用版本管理管理软件，他们都会觉得你很专业，将来指挥大家也会更容易一些。</p>
<p>3.如果需要别人帮你修改代码，而你很早就在用版本管理器，在加上几个人一起开发会很方便，效率也会很高。</p>
<p>所以代码要保存好是很重要的。你最好随时上传到自己的服务器中，或公司指定的服务器中，并且不定时的把自己的代码放到移动硬盘等设备中保存。</p>
<p>（三十七）为什么曾经的公司不做外包项目</p>
<p>理解：</p>
<p>1.现在很多商家不够诚信，不遵守合约，在做外包的过程中往往会采取挖墙脚的战略。</p>
<p>2.若碰到不要脸的、实力强大的客户，他会主动索要你的员工。</p>
<p>3.做外包的过程中往往会有员工离职的情况，这时又要补充新人，重新理顺项目。</p>
<p>4.做外包的过程中，很多技术、很多做法，都会被客户学到，客户自己学到了后，很少再有持续的合作，或者下次合作把价格压得很低廉。</p>
<p>5.虽然做外包项目能有小的盈利，但是无法长期盈利。因为做成功的东西的版权都是客户的，不是开发公司的。</p>
<p>（三十八）在北京做银行项目的亲身感受</p>
<p>总结：</p>
<p>1.银行项目对软件的安全要求比较高，信息的发送接收都需要有安全保障。</p>
<p>2.需要多重密码来保证系统的安全性。例如登录时需要密码，进行数字签字时需要密码，交易时也需要密码等。</p>
<p>3.所有的数据都需要进行数字签名，采用公钥、私钥的方式进行不对称的签名验证，以确保数据安全。</p>
<p>4.所有的窗体、数据、按钮等都需要有严格的权限管理控制。</p>
<p>5.其他。。。</p>
<p>（三十九）这几年养成的几个比较好的工作习惯</p>
<p>1.做事情要有计划，不蛮干，不瞎折腾。</p>
<p>例如，把需要做的事情都列好，哪个做好了，就打个勾，一个个把事情搞定。</p>
<p>2.没有事情做了，向领导说一声，领导安排下来的事情做好了，及时汇报领导，能做到这一点是很不容易的。</p>
<p>3.每天做了什么记录下来，每周回顾下，偶尔有空翻看下，以前都折腾啥，以前的折腾是不是可笑，是不是做了正确的事情。</p>
<p>4.平时主张“站立式开会”，大家把需要解决的问题说出来，已经做好了什么，接下来做什么，别扯个没完没了。站着开会很节省时间。</p>
<p>5.尽量用电话+电子邮箱的沟通沟通方式，电话沟通及时有效，电子邮件有个依据，能留下痕迹，证据。</p>
<p>6.至少看《程序员》杂志，溜达CSDN，博客园，51CTO，了解一下行业的动态，别一不小心成了井底之蛙了。</p>
<p>7.平时多注意积累，不重复劳动，不盲目劳动，把自己的劳动成果尽量重复利用。</p>
<p>8.只为赚钱折腾，不赚钱的事情，就不折腾，人的精力是有限的，折腾来折腾去都会浪费不少时间和金钱。</p>
<p>若你有这些有点，那很容易变成管理型人才。</p>
<p>（四十）能亲自构架万人并发大数据量的软件应该是职业生涯的荣幸</p>
<p>一般的企业信息管理系统，20几个人用的就可以卖出20万的价格，当然如果商务谈的好可以卖出更高的价格。</p>
<p>做一个大项目，最难的是让别人相信你能把这个高并发高压力的系统搞定，这不是能靠关系或钱决定的，必须要有多年的积累，用事实证明你有这个实力，而且就算出了问题也能马上解决好。</p>
<p>那么大项目中需要注意什么呢？</p>
<p>1.首先需要有非常好的宽带，若要支持上万人同时录入数据，至少要10M以上。</p>
<p>2.需要有一台牛X的Web服务器+一台牛X的数据库服务器。需要录入1000万条以上的数据，最好采用Oracle数据库，经得起考验一些。</p>
<p>3.需要进行适当的缓存优化策略。不是所有的数据都依靠数据库访问，而要尽量多的使用缓存策略。</p>
<p>4.需要一个牛X、经得起考验的数据库访问层。如果是不好的数据库访问组件，或者不稳定的数据访问组件，很容易导致系统崩溃。如果占用非常大的内存，也会导致系统崩溃。</p>
<p>5.需要优化分页存取数据的功能，因为有可能有1000万条甚至更多的数据。如果分页没做好，也会导致系统崩溃。如果上万人同一个时间，或者在接近的时间点了查询某页的数据，那系统就真崩溃了。分页存取需要做到极致才可以。</p>
<p>6.需要进行数据库索引优化。有索引和没有索引的性能差异有时候是100倍，有时候是1000倍或更多。</p>
<p>7.严谨的高效的数据库事务处理。由于高并发，而且有些数据是需要同时写入多个表，需要保证数据库的一致性。</p>
<p>8.所有的系统操作日记、异常信息都需要完整记录下来。当系统发生故障时，可以快速排查问题。</p>
<p>9.需要经常检查系统的各项指标。例如各服务的内存使用情况、CPU使用情况，网络宽带使用情况。若服务器快受不了压力了，就得马上进行负载均衡，网络宽带不够了就需要马上增加宽带，不要等到系统崩溃看再去做这些事情。</p>
<p>10.HTML、JS等都可以考虑用压缩模式传输，那样网络传输效率会更高一些。</p>
<p>以上就是我在本文中所要表达的全部，希望以上的内容可以帮助到正在默默艰辛，遇到瓶疾或者正在自己创业的程序员们，我能帮你们的只有这么多了，希望大家在往后的工作中，遇到我在文中提到的注意事项时，可以圆满解决。</p>
<p>觉得小编写的文章不错，能对自己有所帮助的，可以点个赞，加个关注。</p>

                ", 程序员的十年工作创业血泪史，万字长文，仔细读完，受益匪浅,1531977905,382,1,162,1,1,https://segmentfault.com/a/1190000014021889
48,1,0,9,"
                    
<p>30 岁出头的年纪，正是娶妻生子的时候，一方面家庭压力增大，一方面职场上的地位却越发尴尬。稍不留神，就会在这两个战场节节败退。</p>
<p>那么，在这个时代，想给自己一份保障，让自己能够从容地活着，到底应该怎么办？</p>
<p>哪怕你还没到 30 岁，也应该好好看下这篇文章。毕竟，人总有 30 岁的时候，未雨绸缪，总是不会错的。</p>
<p>30 岁的老员工，到底有多惨</p>
<p>我们先来看几条新闻：</p>
<p>去年年初，有华为内部人士发帖称，华为中国区开始集中清理34 岁以上的交付工程维护人员，研发开始集中清退40 岁以上的老员工。</p>
<p>虽然华为官方随即否认了这条消息，但网上曝光的华为老总任正非的一篇讲话，却还是看出华为对于员工的态度和要求：</p>
<p>“华为是没有钱的，大家不奋斗就垮了，不可能为不奋斗者支付什么。30 多岁年青力壮，不努力，光想躺在床上数钱，可能吗？”</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Er9?w=500&amp;h=341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>去年年底，42 岁的中兴程序员欧某从中兴通讯的大楼顶上一跃而下，留下四位老人和一对年幼的儿女。</p>
<p>自杀的原因，是他被领导谈话，说公司要大规模裁员，要求他主动离职，并回收股权。</p>
<p>妻子没有工作，在家当家庭主妇，两个年幼的孩子嗷嗷待哺，四位老人要照顾，还有车贷、房贷…全家老小的生活，都维系在欧某一个人身上。</p>
<p>重压之下，他选择了一条不归路。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Esb?w=640&amp;h=427"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>除此之外，身边更是不少这样令人心碎的案例：</p>
<p>一个百度出来的总监，40 岁左右，因为人事斗争被架空，一气之下辞职创业，觉得自己有人脉有资源能混口饭吃，没想到啥都没做成，最后只好在家里蹲着，每天接送孩子上下课，偶尔给人做做行业顾问赚钱。</p>
<p>一个外资公司中国区销售总监，因为外资撤离，公司倒闭，他失业了，因为超过 45 岁，没有中国公司敢要他，他只能自己创业，半年就亏掉了 100 多万。</p>
<p>一个普通白领，30 岁，公司倒闭了，在家蹲了大半年，每天洗衣做饭，急得晚上睡不着觉，但也没办法，只能日复一日在招聘网站上投简历，最后终于有公司要他了，但工资只有之前的一半，还只做了三个月，又被开除了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Esh?w=640&amp;h=427"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这些故事里，不少人都会说，都怪他们没有危机意识，完全是咎由自取；也有人觉得，他们懒惰、不努力，才会陷入这样尴尬的地步。</p>
<p>事实上，每一个面临裁员的人，并不是不努力，而是他们天真地认为，自己只要勤勤恳恳干活，就能有丰厚的回报。</p>
<p>之前有一条新闻，某地收费站被撤销，收费员围着领导讨说法，其中一位放声痛哭：“我今年 36 岁，除了收费啥都不会！”</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Esq?w=337&amp;h=191"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>据报道，收费员们也很辛苦，逢年过节也没得休息，经常在收费点一坐就是一整天。</p>
<p>然而，时代变了，这是一个选择比努力更重要的时代。</p>
<p>把自己人生的所有希望，赌在一家企业、一个老板身上，却不为自己打算和规划，那一旦被抛弃，受伤最深的一定是你。</p>
<p>很多人错把平台当作自己的价值<em>*</em>*，你在平台上，还有价值，但是放到社会上，却没有价值。</p>
<p>唯一的办法，就是千万别把自己交出去，时刻为自己打算。属于平台的价值根本不属于你，属于你自己的本事，谁也拿不走。</p>
<p>财富的关键：为自己打算</p>
<p>“日本战略之父”大前研一在《专业主义》中提出了这样的观点：</p>
<p>“你凭什么胜出？未来能够牵动世界大势的，是个人之间的竞争。能否独霸世界舞台，锻造他人无法超越的核心竞争力？你唯一的依恃，就是专业。”</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Ess?w=431&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>大前研一</p>
<p>无论你想成为什么样的人，最重要的是给自己找到一个专业定位，树立自己的品牌形象，这样以后你的职场发展，就会有更多的筹码。</p>
<p>2016 年，有一部非常热门的网剧叫做《法医秦明》，这部网剧是改编自《法医秦明》系列小说。</p>
<p>这套小说的作者，就是一名职业法医，名字就叫秦明。工作之余，他写小说、和网友分享自己的办案经历。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Esw?w=500&amp;h=341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>秦明</p>
<p>久而久之，他成了中国最有名的法医，小说火得一塌糊涂。</p>
<p>论做法医的专业技能，秦明一定不是最好的，但他聪明之处就在于，将自己的经验，打造成一个有强大变现能力的 IP。</p>
<p>这样一来，任凭周围的环境怎么变化，只要“法医秦明”这个牌子还在，他就永远不怕没有饭吃。</p>
<p>由此可见，把握财富的根本，就在于跳出本职工作，挖掘更多让自己财富增值的可能。</p>
<p>老实说，光靠给老板打工，你这辈子就能安稳过去了？</p>
<p>30 岁之前：如何打好基础</p>
<p>我建议你做两件事。</p>
<p>第一件，找准一个可以为之奋斗 5 年、 10 年甚至更久的目标。</p>
<p>这是一种最理想的状态。因为一个清晰的目标，可以让你的职业成长围绕着一个点去积累经验，而这种日积月累的经验积累，也是你日后升职加薪的筹码。虽然经验并不一定与能力相关，但如果没有经验的积累，你的能力也基本没有提升的可能。</p>
<p>Macolm Gladwell 在他的著作《异类》中说：无论是最优秀的运动员，企业家，音乐家还是科学家，经调查，你都会发现他们至少都在付出了长达十年，每天不低于三小时的努力之后才崭露头角的。</p>
<p>书中有这样一个故事：</p>
<p>马克西姆·文格罗夫出生在西伯利亚，4 岁的时候，他接触到了第一把小提琴，展现出了过人的天赋。</p>
<p>并且，他的天赋和敬业度是成正比的。他每天练习 7 小时，5 岁就举办了独奏会，15 岁就获得了国际大奖，34 岁就成了世界顶级小提琴家。</p>
<p>文格罗夫说：“我母亲每天晚上 8 点回到家，吃完晚饭之后就教我小提琴直到凌晨 4 点。对于一个 4 岁的小孩来说，这简直就是酷刑，但两年后我变成了小提琴手。”</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6Esy?w=460&amp;h=461"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>很多人在抱怨没有机会。其实并非如此。</p>
<p>肯特大学的社会学教授弗兰克·弗雷迪认为，有效投入很多时间去练习的人自然会拥有自己的运气：“他们近乎苛求地努力，当运气来的时候，他们早就准备好了。”</p>
<p>如果你没有遇到机会，不要抱怨，首先要反思：自己到底哪些方面准备不足？</p>
<p>根据我们的经验，只有你在一个方向上坚持至少 5 年以上，你才有可能得到回报，而且这种回报会对你以后的职业发展产生一个相对长期的影响。同时，也正是这么长时间的积累，让你的基础非常扎实和牢固，你的脚步也会站得更稳。</p>
<p>建议你要考虑的第二件大事，就是学会做人。</p>
<p>我甚至认为，会做人比会做事还要重要百倍。找到一个合适的职业目标，对于很多迷茫中的人来说可能并不是容易的事；但学会做人，则是你在任何公司、任何时候都可以修炼的一种职业素养。</p>
<p>在做人的修炼中，有四项要素，是能够对你以后的职业发展起到致命性影响的：</p>
<p>1、你的人际关系处理能力</p>
<p>这其中包括与你的上司的关系，以及与你的同事的关系。</p>
<p>2、不断学习的能力</p>
<p>我曾经碰到一个客户，已经近 40 岁的人了，做会计做了 14 年，仍然只是一个基层主管的职位，在公司中也看不到晋升的机会，好多年没有加薪了。</p>
<p>我们问他：“在这 14 年中，你有没有进行过培训、进修或者任何其他形式的充电？”</p>
<p>“没有。”</p>
<p>“从来没有吗？”</p>
<p>“从来没有。”</p>
<p>这是一个非常极端的例子，但这种现象在职场中却是非常普遍的。</p>
<p>没有学习，你的职业发展就会在原地踏步。你以为你没有退步，但实际上别人在进步，你与别人之间的差距在不知不觉中拉开了，就等于退步了。</p>
<p>3、树立职业化精神</p>
<p>不管你有没有目标，不管这项工作是不是你愿意做的，只要你在这个岗位上，你就应该把事情做好。</p>
<p>即便这份工作你不喜欢，也不要用消极的的方式去对待，因为你不仅在浪费公司的时间，更是在浪费你自己的时间。</p>
<p>身在职场，你能收获的无非是两种东西：一是回报，二是成长。在没有明确的目标之前，把眼前的事情做到极致，把所有你能够在这个职位上得到的东西，统统用自己最大的努力去争取。以消极的态度对待工作，你会两手空空，什么也得不到。</p>
<p>4、要有强大的内心</p>
<p>我所遇到的很多人，其实内心里都很脆弱，无法经受漫长人生道路上所降临的各种苦难。要知道，每个人的成长都不是一帆风顺。即便是耶稣，又何尝不会遭受苦难的洗礼?</p>
<p>强大的内心可以让一个人在绝望中看到希望，而消极悲观只会让你在希望面前错机良机。</p>
<p>《肖申克的救赎》中有这样一句台词：</p>
<p>“懦怯囚禁人的灵魂，希望可以令你感受自由。强者自救，圣者渡人。”<br>你没有本事成为圣者，但一定要变成强者。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6EsH?w=600&amp;h=337"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>30 岁之后：如何实现质的突破？</p>
<p>要想让你 35 岁以后的职业生涯实现比较大的发展，你应该从 30 岁开始，好好利用 5 年时间，着手准备以下 3 件至关重要的事情：</p>
<p>1 、完成你的专业化品牌构建</p>
<p>“日本战略之父”大前研一在《专业主义》中提出了这样的观点：</p>
<p>“你凭什么胜出？未来能够牵动世界大势的，是个人之间的竞争。能否独霸世界舞台，锻造他人无法超越的核心竞争力？你唯一的依恃，就是专业。”<br>你是一流的商务人士，还是一般的上班族？差别就在这里！给自己一个专业定位，树立自己的品牌形象，会为你以后的职业发展增加更多有价值的筹码。</p>
<p>为了支撑你“专业化”的品牌形象，你需要在以下两个方面做出努力：</p>
<p>第一，就是前面提到过的知识结构问题。</p>
<p>要脱离具体的操作层面的问题，把你看待问题的眼光放得更高一些，更远一些，成为一个具有“远见卓识”而不是“鼠目寸光”的人。</p>
<p>你要向这个行业里最优秀的人看齐，并以他们为目标，作为自己修炼成长的榜样，一步一步弥补与优秀之间的差距。这个时候，在职学习、进修等等都需要提上日程，学会用新的知识充实自己的头脑。</p>
<p>第二，就是树立自己在行业内的影响力。</p>
<p>你要想成为优秀的职场人士，也必须向那些最优秀的人看齐，树立在这个行业内的影响力，用你的思想去影响别人。</p>
<p>我们去年遇到一个非常优秀的小伙子，至今印象深刻。</p>
<p>他是一个印刷专业的大专生，毕业之后去印刷厂做销售。正是这样一个看起来没有什么含金量的职位，他却用自己独特的方式构建着自己的影响力。</p>
<p>他给自己定了一个要求：每月都要写一篇文章，发表在这个行业内最具影响力的杂志上。当然，并不是每篇文章都能够达到发表的质量，但每个月必须要保证质量写一篇。</p>
<p>这样做的好处，第一是树立了你在这个行业内的影响力；第二，可以让你形成自己的知识结构。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV6EsP?w=640&amp;h=427"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><strong>2、</strong>把自己培养成一个优秀的中层管理者</p>
<p>走上了管理者岗位，是你职业成长的关键一步。以后的发展空间，都与此次的晋升密不可分。但这个位子并不是每个人都能够坐稳。</p>
<p>盖洛普曾经做过一项调查，发现基础员工之所以离职频繁，很多时候问题并不在于公司，而是在于其上司：公司的中层管理者。</p>
<p>正因为中层管理的不善，而对于下属员工的发展与成长造成了非常不利的影响，导致他们职业发展无论是在专业能力上，还是在职业修养上，均不能得到有效的成长。</p>
<p>你必须要意识到：你的管理，将有可能改变你的下属的终身命运，是你错误的管理方式在不知不觉中伤害到你的下属，迫使他们离开公司。</p>
<p>当你的成长因为你的上司而受到阻碍的时候，这是你的不幸，你可以选择“用脚投票”；当你某一天也成为管理者的时候，我们不希望把这种不幸继续传递下去。</p>
<p><strong>3、</strong>找一家成长中的公司，伴随其成长</p>
<p>这是一件非常重要的事情。</p>
<p>一是你可以亲眼目睹一家公司从小到大、由弱到强的成长历程，对于公司的运营也会有更加深入的理解，你也能够体会到你的角色在公司成长中的位置和作用。</p>
<p>二是在公司成长的过程中，你的价值会有更大的发挥余地，会更容易展现出来<strong>。</strong></p>
<p>很多人在找工作时都倾向于寻找大公司，这也可以理解，但是要想快速的成长，寻找规模不太大的成长中的公司，其实是更好的一种选择。因为在成长的过程中，会对于人才的需求较为迫切，你的职位晋升也会更快。</p>
<p>三是你的忠诚度会为你的发展带来更多的回报。</p>
<p>企业用人，其中最重要的一条就是忠诚度。尤其是现在跳槽率、流失率在众多企业居高不下的情况下，忠诚就成为一种非常难能可贵的职业精神。</p>
<p>不论你现在已经“奔三”，还是正在“奔三”的路上，请始终告诫自己：不要虚度了大好年华，抓住所有能够抓住的时间，为自己的生命多积累一些厚度。</p>
<p>最后，借用我最喜欢的乔布斯语录，作为本文的结尾：</p>
<blockquote>人这一辈子没法做太多的事情，所以每一件都要做得精彩绝伦。<br>你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音。<br>最重要的是，勇敢的去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其他一切都是次要。</blockquote>
<p>喜欢我文章的朋友可以点赞关注。将文章分享出去，让更多人看到。</p>

                ", 程序员30 岁之后：如何实现质的突破？,1531977907,336,1,98,1,1,https://segmentfault.com/a/1190000013939591
49,1,0,9,"
                    
<p>欢迎大家前往腾讯<a href=""https://cloud.tencent.com/developer/"" rel=""nofollow noreferrer"">云+社区</a>，获取更多腾讯海量技术实践干货哦~。</p>
<blockquote>作者介绍：陈阳(Younger)<br>2011年加入腾讯，现就职于腾讯游戏增值服务部，负责AMS游戏营销平台，致力于研究和推动Web及大前端相关技术的发展。</blockquote>
<h1>一、微信小游戏——H5小游戏及微信小程序</h1>
<p>微信小游戏、H5小游戏以及微信小程序，他们到底是什么关系呢？ 就像这个图一样，微信小游戏，目前其实就是微信小程序里能运行的H5小游戏，既属于微信小程序，也是H5小游戏。 另外这三者 实际也是有区别的，后面会讲。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834899?w=601&amp;h=314"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h1>二、H5小游戏</h1>
<h2>什么是H5小游戏</h2>
<p><strong>首先看一下，什么是HTML5</strong></p>
<p>HTML（Hyper Text Markup Language），超文本标记语言。</p>
<p>1991年，HTML1开始研发。</p>
<p>1993年，HTML1发布。</p>
<p>1999年12月，HTML4发布。</p>
<p>2004年，WHATWG提出Web Applications 1.0，HTML5草案的前身。</p>
<p>2006年，W3C与WHATWG决定合作，推进新版HTML。</p>
<p>2008年01月，HTML5第一份正式草案公布。</p>
<p>2014年10月，W3C宣布HTML5正式公布发布。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834900?w=380&amp;h=373"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>HTML5新规则：减少对外部插件的需求,比如Flash等；</p>
<p>HTML5新特性：canvas、video、本地存储、websocket、新内容元素等等。</p>
<p>可以看到其实在1999年的时候，就已经是html4了，但是到14年w3c，也就是万维网联盟(World Wide Web Consortium,简称W3C) 才正式宣布html5发布。 这中间是一个比较艰辛漫长的过程。而且这中间还出现了一些插曲，比如在06年左右，那个时候盛行flash，很多站点整站flash，还出现了一些比较有代表性的flash小游戏，比如小小flash。不知道大家是否有印象，就是简单几个小人可以操作打来打去，非常有趣。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834901?w=100&amp;h=77"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>那个时候还有个闪客帝国比较有名，可以上传自己的flash作品。这些是06年左右。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834902?w=1392&amp;h=595"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>但其实广义上来看，H5开发，是一个技术合集。如图五，我列了一些主要的点，比如基础知识及标准规范，包括html5、css3、es(我们现在开发中用的主要是es6规范来的)，还有typescript （typescript和javascript最大的一个区别就是 typescript是强类型的），当然还有W3C的一些其他规范比如DOM/BOM（浏览器对象模型，比如window.xxx）。然后还有H5开发需了解熟悉的开发及调试工具。接着就是在安全及性能优化这块，csrf/xss 这些是常见的。</p>
<p>这里再简单说一下 WebAssenmbly, 说一下这个webAssembly的大致由来，js解释性语言，一大特点相对来说性能比较慢，而且特别是网页应用复杂的时候，所在google在09年的时候 在v8引擎里加入了JIT（即时编译），有了buff后，差不多提升20~40倍。JIT是基于运行期分析编译的，而javascript是一个没有类型的语言，于是大部分时间，JIT编译器是在猜测类型，如果类型猜错了只能推倒重来。所以那个时候就有两种思路，一种是Typescript， 这样就不用猜类型了；一种是asm.js，其实也是标记类型。然后谷歌、 苹果、 微软、 W3C就想把这种方法标准一下，结果呢， 激进了，标注类型的事情也不要了，干脆直接定义一种新的方式，比如用c/ c++写，编译成一个.Wasm格式二进制文件，通过javascript直接载入这个二进制文件运行。这样子的话，可以让web应用和原生应用性能差距缩小。</p>
<p>接着说 H5开发的其他主要相关点，一个是工程化，这其实也是最近这些年兴起的，特别是在前端的大型项目上。这主要需要掌握几种规范Commonjs、AMD，以及主要的工具比如webpack。然后就是主要的库 和 框架。这里说一下weex， weex是阿里推出来的其实通常是和vue配合使用的，和facebook的react native类似，可以让开发人员用js去写原生的应用，所以通常被人称为 vue-native。week会提共weekSDK，会准备一个js引擎，在执行过程中会产生各种命令发送给原生端渲染等等。</p>
<p>最后主要是游戏开发相关的，比如DOM CSS，还有Canvas、WebGL，以及一些游戏引擎。当然还有些其他点。 其实游戏开发这块，和整个H5开发来说，区别还是有一些的，做普通web开发的可以不用了解这块。所以在一些公司，已经将H5游戏开发与web前端开发分开了。 好，这里总结一下，H5游戏，就是基于H5技术合集开发出来的小游戏。</p>
<p>H5小游戏特点：</p>
<p><strong>优点：</strong></p>
<blockquote>开发成本相对低<p>跨系统、跨终端、跨平台</p>
<p>无需下载安装，即点即玩</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>制作门槛相对低<p>缺少固定流量入口</p>
<p>体验差距（性能、流量等）</p>
</blockquote>
<p>据艾瑞咨询与白鹭时代等网络数据——2017年H5游戏市场为30亿元，手游市场规模达到1440亿元，两者比值为1:48。以端游、页游发展过程为参考，页游与端游的市场比值约为1:3。伴随着流量资费的降低、手机的更新换代、H5的持续发展，H5游戏多流量入口和即点即玩的特征，H5游戏市场 可能存在巨大的增长空间。</p>
<h2>H5小游戏发展简述</h2>
<p>2014年，《围住神经猫》、《愚公移山》，朋友圈病毒式传播，参与量过亿</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834903?w=280&amp;h=375"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>2015年，《狂挂传奇》、《奇迹西游》，月流水上百万</p>
<p>2016年，《传奇世界》、《决战沙城》，月流水2000万+</p>
<p>2017年，《大天使之剑H5》，公测24天流水破亿，逐渐形成盈利效应—(三七互娱); 同年，QQ、微信、QQ浏览器、腾讯视频开启H5小游戏专区; 企鹅游戏APP、玩吧APP等专门的H5游戏平台诞生。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834904?w=469&amp;h=378"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>2017年12月28日，微信正式公布小程序支持小游戏。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834905?w=213&amp;h=371"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>简单H5游戏开发技术</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834906?w=335&amp;h=504"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>最初只是一些简单的游戏，比如俄罗斯方块，这种主要的技术点就是DOM操作，用jQuery原生javascript css3就可以了。画面内元素比较简单，逻辑不会太复杂，结构与常规Web页面一致；主要技术点：DOM元素、jQuery、原生javascript css3</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834907?w=390&amp;h=282"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>稍复杂H5游戏开发技术</h2>
<p>复杂度相对传统Web页高。</p>
<p>主要技术点：canvas、javascript、部分dom元素 css3</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834908?w=591&amp;h=475"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>然后再复杂一点，比如切水果，相对复杂一些，主要是canvas 部分dom元素的操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834909?w=378&amp;h=276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>复杂H5游戏开发技术</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834910?w=301&amp;h=553"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>然后，再看一下，复杂的游戏开发，比如传奇世界，主要是基于H5游戏引擎来做的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834911?w=458&amp;h=561"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>H5小游戏引擎</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834912?w=905&amp;h=463"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span><span class=""img-wrap""><img data-src=""/img/remote/1460000013834913?w=998&amp;h=575"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<blockquote>看一下这些游戏引擎的主要对比。白鹭，是目前社区非常活跃的H5引擎，去年宣布支持 webassembly，而且2d 3d vr都支持的，同时支持js、ts开发，经典的代表就是传奇世界。另外，laya引擎，是支持js ts as（actionscript）的。所以以前做flash/as开发的或许可以转到这上面来。然后还three.js，只支持3d的，跳一跳和纪念碑谷小游戏，都是通过three来的。然后cocos2d，这个也是一个老牌引擎，欢乐斗地主。然后再说一款，阿里也开源了一款H5小游戏引擎hilo。阿里双十一的营销活动小游戏、天猫狂欢城等都是通过这个来的。</blockquote>
<h2>前端工程化</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834914?w=613&amp;h=306"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>再看一下前端工程化，这个其实也是近些年起来的一个概念。主要是需掌握代码组织规范、webpack工具（帮你压缩 打包 解决依赖关系等等 ），然后还要了解node.js, 基于v8引擎的。其实这个也用于服务端编程。另外就是NPM 包管理。</p>
<p>以上这些就是H5游戏要了解的基本点。</p>
<h1>三、微信小程序</h1>
<p>然后看一下微信小程序。微信小程序，其实也是基于webview的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834915?w=891&amp;h=490"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore（IOS）、X5（安卓） 作为运行环境。</p>
<h1>四、微信小游戏</h1>
<h2>小游戏 与 H5游戏、小程序对比</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834916?w=955&amp;h=597"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>小游戏是在H5游戏的基础上增加微信社交能力、文件系统、工具链，去掉一些对游戏开发不是那么重要的，像Dom、Bom等，从这张图可以看出来，微信小游戏没有webview了，H5规范API这里是微信小游戏sdk自己实现的，比如canvas webgl。然后还有就是 游戏引擎这一层，是做了一个适配</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834917?w=758&amp;h=410"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>小游戏资源加载</h2>
<p>目前核心游戏包 4M（用于首次加载），可以实现即下即玩，需3~5秒的下载</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834918?w=815&amp;h=527"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>理论上，用户若不主动删除，微信客户端只会更新不会删除；容量没有固定值，只有不够用的情况下根据LRU(Least recently used)规则进行删除。</p>
<h2>小游戏Adapte</h2>
<p>小游戏的运行环境在IOS上是Javascript Core， 在Andriod上是 V8，没有DOM和BOM的运行环境。 Adapter，通过wx api模拟BOM、DOM的代码库。</p>
<blockquote>Adapter 是为了让基于浏览器环境的第三方代码更快地适配小游戏运行环境的一层适配层，并不是基础库的一部分。更准确地说，我们将 adapter 视为和游戏引擎都视为第三方库，需要开发者在小游戏项目中自行引入。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834919?w=658&amp;h=386"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>当然，游戏引擎也自己做了适配的，例如cosos</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834920?w=838&amp;h=634"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>小游戏开放注册品类</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834913?w=998&amp;h=575"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>目前是6大类 24个子类</p>
<h2>小游戏开放能力及API</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834921?w=802&amp;h=543"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>小游戏开放工具</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834922?w=1009&amp;h=646"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>小游戏开发工具</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834923?w=1021&amp;h=625"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<p>为了帮助开发者简单和高效地开发和调试微信小程序、微信小游戏，微信在原有的公众号网页调试工具的基础上，推出了全新的 微信开发者工具，集成了公众号网页调试和小程序、小游戏开发两种开发模式，而且自带小游戏demo。详情可参考mp.weixin.qq.com。</p>
<h1>五、微信小游戏应用</h1>
<h2>小游戏营销体系的建设</h2>
<p>小游戏的营销活动、营销应用等的建设。</p>
<h2>游戏预热及用户沉淀</h2>
<p>简单试玩版，提升玩家对游戏的期待，沉淀用户。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834924?w=271&amp;h=463"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>小游戏化营销</h2>
<p>通过小游戏做一些营销活动 或者 营销推广。(阿里双十一、天猫狂欢城等)</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834925?w=485&amp;h=384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<h2>APP导流</h2>
<p>可以给APP导流</p>
<h2>品牌传播</h2>
<p>借助小游戏的流量传播优势，做品牌传播等等。</p>
<p>最后感谢苏秋宏、黄剑鑫、陈亮亮、李一奇、王跃等提供的相关分享参考，以及以下参考资料：</p>
<blockquote>《微信公开课2018》<p>《微信小游戏适配原理》—— cocos 王哲</p>
<p>《天猫双11晚会和狂欢城的互动技术方案》InfoQ——邓红春(阿里巴巴 续彬)</p>
<p>《利用HTML5，CSS3和WebGL开发HTML5游戏》——丹麦Jacob Seidelin 黄蔚瀚译 电子工业出版社</p>
<p>《前端工程化-体系设计与实践》——周俊鹏 电子工业出版社</p>
</blockquote>
<p>大家共同努力，推动WEB及大前端的发展！</p>
<blockquote>
<h2>问答</h2>
<p><a href=""https://cloud.tencent.com/developer/ask/59126"" rel=""nofollow noreferrer"">微信小游戏与传统的手机游戏有什么区别？</a></p>
<h2>相关阅读</h2>
<p><a href=""https://cloud.tencent.com/developer/article/1017421"" rel=""nofollow noreferrer"">什么是微信小游戏？官方解释</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1027185"" rel=""nofollow noreferrer"">微信小游戏的6大趋势分析</a></p>
<p><a href=""https://cloud.tencent.com/developer/article/1020391"" rel=""nofollow noreferrer"">有故事的微信小游戏“跳一跳”</a></p>
</blockquote>
<hr>
<p>此文已由作者授权腾讯云+社区发布，转载请注明<a href=""https://cloud.tencent.com/developer/article/1065070"" rel=""nofollow noreferrer"">文章出处</a></p>
<p>原文链接：<a href=""https://cloud.tencent.com/developer/article/1065070"" rel=""nofollow noreferrer"">https://cloud.tencent.com/dev...</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013834926?w=600&amp;h=773"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>

                ", 鹅厂内部干货|微信小游戏开发技术怎么应用？,1531977908,292,1,400,1,1,https://segmentfault.com/a/1190000013834894
50,1,0,9,"
                    
<p>后端好书阅读与推荐系列文章：<br><a href=""http://mageek.cn/archives/33/"" rel=""nofollow noreferrer"">后端好书阅读与推荐</a><br><a href=""http://mageek.cn/archives/34/"" rel=""nofollow noreferrer"">后端好书阅读与推荐（续）</a><br><a href=""http://mageek.cn/archives/42/"" rel=""nofollow noreferrer"">后端好书阅读与推荐（续二）</a><br><a href=""http://mageek.cn/archives/43/"" rel=""nofollow noreferrer"">后端好书阅读与推荐（续三）</a><br><a href=""http://mageek.cn/archives/44/"" rel=""nofollow noreferrer"">后端好书阅读与推荐（续四）</a></p>
<p>这里依然记录一下每本书的亮点与自己读书心得和体会，分享并求拍砖。</p>
<h2>Docker生产环境实践指南</h2>
<p>Docker生产环境实践指南 (豆瓣) <a href=""https://book.douban.com/subject/26825958/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>前面docker的基本概念和一些核心原理都看的差不多了，那么现在该关注一下具体的生产环境的使用方法了。</p>
<p>亮点：</p>
<ul>
<li>在生产环境中运行docker与在其它环境中相比，最主要的差异是需要在其<strong>安全性与稳定性</strong>上投入更多的注意力</li>
<li>书中提到docker 容器与宿主机是通过IPtables实现的nat转换来进行通信，这点官网有说明 <a href=""https://docs.docker.com/engine/userguide/networking/#docker-and-iptables"" rel=""nofollow noreferrer"">Docker container networking</a>，然后就说了不适宜网络吞吐量有很高要求的应用（但是可以禁用Docker的NAT来提升网络性能），但是docker已经做出了一些努力,效果并不差，见：<a href=""https://stackoverflow.com/questions/21889053/what-is-the-runtime-performance-cost-of-a-docker-container"" rel=""nofollow noreferrer"">1</a>,<a href=""https://stackoverflow.com/questions/18858090/why-containers-network-throughput-is-low"" rel=""nofollow noreferrer"">2</a>,<a href=""https://jtway.co/docker-network-performance-b95bce32b4b9"" rel=""nofollow noreferrer"">3</a>
</li>
<li>书中对于docker相关常见的概念解释得非常清晰易懂，这一部分尤其适合初学者</li>
<li>docker生产环境最好的方式是将应用程序及其依赖预先打包成一个镜像，而包含数据库凭证等铭感信息在运行时动态添加（安全起见）；常见流程是开发机上打包并推送到仓库，然后服务器从仓库拉取镜像，这种用例简单但是从工作流和安全角度看并不理想，更标准的做法是使用持续集成 / 持续交付系统在应用程序代码或者dockerfile发生变化时自动从新构建镜像</li>
<li>实现开发速度和生产环境稳定的方法之一是拥抱简单，亦即系统的每一个部分——容器——有且只有一个目标。系统的简单需要设计时遵照如下原则：倾向无状态服务，倾向静态配置，倾向静态的网络布局，区别对待有状态和无状态的服务</li>
<li>保持镜像小巧：可以从空的文件系统开始构建，从类似于busybox、aipine这种轻量级操作系统开始构建，如果嫌包少就可以从主流Linux发行版的容器优化版开始构建，最明智的做法是标准化一个特定的镜像版本，并尽可能的用于所有容器；尽可能减少层数，也就是相关的命令尽量放到一行，而且下载的内容用完后要在同一行删除；可以使用<a href=""https://github.com/jwilder/docker-squash"" rel=""nofollow noreferrer"">docker-squash</a>来减小镜像体积</li>
<li>存储镜像：开源、公共项目建议存共有仓库；安全性和性能要求较高的存私有仓库；需要定制的使用save / load。此外，很多人可能不知道，DockerHub其实是提供了自动构建功能的，只要通过WebHook连上Github就行（亲测）</li>
<li>一致性是扩展环境和传播知识的关键，所以应该在一个构建系统中构建所有镜像，而且要实现镜像标准化，让所有镜像（尽可能）继承于一个标准基础镜像</li>
<li>AUFS引擎的挂载速度非常快，能很快的创建新容器所以成为了Docker存储引擎的默认解决方案。其性能瓶颈主要在需要写入大文件的场景，因此使用AUFS来存放数据库文件可能不是一个好主意，同样太多的镜像层可能导致文件查找时间过长，所以不要让自己的文件有太多分层。AUFS有一个最大的问题是没有被容纳到Linux主流发行版。事实上，在生产环境选择存储引擎，一个要点是看业务与特性是否吻合，另一个要点就是选最有把握能稳定运维的工具</li>
<li>Docker网络实现包含三方面内容，IP分配、域名解析、容器或服务发现，这也是<a href=""http://zeroconf.org/"" rel=""nofollow noreferrer"">零配置网络</a>的理论基础。零配置网络即是一组在没有人工干预的情况下自动创建和配置一个TCP/IP网络的技术。</li>
<li>Docker集群之中的服务发现，目前是consul做得最好，可以自定义健康检查机制，不像zookeeper(和TCP会话周期绑定)和etcd(和TTL值挂钩)，提供了一个非常完备的服务发现解决方案</li>
</ul>
<p>本书名副其实，对于在生产环境中使用docker有不错的方向指导意义，当然细节还得自己扣啊。<br>注意：由于时间原因，书中有些内容有些过时但是译者给出了注解（但是译者的注解也可能过时呀，所以一定要自己注意跟踪docker的最新变化）</p>
<h2>The Go Programming Language</h2>
<p>The Go Programming Language (豆瓣) <a href=""https://book.douban.com/subject/26337545/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>为什么要了解一下 golang 呢？最明显的原因就是，这个语言有一款杀手级应用，也就是前面说过很多次的：Docker；而且前一段时间 nodejs 的创始人不是要拥抱 go 语言了吗，作为一个编程语言的创始人转投另一门语言，还是很值得了解一下的；最后，对 go 的协程是早有耳闻，<strong>传言</strong>可以用同步的方式写出异步的代码，轻松实现高并发......</p>
<p>亮点：</p>
<ul>
<li>正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能和选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即使从长远来看，简洁依然是好软件的关键因素。秉承着简洁原则，golang没有内置大多数语言都有的隐式转换、宏、异常、继承等等</li>
<li>依然是简洁原则的贯彻，golang 不允许 import 没有使用的包，也不能定义没有使用的变量，否则连编译都不能通过。还有左大括号必须和代码在同一行......感觉这些强制要求非常有用，多一些标准，少一些歧义，这应该是利于工程化的</li>
<li>break 和 continue 都可以加label来实现跳出任一循环，这个有点像 goto 语句，这种语句我们要少用，一般是在编译器生成代码过程使用的</li>
<li>并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。比如for语句创建了两个词法域：花括弧包含的是显式的部分是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（i++），当然也包含循环体词法域</li>
<li>结构体中的匿名成员是一个比较有意思的特点，可以用来无缝的实现“对象组合”这一需求，组合是 go 实现面向对象编程的核心</li>
<li>大部分语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题</li>
<li>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑</li>
<li>当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。deferred类似于java的finally，可用于保证资源回收、锁释放等</li>
<li>看到第八章终于知道<strong>传言</strong>的大概意思了，只需要在原来同步的调用函数的代码之前加一个 go 关键字，就能新建一个goroutine（可以类比线程，但是有不同之处），然后主线程就能继续干活而不必等待函数执行结束了</li>
<li>线程和goroutine的区别主要有几方面：goroutine的栈不是固定大小的，一般从2KB开始动态变化，所以可以打开几百上千的goroutine，而线程是固定栈大小，不可能开很多；goroutine由Go调度器进行调度，而不是操作系统，采用m:n模型（最多n个线程执行m个goroutine），所以goroutine的切换代价较小</li>
<li>虽然及时修改了一个源文件也要重新编译该文件对应的包及其依赖包，但是go的编译速度非常快，主要有三点原因：所有导入包开头显示声明，快速找到；禁止环装依赖，可以并发编译；编译后的包记录了包的依赖关系，编译器不需要遍历所有依赖文件只需读取直接导入包的目标文件</li>
<li>程序的复杂性是可以控制的，其中两种技术在实践中被证明很有效：软件正式部署前的代码评审；自动化测试（写一些小的程序用来检测被测试代码的行为和预期的一样）。go test 命令是一个按照一定的约定和组织的测试代码的驱动程序，在*_test.go文件中：测试函数以Test为函数名前缀，用于测试程序的一些逻辑行为，go test命令会调用这些测试函数并报告PASS或FAIL；基准测试函数以Benchmark为函数名前缀，用于衡量函数的性能，go test命令会多次运行基准函数以计算一个平均的执行时间；示例函数以Example为函数名前缀，提供一个由编译器保证正确性的示例文档</li>
</ul>
<p>本书名不虚传，对go的基础知识介绍的很详尽，底层原理也稍微有一些涉及，同时还有一些高级的话题比如各种并发、测试等，是一本入门go的好书，看完后对golang就有一个几乎完整的概念了。</p>
<p>PS:gitbook有对应中文版。</p>
<h2>从PAXOS到ZOOKEEPER分布式一致性原理与实践</h2>
<p>从Paxos到Zookeeper (豆瓣)  <a href=""https://book.douban.com/subject/26292004/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>如今搞分布式的似乎都离不开Zookeeper了，Zookeeper一般是作为分布式的基础设施，还是很有必要了解一下的。本书阐释了从集中式到分布式的问题，如何解决，层层递进引入了Zookeeper，然后介绍了应用场景和技术内幕，算是一个非常全面的介绍了，而且作者的思路非常清晰，我们读起来很流畅，但是书中涉及的一些协议本身是比较复杂的，读起来有些麻烦。</p>
<p>亮点：</p>
<ul>
<li>集中式的系统保证事务的 ACID 相对而言是比较容易的，而且有很多成熟的解决方案。但是根据 <a href=""https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863"" rel=""nofollow noreferrer"">CAP</a> 理论：“一个分布式系统系统不可能同时满足一致性、可用性、和分区容错性，最多只能满足两样”，所以分布式系统不大可能严格满足 ACID 的<a href=""https://en.wikipedia.org/wiki/Strong_consistency"" rel=""nofollow noreferrer"">强一致性</a>，而分区容错性 P 是分布式系统本身存在的意义，所以一般设计者就在 A 和 C 之间寻求平衡了，根据 <a href=""https://en.wikipedia.org/wiki/Eventual_consistency"" rel=""nofollow noreferrer"">BASE</a> 理论，一般分布式系统都实现以实现<a href=""https://en.wikipedia.org/wiki/Eventual_consistency"" rel=""nofollow noreferrer"">最终一致性</a>、保证高可用性为目标。BASE理论不仅应用于分布式系统，也广泛应用于现代关系数据库</li>
<li>数据的一致性与可用性之间的反复权衡产生了 一系列的一致性协议，最经典莫过于<a href=""https://en.wikipedia.org/wiki/Two-phase_commit_protocol"" rel=""nofollow noreferrer"">二阶段</a>、<a href=""https://en.wikipedia.org/wiki/Three-phase_commit_protocol"" rel=""nofollow noreferrer"">三阶段</a>提交协议和<a href=""https://en.wikipedia.org/wiki/Paxos_%28computer_science%29"" rel=""nofollow noreferrer"">Paxos</a>算法了。这三者层层递进，分别解决了前者的一些问题，并各自在不同的领域被使用</li>
<li>Zookeeper是一个典型的分布式数据一致性解决方案（工业级产品），致力于提供一个高性能（高吞吐量）、高可用（解决单点问题）、具有严格顺序访问（主要是写）控制能力（实现复杂同步原语）的分布式协调服务。其设计目标：简单的数据模型（树型、共享、内存）、可以构建集群、顺序访问（请求有唯一递增编号）、高性能，可以保证许多一致性特性：顺序一致性、原子性、单一视图、可靠性、实时性。分布式应用程序可以基于它实现<strong>数据发布订阅、负载均衡、命名服务、分布式协调通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能</li>
<li>作者对ZooKeeper的常见应用场景进行了详尽的描述，非常有借鉴意义，比如：client利用节点创建的API可以创建一个顺序节点，再加上其type就形成了一个全局唯一的ID了，从而实现命名服务；不同机器通过在同一节点创建临时子节点，并根据其他机器的临时子节点来判断对应的机器是否存活，从而实现心跳检测；通过强一致性的唯一节点保证来实现master选举（谁能建立特定节点谁就是master，其他机器注册watcher，一旦当前master挂了节点删除，就又开始新的选举）；通过节点唯一性来实现排它锁、子节点排序来实现共享锁......总而言之，<strong>可以在ZooKeeper子节点唯一性上面做很多文章</strong>
</li>
<li>具体使用案例，<a href=""https://github.com/alibaba/canal"" rel=""nofollow noreferrer"">Canal</a>这款基于Mysql BinLog的增量订阅消费组件使用ZooKeeper来实现Canal Server的主备切换功能，主要原理就是临时节点和节点唯一性；Canal Client利用ZooKeeper来时刻关注Canal Server的变化，进行消费并记录消费点</li>
<li>数据模型：由ZNode（称为节点，类型有持久、临时、顺序节点，可组合）层次化组织而构成的树，路径类似于Unix文件系统，每个ZNode可以存数据、创建子节点（临时节点无子节点）；采用版本号以及CAS来实现乐观锁机制；采用ACL来实现细粒度的权限管理；采用一次性、客户端回调串行执行、推拉结合的轻量级watcher来实现时间发布订阅</li>
<li>Leader选举的原理简单说来就是谁的数据越新，那么其ZXID（事务ID）越大，就越能够保证数据的恢复，就越能成为Leader，对于相同的ZXID，那么SID较大的成为Leader，这个应该没啥特别的原因，只是作为一种确定机制。</li>
<li>Leader是集群中的核心，主要工作：事务请求的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务的调度者。Follower是集群状态跟随者，主要工作：处理客户端非事务请求，转发事务请求给Leader；参与事务请求Proposal的投票；参与Leader选举。Observer观察集群最新变化状态并同步过来，工作类似于Follower，只是不参与任何投票，通常用于在不影响集群事务处理的情况下提升集群的非事务处理能力</li>
</ul>
<p>看完全书再去看看应用案例可能会产生更好的理解。</p>
<h2>现代操作系统（原书第4版）</h2>
<p>现代操作系统（原书第4版） (豆瓣)  <a href=""https://book.douban.com/subject/27096665/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>操作系统是我们一切编程的根基，不了解操作系统就只是“粘贴复制员”而不是“程序员”更别提“工程师”了。这本书既讲到了传统的重点概念：内存、进程、文件、安全等，又讲到了现在广泛应用的虚拟化、云、Linux、Windows等，无愧于“现代操作系统”的名称。</p>
<p>亮点：</p>
<ul>
<li>抽象是管理复杂性的一个关键，好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分，其一是抽象的定义与实现，其二是用这些抽象解决问题。操作系统就是把硬件丑陋的接口转换为一个良好、清晰、优雅、一致的抽象。最为人熟知的抽象就是“文件”，它统一了各种格式的数据、各种IO设备对于用户的接口（操作系统3大抽象：<strong>文件，进程与线程，地址空间</strong>，分别对应<strong>磁盘，处理器，内存</strong>）。可以把操作系统理解为一个资源管理者，管理硬件资源如何分配给应用程序,让应用程序更好地使用这些资源</li>
<li>技术的变化会导致某些思想迅速过时，但是也可能使得另一种是思想复活，当技术的变化影响了系统内部不同组件的相对性能之时就更是如此。比如早期计算机指令由硬件直接执行，微程序设计出现后采用解释执行，RISC又采用了直接执行，java又采用了解释执行，这样来回摆动主要是因为执行速度不总是关键因素，还有可能是网络延迟。再比如计算服务过时了，但是又以云计算的形式重新流行，所以对待技术要保持客观、辩证的态度，不要因为现在看起来过时就对它唾弃，说不定将来它又能流行起来发挥大的作用</li>
<li>有了进程还要线程的原因：逻辑上，一个应用中本身可以划分为多个活动，一个活动一个线程便于理解；线程更轻量级，容易创建、撤销；若存在大量IO处理，多线程彼此重叠进行是可以提升吞吐量的（若每个线程都是CPU密集型则不能）；多线程可以真正利用多核。</li>
<li>都知道java有偏向锁、轻量级锁、重量级锁的升级，实际上操作系统也有类似锁的概念，而且Linux还采取了“<a href=""https://en.wikipedia.org/wiki/Futex"" rel=""nofollow noreferrer"">Futex</a>”这个方案来结合自旋锁和重量级锁（阻塞）的优点。一个Futex包含两部分：一个内核服务和一个用户库，简单说来就是在用户态创建一个futex同步变量，当有进程要获得锁时，对futex执行""down""操作即原子性的给futex同步变量减1，如果成功即可继续不需进入内核态，否则进入内核态阻塞，这样就大大减少了低竞争时的吞吐量</li>
<li>通过交换技术，系统可以同时运行超过实际内存大小的多个进程；现代计算机都使用某种虚拟内存技术，每个进程地址被分为同样大小的页面(通常4、8KB)，可以被放入空闲内存的任何页框内，有多种页面置换算法，实际应用中用的最多的是老化算法和工作集时钟算法；如果在执行过程中有大小变化的数据结构可以采用分段的方法，但是几乎没有主流的操作系统考虑分段算法</li>
<li>文件系统的存储区分配方案有连续文件、链表、文件分配表和iNode。磁盘空间可以通过位图的空闲表来管理。提升文件系统性能的做法有高速缓存、预读取、以及尽可能将一个文件的块放在一起等方法</li>
<li>操作系统除了负责提供抽象还要负责管理所有IO，IO主要有三种方式实现：程序控制IO、中断驱动IO、DMA</li>
<li>死锁发生有四个条件：互斥条件、占有和等待条件、不可抢占条件、环路等待；解决办法有四个：鸵鸟对策、死锁检测与恢复、合理资源分配动态避免死锁、通过破坏引起死锁发生的四个必要条件之一来防止死锁发生</li>
<li>虚拟化的好处：可以在节省硬件与电力资源的情况下实现强隔离性、使得各个应用程序很容易拥有自己的运行环境、设置检查点和虚拟机迁移比在普通操作系统中容易的多，目前虚拟化最重要的用途就是<a href=""https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97"" rel=""nofollow noreferrer"">云</a>
</li>
<li>编写操作系统不容易，那么从何入手呢？从对外接口开始，三大原则：简单，不是当没什么东西可以添加而是当没什么东西可以减少时才能达到尽善尽美，或者说KISS原则；完备，完事应该简单，但是不能过于简单，必须要能完成用户所需的一切事情；效率，如果功能不能有效实现那就不值得拥有这个功能。这些原则对于我们所有的系统设计都有借鉴意义</li>
</ul>
<p>这本书的字真是太多了，也太小了，吐槽一下印刷，此外，内容也很细很全，还是应该采取先观其大略、使用时细读的策略。</p>
<h2>大规模分布式存储系统</h2>
<p>大规模分布式存储系统 (豆瓣): <a href=""https://book.douban.com/subject/25723658/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>看了许多分布式概念性的书籍，也了解了java中间件、分布式一致性、ZooKeeper作为基础设施等等概念，是时候找个具体的方向了解分布式了，那么这本书就是分布式在存储这一块的具体实战了。本书从概念到实战，讲了分布式文件、键值系统、表格系统、数据库等等，几乎覆盖了所有涉及存储的方向，看完就能对分布式存储有一个较为完整的了解了。</p>
<p>亮点：</p>
<ul>
<li>分布式存储有几个特性：可扩展（容易扩展到几百几千台集群规模，且性能随数量线性增长）、低成本（构建于普通PC机之上）、高性能、易用（提供易用的对外接口）；主要挑战在于数据分布均匀、数据一致性、容错性、负载均衡、事务并发与控制、易用性、压缩解压缩；数据分为非结构化数据（图、文）、结构化数据（关系数据库）、半结构化数据（HTML）；不同的存储系统适合不同的数据类型，分布式文件系统主要存储<a href=""https://en.wikipedia.org/wiki/Binary_large_object"" rel=""nofollow noreferrer"">Blob</a>对象（文档、图片、视频）等非结构化数据和作为其他分布式系统的基础，分布式键值系统存储简单的半结构化数据，分布式表格存储复杂的半结构化数据，分布式数据库存储结构化数据</li>
<li>设计网络系统的基本原则是：网络永远是不可靠的，任何一个消息只有收到对方回复后才可认为发送成功，系统设计时总是假设网络将会出现异常并采取相应处理措施（但是我们必须假设信道是可靠的，不然任何工作于其之上的任何协议都不能是可靠的）</li>
<li>分布式系统在CAP理论的C和A之间权衡时可以参照Oracle的DataGuard复制组件的三种模式：<strong>最大保护模式</strong>（亦即强同步模式，主库先将操作日志同步到至少一个备库才能返回给客户端成功结果），应用于余额等关键记录；<strong>最大性能模式</strong>（亦即异步复制，主库完成执行就返回客户端，将重做日志以异步的方式复制到备库），应用于用户操作日志等非关键记录；<strong>最大可用性模式</strong>（上述两种模式的折中，正常情况相当于最大保护模式，当主备之间的网络出现故障切换为最大性能模式），应用于一般记录</li>
<li>故障检测可以通过心跳检测来做，这是最原始的想法，但是机器也可能因为太忙，或者与控制节点的网络断掉而无法进行心跳，这种情况下使用<strong>时钟同步</strong>（需要考虑一个时间提前量，因为时钟并不能严格一致一般都会有小于1秒的微小误差）加<strong>租约</strong>（Lease）的形式可以较好地避免这个问题</li>
<li>跨机房部署有三种方案：集群整体切换（实际最常见做法，两个机房保持独立，保持相同的副本数，有主备之分（Primary,Secondary），可能强同步或者异步复制），单个集群跨机房（不同数据分片的主副本位于不同机房）、Paxos选主副本（每个数据分片的多个副本构成一个Paxos复制组，自动选举主副本，降低了对总控节点的依赖但是工程复杂度很高）。</li>
<li>GFS成功的经验表明：单Master的设计是可行的，不仅简化了系统，而且能较好地实现一致性。<strong>这是一种中心化的架构，是目前互联网的主流架构</strong>，而<strong>去中心化</strong>的Gossip协议虽然借着Cassandra（Amazon的Dynamo的开源实现）大火了一把，但是<strong>由于其复杂性与一致性问题实际上分布式系统很少使用</strong>
</li>
<li>
<a href=""https://github.com/alibaba/oceanbase/tree/master/oceanbase_0.4"" rel=""nofollow noreferrer"">OceanBase</a>是一款可扩展的关系型数据库（支持强一致性和跨表事务），主要架构分内四部分：<strong>RootServer</strong>一主一备，主备强同步，负责集群管理，数据分布以及副本管理;<strong>UpdateServer</strong>一主一备，主备同步模式可配置，接受写操作，并且定期把新数据同步给Chunkserver;<strong>ChunkServer</strong>存储基线数据，只提供读取服务，并定期接受UpdateServer的数据同步;<strong>MergeServer</strong>解析用户Mysql兼容请求，将请求转发给对应的ChunkServer和UpdateServer，无状态，类似于网关的作用</li>
<li>OceanBase写操作强一致性的原理是：UpdateServer将redo日志发送给备机，redo日志写到本地磁盘，redo日志应用到主机内存表，返回客户端成功。这样即使主备机切换也能保证新的主机有以前所有的操作记录而不会丢失，可以通过增加备机数量来提高可用性保证。当然UpdateServer主备同步也支持异步模式，支持最终一致性，一般用来实现异地容灾。此外主备集群也可以实现错峰合并</li>
<li>OceanBase<strong>借助UpdateServer逻辑单点来实现强一致性</strong>，那么这个单点会不会成为瓶颈呢？一般来说，互联网业务读写比都比较高，所以不会成为瓶颈，即使是双十一这种，也可以通过自动冻结内存表转入SSD硬盘、定期合并与分发、旁路导入、多块网卡配置、RAID卡缓存模块、成组提交等优化方式来避免内存、网络、磁盘的瓶颈；通过主备强一致备份策略与实时同步避免单点故障，这样这个单点问题就几乎不存在了</li>
<li>列式存储的主要目的有两个：大部分<a href=""https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86"" rel=""nofollow noreferrer"">OLAP</a>只需要读取部分列而不是全部列数据，列式存储可以避免读取无用数据；将同一列的数据在物理上存放在一起，能够极大的提高数据压缩率</li>
<li>大表左连接是互联网的一个常见问题，一般采取引用（多表主键连接）、或者嵌套（主表冗余连表信息），但是这分别只能适应读取次数少、读写比较高的场景，如果读取次数多且读写比不高那么这两种做法就没辙了。OceanBase采用基线数据冗余连表+修改增量合并的方式解决了这个问题</li>
</ul>
<p>看完这本书是真的很有收获，对整个分布式架构有了一个完整的了解，从大大的跨机房到一个小小的数据分片副本，从上到下非常清晰。此外最佳实践那一部分也是很赞的，强烈推荐此书。</p>
<h2>微服务设计</h2>
<p>微服务设计 (豆瓣): <a href=""https://book.douban.com/subject/26772677/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p><a href=""https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99"" rel=""nofollow noreferrer"">微服务</a>最近两年越来越火，其实这并不是什么新鲜概念，计算机体系里面早就有单内核与<a href=""https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8"" rel=""nofollow noreferrer"">微内核</a>的架构思想了，微服务也是一种类似的思想，但是是处于更高级别的应用架构层（所以<strong>计算机领域里面的许多思想是可以相互借鉴的比如抽象、缓存、LRU算法、并行处理等等</strong>）。微服务的好处是很多的，<strong>单个服务容易开发、理解和维护；容纳异构技术；部署简单、迭代速度快、变化小bug少；弹性、扩展性好等等</strong>。本书就带领我们从建模、集成、测试到部署和监控，全面了解微服务，为进一步学习指引方向。</p>
<p>亮点：</p>
<ul>
<li>微服务是一种分布式系统解决方案，推动细粒度服务的使用，这些小而自治的服务协同工作，都有自己的生命周期，围绕业务领域建模，根据业务的边界来确定服务的边界，因此也很容易确定某个功能代码的位置，避免了传统分层架构的许多问题。一个微服务就是一个实体，不同微服务通过网络通信互相调用。我们知道，<strong>直接进程内方法调用是很快，但是也意味着两个对象紧密耦合了，通过网络通信调用虽然慢一些，但是两个对象就松耦合了，可以随时替换掉一个而另一个完全不用知道，我觉得随着网速越来越快，网络通信代价越来越小，微服务的优势将越来越明显，直接耦合调用的方式的优势将越来越弱</strong>
</li>
<li>架构师就类似于城市规划师应该专注于大方向，只能参与少量细节，需要保证系统能满足当前的需求，还要能够应对将来的变化，以一种演化的方式来进行规划，这是一个很大的标准，从何入手呢？答案是：分区，定好服务边界与交互方式，可以使用<a href=""https://www.cnblogs.com/xishuai/p/iddd-bounded-context.html"" rel=""nofollow noreferrer"">限界上下文</a>。演化的方式就是我们要理解，随着项目发展，服务一定会越来越大，我们要做的就是让架构增量变化，<strong>在拆分这件事变得过分昂贵之前进行拆分</strong>
</li>
<li>重用代码可能引入危险，因为我们可能引入服务之间的耦合。所以虽然我们要做到DRY原则，但是也要防止过度追求DRY原则带来的系统过度耦合，这是一个比较微妙的话题，要记住，DRY不是意味着避免重复的代码，而是意味着避免系统行为和知识的重复，在微服务内部不要违反DRY，跨服务时可以适当违反来避免服务之间耦合</li>
<li>处理跨服务的业务流程时可以选择：编排，一个中心节点调度其他所有服务完成，这样流程很清晰，但是会导致中心节点承担过多，其它服务沦为贫血的基于CURD的服务；协同，相关服务订阅特定的事件，事件由客户端触发之后每个服务各自完成自己的处理，这样能明显消除耦合，但是就看不到明显的流程图了，而且可能需要跨服务监控，但是总体而言倾向于协同，利大于弊</li>
<li>真正的<a href=""https://segmentfault.com/a/1190000012509128#articleHeader15"" rel=""nofollow noreferrer"">持续集成</a>要理解3个问题：是否每天签入代码到主线？是否有一组测试来验证修改？构件失败过后是否把修复CI当做第一要务？最好是每一个微服务都有自己的代码库和CI，只有这样才能真正实现独立部署</li>
<li>微服务部署最好采用单主机（可以是物理主机、虚拟机、容器）单服务的方式，这样利于团队自治、服务部署、监控、故障排查、扩展性更好等，但是这个模式会引入大量主机，这就意味着重复劳动会多起来，所以我们一定要实现自动化（不管什么技术栈都要追求自动化）</li>
<li>自动化测试类型分为单元测试、服务测试、用户测试（端到端测试）。其中单元测试是针对一个函数的、面向技术、帮助开发人员快速发现错误和增加重构信心；服务测试针对一系列函数构成的完整服务，提高测试隔离性，帮助快速定位问题；端到端测试包含整个系统，增强我们发布服务的信心。这三者的比例最好是前者比后者多一个数量级</li>
<li>监控固然要看低层指标比如CPU利用率、空闲内存、带宽使用等等，但是这些指标往往太多而带来噪声不利于监控我们真正关心的行为，所以需要语义监控，亦即准备一些合成数据和事件来观察系统是否按照我们的期望完成任务，当然这些数据要注意不能和真实生产数据混淆</li>
<li>任何组织在设计一套系统时，所交付的方案在结构上都与该组织的沟通结构一致。这被称为康威定律</li>
<li>构建分布式系统需要思维的转变，那就是<strong>故障总会出现</strong>，不是所有人都需要像Google或者Netflix一样使用<a href=""https://github.com/Netflix/chaosmonkey"" rel=""nofollow noreferrer"">ChaosMonkey</a>来模拟故障测试系统的健壮性，但是我们都需要为各种故障做好准备比如：超时（设置默认超时并记录日志）、断路器（请求失败一定次数后断路器打开，下次快速失败就不用再等待了）、舱壁（服务内外都可以使用，关注点分离，为每个下游单独准备连接池）、隔离</li>
</ul>
<p>PS：书中提到了不少参考书，都是可以看看的。</p>
<h2>算法（第4版）</h2>
<p>算法（第4版） (豆瓣)  <a href=""https://book.douban.com/subject/19952400/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>本书讲解的算法和数据结构都是我们必须掌握的，属于入门级知识，但是作者讲的很仔细，很有趣，没有那么多的数学证明，比<a href=""https://book.douban.com/subject/20432061/"" rel=""nofollow noreferrer"">《算法导论》</a>读起来跟容易一些，但是作者的观点也都是立得住的，有理有据，值得通看，形成自己对于算法的初步体系。</p>
<p>亮点：</p>
<ul>
<li>本书提供了所有代码还有教学视频，可以辅助学习，<a href=""https://algs4.cs.princeton.edu/home/"" rel=""nofollow noreferrer"">网址</a>。我把代码fork了一份，在<a href=""https://github.com/MageekChiu/algs4"" rel=""nofollow noreferrer"">这</a>
</li>
<li>本书对算法性能的分析是科学式的，亦即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程</li>
<li>API的目的是将调用和实现分离（模块化编程），可以将API看做调用和实现之间的一份契约，他详细说明了每个方法的作用，实现的目标就是遵守这份契约。<strong>读到这里就有一个感想，我们程序的进步都是在努力地把人为的契约固化到代码中，减少出错概率。比如程序员之间直接约定不够可靠，那么就通过接口来强制约定；再比如生产与开发环境不容易保持一致，就通过DockerFile来强制约定</strong>
</li>
<li>作者循循善诱，为了给我们分析算法性能提供动力，讲了一个<a href=""http://blog.csdn.net/guanhang89/article/details/50775508"" rel=""nofollow noreferrer"">3-sum问题</a>的逐步优化过程：<a href=""https://github.com/MageekChiu/algs4/blob/master/src/main/java/edu/princeton/cs/algs4/ThreeSum.java"" rel=""nofollow noreferrer"">暴力的3-sum</a>是一个立方级别的算法，先从简单的情况考虑2-sum，通过线性对数级别的排序，然后用对数级别的二分查找一个元素的相反数来进行统计，这个算法就是线性对数级别的，然后自然扩展到3-sum，得到平方对数级别的<a href=""https://github.com/MageekChiu/algs4/blob/master/src/main/java/edu/princeton/cs/algs4/ThreeSumFast.java"" rel=""nofollow noreferrer"">快速的3-sum</a>，<a href=""https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86"" rel=""nofollow noreferrer"">并查集</a>也是类似循序渐进的教法</li>
<li>初级算法虽然简单，但是它帮我们建立了一些基本规则，展示了一些性能基准，在某些特殊情况下也是很好的选择，也是开发更强大的算法的基础，所以仍有必要系统的学习它们</li>
<li>把排序算法讲了一遍之后，讲到了规约（为了解决某个问题而发明的算法可以解决另一个问题），比如排序就可以用了解决很多其他问题，一般能将暴力的平方级别解法下降到非暴力的线性对数级别，比如：找出重复元素、排名、优先队列、中位数、第K个最小/大的值（模仿快速排序的partition操作就能达到线性级别）等</li>
<li>散列表的意义是在时间与空间之间取得一个平衡，选择适当大小的数组M，既不会因为空链表造成内存浪费也不会因为链表太长而导致查找效率低</li>
<li>书中对于图的表述中，深度优先等遍历方式都给出了详细的算法与示例的轨迹图，你想看不懂都难</li>
<li>就解决图的连通性问题，理论上来说，深度优先比<a href=""http://blog.csdn.net/dm_vincent/article/details/7655764"" rel=""nofollow noreferrer"">union-find</a>（联合查找或者说并查集）更快，但是实际上union-find更快，因为它不需要对图进行预处理，是一种动态的算法（能用接近常数的时间检查两点是否相通，甚至是添加边），而对于已经是图的数据类型使用深度优先更快，因为它能利用已知信息</li>
<li>用于子串查找的<a href=""https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95"" rel=""nofollow noreferrer"">KMP</a>算法的基本思想是，当文本出现不匹配时就能知晓一部分文本内容，可以利用这些信息避免将指针会退到所有这些已知字符之前，亦即<strong>充分利用已知信息</strong>，这也是插入排序优于选择排序的原因。KMP主要亮点是提前判断如何重新开始查找，这种判断不需要文本指针i完全回退，只需根据模式本身信息重新进行比较位置的选择</li>
<li>许多问题都可以规约为排序问题（中位数、不同值统计）、最短路径问题（任务调度、套汇）、最大流量问题（就业安置、网络可靠性）、线性规划（最大流量）</li>
<li>NP是所有搜索问题（有解且验证解的正确性的时间不会超过输入规模的多项式的问题）的集合；P是能够在多项式时间内解决的所有搜索问题的集合</li>
</ul>
<p>本书的java基础部分是相当的丰富，学完算法也可以顺带复习一遍java了，很划算 (*￣︶￣)。<br>还有，本书虽厚，但是一定要看完，这样才有一个完整的体系，并且算法的细节也能掌握了，之所以不采取往常对待大部头的观其大略的方法是因为这是算法，是经常需要我们实施的领域，和代码编写直接相关（不像操作系统的知识），所以必须掌握细节。可以参见我的另外几篇专门讲算法的<a href=""https://segmentfault.com/a/1190000012977564"" rel=""nofollow noreferrer"">博客</a></p>
<h2>Hadoop权威指南</h2>
<p>Hadoop权威指南(第3版) (豆瓣): <a href=""https://book.douban.com/subject/26206050/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p><a href=""https://zh.wikipedia.org/wiki/Apache_Hadoop"" rel=""nofollow noreferrer"">Hadoop</a>的出现开启了大数据的序幕，到了现在已经成为一个比较完善的<a href=""http://hadoop.apache.org/"" rel=""nofollow noreferrer"">生态</a>，服务于云计算与大数据。记得大三的时候学校有免费的云服务器，我申请了5台自己搭建了一个Hadoop集群跑了一下 Hello World 级别的 Word Count，然后就开始期末考试了，没有再继续深入了解，现在是时候全面的了解一下了，这本书号称权威指南，看它没错。</p>
<p>亮点：</p>
<ul>
<li>
<strong>MapReduce</strong>相对于其他系统的优势：比<strong>RDBMS</strong>更适合一次写入多次读取的任务，适合批处理任务，是一种线性可伸缩的编程模型；因为尽量做到数据本地存储，所以比<strong>网格计算</strong>（带宽限制，只适宜CPU密集型任务）更能处理巨量数据的任务，同时处理CPU密集型任务也不弱；比<strong>志愿计算</strong>（贡献CPU而非带宽）更可靠，更易实施，更好控制</li>
<li>HDFS是Hadoop的旗舰级文件系统，但是Hadoop也能集成其它文件系统如S3，HDFS设计要点：超大文件、流式数据访问、商用硬件（零售店可买）、低延迟访问不太适用（HBASE更佳）、大量的小文件、仅支持单用户写入且不能随机写</li>
<li>分布式文件系统的块（chunk）抽象有许多好处：一个文件可以大于任意磁盘的容量（因为无需把一个文件存在一个磁盘上）；抽象块简化了存储设计（块大小固定，默认64MB磁盘性能越好越大，故每块盘能存多少块是固定的，而且元数据也可以单独管理）；适合数据备份，从而提高容错能力和可用性（每一块可以复制到多个机器上，默认是3个，如果块、磁盘或机器发生故障系统会从其他机器读取副本，此过程对用户透明。而且多个副本可以提高读取性能）</li>
<li>HDFS 有两种节点，一个namenode作为管理者，管理整个文件系统的命名空间，维护整个文件系统树及其文件与目录，同时也记录着每个文件中各个块所在的数据节点信息，namenode至关重要必须正常运行，所以提供了两种容错机制，实时同步元数据至其它地方和运行辅助namenode；多个datanode作为实际工作者，存储数据块供读写并定期向namenode发送存储的块的列表</li>
<li>
<strong>YARN</strong>将JobTracker划分为多个职能的实体（资源管理器和应用管理器），改善了经典的MapReduce面临的扩展性问题，实际上比MapReduce更具一般性，MapReduce只是YARN应用的一种形式，有很多其他的YARN应用如分布式shell</li>
<li>MapReduce提供了计数器（统计无效数据）、排序、连接（join操作，将两个数据集合二为一）、边数据分布（配置额外的只读数据来完成作业）、MapReduce库类等常见功能</li>
<li>部署hadoop时典型配置是同一个机架有一些节点，不同机架通过交换机连接起来的二级网络架构。因为机架内部通信更快所以一定要把这些配置告诉Hadoop系统，这样分配MapReduce任务时会倾向于机架内节点，节省传输成本，同时HDFS的文件块的3个副本也会尽量分布在两个机架上</li>
<li>Pig是一种探索大规模数据集的脚本语言，省去MapReduce繁琐耗时的步骤（写mapper、reducer，代码编译，打包，提交作业），仅需控制台的几行pig Latin代码就能处理TB级别的数据，而且支持更丰富的数据结构</li>
<li>Hive能把SQL查询转换为一些列运行在Hadoop上运行的MapReduce作业，它把数据组织为表，通过这种方式为HDFS中的数据赋予结构。Hive与传统数据库有很多类似之处（如SQL语言的支持，尤其类似于Mysql），但是其底层依赖于HDFS和MapReduce而非传统的文件系统，Hive采用读时模式（查询时进行模式检查）而非写时模式（写入时检查模式）可以使得数据加载非常迅速，因为他只是移动数据而不需要读取、解析、序列化等。写时模式有利于提升查询性能，因为可以建立索引、数据压缩等，Hive没有考虑过这些特性（以及事务、更新、删除等），因为MapReduce下，全表扫描是常态</li>
<li>HBASE是在HDFS上开发的面向列[族]的分布式数据库，如果需要实时的访问超大规模的数据集，就可以使用HBASE。与RDBMS相比，HBASE能解决很多伸缩性问题（表可以高达几十亿行，几百万列）、能水平分区并在上千个普通节点上自动复制、线性扩展与新节点自动处理。RDBMS对于中小规模应用提供的易用性、灵活性和完整的功能性是几乎无可取代的，但是要在数据规模和并发读中任意方面向上扩展就会损失很多性能，因为RDBMS是面向行的具有ACID和事务的强一致性等特性，向上扩展意味着要打破这些特性，使得管理变得复杂</li>
<li>ZooKeeper一般用来构建分布式服务具有许多特性：简单（核心是一个精简的文件系统）、丰富（提供分布式队列、锁、领导选举等功能）、高可用（运行于一组机器，避免单点故障）、松耦合交互（参与者不必互相了解）、资源库（提供通用协调模式的开源共享库）</li>
</ul>
<p>本书作为了解Hadoop的设计思想以及关键点的手段，我尚未进入真正的使用，很多代码以及API部分就省略没看了，所以虽然是个大部头，但是看起来并不会特别慢。当然如果真的要使用，书中的接口和代码可能就已经过时了，要搭配<a href=""http://hadoop.apache.org/docs/current/"" rel=""nofollow noreferrer"">最新官方文档</a>来看</p>
<h2>HTTP权威指南</h2>
<p>HTTP权威指南 (豆瓣): <a href=""https://book.douban.com/subject/10746113/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>Http协议构成了当今互联网的基石，无论是浏览网页还是使用APP都离不开这个协议，非常有必要进行全面的了解。这本书也是一个权威指南，看完就能有一个完整的概念了，而且本书还讲到了许多架构方面的经验，只赚不赔哈哈。</p>
<p>亮点：</p>
<ul>
<li>URI 统一资源标识符，在世界范围唯一标志并定位一个信息资源，包含URL和URN；URL 统一资源定位符，描述一台特定服务器上的某特定资源的位置；URN 统一资源名称，作为特定内容的唯一名称而与资源所在地无关（所以资源可以迁移到另一处而不影响其访问，URL就不行）。现在几乎所有URI都是URL，URN由于架构的缺乏（虽然引入了PURL）和巨大的工程变动仍处于试验阶段并未广泛使用</li>
<li>HTTP延时一般都是由TCP延时造成的（除非是客户端、服务端超载或者处理复杂的动态资源），如果要编写高性能HTTP程序就要考虑许多的TCP层面的问题与解决方案：<a href=""https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E5%BB%BA%E7%AB%8B%E9%80%9A%E8%B7%AF"" rel=""nofollow noreferrer"">TCP握手</a>产生的延时对于传输少量的http报文而言是巨大的开销（复用已有TCP连接）；<a href=""https://www.cnblogs.com/zhuzhu2016/p/5868497.html"" rel=""nofollow noreferrer"">延迟确认</a>算法不太适用于HTTP这种双峰特征的请求响应式行为（调整或禁用这个算法）；<a href=""http://blog.csdn.net/jtracydy/article/details/52366461"" rel=""nofollow noreferrer"">慢启动</a>影响新的Http连接的传输速度（复用连接，持久连接）；<a href=""https://www.cnblogs.com/wanpengcoder/p/5366156.html"" rel=""nofollow noreferrer"">Nagle算法</a>影响小的Http报文传输（可以禁用该算法，TCP_NODELAY）；TIME_WAIT累计与端口耗尽，TIME_WAIT状态会持续2MSL（如120s）的时间才会转换到CLOSE状态，然后才能创建相同IP和端口的连接（服务器端口有限，如60000个），限制了服务器的连接速率（60000/120=500次每秒），可以增加客户端负载生成器的数量或者虚拟IP</li>
<li>减少Http连接延时的方法：并行连接（并行执行多个Http事务），管道化连接（通过共享的TCP连接发起请求），复用连接（交替传送请求与响应报文），持久连接（由于站点本地性，http事务结束后不必马上释放TCP连接，因为很有可能马上又要向该站点发起请求）。其中持久连接与并行连接搭配可能是最高效的方式</li>
<li>web代理连接的是两个使用相同协议的应用，而网关连接的是两个或多个使用不同协议的端点。所以web代理扮演的是中间人传输者的角色（改善安全性、提高性能，比如完成访问控制、防火墙、匿名者、缓存、反向代理负载均衡、内容路由器、转码器等等），网关扮演的是协议转换器的角色（比如PHP-FPM能把Nginx转发的http请求解析出来然后调用php-cgi来注入参数并执行PHP代码得到结果然后封装为http协议回复给nginx）</li>
<li>大规模web爬虫对其访问管理（避免重复）用到了一些技术：树和散列表（加速查找）、有损的位图（url映射成数字，url无限数字有线所以可能有冲突）、检查点（已访问URL存入本地）、分类（集群爬虫通过通讯来分配URL，各自爬取部分）、规范化URL、广度优先爬取、节流、限制url大小、黑名单、内容指纹、人工监视等等</li>
<li>内容协商技术可以使得服务器把内容的不同版本发送给对应的用户，主要有3种机制：客户端驱动、服务器驱动、透明。</li>
<li>重定向普遍存在，原因无非：可靠的执行Http事务（备用节点）、最小化时延（就近访问）、节约网络带宽（服务器分散，减少拥塞）。用到的主要技术有：Http重定向、DNS重定向、任播寻址、IP MAC转发、IP地址转发、显示浏览器配置、代理自动配置、web Proxy代理自动发现等等</li>
</ul>
<p>这本书详细描述了HTTP协议的方方面面，而且给出了许多参考，如果我们真的要做一个完美的Http应用，还是值得我们细细翻阅的。</p>
<p><a href=""http://mageek.cn/archives/44/"" rel=""nofollow noreferrer"">阅读原文</a></p>

                ", 后端好书阅读与推荐（续四）,1531977910,582,1,946,1,1,https://segmentfault.com/a/1190000013522687
51,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474312?w=1920&amp;h=1271"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""fairyland-canyon-1632749_1920"" title=""fairyland-canyon-1632749_1920""></span></p>
<h3>前提</h3>
<p>《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。</p>
<h3>关注我</h3>
<p>如果你想查看这本书可以关注我的公众号: <strong>zhisheng</strong> ，然后里面回复关键字 <strong>JMM</strong> 可以查看我分享的百度云链接。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012730965?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mark"" title=""mark""></span></p>
<p>转载请务必注明原创地址为：<a href=""http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/</a></p>
<h3>基础</h3>
<h4>并发编程的模型分类</h4>
<p>在并发编程需要处理的两个关键问题是：<strong>线程之间如何通信</strong> 和 <strong>线程之间如何同步</strong>。</p>
<h5>通信</h5>
<p><strong>通信</strong> 是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong> 和 <strong>消息传递</strong>。</p>
<p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的<strong>公共状态</strong>来<strong>隐式</strong>进行通信。</p>
<p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的<strong>发送消息</strong>来<strong>显式</strong>进行通信。</p>
<h5>同步</h5>
<p><strong>同步</strong> 是指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
<p>在<strong>共享内存</strong>的并发模型里，同步是<strong>显式</strong>进行的。程序员必须显式指定某个方法或某段代码需要在线程之间<strong>互斥执行</strong>。</p>
<p>在<strong>消息传递</strong>的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是<strong>隐式</strong>进行的。</p>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h4>Java 内存模型的抽象</h4>
<p>在 Java 中，所有实例域、静态域 和 数组元素存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数 和 异常处理器参数 不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（JMM）控制。JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。</p>
<p>JMM 抽象示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474313?w=1278&amp;h=998"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jmm"" title=""jmm""></span></p>
<p>从上图来看，如果线程 A 和线程 B 要通信的话，要如下两个步骤：</p>
<p>1、线程 A 需要将本地内存 A 中的共享变量副本刷新到主内存去</p>
<p>2、线程 B 去主内存读取线程 A 之前已更新过的共享变量</p>
<p>步骤示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474314?w=1176&amp;h=876"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""tongxin"" title=""tongxin""></span></p>
<p>举个例子：</p>
<p>本地内存 A 和 B 有主内存共享变量 X 的副本。假设一开始时，这三个内存中 X 的值都是 0。线程 A 正执行时，把更新后的 X 值（假设为 1）临时存放在自己的本地内存 A 中。当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存 A 中修改后的 X 值刷新到主内存去，此时主内存中的 X 值变为了 1。随后，线程 B 到主内存中读取线程 A 更新后的共享变量 X 的值，此时线程 B 的本地内存的 X 值也变成了 1。</p>
<p>整体来看，这两个步骤实质上是线程 A 再向线程 B 发送消息，而这个通信过程必须经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p>
<h3>重排序</h3>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p>
<p>1、<strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>2、<strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<p>3、<strong>内存系统的重排序</strong>。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474315"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""sort-again"" title=""sort-again""></span></p>
<p>上面的这些重排序都可能导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h4>处理器重排序</h4>
<p>现代的处理器使用<strong>写缓冲区</strong>来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p>
<p>举个例子：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474316?w=1092&amp;h=440"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""example1"" title=""example1""></span></p>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0。具体的原因如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474317?w=1168&amp;h=804"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""exam1-ans"" title=""exam1-ans""></span></p>
<p>处理器 A 和 B 同时把共享变量写入在写缓冲区中（A1、B1），然后再从内存中读取另一个共享变量（A2、B2），最后才把自己写缓冲区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了。</p>
<p>这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</strong>。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p>
<h4>内存屏障指令</h4>
<p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead><tr>
<th>屏障类型</th>
<th align=""center"">指令示例</th>
<th align=""center"">说明</th>
</tr></thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td align=""center"">Load1; LoadLoad; Load2</td>
<td align=""center"">确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td align=""center"">Store1; StoreStore; Store2</td>
<td align=""center"">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td align=""center"">Load1; LoadStore; Store2</td>
<td align=""center"">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td align=""center"">Store1; StoreLoad; Load2</td>
<td align=""center"">确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。<strong>StoreLoadBarriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</strong>。</td>
</tr>
</tbody>
</table>
<h4>happens-before</h4>
<p>JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果<strong>一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p>与程序员密切相关的 happens-before 规则如下：</p>
<ul>
<li> 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li> 监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。</li>
<li> volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>
<li> 传递性：如果  A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
</ul>
<p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p>
<p>happens-before 与 JMM 的关系如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474318?w=1396&amp;h=1062"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""happens-before-jmm"" title=""happens-before-jmm""></span></p>
<p>如上图所示，一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。</p>
<h4>数据依赖性</h4>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead><tr>
<th align=""center"">名称</th>
<th align=""center"">代码示例</th>
<th align=""center"">说明</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">写后读</td>
<td align=""center"">a = 1;   b = a;</td>
<td align=""center"">写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td align=""center"">写后写</td>
<td align=""center"">a = 1;  a = 2;</td>
<td align=""center"">写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td align=""center"">读后写</td>
<td align=""center"">a = b;  b = 1;</td>
<td align=""center"">读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h4>as-if-serial 语义</h4>
<p>as-if-serial 语义的意思指：<strong>不管怎么重排序</strong>（编译器和处理器为了提高并行度），（单线程）<strong>程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>举个例子：</p>
<pre><code>double pi = 3.14;     //A
double r  = 1.0;       //B
double area = pi * r * r;     //C</code></pre>
<p>上面三个操作的数据依赖关系如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474319?w=550&amp;h=384"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""abc"" title=""abc""></span></p>
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474320?w=1290&amp;h=464"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_16-52-44"" title=""2018-02-27_16-52-44""></span></p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h4>重排序对多线程的影响</h4>
<p>举例：</p>
<pre><code class=""java"">class Demo {
  int a = 0;
  boolean flag = false;

  public void write() {
    a = 1;            //1
    flag = true;    //2
  }

  public void read() {
    if(flag) {            //3
      int i = a * a;    //4
    }
  }
}</code></pre>
<p>由于操作 1 和 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p>
<p>1、当操作 1 和操作 2 重排序时，可能会产生什么效果？</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474321?w=1076&amp;h=738"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""sort12"" title=""sort12""></span></p>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>2、当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474322?w=1294&amp;h=896"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""sort34"" title=""sort34""></span></p>
<p>在程序中，操作 3 和操作 4 存在<strong>控制依赖关系</strong>。当代码中存在控制依赖性时，<strong>会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<strong>猜测</strong>（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a * a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h3>顺序一致性</h3>
<h4>顺序一致性内存模型</h4>
<p>顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474323?w=1028&amp;h=822"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_17-55-09"" title=""2018-02-27_17-55-09""></span></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p>
<p>举个例子：</p>
<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3。B 线程也有三个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。</p>
<p>假设这两个线程使用监视器锁来正确同步：A 线程的三个操作执行后释放监视器锁，随后 B 线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果将如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474324?w=1444&amp;h=910"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_18-01-51"" title=""2018-02-27_18-01-51""></span></p>
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474325?w=1524&amp;h=862"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_18-04-20"" title=""2018-02-27_18-04-20""></span></p>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h4>同步程序的顺序一致性效果</h4>
<p>下面我们对前面的示例程序用锁来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：</p>
<pre><code class=""java"">class demo {
  int a = 0;
  boolean flag = false;

  public synchronized void write() {    //获取锁
    a = 1;
    flag = true;
  }                                        //释放锁

  public synchronized void read() {        //获取锁
    if(flag) {
      int i = a;
    }
  }                                        //释放锁
}</code></pre>
<p>上面示例代码中，假设 A 线程执行 write() 方法后，B 线程执行 reade() 方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474326?w=1396&amp;h=1070"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_22-01-59"" title=""2018-02-27_22-01-59""></span></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h4>未同步程序的执行特性</h4>
<p>未同步程序在 JMM 中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM  不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</li>
<li>
<strong>JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性</strong>，而<strong>顺序一致性模型保证对所有的内存读/写操作都具有原子</strong> 。</li>
</ol>
<p>第三个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过<strong>总线事务</strong>来完成的。总线事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传递数据到内存，每个事务会读／写内存中一个或多个物理上连续的字。总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I／O 设备执行内存的读／写。</p>
<p>总线的工作机制：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474327"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_22-53-53"" title=""2018-02-27_22-53-53""></span></p>
<p>如上图所示，假设处理器 A、B、和 C  同时向总线发起总线事务，这时总线仲裁会对竞争作出裁决，假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以<strong>把所有处理器对内存的访问以串行化的方式来执行</strong>；<strong>在任意时间点，最多只能有一个处理器能访问内存</strong>。这个特性<strong>确保了单个总线事务之中的内存读/写操作具有原子性</strong>。</p>
<p>在一些 32 位的处理器上，如果要求对 64 位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的写操作拆分为两个 32 位的写操作来执行。这两个 32 位的写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474328?w=1386&amp;h=764"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-27_23-06-59"" title=""2018-02-27_23-06-59""></span></p>
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被分配到单个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A “写了一半“的无效值。</p>
<p>注意，在 JSR -133 之前的旧内存模型中，一个 64 位 long/ double 型变量的<strong>读/写</strong>操作可以被拆分为两个 32 位的读/写操作来执行。从 JSR -133 内存模型开始（即从JDK5开始），仅仅只允许把一个 64 位 long/ double 型变量的<strong>写</strong>操作拆分为两个 32 位的写操作来执行，<strong>任意的读操作在JSR -133中都必须具有原子性</strong>（即任意读操作必须要在单个读事务中执行）。</p>
<h3>Volatile</h3>
<h4>Volatile 特性</h4>
<p>举个例子：</p>
<pre><code class=""java"">public class VolatileTest {
    volatile long a = 1L;         // 使用 volatile 声明 64 位的 long 型

    public void set(long l) {
        a = l;                  //单个 volatile 变量的写
    }

    public long get() {
        return a;               //单个 volatile 变量的读
    }

    public void getAndIncreament() {
        a++;                    // 复合（多个） volatile 变量的读 /写
    }
}</code></pre>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p>
<pre><code class=""java"">public class VolatileTest {
    long a = 1L;                 // 64 位的 long 型普通变量

    public synchronized void set(long l) {    //对单个普通变量的写用同一个锁同步
        a = l;                
    }

    public synchronized long get() {        //对单个普通变量的读用同一个锁同步
        return a;           
    }

    public void getAndIncreament() {        //普通方法调用
          long temp = get();                    //调用已同步的读方法
        temp += 1L;                            //普通写操作                            
          set(temp);                            //调用已同步的写方法
    }
}</code></pre>
<p>如上面示例程序所示，对一个 volatile 变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。</p>
<p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着<strong>对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入</strong>。</p>
<p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile变量，对该变量的读写就将具有原子性。<strong>如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性</strong>。</p>
<p>简而言之，volatile 变量自身具有下列特性：</p>
<ul>
<li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
<li>原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ul>
<h4>volatile 写-读的内存定义</h4>
<ul>
<li>当<strong>写</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当<strong>读</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<p>假设上面的程序 flag 变量用 volatile 修饰</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474329?w=1200&amp;h=948"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_10-13-39"" title=""2018-02-28_10-13-39""></span></p>
<h4>volatile 内存语义的实现</h4>
<p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474330?w=1434&amp;h=452"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_10-26-43"" title=""2018-02-28_10-26-43""></span></p>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>下面是基于保守策略的 JMM 内存屏障插入策略：</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>下面是保守策略下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474331?w=1332&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_10-31-14"" title=""2018-02-28_10-31-14""></span></p>
<p>下面是在保守策略下，volatile 读操作 插入内存屏障后生成的指令序列示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474332?w=1328&amp;h=826"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_10-38-12"" title=""2018-02-28_10-38-12""></span></p>
<p>上述 volatile 写操作和 volatile 读操作的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p>
<h3>锁</h3>
<h4>锁释放和获取的内存语义</h4>
<p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p>
<h4>锁内存语义的实现</h4>
<p>借助 ReentrantLock 来讲解，PS： 后面专门讲下这块（ReentrantLock、Synchronized、公平锁、非公平锁、AQS等），可以看看大明哥的博客：[<a href=""http://cmsblogs.com/?p=2210"" rel=""nofollow noreferrer"">http://cmsblogs.com/?p=2210</a>]()</p>
<h4>concurrent 包的实现</h4>
<p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为 volatile；</li>
<li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474333?w=1338&amp;h=946"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_14-58-32"" title=""2018-02-28_14-58-32""></span></p>
<h3>final</h3>
<p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<h4>写 final 域的重排序规则</h4>
<p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ul>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ul>
<h4>读 final 域的重排序规则</h4>
<p>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p>
<h4>final 域是引用类型</h4>
<p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<h3>总结</h3>
<h4>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h4>
<p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474334?w=1252&amp;h=978"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_15-34-39"" title=""2018-02-28_15-34-39""></span></p>
<h4>JMM 的设计示意图</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474335?w=1330&amp;h=1264"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jmm-"" title=""jmm-""></span></p>
<h4>JMM 的内存可见性保证</h4>
<p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p>
<p>1.单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2.正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3.未同步/未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p>
<p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013474336?w=1354&amp;h=1034"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2018-02-28_15-43-10"" title=""2018-02-28_15-43-10""></span></p>

                ", 《深入理解 Java 内存模型》读书笔记,1531977911,423,1,412,1,1,https://segmentfault.com/a/1190000013474307
52,1,0,9,"
                    
<h1><strong>前端知识点总结——CSS</strong></h1>
<h2>1.CSS的概述</h2>
<p>1.什么是CSS?</p>
<pre><code>CSS：Cascading Style Sheets层叠样式表，级联样式表（简称：样式表）</code></pre>
<p>2.作用</p>
<pre><code>设置HTML网页元素的样式</code></pre>
<p>3.HTML与CSS的关系</p>
<pre><code>HTML：负责内容的展示
CSS：负责内容（元素）的修饰</code></pre>
<p>4.HTML与CSS之间的使用原则</p>
<pre><code>W3C建议尽量使用CSS属性去取代HTML属性来修饰元素
</code></pre>
<h2>2.CSS语法规范</h2>
<p>1.使用CSS样式的方式(重点)</p>
<pre><code> 1.内联样式
   又称为行内样式
   特点：将CSS样式定义在HTML开始标记中
   语法：
     &lt;ANY style=""样式声明1；样式声明2""&gt;&lt;/ANY&gt;
 样式声明：
      1.由样式属性和值来组成
      2.属性名与值之间用 冒号 连接
      3.多个样式声明之间用 分号 分割
        常用的CSS样式属性 和 值：
      1.设置文本颜色的属性和值
        属性：color
    值：合法的颜色值（英文）
      2.设置背景颜色的属性和值
        属性：background
    值：合法的颜色值（英文）
      3.设置文字大小的属性和值
        属性：font-size
    值：以px或pt为单位的数字
    ex：font-size:30px;
     
      2.内部样式
   在网页的头元素中增加一对&lt;style&gt;标记，在&lt;style&gt;标记声明该网页用到的样式规则
   语法： &lt;head&gt;
             &lt;style&gt;
        /*注释*/

        样式规则1
        样式规则2
        ...
     &lt;/style&gt;
      &lt;/head&gt;
    样式规则：由选择器和样式声明组成
选择器：规范了页面中哪些元素能够使用定义好的样式（就是把声明好的样式匹配给页面中的元素）
元素选择器：由元素的名称作为选择器
div,p,h1,span,a,img
选择器{}
ex：div{}
    p{}
样式规则：
   选择器{
      样式声明；
   }
ex:
div{
   color:red;
   font-size:20px;
}
p{
  color:blue;
}
h1{...}


 3.外部样式
   独立于任何网页的位置处，声明一个样式表文件（***.css为后缀），
   在.css文件中保存样式规则，然后在网页中引入.css文件。
   使用步骤：
       1.创建样式表文件，并编写样式规则
   2.在网页中引入样式表文件
     &lt;head&gt;
        &lt;link rel=""stylesheet"" href=""**.css""&gt;
     &lt;/head&gt;

</code></pre>
<h2>3.CSS样式特征</h2>
<pre><code>1.继承性
  大部分样式可以被继承（子元素继承父元素的样式特征）
  必须是有层级关系的嵌套
  &lt;div style=""color:red;""&gt;
     &lt;p&gt;p&lt;/p&gt;
  &lt;/div&gt;
2.层叠性 
  可以为一个元素定义多个样式，当样式属性不冲突时，可以同时将这些样式应用到元素上
  div{
     color:red;
  }
  div{
     font-size:20px;
  }
  div{
     background:gray;
  }
  
3.优先级
  如果样式声明冲突时，会按照样式的优先级来应用定义的样式规则
      由低到高：
     浏览器默认设置       最低
     内部样式和外部样式   中(就近原则)
     内联样式             最高

4.调整显示的优先级
  !important规则：
  调整显示的优先级
  将!important添加在属性值之后，与值之间用空格隔开，就能优先使用当前样式
  ex:
    color:red !important;

</code></pre>
<h2>4.CSS基础选择器（重点）</h2>
<pre><code>1.选择器的作用
  规范页面中哪些元素能够使用定义好的样式
2.选择器详解
  1.通用选择器
    作用：可以修饰页面上的任何元素
语法：*{样式声明}
效率较低，尽量少用
ex:
  *{
    color:red;
    font-size:40px;
  }
</code></pre>
<p>2.元素选择器</p>
<pre><code>    作用：设置页面上某种（类）元素的样式
语法：标记名称{声明样式}
ex：
  div{}
  p{}
  span{}  
</code></pre>
<p>3.类选择器</p>
<pre><code>    作用：定义页面上某个或某些元素的样式(谁想用谁就可以引用)
特点：通过元素的class属性进行引用
语法：
   1.声明
     .类名{样式声明}
     注意：
       1.类名是自定义的，但是注意类名不能以数字开头
       2.类名不能包含特殊符号（&amp;,^,%,$,#,@）
       3.可以包含（_,-）
   2.引用
     &lt;ANY class=""类名""&gt;

    特殊用法：
       1.多类选择器
     让一个元素同时引用多个类选择器
     语法：
     &lt;ANY class=""类名1 类名2 类名3 ...""&gt;

       2.分类选择器
     将元素选择器和类选择器联合使用
     对同一类元素中某些特殊的内容进行修饰
     语法：元素名称.类选择器{样式声明}
        ex:div.text{color:red;}
      &lt;div class=""text""&gt;dddd&lt;/div&gt;
      &lt;div&gt;d1d1d1&lt;/div&gt;
</code></pre>
<p>4.id选择器</p>
<pre><code>作用：设置指定ID元素的样式（专属定制）
语法：#id值{样式声明}
ex:
  &lt;div id=""one""&gt;&lt;/div&gt;
  #one{
    color:red;
  }
</code></pre>
<p>5.群组选择器</p>
<pre><code>作用：将多个选择器放在一起进行样式的声明定义
语法：选择器1,选择器2,选择器3,...{样式声明}
 ex:
   div,#main,.mycolor,p.text{color:red;}
   等同于：
 div{color:red};
 #main{color:red};
 .mycolor{color:red};
 p.text{color:red};</code></pre>
<p>6.后代选择器</p>
<pre><code>作用：通过元素的后代关系匹配元素（多级嵌套）
语法：选择器1 选择器2 选择器3{样式声明}</code></pre>
<p>7.子代选择器</p>
<pre><code>作用：通过元素的子代（一层层级关系）关系匹配元素
语法：选择器1&gt;选择器2{样式声明}</code></pre>
<p>8.伪类选择器</p>
<pre><code>作用：匹配元素不同的状态的选择器
语法：
   所有的伪类都是以：作为开始
   选择器：伪类选择器{样式声明}
1.连接伪类
     :link 匹配元素尚未访问的状态
 :visited 匹配元素访问过的状态
2.动态伪类
     :hover 匹配鼠标悬停在元素上时的状态
 :active 匹配元素被激活时的状态（超链接，文本框，密码框点击的时候）
 :focus 匹配元素获取焦点时的状态（文本框和密码框）

3.选择器的优先级
  权值：标识当前选择器的重要程度，权值越大优先级越高。
    元素选择器：1
类选择器：  10
伪类选择器：10
ID选择择器：100
内联样式：  1000

选择器的权值加到一起，大的优先
权值相同，以后定义的为主
</code></pre>
<h2>5.尺寸与边框</h2>
<p>1.单位</p>
<pre><code>1.尺寸单位
  1.px：像素
    1024*768
  2.in:英寸
    1in=2.54cm
  3.pt：磅(1pt=1/72in)
    多数用于表示文字的大小
  4.cm:厘米
  5.mm:毫米
  6.em:相对于父元素乘以倍数(多个父元素2em)
  7.rem:根相对（元素字体大小乘以倍数，html\body）

2.颜色单位（颜色取值）
  1.英文单词
    red,blue,gray,green,yellow,black....
  2.rgb(r,g,b)
    r:0-255
g:0-255
b:0-255
  3.rgba(r,g,b,alpha)
    alpha:透明度，取值为0-1之间的小数，值越大，不透明度越高
  4.#rrggbb
    由6位16进制的数字\字母表示一个颜色
0-9或A-f
#000000:黑色
#ffffff:白色
#eeeeee:灰色
#ff11aa
  5.#rgb是上面的缩写形式
    #000:黑色
#fff:白色
#f1a
</code></pre>
<p>2.尺寸属性</p>
<pre><code>1.作用
  设置元素的宽度和高度
2.语法
  1.宽度
    width:宽度
min-width:最小宽度
max-width:最大宽度
  2.高度
    height：高度
min-height:最小高度
max-height:最大高度
3.页面中哪些元素允许设置尺寸属性
  1.所有的块级元素都允许设置尺寸
    div,p,h1,h2..h6,ul,ol,dl,结构标记
  2.本身具备width和height属性的行内元素是可以设置的
    img,table
  3.行内块允许设置尺寸
    大部分的表单控件（单选按钮，复选框）
  4.大部分的行内元素是无法设置尺寸
    a,span,b,i,u,s等
</code></pre>
<p>3.溢出处理</p>
<pre><code>当内容多，元素区域小的时候，就会产生溢出的效果，默认都是纵向溢出。
属性：overflow,overflow-x,overflow-y
取值：
   1.visible
     可见的，默认值，溢出可见
   2.hidden
     隐藏的，溢出的内容全部隐藏，溢出内容不可见
   3.scroll
     显示滚动条，溢出时，可用
   4.auto
     自动，溢出时才显示滚动条并可用

   </code></pre>
<p>4.边框</p>
<pre><code>1.边框属性
  1.简写方式
    border:width style color;
     width:边框的宽度，以px为单位的数值
     style:边框的样式
       取值：
         solid:实线
     dotted:虚线边框(点)
     dashed:虚线边框(线)
     color:边框的颜色
         取值：合法的颜色值
     transparent:透明色
     注意：
       取消边框：border:0;或border:none;
       


  2.单边定义
    只设置某一条边的边框
属性：border-方向:width style color;
    方向：top/bottom/left/right
       上   下     左   右

  
  3.单属性定义
    只设置四条边框的一个属性
属性：border-width/style/color:值；
  ex:border-width:3px;
     border-style:dotted;
     border-color:red;

  4.单边单属性的定义
    只设置某一个方向的某一个属性
属性：
  border-方向-属性：值；
  方向：top/bottom/left/right
  属性：width/style/color
  ex：
    border-left-color:blue;
    border-right-style:solid;
    border-bottom-width:6px;
2.边框倒角
  将元素的直角倒换成圆角
  属性：border-radius
  取值：
        1.以px为单位的数值
        2.百分比 %  设置圆形（50%）

  单角设置：
     border-top-left-radius:左上角
 border-top-right-radius:右上角
 border-bottom-left-radius:左下角
 border-bottom-right-radius:右下角
3.边框阴影
 属性：box-shadow
 取值：h-shadow v-shadow blur spread color inset
    h-shadow:阴影在水平方向的偏移距离，必须值   
     取值为正：阴影向右偏移
     取值为负：阴影向左偏移
v-shadow:阴影在垂直方向的偏移距离，必须值   
     取值为正：阴影向下偏移
     取值为负：阴影向上偏移
blur:阴影模糊距离，取值越大，模糊效果越明显，以px为单位的数值（可选值）
spread:阴影的大小，指定要在基础阴影上扩充出来的大小，取值以px为单位的数值（可选值）
color:阴影颜色（可选值）
inset:将默认的外阴影改为内阴影（可选值）

 
4.轮廓
  轮廓指的是边框的边框，绘制于边框外围的一条线
  属性：
     outline:width style color;
 widht:轮廓的宽度
 style:轮廓的样式  
    取值：solid/dotted/dashed
 color:轮廓的颜色

  取消轮廓：
       outline:none/0;
</code></pre>
<h2>6.框模型</h2>
<p>1.什么是框模型</p>
<pre><code>框模型：box model,定义了元素框处理元素的内容，内边距，外边距以及边框的一种计算方式。
外边距：元素与元素之间的空白间距
内边距：元素边框与元素内容之间的间距
框模型的计算模式：
    元素的实际占地宽度=左右外边距+左右边框+左右内边距+width;
元素的实际占地高度=上下外边距+上下边框+上下的内边距+height
</code></pre>
<h2>7.外边距</h2>
<p>1.什么是外边距</p>
<pre><code>围绕在元素边框外的空白距离，就是外边距
也能表示当前元素与其他元素之间的空白距离</code></pre>
<p>2.语法</p>
<pre><code>属性：
   margin 定义某个元素四个方向的外边距
   margin-top/bottom/left/right 定义单边的外边距
取值：
   1.具体数值，以px为单位
   2.取值为负
     让元素向相反的方向移动
 margin-left:
  取值为正，让元素向右移动
  取值为负，让元素向左移动
 margin-top:
  取值为正，让元素向下移动
  取值为负，让元素向上移动
   3.取值为%
     外边距的值，是父元素的宽或高的占比（50%）
   4.取值为auto
     自动计算外边距的值（控制块级元素水平居中对齐）
 
简写方式：
    1.margin:value
  四个方向的外边距
2.margin:v1 v2;
  v1:上下外边距
  v2:左右外边距
3.margin:v1 v2 v3;
  v1:上外边距
  v2:左右外边距
  v3:下外边距
3.margin:v1 v2 v3 v4;
         上 右 下 左  （顺时针方向）</code></pre>
<p>3.自带外边距的元素</p>
<pre><code>body,h1~h6,p,ul,ol,dl,dd,pre
通过CSS Reset(css重写)的手段，来重置具备外边距的元素
 body,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{
    margin:0;
 }</code></pre>
<p>4.外边距的特殊效果</p>
<pre><code>1.外边距合并
  当两个垂直外边距相遇时，他们将合并为一个，最终取决于两个外边距中距离较大的那个。
  如果两个外边距相遇时值相等，那么取其中一个值。
2.外边距的溢出
  在某些条件下，为子元素设置上外边距时，有可能会作用到父元素上。
      1.父元素没有上边框
  2.为子元素设置上外边距时
  
2.在d2中嵌套一个子元素div,id=""d3"",设置其尺寸为100*100，并设置其背景颜色
3.设置d3的上外边距为50px,观察其结果。
 解决溢出方案：
    1.为父元素增加上边框
  弊端：对父元素的高度有影响
2.使用父元素的上内边距来取代子元素的上外边距
  弊端：对父元素的高度有影响
3.在父元素的第一个子元素位置处，增加一个空(table)
 行内元素以及行内块元素的垂直外边距
     1.行内元素垂直外边距无效（img除外）
 2.行内块元素，设置垂直外边距时，整行元素都跟着发生改变
</code></pre>
<h2>8.内边距</h2>
<p>1.什么是内边距</p>
<pre><code>元素边框与内容之间的空白距离
内边距会扩大元素边框占地区域</code></pre>
<p>2.语法</p>
<pre><code>属性：
   padding 四个方向的内边距
   padding-top/bottom/left/right 设置单边内边距
取值：
      以px为单位的数值
      以%形式设置
简写方式：
      1.padding:value;  四个方向的内边距
  2.padding:v1 v2; 
    v1:上下内边距
    v2:左右内边距
  3.padding:v1 v2 v3;
    v1:上
    v2:左右
    v3:下
  4.padding:v1 v2 v3 v4;
            上 右 下 左 （顺时针）

</code></pre>
<h2>9.属性：box-sizing</h2>
<p>作用：指定框模型的计算方式</p>
<pre><code>取值：
   1.content-box
     默认值，采用默认的计算元素的占地区域
 实际占地宽度=左右边框+左右外边距+左右内边距+width;
 实际占地高度=上下边框+上下外边距+上下内边距+height;
   2.border-box
     元素的尺寸，会包含border以及padding的值
 实际占地宽度=width(包含了border和padding)
 实际占地高度=height(包含了border和padding)
 </code></pre>
<p>3.背景属性<br>  背景：可以是单一颜色或图片填充元素<br>  1.背景色</p>
<pre><code>属性：background-color
取值：合法的颜色值
注意：背景颜色默认是从边框的位置处开始填充的</code></pre>
<p>2.背景图片</p>
<pre><code>属性：background-image
取值：url(图片的路径);
ex:background-image:url(a.jpg);</code></pre>
<p>3.背景图片平铺</p>
<pre><code>属性：background-repeat
取值：
   repeat 默认值，横向纵向都平铺
   no-repeat 不平铺（图片只显示一次）
   repeat-x 只在水平方向平铺
   repeat-y 只在垂直方向平铺</code></pre>
<p>4.背景图片尺寸</p>
<pre><code>属性：background-size
取值：
   1.width/height  (ex:200px 300px)
   2.width%/height%  (ex:50% 50% 是元素自己的高宽占比)
   3.cover
     将背景图等比放大，直到背景图完全覆盖到元素的所有区域为止。
   4.contain
     将背景图等比放大，直到背景图碰到元素的某一个边缘为止</code></pre>
<p>5.背景图片固定</p>
<pre><code>作用：将背景图固定在网页的某个位置处，一直在可视区域中，不会随着滚动条而发生位置的变化。
属性：background-attachment
取值：
   1.scroll 默认值，滚动
   2.fixed 固定
</code></pre>
<p>6.背景图片定位</p>
<pre><code>作用：改变背景图在元素中的位置
属性：background-position
取值：
   1.x y  具体的数值（px）
     x:
   背景图水平偏移距离
   取值为正，向右移动
   取值为负，向左移动
 y:
   背景图垂直偏移距离
   取值为正，向下移动
   取值为负，向上移动
   2.x% y%
     0% 0% 背景图在左上角
 100% 100% 背景图在右下角
 50% 50% 背景图在中间位置
   3.关键字
 x:left/center/right
 y:top/center/bottom
 ex:background-position:right top;
 
  </code></pre>
<p>7.背景简写属性</p>
<pre><code>在一个属性中指定背景的多个属性值
属性：background
取值：color url() repeat attachment position
ex：
  background:gray url(a.jpg);
注意：
  如果不设置其中某个属性值的话，该位置采用默认值。
</code></pre>
<h2>8.渐变</h2>
<p>1.什么是渐变</p>
<pre><code>渐变指定是多种颜色平缓变换的一种显示效果。</code></pre>
<p>2.渐变的主要因素</p>
<pre><code>1.色标：一种颜色及其出现的位置
2.一个渐变是由多个色标组成（至少两个）</code></pre>
<p>3.渐变分类</p>
<pre><code>1.线性渐变
  以直线的方向来填充效果
2.径向渐变
  以圆形的方式来实现填充
3.重复渐变
  将线性渐变或径向渐变 重复几次实现填充</code></pre>
<p>4.渐变详解</p>
<pre><code>1.线性渐变
  属性：background-image
  取值：linear-gradient(angle,color-point1,color-point2,....);
    1.angle
  表示渐变填充的方向或角度
  取值：
    1.关键字
      to top 从下向上填充渐变色
      to bottom 从上向下填充渐变色
      to left 从右向左填充渐变色
      to right 从左向右填充渐变色
    2.角度值
     0deg 从下向上填充，等同于to top
     90deg 从左向右填充，等同于to right
     180deg 从上到下填充，等同于to bottom
     270deg 从右向左填充，等同于to left
    2.color-point
  色标：颜色 及其 位置
  取值：颜色 以及 位置的组合，中间用空格分开
  ex:
    1.red 0%
      在填充方向的开始位置处颜色为红色
    2.green 50%
      到填充方向一半的位置处，颜色变为绿色
    3.blue 200px
      到填充方向的200px的位置处，颜色变为蓝色
2.径向渐变
  属性：
  background-image:radial-gradient([size at position],
  color-point1,color-point2,...);
  size at position: 
      size:半径，以px为单位的数值
  position:圆心所在位置
       1.x y 具体数值
       2.x% y% 元素宽和高的占比
       3.关键字
         x:left,center,right
     y:top,center,bottom
  ex：
    100px at right top 
半径     右上角位置
3.重复渐变
  1.重复线性渐变
    background-image:repeating-linear-gradient
    (angle,color-point1,color-point2,...);
color-point:位置一定要给绝对数值（px）,不要用相对单位%
  2.重复径向渐变
    background-image:repeating-radial-gradient
    ([size at position],color-point1,color-point2,...);

</code></pre>
<h2>9.浏览器兼容性</h2>
<pre><code> 各个浏览器的新版本都支持渐变属性
对于不支持的浏览器版本，可以通过增加浏览器前缀的方式，让浏览器支持渐变属性
Firefox:-moz-
Chrome &amp; Sagari:-webkit-
Opera:-o-
IE:-ms-
</code></pre>
<p>2.文本格式化属性<br>  1.字体属性</p>
<pre><code>1.指定字体
  属性：font-family
  取值：字体名称，名称之间用逗号隔开
  ex：
  font-family:""微软雅黑"",Arial,""黑体"";
2.字体大小
  属性：font-size
  取值：以px或pt为单位的数字
3.字体加粗
  属性：font-weight
  取值：
     1.bold 加粗（b,hn）
 2.normal 正常
 3.value 无单位的数字（整百倍）
   400-900
   400：等同于normal
   900：等同于bold
4.字体样式
  属性：font-style
  取值：
     1.normal 正常显示 
 2.italic 斜体显示
5.小型大写字母
   将小写字符变成大写，但文本的大小与小写字符一致
   属性：font-variant
   取值：
      1.normal 正常
  2.small-caps 小型的大写字符
6.字体属性简写
  属性：font
  取值：style variant weight size family;
  注意：
    如果用简写方式，必须设置family的值，否则无效。
font:12px; 错误
font:12px ""黑体""; 正确

 </code></pre>
<p>2.文本格式</p>
<pre><code>1.文本颜色
  属性：color
  取值：合法的颜色值
2.文本排列
  作用：指定文本，行内，行内块元素的水平对齐方式。
  属性：text-align
  取值：left/center/right/justify(两端对齐)
3.文字修饰（线条）
  属性：text-decoration
  取值：
    none:无任何线条修饰
underline:下划线修饰
overline:上划线修饰
    line-through:删除线修饰
4.行高
  作用:定义一行文本的高度
  特点：如果行高的高度大于字体本身的大小，那么该行文本将在指定的行高内呈现垂直居中的效果。
  属性:line-height
  取值：以px为单位数值
5.首行文本缩进
  属性：text-indent
  取值：以px为单位的数值
6.文本阴影
  属性：text-shadow
  取值：h-shadow v-shadow blur color;
</code></pre>
<h2>10.表格</h2>
<p>1.表格的常用属性</p>
<pre><code>1.边距属性：padding
2.边框属性：border
3.尺寸属性：width,height
4.文本格式化属性：font-*,text-*,line-height
5.背景属性：颜色，图片，渐变
6.vertical-align
  作用：指定单元格数据垂直对齐方式
  取值：
     top:上对齐
 middle:居中对齐
 bottom:下对齐
 练习：创建网页，并在网页中添加表格
     1.表格尺寸为400*400，4行4列;
 2.每个单元格的尺寸为100*100,内容随意;
 3.设置表格和单位元格的边框为1px solid #000;
 4.设置每个单元格的左内边距为20px;
 5.尝试为每个单元格增加上外边距15px。</code></pre>
<p>2.表格的特殊属性</p>
<pre><code>1.边框合并
  取值：border-collapse
  取值：
     1.separate
   默认值，即分离边框模式
 2.collapse
   边框合并
2.边框边距
  作用：设置单元格之间或单元格与表格之间的距离
  属性：border-spacing
  取值：
    1.给定一个值：水平和垂直的间距相同
2.给两个值：
  第一个值 表示水平间距
  第二个值 表示垂直间距
注意：只有在边框分离模式下，边框边距才有效果，即border-collapse:separate时，border-spacing才有效。
    </code></pre>
<p>3.表格标题位置</p>
<pre><code>属性：caption-side
取值：
    1.top:默认值，标题在表格内容之上
2.bottom:标题在表格内容之下
</code></pre>
<p>4.显示规则</p>
<pre><code>作用：用来帮助浏览器指定如何布局一张表，也就是指定td尺寸的计算方式。
属性：table-layout
取值：
   1.auto
     默认值，即自动布局表格，列的尺寸实际上由内容来决定的。
   2.fixed
     固定表格布局，列的尺寸由设置的值为准
自动表格布局VS固定表格布局：
    1.自动表格布局
  1.单元格的大小会适应内容
  2.表格复杂时，加载速度较慢（缺点）
  3.自动表格布局会比较灵活（优点）
  4.适用于不确定每列大小时使用
    2.固定表格布局
  1.单元格的尺寸取决于设定的值
  2.任何情况下都会加载显示表格（优点）
  3.适用于确定每列大小时使用
  4.固定表格布局不够灵活（缺点）
</code></pre>
<h2>11.定位-浮动定位</h2>
<p>1.定位</p>
<pre><code>定位：指的是改变元素在页面中的默认位置</code></pre>
<p>2.定位的分类</p>
<pre><code>按照定位的效果，可以分成以下几类：
   1.普通流定位（默认的定位方式）
   2.浮动定位
   3.相对定位
   4.绝对定位
   5.固定定位</code></pre>
<p>3.定位详解</p>
<pre><code>1.普通流定位
  又称为文档流定位，页面中元素的默认定位方式
  1.每个元素在页面中都有自己的空间
  2.每个元素默认都是在其父元素的左上角开始显示
  3.页面中的块级元素都是从上往下排列，每个元素独占一行
  4.页面中的行内元素以及行内块都是按照从左到右的顺序来排列的

  要解决的问题：让多个块级元素在一行中显示
2.浮动定位
  1.什么是浮动&amp;特点
    1.元素一旦浮动起来，将不占据页面空间（脱离了文档流），其它未浮动元素将上前补位。
2.浮动元素会停靠在父元素的左边或右边，或其它已经浮动的元素的边缘上。
3.浮动定位解决的问题：能够让多个块级元素在一行中显示。
  2.语法
    属性：float
取值：
   1.left
     左浮动，让元素停靠在父元素的左边或挨着左侧已经浮动的元素
   2.right
     右浮动，让元素停靠在父元素的右边或挨着右侧已经浮动的元素
   3.none
     默认值，即无任何浮动效果

</code></pre>
<h2>12.浮动引发的特殊效果</h2>
<p>1.元素一旦浮动起来以后就会变成块级元素</p>
<pre><code>允许修改尺寸
能正常处理垂直方向外边距</code></pre>
<p>2.当父元素显示不下所有已浮动元素时，最后一个将换行，但是，有可能被卡住；<br>  3.元素一旦浮动起来后，宽度将以内容为主（未指定宽度情况下）；<br>  4.文本，行内元素，行内块元素是采用环绕的方式来排列的，是不会别浮动元素压在底下的，而会巧妙的避开浮动元素。</p>
<h2>13.清除浮动带来的影响</h2>
<p>元素一旦浮动起来之后，就会对后续元素带来一定的位置影响（后续元素要上前补位），如果后续元素不想被影响（不想补位），那么就可以通过清除浮动的方式来解决<br>  属性：clear<br>  取值：</p>
<pre><code> 1.left
   清除当前元素前面的元素左浮动所带来的影响
 2.right
   清除当前元素前面的元素右浮动所带来的影响
 3.both
   清除当前元素前面元素任何一种浮动所带来的影响
 4.none
   默认值，不做任何的清除浮动操作
</code></pre>
<h2>14.浮动元素对父元素高度的影响</h2>
<p>1.元素的高度都是以未浮动元素的高度为准的，浮动元素是不占页面的高度的</p>
<pre><code> 解决父元素的高度方案如下：
    1.直接设置父元素的高度
  弊端：不是每次都知道父元素的高度
2.设置父元素也浮动
  弊端：不是任何时候父元素都需要浮动，而且浮动会影响后续元素
3.为父元素设置overflow
  取值：hidden或auto
  弊端：如果有内容需要溢出显示的话，也会一同被隐藏
4.在父元素中，追加空子元素(块级)，并设置其clear:both;
</code></pre>
<h2>15.显示</h2>
<p>1.显示方式</p>
<pre><code>1.什么是显示方式
  决定了元素在网页中的表现形式（块级，行内，行内块）
2.语法
  属性：display
  取值：
     1.none 不显示元素-隐藏
   特点：脱离文档流，不占据页面空间
 2.block
   让元素表现的和块级元素一致
   特点：
      独占一行，可是修改高宽
 3.inline
   让元素表现的和行内元素一致
   特点：
      不允许修改尺寸
      多个元素在一行中显示
      无法设置垂直外边距
 4.inline-block
   让元素表现的和行内块元素一致
   特点：
     多个元素在一行中显示，但是可以修改尺寸
 5.table
   让元素表现的与表格一致
   特点：
      尺寸以内容为准
      每个元素独占一行
      允许修改尺寸
</code></pre>
<p>2.显示效果</p>
<pre><code>1.显示/隐藏
  属性：visibility
  取值：
      1.visible:默认值，元素可见
  2.hidden:元素不可见-隐藏
  面试：display:none和visibility:hidden的区别
        display:none 不占页面空间
    visibility:hidden 占页面空间
2.透明度
  属性：opacity
  取值：0.0（完全透明）~1.0（完全不透明）之间的小数
3.垂直方向对齐方式
  属性：vertical-align
  场合：
     1.表格中使用
   取值：top/bottom/middle
 2.图片（img）中使用
   取值：
      top：上
      bottom：下
      middle：中间
      baseline:基线对齐，默认值
</code></pre>
<h2>16.光标</h2>
<p>1.作用</p>
<pre><code>改变鼠标悬停在元素上时，鼠标的状态</code></pre>
<p>2.语法</p>
<pre><code>属性：cursor
取值：
    1.default: 默认
2.pointer: 小手
3.crosshair: +
4.text: I
5.wait: 等待
6.help: 帮助
 练习：
   新建一个div元素，当鼠标移入到div上时，让光标变成小手状态。
</code></pre>
<h2>17.列表</h2>
<p>1.列表项标记</p>
<pre><code>属性：list-style-type
取值：
   1.none
   2.disc
   3.circle
   4.square</code></pre>
<p>2.列表项图像</p>
<pre><code>作用：使用自定义图像作为列表项标识
属性：list-style-image
取值：url(图像路径);</code></pre>
<p>3.列表项位置</p>
<pre><code>作用：将默认的列表项标识的位置，放到li里面
属性：list-style-position
取值：
   1.outside 默认值，将标识显示在li外面的
   2.inside 将标识放于li里面</code></pre>
<p>4.列表属性简写</p>
<pre><code>属性：list-style
取值：type url() position;
常用方式：list-style:none;
列表的使用场合：
   横向排列或纵向排列的内容，都可以使用列表来实现。
</code></pre>
<h2>18.定位</h2>
<p>相对定位，绝对定位，固定定位<br>  1.定位相关属性</p>
<pre><code>属性：position
取值：
   1.static:静态，默认值
   2.relative:相对定位
   3.absolute:绝对定位
   4.fixed:固定定位</code></pre>
<p>2.偏移属性</p>
<pre><code>top/bottom/left/right
以上四个属性的取值均为数字
ex:
  top:150px 元素向下移动150px
  left:20px 元素向右移动20px
  right:-150px 元素向右移动150px
注意：
  只有已定位元素才能使用偏移属性</code></pre>
<p>3.定位详解</p>
<pre><code>1.相对定位
  1.什么是相对定位
    元素相对于它原来的位置偏移某个距离
  2.使用场合
    做元素位置微调时使用
  3.语法
      position:relative;
      配合偏移属性来实现位置的移动
      left:10px;
      top:10px;
2.绝对定位
  1.什么是绝对定位&amp;特点
    1.绝对定位的元素会脱离文档流-不占页面空间
2.绝对定位的元素会相对于离他最近的，已定位的，祖先元素 去实现位置的初始化。
3.如果没有已定位的祖先元素，那么该元素就相对于body去实现位置的初始化
4.配合偏移属性 实现元素位置的修改
  2.语法
    position:absolute;
配合偏移属性实现位置的修改
  3.使用场合
    1.有堆叠效果的元素
2.弹出菜单
  4.注意：
    1.脱离文档流-不占据页面空间
2.绝对定位元素会变成块级元素

  5.堆叠顺序
    一旦元素变为已定位元素的话，元素们则有可能出现堆叠的效果
属性：z-index
取值：无单位的数字，数字越大越靠上
    注意：
  1.只有已定位元素才能实现堆叠顺序的改变（z-index）
  2.父子元素间，z-index无效，永远都是子元素压在父元素上方
3.固定定位
  1.什么是固定定位
    将元素固定在网页的某个位置处，位置不会随着滚动条而发生改变，固定在可视区域中。
  2.语法
    position:fixed;
配合偏移属性使用
  注意：
    1.固定定位的元素永远都是相对于body去实现位置的初始化和偏移。
2.固定定位的元素会变成块级元素
3.固定定位元素会脱离文档流-不占页面空间



 
  

   

 


  
    



   

  

    
  


  



  
  


</code></pre>

                ", 前端知识点总结——CSS,1531977913,343,1,131,1,1,https://segmentfault.com/a/1190000013370170
53,1,0,9,"
                    
<p>欢迎大家前往<a href=""https://cloud.tencent.com/developer"" rel=""nofollow noreferrer"">云+社区</a>，获取更多腾讯海量技术实践干货哦~</p>
<p>决策树可能会受到高度变异的影响，使得结果对所使用的特定测试数据而言变得脆弱。</p>
<p>根据您的测试数据样本构建多个模型（称为套袋）可以减少这种差异，但是树本身是高度相关的。</p>
<p>随机森林是套袋（方法）的延伸，除了基于多个测试数据样本构建树木之外，它还限制了可用于构建树木的特征，使得树木间具有差异。这反过来可以提升算法的表现。</p>
<p>在本教程中，您将了解如何在Python中从头开始实现随机森林算法。</p>
<p>完成本教程后，您将知道：</p>
<ul>
<li>套袋决策树和随机森林算法的区别。</li>
<li>如何构造更多方差的袋装决策树。</li>
<li>如何将随机森林算法应用于预测建模问题。</li>
</ul>
<p>让我们开始吧。</p>
<p><strong>2017年1月更新</strong>：将cross_validation_split（）中fold_size的计算更改为始终为整数。修复了Python 3的问题。<br><strong>2017年2月更新</strong>：修复了build_tree中的错误。<br><strong>2017年8月更新</strong>：修正了基尼计算中的一个错误，增加了群组大小（基于迈克尔！）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013359864?w=640&amp;h=426"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如何在Python中从头开始实现随机森林 图片来自 InspireFate Photography，保留部分权利。</p>
<h2>描述</h2>
<p>本节简要介绍本教程中使用的随机森林算法和Sonar数据集。</p>
<h3>随机森林算法</h3>
<p>决策树涉及从数据集中（利用）贪婪选择选取最佳分割点过程中的每一步。</p>
<p>如果不精简（该算法），此算法容易使决策树出现高方差。这种高方差（结果）可以通过创建包含测试数据集中（多个）不同的实例（问题的不同观点）的多重树，接着将实例所有的可能结果结合，这种方法简称为bootstrap聚合或套袋。</p>
<p>套袋的局限性在于，它使用相同的贪婪算法来创建每棵树，这意味着在每棵树中可能会选择相同或非常相似的分割点，使得不同的树非常相似（树将被关联）。这反过来又使他们的预测相似，从而缩减了最初寻求的差异。</p>
<p>我们可以通过贪婪算法在创建树时在每个分割点评估的特征（行）来限制决策树不同。这被称为随机森林算法。</p>
<p>像装袋一样，测试数据集的多个样本在被采集后，接着在每个样本上训练不同的树。不同之处在于在每一点上，拆分是在数据中进行并添加到树中的，且只考虑固定的属性子集。</p>
<p>对于分类问题，我们将在本教程中讨论的问题的类型——分割中输入特点数的平方根值对为分割操作考虑的属性个数的限制。</p>
<pre><code>num_features_for_split = sqrt(total_input_features)
</code></pre>
<p>这一小变化的结果是树之间变得更加不同（不关联），作为结果会有更加多样化的预测，这样的结果往往好于一个单独的树或者单独套袋得到的结果。</p>
<h3>声纳数据集</h3>
<p>我们将在本教程中使用的数据集是Sonar数据集。</p>
<p>这是一个描述声纳声音从不同曲面反弹后返回（数据）的数据集。输入的60个变量是声呐从不同角度返回的力度值。这是一个二元分类问题，需要一个模型来区分金属圆柱中的岩石。这里有208个观察对象。</p>
<p>这是一个很好理解的数据集。所有变量都是连续的且范围一般是0到1。输出变量是“Mine”字符串中的“M”和“rock”中的“R”，需要转换为整数1和0。</p>
<p>通过预测在数据集（“M”或“mines”）中观测数最多的类，零规则算法可以达到53％的准确度。</p>
<p>您可以在UCI Ｍachine Learning repository了解关于此数据集的更多信息。</p>
<p>下载免费的数据集，并将其放置在工作目录中，文件名为<strong>sonar.all-</strong><strong>data.csv</strong>。</p>
<h2>教程</h2>
<p>本教程分为2个步骤。</p>
<ol>
<li>计算分割。</li>
<li>声纳数据集案例研究。</li>
</ol>
<p>这些步骤为您需要将随机森林算法应用于自己的预测建模问题奠定了基础。</p>
<h3>1.计算分割</h3>
<p>在决策树中，通过利用最低成本找到指定属性和该属性的值方法来确定分割点。</p>
<p>对于分类问题，这个成本函数通常是基尼指数，它计算分割点创建的数据组的纯度。基尼指数为0是完美纯度，其中在两类分类问题的情况下，将类别值完全分成两组。</p>
<p>在决策树中找到最佳分割点涉及到为每个输入的变量评估训练数据集中每个值的成本。</p>
<p>对于装袋和随机森林，这个程序是在测试数据集的样本上执行的，并且是可替换的。更换取样意味着同一行（数据）会不止一次的被选择并将其添加到取样中。</p>
<p>我们可以优化随机森林的这个程序。我们可以创建一个输入属性样本来考虑，而不是在搜索中枚举输入属性的所有值。</p>
<p>这个输入属性的样本可以随机选择而不需要替换，这意味着每个输入属性在查找具有最低成本的分割点的过程中只被考虑一次。</p>
<p>下面是实现此过程的函数名称get_split（）。它将数据集和固定数量的输入要素作为输入参数进行评估，此数据集可能是实际测试数据集的一个样本。</p>
<p>helper函数test_split（）用于通过候选分割点拆分数据集，gini_index（）用于根据创建的行组来计算给定拆分的花费。</p>
<p>我们可以看到，通过随机选择特征索引并将其添加到列表（称为特征）来创建特征列表，然后枚举该特征列表并且将测试数据集中的特定值评估作为分割点。</p>
<pre><code># Select the best split point for a dataset
def get_split(dataset, n_features):
    class_values = list(set(row[-1] for row in dataset))
    b_index, b_value, b_score, b_groups = 999, 999, 999, None
    features = list()
    while len(features) &lt; n_features:
        index = randrange(len(dataset[0])-1)
        if index not in features:
            features.append(index)
    for index in features:
        for row in dataset:
            groups = test_split(index, row[index], dataset)
            gini = gini_index(groups, class_values)
            if gini &lt; b_score:
                b_index, b_value, b_score, b_groups = index, row[index], gini, groups
    return {'index':b_index, 'value':b_value, 'groups':b_groups}
</code></pre>
<p>现在我们知道如何修改决策树算法以便与随机森林算法一起使用，我们可以将它与一个bagging实现一起使用，并将其应用于现实生活中的数据集。</p>
<h3>2.声纳数据集案例研究</h3>
<p>在本节中，我们将把随机森林算法应用到声纳数据集。</p>
<p>该示例假定数据集的CSV副本位于当前工作目录中，文件名为sonar.all-data.csv。</p>
<p>首先加载数据集，将字符串值转换为数字，并将输出列从字符串转换为0和1的整数值。这可以通过使用帮助器函数load_csv（），str_column_to_float（）和str_column_to_int（）来加载和预备数据集。</p>
<p>我们将使用k-fold交叉验证来估计未知数据的学习模型的性能。这意味着我们将构建和评估k个模型，并将性能估计为平均模型误差。分类准确性将用于评估每个模型。这些工具或是算法在cross_validation_split（），accuracy_metric（）和evaluate_algorithm（）辅助函数中提供。</p>
<p>我们也将使用适合套袋包括辅助功能分类和回归树（CART）算法的实现）test_split（拆分数据集分成组，gini_index（）来评估分割点，我们修改get_split（）函数中讨论在前一步中，to_terminal（），split（）和build_tree（）用于创建单个决策树，预测（）使用决策树进行预测，subsample（）创建训练数据集的子采样，以及bagging_predict（）用决策树列表进行预测。</p>
<p>开发了一个新的函数名称random_forest（），首先根据训练数据集的子样本创建一个决策树列表，然后使用它们进行预测。</p>
<p>正如我们上面所说的，随机森林和袋装决策树之间的关键区别是对树的创建方式中的一个小的改变，这里是在get_split（）函数中。</p>
<p>完整的例子如下所示。</p>
<pre><code># Random Forest Algorithm on Sonar Dataset
from random import seed
from random import randrange
from csv import reade
from math import sqrt
 
# Load a CSV file
def load_csv(filename):
    dataset = list()
    with open(filename, 'r') as file:
        csv_reader = reader(file)
        for row in csv_reader:
            if not row:
                continue
            dataset.append(row)
    return dataset
 
# Convert string column to float
def str_column_to_float(dataset, column):
    for row in dataset:
        row[column] = float(row[column].strip())
 
# Convert string column to intege
def str_column_to_int(dataset, column):
    class_values = [row[column] for row in dataset]
    unique = set(class_values)
    lookup = dict()
    for i, value in enumerate(unique):
        lookup[value] = i
    for row in dataset:
        row[column] = lookup[row[column]]
    return lookup
 
# Split a dataset into k folds
def cross_validation_split(dataset, n_folds):
    dataset_split = list()
    dataset_copy = list(dataset)
    fold_size = int(len(dataset) / n_folds)
    for i in range(n_folds):
        fold = list()
        while len(fold) &lt; fold_size:
            index = randrange(len(dataset_copy))
            fold.append(dataset_copy.pop(index))
        dataset_split.append(fold)
    return dataset_split
 
# Calculate accuracy percentage
def accuracy_metric(actual, predicted):
    correct = 0
    for i in range(len(actual)):
        if actual[i] == predicted[i]:
            correct += 1
    return correct / float(len(actual)) * 100.0
 
# Evaluate an algorithm using a cross validation split
def evaluate_algorithm(dataset, algorithm, n_folds, *args):
    folds = cross_validation_split(dataset, n_folds)
    scores = list()
    for fold in folds:
        train_set = list(folds)
        train_set.remove(fold)
        train_set = sum(train_set, [])
        test_set = list()
        for row in fold:
            row_copy = list(row)
            test_set.append(row_copy)
            row_copy[-1] = None
        predicted = algorithm(train_set, test_set, *args)
        actual = [row[-1] for row in fold]
        accuracy = accuracy_metric(actual, predicted)
        scores.append(accuracy)
    return scores
 
# Split a dataset based on an attribute and an attribute value
def test_split(index, value, dataset):
    left, right = list(), list()
    for row in dataset:
        if row[index] &lt; value:
            left.append(row)
        else:
            right.append(row)
    return left, right
 
# Calculate the Gini index for a split dataset
def gini_index(groups, classes):
    # count all samples at split point
    n_instances = float(sum([len(group) for group in groups]))
    # sum weighted Gini index for each group
    gini = 0.0
    for group in groups:
        size = float(len(group))
        # avoid divide by zero
        if size == 0:
            continue
        score = 0.0
        # score the group based on the score for each class
        for class_val in classes:
            p = [row[-1] for row in group].count(class_val) / size
            score += p * p
        # weight the group score by its relative size
        gini += (1.0 - score) * (size / n_instances)
    return gini
 
# Select the best split point for a dataset
def get_split(dataset, n_features):
    class_values = list(set(row[-1] for row in dataset))
    b_index, b_value, b_score, b_groups = 999, 999, 999, None
    features = list()
    while len(features) &lt; n_features:
        index = randrange(len(dataset[0])-1)
        if index not in features:
            features.append(index)
    for index in features:
        for row in dataset:
            groups = test_split(index, row[index], dataset)
            gini = gini_index(groups, class_values)
            if gini &lt; b_score:
                b_index, b_value, b_score, b_groups = index, row[index], gini, groups
    return {'index':b_index, 'value':b_value, 'groups':b_groups}
 
# Create a terminal node value
def to_terminal(group):
    outcomes = [row[-1] for row in group]
    return max(set(outcomes), key=outcomes.count)
 
# Create child splits for a node or make terminal
def split(node, max_depth, min_size, n_features, depth):
    left, right = node['groups']
    del(node['groups'])
    # check for a no split
    if not left or not right:
        node['left'] = node['right'] = to_terminal(left + right)
        return
    # check for max depth
    if depth &gt;= max_depth:
        node['left'], node['right'] = to_terminal(left), to_terminal(right)
        return
    # process left child
    if len(left) &lt;= min_size:
        node['left'] = to_terminal(left)
    else:
        node['left'] = get_split(left, n_features)
        split(node['left'], max_depth, min_size, n_features, depth+1)
    # process right child
    if len(right) &lt;= min_size:
        node['right'] = to_terminal(right)
    else:
        node['right'] = get_split(right, n_features)
        split(node['right'], max_depth, min_size, n_features, depth+1)
 
# Build a decision tree
def build_tree(train, max_depth, min_size, n_features):
    root = get_split(train, n_features)
    split(root, max_depth, min_size, n_features, 1)
    return root
 
# Make a prediction with a decision tree
def predict(node, row):
    if row[node['index']] &lt; node['value']:
        if isinstance(node['left'], dict):
            return predict(node['left'], row)
        else:
            return node['left']
    else:
        if isinstance(node['right'], dict):
            return predict(node['right'], row)
        else:
            return node['right']
 
# Create a random subsample from the dataset with replacement
def subsample(dataset, ratio):
    sample = list()
    n_sample = round(len(dataset) * ratio)
    while len(sample) &lt; n_sample:
        index = randrange(len(dataset))
        sample.append(dataset[index])
    return sample
 
# Make a prediction with a list of bagged trees
def bagging_predict(trees, row):
    predictions = [predict(tree, row) for tree in trees]
    return max(set(predictions), key=predictions.count)
 
# Random Forest Algorithm
def random_forest(train, test, max_depth, min_size, sample_size, n_trees, n_features):
    trees = list()
    for i in range(n_trees):
        sample = subsample(train, sample_size)
        tree = build_tree(sample, max_depth, min_size, n_features)
        trees.append(tree)
    predictions = [bagging_predict(trees, row) for row in test]
    return(predictions)
 
# Test the random forest algorithm
seed(2)
# load and prepare data
filename = 'sonar.all-data.csv'
dataset = load_csv(filename)
# convert string attributes to integers
for i in range(0, len(dataset[0])-1):
    str_column_to_float(dataset, i)
# convert class column to integers
str_column_to_int(dataset, len(dataset[0])-1)
# evaluate algorithm
n_folds = 5
max_depth = 10
min_size = 1
sample_size = 1.0
n_features = int(sqrt(len(dataset[0])-1))
for n_trees in [1, 5, 10]:
    scores = evaluate_algorithm(dataset, random_forest, n_folds, max_depth, min_size, sample_size, n_trees, n_features)
    print('Trees: %d' % n_trees)
    print('Scores: %s' % scores)
    print('Mean Accuracy: %.3f%%' % (sum(scores)/float(len(scores))))
</code></pre>
<p>使用k值5进行交叉验证，给定每个倍数值为208/5 = 41.6或者在每次迭代中刚好超过40个记录被计算。</p>
<p>构建深度树的最大深度为10，每个节点的最小训练行数为1。训练数据集样本的创建大小与原始数据集相同，这是随机森林算法的默认期望值。</p>
<p>在每个分割点处考虑的特征的数量被设置为sqrt（num_features）或者sqrt（60）= 7.74被保留为7个特征。</p>
<p>对一套有着3种不同数量的树木（示例）进行评测在此过程中进行比较，结果表明随着更多树木的添加，（处理）技能也随之提升。</p>
<p>运行该示例将打印每个折叠的分数和每个配置的平均分数。</p>
<pre><code>Trees: 1
Scores: [56.09756097560976, 63.41463414634146, 60.97560975609756, 58.536585365853654, 73.17073170731707]
Mean Accuracy: 62.439%
 
Trees: 5
Scores: [70.73170731707317, 58.536585365853654, 85.36585365853658, 75.60975609756098, 63.41463414634146]
Mean Accuracy: 70.732%
 
Trees: 10
Scores: [82.92682926829268, 75.60975609756098, 97.5609756097561, 80.48780487804879, 68.29268292682927]
Mean Accuracy: 80.976% 
</code></pre>
<h2>扩展</h2>
<p>本节列出了您可能有兴趣探索的关于本教程的扩展。</p>
<ul>
<li>
<strong>算法优化</strong>。发现教程中使用的配置有一些试验和错误，但没有进行优化。尝试更多的树木，不同数量的特征，甚至不同的树形配置来提高性能。</li>
<li>
<strong>更多的问题</strong>。将该技术应用于其他分类问题，甚至将其应用于回归，具有新的成本函数和结合树预测的新方法。</li>
</ul>
<p><strong>你有没有尝试这些扩展</strong>？ 在下面的评论中分享你的经验。</p>
<h2>评论</h2>
<p>在本教程中，您了解了如何从头开始实现随机森林算法。</p>
<p>具体来说，你了解到：</p>
<ul>
<li>随机森林和Bagged决策树的区别。</li>
<li>如何更新决策树的创建以适应随机森林过程。</li>
<li>如何将随机森林算法应用于现实世界的预测建模问题。</li>
</ul>
<blockquote>翻译人：一只懒惰的小白，该成员来自云+社区翻译社<br>原文链接：<a href=""https://machinelearningmastery.com/implement-random-forest-scratch-python/"" rel=""nofollow noreferrer"">https://machinelearningmaster...</a><br>原文作者：Jason Brownlee</blockquote>
<h2>相关阅读</h2>
<p><a href=""https://cloud.tencent.com/developer/article/1043112"" rel=""nofollow noreferrer"">教程从头开始在Python中实现k最近邻居</a><br><a href=""https://cloud.tencent.com/developer/article/1043114"" rel=""nofollow noreferrer"">Python NLTK 自然语言处理入门与例程</a><br><a href=""https://cloud.tencent.com/developer/article/1042161"" rel=""nofollow noreferrer"">浅谈用Python计算文本BLEU分数</a></p>
<hr>
<p>此文已由作者授权云加社区发布，转载请注明<a href=""https://cloud.tencent.com/developer/article/1043093"" rel=""nofollow noreferrer"">文章出处</a></p>

                ", 如何在Python中从零开始实现随机森林,1531977914,518,1,396,1,1,https://segmentfault.com/a/1190000013359859
54,1,0,9,"
                    
<h1><strong>前端面试题总结——HTML(持续更新中)</strong></h1>
<h2>1.什么是HTML？</h2>
<p>HTML：HyperText Markup Language超文本标记语言</p>
<h2>2.XHTML和HTML有什么区别</h2>
<p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标记语言</p>
<h2>3.简述一下你对HTML语义化的理解？</h2>
<p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>
<h2>4.浏览器页面有哪三层构成，分别是什么，作用是什么?</h2>
<p>浏览器页面构成：结构层、表示层、行为层<br>分别是：HTML、CSS、JavaScript<br>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</p>
<h2>5.Doctype作用？严格模式与混杂模式如何区分？</h2>
<p>（1）作用：用于告知浏览器的解析器用什么文档标准解析这个文档。<br>（2）区分:如果HTML文档包含形式完整的DOCTYPE，那么他一般以标准模式呈现。DOCTYPE不存在或者格式不正确会导致文档已混杂模式呈现。</p>
<h2>6.Quirks模式是什么？它和Standards模式有什么区别</h2>
<p>区别：<br>总体会有布局、样式解析和脚本执行三个方面的区别。<br>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。<br>设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。<br>用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</p>
<h2>7.页面导入样式时，使用link和@import有什么区别？</h2>
<p>（1）作用不同：link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<br>   而@import是CSS提供的，只能用于加载CSS;<br>（2）加载不同：页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>（3）兼容不同：import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
<h2>8.知道的网页制作会用到的图片格式有哪些？</h2>
<p>Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。<br>并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。<br>Apng：是PNG的位图动画扩展，可以实现png格式的动态图片效果，有望代替GIF成为下一代动态图标准。</p>
<h2>9.文本标记</h2>
<pre><code>1.特殊字符
  1.&amp;nbsp; 表示一个空格
  2.&amp;lt; 表示一个&lt;
  3.&amp;gt; 表示一个&gt;
  4.&amp;copy; 表示版权
  5.&amp;yen; ￥
2.文本样式
  1.&lt;b&gt;&lt;/b&gt; :加粗
  2.&lt;i&gt;&lt;/i&gt; :斜体
  3.&lt;u&gt;&lt;/u&gt; :下划线
  4.&lt;s&gt;&lt;/s&gt; :删除线
  5.&lt;sup&gt;&lt;/sup&gt; :上标
  6.&lt;sub&gt;&lt;/sub&gt; :下标

</code></pre>
<h2>10.什么是锚点</h2>
<pre><code> 锚点就是网页中一个记号，可以通过超级链接跳转到该记号位置处。
 1.定义锚点
    1.使用a标记的name属性定义锚点
      &lt;a name=""锚点名称""&gt;&lt;/a&gt;
    2.使用任意标记的id属性定义锚点
      &lt;ANY id=""锚点名称""&gt;&lt;/ANY&gt;
 2.链接到锚点
      &lt;a href=""#锚点名称""&gt;本页面&lt;/a&gt;
      &lt;a href=""url#锚点名称""&gt;其它页面&lt;/a&gt;
</code></pre>
<h2>11.div+css的布局有什么优点？</h2>
<p>（1）改版的时候更方便 只要改css文件。<br>（2）页面加载速度更快、结构化清晰、页面显示简洁。<br>表现与结构相分离。<br>（3）易于优化（seo）搜索引擎更友好，排名更容易靠前。</p>
<h2>12.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2>
<p>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。<br>（1）行内元素有：a b span img input select <br>（2）块级元素有：div p ul ol li dl dt dd  h1-h6<br>（3）常见的空元素：br-换行，hr-水平分割线；</p>
<h2>13.iframe有那些缺点？</h2>
<p>1.iframe会阻塞主页面的Onload事件，会影响页面的并行加载；<br>2.搜索引擎的检索程序无法解读这种页面，不利于SEO;<br>改进：通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
<h2>14.Label的作用是什么？是怎么用的？</h2>
<p>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<h2>15.隐藏元素的几种方法</h2>
<p>（1）display:none;<br>（2）visibility:hidden;<br>（3）opacity:0;<br>（4）position:absolute; left:-10000px;</p>
<h2>16.简述一下src与href的区别。</h2>
<p>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</p>
<h2>17.实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</h2>
<p>&lt;div style=""height:1px;overflow:hidden;background:red""&gt;&lt;/div&gt;</p>
<h2>18.如何给背景图片加上超链接</h2>
<pre><code>&lt;div class=""swiper-slide "" 
style='background:#dedede url() no-repeat center center;background-size:contain'&gt;
    &lt;a  class=""banner-a""rel=""nofollow"" href=""#""&gt;&lt;/a&gt;
&lt;/div&gt;

.banner-a{
      width:100%;
      height: 8rem;
      display: inline-block;
}    
</code></pre>
<h2>19.清除浮动的方法有哪些？</h2>
<p>第一种：clear:both</p>
<p>在父元素的里面添加一个空的clear的div（跟浮动的子级同级），然后再为这个类添加属性值clear:both;便可以清除浮动。</p>
<p>第二种：overflow：hidden</p>
<p>在父元素的样式中添加overflow: hidden;也可以清除浮动，如下css代码，但不提倡使用这个方法，overflow: hidden;还有一个意思就是隐藏超出的部分，处理不好还是会给页面带来麻烦。</p>
<p>第三种：clearfix(推荐使用)</p>
<p>1.在父集元素类名中添加 clear-fix<br>2.写伪类样式</p>
<pre><code>&lt;style&gt;  
.clear-fix::after {
   content:""""; 
   display: block; 
   clear:both; 
}
&lt;/style&gt;

&lt;div class=""header-line clear-fix""&gt;
            &lt;div class=""header-logo""&gt;
                &lt;a class=""logo""href="" https://www.meisaas.com/index.html""&gt;样式方案&lt;/a&gt;
            &lt;/div&gt;
&lt;/div&gt;
</code></pre>

                ", 前端面试题总结——HTML(持续更新中) ,1531977916,356,1,374,1,1,https://segmentfault.com/a/1190000013353474
55,1,0,9,"
                    
<h2>起因</h2>
<p>最近突然觉得无论是生活还是工作乱糟糟的，没有一个计划，想到哪里做到哪里。不知不觉时间已经过去了，但是原来的计划都没有实现。而后无意间看到了一篇新闻，关于<a href=""https://mp.weixin.qq.com/s/JMd0brQfNmHll991mOs1yQ"" rel=""nofollow noreferrer"">王健林的一天</a>，很受感触:</p>
<blockquote>想想我们本为平庸之辈还在浑浑噩噩的生活，他人已然成功却更加努力，这不禁让我想去了一句话：“比你优秀的人不可怕，可怕的是比你优秀的人比你更努力”。</blockquote>
<p>所以如果你和我一样，对目前自己的现状不满意，对自己的水平也不满意，不妨参考大佬们的作息时间制定一下自己的作息，不需要一样，我给自己规划的也不一定对。当然笔者不是说有了作息时间一定成功，和大佬们比肩，而是有了它能让你“充实”。</p>
<h2>大佬们的作息</h2>
<p>柳传志习惯早起，每天5点起床，运动一小时，然后早餐，上班处理工作。  <br>苹果公司创始人乔布斯6点起床，“在孩子们起床前做一些锻炼和工作，然后和孩子们吃早餐，看着他们上学。”  <br>巨人网络集团董事长史玉柱，每天凌晨三四点入睡，然后从午后开始工作。  <br>新东方董事长兼总裁俞敏洪的作息时间比较规律，每天早上六点钟起床，一天工作十几个小时，对于他来说几乎没有节假日，他曾经抱怨自己甚至没有时间看完一整本书。  <br>李嘉诚已经有88岁高龄，但却依然保持早起习惯：无论每天多晚睡，第二天早晨6点一定会准时起床。随后，听新闻，打一个半小时高尔夫。在8点前到办公室工作。  <br>美国通用电气公司董事长杰夫·伊梅尔特起床时间是5：30。  <br>星巴克咖啡公司创始人霍华德·舒尔茨每天早上4：30起床，吃早餐的同时还能高效率地看完三份报纸，他会保证自己在6点之前赶到办公室。  <br><a href=""http://www.sohu.com/a/219234926_762024"" rel=""nofollow noreferrer"">想看更多请点击</a></p>
<h2>规划自己的作息</h2>
<p>规划是规划，但是重在坚持，不坚持的话再多的规划都是空话。笔者第一次做规划，先按照下面的尝试一下，看看是不是能坚持21天养成习惯。空挡的时间是什么？当然是工作的时间。周末呢？当然是陪家人。 当然时间的规划也是循序渐进的，开始规划。</p>
<h3>2018-02-23</h3>
<h4>作息</h4>
<ul>
<li>6:00 起床</li>
<li>6:00 - 6:30 健身</li>
<li>6:30 - 7:00 洗漱+冥想(计划和变化)</li>
<li>7:00 - 8:00 学习技能</li>
<li>8:00 - 9:00 上班路上(看新闻)</li>
<li>9:00 - 10:00 回顾(工作内容和技术难点)</li>
<li>12:00 - 14:00 写文章</li>
<li>9:00 - 10:00 下班路上(看文学书)</li>
<li>10:00 - 陪家人+看技术书籍</li>
</ul>
<h4>作息说明</h4>
<ul>
<li>6:00起床，没有起这么早过，但是如果不早起你的时间哪里来？就像是特朗普在《每日新闻》里说:“一天睡12-14小时的人如何能与每天睡3-4个小时的人竞争?”。</li>
<li>6:00 - 6:30 健身，公司有健身房，但是早晨起来需要精神一下，用自己的器材抖擞一下精神。</li>
<li>6:30 - 7:00 洗漱+冥想，洗漱也可以思考，主要思考一下今天昨天做的事，今天该做的事情，是否有疏漏，同时可以考虑一下家庭中是否有什么需要计划的。虽然在上面大佬的作息中很少看到家庭的因素，但是齐家治国平天下嘛。</li>
<li>7:00 - 8:00 学习技能，做技术这个行业，不想吃年轻饭，不想有中年危机就必须坚持的学下去。相比大家看中年危机的文章也是太多了吧。当然如果你能按照 <a href=""https://amazon.cn/gp/product/B00368C0FG/ref=as_li_tl?ie=UTF8&amp;tag=majiang-23&amp;camp=536&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B00368C0FG&amp;linkId=8e76aef45d9df7e6f02fd7b3f4c3a42a"" rel=""nofollow noreferrer""><strong>GTD</strong></a> 去做那效果会更好。Omnifocus 软件是一个不错的选择。</li>
<li>8:00 - 9:00、9:00 - 10:00 <a href=""https://mp.weixin.qq.com/s/J9vWk4cvLRhrKQ5HxLH-zg"" rel=""nofollow noreferrer"">《如何有效的进行碎片化学习》</a>，<a href=""https://amazon.cn/gp/product/B005DSK4W8/ref=as_li_tl?ie=UTF8&amp;tag=majiang-23&amp;camp=536&amp;creative=3200&amp;linkCode=as2&amp;creativeASIN=B005DSK4W8&amp;linkId=ef1261dd4c6cf521898673e9f539ab9f"" rel=""nofollow noreferrer"">《暗时间》</a>，看过上面的文章和书籍的人就会明白，零碎的时间才是最多的时间。</li>
<li>12:00 - 14:00，有午睡习惯的码友就算了，本人是大部分中午时间都奉献给“王者荣耀”了，现在想想几千局的时间就明白了。一两个小时，整理一个文章发发博文，整理一下微信号的时间肯定是有的，其实主要是知识的积累。</li>
<li>10:00 点以后到家对于我们这个行业的人来说很正常，但是对于家庭来说已经迟到了。所以应该有更多的时间陪陪家人，剩下的时间看看技术方面的书籍。一天一个小时就够了，这个就要推荐 “网易蜗牛读书”，用一下你就知道他的好处了。</li>
</ul>
<h2>共勉</h2>
<p>最后希望我们都能按照计划如期进行，摆脱自己的舒适区，以此共勉。</p>
<h2>参考文献</h2>
<p><a href=""https://www.zhihu.com/question/48553439"" rel=""nofollow noreferrer"">https://www.zhihu.com/questio...</a>  <br><a href=""http://www.sohu.com/a/219234926_762024"" rel=""nofollow noreferrer"">http://www.sohu.com/a/2192349...</a></p>

                ", 程序员的成功首先需要从规划时间开始,1531977918,236,1,552,1,1,https://segmentfault.com/a/1190000013345673
56,1,0,9,"
                    
<p>2018年已经过去了12%，然而对于我来说也刚刚安稳下来。趁着年后大家还没来齐，我抽空偷偷的回望与展望。</p>
<h3>开心的事</h3>
<p>去年11月份开始面试跳槽，挑挑offer加上老东家的挽留，一直到12月底才离职。<br>跑到上海待了一月，然后很幸运的又跳了阿里。</p>
<p>有人觉得怎么可能跳的这么频繁，实际上其实是我在面试后期才投的阿里，加上双十一双十二的，本来面试周期就长的流程，就更加的冗长了，当时也没有100%的把握，就去了上海。</p>
<p>这里感觉挺对不住在上海的那家公司，其实同事也是很nice，也是明星企业，感觉浪费了人家的成本，不过我宽慰自己的理由就是，HR姐姐压价略多。。。</p>
<h3>新视野</h3>
<p>我本人有点乡下人进城的感觉，之前在创业公司，没在大公司呆过，目前新鲜感还是不错的，不过也有前所未有的压力。常常会在心底感慨，原来还有这种玩法。身边的牛人很多，需要保持着一个职场菜鸟的心态勤奋学习。</p>
<h3>感恩</h3>
<p>我学历本科，非985，211，16年毕业的时候很是迷茫。之前的老大很好，一直带我，把我从一个小白变成一个菜鸟。也点拨过我如何接物处事，如何对待工作，我唯一记得又一次周末下雨，我俩加班，我请他吃了一次麻辣香锅，他说好吃，要以后带他老婆来吃，以后有机会回去，我想一定要请老大再吃一次啊，哈哈哈。</p>
<p>还有感恩的老爸老妈，投简历，面试，离职，租房，搬家。这些事经历过的人应该知道，让人身心俱疲，有时候，视频过去，跟父母聊聊，遇到一个奇葩的面试官啊，看到一个不错的房子结果被别人租啦等等，就会放松很多，感谢他们的支持与相伴。</p>
<h3>情感</h3>
<p>之前恋爱长跑的姑娘离开了我，这点让我现在提起来也有些心酸，想想自己有许多不成熟的地方，正如老话说的：失去后才懂得珍惜。毕业后没了基友的开黑，来自工作的上的压力又不想告诉父母，能有一个人陪你聊天是很值得庆幸的事情。很多事情，现在想来不算什么，只是哪有什么后悔药呢。如果有另一半的就好好珍惜，如果暂时没找到的就好好努力变得优秀。</p>
<p>引用一段我喜欢的句子</p>
<blockquote>像所有的男孩一样，从单纯热烈、才华横溢，到年少轻狂、自命不凡，再到认清世界，认识自己，成为真实世界的一份子，将辛苦和艰难，激情和回忆都能妥妥的放在肚子里，成为一个真正的男人。</blockquote>
<p>祝好</p>
<h3>生活</h3>
<p>2018年想多看几场演唱会，之前我是觉得有些浪费钱，去了现场感受到了气氛，就有些上瘾，我不追某个明星，有便宜的票就喜欢凑凑热闹，感觉很热烈，每次都能感觉到压力的释放。</p>
<p>有机会想要多次周边游，我之前是很宅，觉得需要多多接触下，让自己开阔下视野。</p>
<h3>锻炼</h3>
<p>没有健身的爱好，但是日常的锻炼需要保持，程序员对着电脑，稍微不修边幅，不注意锻炼就会非常油腻。尤其是我这种皮肤敏感的，稍不注意就会蹦豆豆，晚上基本就是吃点素了。</p>
<p>睡眠，我经常熬夜，可是不是我故意熬夜，经常一看时间就凌晨一点了。这点我还没有改正，如果是啃书到凌晨心里还好受，但是大部分时间都不是这样。</p>
<h3>理财</h3>
<p>最初都是月光，也没有财可理。听闻身边同事聊着股票基金的，感觉自己什么都不懂。不玩币圈，泡沫高，风险大；不玩股票，因为真的不懂，也没时间研究。2018 准备定投点基金，天天存余额宝真的是跑不赢通胀。</p>
<p>渐渐认识到，通过coding实现财富自由很难很难，它只能让你生活还不错，但是一旦你不coding了，下个月立马就要恐慌了。财富自由靠股票啊。。。</p>
<p>记账，之前记过一阵，但是现在各种支付手段太多了微信、支付宝、京东、信用卡，每次统计，都要挨个翻一遍，今年计划主力使用一个支付app,记账也方便些。解决掉不知道钱花在哪里的问题。</p>
<h3>技术</h3>
<p>保持技术水平的提高是每个程序员的最基本素养。<br>java学习起来，有机会搞搞golang;<br>不罗列很细了，就是大方向这个吧。</p>
<h3>经历</h3>
<p>我更多想分享的还是最近的心态，和技术官面试，和HR谈薪资，跑市场找房子，打电话约搬家。这些事情，给你足够的时间，足够的资金。我想都不算太难。通常面试前需要突击下技术，刷刷题。谈薪资高了怕人家不理你，低了怕自己不能取得相应的报酬。便宜的房子不是太远就是太破，你看着装修还不错的不错的房子，是被人抢掉了，就是价格贵的吓人。物美价廉通常需要你花费时间去搜索筛选。你要坚持下去啊，然后回过头来看看，自己也不都是熬过去啦，你就变得更独立，更成熟些。</p>
<h3>希望2018  keep clam,carry on~</h3>
<p>以上</p>

                ", 2018年份的唠嗑,1531977919,261,1,394,1,1,https://segmentfault.com/a/1190000013343759
57,1,0,9,"
                    
<h1>分享一些实用的软件工具</h1>
<p>PS：也可以分享自己常用的软件给大家，<a href=""https://github.com/guoxiaoxu/Guo-Software-Tools"" rel=""nofollow noreferrer"">这里会同步更新</a></p>
<h3>kindle(必备)</h3>
<p>放几个azw3资源站点：有能力建议购买正版,不要看PDF格式的，可以是mobi。<br><a href=""http://mebook.cc/"" rel=""nofollow noreferrer"">我的小书屋</a><br><a href=""https://book.shuyuzhe.com/"" rel=""nofollow noreferrer"">书语者</a></p>
<p>1、<a href=""http://download.cnet.com/My-WiFi-Router/3000-18508_4-76086273.html"" rel=""nofollow noreferrer"">My WIFI Router</a><br>无线热点、无广告、设置自启。赶快卸载国产类吧，尝试下这个。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013288025?w=965&amp;h=622"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>2、<a href=""http://download.cnet.com/Nitro-PDF-Reader-64-bit/3000-10743_4-75206289.html"" rel=""nofollow noreferrer"">Nitro PDF Reader</a></p>
<p>3、<a href=""http://www.eagleget.com/download/"" rel=""nofollow noreferrer"">EagleGet</a>终于可以卸载迅雷精简版了。<br>配合<a href=""https://tampermonkey.net/"" rel=""nofollow noreferrer"">Tampermonkey</a> 和<a href=""https://greasyfork.org/zh-CN/scripts/13638-%E7%99%BE%E5%BA%A6%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD"" rel=""nofollow noreferrer"">百度盘直接下载</a> 这个网站有很多脚本可用。</p>
<p>4、<a href=""http://download.cnet.com/qBittorrent/3000-2196_4-75587054.html"" rel=""nofollow noreferrer"">qBittorrent</a>下载种子必备，可以达到10M/s</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013294785?w=1200&amp;h=900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>5、<a href=""https://chrome.google.com/webstore/detail/githunt/khpcnaokfebphakjgdgpinmglconplhp?utm_source=chrome-ntp-icon"" rel=""nofollow noreferrer"">Githunt</a></p>
<p>好想分享自己的书签给大家，无奈没整理全。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013295553?w=1508&amp;h=1724"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>5、<a href=""http://download.cnet.com/windows/"" rel=""nofollow noreferrer"">网站在这里</a>，大家去找自己顺手的。</p>
<h2>1、ALTRun(国产启动神器)</h2>
<p>ALTRun是由网友 ET民工个人独立开发的一款快速启动软件，小巧绿色，简单易用。精致简洁的操作界面、精巧灵动的智能匹配、疾如雷电的响应速度和行云流水般畅快淋漓的操控体验的完美结合，足以令人爱不释手。<br></p>
<h2>2、LD(<a href=""https://github.com/getlantern/forum"" rel=""nofollow noreferrer"">科学++网</a>)</h2>
<p>速度绝对刚刚的，YouTube1080P妥妥的，2K微卡。支持Android、IOS、Ubuntu、macOS。其他Linux系统可以使用Chome浏览器插件：SpeedplusV+N。Centos安装请参考这篇文件：<a href=""https://github.com/guoxiaoxu/install-lantern"" rel=""nofollow noreferrer"">https://github.com/guoxiaoxu/...</a></p>
<h2>3、<a href=""https://networx.en.softonic.com/"" rel=""nofollow noreferrer"">networx</a>(流量监控)</h2>
<p>屏蔽某雷自动上传文件，屏蔽某些自动联网的软件。PS：最好卸载各种国产杀毒软件，使用Avast，强大到可以杀掉浏览器脚本。卸载方式：先删除安装目录，在启动avastclear.exe。最好在安全模式下进行。</p>
<h2>4、<a href=""https://gifcam.en.softonic.com/"" rel=""nofollow noreferrer"">GifCam</a>
</h2>
<p>看名字就知道，不做介绍。谁用谁知道。</p>
<h2>5、<a href=""https://zh.snipaste.com/"" rel=""nofollow noreferrer"">Snipaste</a>
</h2>
<p>好用的截图软件，F1截图，F3取消。</p>
<h2>6、<a href=""https://www.resilio.com/individuals/"" rel=""nofollow noreferrer"">Resilio-Sync</a>
</h2>
<p>其可在局域网、互联网上通过安全的、分布式的P2P技术在不同设备之间同步文件。支持各终端，据说在国内和谐了？因为一个人。</p>
<h2>7、<a href=""https://github.com/oldj/SwitchHosts"" rel=""nofollow noreferrer"">SwitchHosts</a>
</h2>
<p>快捷切换hosts的小工具，非常好用。</p>
<h2>8、<a href=""https://www.vandyke.com/products/securecrt/"" rel=""nofollow noreferrer"">SecureCRT</a>
</h2>
<p>SecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。非常方便，按下ALT+P可以实现拖拽上传文件。</p>
<h2>9、<a href=""https://github.com/rest-client/rest-client"" rel=""nofollow noreferrer"">restclient</a>
</h2>
<p>用Ruby封装的访问HTTP和REST client的gem，其中HTTP访问动词(get, put, post, delete) ... 使用RestClient可以完成多部件的发送。</p>
<h2>10、<a href=""https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer"" rel=""nofollow noreferrer"">ProcessExplorer</a>
</h2>
<p>由Sysinternals开发的Windows系统和应用程序监视工具，目前已并入微软旗下。不仅结合了Filemon（文件监视器）和Regmon（注册表监视器）两个工具的功能，还增加了多项重要的增强功能。</p>
<h2>11、<a href=""https://atom.io/"" rel=""nofollow noreferrer"">atom</a>
</h2>
<p>强大到没朋友，各种插件，并且开源。因为Atom比较吃内存，介意卸载没必要的插件。响应速度才能提上来，电脑软件装多了也会卡，各司其职。推介插件：Git Plus、atom-ide-ui、markdown-preview-plus、simplified-chinese-menu、atomic-chrome。</p>
<h2>13、<a href=""https://www.sublimetext.com/3"" rel=""nofollow noreferrer"">sublime text 3</a>
</h2>
<p>世界上最好的编辑器器之一，堪称神器。和上面结合起来，堪称完美。</p>
<h2>14、<a href=""http://www.oldapps.com/zh-cn/everything_search.php?old_everything_search=14940"" rel=""nofollow noreferrer"">Search Everything</a>
</h2>
<p>注意：不要使用新版本，旧版本只要你输入，就会有结果。比win自带的强大一万倍。还有一点不要强迫症的乱更新软件，新版本未必都是好的。顺手就好。</p>
<h2>15、网易云音乐</h2>
<p>这个取决于个人喜好，没装的，尝试用几天。我相信你觉得会卸载其他的。说起卸载，我希望大家卸载一些国产的垃圾软件、用国外的代替。你会发现广告少多了，速度起来了。同样的软件，在play商店下载，功能比国内多而且没广告 。</p>
<h2>16、迅雷极速版</h2>
<p>速度没有限制，更具版本而定，连接不给力。结合Tampermonkey插件，爽歪歪、、、</p>
<h1>Chrome插件篇(太多好用的了)</h1>
<h2>31、Earth View from Google Earth(强烈推介)</h2>
<p>效果如下： <br><br><span class=""img-wrap""><img data-src=""/img/remote/1460000013259491?w=1920&amp;h=1023"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>32、Click&amp;Clean</h2>
<p>当浏览器关闭时，这款应用程序删除你的浏览历史,防止他人跟踪你的网上活动。</p>
<h2>33、Tampermonkey(<a href=""https://greasyfork.org/zh-CN"" rel=""nofollow noreferrer"">脚本地址</a>)</h2>
<p>我想大家都用过，最常用的还是网盘助手，一键清除新浪微博。建议：希望大家不要把生命中重要的时间浪费在刷微博，微信。多去关注下Twitter的世界，太多大神。顺便可以跟着川普学英语，看别人怼他。</p>
<h2>34、Insight.io for Github</h2>
<p>每个程序员必备，</p>
<h2>35、划词翻译</h2>
<p>真的非常方便</p>
<h2>36、LastPass</h2>
<p>非常好用。哈哈</p>
<h2>37、<a href=""https://chrome.google.com/webstore/search/jsonviewer?utm_source=chrome-ntp-icon"" rel=""nofollow noreferrer"">JsonViewer</a>
</h2>
<p>JSONView是一款非常棒的查看JSON格式数据的Chrome扩展。</p>
<h2>38、Grammarly for Chrome</h2>
<p>英语写作的这个插件很有用，自动判断语法，点击修改。</p>
<h2>39、Adblock for Youtube™ 、AdShield</h2>
<p>上面两个都不错，结合起来效果完美。</p>
<h2>40、ColorZilla</h2>
<p>前端的朋友必备，设计师、后端的也需要。找到具体颜色数值并且测量它们的不同。</p>
<h2>41、Death Clock</h2>
<p>死亡倒计时，强迫自己珍惜每一分，每一秒。</p>
<h2>42、新的隐身窗口</h2>
<p>隐私很重要，我们的搜索记录会被记录下来。可以使用隐身窗口。</p>
<h2>43、IntelliJ IDEA</h2>
<p>很智能，适应了之后感觉非常不错。</p>
<h2>43、ImTranslator: 翻译，字典，声音</h2>
<p>非常不错，尤其读API的时候，</p>
<h2>44、cVim</h2>
<p>我把浏览器，两个编辑器都换成了命令行模式，减少用鼠标的次数。浏览网页非常流畅。建议使用！</p>
<h2>45、Malwarebytes</h2>
<p>清除系统的间谍软件，用了之后夏一跳，赶紧卸载了迅雷极速版，只用精简版。</p>
<h2>46、Fences</h2>
<p>自定义桌面，之前设置的像一个台阶，现在分格放，只有鼠标路过才显示。效果如下：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013259492?w=719&amp;h=276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>47、MPC-BE x64</h2>
<p>一个好用的播放器，因为自己换来LG入门级4K，播放效果非常好。</p>
<h1>PS：可以给笔记本外接一个显示器，效率提高了不少。</h1>
<h1>PS:先分享到这里，后续慢慢补充。</h1>

                ", 分享一些实用的软件工具,1531977921,452,1,669,1,1,https://segmentfault.com/a/1190000013259486
58,1,0,9,"
                    
<blockquote>搞技术的，如果想更高提升自身技能水平，英语这关是逃不了的。 <br>——某位不愿透露姓名的四级loser</blockquote>
<p>技术人员经常会在各种技术交流社区游逛，大家互相学习、交流、分享、帮助。互联网拉近了地球人的距离，让全世界的技术人员可以聚集在一起分享交流。当然因为多方面原因，通常最新最权威的技术知识传到国内存在一定“时差”。本文将给大家分享技术人员经常访问的国外技术交流社区网站。</p>
<p>1.stackoverflow<br><a href=""https://stackoverflow.com/"" rel=""nofollow noreferrer"">https://stackoverflow.com/</a></p>
<p>众所周知，stackoverflow可以说是全球最为活跃的程序员技术问答交流社区。</p>
<p>2.Google+<br><a href=""https://plus.google.com/"" rel=""nofollow noreferrer"">https://plus.google.com/</a></p>
<p>Google+是Google公司推出的社交网站，虽不是专为编程技术人员打造，但在这里你可以搜索并加入到很多技术社群，结交群内好友。</p>
<p>3.DZone<br><a href=""https://dzone.com/"" rel=""nofollow noreferrer"">https://dzone.com/</a></p>
<p>DZone.com是世界上最大的在线社区之一，全世界的开发技术人员通过共享知识来了解最新的技术趋势，了解新技术，方法和最佳实践。</p>
<p>4.Bytes<br><a href=""https://bytes.com/"" rel=""nofollow noreferrer"">https://bytes.com/</a></p>
<p>Bytes是面向开发人员和IT专业人员的交流社区。涵盖了软件开发，Web开发，数据库开发+优化，数据库管理，系统管理，网络管理等领域。在Bytes里你可以提问、回答问题，并分享技术文章。</p>
<p>5.github<br><a href=""https://github.com/"" rel=""nofollow noreferrer"">https://github.com/</a></p>
<p>可以审查代码、管理项目，与数百万用户一起交流、开发软件。</p>
<p>6.Hacker News<br><a href=""https://news.ycombinator.com/news"" rel=""nofollow noreferrer"">https://news.ycombinator.com/...</a></p>
<p>HackerNews也是深受广大技术人员欢迎的技术分享交流网站。虽然HackerNews被很多人吐槽网站界面很low，但毕竟访客的需求就是如此的明确，简单。所以有的时候浏览网站内容，能提供一个RSS订阅地址足矣。</p>
<p>7.hongkiat<br><a href=""https://www.hongkiat.com/blog/"" rel=""nofollow noreferrer"">https://www.hongkiat.com/blog/</a></p>
<p>hongkiat是与技术、设计领域相关的站点之一，大家可以在这里分享技术文章。</p>
<p>8.reddit<br><a href=""https://www.reddit.com/r/programming/"" rel=""nofollow noreferrer"">https://www.reddit.com/r/prog...</a></p>
<p>reddit是一个大型的社交新闻媒体网站，涵盖放模块非常多，所以我这里分享的地址是编程技术模块。用户可以相互分享，交流、学习。</p>
<p>9.InfoQ<br><a href=""https://www.infoq.com/"" rel=""nofollow noreferrer"">https://www.infoq.com/</a></p>
<p>InfoQ是一家全球性在线新闻/社区网站，坚持促进软件开发领域知识与创新的传播宗旨。当然InfoQ也有中文站。</p>
<p>10.daniweb<br><a href=""https://www.daniweb.com/"" rel=""nofollow noreferrer"">https://www.daniweb.com/</a></p>
<p>daniweb为广大开发技术人员提供了一个专业的学习、分享知识的社区平台。包括软件、硬件、程序设计、UI/UX设计等领域。</p>
<p>11.sitepoint<br><a href=""https://www.sitepoint.com"" rel=""nofollow noreferrer"">https://www.sitepoint.com</a></p>
<p>SitePoint是一个面向WEB开发领域的交流社区。</p>
<p>12.tutorialspoint<br><a href=""https://www.tutorialspoint.com/"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/</a></p>
<p>tutorialspoint为广大还学习的朋友提供了众多在线免费教程内容。用户也可以自己编写分享新的知识库。</p>
<p>13.google developers<br><a href=""https://developers.google.com/"" rel=""nofollow noreferrer"">https://developers.google.com/</a></p>
<p>google提供的开发技术、产品和项目资源交流社区，无论您的产品是针对国内还是面向国际市场， 您都可以在这里找到最相关的 Google 产品和技术资源。</p>
<p>14.DEV<br><a href=""https://dev.to/"" rel=""nofollow noreferrer"">https://dev.to/</a></p>
<p>这是2016年创建的一个年轻平台，帮助广大技术开发人员相互分享、交流。</p>
<p>15.codeproject<br><a href=""https://www.codeproject.com/"" rel=""nofollow noreferrer"">https://www.codeproject.com/</a></p>
<p>CodeProject为开发人员提供相关技术资源，并帮助大家了解、掌握最新的技术。</p>
<p>16.zentaoPM<br><a href=""http://zentao.pm/"" rel=""nofollow noreferrer"">http://zentao.pm/</a></p>
<p>禅道项目管理软件是研发团队必备的项目管理利器。并逐步受到广大国外用户的关注。</p>
<p>本文和大家一起分享了众多国外技术交流门户社区，大家如果还有更多好高的站点，欢迎推荐分享。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV2TYg?w=300&amp;h=231"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""f_1a3cddd343d530450eb4acae849c9a65&amp;t=png&amp;o=&amp;s=&amp;v=1513735304"" title=""f_1a3cddd343d530450eb4acae849c9a65&amp;t=png&amp;o=&amp;s=&amp;v=1513735304""></span></p>
<p>如果上面的某些网站由于某些原因无法打开的，就不要出去说你是搞技术的了～</p>
<p>作者：GavinHsueh，QQ/微信：753391279，专注网站建站、运维及企业web应用开发技术。<br>更多技术文章、互动交流，欢迎关注公众号：<br><span class=""img-wrap""><img data-src=""/img/bVYTY0?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 【干货】程序员常访问的国外技术交流网站汇总,1531977922,555,1,568,1,1,https://segmentfault.com/a/1190000013045843
59,1,0,9,"
                    
<p>目前绝大部分面试都不会安排机试，即使出题考查也基本上都是笔试。就我个人经验，其实如果要用笔试的话，还不如直接用机试，花费的时间差不多，但得到的信息量更大。</p>
<h2>机试不能代替谈话</h2>
<p>机试之前还是要聊下天，大致了解下求职者的知识面和性格之类的。</p>
<h2>什么样的求职者适合机试</h2>
<p>如果面试者的意向岗位是一线开发人员，基本上就可以适用机试。当然也有例外，比如熟人内推，内推的简历我相信不会有假，从项目经验和推荐人的描述，基本上可以确定求职者入职后能担当什么样的角色。</p>
<h2>要准备充分</h2>
<p>首先要向求职者充分说明机试的理由，如果求职者拒绝，那就没办法了。</p>
<p>其次要预先准备好机试环境，比如我会拿自己的电脑给对方用，我就把 IDEA/Eclipse/MyEclipse/NetBeans 全都装好，数据库也准备好，还有机械键盘、大尺寸显示器、网络环境这些都准备好。如果求职者有带自己用惯了的的笔记本来，那就更好了。</p>
<p>网络环境是开放的，机试过程中要上网搜索什么的都可以。</p>
<p>机试准备的一个原则就是要让求职者水平有最好的发挥，不要设置任何障碍，公司的工作环境是什么样子就是什么样子。</p>
<h2>机试内容要简单</h2>
<p>机试题根据求职者的意向，以相应岗位的最低要求来决定。比如说初级程序员，我的机试内容可能就是写一个用户注册和登录的 Web 项目，数据库和表都已经准备好了。面试者只要挑选自己熟悉的 IDE，然后搭建工程实现代码，对界面我没有任何要求，简单的 HTML 就行。一般顺利的话半个小时应该足够了，就算不顺利，一个小时也应该搞得定。</p>
<p>即使极端情况下最后没搞定也没关系，因为机试不是要看结果，而是看过程。</p>
<h2>简单的机试能看出什么来</h2>
<p>这也是很多人不愿用机试的原因，觉得考察的内容是不是太少了，还不如多出几个题目。我不这么觉得，我认为这半个小时是可以看出很多东西的。</p>
<p>首先是打字的速度，可以看出求职者平时练习多不多。我见过最烂的情况是就用两根食指打字。</p>
<p>其次是搭建项目是否熟练，这体现了对 IDE 是否熟悉。</p>
<p>然后是编码规范是否到位，比如命名是否准确，是否有格式化代码的习惯，长语句如何换行，重构用的多不多，是否有意识的去掉重复代码。</p>
<p>还有其他的一些信息，比如是否有用单元测试，是否有写注释的习惯等等，都可以在机试过程中看出来。</p>
<h2>这个行业在变</h2>
<p>到这里你可能了解我绝对的实用主义态度。理论水平我是不信的，潜力什么的我也是不信的，你现在是什么样子就好。因为 IT 行业在如今的经济形势下越来越受欢迎，也导致培训机构越来越多，从培训机构出来的求职者比例越来越大，当中也确实有不少不爱学习的，靠假学历和假项目经验希望能骗到一份工作。所以企业面对这个形势，面试的手段也不能一成不变，也要想办法去伪求真，这是对自己的产品和公司员工负责，也是对那些真正学好了的求职者负责，避免他们受到不公正的待遇。</p>

                ", 谈谈软件公司如何安排机试,1531977923,572,1,996,1,1,https://segmentfault.com/a/1190000012832918
60,1,0,9,"
                    
<p>标题是17年总结，其实更贴切的说法应该毕业从事技术6年总结。</p>
<h3>感谢</h3>
<p>从学校毕业到现在一路上遇到了很多帮助过我人，有的是启蒙老师、有的是言传身教、有的是瞬间的提点、有的是职业发展中的提携、还有一些素未谋面的人，不管帮助大小、时间地点我都想很真诚的对你们道声感谢。同时在我从事技术这个行业里也时刻提醒自己“站在巨人的肩膀上，心怀感恩”。技术就像浩瀚的星空，远处看一片璀璨，但是当你进入的时候每一个又是那么的深不可测，无边的星空，你知道的越多不知道的就更多，唯有怀揣一颗敬畏的心不停的前进。</p>
<h3>大神</h3>
<p>随着工作年数的增长，这个称号在我身上偶尔也会出现，其实一开始我很抵触这个，因为自认为并没有达到这个级别，然后17年我再被挂上这个标签的时候倒是觉得无所谓了，并不是自己觉得技术怎么怎么了，而是在我看来，别人喊你“大神”就和别人喊你“帅哥”一样，它只是一个轻松的称号。</p>
<h3>带人</h3>
<p>从被人带慢慢的自己开始带人，带的人有男有女、有技术好的技术差的还有技术小白；在带人的过程中自己有时候没控制住脾气说话的声音会大很多，这个我希望自己未来能好好改掉，保持一颗平常心。当然我在待人到时候对待技术从来都是严谨负责的态度，严谨：说出来的东西绝对是自己实践过的；负责：希望自己带的人离开的时候能上几个台阶。不过我对自己带的人只有一个要求，认真努力积极。</p>
<h3>技术成长</h3>
<p>从一开始的疑惑慢慢的学的越来越快再到最近2年的技术沉淀，不管处于哪个阶段我时刻提醒自己，基础是最重要的东西，所以时不时的会看有些基础性的文章和书籍，希望把任何前沿的技术都在这些基础中找到对应的影子</p>
<h3>工作狂</h3>
<p>不管我的家人、朋友很多时候都认为我是个工作狂，因为我一闲下来的时候第一想到的就是拿起电脑撸几行代码，其实这个并不是工作狂的表现，因为我一直把撸代码当成了自己的一个爱好。就像你爱打游戏，他爱大牌，他爱唱歌，女生爱逛街一样。都是有一种“累并快乐”的自虐感</p>
<h3>未来</h3>
<p>都是技术是个青春饭，年纪越大后面的社会竞争越大。所以很多做技术的都是想着怎么去转管理、去创业；去年的我也是这个想法，17年这一年经历的很多，渐渐的想通了这个问题，编程是一个爱好刚好这个爱好能够赚到钱让我养家糊口，如果真的那天没人要了，就去干别的吧，但是编程这个爱好还是不可能放弃的只是时间可能会有些调整罢了。如果有幸往管理、创业去发展，也是一个不错的选择。总之，让这一切顺其自然吧</p>
<h3>给自己的话</h3>
<p>心怀感恩，编程不仅仅给我快乐更让我有了一个美好的家庭；<br>严于律己宽以待人，原谅自己犯的错误往往比原谅别人的错误来的更加容易，是因为你无法知道别人犯错误的过程；<br>分享，一切来于技术，分享自己对技术的一切</p>

                ", 2017年总结,1531977925,495,1,979,1,1,https://segmentfault.com/a/1190000012650463
61,1,0,9,"
                    
<p>国外有个词叫做10x Programmer，直译是以一当十的程序员。我并不认为一个技术大牛能完成10个普通程序员的工作，技术大牛会花1/10的时间把工作做完，然后用剩下9/10的时间平衡生活、爱好和未来，所以我仅把10x Programmer叫做10倍速的程序员。  </p>
<p>也许有人会觉得这种定义太过狭隘，没错，确实狭隘。不同的程序员处在不同的技术水平阶段，有着不同的人生追求和生活诉求，我谨以此文让大家换个角度去审视这个职业，也许你会有些感触和启发。</p>
<h2>Keep You Sane</h2>
<p>这是我很喜欢的这句英文，保持清醒。我希望所有人都能做到工作和生活的平衡，有更多的精力去做自己爱做的事，陪自己爱的人。这是本文的最终目的。</p>
<h2>善用工具</h2>
<p>业界有句话叫做“不要重复造轮子”，人类就像一台内存有限、CPU有限、硬盘有限的服务器，既然可以选择调用API，就不要试图在本地跑各种服务，那样只会让自己变得臃肿、耦合、满负荷。  </p>
<p>像Beyond Compare(代码比较合并), Notepad ++（关闭时无需保存）, Chrome（现代浏览器）, VPN（google必备）, FastStone Capture（截屏、测量、录屏、取色等）、Chrome 翻译插件（快速翻译网页英文）、反编译工具（不同语言开发者各异）、CookieInjector（cookie注入工具）等。这些工具可以说是程序员必备的，没有下载的可以下载，最后一个在github里搜。</p>
<h2>不要记忆</h2>
<p>不要记忆。这个观点同样狭隘。但我认为把JDK源码看一遍这种事大可不必去做。如果你把JDK装载脑子里占用了太多""硬盘""不说，还浪费了过多精力。我建议的做法是索引。还记的索引的定义吗？它就像是一本书的目录。我通常会记一遍JDK的API列表，知道哪个Function对应在哪个库里。当需要的时候去取就可以。我相信做过数据库的都应该知道索引的意义和用处。  </p>
<p>举例来说，你记住concurrent包是用来处理多线程的，你记住反向代理有nginx、Apache，你记住python适合计算、Java库比较多、C++适合原生、Zepto适合移动终端、XML比Json占用更多字节、SVG比PNG更适合比例放大、无论Mysql/Oracle/SQLite/Cubrid都是ANSI SQL类似这样就足够了，用什么才去取什么，无需都记在脑子里。只需记住，在哪里能找到答案就可以了。</p>
<h2>善于记录</h2>
<p>即使你的思维再清晰，也需要记录。正如“好记性不如烂笔头”这句俗语所说。把需要做的工作，手头做了一半的工作记录下来，然后可以迅速的切换自己的思维到生活状态。当然，翻开自己的TODOs也可以迅速切换回工作状态。现在手机电脑都可以下载各种各样的记事本，像Evernote、有道云笔记这种有checkbox、列表的，完成一项勾一项。  </p>
<p>博客。这种最原始内容载体，开放于互联网，不限于某个产品的生态圈。在你记录博客的同时，你重新审视了自己的技术，并且为了复述清楚，你会更加谨慎的思考技术逻辑。同时，假如你陷入了某些思维误区，会有热心的朋友帮你指出，共同进步。</p>
<h2>设置闹钟</h2>
<p>程序员都是专注的。即使你生性不是如此，也会在长期的职业生涯中渐渐变得专注、谨慎、注意细节、逻辑清晰。但是正因为这份专注你可能陷入思维的死循环中。当你低头专注于某项技术的时候，外界的技术每天都在快速的迭代、增长、创新。正式这份专注可能会让你错过很多东西，就好像一个bug嵌套另外一个bug，你整天都在解决bug，然后就陷入了递归、for、do...while里面去了。你需要设置一个触发器（trigger？break？whatever），让自己跳出自己的思维，重新认识这个世界。这里我说的不仅仅是技术，而是一种思维，跳出程序员的思维，也许……你会有女朋友的。  </p>
<p>闹钟的作用就是叫醒你。当你无法解决一个问题是，放下，换个角度，也许用10分钟就可以了，而不是你钻研一个晚上。</p>
<h2>广交朋友</h2>
<p>技术是不分城市、国界的。有时候与其闭门造车，不如结交一些像尤雨溪、stormzhang、justjavac、Sean Larkin、caiyongji这样的人。他们的观点和技术分享是引领国内技术潮流的（虽然最后一个比较渣），和他们探讨技术也是别有一番乐趣。我有幸有上面其中几位的微信，比如caiyongji的微信是takeurhand。  </p>
<p>当你遇到技术难点需要攻克的时候，可能牛人们已经遇到了，与其上网搜索，不如直接和牛人们探讨。</p>
<h2>善用口诀</h2>
<p>口诀是需要记忆的东西。比如快捷键、JVM优化方法、SQL的执行顺序、数据库分库分表技巧、锁的原理、内存结构。这些是IT界的元素周期表。</p>
<h2>放弃完美</h2>
<p>String和StringBuffer的区别并不是很大，如果不是在大量重复的循环语句中，不要在乎那点内存浪费。不完美的成果会在快速迭代中解决。也许你过度优化的时间成本足够为服务器加一条内存了。  </p>
<p>Relax! 准备好迎接你的2018吧。</p>

                ", 如何成为10倍速的程序员,1531977926,423,1,833,1,1,https://segmentfault.com/a/1190000012497267
62,1,0,9,"
                    <p>我们分析了大量知乎精华回答，将里面被提到的书籍提取出来，按照被提到次数做成了一个书籍推荐网站。<br>被提到即是价值。<br>网站内容对程序员较为友好。<br>地址：<a href=""http://books.bigfacewo.com"" rel=""nofollow noreferrer"">http://books.bigfacewo.com</a></p>
                ", 知乎上书籍被提到次数排行,1531977928,525,1,211,1,1,https://segmentfault.com/a/1190000011461105
63,1,0,9,"
                    
<p>从前有一个沉迷编程的程序员，他的太太让他买一斤包子，并说：“你如果看见有卖西瓜的，就买一个。记得套两个袋子！”</p>
<p>晚上，这位程序员老兄拎着一个大袋子回了家。太太高兴地打开，里面是一个小袋子，再打开这个小袋子，里面一个包子……</p>
<p>太太问：“我怎么跟你说的？！”</p>
<p>程序员老兄不紧不慢，写下了这样一段代码：</p>
<pre><code>#include &lt;buyBaozi.h&gt;
int bigBag()
{
    int smallBag()
    {
        if(anyoneSellsWatermelon == 1)
        {
            buy (baozi,1,ge);
        }
        else{
            buy(baozi,1,jin);
        }
    }
    return 0;
}</code></pre>
<p>“我看见卖西瓜的了，所以照你说的买了一个包子呀！”</p>

                ", 一个“古老”的故事——程序员买包子,1531977930,570,1,353,1,1,https://segmentfault.com/a/1190000011331788
64,1,0,9,"
                    
<p>续前文 <a href=""http://mageek.cn/archives/33/"" rel=""nofollow noreferrer"">后端好书阅读与推荐 - Mageek`s Wonderland</a> ，几十天过去了，又看了两本好书（还有以前看过的书），这里依然把它们总结归纳一下，加入一些自己的看法、有用的链接和可能的延伸阅读，并推荐给需要的同学。</p>
<h2>深入理解Java虚拟机</h2>
<p>深入理解Java虚拟机 (豆瓣)  <a href=""https://book.douban.com/subject/6522893/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>Java怎么用，是一个问题；怎么用好是一个大问题；这么用是为什么，是一个更大的问题。搞懂这三个问题应该是每一个搞Java的人都要追求的目标，读完本书，就能把这个更大的问题搞懂了。</p>
<p>本书亮点：</p>
<ul>
<li><p>模块化是解决应用系统与技术平台越来越复杂，越来越庞大的问题的一个重要途径，也是建立各种功能的标准件的前提。</p></li>
<li><p><a href=""https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html"" rel=""nofollow noreferrer"">Java运行时数据</a>区几个主要部分：<strong>程序计数器</strong>（可看作当前线程所执行的字节码的行号指示器）、<strong>虚拟机栈</strong>（每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，而栈帧存储局部变量表、 操作数栈、 动态链接、 方法出口等信息）、<strong>本地方法栈</strong>（Native方法对应的栈）、<strong>堆</strong>（所有线程共享的一块内存区域，存放对象实例）、方法区（各个线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）、<strong>常量池</strong>（方法区的一部分，存放编译期生成的各种字面量和符号引用）。</p></li>
<li><p>对象访问方式取决于虚拟机实现而定的，目前主流的访问方式有使用句柄和直接指针两种：如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；如果使用直接指针访问，reference中存储的直接就是对象地址。</p></li>
<li><p>Java垃圾回收采用分代回收机制，新生代和老生代采用不同的算法（node.js也是），而不管什么机制，<strong>判断一个对象是否存活</strong>都是基本的步骤，方法有：<strong>引用计数法</strong>，给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的，这个方法实现简单，但是不能解决循环引用问题，所以主流JVM不使用，但是这个算法也适用于许多地方如Python，微软的COM；<strong>可达性分析</strong>，按照对象之间的引用关系维护一个引用链，如果一个对象不可达GC Roots，那么就是可回收的，应用于主流JVM中。</p></li>
<li><p>finalize是一种迎合C++程序员的妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以建议大家完全可以忘掉Java语言中有这个方法的存在。</p></li>
<li><p>几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用“含糖”的语法，容易让程序员产生依赖，无法看清语法糖的糖衣背后代码的真实面目。所以我们既要会使用语法糖，同时也要搞懂背后的原理，这样才能进阶呀。比如泛型技术：泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型。</p></li>
<li><p>Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定“热点代码”（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称JIT编译器）</p></li>
<li><p>基于<strong>高速缓存</strong>(Cache)的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行</strong>(Out-Of-Order Execution)优化，类似的JVM也有<strong>指令重排</strong>(Instruction Reorder)。这两点是提高程序运行的主要方法，然而也是多线程程序难以正确编写的主要原因。</p></li>
<li><p>先行发生（happens-before）是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p></li>
</ul>
<p>这本书是基于jdk1.7的，如果要追踪最新的Java和JVM规范，可以看<a href=""https://docs.oracle.com/javase/specs/index.html"" rel=""nofollow noreferrer"">这里</a>。<br>另外，上面提到的第一个问题可以参阅<a href=""https://book.douban.com/subject/25762168/"" rel=""nofollow noreferrer"">Java核心技术</a>，第二个问题可以参阅<a href=""https://book.douban.com/subject/2130190/"" rel=""nofollow noreferrer"">Java编程思想</a>、<a href=""https://book.douban.com/subject/3360807/"" rel=""nofollow noreferrer"">Effective Java</a>，第三个问题还可以参阅<a href=""https://book.douban.com/subject/25847620/"" rel=""nofollow noreferrer"">HotSpot实战</a>。这几本书我都浏览过，部分有细读，都是相当经典的。</p>
<h2>高性能MySQL</h2>
<p>高性能MySQL (豆瓣)  <a href=""https://book.douban.com/subject/23008813/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>这本书可谓是MySQL领域的权威之作，从架构到测试，从性能分析到查询优化，从软件配置优化到服务器硬件优化，从单实例到主从复制、负载均衡，从底层数据库优化到应用层优化......本书真可谓是面面俱到，同时又很有深度，绝非浅尝辄止。</p>
<p>本书亮点：</p>
<ul>
<li><p>所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡自然也影响到性能。这句话适用于世间的一切工具，<strong>安全性和可用性总是矛盾的</strong>，我们在使用工具或者开发工具的时候，都要寻求一个<strong>最佳平衡点</strong>。</p></li>
<li><p>除非需要使用InnoDB不具备的的特性，并且没有其他办法可以替代，则都应该优先使用InnoDB引擎，也不要多引擎混用，例如全文索引可以使用InnoDB+Sphinx，而不要使用MyISAM引擎，因为InnoDB其他方面的优点可以完全碾压MyISAM，比如崩溃恢复快，支持事务，支持行级锁，支持真正的热备份等等。</p></li>
<li><p>基准测试可以验证对于系统的假设，检查异常行为，找出扩展性瓶颈等等。需要注意的是不要使用真实数据的子集，作物的数据分布，忽略预热等等，这些错误的操作会使得测试结果无用或者不精确。而且要建立参数与结果文档化的规范，这样才利于结果分析与优化。</p></li>
<li><p>很多人在优化时都将精力放在修改某些东西上，却很少去测量；正确的做法是要尽量测量响应花的时间在哪，正确的测量一般都能将性能问题的点暴露出来，我们就能更好的对症下药，而不是盲目优化（花1000块优化一个只值500块的业务，或者已经处于顶点的业务不就是亏了吗）。所以说，决策要基于数据而不是感觉。</p></li>
<li><p>良好的逻辑设计和物理设计是高性能的基石，某些反范式的设计可能加快某些查询，比如计数表和汇总表是一种很好的查询优化方式，能提高统计类的查询速度，但是维护起来就比较麻烦，可能降低数据插入速度。这些都需要自己根据业务来进行权衡（比如读写比），有阴就有阳嘛。</p></li>
<li><p>选择能正确存储数据的最小类型：既省空间又省计算时间，简单就好：比如使用MySQL内建时间戳而不是自己使用字符串，尽量避免null：因为null使得索引、统计、值比较都更加复杂还可能会占用更多空间。</p></li>
<li><p>InnoDB有一个“自适应哈希索引”的功能，当引擎注意到某些索引值被频繁使用时就会在内存中基于B+Tree索引之上再创建一个hash索引，这样就让B+Tree也具有hash索引的优点比如快速查找。</p></li>
<li><p>小表通常全表扫描更高效，中大型表才适合用索引，使用索引过程中要注意，索引列必须单独的出现在比较符号的右侧而不是表达式的一部分（这会使索引失效），使用前缀索引来节省空间提高检索效率，多列索引要注意顺序不然容易失效，聚簇索引可以提高访问速度。</p></li>
<li><p>慢查询优化：只向数据库请求需要的列（比如不要随意select * ）、避免不必要的行扫描、必要的时候分解查询（拆分大的查询，分解关联查询）。</p></li>
<li><p>默认配置文件是经过大量测试，所以属于较优解，一般符合普通用户，要修改也主要是根据业务而不是服务器配置；任何打算长期使用的配置都应该写到全局配置文件而不是在命令行指定，因为如果偶然启动忘了（事实是经常会忘，<strong>好记性不如烂笔头是个真理</strong>）设置就会有风险。</p></li>
<li><p>MySQL复制功能不仅有利于构建高性能应用，同时也是高可用性（负载均衡、故障切换）、可扩展性（升级）、灾难恢复、备份以及数据仓库等工作的基础。</p></li>
<li><p>数据如果非常庞大，比如几亿行了，单台机器已经撑不住了，通常要采取分片技术，分片最大的问题就是查询与获取数据，我们的目标是对最重要且频繁查询的数据减少分片（热点数据通常就那么多）。所以分片关键问题就在于选择一个好的分区键，通常是一个数据库中非常重要的实体的主键。</p></li>
<li><p>不仅要关注MySQL，还要关注应用层优化：Apache服务器处理静态文件都可能使用一个占用内存很大的进程（上一个请求处理完后，该进程仍然保持着），所以最好使用Nginx或者Lighttpd来处理静态内容服务，而且静态文件名不要重用，要加上版本号，这样就能避免浏览器缓存问题；主动缓存如Squid，被动缓存如Memcached，都可以对性能获得数量级的提升，关键就在于找到正确的粒度和缓存过期策略组合，通常主动缓存更好，因为对应用层隐藏了检查-生成-存储这个过程；</p></li>
<li><p><strong>......</strong></p></li>
</ul>
<p>亮点太多，列不完了，需要大家自己去寻找。另外，这本书不适宜一次性的精读完毕（太厚，内容太多），可以快速浏览一遍，大概了解，以后遇上问题就可以把这本书当作一本问题解答手册来查询解决方案，或者找找灵感。</p>
<h2>Redis实战</h2>
<p>Redis实战 (豆瓣)  <a href=""https://book.douban.com/subject/26612779/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>本书对redis的介绍是相当全面了，从基本用法讲起，然后讲了许多应用场景，包括购物车、数据库缓存等，然后讲了一些常见问题的解决办法，比如内存占用过高，自定义扩展来丰富redis的用法等等，看完一本书过后就能很好的使用redis了（还有本好书：<a href=""https://book.douban.com/subject/25900156/"" rel=""nofollow noreferrer"">redis设计与实现</a>，我大致浏览了一下，这本书主要讲了redis的实现原理，这两本书加起来就能既懂原理又会使用，把redis搞个透彻）。</p>
<p>本书亮点：</p>
<ul>
<li><p>使用冒号 : 或者管道号 | 等来实现命名空间的作用，比如一个名为 article:12222 的hash存了这篇article的title，link，time等属性，article:12223又是另一篇文章，这个可以部分实现数据库检索的功能。</p></li>
<li><p>为了减少redis与客户端之间的通信次数，可以用multi和exec来做事务处理，事务会一次性的把一批命令一次发给redis，提高吞吐率；另外事务还能保证一批操作的原子性。在node-redis实现中，如果只是想提高吞吐率则可以用batch替代multi。</p></li>
<li><p>通过复制（主从）和AOF能够增强redis抵抗系统崩溃损失数据的能力，AOF如果用得不好的话，要么损失很多数据，要么严重降低吞吐量，比较合适的做法是appendfsync everysec 亦即把每一秒的命令一次同步进文件。</p></li>
<li><p>使用 redis 的 setnx 来实现基本上正确的的分布式锁，再加上expire可以实现具有超时功能的锁，保证即使获得锁的客户端崩溃没有主动释放锁时，其他进程也有机会获得锁。</p></li>
<li><p>用 list 来替代 subscribe、publish 实现更可靠的发布订阅系统；另外，利用subscribe、publish加list来实现具有离线缓存的消息队列系统，保证即使发生连接故障也能把消息送达。</p></li>
<li><p>利用反向索引以及 redis 集合的并、交、差功能可以实现简易的搜索引擎，利用 hash 结构的 sort 功能还能对搜索结果进行简易的排序功能，利用有序集合 zset 能实现更高级的排序功能。</p></li>
<li><p>社交网站通常是用时间线这一数据结构来实现新鲜事浏览这一功能，虽然导致了大量的冗余信息，但是能够节省查询时间，这是典型的以空间换时间的操作，我以前做社交APP后台的时候直接把所有新鲜事直接放在一张表中，然后按用户id查询，这样虽然省了空间，但是如果用户剧增（(⊙﹏⊙)b，我们的APP并没有用户剧增）就不行了，一张表几亿行还怎么查。</p></li>
<li><p>使用短结构来节约内存，使用较短的键名节约内存，分片降低单实例的内存占用。</p></li>
<li><p>使用lua脚本，在不编写C代码的情况下，为redis添加新的功能。</p></li>
</ul>
<p>时效性问题，本书没有一些最新特性 比如 geohash 解决了地理坐标问题，键的异步释放使得我们可以放心删除而不必担心大量数据的删除使得redis短暂不可用。总之，要更好的利用redis还是要追踪redis的<a href=""https://redis.io/download"" rel=""nofollow noreferrer"">最新变化</a>，以便更简洁、更靠谱的解决问题。</p>
<h2>深入剖析Nginx</h2>
<p>深入剖析Nginx (豆瓣)  <a href=""https://book.douban.com/subject/23759678/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>本书从源码入手，依次讲解了进程模型、模块、响应处理机制、过滤、负载均衡等相关原理，极大的满足了我的好奇心，因为之前一直就对nginx高并发处理能力有一丢丢了解（比如nginx采用事件驱动机制而非apache的进程、线程每请求方式），自己也用过nginx，但是对他的原理还不是特别的明白，本书算是填补了我的这个空白。</p>
<p>本书亮点：</p>
<ul>
<li><p>Nginx 将职责分为监控进程（主进程）和工作进程（主进程fork的子进程），监控进程与用户交互并对工作进程进行监控管理，工作进程完成具体业务逻辑，两者都有一个无限的for循环，这是服务进程的基本写法。</p></li>
<li><p>Nginx仅提供针对大块内存的回收不提供小块内存的回收，这是因为web server的特殊性亦即阶段和时效，请求就申请内存，处理完毕就释放内存，所以不会存在nginx长时间占据大量无用内存的情况，那么小内存也自然不必急于回收，而是成为大内存后在回收。</p></li>
<li><p>对于客户端的请求，nginx将整个过程分为11个阶段，每个阶段有数个回调函数进行专门的处理，每个阶段的处理功能都比较单一，达到高内聚低耦合的目的。</p></li>
<li><p>Nginx是以事件为驱动的，也就是说Nginx内部流程的向前推进基本都是靠各种事件的触发来驱动，内部事件主要有两类：IO事件与定时器事件。其中IO事件主要靠epoll,epoll主要优点是监控数目不受文件描述符限制、事件响应是触发式的，不需要遍历描述符（select需要）。</p></li>
<li><p>Nginx要处理动态的内容一般需要转发给后端服务器，常见的搭配是nginx+fastcgi+php，nginx把http请求转化为fastcgi协议的数据后转发给PHP引擎，PHP引擎处理结果后把数据返回给nginx，nginx把数据转化为http格式返回给客户端。</p></li>
<li><p>负载均衡有多重含义（或者说多重级别），可以是进程上的（根据master进程根据子进程压力调整其获取监听套接口的几率），更广的意义上是指反向代理上，亦即nginx把请求均衡的转发给后端服务器如PHP引擎，发挥多个单元的整体效能。一般采取加权轮询、IP hash等策略，但是只靠nginx是不能实现完整的负载均衡的，详见我以前写的一篇<a href=""https://segmentfault.com/a/1190000004708640"" rel=""nofollow noreferrer"">文章</a>。</p></li>
</ul>
<p>这本书主要从应用及其原理方面来介绍nginx，对于后端程序员应该是够用了（我也忽略了许多源码，因为只是想了解一下原理）。但是对于要想自己深入、进行模块编写的读者应该还不够用，可以再参考一下这本书  <a href=""https://book.douban.com/subject/26745255/"" rel=""nofollow noreferrer"">深入理解Nginx（第2版）</a>（我大概浏览了一下，本书会指导读者编写具体的模块及其底层原理，比我们今天介绍的书更深入一些）。</p>
<h2>第一本Docker书</h2>
<p>第一本Docker书 修订版 (豆瓣)  <a href=""https://book.douban.com/subject/26780404/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>书如其名，这就是真正的第一本docker书。docker是什么、怎么安装、如何使用、测试集成、构建服务等都有介绍。之前就久仰docker大名，也试着试用了一下，但是直到这本书读完我才对docker有了一个完整的认知。另外，不出意料，本书的推荐序也很精彩。</p>
<p>本书亮点：</p>
<ul>
<li><p>docker的核心价值在于可能改变软件的交付方式和运行方式。传统的交付方式下，软件运行期依赖的环境是无法控制，不能标准化的，开发人员常常需要解决开发环境和生产环境的差别带来的问题，而docker则把软件及其依赖环境打包在一起，以镜像形式交付，让<strong>软件运行在标准环境中</strong>，非常符合<a href=""https://aws.amazon.com/cn/what-is-cloud-computing/"" rel=""nofollow noreferrer"">云计算</a>的需求，同时docker的轻量虚拟化技术也符合<strong>实例水平扩展，资源动态调整</strong>的要求。</p></li>
<li><p>docker提供以下几个好处：简单轻量的建模方式，工程容易docker化，随时修改代码，运行快速；职责分离，开发人员只管开发，运维人员只管容器管理，减少环境不同带来的问题；快速高效的开发生命周期，程序容易部署、移植和协作；容易实现<a href=""http://dockone.io/article/394"" rel=""nofollow noreferrer"">面向服务的架构和微服务架构</a>。</p></li>
<li><p>docker只支持64位架构，原生的Linux容器格式：libcontainer，使用命名空间来隔离文件系统（每个容器都有自己的root系统）、进程（每个容器都运行在自己的进程环境中）和网络（容器间虚拟网络地址和IP地址都是分开的），使用cgroups将CPU内存之类的资源独立分配给容器，写时复制使得文件系统分层隔离、速度更快、占用空间更小，还提供日志和交互式shell。</p></li>
<li><p>镜像分层：新镜像是从 base 镜像一层一层叠加生成的，文件系统发生变化时，就在现有镜像的基础上增加一层，这一层叫做“容器层”（读写层），“容器层”之下的都叫“镜像层”（只读层），只有当需要修改时才从镜像层复制一份数据到容器层，这种特性被称作写时复制（Copy-on-Write），达到了镜像共享，快速构建的目的。</p></li>
<li><p>可以使用docker commit来构建镜像，也可以基于dockerfile和docker build命令构建，通常建议使用后者，因为dockerfile更具备<strong>透明性</strong>（可以清晰地看出安装了什么软件，修改了什么配置）、<strong>可重复性</strong>（一次编写，多次使用。此外构建缓存还可以制作构建模板）、<strong>幂等性</strong>（同一个dockerfile不论执行多少次，结果都是相同的）。</p></li>
<li><p>docker容器之间通讯有3种方式，1.9之前推荐用Docker Link（安全：只有link之前的容器可以通信，不必硬编码，不支持多主机），1.9之后推荐Docker Networking（支持多主机容器连接，可以热更新容器，Networking网络内部容器可以自主发现），不太推荐docker内部网络（IP硬编码等导致该方法不够灵活）。</p></li>
<li><p>volume（卷）具有一些有用的特性：容器之间共享数据，对卷的修改会直接反映在包含改卷的容器里所以可以在不修改容器的情况下向容器里加入、更新、删除数据，更新镜像时不会影响卷。利用这些特性可以更好的进行数据共享与持久化。</p></li>
<li><p>docker编排与集群化之路：<strong>Docker Compose</strong> 是用来做 docker 的多容器控制，使用Compose ，你可以在一个文件中定义多个容器应用，然后使用一条命令来启动你的所有应用，避免繁复操作，docker 自动化构建容器栈；<strong>Consul</strong>提供了一个易于使用，基于开放标准的服务发现解决方案，服务发现允许某个组件在想与其他组件通讯时自动找到对方；<strong>Docker Swarm</strong>是一个用于创建Docker主机（运行Docker守护进程的服务器）集群的工具，使用Swarm操作集群，会使用户感觉就像是在一台主机上进行操作亦即将容器抽象到集群级别。还有其他很多工具如：fleet、etcd、Kubernetes、Apache Mesos、Helios、Centurion。</p></li>
</ul>
<p>时效性原因，书中一些例子已经过时（如Docker1.12开始内置编排机制，Docker1.13正式支持<a href=""http://blog.csdn.net/u011499747/article/details/74019957"" rel=""nofollow noreferrer"">docker stack</a>），需要结合<a href=""http://www.dockerinfo.net/dockerversion"" rel=""nofollow noreferrer"">最新版本</a>来使用。<br>另外，想要深入理解docker可以阅读这本书 <a href=""https://book.douban.com/subject/26593175/"" rel=""nofollow noreferrer"">Docker——容器与容器云</a>。我大致浏览了下，这本书不仅讲了docker如何使用，还深入讲解了docker的核心原理如namespace资源隔离、cgroups资源限制、libcontainer原理和一些高级实践技巧。此外，还讲了对容器、容器云的思考，包括如何构建自己的容器云，以及Kubernetes实现一切皆容器的“大同理想”。</p>
<h2>UNIX/Linux 系统管理技术手册</h2>
<p>UNIX/Linux 系统管理技术手册 (豆瓣)  <a href=""https://book.douban.com/subject/10747453/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>又是一本进千页的大部头，但是不怕，这本书如其名，是一本手册性质的书，非常大而全，包括基本管理技术、网络管理技术和其他补充管理技术，几乎包揽了所有我们可能用到的功能（小到一行代码整么写，大到数据中心怎么建），对于宏观把握<strong>整个Linux生态系统</strong>有很大作用。我的应对策略是跳跃式阅读（不错，就像上面那本MySQL），留下整体映像，等遇上问题时再来具体的查询相关部分的内容。也就是说，大脑相当于内存，书本相当于硬盘数据库，我们首次阅读就是在内存中建立索引，便于提升以后的查找速度:-D。</p>
<p>本书亮点：</p>
<ul>
<li><p>Linux各个发行版其实并没有那么巨大的差别，我们选择一个发行版时主要考虑几点：是否能长期存在，是否会有持续的安全补丁，是否会持续更新软件，发行商是否会在出了问题时帮我们解决，不同发行版侧重点会有所不同我们要根据自己的业务来进行选择。</p></li>
<li><p>编写脚本时注意形成一种指导风格，这样你和你的团队成员可以按照相同的规范来书写代码，有了这种指导在阅读别人写的代码或者别人阅读你的代码时都会更容易；注释不要多也不要少，最好的效果是一两个月后再来读代码发现注释和有用。</p></li>
<li><p>一个进程由一个地址空间（一组内存页面）和内核一部分数据（有关进程的信息如地址空间映射、状态、优先级、资源）组成；一个线程是在进程内执行fork的结果，继承了包含它的进程的许多属性，多个线程可以共享该进程内数据，<strong>并行</strong>（多核）或<strong>并发</strong>（单核，模拟并行）执行</p></li>
<li><p>Unix家族的文件系统目前没有一个标准，我们尽量按照如下标准来组织。bin：核心操作系统命令；sbin：系统最小规模运行所需命令；boot：内核及加载内核所需软件；etc：关键启动文件及配置文件；usr：次要的命令文件；var:随主机变化的文件如日志，数据文件；mnt：可移动介质临时挂载点；opt：可选的应用软件包；proc：正在运行的进程信息；tmp：临时文件；</p></li>
<li><p>合适的备份计划取决于：文件系统的活跃性，转储设备的容量，用户期望的冗余度，想要购买的备份介质数量。</p></li>
<li><p>版本控制与多人合作：svn是集中式的，一台中央服务器充当了一个项目的权威库；git是分布式的，没有中央库，每个用户都含有一个完整的项目，采用的是拷贝-分支策略。</p></li>
<li><p>信息安全领域的基本思想——CIA原则：Confidentiality（机密性），Integrity（完整性），Availability（可用性）。在设计、实现或者维护系统的时候，需要考虑CIA安全三原则，正如老话所说“安全性是一个过程”。</p></li>
<li><p>负载均衡既提高了性能又增加了冗余性，包括几种方式：循环域名服务（也就是DNS轮询）、负载均衡硬件（比如Big-IP Controller、Content Services Switches等）、软件负载均衡（比如Nginx）。</p></li>
<li><p>Squid既是一个高速缓存软件也是一个代理服务程序，代理服务很有用，但是Squid真正厉害之处是其高速缓存，它甚至能够形成一个缓存层次结构，以最大化提高缓存命中率。Squid是有意义的，因为用户对web的探索具有<strong>趋同性</strong>，所以在适度的规模上会出现相当多重复请求，运行高速缓存可以节省带宽和计算资源。</p></li>
<li><p>虚拟化技术让多个彼此独立的操作系统同时运行在相同的物理硬件上，系统管理员把每个虚拟机当做一台独立的服务器，既满足了软件厂商的要求，又降低了单一服务的成本。包括全虚拟化（如VMwareESX）、半虚拟化（Xen）、操作系统级别虚拟化（如workload partition）。除了传统的虚拟化技术，近年来的云计算也是一种（或者说类）虚拟化技术，它把计算能力作为对外提供的服务类似于水电等<strong>基础设施</strong>，直接使得硬件层对开发人员和系统管理员透明，提高了效率。</p></li>
<li><p>分析性能问题步骤：明确表述问题、收集证据并分类、批判性的评价数据、用语言和图示总结证据、形成一份总结说明。这一套其实不止适用于性能分析问题，也适用于大多数其他问题，比如架构、重构、debug等等。</p></li>
<li><p>系统管理不是一种行为艺术。无论做的什么，都应该能重复完成，切前后一致。通常意味着最底层的变化应该有脚本或者配置程序来做，而不是管理员来做。配置上的变化应该体现在系统管理软件的配置文件里。说白了，就是<strong>文档的重要性</strong>，在我看来：首先文档就是一家公司的财富，没有文档，人走了，那么之前公司的积累也就没了，又得重头来，损失很大；其次，文档是一种保证，大家都按约定办事，保证操作可重复，避免歧义与甩锅；再其次，文档能节约时间，虽然写的时候可能费点事，但是能节省后面大量的人员沟通的时间；最后，文档保证了系统的完整性，亦即文档保证了系统的后续修改遵循一致的思路和风格，才不至于系统随着时间流逝而越来越乱，难以维护与使用。</p></li>
</ul>
<p>本书教会了我们怎么使用Linux，这对于我们后端开发人员是足够受用了。而这本书<a href=""https://book.douban.com/subject/6097773/"" rel=""nofollow noreferrer"">Linux内核设计与实现(原书第3版)</a>就会告诉我们Linux是如何实现它这么多这么强大的功能的内在原理，精力有限，我只是浏览了一下没有细读，等以后真的用得上Linux的深入知识时，或者遇上了什么解决不了的问题，我会再来求助于这本书的。</p>
<h2>代码整洁之道</h2>
<p>代码整洁之道 (豆瓣)  <a href=""https://book.douban.com/subject/4199741/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>本书提出一个观点就是：代码质量与整洁度成正比，围绕提高整洁度，作者展开了方方面面的阐述，从命名的方法到函数的定义，从注释的使用到格式的目的，还介绍了对象，错误处理等等等等。看完后的感觉就是：写好代码，从本书开始。虽然我现在写的代码还比较“乱”，但是今后的代码中会努力践行书中的原则，争取写出整洁的代码。</p>
<p>本书亮点：</p>
<ul>
<li><p>软件质量既依赖于<strong>架构和项目管理</strong>，又与<strong>代码质量</strong>紧密相关，而代码质量与<strong>整洁度</strong>成正比，所以我们要致力于写出干净整洁的代码。并且不仅要知道书写整洁代码的原则，还有查看大量代码实例，进行案例研究，在实践中贯彻这些原则，才能真正做到<strong>知行合一</strong>。</p></li>
<li><p>不同的人对整洁代码有不同的理解，总归起来，有如下一些特点：代码逻辑直截了当，依赖关系很少，性能最优，每个函数模块类专注于一件事，可以轻易的被其他人阅读，具有完整的测试，作者自己要在乎自己的代码悉心维护，没有重复代码提前构建重复代码应有的抽象，体现系统的所有设计理念，包含尽量少的实体。</p></li>
<li><p>命名看似简单却无处不在，所以我们不妨命好名，几个原则：名副其实，不用注释也能明白这个变量代表什么；避免误导，不要用保留词或太相同的词引起歧义；做有意义的区分，不要添加在名字后数字或者废话而是以读者能鉴别不同之处的方式来区分；名字要读的出来，便于交流；名称要便于搜索；一个概念统一用一个词，比如不要混用manager和Controller；避免双关词；给名词添加语境，但是避免冗余的语境，含义明确的情况下，短名字总是比长名字好呀......</p></li>
<li><p>函数构成了当今程序的基石，函数要写的明白要遵循如下原则：短小；只做一件事，也就是函数中的语句要在同一个抽象层级上，不在同一个抽象层级就得拆出来形成一个新的函数；把switch埋藏在较低的抽象层级，比如抽象工厂中，虽然依然免不了判断或者条件增多时要增添代码，但是能够把<strong>变化截留在工厂内，减少影响范围</strong>；不要向函数传入标志参数，比如TRUE/FALSE，而是应该直接把这个函数重构成两个函数；一个函数要么下达什么指令（set）要么回答什么问题（get），不要添加副作用；DRY（别重复自己）。</p></li>
<li><p>注释是一种必须的恶，如果代码写的好根本不需要注释（<strong>感觉有点过了，至少一个大的模块用来干啥还是因该用注释或者说文档直接来说明</strong>），而且代码才是真实的地方，注释很可能没有被维护而导致失效；别给糟糕的代码加注释，重写吧；版本控制系统可以帮我们省掉许多注释如作者署名，注释掉的代码。</p></li>
<li><p>或许你认为“让代码工作”是开发者的头等大事，但是其实并不是这样的，代码风格关系着沟通，而<strong>沟通才是头等大事</strong>。代码风格影响着可维护性和扩展性，即使代码已不复存在，其风格和律条依然存在,因而一个团队应该形成一个统一的风格，便于沟通与维护。</p></li>
<li><p>隐藏实现并非就是简单的在变量之间放一个函数层。隐藏关乎抽象，类并不是简单的用取值器和赋值器将变量向外推，而是暴露抽象接口，以便用户无需了解数据的具体实现就能操作数据本身。对象暴露行为，隐藏数据；数据结构暴露数据，没有明显的行为。要合理的利用二者。</p></li>
<li><p>错误处理一旦处理不好就容易污染整洁的代码：使用异常来保证错误处理不会打乱正常的程序逻辑；可检异常可能会破坏开闭原则，要谨慎使用；打包第三方API就降低了对它的依赖；不要返回null值，只是突然增加了工作量，可以用异常或者特例对象来代替。</p></li>
<li><p>测试非常重要：测试代码和生产代码一样重要，脏测试就等于没测试；有了测试就可以毫无顾虑的进行重构和改善，因为有保证，<strong>消除了清理代码就会破坏代码的恐惧</strong>（这句话可谓是戳中了我，我之前的项目也有过一些重构的努力，但是就是怕重构过后不能正常运行，导致重构举步维艰）；测试代码要清晰，符合<strong>构造-操作-检验</strong>三个环节；单个测试中的断言应该最小化，保证一个测试对应一个概念；整洁的测试遵循 ＦＩＲＳＴ 原则（fast，independent，repeatable，self-validing，timely）。</p></li>
<li><p>系统层级的整洁：城市能有效运转是因为演化出了<strong>恰当的抽象层级和模块</strong>，有人负责全局有人负责细节，所以软件系统也有架构师和项目经理等；将构造和使用分开（依赖注入，控制反转）；扩容（要考虑可扩展性，但是注重现有的系统的构造，将来再重构和添加，没必要<a href=""https://en.wikipedia.org/wiki/Big_Design_Up_Front"" rel=""nofollow noreferrer"">Big Design Up Front</a>，考虑好模块化和关注切面划分就好）。</p></li>
<li><p>KISS（Keep It Simple, Stupid），简单设计原则：运行所有测试（测试是对一个系统的保证）；不要重复（重复意味着额外的工作、风险、复杂度）；表达了程序员的意图（清晰可读）；尽可能少的类和方法数量（避免教条如：每个类都要有接口）。</p></li>
<li><p>编程是一种技艺甚于科学的东西，不要指望一开始就写出优雅整洁的代码，一般是先写出肮脏的代码，然后进行重构，清理。所以代码仅仅能工作还不够，满足于代码能工作的程序员不够专业，他们害怕没时间进行代码结构的重新设计，其实没有什么比糟糕的代码给项目带来更长远的损害了，糟糕的代码会一直腐败发酵，影响各个模块（找出这些依赖和影响相当不容易）无情的腐蚀整个项目和团队。</p></li>
<li><p>......</p></li>
</ul>
<p>这本书里面的良心建议实在是太多了，无法一一列举，真的得自己看一遍才能有收获。</p>
<h2>重构-改善既有代码的设计</h2>
<p>重构 (豆瓣)  <a href=""https://book.douban.com/subject/4262627/"" rel=""nofollow noreferrer"">https://book.douban.com/subje...</a></p>
<p>上一本书教会我们怎样书写整洁的代码，那么面对不整洁的代码，我们怎么办呢？这本书就手把手教我们怎么重构，改善现有的代码。从一个实例入手，讲了重构的理由、原则、技巧、步骤与时机。我读完过后感觉<strong>心里就有了些烙印</strong>，无论是写代码还是改代码，基本都会不自主的向这本书靠拢，很有收获。</p>
<p>本书亮点：</p>
<ul>
<li><p>重构是在不改变代码外在行为的前提下对代码作出修改，以改进程序的内部结构，本质上说重构就是在代码写好后改进其设计，<strong>提高其可理解性，降低修改成本</strong>；记住所有代码的“坏味道”及其对应的重构手法，才能有信心面对各种情况—<strong>—学会所有招式才可能“无招胜有招”</strong>；为了避免自掘坟墓，重构必须系统化进行，用一些经过检验的重构手法，就可以<strong>一次一小步的修改代码</strong>，所以任何<strong>错误都可以比较容易的发现</strong>，降低了重构过程中的风险。</p></li>
<li><p>如果你发现自己需要为程序添加一个特性，而现有的代码结构使你无法方便的添加，那就先重构程序，使得特性添加变得容易，然后再添加这个特性。而重构的第一步就是建立一组可靠的测试，来尽量避免bug，保证重构的正确性。</p></li>
<li><p>对象A最好不要在另外一个对象B的属性基础上使用switch语句，因为将来B变了A也必须变，如果不得不使用switch也要在自己的属性上使用，也就是把switch移动至B里面去；最好是用多态替换switch语句（其实也不是替换，而是把switch放在了较低的抽象层级，使得可能变化的部分就在一个对象里面，将其与不变的部分隔离开）。</p></li>
<li><p>添加新功能和重构是两种行为，一定要加以区分，并且同一时刻只做好一件事就行。</p></li>
<li><p>任何能够查询的东西，我都不太愿意去记，因为怕把大脑挤爆了。所以说<strong>大脑这个珍贵而有限的内存主要做的事一定是建好索引，而非存储数据；另一方面，常用的数据也应该存进大脑，以提高效率，这和内存中的缓存是一个道理</strong>。</p></li>
<li><p>不要为了重构而重构，一定是因为你想做某件事时重构恰好可以帮你做好，重构的几个时机：添加新特性时，修补错误时，复审代码时。</p></li>
<li><p>程序有两面价值“今天可以为你做什么”和“明天可以为你做什么”，<strong>如果只关注今天的工作，那么明天我们将无法工作</strong>，所以需要重构，来避免代码出现以下四个情况：难以阅读，重复太多，新行为无法简单添加，逻辑复杂。这四个情况导致的结果都是程序难以改变（修改），而唯一不变的就是改变:-D</p></li>
<li><p>代码的坏味道——重构的时机：重复代码、过长函数、过大的类、过长的参数列、发散式变化、霰弹式修改、依恋情结、数据泥团、基本类型偏执、switch语句、平行继承体系、冗赘类、夸夸其谈未来性、临时字段、过渡耦合的消息链、中间人、不适合的亲昵关系、异曲同工的类......</p></li>
<li><p>本书给出了一份重构列表，包含了很多很多的重构类型的名称、动机、方法、范例，涵盖了函数、对象、数据、表达式、调用、概括关系、大型项目等方方面面，值得我们借鉴，下面摘抄几条作为示例。</p></li>
<li><p>当我看见一个过长的函数或者一段需要注释才能让人理解用途的代码就会把这段代码放进一个独立的函数中。短函数的好处：更可能被复用，让高层函数看起来更清晰易懂，复写更容易。“短”的含义不在代码行数，而在于函数名称和函数本体之间的语义距离。</p></li>
<li><p>如果一个类的某个方法、字段被另一个类频繁使用，就应该搬移该方法、字段。</p></li>
<li><p>混乱的继承体系是一个严重的问题，因为它会导致重复的代码，这正是程序员职业生涯的致命毒药。它还会使修改变得困难，因为特定问题的解决策略被分散到了整个继承体系，最终你的代码难以理解。所以可以通过建立多个继承体系，并利用委托来互相调用，使得原来负责多个任务的继承体系变成多个负责单个任务的继承体系。</p></li>
<li><p>......</p></li>
</ul>
<p>感觉本书最大的问题就是太老了（1999年），有些工具或者方法在如今技术进步的情况下显得有些多余，比如现在的IDE如Eclipse或者IDEA都有很强大的功能，书里提到的一些技巧完全用不着。不过经典终究是经典，里面的绝大部分思想我们如今都还是可以借鉴的，尤其是对于重复代码的观点——应该坚决消灭重复。</p>
<h2>2017.9.8 后记</h2>
<p>花费了几个月来看书，又花了几天来整理，希望对我们都有所帮助:-D。欢迎拍砖，我的主页<a href=""http://mageek.cn/"" rel=""nofollow noreferrer"">Mageek`s Wonderland</a>。<br><a href=""http://mageek.cn/archives/34/"" rel=""nofollow noreferrer"">查看原文</a></p>

                ", 后端好书阅读与推荐（续）,1531977932,141,1,98,1,1,https://segmentfault.com/a/1190000011076865
65,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989115"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>我们在日常开发中经常遇到布局问题，下面罗列几种常用的css布局方案<br>话不多说，上代码！</p></blockquote>
<blockquote><p>以下所有demo的源码<br>github：<a href=""https://github.com/zwwill/css-layout/tree/master/demo-1"" rel=""nofollow noreferrer"">https://github.com/zwwill/css-layout/tree/master/demo-1</a><br>链接: <a href=""http://pan.baidu.com/s/1cHBH3g"" rel=""nofollow noreferrer"">http://pan.baidu.com/s/1cHBH3g  </a>  <br>密码:obkb</p></blockquote>
<h1>居中布局</h1>
<blockquote><p>以下居中布局均以不定宽为前提，定宽情况包含其中</p></blockquote>
<h2>1、水平居中</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989116"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<h3>a) inline-block + text-align</h3>
<pre><code class=""css"">.parent{
    text-align: center;
}
.child{
    display: inline-block;
}</code></pre>
<p>tips：此方案兼容性较好，可兼容至IE8，对于IE567并不支持inline-block，需要使用css hack进行兼容</p>
<h3>b) table + margin</h3>
<pre><code class=""css"">.child{
    display: table;
    margin: 0 auto;
}</code></pre>
<p>tips：此方案兼容至IE8，可以使用<code>&lt;table/&gt;</code>代替css写法，兼容性良好</p>
<h3>c) absolute + transform</h3>
<pre><code class=""css"">.parent{
    position: relative;
    height:1.5em;
}
.child{
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}</code></pre>
<p>tips：此方案兼容至IE9，因为transform兼容性限制，如果<code>.child</code>为定宽元素，可以使用以下写法，兼容性极佳</p>
<pre><code class=""css"">
.parent{
    position: relative;
    height:1.5em;
}
.child{
    position: absolute;
    width:100px;
    left: 50%;
    margin-left:-50px;
}</code></pre>
<h3>d) flex + justify-content</h3>
<pre><code class=""css"">.parent{
    display: flex;
    justify-content: center;
}
.child{
    margin: 0 auto;
}</code></pre>
<p>tips：flex是一个强大的css，生而为布局，它可以轻松的满足各种居中、对其、平分的布局要求，但由于现浏览器兼容性问题，此方案很少被使用，但是值得期待浏览器兼容性良好但那一天！</p>
<h2>2、垂直</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989117"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<h3>a) table-cell + vertial-align</h3>
<pre><code class=""css"">.parent{
    display: table-cell;
    vertical-align: middle;
}</code></pre>
<p>tips：可替换成<code>&lt;table /&gt;</code>布局，兼容性良好</p>
<h3>b) absolute + transform</h3>
<pre><code class=""css"">.parent{
    position: relative;
}
.child{
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}</code></pre>
<p>tips：存在css3兼容问题，定宽兼容性良好</p>
<h3>c) flex + align-items</h3>
<pre><code class=""css"">.parent{
    display: flex;
    align-items: center;
}</code></pre>
<p>tips：高版本浏览器兼容，低版本不适用</p>
<h2>3、水平垂直</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989118"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<p>a) inline-block + table-cell + text-align + vertical-align</p>
<pre><code class=""css"">.parent{
    text-align: center;
    display: table-cell;
    vertical-align: middle;
}
.child{
    display: inline-block;
}</code></pre>
<p>tips：兼容至IE8<br>b) absolute + transform</p>
<pre><code class=""css"">.parent{
    position: relative;
}
.child{
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
}</code></pre>
<p>tips：兼容性稍差，兼容IE10以上<br>c) flex</p>
<pre><code class=""css"">.parent{
    display: flex;
    justify-content: center;
    align-items: center;
}</code></pre>
<p>tips：兼容差</p>
<h1>多列布局</h1>
<h2>1、一列定宽，一列自适应</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989119"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<p>a) float + margin</p>
<pre><code class=""css"">.left{
    float: left;
    width: 100px;
}
.right{
    margin-left: 120px;
}</code></pre>
<p>tips：此方案对于定宽布局比较好，不定宽布局推荐方法b<br>b) float + overflow</p>
<pre><code class=""css"">.left{
    float: left;
    width: 100px;
    margin-right: 20px;
}
.right{
    overflow: hidden;
}</code></pre>
<p>tips：个人常用写法，此方案不管是多列定宽或是不定宽，都可以完美实现，同时可以实现登高布局<br>c) table</p>
<pre><code class=""css"">.parent{
    display: table; width: 100%;
    table-layout: fixed;
}
.left,.right{
    display: table-cell;
}
.left{
    width: 100px;
    padding-right: 20px;
}</code></pre>
<p>d) flex</p>
<pre><code class=""css"">.parent{
    display: flex;
}
.left{
    width: 100px;
    padding-right: 20px;
}
.right{
    flex: 1;
}</code></pre>
<h2>2、多列定宽，一列自适应</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989120"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<p>a) float + overflow</p>
<pre><code class=""css"">.left,.center{
    float: left;
    width: 100px;
    margin-right: 20px;
}
.right{
    overflow: hidden;
}</code></pre>
<p>b) table</p>
<pre><code class=""css"">.parent{
    display: table; width: 100%;
    table-layout: fixed;
}
.left,.center,.right{
    display: table-cell;
}
.right{
    width: 100px;
    padding-right: 20px;
}</code></pre>
<p>c) flex</p>
<pre><code class=""css"">.parent{
    display: flex;
}
.left,.center{
    width: 100px;
    padding-right: 20px;
}
.right{
    flex: 1;
}</code></pre>
<h2>3、一列不定宽，一列自适应</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989121"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<p>a) float + overflow</p>
<pre><code class=""css"">.left{
    float: left;
    margin-right: 20px;
}
.right{
    overflow: hidden;
}
.left p{width: 200px;}</code></pre>
<p>b) table</p>
<pre><code class=""css"">.parent{
    display: table; width: 100%;
}
.left,.right{
    display: table-cell;
}
.left{
    width: 0.1%;
    padding-right: 20px;
}
.left p{width:200px;}</code></pre>
<p>c) flex</p>
<pre><code class=""css"">.parent{
    display: flex;
}
.left{
    margin-right: 20px;
}
.right{
    flex: 1;
}
.left p{width: 200px;}</code></pre>
<h2>4、多列不定宽，一列自适应</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989122"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<p>a) float + overflow</p>
<pre><code class=""css"">.left,.center{
    float: left;
    margin-right: 20px;
}
.right{
    overflow: hidden;
}
.left p,.center p{
    width: 100px;
}</code></pre>
<h2>5、等分</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989123"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span><br>a) float + margin</p>
<pre><code class=""css"">.parent{
    margin-left: -20px;
}
.column{
    float: left;
    width: 25%;
    padding-left: 20px;
    box-sizing: border-box;
}</code></pre>
<p>b) table + margin</p>
<pre><code class=""css"">.parent-fix{
    margin-left: -20px;
}
.parent{
    display: table;
    width:100%;
    table-layout: fixed;
}
.column{
    display: table-cell;
    padding-left: 20px;
}</code></pre>
<p>c) flex</p>
<pre><code class=""css"">.parent{
    display: flex;
}
.column{
    flex: 1;
}
.column+.column{
    margin-left:20px;
}</code></pre>
<h2>6、等高</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989124"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span><br>a) float + overflow</p>
<pre><code class=""css"">.parent{
    overflow: hidden;
}
.left,.right{
    padding-bottom: 9999px;
    margin-bottom: -9999px;
}
.left{
    float: left; width: 100px;
}
.right{
    overflow: hidden;
}</code></pre>
<p>b) table</p>
<pre><code class=""css"">.parent{
    display: table; 
    width: 100%;
}
.left{
    display:table-cell; 
    width: 100px;
    margin-right: 20px;
}
.right{
    display:table-cell; 
}</code></pre>
<p>c) flex</p>
<pre><code class=""css"">.parent{
    display:flex;
    width: 100%;
}
.left{
    width: 100px;
}
.right{
    flex:1;
}</code></pre>
<h1>并排等分，单排对齐靠左布局</h1>
<p>效果图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011002323"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果图"" title=""效果图""></span></p>
<h2>flex</h2>
<pre><code class=""css"">.main {
    display: flex;
    flex-flow: row wrap;
    justify-content: space-between;
}
.item {
    display: inline-block;
}
.empty{
    height: 0;
    visibility: hidden;
}</code></pre>
<p>具体详解请见下文<br><a href=""https://segmentfault.com/a/1190000011007357"" rel=""nofollow noreferrer"">https://segmentfault.com/a/1190000011007357</a></p>
<h1>圣杯布局&amp;双飞翼布局</h1>
<blockquote><p>此处仅为代码展示，差别讲解请移驾下文<br><a href=""https://segmentfault.com/a/1190000011149400"" rel=""nofollow noreferrer"">【方案】圣杯布局&amp;双飞翼布局</a></p></blockquote>
<h2>圣杯布局</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVUWBQ?w=1046&amp;h=632"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>【JsFiddle】<br><a href=""https://jsfiddle.net/zwwill/px57xzp4/"" rel=""nofollow noreferrer"">https://jsfiddle.net/zwwill/px57xzp4/</a></p>
<pre><code class=""html"">&lt;div class=""container""&gt;
    &lt;div class=""header""&gt;header&lt;/div&gt;
    &lt;div class=""wrapper clearfix""&gt;
        &lt;div class=""main col""&gt;main&lt;/div&gt;
        &lt;div class=""left col""&gt;left&lt;/div&gt;
        &lt;div class=""right col""&gt;right&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""footer""&gt;footer&lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code class=""css"">.container {width: 500px; margin: 50px auto;}
.wrapper {padding: 0 100px 0 100px;}
.col {position: relative; float: left;}
.header,.footer {height: 50px;}
.main {width: 100%;height: 200px;}
.left {width: 100px; height: 200px; margin-left: -100%;left: -100px;}
.right {width: 100px; height: 200px; margin-left: -100px; right: -100px;}
.clearfix::after {content: """"; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden;}</code></pre>
<h2>双飞翼布局</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVUWBQ?w=1046&amp;h=632"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>ps: <br>“这不是一样的图嘛？”<br>“对！就是一样的，因为是解决同一种问题的嘛。”</p></blockquote>
<p>【JsFiddle】<br><a href=""https://jsfiddle.net/zwwill/5xjyeu9d/"" rel=""nofollow noreferrer"">https://jsfiddle.net/zwwill/5xjyeu9d/</a></p>
<pre><code class=""html"">&lt;div class=""container""&gt;
    &lt;div class=""header""&gt;header&lt;/div&gt;
    &lt;div class=""wrapper clearfix""&gt;
        &lt;div class=""main col""&gt;
            &lt;div class=""main-wrap""&gt;main&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=""left col""&gt;left&lt;/div&gt;
        &lt;div class=""right col""&gt;right&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""footer""&gt;footer&lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code class=""css"">.col {float: left;}
.header {height: 50px;}
.main {width: 100%;}
.main-wrap {margin: 0 100px 0 100px;height: 200px;}
.left {width: 100px; height: 200px; margin-left: -100%;}
.right {width: 100px; height: 200px; margin-left: -100px;}
.footer {height: 50px;}
.clearfix::after {content: """"; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden;}</code></pre>
<h2>无名布局</h2>
<p>自己瞎搞的，简单的绝对定位即可解决问题，为啥还要搞什么圣杯和双飞翼<br><a href=""https://jsfiddle.net/zwwill/awwkpwbL/"" rel=""nofollow noreferrer"">https://jsfiddle.net/zwwill/a...</a></p>
<pre><code>&lt;div class=""header""&gt;header&lt;/div&gt;
&lt;div class=""wrapper""&gt;
    &lt;div class=""main col""&gt;
        main
    &lt;/div&gt;
    &lt;div class=""left col""&gt;
        left
    &lt;/div&gt;
    &lt;div class=""right col""&gt;
        right
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=""footer""&gt;footer&lt;/div&gt;</code></pre>
<pre><code>.wrapper { position: relative; }
.main { margin:0 100px;}
.left { position: absolute; left: 0; top: 0;}
.right { position: absolute; right: 0; top: 0;}</code></pre>
<blockquote><p>如果你觉得此文对你有一定的帮助，可以点击下方的【喜欢】收藏备用</p></blockquote>

                ", 【整理】CSS布局方案,1531977934,284,1,378,1,1,https://segmentfault.com/a/1190000010989110
66,1,0,9,"
                    
<blockquote><p>来自 GitChat 作者：帐前卒<br>更多IT技术分享，尽在微信公众号：GitChat 技术杂谈</p></blockquote>
<p><a href=""http://gitbook.cn/books/5993023572746728bbdf8296/index.html"" rel=""nofollow noreferrer"">进入 GitChat 阅读原文</a></p>
<h3>引子</h3>
<blockquote>
<p>遇到一个陌生人，只看到他沾满泥土的鞋子。</p>
<p>夏日地铁里，闻到了周围人的汗臭。</p>
<p>朋友聚会，似乎有些人眼屎没擦干净。</p>
<p>初次相亲见面，就一直在说对方不好看。</p>
<p>你看到别人的种种不足，当面指出来，为什么没有人感谢你？</p>
<p>不光没有人感谢，似乎还有人恶言相向，某些人还因此要打你。</p>
<p>你做错了吗？</p>
<p>————《帐前卒的寓言》</p>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010930968"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>Code Review作为编码社会活动，一直被人诟病。每个人似乎都知道Code Review好，但是推广起来却有种种困难。而“用IDE编程”这事似乎根本就不用推广。这到底是为什么？因为Code Review中不可避免要指出别人的代码不足。我们也经常会遇到：</p>
<ul>
<li>评价/建议后，编码者却不修改；</li>
<li>总是同一种错误，一犯再犯；</li>
<li>抵制你的评价意见，寻求他人再次Review。</li>
</ul>
<p>我们review别人的代码，不是专门为代码点赞，那是“鼓励师”要做的事情。我们主要是指出别人的代码哪里写的不好。我想，即使是最和善、最理智的程序员也肯定不喜欢那些评论。即便如此，我们还是要评论，要让别人接受我们的观点。不过为了让别人乐于接受，肯定要有恰当的鼓励。另外，在评论别人的代码之前，我们最好知道是谁写的代码。如果是匿名的，当然可以肆无忌惮的评论。但Code Review是一种非匿名的社交活动：我们都知道编码者是谁，编码者也知道评价者是谁。与说话的技巧一样：“对什么人，说什么话”。所以我们首先需要了解编码者。</p>
<h3>读代码识人心</h3>
<blockquote>
<p>比鬼神更可怕的，是人心。</p>
<p>————《盗墓笔记》</p>
</blockquote>
<p>读懂人心，实在是太难了。通过代码去读懂人心，那就更难了。如果和编码者经常在一起，性格喜好自然能略知一二。如果你从来没有接触过编码者，只看代码能了解什么呢？我们无法从代码中看出那人的血型、星座、爱好；也难看出勇敢、乐观、顽强、抑郁或悲伤；更看不出他是表现型、分析性还是实干型。当然以上那些性格特点对我们评价代码也没有什么卵用。从代码中读懂人心，只需关注三个方面：</p>
<ul>
<li>是否认真编码</li>
<li>是否对技术有激情</li>
<li>编码水平怎么样</li>
</ul>
<p>为什么只关注这三个方面？认真的编码者对细节格外关心，指明他代码细节的缺陷，他的技术水平一定会有提升。有激情的编码者一定会迫不及待的使用新的技术、新的语法、新的组件。应该告诉他们这些新的技术、语法、组件在代码里用的是否恰当。高水平的编码者乐于提高自己的编程技巧，也喜欢破坏现有的规则，他们看重的只有逻辑错误和运行时问题。Review时，投其所好，才能让编码者信任你，然后才可能接受你的建议。如果编码者编码不认真、技术没激情、水平也不咋样，请问该怎么办？这我们后面会说。</p>
<h4>认真的编码者</h4>
<p>编码者是否想到你所想到的细节，是否还考虑了你没有想到的点？是否遵循了code style规范中每一条细节？是否考虑了边界情况？在特殊处理的地方，有没有写详细的注释？当他看到你的评论时，不管同意与否，他是否每一条都认真回复了。</p>
<h4>有激情的编码者</h4>
<p>编码者是否尝试了新的技术：新的组件、新的语法糖？是否愿意解决一些别人不碰的难题？不那么美观的代码是否充满了不断尝试的味道？是否规避了存在问题的第三方组件？是否尝试写过一些公用组件？是否对旧的问题有新的思路?</p>
<h4>高水平的编码者</h4>
<p>编码水平有优劣，但这个优劣大多数只存在于人的内心。有时候你看了一眼别人的代码，你心里想：“这段代码能写的更简单，更容易。” 所以优劣大多是和自己比较的：技术比自己好，还是比自己差。如果你熟悉整个团队，那么你就能知道这个人的编码水平大概处于整个团队的什么位置。</p>
<p>但是编码者提交的代码量太少，或者大多是log/print/bean，无法了解他这三个方面的特质，那就用comments多交流几次。</p>
<h3>书写评论</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010930969"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>初识，最好多点赞，并建议如何编码。如果对方是新入职的人员， 最好一次性的指出程序要修改的地方。一是他有时间修改；二是新人需要了解公司里的编码规范；三是提升他的编码水平。</p>
<p>在review的过程中不要否定新技术，也不要轻易肯定新技术，<strong>适用才是评判依据</strong>。为什么使用这些新技术？是旧的写起来麻烦，还是旧的无法满足需求，还是只为尝鲜？对于调研团队，我们鼓励使用各种新的技术。不管是挖坑还是填坑，需要通过他们的使用情况，了解多种新技术的功能特性、成熟度、性能优劣和适用条件。对于功能交付团队，不管是上线还是开发软件给客户使用，能满足需求的同时，一定要为了稳定不折腾。否则后期就会被bug所累，疲于奔命。</p>
<p>表达相同意思的一段文字可以有不同的写法。工作要有乐趣，不要评论千篇一律、枯燥乏味。下面我要说几种评论的风格:</p>
<ul>
<li>吐槽。针对熟识的同事或者针对技术水平很高的人。幽默风趣，又让人容易接受。</li>
<li>委婉建议。针对有激情的人，不应该抹杀别人的技术追求。多以疑问句为主，让其自己反思。</li>
<li>批评。针对多次犯同一错误的新人。他们犯的错误一般都是非常容易改正，例如，多写常量定义、使用linux换行符、打印不用System.out等等。有时用感叹句让批评的语气再严厉一点，否则下次新人还会犯同样的错误。</li>
<li>直白陈述。可能大多数评论采用的是这种句式。另外针对编码“得过且过”的老码农，你可能需要多写点：除了点明问题所在， 还应该建议他怎样去修改代码。这样可以减少他的返工次数，消减他的抵触情绪。</li>
<li>讥讽。除非是你的好基友，否则不要用，不要用，不要用，说三遍，不要树敌。</li>
</ul>
<h3>当面交流</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010930970"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>既然当面交流，不妨听听编码者怎么看待你的评论。不要一言不合就暴跳如雷，要问问他想怎么修改，或者为什么不想修改。</p>
<p>出发点还是<strong>""利""</strong>字。但是受益者可能不同的：是编码者得利，还是团队得利，还是公司得利。这就要看你的三寸不烂之舌，如何既讨人欢心又让人听你指示。程序员这群理智的动物，有时最看不惯的就是阿谀奉承。大家都是靠技术混饭吃的，虽然糖衣炮弹固然重要，但更重要的是言明利弊。</p>
<p>有些人即使你心平气和的交流，仍然不愿意修改他们的代码，这时候就要关注问题的边界。如果在容忍的边界里，或者对建议置之不理，或者允许开发者以后再修改。如果是边界之外，就应该据理力争。那边界究竟是怎样划定的呢？我写在下面：</p>
<ul>
<li>代码中存在bug。bug会导致各种错误，有些会导致数据错乱、文件错乱等难以修复的问题。</li>
<li>代码难以理解，日后难维护。当然如果写这代码的人永不离职，自己维护尚可。可人要是离职了，还要看后继者是否愿意担风险去重构这些代码。</li>
<li>长时间运行有问题。那多久会出问题呢？看多久再次部署，如果每天都部署一次，两天就算长时间了。但是为了让团队每个人都休息好、有自己的假期、以及不在休假时被打扰，还是尽量考虑长远一点。如果你最长假期有10天，那至少要考虑软件运行大半个月没问题。</li>
<li>数据量大、访问量大时，代码运行缓慢或者宕机。如果估算运行部署几天后数据/访问量就会到达这个规模，那一定要尽早修改代码。</li>
<li>改动后将大量节省他人的时间。如果将代码抽取为模块或者组件后，有更大的收益。特别是他人即将开始这部分工作时，一定要尽快的抽取出相关代码。不抽取的话，一是别人也要写相关代码；二是一旦有修改，相同功能的代码都会修改；三是即使后期再抽取了组件，也没人愿意重构。</li>
</ul>
<p>我们都是执着的技术人，我们心中自有不可逾越的底线，我们也希望所有的编码者不要越过这条底线。我们把这底线告诉给编码者，这也是Code Review中评审者的义务。但建议也写了，见面也谈过了，编码者和审阅者两方就是各不相让。那没有其他办法，只能通过公司里的人事关系去解决：</p>
<ul>
<li>如果是你的下属，都已经讲明白道理，还是不执行，那是这个下属不称职。</li>
<li>如果是你的上级，你已经告知了他风险，他觉得你的建议没有道理，那就请他说出自己的道理。当然你觉得是他是一个傻X领导，拍拍屁股走人就是；但如果你<strong>越职言事</strong>，那就是大忌了。</li>
<li>如果是你的平级，告知他上级代码的风险，之后就交给他的上级处理吧。</li>
</ul>
<p>当然你需要知道，为了权衡：有时为了紧急上线，有时为了更大的利，即使逾越了你的底线，也要先把代码merge了再说。</p>
<p>Code Review是为了什么？最终是为了获利。在公司，什么都不考虑，只为把代码写的完美无缺，那才是真的傻。</p>
<hr>
<h2><a href=""http://gitbook.cn/m/mazi/article/598282fb65b4f352972e9bfe?isLogArticle=yes&amp;readArticle=yes"" rel=""nofollow noreferrer"">实录：《帐前卒：代码如何评价实战解析》</a></h2>
<p><span class=""img-wrap""><img data-src=""/img/bVTSrW?w=640&amp;h=640"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 作为程序员，你该如何评价别人的代码？,1531977935,330,1,277,1,1,https://segmentfault.com/a/1190000010930963
67,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010867984"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>开头</h3>
<p>2017.08.21  正式开启我入职的里程，现在已是工作了一个星期了，这个星期算是我入职的过渡期，算是知道了学校生活和工作的差距了，总之，尽快习惯这种生活吧。下面讲下自己的找工作经历和大学阅读的书籍，算是一种书籍推荐，为还在迷茫的你指引方向，同时为我三年的大学生活致敬！也激励我大四在公司实习能更上一层楼！</p>
<h3>找工作经历</h3>
<p>这段经历，算是自己很难忘记的经历吧。既辛酸既充实的日子！也很感谢自己在这段时间的系统复习，感觉把自己的基础知识再次聚集在一起了，自己的能力在这一段时间提升的也很快。后面有机会的话我也想写一系列的相关文章，为后来准备工作（面试）的同学提供一些自己的帮助。自己在找工作的这段时间面过的公司也有几家大厂，但是结果都不是很好，对我自己有很大的压力，当时心里真的感觉 ：“自己真的有这么差”，为什么一直被拒，当时很怀疑自己的能力，自己也有总结原因。一是面试的时候自己准备的还不够充分，虽说自己脑子里对这些基础有点印象，但是面试的时候自己稍紧张下就描述不怎么清楚了，导致面试官觉得你可能广度够了，深度还不够（这是阿里面试官电话面试说的）；二是自己的表达能力还是有所欠缺，不能够将自己所要表达的东西说出来，这可能我要在后面加强的地方；三是我的学校问题，好些家公司面试官对我的学校都有问及，可能觉得我的学校在上海，但是觉得上海好像没这么个学校，在此澄清下，我的学校是华东交通大学，在南昌，不是在南昌，要说和上海交大有没有渊源，我只能说有，具体请去百度查。在面了几家公司失败后，终于面了家公司要我了，我也确定在这家公司了。很幸运，刚出来，就有一个很好（很负责）的架构师带我，这周就给了我一个很牛逼的项目给我看（虽然自己目前还没有思路改里面的代码），里面新东西很多，说吃透了这个项目，以后绝对可以拿出去吹逼（一脸正经.jpg）。目前我的找工作经历就简短的介绍到这里了，如果感兴趣的话，可以加群：528776268   进来和我讨论交流。</p>
<h3>书籍推荐</h3>
<p>大学，我不怎么喜欢玩游戏，自己也还算不怎么堕落吧，看了以下的一些书籍，算是对我后面写博客、找工作也有很大的帮助。如果你是大神，请忽略，如果你还是还在大学，和我一样不想把时间浪费在游戏上，可以看看我推荐的一些书籍，有想讨论的请在评论下留下你的评论或者加上面给的群号。</p>
<h4>Java</h4>
<p>1、《Java 核心技术》卷一 、卷二              两本书，算是入门比较好的书籍了</p>
<p>2、《疯狂 Java 讲义》                                很厚的一本书，里面的内容也是很注重基础了</p>
<p>3、《Java 并发编程的艺术》——  方腾飞 、魏鹏、程晓明著        方腾飞 是并发编程网的创始人，里面的文章确实还不错，可以多看看里面的文章，收获绝对很大。</p>
<p>4、《 Java多线程编程核心技术》——  高洪岩著   这本书也算是入门多线程编程的不错书籍，我之前还写了一篇读书笔记呢，<a href=""http://www.54tianzhisheng.cn/2017/06/04/Java-Thread/"" rel=""nofollow noreferrer"">《Java 多线程编程核心技术》学习笔记及总结</a>  , 大家如果不想看书的可以去看我的笔记。</p>
<p>5、《Java 并发编程实战》 这本书讲的有点难懂啊，不过确实也是一本很好的书，以上三本书籍如果都弄懂了，我觉得你并发编程这块可能大概就 OK 了，然后再去看看线程池的源码，了解下线程池，我觉得那就更棒了。不想看的话，请看我的博客：<a href=""http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/"" rel=""nofollow noreferrer"">Java 线程池艺术探索</a>  我个人觉得还是写的很不错，那些大厂面试也几乎都会问线程池的东西，然后大概内容也就是我这博客写的</p>
<p>6、《Effective Java》中文版 第二版       算是 Java 的进阶书籍了，面试好多问题也是从这出来的</p>
<p>7、《深入理解 Java 虚拟机——JVM高级特性与最佳实践》第二版     这算是国内讲 JVM 最清楚的书了吧，目前还是只看了一遍，后面继续啃，大厂面试几乎也是都会考 JVM 的，阿里面 JVM 特别多，想进阿里的同学请一定要买这本书去看。</p>
<p>8、《深入分析Java  Web技术内幕  修订版》许令波著   里面知识很广，每一章都是一个不同的知识，可见作者的优秀，不愧是阿里大神。</p>
<p>9、《大型网站系统与 Java 中间件实践》—— 曽宪杰 著    作者是前淘宝技术总监，见证了淘宝网的发展，里面的讲的内容也是很好，看完能让自己也站在高处去思考问题。</p>
<p>10、《大型网站技术架构 —— 核心原理与案例分析》 —— 李智慧 著   最好和上面那本书籍一起看，效果更好，两本看完了，提升思想的高度！</p>
<p>11、《疯狂Java.突破程序员基本功的16课》 李刚 著       书中很注重 Java 的一些细节，讲的很深入，但是书中的错别字特多，可以看看我的读书笔记：<a href=""http://www.54tianzhisheng.cn/2017/05/31/Java-16-lession/"" rel=""nofollow noreferrer"">《疯狂 Java 突破程序员基本功的 16 课》读书笔记</a></p>
<p>12、《Spring 实战》   Spring 入门书籍</p>
<p>13、《Spring 揭秘》—— 王福强  著   这本书别提多牛了，出版时期为 2009 年，豆瓣评分为 9.0 分，写的是真棒！把 Spring 的 IOC 和 AOP 特性写的很清楚，把 Spring 的来龙去脉讲的很全。墙裂推荐这本书籍，如果你想看 Spring，作者很牛，资深架构师，很有幸和作者有过一次交流，当时因为自己的一篇博客  <a href=""http://www.54tianzhisheng.cn/2017/03/27/Pyspider%E6%A1%86%E6%9E%B6%20%E2%80%94%E2%80%94%20Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%20V2EX%20%E7%BD%91%E7%AB%99%E5%B8%96%E5%AD%90/"" rel=""nofollow noreferrer"">Pyspider框架 —— Python爬虫实战之爬取 V2EX 网站帖子</a>，竟然找到我想叫我去实习，可惜了，当时差点就跟着他混了。作者还有一本书  《Spring Boot 揭秘》。</p>
<p>14、《Spring 技术内幕》—— 深入解析 Spring 架构与设计原理     讲解 Spring 源码，深入了内部机制，个人觉得还是不错的。</p>
<p>15、Spring 官方的英文文档          这个别提了，很好，能看英文尽量看英文</p>
<p>16、《跟开涛学 Spring 3》  《跟开涛学 Spring MVC》  京东大神，膜</p>
<p>17、《看透springMvc源代码分析与实践》    算是把 Spring MVC 源码讲的很好的了</p>
<p>见我的笔记：</p>
<p><a href=""http://www.54tianzhisheng.cn/2017/07/09/servlet/"" rel=""nofollow noreferrer"">1、通过源码详解 Servlet</a></p>
<p><a href=""http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC01/"" rel=""nofollow noreferrer"">2 、看透 Spring MVC 源代码分析与实践 —— 网站基础知识</a></p>
<p><a href=""http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC02/"" rel=""nofollow noreferrer"">3 、看透 Spring MVC 源代码分析与实践 —— 俯视 Spring MVC</a></p>
<p><a href=""http://www.54tianzhisheng.cn/2017/07/21/Spring-MVC03/"" rel=""nofollow noreferrer"">4 、看透 Spring MVC 源代码分析与实践 —— Spring MVC 组件分析</a></p>
<p>18、《Spring Boot 实战》</p>
<p>19、Spring Boot 官方 Reference Guide        网上好多写 SpringBoot 的博客，几乎和这个差不多。</p>
<p>20、《JavaEE开发的颠覆者: Spring Boot实战》</p>
<p>21、MyBatis 当然是官方的文档最好了，而且还是中文的。</p>
<p>自己也写过几篇文章，帮助过很多人入门，传送门：</p>
<p>1、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%B8%80"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis（一）</a>/)</p>
<p>2、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%BA%8C"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis（二）</a>/)</p>
<p>3、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%B8%89"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis（三）</a>/)</p>
<p>4、<a href=""http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E5%9B%9B"" rel=""nofollow noreferrer"">通过项目逐步深入了解Mybatis（四）</a>/)</p>
<p>22、《深入理解 Java 内存模型》—— 程晓明 著      我觉得每个 Java 程序员都应该了解下 Java 的内存模型，该书籍我看的是电子版的，不多，但是讲的却很清楚，把重排序、顺序一致性、Volatile、锁、final等写的很清楚。</p>
<h4>Linux</h4>
<p>《鸟哥的Linux私房菜 基础学习篇(第三版)  》</p>
<p>鸟哥的Linux私房菜：服务器架设篇(第3版)    鸟哥的书</p>
<h4>计算机网络</h4>
<p>《计算机网络第六版——谢希仁 编》</p>
<p>《计算机网络自顶向下方法》</p>
<h4>计算机系统</h4>
<p>《代码揭秘：从C／C.的角度探秘计算机系统 —— 左飞》</p>
<p>《深入理解计算机系统》</p>
<p>《计算机科学导论_佛罗赞》</p>
<h4>数据库</h4>
<p>《高性能MySQL》</p>
<p>《Mysql技术内幕InnoDB存储引擎》</p>
<h4>Python</h4>
<p>这门语言语法很简单，上手快，不过我目前好久没用了，都忘得差不多了。当时是看的廖雪峰的 Python 博客</p>
<p>自己也用 Python 做爬虫写过几篇博客，不过有些是在前人的基础上写的。感谢那些栽树的人！</p>
<h4>工具</h4>
<p>Git   ： 廖雪峰的 Git 教程</p>
<p>IDEA：<a href=""https://github.com/judasn/IntelliJ-IDEA-Tutorial"" rel=""nofollow noreferrer"">IntelliJ IDEA 简体中文专题教程</a></p>
<p>Maven：《Maven实战》</p>
<h4>其他</h4>
<p>《如何高效学习-斯科特杨》   教你怎样高效学习的</p>
<p>《软技能：代码之外的生存指南》    程序员除了写代码，还得懂点其他的软技能。</p>
<p>《提问的智慧“中文版”》</p>
<p><a href=""https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way"" rel=""nofollow noreferrer"">《How-To-Ask-Questions-The-Smart-Way》</a>   作为程序员的你，一定要学会咋提问，不然别人都不想鸟你。</p>
<h3>优秀网站推荐</h3>
<p>1、GitHub     别和我说不知道</p>
<p>2、InfoQ        文章很不错</p>
<p>3、CSDN    经常看博客专家的博客，里面大牛很多，传送门：<a href=""http://blog.csdn.net/tzs_1041218129"" rel=""nofollow noreferrer"">zhisheng</a></p>
<p>4、知乎         多关注些大牛，看他们吹逼</p>
<p>5、掘金        自己也在上面写专栏，粉丝已经超过一万了，传送门 ：<a href=""https://juejin.im/user/57510b82128fe10056ca70fc"" rel=""nofollow noreferrer"">zhisheng</a></p>
<p>6、并发编程网    前面已经介绍</p>
<p>7、developerworks     上面的博客也很好</p>
<p>8、博客园        里面应该大牛也很多，不过自己没在上面写过博客</p>
<p>9、微信公众号    关注了很多人，有些人的文章确实很好。</p>
<p>10、牛客网        刷笔试题不错的地方，里面大牛超多，怀念叶神和左神讲课的时候，还有很有爱的牛妹。</p>
<p>11、优秀博主的博客地址了</p>
<h3>优秀博客推荐</h3>
<p><a href=""https://www.liaoxuefeng.com/"" rel=""nofollow noreferrer"">廖雪峰</a>  Git 和 Python 入门文章就是从他博客看的</p>
<p><a href=""http://www.ruanyifeng.com/blog/"" rel=""nofollow noreferrer"">阮一峰的网络日志</a></p>
<p><a href=""https://coolshell.cn/"" rel=""nofollow noreferrer"">酷壳-陈皓</a></p>
<p><a href=""https://www.zhihu.com/people/rednaxelafx/answers"" rel=""nofollow noreferrer"">RednaxelaFX</a>   R大，牛逼的不得了</p>
<p><a href=""http://calvin1978.blogcn.com/"" rel=""nofollow noreferrer"">江南白衣</a>      老司机</p>
<p><a href=""http://stormzhang.com/"" rel=""nofollow noreferrer"">stormzhang</a>     人称帅逼张，微信公众号写的不错</p>
<p><a href=""http://lovestblog.cn/"" rel=""nofollow noreferrer"">你假笨</a>    阿里搞 JVM 的，很厉害</p>
<p><a href=""http://www.jianshu.com/u/90ab66c248e6"" rel=""nofollow noreferrer"">占小狼</a></p>
<p><a href=""http://www.bysocket.com/"" rel=""nofollow noreferrer"">泥瓦匠BYSocket</a></p>
<p><a href=""http://cuiqingcai.com/"" rel=""nofollow noreferrer"">崔庆才</a>   写了好多 Python 爬虫相关的文章</p>
<p><a href=""http://www.ityouknow.com/"" rel=""nofollow noreferrer"">纯洁的微笑</a>    SpringBoot 系列不错，其他的文章自己看了感觉是自己喜欢的那种文笔</p>
<p><a href=""http://blog.didispace.com/"" rel=""nofollow noreferrer"">程序猿DD</a></p>
<p><a href=""http://itmuch.com/"" rel=""nofollow noreferrer"">周立</a></p>
<p><a href=""https://www.yunai.me/"" rel=""nofollow noreferrer"">芋艿V的博客</a>     好多系列的源码分析</p>
<p><a href=""http://www.54tianzhisheng.cn/"" rel=""nofollow noreferrer"">zhisheng</a>       这个是我不要脸，竟然把自己博客地址的写上去了</p>
<h3>最后</h3>
<p>送一句话，<strong>越努力，越幸运，祝早日成为大神！</strong></p>
<hr>
<p>这些地方可以找到我：</p>
<ul>
<li>blog:  <a href=""http://www.54tianzhisheng.cn/"" rel=""nofollow noreferrer"">http://www.54tianzhisheng.cn/</a>
</li>
<li>GitHub: <a href=""https://github.com/zhisheng17"" rel=""nofollow noreferrer"">https://github.com/zhisheng17</a>
</li>
<li>QQ 群：528776268</li>
</ul>

                ", 那些年我看过的书 —— 致敬我的大学生活 —— Say Good Bye ！,1531977937,354,1,532,1,1,https://segmentfault.com/a/1190000010871122
68,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010805368"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""各种框架"" title=""各种框架""></span></p>
<p>最近看了一篇文章 <a href=""https://zhuanlan.zhihu.com/p/22782487"" rel=""nofollow noreferrer"">在 2016 年学 JavaScript 是一种什么样的体验？</a>。看完之后真是深有体会。以前上大学的时候觉得前端比较简单，最近入坑之后发现东西真的很多。</p>
<p>各种眼花缭乱的框架，让很多人患上了选择困难症。网上诸多类似的提问  <br>Angular，React，Vue学哪个好？  <br>jQuery会过时吗？是否还需要学习？</p>
<p>这两年市场上的 Hybird App、Web App 越来越多，不少公司看上了 <strong>一套框架，多种平台</strong> 的优点，转而让原 iOS、Android 的员工去学习相关知识。作为一个 iOS 开发，我也是这样入坑的。在维护 iOS 旧的原生项目的过程中，我需要尽快地掌握前端相关知识，好为公司开发新的 Web App。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010805369"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""前端"" title=""前端""></span></p>
<p>强迫使用新东西的过程是痛苦的，会有一种对于陌生事物的排斥。我也在告诉自己，多学点东西是好的，不要逃避。大概讲一下我学习的过程吧。</p>
<p>最初，我花了一周时间看完了一个网上的前端教学视频，并把视频中的项目代码敲一遍，使用笔记软件做上笔记。买了一本《JavaScript DOM 编程艺术》在家看。公司旧项目需要用 MUI 替换部分原生界面，并使用 Cordova 和原生进行交互，我边学边做慢慢也习惯了。</p>
<p>后来新项目确定要用 ionic2 来进行开发。我主要在官方文档，业余看了《图解HTTP》、《Angular 权威教程》、《JavaScript 高级程序设计》。也在网上看了一些 Promise、Rxjs 的电子书。慢慢的也算是能用 ionic2 进行一些开发工作了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010805370"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在网上看到过一句话，<code>现在前端的技术栈，不是一个新人能掌握的了的</code>。层出不穷的技术让浮躁的心静不下来，总感觉要学的东西多的让人绝望。这种感觉很不好受，但并不是我们放弃的理由。有的时候我也经常推迟自己的学习计划，因为人容易沉浸在自己心里的舒适区。</p>
<p>我们总会找到借口来安慰自己的拖延，比如 我太累了需要休息、我不在状态、我还没做好充分准备等等。然后就会自己接受自己的安慰，理所当然的跑去休息、玩游戏。人是好逸恶劳的，其实这些都属于身体的一种保护机制。我们如果想强迫自己做一些事情，需要一些方法来控制自己。<br><strong>下面分享一点学习经验，包括但不限于编程。</strong></p>
<blockquote>制定短期、可量化的目标</blockquote>
<p>为什么玩游戏这么爽，学习总学不进去，看代码这么心烦。玩游戏爽是因为他总会给你一个反馈，比如你杀掉这个怪得到 50 经验；你通关了拿到了 3 星评价等。所以我建议把学习计划拆成一些小目标，不要出现这些时间过长或者模棱两可的计划。如：</p>
<ul>
<li>3 个月内入门前端</li>
<li>掌握 Angular 框架</li>
</ul>
<p>这种目标根本无从下手，前几天兴致满满，后面马上就扔一边了。我们应该这么做，举个例子：</p>
<ul>
<li>我有一套前端视频，每天看两集</li>
<li>学习 React Native 官方文档，每天看两个章节</li>
<li>阅读一篇博客，并把示例代码再敲一遍</li>
</ul>
<blockquote>劳逸结合</blockquote>
<p>很简单，比如你可以告诉自己。今天的计划完成后，我马上去玩 LOL、Dota2、王者荣耀等。人不是机器，是需要娱乐的，天天看鸡汤打鸡血，反弹的时候会爆发极大的厌学、不想上班的情绪。</p>
<blockquote>使用笔记软件、写博客</blockquote>
<p>有道云笔记、印象笔记、OneNote 都是不错的笔记软件。把自己的计划写在上面、把常用的东西记录下来、把你学到的知识写在上面并按层级划分成体系。也许你会喜欢上记笔记。</p>
<p>如果学到了知识，把自己的东西写成博客分享出来，也是一件很棒的事情。不用怕写的东西没人看，也许就帮助到其他人了呢，没人看就当做云备份了哈哈。</p>
<blockquote>多写多练</blockquote>
<p>思而不学则殆，只看文档和视频绝对不可取，一定要<strong>多写代码、多写代码、多写代码</strong>。就算是简单的代码，多写慢慢都会有收获。有一些不理解的地方，写多了也许哪一天就突然顿悟了。</p>
<h2>最后</h2>
<p>有的朋友会觉得，我已经浪费了这么多时间，现在努力还来得及吗？送给你一句很常见的话。  <br><strong>种一棵树最好的时间是十年前，其次是现在。</strong></p>

                ", 程序员如何高效学习,1531977939,271,1,213,1,1,https://segmentfault.com/a/1190000010805365
69,1,0,9,"
                    
<p>近日看了一本&lt;程序员健康指南&gt;，觉得里面的一些建议还不错，整理一下。<br>不仅适用于程序员，也同样适用于其他上班族，因为大家目前的工作强度都很大，都需要更好去关注自己的身体，为以后的生活打下良好的基础，不要被工作掏空了身体~</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010544939"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>一些建议</h3>
<p>1 <strong>每天行走10000步</strong>，适当加快速度，最好可以达到最大心率的百分之60。<br>2 <strong>学会正确的行走姿势</strong>。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010544940"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>3 <strong>避免久坐</strong>，每坐1小时，起来活动5分钟。如果实在无法离开椅子上的话，做一些简单的动作，防止肌肉僵化。比如下图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010544941"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>腿部画圈<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010544942"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>抬升小腿<br>4 <strong>尝试站立式与坐式办公混合</strong>，可以借助一定的工具实现。<br>5 <strong>保持每天营养摄入的均衡</strong>。<br>30% 水果及蔬菜。<br>30% 的谷物及淀粉食物。<br>16%的精益蛋白质，比如肉类、鱼类、蛋类和豆类食品。<br>16%的牛奶及奶制品。<br>8%的脂肪及糖类食品。<br>6 <strong>避免不需要的进食</strong>，这个很有意思，在我们学习和工作的时候，只是看到有东西所以就吃了，但我们的身体其实并不需要，作者建议在进食前问自己这么几个问题。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010544943"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>7 <strong>预防眼部疲劳</strong>。经常眨眼，保持眼部湿润。工作20分钟后，眺望6米元的事物，持续20秒钟。<br>8 <strong>预防背部疲劳</strong>。在工作间隙，进行一些背部的活动。很重要的一点是保持正确的坐姿。如下图。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010544944"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>经常站起来活动一下。<br>9 <strong>预防手腕疲劳</strong>。工作1小时，活动一下手腕，做一些手腕绕圈的运动。<br>10 <strong>多到户外走走</strong>，呼吸新鲜空气。<br>11 <strong>找到锻炼的基友</strong>，作者建议最好能够形成几人的锻炼小队，起到互相督促进步的作用。<br>12 <strong>设定一个目标，并持之以恒</strong>。作者建议我们设立一个小目标，并且经常暗示自己要完成它，同时要坚持下去。不要一下子设立很高的健康目标，反而会压力过大，早早放弃。</p>
<h3>总结</h3>
<p>以上大致是阅读完本书后，从中提炼出来的一些观点，关于锻炼的具体动作以及在实践过程中应该注意的事项，大家可以自行购买本书去学习一下，总之一定要坚持。<br><strong>先定一个小目标，我定的第一个健康目标就是每坐1小时起来活动5-10分钟。</strong><br>你呢？ 欢迎留言，写下你的健康小目标，一起保护自己的身体。</p>

                ", 【程序员健康指南】读书笔记,1531977940,251,1,370,1,1,https://segmentfault.com/a/1190000010544934
70,1,0,9,"
                    
<p>由于在之前的公司做得不爽，于是我毅然决然的离职了，离职之后发生的许多事情，验证了我离职的正确性，至于之前公司发生的事情（我为什么离职）我不在此做说明。本文我以我这两年的一些工作进行说明。</p>
<h2>感谢</h2>
<p>首先感谢segmentfault @joyqi大大送了我一张《全球技术领导者峰会》的门票，对我实在是太好了；<br>然后感谢有赞 @vimac大大这几天和我聊让我开阔了整个技术圈的眼界；<br>另外一个，还是感谢上家公司给我带来的工作机会，让我在技术方面得以的一定的成长。</p>
<h2>上家公司收获</h2>
<p>我是15年6月份毕业的，毕业后就加入了这家公司，待了两年时间，这期间，技术能力具有一定的成长，但毕竟是小公司，技术眼界有限，并且一直是在做传统的PHP技术开发（此处也是技术眼界局限性），相对于目前流行的一些技术解决方案，并没有足够的技术认知。</p>
<p>大概是在我工作了一年之际，有幸接手了整个团队的管理工作，后面的一年时间，在管理能力上（主要还是沟通能力）得到了非常大的锻炼。也总结了8篇技术团队管理方面的笔记，并且在《全球技术领导者峰会》上听完各位大佬的技术团队管理经验总结之后，许多东西也得以了印证。</p>
<p>在团队管理期间，也基于当前公司的技术情况推出了一些新技术，并且也总结了程序开发的一些思想在团队内进行了培训和分享。</p>
<h2>@joyqi大大带我参加峰会收获</h2>
<p>整个峰会，我印象最深的就是有赞老总白鸦与CTO的对话，至少让我感觉这是一个非常人性化的公司。</p>
<p>技术团队管理也是以人为本，不同层次的技术管理引导的方向是不一样的，基层的技术管理需要以技术作为领导力，而CTO更应该与CEO进行协调展开工作，做技术性、产品性的战略性规划。</p>
<p>整个管理的其中细节，完全可以整理成一篇文章来进行分享，但由于最近在忙其他但一些事情，没有时间进行整理，不管怎么说，我也还是要抽空进行整理的，就当是对自己学习的一个回顾。</p>
<h2>关于眼界问题</h2>
<p>首先感谢@vimac约我到有赞线下体验店喝的咖啡。</p>
<p>这期间，我逛了有赞的办公区，真的挺感慨的，才意识到大公司是什么样的一个情况，大公司的氛围又是什么样的一个情况。</p>
<p>另外一个就是接触了zanphp框架（基于zan-extension进行开发的），才意识到真正的大数据业务应该是以什么样的思路进行处理。而同时里面涉及到的一些底层的东西，才知道之前在学校学的基础知识到底有什么用，感慨颇多。</p>
<p>学习zanphp的过程中，算是恶补了很多之前欠缺下来的知识吧，才知道自己的知识体系是什么样的。我觉得，人不怕自己目前的能力差，而是根本就不知道自己的未来方向是什么，根本不知道自己的努力方向。虽然感叹自己能力不足的地方，但同时也知道了自己的技术方向，知道了自己离真正的大牛到底有多远。</p>
<h2>离职感悟</h2>
<p>作为一个程序员，是没有那种文艺青年的艺术细胞在里面的，我也就不以什么文艺的方式进行描述了。</p>
<p>离职前，有幸能到segmentfault与@joyqi大大进行了面对面的聊，然后离职之后又和他一起参与了《技术领导者峰会》，然后又机缘巧合的认识了@vimac，总体来说，我觉得我还是很幸运的。认识他们才知道自己信息闭塞处，算是给自己的思维打开了一扇大门。</p>
<p>人生如爬山，到半山腰的时候，的确是应该停下来歇息一下的，才知道自己走了多少弯路，顺便把前路看得更清晰。</p>

                ", 离职感言——程序员的世界太神奇,1531977942,103,1,193,1,1,https://segmentfault.com/a/1190000010105958
71,1,0,9,"
                    
<p>最近 Webpack 核心开发者 Sean 同学想跟中国的开发者有更多的交流，有不少社区的同学喊我邀请 Sean 也来 SegmentFault 入驻，跟开发者一起交流，谈笑风生。这我当然是支持的了。在 SF 社区大V <a href=""/u/justjavac"" rel=""nofollow noreferrer"">@justjavac</a> 同学的引荐下，我跟 Sean 顺利的从微信上勾搭上了。是的他用微信，哈哈...我就用我那三脚猫的英文，跟他交流起来，说可以来 SF 一起跟中文的开发者交流。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVPYnk?w=449&amp;h=600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这个时候的美国时间应该是凌晨1点多，一看大神就是特别的努力，人家这个时间还在处理 GitHub issues，此处点赞！其实大神说他两天前已经注册了 SF 帐号了，正准备着上来跟社区的用户交流交流。一会儿，我就发现他开始回答问题了，666 ~~ </p>
<p>第一个中奖的问题是：<a href=""https://segmentfault.com/q/1010000009932567/a-1020000009962993"" rel=""nofollow noreferrer"">请问为什么webpack打包之后项目根目录下会出现0..，1..，2..的文件夹，有什么作用？</a></p>
<p>从网上找了一些资料简单介绍下 Sean Larkin，昵称 TheLarkInn，1988年出生，毕业于美国协和大学威斯康辛分校（Concordia University-Wisconsin）。 是 Webpack 的开发者，Angular 团队和 Angular-CLI 核心团队成员。</p>
<h5>重点，欢迎大家关注 Sean 在 <a href=""https://segmentfault.com/u/thelarkinn"" rel=""nofollow noreferrer"">SegmentFault 的个人主页</a>，目测后面他会经常跟中国的开发者交流，希望以后有机会 SF 邀请 Sean 直接来中国跟大家面对面交流。</h5>
<p>关于 Webpack 可以直接看这篇文章：《<a href=""https://segmentfault.com/a/1190000006178770"" rel=""nofollow noreferrer"">入门 Webpack，看这篇就够了</a>》</p>
<p><span class=""img-wrap""><img data-src=""/img/bVPYpG?w=800&amp;h=534"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>图中这位长发飘逸的小哥就是 Sean 了，图片来自他的 Linkedin 首页。</p>
<p>开发者其实越来越多的得到各行各业的重视，中国的开发者也在慢慢得到全球的关注了，硅谷现在很多大厂现在有越来越多的中国开发者就职。这几年面向开发者服务的公司也越来越多，越来越完善，相信中国的开发者环境会越来越好，SF 要做的就是在开发者领域继续坚持，为大家提供更好的技术交流和学习的平台，帮助中国的开发者成长。</p>

                ", Webpack 的核心开发者 Sean Larkin 入驻 SegmentFault 了,1531977944,526,1,479,1,1,https://segmentfault.com/a/1190000009964731
72,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVPhMv?w=900&amp;h=385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>不知不觉已是 6 月中旬了，掐指一算 2017 年已经过去了一半。过去的半年，也许你刚跳槽进入一家新公司，在一个全新的环境里学习和成长；也许你还是和去年一样，仍然奋斗在各种各样的项目和需求里，每天和产品、设计、运营打交道；也许你还在无休止的加班，每天忙忙碌碌却没有方向；也许你正在犹豫是否辞职，彷徨着不知道下一步要怎么走。</p>
<p>不管怎样，现在就可以让自己停下来，找一个清新的早餐，或者在某个安静的夜晚，重新审视自己，对工作、对生活做一个全面的复盘，重新规划，适时调整，更好的前行。</p>
<h2>生于忧患</h2>
<p>相信小伙伴们都还记得前不久网传华为辞退部分 34 岁以上员工的事。很多人不由感慨程序员也是青春饭，并开始思虑自己的未来，犹豫是不是要转行，担心自己 34 岁以后无处可去。</p>
<p><a href=""https://segmentfault.com/p/1210000009650055/read"" rel=""nofollow noreferrer"">程序员为什么会忧虑自己的未来?</a></p>
<blockquote><p>互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？</p></blockquote>
<p>“谁的青春不迷茫”，但其实迷茫不仅限于青春期，人生的每一个阶段都可能迷茫。</p>
<p><a href=""https://segmentfault.com/p/1210000008870278/read"" rel=""nofollow noreferrer"">三十岁程序员的迷茫</a></p>
<blockquote><p>回想自己这几年的迷茫，刚毕业那会迷茫要不要进入IT行业，要。工作两三年迷茫要不要离开家乡去互联网公司？去。来北京后，要不要跟着公司搞互联网金融，搞了。去年朋友说创业去不去，思索良久，么去；那么现在呢，要不要继续在北京吸霾，还是没有想好，要不要进入一个新的领域去拼搏，也是没想好？</p></blockquote>
<p>如果有一天，我们终将离开现在拼搏的城市，那我们将何去何从？</p>
<p><a href=""https://segmentfault.com/p/1210000008948720/read"" rel=""nofollow noreferrer"">除了北上广深，程序员的归宿还有哪些城市？</a></p>
<blockquote>
<p>我认为如果让我说出我心中中国互联网乃至移动互联网发展最好的十个城市排名，我会这么排：北京，深圳，上海，杭州，广州，成都，武汉，南京，西安，厦门。</p>
<p>如果除了北上广深，这四个一线城市外，让我推荐程序员最好的归宿和去的地方，首选应该是杭州，其次是成都，再次是武汉，然后是厦门。</p>
</blockquote>
<p>PS：从关注 SF 微信公众号的小伙伴们所在城市的分布来看，排名前十的分别是：北京、上海、杭州、武汉、深圳、广州、南京、成都、西安、厦门。</p>
<h2>所谓程序员</h2>
<p>要想不被淘汰，每个人都需要有自己的核心竞争力，有自己的存在的价值。而在发展变化如此之快的互联网行业，风口浪尖上的程序员们尤甚。</p>
<p><a href=""https://segmentfault.com/a/1190000006770379"" rel=""nofollow noreferrer"">何为技术人的核心竞争力</a></p>
<blockquote><p>我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他独特的个性知识经验组合。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，1，绝无仅有；2，在实践中有价值，3，具有可持续发展性，那你就具备核心竞争力。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009074969/read"" rel=""nofollow noreferrer"">【转】程序员该如何定位？看这四大方向</a></p>
<blockquote><p>定位能够产生目标，目标会让你聚焦在一个方向上，远离迷茫。所以，只要你根据自身的实际情况，找好定位，就拥有了摆脱迷茫的银弹。</p></blockquote>
<h2>博客</h2>
<p>和书籍一样，博客是知识最好的沉淀。</p>
<p><a href=""https://segmentfault.com/a/1190000004613367"" rel=""nofollow noreferrer"">我为什么坚持写博客？</a></p>
<blockquote>
<p>最后奉劝大家，如果你还没有写博客，那从现在开始开通个博客，走出第一步，如果你已经开始写博客了，不要去奢望靠写博客去赚钱，安心的写博客提升自己能力，总结经验，把它看成一种投资自己的手段，别把目标搞错了，也许有一天你会突然发现，原来你已经走了这么远，而且还有意外收获！</p>
<p>勿忘初心，才能方得始终！</p>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000002412576"" rel=""nofollow noreferrer"">阮一峰：为什么写博客？</a></p>
<blockquote><p>我的每一篇文章，通常需要2小时~6小时的写作时间。有时候写完以后，觉得特别累，都不想干别的事情了。不过，我还是觉得这是值得的。回过头看，我幸亏把时间花在写作博客上面，否则那些时间就白白过去了，没有留下任何印记。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000007954793"" rel=""nofollow noreferrer"">坚持写博一年半，我的收获与成长</a></p>
<blockquote>
<p>在2016年我主要做了两件事情，即编程与写作。在编程方面我主要把重点放在了JavaScript、Vue、React的学习与探究上，而在写作方面我主要发表了20余篇关于前端的原创技术文章。</p>
<p>古人云：学而不思则罔，思而不学则殆。在我看来编程与写作其实并不冲突，编程是一个学习与探究的过程，而写作则是一个分享与记录的过程，只有举一反三，方能为师矣。</p>
</blockquote>
<h2>书山有路</h2>
<p>互联网的发达几乎可以让我们在网上找到任何我们想要的信息，我们也越来越习惯碎片化的阅读和学习。但当我们想要全面、深入地去了解某一样技术、某一门语言的时候，仅有网上的碎片化信息是远远不够的。</p>
<p>“优秀的编程书是没有时间限制的。它们会超越语言的限制，IDE 的限制和平台的限制。它们不是解释 how，而是 why。”</p>
<p><a href=""https://segmentfault.com/p/1210000009791351/read"" rel=""nofollow noreferrer"">私以为可以提高程序员技术档次的书和博客</a></p>
<blockquote><p>为什么中国的程序员总是在不断学习新的开发工具、钻研程序代码，而不逐步提升自己的视野、思维和经验？</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002590273"" rel=""nofollow noreferrer"">【干货】程序员必读书单（上）</a></p>
<blockquote>
<p>本文把程序员所需掌握的关键知识总结为三大类19个关键概念，然后给出了掌握每个关键概念所需的入门书籍，必读书籍，以及延伸阅读。旨在成为最好最全面的程序员必读书单。</p>
<p>良好的程序设计能力：</p>
<ul>
<li><p>掌握常用的数据结构和算法（例如链表，栈，堆，队列，排序和散列）；</p></li>
<li><p>理解计算机科学的核心概念（例如计算机系统结构、操作系统、编译原理和计算机网络）；</p></li>
<li><p>熟悉至少两门以上编程语言（例如C++，Java，C#，和Python）；</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000002590271"" rel=""nofollow noreferrer"">【干货】程序员必读书单（下）</a></p>
<blockquote>
<p>专业的软件开发素养：</p>
<ul>
<li><p>具备良好的编程实践，能够编写可测试（Testable），可扩展（Extensible），可维护（Maintainable）的代码；</p></li>
<li><p>把握客户需求，按时交付客户所需要的软件产品；</p></li>
<li><p>理解现代软件开发过程中的核心概念（例如面向对象程序设计，测试驱动开发，持续集成，和持续交付等等）。</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000008037424/read"" rel=""nofollow noreferrer"">最简编程基本功指南 - 瀚阳的博客</a></p>
<blockquote>
<p>整理分为四大块：编程语言(能写代码)-&gt;程序设计(能写好代码)-&gt;计算机底层(能做别人做不到)-&gt;计算机理论(能做别人想不到)</p>
<p>不过以我的经历，实际过程中会螺旋上升，编程语言-&gt;程序设计-&gt;计算机底层-&gt;计算机理论-&gt;编程语言-&gt;…，因为一下啃完一整块是不现实的。</p>
</blockquote>
<h2>简历</h2>
<p><a href=""https://segmentfault.com/p/1210000008135913/read"" rel=""nofollow noreferrer"">写好一份技术简历很重要</a></p>
<blockquote>
<p>其实很多技术人员有很强的工程能力，但是不屑于上述的一些活动，个人觉得这是一个误区，只有有效和这个社会融合，才能获取更多有用的知识和体验，而具备这些能力，才能更好的为公司服务。</p>
<p>最后，如同写博客一样，将你写好的简历不断的修改和完善，直到自己满意，然后将简历投递给心仪的公司吧。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000008341468/read"" rel=""nofollow noreferrer"">程序员如何写好简历 &amp;&amp; 一份优秀的程序员简历是什么样的?</a></p>
<blockquote>
<p>简历就是简单的介绍一下你自己有多 NB。所以，你需要介绍以下的内容：</p>
<ul>
<li><p>我是谁。</p></li>
<li><p>我会什么。</p></li>
<li><p>做过什么。</p></li>
<li><p>结果如何。</p></li>
</ul>
<p>然后把这些内容放到一个模子里，就可以了。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000009791122"" rel=""nofollow noreferrer"">程序员简历应该怎么写？</a></p>
<blockquote><p>作为一个潜入 IT 圈五年之久、看过数万份简历的 HR，在这个问题上还是有点发言权的。HR 在筛选简历时主要从公司需求出发，重点不一，不过还是有很多“通用”的套路，为了在 30 秒内判断出这份简历是否值得跟进，我认为程序员写简历的正确姿势是这样的：</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000004338645"" rel=""nofollow noreferrer"">每个程序员都应该有个 Github 简历</a></p>
<blockquote><p>相信程序员对 Github 都不会陌生，你的 Github 也是自己的简历，在 Github 的贡献越大，对求职的帮助就越大，也能够慢慢增加自己的影响力。</p></blockquote>
<h2>面试</h2>
<p><a href=""https://segmentfault.com/a/1190000004482530"" rel=""nofollow noreferrer"">程序员找工作，应该怎么应对面试官？</a></p>
<blockquote><ul>
<li><p>面试过程中，应该注意哪些问题？</p></li>
<li><p>面试中遇到冷场怎么化解？</p></li>
<li><p>如何给面试官留下好印象？</p></li>
</ul></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009219036/read"" rel=""nofollow noreferrer"">如何在没有实际项目经验的情况下找到工作</a></p>
<blockquote><p>  对于许多年轻的计算机或 IT 相关专业毕业生，在没有实际项目开发经验的情况下找到第一份全职工作可能是你在职业生涯中遇到的最大的挑战。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009744700/read"" rel=""nofollow noreferrer"">程序员应聘/面试相关整理</a></p>
<blockquote>
<p>我整理这篇文章的重点不在于资源的整理，上面 4 点：面试前的准备——面试题库——大公司面试总结——面试相关的网站和书籍，我是按照先后顺序整理的。</p>
<ul>
<li><p>想要去应聘参加面试，首先当然得准备好简历以及自检技能咯；</p></li>
<li><p>然后再看看你所面试领域的一些题库，看看自己是否能够回答上来；</p></li>
<li><p>再者去针对性看看你要应聘的公司，看看以往面试者是怎样的一个流程以及问了一些什么问题之类的；</p></li>
<li><p>最后，如果以上几点都做了之后还觉得美准备好，那么可以找一些网站和书籍看看；</p></li>
</ul>
</blockquote>
<h2>英语这个硬伤</h2>
<p>如今英语对程序员而言，已经不仅仅是看懂国外的开发文档和技术博客这么简单了。无数的中国开发者走出国门，进入到各大世界顶级公司从事 IT 开发工作，参加各大开发者会议，和无数国外程序员交流合作。英语对于程序员来说，毫无疑问已经越来越重要了。</p>
<p>别让英语成为自己进步的硬伤。 </p>
<p><a href=""https://segmentfault.com/p/1210000009728394"" rel=""nofollow noreferrer"">程序员如何提高自身的英语水平</a></p>
<blockquote>
<p>在此之前，我不并不知道原来有那么多的同学在学习英语的道路上是一路走到黑的。 他们甚至从未想过：英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。</p>
<p>在这份指南里，我会尽可能地综合我主观的看法与一定的科学依据，为大家提供一份详尽的英语进阶指南，真心希望本指南能给你带来一点小小的帮助。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000009410481/read"" rel=""nofollow noreferrer"">程序员拿什么来学英语</a></p>
<blockquote><p>作为程序员，工作中不得不接触英语。如果你对一些新的技术或开源项目感兴趣，英语更是必不可少的。如果你不想花太多时间、精力和金钱去上学习班，又希望可以在日常生活和工作中去提高英语，那么希望这篇文章可以给你带来些帮助。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002453072"" rel=""nofollow noreferrer"">老码农教你学英语</a></p>
<blockquote><p>对于咱们这些高端大气、时刻需要和国际接轨的码农，英语的重要性自然是毋庸置疑的。尤其是那些胸怀大志的潜在大牛们，想在码农行业闯出一片天地，秒杀身边的小弟们，熟练掌握英语更是实现其目标最关键的因素之一。否则，试想在你捧着某出版社刚刚翻译出来的《JSP 高效编程》苦苦学习JSP模板的时候，你旁边的小弟却是拿着原版的《AngularJS in Action》学习开发单页面应用，虽然你们都同样认真地学习了一个月，可做出来东西的效果能一样吗？</p></blockquote>
<h2>软技能</h2>
<p>程序员走江湖必备。</p>
<p><a href=""https://segmentfault.com/p/1210000008133350"" rel=""nofollow noreferrer"">程序员怎么找到想要的资源？</a></p>
<blockquote>
<p>这篇文章从以下几个方面进行了整理和推荐，对新手小白自学找资料很实用：</p>
<ul>
<li><p>学新技术：想学新技术去哪里找教程？</p></li>
<li><p>找项目：想要开发项目，去哪里找点子？找教程？</p></li>
<li><p>找书籍：哪里可以找到免费的书籍？</p></li>
<li><p>交流探讨：遇到问题哪里可以交流？</p></li>
<li><p>其他：一些程序员相关</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000006445581/read"" rel=""nofollow noreferrer"">如何发现优秀的开源项目？</a></p>
<blockquote><p>GitHub 其中一个最重要的作用就是发现全世界最优秀的开源项目，你没事的时候刷刷微博、知乎，而人家没事的时候刷刷 GitHub ，看看最近有哪些流行的项目，久而久之，这差距就越来越大。那么如何发现优秀的开源项目呢？</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000003713616"" rel=""nofollow noreferrer"">整理一些好的开源项目</a></p>
<blockquote><p>通过这些项目你可以大幅度减少不必要的开发而将精力放在更重要的地方。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000007430781"" rel=""nofollow noreferrer"">16个小众却很实用的网站（程序员 向）</a></p>
<blockquote><p>16个相对来说比较小众，但是对程序员来说却有趣或者有用的网站</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000007422465/read"" rel=""nofollow noreferrer"">21个国外受欢迎的学习编程的网站：总有一个理由会让你爱上它们</a></p>
<blockquote><p>21个与学习编程有关的网站。 每个网站，我会作一些简单的介绍。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008434109"" rel=""nofollow noreferrer"">中国程序员容易发音错误的单词</a></p>
<blockquote><p>中国程序员容易发音错误的单词 (以美式发音为准, 非音标为字母发音)</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000008209343"" rel=""nofollow noreferrer"">研发团队GIT开发流程新人学习指南</a></p>
<blockquote><p>本文定位于为使用GIT标准分支开发流程的开发团队新人提供一份参考指南，其中的内容都是我们公司在研发团队初创时所遵循的一些开发流程标准，经过近一年的实践，虽说还有很多不足，但是随着团队经验的丰富和人员的扩张，我会适时地更新本文，分享我们在使用GIT开发流程中遇到的问题和解决方案。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008626219/read"" rel=""nofollow noreferrer"">《Git权威指南》GotGit 书稿开源</a></p>
<blockquote><p>2015年底，在为华为做咨询顾问一年多之后，我决定接受新的挑战，加入华为公司，成为这个拥有着最大的开发者群体的世界级公司的一员。 如何有效地在大公司内进行过知识的传递也是一个课题，我决定将这本书的书稿开源，惠及更多的开发者。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008914711/read"" rel=""nofollow noreferrer"">程序员优雅提问宝典《九步真经》 | 软技能</a></p>
<blockquote>
<p>基本口诀</p>
<ul>
<li><p>先靠自己、再靠别人</p></li>
<li><p>排除原因、礼貌问答</p></li>
<li><p>善于总结、手留余香</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000008317291/read"" rel=""nofollow noreferrer"">程序员如何提一个好问题？</a></p>
<blockquote>
<p>我实际上是那种总是会问出愚蠢问题或“不好”问题的大信徒。我一直在问人们一些愚蠢并且完全可以通过谷歌搜索或搜索代码库解决的问题。大多数时候我都不愿意自己去搜索解决，但有的时候我又会无论如何都自己去搞定，而且也不会认为这如同世界末日一样可怕。</p>
<p>所以本文中列举的各个策略不是关于“在提问之前你必须要做的所有事情”，而是“一些可以帮助提出更好的问题并得到我想要的答案的要点！”。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000008895830/read"" rel=""nofollow noreferrer"">程序员，你真的会解决问题吗？</a></p>
<blockquote><p>作为一枚程序员，我们天生就是来解决问题的。在你不知道你的问题之前，我帮不了你，Google 也不能帮你解决问题。</p></blockquote>
<h2>积跬步，致千里</h2>
<p>大神不是一天练成的。</p>
<p><a href=""https://segmentfault.com/p/1210000007129330/read"" rel=""nofollow noreferrer"">工程师成长之路：工作1-3年工程师如何突破瓶颈期？</a></p>
<blockquote>
<p>成熟期是整个职业生涯中最关键的时期，快的可能一两年就能走过去；慢的，可能整个职业生涯都定格在成熟期。</p>
<p>从上面分析中可以看到，这些问题最终都和“心”相关。要想高速成长，就得克服掉温水中的舒适。要想提高自信，还得思考成就感获取渠道这么虚头巴脑的问题。所以要想迈过去这个坎儿，必须有一颗非常强大的内心。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000008388899/read"" rel=""nofollow noreferrer"">面试感悟：一名3年工作经验的程序员应该具备的技能</a></p>
<blockquote><p>每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008854266/read"" rel=""nofollow noreferrer"">天天写业务代码，如何成为技术大牛？</a></p>
<blockquote>
<p>成为技术大牛梦想固然很美好，但是要付出很多，不管是Do more还是Do better还是Do exercise，都需要大量花费时间和精力，这个过程中可能很苦逼，也可能很枯燥。</p>
<p>这里我想特别强调一下：前面所讲的都是一些方法论的东西。但真正起决定作用的，其实还是我们对技术的热情和兴趣！</p>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000009201146"" rel=""nofollow noreferrer"">当当架构部张亮：从码农到大牛，技术与心境的双重提升</a></p>
<blockquote><p>只有保持足够的兴趣才能在技术上走得更远。如果做技术无法体会快乐，完全是为了养家糊口而被迫走上这条路，相信很难在漫长的职业生涯中有足够的动力持续成长。世界很精彩，不喜欢做技术的人不一定非要做技术，如果最终一定要转行，越早就越能在新的行业中掌握主动权。</p></blockquote>
<h2>心经</h2>
<p><a href=""https://segmentfault.com/p/1210000007007052/read"" rel=""nofollow noreferrer"">「代码家」的学习过程和学习经验分享</a></p>
<blockquote><p>目前能想到的一些学习的技巧和陷阱，大致都列了出来。都是我个人的一些学习的经验，如果对你有帮助，想必也是极好的，如果你觉得我写的有不合理的地方也欢迎指出。坚持着去实施提及的一些方法，一定会对你的生活和职业带来改变。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000008526301/read"" rel=""nofollow noreferrer"">技术大牛养成指南，一篇不鸡汤的成功学实践</a></p>
<blockquote><p>有的人想成为大牛，却不曾为此努力。有的人辛苦耕耘，却收获寥寥。很多时候，你跟成功的差距并不是能力，也不是运气，或许只是正确的方法？这是一篇不鸡汤的成功学指南，如果你相信且愿意坚持尝试，未必帮不到你！</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009164379/read"" rel=""nofollow noreferrer"">[译] 我是如何成为一名更优秀的程序员的</a></p>
<blockquote>
<p>关于我的一些详细信息：我现年32岁，有10年以上扎实的工作经验。直到最近几年我才对自己所做的工作充满信心。即使是现在，我也在不断质疑自己。问题在于，这种质疑并不会消失，所以你要做的就是无视它，不断的解决问题，不断的积累经验。</p>
<p>首先我要说明的是以下提到的只是一些帮你提升技能的小贴士。最终你还是需要找到一条最适合你自己的路。这些只是我发现对我有帮助的点。</p>
</blockquote>
<p><a href=""https://segmentfault.com/p/1210000007215374/read"" rel=""nofollow noreferrer"">论程序员的自我修养</a></p>
<blockquote><p>我想说的是，本篇里面分享的一些道理和方法，都是通俗易懂的，就和常听到的例如101%和99%的365次方的故事、1万小时的道理等等一样，但真正去认真思考并实践的屈指可数，也许，坚持才是程序员最大的修养，和各位共勉！</p></blockquote>
<h2>出任 CTO</h2>
<p>程序员的未来在哪里？当然是“出任CTO，迎娶白富美，走上人生巅峰！”，想想是不是有点小激动？</p>
<p><a href=""https://segmentfault.com/a/1190000005974376"" rel=""nofollow noreferrer"">魔都，3 年，程序员到 CTO</a></p>
<blockquote>
<ul>
<li><p>以前的我，只会一味的阅读技术书籍，沉迷于技术。</p></li>
<li><p>以前的我，不喜欢和不熟悉的人聊天，甚至有些偏内向。</p></li>
<li><p>以前的我，只会用最快的速度完成安排下来的任务。</p></li>
<li><p>以前的我，只关注自我成长。</p></li>
</ul>
<ul>
<li><p>现在的我，阅读的书籍类型有管理，心理，商业，人文。</p></li>
<li><p>现在的我，喜欢和人聊天，倾听，讨论，分享自己的想法。</p></li>
<li><p>现在的我，在接到任务之前更多的是思考是否合理，有没有更好的解决方案。</p></li>
<li><p>现在的我，关注团队每个人的成长。</p></li>
</ul>
</blockquote>
<p><a href=""https://segmentfault.com/a/1190000006723431"" rel=""nofollow noreferrer"">4 年前端狗，2 年 CTO</a></p>
<blockquote><p>在工作 2 年左右，我发现自己在技术深度上很难有专业造诣的时候，我开始把眼光放的更长远，我不再把自己仅仅定位成一个前端工程师，而是会开始关心互联网的发展趋势与整体格局，关心产品从 0 到 1 诞生过程中的盈利模式，关心在产品迭代中工程师与运营多方参与的角度和结合的效率，关心工作流程和团队文化，这一切其实都是我潜意识不自觉的关注，是一种不安分，过后很久才逐渐意识到自己早就在默默铺路，有时候一个选择早就做了，只是你还未意识到。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000003725944"" rel=""nofollow noreferrer"">Coding CTO 孙宇聪：《人，技术与流程》</a></p>
<blockquote><p>从 Google 回来在 Coding 做 CTO，对我来说也是人生的一个大改变。最近我在知乎看到一个好问题，“从大公司离开到小公司当 CTO 是怎样的体验”，我摘抄了一个好答案：“ 顶着 CTO 的名号，招聘，培训，鼓励程序猿，拉网线，查机房，装系统这都是 CTO 要做的事；讨论方案，推方案，定方案，确定进度，拖延进度，安抚程序猿，挨老板骂，安抚老板，这也是 CTO 的职务。” 不包括 Coding，而我的工作还包括 Coding，很伤心。(笑)</p></blockquote>
<h2>致程序媛</h2>
<p>虽然程序媛们没有程序员鼓励师，但我们自己就是自己的鼓励师。程序媛们正在创造越来越多的可能。PPS：SF 微信公众号的关注者中有 20% 是程序媛～加油吧程序媛们，请为自己自豪！</p>
<p><a href=""https://segmentfault.com/a/1190000000324821"" rel=""nofollow noreferrer"">历史上首位程序员是一名女性</a></p>
<blockquote><p>在男性占据技术行业统治地位的今天，人们恐怕难以想象，历史上首位电脑程序员竟然是一名女性！在1842年，人称“数字女王”的阿达-奥古斯塔（Ada Lovelace）编写了历史上首款电脑程序。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009376150/read"" rel=""nofollow noreferrer"">冯怡：我想给大家展示一种可能性（图灵访谈）</a></p>
<blockquote>
<p>我觉得就是社会上的social stereotype，这种固有偏见会打消一些姑娘想要成为程序员的想法。她们会听到很多声音：你不适合，或者你做不好，或者说这个很累，坚持不下来，这会导致一件事情在还没开始的时候，就被否定掉了。</p>
<p>我是那种“反着来”的类型，越是说我不行，我就越要证明自己可以。</p>
</blockquote>
<h2>最后</h2>
<p>小时候，我们以为能够改变世界的人只有极少数的科学家。然而今天，互联网正在以几何级的速度改变着世界，改变着我们的生活。“程序员是世界上少有的能改变世界的人”，而每天坐在电脑前敲代码的我们就是这其中的一员。</p>
<p>“这是最好的时代，也是最坏的时代”。我们生于这个世界，也终将改变这个世界。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP744?w=1906&amp;h=886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ",  SegmentFault 技术周刊 Vol.26 - 年中复盘 --- 程序员的自我修养,1531977946,581,1,674,1,1,https://segmentfault.com/a/1190000009781697
73,1,0,9,"
                    
<h2>目录</h2>
<ul>
<li><p>介绍</p></li>
<li><p>官网及文档</p></li>
<li><p>中文社区</p></li>
<li><p>教程 &amp; 文章</p></li>
<li><p>开源库和框架</p></li>
<li><p>Demo</p></li>
<li><p>其他</p></li>
</ul>
<hr>
<h2>介绍</h2>
<p>今天凌晨的 Google I/O 上，Google 正式宣布官方支持 Kotlin. 为了让大家更快了解和上手 Kotlin，<a href=""https://juejin.im?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">掘金技术社区</a>为大家整理了这份 Kotlin 资源大全，希望可以帮助大家用最短时间学习 Kotlin.</p>
<hr>
<h2>官网及文档</h2>
<ul>
<li><p><a href=""https://kotlinlang.org/"" rel=""nofollow noreferrer"">Kotlin 官网</a></p></li>
<li><p><a href=""https://kotlinlang.org/docs/reference/"" rel=""nofollow noreferrer"">Kotlin 文档</a></p></li>
<li><p><a href=""http://www.kotlincn.net/docs/reference/"" rel=""nofollow noreferrer"">Kotlin 文档中文版</a></p></li>
<li><p><a href=""https://github.com/JetBrains/kotlin"" rel=""nofollow noreferrer"">Kotlin on GitHub</a></p></li>
</ul>
<hr>
<h2>中文社区</h2>
<ul><li><p><a href=""https://juejin/im?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">掘金技术社区</a></p></li></ul>
<hr>
<h2>教程 &amp; 文章</h2>
<h3>视频教程</h3>
<ul><li><p><a href=""https://juejin.im/entry/584f37c4a22b9d0058ea1715/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin 系列视频教程</a></p></li></ul>
<h3>开始用 Kotlin 之前</h3>
<ul>
<li><p><a href=""https://juejin.im/entry/591d6805a0bb9f005f22f33d/detail"" rel=""nofollow noreferrer"">将 Kotlin 用于生产环境：你在犹豫什么？</a></p></li>
<li><p><a href=""https://juejin.im/entry/591ce8aca0bb9f005f1bedb6/detail"" rel=""nofollow noreferrer"">为什么我要改用 Kotlin？</a></p></li>
<li><p><a href=""https://juejin.im/entry/58df4ef7a0bb9f0069e303c5/detail"" rel=""nofollow noreferrer"">用 Kotlin 开发 Android 项目是一种什么样的感受？</a></p></li>
<li><p><a href=""https://juejin.im/entry/58e4c1f22f301e0062275139/detail"" rel=""nofollow noreferrer"">用 Kotlin 开发 Android 项目是一种什么样的感受？（二）</a></p></li>
</ul>
<h3>Kotlin 语言程序设计</h3>
<ul>
<li><p><a href=""https://juejin.im/entry/5893ff2f8d6d81006c4a9565/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin Primer · 第一章 · 启程</a></p></li>
<li><p><a href=""https://juejin.im/entry/58955ed9b123db16a395cf9b/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin Primer · 第二章 · 基本语法</a></p></li>
<li><p><a href=""https://juejin.im/entry/589aaab11b69e60059aa0b1e/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin Primer · 第三章 · Kotlin 与 Java 混编</a></p></li>
<li><p><a href=""https://juejin.im/entry/58b3d0ba8fd9c50063e142f8/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin Primer · 第四章 · 类特性</a></p></li>
<li><p><a href=""https://juejin.im/entry/58fcaab95c497d005800743c/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin Primer · 第五章 · 函数与闭包</a></p></li>
</ul>
<h3>上手 Kotlin</h3>
<ul>
<li><p><a href=""https://juejin.im/entry/58c79d591b69e6006bebfd41/detail"" rel=""nofollow noreferrer"">快速上手 Kotlin 的 11 招</a></p></li>
<li><p><a href=""https://juejin.im/post/59006ef95c497d00581a8d7c"" rel=""nofollow noreferrer"">Kotlin 初探</a></p></li>
<li><p><a href=""https://juejin.im/entry/587ce6198d6d810058d47242/detail"" rel=""nofollow noreferrer"">用 Kotlin 写 Android 01 难道只有环境搭建这么简单？</a></p></li>
<li><p><a href=""https://juejin.im/entry/58857f978fd9c50067fc404d/detail"" rel=""nofollow noreferrer"">用 Kotlin 写 Android 02 说说 Anko</a></p></li>
</ul>
<h3>Kotlin &amp; Java</h3>
<ul>
<li><p><a href=""https://juejin.im/entry/5858c87161ff4b006cb7a7e1/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin 与 Java 共存 (1)</a></p></li>
<li><p><a href=""https://juejin.im/entry/5858c8f78d6d810065c21a2c/detail?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">Kotlin 与 Java 共存 (2)</a></p></li>
<li><p><a href=""https://juejin.im/post/583b042461ff4b007ecf00ff"" rel=""nofollow noreferrer"">告别 Java，一起来使用kotlin开发完整客户端</a></p></li>
<li><p><a href=""https://juejin.im/entry/58e19fd12f301e006214b88c/detail"" rel=""nofollow noreferrer"">Kotlin 兼容 Java 遇到的最大的 “坑”</a></p></li>
</ul>
<h3>开发实践</h3>
<ul>
<li><p><a href=""https://juejin.im/entry/5910833eac502e0065523c34/detail"" rel=""nofollow noreferrer"">研究学习 Kotlin 的一些方法</a></p></li>
<li><p><a href=""https://juejin.im/entry/588ff7cd2f301e0069fd4fec/detail"" rel=""nofollow noreferrer"">深入理解 Kotlin Coroutine（一）</a></p></li>
<li><p><a href=""https://juejin.im/entry/58985f392f301e0069195409/detail"" rel=""nofollow noreferrer"">深入理解 Kotlin Coroutine（二）</a></p></li>
<li><p><a href=""https://juejin.im/entry/58c79d20a22b9d0058baba9a/detail"" rel=""nofollow noreferrer"">Kotlin Script 及其运行机制简析</a></p></li>
<li><p><a href=""https://juejin.im/entry/58f42b595c497d006c940e12/detail"" rel=""nofollow noreferrer"">Kotlin Native 详细体验，你想要的都在这儿</a></p></li>
<li><p><a href=""https://juejin.im/entry/591adc7ca0bb9f005f079bcd/detail"" rel=""nofollow noreferrer"">Kotlin 一个很厉害的 DSL 写法</a></p></li>
<li><p><a href=""https://juejin.im/post/58fd31dd8d6d8100589813bf"" rel=""nofollow noreferrer"">如何正确终止 forEach</a></p></li>
<li><p><a href=""http://itangqi.me/2017/03/28/using-kotlin-for-android-development/"" rel=""nofollow noreferrer"">Using Kotlin for Android Development</a></p></li>
</ul>
<h3>更多</h3>
<ul><li><p><a href=""https://juejin.im/tag/Kotlin?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">阅读更多 Kotlin 相关经验文章</a></p></li></ul>
<hr>
<h2>开源库和框架</h2>
<h3>Android 开发</h3>
<ul>
<li><p><a href=""https://github.com/pawegio/KAndroid"" rel=""nofollow noreferrer"">KAndroid</a> - Kotlin library for Android</p></li>
<li><p><a href=""https://github.com/TouK/bubble"" rel=""nofollow noreferrer"">Bubble</a> - 屏幕方向监测</p></li>
<li><p><a href=""https://github.com/chibatching/Kotpref"" rel=""nofollow noreferrer"">Kotpref</a> - Android SharedPreference delegation for Kotlin.</p></li>
<li><p><a href=""https://github.com/kittinunf/Fuse"" rel=""nofollow noreferrer"">Fuese</a> - The simple generic LRU memory/disk cache for Android</p></li>
</ul>
<h3>Web 开发</h3>
<ul>
<li><p><a href=""https://github.com/Kotlin/ktor"" rel=""nofollow noreferrer"">ktor</a> - 用 Kotlin 写的 Web 后端开发框架</p></li>
<li><p><a href=""http://karaframework.com/"" rel=""nofollow noreferrer"">Kara</a> - MVC 开发框架</p></li>
<li><p><a href=""https://github.com/MarioAriasC/KotlinPrimavera"" rel=""nofollow noreferrer"">KotlinPrimavera</a> - KotlinPrimavera is a set of Kotlin libraries to support Spring portfolio projects</p></li>
<li><p><a href=""https://github.com/jean79/yested"" rel=""nofollow noreferrer"">Yested</a> - 用来开发 SPA 应用的框架</p></li>
<li><p><a href=""https://github.com/kohesive/kovert"" rel=""nofollow noreferrer"">Kovert</a> - The invisible REST and web framework</p></li>
<li><p><a href=""https://github.com/jaguililla/hexagon"" rel=""nofollow noreferrer"">HEXAGON</a> - 微服务框架</p></li>
<li><p><a href=""https://github.com/gimlet2/kottpd"" rel=""nofollow noreferrer"">kottpd</a> - REST framework written in pure Kotlin</p></li>
</ul>
<h3>网络</h3>
<ul>
<li><p><a href=""https://github.com/kittinunf/Fuel"" rel=""nofollow noreferrer"">Fuel</a> - The easiest HTTP networking library for Kotlin/Android.</p></li>
<li><p><a href=""https://github.com/wasabifx/wasabi"" rel=""nofollow noreferrer"">Wasabi</a> - HTTP 框架</p></li>
<li><p><a href=""https://github.com/jkcclemens/khttp"" rel=""nofollow noreferrer"">khttp</a> - khttp is a simple library for HTTP requests in Kotlin.</p></li>
</ul>
<h3>依赖注入</h3>
<ul>
<li><p><a href=""https://github.com/JakeWharton/kotterknife"" rel=""nofollow noreferrer"">Kotter Knife</a> - View ""injection"" library for Android</p></li>
<li><p><a href=""https://github.com/square/kotlinpoet"" rel=""nofollow noreferrer"">KotlinPoet</a></p></li>
<li><p><a href=""https://github.com/kohesive/injekt"" rel=""nofollow noreferrer"">injekt</a> - Kotlin 依赖注入</p></li>
<li><p><a href=""https://github.com/SalomonBrys/Kodein"" rel=""nofollow noreferrer"">Kodein</a> - 让你的 Kotlin 实现无痛依赖注入</p></li>
</ul>
<h3>函数式编程</h3>
<ul>
<li><p><a href=""https://github.com/ReactiveX/RxKotlin"" rel=""nofollow noreferrer"">RxKotlin</a></p></li>
<li><p><a href=""https://github.com/MarioAriasC/funKTionale"" rel=""nofollow noreferrer"">funKTionale</a> - Functional constructs for Kotlin</p></li>
<li><p><a href=""https://github.com/kittinunf/Result"" rel=""nofollow noreferrer"">Result</a> - The modelling for success/failure of operations in Kotlin</p></li>
</ul>
<h3>JSON</h3>
<ul><li><p><a href=""https://github.com/cbeust/klaxon"" rel=""nofollow noreferrer"">Klaxon</a> - 一个解析 JSON 的库</p></li></ul>
<h3>数据库</h3>
<ul>
<li><p><a href=""https://github.com/JetBrains/Exposed"" rel=""nofollow noreferrer"">Exposed</a> - Kotlin SQL 库</p></li>
<li><p><a href=""https://github.com/cheptsov/kotlin-nosql"" rel=""nofollow noreferrer"">Kotlin NoSQL</a> - NoSQL database query and access library for Kotlin</p></li>
<li><p><a href=""https://github.com/seratch/kotliquery"" rel=""nofollow noreferrer"">KotliQuery</a> - A handy Database access library in Kotlin</p></li>
</ul>
<h3>测试</h3>
<ul>
<li><p><a href=""http://spekframework.org/"" rel=""nofollow noreferrer"">Spek</a> -     A Specification Framework</p></li>
<li><p><a href=""https://github.com/npryce/hamkrest"" rel=""nofollow noreferrer"">HamKrest</a> - Hamcrest for Kotlin</p></li>
<li><p><a href=""https://github.com/ntaro/knit"" rel=""nofollow noreferrer"">Knit</a> - JUnit API set for Kotlin</p></li>
<li><p><a href=""https://github.com/kotlintest/kotlintest"" rel=""nofollow noreferrer"">KotlinTest</a> - Kotlin 测试框架</p></li>
</ul>
<h3>构建工具</h3>
<ul><li><p><a href=""http://beust.com/kobalt/home/index.html"" rel=""nofollow noreferrer"">Kobalt</a> - 一个用 Kotlin 写的多功能构建工具</p></li></ul>
<h3>编辑器</h3>
<ul>
<li><p><a href=""https://github.com/vkostyukov/kotlin-sublime-package"" rel=""nofollow noreferrer"">Sublime Package</a> - Sublime Text 2 Package for Kotlin Programming Language</p></li>
<li><p><a href=""https://github.com/udalov/kotlin-vim"" rel=""nofollow noreferrer"">kotlin-vim</a> - Kotlin 语法高亮 for Vim</p></li>
</ul>
<h3>其他</h3>
<ul>
<li><p><a href=""https://github.com/MehdiK/Humanizer.jvm"" rel=""nofollow noreferrer"">Humanizer.jvm</a> - Humanizer Library</p></li>
<li><p><a href=""https://github.com/leprosus/kotlin-hashids"" rel=""nofollow noreferrer"">Hashids.kt</a> - Kotlin hashids hash function</p></li>
<li><p><a href=""https://github.com/hotchemi/khronos"" rel=""nofollow noreferrer"">khronos</a> - An intuitive Date extensions in Kotlin.</p></li>
</ul>
<hr>
<h2>Demo</h2>
<h3>Android 客户端</h3>
<ul>
<li><p><a href=""https://github.com/githubwing/GankClient-Kotlin"" rel=""nofollow noreferrer"">GankClient-Kotlin</a> - 用 Kotlin 写的 Gank 客户端</p></li>
<li><p><a href=""https://github.com/TonnyL/FanfouHandpick"" rel=""nofollow noreferrer"">饭否精选</a> - 使用 Kotlin 开发的饭否精选 App</p></li>
</ul>
<hr>
<h2>其他</h2>
<h3>维护</h3>
<ul>
<li><p>本文档将由<a href=""https://juejin.im?utm_source=awesome_kotlin&amp;utm_medium=jjzl"" rel=""nofollow noreferrer"">掘金</a>长期更新，也欢迎更多 Kotlin 开发者参与维护。</p></li>
<li><p>联系方式：liutao@xitu.io</p></li>
</ul>
<h3>kotlin 开发交流群</h3>
<p>扫描二维码添加小编好友，备注：kotlin，稍后会拉你进群</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009477717"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", Kotlin 资源大全,1531977948,329,1,579,1,1,https://segmentfault.com/a/1190000009477714
74,1,0,9,"
                    
<p>作为前端开发者，你会感受到JS中对象(Object)这个概念的强大。我们说“JS中一切皆对象”。最核心的特性，例如从String，到数组，再到浏览器的APIs，“对象”这个概念无处不在。<a href=""https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects"" rel=""nofollow noreferrer"">在这里</a>你可以了解到JS Objects中的一切。</p>
<p>同时，随着React的强势崛起，不管你有没有关注过这个框架，也一定听说过一个概念—不可变数据(immutable.js)。究竟什么是不可变数据？这篇文章会从JS源头—对象谈起，让你逐渐了解这个函数式编程里的重要概念。</p>
<p>JS中的对象是那么美妙：我们可以随意复制他们，改变并删除他们的某项属性等。但是要记住一句话：</p>
<blockquote><p>“伴随着特权，随之而来的是更大的责任。”<br>(With great power comes great responsibility)</p></blockquote>
<p>的确，JS Objects里概念太多了，我们切不可随意使用对象。下面，我就从基本对象说起，聊一聊不可变数据和JS的一切。</p>
<p>这篇文章缘起于Daniel Leite在2017年3月16日的<a href=""https://www.ckl.io/blog/objects-immutability-javascript/"" rel=""nofollow noreferrer"">新鲜出炉文章：Things you should know about Objects and Immutability in JavaScript</a>，我进行了大致翻译并进行大范围“改造”，同时改写了用到的例子，进行了大量更多的扩展。</p>
<h2>“可变和共享”是万恶之源</h2>
<p>不可变数据其实是函数式编程相关的重要概念。相对的，函数式编程中认为可变性是万恶之源。但是，为什么会有这样的结论呢？</p>
<p>这个问题可能很多程序员都会有。其实，如果你的代码逻辑可变，不要惊慌，这并不是“政治错误”的。比如JS中的数组操作，很对都会对原数组进行直接改变，这当然并没有什么问题。比如：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
arr.splice(1, 1); // 返回[2];
console.log(arr); // [1, 3, 4, 5];
</code></pre>
<p>这是我们常用的“删除数组某一项”的操作。好吧，他一点问题也没有。</p>
<p>问题其实出现在“滥用”可变性上，这样会给你的程序带来“副作用”。先不必关心什么是“副作用”，他又是一个函数式编程的概念。</p>
<p>我们先来看一下代码实例：</p>
<pre><code>const student1 = {
    school: 'Baidu',
    name: 'HOU Ce',
    birthdate: '1995-12-15',
}

const changeStudent = (student, newName, newBday) =&gt; {
    const newStudent = student;
    newStudent.name = newName;
    newStudent.birthdate = newBday;
    return newStudent;
}

const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');

// both students will have the name properties
console.log(student1, student2);
// Object {school: ""Baidu"", name: ""YAN Haijing"", birthdate: ""1990-11-10""} 
// Object {school: ""Baidu"", name: ""YAN Haijing"", birthdate: ""1990-11-10""}
</code></pre>
<p>我们发现，尽管创建了一个新的对象student2，但是老的对象student1也被改动了。这是因为JS对象中的赋值是“引用赋值”，即在赋值过程中，传递的是在内存中的引用(memory reference)。具体说就是“栈存储”和“堆存储”的问题。具体图我就不画了，理解不了可以单找我。</p>
<h2>不可变数据的强大和实现</h2>
<p>我们说的“不可变”，其实是指保持一个对象状态不变。这样做的好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。<br>函数式编程认为：</p>
<blockquote><p>只有纯的没有副作用的函数，才是合格的函数。</p></blockquote>
<p>好吧，现在开始解释下“副作用”(Side effect)：</p>
<p>在计算机科学中，函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。<br>－维基百科</p>
<p>函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p>
<p>那么我们避免副作用，创建不可变数据的主要实现思路就是：一次更新过程中，不应该改变原有对象，只需要新创建一个对象用来承载新的数据状态。</p>
<p>我们使用纯函数(pure functions)来实现不可变性。纯函数指无副作用的函数。<br>那么，具体怎么构造一个纯函数呢？我们可以看一下代码实现，我对上例进行改造：</p>
<pre><code>const student1 = {
    school: ""Baidu"", 
    name: 'HOU Ce',
    birthdate: '1995-12-15',
}

const changeStudent = (student, newName, newBday) =&gt; {
    return {
        ...student, // 使用解构
        name: newName, // 覆盖name属性
        birthdate: newBday // 覆盖birthdate属性
    }
}

const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');

// both students will have the name properties
console.log(student1, student2);
// Object {school: ""Baidu"", name: ""HOU Ce"", birthdate: ""1995-12-15""} 
// Object {school: ""Baidu"", name: ""YAN Haijing"", birthdate: ""1990-11-10""}
</code></pre>
<p>需要注意的是，我使用了ES6中的解构(destructuring)赋值。<br>这样，我们达到了想要的效果：根据参数，产生了一个新对象，并正确赋值，最重要的就是并没有改变原对象。</p>
<h2>创建纯函数，过滤副作用</h2>
<p>现在，我们知道了“不可变”到底指的是什么。接下来，我们就要分析一下纯函数应该如何实现，进而生产不可变数据。</p>
<p>其实创建不可变数据方式有很多，在使用原生JS的基础上，我推荐的方法是使用现有的Objects API和ES6当中的解构赋值（上例已经演示）。现在看一下Objects.assign的实现方式：</p>
<pre><code>const student1 = {
    school: ""Baidu"", 
    name: 'HOU Ce',
    birthdate: '1995-12-15',
}

const changeStudent = (student, newName, newBday) =&gt; Object.assign({}, student, {name: newName, birthdate: newBday})

const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');

// both students will have the name properties
console.log(student1, student2);
// Object {school: ""Baidu"", name: ""HOU Ce"", birthdate: ""1995-12-15""};
// Object {school: ""Baidu"", name: ""YAN Haijing"", birthdate: ""1990-11-10""};
</code></pre>
<p>同样，如果是处理数组相关的内容，我们可以使用：.map, .filter或者.reduce去达成目标。这些APIs的共同特点就是不会改变原数组，而是产生并返回一个新数组。这和纯函数的思想不谋而合。</p>
<p>但是，再说回来，使用Object.assign请务必注意以下几点：<br>1）他的复制，是将所有可枚举属性，复制到目标对象。换句话说，不可枚举属性是无法完成复制的。<br>2）对象中如果包含undefined和null类型内容，会报错。<br>3）最重要的一点：Object.assign方法实行的是浅拷贝，而不是深拷贝。</p>
<p>第三点很重要，也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个属性对象的引用。这也就意味着，当对象存在嵌套时，还是有问题的。比如下面代码：</p>
<pre><code>const student1 = {
    school: ""Baidu"", 
    name: 'HOU Ce',
    birthdate: '1995-12-15',
    friends: {
        friend1: 'ZHAO Wenlin',
        friend2: 'CHENG Wen'
    }
}

const changeStudent = (student, newName, newBday, friends) =&gt; Object.assign({}, student, {name: newName, birthdate: newBday})

const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');

// both students will have the name properties
console.log(student1, student2); 
// Object {school: ""Baidu"", name: ""HOU Ce"", birthdate: ""1995-12-15"", friends: Object}
// Object {school: ""Baidu"", name: ""YAN Haijing"", birthdate: ""1990-11-10"", friends: Object}

student2.friends.friend1 = 'MA xiao';
console.log(student1.friends.friend1); // ""MA xiao""
</code></pre>
<p>对student2 friends列表当中的friend1的修改，同时也影响了student1 friends列表当中的friend1。</p>
<h2>JS本身的苍白无力VS不可变数据类库</h2>
<p>以上，我们分析了纯JS如何实现不可变数据。这样处理带来的一个负面影响在于：一些经典APIs都是shallow处理，比如上文提到的Object.assign就是典型的浅拷贝。如果遇到嵌套很深的结构，我们就需要手动递归。这样做呢，又会存在性能上的问题。</p>
<p>比如我自己动手用递归实现一个深拷贝，需要考虑循环引用的“死环”问题，另外，当使用大规模数据结构时，性能劣势尽显无疑。我们熟悉的jquery extends方法，某一版本（最新版本情况我不太了解）的实现是进行了三层拷贝，也没有达到完备的deep copy。</p>
<p>总之，实现不可变数据，我们必然要关心性能问题。针对于此，我推荐一款已经“大名鼎鼎”的——<a href=""http://facebook.github.io/immutable-js/"" rel=""nofollow noreferrer"">immutable.js类库</a>来处理不可变数据。</p>
<p>他的实现既保证了不可变性，又保证了性能大限度优化。原理很有意思，下面这段话，我摘自camsong前辈的<a href=""https://zhuanlan.zhihu.com/p/20295971?columnSlug=purerender"" rel=""nofollow noreferrer"">文章</a>：</p>
<blockquote><p>Immutable实现的原理是Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。</p></blockquote>
<p>同时为了避免deepCopy把所有节点都复制一遍带来的性能损耗，Immutable使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>
<p>感兴趣的读者可以深入研究下，这是很有意思的。如果有需要，我也愿意再写一篇immutable.js源码分析。</p>
<h2>总结</h2>
<p>我们使用JavaScript操纵对象，这样的方式很简单便捷。但是，这样操控的基础是在JavaScript灵活机制的熟练掌握上。不然很容易使你“头大”。</p>
<p>在我开发的百度某部门<a href=""http://jingyan.baidu.com/msg"" rel=""nofollow noreferrer"">私信</a>项目中，因为使用了React+Redux技术栈，并且数据结构较为负责，所以我也采用了immutable.js实现。</p>
<p>最后，在前端开发中，函数式编程越来越热，并且在某种程度上已经取代了“过程式”编程和面向对象思想。</p>
<p>我的感想是在某些特定的场景下，不要畏惧变化，拥抱未来。<br>就像我很喜欢的葡萄牙诗人安德拉德一首诗中那样说的：</p>
<blockquote><p>我同样不知道什么是海，</p></blockquote>
<p>赤脚站在沙滩上，<br>急切地等待着黎明的到来。</p>
<p>Happy Coding!</p>

                ", 从JS对象开始，谈一谈“不可变数据”和函数式编程,1531977949,512,1,492,1,1,https://segmentfault.com/a/1190000008780076
75,1,0,9,"
                    
<p>UX Planet论坛上有过这么一篇<a href=""https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11"" rel=""nofollow noreferrer"">热门文章: Infinite Scrolling Best Practices</a>，它从UX角度分析了无限滚动加载的设计实践。</p>
<p>无限滚动加载在互联网上到处都有应用：<br>豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。</p>
<p>无限滚动加载背后的技术挑战其实比想象中要多不少。尤其是要考虑页面性能，需要做到极致。<br>本文通过代码实例，来实现一个无限滚动加载效果。更重要的是，在实现过程中，对于页面性能的分析和处理力图做到最大化，希望对读者有所启发，同时也欢迎与我讨论。</p>
<h2>性能测量</h2>
<p>在开启我们的代码之前，有必要先了解一下常用的性能测量手段：</p>
<p>1）使用window.performance </p>
<p>HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。<br>同时，也可以使用performance.mark()标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</p>
<p>2）使用console.time方法与console.timeEnd方法</p>
<p>其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。</p>
<p>3）使用专业的测量工具／平台：jsPerf</p>
<p>这次实现中，我们使用第二种方法，因为它已经完全可以满足我们的需求，且兼容性更加全面。</p>
<h2>整体思路和方案设计</h2>
<p>我们要实现的页面样例如图，</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518318"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ye mian"" title=""ye mian""></span></p>
<p>它能够做到无限下拉加载内容。我把红线标出的部分叫做一个block-item，后续也都用这种命名。</p>
<p>1）关于设计方案，肯定第一个最基本、最朴素的思想是下拉到底部之后发送ajax异步请求，成功之后的回调里进行页面拼接。</p>
<p>2）但是观察页面布局，很明显图片较多，每一个block-item区块都有一张配图。当加载后的内容插入到页面中时，浏览器就开始获取图片。这意味着所有的图像同时下载，浏览器中的下载通道将被占满。同时，由于内容优先于用户浏览而加载，所以可能被迫下载底部那些永远也不会被用户浏览到的图像。<br>所以，我们需要设计一个懒加载效果，使得页面速度更快，并且节省用户的流量费用和延长电池寿命。</p>
<p>3）上一条提到的懒加载实现上，为了避免到真正的页面底部时才进行加载和渲染，而造成用户较长时间等待。我们可以设置一个合理阈值，在用户滚动到页面底部之前，先进行提前加载。</p>
<p>4）另外，页面滚动的事件肯定是需要监听的。同时，页面滚动问题也比较棘手，后面将专为滚动进行分析。</p>
<p>5）DOM操作我们知道是及其缓慢而低效的，有兴趣的同学可以研究一下jsPerf上一些经典的benchmark，比如<a href=""http://jsperf.com/jquery-cache-vs-dom-querying"" rel=""nofollow noreferrer"">这篇</a>。关于造成这种缓慢的原因，社区上同样有很多文章有过分析，这里就不再深入。但我想总结并补充的是：DOM操作，光是为了找一个节点，就从本质上比简单的检索内存中的值要慢。一些DOM操作还需要重新计算样式来读取或检索一个值。更突出的问题在于：DOM操作是阻塞的，所以当有一个DOM操作在进行时，其他的什么都不能做，包括用户与页面的交互（除了滚动）。这是一个极度伤害用户体验的事实。</p>
<p>所以，在下面的效果实现中，我采用了大量“不可思议”的DOM缓存，甚至极端的缓存everything。当然，这样做的收益也在最后部分有所展现。</p>
<h3>滚动问题</h3>
<p>滚动问题不难想象在于高频率的触发滚动事件处理上。具我亲测，在极端case下，滚动及其卡顿。即使滚动不卡顿，你可以打开Chrome控制台发现，帧速率也非常慢。关于帧速率的问题，我们有著名的16.7毫秒理论。关于这个时间分析，社区上也有不少文章阐述，这里不再展开。</p>
<p>针对于此，有很多读者会立刻想到“截流和防抖动函数”（Throttle和Debounce）。<br>简单总结一下：</p>
<p>1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间;</p>
<p>2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。</p>
<p>具体这里就不代码实现了。原理明白之后，应该不难写出。</p>
<p>但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题：</p>
<p>1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。</p>
<p>2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。</p>
<p>另外，我想也许会有读者想到rAf（requestAnimationFrame），但是据我观察，很多前端其实并不明白requestAnimationFrame技术的原理和解决的问题。只是机械地把动画性能、掉帧问题甩到这么一个名词上。在真实项目中，也没有亲自实现过，更不要说考虑requestAnimationFrame的兼容性情况了。这里场景我并不会使用rAf，因为。setTimeout的定时器值推荐最小使用16.7ms（原因请去社区上找答案，不再细讲），我们这里并不会超过这个限制，并且考虑兼容性。关于这项技术的使用，如果有问题，欢迎留言讨论。</p>
<p>基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。</p>
<h3>用户体验优化小窍门</h3>
<p>在图像加载完成时，使用淡入（fade in）效果出现。这在实际情况上会稍微慢一下，应该慢一个过渡执行时间。但用户体验上感觉会更快。这是已经被证实且普遍应用的小“trick”。但是据我感觉，它确实有效。我们的代码实现也采用了这个小窍门。不过类似这种“社会心理学”范畴的东西，显然不是本文研究的重点。</p>
<h3>总结一下</h3>
<p>代码上将会采用：超前阈值的懒加载＋DOM Cache和图片Cache＋滚动throttle模拟＋CSS fadeIn动画。<br>具体功能封装上和一些实现层面的东西，请您继续阅读。</p>
<h2>代码实现</h2>
<h3>DOM结构</h3>
<p>整体结构如下：</p>
<pre><code class=""html"">    &lt;div class=""exp-list-box"" id=""expListBox""&gt;
        &lt;ul class=""exp-list"" id=""expList""&gt;
        &lt;/ul&gt;
        &lt;div class=""ui-refresh-down""&gt;&lt;/div&gt;
    &lt;/div&gt;</code></pre>
<p>主体内容放在id为“expListBox”的container里面，id为“expList”的ul是页面加载内容的容器。<br>因为每次加载并append进入HTML的内容相对较多。我使用了模版来取代传统的字符串拼接。前端模版这次选用了我的同事<a href=""https://github.com/yanhaijing/template.js"" rel=""nofollow noreferrer"">颜海镜大神的开源作品</a>，模版结构为：</p>
<pre><code class=""html"">     &lt;#dataList.forEach(function (v) {#&gt;
        &lt;div id=""s-&lt;#=v.eid#&gt;"" class=""slide""&gt;
            &lt;li&gt;
                &lt;a href=""&lt;#=v.href#&gt;""&gt;
                    &lt;img class=""img"" src=""data:image/gif;base64,R0lGODdhAQABAPAAAP%2F%2F%2FwAAACwAAAAAAQABAEACAkQBADs%3D"" 
                    data-src=""&lt;#=v.src#&gt;""&gt;
                    &lt;/img&gt;
                    &lt;strong&gt;&lt;#=v.title#&gt;&lt;/strong&gt;
                    &lt;span class=""writer""&gt;&lt;#=v.writer#&gt;&lt;/span&gt;
                    &lt;span class=""good-num""&gt;&lt;#=v.succNum#&gt;&lt;/span&gt;
                &lt;/a&gt;
            &lt;/li&gt;
        &lt;/div&gt;
    &lt;#})#&gt;</code></pre>
<p>以上模版内容由每次ajax请求到的数据填充，并添加进入页面，构成每个block-item。<br>这里需要注意观察，有助于对后面逻辑的理解。页面中一个block-item下div属性存有该block-item的eid值，对应class叫做""slide""，子孙节点包含有一个image标签，src初始赋值为1px的空白图进行占位。真实图片资源位置存储在""data-src""中。<br>另外，请求返回的数据dataList可以理解为由9个对象构成的数组，也就是说，每次请求加载9个block-item。</p>
<h3>样式亮点</h3>
<p>样式方面不是这篇文章的重点，挑选最核心的一行来说明一下：</p>
<pre><code class=""css"">    .slide .img{
        display: inline-block;
        width: 90px;
        height: 90px;
        margin: 0 auto;
        opacity: 0;
        -webkit-transition: opacity 0.25s ease-in-out;
        -moz-transition: opacity 0.25s ease-in-out;
        -o-transition: opacity 0.25s ease-in-out;
        transition: opacity 0.25s ease-in-out;
    }</code></pre>
<p>唯一需要注意的是image的opacity设置为0，图片将会在成功请求并渲染后调整为1，辅助transition属性实现一个fade in效果。<br>对应我们上面所提到的那个“trick”</p>
<h3>逻辑部分</h3>
<p>我是完全按照业务需求来设计，并没有做抽象。其实这样的一个下拉加载功能完全可以抽象出来。有兴趣的读者可以下去自己进行封装和抽象。<br>我们先把精力集中在逻辑处理上。<br>下面进入我们最核心的逻辑部分，为了防止全局污染，我把它放入了一个立即执行函数中：</p>
<pre><code class=""javascript"">    (function() {
        var fetching = false; 
        var page = 1;
        var slideCache = [];
        var itemMap = {};
        var lastScrollY = window.pageYOffset;
        var scrollY = window.pageYOffset;
        var innerHeight;
        var topViewPort;
        var bottomViewPort;
        
        function isVisible (id) {
            // ...判断元素是否在可见区域
        }
        
        function updateItemCache (node) {
            // ....更新DOM缓存
        }
        
        function fetchContent () {
            // ...ajax请求数据
        }
        

        function handleDefer () {
            // ...懒加载实现
        }

        function handleScroll (e, force) {
            // ...滚动处理程序
        } 
        
        window.setTimeout(handleScroll, 100);
        fetchContent();
    }());</code></pre>
<p>我认为好的编程习惯是在程序开头部分便声明所有的变量，防止“变量提升”带来的潜在困扰，并且也有利于程序的整体把控。<br>我们来看一下变量设置：</p>
<pre><code class=""javascript"">    // 加载中状态锁
    1）var fetching = false;
    // 用于加载时发送请求参数，表示第几屏内容，初始为1，以后每请求一次，递增1
    2）var page = 1; 
    // 只缓存最新一次下拉数据生成的DOM节点，即需要插入的dom缓存数组
    3）var slideCache = []; 
    // 用于已经生成的DOM节点储存，存有item的offsetTop，offsetHeight
    4) var slideMap = {}; 
    // pageYOffset设置或返回当前页面相对于窗口显示区左上角的Y位置。
    5）var lastScrollY = window.pageYOffset; var scrollY = window.pageYOffset;
    // 浏览器窗口的视口（viewport）高度
    6）var innerHeight;
    // isVisible的上下阈值边界
    7) var topViewPort; 
    8) var bottomViewPort; </code></pre>
<p>关于DOM cache的变量详细说明，在后文有提供。</p>
<p>同样，我们有5个函数。在上面的代码中，注释已经写明白了每个方法的具体作用。接下来，我们逐个分析。</p>
<h4>滚动处理程序handleScroll</h4>
<p>它接受两个变量，第二个是一个布尔值force，表示是否强制触发滚动程序执行。</p>
<p>核心思路是：如果时间间隔100毫秒内，没有发生滚动，且并未强制触发，则do nothing，间隔100毫秒之后再次查询，然后直接return。<br>其中，是否发生滚动由lastScrollY === window.scrollY来判断。<br>在100毫秒之内发生滚动或者强制触发时，需要判断是否滚动已接近页面底部。如果是，则拉取数据，调用fetchContent方法，并调用懒加载方法handleDefer。<br>并且在这个处理程序中，我们计算出来了isVisible区域的上下阈值。我们使用600作为浮动区间，这么做的目的是在一定范围内提前加载图片，节省用户等待时间。当然，如果我们进行抽象时，可以把这个值进行参数化。</p>
<pre><code class=""javascript"">    function handleScroll (e, force) {
        // 如果时间间隔内，没有发生滚动，且并未强制触发加载，则do nothing，再次间隔100毫秒之后查询
        if (!force &amp;&amp; lastScrollY === window.scrollY) {
            window.setTimeout(handleScroll, 100);
            return;
        }
        else {
            // 更新文档滚动位置
            lastScrollY = window.scrollY;
        }
        scrollY = window.scrollY;
        // 浏览器窗口的视口（viewport）高度赋值
        innerHeight = window.innerHeight;
        // 计算isVisible上下阈值
        topViewPort = scrollY - 1000;
        bottomViewPort = scrollY + innerHeight + 600;

        // 判断是否需要加载
        // document.body.offsetHeight;返回当前网页高度 
        if (window.scrollY + innerHeight + 200 &gt; document.body.offsetHeight) {
            fetchContent();
        }
        // 实现懒加载
        handleDefer();
        window.setTimeout(handleScroll, 100);
    } </code></pre>
<h4>拉取数据</h4>
<p>这里我用到了自己封装的ajax接口方法，它基于zepto的ajax方法，只不过又手动采用了promise包装一层。实现比较简单，当然有兴趣可以找我要一下代码，这里不再详细说了。<br>我们使用前端模版进行HTML渲染，同时调用updateItemCache，将此次数据拉取生成的DOM节点缓存。之后手动触发handleScroll，更新文档滚动位置和懒加载处理。</p>
<pre><code class=""javascript"">    function fetchContent () {
        // 设置加载状态锁
        if (fetching) {
            return;
        }
        else {
            fetching = true;
        }
        ajax({
            url: (!location.pathname.indexOf('/m/') ? '/m' : '')
                + '/list/asyn?page=' + page + (+new Date),
            timeout: 300000,
            dataType: 'json'
        }).then(function (data) {
            if (data.errno) {
                return;
            }
            console.time('render');

            var dataList = data.data.list;
            var len = dataList.length;
            var ulContainer = document.getElementById('expList');
            var str = '';
            var frag = document.createElement('div');

            var tpl = __inline('content.tmpl');
            for (var i = 0; i &lt; len; i++) {
                str = tpl({dataList: dataList});
            }
            frag.innerHTML = str;
            ulContainer.appendChild(frag);
            // 更新缓存
            updateItemCache(frag);
            // 已经拉去完毕，设置标识为true
            fetching = false;
            // 强制触发
            handleScroll(null, true);
            page++;
            console.timeEnd('render');
        }, function (xhr, type) {
            console.log('Refresh:Ajax Error!');
        });
    }</code></pre>
<h4>缓存对象</h4>
<p>之前参数里提到过，一共有两个用于缓存的对象／数组：</p>
<p>1）slideCache：缓存最近一次加载过的数据生成的DOM内容，缓存方式为数组储存：</p>
<pre><code class=""javascript"">    slideCache = [
        {
            id: ""s-97r45"",
            img: img DOM节点,
            node: 父容器DOM node,类似&lt;div id=""s-&lt;#=v.eid#&gt;"" class=""slide""&gt;&lt;/div&gt;,
            src: 图片资源地址
        },
        ...
    ]</code></pre>
<p>slideCache由updateItemCache函数更新，主要用于懒加载时的赋值src。这样我们做到“只写入DOM”原则，不需要再从DOM读取。</p>
<p>2）slideMap：缓存DOM节点的高度和offsetTop，以DOM节点的id为索引。存储方式：</p>
<pre><code class=""javascript"">    slideMap = {
        s-97r45: {
            node: DOM node,类似&lt;div id=""s-&lt;#=v.eid#&gt;"" class=""slide""&gt;&lt;/div&gt;,
            offTop: 300,
            offsetHeight: 90
        }
    }</code></pre>
<p>slideMap根据isVisible方法的参数进行更新和读取。使得我们在判断是否isVisible时，大量减少读取DOM的操作。</p>
<h4>懒加载程序</h4>
<p>在上面的滚动处理程序中，我们调用了handleDefer函数。我们看一下这个函数的实现：</p>
<pre><code class=""javascript"">    function handleDefer () {
        // 时间记录
        console.time('defer');

        // 获取dom缓存
        var list = slideCache;
        // 对于遍历list里的每一项，都使用一个变量，而不是在循环内部声明。节省内存，把性能高效，做到极致。
        var thisImg;

        for (var i = 0, len = list.length; i &lt; len; i++) {
            thisImg = list[i].img; // 这里我们都是从内存中读取，而不用读取DOM节点
            var deferSrc = list[i].src; // 这里我们都是从内存中读取，而不用读取DOM节点
            // 判断元素是否可见
            if (isVisible(list[i].id)) {
                // 这个函数是图片onload逻辑
                var handler = function () {
                    var node = thisImg;
                    var src = deferSrc;
                    // 创建一个闭包
                    return function () {
                        node.src = src;
                        node.style.opacity = 1;
                    }
                }
                var img = new Image();
                img.onload = handler();
                img.src = list[i].src;
            }
        }
        console.timeEnd('defer');
    }</code></pre>
<p>主要思路就是对DOM缓存中的每一项进行循环遍历。在循环中，判断每一项是否已经进入isVisible区域。如果进入isVisible区域，则对当前项进行真实src赋值，并设置opacity为1。</p>
<h4>更新拉取数据生成的DOM缓存</h4>
<p>针对每一个slide类，我们缓存对应DOM节、id、子元素img DOM节点：</p>
<pre><code class=""javascript"">    function updateItemCache (node) {
        var list = node.querySelectorAll('.slide');
        var len = list.length;
        slideCache = [];
        var obj;

        for (var i=0; i &lt; len; i++) {
            obj = {
                node: list[i],
                id: list[i].getAttribute('id'),
                img: list[i].querySelector('.img')
            }
            obj.src = obj.img.getAttribute('data-src');
            slideCache.push(obj);
        };
    }</code></pre>
<h4>是否在isVisible区域判断</h4>
<p>该函数接受相应DOM id，并进行判断。<br>如果判断条件晦涩难懂的话，你一定要手动画画图理解一下。如果你就是懒得画图，那么也没关系，我帮你画好了，只是丑一些。。。</p>
<pre><code class=""javascript"">    function isVisible (id) {
        var offTop;
        var offsetHeight;
        var data;
        var node;

        // 判断此元素是否已经懒加载正确渲染，分为在屏幕之上（已经懒加载完毕）和屏幕外，已经添加到dom中，但是还未请求图片（懒加载之前）
        if (itemMap[id]) {
            // 直接获取offTop，offsetHeight值
            offTop = itemMap[id].offTop;
            offsetHeight = itemMap[id].offsetHeight;
        }
        else {
            // 设置该节点，并且设置节点属性：node，offTop，offsetHeight
            node = document.getElementById(id);
            // offsetHeight是自身元素的高度
            offsetHeight = parseInt(node.offsetHeight);
            // 元素的上外缘距离最近采用定位父元素内壁的距离
            offTop = parseInt(node.offsetTop);
        }

        if (offTop + offsetHeight &gt; topViewPort &amp;&amp; offTop &lt; bottomViewPort) {
            return true;
        }
        else {
            return false;
        }
    }</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518319"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""手绘图示"" title=""手绘图示""></span></p>
<h3>性能收益</h3>
<p>如上代码，我们主要进行了两方面的性能考量：</p>
<p>1）延迟加载时间</p>
<p>2）渲染DOM时间</p>
<p>整体收益如下：</p>
<p>优化前延迟平均值：49.2ms     中间值：43ms；</p>
<p>优化后延迟平均值：17.1ms     中间值：11ms；</p>
<p>优化前渲染平均值：2129.6ms   中间值：2153.5ms；</p>
<p>优化后渲染平均值：120.5ms    中间值：86ms；</p>
<h2>继续思考</h2>
<p>做完这些，其实也远远没有达到所谓的“极致化”性能体验。我们无非就做了各种DOM缓存、映射、懒加载。如果继续分析edge case，我们还能做的更多，比如：DOM回收、墓碑和滚动锚定。这些其实很多都是借鉴客户端开发理念，但是超前的谷歌开发者团队也都有了自己的实现。比如在去年7月份的<br><a href=""https://developers.google.com/web/updates/2016/07/infinite-scroller"" rel=""nofollow noreferrer"">一篇文章：Complexities of an Infinite Scroller</a>就都有所提及。这里从原理（非代码）层面，也给大家做个介绍。</p>
<h3>DOM回收</h3>
<p>它的原理是，对于需要产生的大量DOM节点（比如我们下拉加载的信息内容）不是主动用createElement的方式创建，而是回收利用那些已经移出视窗，暂时不会被需要的DOM节点。如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518320?w=652&amp;h=902"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""动图（盗图）"" title=""动图（盗图）""></span></p>
<p>虽然DOM节点本身并非耗能大户，但是也不是一点都不消耗性能，每一个节点都会增加一些额外的内存、布局、样式和绘制。同样需要注意的一点是，在一个较大的DOM中每一次重新布局或重新应用样式（在节点上增加或删除样式所触发的过程）的系统开销都会比较昂贵。所以进行DOM回收意味着我们会保持DOM节点在一个比较低的数量上，进而加快上面提到的这些处理过程。</p>
<p>据我观察，在真正产品线上使用这项技术的还比较少。可能是因为实现复杂度和收益比并不很高。但是，淘宝移动端检索页面实现了类似的思想。如下图，</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518321"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""淘宝做法"" title=""淘宝做法""></span></p>
<p>每加载一次数据，就生成“.page-container  .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。</p>
<h3>墓碑（Tombstones）</h3>
<p>如之前所说，如果网络延迟较大，用户又飞快地滚动，很容易就把我们渲染的DOM节点都甩在千里之外。这样就会出现极差的用户体验。针对这种情况，我们就需要一个墓碑条目占位在对应位置。等到数据取到之后，再代替墓碑。墓碑也可以有一个独立的DOM元素池。并且也可以设计出一些漂亮的过渡。这种技术在国外的一些“引领技术潮流”的网站上，早已经有了应有。比如下图取自Facebook：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518322"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Facebook墓碑"" title=""Facebook墓碑""></span></p>
<p>我在“简书”APP客户端上，也见过类似的方案。当然，人家是native...</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008518323"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""简书客户端"" title=""简书客户端""></span></p>
<h3>滚动锚定</h3>
<p>滚动锚定的触发时机有两个：一个是墓碑被替换时，另一个是窗口大小发生改变时（在设备发生翻转时也会发生）。这两种情况，都需要调整对应的滚动位置。</p>
<h2>总结</h2>
<p>当你想提供一个高性能的有良好用户体验的功能时，可能技术上一个简单的问题，就会演变成复杂问题的。这篇文章便是一个例证。<br>随着 “Progressive Web Apps” 逐渐成为移动设备的一等公民（会吗？），高性能的良好体验会变得越来越重要。<br>开发者也必须持续的研究使用一些模式来应对性能约束。这些设计的基础当然都是成熟的技术为根本。</p>
<p>这篇文章参考了Flicker工程师，前YAHOO工程师Stephen Woods的《Building Touch Interfaces with HTML5》一书。以及王芃前辈对于《Complexities of an Infinite Scroller》一文的部分翻译。</p>

                ", 设计无限滚动下拉加载，实践高性能页面真谛,1531977951,369,1,721,1,1,https://segmentfault.com/a/1190000008518315
76,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""https://sfault-image.b0.upaiyun.com/319/557/3195573810-587dee3e967a4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""weekly-vol021"" title=""weekly-vol021""></span></p>
<p>在第 18 期社区周刊《程序人生》<sup><a class=""footnote-ref"">1</a></sup> 中，我们汇总图灵访谈、SegmentFault 内部程序员访谈、社区开发者的编程之路和工具利器等，分享 2016 这一年里，社区开发者们的日常。其中提到“EAT SLEEP CODE REPEAT，google 搜一下这句话，大概就知道，世界很多程序员似乎都过着这句话所描述的生活”。</p>
<p>最近，社区也举办了一个「回顾 2016，你都收获了什么？」<sup><a class=""footnote-ref"">2</a></sup> 的年终总结活动，有 70 多位社区开发者对过去的这一年进行了总结。其中我看了很多，收获最大的是，多数人无论日常是否围绕「吃、睡、码」，他们对个人价值、生活、理想的追求，始终很明确，对下一步该怎么走，计划得很清楚。</p>
<p>所以，本期周刊特别放送——《程序人生（二）：2016 这一年》，作为春节前最后一期，将我们认为值得推荐的年终总结，分享给大家，看他程序人生，启迪自己的路。任性私货，请多多海涵。</p>
<p>祝阅读 &amp; 和作者交流愉快！<br><br></p>
<p><strong><a href=""https://segmentfault.com/a/1190000007954793"" rel=""nofollow noreferrer"">《坚持写博一年半，我的收获与成长》  by 劳卜</a></strong></p>
<p>「码梦为生，笔耕不辍。」——劳卜这一年，应该是很勤劳的，全年持续产出，写了 20 余篇文章（主要 JavaScript、Vue 和 React），用他自己的话概括，就是“敲了很多代码，看了很多书，写了很多字”。推荐关注他的专栏。</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007943157"" rel=""nofollow noreferrer"">《2016 年总结--成长》  by 乖小鬼YQ</a></strong></p>
<p>公司 Web 前端技术架构体系的演进、开发项目组件库、富文本编辑器，主动推进，直到年末那篇有名的<a href=""https://segmentfault.com/a/1190000007795647"" rel=""nofollow noreferrer"">《割裂的前端工程师》</a>诞生——</p>
<p>「保持了一定频率和质量的技术文章，这养成了我一个习惯，觉得有意思有意义的技术点，就记录下来和大家分享，也算是一种梳理，这种梳理对于我而言，很有作用，每隔一段时间就会思考业内前端的各种发展，以及我自身的优缺点，我需要提高的地方。」</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007939351"" rel=""nofollow noreferrer"">《我的 2016：从野路子到正规军的前端养成记》  by jrainlau</a></strong></p>
<p>看 jrainlau 的历程，从实习到面试、毕业、入职，最大的感受就是这一年他对新事物疯狂的汲取。希望如他所说，“新的一年继续保持学习的势头，全方位地培养自己的能力，争取独立负责一些公司的项目。”</p>
<p>「你一个搞光电物理的，怎么就跑来前端了呢？」</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007979219"" rel=""nofollow noreferrer"">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟  by lon</a></strong></p>
<p>「过去一年里，我几乎一直坚持着 9117（周一至周五每天 9 点半至 11 点半，周六、日 12 点 至 24 点）。」</p>
<p>lon 生猛的这一年让人惭愧，? 我只能把他这几条总结来送给大家：入行要学好 Git，初学者要珍惜参与全新项目的机会，用好 Webpack 以及 Babel、PostCSS 等。</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007975416"" rel=""nofollow noreferrer"">《面对 2017 的轻狂和多疑》  by 题叶</a></strong></p>
<p>2016 百态前端，看题叶如何在不断的阅读、总结、思考中，回顾自己这一年的收获。</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007983630"" rel=""nofollow noreferrer"">《写于 2016 年末》  by jeffjade</a></strong></p>
<p>工作、前端、博客、影视剧、社交、读书、旅行、运动，寄语明朝：纵年与时驰，可初心不改；即意与岁去，依激情满怀。</p>
<p><strong><a href=""https://segmentfault.com/a/1190000008055889"" rel=""nofollow noreferrer"">《死月的二零一六总结》  by XadillaX</a></strong></p>
<p>让前端更专注前端，让后端更专注后端，让浏览器得到的还是传统的结果。<br>一开始不要把所有事情都想得面面俱到，很有可能是浪费你的精力和感情，在迭代速度非常快的互联网时代，快速出产品才是最重要的事。还要练就强大的内心来拥抱各种变化。<br>宁可一开始花更多的时间和设计去搞定一套东西，也不要在代码稳定线上跑了好久之后再重构它的实现方式——哪怕旧的方式是一坨屎。<br>……</p>
<p>总结看过这么多，只有 XadillaX 的拍照水平，虐得我服！</p>
<p><strong><a href=""https://segmentfault.com/a/1190000007964145"" rel=""nofollow noreferrer"">《2016 总结：一个应届生的互联网名企逐梦记》  by brianway</a></strong></p>
<ul>
<li><p>敲了超过 7 万行代码</p></li>
<li><p>写了约 80 篇技术博客</p></li>
<li><p>第一次说走就走的旅行</p></li>
<li><p>第一次买了超过自己消费能力的奢侈品</p></li>
</ul>
<p>还得加一条：泡了半年图书馆，一周啃一本书。彪悍的人生，大多来自勤奋与努力。<br><br></p>
<p>上面 8 位的总结我们做了特别介绍，当然还有一些非常不错的，他们对目标笃定，对未来充满期待，但不在此大幅介绍，大家有兴趣可以自行查看，将其罗列如下：</p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000007926699"" rel=""nofollow noreferrer"">《2016-我的前端之路：工具化与工程化》  // 王下邀月熊_Chevalier</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007979233"" rel=""nofollow noreferrer"">《2016，驻足、思考、寻找方向》  // 边城</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007471854"" rel=""nofollow noreferrer"">《早产的 2016 年终总结》  // 韩子迟</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007963160"" rel=""nofollow noreferrer"">《2016 年末总结，我的前端之路》  // 科西嘉乡巴佬</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000008051373"" rel=""nofollow noreferrer"">《流浪小猫的 2016 年总结》  // xcatliu</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000008091265"" rel=""nofollow noreferrer"">《聊聊这一年从技术麻瓜开始的奋斗史》  // WilsonLiu95</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007981897"" rel=""nofollow noreferrer"">《任重道远，活在当下》  // qeesung</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007843225"" rel=""nofollow noreferrer"">《2016 工作、生活与得失》  // mindwind</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000008121058"" rel=""nofollow noreferrer"">《2016 年结束后的感想》  // beanlam</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000008053261"" rel=""nofollow noreferrer"">《我的 2016 收获满满》  // songjz</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007978598"" rel=""nofollow noreferrer"">《致敬 2016，拥抱 2017》  // William007</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007958297"" rel=""nofollow noreferrer"">《2017-当行远方》  // Lxxyx</a></p></li>
</ul>
<p>万千程序人生，2017 祝大家都走得更远。（本期完）</p>
<hr>
<blockquote>
<p><strong># SegmentFault 技术周刊 #</strong></p>
<p>「技术周刊」是社区特别推出的技术内容系列，一周一主题。周刊筛选的每篇内容，是作者的独到见解，踩坑总结和经验分享。</p>
<p>每周二更新，欢迎「<a href=""https://segmentfault.com/blog/weekly"" rel=""nofollow noreferrer"">关注</a>」或者「<a href=""https://segmentfault.com/feeds/blog/weekly"" rel=""nofollow noreferrer"">订阅</a>」。大家也可以在评论处留言自己感兴趣的主题，推荐主题相关的优秀文章。</p>
</blockquote>
<hr>
<ol>
<li> <a href=""https://segmentfault.com/a/1190000007936914"" rel=""nofollow noreferrer"">SegmentFault 技术周刊 Vol.18 - 程序人生</a> <a class=""footnote-backref"">↩</a>
</li>
<li> 社区活动：<a href=""https://segmentfault.com/a/1190000007917925"" rel=""nofollow noreferrer"">回顾 2016，你都收获了什么？</a> <a class=""footnote-backref"">↩</a>
</li>
</ol>

                ", SegmentFault 技术周刊 Vol.21 - 程序人生（二）：2016 这一年,1531977953,289,1,432,1,1,https://segmentfault.com/a/1190000008144974
77,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""https://sfault-image.b0.upaiyun.com/330/511/3305116510-58623d5561137"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""weekly-vol018"" title=""weekly-vol018""></span></p>
<pre><code class=""js"">(function repeat() {
    eat();
    sleep();
    code();
    repeat();
})();</code></pre>
<p>SegmentFault 曾出过一款三周年纪念版的 T 恤，上面只有四个词：<code>347  5L33P  C0D3  R3P34T</code>，然后 google 搜一下这句话，大概就知道，世界很多程序员似乎都过着这句话所描述的生活。</p>
<p>简直是各种刻板印象的综合归因，毕竟大家都常问：</p>
<p>为什么程序员普遍难沟通？<br>为什么程序员普遍没有女朋友？<br>为什么有些程序员看起来头发都没整理好就来上班了？<br>为什么程序员加班过劳的那么多？</p>
<p>然后再去知乎上看看：</p>
<p>为什么我那当程序员的男朋友，一直特别想要一个机械键盘？<br>什么样的 bug 会让你目瞪口呆？<br>祈求代码不出 bug 该拜哪个神仙？<br>为什么很多程序员、geek 都喜欢熬夜，而且在后半夜工作效率异常高？</p>
<p>所以，看起来简直就真的是日常围绕着「吃、睡、码」三件事在重复。</p>
<p>可真实就是这样么？2016 年最后一期社区周刊，我们决定做一期与开发者日常相关的——《程序人生》，整理了过去的这一年里，社区开发者们的日常分享，从新手到领域专家，他们和你的人生，实际都很精彩。</p>
<p>祝阅读愉快！</p>
<h4>目录</h4>
<p><strong>1. 你如何成为程序员 by mindwind</strong></p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000005045930"" rel=""nofollow noreferrer"">程序员的成长阶梯和级别定义</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007254260"" rel=""nofollow noreferrer"">程序员从入门到精通</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004975318"" rel=""nofollow noreferrer"">程序员应该接外包吗？</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006197447"" rel=""nofollow noreferrer"">技术大会值得参加吗？</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007691465"" rel=""nofollow noreferrer"">程序员都讨厌开会？</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004934137"" rel=""nofollow noreferrer"">刚挣钱的程序员同学该如何花钱？</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007616297"" rel=""nofollow noreferrer"">程序员，你为什么值这么多钱？</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007765895"" rel=""nofollow noreferrer"">程序员的口头禅：技术上无法实现</a></p></li>
</ul>
<p><strong>2. 「编程观」 by mindwind</strong></p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000005832399"" rel=""nofollow noreferrer"">系统崩溃，大圣归来</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006172378"" rel=""nofollow noreferrer"">一技压身，天下行走</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007398387"" rel=""nofollow noreferrer"">编辑器背后的程序观</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000005990281"" rel=""nofollow noreferrer"">代码故事：汉德的救赎</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000005731314"" rel=""nofollow noreferrer"">程序员「奇葩」说</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000005924198"" rel=""nofollow noreferrer"">编程的艺术门槛</a></p></li>
</ul>
<p><strong>3. 技术管理者的日常 by mindwind</strong></p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000005106868"" rel=""nofollow noreferrer"">飞行的架构师和奔跑的程序员</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007135253"" rel=""nofollow noreferrer"">编程的三个阶段</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007004552"" rel=""nofollow noreferrer"">程序员、技术主管和架构师</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000007186373"" rel=""nofollow noreferrer"">系统故障、程序失败和错误修正</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006662314"" rel=""nofollow noreferrer"">认清性能问题</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006138752"" rel=""nofollow noreferrer"">IM 去中心化概念模型与架构设计</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000005892459"" rel=""nofollow noreferrer"">京东咚咚架构演进</a></p></li>
</ul>
<p><strong>4. 大牛走过的路 by 图灵访谈</strong></p>
<ul>
<li><p>Arcthur - <a href=""https://segmentfault.com/a/1190000007917014"" rel=""nofollow noreferrer"">pure rende 专栏创办人@流形：选择 React 这条路，很庆幸</a></p></li>
<li><p>郭霖 - <a href=""https://segmentfault.com/a/1190000007895597"" rel=""nofollow noreferrer"">“Android 第一书”作者：用心做事，结果自然水到渠成</a></p></li>
<li><p>尤雨溪 - <a href=""https://segmentfault.com/a/1190000007297553"" rel=""nofollow noreferrer"">Vue 作者：以匠人的态度不断打磨完善 Vue</a></p></li>
<li><p>月影 - <a href=""https://segmentfault.com/a/1190000006987493"" rel=""nofollow noreferrer"">360 前端负责人：赛跑项目和跳水项目的金牌含量其实一样</a></p></li>
<li><p>李成银 - <a href=""https://segmentfault.com/a/1190000005950344"" rel=""nofollow noreferrer"">ThinkJS 作者：择善而从之，笃行致远</a></p></li>
<li><p>魔法哥 - <a href=""https://segmentfault.com/a/1190000005735227"" rel=""nofollow noreferrer"">CSS 魔法：学海无涯，而吾生有涯</a></p></li>
<li><p>结城浩 - <a href=""https://segmentfault.com/a/1190000005676256"" rel=""nofollow noreferrer"">坚持做一件事而不厌倦，一旦厌倦马上更换目标</a></p></li>
<li><p>肖鹏 - <a href=""https://segmentfault.com/a/1190000004554857"" rel=""nofollow noreferrer"">微博数据库那些事儿</a></p></li>
<li><p>高博 - <a href=""https://segmentfault.com/a/1190000004366586"" rel=""nofollow noreferrer"">对话高博（一）| 机器码、Pascal，以及计算机学习的分形</a> 、 <a href=""https://segmentfault.com/a/1190000004378752"" rel=""nofollow noreferrer"">对话高博（二）| 换工作这件事</a></p></li>
<li><p>阿朱 - <a href=""https://segmentfault.com/a/1190000004343120"" rel=""nofollow noreferrer"">从 50 到 5000，从技术到人</a></p></li>
<li><p>许式伟 - <a href=""https://segmentfault.com/a/1190000004312606"" rel=""nofollow noreferrer"">ECUG 社区发起人：对编程语言的选择无关阵营，关乎品味</a></p></li>
<li><p>余弦（钟晨鸣） - <a href=""https://segmentfault.com/a/1190000004837912"" rel=""nofollow noreferrer"">打破常规，守正出奇</a></p></li>
<li><p>Holden Karau - <a href=""https://segmentfault.com/a/1190000004438583"" rel=""nofollow noreferrer"">IBM 美女工程师：寻找友善的人一起共事</a></p></li>
</ul>
<p><strong>5. SegmentFault 内部程序员访谈</strong></p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000004330616"" rel=""nofollow noreferrer"">Codes Don't Lie —— Integ</a></p></li>
<li><p><a href=""http://beta.segmentfault.com/a/1190000004510843"" rel=""nofollow noreferrer"">设计本身是一个禅悟过程——董锋</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004325426"" rel=""nofollow noreferrer"">程序员的使命是让程序员失业 —— Gemini</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004330622"" rel=""nofollow noreferrer"">用匠心和铁手，打造自己的人生 —— Wtser</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004372485"" rel=""nofollow noreferrer"">为什么你需要找一个程序员做男票？ —— Tairy</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000004489749"" rel=""nofollow noreferrer"">程序员创业是怎样的一番体验？——Joyqi 访谈</a></p></li>
</ul>
<p><strong>6. 社区开发者的「编程之路」</strong></p>
<ul>
<li><p>Phodal - <a href=""https://segmentfault.com/a/1190000004513191"" rel=""nofollow noreferrer"">我的编程之路：创造、分享是我编程的乐趣</a></p></li>
<li><p>yuanzm - <a href=""https://segmentfault.com/a/1190000004520193"" rel=""nofollow noreferrer"">我的编程之路：分享、坚持、热学编程</a></p></li>
<li><p>HarryZhu - <a href=""https://segmentfault.com/a/1190000004521190"" rel=""nofollow noreferrer"">野生码农的逆袭之路：在跨界中找到自我</a></p></li>
<li><p>山河永寂 - <a href=""https://segmentfault.com/a/1190000004530393"" rel=""nofollow noreferrer"">The road you are trudging is bound for loneliness.</a></p></li>
<li><p>Thonatos - <a href=""https://segmentfault.com/a/1190000004531937"" rel=""nofollow noreferrer"">论我是如何走上前端这条不归路的！</a></p></li>
<li><p>incNick - <a href=""https://segmentfault.com/a/1190000004538778"" rel=""nofollow noreferrer"">程序之美 存乎于心</a></p></li>
<li><p>这块显卡有点冷 - <a href=""https://segmentfault.com/a/1190000004542202"" rel=""nofollow noreferrer"">青春献给Code</a></p></li>
<li><p>_我已经从中二毕业了 - <a href=""https://segmentfault.com/a/1190000004542349"" rel=""nofollow noreferrer"">论一个普通高中生如何走向编程这条不归路</a></p></li>
<li><p>justjavac - <a href=""https://segmentfault.com/a/1190000004553550"" rel=""nofollow noreferrer"">我的编程之路：「懒惰」是程序员最大的美德</a></p></li>
<li><p>吃半个馒头 - <a href=""https://segmentfault.com/a/1190000004554945"" rel=""nofollow noreferrer"">我的编程之路：「生存」是唯一的基本要求</a></p></li>
<li><p>大猛 - <a href=""https://segmentfault.com/a/1190000004556813"" rel=""nofollow noreferrer"">野百合也会有春天</a></p></li>
<li><p>Gemini - <a href=""https://segmentfault.com/a/1190000004558460"" rel=""nofollow noreferrer"">那是我夕阳下的奔跑 —— Gemini</a></p></li>
<li><p>AnnatarHe  - <a href=""https://segmentfault.com/a/1190000004545403"" rel=""nofollow noreferrer"">代码写到第二年</a></p></li>
<li><p>noulli - <a href=""https://segmentfault.com/a/1190000004551834"" rel=""nofollow noreferrer"">我的编程之路</a></p></li>
<li><p>hiYoHoo - <a href=""https://segmentfault.com/a/1190000004564219"" rel=""nofollow noreferrer"">精灵般灵动 黑洞般深邃</a></p></li>
<li><p>黄总 - <a href=""https://segmentfault.com/a/1190000004575405"" rel=""nofollow noreferrer"">想做就马上做，喜欢就坚持做 —— 我的编程之路</a></p></li>
<li><p>beckyyyy - <a href=""https://segmentfault.com/a/1190000004596444"" rel=""nofollow noreferrer"">我的编程之路：这是一个蓄谋已久的大坑</a></p></li>
<li><p>learning - <a href=""https://segmentfault.com/a/1190000004609760"" rel=""nofollow noreferrer"">我思故我Code</a></p></li>
<li><p>王下邀月熊_Chevalier - <a href=""https://segmentfault.com/a/1190000004612590"" rel=""nofollow noreferrer"">我的编程之路--知识管理与知识体系</a></p></li>
<li><p>JellyBool - <a href=""https://segmentfault.com/a/1190000004617552"" rel=""nofollow noreferrer"">我的编程之路：走上不归路</a></p></li>
<li><p>过世秋凤 - <a href=""https://segmentfault.com/a/1190000004618537"" rel=""nofollow noreferrer"">我的编程之路</a></p></li>
<li><p>leohotfn - <a href=""https://segmentfault.com/a/1190000004628622"" rel=""nofollow noreferrer"">我的编程之路：面朝大海，bug 狂来</a></p></li>
<li><p>outshineamaze - <a href=""https://segmentfault.com/a/1190000004639013"" rel=""nofollow noreferrer"">我的编程之路</a></p></li>
<li><p>garfileo - <a href=""https://segmentfault.com/a/1190000004642053"" rel=""nofollow noreferrer"">这么多年，差不多一直在为自己写程序</a></p></li>
<li><p>RobinTang - <a href=""https://segmentfault.com/a/1190000004645085"" rel=""nofollow noreferrer"">一不小心就码了十年</a></p></li>
<li><p>公子 - <a href=""https://segmentfault.com/a/1190000004715628"" rel=""nofollow noreferrer"">别人在挖石头我在撸码的编程之路</a></p></li>
<li><p>kumfo - <a href=""https://segmentfault.com/a/1190000004811452"" rel=""nofollow noreferrer"">我的编程之路：人生都是一个奋斗的过程 </a></p></li>
<li><p>德来 - <a href=""https://segmentfault.com/a/1190000004823207"" rel=""nofollow noreferrer"">我的编程之路：从好玩到玩好</a></p></li>
<li><p>艾尼菲楠 - <a href=""https://segmentfault.com/a/1190000004878155"" rel=""nofollow noreferrer"">我的编程之路</a></p></li>
<li><p>Fallenwood - <a href=""https://segmentfault.com/a/1190000004905443"" rel=""nofollow noreferrer"">代码写不下去了</a></p></li>
<li><p>脑脑脑脑脑补大王 - <a href=""https://segmentfault.com/a/1190000004906290"" rel=""nofollow noreferrer"">一个野生程序员的成长</a></p></li>
<li><p>vczh - <a href=""https://segmentfault.com/a/1190000004907985"" rel=""nofollow noreferrer"">进入2016 -- 回顾我走过的编程之路</a></p></li>
<li><p>cheky - <a href=""https://segmentfault.com/a/1190000005093749"" rel=""nofollow noreferrer"">青春十年 —— 一个普通IT人的十年回顾</a></p></li>
</ul>
<p><strong>7. 社区开发者的「工具利器」</strong></p>
<ul>
<li><p>捞鱼的转阿转 - <a href=""https://segmentfault.com/a/1190000004551378"" rel=""nofollow noreferrer"">职业打杂 业余编程，那些抓起来就用伙伴们</a></p></li>
<li><p>andyyu0920 - <a href=""https://segmentfault.com/a/1190000004567434"" rel=""nofollow noreferrer"">2015 的工具包，持續邁向 2016！</a></p></li>
<li><p>王铁手 - <a href=""https://segmentfault.com/a/1190000004569533"" rel=""nofollow noreferrer"">用工具武装自己</a></p></li>
<li><p>dyzdyz010 - <a href=""https://segmentfault.com/a/1190000004596145"" rel=""nofollow noreferrer"">非职业程序员的工具箱</a></p></li>
<li><p>Michael_翔_ - <a href=""https://segmentfault.com/a/1190000004234603"" rel=""nofollow noreferrer"">Win软件私家珍藏-常用软件工具使用总结</a></p></li>
<li><p>rccoder - <a href=""https://segmentfault.com/a/1190000004604196"" rel=""nofollow noreferrer"">不求很多，够用就好</a></p></li>
<li><p>jeffjade - <a href=""https://segmentfault.com/a/1190000004628751"" rel=""nofollow noreferrer"">那些所倚靠的利器记载</a></p></li>
<li><p>arkii - <a href=""https://segmentfault.com/a/1190000004637234"" rel=""nofollow noreferrer"">运维、开发 5/5 开，常用工具</a></p></li>
<li><p>HarryZhu - <a href=""https://segmentfault.com/a/1190000004639278"" rel=""nofollow noreferrer"">操千曲而后晓声：跨界矿工必备六神装精选</a></p></li>
<li><p>qeesung - <a href=""https://segmentfault.com/a/1190000004644604"" rel=""nofollow noreferrer"">数数我的神器</a></p></li>
<li><p>优de良 - <a href=""https://segmentfault.com/a/1190000004916317"" rel=""nofollow noreferrer"">利器在手， 啥都顺手</a></p></li>
<li><p>Homu - <a href=""https://segmentfault.com/a/1190000004914833"" rel=""nofollow noreferrer"">这只是一套工具指南</a></p></li>
</ul>
<p>2016 年马上就要完结了，回顾一下，你都收获了什么？或许也可以 <a href=""https://segmentfault.com/a/1190000007917925"" rel=""nofollow noreferrer"">跟大家分享 - #2016总结#</a></p>
<p><br><em>预祝新年快乐！</em><br><br></p>
<hr>
<blockquote>
<p><strong># SegmentFault 技术周刊 #</strong></p>
<p>「技术周刊」是社区特别推出的技术内容系列，一周一主题。周刊筛选的每篇内容，是作者的独到见解，踩坑总结和经验分享。</p>
<p>每周二更新，欢迎「<a href=""https://segmentfault.com/blog/weekly"" rel=""nofollow noreferrer"">关注</a>」或者「<a href=""https://segmentfault.com/feeds/blog/weekly"" rel=""nofollow noreferrer"">订阅</a>」。大家也可以在评论处留言自己感兴趣的主题，推荐主题相关的优秀文章。</p>
</blockquote>

                ", SegmentFault 技术周刊 Vol.18 - 程序人生,1531977955,558,1,481,1,1,https://segmentfault.com/a/1190000007936914
78,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007843228?w=900&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>今天，又到了一年的生日，正好生日在每年的十二月中下旬，临近翻过旧年迎来新年。写下一篇文字送给自己，也算作今年的总结吧。</p>
<h2>职级、晋升与寻路</h2>
<p>今年初，正好是工作的第十个年头，再次在公司技术职级这条路上晋级了一小步。这一小步也基本走到了我曾在<a href=""http://mp.weixin.qq.com/s?__biz=MzAxMTEyOTQ5OQ==&amp;mid=2650610534&amp;idx=1&amp;sn=653dbd5b54b32f232dc86f973b30e983"" rel=""nofollow noreferrer"">《程序员的成长阶梯和级别定义》</a> 一文中写过的资深级尽头。再往后如果继续走技术之路，似乎就该走上「专家」之路了，但我没有立刻迈步，而是在此停留思考了一阵。</p>
<p>之所以停留，是因为下一个阶梯和前面的路径都将不同，花费的时间也许是前面所有时间的总和还要多。而且后面的路也不像前面的路存在一条确定的路径，只要顺着这个路径走下去，不断努力总能达到。我这前十年走过的路就是鲁迅在《故乡》里说的：</p>
<blockquote><p>走的人多了，也便成了路。</p></blockquote>
<p>但之后的路，实际走的人已经不多了。之前的路就像非洲第一高峰乞力马扎罗山，这是人类可以徒步登顶的最高峰。所谓可以徒步登顶就意味着是存在一条确定的路径，只需要你坚持走下去总能走到山顶。而再往后，更高的山峰，就没有所谓徒步登顶的确定路径了。就像珠穆朗玛峰，人类已经找到一些登顶的路径，但对你的体能和其他登山技能都有特殊的要求，即使你能看见别人能攀登上去，但不代表你也能的。</p>
<p>所以，为什么我需要在此驻足停留思考下，问问自己的内心，追寻的是什么？想要去到的地方是哪里？当前是否具备了这样的前提和能力？还差些什么？然后再出发，去开辟属于自己的路。</p>
<h2>英语、读书与写作</h2>
<p>去年公司给免费提供了一个参加在线英语培训的机会，断续在线学习了一年，发现根本没有任何进步，真尴尬啊。我那时是从初中才开始学习英语的，距今已有二十多年了。但英语水平似乎从大学毕业拿了六级证后就定格在彼时彼刻了。本想利用公司的机会提高一下，发现不仅花了钱，也花了时间，但却感觉没有任何提高，还有比这更气馁的事么。</p>
<p>所以，今年憋了一口气，想真正好好把英语提高到一个能自如运用的水准。自己分析了下去年的失败在于，完全按照在线培训的节奏来，一周只有三、四小时，还分散在听说读写四项上，完全达不到必要的学习强度。因而，今年调整了节奏和强度，每天尽量抽出二、三小时在学中用、在用中学。公司今年也开通了国际互联网，访问一些原来不存在的英语世界网站也便捷了许多，不管是看技术资料还是读一些有意思或启发的文章，都尽量在英语世界中寻找第一手材料。一年过去，虽然还没能达到我的预期，但和去年相比我确实感到了进步。</p>
<p>去年下半年开始了公众号的原创写作，给自己的承诺是如无意外保持每周一篇，今年基本算是做到了。刚开始给自己订下这个承诺，最怕的是总有一天会把自己掏空，然后发现没什么可写的了。确实有这个忧虑，也正因为有了输出的承诺，所以倒逼了输入的需求，今年发现读书量比往年都提高了不少。一般来说（所谓一般，就是对非天赋异禀的人来说），写作的输入输出比大概是 100:1。每周一篇，一篇 2000 字左右，那么一年 10 万字，需要的阅读量就是 1000 万。今年一半的阅读量通过读书来完成了，另外一半大概是读的网络上的各类作者的文字了。</p>
<p>月初刚看了和菜头的《十一月写字总结》。和菜头也算在网络写作界的活化石了，国内有互联网以来他就开始写，持续十多年下来，仅上个月又写了三十多篇，还笑呵呵的表示感觉自己还没有被掏空。既然活化石还在，对大部分的网络写作者也算是一种莫大的鼓舞，我想必也还能再写下去。有时候作者和读者之间也算一种很奇妙的缘分，每天这个世界产生那么多文字，我们每年能读的仅仅是其中很小很小的一部分，因此写作本身似乎就有了一种命运的牵连感在里面。</p>
<p>前段时间看和菜头从 2003 年开始每年生日给自己写上一篇文字，颇有触动，觉得是一种特别奇妙的体验。毕竟如今十多年后过去，还能回看自己当年的想法，也是有趣。今年生日一过，便已三十有五，当此刻再想去回忆二十五时的想法，发现已变得如此模糊不清，以至于完全找寻不到。</p>
<p>所以，我也才想在生日这天也为自己写上一篇文字，记录下今年的变化和想法。在大学的时候读过好多本村上春树的小说，可惜人的记忆十分不可靠，大部分内容都忘记了，仅有一句记得特别清晰：</p>
<blockquote><p>一切都清晰得历历如昨的时候，反而不知如何着手，就像一张详尽的地图，有时反倒因其过于详尽而派不上用场。但我现在明白了：归根结蒂，我想，文章这种不完整的容器所能容纳的，只能是不完整的记忆和不完整的意念。</p></blockquote>
<p>是的，写作记录生活和想法的最佳时刻，不在其刚刚发生后印象最深的时刻，也不在十年后已经无从回忆的时刻。也许就在一年的末尾，记录下今年的一些不完整的记忆和不完整的意念，写下自己的故事。</p>
<blockquote><p>因为过去要进入未来，所以有了故事。因为在深夜里，你会想不起你是怎么从原来走到的现在，所以有了故事。</p></blockquote>
<h2>得到、失去与断爱</h2>
<p>和菜头在今年生日写给自己的文字里有一句话：</p>
<blockquote><p>过了四十岁之后，人生终于开始像一部真正的电影。什么是真正的电影？就是对于主人公而言，他的得到是真正的得到，他的失去是真的失去。</p></blockquote>
<p>李笑来年初写了本书《七年就是一辈子》，他把人生每七年当作一辈子来过。我 2009 年底离开广州到了成都，到 2016 年末正好七年，“一辈子”就这么过去了，而这一辈子过去总要总结下得到与失去。这一辈子从传统的 IT 业进入了发展迅猛的互联网电商行业，另外也完成了人生的几件大事：买房买车、结婚、生子等。</p>
<p>当物质生活的水平慢慢了提高后，渐渐对物质的追求也会慢慢趋于平淡。也许是我们从小以来一直在追求的共产主义还未实现，物质也未极大丰富，心生馁念，因而转为更多追求精神需求。</p>
<blockquote><p>得到幸福是困难的，占有一套房子一辆车子是容易的；  <br>学习新知是困难的，买套学习材料是容易的；  <br>拥有迷人的气质是困难的，买点衣服首饰是容易的；  <br>人们总是想用物质上占有的方式，解决精神上拥有的困难。</p></blockquote>
<p>上面几句，还是来自和菜头的文字。也许这就是为什么在拥有更多的物质后，我们越发显得迷惑了的原因。如今，一年过去，又辛苦了一年，犒劳下自己，去吃个几百块一位的大餐，却不免回味起当初学校附近的大排档，似乎那里的味道比这几百块的大餐更美味。据说，每个学校附近都有“腐败”一条街，那里的美味如今你哪里还能体会得到，即使今天它们依然还存在，所以，人生就是走在路上不断的得到并失去。</p>
<p>有个佛经故事，据说是释迦牟尼说法时讲的：</p>
<blockquote>
<p>有人在旅行时遇到一片大水，这边岸上充满危机，水的对岸则安全无险，他想：“此水甚大，此岸危机重重，彼岸则无险，无船可渡，无桥可行，我不免采集草木枝叶，自做一筏，当得安登彼岸。于是那人采集草木枝叶做了一只木筏，靠着木筏，他安然抵达对岸，他就想：“此筏对我大有助益，我不妨将它顶在头上，或负于背上，随我所之。</p>
<p>举了这个例子以后，释迦牟尼指出这人的行为是错误的，因为他不能断爱，那么他应该如何处置呢？ 佛陀说：“应该将筏拖到沙滩，或停泊某处，由它浮着，然后继续行程，不问何之。 因为筏是用来济渡的，不是用来背负的，世人呀！你们应该明白好的东西尚应舍弃，何况是不好的东西呢？”</p>
</blockquote>
<p>这是今年读到的一个很有启发的故事，这是一个关于行路与断爱的故事。所以每一次生日也许是一次小的断爱，每「一辈子」则可能是一次大的断爱。</p>
<p>...</p>
<p>2016，三十五，这算是午后的太阳了吧。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007843229?w=760&amp;h=1024"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<hr>
<p>写点文字，画点画儿，记录成长瞬间。<br>微信公众号「瞬息之间」，既然遇见，不如一起成长。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006760473?w=450&amp;h=335"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 2016 工作、生活与得失,1531977956,271,1,481,1,1,https://segmentfault.com/a/1190000007843225
79,1,0,9,"
                    
<h1>程序员，你真的会提问吗？</h1>
<blockquote><p>提问是软件开发的一个不可避免的环节，各种思想火花地碰撞往往能产生奇妙的结果，但是作为一名傲娇霸气君临天下的程序员，你是否真的思考和总结过自己的提问方式呢？如何去问一个让双方都满意的好问题并最大程度的得到回复呢？毕竟人生苦短，谁也不愿意为一个烂问题浪费大把好时光。</p></blockquote>
<h2>需要发起这个问题吗？</h2>
<p>提问之前，请先扣心自问下如下事项：</p>
<blockquote><ol>
<li><p>仔细思考过遇到的问题吗？</p></li>
<li><p>单凭自身的能力已经无法解决了吗？</p></li>
<li><p>搜索引擎和社区里有人提过类似的问题吗？</p></li>
<li><p>我有合适的提问人吗？</p></li>
<li><p>做好了提问前的准备材料吗？</p></li>
</ol></blockquote>
<p><em>对于各种凌乱的技术问题，程序员中，女程序员以为男程序员，什么都会；男程序员中，一般程序员以为技术好的程序员，什么都会；技术好的程序员，每次都在网上苦苦找答案......</em></p>
<h2>提问前的准备</h2>
<p>提出好的问题是你提升的第一步，提问就跟写程序一样，要有语境，要有上下文，要有条理，要有断点调试，而不是一来就要求被问人必须给出答案，毕竟谁也不曾欠谁的，帮你是热心，不帮你是本分。</p>
<ul>
<li><p><strong>确认自己无法独立解决，已经做过很多尝试</strong> ：遇到问题不要急着问别人，解决问题的独立性一定要培养出来，在时间允许的情况下先看看自己能否应付而非偷懒，一方面可以锻炼分析问题和解决问题的能力，另一方面，一旦问题解决了，问题就不是问题，而是经验和知识库。如果有条件，请记录下来，可以避免其他人在你的问题上犯同样的错误，知识作为财富是可以被散播和继承的。</p></li>
<li><p><strong>搜索引擎没有找到满意答案</strong> ：现在互联网环境总体来说已经非常开放了，诸多的技术资料和各类问答网站都可以利用，想碰到一个别人没碰到的问题，已经非常困难了，此外也不存在什么问题是一眼就可以看出答案的（如果有，只能说明这个问题太粗浅或者太常见，更没有咨询求助的必要了），你提出的问题初衷应该是对这些问题的答案并不满意，解决不了当下的问题。另外，不要排斥英文阅读，结合语境语义地阅读其实只要看关键字就好，各种翻译软件也随时可查，要知道你的问题可能早已经被人解决只是并非用中文来表述，所以请多多使用google和stackoverflow等知识搜索引擎，会有很多意外之喜。</p></li>
<li><p><strong>找对要咨询的目标人选</strong> ：如果做了努力依然不能解决，或者客观条件不允许你自己解决了，那么首先要选择提问对象，确保他是你所知道的最佳解决人选，并且对你的问题会感兴趣，所以选择一般的建议顺序是：同事 &gt; 社区 &gt; 软件作者(github私信)，一定要在解决问题的时长，质量，响应速度上做到均衡，毕竟没有人会时刻准备着为你提供各种无私的服务。</p></li>
<li><p><strong>用最干练和扼要的语言来提问</strong> ：多用清晰的短句来作为你遇到的问题的发问标题，如果无法总结，那就贴出你的关键代码和报错日志，不要让被问人在梳理你的问题本意上浪费过多时间。</p></li>
</ul>
<h2>至关重要的正文</h2>
<p>一篇提问的内容如同一篇好的破案报告一样，既要有客观详实的叙述，也要求有尝试方案的记录，这是对问题的起码尊重，如果连你自己对问题的表达的不清晰全面，怎么能指望被问人从中发现更多有价值的思路。</p>
<ul>
<li><p><strong>不要先入为主地固守自己的方法</strong>：切记不要一上来就强调自己的每一步操作都是对的，为何结果不对，这种是极其不负责任的做法。想想既然你都有如此的主见，为何还需要来咨询他人，另外你确定这样做不会把提问人带进沟里？子还曰过""三人行，必有我师焉""，虚心求教，放低姿态，是对他人与问题的起码尊重。</p></li>
<li><p><strong>提供你的运行上下文</strong> ：程序的运行都会依赖自身所处的执行环境以及对应的各种配置项参数，这些通常包括有：操作系统、数据库、浏览器、框架等相关软件及其版本号等等，参考下自己公司用来记录bug的报告（如jira，issue list等），通常测试系统在报告一个问题时都会有非常规范的叙述模板，一般包括：出错表现、运行环境、错误日志等多要素，所以尽可能地按照这些来要点组织你的提问语言和线索。</p></li>
<li><p><strong>问题是否可以重现，怎样重现</strong> ：请尽可能地详细地复现出错步骤，找出问题复现的一般规律，通常解决问题的关键点其实就是某一段小代码或者某个配置项不对，复现的过程中会逐步减少出错的范围，这会极大的节省调试时间，同时也能激起各种解决问题的灵感。</p></li>
<li><p><strong>描述下之前使用过的解决方式</strong>：把你的自己之前用过的方式都简明扼要地记录下，可以是日志、程序中的try catch信息、出错截图等，这个有点类似排除法，一来避免求助人在同样的操作上浪费时间，二来也是对求助人的尊重，说明自己至少是尝试过解决而非直接上来乞讨答案。</p></li>
</ul>
<h2>尽量清楚地描述问题</h2>
<ul>
<li><p><strong>善于利用编辑器</strong>：有良好的排版可以提高可读性，减少阅读成本，如果条件允许请多用协作调试平台和代码片断分享工具，尽可能地让被问人和你接触到的代码环境保持一致（如果是站点发问咨询也可以额附上代码片断和github公有库地址），真实环境下的实时调试会比口若悬河地文字描述效果好的多；</p></li>
<li><p><strong>实时跟进和完善你的提问内容</strong>：一个复杂的问题往往不是一步到位解决，而是通过一个个片断的持续改进与更新来最终完成，所以每当解决一个关键点时，请及时同步你的进度信息，持续优化与集成，而不是把问题甩出去后就与我无关，等着拿成果就行，毕竟作为当事人没人比你需要更对这件事的整体进度负责。</p></li>
<li><p><strong>就事论事，不要附加负面情绪</strong>：很多时候我们遇到的问题往往自己也无法避免，比如选用了不熟悉的语言，框架，不成熟的技术选型等，这种情况下往往会有各种槽点和不服想倾述，但请记住这些东西你自行消化或者找个地方写篇长文批判下都行，但是不要带到你的提问内容中，因为这些信息对解决问题没有任何实质性的帮助，同时会带来不少负面的情绪。既然已经跳到坑里了，首先应该想到的是怎么尽快跳出来并且确保以后不再掉进来，而非一直在抱怨是谁挖的坑。</p></li>
</ul>
<h2>写在最后</h2>
<p>提问是门学问，请认真对待，在提问的过程中不断提升归纳问题，分析问题的能力，不断提升自我才是最终目的，一个好的提问会跟好的回答同样精彩，同时别忘了给每一个帮你解答过的人说声谢谢。</p>
<h2>延伸读物</h2>
<p><a href=""https://book.douban.com/subject/25806793/"" rel=""nofollow noreferrer"">提问的艺术</a></p>

                ", 程序员，你真的会提问吗？,1531977958,455,1,818,1,1,https://segmentfault.com/a/1190000007610773
80,1,0,9,"
                    
<h2>说明</h2>
<p>此快捷键说明我是翻译官方的快捷键说明的，方便查看，基于PHPStorm的官方Help来翻译的，其他系列的JetBrains软件应该都是一样的道理，其中如有错误，欢迎斧正。</p>
<h2>编辑</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Ctrl + Space</td>
<td>代码自动完成提示（选择）</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>显示意图动作和快速修复</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>参数信息（在调用方法参数忘记的时候，提示）</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>快速查找文件，可以查找当前类定义的文件等</td>
</tr>
<tr>
<td>Ctrl + 鼠标滑过</td>
<td>基本信息</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>生成代码...(细节需要多次操作会发现很有意思)</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>重写方法（在PHPStorm中是重写父类方法，会有选择框）</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>实现方法（一般是指实现接口类或抽象类方法）</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>环绕代码块 (if..else, try..catch, for, 等)</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>单行注释(//)</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>块注释 (/**/)</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选择依次递增的代码块，具体使用目前来看比较少</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>去掉当前选择返回上一个选择，类似于撤销选择，与上面的相反</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>格式化代码，一般来说，写的代码格式不整齐统一，这个很有用</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>自啮合线，这个解释不太好解释，测试结果就是会自动根据代码来进行对齐</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制当前行或选定的块</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除插入符号所在行</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>智能线连接（HTML和JavaScript才有用）</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能分割线 (HTML 和 JavaScript 才有用)</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>开始新行，比如光标在当前行，不需要切换到行尾按Enter，直接按这个组合键即可</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>切换选中的英文文字的大小写，此处其实用到挺多的</td>
</tr>
<tr>
<td>Ctrl + Shift + ] 或 [</td>
<td>选择直到代码块的开始或结束，我之前不知道这个，其实很有用</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除从当前光标到当前单词结尾</td>
</tr>
<tr>
<td>Ctrl + Backspace</td>
<td>从光标位置删除到当前单词的开始</td>
</tr>
<tr>
<td>Ctrl + + 或 -</td>
<td>这里是ctrl和加号或者减号产生的组合，可以折叠或展开当前代码块</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭活动中的tab</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>从历史粘贴</td>
</tr>
</tbody>
</table>
<h2>调试</h2>
<hr>
<p><em>此处我是用得很少</em></p>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>F8</td>
<td>跳过</td>
</tr>
<tr>
<td>F7</td>
<td>步进</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>跳出</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>表达式求值</td>
</tr>
<tr>
<td>F9</td>
<td>恢复程序</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>切断断点</td>
</tr>
<tr>
<td>Ctrl+Shift+F8</td>
<td>查看断点</td>
</tr>
</tbody>
</table>
<h2>运行</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Shift + F10</td>
<td>运行</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>调试</td>
</tr>
<tr>
<td>Ctrl + Shift + F10</td>
<td>从编辑器运行上下文配置（Run context configuration from editor），此处可能翻译不够准确</td>
</tr>
<tr>
<td>Ctrl + Shift + X</td>
<td>在命令行运行</td>
</tr>
</tbody>
</table>
<h2>搜索/替换</h2>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Ctrl + F/R</td>
<td>查找/替换</td>
</tr>
<tr>
<td>F3/Shift + F3</td>
<td>查找下一个/上一个</td>
</tr>
<tr>
<td>Ctrl + Shift + F/R</td>
<td>在目录中查找/替换</td>
</tr>
</tbody>
</table>
<h2>查找哪些地方使用</h2>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Alt + F7 / Ctrl + F7</td>
<td>当前文件查找被使用/在文件中查找哪些地方使用</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>文件中搜索并在使用的地方高亮显示</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示哪些地方被使用</td>
</tr>
</tbody>
</table>
<h2>导航</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Ctrl + N</td>
<td>跳转到指定类</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>跳转到文件</td>
</tr>
<tr>
<td>Ctrl + Alt + Shift + N</td>
<td>跳转到符号</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>跳转到第几行</td>
</tr>
<tr>
<td>Alt + Right/Left</td>
<td>切换编辑器活动窗</td>
</tr>
<tr>
<td>Esc</td>
<td>Go to editor (from tool window)</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>弹出最近编辑文件，我也是在写这文档才知道，太方便了</td>
</tr>
<tr>
<td>Ctrl + Alt + Left/Right</td>
<td>导航前进/后退</td>
</tr>
<tr>
<td>Ctrl + Shift + Backspace</td>
<td>跳转到最近编辑的代码位置</td>
</tr>
<tr>
<td>Alt + F1</td>
<td>在任何视图中选择当前文件或符号</td>
</tr>
<tr>
<td>Ctrl + B 或 Ctrl + Click</td>
<td>跳到申明（如跳转到当前函数声明的地方，这个很常用，可以实操一下）</td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>与上面相反，跳到执行位置</td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>打开快速定义查找</td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>跳到超级方法(super-method)/超类 (super-class)</td>
</tr>
<tr>
<td>Alt + Up/Down</td>
<td>跳转到上一个或者下一个方法，在编辑一个类的时候，方便一个一个的方法进行查看</td>
</tr>
<tr>
<td>Ctrl + ] / [</td>
<td>跳转到代码块的开始或结束</td>
</tr>
<tr>
<td>F2 / Shift + F2</td>
<td>跳转到上一个或下一个高亮错误地方，这个检查代码语法错误很有用</td>
</tr>
<tr>
<td>F4 / Ctrl + Enter</td>
<td>编辑源代码/查看源代码</td>
</tr>
</tbody>
</table>
<h2>重构</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>F5/F6</td>
<td>复制/移动</td>
</tr>
<tr>
<td>Alt + Delete</td>
<td>安全删除</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名</td>
</tr>
<tr>
<td>Ctrl + Alt + N</td>
<td>内联变量</td>
</tr>
<tr>
<td>Ctrl + Alt + M/V/F/C</td>
<td>提取方法/变量/字段/常数(Method/Variable/Field/Constant)</td>
</tr>
<tr>
<td>Ctrl + Alt + Shift + T</td>
<td>重构这段代码（显示所有可用的重构），比如if else if 这种语句转switch语句</td>
</tr>
</tbody>
</table>
<h2>VCS/本地历史</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Alt + 反引号 (`)</td>
<td>‘VCS’ 快速弹出，此处需要注意这个反引号在最左上角，和那个~符号在一起的，ESC键下面</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>提交项目到VCS</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>从 VCS 更新项目</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>显示最近更改</td>
</tr>
</tbody>
</table>
<h2>常用操作</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>快速按两次 Shift</td>
<td>搜索任何一个地方</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找方法(Action)</td>
</tr>
<tr>
<td>Alt + #[0-9]</td>
<td>打开相应的工具窗口（这个我也没搞明白）</td>
</tr>
<tr>
<td>Ctrl + Alt + F11</td>
<td>开启或关闭全屏模式</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>开启或关闭最大化编辑</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到收藏列表（我觉得这个功能很神奇，不知道为啥要这么做）</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>检查当前文件以及当前配置文件</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开设置对话框（表示会与QQ默认快捷键冲突）</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>在 tabs 和工具窗口间切换</td>
</tr>
</tbody>
</table>
<h2>插入模板/片段(针对PHPstorm)</h2>
<hr>
<table>
<thead><tr>
<th>快捷键组合</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>Alt + J</td>
<td>插入模板</td>
</tr>
<tr>
<td>eco</td>
<td>‘echo’ 语句</td>
</tr>
<tr>
<td>fore</td>
<td>foreach(iterable_expr as $value) {…}</td>
</tr>
<tr>
<td>forek</td>
<td>foreach(iterable_expr as $key =&gt; $value) {…}</td>
</tr>
<tr>
<td>inc/inco</td>
<td>‘include’/‘include_once’ 语句</td>
</tr>
<tr>
<td>prif</td>
<td>private function</td>
</tr>
<tr>
<td>prof</td>
<td>protected function</td>
</tr>
<tr>
<td>pubf</td>
<td>public function</td>
</tr>
<tr>
<td>rqr/rqro</td>
<td>‘require’/‘require_once’ 语句</td>
</tr>
<tr>
<td>更多...</td>
<td>其他自己尝试</td>
</tr>
</tbody>
</table>

                ", JetBrains系列IDE快捷键大全,1531977960,547,1,474,1,1,https://segmentfault.com/a/1190000007206543
81,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007004555?w=938&amp;h=580"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最近在进一步思考程序员的成长，曾经写过一篇<a href=""http://mp.weixin.qq.com/s?__biz=MzAxMTEyOTQ5OQ==&amp;mid=2650610534&amp;idx=1&amp;sn=653dbd5b54b32f232dc86f973b30e983"" rel=""nofollow noreferrer"">《程序员的成长阶梯和级别定义》</a> ，里面写了我对程序员主要成长阶段的定义，但在程序员从初级走向资深的过程中，会面临两个支路，一个叫「技术主管」，另一个则是「架构师」。为什么这是两条支路？因为现在回过来看，这两条路从来都不是程序员的自然成长路径，下面我们先从「技术主管」开始吧。</p>
<h2>技术主管</h2>
<p>技术主管，有些公司可能又叫「技术经理」，英文一般是 Tech Leader 或简称 TL。在拉姆·查兰 (Ram Charan) 那本《领导梯队》中提到一个人的工作角色中至少有百分之五十以上的时间是花费在管理事务上，那么他的角色才算是一个经理（Manager）。所以技术主管（经理）类似产品经理属于以经理命名却是非经理的角色。</p>
<p>「技术主管」是开发团队中的某位程序员需要对一起创建系统的整个开发团队负责时所承担的角色。通常他既要对最终交付的软件系统负责，另外也会像一个程序员一样去开发实现系统。一个技术主管的 60% ～ 70% 的时间可能花在了开发任务分解分配、开发实践、代码审核和风险识别上，而余下的 30% ～ 40% 的时间则花在为了保障系统按时交付所需的各种计划、协作、沟通、管理上。和团队管理者不同的是，技术主管的大部分管理工作都是针对具体研发任务和技术事务的。</p>
<p>例如：在一个开发团队中经常会碰到因为技术方案和实现细节方面的分歧，如果程序员无法自主友好的完成对不同技术意见的统一，这时候技术主管就需要介入去了解两种不同意见所造成的冲突。对事不对人的去把问题搞清楚，分析各自方案的利弊，必要的时候甚至能够提出第三种更好的技术方案，以帮助开发团队达成共识。</p>
<p>另一方面，技术主管即使在日常的开发实现中，重点的内容一般也不是放在某个具体的功能实现上。在完成了具体的开发任务评估、分解并分配后，技术主管应该负责设计整体代码的结构和规范、必要时引入能提高整个团队生产力的新工具，推广代码模板，总结最佳实践。他需要经常性的关注整个团队完成一项研发任务的水平和实际要求的水平的差距问题，让团队不仅满足及时的软件系统交付，同时又得到成长。</p>
<p>现实中，一个开发团队中最优秀的程序员容易被指定承担技术主管的角色，但优秀的程序员又很容易陷入到实现功能的细节中，满足于完美的实现，优雅简洁的代码。实际上，这样优秀的程序员转入技术主管这个角色后，就很容易尝试控制设计和代码的实现，他们很难接受代码不按照他们希望的方式去编写，这个是他们作为优秀程序员一直以来的工作习惯，长此以往他们自身很容易变成整个开发团队的瓶颈，而团队里的其他成员却未能得到足够的锻炼和成长。</p>
<p>所以技术主管实际相比团队里的其他程序员对系统的视角更开阔，以更有策略和长远的方式来考虑问题。他们即使拥有比团队里所有其他程序员更高超的开发实现技能，对所有开发任务拥有最强大的实现自信，也需要转变为另一种「借助他人使之实现」的能力和自信，因为技术主管是一个承担更广泛责任的角色，必然导致能够专注有效编码的时间会相比以前减少很多，而这一点正是优秀程序员转变为技术主管的所面临的最大挑战之一。</p>
<p>最后，我们总结下技术主管的职责要求：</p>
<ul>
<li>
<p>技术职责</p>
<ul>
<li>
<p>研发任务管理</p>
<ul>
<li><p>工作量评估</p></li>
<li><p>任务分解、分配</p></li>
<li><p>代码审核</p></li>
<li><p>风险识别</p></li>
</ul>
</li>
<li>
<p>技术能力提升</p>
<ul>
<li><p>代码规范制定和推广</p></li>
<li><p>生产力工具研发和推广</p></li>
<li><p>最佳实践总结和推广</p></li>
</ul>
</li>
<li><p>关键代码实现</p></li>
</ul>
</li>
<li>
<p>组织职责</p>
<ul>
<li><p>协调沟通</p></li>
<li><p>招聘面试</p></li>
<li><p>教练指导</p></li>
<li><p>复盘总结</p></li>
</ul>
</li>
</ul>
<h2>架构师</h2>
<p>看完上面关于技术主管的职责能力要求，想必你会有些疑惑，感觉好像很多条目对架构师也是这么要求的。对，你的感觉没错，技术主管的角色与架构师这一角色会产生一些职责上的重叠，事实上我自己认为在团队规模比较小的时候（10 多人的规模），架构师和技术主管的职责几乎完全重叠，甚至技术主管还会代理一些团队主管的角色。</p>
<p>和技术主管一样，架构师也是一个在业界拥有著名的称谓，但在绝大部分公司却不属于一个职位序列。许多公司都很纠结于如何定义架构师的角色，以及架构师所做的工作。以前听阿里同学说 P7 属于架构师职位，不过最近在看另一个阿里同学写的文章说：“前几年是有专职的「架构师」职位的，现在已经回归到「工程师」、「技术专家」、「研究员」这样的纯技术职位。”。可见在一线互联网公司关于架构师的定义也是很模糊的。</p>
<p>曾经在一篇文章《在首席架构师眼里，架构的本质是...》提到了一个架构师能力模型，我曾经写过结合我自己的经历和经验，这个能力模型针对架构师这个角色来说还是比较符合的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007004556?w=851&amp;h=414"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>但正因为业界和公司对架构师这个角色的职责定义很模糊，所以很多经验积累到一定程度的优秀程序员，并且在公司内被提升到一定高度的技术级别后，都会冠以架构师之名。但实际情况是大部分刚刚冠以架构师之名的优秀程序员，其能力模型大部分停留在上图中的蓝色区域，而对其他区域并未有过系统性的认识和训练。</p>
<p>看过了架构师的能力模型，我们再来试着分析下对应的职责。随着软件系统复杂度和规模的提升，团队也相应变大，那么一个架构师此时所处的职责位置就开始和技术主管区别开来，如果把技术主管想成是站在楼顶看整个系统，那么架构师此时就是需要挂个气球（此处脑补下动画《飞屋环游记》的场景），飞到天上去看整个系统了。</p>
<p>除了技术主管的技术职责之外，架构师还需要站在更高的纬度去做关于软件系统的抽象和封装。如果技术主管的抽象和封装层次更多考虑的是语言函数、设计模式、代码结构等这一类的事务，那么架构师是站在整体软件系统高度，考虑不同子系统之间的交互关系、技术的合理性、需求的完整性、未来的演进可能性，技术体系发展与组织、产品商业诉求的匹配度。</p>
<p>这是相对技术主管更高纬度的全局视角，另一方面依然有很多技术主管可能感觉没把握的技术决策和技术争端需要架构师的介入协调。之所以要找架构师来对一些技术争端和方案进行决策判断，很多情况在于程序员对架构师在技术领域内专业力和影响力的信任，而建立这种专业力和影响力是实际构建架构师非权威领导力的来源。</p>
<p>这里提到一个「非权威领导力」，这是什么？非权威是相对权威而言，管理者的权威领导力来自于公司正式任命的职位和职权，而架构师在大部分公司基本连职位职责都没定义清楚，更没有职权一说，所以实际上就不会有任何权威领导力。所以，架构师要发挥更大的作用和价值就需要去构建自己的非权威领导力，而这需要长期的专业力和影响力积累，而关于如何去积累并很好的发挥作用，这一点我也还在摸索，还没有形成很系统的认知体系。</p>
<p>另一方面，架构师的组织职责除了技术主管承担的之外，架构师还承担着在技术团队和非技术团队（例如：产品设计等团队）之间的接口作用，明确产品的边界，勾勒技术蓝图，协调不同技能的技术团队协作，完成最终的软件系统交付。这时架构师的角色就像服务化架构中的 API，定义了协作规范、交互协议和方式，但并不会聚焦在具体的实现上。</p>
<p>在更大规模的系统上，架构师似乎还要去涉猎更多的跨领域知识，否则很可能无法做出最适合的技术决策。但人终究是有局限的，你不可能学完所有领域，所以特定的领域又会涌现一些垂直领域的架构师。比如：数据架构师、网络架构师、业务架构师、安全架构师。因而某一个领域背景出身的架构师，他对其他领域也只能做个初步了解，当需要作出关于涉及其他领域的架构决策时，他就需要和其他领域的垂直架构师做深度的沟通交流，以辅助决策判断。</p>
<p>最后，我们还是总结下架构师的职责要求：</p>
<ul>
<li>
<p>技术职责</p>
<ul>
<li><p>继承技术主管的职责</p></li>
<li><p>高纬度的系统设计、抽象和封装</p></li>
<li><p>产品技术蓝图绘制与关键技术决策</p></li>
</ul>
</li>
<li>
<p>组织职责</p>
<ul>
<li><p>继承技术主管的职责</p></li>
<li><p>跨技术和非技术团队的接口协作</p></li>
</ul>
</li>
</ul>
<h2>发展取舍</h2>
<p>从一开始，我就提到技术主管和架构师是程序员自然成长路上的两条支路，始终停留在上面「出色程序员」能力模型域的程序员是无法很好的胜任技术主管和架构师这两个角色的。所以程序员在成长到一定阶段就需要去考虑是否真要往技术主管和架构师的方向发展。而从技术主管走到架构师相对而言更有延续性，但技术主管也会有另一条路，就是转型走上纯管理岗位，成为一名真正意义上的经理。</p>
<p>一旦选择走入架构师这条路，基本你就从一名出色的程序员这个领域走出，需要尽快去补充上面能力模型中指出的其他能力。这一点会让刚刚走上这条路的程序员很不适应，因为承担了更多其他职责，就必然要减少在编码实现的时间，慢慢就会怀疑自己的编码能力会退化，也跟不上一线最新的技术栈，各种酷酷的新工具。我曾有一段时间就产生过这样的茫然与惶恐，如今算是释然了。</p>
<p>舍得，舍得，没有舍就没有得。成为架构师会拥有一个更立体的知识、技能矩阵，这是你的得。获得了一个面，在某些点上必然面临被超越的结局。如果成为一名架构师好几年后，你居然还是团队里面编码最多，编程能力最强的人，其实这是一个失败的架构师，在教练和指导这个职责上已经完全的失败了。而有些谈论架构师的文章说：</p>
<blockquote><p>架构师一定要负责整个系统中最核心和最难的地方的代码编写，如果一个团队里需要一个架构师，那他一定必须是团队里写代码能力最好的，而且要负责至少 40% 以上的核心开发工作。</p></blockquote>
<p>上面的说法就是扯淡，这样的架构师就是这个团队最大的瓶颈。一个稍具规模的软件系统和团队中，承担 40% 以上的核心开发工作，基本上这样的架构师就是一个资深程序员，而架构师的其他职责我估计他都没时间和能力去考虑了。他会意识到这种方式无法持久，同时也夺走了其他开发者的创新能力和解决问题的乐趣，一个有经验的架构师能够更好地表达某些指导原则，并且了解什么时候该插手，什么时候该放手。</p>
<p>而架构师到底要不要编码，承担多少的编码工作，不是由某种定义和说法决定的。而是由架构师自己决定的，因为架构师承担了软件系统的最终交付和过程风险识别，如果架构师认为某些关键部分，团队里没有其他人能在交付日期前写出达到他认可的足够可靠的代码，他把这识别为一种风险，决定自己完成，那么他就去编码实现，否则就委托给他认为足够可靠的团队成员，这就是前面提到的「借助他人使之实现」的能力和自信。</p>
<p>当团队里的程序员都逐渐获得成长，成了高级或资深程序员之后，架构师实际还需要写代码的机会越来越少。这方面的能力必然面临退化，所以这方面对一线技术栈的决策会越来越交给一线资深程序员来判断。但我们担心时代、环境变化，有一天又需要回到一线技术栈时，那时技术栈已经发生了巨大变化，架构师还能很好的适应么。技术的理解和基础如内功，而重新学通一门技术栈如招数，我觉得也未必需要多少时间，数月、半年或一年也许又让你恢复到在新技术栈上感觉良好的编程状态。</p>
<p>...</p>
<p>有时候安安静静的做个程序员，也挺好的。</p>
<hr>
<p>写点文字，画点画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006760473?w=450&amp;h=335"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 程序员、技术主管和架构师,1531977962,416,1,415,1,1,https://segmentfault.com/a/1190000007004552
82,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVCMqq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>项目简介：本课程将带领大家在 Github Pages 上部署自己的简历，教大家如何将简历保存为 pdf 格式且该简历文件可直接在 A4 纸上打印。另外本课程还提供了简单的在线可编辑的简历页面，同学可直接使用它来生成自己的简历文件。</p>
<p>项目由<a href=""https://www.shiyanlou.com/user/8834"" rel=""nofollow noreferrer"">ekCit</a>发布在<a href=""https://www.shiyanlou.com/courses"" rel=""nofollow noreferrer"">实验楼</a>，完整教程及在线练习地址：<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">在Github Pages上部署自己的简历</a>，可以直接在实验环境中部署实践。</p>
<h2>一、课程介绍</h2>
<h3>1. 课程背景</h3>
<p>这几天室友忙着找工作改简历，想到自己也会有这么一天，那么就来一起好好写一份简历吧。</p>
<p>期间在网上找了不少写简历的资源，我对自己写的简历模板有信心，放这个出来就是要比比看。比比看性价比，我们这个模版的价格是 0，分母是 0 就意味着性价比无穷大！</p>
<p>写这个模版的初衷是希望同一份简历既能做页面展示，也能直接打印出来给我到处投。（请认真对待每一份简历，不要学习笔者）。</p>
<p>写这份模版也是站在巨人的肩膀上，参考了前人经验的。</p>
<p>我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。</p>
<blockquote>
<p>什么是 Github Pages？</p>
<p>Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：<a href=""https://help.github.com/articles/what-is-github-pages/"" rel=""nofollow noreferrer"">https://help.github.com/artic...</a></p>
</blockquote>
<p>可以说相当于一个可直接用 git 管理内容的静态服务器，有许多人会用它来托管自己的个人博客（利用 Jekyll、Pelican 这一类静态页面生成工具）或是在这上面发布自己的 HTML5 小游戏。当然这么好的东西也是有限制的。</p>
<p>Github Pages 的限制：</p>
<ul>
<li><p>仓库存储的所有文件不能超过 1 GB</p></li>
<li><p>页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。</p></li>
<li><p>每小时最多只能部署 10 个静态网站。</p></li>
</ul>
<p>对于发布自己的简历或是部署自己的博客的这一类需求我想是不用担心这些限制的，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。</p>
<h3>2. 预备知识</h3>
<p>本课程需要的预备知识：</p>
<ul><li><p><code>git</code> 的基本使用</p></li></ul>
<p>如果对 <code>git</code> 完全陌生，推荐学习实验楼的<a href=""https://www.shiyanlou.com/courses/4"" rel=""nofollow noreferrer"">《Git 实战教程》</a>，仅需了解最基本的操作即可。</p>
<h3>3. 课程知识点</h3>
<p>本课程项目完成过程中，我们将学习：</p>
<ol><li><p>在 Github Pages 上部署自己的简历</p></li></ol>
<h3>4. 最终效果</h3>
<p>简历页面展示：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006820293"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>保存后的 pdf 版本：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820294"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<h2>二、实验步骤</h2>
<h3>1、初始化 git 库</h3>
<p>打开终端，进入 <code>Code</code> 目录，创建 <code>CV</code> 文件夹, 并将其作为我们的工作目录。</p>
<pre><code>$ cd Code
$ mkdir CV &amp;&amp; cd CV
</code></pre>
<p>初始化 git 库。</p>
<pre><code>$ git init
</code></pre>
<p>用户配置（可选）：</p>
<pre><code>$ git config --global user.name ""你的用户名""
$ git config --global user.email ""你的邮箱地址""
</code></pre>
<p>这一步不做也没关系，用户名和邮箱是你提交<code>commit</code>时的签名，在 Github 的仓库页面上会显示这次提交的用户，如果不做设置就会默认为该仓库的拥有者，做了则根据邮箱来匹配用户。</p>
<h3>2、编辑简历文件</h3>
<p>下载页面模板文件。</p>
<p>解包，并且直接将其中的文件置于 CV 文件夹下。</p>
<pre><code>$ wget http://labfile.oss.aliyuncs.com/courses/624/cv-template.zip
$ unzip cv-template
$ mv cv-template/* .
$ rm -rf cv-template* __MACOSX*
</code></pre>
<p>用浏览器打开就可以看见模板的样子了。同学们可以根据自己的需求来修改模板的样式。</p>
<p>有的同学可能已经发现这份模板是可编辑的了。</p>
<p>所有的文字栏目都是可以随意编辑的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820295"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>点击图片可以通过图片的url地址替换：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820296"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>微信号不想留就把整个栏目删掉，可增加新的条目：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820297"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>可通过点击编辑进度条，注意敏感信息不要发布在页面上，我们仅在需要打印简历时用到这些信息：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820298"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>注意简历的内容不要超出背景的高度。</p>
<p>编辑完自己的简历以后，就把修改后的代码复制下来，替换掉原<code>index.html</code>里的代码。</p>
<p>Firefox 下：</p>
<p>打开查看器：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820299"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>复制 html 标签的外部 HTML：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>然后将index.html中的 html 标签的所有内容（包括 html 标签）替换掉即可。</p>
<p>我的本意是发布后的简历页面仍是可编辑的，这方便我日后直接在上面编辑手机等个人信息后保存打印。</p>
<h3>3、部署简历文件</h3>
<p>首先需要每位同学都有自己的 Github 账号，没有就快去注册一个吧。然后新建一个仓库，名字取 cv 或是 resume 皆可，之后先别跟着它给的步骤做。</p>
<p>Github Pages 支持托管的页面分两类，个人/组织页面 与 项目页面，其主要区别就是托管位置的区别。<br>如果想使用个人主页，那么就创建一个名为 <code>username.github.io</code> （username需要替换为你的用户名）的库，在主分支<code>master</code>上托管你的页面代码。</p>
<p>如果是使用项目主页，那么可以选择将代码托管在<code>master</code>、<code>gh-pages</code>、或者<code>master</code>的<code>doc</code>目录下，其中<code>gh-pages</code>是默认的页面托管分支，如果想使用<code>master</code>，可在项目页面的设置栏中进行切换。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820301"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>无论使用哪一种页面操作都是差不多的，这里就用项目页面来做演示了，由于我们所有的代码就只有页面代码而已，那么就直接在<code>master</code>分支上进行托管吧。</p>
<p>先在本地仓库做一次代码提交：</p>
<pre><code>$ git add .
$ git commit -m 'commit my cv'
</code></pre>
<p>在项目页面找到你的仓库地址后输入：</p>
<pre><code>$ git remote add origin 你的远程仓库地址
$ git push -u origin master
</code></pre>
<p>代码提交到远程仓库后，在项目页面设置 Github Pages 使用的托管源。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820302"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>现在你可以访问<code>https://你的用户名.github.io/resume/</code>这个地址了，恭喜，简历页面已成功部署在了 Github Pages 上。</p>
<h3>4、保存简历为 pdf 格式</h3>
<p>笔者考察过多个在线转换 pdf 的网站以及 js 保存 pdf 的方案，效果都不甚理想。最后发现这一步其实可以很简单，你只要打开浏览器的打印选项然后它其实是可以直接帮你保存为 pdf 的！这里还是推荐使用 Chrome ，Firefox 似乎无法删页脚与页眉。</p>
<p>Chrome 下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006820303"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>因为等到打印 pdf 的时候，那个页边距是可以再调的，所以笔者比较倾向于在保存的时候不保留页边距。</p>
<p>完整教程可在<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">实验楼</a>查看并在线完成，有更详细的简历编辑及部署细节，还有<a href=""https://www.shiyanlou.com/courses/624"" rel=""nofollow noreferrer"">简历模板福利</a>。<br>更多经典项目：<a href=""https://www.shiyanlou.com/courses"" rel=""nofollow noreferrer"">全部-课程-实验楼</a></p>

                ", 程序员必备技能：在Github上部署自己的简历,1531977964,283,1,780,1,1,https://segmentfault.com/a/1190000006820290
83,1,0,9,"
                    
<blockquote><p>欢迎来我的博客阅读：<a href=""http://huang-jerryc.com/2016/08/30/%E4%BD%95%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/"" rel=""nofollow noreferrer"">「何为技术人的核心竞争力」</a></p></blockquote>
<p>在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。<br>不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。</p>
<p>最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。<br>可能是因为我天资愚钝，没能通过自学看懂这本书。<br>如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。<br>虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。<br>要说我编程的功底，也就只有两年的功力。</p>
<p>在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。<br>在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。<br>渐渐的会想到这样的一个问题：<br><strong>技术人的核心竞争力到底是什么？</strong></p>
<p>今天受<strong>刘未鹏</strong>先生在书中《暗时间》的介绍，阅读了<strong>孟岩</strong>老师的「<a href=""http://blog.csdn.net/myan/article/details/3247071"" rel=""nofollow noreferrer"">技术路线的选择重要但不具有决定性</a>」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。<br>这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。</p>
<p>文中把技术人大致的分了四类：</p>
<ol>
<li><p>把命运寄托在<strong>事业</strong>上的人</p></li>
<li><p>把命运寄托在<strong>组织</strong>上的人</p></li>
<li><p>把命运寄托在<strong>技术</strong>上的人</p></li>
<li><p>仍然处于出卖劳动力的人</p></li>
</ol>
<h1>做技术的几类人</h1>
<p><strong>第一类是把自己的命运寄托在一项事业上。</strong><br>他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。</p>
<p><strong>第二类是把自己的命运寄托在组织和团队上</strong><br>他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。<br>但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。</p>
<p><strong>第三类是把命运寄托在技术上。</strong><br>他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。</p>
<p><strong>第四种就是处于出卖劳动力的阶段</strong><br>他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。</p>
<p>第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。<strong>被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。</strong></p>
<h1>核心竞争力</h1>
<p>关于核心竞争力，孟岩先生有这样一段话：</p>
<p>那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他<strong>独特的个性知识经验组合</strong>。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，<strong>1，绝无仅有；2，在实践中有价值，3，具有可持续发展性</strong>，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。</p>
<p>个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是<strong>独特的个性、知识、经验之间的组合</strong>。</p>
<h1>不可替代性</h1>
<p>孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：<br><strong>1. 绝无仅有</strong><br><strong>2. 在实践中有价值</strong><br><strong>3. 具有可持续发展性</strong></p>
<p><strong>刘未鹏</strong>先生在书中《暗时间》给出了他对这个问题的补充：</p>
<p>我相信以下的知识技能组合是具有相当程度的不可替代性的：<br><strong>1. 专业领域技能。</strong><br>成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。<br><strong>2. 跨领域的技能。</strong><br>解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。<br><strong>3. 学习能力。</strong><br>严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是<strong>持续学习</strong>和<strong>思考知识</strong>。<br><strong>4. 性格要素。</strong><br>严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。</p>
<p>除了<strong>刘未鹏</strong>先生上面的四点，我需要补充的还有一点：<br><strong>5. 学历与背景</strong><br>虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。</p>

                ", 何为技术人的核心竞争力,1531977965,528,1,571,1,1,https://segmentfault.com/a/1190000006770379
84,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006760655"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>本文翻译自 <a href=""http://queue.acm.org/detail.cfm?id=1854041"" rel=""nofollow noreferrer"">Thinking Clearly About Performance</a> 这是我三年前读到的一篇关于性能问题的好文，读完后还觉不过瘾，怕理解的不够遂又翻译了一遍，这也是当年我的第一次翻译。</p>
<p>这几年来每次碰到性能问题，我都会想起这篇文章，它并不像很多其他关于性能问题的文章，告诉你利用什么工具怎么去解决性能问题，这类文章更多属于「术」的层面，而术的层面在不同的技术栈会有很不同的选择。而本文则高屋建瓴的帮助读者建立起对性能的正确认识，从而能够获得更全面的视角去看待和思考性能问题。这是「道」的层面，正所谓道法自然，术变万千，深刻理解了「道」，那么面对性能问题的万千之「术」才不会那么茫然。</p>
<p>文章略长，建议先收藏，稍后合适时抽出一块时间来细细读之，当有所获。</p>
<h2>摘要</h2>
<p>对于开发者、技术管理者、架构师、系统分析师和项目经理来说，创建具备高性能特征的复杂软件都是一件极其困难的事。然而，通过了解一些基本原理，性能问题的解决和预防可以更简单可靠。本文讲述了这些基本原理，涵盖了一系列的目标、术语、工具和决策，综合利用好它们来最大可能的创建一个长期有效的高性能应用。本文的一些例子来自于 Oracle 的经验，但本文的范围并不局限于 Oracle 的产品。</p>
<h2>目录</h2>
<ul>
<li><p>公理化方法</p></li>
<li><p>什么是性能？</p></li>
<li><p>响应时间 VS. 吞吐量</p></li>
<li><p>百分比指标</p></li>
<li><p>问题诊断</p></li>
<li><p>序列图</p></li>
<li><p>性能剖析</p></li>
<li><p>阿姆达尔定律</p></li>
<li><p>偏斜度</p></li>
<li><p>最小化风险</p></li>
<li><p>效率</p></li>
<li><p>负载</p></li>
<li><p>队列延迟</p></li>
<li><p>拐点</p></li>
<li><p>拐点的相关性</p></li>
<li><p>容量规划</p></li>
<li><p>随机到达</p></li>
<li><p>相关性延迟</p></li>
<li><p>性能测试</p></li>
<li><p>测量</p></li>
<li><p>性能是一项功能特性</p></li>
<li><p>尾声：关于「拐点」的公开辩论</p></li>
<li><p>关于作者</p></li>
<li><p>参考</p></li>
</ul>
<hr>
<h2>1. 公理化方法</h2>
<p>当我在 1989 年加入 Oracle 公司时，解决性能问题（人们通常说的是 Oracle 调优）是很困难的。 只有少部分人声称他们很擅长这个，很多人都去咨询他们。 当时，我进到 Oracle 调优这个领域时，我完全没准备好。 最近我又开始对 MySQL 进行调优，这看起来和我 20 年前在 Oracle 公司做的差不多。</p>
<p>它让我想起了当我 13 岁刚接触代数学时是多么的困难。 在那个年龄我只能依靠「数学直觉」来解决类似 3x + 4 = 13 这样的方程。 问题是我们之中大部分人都没有所谓的「数学直觉」。 我记得当看到这样的问题: 3x + 4 = 13 求解 x，只能采用试错法偶然发现 x 应该是3。</p>
<p>试错法给我的感觉虽然能解决一些简单的方程式，但很慢而且不爽。 一旦等式稍有变化如 3x + 4 = 14，试错法就不能适应。 那么该怎么办呢？当时我没有好好思考过，直到 15 岁时 James R. Harkey 指引我走上正确的道路。</p>
<p>Harkey 先生教会我使用公理方法来解决代数方程问题。他给我们展示了一系列的步骤（还给了我很多家庭作业进行练习）。做作业时除了记录下这些步骤，还要写下我们是如何思考的。这样我们不仅自己想得很清楚，而且通过一系列可靠的、可重复的步骤来向阅读我们作业的人证明了我们确实搞明白了。 Harkey 先生看到的我的作业像下面这样：</p>
<pre><code>3.1x + 4 = 13               
待求解方程
3.1x + 4 - 4 = 13 - 4
减去相等的值
3.1x = 9
加法逆运算，化简
3.1x ∕ 3.1 = 9 ∕ 3.1
除以相等的值
x ≈ 2.903
乘法逆运算，化简求解</code></pre>
<p>这就是 Harkey 先生教导的适用于代数学、几何学、三角学和微积分的公理化方法。 由一系列符合逻辑的、可证明的和可审计的小步骤组成。这是我第一次真正从数学中学到的东西。</p>
<p>自然，当时我没能认识到其中的价值，但证明作为一种技能对我后来的成功至关重要。我发现在生活中，知道一件事很重要，但能向别人讲清楚（证明）更重要。没有好的证明技能，就很难成为一名好的顾问、好的领导甚至好的员工。</p>
<p>我在上世纪 90 年代中期的目标是为 Oracle 性能优化创建一套类似的、严格的公理化方法。后来我将其扩展到了 Oracle 之外，建立了一套适用于所有计算机软件性能优化的公理化方法。好吧，我发现并非所有人都喜欢这种说法，那我们换一种说法：</p>
<blockquote><p>我们的目标就是帮助你想清楚如何优化你的软件系统性能。</p></blockquote>
<h2>2. 什么是性能？</h2>
<p>假如你去 Google 下 Performance 这个关键字，可能会得到 5 亿个链接。 其中涉及的内容范围可能从自行车比赛到可怕的员工审查流程（如今很多公司已经学会了避免这个流程）。但假如我去 Google 下 Performance 这个关键字，大部分的首页链接都会与这篇文章的主题有关：__计算机软件执行无论何种任务所花费的时间。__</p>
<p>任务这个词是一个很适合的开始。任务是一个面向业务的工作单元。任务能够嵌套：打印发货单是一个任务，打印一张发货单（一个子任务）也是一个任务。当一个用户说起性能时，他通常指的是系统执行一系列任务所花费的时间。__响应时间__ 是任务的执行时长，用每个任务的时间来度量，像每点击秒数。例如我用 Google 搜索关键字 Performance 的响应时间是 0.24 秒。 这个数据来自我的浏览器它渲染完 Google 网页花费的时间，那么很明显，这量化了我对 Google 性能的直觉感知。</p>
<p>一些人对另外一个性能指标很感兴趣：吞吐量。 <strong>吞吐量</strong> 是在一个特定时间段内完成的任务的计数，例如：每秒点击数。通常为一群人提供服务比为个别人提供服务的人更关心吞吐量。例如，一个独立会计会更关心日报的响应时间是否会导致今晚需要加班，而会计部的经理更关心系统的是否能支撑所有的会计处理完今天的数据。</p>
<h2>3. 响应时间 VS. 吞吐量</h2>
<p>通常来讲，响应时间和吞吐量是一个倒数关系（响应时间越长吞吐量越低），但这并不确切。 实际情况更微妙、复杂一些。</p>
<p><strong>例 1</strong>  <br>假如，在一些性能基准测试中，你的系统的测量结果是每秒能处理 1000 个任务，那么用户的平均响应时间是多少？  你可能会说平均响应时间等于 1 / 1000 = 0.001 秒/每任务，但它真不是这样的。</p>
<p>假如在你的系统内部拥有 1000 个相同的、独立的、并行的服务执行通道，每个通道都在等待请求到来并提供服务。 在这种情况下，每个请求其实花费了 1 秒。</p>
<p>现在我们知道，平均响应时间其实应该在每任务 0 秒到 1 秒之间。 但是我们不能仅仅从吞吐量的测量数据中推导出平均响应时间。（事实上存在数学模型从吞吐量推导出平均响应时间，但这个模型要求更多的输入参数，而不仅仅是吞吐量） 你必须单独测量它。</p>
<p>反过来说也是一样的，你应该能从我上面给出的例子中得到启发。 下面是一个更有趣的例子。</p>
<p><strong>例 2</strong>  <br>你的客户要求一个新任务必须满足在单核 CPU 的计算机上达到每秒 100 的吞吐量。  假如这个新任务在客户的系统上执行一次需要 0.001 秒。 那么你的程序能够满足客户要求的吞吐量么？</p>
<p>你可能会说，跑一次这个任务只需要千分之一秒，那么在一秒内完成 100 次显然是绰绰有余的。 恩，是的，你很正确，假如这个任务被很好的串行化了。  例如，你的程序处理 100 个任务执行请求是在一个循环中，一个接一个的执行，那就是正确的。</p>
<p>但是如果这 100 个任务到达你的系统是完全随机的来自 100 个不同的用户，那该怎么办呢？CPU 调度器和串行资源（Oracle 的闩和锁，内存可写缓冲区访问）这些糟糕的实际情况会严格限制你的并发吞吐量低于每秒 100。  最终，你可能会达到客户的期望也可能达不到。 你不能仅仅从响应时间推导出吞吐量，你必须单独测量吞吐量。</p>
<p>所以，响应时间和吞吐量不是那么简单的互为倒数关系。 你想要知道这两个指标，就必须一起测量它们。那么响应时间和吞吐量到底哪一个更重要呢？ 在一些场景下，说哪一个都是合理的。 但在大多数情况下，两者都同样重要。 因为，对系统来说它的业务需求通常是这样的，在大于 99％ 的情况下响应时间要少于 1 秒，并且能支持 10 分钟内持续不低于 1000 的吞吐量。</p>
<h2>4. 百分比指标</h2>
<p>在上一节，我用了“大于 99％”这样的描述来表达对响应时间的期望。 但大部分人可能更习惯于这样的描述：“平均响应时间少于 r 秒”。 但从经验的角度，使用百分比方式更好。</p>
<p><strong>例 3</strong>  <br>假想每天运行在你的计算机上的任务的响应时间的容忍极限是 1 秒。进一步假设「表1」列出了该任务执行 10 次的测量值。 这两个列表的平均响应时间都是 1 秒。哪一个你认为更好？</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662321"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>虽然你看到两个列表拥有同样的平均响应时间，但本质上差别很大。ListA 90％ 的响应时间是低于 1 秒的，而 ListB 只有 60％ 的时间是低于 1 秒的。从用户体验的角度来说，ListB 表明会有 40％ 的用户会感到不满意，而 ListA 仅有 10％ 的不满意率，虽然它们平均响应时间相同。</p>
<p>ListA 90％ 的响应时间是 0.987 秒，而 ListB 90％ 的响应时间是 1.273 秒。 因此使用百分比描述的响应时间比平均响应时间包含更多的信息量。</p>
<p>正如 GE 公司所说：“客户感受到的是差异变化，而非平均”。（参见GE的《什么是六西格玛》） 可见使用百分比来描述响应时间更符合终端用户的期望：例如，99.9% 的跟踪货运单的任务必须在 0.5 秒内完成。</p>
<h2>5. 问题诊断</h2>
<p>最近我被邀请去解决的一些性能问题的描述都是些关于响应时间的。 如：“过去只用不到 1 秒的时间就能完成 X 任务，但是现在却需要 20 秒。” 当然，一些真正的问题隐藏在其他一些问题描述的表象背后，例如：“我们的系统变的很慢，完全没法用了。”</p>
<p>虽然我经常碰到类似这样的表述，但并不意味着你应该这样去描述问题。 首先你得清晰得描述问题本身，才可能把它们弄清楚。 一个好办法是去询问，你想要达到得目标状态是怎样的呢？ 找到一些细节，你可以用量化的方式来表达它们。 例如：执行 X 任务大部分情况下都超过 20 秒，希望能在 95% 的情况下小于 1 秒。</p>
<p>理论上这听起来很棒，但要是你的用户根本没有很具体的可以量化的目标呢？或者你的用户根本就不知道怎样去量化，更糟糕的情况是你的用户如果还有一些完全不切实际的期望怎么办？你如何知道到底什么是“可能的”，什么是“不切实际的”？</p>
<p>好吧，下面我们继续探讨这些问题。</p>
<h2>6. 序列图</h2>
<p>序列图是一种 UML（统一建模语言）中定义的图形种类，用于表达对象间交互的发生顺序。序列图特别适合用于可视化的表达响应时间。 在「图1」中，我们展示了一个由浏览器、应用服务器和数据库构成的简单应用系统的序列图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662325"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>假如我们扩展下序列图的表示，让请求和响应之间距离表示服务该请求的消耗时长。 在「图2」中我展示了一个扩展后的序列图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662323"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>通过「图2」你可以很直观的看到到底是哪个部分消耗了最多的时间。你能直观的感受到整个响应时间在各个部分的构成。序列图很好的帮助人们从概念上直观的理解一个任务如何在系统各个部分之间顺序流转的。序列图也能很好的表达并行执行的任务。序列图也是一个很棒的工具用于在业务层次分析性能问题。</p>
<p>序列图是很好的描述性能问题的概念工具，但要把性能问题分析清楚我们还需要其他的。序列图的问题是，假设有个任务花费了 2468 秒才执行完成（大约 41 分 8 秒）。 在这 41 分钟里，应用服务器和数据库大约交互了 322968 次。 把这个过程画成序列图大概就是下面「图3」的样子：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662327"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在应用服务器和数据库之间有如此之多的箭头，以至于你完全看不清细节了。我们可能需要花费数周才能画完这个图，但这并不是一个有效的方法。序列图虽然很好的概念可视化了任务的执行流和时间流，但要仔细分析清楚响应时间的问题我们还需要别的工具。</p>
<h2>7. 性能剖析</h2>
<p>对于像上述这种拥有大量调用交互的情况，序列图不能很好的描述。我们需要一种更方便的聚合视图来更容易的理解到底哪个部分消耗了最多的时间。 「表2」给出了一个性能剖析的例子。性能剖析是对响应时间的表格化分解，按响应时长倒序排列如下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662330"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>例 4</strong>  <br>「表2」中的性能剖析是很初级的，但它能告诉你最慢的 8 个任务占用了 2468 秒。从中你大概可以得到每个函数的响应时长占比。也可以从中算出每个函数调用的平均响应时间。</p>
<p>性能剖析指出了哪些代码花费了你的时间，也许更重要的是告诉你哪些代码并没有花费太多时间。当你不得不去猜测代码的性能瓶颈时，性能剖析是有巨大价值的。</p>
<p>从「表2」的数据表明，大约 70.8% 的响应时间消耗在了 <code>DB:Fetch()</code> 这个方法上。如果你进一步深入方法调用中会发现 <code>App:await_db_netIO()</code> 方法与 <code>DB:Fetch()</code> 的一一对应关系。于是能知道每个部分消耗了多少时间，通过性能剖析你开始能够明确的回答像这样的问题：“这个任务需要运行多长时间？”从第 5 节你可以知道，对问题诊断的第一步来说这是一个很重要的问题。</p>
<h2>8. 阿姆达尔定律</h2>
<p>性能剖析能帮你分析清楚性能问题。即便吉恩·阿姆达尔（Gene Amdahl）在 1967 年没有告诉我们阿姆达尔定律，你也可以在看到性能剖析表格时自己归纳出来。阿姆达尔定律指出：</p>
<blockquote><p>系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。</p></blockquote>
<p>所以如果你尝试改进的部分只占总响应间的 5％，那么对总响应时间的提高最多不会超过 5％。这意味着你改进的部分在性能剖析列表中排位越高（假设它们按倒序排列），你获得的收益就越大。</p>
<p>但这并不意味着你一定要按照性能剖析列表的顺序从高到低进行改进，这里你还需要考虑改进的成本问题。</p>
<p><strong>例 5</strong>  <br>看下「表3」,它基本和「表2」一样。「表3」额外给出了你实施最好的改进方案所能达到的效果以及相应的实施成本。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>那么你应该先实现哪一项改进呢？阿姆达尔定律告诉我们改进第一项的潜在收益最大，大约可以减少851秒（34.5% * 2468秒）。但改进第一项真的非常昂贵，那么改进第二项也许能产生更多的净收益。这才是我们真正需要改进的瓶颈所在，尽管它仅能节省大约 303 秒。</p>
<p>性能剖析的巨大价值在于你能够确切的了解你预期的投资能获得多大的改进，它为你的改进实施方案提供了决策支持，为你在预测给性能问题的度量时提供了参照。__当你能够找到一种比预期成本更低，减少响应时间比预期更多的改进方式时，这给你了一个很好展示聪明才智的机会。__</p>
<p>你首先实施哪一项改进，归结于你对成本评估有多大把握。简单省事的改进的措施是否考虑了改进可能造成的系统风险？一个很简单的改进，例如调整了某个参数，取消了一个索引可能会潜在的破坏了一些目前性能表现良好的功能，而你又完全没考虑倒。__靠谱的成本评估则是展现你技术能力的另一个领域了。__</p>
<p>另一个因素值得考虑的是，你可以通过一些小的成功来积累政治资本。也许一些便宜低风险的改进并不能带来响应时间的大幅度降低，但可以通过跟踪记录这些小改进来印证你对响应时间提升的预测。在神话和迷信统治了数十年的软件性能领域，这些对性能的预测和印证的跟踪记录，可以影响你的同事（工程师、经理、客户）并建立自己的信誉，然后你才可能实施更昂贵的改进方案。</p>
<p>最后提醒一句：当你不断取得胜利并建议实施成本更高、风险更大的改进措施时，可千万别掉以轻心。信任是很脆弱的，你做了很多事情才取得信任，但可能只是因为一次粗心大意的错误就会摧毁它。</p>
<h2>9. 偏斜度</h2>
<p>当你使用性能剖析时，你会反复遇到类似这样的衍生问题。</p>
<p><strong>例 6</strong>  <br>从「表2」中可以看到一共调用了 322,968 次 <code>DB:fetch()</code> 方法，花费了 1748.229 秒。假如我们将调用量降低一半，那么响应时间会降低多少？答案绝对不会是降低一半，花点时间思考下面这个更简单点的例子。</p>
<p><strong>例 7</strong>  <br>调用 4 个方法花费了 4 秒钟，那么减少为调用 2 个方法花费多少时间？答案依赖于我们省掉的调用到底是哪些方法。你可能这样假设了，每个方法的平均调用时间就是 4 / 4 = 1 秒。但我可没在问题描述中告诉你每个方法的调用耗时是一样的。</p>
<p><strong>例 8</strong>  <br>假设下面两种可能性，每个列表列出了 4 个方法调用的响应时间</p>
<pre><code>  A = {1, 1, 1, 1}
  B = {3.7, .1, .1, .1}</code></pre>
<p>在 A 中响应时间是一致的，所以无论我们省掉了哪两个调用，最后响应时间都能缩短到 2 秒。但在 B 中，到底省掉哪两个方法调用对响应时间的影响是有很大差别的。如果我们去掉头两个调用，响应时间缩短为 0.2 秒，提升了 95%。但如果我们去掉的是后两个调用，响应时间变为 3.8 秒，仅仅提升了 5％。</p>
<p>偏斜度表达在一组值中的非一致性程度。正是因为偏斜度的存在，所以你没法准确的回答我在本节开头的问题。 让我们再回头看看这个例子：</p>
<p><strong>例 9</strong>  <br>在不知道偏斜度的前提下，你只能回答响应时间可能减少的范围是在 0 到 1748.229 秒之间，这也是你能提供的最好的回答了。</p>
<p>尽管如此，假设你有一些额外的信息，如「表4」所示，你就能对最好和最坏的情况进行估算。进一步说，假如你有了「表4」中信息就会很聪明的去特别优化响应时间在 0.01 秒到 0.1秒 之间的那 47,444 个调用。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662336"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>10. 最小化风险</h2>
<p>前面的章节我提到过，当修复一个任务性能问题时可能破坏另一个任务的性能，让我想起了一件曾经在丹麦发生的事。这个故事很短：</p>
<p><strong>场景</strong>    <br>在丹麦的巴勒鲁普自治市（Måløv）的一张橡木餐桌前，大约 10 个人围坐一起，在用笔记本工作和相互交流。</p>
<p><strong>Cary：</strong> 伙计们我快热死了，你们不介意我打开窗户放点冷空气进来吧？  <br><strong>Carel-jan：</strong> 为什么你不把你的厚毛衣脱了呢？  </p>
<p><strong>完。</strong></p>
<p>在这里，有个乐观的人都知道的一般性原则在发挥效力：__当大家都很舒适除了你以外，那么你首先应该确保影响自己的东西是否正常，否则你可能去搞乱一些全局的东西导致每一个人都受影响。__</p>
<p>正是这个原则，当因为几个写的很烂的 Java 应用程序有人建议我去调整 Oracle 的网络包大小时让我感到很害怕。这些很烂的程序产生了很多不必要的数据库调用，自然也产生了很多不必要的网络等待。当其他一切正常除了这几个烂程序，那么最安全的做法是将调整的范围本地化，只需要去调整这几个烂程序就好了。</p>
<h2>11. 效率</h2>
<p>即便依赖此系统进行工作的所有人都很痛苦，你依然需要首先专注于业务上最优先需要修正的程序部分。让程序工作的尽可能的高效是一个很好的切入点。在不增加容量，不牺牲必须的业务功能的前提下，效率是能够节省下来的任务总执行时间的倒数。</p>
<p>换句话说，效率就是从反面对浪费进行的度量。下面是一些经常发生在数据库应用中浪费的例子。</p>
<ul>
<li><p>一个中间层程序为插入数据库的每条记录创建了一条独立的 SQL 语句。它执行了 10,000 次数据库预编译语句调用，导致了 10,000 次网络 I/O 调用。其实它可以只使用一条预编译语句，从而节省 9,999 次网络 I/O 调用。</p></li>
<li><p>一个 SQL 语句访问数据库缓冲区缓存 7,428,322 次获得了 698 行的结果集。使用一个额外的过滤预测，只返回了终端用户真正想要看见的 7 行结果，只需访问缓冲区缓存 52 次。</p></li>
</ul>
<p>确实如果一个系统存在一些全局性的问题（不良索引、错误参数、弱弱的硬件配置）导致了一大片任务执行的低效率，你应当修正它。但不要尝试调优系统去满足低效的程序。有很多办法来调优低效的程序本身。即使这个程序是商业的现成的软件，那么和你的软件供应商一起去优化程序本身比你去优化系统让其尽可能的高效从长期来说会更受益。</p>
<p>让程序变的更高效会让工作在这个系统上的每一个人都受益巨大。很容易看到浪费的减少对任务响应时间的贡献。但依然有很多人不明白为什么提升这部分程序的性能会导致一种副作用，让看起来完全不相关的另一个程序性能变差。</p>
<p>其实这是系统负载在作祟。</p>
<h2>12. 负载</h2>
<p>负载（Load）是并发任务执行时引发的资源竞争。负载正是我们为什么不能在性能测试中捕捉到所有性能问题的原因，而这些问题以后会在生产环境发生。负载的一个测量指标是使用率，使用率反应了资源按时间分片的使用情况。当某个资源使用率上升时，那么请求该资源服务的用户就不得不经历更长的响应时间。任何一个在城市的高峰期开车的人都经历过类似现象。当交通变的严重拥堵时，你不得不在收费站前等待更长的时间。</p>
<p>你的汽车在开阔的道路上能开上每小时 60 英里，但在拥堵的路上只能以每小时 30 英里的速度行驶，而软件不会像汽车这样真的变慢。软件按照固定的同样的速度执行，每个时钟周期总是执行同样数量的指令，但响应时间会随着系统资源变的繁忙而严重退化。</p>
<p>负载上升系统变慢的原因有两个：__队列延迟__ 和 __相关性延迟__。下面我会进一步讲述。</p>
<h2>13. 队列延迟</h2>
<p>负载和响应时间之间在数学上的相关性大家都很熟悉了。一个叫做「M/M/m」的数学模型（译注：「M/M/m」是一个关于队列理论的数学模型，你无需详细搞明白也能从感性认识并理解作者的分析。）将响应时间和负载关联起来应用于一些特定的需求场景下。「M/M/m」模型的一个假设前提是你的系统模型拥有理论上的完美扩展性。这个假设非常类似于我们在初级物理学课程中经常提到的光滑表面（无摩擦力）假设。</p>
<p>虽然「M/M/m」模型假设的条件有些不现实，如完美的可扩展性，但从中依然可以学到很多。「图4」使用「M/M/m」模型展示了负载和响应时间之间的关系。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662332"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从「图4」，你从数学的角度看到了系统在不同负载条件下给你的感受。低负载下的响应时间和无负载基本一样。当负载上升时，你能感受到响应时间有一个轻微、平缓的退化。这种平缓的变化不会造成什么麻烦，但随着负载继续上升响应时间开始以一种急剧的方式退化，这可要造成大麻烦了。</p>
<p>响应时间在具备完美扩展性的「M/M/m」模型下由两个部分组成：__服务时间__ 和 __队列延迟__。</p>
<pre><code>就是这样一个等式：R = S + Q
服务时间（S）就是任务的执行时间。
队列延迟（Q）就是任务在队列中等待机会获得消费某个资源的时间。</code></pre>
<p>所以当你在 Taco Tico（美国和墨西哥边境的快餐连锁）订餐时，你的订单响应时间（R）就包括了等待服务员来餐桌边接收订单的等待时间，这就是队列延迟等待（Q），而服务时间（S）就是从订单交到服务员时到食物送到你手上的等待时间。 同样，任务的响应时间在有负载和无负载的系统之间是有差别的。</p>
<h2>14. 拐点</h2>
<p>提及性能，你想要达到两个目标:</p>
<ul>
<li><p>你想要获得最快的响应时间：你不想任务的完成需要太长的时间。</p></li>
<li><p>你想要获得最大的吞吐量：同一时间能支持更多人执行他们的任务。</p></li>
</ul>
<p>不幸的是这两个目标是相互矛盾的。__优化达到第一个目标需要你最小化系统的负载，而达到第二个目标则要最大化系统负载，二者不可兼得。__ 在这两者之间的某个负载值就是系统的最优负载。</p>
<p>处于最优负载平衡点的资源使用率的值，我称其为「拐点」。系统中某种资源达到「拐点」后，那么吞吐量被最大化了而对响应时间只有很小的负面影响。从数学上来讲，「拐点」就是响应时间除以资源利用率所得结果最小的值。 「拐点」有个很好的属性，就是位于从原点画一条直线正好与响应时间曲线相切的位置。 在一个仔细绘制的「M/M/m」图中，你能很容易的利用这个性质找到「拐点」，如下「图5」所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>关于「M/M/m」模型「拐点」的另一个很好的属性是你只需要知道一个参数就可以计算出它。这个参数就是系统中并行的、相同的和独立的服务通道数。服务通道是一种资源，它们共享一个队列，其他资源像收费站或者 SMP(Symmetric multiprocessing 对称多处理)结构的计算机中的 CPU 都是类似的概念。</p>
<p>在「M/M/m」模型中，斜体小写的 m 表示系统建模时服务通道数。对任意一个系统来说，计算「拐点」都是很困难的，好在我已经给你计算出来了。「表5」中列出了一些常见的服务通道数的「拐点」值。（此时你也许想知道在「M/M/m」队列模型中另外两个 M 代表什么。它们与请求进入时刻和服务时间的随机性假设有关。 更多请参考 Kendall's Notation 或进一步参考 _Optimizing Oracle Performance_）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>为何「拐点」如此重要？对于那些请求随机到达的系统，如果资源负载持续超过「拐点」，那么响应时间和吞吐会因为负载的轻微变化而严重波动。 所以，__对于请求随机到达的系统而言，保持负载低于拐点是至关重要的。__</p>
<p>(译注：从上面「表5」可以看出，为什么经验值将 4 核的虚拟化容器 CPU 负载红色报警点在 60%，32或64 核物理机的 CPU 负载红色报警点在 80%。)</p>
<h2>15. 拐点的相关性</h2>
<p>那么「拐点」的概念是不是真的如此重要呢？ 毕竟，我曾经告诉过你「M/M/m」模型建立在一个理想的乌托邦理念之上，那就是系统拥有完美的可扩展性。我知道你正在想什么：你想的都是错的。</p>
<p>「M/M/m」模型告诉我们，即便你的系统拥有完美的可扩展性，你依然会遭遇巨大的性能问题只要系统的平均负载超过了图表中给出的拐点。那么现实中你的系统不可能比「M/M/m」假设的理论系统更完美。所以，你的系统的真实「拐点」会比我在「表5」中给出的更小。（我在这里对拐点使用了复数形式，因为你可以基于 CPU 来建立拐点模型，同时也可以基于你的磁盘、网络 I/O 等等。）</p>
<p>再次说明：</p>
<ul>
<li><p>你的系统中的每一项资源都有一个「拐点」。</p></li>
<li><p>你的系统「拐点」都是小于或等于「表5」中给出的理论值，你的系统扩展的完美性越差，「拐点」越小。</p></li>
<li><p>对于请求随机到达的系统，如果资源负载持续超过「拐点」，你将遭遇性能问题。</p></li>
</ul>
<p>所以，保持负载低于拐点是至关重要的。</p>
<p>(译注：所以性能测试干的就是找出真实系统的负载拐点，并和理论值比较就可以看出系统的横向扩展性是否有瓶颈点。)</p>
<h2>16. 容量规划</h2>
<p>理解了「拐点」可以减少容量规划的复杂性，可以这样来规划：</p>
<ul>
<li><p>某项资源的容量就是在高峰期能轻松的运行你的任务而资源使用率不会超过「拐点」。</p></li>
<li><p>保持资源利用率低于「拐点」，那么系统表现就基本不会给你带来大的惊讶。</p></li>
<li><p>但是，如果系统中任何一项资源超出了它们的「拐点」，你就会遭遇性能问题，无论你是否意识到。</p></li>
<li><p>如果你遭遇性能问题，不要纠结于数学模型上，要修正这些问题要么重新安排下负载分配，要么减少负载，要么增加容量。</p></li>
</ul>
<p>这就是将性能管理过程和容量规划结合起来的办法。</p>
<h2>17. 随机到达</h2>
<p>你可能已经注意到了，我在前文经常提及“随机到达”这个说法，为什么它如此重要？现在一些系统拥有的特征你可能不会具备，如：完全确定的作业调度。另外一些系统被配置为接受任务的方式像是机器人模式，如每秒接受一个任务，十分固定，当然现在这些系统很少见了。我这里说的一秒一个任务，并不是说平均一秒一个任务，例如第一秒 2 个任务，而下一秒 0 个任务。我指的是均匀的一秒来一个任务，类似汽车工厂组装线上机器人的工作模式。</p>
<p>如果任务到达系统是完全确定的，就是说你完全能预知下一个请求什么时候到达，那么让资源的使用率超过「拐点」必然不会引发性能问题。对于一个任务到达很确定的系统，那么你的目标应该是将资源利用到 100%，而不是让它们排队等待。</p>
<p>「拐点」对于随机到达的系统如此重要的原因是，随机任务请求往往会聚集并引发短暂的资源使用脉冲式上升。这些脉冲式上升需要足够的剩余容量来消化它们，所以当脉冲发生时可能就会引发队列延迟并导致响应时间的明显起伏。</p>
<p>短暂的脉冲并导致资源使用率超过「拐点」也还好，只要不要持续达到数秒时间。这个数秒到底应该是多少秒呢？ 我相信（当然我没试过去证明）这个时间最好不要超过 8 秒。（来自著名的互联网 8 秒原则） 如果你无法满足在特定百分比下响应时间和吞吐量对用户的承诺，那么很显然系统脉冲上升持续时间太长了。</p>
<h2>18. 相关性延迟</h2>
<p>你的系统肯定不具备理论上的完美扩展性。尽管我从没分析过你的系统，但我敢打赌无论你的系统无论是什么样的也不具备「M/M/m」理论模型假设的完美扩展性，而相关性延迟正是你的建模不可能完美的原因。执行任务时花在对共享资源访问的协商和通信的时间就是相关性延迟。和响应时间、服务时间、队列延迟一样，相关性延迟也可以在任务的执行中被测量，例如每点击秒数。</p>
<p>这里我并不想描述预测相关性延迟的数学模型，但如果你分析过你的任务执行情况，你可以了解什么时候相关性延迟会发生。在 Oracle 中，一些同步的事件正是相关性延迟的例子：</p>
<ul>
<li><p>入队列（enqueue）</p></li>
<li><p>缓冲忙等待（buffer busy waits）</p></li>
<li><p>闩锁释放（latch free）</p></li>
</ul>
<p>你不能使用「M/M/m」来对相关性延迟进行建模，因为「M/M/m」模型假设了你的 m 个服务通道是完全并行的、等同的和独立的。这个模型假设在一个先进先出（FIFO）队列中，只要你等待的时间足够长，在你之前的请求已出队列并得到服务，那么最终你也会得到服务，但是相关性延迟不是这样工作的。</p>
<p><strong>例 10</strong>  <br>假设在一个 HTML 数据表单上，有个按钮是「更新」，点击它会执行一条 SQL 更新语句。另外一个按钮是「保存」，点击它执行事务提交将刚才的更新保存下来。如果一个应用是这样做的，我可以保证它的性能是非常糟糕的。这是因为这样一种设计，让下面的场景成为可能的，实际上这也是必然可能的。一个用户先点击了「更新」，发现到了午餐时间，然后就去吃饭了，过了两小时下午回来再点击「保存」。</p>
<p>对于想要更新同一行的其他任务来说，这是一个灾难。其他任务不得不等待获取行锁，更糟的情况下甚至是页锁，直到原来锁定的用户想起继续点击「保存」。或者 DBA 来杀掉原来锁定用户的会话，这样的话当然又会给原用户造成错觉，他以为他更新了一行实际却没有，这可糟透了。</p>
<p>在这个例子中，不管系统繁忙与否，一个任务就在那无所事事的等待锁的释放。它依赖了系统资源利用率之外的一些随机性因素。这就是为什么你不能使用「M/M/m」模型来对其进行建模。这也是为什么在一个单元测试环境下的性能测试结果不足以用来决策是否应该在生产环境添加一些新的代码。</p>
<h2>19. 性能测试</h2>
<p>我们谈到的队列延迟、相关性延迟引发了一个很困难的问题。你如何对一个新的应用进行足够的测试，让你信心满满的认为它不为因为性能问题而对你的生产程序造成破坏。你可以去建模，也可以去测试。但是，在你真正遭遇这些问题之前，为所有你可以预见的生产问题去建立模型和测试是极其困难的。</p>
<p>因此，一些人看到了这样窘境，因此申辩说那么就干脆别测试了。千万别被这样的心态所困扰。下面的观点是很确定的：</p>
<ul>
<li><p>在程序进入生产环境之前，如果你尝试去发现一些问题你肯定会比那些完全不去做的找到更多的问题。</p></li>
<li><p>在预发布的测试中，你不可能发现所有的问题，所以你需要一些可靠并有效的方法来解决这些在预发布测试中漏掉的问题。</p></li>
</ul>
<p><strong>在完全不测试和完整的生产环境模拟测试之间，存在一个适度测试量的平衡点。</strong> 当然对于一家飞机制造商来说，适度测试量肯定多于一家销售棒球帽的公司。但千万别完全跳过性能测试。至少，当你在生产环境遭遇不可避免的性能问题时，一份性能测试计划将使你成为一名更称职的诊断专家（更清晰的思考者）。</p>
<h2>20. 测量</h2>
<p>人们能感知到的就是吞吐量和响应时间。吞吐量很容易测量，相对来说测量响应时间要稍微困难些。（还记得吧，吞吐量和响应时间可不是简单的倒数关系）用个秒表来计时终端用户的行为并不困难，但你不会从中得到你真正想要的关于为什么响应时间如此之大的细节。</p>
<p><strong>不幸的是，人们总是测量他们容易测量的，而不是他们应当测量的。</strong> 当我们需要测量的东西不容易测量时，我们就把注意力转移到那些容易得到测量数据上了，这是个错误。那些并不是你真正需要的测量，但看起来似乎和你真正需要的有些相关又容易去执行的测量，我们称之为「替代指标」。 一些「替代指标」例子包括像子程序调用计数和子程序执行耗时的采样数据。对于「替代指标」，很遗憾在我的母语中没有更好的语句来表达我的想法，但有一个大家都熟悉的现代表达方式：__替代指标真是恶心。（Surrogate measures suck.）__</p>
<p>不幸的是，「恶心」在这里并不表示它没用。要是替代指标真的没用就好了，那就没人会使用它们了。问题就在于替代指标有时是有用的，这让使用替代指标的人相信它们总是有用的，但实际并不是这样。</p>
<p>替代指标有两个严重的问题：</p>
<ul>
<li><p>它们可能在系统不正常时告诉你系统一切正常，这在统计学上叫做第一型错误，假阳性。</p></li>
<li><p>它们也可能在系统正常时告诉你系统出问题了，这在统计学上叫做第二型错误，假阴性。</p></li>
</ul>
<p>这两类错误浪费了人们许多的时间。</p>
<p>当你去评测一个真实系统方方面面，你能否取得成功在于你能从那个系统中获得多少有效的测量数据。我曾有幸在 Oracle 的市场部门工作过，那时许多软件供应商围绕着我们积极的参与，这才使得正确的测量系统成为可能。让软件开发者使用 Oracle 提供的工具是另外一回事了，至少我们的产品中具备这样的能力（记录有效的测量数据）。</p>
<h2>21. 性能是一项功能特性</h2>
<p>性能是软件程序的一项功能特性，就像你在 Bug 跟踪系统中很方便的将「Case 1234」这样一个字符串自动链接到编号 1234 的 Bug 案例上。__性能像所有其他软件功能一样，不是凑巧得到的，你需要去设计和构建它。要想获得好的性能，你不得不去仔细的思考、研究、学习，写出额外的代码来测试和支持它。__</p>
<p>尽管如此，像所有其他功能特性一样，在项目初期你还在调研、设计和编写代码时你不可能知道性能到底会怎样。对大多数应用（可能是绝大多数，这个说法可能有争议）而言性能都是未知的，直到它们投入实际使用阶段。那么留给你的问题就是：__因为在上线前你不可能知道你的应用性能表现到底怎样，因此你需要在编写应用时考虑怎样很容易的在生产环境修复性能问题。__</p>
<p>正如大卫·加文（David Garvin）告诉我们的，容易测量的东西也更容易管理（来自《建立一个学习型组织》1993年发表于《哈佛商业评论》） 那么要写一个在生产环境容易修复问题的应用程序，首先要做的就是要容易在生产环境进行测量。大多数时候，当我提到生产环境的性能测量时人们就会陷入一种焦虑状态，他们很担心性能测量带来的入侵效应。他们立刻对采集哪些数据做出了妥协，只留下那些「替代指标」（更容易采集的）在数据采集表上，拥有额外数据采集代码的软件会变的比没有这些代码的更慢么？</p>
<p>我喜欢汤姆·凯特（Tom Kyte）以前对这个问题的回答。他估计额外的性能测量代码给 Oracle 带来不超过 10% 性能损失。他接着向那些气恼的提问者作出解释，正是因为从这些性能测量代码获取的数据让 Oracle 公司进一步将产品性能改进提升了不止 10%，这超出了性能测量代码本身引发的开销。</p>
<p><strong>我认为很多软件供应商他们通常花费了太多时间来优化他们的性能测量代码路径使其更高效，而不是首先搞清楚怎么让这些代码有效果。</strong> 高德钠（Donald Knuth）曾在 1974 说过的一句话印证了这个观点：</p>
<blockquote><p>过早优化是一切罪恶的根源。</p></blockquote>
<p>软件设计者将性能测量代码整合进他们的产品中更有可能创建一个高性能的应用，更重要的是这个应用会不断变的更快。</p>
<h2>尾声：关于「拐点」的公开辩论</h2>
<p>在本文的 14 到 16 节，我描述了「拐点」的性能曲线、它们的相关性和应用。但是，在 20 年前有一场关于是否值得定义一个「拐点」概念的公开辩论。</p>
<p>历史上的一个重要的观点认为我所描述的「拐点」并不是真正有意义的。在 1988 年，斯蒂芬·萨姆森（Stephen Samson）争论说至少在「M/M/1」的排队系统的性能曲线中并不存在「拐点」。 他写道：“选择一个具备指导意义的数字并不容易，经验法则还是最适用的，在大多数情况下都不存在拐点，无论你多么希望找到一个。”</p>
<p>1999 年，温水煮青蛙的故事启发了我。这个故事是这样的说的，当你把一只青蛙扔进煮沸的开水中，它会立刻跳出来。但假如你先把它放在冷水中并慢慢的加热水温，青蛙会安静的呆在水里直到被煮熟了。对于资源使用率，它就像是沸水，有一个清晰的「死亡区间」。在这个区间值内，对于随机到达的请求你的系统将不堪重负。那么「死亡区间」的边界在哪里？如果你尝试用程序来自动管理资源使用率，你就必须知道这个值。</p>
<p>最近，我的朋友尼尔·冈瑟（Neil Gunther）跟我有一场私下的辩论。首先，他认为「死亡区间」这个术语使用在这里是完全错误的，因为在函数连续性的前提下使用「死亡区间」是错误的。 其次，他认为对于「M/M/1」系统的「拐点」在 0.5 是过于浪费了，你应当更多的利用好系统资源，它应高于 0.5 的资源利用率。最后，他认为你对使用率的明确定义取决于实际的平均响应时间相对你能忍受的平均响应时间实际超出了多少。因此，冈瑟认为任何有用的使用率阈值的定义都来源于询问人们自身的偏好，而非来自于数学。（图A）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662342"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从「图B」中，我们可以看出这个说法的问题所在。 假设，你对平均响应时间的忍耐限度是 <code>T</code>，那么对应的最大资源利用率是 <code>ρT</code>。你会看到在 <code>ρT</code> 附近资源利用率一个微小的变化都会导致响应时间巨大的波动。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006662344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我相信如我在第 4 节所写的，__客户感受到的是差异变化，而非平均。__ 或许他们会说我们能够接受平均响应时间达到 <code>T</code>，但我不相信人们能忍受因为系统平均负载发生了 1% 的变化导致平均响应时间达到 1 分钟，换句话说就是平均响应时间翻了 10 倍。我确实了解我在 14 节列出的「拐点」列表比很多人直觉上感受到地安全值更低一些，特别是对「低阶」的系统如「M/M/1」而言。 尽管如此，但我相信避免因为资源使用率的微小变化引发响应时间的过大波动，这是极其重要的。</p>
<p>话虽如此，我也不知道该如何确切的定义「过大」这个词。像响应时间波动的忍耐度，不同的人有不同的底线。或许有一个起伏忍耐的因子适用于所有人。例如，Apdex Standard Application Performance Index 假设了响应时间 <code>F</code> 是 <code>T</code> 的 4 倍就会让人们的态度从「满意」变为「煎熬」。</p>
<p>正如我在 16 节中描述的，「拐点」无论你怎么去定义或称呼它，对于容量规划过程来说都是一个十分重要的参数。并且我相信它对日常的系统负载管理也是一个重要参数，我会继续保持研究。</p>
<h2>关于作者</h2>
<p>Cary Millsap 是一家致力于软件性能优化公司 Method R 的创始人和 CEO，是一位在 Oracle 全球社区著名的演讲者、教育者、顾问和作者。曾和 Jeff Holt 合著 <em>Optimizing Oracle Performance</em> 一书，更多详细信息参见作者 LinkedIn 的介绍和<a href=""http://carymillsap.blogspot.com"" rel=""nofollow noreferrer"">个人博客</a>。</p>
<h2>参考</h2>
<ol>
<li><p>CMG (Computer Measurement Group, a network of professionals who study these problems very, very seriously); <a href=""http://www.cmg.org."" rel=""nofollow noreferrer"">http://www.cmg.org.</a></p></li>
<li><p>Eight-second rule; <a href=""http://en.wikipedia.org/wiki/Network_performance#8-second_rule."" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/...</a></p></li>
<li><p>Garvin, D. 1993. Building a learning organization. Harvard Business Review (July).</p></li>
<li><p>General Electric Company. What is Six Sigma? The roadmap to customer impact.  <a href=""http://www.ge.com/sixsigma/SixSigma.pdf."" rel=""nofollow noreferrer"">http://www.ge.com/sixsigma/Si...</a></p></li>
<li><p>Gunther, N. 1993. Universal Law of Computational Scalability; <a href=""http://en.wikipedia.org/wiki/Neil_J._Gunther#Universal_Law_of_Computational_Scalability."" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/...</a></p></li>
<li><p>Knuth, D. 1974. Structured programming with Go To statements. ACM Computing Surveys 6(4): 268.</p></li>
<li><p>Kyte, T. 2009. A couple of links and an advert...; <a href=""http://tkyte.blogspot.com/2009/02/couple-of-links-and-advert.html."" rel=""nofollow noreferrer"">http://tkyte.blogspot.com/200...</a></p></li>
<li><p>Millsap, C. 2009. My whole system is slow. Now what? <a href=""http://carymillsap.blogspot.com/2009/12/my-whole-system-is-slow-now-what.html."" rel=""nofollow noreferrer"">http://carymillsap.blogspot.c...</a></p></li>
<li><p>Millsap, C. 2009. On the importance of diagnosing before resolving.  <a href=""http://carymillsap.blogspot.com/2009/09/on-importance-of-diagnosing-before.html."" rel=""nofollow noreferrer"">http://carymillsap.blogspot.c...</a></p></li>
<li><p>Millsap, C. 2009. Performance optimization with Global Entry. Or not? <a href=""http://carymillsap.blogspot.com/2009/11/performance-optimization-with-global.html."" rel=""nofollow noreferrer"">http://carymillsap.blogspot.c...</a></p></li>
<li><p>Millsap, C., Holt, J. 2003. Optimizing Oracle Performance. Sebastopol, CA: O'Reilly.</p></li>
<li><p>Oak Table Network; <a href=""http://www.oaktable.net."" rel=""nofollow noreferrer"">http://www.oaktable.net.</a></p></li>
</ol>
<hr>
<p>写点文字，画点画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006760473"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 认清性能问题,1531977968,214,1,921,1,1,https://segmentfault.com/a/1190000006662314
85,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://images2015.cnblogs.com/blog/815275/201608/815275-20160807201407731-1182270303.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我记得上次参加技术大会已经是三年前了，现在各类技术大会似乎比以前多了不少，参加这类大会的价值有多大呢？我想先从我自己以前参会的一些经历来说说。</p>
<h2>第一次</h2>
<p>第一次的参会经历是在北京参加 Velocity 的一个性能与运维技术大会。那是 2011 年的时候，我刚从传统的 IT 业进入互联网行业，正处在一个转换过渡期，对自身技术和职业发展都充满了迷茫。</p>
<p>那时正好在北京总部出差，正好这期间就开了这个会，正好我们所在项目组又分了一些公司买的票，北京的同事看我们远道而来就好客的分了几张票给我们一起出差的几个同事，所以我就凑巧参加了这个会。后来知道这个会的门票价格并不便宜（具体是多少忘记了，大概好几千吧），就很好奇并疑惑就这么两天的分享会值这么些钱么？毕竟是第一次参会，就带着这样的疑惑去了。</p>
<p>开场是章文嵩博士关于绿色计算的主题演讲，几个主题演讲结束后就是分专场的分享演讲。我至今还有比较深刻印象的是关于 Facebook 一个工程师分享当时比较火的 BigPipe 前端网页性能优化，听完后不禁感慨原来还可以这样做。还有个淘宝的工程师分享关于面向浏览器推送的主题，听的饶有兴趣，当时我还没做咚咚（IM）项目，后来开始做 IM 后，又把这个主题的材料找来反复揣摩了下，算是对我早期做 IM 给予了很多启发。</p>
<p>临到下午晚时，一些感兴趣的主题都差不多结束了，但一想票这么贵，还舍不得离开就在各个专场四处转转，看看还有什么值得听的。然后发现一个腾讯做 QQ 的工程师在讲 QQ 客户端如何融合 Web 技术来应对日新月异的互联网变化，毕竟客户端的更新相比 Web 还是难度更大而速度更慢。其中揭秘了一些我们平时使用桌面 QQ 时看上去像原生客户端实现的功能，其实都是隐藏在浏览器后面，通过一系列的伪装把浏览器的 5xx 和 4xx 错误小心的隐藏起来，让用户完全感知不到。</p>
<p>虽然我那时是一个专注后端的工程师，但也并不妨碍去了解前端和客户端的一些有趣的技术和技巧。就这样我的第一次参会经历就结束了，如果我的记忆没有差错，我当时应该是感觉收获满满的，给我当时略感迷茫的技术发展方向提供了很多指引。但站在当时的角度要不是公司买了门票，要让自己掏腰包买票我可能就会有很多犹豫不决，很大的可能是不会去了。但今天的我再回过头去看，我会想告诉曾经的我即使自己掏钱也是值得去的，所以今天当我在面对一些有利于学习和成长的新东西或从未尝试过的体验时，只要需要付出的价格没有达到无法承担的地步，为学习和成长付出一点试错成本应该是必要的，何况有时这种付出带来的未来潜在收益可能会远远超出预期。</p>
<p>我看到的是，大部分人为学习和成长花费的代价，可能还没有花吃、穿、玩上面多。</p>
<h2>再次</h2>
<p>再次参加技术大会是两年后了，这次是在杭州，阿里举办的技术嘉年华（ADC）。其时，我已经做咚咚快两年了，一路踩了不少坑，也还碰到不少疑惑没有特别有信心的答案，借这次技术大会的机会也想去找找看做阿里旺旺的同学一起交流下。</p>
<p>这次大会除了有专场分享的主题大会场，还有更垂直专业化的 LOFT 小空间分享，更适合面对面交流。听了几个主题后，我后来就找到了阿里旺旺的后端负责人进行面对面的交流沟通。其时，阿里旺旺已经发展到一个业务稳定期，日均 1200 万淘宝卖家和用户在线。所以他们后端开发的主要工作不像当时我们主要是应对业务的快速发展，而是不断优化效率降低成本。比如：当时阿里旺旺后端是 300 多个服务，部署了 1600 台物理机，他们通过不断重构和优化服务程序，把业务快速发展期欠下的技术债逐步还掉，计划当年缩减服务器到 1000 台以内。</p>
<p>如果说我参加第一次技术大会是帮助拓展了眼界，看清了发展方向，在茫然中找到了路径。那么这次参加则是聚焦在一个特定领域关联的技术范围内，寻找行业中领先者切磋交流，并增强了一些路径选择上的信心。</p>
<p>大部分我们正在走的路，可能都是有人已经走过的，有人告诉你前面还有路，你就会走的更坚定而快速了。</p>
<h2>选择</h2>
<p>以上就是我参加过的仅有的两次技术大会，现在技术大会年年都有，一年还有不同主办方的不同大会，我们应该参加多少呢？我觉得还是看个人需求，这样的大会如我前面所说，有可能会给你带来启发和指引，也有可能给你机会去和前方的同行深度交流，若你有遇到适合的大会，适合的主题和适合的同行，就不应犹豫和错过，毕竟付出的成本实际并没有多大。</p>
<p>当然，除了这类成长类的需求，还有些人可能是有社交性的需求，所以来参会。但实际上我个人感觉在这种技术大会中寻求社交有点虚无缥缈，也许这和我本身有社交恐惧有关，所以我更喜欢写文字来分享。</p>
<p>正在写这篇文章时，还看到朋友圈有人更新说：「有些分享太软了，开头两分钟和结束三分钟是主题软广，中间都是硬广。」呵呵，所以大家在如今越来越多的大会分享中，可要擦亮眼镜，做好选择。即使是在一个以高质量著称的技术大会上，你也不可能听完所有的主题，必需做出选择与取舍。这就是一个技术人面临的永恒主题，你永远学不完所有的技术，你的日常就总是在做出选择与取舍。</p>
<p>当我们一个都不想错过时，往往全部都错过了。</p>
<p>...</p>
<p>现在都是哪些人爱在技术大会上分享呢，我观察了下大部分的讲师会集中在他们工作年限的十年左右，左一点可能是是七八年，右一点可能是十一二三年。这正是他们工作经验积累并梳理总结成型的一个爆发期，再短一些则积累不够，再长一些则可能就过了这个阶段了。</p>
<p>所以作为一个程序员、技术人，你需要在合适的时候去邂逅一两场适合自己的技术大会，不多，不少。不仅可以去听，其实也可以去讲。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。<br><span class=""img-wrap""><img data-src=""http://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 技术大会值得参加吗？,1531977970,599,1,311,1,1,https://segmentfault.com/a/1190000006197447
86,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010063204?w=658&amp;h=370"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最近朋友圈有篇文章《为何我工作十年，内心仍无比恐慌》转的比较多，来自一个腾讯产品总监的演讲。我一个程序员也工作了十年，确实依然感到内心的恐慌，这种职业焦虑在这个行业普遍存在。也许正是因为互联网行业还很年轻，一个行业的寿命远超过一个人的寿命，而互联网行业还不到三十年。远超传统行业的发展速度和新陈代谢规律，让其中的从业者深感疲惫，而对未来又充满了不确定性。而未来的不确定性通常正是心力交瘁的一个主要原因。</p>
<p>那篇文章中提到产品的从业门槛足够低，作者十年的从业经历中见过从事产品的来自各种专业，还有各种改行做产品的。从业门槛主要来自于技能门槛，特别是硬技能，硬技能属于行业的专有技能，需要足够的时间积累，想起一万小时理论了吧。而产品看起来是一个缺乏硬技能门槛的行业，因此门槛低。而程序员是有一定硬技能门槛的，而这种门槛随着技术和工具的进步正在变的越来越低。</p>
<p>互联网行业如今当然是繁荣的，繁荣的行业吸引大量其他行业的从业者进入。这些进入者自然会选择门槛低的来跨越边界，所以在其他行业干了些年头的人还可以通过垂直行业专家来进入互联网行业。对程序员来说我很少见到在其他垂直行业积累经年者进入，如果有这可能是真爱了。一般都是在大学或刚毕业不久就完成了行业属性的转换，比如我，比如有个高中文科班女生本来读中文系，大二就毅然开始辅修计算机的第二学位了。而还有个行业一直繁荣，需求永续存在而且供不应求，却从没见过任何其他行业的人进入的。我说的是医生这个职业，它的硬技能门槛之高让人联想起《冰与火之歌》里的绝境长城，让人完全兴不起翻越的欲望。我听说过小说写的好的前妇产科医生，却没听说过手术做的好的前小说家。</p>
<p>医学院的学生本科都要比其他专业多读一年，但本科毕业然并卵，至少读到硕士，想有点发展还得读博，十年一晃而过。而本科毕业的程序员，一进入互联网行业可能拿的工资比医学博士生刚进入医院还高，这就是行业繁荣的好处。坏处是互联网用户娇惯坏了，他们善变，喜新厌旧追求激情，你 out 了，没什么错只是老了。所以互联网公司喜欢年轻人，标榜年轻，你看公司员工平均年龄 25，所以我们懂年轻人，我们是最好的。而医生呢，你是喜欢年轻有激情的医生，还是有经验的老医生呢。</p>
<p>之前看过一本小说里有一些角色叫「天下行走」，他们都有自己厉害的独门绝技，不厉害怎能天下行走。剑客的剑快，野人的身体坚硬如铁，和尚从不说话修的闭口蝉，一开口就人人色变。以前玩过一个游戏《暗黑破坏神》，正常不作弊的玩，一个角色你很难点亮所有的技能，游戏是会故意这样设计的。所以你可以反复玩来尝试点亮不同的技能组合方式，这样游戏才具备反复的可玩性。与游戏不同，人生只有一次，你无法点亮所有技能，只有唯一的一种点亮路径塑造独一无二的你。</p>
<p>我成为一名 Java 程序员是偶然的，你成为一名 C++ 程序员也可能是偶然的，早期的技能点亮策略有很多偶然性。古龙小说中有个角色叫荆无命，他腰带右边插着一柄剑，剑柄向左，是个左撇子，江湖中都知道他左手剑快，但他右手剑其实更快。荆无命要是个程序员，那就是 Java 很强，C++ 更牛，但我从业这些年还没碰到过同时点亮两者的。无论 Java 还是 C++ 因为各自都有足够大的生态和体系，需要很长的时间来积累。</p>
<p>需要长时间积累的技能，都是从业者的核心硬技能，核心硬技能需要修何种程度才能天下行走？如果刚开始起步算 0，那么 1 算是行业平均水准，那至少先要专注在核心硬技能上并修行到 1 以上。核心硬技能之间是一种加和关系，而围绕核心硬技能还有很多辅助技能，可以发挥指数作用。所以这也是为什么核心硬技能要先修行到 1 以上，指数关系只有在大于 1 时才有意义。辅助技能大多属于软技能，也有部分硬技能，只是没有核心技能那么硬，通常起到放大和加强核心技能的作用。有些辅助软技能可以通过刻意练习来掌握，而有些则很难，属于埋藏在天生的基因和后天的成长性格中。在《火影》的忍术体系中对这种天生的技能有个术语叫「血继限界」，其中最变态的当属「写轮眼」。想想在职业发展技能体系中，有什么是可媲美「写轮眼」的辅助软技能，如果你幸运拥有可别浑然不知哦。</p>
<p>读中学时老师说：「学好数理化走遍天下都不怕」，不怪老师骗人这是时代的局限性。程序员怕什么，就怕技术潮流的颠覆直接废了你全身武功。读大学时就经历了一次，当时主流的企业应用开发是 C/S 架构的 Delphi 和 VB，如今安在。武功体系由内力加招式组成，技术的演进容易废了招式，却不容易废了内力。张无忌九阳神功一身内力惊人，招式现学现卖也打的少林龙爪手高僧叫屈。所以在点亮技能树的过程中，你得分得清九阳神功和龙爪手的区别，方能一技压身，天下行走。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006760473?w=450&amp;h=335"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 一技压身，天下行走,1531977971,435,1,677,1,1,https://segmentfault.com/a/1190000006172378
87,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866479"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>编程是门艺术，这个说法由来已久。最近在朱赟的公众号（滴答滴答）读到一篇文章《设计是门逻辑学，然后才是美学》，文中作者漂洋过海追寻艺术，老师却说：“设计不是艺术！”。如果设计都不是艺术，那么编程还能是艺术么？</p>
<h2>艺术</h2>
<p>那么艺术到底是什么？我一下懵了，发现从来没有想过这个问题，只好求助于 Google。Wikipedia 上的定义是：「艺术是具有智能思考能力的动物（目前其实只有人类吧），借由各种形式及工具借以表达其情感与意识形态，所产生的形态泛称之为艺术。」</p>
<p>而上面那篇文章中老师的观点是：</p>
<blockquote><p>设计是实现别人的需要，艺术是自我表达的需要。</p></blockquote>
<p>和 Wikipedia 的说法相近，核心都在于表达。而目前公认的艺术分类，包括八大艺术种类：</p>
<ol>
<li><p>文学</p></li>
<li><p>绘画</p></li>
<li><p>音乐</p></li>
<li><p>舞蹈</p></li>
<li><p>雕塑</p></li>
<li><p>建筑</p></li>
<li><p>戏剧</p></li>
<li><p>电影</p></li>
</ol>
<p>它们的共性是这些都是人类自古以来的创造，其中最年轻的艺术门类当属「电影」了，其作品承载了作者的情感和意识形态。而所有被公认的艺术门类，显然它们最终作品呈现出的艺术表达形态更容易被普通人直接的感受到，直接作用于人们的视觉、听觉和触觉感官。</p>
<p>关于编程是一门艺术这个概念，到底什么时候钻入程序员的头脑中的呢？也许来自我们在学习编程的路上，很多讲述编程的书籍都冠以艺术之名，比如：《UNIX编程艺术》，这是一本讲述 Unix 专家们在创造 Unix 过程中形成的理念和文化，那么技术文化是艺术么？还有另一本程序员中的圣经《计算机程序设计艺术》，我们都知道，却几乎没读过。这是一套讲述算法，并基于数学来推导和论证算法的基础书籍，那么算法是艺术么？</p>
<p>编程的直接产物是代码，代码是面向程序员的，而非普罗大众。编程的间接产物是信息产品，在当下这个信息时代，信息产品的形态很多样化，可以是你手机上的 App，也可以是你每晚打开的电视。很可能一切和电子相关的东西，在当下或多或少都和编程有关，但我们发现即使是在这些间接产物中，也找不出一样可以让我们很严肃的把它归为艺术。即使是神化的乔布斯时代，我们给予的最大赞誉也只是苹果的每件产品都像艺术品一般。仅仅是像，像可以无限逼近，但毕竟还不是。</p>
<p>所以相对而言，编程也如设计是实现别人的需要，像我在这写作倒更多是自我表达的需要了。编程受限于程序语言的表达能力，是不可能达到像自然语言的表达能力的，因此编程的艺术性，它的受众也只可能是程序员们。虽然面向大众的艺术，很多大众也表示看不懂，但至少能感受，而编程艺术则是只有程序员本身才可能感受得到了。</p>
<h2>技术</h2>
<p>程序员的日常编程工作就是编写代码，完成功能，实现别人的需要。在这个过程中不小心就还会制造一些 bug，程序员也不知道这些 bug 是怎么变出来的，就像你天天在家做饭，不知道怎么厨房里就多了那么多小强。美食也不属于公认的艺术门类，但时不时我们会听到美食艺术的说法，这一点倒是和编程艺术很像。但若是你在创造美食的过程，时不时冒出些小强，哪里还有去感受艺术的心思。程序员大部分时候就是在不断的解决源源不绝，生生不息的 bug，这个过程与艺术无关，只与技术有关，技术越练越好，bug 也就越来越少。bug 少到我们能腾出精力和心思，才能去感受编程的艺术性。</p>
<p>编程的艺术源于技术，没有技术则艺术成了无源之水，无根之木。所以那些冠以「艺术」之名的程序书籍其实都是讲的技术或者技术原则与文化。而关于编程最基础的技术当然是写好代码，而如何写好代码这件事以前看过王垠写过的一篇长文《编程的智慧》，其中观点我都认同，包括下面一些方面：</p>
<ul>
<li><p>反复推敲代码</p></li>
<li><p>写优雅的代码</p></li>
<li><p>写模块化的代码</p></li>
<li><p>写可读的代码</p></li>
<li><p>写简单的代码</p></li>
<li><p>写直观的代码</p></li>
<li><p>写无懈可击的代码</p></li>
<li><p>正确处理错误</p></li>
<li><p>正确处理null指针</p></li>
<li><p>防止过度工程</p></li>
</ul>
<p>文章很长，但花点时间细细读来，必有收获，其中关于推敲代码这点于我感触最深。</p>
<blockquote><p>看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。<br>我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。</p></blockquote>
<p>我曾经自己维护了一个项目，包括一些样板代码，称手的小工具等等。每一年我都会抽业余时间对这个工程做一次重构，一些代码随着技术发展而过时了，一些则被重新实现变得更简洁。每年的一次回顾，对过去自己的审视，对代码的推敲都带来新的成长，这个过程持续了大约七年。</p>
<p>在技术成长到了一定阶段，有些程序员就会开始不满足于仅仅实现别人的需要，也会在代码里尝试自我表达。最基础且最明显的表达是为代码签名，打上自己的标签，要是雷军二十年前没有为那段汇编代码签名，我们今天哪里知道这会是雷军写的，并在这里评头论足。但依然有很多程序员不会为自己的代码签名，连机器生成的代码都会签名说这是自动生成的，而一份没有签名的代码是缺乏艺术最基本的要素「自我」的，永远停留在艺术的门槛之外。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>另一些程序员则不止于此，比如 Redis 的作者 @Antirez，你会在 Redis 启动控制后台看到下面的启动画面，这个程序字符精心打印出来的 Logo 无关乎任何功能和别人的需要，只是作者的自我表达而已。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866481"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>而另外一段代码中，单元测试通过后的输出中每个 case 会有一个笑脸，在调试代码的寂寥中增加点点暖意。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866482"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>进一步回归到源代码本身，代码同时是主观的和非主观的。编码非主观的方面就包括一些创建好代码必须遵循的「硬」规范：设计模式，项目结构，公共库的使用等等。 虽然这些概念奠定了高质量、可维护代码的基础，但正是程序员间不同的技术与工具的细微差别，微妙的风格选择——对齐方式、命名、空格使用、语境利用、语法高亮和IDE的选择——真正使代码清晰、可维护和容易理解，同时也使得代码更好的表达了其意图、功能和用法。</p>
<p>任何人都可以遵循设计模式或其他一些「硬」规范来编写代码，但有艺术追求的程序员会以自己的方式来填充代码的细节，使代码变得清晰、简洁、易懂。 这很重要，正如每个人都可以从一件艺术品中体会到独一无二的意义，不管代码的架构和设计怎样，每个开发者或代码阅读者可能也会从代码的命名和其他约定习俗中推断出不同的含义。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866483"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>就像上面一段对得整整齐齐的代码声明块，没有语法或硬性的风格要求程序员要这样写。我只是觉得这样更符合视觉感受，更容易清晰分辨。而这一点 Poul-Henning Kamp 曾在 ACM Queue 发表文章提出了一个迷人的观点：</p>
<blockquote><p>很多编程语言的风格源自于 ASCII 字符集和基于打字机的终端。编程语言没有利用现代设备的图形属性和选项。虽然代码是按照清晰的英语语法格式编写的，但它并不是英文句子。事实上，它更像数学和表格。</p></blockquote>
<p>而有时还会有些看起来明显不符合「好」代码规范的代码编写方式。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866484"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上面的代码中，<code>if</code> 语句后面把多句代码写在了一行，但从整体上看这样一个短小的方法，其表现形式一下就能让阅读者捕捉到，方法内部有四个分支，每行代码一个分支情况，两种正常分支，两种异常分支。</p>
<p>上面这些随手拈来的例子，都是作者有意为之的选择，正是在这些微妙的个人风格选择中，体现了作者自我的表达。</p>
<h2>技艺</h2>
<p>单独说编程艺术是不完整的，编程是从技术走向艺术。编程艺术是开在枝头的鲜花，而技术是支撑花朵的枝与根。</p>
<p>而在技术和艺术之间实际存在一道很高的门槛，艺术是一种自我表达，但自我表达却未必是艺术。关于这一点我们说个大家耳熟能详的人——毕加索，他说：</p>
<blockquote><p>我十多岁就能画的像拉斐尔那么好了。</p></blockquote>
<p>毕加索到底有没有说过这句话，我没去考证，但他的作品至少说明了一些事实。拉斐尔是文艺复兴时期的写实派画家，他的素描和油画像是下面这样的（图片来自「顾爷」公众号，一个经常谈艺术很有趣的公号）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866485"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>而毕加索十多岁时候的素描和油画是下面这样的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008866486"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>写实是毕加索的绘画基础技术，而其后期的抽象主义才是他的艺术自我表达，两者相辅相成。</p>
<p>虽然，我也不太看得懂毕加索后期的抽象作品，毕加索相对于大众的距离依然比编程相对于大众的距离更近。编程的艺术之花也许就像花中的「满天星」，永远只是配角，只有追寻艺术的程序员方能感受到满天星所营造的那份梦境吧。</p>
<p>...</p>
<p>编程是完成功能，编程是解决 bug，编程是打磨技能，编程是修炼心性，最后编程才成了艺术。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。</p>
<p><span class=""img-wrap""><img data-src=""https://segmentfault.com/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 编程的艺术门槛,1531977973,569,1,229,1,1,https://segmentfault.com/a/1190000005924198
88,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083941"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>咚咚是什么？咚咚之于京东相当于旺旺之于淘宝，它们都是服务于买家和卖家的沟通。 自从京东开始为第三方卖家提供入驻平台服务后，咚咚也就随之诞生了。 我们首先看看它诞生之初是什么样的。</p>
<h2>1.0 诞生（2010 - 2011)</h2>
<p>为了业务的快速上线，1.0 版本的技术架构实现是非常直接且简单粗暴的。 如何简单粗暴法？请看架构图，如下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083942"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>1.0 的功能十分简单，实现了一个 IM 的基本功能，接入、互通消息和状态。 另外还有客服功能，就是顾客接入咨询时的客服分配，按轮询方式把顾客分配给在线的客服接待。 用开源 Mina 框架实现了 TCP 的长连接接入，用 Tomcat Comet 机制实现了 HTTP 的长轮询服务。 而消息投递的实现是一端发送的消息临时存放在 Redis 中，另一端拉取的生产消费模型。</p>
<p>这个模型的做法导致需要以一种高频率的方式来轮询 Redis 遍历属于自己连接的关联会话消息。 这个模型很简单，简单包括多个层面的意思：理解起来简单；开发起来简单；部署起来也简单。 只需要一个 Tomcat 应用依赖一个共享的 Redis，简单的实现核心业务功能，并支持业务快速上线。</p>
<p>但这个简单的模型也有些严重的缺陷，主要是效率和扩展问题。 轮询的频率间隔大小基本决定了消息的延时，轮询越快延时越低，但轮询越快消耗也越高。 这个模型实际上是一个高功耗低效能的模型，因为不活跃的连接在那做高频率的无意义轮询。 高频有多高呢，基本在 100 ms 以内，你不能让轮询太慢，比如超过 2 秒轮一次，人就会在聊天过程中感受到明显的会话延迟。 随着在线人数增加，轮询的耗时也线性增长，因此这个模型导致了扩展能力和承载能力都不好，一定会随着在线人数的增长碰到性能瓶颈。</p>
<p>1.0 的时代背景正是京东技术平台从 .NET 向 Java 转型的年代，我也正是在这期间加入京东并参与了京东主站技术转型架构升级的过程。 之后开始接手了京东咚咚，并持续完善这个产品，进行了三次技术架构演进。</p>
<h2>2.0 成长（2012）</h2>
<p>我们刚接手时 1.0 已在线上运行并支持京东 POP（开放平台）业务，之后京东打算组建自营在线客服团队并落地在成都。 不管是自营还是 POP 客服咨询业务当时都起步不久，1.0 架构中的性能和效率缺陷问题还没有达到引爆的业务量级。 而自营客服当时还处于起步阶段，客服人数不足，服务能力不够，顾客咨询量远远超过客服的服务能力。 超出服务能力的顾客咨询，当时我们的系统统一返回提示客服繁忙，请稍后咨询。 这种状况导致高峰期大量顾客无论怎么刷新请求，都很可能无法接入客服，体验很差。 所以 2.0 重点放在了业务功能体验的提升上，如下图所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083943"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>针对无法及时提供服务的顾客，可以排队或者留言。 针对纯文字沟通，提供了文件和图片等更丰富的表达方式。 另外支持了客服转接和快捷回复等方式来提升客服的接待效率。 总之，整个 2.0 就是围绕提升客服效率和用户体验。 而我们担心的效率问题在 2.0 高速发展业务的时期还没有出现，但业务量正在逐渐积累，我们知道它快要爆了。 到 2012 年末，度过双十一后开始了 3.0 的一次重大架构升级。</p>
<h2>3.0 爆发（2013 - 2014）</h2>
<p>经历了 2.0 时代一整年的业务高速发展，实际上代码规模膨胀的很快。 与代码一块膨胀的还有团队，从最初的 4 个人到近 30 人。 团队大了后，一个系统多人开发，开发人员层次不一，规范难统一，系统模块耦合重，改动沟通和依赖多，上线风险难以控制。 一个单独 tomcat 应用多实例部署模型终于走到头了，这个版本架构升级的主题就是服务化。</p>
<p>服务化的第一个问题如何把一个大的应用系统切分成子服务系统。 当时的背景是京东的部署还在半自动化年代，自动部署系统刚起步，子服务系统若按业务划分太细太多，部署工作量很大且难管理。 所以当时我们不是按业务功能分区服务的，而是按业务重要性级别划分了 0、1、2 三个级别不同的子业务服务系统。 另外就是独立了一组接入服务，针对不同渠道和通信方式的接入端，见下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083944"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>更细化的应用服务和架构分层方式可见下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083945"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这次大的架构升级，主要考虑了三个方面：稳定性、效率和容量。 做了下面这些事情：</p>
<ol>
<li><p>业务分级、核心、非核心业务隔离</p></li>
<li><p>多机房部署，流量分流、容灾冗余、峰值应对冗余</p></li>
<li><p>读库多源，失败自动转移</p></li>
<li><p>写库主备，短暂有损服务容忍下的快速切换</p></li>
<li><p>外部接口，失败转移或快速断路</p></li>
<li><p>Redis 主备，失败转移</p></li>
<li><p>大表迁移，MongoDB 取代 MySQL 存储消息记录</p></li>
<li><p>改进消息投递模型</p></li>
</ol>
<p>前 6 条基本属于考虑系统稳定性、可用性方面的改进升级。 这一块属于陆续迭代完成的，承载很多失败转移的配置和控制功能在上面图中是由管控中心提供的。 第 7 条主要是随着业务量的上升，单日消息量越来越大后，使用了 MongoDB 来单独存储量最大的聊天记录。 第 8 条是针对 1.0 版本消息轮询效率低的改进，改进后的投递方式如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083946"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>不再是轮询了，而是让终端每次建立连接后注册接入点位置，消息投递前定位连接所在接入点位置再推送过去。 这样投递效率就是恒定的了，而且很容易扩展，在线人数越多则连接数越多，只需要扩展接入点即可。 其实，这个模型依然还有些小问题，主要出在离线消息的处理上，可以先思考下，我们最后再讲。</p>
<p>3.0 经过了两年的迭代式升级，单纯从业务量上来说还可以继续支撑很长时间的增长。 但实际上到 2014 年底我们面对的不再是业务量的问题，而是业务模式的变化。 这直接导致了一个全新时代的到来。</p>
<h2>4.0 涅槃（2015 至今）</h2>
<p>2014 年京东的组织架构发生了很大变化，从一个公司变成了一个集团，下设多个子公司。 原来的商城成为了其中一个子公司，新成立的子公司包括京东金融、京东智能、京东到家、拍拍、海外事业部等。 各自业务范围不同，业务模式也不同，但不管什么业务总是需要客服服务。 如何复用原来为商城量身订做的咚咚客服系统并支持其他子公司业务快速接入成为我们新的课题。</p>
<p>最早要求接入的是拍拍网，它是从腾讯收购的，所以是完全不同的账户和订单交易体系。 由于时间紧迫，我们把为商城订做的部分剥离，基于 3.0 架构对接拍拍又单独订做了一套，并独立部署，像下面这样。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083947"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>虽然在业务要求的时间点前完成了上线，但这样做也带来了明显的问题：</p>
<ol>
<li><p>复制工程，定制业务开发，多套源码维护成本高</p></li>
<li><p>独立部署，至少双机房主备外加一个灰度集群，资源浪费大</p></li>
</ol>
<p>以前我们都是面向业务去架构系统，如今新的业务变化形势下我们开始考虑面向平台去架构，在统一平台上跑多套业务，统一源码，统一部署，统一维护。 把业务服务继续拆分，剥离出最基础的 IM 服务，IM 通用服务，客服通用服务，而针对不同的业务特殊需求做最小化的定制服务开发。 部署方式则以平台形式部署，不同的业务方的服务跑在同一个平台上，但数据互相隔离。 服务继续被拆分的更微粒化，形成了一组服务矩阵（见下图）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083948"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>而部署方式，只需要在双机房建立两套对等集群，并另外建一个较小的灰度发布集群即可，所有不同业务都运行在统一平台集群上，如下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083949"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>更细粒度的服务意味着每个服务的开发更简单，代码量更小，依赖更少，隔离稳定性更高。 但更细粒度的服务也意味着更繁琐的运维监控管理，直到今年公司内部弹性私有云、缓存云、消息队列、部署、监控、日志等基础系统日趋完善， 使得实施这类细粒度划分的微服务架构成为可能，运维成本可控。 而从当初 1.0 的 1 种应用进程，到 3.0 的 6、7 种应用进程，再到 4.0 的 50+ 更细粒度的不同种应用进程。 每种进程再根据承载业务流量不同分配不同的实例数，真正的实例进程数会过千。 为了更好的监控和管理这些进程，为此专门定制了一套面向服务的运维管理系统，见下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083950"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>统一服务运维提供了实用的内部工具和库来帮助开发更健壮的微服务。 包括中心配置管理，流量埋点监控，数据库和缓存访问，运行时隔离，如下图所示是一个运行隔离的图示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083951"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>细粒度的微服务做到了进程间隔离，严格的开发规范和工具库帮助实现了异步消息和异步 HTTP 来避免多个跨进程的同步长调用链。 进程内部通过切面方式引入了服务增强容器 Armor 来隔离线程， 并支持进程内的单独业务降级和同步转异步化执行。而所有这些工具和库服务都是为了两个目标：</p>
<ol>
<li><p>让服务进程运行时状态可见</p></li>
<li><p>让服务进程运行时状态可被管理和改变</p></li>
</ol>
<p>最后我们回到前文留下的一个悬念，就是关于消息投递模型的缺陷。 一开始我们在接入层检测到终端连接断开后，消息无法投递，再将消息缓存下来，等终端重连接上来再拉取离线消息。 这个模型在移动时代表现的很不好，因为移动网络的不稳定性，导致经常断链后重连。 而准确的检测网络连接断开是依赖一个网络超时的，导致检测可能不准确，引发消息假投递成功。 新的模型如下图所示，它不再依赖准确的网络连接检测，投递前待确认消息 id 被缓存，而消息体被持久存储。 等到终端接收确认返回后，该消息才算投妥，未确认的消息 id 再重新登陆后或重连接后作为离线消息推送。 这个模型不会产生消息假投妥导致的丢失，但可能导致消息重复，只需由客户终端按消息 id 去重即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009083952"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>京东咚咚诞生之初正是京东技术转型到 Java 之时，经历这些年的发展，取得了很大的进步。 从草根走向专业，从弱小走向规模，从分散走向统一，从杂乱走向规范。 本文主要重心放在了几年来咚咚架构演进的过程，技术架构单独拿出来看我认为没有绝对的好与不好， 技术架构总是要放在彼时的背景下来看，要考虑业务的时效价值、团队的规模和能力、环境基础设施等等方面。 架构演进的生命周期适时匹配好业务的生命周期，才可能发挥最好的效果。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。</p>
<p><span class=""img-wrap""><img data-src=""https://segmentfault.com/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 京东咚咚架构演进,1531977975,565,1,115,1,1,https://segmentfault.com/a/1190000005892459
89,1,0,9,"
                    
<p>threejs下载位置：<a href=""http://www.threejs.org"" rel=""nofollow noreferrer"">http://www.threejs.org</a><br>我在Facebook上看到Facebook实现了3D全景图，然后，一直很好奇，最后，我发现threejs里面有一个库竟然可以实现，一下我贴出代码：</p>
<pre><code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;meta name=""viewport"" content=""width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0""&gt;
    &lt;title&gt;three.js css3d - panorama&lt;/title&gt;
    &lt;style&gt;
        body {
            background-color: #000000;
            margin: 0;
            cursor: move;
            overflow: hidden;
        }

        a {
            color: #ffffff;
        }

        #info {
            position: absolute;
            width: 100%;
            color: #ffffff;
            padding: 5px;
            font-family: Monospace;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            z-index: 1;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=""../build/three.min.js""&gt;&lt;/script&gt; &lt;!-- 此处引入threejs基础类 --&gt;
&lt;script src=""js/renderers/CSS3DRenderer.js""&gt;&lt;/script&gt; &lt;!-- 此处引入CSS3Drenderer.js类 --&gt;
&lt;!-- 以上两个文件，在下载threejs的时候就有的，引入就好 --&gt;
&lt;script&gt;
    var camera, scene, renderer;
    var geometry, material, mesh;
    var target = new THREE.Vector3();

    var lon = 90, lat = 0;
    var phi = 0, theta = 0;

    var touchX, touchY;

    init();
    animate();

    function init() {

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

        scene = new THREE.Scene();
/** 次数是重点说明的
 * 这个sides对应的是六张图位于立体坐标轴内的位置，里面的position又包含x,y,三个轴
 * 然后ratation是三个轴上的变换
 */ 
        var sides = [
            {
                position: [ 512, 0, 0 ], // 1
                rotation: [ 0, -Math.PI / 2, 0 ]
            },
            {
                position: [ -512, 0, 0 ], // 2
                rotation: [ 0, Math.PI / 2, 0 ]
            },
            {
                position: [ 0,  512, 0 ], // 3
                rotation: [ Math.PI / 2, 0, Math.PI ]
            },
            {
                position: [ 0, -512, 0 ], // 4
                rotation: [ - Math.PI / 2, 0, Math.PI ]
            },
            {
                position: [ 0, 0,  512 ], // 5
                rotation: [ 0, Math.PI, 0 ]
            },
            {
                position: [ 0, 0, -512 ], // 6
                rotation: [ 0, 0, 0 ]
            }
        ];

        var canvas = document.createElement('canvas');
        var image = document.createElement('img');
        image.src = 'picture/360photos.jpg'; // 画图，这里引入的这张图片，是一张图上集合了6张图片
        image.height = 6144;
        image.width = 1024;
        canvas.width = 1024;
        canvas.height = 1024;
        // 这里有判断image.onload，这里是判断创建的image节点是否把引入的图片加载进来
            image.onload = function() {
                for ( var i = 0; i &lt; sides.length; i ++ ) { // 由于是六张图放在一张图片上，然后这里分割六张图片
                    var cxt = canvas.getContext(""2d"");
                    cxt.drawImage(image, 0, -1024*i);
                    var side = sides[ i ];

                    var element = document.createElement( 'img' );
                    element.width = 1026; // 2 pixels extra to close the gap.
                    document.getElementsByTagName('body')[0].appendChild(canvas);
                    var _img_url = canvas.toDataURL(""image/png""); // 获取图片位置
                    element.src = _img_url;
                    var object = new THREE.CSS3DObject( element ); // 这里根据sides把图片放在坐标轴上进行渲染
                    object.position.fromArray( side.position );
                    object.rotation.fromArray( side.rotation );
                    scene.add( object );
                }
        }


        renderer = new THREE.CSS3DRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        //

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );

    }

    function onDocumentMouseMove( event ) {

        var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        lon -= movementX * 0.1;
        lat += movementY * 0.1;

    }

    function onDocumentMouseUp( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove );
        document.removeEventListener( 'mouseup', onDocumentMouseUp );

    }

    function onDocumentMouseWheel( event ) {

        camera.fov -= event.wheelDeltaY * 0.05;
        camera.updateProjectionMatrix();

    }

    function onDocumentTouchStart( event ) {

        event.preventDefault();

        var touch = event.touches[ 0 ];

        touchX = touch.screenX;
        touchY = touch.screenY;

    }

    function onDocumentTouchMove( event ) {

        event.preventDefault();

        var touch = event.touches[ 0 ];

        lon -= ( touch.screenX - touchX ) * 0.1;
        lat += ( touch.screenY - touchY ) * 0.1;

        touchX = touch.screenX;
        touchY = touch.screenY;

    }

    function animate() {

        requestAnimationFrame( animate );

        lon +=  0.1;
        lat = Math.max( - 85, Math.min( 85, lat ) );
        phi = THREE.Math.degToRad( 90 - lat );
        theta = THREE.Math.degToRad( lon );

        target.x = Math.sin( phi ) * Math.cos( theta );
        target.y = Math.cos( phi );
        target.z = Math.sin( phi ) * Math.sin( theta );

        camera.lookAt( target );

        renderer.render( scene, camera );

    }

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>以上，我把重要的说明点都写上了注释，然后，注意，我这里的图片是去facebook上下载下来的，我把Facebook上的图片手动进行了左右翻转实现的程序，如果不需要手动翻转，如果是渲染Facebook上的图片的话，需要把Facebook的图片用程序进行翻转再分割才能渲染出正常的图片，否则渲染出来的全景是不正常的。<br>我下面附上的图很大，宽度是1024像素的，然后高度是1024像素*6；原图是这张图的左右翻转。<br>下面，我附上图，此图来自简书上传的，可能会有盗链导致加载不出来：</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1481370-1ad916ab14b02d5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""360photos.jpg"" title=""360photos.jpg""></span></p>

                ", 利用threejs实现3D全景图,1531977976,145,1,386,1,1,https://segmentfault.com/a/1190000005792628
90,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1131767-fb7fabf4e0fce63a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一直以来「奇葩」这个词都是偏贬义的，直到去年有个综艺节目叫「奇葩说」挺热闹，这里的人不一定是奇葩，更多指达人的意思。 「奇葩说」里的达人都是能说会道的，我的主业是程序员，所以只能写写在我职业生涯中碰到的一些「奇葩」程序员。 你懂的，我这里的「奇葩」没有任何贬义的意思。</p>
<h2>月在胸襟人在途</h2>
<p>我刚入行时的第一位项目经理，70后。那年三十出头，在银行客户现场做项目经理，负责一个二十来人的客户现场团队。 虽然他的职位是项目经理，但实际那时他真是一个名地道的资深程序员。 70 后的程序员大都是从写 C 开始的，那时银行系统大部分也都还是 C 写的。 做为 Java 程序员入职的我十分惊奇的发现上一代程序员的工作方式是和我如此的不同。</p>
<p>当时团队资深的 C 程序员没几个，他算工作十来年里最老的，还要兼项目管理。 每有发生比较难搞的线上问题，他都会冲上一线。 比如我之前有文章里提到过的一个运行了十二年的 C 程序突然意外频频崩溃的事情，也是他带领几个高工在排险。 他们都是直接登上生产环境的小型机，程序源码就在上面，直接用 vi 编程调试，连语法着色都木有。 开着好几个黑底绿色字符的命令行终端窗口，coding，make，运行，查看日志，行云流水，金声玉震。 那时为了做好维护老项目工作我也学着用 vi 直接编程调试，但一直以来都感觉自己用的笨拙。 之后我转去专门做 Java 项目后，我的 vi 水平就再也没有长进过，十年过去，好像还和毕业第一年差不多。</p>
<p>项目经理人很随和，人到中年发福的有点多，整天笑呵呵的样子，让我感觉如果继续发福下去，就有些弥勒佛的风采了。 每次看他调试程序，短胖的手指流畅的敲打着键盘，看着那枚紧紧嵌入肉里的戒指就想他年轻那时也曾瘦过吧。 不管碰到什么大的线上事故，我也极少见他愁眉苦脸，还是那副笑弥勒的样子。 包括那次我负责的系统故障，让银行临时关窗停业的事情，他也笑呵呵的挡住了所有来自客户方的压力，让我能更从容的去处理。</p>
<p>那一年有次电话银行临时故障，他小孩出生请了陪护假在医院，故障时现场就我一人还在加班了。 只好让我来处理，但我完全没弄过电话银行那个程序，他就在电话里让我口述错误日志，他去分析什么地方有问题。 根据错误日志他猜到了错误的原因，就电话里单步指导我直接去生产机上重新修改源码，编译，替换原来的程序。 我震惊于他对细节的记忆力和超强的问题解决能力，但也看着他不禁感到对前路的迷茫。 十年后我也会成为他这样的程序员吗？我在他笑呵呵的面容后也能感觉到一份中年程序员背后的丝丝无奈。 在我写下这篇文章时正好是第十个年头，站在此时此刻回首彼时彼刻的感觉，现在应该是一个比当时对程序员更好的时代吧。</p>
<p>我和他只共事了一年，离开的原因如今回想起来也算是年轻随性的选择。 当时他觉得我还不错，就说年底给我加工资吧，可能说的时候觉得每个项目组年终总有些加薪的名额。 他这么说了我就这么信了，后来年底整个项目组都没名额，终究有些事情并不在他的掌控能力范围内，我就这么一气盛便离开了。 这样的选择如今回想起来，谈不上好坏，一种选择就是一条路径，没有这样的选择也不会有后面的故事。</p>
<h2>人生得意须尽欢</h2>
<p>之后我到了一个新公司，认识了一个挺另类的程序员。 当有点进取心的程序员都在努力的更新自己的技能怕被时代的技术变迁淘汰时，他却一点也不担心，不到最后时刻绝不更新。</p>
<p>他是毕业后就到这个公司的，已经在那工作了三年了。 我当时刚工作一年，因为我读了研究生，所以我们其实差不多同年。 他有个绝大部分程序员都没有的特殊能力，就是和公司里各类人等都挺熟的，不仅限于开发部，包括行政、财务和各类不同层级的领导。 所以当我一个新人来到公司，他就很早过来招呼起来。 后来因为同一个项目，一起出差派到客户方现场作技术支持，就变得更熟悉起来。</p>
<p>熟悉了后，他就经常跟我抱怨公司，三年了也没给他涨过工资。 老是旁敲侧击的打听我进来时公司给开多少工资了。 我一开始谨慎地回绝了谈这个敏感的话题，因为公司也要求了员工间不能谈工资。 后来，过了段时间不知他通过什么渠道了解我的工资范围，然后对公司的抱怨就更大了。 那天，正好发了工资我们一起在外出差，他就说起他工资太低，2800一个月，想要去跟公司谈谈。 我一开始不信怎么可能这么低，要知道那是 2007 年的广州，我毕业那年拿到的 offer 是 5k，用各类电脑管家的话说叫打败了同年毕业同学中的 40% 吧，属于中等偏下。 而我跳到这家公司时，其实还涨了不少，所以他做为一个在公司三年的老员工，这个工资水平也着实让我震惊了。</p>
<p>我开始说不信，当时我自己在广州租房就要近 1500 了，2800 一个月怎么活？ 他为了证明就在 ATM 当场查询当天工资的入账记录给我看，让我不得不信。</p>
<blockquote><p>你这样还活的下去，租房加吃饭都嫌勉强了。 <br>所以我不在广州租房，这几年长期外派出差，公司管住另外每天给一百多点的出差补贴，要不然呢。</p></blockquote>
<p>他说要抽空回去和公司领导谈谈，要求涨工资，原来市场行情都这么高了，不行就离职了。 然后他就回去了广州总部，但一个周末后又回到了出差地。 我问他谈的怎样，他说领导不给涨，让他想离就离呗。 然后他就想了想还是算了，加上出差补贴收入还算凑和，而且这边干活轻松。</p>
<p>他确实轻松，因为他只负责维护几年前围绕数据库用存储过程写的旧系统。 而新系统公司采用了当时流行的 J2EE 企业架构，慢慢在把旧系统用存储过程写的逻辑转换到新架构上。 所以在工作上他是我的接口人，并不断的在把他维护的系统转换到我负责的新系统上去，所以他是越来越轻松。 我都替他担心，等系统转换完了，公司的系统都转到了 J2EE 平台，你也不学 Java 以后怎办？ 他说，到时再说吧，领导反正也说了我这点工资，多我一个不多，少我一个也不少。 乐的清闲，而且我现在的主要精力也不在写程序上。</p>
<p>当时，适逢大牛市。他把前三年工资和出差补贴存下的 10 万全部投进了股市。 到 07 年下半年时，股市趋近疯狂，他的股票一涨再涨，每天红光满面。 终于有天忍不住给我说，现在真是炒股赚钱的最好时光。 我就问他投了多少，赚了多少？其实当时我也受全民炒股情绪感染，但由于不太懂谨慎起见，只少少的买了点基金。 他说去年就全仓进入，投了十来万，到现在已经赚到人生第一个一百万。 现在股市一天赚的当过去一年，工资权当零花钱了，然后就该我凌乱了，不禁怀疑起在这出差加班码代码的意义何在？</p>
<p>受其影响，我也在 07 年末发了年终奖后大举进场，然后就没有然后了，直到 15 年才解套。 08 年初市场风气转换，他及时套现拿出部分在广州买了套房，而回头去看也正是广州房价近十年最低位了吧。 之后在那个公司干到 09 年后，我离开了广州回了成都，慢慢就和他的联系少了。</p>
<p>14 年下半年到 15 年上半年 A 股市场再现 07 年的狂牛盛景，而且这次还有新玩法：融资。 到 15 年我差不多解了 08 年的套时，这些年许久未曾联系的他的 QQ 头像又闪动起来。 告诉我这次他又踩准了趋势，借融资杠杆，一波赚到了人生第一个 500 万。 并规划着，赚到 1000 万就够了，基本靠低风险的理财能产生足够品质生活的现金流，只留 1、2 百万在股市继续沉浮。 我问你现在就全职炒股了？他说没啊，换了个公司继续还写程序，并且终于学了 Java。</p>
<blockquote><p>那现在写程序于你的意义何在呢？<br>牛市不是天天有，过去熊了六、七年，我还得生活不是。<br>所以还在写程序，工资也不太高，如今也就 8、9k 吧，能过生活够了。</p></blockquote>
<p>所以，作为程序员一直是他的一个后备选择。 之后 15 年下半年出现了股灾，后事便不知如何，之后他的 QQ 头像也未再闪动过。 希望一切顺利，也许下个牛市我还能听到关于他的故事。</p>
<h2>裁诗为骨玉为神</h2>
<p>他姓韦，所以大家都叫他「韦爵爷」，其实跟韦小宝没任何相关之处，但没见过真人前总会把他的形象和韦小宝的爵爷形象关联起来。 第一次见到他是在杭州，也是因为公司意外中标的项目（之前大圣文有写过）临时调集人手过去支持。 见到真人后发现与我想象中差距还蛮大，那时他留了一头长发，瘦削清癯，穿一款旧式风衣。 那要放在武侠的江湖里，很有一种不出世的高手感觉。 我问他干嘛留长发，他说杭州冬天比广州冷多了，留长发还暖和，过完年回广州夏天热了再剪吧。</p>
<p>当时那个项目最棘手的问题不是技术有多难，只是时间紧迫，还在和对手比赛。 杭州电信接手了联通 CDMA 一堆古老的旧网络设备，上面还有几百万用户在用。 但这些设备的供应商倒闭的倒闭，要么就是接近倒闭（当时的北电），完全没接口人。 情况好点的留下了一些设备文档，韦爵爷就是在那样的情况下开始了和这些设备调试接口的工作。 一份英文的设备文档 800 多页，韦爵爷一边看文档，一边学串口编程，一边测试接口程序。 不分昼夜，一周时间我们就全部搞定了所有网元设备的调试工作，具备了全网系统集成测试的条件，也因此顺利拿下了杭州电信的订单。</p>
<p>感到爵爷读英文文档的速度十分迅速，就问他诀窍。 他说之前被公司外派去巴基斯坦呆了一年多，在那边天天搞英文，也就熟练了。 然后跟我讲起巴基斯坦的经历，那边国家政治环境不太稳定，治安堪忧，办公室都是常备武器的，上班无聊了就把玩下 AK47 什么的。 平时出去取个钱，都要借大使馆的车开出去，取了立马开回来，极少外出。 怪不得我进公司一年多一直没见过爵爷，原来他那阵子一直在巴基斯坦。 之前公司时不时发个邮件征招去非洲或伊拉克之类地方做项目的人，我就在想真有人去么，这不是用生命在写程序么。 当然，这类选择每个人都有自己的原因。 后来了解到爵爷家里情况并不太好，作为老大还有弟弟妹妹尚在读书，都是他在供养。</p>
<p>爵爷每次长期出差，他的皮箱总是半空着，等回来的时候箱子里就塞满了书。 出差加班熬夜等割接上线的时候，无聊时有人打游戏，有人看视频，爵爷经常摸出一本书读起来。 一般程序员桌上可能会放几本技术书籍，爵爷的桌上都是《桃花扇》《许三观卖血记》之类的。 他会一本正经的看完本小说，跟你探讨主人公的命运感受之类，分析作者为啥要这么写。 所以越发让我感觉他是一个经历丰富而层次感分明的人。</p>
<p>最后一次和爵爷合作就是某天半夜计费系统出错，错误下发了一批量单，把几十万正常用户给停机了。 爵爷把我叫醒，出了点事说我们去搞搞吧，还是那样的云淡风清，好像根本没出事一样。 翻过那年冬天我便离开了广州，没等到夏天再见到爵爷把长发剪短的样子。 之后，渐渐相忘于江湖，不过那个清癯身影似乎还形影相吊的读着：</p>
<blockquote><p>徘徊久，问桃花昔游，这江乡，今年不似旧温柔。</p></blockquote>
<p>这一路走来遇到这些个「奇葩」程序员，感觉也挺有意思，有时生活不就是为了活的有点意思么。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿。<br>微信公众号「瞬息之间」，遇见了不妨就关注看看。</p>
<p><span class=""img-wrap""><img data-src=""https://segmentfault.com/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 程序员「奇葩」说,1531977978,427,1,767,1,1,https://segmentfault.com/a/1190000005731314
91,1,0,9,"
                    
<blockquote><p>非商业转载请注明作译者、出处，并保留本文的原始链接：<a href=""http://www.ituring.com.cn/article/216181"" rel=""nofollow noreferrer"">http://www.ituring.com.cn/article/216181</a></p></blockquote>
<p>结城浩（Hiroshi Yuki），1963年出生，居住于东京都武藏野，有两个儿子。职业为程序员（应该是自由职业）、技术作家、虔诚的新教教徒，对传教很热心。喜爱语言文字、读书（宗教、小说、科普类）、巴洛克音乐。</p>
<p>1993年出版了第一本书《C语言编程精华》，至今为止共计出版图书44种（含修订版），主要包括：</p>
<ul>
<li><p>C语言：8种</p></li>
<li><p>Perl：4种</p></li>
<li><p>Java：11种</p></li>
<li><p>密码学：3种</p></li>
<li><p>数学：3种</p></li>
<li><p>《数学女孩》系列：12种</p></li>
</ul>
<p>目前依旧在写网络连载《数学女孩的秘密笔记》，链接地址<a href=""https://cakes.mu/series/339"" rel=""nofollow noreferrer"">https://cakes.mu/series/339</a>，这个系列已经出了7本单行本。</p>
<p>2013年至2015年，在《Software Design》杂志上连载专栏《再发现的思考法》，从一些技术术语中找到新发现，链接地址<a href=""http://www.hyuki.com/discover/"" rel=""nofollow noreferrer"">http://www.hyuki.com/discover/</a></p>
<blockquote>
<p>编者的话：</p>
<p>结城浩先生接到图灵访谈的邀请后，第一时间接受了访谈。回答读者提问的过程中，还不时就访谈问题进行沟通交流，让人感到满满的认真负责。编者认为，结城浩先生一定是一位漫画里走出来的、温暖的人吧~</p>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVxYNG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3><strong>关于写作和出版</strong></h3>
<p><strong>图灵访谈：您20多年的时间里总共出版了40多本图书，平均一年两本，而且内容和形式非常多样。除此之外，还要写网络和杂志专栏。您认为自己算不算是一个“高产”的作家？您如此高产的秘诀是什么？</strong></p>
<p>结城浩：其实也没有什么秘诀。我本来就很喜欢写作，或者说喜欢将自己的思想用文字表达出来。因此，我并没有刻意地去想着要多写几本书或者是要当一个“高产”的作家，我只是坚持做自己喜欢的事而已。我的性格里有两个看似矛盾的方面：一个是“长期坚持做同一件事而不感到厌倦”，另一个是“一旦感到厌倦了，马上换新的目标”。也许，这两点对我的“高产”有一定的贡献吧。</p>
<p><strong>图灵访谈：您在网站上说“我一直在写新书”，能透露一下现在在写的新书是关于哪方面的吗？您还有很多书没有和中国读者见面，您希望推荐给中国读者的下一本书是什么？</strong></p>
<p>结城浩：现在（2016年6月）我正在写的书有两本，一本是《数学女孩》系列的第6本——《数学女孩6》，另一本是《数学女孩的秘密笔记》系列的第8本——《数学女孩的秘密笔记：简单的统计》，其中《秘密笔记》应该会先上市。按照现在出版的顺序来看，中国读者应该会先看到《数学女孩3：哥德尔不完备定理》，但其实我也很想推荐《数学女孩的秘密笔记》系列。《秘密笔记》系列讲的数学知识比较浅显，对话风格也比较活泼，而且它和《数学女孩》系列之间是相互独立的，系列中的每一本之间也是独立的，从任何一本开始读都可以。我希望能够有更多的中国读者阅读和喜欢我的书！</p>
<p><strong>图灵访谈：您写的书里面有C语言、Java语言这样的技术书，也有《数学女孩》这样的青春小说，您觉得写技术书和写小说感觉有哪些不同，您更喜欢写哪一种书呢？</strong></p>
<p>结城浩：我觉得这两种并没有太大的不同。我们想要传达的很多价值本身就非常复杂，我喜欢把它们用尽量通俗易懂的方式讲出来。从这一点上来说，不管是编程的话题还是数学的话题，讲法都是一样的。只不过《数学女孩》从体裁上来说不是我来讲，而是小说里面的人物来讲。如果问更喜欢写哪一种，我想说，至今写的所有的书都是因为喜欢才写的，没有任何一本是出于什么义务或者在别人的要求下写出来的。</p>
<h3><strong>关于密码技术</strong></h3>
<p><strong>图灵访谈：《图解密码技术（第3版）》中文版马上就要上市了，这本新版里面有哪些特别值得推荐的内容？</strong></p>
<p>结城浩：第三版在整体上进行了信息的更新，另外增加了一些新的内容，如SHA-3的选拔过程以及其算法（Keccak）的结构、POODLE等对SSL/TLS的各种攻击方式、认证加密、椭圆曲线密码，还介绍了比特币是如何通过各种密码技术的有机结合设计出来的。第三版在日本的反响非常好，即使在算上小说等一般读物的情况下，甚至能够在某些书店里排到综合第二位。</p>
<p><strong>图灵访谈：《图解密码技术》一书中提到PGP的作者Phil Zimmermann曾引发了一场关于“密码自由”的大论战，至今依然有人认为密码技术可能成为恐怖分子的帮凶，应该像武器一样进行管制，您个人如何看待这一问题？目前量子密钥分发技术也正在快速发展，中国的京沪广域量子通信专线将于今年年底交付使用，这种“无法破译”的密码技术会不会再一次引发一场类似的论战？密码技术的未来又是什么样的呢？</strong></p>
<p>结城浩：我的知识水平还不足以讨论密码技术的未来是什么样的，不过就现在来看，“认证”比“加密”更重要，进一步说就是“信任”的问题。比如说，当你看到某个人的发言时，你确定发言的人就是你所设想的那个人本人吗？正在和你进行交易的人，真的就是你所设想的那个人吗？</p>
<p>“无法破译”这个词看起来很吸引人，但如果这里的无法破译仅限于“机密性”这个层面的话，大家应该意识到，这种技术只是我们所期望的“安全”中的一小部分而已。恐怖分子固然可怕，那么国家就不可怕了吗？如果说恐怖分子不值得信任，那么国家就一定值得信任吗？讨论到这里，我们已经离技术的话题很远了呢，但无论如何，我认为我们每个人都应该对技术有充分的认识和理解，这一点还是非常重要的。</p>
<h3><strong>关于编程</strong></h3>
<p><strong>图灵访谈：除了作家之外，您还有一个身份是程序员，曾经还开发了一款在日本非常流行的维基引擎。当初您是如何想到开发这个软件的？后来您又开发过哪些其他的软件呢？</strong></p>
<p>结城浩：日本有一款非常流行的维基引擎叫做PukiWiki，这个软件其实并不是我开发的，但它最早的版本是我编写的一个叫做YukiWiki的维基引擎。在YukiWiki的基础上，PukiWiki把Perl移植到PHP。当初之所以要开发YukiWiki，只是因为我知道了维基这个东西，想自己做一个玩玩而已（动机很单纯对吧）。除了这个以外，我自己还开发过一个叫做MakeWeb的软件，它可以将纯文本转换成HTML和LaTeX。开发这个软件是为了方便开发自己的网站。其实MakeWeb就相当于现在的Markdown，只不过我当时写这个软件的时候是1996年（！），那时候还没有Markdown呢。我还编写过其他一些小的工具或者脚本，基本上都是为了方便自己写书用的。</p>
<p><strong>图灵访谈：日本的程序员生活是怎样的？工作起来，尤其是进入某个项目后，就不考虑生活中的其他事情，专注工作吗？对于如何平衡生活与工作，您有什么建议？</strong></p>
<p>结城浩：“日本的程序员”还是太宽泛了，不同的行业其工作状态也不同。有些人每天要花很多时间在公司里，也有些人能够很好地平衡工作和生活。我离开公司不做全职程序员已经很久了，当然那个时候确实工作时间非常的长，但自己确实又没有什么办法解决这个问题，感到很苦恼。现在看起来，当时自己还不够成熟，没有办法很好地管理自己的工作，所以其实我也没办法给大家太多的建议。</p>
<p>不过话说回来，“平衡生活和工作”本来就并不容易，要达到这样的状态得有自己的想法，靠“别人说应该如何如何”并不是长久之计。因为工作和生活之间密不可分，同时作为他们作为一个整体又和人的价值观密不可分，对于从事智力活动的人来说尤其如此。单纯地增加私人时间肯定是不行的，或许将时间简单地划分为“工作”和“生活”这样的二元论本来就不是一种合理的思考方式？因此我认为，知难而进、独立思考，这两点都是很重要的，无论工作还是生活，都是人生的重要一部分。</p>
<p><strong>图灵访谈：在技术更迭飞快的时代，计算机从业者常常会担心被时代抛弃，因为新技术不断涌现，但自己又对这些技术一知半解，很多人因此患上了“技术恐慌症”，您是否也有同样的感受？对于“如何才能不被时代抛弃”，您有什么建议？</strong></p>
<p>结城浩：我在网上写过一组文章“程序员的心理健康“，其中就有一个关于“信息恐慌”的段落，写的就是新的东西层出不穷，让人们感到恐慌的这样一种心理状态。在那个段落中我给出了一些建议，就是培养一种“其实这是个机会”的心态。感到技术更迭飞快的并不只有你一个人，所有人都是，因此其中一定能够找到你施展的空间，不是吗？</p>
<blockquote>
<p>程序员的心理健康——关于“信息恐慌”（译文）</p>
<p>计算机的世界瞬息万变，让人感觉似乎不努力往前跑就会被抛弃，的确，现实中真的有因为这样的原因丢了饭碗的人（对吧？）。</p>
<p>于是你得经常看计算机杂志和专业的书籍，还得订阅一些邮件杂志，上网收集各种资料，不然完全跟不上话题，因为新的东西出来得太快，新产品、新编程环境……</p>
<p>但要是长年累月过这样的生活，恐怕神经要崩溃了。其实我也是这么过来的，以至于有时看到专业杂志和书籍都会感觉头疼，现在也会如此。</p>
<p>所谓“信息恐慌”，其根源就是觉得必须得不断的获取新的信息，但又被日趋膨胀的信息量压得喘不过气来。我不知道到底有没有这么一个词，就当是我为自己身上的症状起个名字吧。</p>
<p>那么到底应该如何摆脱“信息恐慌”呢？当我遇到类似感觉的时候，我会想“不，其实这是个机会”。</p>
<p>唉，最近出来好多新的概念，有好多东西要学啊→“不，其实这是个机会”。要学的东西很多，对于所有人都是一样的，如果我能把自己理解的部分很好地讲给别人听，这不就是我发挥价值的机会吗？有了这种积极的心态，就会感觉好多了（至少我是这样）。</p>
<p>还有一种方法，就是当感觉出现“信息恐慌”的时候，能够清醒地认识到自己可能已经太累了，需要调整一下。就好像编译代码的时候看到warning，就要停下来把代码检查一遍一样，当感觉出现“信息恐慌”的时候，也要停下来把自己的生活检查一遍。不要陷入恐慌之中，而是把恐慌当作自己健康状况的一个报警器就好了。</p>
<p>再或者，喝点酒睡一觉可能也是个不错的主意吧。</p>
<p>（1996年10月10日）</p>
</blockquote>
<h3><strong>关于数学</strong></h3>
<p><strong>图灵访谈：您写了很多和数学相关的著作，书中的巧妙证明过程，总是给读者以强烈的震撼，大多读者表示自己永远也想不出这样的解法。您认为数学学习和天赋有关系吗？您自己学习数学的经历是怎样的，遇到过什么困难，有什么值得分享的故事？</strong></p>
<p>结城浩：我自己对数学当然也有喜欢和不喜欢的部分，也有擅长和不擅长的部分。对于那些最顶尖的数学家来说，一定的天分和直觉肯定是需要的（当然，我并不是数学家）。不过数学书籍上面写的那些东西，其实都是成百上千年来各个时代最优秀的头脑的智慧结晶，所以我觉得看到这些东西的时候真的没有必要感叹“自己永远想不出”。我的书里的那些内容，抛开展现的方式，其最本质的内容大部分都是引用其他参考文献的。我写书的过程，其实就是从自己读过的很多书中进行思考，并把头脑中闪过的感动用文字表达出来而已。我希望能够将自己从知识中获得的喜悦和感动更多地传达给我的读者。</p>
<p><strong>图灵访谈：《数学女孩》描述的高中生活没有围绕成绩、题海展开，反而尽现了追求数学魅力的青春记忆，您当初为什么会想到用青春小说这样的体裁来写数学的故事呢？有读者感叹，如果有这般的数学教科书，数学教育一定会提升一大截。如果改革教科书，您最想从哪些方面入手？您认为日本与其他国家的数学教育有哪些最主要的区别？</strong></p>
<p>结城浩：我写《数学女孩》的缘起和详细经过都写在一本叫《数学女孩的诞生》的书里。最初想着写一本数学读本的时候，脑子里出现的形象就是一个擅长数学的少女，然后我就在网上写了数学女孩的原型故事。其实我也不明白为什么会这样写，好像在我心里，用“故事”和“对话”来聊数学就是一种很自然的风格。</p>
<p>数学故事和教科书所需的要件不同，改革教科书可没有那么容易。教科书的前提是让老师来教，和可以自由阅读的故事书从构成上就完全不同。我不知道其他国家的教科书是什么样的，至少日本的数学教科书中很少有不准确和不恰当的描述，从准确性来说质量还是很高的。我掌握的信息有限，没办法从整体上去讨论数学教育，不过我希望数学教育能够多向学生展现数学的魅力，让他们更有兴趣和动力去学习数学。数学本来是一个很有魅力的学科，我感觉人们过于厌恶它了。</p>
<p><strong>图灵访谈：有部分计算机从业者认为，在实际项目中，数学的作用似乎并不大，但与此同时我们也看到，伟大的程序员，如高德纳、Linus，却又无不精通数学。作为程序员，您长于数学的背景，带给您怎样的专业收获和生活体验？</strong></p>
<p>结城浩：其实在很多领域，数学知识都能够直接在编程中派上用场。比如说，如果不懂离散数学、集合、逻辑、进制的相关知识，可能没有办法很好地编程；如果不懂三角函数等函数以及几何学、矩阵和简单的微分方程，可能也很难去编写游戏方面的程序；对于最近流行的人工智能和机器学习，如果不懂概率和统计的话也很难下手。然而，对编程有用的并不只是数学“知识”，还有学习数学所接受的“训练”过程本身。将现实中的事物转化成模型，用抽象的概念和人造的语法与规则去表达出来，从这一点来看数学和编程其实是非常相似的智力活动呢。</p>
<p><strong>图灵访谈：今年AlphaGo引爆了机器学习和人工智能相关的领域，这是否意味着对于程序员来说，学好数学变得越来越重要呢？对于程序员如何学好数学，您有哪些建议呢？</strong></p>
<p>结城浩：“由于人工智能和机器学习的兴起，对于程序员来说学好数学变得越来越重要了”，对于这一点我觉得很难简单地做判断。程序员很善于对功能进行封装，就算是人工智能和机器学习这种看似高深的东西，将来必定会出现很多面向“用户”封装好的系统和服务。当然，精通数学并没有坏处，我也不是说数学就没那么重要了，我只是想说数学一直都很重要，和当下流行什么东西没有什么关系。</p>
<p>关于对读者的建议，我就简单说说吧。很多程序员对数学，特别是数学公式有一种抵触情绪。我认为即便不懂具体的理论，也应该养成遇到公式都仔细看一遍的习惯，平常先掌握一些基本的数学知识，遇到需要深入学习的部分再去探索就好。</p>
<h3><strong>关于个人</strong></h3>
<p><strong>图灵访谈：您是基督教徒，能简单介绍一下这方面的经历和感受吗？您又是如何看待信仰与科学技术之间的关系呢？</strong></p>
<p>结城浩：我在20多岁的时候有过一段非常痛苦的时期，在此之前，我一直相信人可以靠自己的力量在这个世界中纵横驰骋，但后来我发现自己的这个想法太傲慢了。当遇到自己无论如何也无能为力的状况时，除了苦恼真的无计可施。就在那个时候，我开始信圣经中的基督，并成为了一名基督教徒。此后，我每周都去教堂，读圣经，过着信仰上帝的生活。</p>
<p>我写了很多技术方面的书，但是我却信基督。对于这一点可能很多人抱有疑问，他们可能觉得信仰上帝是一种不科学的行为。我认为信仰上帝和用科学方法去思考这两者并不矛盾，因为它们各自所涉及的范围不同。相信圣经上的文字，这一信仰是用来回答“我为了什么活在世上”这个问题的，而无论再怎么学习科学，也绝对无法回答“我”这个特定个体应该如何行动这样的问题。科学的目的是解开“世界的奥秘”，无法解开“我这个人的奥秘”。我自己的人生何去何从，这其中的奥秘是需要通过信仰来学习的。</p>
<p><strong>图灵访谈：您似乎在网上从来不公开自己的照片，而是一直用一个小妖怪的头像。您不喜欢抛头露面的主要原因是什么？用这样一个头像背后有什么故事吗？</strong> </p>
<p>结城浩：我一直不公布自己详细的生平经历和照片，用的那个头像名字叫作“Thread妖怪娃娃”，是我自己画的，其中thread一词的意思是多线程编程里面的“线程”。我写《用Java语言学习设计模式：多线程篇》这本书的时候，在书里画了这么一个角色当作运行代码的主体，从此之后我就用这个形象来代表自己了。我的推特头像，以及我在书上签名的时候都会用这个形象。之所以不公布照片，主要还是出于信息安全的考虑，我不喜欢主动公开自己的隐私。</p>
<p><strong>图灵访谈：感谢结城浩先生，希望您能带给读者更多的精彩书籍！</strong></p>
<p>结城浩：最后我想说，感谢大家喜欢我写的书，也感谢大家对我的工作和个人报以如此的兴趣。我今后还会积极地写更多快乐和有趣的作品，希望大家继续支持，谢谢。</p>
<hr>
<p><strong>图灵访谈特约记者：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVxYOj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>更多精彩，加入图灵访谈微信！ </p>
<p><span class=""img-wrap""><img data-src=""/img/bVtg5t"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 知名著者结城浩：坚持做一件事而不厌倦，一旦厌倦马上更换目标 ,1531977980,237,1,289,1,1,https://segmentfault.com/a/1190000005676256
92,1,0,9,"
                    
<blockquote>
<p>起初温州动车出轨，他们抓了程序员； 我没有出声， 因为我不写动车代码。 接着携程网出现故障，他们抓了程序员； 我没有出声，<br>因为我不写旅游代码。</p>
<p>然后小米手机在天猫的数据造假，他们抓了程序员； 我没有出声， 因为我不写电商代码。</p>
<p>后来穿行删除代码，他们抓了程序员； 我没有出声， 因为我不删代码。</p>
<p>最后他们来抓我； 到那时候， 已经没有剩下能出声讲话的人了。</p>
<p>迷·马丁·尼莫拉·渡 —— 《我没有说话》</p>
</blockquote>
<p>以上是我改编的一首诗，原文是德国牧师马丁·尼莫拉的一首诗（忏悔文），这首诗被镌刻在美国波士顿的犹太人大屠杀纪念石碑上。</p>
<p>原文是：</p>
<blockquote>
<p>起初他们抓了所有的共产党人； 我没有出声， 因为我不是共产党人。 接着他们抓了所有的犹太人； 我没有出声， 因为我不是犹太人。</p>
<p>然后他们抓了所有的工会骨干； 我没有出声， 因为我不是工会骨干。</p>
<p>后来他们抓了所有的天主教徒； 我没有出声， 因为我属于新教。</p>
<p>最后他们来抓我； 到那时候， 已经没有剩下能出声讲话的人了。</p>
</blockquote>
<p>事件回顾：<a href=""https://www.zhihu.com/question/46294596"" rel=""nofollow noreferrer"">如何看待异乡好居老板娘控告程序员删代码？</a></p>
<p>5月7号，我、i5ting（桑世龙）、寇云，李彬作为嘉宾参加了 SegmentFault 举办的 D<a href=""https://segmentfault.com/e/1160000004637487"" rel=""nofollow noreferrer"">-Day 天津前端专场</a>大会。</p>
<p>要说交情，在所有的嘉宾中我和李彬交情最浅了，仅仅是在大会当天加过一次面。而其他几位嘉宾我都见过了好几次。</p>
<p>但是看到李彬的朋友圈后，我当时简直是气炸了，感同身受。为什么？因为我也是普普通通的程序员的一名。</p>
<p>随后 i5ting 在公众号发布了《大牛被公司诬蔑，还要进派出所》的文章，于此几乎同时知乎也开始出现了相关问题：<a href=""https://www.zhihu.com/question/46294596"" rel=""nofollow noreferrer"">如何看待异乡好居老板娘控告程序员删代码</a>？作为一名知乎小V，我把文章分享到了微博和其它社交平台。随着几名异乡好居的内部员工的回答，整个事情的真相也慢慢浮出水面。第二天 i5ting 发布了《为何受伤的总是技术人》的文章。（大家可以搜索公众号 nodeonly 阅读这些文章）</p>
<p>虽然微博的阅读量仅仅3万，但是还是引起了印老板的注意，随后印老板回复了我：</p>
<blockquote><p>印建坤是80后：你好，我就是你说的这个“厚颜无耻的”公司的创始人。我们会发官方声明，对于当事人歪曲事实的言行，我个人觉得十分可惜。谢谢你的关注，也请你在不知内情的情况下不要对一件自己完全不确定的事情妄下结论。</p></blockquote>
<p>接着很多人在微博给我发私信，也有些热心网友通过 justjavac 找到了我的微信，然后加了我微信和我聊，或者通过我的微信公众号直接留言。忠告我事不关己高高挂起。你这样做印建坤会不会找你麻烦啊。这些事不是咱们程序员能管的，印肯定有后台。JJC 大神你是不是和彬GO交情很深，看你一直在转发。……如此种种。</p>
<p>对以上热心网友我表示非常感谢，谢谢你们的关心，但是我觉得此时最无助的是李彬，还有和李彬一起遭受不公平待遇的异乡好居的前端工程师们。</p>
<p>即使没有和李彬的一面之缘，我也会关注这件事，关注这件发生在我们天津的事，关心这件发生在程序员身上的事。</p>
<p>在知乎有人贴了这个链接：<a href=""http://m.xianguo.com/blog/xg_2d89wk"" rel=""nofollow noreferrer"">你们知道异乡好居这个公司吗？在天津把员工...</a></p>
<blockquote>
<p>你们知道异乡好居这个公司吗？在天津把员工卡在试用期后不久开除，你去仲裁不给你当月工资，过了试用期不给赔偿，试用期还不给上五险一金。工期都随老板随便说，员工天天加班到早21点，晚凌晨2、3点。没有加班费，报销加班到晚9点之后的打车费，还让你证明你是在加班。没有病假，年假，不能调休</p>
<p>40人点赞 9人评论</p>
</blockquote>
<p>还有这张图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVvHYb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""异乡好居老板娘控告程序员删代码"" title=""异乡好居老板娘控告程序员删代码""></span></p>
<p>我想他们也是千千万万个李彬，他们也受到了不公平的待遇，但是这种待遇之下除了抱怨，还能做些什么呢？</p>
<p>晚上回到家，发朋友圈，获得几个赞和几个朋友安慰的话！！</p>
<p>在匿名社区吐槽，然后获得陌生网友的安慰！！</p>
<p>父母安慰：吃一堑长一智，就当买教训了。</p>
<p>朋友安慰：早一天离开这家垃圾公司就有早一天的福分，凡事往好的一面想想。</p>
<p>网友安慰：坚强些，挺住。</p>
<p>当李彬被冤枉之后的第一件事也是发朋友圈吐槽，当我看到之后第一时间截图并做了转发，我只是尽我微薄之力让更多的开发者看到这种事，看到这种发生在我们程序员身上的事。</p>
<p>我们都是千千万万普普通通的一名程序员。程序员的事，就是我的事，就是我们所有程序员的事。</p>
<p>虽是萤火，我们依然努力发光。不求照亮世界，只愿照亮身边。</p>
<p>最后贴上我的公众号：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVvHYj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""justjavac"" title=""justjavac""></span></p>

                ", 我为什么“明目张胆”地和异乡好居撕逼？因为我是千千万万普通程序员的一名,1531977982,369,1,683,1,1,https://segmentfault.com/a/1190000005134856
93,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1131767-01a04a0aa924b4ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>关于程序员和架构师的讨论很多，我想从不同的角度说下。</p>
<h2>寻路</h2>
<p>当我刚进入软件行业成为一名程序员时，我的理想就是成为一名架构师。架构师这个词的英文叫 Architect，原意是建筑师，因为软件行业参照借鉴了很多建筑行业的概念，所以就借用这个词。我是在学校读书时知道架构师这个名词的，当时很多软件方面的书都是翻译过来的，现在也不知道是谁最早把 Architect 翻译成架构师的了。总之从那时起，架构师这个名词对于我这个还刚准备走出校门的学生来说就特别高大遥远，自然当成了最初的一个职业目标。</p>
<p>可惜，我进入第一家公司后，这是一个家民营 IT 服务企业，我发现居然没有架构师这个职位。我所在的一个几十人团队里，本科刚毕业的是助理工程师，硕士刚毕业的是初级工程师，然后是中级，高级工程师。再往上就变成了项目经理、这个团队就是一个项目经理，下面有几个高工，然后一堆初级和助理工程师。让我颇为失望的是，我当时明显觉得未来我的职业发展目标并不是当时团队项目经理所处的方向。不过一想我离架构师这个目标还早，当时估计最快也要十年吧，先把程序写熟再说，我也不太可能在这里干十年，以后换个就好了。</p>
<p>实际，一年后我就换了个公司，入职后又失望了，发现还是没有架构师这个职位。不仅没有架构师职位，连工程师都不分初、中、高级了，全是软件工程师，再上面是组长、科长、部长，然后就是总经理。科长、部长这类职位是国营性质的，而经理这类职位更像民营公司性质的，这就是一家正在从国营向公司制转型的公司，所以职位也很奇特的混合着。我当时也是想还早，先专注好眼前的事，写好程序做好事情，至于有没有架构师这个职位将来再说。</p>
<p>在这里工程师虽说不分级，但团队里也有一位大家口中的牛人，姓陈，大家称呼陈总，实际并没有承担任何管理职责。工作了十多年了，专注于 IBM AIX 和 HP UX 小型机以及 Oracle 数据库调优。我们那时经常长期出差在客户现场开发、实施，支持上线等，陈总一般不出差。他出现的时候一般都是我快把数据库搞挂的时候，然后就来现场救火，分析磁阵 IO，抓 SQL 调优什么的（当时应用系统都是围绕数据库为中心的）。通过从底向上来发现性能瓶颈，再建议程序优化，当时我觉得他最符合我对架构师这一角色的一些想象，但又总觉得还差点啥，当时是说不上来。总之当时我是很期盼看到一个真正的架构师是怎样的，他们是如何工作的？</p>
<p>在第二家公司工作了几年后，工作了已快 5 年了，我还是没有找到答案，而且感觉走程序员技术发展道路在当前的公司碰到了瓶颈。再次跳槽后，我想之前民营和具有国营性质的公司都没有架构师职位，而且这个名词来自国外，那么外企应该会有吧？尝试去面试过几个外企，不幸的是英语口语太差都没有通过面试，而我那段时间也从广州搬回成都。老实说成都当时的程序员就业环境比广州差不少，工作找的有些郁闷，就干脆休息了半年，好好想想清楚下个五年我该何去何从？</p>
<p>也正是在这赋闲的半年，我突然发现原来除了国企、民营 IT 服务（外包）企业和外企之外，还有一类公司和它们很不一样。这就是互联网公司，而可惜的是成都当时几乎没有任何互联网公司在这边有研发。而正在我等待的时间里，一家新兴快速成长的互联网电商公司正好在成都设立研发中心，时机正好也就加入进去。</p>
<h2>奔跑</h2>
<p>进了互联网公司后，不仅有了架构师职位还有架构师团队，有了方向又可以放心的作一名程序发力狂奔。不停的写程序，优化代码，追求更优更简洁的代码，重构了一遍又一遍，解决一个又一个问题。我曾在以前的文章中将程序员具体和代码相关的工作比作剑术，修炼代码技能类似练剑的过程。很多程序员梦想着有一天能成为一代高手，面对敌人，抽刀拔剑，刹那间交击，归剑入鞘，敌人倒下。就像线上系统突然出现大问题，你打开电脑，查了几行日志，敲下几行代码，分分钟系统恢复。</p>
<p>好吧，实际这也就在电影里能有，随着系统规模的扩大，程序员需要解决的问题和解决问题的方式完全不同。以前看过一篇文章说，进入大规模分布式时代，局部的代码优化已不是最重要的，不像二十年前硬件制约了软件的规模。更重要的是程序之间的协作方式，沟通路径的简洁清晰性。</p>
<p>一个好的程序员当然能写一手好代码，在我学习写程序的前七八年里，业余时间做了一些练习性质的项目。在 Github 之前的时代，Google 还能访问，在 Google Code 上维护了应该不止十万行的业余之作。后来 Github 兴起后迁移过来，不断练习重构优化维护自己的专属工具库，删减了很多冗余代码又新增了不少，目前还剩下几万行。这个过程持续了七年，基本每年重构优化一次，在 Github 持续 commit 时间最长有 118 天（最近看到有人连击 365 天的，真心佩服）。如今过去两年再回头看曾经的代码，不能说觉得完美到不能再优化了，只是觉得继续下去于我剑术精进终究有限，而更大的价值如今已不再局部的优化上。</p>
<p>此时我已在团队承担总体的系统设计工作，专注于局部代码优化其实是在驱动细节而非本质。资深程序员出身的架构师，单兵作战能力都是极强的，就像《进击的巨人》中的利威尔兵长，具备单挑巨人的能力。可当你面对成群结队的巨人来袭时，个人单挑能力的作用始终有限。这时从程序员到架构师不仅仅是一个名称的变化，有时它也意味着技能和视角的转变。在地上飞奔了七八年的程序员，在面对成群的巨人袭来时，深深的感觉到，杀光巨人不应是目的，真正的目的是到达彼岸。选择合适的路径，坚定的前行，清除或绕过挡道的巨人，到达目的地。</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1131767-210c993245e81706.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>飞行</h2>
<p>资深的程序员，每天大部分时间和代码打交道，当需要转变为架构师时，却有一个障碍，借用一句台词来说：</p>
<blockquote><p>汝今剑术已成 ，而道心未明，唯不能斩绝与代码之情。</p></blockquote>
<p>开发功能，解决 bug，优化代码，这是一个资深程序员的拿手技能，也是地面作战的基本技能。而一个架构师还需要掌握其他维度的技能，也许就像一个立体机动装置，让你能在需要时飞在空中看清全局，也能落地发起凌厉一击。多了一个空中的维度，过去在地面练到精熟的剑术，飞在空中还有效么，这需要时间去学习，适应新维度的技巧。</p>
<p>这不是一个容易掌握的技能，这正是我曾经写过的从一个点到另一个点连成线的技能升级，需要一个升维的学习过程。所以很多讨论架构师到底还要不要写代码这事儿的，我思考后的结论是，需要拔剑时就拔剑，而无需在意如果每天不拔剑是不是剑就锈住了？当剑术精进后总觉得每次拔剑就要杀人（只处理难题），其实有时拔剑也可以只是切菜（挡路的小问题），只要有助于达到目标。就像《火星救援》里的马克为了回家便要去种土豆，只要开始，解决一个问题，解决下一个问题，解决下下个问题，等解决了足够的问题，就能回家了。飞在空中的架构师就是要在高处看清都有哪些挡在回家路上的必要问题，落地成为进击的程序员们将其一一斩杀。</p>
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1131767-c922be584c87f0b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如今问我，还出剑么？剑还在手，该出就出。那么还练剑么？练，练空中出剑，术还未成，但道心已明。</p>
<hr>
<p>写点程序世间的文字，画点生活瞬间的画儿，微信公众号「瞬息之间」，遇见了不妨就关注看看。<br><span class=""img-wrap""><img data-src=""/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 飞行的架构师和奔跑的程序员,1531977983,451,1,558,1,1,https://segmentfault.com/a/1190000005106868
94,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://upload-images.jianshu.io/upload_images/1131767-63232ef367331f47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>前阵子连续收到几封来自「程序员客栈」的营销邮件，这引起了我的好奇。</p>
<h2>从客栈说起</h2>
<p>我每天都会收到大量推广或广告的营销邮件，为什么这个引起了我的注意？恩，这里先跑远点扯点题外话。</p>
<p>客栈这个词让我想起了一部叫《新龙门客栈》的电影，这部电影曾给我留下了十分深刻的印象。还在读小学大约五年级时，学校可能是在什么节日组织全校同学去县里唯一的电影院集体看革命电影。老师同学都坐好了，革命电影开始放映了，但放了不到十分钟就卡壳了，进入黑屏状态。出现紧急状况，影院只好另外找了一部电影来播放救场，然后放的就是这部《新龙门客栈》。这部电影按现在的电影分级制度看可能该属于 R 级，在当年对于一帮小学同学们的震撼那自然是极大的，印象能不深刻吗。近年出了这部电影修复版，我又看了遍，最大的变化是一些镜头被剪掉了，二十多年前能看的现在却不能看了。</p>
<p>回到正题，正是因为这样我才好奇的把邮件里的链接点开并跳转到了「程序员客栈」的首页，一看原来就是个程序员接兼职外包项目的平台。按照首页的展示，上面已有好几万的签约程序员了，这不免让我思考什么样的程序员会去接兼职外包项目呢？</p>
<p>然后我就把网站上程序员页面的列表挨着翻了十来页，发现了一个规律。我看过的这些签约程序员多数工作经验在三到五年之间。当然也有例外的，比如工作十年的。而且还看到一个创业公司的创始人，可能是目下创业维艰，接点外包项目来给团队续命吧。总的来说来这里接单的程序员都是想要赚点工资之外的钱吧。</p>
<h2>赚钱方式</h2>
<p>赚钱本无错，只是程序员除了接兼职外包项目还有什么赚钱方式么？</p>
<p><strong>咨询/培训</strong>  <br>一般被外部企业邀请去做咨询或培训的程序员，根据个体差异可能报酬从几千到几万不等吧，但能够提供此类服务的程序员，对其本身的素质要求较高，所以不具有普适性。</p>
<p><strong>演讲/分享</strong>  <br>程序员圈子经常会有一些技术大会分享，组织者一般会对提供分享的讲师支付报酬，具体数额可能各种不同的会各有差异吧，但一般不会比咨询和培训类更多。而对于有些在线类的网络分享，组织方也会给予报酬，这个就更少了。可能一小时的在线分享，会有几百元的一个感谢费吧。</p>
<p><strong>投稿/翻译</strong>  <br>一些写作和英语能力都不错的程序员可以向技术媒体去投稿或翻译稿件。原创千字标准是 ¥150，而翻译会更低些，看译者的水平从千字几十到一百左右。</p>
<p><strong>写书</strong>  <br>也有不少程序员写书出版的，但基本都是技术类图书。对于图书版税，一个非著名作者可能在 6% 左右，而能卖到一万册的国内技术书籍并不多，假如一本书均价 ¥50，可以自己算下大概写一本书能挣多少。当然如果你能像另一个前程序员那样写本《盗墓笔记》这样的书，那么可能你最适合干的也不是写程序，也不需要写程序了。</p>
<p><strong>写博客/公众号</strong>  <br>十年前大家写博客，现在很多人都写公众号。公众号开创了阅读打赏模式，有些人看见一些大V随便写篇文章就有几千人打赏，觉得肯定赚钱。其实写公众号的人真没有靠打赏赚钱的，打赏顶多算个正向鼓励罢了。一个拥有十万读者的公众号，实际平均每篇的打赏人数可能不到 50 人，而平均打赏单价可能不到 ¥5。这么一算假如一篇文章 2000 字，还不如投稿的稿费多。所以持续的博客或公众号写作基本靠兴趣，而能积累起十万读者的程序员几乎属于万中无一吧。</p>
<p><strong>兼职外包项目</strong>  <br>外包项目平台一直都有，但多见于面向设计师的。因为设计师的交付产出更独立且容易评估，而程序项目的交付产出依赖关联性更强，而且不容易评估。所以在「程序员客栈」按人天自己标价，跨度从 300 到 2000 一天。 但对于项目发布方来说，一个发布项目的预算是固定的，比如三万元。假如程序员觉得自己一天价值 ¥1000，那么想赚这三万就得在不到 30 人天内完成这个项目，但程序员对项目的人天估算通常也是出了名的不准。</p>
<p>分析了这么多赚钱方式，发现其实对大部分程序员最具普适性的还是兼职外包方式。其他方式都需要编程之外的一些其他技能，而且显然兼职外包方式相比较而言属于赚钱性价比最高的一种方式，无怪乎会有那么多程序猿去客栈注册为签约开发者。那么这种方式的赚钱性价比真的高么？</p>
<h2>性价比</h2>
<p>我虽然花了点时间研究了这个客栈，但完全不会也不想注册为签约开发者。为什么？因为这种赚钱方式性价比真的很低。不止是兼职外包项目，其实上面提到的所有方式的赚钱性价比都很低。</p>
<p>对，我现在经常写作，偶尔翻译，非常偶尔会受邀做一些在线分享，但我所做的所有这些事情的直接目的都和提高现阶段的收入（立刻多赚钱）没关。网上有个 Ray Dalio 制作的视频《三十分钟看清经济机器如何运转》最后他在视频的末尾提出了三条建议：</p>
<blockquote><ol>
<li><p>不要让债务的增长速度超过收入。</p></li>
<li><p>不要让收入的增长速度超过生产率。</p></li>
<li><p>尽一切努力提高生产率。</p></li>
</ol></blockquote>
<p>三条建议虽然是针对宏观经济的，但用在个人身上也无比正确啊。特别是第二条，现下去多接外包提高了当下的收入，但长期可能会抑制你的生产率，让你失去竞争力。为什么呢？举个例子，经常在电影里能看到一些熟悉的画面，白天晚上打着几份工的人为生活疲于奔命，他（她）还有时间来为做第三条么？疲于奔命导致个人生产率增长的停滞，未来竞争力的下降。</p>
<p>生产率是一个宏观经济术语，用到程序员个人身上可不能直白的理解为产出代码的效率啊。正确的理解我认为是个人价值的产出率，所以我所做的一切都是尽可能的提高个人价值的同时推升价值产出率，也就是在做第三点。而个人价值的提升可能不会立刻反应到当下的收入上，就像公司的内在价值提升了可能股价还没涨一样。但长期来看价格总是要回归价值的，这是经济规律，宏观如国家，微观如个人。</p>
<h2>出发点</h2>
<p>最后回到我们的主题，到底该不该接兼职外包？我觉得选择的出发点应该是看是否以个人价值及其增长为归依，而非是为了当下能多赚点钱。过于专注短期的收入提升，可能一叶障目，忽视了长期的价值增值。</p>
<p>所以上面列出的所有赚钱方式，我认为都是在不以赚钱为直接目的，而以个人价值增值为出发点为前提下才值得尝试。正因为兼职外包接单对很多程序员具有普适性，所以才想搞清楚针对这件事的出发点。为了多赚点外快牺牲当下所有的业余时间，这值得吗？这种兼职外包项目对于自身的价值增值有多大的帮助？我估计很多兼职项目都是低水平的重复劳作，这不止是兼职甚至很多全职工作都如此。</p>
<p>说个例子，刚毕业和我一起加入公司的另一个校友，我被分配维护一些历史遗留 Java Web 项目（可能因为毕业时我已有些 Java Web 相关的课程设计）。而他完全没有这方面的基础，所以被安排维护另外一个历史遗留基于 IBM Lotus 的系统。估计 Lotus 这套东西现在几乎绝迹了，在当时也是非技术主流了，只不过因为历史原因还需要维护。既然公司出钱招聘了你，为了生存和生活，作为刚毕业的我们其实没有多少挑选工作内容的机会。所以他在维护 Lotus 项目之余，还在不断的学习 Java 相关的东西，找一些业余项目来做和练习，为下一次的工作转型作准备。我认为像他这样以此为出发点的兼职或业余项目都是没问题的。</p>
<p>为什么客栈上三到五年的签约程序员最多，我揣摩可能与他们所处的阶段有关。正是处在结婚安家的阶段，收入敏感度较高。但牺牲未来潜在的生产率增长来换取当下收入临时的且不高的增幅，是不值得的。按照前面我说的对个人生产率的理解：</p>
<blockquote><p>个人生产率 = 个人价值的产出率</p></blockquote>
<p>在价值积累到一定阶段之前，收入增长的并不明显，这阶段人和人之间的收入差距其实很小。想想同一家公司同一个岗位同样工作三到五年的程序员，收入能有多大差距呢。这阶段你即使花费所有的业余时间来赚钱，与你的同龄人拉开的收入差距也不大。而我观察多数真正拉开差距的阶段是在工作的十年到二十年之间，根据个人的价值积累大小，价值变现的机遇，拉开的差距是数量级的差别。会让你生出看起来我们差不多但他干一天能抵我干上一个月甚至一年了的感慨。</p>
<p>所以前十年不妨把关注的焦点放在个人价值的增值上，而我个人领悟的太晚，前十年已经过完了，才刚刚开始沉下来对个人的价值做反思和梳理，发现欠缺的太多。价值通过能力体现，能力包括能力的深度、能力的边界和能力之间的协同作用，所以选择的出发点就是努力培育和提升真实的能力，价值先增值了，反应个人价值的收入按经济规律终将回归。</p>
<p>...</p>
<p>从程序员接外包这件事好像发散到了如何看待程序员收入，就不进一步发散了。最后总结下吧，如果你安于现状，觉得目前收入足够满足现在的生活，能力增长停滞，那么可能需要警惕环境变化带来的中年职业危机。如果你现下感觉缺钱，拼命想多赚钱提升当下的生活，不妨适当压制享受的欲望将其延后。如果你追求经济自由，那么你的路可能还很长，可将其作为一个目标，而不是一个终点，保持前行，但别忘了感受路途的风景。</p>
<hr>
<p>写点文字，画点画儿，「瞬息之间」一切都变了。觉得不错，可长按或扫描二维码关注。<br><span class=""img-wrap""><img data-src=""/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 程序员应该接外包吗？,1531977985,412,1,756,1,1,https://segmentfault.com/a/1190000004975318
95,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://images2015.cnblogs.com/blog/815275/201604/815275-20160413222825426-805329106.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我刚毕业那年第一个月到手的全额工资大概是 4k 出头，自己单独租了一个套一的房子再加上吃饭一个月 2.5k 就这么花掉了。每个月所剩余的可自由支配的钱确实不多，我这也算是在一线城市的广深地区，在内地二线城市的朋友当时只有 1k 出头，合租房加上吃饭还略显紧张。所以我们当时不太需要考虑花钱这个事，确实是没什么钱可花的。</p>
<p>今天行业发展得不错，如今程序员的起薪大幅提升，刚走出校门的同学除租房吃饭之外想必都还有不少剩余可供花销。作为一个过来人，写这篇文章其实就想谈谈早期如何更明智的花钱，可能会对自身未来的发展更有好处。</p>
<h2>电脑</h2>
<p>一般进入公司你会得到一台工作电脑，有些公司是直接给你配置发放没得选择（当年我就是领了个二手本），有些是给你一个上限额度让你自己去买一台，再分几年折旧完，比如额度 8k 分四年折旧，这样你每在公司呆满一年，公司返 2k 给你。我比较喜欢后面一种，这样我可以自由选择自己的电脑配置，但偏偏我这十年工作过的所有公司都是第一种，只能呵呵了。</p>
<p>工作前几年公司发什么电脑我只好用什么，工资剩余也不多，当时虽然心系 ThinkPad T 系列的本子，但按我前面的每月结余不得存上一年才能买得起啊。而且心想我干嘛要拿自己电脑去公司工作啊，当时确实想不通。所以结果就是工作的前五年，我换了三个公司用了三个笔记本，都有一个共同特点：慢，还老需要重装系统。回头一想浪费了多少青春好时光在等待编译、打包和重装系统上啊。</p>
<p>五年前到了京东后，碰到了一个同事他就用的自己的电脑，一台 09 款的苹果小白 Macbook。这是最后一代塑料外壳的 Mac，之后都是细磨砂铝合金的了。之后他就一直给我安利 Mac 的好处，然后我就自己买了一台当时最新的 Macbook Pro，再 DIY 换了 SSD 硬盘，原机搭配的机械硬盘用作 TimeMachine 的备份盘，再把内存加到 12G 一直用到今年初。再更新了最新的 OS X EI Capitan 之后，感觉系统变得更快了（说明 OS 优化的更好了吧）。</p>
<p>用 Mac 的五年里彻底告别了 Windows 下重装系统的问题，都快忘记怎么装了。在原来公司发的电脑上 mvn package 一下一个以前的 Java 工程需要 50 秒，在我的 Mac 下是 20 秒。考虑下这五年来这个命令敲击了多少次，每次都节省半分钟，还是很可观的。关于为什么要用 Mac 的最有力的理由，我觉得最有发言权的是 Mac 代言人池建强在他的文章《先有 Mac 还是先有银元？》里已经写得很明白了，我就不再多说了。</p>
<h2>椅子</h2>
<p>去年底去体检时医生说我的颈椎有轻微变形，而我自己也时常感受到肩背的酸痛。既然达到了变形的程度，肯定非一日之功，都是长年累月不正确的坐姿导致的。程序员进入专注写代码和调程序的状态，或者全神贯注的处理着线上的问题和 bug，哪里还会注意到自身坐姿的问题。有时还要加班熬夜通宵什么的，累了就趴在桌上睡着了，这些都是导致脊椎长期过载并变形的原因，然后随之而来就是肩背酸痛，扭动脖子咔咔得响。</p>
<p>正因为如此我才开始关心起椅子的事情，然后我想到好些年前看的《软件随想录》，其中程序员部落酋长 Joel 写道：</p>
<blockquote>
<p>程序员的椅子是 Aerons 出品的名牌电脑椅还是 Staples 品牌打折时的便宜货？关于 Herman Miller 设计的著名的 Aeron 牌电脑椅，请让我在这里多说一句。  </p>
<p>这种椅子的价格是每把 900 美元，比办公用品连锁超市 Office Depot 里卖的便宜货或者 Staples 牌贵出 800 美元。Aeron 牌电脑椅比那些便宜货舒服得多。如果尺寸正确，并且调节到最合适的位置，那么大多数人坐一整天都不会感到不舒服。靠背和坐垫都被设计成网状形，空气可以自由流通，所以坐着不会捂汗。这种椅子包含了第一流的人体工程学设计，尤其是那些带有腰部支撑的新型号。  它们比便宜的椅子更耐用，一把 Aeron 牌电脑椅的寿命至少抵得上 4 把那种 100 美元的椅子。  </p>
<p>所以结果是，买一把 Aeron 牌电脑椅，每 10 年只多出 500 美元，也就是每年多出 50 美元，相当于在每个程序员身上每星期多支出 1 美元。一卷上等卫生纸的价格大约是 1 美元。你的程序员每人每星期大概会用掉一卷。所以，将电脑椅升级到 Aeron 牌，多出的花销与你花在程序员的卫生纸上的开销大致相等。但是，我可以向你保证，如果你把卫生纸的支出拿到预算委员会上讨论，你一定会被严厉地呵斥不要捣乱，还有许多更重要的事需要讨论。</p>
</blockquote>
<p>Aeron 的椅子确实很好，它曾“坐”揽诸多设计大奖，被美国现代艺术博物馆列为永久典藏，还入选了由伦敦设计博物馆甄选的顶尖案例集《50把改变世界的椅子》，堪称办公椅设计史上当之无愧的“头把交椅”。当然价钱也很感人，国内在万元附近，所以基本上绝大多数公司都不会给你配备类似这样的办公座椅。大部分公司配备都是几百块一把的普通办公椅，无人体工学设计，在工作时对你的肩背和脊椎没有任何支撑作用。</p>
<p>不过像 Aeron 这样高端的椅子我自己买起来都还是感觉肉痛，但至少给自己配一把符合人体工学设计的椅子还是有必要的。在 1.5k 到 3k 之间还是有一些可供选择的替代品，别等到十年后需要去医院做脊椎牵引理疗，这花费的时间和金钱不比椅子贵多了，还要受痛苦。当然希望未来更多公司都能想清楚即使一把顶级的 Aeron 椅子的价钱相比程序员的人力成本也算不了什么吧。</p>
<h2>房子</h2>
<p>如果再给我一次机会，我毕业的那年就该想尽办法把房子买了，那么是否意味着今年毕业的你也需要立刻买房呢？斗转星移，时移势易，房产的黄金十年是否已经过了？我 12 年底才在二线城市成都买了套房，每平米价格 7、8k 和我刚毕业那年广州天河岗顶附近差不多。几年过去了这套房子的价格依然保持平稳，没涨没跌。</p>
<p>2016 年伊始就听说上海虹口区新楼盘遭哄抢一空，352 套房源一天内售罄，平均每套均价近千万，每平米均价 8 万。现在这种一线城市的千万级住房都算不上什么豪宅，只不过是普通的小区住宅，是否值得购买呢？基本上我看还是算了吧，如果房子总价超过你年薪的十倍，那么还是别用贷款上杠杆买房了。</p>
<p>如果是在二线城市，比如我所在的成都，不说一千万，一百万的房子已经有很大的选择余地。如果你有年薪十万那么贷款买一套总价百万附近的首套自住房，看起来还算比较合理。现在库存房源太多，首套房贷款比例已降到两成，而公积金贷款的利率也比较低，尽可能长（30 年，因为钱总是不断贬值的）的还贷期限，那么双工薪阶层夫妻双方的公积金就可能能覆盖了每月的还贷额，对生活开支的影响微乎其微。</p>
<h2>理财</h2>
<p>在买完上面这些后，剩下的节余就用来该用来理财。李笑来写过一篇《越早开始越好的事情没几个：理财排在第一位》，他对于理财的观点如下：</p>
<blockquote><p>所谓的理财，理论上并不应该狭义地理解为去银行买理财产品。<br>存钱、做预算、控制开销、赚更多利息、赚利息差、正确使用信用卡、购置不动产、投资一些多少有风险的标的，这些都是理财活动。<br>所谓理财，这个定义比较合理准确：如何有效管理现金流 —— 这其实与钱多钱少关系不大。</p></blockquote>
<p>深以为然，对于理财我就属于开窍得挺晚的，但我观察了下在我身边一直没开窍的也还挺多的，而我的上一代人几乎从来就没有开窍过，一生唯一的理财方式就是银行存款。既然提到理财就是有效管理现金流，我就谈谈如今我管理现金流最重要的一条，永远不把钱放在银行活期账户上。</p>
<p>所以每次工资一到账，预算好本月需要还的各种账单和可预期支出，这部分就会立刻就转到余额宝。其余的部分转入流动性比余额宝更差点，但利息更高的风险资产。理财的本质就是聪明的承担风险，这里的「聪明」并非智商高下，更多是一种控制能力，风险控制和自我心理的控制。至于如何才能变聪明，除了不断学习、试错并吸收经验教训，然后永远地重复这个过程。所以知道为什么越早开始越好了吧，至少试错的成本更低。</p>
<p>大部分人对理财的关心都放在了怎么存来获取更高的利息或投资收益，其实理财的另一面是怎么花。关于花钱就自然绕不开信用卡，传统的观念是挣多少花多少，绝不用信用卡今天花明天的钱。这种观念绝不是什么老一代人的观念，其实我观察到比我年轻的好些人都有。如果你控制不住刷信用卡并导致入不敷出，成为卡奴。那么其实可能你的自控能力也不足也去承担更高风险的理财活动。</p>
<p>虽然我 04 年就办了第一张信用卡，但却一直没开窍用得一塌糊涂。我认为刷信用卡的一大作用是积攒信用，而信用在未来会成为你的财务杠杆。另外刷信用卡还有很多「羊毛」可以薅，有刷信用卡送加油洗车的，有超市或海淘刷卡返现的，也有刷卡送星巴克咖啡或电影票的，还也有机场接送或免费航空保险等等，而且大部分的信用卡刷卡都有积分，积分又可以兑换礼品或航空里程。这里面的窍门多多，但我觉得不要为了薅羊毛去花太多心思，办太多卡，这里面的时间成本也不低。所以结合自身的消费习惯和生活所需去适当办理几张信用卡还是不错的。</p>
<p>这时可能有个观念又会跳出来挑战，手上不留点应急救命钱么？不用，前面说了信用这时就可以当钱用。随时可以从手上的信用卡、京东金条、支付宝借吧、腾讯微粒贷、消费信贷之类的地方借出需要应急救命的钱。而你实际有那么多需要应急救命的时刻么？</p>
<h2>买书</h2>
<p>这条最重要，但只有两句话，所以放在最后。买书根本不需要考虑价钱，读书最大的成本是选书和读所花费的时间成本。所以别花时间去找这个资源那个下载了，直接买是最划算的方式。</p>
<p>...</p>
<p>写了这么些方面，其实这些都是我刚开始挣钱时都没做好的地方，终于开窍了，时间已经过去了不少。</p>
<hr>
<p>写点文字，画点画儿，「瞬息之间」一切都变了。觉得不错，可长按或扫描二维码关注。<br><span class=""img-wrap""><img data-src=""/img/bVupvo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 刚挣钱的程序员同学该如何花钱？,1531977987,313,1,329,1,1,https://segmentfault.com/a/1190000004934137
96,1,0,9,"
                    
<p>创业，互联网，融资，程序员......这些被推在风口浪尖的词总是勾起人们无限的好奇心。什么样的人适合创业？程序员创业是怎样的一番体验？从 0 到 1 的创业过程究竟是怎样的？在这期访谈中，SegmentFault 的 CTO Joyqi 向我们描述了一个技术人在这场互联网创业浪潮中的一些感想。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsZ9l"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p><strong>以前一个人做网站和现在一个团队做社区产品，你感觉有什么区别？</strong></p></blockquote>
<p>在一个团队里工作是很需要胸怀的。一开始，我很有洁癖，总是会挑剔团队里的程序员写的代码，很难忍受自己的程序里有一坨不怎么优美的代码，然后总是忍不住去把它们改掉。挺长一段时间以后，我慢慢领会到很多过分去纠结的细节其实没有那么重要。作为一个团队的领导，我更需要把我的精力放在把握大方向上。与此同时，我需要相信我的队员，给予他们足够的空间去发挥。如果他们实在写了些不好的代码，我会引导他们如何去更好的思考问题，优雅地去写代码。如果团队里的每个人都能提升能力，整个团队的能力就能上一个境界，这远远比我一个人不停地修进代码更有效率和长远的价值。</p>
<blockquote><p><strong>SegmentFault 还在探索盈利模式，这可能在刚开始创业的时候就预想到了，那为什么当时不选择一个可以有清晰盈利模式的领域呢？</strong></p></blockquote>
<p>当时我们的想法非常简单，就是想做一个程序员的问答社区。我们觉得只要把社区做大了，就可以赚钱，至于怎么赚钱，当时没有思考。就是这么一股热血地辞掉了工作开始干了起来。创业不久，我们就把我们的本金烧光了。这个时候，对公司的业务的思路发生了转变。因为急需赚钱，我们开始办各种线下活动，比如影响力比较大的有黑客马拉松。这些活动不仅帮助我们渡过资金难关，更帮助我们树立了品牌形象，和程序员们有了实际的互动。</p>
<blockquote><p><strong>做社区最直接的一个收入来源就是广告，为什么 SegmentFault 从来没有在平台上放过什么广告呢？</strong></p></blockquote>
<p>商业广告对程序员是个很大的干扰。我希望我们的问答社区是个很纯粹的技术平台，在程序员遇到问题的时候，可以在我们的平台里找到思路，而不是被广告分散了注意力。<strong>广告的收入并不值得我们牺牲用户体验。</strong></p>
<blockquote><p><strong> 创业过程中，有没有一个时刻让你感觉到前途一片光明?</strong></p></blockquote>
<p>没有。创业每一刻如履薄冰。我觉得成功是有很大的偶然性的，一个人成功之后，后人可以总结很多很多的经验，但是就算另一个人复制了相同的技能，也未必成功。因为市场是多变的，不可复制的，所以我对市场总是抱有很大的敬畏心，不停地去理解用户的需求，大趋势的发展。</p>
<blockquote><p><strong> 目前的 SegmentFault 离当初的目标还有多远？你们在做什么样的改进？</strong></p></blockquote>
<p>当时创业之初的目标很简单，做大，做成一个能让所有程序员用的网站。这是一个很迷茫的过程，真的很迷茫。以前每天上班，修复一个 bug，改改版，就不知道要如何前进了。但是这又是一个很有价值的磨砺过程，它迫使你去更多更深入的思考自己的产品。现在的愿景是把目前的产品做踏实了，然后在这个基础之上，希望可以建立一个体系。在 SegmentFault，一个程序员，不仅有 TA 提问和回答的历史，还有他的个人档案，喜好，甚至和 GitHub 对接，以更完整的数据去体现一个程序员的技能。然后我们希望更好更好的使用这些数据，为每个程序员提供更多人性化的服务。简而言之，还在探索，也会一直探索成长下去。</p>
<blockquote><p><strong>对于技术人员创业，有什么建议？他们有什么劣势，又有什么优势？</strong></p></blockquote>
<p>在一个开发者没有具备好相关技能或者对此没有任何思想准备之前，不要轻易走上创业之路。开发者由于经常面对代码，他们往往会遵循一条基本准则，那就是任何问题都是有原因的，而且都是有解决方案的。但如果是去干一个企业，这么想会死得很快。任何事情都是有原因没错，但是找到这个原因所需要的代价可不是你在电脑上 debug 代码所付出的那一点时间，在现实生活中试错的成本任何人都承受不起。</p>
<p>至于有什么优势，那么他以前所积累的专业知识可以看成他的一部分资源，仅此而已。至于说什么开发者看问题更理性，更全面之类的，是不是因人而异不说，经过验证也没有什么决定性作用。用这几点总结出创业成功学的都是马后炮，毕竟有那么多比你更理性的人失败了，而还有那么多比你感性都比你更成功。</p>
<p><strong>所以要创业就先把以前的自己当成个屁放掉。。。</strong></p>

                ", 程序员创业是怎样的一番体验？——Joyqi 访谈,1531977989,328,1,400,1,1,https://segmentfault.com/a/1190000004489749
97,1,0,9,"
                    
<p>现在的姑娘们幻想着找一个像国民男神王思聪一样的男票，或者一只国外小鲜肉也不错。印象中，又宅又没有情趣的程序员怎么也不会成为候选人。NONONONO！程序员思维敏捷，思路清晰，毅力惊人，创造力逆天。他们做的了编一个十万行代码的苦力，他们以后也是干家务的料。他们对代码细心体贴，他们以后也能对你悉心照料。他们能随手写一个改变生活的程序，他们以后也能成为下一个扎克伯格，下一个改变世界的英雄。他们好学好啃书好探索，他们集中了人类的智慧和追求更快更好的精神。他们把自己煮了就是碗浓浓的鸡汤。如果他们不是做男票的料？？？I am SPEECHLESS，如果你不相信他们这么优秀，我司 Tairy 就是 living proof。</p>
<p>在我司，Tairy 被尊称为天才少年 00 后，因为他在我司年龄最小，却稳坐后端开发的要职。在这期访谈中，Tairy 分享了他的自学心得，对编程未来的看法，还喝下了一碗关于自己青葱岁月的浓浓鸡汤。（他还间接证明了自己是个男票 Top Choice）</p>
<h3>Part 1：Tairy 是个踏实好学的美男子</h3>
<blockquote><p><strong>在学习计算机编程的时候，有什么经验之谈？</strong></p></blockquote>
<p>首先自学的一个最大的难题就是没有指路的人告诉你该学什么，该怎么学，所以我觉得自学就是解决这两个问题的过程。 </p>
<p>在这个过程中，需要大量的了解别人的观点和方法，然后自己对其做一些思考和总结，最终找到最适合自己的学习方法，所以一定要多与人交流，平时多参加一些技术类的社团，认识一些一起学习的小伙伴，也可以多逛逛社区，取他人之长。 </p>
<p>我觉得在技术成长的过程中，以下几点比较重要：</p>
<ol>
<li><p>多读书，面对网络上快餐式的知识点，对于速成解决实际问题确实很方便，但是要想跟深入透彻的掌握一门技术，还是得去研究相关的书籍。</p></li>
<li><p>耐得下性子，我觉得程序员是和科研非常相似的一个职业，遇到的大多数问题事实上是很枯燥的，所以需要耐得下性子去钻研，才能有所收获。</p></li>
<li><p>厚积薄发，技术与学识的东西，从来都来不得半点虚假，只有大量的积累才能有显著的成长，所以不能急于求成，给自己几年的时间做技术的沉淀，多多积累，再去追求其他的一些事情。</p></li>
<li><p>重视基础积累，基础就像地基，也是学习阶段需要非常重视和积累的。对于计算机领域的四大基础：操作系统，编译原理，计算机网络，算法数据结构应该长期保持学习。</p></li>
<li><p>注意广度和深度的拿捏，单纯的追求视野的拓展，研究各种新兴的技术，可能会造成落地不稳；只研究一门技术，又容易形成井底之蛙的局面；所以要在学习的广度和深度上维护好一个平衡。</p></li>
</ol>
<p>总之，学习是一个很艰难的过程，需要长期的和自己的惰性不断的挑战，最终才能实现自己能力的提升。</p>
<blockquote><p><strong>现在看来，如何评价你自己的大学时光？</strong></p></blockquote>
<p>我很感谢那个时候努力坚定的自己。虽然在学妹眼里，我就是物理系的失足学长，整天上课抄作业，下课没踪影。但她们不知道的是，那个时候的我为未来的我找到了自己热爱的东西，并打下了坚实的基础。我有很多物理系的同学，大三大四的时候非常迷茫，不知道自己以后能做什么，喜欢做什么，于是浪费了大把的精力。而我就不用去经历过这种迷茫，相反，把我的精力用在了该用的地方。</p>
<p>现在工作的时候有时候遇到一些技术问题，很快就能找到解决的办法，都归功于之前大学里面的一些积累；另外自己现在的一些学习和处事方式都是在大学里培养起来的，我觉得这些都对于我以后的发展都会有很大的作用。</p>
<h3>Part 2：Tairy 是个技术宅，但对未来，他很有看法</h3>
<blockquote><p><strong>为什么在计算机编程众多领域里，选择做一只后端开发者？</strong></p></blockquote>
<p>“后端爽！”</p>
<p>其实我也写前端，客户端，但还是更喜欢做后端。我觉得喜欢哪个方向和一个人的性格和价值观有很大的关系，相对前端五颜六色的界面，我更喜欢每天面对单纯的 Terminal，觉得程序结果一条条的在 Terminal 中输出的感觉很美；另外后端可以通过代码让无数台服务器为你工作本身就是一件很有快感的事情（让很多机器为你工作，有种手握大权的感觉 LOL）。</p>
<blockquote><p><strong>你如何看待“PHP 是最好的语言”这句话？</strong></p></blockquote>
<p>我觉得这句话是个笑话。首先我还没有大牛到可以对语言评头论足的地步，所以对我来说语言只有适合不适合。比如需要短时间开发的时候，可以用些敏捷的语言，比如 Rails，因为他们有很多库来拓展功能性。PHP 的话，我觉得在 web 开发上确实很方便，运行环境只需要简单的配置即可，而不像其它的一些语言或者框架，需要不停的折腾环境。所以每一种语言都在特定环境下，有它的优越性。语言实际就是一个操作机器的工具，适合才最重要。单纯地比较好坏，没有意义。</p>
<blockquote><p><strong>你觉得编程的未来会是什么样子的？</strong></p></blockquote>
<p>我觉得未来的编程将会更普遍化和大众化。首先从语言的发展角度来看，语言变得越来越接近自然语言，“!=”变成了 not，“&amp;&amp;”变成了 and。这说明编程门槛已经越来越低，越来越口语化。这种友好的姿态使得越来越多的人可以掌握编程。而且在未来，编程很有可能是一个必要技能，就像大家都需要会写字一样。</p>
<p>如今我们的生活越来越依赖通过程序创造的工具，也就是说我们的生活习惯被程序员所创造出来的东西所改变着。这个趋势让人细思极恐，因为如果你不会编程，你的生活就近似于被程序员所操控，他们让你看到他们想让你看的东西，让你做他们想让你做的事。这种环境下，编程变成了防止社会过度阶级化的工具。</p>
<p>短期来说，编程的门槛已经降低很多，也将会更加轻松和简单化，再加上大量轮子的出现让一些功能的实现更容易，所以我觉得未来会有更多的人加入这个队伍吧。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsvDL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Pepper 点评：如果你是只男性程序员，看完这篇访谈，希望你看到自己身上值得你自己骄傲，很有价值的优点，找不到女朋友根本不是你的错！！！请以自豪的姿态继续寻找。如果你是个妹子，看完这篇访谈，希望你能了解真真实实的程序员，而不被坊间流传的对程序员的偏见绑架。你还可以 Call Tairy maybe &lt;3 需要手机号码评论区留言 XOXO</p>

                ", 为什么你需要找一个程序员做男票?,1531977990,362,1,282,1,1,https://segmentfault.com/a/1190000004372485
98,1,0,9,"
                    
<p>Integ 是 SegmentFault 的前端 Hacker，在本次访谈中贡献了编程五年多的感悟与总结。Codes Don't Lie 这个标题（并非 Hips Don't Lie）代表了 Integ 的诚恳和回答的干货满满。在访谈中，他谈到了最近国内互联网创业热潮的成就及其存在的问题，发表了对行业热门的 JavaScript 的看法，对极客精神的理解，并且在最后谈到了政治和商业对个人隐私的威胁。</p>
<h3>Part I. Scrum Master 与“大菊观”</h3>
<blockquote><p><strong>你为什么自称 Scrum Master？</strong></p></blockquote>
<p><strong>""It sounds cool.""</strong></p>
<p>只是单纯的喜欢这个名字，虽然我个人是反对 Scrum 的，原因是它限制了程序员的创造力。SegmentFault 团队在尝试过一次之后也没有继续使用。</p>
<p>Scrum 在橄榄球里的意思是争球，而在软件工程中是一种协同工作的方法论，也就是常说的“敏捷开发”。大致的流程是大家通过积极的讨论，确定各自的任务和所需的时间，通过移动 Storyboard 上的小纸条，清晰地向所有人展示整个项目的状态。先拆分任务，然后大家一起用扑克牌来估时，每个人使用一张扑克牌，上面的数字代表这项任务需要多少时间完成。通过这种方式，理论上一个庞大的团队可以有效率的完成一个项目。</p>
<p>在我们使用 Scrum 的过程中，第一个 Sprint 就觉得它很有趣，效率也很高。可是慢慢的我们发现它过于程式化，给人一种死板、走流程的印象。在我们只有 3 个人的小团队（一个前端，一个后端，一个设计师兼产品经理）里根本施展不开，简直就是用超级计算机玩扫雷。Scrum 的强透明的属性可能更适合远程的团队使用。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsgoo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p><strong>JavaScript 最近几年是程序员中的一个热点，你对此有什么看法？</strong></p></blockquote>
<p><strong>JavaScript 是互联网时代的汇编语言。</strong></p>
<p>我写 JavaScript 已经接近 5 年了，但是觉得距离精通这门语言还很远。JavaScript 是一门更新很快的语言，用最新的 JavaScript 规范写出的代码，和 JavaScript 刚创造出来时写出的代码，看上去可能差别很大，甚至是用另一种语言写出来的感受。然而，虽然已有多代的更新，我个人觉得，编程的思维模式几乎没有改变。JavaScirpt 最初只是 Brendan Eich 用很短时间设计出来的语言，很难做到完美。然而现在用户众多，即使有更好的语言出现，我个人认为在短时间内也难以替代。</p>
<blockquote><p><strong>你个人积累了很多开发经验，有什么给新手程序员的建议吗？</strong></p></blockquote>
<p><strong>“大菊观。”</strong></p>
<p>当我刚开始接触编程的时候，关注点都在于如何用代码来实现自己的想法。写了很多个小程序，当我开始真正接触大项目，我发现写代码来解决某一个问题只是编程的第一阶段而已。这仅仅是实现编程路上的一个小台阶。到了第二个阶段，编程的关键在于拥有大局意识，不仅要把功能实现，还要把程序实现得优雅，易于维护，甚至可以快速推倒重来。大局意识还有一个好处：可以大幅节省时间。一个大项目，可以拆分成很多个小功能，这些小功能有些简单有些复杂，有些重要，有些不重要，一定要先挑简单且重要的做，然后是重要但不简单，而复杂且不重要的一定最后做，因为它们很可能在之后的产品设计中被抛弃。大局意识就是合理地优先处理某些重要的小项目。</p>
<blockquote><p><strong>简单介绍一下在 SegmentFault 的工作。如何看待 SegmentFault 的价值？</strong></p></blockquote>
<p>我在 SegmentFault 主要做的是前端开发。除了网站的开发和维护，还会做一部分运营和创意的工作，偶尔还会客串下 DevOps。在 SF 所有工作的目的都是一致的：保证每个用户都可以轻松愉快地使用我们的服务。对于 SF 所做事情的意义，我想到了美国西部大淘金的时代。虽然现在已经没有淘金者了，但是那些默默无闻的为淘金者提供各种相关服务的人同样推动了那个时代的发展。同样的道理，这是开发者的时代，大量的资本和人才涌入互联网行业，SF 服务于开发者，为他们搭建平台，提供支持。所以我对 SF 的未来还是很有信心的。</p>
<h3>Part II. 互联网创业热潮与极客精神</h3>
<blockquote><p><strong>身为创业公司的一员，你对国内的创业热怎么看？</strong></p></blockquote>
<p><strong>商业是有生命的，会自我驱动和救赎。</strong></p>
<p>我认为国内的互联网创业热潮，彻底改变了中国互联网的面貌，甚至改变了很多人的命运。虽然不可避免的存在一定泡沫的，但勇敢的弗拉多正站在这样一群霍比特人之间。虽然我对一些互联网公司的未来不是很乐观，可能一些公司更像是在做市场调研，付出了很多努力，发掘了新市场后，很有可能后来居上，被其他人学走商业模式和核心技术，然后把第一批初创公司挤出市场。创新在很多领域都有，重点在于如何构建商业模式，实现它的价值。我在美国时发现很多产业都只剩下几个巨头在竞争，而国内各种类似领域有大量小公司的存在。对于小公司来说规模扩张的成本在提高，人力成本也在提高，每个领域最后可能只会剩下做得最好的几家公司。</p>
<blockquote><p><strong>你是如何理解极客精神的？</strong></p></blockquote>
<p><strong>Geek 都是理想主义者。</strong></p>
<p>在我看来，真正的极客精神是非常理想化的。首先，你需要大量的时间，需要不用去考虑物质因素，不向现实妥协。在这种不计成本的情况下，真正的极客会不计精力地去钻研 TA 所热爱的事物，制造新鲜的东西。如果有人问一个专业登山者：“你为什么做这些？”，正确的答案是：“因为山就在那里”。极客也是如此。纯纯粹粹地为了探索而探索，就像物理学家费曼，特别喜欢研究如何开锁，但他不用去顾虑这些研究是否会带来实质性的回报。与此同时，真正的极客不能局限于某个领域，那样只能被称作某些领域的专家。极客有着无限膨胀的好奇心，对身边的各种事物都会克制不住地去探个究竟。从这个意义上说，国内真正的极客还是少见的。</p>
<h3>Part III. 自由软件与知识产权激进主义</h3>
<blockquote><p><strong>看到了你博客里关于《若为自由故》的读书笔记<sup><a class=""footnote-ref"">1</a></sup>，想问下你对知识产权和开源的个人看法？</strong></p></blockquote>
<p><strong>《Free as in Freedom》这本书向所有人发出了警告，信息安全问题势必成为互联网行业的 H-Bomb。</strong></p>
<p>无论是微软、苹果之类的科技公司巨头还是各类信息服务提供商，虽然可能并不希望这样做，但它们的一些不透明行为，导致其用户的隐私，存在着严重的安全隐患。除了这些公司里的一部分人，其使用者根本不能确定自己的用户信息、密码、搜索记录等内容是否万无一失，是否会被他人染指。尤其是在恐怖主义的威胁下，很多国家出台了应对法案，一个主要附带结果就是个人隐私的威胁进一步扩大。《若为自由故》的作者 Richard Stallman 提出的解决方案是<strong>拥抱自由软件</strong>。 </p>
<p>可能很多人会误解自由软件，认为开源和保护知识产权是相互矛盾的，其实并非这样。正因为各种开源协议的存在，我们可以更好的保护自己的知识产权不受侵害。而且，自由软件并不反对商业。甚至 RMS 明确提出了“自由商业软件”的概念。</p>
<p><strong>人们应当可以以任何有价值的方式自由地使用软件。</strong>——自由软件的哲学</p>
<p>互联网之子 Aaron Swartz 的自杀，引发了人们对公共领域的思考。他是一个殉道者，他做的事情在当时是存在道德风险的，然而他的死促进了社会大众对公共领域看法的大幅改变。人类知识智慧的结晶应让所有人分享，这样我们才能在真理的追求上不断前进，然而我不否认知识产权所有者对应得利益的索取。</p>
<p>Richard Stallman 和 Arron Swartz 都是 <em>知识产权激进主义</em> 的代表人物。他们的行为和观点不能简单的用对或错来评价，这些观点对于处在不同时代不同的人有不同的利与弊，受争议是必然的。  <br><br><br><strong>如果大家有任何问题，或者就某一话题想讨论，请在评论区留言给 Integ~</strong></p>
<hr>
<p>//看破红尘清新文艺的编程女纸 Lily，愤世嫉俗逗逼无穷的编程喷子 Pepper<br>Pepper：Lily，我们是何方妖怪？<br>Lily：我们都是萌萌哒美帝大二在读生，现在在 SegmentFault 实习中。<br>Pepper：我们最近两打什么酱油？<br>Lily：我们要制作一个访谈系列，为打破外界对程序员简单平面的偏见，他们其实都是有血有肉有思想的创造家。</p>
<hr>
<ol><li> <a href=""http://segmentfault.com/a/1190000002699413"" rel=""nofollow noreferrer"">《自由软件利与弊》</a> <a class=""footnote-backref"">↩</a>
</li></ol>

                ", Codes Don't Lie —— Integ,1531977992,342,1,931,1,1,https://segmentfault.com/a/1190000004330616
99,1,0,9,"
                    
<p>刚刚踏入编程世界大门的你，是不是对程序员生活充满了 YY？是不是幻想前方是一条令人热血沸腾的杀怪之路？亦或是默默坐在电脑前做孤独英雄一辈子？充满好奇，不如来看看 SegmentFault 最具匠心的工程师—— <a href=""/u/wtser"" rel=""nofollow noreferrer"">@王铁手</a> 的感悟。他也曾与你一样满心期待地加入互联网行业，在多年不卑不亢，一步一个脚印地慢慢打造自己的生活工作以后，他有话想说。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVsoWj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""手哥.avi"" title=""手哥.avi""></span></p>
<blockquote><p><strong>为什么在大学里选择学习计算机？</strong></p></blockquote>
<p>我觉得这是一个纯粹被兴趣所驱动的选择。从初中家里有了电脑，我就喜欢瞎折腾研究它。高中的时候也是公认的电脑高手。那个时候互联网远没有现在这么发达，没有大数据、云计算、电商这种概念，<strong>所以这个选择并不是追逐浪潮，而是我自己真真切切的喜欢。</strong></p>
<blockquote><p><strong>觉得一个程序员最需要什么样的品质？</strong></p></blockquote>
<p>程序员就像一个学校里最酷的 nerds。他们根本不去操心老师的课，却又什么都懂。为什么呢？因为程序员最厉害的品质就是主动推进。他们自主学习不熟悉的知识，主动探索解决问题。他们需要具备超强的解决问题的能力，在没有人监督帮助的情况下，也能够顺藤摸瓜，一步一步学习新技能，使用新技能，干掉大 boss。与此同时，程序员还需要一针见血的洞悉能力。很多用户，由于自身有限的专业知识水平，往往不知道自己真正想要的是什么。这时候就需要程序员用专业的能力不断和用户“沟通”，来发现用户需求的深层次原因。这种沟通不仅限于语言上的沟通，程序员更多的是通过技术手段采集有效数据，分析这些数据来了解用户。</p>
<blockquote><p><strong>什么是程序员思维？</strong></p></blockquote>
<p>首先，程序员看待事物就像把这个东西放在手术台上要去解剖它，要去理解它的内在逻辑。比如一个手机，在一般人眼睛里它只是手机，而在程序员的眼中，它就是个生命体，有自己的 body（硬件)，自己的灵魂（OS)，能量管理（电池)。各个部分都是互相协作的。比如，OS 要根据硬件的条件去设计。其次，程序员喜欢利用自己的编程技能来傻瓜化自己的生活。比如我自己喜欢阅读各大新闻类网站的最热最新文章，但是繁琐地打开一个个网站去阅读，太费时。于是我自己做了一个帮助推送所有自选网站的热门新闻的<a href=""https://chrome.google.com/webstore/detail/%E5%8D%81%E9%98%85/bpnpkcfhagdgccpikdkldbnngifepibc"" rel=""nofollow noreferrer"">浏览器扩展</a>。这样所有的想看的新闻就能一键 get！</p>
<blockquote><p><strong>为什么选择 SegmentFault？你在 SegmentFault 的工作，感觉有什么收获？</strong></p></blockquote>
<p><strong>我觉得选择一家公司，最重要的是深切地认同公司产品的价值，这样才能保证我的工作是产生价值的。</strong>选择 SF，首先因为我自己就是 SF 的用户，我使用过 SF 的产品，从心底里认同它给不同阶段的程序员带来的帮助和成长。与此同时，我关注一个公司是否能推动我个人的进步。创业公司的优势就是在此。它就好像一个刚出生的小孩，充满了活力，没有历史包袱。由于人员较少，管理灵活，自由，人性化。随着公司的成长，我也需要不断地成长来与之适应。我需要不断的打破原有的舒适区，进入未知领域进行探索。</p>
<blockquote><p><strong>哪些东西平时容易被程序员们忽略，却其实很重要？</strong></p></blockquote>
<p><strong>健身，健身，健身</strong>……重要的事情说千千万万遍。</p>
<p>还有需要控制情绪。因为程序员的专业技术其实是很闭塞的，懂的人懂，不懂的人就是不懂，所以程序员在跟项目经理或者其他不懂技术的人沟通的时候，很容易争执。在这个时候，请把握好自己的情绪。</p>
<blockquote><p><strong>程序员有什么苦逼之处？</strong></p></blockquote>
<p>没有女朋友的，没时间找女朋友。有女朋友的，没有时间陪女朋友啊。BTW，请在入行之前找好女票。<br><br><br><strong>大家还有什么问题，请尽情喊话，王铁手在评论区为你解答！！！</strong></p>
<hr>
<p>//清新文艺无比靠谱的编程女纸 Lily，愤世嫉俗逗逼无穷的编程喷子Pepper<br>Pepper：Lily，我们是何方妖怪？<br>Lily：我们都是萌萌哒美帝大二在读生，现在在 SegmentFault 实习中。<br>Pepper：我们俩最近打什么酱油？<br>Lily：我们要制作一个访谈系列，为打破外界对程序员简单平面的偏见，他们其实都是有血有肉有思想的创造家。</p>

                ", 用匠心和铁手，打造自己的人生 —— Wtser,1531977993,153,1,575,1,1,https://segmentfault.com/a/1190000004330622
100,1,0,9,"
                    
<blockquote><p>为打破外界对程序员简单平面的偏见，一系列程序员访谈正在进行中。</p></blockquote>
<p>第一个接受访谈的程序员 Gemini，在 SegmentFault 主要负责 Android 移动端开发，然而作为移动端工程师，他最喜欢的语言却是 JavaScript。喜欢一语惊人的他，在访谈中贡献了这篇文章的标题——“程序员的使命是让程序员失业”。</p>
<p>以下是访谈内容。</p>
<h3>Part I. 程序员应该致力于“让所有人失业”</h3>
<p><strong>我们生活中的很多东西，都正在被计算机取代。</strong>对于年轻人来说，网上课程，电子邮件都不是新鲜事。然而如果你从 2016 年往回看历史，会发现计算机对人类社会已经造成了巨大的改变。计算机对整个社会的就业结构产生深远的影响，导致很多工作的需求直线下降，比如电话销售员。我的计算机教授曾经说过：当你在考虑就业方向时，最好考虑一个因素，你的工作将来是否有可能被自动化程序代替，计算机对我们的生活产生的影响可能高出你的预料。仅仅几个搜索引擎巨头主导了你大部分情况下获取的信息内容，从而影响你的思维。</p>
<p>“这是计算机的时代，是程序员的时代”，当被问到对计算机和互联网的展望时，Gemini 给了肯定地评价，“计算机和互联网行业的投资热绝不是泡沫”。我们现在可能处于与工业革命带来的影响力相匹配的计算机革命时代当中。然而对程序员的未来，他说：“我认为程序员的使命是写出一个可以自动写出所有程序的程序，从而导致所有程序员失业。曾经很多程序员被雇佣来写程序让 Photoshop 处理过的图片能在网页中显示，然而有一个程序员写出了能自动转换成 html 格式的脚本，导致这个工作不再有人工需求，部分程序员被转岗。”</p>
<p><strong>“程序员不仅应致力于让程序员失业，也应致力于让所有人失业。”</strong></p>
<p>Gemini 补充道，“我认为程序员不只限于写代码来实施项目，真正使命在于使用机器来代替人力，利用人工智能促进社会生产力的发展。互联网企业改变了一个又一个传统企业，倒逼他们进行产业改革或者制度改革。电子商务行业彻底颠覆了传统的零售业，Uber 等 O2O 打车行业引发社会对出行行业的思考，这些改变与颠覆让我们生活充满想像力，让人们充满动力”，Gemini 谈到了程序员自身的命运，“程序员作为一个新兴行业，在不断探索过程中，因为自己不断创新的一个本能，必将颠覆自己，‘失业’只是目光短浅情况下看到的结果，人类社会的进步一直都伴随着腥风血雨。”至于达到终极目标后，失业的人们应如何生活，我相信社会学家等会提出设想。 </p>
<p><span class=""img-wrap""><img data-src=""/img/bVsgeG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><em>图右的 HACKer 为 Gemini</em></p>
<h3>Part II. “我最喜欢的语言是 JavaScript”</h3>
<p>“Mark Zukerberg 在大学里写出了 Facebook， 我大学时期就也写了一个类似 Facebook 的社交程序。我和一个学长合作，不是为了盈利或其他原因，只是纯粹地觉得我们也能写出这个程序。当时云服务器还不普遍，我们只能把服务器架构在学校实验室电脑上。”Gemini 如此描述他参与的第一个大型项目。至于个人的第一个程序，则是他高一的时候写的一个社交属性的论坛。他说道：“在论坛上，我可以发表文章，然后可以查看朋友的留言。我高一时费了很长时间把服务器架设在自己电脑上，我还一直开着电脑，为了让论坛持续在线，就这件事被我父母讲了很多遍。”</p>
<p><strong>“我最喜欢的语言是 JavaScript”。</strong></p>
<p>Gemini 学习和使用过很多语言。当被问到计算机语言的个人喜好时，他的回答是 JavaScript。“JavaScript 能时刻保持新鲜感，功能更新得很快，”他解释道，“JavaScript 让前端工程师有更大的潜能，能做一些后端工程师的工作，另外我对 JavaScript 的未来发展也很看好。我就是喜欢这门语言。”他最后加上一句。对于其他计算机语言，Gemini 认为“<strong>一些 Java 程序员可能会有些教条主义的倾向</strong>。Java 相对来说是一门历史较为悠久的语言，程序员在学习这门语言时，会学到许多 Design Pattern 的知识。某些 Java 程序员在写程序时，可能会受影响，然后写出很复杂的代码来解决两三行代码就能解决的问题。Design Pattern 是一把双刃剑，”他解释说，“开个玩笑的话，一行代码能运行的事情，让 Java 程序员来写，可能写得又臃肿又冗长。” </p>
<p>关于新手如何学习的建议，Gemini 说道：“<strong>官方网站是我最推荐的学习渠道</strong>，因为官网是更新最快的，其他途径比如通过看教学视频的话，因为视频制作周期较长，可能造成到学习到过期技术的情况。当 Android SDK 已经更新到 Ice Cream Sandwich 时，很多视频还在讲 Android Gingerbread 的开发。”他还提到对于客户端开发者来说，他认为高等数学是非常值得认真学习的一门课。“客户端开发者在制作动画的时候，会需要数学知识来模拟物体运动轨迹等，微积分等数学知识会用到。”</p>
<h3>Part III. 技术，产品和未来</h3>
<p>Gemini 同时是个酷爱技术的人。“如果有新的技术点等出现，我会放在脑子中的 to-do-list 里，然后等到空闲时间来研究学习。我喜欢看新功能的源代码，了解这些酷炫的效果是如何实现的。”源代码公开是一个热议话题，当问到对源代码公开的个人观点时，Gemini 说到：“虽然对程序员是一件好事，可以让程序员研究源代码，但我并不认为所有软件的源代码必须公开，源代码公开涉及到知识产权等各种问题。同时，我有一个请求，如果软件是闭源的话，我希望该公司能够尽快处理好 bug，既然他们不允许外部开发者通过研究源代码来帮助修复 bug”。</p>
<p><strong>当被问到身为开发者的个人感受的时候，Gemini 感慨道，“程序员和产品经理是天生的冤家。”</strong></p>
<p>很多情况下，好的设计效果和漂亮的代码不可同时兼得。好的代码能让程序员有舒心的感受，但是不一定有好的用户体验。有一种能减轻此矛盾的方法，就是开发者兼任程序设计的职位，当这两种职位由同一个人担当时，前文提到的矛盾貌似就可以解决。很多独立的游戏开发者，同时设计游戏场景，以及代码实现。然而 Gemini 认为，这样的情况还是会导致矛盾。“这样的情况下程序员有两个目标，一个是希望自己的产品能有更多用户，另一个是写代码写得舒心。然而大部分情况下很难用漂亮的代码来实现漂亮的界面，从而吸引更多的用户。”他评论道，“即使是一个人承担两种工作，这份工作本身就存在矛盾，但是一旦解决这个矛盾，那它一定就是一种被称为‘完美’的艺术。”</p>
<p>至于在 SegmentFault 的现任客户端工作，Gemini 表示非常有成就感。“我在 SegmentFault 待了一个月，就写出了 SegmentFault for Android，这是一个值得我自己骄傲的作品，我在其中融入了很多我想表现的东西，包含一些新奇的技术，以及作为一个 Android Developer 最爱的 Material Design。SegmentFault 团队给予了我最大的自由度让我表现自己，它让我感觉到了公司对一个技术人的信任，和对待技术的尊重。”</p>
<p>最后一个问题是：你对中国未来互联网的发展有什么展望？</p>
<p>“我希望中国能出现 Google 这样的为了研发科技而研发科技的公司。”他说到，“我个人觉得国内的一些程序员有时候有些功利，专注与有可见利益的项目，而不是为了个人的信念而去编写程序。Google X 的很多科研项目是在短时间内没有可见利益的，然而这些项目对科技和社会的发展有很重要的意义。”</p>
<p>-EOF-</p>
<p><strong>如果大家有任何问题，或者就某一话题想讨论，请在评论区留言给 Gemini~</strong></p>
<hr>
<p>// 看破红尘清新文艺的编程女纸 Lily，愤世嫉俗逗逼无穷的编程喷子 Pepper<br>Pepper：Lily，我们是何方妖怪？<br>Lily：我们都是萌萌哒美帝大二在读生，现在在 SegmentFault 实习中。<br>Pepper：我们俩最近打什么酱油？<br>Lily：我们要制作一个访谈系列，为打破外界对程序员简单平面的偏见，他们其实都是有血有肉有思想的创造家。</p>

                ", 程序员的使命是让程序员失业 —— Gemini,1531977994,167,1,317,1,1,https://segmentfault.com/a/1190000004325426
101,1,0,9,"
                    
<p>一个月以前，SegmentFault 上线了「笔记」功能第一版，使用 CodeMirror 作为编辑器，支持纯文本、Markdown、Java、Python、JavaScript、CSS 等多种类型的文本渲染，也曾说过后期将支持一些新的功能：</p>
<blockquote>
<ul>
<li><p>支持更多的语言</p></li>
<li><p>支持评论</p></li>
<li><p>SegmentFault 网站内笔记链接自动展开为内容</p></li>
</ul>
<p>（笔记 1.0 版本历史请看<a href=""http://segmentfault.com/a/1190000003409814"" rel=""nofollow noreferrer"">《费马大定理的启示：记笔记是一种信仰》</a>）</p>
</blockquote>
<p>现在这些已全部完成，而且优化得更优雅。但这次要介绍的重点并不是更新，因为我们放的一个大招：快速笔记传送门，上线为所有用户提供服务。</p>
<h2>笔记传送门</h2>
<p>目前有两种正确姿势可以帮你找到笔记传送娘：</p>
<h3>选择文本</h3>
<p>在问答或文章内容中用鼠标选择需要保存为笔记的文字，你会发现鼠标附近出现一枚野生的「放进笔记」按钮：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVp0sk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>情不自禁地点一下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVp0so"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>你要的内容已经在编辑器里等你了。</p>
<h3>复制代码</h3>
<p>你还可以直接把一段代码放进笔记里。让鼠标在问答或文章的代码块上停留 1 秒以上，此时代码块的右上方会浮现出三个按钮：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVp0rm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>然后，同样点击「放进笔记」按钮：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVp0rN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>代码块的快速笔记会自动识别语言类型，并添加代码高亮，你要做的只是保存笔记就好了。</p>
<h2>开发者的初心</h2>
<p>这是一个好消息，笔记传送娘已经躺好洗白白等待体验啦~</p>
<p>关于笔记，如果你还有其他的想法与建议、想要的功能等，欢迎反馈到我们的社区建设 <a href=""http://segmentfault.com/0x"" rel=""nofollow noreferrer"">0x.sf.gg</a>，说不定下次更新就看见自己想要的功能了呢 ｡◕‿◕｡</p>
<blockquote><p>无论如何，希望有一个能陪伴自己好多年的心爱的笔记本。</p></blockquote>

                ", 笔记 v2：快速传送门,1531977996,175,1,939,1,1,https://segmentfault.com/a/1190000003775567
102,1,0,9,"
                    
<h2>Abstract</h2>
<blockquote><p>本文主要介绍如何从0开始，构造适合自己的vim。目的不是比较什么编辑器更好，也不是宣传vim多么神奇，只是想给需要的人提供一些帮助。<br>文章以<strong>ubuntu14.04</strong>，<strong>Vim 7.4</strong> 为例子。主要介绍如何自己动手构造能高效编码的Vim，而不是使用已有的配置。这里说明，已有的配置固然很好，但是也是有针对性，初用Vim应该在探索中发现自己喜欢的配置。</p></blockquote>
<h2>开始</h2>
<p>首先，原始的vi用起来是很别扭的。我新装了一个虚拟机，里面还没有vim，只有vi。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgM5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""正在安装Ubuntu14.04"" title=""正在安装Ubuntu14.04""></span></p>
<p>可以看到，刚装上的时候vi是相当之简陋。↑↓←→四个键都不能用。</p>
<h2>从 Vi 升级到 Vim</h2>
<pre><code>sudo apt-get install vim
</code></pre>
<p>这里当然提前要把源设置好。如何设置源不是本文讨论的范围。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgNz"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""正在安装Vim。"" title=""正在安装Vim。""></span></p>
<p>Vim安装完成之后，会自动覆盖vi。现在的vim已经是一个可以使用的版本了。忍不住来一段HelloWorld。<br><span class=""img-wrap""><img data-src=""/img/bVmgNU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""HelloWorld"" title=""HelloWorld""></span></p>
<p>唉~~~~那么问题来了：</p>
<ol>
<li><p>配色怎么这么难看。</p></li>
<li><p>怎么没有行号。</p></li>
<li><p>这个tab键一下子空了8格，能不能调一下...</p></li>
</ol>
<h2>.vimrc 的设置</h2>
<p>首先介绍一下这个.vimrc文件。这个文件在根目录里面，ls查看不到，用ll可以看到。这个文件是vim的配置文件，想要解决上面的几个问题，我们需要更改这个文件里面的一些内容。</p>
<p>初次使用根目录中可能根夲就没有.vimrc文件。noproblem，可以自己建一个。</p>
<h3>设置行号，用4空格代替tab</h3>
<pre><code>vi .vimrc
</code></pre>
<p>打开了一个空文件，我们先来加一点东西在里面。</p>
<pre><code>
set nu //加入行号显示
set ts=4 //将tab键宽度定义为4
set expandtab //用空格代替tab
</code></pre>
<p>保存退出。再次进入刚刚的.vimrc，行号出来了。按一下tab试试，4空格！YES！</p>
<h3>设置colorscheme</h3>
<p>颜色还是那么难看。没关系，这个是可以调的。首先，终端要改成用户自定义颜色。Edit-&gt;Profile_Proference</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgPq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>需要将这个对钩去掉。然后自己选一个想要的底色。</p>
<p>然后，在<code>usr/shared/vim/vim74/color</code>里面，有很多配色方案。打开.vimrc，加入</p>
<pre><code>colorscheme desert //此处desert可换成任意一种配色方案 
</code></pre>
<p>再次启动vim。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgPD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>好看了？？- -|||</p>
<h3>设置自动缩进</h3>
<pre><code>set cindent
set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s
</code></pre>
<p>将着两行也加入到.vimrc， 可以让代码以C风格缩进。编辑的时候不用频繁的敲tab和space了。</p>
<h3>summary</h3>
<p>上面简单介绍了vim的初步配置，但是，仅仅这样还是不够。你可能会喜欢Eclipse左边的文件树结构，可能也喜欢Eclipse可以显示一个类里面的所有方法，也可能喜欢Eclipse的静态语法检查，也可能喜欢Eclipse的......</p>
<p>怎么都是Eclipse! - -|||<br>因为Eclipse实在太好用...</p>
<p>我想说的是，Eclipse有的功能，vim一样可以。要实现诸多的功能，vim需要安装一些插件。</p>
<h2>Vim 插件管理</h2>
<p>vim插件众多，配置插件更是一件麻烦事儿，不过没关系，推荐大家一款插件管理器<code>Vundle</code>。有了Vundle，插件的安装不再麻烦。</p>
<p>当然，首先你要有一个Vundle。</p>
<h3>Vundle安装</h3>
<p><a href=""https://github.com/gmarik/Vundle.vim"" rel=""nofollow noreferrer"">Vundle网址</a></p>
<p>参考里面的安装方式，首先你要装git，用git装Vundle。</p>
<p>没事，咱们就先装个git。</p>
<pre><code>
sudo apt-get install git
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVmgQt"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""安装git"" title=""安装git""></span></p>
<p>搞定！</p>
<p>下面可以安装Vundle了。</p>
<pre><code>git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVmgRa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""从git安装vundle"" title=""从git安装vundle""></span></p>
<p>NOTE:如果https访问失败，可以改正git试一下。</p>
<p>好了，Vundle也有了。在我们安装我们喜欢的插件之前，要按照vbundle的说明书，自己看看<code>.v imrc</code>里面需要怎么写。</p>
<p>请仔细阅读Vundle的说明书。就那么一页纸，please~~~</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgRC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vundle Vimrc"" title=""vundle Vimrc""></span></p>
<p>我们的.vimrc文件现在应该改成这个样子。想装的插件必须放在begin()和end()中间。其中这个Vundle.vim是必须要有的。</p>
<p>现在打开vim，在命令模式下</p>
<pre><code>
:PluginInstall
</code></pre>
<p>试一下。此时插件Vbundle正在安装。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgRG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""插件正在安装"" title=""插件正在安装""></span></p>
<p>安装完成后，左下角会出现Done！</p>
<p>此时我们已经可以安装自己想要的任何插件了。不过首先你要有插件 - -||||</p>
<h3>NerdTree</h3>
<p><a href=""https://github.com/scrooloose/nerdtree"" rel=""nofollow noreferrer"">NerdTree</a>可以让你的vim拥有文件树，just like Eclipse and vs。</p>
<h3>ctrlp</h3>
<p><a href=""http://kien.github.io/ctrlp.vim/"" rel=""nofollow noreferrer"">ctrlp</a>可以方便的在vim打开文件。</p>
<h3>summary</h3>
<p>将上面两个插件的git地址，按照vundle要求的格式加入.vimrc。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgRZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一大波插件"" title=""一大波插件""></span></p>
<p>还是按照上面的步骤，运行vim，执行</p>
<pre><code>:PluginInstall
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVmgR2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""一大波插件正在安装"" title=""一大波插件正在安装""></span></p>
<p>安装完成后，打开刚刚的HelloWorld。输入</p>
<pre><code>
:NERDTreeToggle
</code></pre>
<p>打开了文件树。</p>
<p>在命令模式下，ctrl-p，可以打开文件检索。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVmgSp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>Summary</h2>
<p>vim还有很多有意思的插件，有了这些插件，可以极大的提高我们的工作效率。</p>
<ul>
<li><p><a href=""https://github.com/tpope/vim-surround"" rel=""nofollow noreferrer"">vim-surround</a>：括号管理工具</p></li>
<li><p><a href=""https://github.com/Shougo/neocomplcache.vim"" rel=""nofollow noreferrer"">neocomplcache</a>：代码补全</p></li>
<li><p><a href=""https://github.com/scrooloose/syntastic"" rel=""nofollow noreferrer"">Syntasic</a>：即时语法检查</p></li>
<li><p><a href=""https://github.com/godlygeek/tagbar"" rel=""nofollow noreferrer"">Tagbar</a>：标签生成</p></li>
</ul>
<p>最后感觉，插件的并不是越多越好，也不是vim就是最好。写java裸体Eclipse跟全副武装的vim谁更好用不言自明。所以，针对不容的环境，不同的项目，应选择最合适的编辑器，就像不同的项目要用不同的开发语言一样。</p>
<h2>相关问题解决</h2>
<h3>　自定义TagHighLight高亮的对象</h3>
<p>找到taghighlight的安装目录，我的是<code>~/.vim/bundle/TagHighlight/plugin/TagHighlight/data</code>，打开kinds.txt里面包含高亮的对象，在不需要的前面加一个<code>＃</code>注释掉就可以了。我平时Ｃ用的比较多，所以在Ｃ语言相关部分里面将member和gobleVar注释掉了。</p>
<h2>相关Error</h2>
<ul><li><p><a href=""https://github.com/Valloric/YouCompleteMe/issues/1722"" rel=""nofollow noreferrer"">Error on vim start up when UltiSnips is not installed</a></p></li></ul>

                ", 折腾Vim 编辑器,1531977997,115,1,659,1,1,https://segmentfault.com/a/1190000002885785
103,1,0,9,"
                    
<h2>案例</h2>

<blockquote>
  <p>我想要一个XX的完美实现，各位大神谁能说下怎样实现？</p>
</blockquote>

<p>PS:我看到这个问题的内容，冲动的就想把它删了，根本都不会去考虑怎么回答。你这是问题吗？</p>

<hr>
<blockquote>
  <p><em>以下省略1大段描述</em>，<em>这里有个截图显示的是一些code</em>，请问大家这样的错误是怎么回事？</p>
</blockquote>

<p>PS:X。。。你这是想害死人的节奏啊，问题中的code用截图，是你省事了还是想害死给你解答问题的人？我们连在其他地方try一下的机会都没有了，除非按照截图一个字母一个字母的敲，这是有多大的仇？</p>

<hr>
<blockquote>
  <p>mysql连接显示""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX""，我调用了XXXXXX，但还是出现这个错误，请帮忙解决。</p>
</blockquote>

<p>PS:多点描述会死吗？</p>

<p>之后如果你有耐心的话，就和题主挤牙膏吧！问一句答一句，这是贴吧！不是问答。</p>

<hr>
<blockquote>
  <p>请问各位大神，怎样实现XXXXXXX？……</p>
</blockquote>

<blockquote>
  <p>我遇到了一个XXXXX问题……</p>
</blockquote>

<p>PS:经常性的看到很多的问题，竟然找度娘都能搜到答案，可是为啥题主就不知道看看？</p>

<hr>
<p>还遇到过不同的3个人，发的相同的3个问题，这是刷分的节奏吗？特地等了很久没看到有人会回复，试着回了一下，没有任何的相应。。这是什么意思？</p>

<hr>
<p>难道说答题的人就没事了吗？不是！</p>

<p>碰到过一个问题，就上面截图的例子，我因为觉得奇葩，一个字母一个字母敲的，最后为了省事和题主的命名不太一样，写了例子发了截图来证明没问题。竟然被其他答复者踩，说我这样命名不对，和题主相同的命名才会有问题。好吧，我承认因为自己懒，这么做了有问题？就改一下试试，但我试过之后证明这个答复者说的话是错的，和题主相同命名也不会有问题。没有责任心的答复亏你发的出来！</p>

<hr>
<h2>警语</h2>

<p>看到一个描述不明确的问题，现在懒得和挤牙膏一样慢慢的挤了，但是多天过去后还是没人答复问题，我总是会多余的问一下，不是想说自己怎么样，只是因为我有遇到紧急问题时的经历知道那是一种什么样的心态。</p>

<p>答复你的人，可能是正在工作，可能加班回家休息刚起床，又可能是个脱离了技术岗位的热心人士……总之答复你的人，没有任何义务在你提出问题后答复你问题！有人说有积分哦！积分算个P！多少人真不是看中积分才回答你的，大家都是从一个问题又一个问题走过来的，都明白遇到了解决不了问题的心情，技术注重的是交流，所以才会有这个平台的市场来供大家交流。</p>

<p><strong>我想奉劝大家，提问要有智慧！哪怕你再着急，也要言之有物，越着急越应该把所有相关的信息列出来，这样才会让其他人在空闲的时间看到问题思考后，给你一个答复，而不是把所有的时间都费在""挤牙膏""身上！</strong></p>

                ", 提问的智慧,1531977998,257,1,599,1,1,https://segmentfault.com/a/1190000002719288
104,1,0,9,"
                    
<p>非常全面，Mark。太长了，竟然超过SFG的字数限制 = = 分两次发吧</p>

<hr>
<p>作者：<a rel=""nofollow"" href=""http://lucida.me/"">Lucida</a><br>
微博：<a rel=""nofollow"" href=""http://www.weibo.com/pegong/"">@peng_gong</a><br>
豆瓣：<a rel=""nofollow"" href=""http://www.douban.com/people/figure9/"">@figure9</a><br>
原文链接：<a rel=""nofollow"" href=""http://lucida.me/blog/developer-reading-list/""></a><a rel=""nofollow"" href=""http://lucida.me/blog/developer-reading-list/"">http://lucida.me/blog/developer-reading-list/</a></p>

<h2>关于</h2>

<p>本文把程序员所需掌握的关键知识总结为三大类19个关键概念，然后给出了掌握每个关键概念所需的入门书籍，必读书籍，以及延伸阅读。旨在成为最好最全面的程序员必读书单。</p>

<h2>前言</h2>

<blockquote>
  <p>Reading makes a full man; conference a ready man; and writing an exact man.</p>
  
  <p>Francis Bacon</p>
</blockquote>

<p>优秀的程序员应该具备两方面能力：</p>

<ul>
<li>
<p>良好的<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"">程序设计</a>能力：</p>

<pre><code>*   掌握常用的数据结构和算法（例如链表，栈，堆，队列，排序和散列）；

*   理解计算机科学的核心概念（例如计算机系统结构、操作系统、编译原理和计算机网络）；

*   熟悉至少两门以上编程语言（例如C++，Java，C#，和Python）；
</code></pre>
</li>
<li>
<p>专业的<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"">软件开发</a>素养：</p>

<pre><code>*   具备良好的编程实践，能够编写可测试（Testable），可扩展（Extensible），可维护（Maintainable）的代码；

*   把握客户需求，按时交付客户所需要的软件产品；

*   理解现代软件开发过程中的核心概念（例如面向对象程序设计，测试驱动开发，持续集成，和持续交付等等）。
</code></pre>
</li>
</ul>
<p>和其它能力一样，<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"">程序设计</a>能力和<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"">软件开发</a>素养源自项目经验和书本知识。项目经验因人而异（来自不同领域的程序员，项目差异会很大）；但书本知识是相通的——尤其是经典图书，它们都能够拓宽程序员的视野，提高程序员的成长速度。</p>

<p>在过去几年的学习和工作中，我阅读了大量的程序设计/软件开发书籍。随着阅读量的增长，我意识到：</p>

<ul>
<li><p>经典书籍需要不断被重读——每一次重读都会有新的体会；</p></li>
<li><p>书籍并非读的越多越好——大多数书籍只是经典书籍中的概念延伸（有时甚至是照搬）；</p></li>
</ul>
<p>意识到这两点之后，我开始思考一个很<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E6%95%88%E7%9B%8A%E4%B8%BB%E7%BE%A9"">功利</a>的问题：<strong>如何从尽可能少的书中，获取尽可能多的关键知识？</strong>换句话说：</p>

<ul>
<li><p>优秀的程序员应该掌握哪些关键概念？</p></li>
<li><p>哪些书籍来可以帮助程序员掌握这些关键概念？</p></li>
</ul>
<p>这即是这篇文章的出发点——我试图通过<a rel=""nofollow"" href=""http://lucida.me/blog/developer-reading-list/"">程序员必读书单</a>这篇文章来回答上面两个问题。</p>



<h2>标准</h2>

<p>进入必读书单之前，我先介绍下书单里的书籍选择标准和领域选择标准。当然你也<a rel=""nofollow"">点击这里</a>直接跳转到书单开始阅读。</p>

<h3>书籍选择标准</h3>

<ol>
<li>
<p><strong>必读</strong>：什么是必读书籍呢？如果学习某项技术有一本书无论如何都不能错过，那么这本书就是必读书籍——例如<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;creative=3132"">Effective Java</a>于Java，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00P8VZ8T4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00P8VZ8T4&amp;linkCode=as2&amp;creative=3132"">CLR via C#</a>于C#；</p>

<pre><code>*   注意我没有使用“经典”这个词，因为**经典**计算机书籍往往和**计算机科学**联系在一起，而且经典往往需要10年甚至更长的时间进行考验；
</code></pre>
</li>
<li><p><strong>注重实践，而非理论</strong>：所以这个书单不会包含过于原理性的书籍；</p></li>
<li><p><strong>入门—必读—延伸</strong>：必读书籍的问题在于：1. 大多不适合入门；2. 不够全面。考虑到没有入门阅读和延伸阅读的阅读列表是不完整的——所以书单中每个关键概念都会由一本入门书籍，一本必读书籍（有时入门书籍和必读书籍是同一本），和若干延伸阅读书籍所构成。</p></li>
</ol>
<h3>概念选择标准</h3>

<ol>
<li><p><strong>全面</strong>：全面覆盖软件开发中重要的概念；</p></li>
<li><p><strong>通用</strong>：适用于每一个程序员，和领域特定方向无关；</p></li>
<li><p><strong>注重基础，但不过于深入</strong>：优秀的程序员需要<strong>良好</strong>的计算机科学基础，但程序员并没必要掌握<strong>过于深入</strong>的计算机科学知识。以算法为例，每个程序员都应该掌握排序、链表、栈以及队列这些基本数据结构和算法，但计算几何、线性规划和网络流这些算法可能就不是每个程序员都需要掌握的了；</p></li>
</ol>
<p>通过这几个标准，我把程序员应掌握的关键概念分为程序设计，软件开发，以及个人成长三大类，每一大类均由若干关键概念组成。</p>

<h2><a>快速通道</a></h2>

<p>自从开博以来，经常会有朋友在论坛，微博，和QQ上提问学习X技术读什么书合适（例如：学习Java读什么书合适？如何学习程序设计？）所以我在这里列出了一个“快速通道”——把常见的问题集中在一起，点击问题，即可直接进入答案。（当然，如果你把本文从头读到尾帮助会更大 :-)）</p>

<ul>
<li><p><a rel=""nofollow"">如何学习计算机基础知识？</a></p></li>
<li><p><a rel=""nofollow"">如何学习C语言？</a></p></li>
<li><p><a rel=""nofollow"">如何学习C++？</a></p></li>
<li><p><a rel=""nofollow"">如何学习Java？</a></p></li>
<li><p><a rel=""nofollow"">如何学习C#？</a></p></li>
<li><p><a rel=""nofollow"">如何学习JavaScript？</a></p></li>
<li><p><a rel=""nofollow"">如何学习Python？</a></p></li>
<li><p><a rel=""nofollow"">如何加深对编程语言的理解？</a></p></li>
<li><p><a rel=""nofollow"">如何学习程序设计技巧？</a></p></li>
<li><p><a rel=""nofollow"">如何学习算法？</a></p></li>
<li><p><a rel=""nofollow"">如何高效的调试程序？</a></p></li>
<li><p><a rel=""nofollow"">如何掌握良好的编程实践？</a></p></li>
<li><p><a rel=""nofollow"">如何学习面向对象程序设计？</a></p></li>
<li><p><a rel=""nofollow"">如何对代码进行重构？</a></p></li>
<li><p><a rel=""nofollow"">如何更好的进行软件测试？</a></p></li>
<li><p><a rel=""nofollow"">如何管理软件团队/软件项目？</a></p></li>
<li><p><a rel=""nofollow"">如何成为一名更专业的程序员？</a></p></li>
<li><p><a rel=""nofollow"">程序员如何学习设计？</a></p></li>
<li><p><a rel=""nofollow"">程序员如何进行职业规划？</a></p></li>
<li><p><a rel=""nofollow"">如何提高自己的思维能力？</a></p></li>
<li><p><a rel=""nofollow"">如何进行高效求职面试？</a></p></li>
<li><p><a rel=""nofollow"">如何提高自己的英语写作能力？</a></p></li>
</ul>
<h2><a>程序员必读书单</a></h2>

<h3><a>入门书籍</a></h3>

<h4>程序设计：</h4>

<ol>
<li><p><a rel=""nofollow"">基础理论</a>：<a rel=""nofollow"">编码：隐匿在计算机软硬件背后的语言</a></p></li>
<li>
<p><a rel=""nofollow"">编程语言</a>：</p>

<pre><code>*   [C](#c)：[C和指针](#pointers_on_c)

*   [C++](#cpp)：[C++程序设计原理与实践](#pppcpp)

*   [Java](#java)：[Java核心技术（第9版）](#core_java)

*   [C#](#csharp)：[精通C#（第6版）](#pro_csharp)

*   [JavaScript](#javascript)：[JavaScript DOM编程艺术（第2版）](#js_dom_scripting)

*   [Python](#python)：[Python基础教程（第二版）](#beginning_python)
</code></pre>
</li>
<li><p><a rel=""nofollow"">编程语言理论</a>：<a rel=""nofollow"">编程语言实现模式</a></p></li>
<li><p><a rel=""nofollow"">程序设计</a>：<a rel=""nofollow"">程序设计方法</a></p></li>
<li><p><a rel=""nofollow"">算法与数据结构</a>：<a rel=""nofollow"">算法（第4版）</a></p></li>
<li><p><a rel=""nofollow"">程序调试</a>：<a rel=""nofollow"">调试九法——软硬件错误的排查之道</a></p></li>
</ol>
<h4>软件开发：</h4>

<ol>
<li><p><a rel=""nofollow"">编程实践</a>：<a rel=""nofollow"">程序设计实践</a></p></li>
<li><p><a rel=""nofollow"">面向对象程序设计</a>：<a rel=""nofollow"">Head First设计模式</a></p></li>
<li><p><a rel=""nofollow"">重构</a>：<a rel=""nofollow"">重构</a></p></li>
<li><p><a rel=""nofollow"">软件测试</a>：<a rel=""nofollow"">How to Break Software</a></p></li>
<li><p><a rel=""nofollow"">项目管理</a>：<a rel=""nofollow"">极客与团队</a></p></li>
<li><p><a rel=""nofollow"">专业开发</a>：<a rel=""nofollow"">程序员修炼之道：从小工到专家</a></p></li>
<li><p><a rel=""nofollow"">大师之言</a>：<a rel=""nofollow"">奇思妙想：15位计算机天才及其重大发现</a></p></li>
<li><p><a rel=""nofollow"">界面设计</a>：<a rel=""nofollow"">写给大家看的设计书</a></p></li>
<li><p><a rel=""nofollow"">交互设计</a>：<a rel=""nofollow"">通用设计法则</a></p></li>
</ol>
<h4>个人成长：</h4>

<ol>
<li><p><a rel=""nofollow"">职业规划</a>：<a rel=""nofollow"">软件开发者路线图</a></p></li>
<li><p><a rel=""nofollow"">思维方式</a>：<a rel=""nofollow"">程序员的思维修炼：开发认知潜能的九堂课</a></p></li>
<li><p><a rel=""nofollow"">求职面试</a>：<a rel=""nofollow"">金领简历：敲开苹果微软谷歌的大门</a></p></li>
<li><p><a rel=""nofollow"">英语写作</a>：<a rel=""nofollow"">The Only Grammar Book You'll Ever Need</a></p></li>
</ol>
<h3><a>必读书籍</a></h3>

<h4>程序设计：</h4>

<ol>
<li><p><a rel=""nofollow"">基础理论</a>：<a rel=""nofollow"">深入理解计算机系统（第2版）</a></p></li>
<li>
<p><a rel=""nofollow"">编程语言</a>：</p>

<pre><code>*   [C](#c)：[C程序设计语言（第2版）](#tcpl)

*   [C++](#cpp)：[C++程序设计语言（第4版）](#tcpppl)

*   [Java](#java)：[Effective Java（第2版）](#effective_java)

*   [C#](#csharp)：[CLR via C#（第4版）](#clr_via_csharp)

*   [JavaScript](#javascript)：[JavaScript语言精粹](#js_good_parts)

*   [Python](#python)：[Python参考手册（第4版）](#python_essential_reference)
</code></pre>
</li>
<li><p><a rel=""nofollow"">编程语言理论</a>：<a rel=""nofollow"">程序设计语言——实践之路（第3版）</a></p></li>
<li><p><a rel=""nofollow"">程序设计</a>：<a rel=""nofollow"">计算机程序的构造与解释（第2版）</a></p></li>
<li><p><a rel=""nofollow"">算法与数据结构</a>：<a rel=""nofollow"">编程珠玑（第2版）</a></p></li>
<li><p><a rel=""nofollow"">程序调试</a>：<a rel=""nofollow"">调试九法——软硬件错误的排查之道</a></p></li>
</ol>
<h4>软件开发：</h4>

<ol>
<li><p><a rel=""nofollow"">编程实践</a>：<a rel=""nofollow"">代码大全（第2版）</a></p></li>
<li><p><a rel=""nofollow"">面向对象程序设计</a>：<a rel=""nofollow"">设计模式</a></p></li>
<li><p><a rel=""nofollow"">重构</a>：<a rel=""nofollow"">修改代码的艺术</a></p></li>
<li><p><a rel=""nofollow"">软件测试</a>：<a rel=""nofollow"">xUnit Test Patterns</a></p></li>
<li><p><a rel=""nofollow"">项目管理</a>：<a rel=""nofollow"">人月神话</a></p></li>
<li><p><a rel=""nofollow"">专业开发</a>：<a rel=""nofollow"">程序员职业素养</a></p></li>
<li><p><a rel=""nofollow"">大师之言</a>：<a rel=""nofollow"">编程人生：15位软件先驱访谈录</a></p></li>
<li><p><a rel=""nofollow"">界面设计</a>：<a rel=""nofollow"">认知与设计：理解UI设计准则（第2版）</a></p></li>
<li><p><a rel=""nofollow"">交互设计</a>：<a rel=""nofollow"">交互设计精髓（第3版）</a></p></li>
</ol>
<h4>个人成长：</h4>

<ol>
<li><p><a rel=""nofollow"">职业规划</a>：<a rel=""nofollow"">软件开发者路线图</a></p></li>
<li><p><a rel=""nofollow"">思维方式</a>：<a rel=""nofollow"">如何把事情做到最好</a></p></li>
<li><p><a rel=""nofollow"">求职面试</a>：<a rel=""nofollow"">程序员面试金典（第5版）</a></p></li>
<li><p><a rel=""nofollow"">英语写作</a>：<a rel=""nofollow"">风格的要素</a></p></li>
</ol>
<p>这个阅读列表覆盖了软件开发各个关键领域的入门书籍和必读书籍，我相信它可以满足绝大多数程序员的需求，无论你是初学者，还是进阶者，都可以从中获益：</p>

<ul>
<li><p><a rel=""nofollow"">基础理论</a>包括了程序员应该掌握的计算机基础知识；</p></li>
<li><p><a rel=""nofollow"">编程语言</a>对软件开发至关重要，我选择了<a rel=""nofollow"">C</a>，<a rel=""nofollow"">C++</a>，<a rel=""nofollow"">Java</a>，<a rel=""nofollow"">C#</a>，<a rel=""nofollow"">Python</a>，和<a rel=""nofollow"">JavaScript</a>这六门<a rel=""nofollow"" href=""http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html"">主流编程语言</a>进行介绍，如果想进一步理解编程语言，可以阅读<a rel=""nofollow"">编程语言理论</a>里的书目；</p></li>
<li><p>在理解编程语言的基础上，优秀的程序员还应该了解各种<a rel=""nofollow"">程序设计</a>技巧，熟悉基本的<a rel=""nofollow"">算法数据结构</a>，并且能够高效的进行<a rel=""nofollow"">程序调试</a>。</p></li>
<li><p>良好的程序设计能力是成为优秀程序员的前提，但软件开发知识也是必不可少的：优秀的程序员应具备良好的<a rel=""nofollow"">编程实践</a>，知道如何利用<a rel=""nofollow"">面向对象</a>，<a rel=""nofollow"">重构</a>，和<a rel=""nofollow"">软件测试</a>编写可复用，可扩展，可维护的代码，并具备软件<a rel=""nofollow"">项目管理</a>知识和<a rel=""nofollow"">专业开发</a>素养；</p></li>
<li><p>就像我们可以从名人传记里学习名人的成功经验，程序员也可以通过追随优秀程序员的足迹使自己少走弯路。<a rel=""nofollow"">大师之言</a>包含一系列对大师程序员/计算机科学家的访谈，任何程序员都可以从中获益良多；</p></li>
<li><p>为了打造用户满意的软件产品，程序员应当掌握一定的<a rel=""nofollow"">界面设计</a>知识和<a rel=""nofollow"">交互设计</a>知识（是的，这些工作应该交给UI和UX，但如果你想独自打造一个产品呢？）；</p></li>
<li><p>专业程序员应当对自己进行<a rel=""nofollow"">职业规划</a>，并熟悉程序员<a rel=""nofollow"">求职面试</a>的流程，以便在职业道路上越走越远；</p></li>
<li><p>软件开发是一项需要不断学习的技能，学习<a rel=""nofollow"">思维方式</a>可以有效的提升学习能力和学习效率；</p></li>
<li><p>软件开发是一项国际化的工作，为了让更多的人了解你的代码（工作），良好的<a rel=""nofollow"">英语写作</a>能力必不可少。</p></li>
</ul>
<p>尽管我尽可能的去完善这个书单，但受限于我的个人经历，这个书单难免会有所偏颇。所以如果你有不同的意见，或者认为这个书单漏掉了某些重要书籍，请在评论中指出，我会及时更新。:-)</p>

<h2>程序设计</h2>

<h3><a>1. 基础理论</a></h3>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009RSXIB4&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/FDMMp2w.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""编码：隐匿在计算机软硬件背后的语言""></span></a></p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009RSXIB4&amp;linkCode=as2&amp;creative=3132"">编码：隐匿在计算机软硬件背后的语言</a>这本书其实不应该叫编码——它更应该叫“Petzold教你造计算机”——作者<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Charles_Petzold"">Charles Petzold</a>创造性的以编码为主题，从电报机和手电筒讲到数字电路，然后利用<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF"">数字电路</a>中的逻辑门构造出<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8"">加法器</a>和<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8"">触发器</a>，最后构造出一个完整的<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E6%9C%BA"">存储程序计算机</a>。不要被这些电路概念吓到——<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009RSXIB4&amp;linkCode=as2&amp;creative=3132"">编码</a>使用大量形象贴切的类比简化了这些概念，使其成为最精彩最通俗易懂的计算机入门读物。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004BJ18KM&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/CkWOTm2.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""深入理解计算机系统（第2版）""></span></a></p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004BJ18KM&amp;linkCode=as2&amp;creative=3132"">深入理解计算机系统（第2版）</a>这本书的全名是：Computer Systems：A Programmer's Perspective（所以它又被称为CSAPP），我个人习惯把它翻译为程序员所需了解的计算机系统知识，尽管土了些，但更名副其实。</p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004BJ18KM&amp;linkCode=as2&amp;creative=3132"">深入理解计算机系统</a>是我读过的最优秀的计算机系统导论型作品，它创造性的把操作系统，计算机组成结构，数字电路，以及编译原理这些计算机基础学科中的核心概念汇集在一起，从而覆盖了指令集体系架构，汇编语言，代码优化，计算机存储体系架构，链接，装载，进程，以及虚拟内存这些程序员所需了解的关键计算机系统知识。如果想打下扎实的计算机基础又不想把操作系统计算机结构编译原理这些书统统读一遍，阅读<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004BJ18KM&amp;linkCode=as2&amp;creative=3132"">深入理解计算机系统</a>是最有效率的方式。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00DSQZBDE/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00DSQZBDE&amp;linkCode=as2&amp;creative=3132"">世界是数字的</a>：<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;creative=3132"">K&amp;R</a>中的K（<a rel=""nofollow"" href=""http://www.cs.princeton.edu/~bwk/"">Brian Kernighan</a>）的近作，这本书源自Brian在普林斯顿大学所教授的计算机基础课程，以通俗易懂的方式讲述了现代人所应了解的计算机知识和网络知识；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00AAQXKXS/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00AAQXKXS&amp;linkCode=as2&amp;creative=3132"">图灵的秘密：他的生平、思想及论文解读</a>：<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Charles_Petzold"">Charles Petzold</a>的另一部作品，这本书以图灵的论文<strong>论可计算数及其在判定问题上的应用</strong>（<a rel=""nofollow"" href=""http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf"">On Computable Numbers, with an Application to the Entscheidungsproblem</a>）为主题，阐述了图灵机（现代计算机的始祖）的构造，原理，以及应用。</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011F9OQE/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011F9OQE&amp;linkCode=as2&amp;creative=3132"">计算机系统概论（第2版）</a>：另一部优秀的计算机系统导论型作品，和<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004BJ18KM&amp;linkCode=as2&amp;creative=3132"">深入理解计算机系统</a>不同，这本书采用自下而上的方式，从二进制，和数字逻辑这些底层知识一步步过渡到高级编程语言（C），从而以另一种方式理解计算机系统。</p></li>
</ul>
<h3><a>2. 编程语言</a></h3>

<p>编程语言是程序员必不可少的日常工具。工欲善其事，必先利其器。我在这里给出了C，C++，Java，C#，JavaScript，和Python这六种<a rel=""nofollow"" href=""http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html"">常用编程语言</a>的书单（我个人不熟悉Objective-C和PHP，因此它们不在其中）。</p>

<p>需要注意的是：我在这里给出的是编程语言（Programming Language）书籍，而非编程平台（Programming Platform）书籍。以Java为例，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;creative=3132"">Effective Java</a>属于编程语言书籍，而<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00J4DXWDG/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00J4DXWDG&amp;linkCode=as2&amp;creative=3132"">Android编程权威指南</a>就属于编程平台书籍。</p>

<h4><a>C</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00163LU68/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00163LU68&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/ZXrZwIk.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""C和指针""></span></a></p>

<p>忘记谭浩强那本糟糕不堪的C程序设计，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00163LU68/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00163LU68&amp;linkCode=as2&amp;creative=3132"">C和指针</a>才是C语言的最佳入门书籍。它详细但又不失简练的介绍了C语言以及C标准库的方方面面。</p>

<p>对于C语言初学者，最难的概念不仅仅是指针和数组，还有指向数组的指针和指向指针的指针。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00163LU68/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00163LU68&amp;linkCode=as2&amp;creative=3132"">C和指针</a>花了大量的篇幅和图示来把这些难懂但重要的概念讲的清清楚楚，这也是我推荐它作为C语言入门读物的原因。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/ch4KuSt.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""C程序设计语言（第2版）""></span></a></p>

<p>尽管<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;creative=3132"">C程序设计语言</a>是二十多年前的书籍，但它仍然是C语言——以及计算机科学中最重要的书籍之一，它的重要性不仅仅在于它用清晰的语言和简练的代码描述了C语言全貌，而且在于它为之后的计算机书籍——尤其是编程语言书籍树立了新的标杆。以至于在很多计算机书籍的扉页，都会有“感谢Kernighan教会我写作”这样的字样。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0012NIW9K/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0012NIW9K&amp;linkCode=as2&amp;creative=3132"">C专家编程</a>：不要被标题中的“专家”吓到，这实际是一本很轻松的书籍，它既包含了大量C语言技术细节和编程技巧，也包含了很多有趣的编程轶事；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0012UMPBY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0012UMPBY&amp;linkCode=as2&amp;creative=3132"">C陷阱与缺陷</a>：书如其名，这本书介绍了C语言中常见的坑和一些稀奇古怪的编程“技巧”，不少刁钻的C语言面试题都源自这本小册子；</p></li>
<li><p><a rel=""nofollow"" href=""http://book.douban.com/subject/6519268/"">C语言参考手册</a>：全面且权威的C语言参考手册，而且覆盖C99，如果你打算成为C语言专家，那么这本书不可错过；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00IZW4DK8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00IZW4DK8&amp;linkCode=as2&amp;creative=3132"">C标准库</a>：给出了15个C标准库的设计思路，实现代码，以及测试代码，配合<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;creative=3132"">C程序设计语言</a>阅读效果更佳；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B005LAJ9F6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B005LAJ9F6&amp;linkCode=as2&amp;creative=3132"">C语言接口与实现</a>：这本书展示了如何使用C语言实现可复用的数据结构，其中包含大量C语言高级技巧，以至于Amazon上排行第一的评论是“Probably the best advanced C book in existance”，而排行第二的评论则是“By far the most advanced C book I read”。</p></li>
</ul>
<h4><a>C++</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B003VPX6YS&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/5KPyCw8.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""C++程序设计原理与实践""></span></a></p>

<p>作为C++的发明者，没有人能比<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Bjarne_Stroustrup"">Bjarne Stroustrup</a>更理解C++。Bjarne在Texas A&amp;M大学任教时使用C++为大学新生讲授编程，从而就有了<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B003VPX6YS&amp;linkCode=as2&amp;creative=3132"">C++程序设计原理与实践</a>这本书——它面向编程初学者，既包含C++教程，也包含大量程序设计原则。它不但是我读过最好的C++入门书，也是我读过最好的编程入门书。</p>

<p>比较有趣的是，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B003VPX6YS&amp;linkCode=as2&amp;creative=3132"">C++程序设计原理与实践</a>直到全书过半都没有出现指针，我想这可能是Bjarne为了证明不学C也可以学好C++吧。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0321958322/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0321958322&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/gCHJXQJ.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""C++程序设计语言（第4版）""></span></a></p>

<p>同样是<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Bjarne_Stroustrup"">Bjarne Stroustrup</a>的作品，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0321958322/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0321958322&amp;linkCode=as2&amp;creative=3132"">C++程序设计语言</a>是C++<strong>最权威且最全面</strong>的书籍。第4版相对于之前的版本进行了全面的更新，覆盖了第二新的C++ 11标准，并砍掉了部分过时的内容。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.com/Tour-C--Depth/dp/0321958314/"">A Tour of C++</a>：如果你觉得<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0321958322/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0321958322&amp;linkCode=as2&amp;creative=3132"">C++程序设计语言</a>过于庞大，但你又想快速的浏览一遍新版C++的语言特色，那么可以试试这本小红书；</p></li>
<li><p><a rel=""nofollow"" href=""http://book.douban.com/subject/1096216/"">C++语言的设计与演化</a>：C++的“历史书”，讲述了C++是如何一步一步从C with Classes走到如今这一步，以及C++语言特性背后的故事；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00APCO6DA/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00APCO6DA&amp;linkCode=as2&amp;creative=3132"">C++标准库（第2版）</a>：相对于其它语言的标准库，C++标准库虽然强大，但学习曲线十分陡峭，这本书是学习C++标准库有力的补充；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B006QXQXTM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B006QXQXTM&amp;linkCode=as2&amp;creative=3132"">深度探索C++对象模型</a>：这本书系统的讲解了C++是如何以最小的性能代价实现对象模型，很多C++面试题（包括被问烂的虚函数指针）都可以在这本书里找到答案；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004G72P24/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004G72P24&amp;linkCode=as2&amp;creative=3132"">Effective C++</a>和<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004IP8BD6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004IP8BD6&amp;linkCode=as2&amp;creative=3132"">More Effective C++</a>：由于C++的特性实在繁杂，因此很容易就掉到坑里。Effective系列既讲述了C++的良好编程实践，也包含C++的使用误区，从而帮你绕过这些坑。</p></li>
</ul>
<h4><a>Java</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00G9KF4JC&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/LOiRwUO.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Java核心技术（第9版）""></span></a></p>

<p>平心而论<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00G9KF4JC&amp;linkCode=as2&amp;creative=3132"">Java核心技术</a>（即Core Java）并不算是一本特别出色的书籍：示例代码不够严谨，充斥着很多与C/C++的比较，语言也不够简洁——问题在于Java并没有一本很出色的入门书籍，与同类型的<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;creative=3132"">Java编程思想</a>相比，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00G9KF4JC&amp;linkCode=as2&amp;creative=3132"">Java核心技术</a>至少做到了废话不多，与时俱进（<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;creative=3132"">Java编程思想</a>还停留在Java 6之前），矮子里面选将军，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00G9KF4JC&amp;linkCode=as2&amp;creative=3132"">Java核心技术</a>算不错了。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/93uhytH.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Effective Java（第2版）""></span></a></p>

<p>尽管Java没有什么出色的入门书籍，但这不代表Java没有出色的必读书籍。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;creative=3132"">Effective Java</a>是我读过的最好的编程书籍之一，它包含大量的优秀Java编程实践，并对泛型和并发这两个充满陷阱的Java特性给出了充满洞察力的建议，以至于Java之父<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/James_Gosling"">James Gosling</a>为这本书作序：<em>“我很希望10年前就拥有这本书。可能有人认为我不需要任何Java方面的书籍，但是我需要这本书。”</em></p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00D2ID4PK&amp;linkCode=as2&amp;creative=3132"">深入理解Java虚拟机（第2版）</a>：非常优秀且难得的国产佳作，系统的介绍了Java虚拟机和相关工具，并给出了一些调优建议；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00E0D2OX4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00E0D2OX4&amp;linkCode=as2&amp;creative=3132"">Java程序员修炼之道</a>：在这本书之前，并没有一本Java书籍系统详细的介绍Java 7的新特性（例如新的垃圾收集器，<code>try using</code>结构和<code>invokedynamic</code>指令），这本书填补了这个空白；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0077K9XHW/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0077K9XHW&amp;linkCode=as2&amp;creative=3132"">Java并发编程实践</a>：系统全面的介绍了Java的并发，如何设计支持并发的数据结构，以及如何编写正确的并发程序；</p></li>
<li><p><a rel=""nofollow"" href=""http://book.douban.com/subject/1328664/"">Java Puzzlers</a>：包含了大量的Java陷阱——以至于读这本书时我说的最多的一个词就是WTF，这本书的意义在于它是一个<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F"">反模式</a>大全，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;creative=3132"">Effective Java</a>告诉你如何写好的Java程序，而<a rel=""nofollow"" href=""http://book.douban.com/subject/1328664/"">Java Puzzlers</a>则告诉你糟糕的Java程序是什么样子。更有意思的是，这两本书的作者都是<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Joshua_Bloch"">Joshua Bloch</a>。</p></li>
</ul>
<h4><a>C#</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00DVDDP0K/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00DVDDP0K&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/A6lMyB1.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""精通C#（第6版）""></span></a></p>

<p>可能你会疑问我为什么会推荐这本接近1200页的“巨著”用作C#入门，这是我的答案：</p>

<ol>
<li><p>C#的语言特性非常丰富，很难用简短的篇幅概括这些特性；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00DVDDP0K/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00DVDDP0K&amp;linkCode=as2&amp;creative=3132"">精通C#</a>之所以有近1200页的篇幅，是因为它不但全面介绍了C#语言，而且还覆盖了ADO.NET，WCF，WF，WPF，以及ASP.NET这些.Net框架。你可以把这本书视为两本书——一本500多页的C#语言教程和一本600多页的.Net平台框架快速上手手册。</p></li>
<li><p>尽管标题带有“精通”两字，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00DVDDP0K/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00DVDDP0K&amp;linkCode=as2&amp;creative=3132"">精通C#</a>实际上是一本面向初学者的C#书籍，你甚至不需要太多编程知识，就可以读懂它。</p></li>
</ol>
<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00P8VZ8T4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00P8VZ8T4&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/5sEqC1N.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""CLR via C#（第4版）""></span></a></p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00P8VZ8T4/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00P8VZ8T4&amp;linkCode=as2&amp;creative=3132"">CLR via C#</a>是C#/.Net最重要的书籍，没有之一。它全面介绍了.Net的基石——<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Common_Language_Runtime"">CLR</a>的运行原理，以及构建于CLR之上的C#类型系统，运行时关系，泛型，以及线程/并行等高级内容。任何一个以C#为工作内容的程序员都应该阅读此书。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00J94AG2A/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00J94AG2A&amp;linkCode=as2&amp;creative=3132"">深入理解C#（第3版）</a>：C#进阶必读，这本书偏重于C#的语言特性，它系统的介绍了C#从1.0到C# 4.0的语言特性演化，并展示了如何利用C#的语言特性编写优雅的程序;</p></li>
<li><p><a rel=""nofollow"" href=""http://book.douban.com/subject/4231292/"">.NET设计规范（第2版）</a>：C#<strong>专业</strong>程序员必读，从变量命名规范讲到类型系统设计原则，这本书提供了一套完整的.Net编程规范，使得程序员可以编写出一致，严谨的代码，</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00G51PUDA/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00G51PUDA&amp;linkCode=as2&amp;creative=3132"">C# 5.0权威指南</a>：来自O'Reilly的C#参考手册，严谨的介绍了C#语法，使用，以及核心类库，C#程序员案头必备；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0321637003/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0321637003&amp;linkCode=as2&amp;creative=3132"">LINQ to Objects Using C# 4.0</a>和<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/1449337163/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=1449337163&amp;linkCode=as2&amp;creative=3132"">Async in C# 5.0</a>：LINQ和<code>async</code>分别是.Net 3.5和.Net 4.5中所引入的最重要的语言特性，所以我认为有必要在它们上面花点功夫——这两本书是介绍LINQ和<code>async</code>编程的最佳读物。</p></li>
</ul>
<h4><a>JavaScript</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004VJM5KE&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/xnRA9b6.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""JavaScript DOM编程艺术（第2版）""></span></a></p>

<p>尽管JavaScript现在可以做到客户端服务器端通吃，尽管<a rel=""nofollow"" href=""http://jquery.com/"">JQuery</a>之类的前端框架使得一些人可以不懂JavaScript也可以编程，但我还是认为学习JavaScript从HTML DOM开始最为适合，因为这是JavaScript设计的初衷。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004VJM5KE&amp;linkCode=as2&amp;creative=3132"">JavaScript DOM编程艺术</a>系统的介绍了如何使用JavaScript，HTML，以及CSS创建可用的Web页面，是一本前端入门佳作。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0097CON2S&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/LLq0LC5.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""JavaScript语言精粹""></span></a></p>

<p>JavaScript语言包含大量的陷阱和误区，但它却又有一些相当不错的特性，这也是为什么<a rel=""nofollow"" href=""http://javascript.crockford.com/"">Douglas Crockford</a>称JavaScript为<a rel=""nofollow"" href=""http://javascript.crockford.com/javascript.html"">世界上最被误解的语言</a>，并编写了<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0097CON2S&amp;linkCode=as2&amp;creative=3132"">JavaScript语言精粹</a>一书来帮助前端开发者绕开JavaScript中的陷阱。和同类书籍不同，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0097CON2S&amp;linkCode=as2&amp;creative=3132"">JavaScript语言精粹</a>用精炼的语言讲解了JavaScript语言中好的那部分（例如闭包，函数是头等对象，以及对象字面量），并建议读者<strong>不要</strong>使用其它不好的部分（例如混乱的类型转换，默认全局命名空间，以及<a rel=""nofollow"" href=""https://dorey.github.io/JavaScript-Equality-Table/"">奇葩的相等判断符</a>），毕竟，用糟糕的特性编写出来的程序往往也是糟糕的。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007OQQVMY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007OQQVMY&amp;linkCode=as2&amp;creative=3132"">JavaScript高级程序设计（第3版）</a>：详尽且深入的介绍了Javascript语言，DOM，以及Ajax，并针对HTML5做了对应更新；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007VISQ1Y&amp;linkCode=as2&amp;creative=3132"">JavaScript权威指南（第6版）</a>：这本书的第5版曾被前端专家<a rel=""nofollow"" href=""http://javascript.crockford.com/"">Douglas Crockford</a>称之为<em>“唯一靠谱的JavaScript书”</em>。相对于<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007OQQVMY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007OQQVMY&amp;linkCode=as2&amp;creative=3132"">JavaScript高级程序设计</a>，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007VISQ1Y&amp;linkCode=as2&amp;creative=3132"">JavaScript权威指南</a>更像是一本案头参考书，当然如果你感兴趣也可以从头读到尾；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00BQ7RMW0/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00BQ7RMW0&amp;linkCode=as2&amp;creative=3132"">编写可维护的JavaScript</a>：书如其名，这本书给出了大量的优秀JavaScript编程实践，使得程序员编写出健壮且易于维护的JavaScript代码；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00CYM0Z8Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00CYM0Z8Y&amp;linkCode=as2&amp;creative=3132"">JavaScript异步编程</a>：和常见的支持并发的编程语言（例如Java和C#）不同，JavaScript本身是<strong>单线程</strong>的，因此不能把其它语言处理并发的方式照搬到JavaScript。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00CYM0Z8Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00CYM0Z8Y&amp;linkCode=as2&amp;creative=3132"">JavaScript异步编程</a>系统的介绍了JavaScript中的并发原理，并阐述了如何使用<code>Promise</code>、<code>Deferred</code>以及<code>Async.js</code>编写出简洁高效的异步程序。</p></li>
</ul>
<h4><a>Python</a></h4>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00KAFX65Q/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00KAFX65Q&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/oUHltzm.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Python基础教程（第二版）""></span></a></p>

<p>Python的入门书籍很多，而且据说质量大多不错，我推荐<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00KAFX65Q/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00KAFX65Q&amp;linkCode=as2&amp;creative=3132"">Python基础教程</a>的原因是因为它是我的Python入门读物——简洁，全面，代码质量很不错，而且有几个很有趣的课后作业，使得我可以快速上手。</p>

<p>这里顺便多说一句，不要用<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004TUJ7A6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004TUJ7A6&amp;linkCode=as2&amp;creative=3132"">Python学习手册</a>作为Python入门——它的废话实在太多，你能想象它用了15页的篇幅去讲解<code>if</code>语句吗？尽管O'Reilly出了很多经典编程书，但这本<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004TUJ7A6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004TUJ7A6&amp;linkCode=as2&amp;creative=3132"">Python学习手册</a>绝对不在其中。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004H0784U/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004H0784U&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/0oznmLb.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Python参考手册（第4版）""></span></a></p>

<p>权威且实用的Python书籍，覆盖Python 2和Python 3。尽管它名为参考手册，但<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004H0784U/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004H0784U&amp;linkCode=as2&amp;creative=3132"">Python参考手册</a>在Python语法和标准库基础之上对其实现机制也给出了深入的讲解，不容错过。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00QT9IA2G/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00QT9IA2G&amp;linkCode=as2&amp;creative=3132"">Python袖珍指南（第5版）</a>：实用且便携的Python参考手册，我会说我在飞机上写程序时用的就是它么 -_-#；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00IZRMQAM/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00IZRMQAM&amp;linkCode=as2&amp;creative=3132"">Python Cookbook（第3版）</a>：非常好的Python进阶读物，包含各种常用场景下的Python代码，使得读者可以写出更加Pythonic的代码；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00MHDPIJ6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00MHDPIJ6&amp;linkCode=as2&amp;creative=3132"">Python编程实战：运用设计模式、并发和程序库创建高质量程序</a>：Python高级读物，针对Python 3，2014年的<a rel=""nofollow"" href=""http://www.drdobbs.com/joltawards/jolt-awards-the-best-books/240169070?pgno=7"">Jolt大奖图书</a>，不可错过；</p></li>
<li><p><a rel=""nofollow"" href=""http://book.douban.com/subject/3117898/"">Python源码剖析</a>：少见的国产精品，这本书以Python 2.5为例，从源代码出发，一步步分析了CPython是如何实现类型，控制流，函数/方法的声明与调用，类型以及装饰器等Python核心概念，读过之后会大大加深对Python的理解。尽管这本书有些过时，但我们仍然可以按照它分析源代码的方式来分析新版Python。</p></li>
</ul>
<h3><a>3. 编程语言理论</a></h3>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007HYMPBY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007HYMPBY&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/SixMs8m.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""编程语言实现模式""></span></a></p>

<p>大多数程序员并不需要从头编写一个编译器或解释器，因此<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001NGO85I/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001NGO85I&amp;linkCode=as2&amp;creative=3132"">龙书（编译原理）</a>就显得过于重量级；然而多数程序员还是需要解析文本，处理配置文件，或者写一个小语言，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007HYMPBY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B007HYMPBY&amp;linkCode=as2&amp;creative=3132"">编程语言实现模式</a>很好的满足了这个需求。它把常用的文本解析/代码生成方法组织成一个个模式，并为每个模式给出了实例和应用场景。这本书既会提高你的动手能力，也会加深你对编程语言的理解。Python发明者Guido van Rossum甚至为这本书给出了<em>“Throw away your compiler theory book!”</em>这样的超高评价。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B008FQHHW0/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B008FQHHW0&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/3H08lMv.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""程序设计语言——实践之路（第3版）""></span></a></p>

<p>程序员每天都要和编程语言打交道，但是思考编程语言为什么会被设计成这个样子的程序员并不多，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B008FQHHW0/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B008FQHHW0&amp;linkCode=as2&amp;creative=3132"">程序设计语言——实践之路</a>完美的回答了这个问题。这本书从编程语言的解析和运行开始讲起，系统了介绍了命名空间，作用域，控制流，数据类型以及方法（控制抽象）这些程序设计语言的核心概念，然后展示了这些概念是如何被应用到过程式语言，面向对象语言，函数式语言，脚本式，逻辑编程语言以及并发编程语言这些具有不同编程范式的编程语言之上。这本书或极大的拓宽你的视野——无论你使用什么编程语言，都会从这本书中获益良多。理解这一本书，胜过学习十门新的编程语言。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B008041DUY&amp;linkCode=as2&amp;creative=3132"">七周七语言：理解多种编程范型</a>：尽管我们在日常工作中可能只使用两三门编程语言，但是了解其它编程语言范式是很重要的。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B008041DUY&amp;linkCode=as2&amp;creative=3132"">七周七语言</a>一书用精简的篇幅介绍了Ruby，Io，Prolog，Scala，Erlang，Clojure，和Haskell这七种具有不同编程范式的语言——是的，你没法通过这本书变成这七种语言的专家，但你的视野会得到极大的拓宽；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00GAUNDYY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00GAUNDYY&amp;linkCode=as2&amp;creative=3132"">自制编程语言</a>：另一本优秀的编译原理作品，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00GAUNDYY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00GAUNDYY&amp;linkCode=as2&amp;creative=3132"">自制编程语言</a>通过从零开始制作一门无类型语言<code>Crowbar</code>和一门静态类型语言<code>Diksam</code>，把类型系统，垃圾回收，和代码生成等编程语言的关键概念讲的清清楚楚；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00PG0MM3C/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00PG0MM3C&amp;linkCode=as2&amp;creative=3132"">计算的本质：深入剖析程序和计算机</a>：披着Ruby外衣的<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Theory_of_computation"">计算理论</a>入门书籍，使你对编程语言的理解更上一层楼。</p></li>
</ul>
<h3><a>4. 程序设计</a></h3>

<p><a></a><a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/""><span class=""img-wrap""><img data-src=""http://i.imgur.com/ifN25u3.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""程序设计方法""></span></a></p>

<p>现代编程语言的语法大多很繁杂，初学者使用这些语言学习编程会导致花大量的时间在编程语言语法（诸如指针，引用和类型定义）而不是程序设计方法（诸如数据抽象和过程抽象）之上。<a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/"">程序设计方法</a>解决了这个问题——它专注于程序设计方法，使得读者无需把大量时间花在编程语言上。这本书还有一个与之配套的教学开发环境<a rel=""nofollow"" href=""http://plt-scheme.org/software/drscheme/"">DrScheme</a>，这个环境会根据读者的程度变换编程语言的深度，使得读者可以始终把注意力集中在程序设计方法上。</p>

<p>我个人很奇怪<a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/"">程序设计方法</a>这样的佳作为什么会绝版，而谭浩强C语言这样的垃圾却大行其道——好在是程序设计方法<a rel=""nofollow"" href=""http://www.ccs.neu.edu/home/matthias/HtDP2e/"">第二版</a>已经被免费发布在网上。</p>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/kZZWblP.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""计算机程序的构造与解释（第2版）""></span></a></p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;creative=3132"">计算机程序的构造与解释</a>是另一本被国内大学忽视（至少在我本科时很少有人知道这本书）的教材，这本书和<a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/"">程序设计方法</a>有很多共同点——都使用<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Scheme_(programming_language)"">Scheme</a>作为教学语言；都专注于程序设计方法而非编程语言本身；都拥有相当出色的课后题。相对于<a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/"">程序设计方法</a>，<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;creative=3132"">计算机程序的构造与解释</a>要更加深入程序设计的本质（过程抽象，数据抽象，以及元语言抽象），以至于Google技术总监<a rel=""nofollow"" href=""http://norvig.com/"">Peter Norvig</a>给了这本书<a rel=""nofollow"" href=""http://www.amazon.com/gp/review/R403HR4VL71K8/ref=cm_cr_pr_rvw_ttl?ie=UTF8&amp;ASIN=0262510871"">超高的评价</a>。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B006P7V73G&amp;linkCode=as2&amp;creative=3132"">编程原本</a>：<a rel=""nofollow"" href=""https://www.sgi.com/tech/stl/"">STL</a>作者的关于程序设计方法佳作——他把关系代数和群论引入编程之中，试图为程序设计提供一个坚实的理论基础，从而构建出更加稳固的软件。这本书是<a rel=""nofollow"" href=""http://book.douban.com/subject/1140942/"">程序设计方法</a>和<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B0011AP7RY&amp;linkCode=as2&amp;creative=3132"">计算机程序的构造与解释</a>的绝好补充——前者使用函数式语言（Scheme）讲授程序设计，而<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B006P7V73G&amp;linkCode=as2&amp;creative=3132"">编程原本</a>则使用命令式语言（C++）;</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00LPQ6KAW/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00LPQ6KAW&amp;linkCode=as2&amp;creative=3132"">元素模式</a>：<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B001130JN8&amp;linkCode=as2&amp;creative=3132"">设计模式</a>总结了<strong>面向对象程序设计</strong>中的模式，而<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00LPQ6KAW/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00LPQ6KAW&amp;linkCode=as2&amp;creative=3132"">元素模式</a>这本书分析了<strong>程序设计</strong>中的常见模式的本质，阅读这本书会让你对程序设计有更深的理解；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0387964800/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0387964800&amp;linkCode=as2&amp;creative=3132"">The Science of Programming</a>：会编程的人很多，但能够编写正确程序的人就少多了。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/0387964800/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=0387964800&amp;linkCode=as2&amp;creative=3132"">The Science of Programming</a>通过<strong>前条件——不变式——后条件</strong>以及逻辑谓词演算，为编写正确程序提供了强有力的理论基础，然后这本书通过实例阐述了如何应用这些理论到具体程序上。任何一个想大幅提高开发效率的程序员都应阅读此书。</p></li>
</ul>
<h3><a>5. 算法与数据结构</a></h3>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/vKnkD4B.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""算法（第4版）""></span></a></p>

<p>我在<a rel=""nofollow"" href=""http://lucida.me/blog/on-learning-algorithms/"">算法学习之路</a>一文中提到我的算法入门教材是<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B002WC7NGS&amp;linkCode=as2&amp;creative=3132"">数据结构与算法分析：C语言描述</a>，我曾经认为它是最好的算法入门教材，但自从我读到<a rel=""nofollow"" href=""http://www.cs.princeton.edu/~rs/"">Sedgewick</a>的<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;creative=3132"">算法</a>之后我就改变了观点——这本<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;creative=3132"">算法</a>才是最好的算法入门教材：</p>

<ul>
<li><p>使用更为容易的Java语言作为教学语言；</p></li>
<li><p>覆盖所有常用的数据结构和算法，并均给出其完整实现；</p></li>
<li><p>包含大量的图示用于可视化算法——事实上这是我读过的图示最为丰富形象的书籍，这也是我称其为最好的算法入门书籍的原因。</p></li>
</ul>
<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/uNnVH86.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""编程珠玑（第2版）""></span></a></p>

<p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;creative=3132"">编程珠玑（第2版）</a>是一本少见的实践型算法书籍——它并非一一介绍数据结构/算法的教材，而是实践性极强的算法应用手册。作者（<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Jon_Bentley"">Jon Bentley</a>）从他多年的实际经验精选出一些有趣而又实用的问题，然后展示了他解决这些问题的过程（分析问题，选择合适的算法，解决问题，以及验证答案）。任何程序员都可以从中获益。</p>

<p><strong>延伸阅读：</strong></p>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B004ZWBW5G/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B004ZWBW5G&amp;linkCode=as2&amp;creative=3132"">编程珠玑（续）</a>：严格来说这本书并非<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;creative=3132"">编程珠玑</a>的续作，而是一本类似于番外篇的编程技巧/实践手册；它不像<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;creative=3132"">编程珠玑</a>那般重视算法的应用，而是全面覆盖了程序员所需的能力；</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00AK7BYJY&amp;linkCode=as2&amp;creative=3132"">算法导论（第3版）</a>：尽管我在这边文章开头提到会尽量避免理论性的书籍，但没有<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00AK7BYJY&amp;linkCode=as2&amp;creative=3132"">算法导论</a>的算法阅读列表是不完整的，我想这本书就不需要我多介绍了； :-)</p></li>
<li><p><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00S4HCQUI/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00S4HCQUI&amp;linkCode=as2&amp;creative=3132"">算法设计与分析基础（第3版）</a>：侧重于算法设计，这本书创新的把常见算法分为分治，减治，变治三大类，并覆盖了动态规划，回溯，以及分支定界等高级算法设计方法，属于算法设计的入门佳作；</p></li>
</ul>
<h3><a>6. 程序调试</a></h3>

<p><a></a><a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00CBBLUFK/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00CBBLUFK&amp;linkCode=as2&amp;creative=3132""><span class=""img-wrap""><img data-src=""http://i.imgur.com/x4o6psE.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""调试九法——软硬件错误的排查之道""></span></a></p>

<p>一个让非编程从业人员惊讶的事实是程序员的绝大多时间都花在调试上，而不是写程序上，以至于<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Robert_Cecil_Martin"">Bob大叔</a>把<strong>调试时间占工作时间的比例</strong>作为衡量程序员开发能力的标准。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00CBBLUFK/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00CBBLUFK&amp;linkCode=as2&amp;creative=3132"">调试九法——软硬件错误的排查之道</a>既是调试领域的入门作品，也是必读经典之作。<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B00CBBLUFK/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;tag=lucida-23&amp;creativeASIN=B00CBBLUFK&amp;linkCode=as2&amp;creative=3132"">调试九法</a>的作者是一个具有丰富实战经验的硬件工程师，他把他多年的调试经验总结成九条调试法则，并对每一条法则都给对应的实际案例。任何程序员都应通过阅读这本书改善调试效率，即便是非程序员，也可以从这本书中学到系统解决问题的方
                ", 【干货】程序员必读书单（上）,1531978000,389,1,249,1,1,https://segmentfault.com/a/1190000002590273
105,1,0,9,"
                    
<p>我算是靠坑蒙拐骗进了程序员的门，然后一路狂奔。26岁之前几乎没有任何写代码的经验，研究生毕业却意外选择了一家不可能提供培训的初创公司，在每日担忧公司倒闭、害怕被炒鱿鱼以及同事冷落白眼的三重压力下逆流而上，一年半后离职，已是拥有500万用户产品的后台主程。从前我对计算机技术心怀畏惧，认定技术高人一定有佛光笼罩，昼夜不息运键如飞日吐代码上万行。现在也算见过一些世面了，回首那段忐忑不安宛如初夜的过程，我却不发觉有任何的励志意味，而是视为一种理所当然。理想的程序员，和理想的建筑师、理想的财务师、理想的按摩师没有任何的差别，他们本质上都是一群手艺人。我相信理想的程序员人人皆可成为。</p>

<p>近三年总在互联网圈厮混，我认识过一些程序员，共事过一些程序员，领导过一些程序员，又面试过一些程序员。他们学历不同，有的来自北大，有的来自北大青鸟，有的是博士，有的是高中肄业；资历也不同，有的来自BAT，有的来自某破产基金公司（还是一个销售）；年限也从0到15年不等。但我认为程序员只需分三类：天才的程序员、理想的程序员、平庸的程序员。天才的程序员我只敢说接触过3个，这是天命。7分由你是颗精子的时候就已决定，拥有绝佳的数学天赋、冷静致密的逻辑、为解决难题宁愿不眠不休而深以为乐的技术热情；3分来自起步要早早早，恨不得同龄人玩泥巴的时候就得开始玩电脑，大学毕业前就突破一万小时法则，后面的已是游戏人生。</p>

<p>天才的程序员可遇不可求，更不能长有，我看到的90%仍是平庸的程序员。IT时代的膨胀，已让程序员如同文艺复兴时的印刷匠一样的普通，多数投入祖师爷门下的人，仅是为了更大的饭碗，更高的待遇，更好的生计。平庸的程序员编写腐烂的代码，没有规范和一致性，固守旧世界的语言，还好谈论大的架构和性能，说的比做的漂亮。而毫无例外的，他们认定技术没有出路，做产品、营销和管理的是更高大上的手艺，而他们当中的99%，又会自然的流露出自己恰巧具备了那方面的天赋，至于进程为什么会崩溃这样的小问题是不屑于去了解的。</p>

<p>而我最喜欢和理想的程序员相处，恨不得与他们同吃同住，如果允许，我希望我的队伍能插满他们的旗帜。理想的程序员心眼儿不坏（他们从来都不是办公室政治的宠儿，是一群单纯明亮快乐的手艺人），有天真烂漫的好奇心（他们的眼睛里经常闪着「哇，这个是怎么做到的！」），永远精益求精（他们的口头禅是「我再研究一下」），还乐于分享（他们活跃于GitHub、各大问答社区和你的身边，舍得将宝贵时间用于帮助新手）。是的，他们不需要被管理，只需要给一个大的方向，总能回报以意想不到的结果。</p>

<p>理想的程序员与平庸的程序员只有一墙之隔。两者的差距只有6个一点点，而人与人的差距，正是在这日积月累的一点点中，被永远拉开了。有意思的是，我发现这6个一点点都和意识有关，也就是程序员和其他一切新兴产业的工种一样，只需要意识加上时间的锤炼，人人皆可达到理想的阶段。理想的程序员必然也是一个优秀的problem-solver。</p>

<h2>第1个一点点：专注眼下</h2>

<p>见过太多心猿意马的程序员，我不得不把「专注眼下」作为天字第一条。他们往往有各式各样的小梦想，比如做个小茶农、做个小鹅贩、做产品、做销售、做投资，却被程序员的高薪或是没有转行的魄力「耽误」了，而因为不专注，他们不在意做好自己的本分，不在意锤炼自己的技能，不在意学习新兴的技术。不可否认，这世界上存在着伟大的产品（像乔老爷）、伟大的销售（像埃里森）、伟大的投资客（像彼得菲），而他们毫无例外都是程序员出身。可你听说过巴菲特评价盖茨的话么，比尔盖茨如果转行去卖狗，那他一定是全世界最大的狗贩。我坚信除了少数的天才外，冥冥众生均可以在多个领域取得成功，只要保持足够的专注。而哪怕你下一年就想卖狗去，程序员的经验仍然能训练你强大的逻辑、谨慎和耐心，放在哪个行业都是相当可观的竞争力。</p>

<h2>第2个一点点：思考力与推动力</h2>

<p>我认为处理bug、崩溃、调优、入侵等突发事件比编程本身更能体现平庸程序员与理想程序员的差距。当面对一个未知的问题时，如何定位复杂条件下的核心问题、如何抽丝剥茧地分析问题的潜在原因、如何排除干扰还原一个最小的可验证场景、如何抓住关键数据验证自己的猜测与实验，都是体现程序员思考力的最好场景。是的，在衡量理想程序员的标准上，思考力比经验更加重要。</p>

<p>有时候小伙伴跑过来，问我「提交了一个任务被卡住了，怎么办」的时候，我总觉得他可以做得更好。比如，可以检查试验别的任务，以排除代码自身的原因；可以通过Web UI检查异常（如果没有账号，可以让我提供）；可以排查主机日志或删除缓存，再不济，总应该提供任务ID和控制台日志给我。理想的程序员永远不会等事情前进，他们会用尽一切方法让事情前进。</p>

<h2>第3个一点点：Never Say No</h2>

<p>记得从前厂离职之前，找老板谈话，他说我最大的优点就是从来不和他说这个做不到。后来我发现在很多团队里，都存在一种技术和产品的对立，程序员往往以「技术上无法实现」来挡产品的需求，而产品也往往以「Facebook可以为什么我们做不到」来奚落程序员。这两句话应该属于禁语，从根本上都不利于程序猿和产品狗的相亲相爱。</p>

<p>一句「技术上无法实现」是容易出口，可有多少人在说出这句话的时候，心里是100%肯定的？如果不肯定，为什么不能回去谷歌一下再回答？原本我以为程序员是充满想象力，在因为有想象力，才能诞生那么多改变我们生活的软件和互联网产品。见识多了，才了解大部分程序员已经在与bug的对抗中变得保守而不愿担当风险，与此同时许多团队也不愿意宽容失败。于是「Say No」变成一种习惯性的抵触，还记得曾国藩为什么解散湘军么？他说那支军队已「暮气渐深」，不能打仗了。要做理想的程序员，就不能给自己滋生暮气的机会，如果面对不合理的需求，可以把时间成本摆出来，把曲线救国方案亮出来，简单粗暴「Say No」是不可取的。</p>

<h2>第4个一点点：投资未来</h2>

<p>程序员是一个非常残忍的职业。你所学所用的语言、框架、模式，很可能在数年内就成昨日黄花了；你现在嘲笑的另一群程序员，可能马上就能转身来嘲笑你了。所以理想的程序员除了做好自己的本分，还要花费时间来投资未来。什么是「投资」？投资就是你现在投入的时间，在未来会以更多的时间或者金钱（看看早几年学习iOS的程序员现在的薪酬！）回报你。举我自己的领域 -- 数据挖掘为例，08年左右Hadoop开始兴起，一时「大数据」概念火热，Hadoop工程师万金难求，各互联网公司纷纷把数据统计、数据分析和数据挖掘的业务切换到分布式平台上。这几年眼看Hadoop还在不断迭代，Spark又异军突起，一举刷新了Hadoop保持的排序记录，以内存存储中间数据带来的性能优势和丰富的数据结构让人爱个不停，各种奇异的小bug和陡峭的学习曲线又让人打退堂鼓。那么，明眼人都知道Spark是未来的趋势（内存会越来越便宜），在主业务放在Hadoop的条件下，就可以适当把一些小模块切换到Spark上，同时留意Spark社区的发展。很快从Spark获得的性能收益就能把之前投入的学习时间挣回来。</p>

<h2>第5个一点点：善用工具</h2>

<p>善用工具可以分为4个层面：</p>

<ul>
<li>搜索引擎</li>
<li>不相信重复</li>
<li>代码片段</li>
<li>自动化</li>
</ul>
<p>我刚入行那会，一个计算机专业却当了公务员的朋友问我，你一点都没学过编程，平时怎么写代码？我说，谷歌，于是遭到无情的耻笑，以至于我在哪里的账号都叫2shou，告诫自己是一个无耻的二手程序员。这是一个笑话，但如果现在问我，我还是要回答谷歌。程序员的成长就像膨胀的圆饼，外面是无边无际的大海，圆饼越大，与大海接触的面也越大，懂的越多，不懂的越多，而计算机科学又是一门更新换代异常迅速的学科，同时也是知识互联网化最好的学科，很难利用传统的科班式有教有学的方法，相反通过搜索引擎则很容易获取到最新的知识。</p>

<p>不相信重复，大师的话叫DRY原则（Dont repeat yourself），代码写多了，会有人为的直觉判断好的和烂的代码，我的标准是简洁和规范，简洁并不是美感上的标准，重复越少，给自己出错的机会也越少，后期维护的成本也越少。</p>

<p>如果你不幸丢了三周前的代码，也许你能凭着过人的记忆力把脑子里残余的片段复写出来，但如果丢的是三个月前的代码，恐怕就没有那么好的运气了。理想的程序员会着力找寻有效的资料保存方式，把工作里灵光闪现写下的代码、脚本、配置、经验等短的片段保存起来，以便任何时候都能复查。</p>

<p>理想的程序员必须懒惰。对他们来说，重复的步骤和重复的代码一样丑陋，如果意识到一项工作有可能长期要重复，那么自动化的时间总是越早越好。</p>

<h2>第6个一点点：管理时间</h2>

<p>之所以管理时间会对程序员这个行当特别重要，是因为在完成任务时你必须像荒野里的狼一样，「独行」。没有外界约束的情况下还能稳定控制自己，保证能高效率地工作和学习，那么日积月累你肯定会变得比一般人厉害。</p>

<p>程序员干的是高强度的脑力活，一般每天集中4-5个小时应对本职工作就足够了，但工作之外，一定要安排时间用于学习。除了学习，留点时间放空自己也是必要的，利用泡茶或者喝咖啡的间隙，把弥足珍贵的时间留给自己，往前想往后想，事半功倍。</p>

<p>说了这么多，想必有人会问，费劲心思成为一个理想的程序员，又有什么用处？会有高薪吗？不。能升职吗？也不见得。迎娶白富美呢？不如去卖狗。<br>
稻盛和夫曾经说过一个故事，明治时期的手艺人被天皇召见，虽然都是不读书的乡下人，但一辈子兢兢业业地做一件事情，自然有一股高贵的气质。理想的程序员，应该就是循着这种高贵的气质而去的吧。</p>

<blockquote>
  <p>来自：<a rel=""nofollow"" href=""http://guoze.me"">建造者说</a></p>
</blockquote>

                ", 理想的程序员,1531978002,471,1,733,1,1,https://segmentfault.com/a/1190000002572882
106,1,0,9,"
                    
<p>一起来回顾一下 Tuts+ 网站2014年最受欢迎的前50的篇技术文章。这些文章内容丰富，你可以选择感兴趣的文章进行学习。希望读者们不仅选择自己已知领域的内容，也多去探索未知领域的知识。</p>

<ol>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/using-the-accelerometer-on-android--mobile-22125"">Using the Accelerometer on Android</a> 【在Android上使用Accelerometer 】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/authenticating-nodejs-applications-with-passport--cms-21619"">Authenticating Node.js Applications With Passport</a> 【使用Passport验证Node.js应用】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/ios-8-beta-testing-with-testflight--cms-22224"">iOS 8: Beta Testing with TestFlight</a> 【iOS 8：用TestFlight进行Beta测试】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/setting-up-push-notifications-on-ios--cms-21925"">Setting Up Push Notifications on iOS</a> 【iOS的消息推送设置】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/build-a-custom-launcher-on-android--cms-21358"">Build A Custom Launcher on Android</a> 【自定义Android Launcher】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/create-a-music-player-on-android-project-setup--mobile-22764"">Create a Music Player on Android: Project Setup</a> 【编写Android音乐播放器：准备篇】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/core-data-from-scratch-core-data-stack--cms-20926"">Core Data from Scratch: Core Data Stack</a> 【Scratch的Core Data框架】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/adding-blur-effects-on-ios--cms-21488"">Adding Blur Effects on iOS</a> 【在iOS中添加模糊效果】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/setting-up-continuous-integration-continuous-deployment-with-jenkins--cms-21511"">Setting Up Continuous Integration &amp; Continuous Deployment With Jenkins</a> 【用Jenkins建立持续集成与持续部署】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/creating-a-custom-wordpress-registration-form-plugin--cms-20968"">Creating a Custom WordPress Registration Form Plugin</a> 【创建自定义 WordPress 注册表单插件】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/getting-started-with-android-studio--mobile-22958"">Getting Started with Android Studio</a> 【初学Android Studio】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/magento-custom-module-development--cms-20643"">Magento Custom Module Development</a> 【Magento自定义模块化开发】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/angularjs-and-laravel-finishing-building-a-crm--cms-22234"">AngularJS and Laravel: Finishing Building a CRM</a> 【AngularJS 和 Laravel：创建CRM（完结篇）】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/create-a-weather-app-on-android--cms-21587"">Create a Weather App on Android</a> 【在Android上编写一个天气应用】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/10-alternative-android-app-stores--cms-20999"">10 Alternative Android App Stores</a> 【10个Android应用商城推荐】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/streaming-video-in-android-apps--cms-19888"">Streaming Video in Android Apps</a> 【在Android 应用里插入视频】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/angularjs-and-laravel-begin-building-a-crm--net-36444"">AngularJS and Laravel: Begin Building a CRM</a> 【AngularJS 和 Laravel：创建CRM（开始篇）】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/testing-in-nodejs--net-35018"">Testing in Node.js</a> 【Node.js的测试】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/check-out-atom-githubs-new-development-editor--net-37030"">Check Out Atom, GitHub's New Development Editor</a> 【初探GitHub's编辑器Atom】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/managing-your-build-tasks-with-gulpjs--net-36910"">Managing Your Build Tasks With Gulp.js</a> 【用Gulp.js管理你的构建任务】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/introduction-to-the-mean-stack--cms-19918"">Introduction to the MEAN Stack</a> 【MEAN Stack的简绍】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/using-polymer-to-create-web-components--cms-20475"">Using Polymer to Create Web Components</a> 【使用Polymer编写web控件】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/chrome-devtools-features-you-may-have-missed--cms-20850"">Chrome DevTools Features You May Have Missed</a> 【你可能不知道的Chrome DevTools的特性】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/phpstorm-when-the-ide-really-matters--cms-20787"">PhpStorm: When the IDE Really Matters</a> 【PhpStorm： IDE的重要性】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/introduction-to-android-design-patterns--cms-20808"">Introduction to Android Design Patterns</a> 【初探Android Design Patterns】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/dont-forget-to-cover-your-client-side--cms-21021"">Don't Forget to Cover Your Client Side!</a> 【别忘了隐蔽你的客户端】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/resources-for-staying-on-top-of-javascript--cms-21369"">Resources for Staying on Top of JavaScript</a> 【高级JavaScript开发的学习资源】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/single-page-todo-application-with-backbonejs--cms-21417"">Single Page ToDo Application With Backbone.js</a> 【利用Backbone.js开发单页面的ToDo应用】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/recreating-the-touch-ripple-effect-as-seen-on-google-design--cms-21655"">Recreating the Touch Ripple Effect as Seen on Google Design</a> 【实现Google的点击出现波纹的效果】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/how-to-create-your-own-html-elements-with-web-components--cms-21524"">How to Create Your Own HTML Elements With Web Components</a> 【创建自定义的HTML元素】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/7-non-raster-approaches-for-making-the-hamburger-menu-icon--cms-21686"">7 Non-raster Approaches for Making the “Hamburger” Menu Icon</a> 【7种不用图片制作“Hamburger”导航图标的办法】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/setting-up-user-authentication-in-laravel-using-confide--cms-21866"">Setting Up User Authentication in Laravel Using Confide</a> 【使用Laravel Confide进行用户验证】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/php-56-whats-new--cms-22101"">PHP 5.6: What's New</a> 【PHP 5.6 新特性】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/how-to-give-your-logo-the-slip-scroll-effect--cms-22274"">How to Give Your Logo the “Slip Scroll” Effect</a> 【给logo添加“Slip Scroll”特效】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/building-an-instagram-based-portfolio-with-bootstrap--cms-22243"">Building an Instagram Based Portfolio With Bootstrap</a> 【用Bootstrap构建基于Portfolio的Instagram】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/programming-with-yii2-getting-started--cms-22440"">Programming with Yii2: Getting Started</a> 【Yii2编程学习：开始篇】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/7-css-units-you-might-not-know-about--cms-22573"">7 CSS Units You Might Not Know About</a> 【7个你可能不知道CSS单位】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/useful-shortcuts-for-a-faster-workflow-in-sublime-text-3--cms-22185"">Useful Shortcuts for a Faster Workflow in Sublime Text 3</a> 【提高工作效率的Sublime Text 3快捷键】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/create-a-custom-keyboard-on-android--cms-22615"">Create A Custom Keyboard on Android</a> 【创建自定义Android键盘】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/focusing-on-a-team-workflow-with-git--cms-22514"">Focusing on a Team Workflow With Git</a> 【专注于团队协作的Git】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/introduction-to-html5-desktop-apps-with-node-webkit--net-36296"">Introduction to HTML5 Desktop Apps With Node-Webkit</a> 【初探Node-Webkit构建HTML5桌面应用】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/create-a-music-player-on-android-song-playback--mobile-22778"">Create a Music Player on Android: Song Playback</a> 【构建Android音乐播放器：Song Playback】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600"">SOLID: Part 2 - The Open/Closed Principle</a> 【SOLID：第二章 —— 打开/关闭的原理】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/working-with-less-and-the-chrome-devtools--net-36636"">Working With LESS and the Chrome DevTools</a> 【LESS和Chrome DevTools的使用】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/networking-with-nsurlsession-part-1--mobile-21394"">Networking with NSURLSession: Part 1</a> 【NSURLSession建立网络通信：第一章】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/better-responsive-images-with-the-picture-element--net-36583"">Better Responsive Images With the picture Element</a> 【使用picture元素完善响应式图片】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/javascript-animation-that-works-part-1-of-4--net-35205"">JavaScript Animation That Works (Part 1 of 4)</a> 【JavaScript动画（第一章）】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/articles/an-introduction-to-theming-woocommerce-for-wordpress--wp-31577"">An Introduction to Theming WooCommerce for WordPress</a> 【WordPress主题WooCommerce的介绍】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/using-createjs-easeljs--net-34840"">Using CreateJS - EaselJS</a> 【CreateJS的使用 - EaselJS】</li>
<li>
<a rel=""nofollow"" href=""https://tutorials.tutsplus.com/tutorials/beginners-guide-to-the-django-rest-framework--cms-19786"">Beginner's Guide to the Django Rest Framework</a>  【Django Rest框架初学教程】</li>
</ol>
<blockquote>
  <p>编者注：<br>
  欢迎广大 SFers 在评论中选出你感兴趣的文章，我们将选择部分文章进行翻译。<br>
  我们将对翻译好的文章在此文中进行更新，大家可以通过收藏文章的方式获得最新的翻译信息。<br>
  上面文章涉及范围很广，希望能集思广益，欢迎各领域的爱好者把自己翻译好的文章链接粘贴到评论中，我们将把您的译文链接更新到此文，供大家学习交流。非常感谢您的奉献~</p>
</blockquote>

<p>原文：<a rel=""nofollow"" href=""http://code.tutsplus.com/articles/the-top-50-code-posts-of-2014--cms-22897"">The Top 50 Code Posts of 2014</a></p>

                ", 推荐——Tuts+ 2014年前50的技术文章,1531978003,300,1,224,1,1,https://segmentfault.com/a/1190000002501824
107,1,0,9,"
                    
<p>收藏自<a rel=""nofollow"" href=""http://www.w2bc.com/Article/16758"">成为优秀高级程序员的10个要点</a></p>

<h2>What</h2>

<p>软件工程师的职业生涯要历经以下几个阶段：初级、中级，最后才是高级。这篇文章主要是讲如何通过10个步骤助你成为一名高级软件工程师。</p>

<h2>Why</h2>

<p>得到更多的报酬！因为你的薪水会随着你水平的提高而增加</p>

<p>提升你的职业生涯。成为了高级软件工程师之后，就可以朝着架构师、团队负责人、CTO等职位前进</p>

<p>历经更大的挑战。随着你的成长，各种影响力也会提高。</p>

<h2>How</h2>

<p>软件工程是很难的。这一行业在不断变化中，所以你必须紧跟它的步伐。你必须不断地投入时间和精力，因为你需要学习的东西总是比你能吸收的多。很多新手工程师甚至都不曾意识到他们如果想要攀登行业的高峰，要学习的东西、要付出的努力得有多少。不过，不用担心，下面我将指出一条“明路”有助于你成为一名高级软件工程师。</p>

<h2>步骤0：选择你的道路，坚持下去！</h2>

<blockquote>
  <p>做一件事，就要把它做好。——Doug McIlroy《Unix Philosophy》</p>
</blockquote>

<p>关于这一点，我真的是强调得不能再强调了。选择好你将与之并肩作战的专业和技术堆栈非常重要。坚持不懈，不要分心。至于应该怎么做请看下面：</p>

<ul>
<li>选择专业。也就是你想做的事情。例如：Web开发、移动开发、DevOps等。</li>
<li>选择专业中的实用技术。例如：如果你选择了Web开发，那你就需要在Ruby on Rails、Python、Django，JavaScript和MEAN等之间做斟酌。如果你选择的是移动开发，则需要在iOS和Android等之间做出选择。</li>
</ul>
<p>坚持下去，直到掌握这门技术。</p>

<p>我的意思并不是说除了你的主要专业以外，你就不必熟悉其他的了。那种首屈一指的软件工程师通常对其他的编程语言和技术都非常了解，当然首先他们对他们自己的主要专业了解得非常剔透。当你确定好主要专业之后，接下来要做的就是学习，阅读所有相关的书籍、练习各种必要的技能，这可能需要很多年的时间。但是千万不要气馁，一步一个脚印，一个一个攻克难关，量变才能达到质变。关于技术，我的推荐是：Ruby on Rails之于web开发，iOS之于移动开发。这是我是以一个过来人的身份告诉你的宝贵经验。不过我还是想补充一句，可能每个人的口味不同，我的经验也许并不适合你，你完全可以选择其他的技术，不过这样的话，你要阅读的书籍可能就和我的推荐不一样了。</p>

<h2>步骤1：奠定基础</h2>

<p>《The Pragmatic Programmer 》对于我们掌握软件是一个很好的起点。该书总结了高水平的实践探索。这与我们使用的是什么语言/技术无关。无论你选择的是哪种技术堆栈，其主要原理都是一样的。</p>

<h2>步骤2：掌握你的编程语言</h2>

<p>你以后每天需要面对哪种编程语言取决于你今天选择的技术。但是编程语言总有主次之分。例如，Ruby on Rails开发人员主要使用Ruby，AngularJS开发人员大多数时间用的是JavaScript。确定编程语言、掌握编程语言对你的职业生涯发展至关重要。因为以后你每天都会使用它！推荐你先阅读有关书籍。</p>

<p>《The Swift Programming Language》之于Ruby开发人员，以及《Programming Ruby 》之于iOS开发人员。</p>

<h2>步骤3：学习框架</h2>

<p>选一个，然后好好学习：</p>

<ul>
<li>对于Rails开发人员——《Rails Tutorial 》by Michael Hartl</li>
<li>对于iOS开发人员——《iOS programming: The Big Nerd Ranch Guide》</li>
</ul>
<h2>步骤4：掌握文本编辑器/ IDE</h2>

<p>再选一个，然后坚持不懈地掌握这个工具。如果你选择的是VIM，那就要成为它的主人，让它往东就往东。</p>

<h2>步骤5：使用版本控制系统</h2>

<p>我建议使用Git。下面是我喜欢的资源：Pro git——免费的在线电子书，详细讲解了git的各个方面。</p>

<h2>步骤6：做好测试驱动开发</h2>

<p>将TDD添加到你的技术堆栈中。养成每天TDD的习惯。高质量的代码源于良好的测试。<br>
对于Ruby on Rails开发人员——《Rails Test Prescriptions》<br>
对于iOS开发人员——《Test Driven iOS Development》</p>

<h2>步骤7：将重构养成习惯</h2>

<p>随着你不断添加更多的功能，代码库也会越来越复杂。为了保持代码库的可管理化，你需要重构。如果你不重构的话，你很快就会进入两难境地——即使是做很小的改动都很困难、bug没法避免、没有人愿意处理这个凌乱的代码库。重构能让你的工作更加轻松。事不宜迟，赶快养成重构的习惯吧。下面这本好书能教你该怎么做：《Refactoring: Improving the Design of Existing Code》by Martin Fowler</p>

<h2>步骤8：学习软件架构</h2>

<p>根据你上面选择的堆栈，再学习相关的架构。我推荐Martin Fowler写的《Patterns of Enterprise Application Architecture》一书。</p>

<h2>步骤9：展示命令行的力量</h2>

<p>刚开始接触命令行的第一感觉就是望而生畏。但是，一旦你学会如何使用，这将大大提高你执行一些基本任务的效率。而这本身就能让你成为一名更好的开发人员，因为你能在更短的时间里实现目标。然后你就能进入下一个水平。使用shell自动执行常见任务，建立自己的dotfiles。如果你使用的mac或者Linux发行版，那么学会shell。下面这本书由Mark Bates所写的书挺不错:《Conquering the Command Line》</p>

<h2>步骤10：code code code！</h2>

<p>只有不断地练习学到的知识，你才能真正掌握它。</p>

<h2>总结</h2>

<p>众所周知，成为一名高级软件工程师是非常难的。这需要大量的时间和精力。不同的人他们的学习速度也不尽相同，但是平均来说，大约需要10年时间才能成为一名可靠的高级开发人员。你付出的各种投资最后必将给你带来巨大的回报。软件工程师的钱途很美好，其就业市场的需求一直居高不下，薪资水平也根据经验程度在提高。这是一个快速增长且相对较新的领域。软件工程师的每一天都在面临挑战：挑战改变人们的生活。来吧，各位软件工程师，首先挑战成为一名高级软件工程师吧！</p>

                ", 成为优秀高级程序员的10个要点,1531978004,271,1,675,1,1,https://segmentfault.com/a/1190000002483864
108,1,0,9,"
                    
<p>转<a rel=""nofollow"" href=""http://yafeilee.me/blogs/54995f3a6c69342f6d100000"">李亚飞 2014年WEB高手都在做什么</a></p>

<p><span class=""img-wrap""><img data-src=""/img/bVkAhp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<h2>写在前面的话</h2>

<p>今年, 对于我, 从技术上说, 还是有不少的进步的. 进步的主要是在于前端开发, 所以, 想从后端工程师的身份对前端的发展做一些总结.</p>

<p>在我前几年的印象中, 前端工程师一直是一个很不独立, 也不高端的职位. 因为他们就是来写 Javascript 的.</p>

<p>往上要跟 UI 设计师要设计图, 被他们欺负, 往下与老牌的后端工程师要接口, 后端工程师往往作为架构师存在, 只能更被期负, 由于自己的领域只是关乎用户体验, 与功能无关, 又 Javascript 作为一门语言设计的仓促, 有很多缺陷, 所以很难过.</p>

<p>随着 Javascript 的发展, 前端用户体验要求越来越高, 前端俨然迎来了春天.</p>

<p>据业内报道, 前端工程师薪水也完全可以媲美甚至越过后端工程师. 我们来看看前端是怎么从一个简单的脚本小子蜕变成高上大的工程师的.</p>

<p>一切的蜕变从 v8 的产物之一: nodejs 开始.</p>

<h2>GruntJS</h2>

<p>首先, 迎入眼帘必然是 GruntJS, 这是一个类似于 make(C), ant(JAVA), rake(Ruby) 的构建/执行环境, 它本身并没有伟大的地方, 但伟大的是它的生态环境.</p>

<p>随着 GruntJS 的成熟, 越来越多的组件被加入 GruntJS 的阵营:</p>

<ul>
<li>CSS 压缩</li>
<li>精简, 打包 Javascript</li>
<li>图片压缩, 合并</li>
<li>Sass, less 处理</li>
<li>Coffeescript 处理</li>
<li>发布前端应用</li>
</ul>
<p>看得出, 这已经是一个完整的生态系统, 不需要像从前那样后端的帮助, 前端完全有自己的工作流程了.</p>

<p>与 GruntJS 类似的一个产物叫 GulpJS, 它采用管道技术来优化与改进 GruntJS 的不足, 发展很快, 大有赶超的趋势.</p>

<h2>Yeoman</h2>

<p>GruntJS 之后, 必然缺乏一个前端工作流程事实的标准, 这就是 Yeoman. Yeoman 是一个由 30 多人的团队开发维护的脚手架项目, 通过它, 我们不要需要研究 GruntJS 里面的各种插件. 只需要跟随 Yeoman, 跟着它, 便能找到光明: 十倍百倍地超越一般程序员.</p>

<p>例如, 我输入</p>

<pre><code>yo angular
`&lt;/pre&gt;

就可以创建

&lt;pre class=""highlight shell""&gt;`.
|-- Gruntfile.js
|-- app
|   |-- 404.html
|   |-- favicon.ico
|   |-- images
|   |-- index.html
|   |-- robots.txt
|   |-- scripts
|   |-- styles
|   &lt;span class=""sb""&gt;`&lt;/span&gt;-- views
|-- bower.json
|-- bower_components
|   |-- angular
|   |-- bootstrap-sass-official
|   |-- es5-shim
|   |-- jquery
|   &lt;span class=""sb""&gt;`&lt;/span&gt;-- json3
|-- node_modules
|   |-- grunt-autoprefixer
|   |-- grunt-usemin
|   |-- grunt-wiredep
|   |-- jasmine-core
|   |-- jshint-stylish
|   &lt;span class=""sb""&gt;`&lt;/span&gt;-- karma
|-- npm-debug.log
|-- package.json
&lt;span class=""sb""&gt;`&lt;/span&gt;-- &lt;span class=""nb""&gt;test&lt;/span&gt;
    |-- karma.conf.js
    &lt;span class=""sb""&gt;`&lt;/span&gt;-- spec
</code></pre>

<p>都不用管 <code>bootstrap</code>, <code>angularjs</code> 从哪里来, 一个项目已经启动了.</p>

<p>扔掉 <code>Rails</code>, 开启前端开发之旅.</p>

<h2>Bower</h2>

<p>说到 <code>Yeoman</code>, 不能忘了它背后的 ""男人"", 这就是 <code>Bower</code>, 类似于 Ruby 圈子的 <code>bundler</code>,</p>

<p>正是因为它, <code>Yeoman</code> 才会方便做到自动帮你管理 <code>bootstrap</code>, <code>angularjs</code>, 无须让你操心用哪个版本, 如果愿意, 它会帮你更新, 当然也可以帮你锁定版本.</p>

<h2>Angular</h2>

<p>项目基础的框架能让你开发的流程十分顺畅, 就像我在办公室里面, 用着 27 寸 imac 一样带感, 而你只用着 3 年前的配置, IT 部还告诉你, 2G 内存完全够用了.</p>

<p>但是, 真正让高手与菜鸟产生差距的还在于内功: 前端JS框架, 如 Angular, Ember, Backbone 以及小而美的 React.</p>

<p>我们先来说说 Google 出品的 Angular, 也是我最熟悉的前端框架.</p>

<p>首先, 它出手极快. 相信你去看过它的官方主页, 就可以体会到, 什么叫快速开发.</p>

<p>其次, 它非常现代化. 不管你信与信, HTML 标准已经落后时代好多年了, 单单从 HTML 的组件化能力上看, 几乎没有. 而 Angular, 从内在改进了它. 通过编译原理, 标记扩展, digest 处理等技术手段, 让你可以写出极为优雅的逻辑代码. 并且前端测试, 在它这里易如反掌.</p>

<p>最后, 最为全面. 它拥有自己的路由系统, Model, Controller, View, Template, 一个不少. 极为方便的开发体验.</p>

<p>并且, Angular 2.0 也在日程, 将会一消第一版的历史问题, 带来更为清晰现代的设计.</p>

<h2>Backbone &amp; Ember &amp; React</h2>

<p>之所以把 Angular 单独一篇, 是我最看好它, 无论是设计, 还是技术, 还是生态, 皆有巨大优势. 不过, 大而全, 不一定全是优点, 我们先来看看 Backbone.</p>

<p>Backbone 其实是一个十分久远的前端框架, 或者说, 在 Angular 之前, 它是事实的标准. 而且在很多重前端的项目中, 都应用很不错. 随着时间的推进, 小而美( 核心只有 1000 多行 )不太适合普通开发者使用, 重复开发的轮子太多, 人们开们转向 Angular 与 Ember 了.</p>

<p>而 Ember 是一个真正的 MVC 前端框架, 其思路借鉴了后端的 MVC 思想, 相比于 Angular, 它也很全面, 很好, 与 Angular 与众不同.</p>

<p>它的背后, 也站着许多坚定的支持者, 因为它确实值得你去一试.</p>

<p>而且, <code>Ember-CLI</code> 这样一个像 <code>Rails</code> 一样酷的框 架的出现, 也大大激励了整个社区的前进.</p>

<p>如果说, Angular, Backbone, Ember 都是为解决前端问题而生的全能型武器. 那 React 就是一个锋利的匕首, 你可以同时携带一个主武器和一个匕首, 是吧?</p>

<p>这个 ""匕首"", 是由 Facebook 发起的开源项目, 它利用虚拟 DOM 生成技术, 极为巧妙地避开了一般前端框架都会遇到的一个问题: DOM节点处理的性能问题. 并且, 通过特有的虚拟 DOM, 可以很好的封装自己的组件, 让一个组件像后端的一个函数一样, 有输入与输出. 在庞大的前端项目中, 有了它, 就可以游刃有余地重用代码.</p>

<p>说完前端框架, 不得不提的就是 CSS 框架了. 缺了 CSS, 我们的生活哪有色彩.</p>

<h2>Bootstrap 与 Fondation</h2>

<p>如果你是我的忠实读者(虽然不多), 还是技术爱好者, 应该就知道我之前翻译了一篇它俩的比较一文: <a rel=""nofollow"" href=""http://yafeilee.me/blogs/52f83eb915638851a3000006""></a><a rel=""nofollow"" href=""http://yafeilee.me/blogs/52f83eb915638851a3000006"">http://yafeilee.me/blogs/52f83eb915638851a3000006</a>, 通过这一年的观察, 这两个都是非常酷的 CSS 框架, 如果你不是一个 CSS 的顶级高手, 择其一而用之, 你会发现, 做一个漂亮的页面, 也没那么复杂嘛.</p>

<p>相比之下, 我更喜欢 Foundation, 如果你都用过, 相信会理解我的意思.</p>

<h2>Sass, Less</h2>

<p>除了 HTML 与 JS, CSS 也不断在发展, 因为 CSS 没有像 Javascript 那样强大的扩展性, 所以我们只能去做他的预编译技术:</p>

<p>Sass, Less 这两个项目正是为此而生, 有了它们, CSS 里面也可以用变量, 可以写函数, 可以复用代码了.</p>

<p>这个方向, 正是为写大型复杂的前端项目应运而生.</p>

<p>值得一提的是, 有人写了一个 Stylus, 可以采用缩进的方式写 CSS, 而且语法与 Sass, Less 非常相近.</p>

<h2>总结</h2>

<p>WEB高手之所以为高手, 是他的学习能力, 是他的创造力, 是他愿于突破自己的舒适区. 不断改进手上的技术, 不断提高水平.</p>

<p>而前端领域, 也像后端一样庞大的社区了, 那么, 后端还需要像 Rails 那样大而全的框架吗? 也许只需要一个 API 接口就可以了.</p>

<p>这个 API 接口, 目前看不是 nodejs, 也不是 Rails, 不是 Grape, 那会是什么呢?</p>

<p>我们拭目一待.</p>

<p>ps: 原作者的微信公众号: 技术达人李亚飞</p>

                ", 2014年WEB高手都在做什么,1531978006,184,1,304,1,1,https://segmentfault.com/a/1190000002483686
109,1,0,9,"
                    
<p><a rel=""nofollow"" href=""http://knewone.com/entries/54a3a39a31302d01bd3d0100"">KnewOne 原文</a></p>

<p>赵戈戈拥有很多重身份，是瀑布 Pubu.im 和一起播 Each.fm 创始人、StaticFile 维护者、iNews 开发者、还是 Pagon 作者，自称是“一个有产品癖好又不随便掉节操的互联网土鳖”。他的 LinkedIn 每天一堆猎头加，由于正在艰苦创业因此只能忽略，不堪其扰的在微博大喊“勿扰！！！”</p>

<h2>自我介绍？</h2>

<p>Hi，我是 hfcorriez，微博 ID 也是 <a rel=""nofollow"" href=""http://weibo.com/u/1642295360?topnav=1&amp;wvr=6&amp;topsug=1"">@hfcorriez</a> 。因为名字比较占便宜，大家都叫我哥哥、赵戈戈，85 后，目前正在创业做团队办公方面。项目正在内测中，对于团队办公方面感兴趣的可以 <a rel=""nofollow"">pubu.im</a> 上提交内测申请。<br><span class=""img-wrap""><img data-src=""/img/bVkwuL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ea10d3844e53cd91e5b2146eb3569576.png""></span></p>

<p>我接触电脑很早，小学熟练用五笔，不过现在已经基本不会了；初一就跟电脑老师比打字速度来获得电脑教室玩游戏的机会，高中打了一年游戏就完全失去兴趣；步入码农行业，从此一发不可收拾……高中、大学期间都当过个人站长、做过各种论坛插件、写个留言本什么的，那时候 ASP 还很火。大二后开始搞 PHP，毕业后在 PPTV 做了 4 年的 PHP 和网站架构。如果不包含设计的话我也算一个全栈工程师~工作期间喜欢研究新技术和工具，由于受不了团队工具都做的那么难用，所以有出来创业的想法。我们的产品，最起码也是一个有态度的产品。</p>

<h2>工作装备？</h2>

<p>我不属于非常 Geek 的人，没有用机械键盘，但是体验不好的东西我一定不会用。我目前用苹果的蓝牙键盘，但是打字速度很少有人可以比得过我。<br><span class=""img-wrap""><img data-src=""/img/bVkwuN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""976d24b4d6e1761ed4e9085f252dc94a.jpg""></span><br>
我是那种经常把各种 IDE 或者工具打字到 Crash 的人。</p>

<p>工作时候用的 13 寸 Macbook Pro Retina 对我已经够了，带着不重；在家接 DELL P2714H 的显示器做开发，除了不能 Retina，亮度和显示效果都还可以接受。我工作时候属于非常沉浸的那种，很少起身。工作了了 4、5 年觉得自己身体已经大不如前了，果断在 KnewOne 团购了 Herman Miller 椅子。从此感到人生是多么的精彩，坐一天身体也不会很累了。<br><span class=""img-wrap""><img data-src=""/img/bVkwu3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""0c526f6a60381dfb53fd79423bd68152.jpg""></span></p>

<p>对于很多码农来说，咖啡是挚爱，我自从有了 De'Longhi EC330S 咖啡机就欲罢不能，几乎每天都要自己做一杯拿铁。我现在已经可以简单的拉花了，自己做的咖啡绝对比星巴克要好喝。<br><span class=""img-wrap""><img data-src=""/img/bVkwu5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""3115dec24510ad95457e01fe6d3e3815.jpg""></span></p>

<p>我对于各种硬件还是挺感兴趣的，所以 YeeLight 刚出的时候，试了试感觉，玩起来还是蛮有意思的，但是玩玩就好了，现在插在我的台灯上，基本也是用白光。<br><span class=""img-wrap""><img data-src=""/img/bVkwvh"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""eb56c533823f693a0a6291e509bf2d78.jpg""></span></p>

<p>我的电子设备很多，所以充电是个痛点，朋友送了 Anker 36W 4USB 充电器，觉得用起来很不错。<br><span class=""img-wrap""><img data-src=""/img/bVkwvi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""152a5bd7b78f48c472796ef768e7e1fe.jpg""></span></p>

<p>这些基本就是我的所有办公设备了。</p>

<h2>兴趣爱好？</h2>

<p>我的兴趣不算很多，篮球算是一个吧，因为创业的原因，也很长时间没去了。对于新玩意儿挺感兴趣的，最早的一批 Jawbone UP 2 的用户。<br><span class=""img-wrap""><img data-src=""/img/bVkwvm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""02d29eb907b59fec6fd962374ee14086.jpg""></span></p>

<p>说实在从设计到使用体验，Jawbone 让我很受伤，后来就换新转卖给别人了。自己也试了国内的硬件 bong，设计感缺乏的太严重，没有感觉到美，也没有感觉到酷，所以带了一周就扔了。</p>

<p>然后就是各种应用了，我对体验的要求很高，如果体验达不到或者不爽，我就会删掉或者退款。</p>

<h2>最近想买啥？</h2>

<p>由于我现在的住处靠着马路，所以晚上很吵，之前关注了 Sono，一款贴在玻璃上降低噪音的硬件产品，但还没有正式开售没法买到。<br><span class=""img-wrap""><img data-src=""/img/bVkwvx"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""77116f2a834d5b10278ddbe72e01ffcc.jpg""></span></p>

<p>很久之前自己有个想法，是否可以有一款雨伞产品可以帮助人解决忘带雨伞和是否要带雨伞的难题。最近发现有人已经做出来了一款叫 Kisha，在考虑要不要买一把体验一下。<br><span class=""img-wrap""><img data-src=""http://image.knewone.com/photos/a597445d74f56432c87634cb2be2f66e.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>产品癖好同类可以点击查看赵戈戈的产品列表：<a rel=""nofollow"" href=""http://knewone.com/lists/54a246c831302d769f3e0000"">hfcorriez 的产品癖</a></p>

                ", 【KnewOne Talk】赵戈戈：创业进行时,1531978007,134,1,398,1,1,https://segmentfault.com/a/1190000002469178
110,1,0,9,"
                    
<p>送给和我一样犹豫要不要学前端的大家：</p>

<p>前端的特殊性，前端不属于某一个专业，在大学里面没有专门的理论课做技术支撑，大多数前端是靠自学成才。但切入的方向各有不有不同：</p>

<p>1.有从设计方向切入的（设计，切图，布局包干），这群人的特点，对UI，用户体验，颜色，感觉会明锐一些。但对程序敬而远之，当遇到效果需要开发时，都是在百度或google上搜索现成的例子不能自主开发。</p>

<p>2.在一部分是从程序员转过来的（extjs或jquery,后台包干），常常是因为项目需要，做法上以达到目的为主，由于对用户体验，CSS重构优化以及对浏览器兼容上面功夫欠火候，做出来的除了功能能用之外其他的不堪入目，程序员的美感和真正的美感差距甚大，所以让他们做用户界面，那就。。。</p>

<p>特殊性还有对这个行业的错误理解，</p>

<p>1.前端的复杂度现在不亚于后台，各浏览器兼容，多终端，完成产品提出的各种变态需求，不影响线上的情况下修改代码，脚本阻塞，跨域，性能等等，这些还仅仅是开发这一块所涉及到的。</p>

<p>2.大多数公司还停留在是否高效的把页面做出来作为质量标准，虽接触这个行业，但无法进入核心业务，导致成为流水线上的一颗螺丝钉，发展空间遭到遏制。</p>

<p>一个合格前端绝对是多面手，不仅要掌握css，html，js，切图这些基本的内容，还需要熟练掌握类似jquery，YUI，dojo，prototype这样的内裤，以及至少一门后端语言java或php，因为工作中会经常和后台打交道了解语言的特性，会少掉很多沟通成本，沟通起来轻松愉快，也可以防止后台人员为了推需求来忽悠你。</p>

<p>前端人员软实力，体现在于各种人的PK，与产品pk需求，与测试pk bug，与项目pk时间，与后台pk接口，与同组pk技术。最后一项很重要，要懂得汇报，别什么事情都等领导要找你！！！</p>

<p>基本功扎实了，在高一层就是前端架构，大型互联网公司是不用jquery之类的内裤的，他们都有自己的一套js框架，考虑性能的原因都是用原生JS实现的（基于各种库的底层源代码），还有一套网站部署流程。这一套的东西就是公司技术积累，常常是公司好几波人的智慧结晶，所谓架构就是对于公司项目或者业务需求的一整套解决方案。</p>

<p>前端框架搭建，本地调试环境，线上部署环境，测试环境，自动化测试，性能优化，前端工具开发/选取，代码规范定义，项目流程规范，项目管理工具，模块化，防止跨站攻击，css/js目录组织，SEO，框架更换版本，敏捷开发。这些每个点都有自己的分支，感兴趣的就百度吧，我就不一一叙述了。</p>

<p>一套完美流水线和平台出来之后，人与人之间的沟通降到最低，重复而繁琐的劳动将由自动化工具替代，完善的开发工具让开发人员战斗力大增，合理的工作流程让项目按健康的方向进行，敏捷开发就不那么扯淡了。</p>

<p>软实力</p>

<ul>
<li><p>拿数据说话：做好对每一次优化和改版的数据对比，boss是希望看到最直接的东西，长篇的废话还不如一小串的数据效果好。</p></li>
<li><p>写文档：经常因为项目排期很紧，导致没有时间补文档，不利于交接和培训，做好每一次的技术回收。</p></li>
<li><p>培训：可以先熟悉一下公司框架，然后准备一些小DEMO，量逐渐增大。</p></li>
<li><p>面试：可以准备一些初，中，高三个等级的面试题目，不同的人不同问法，知识有时候不等于能力，个人觉得如果不是招的高端，只要基本功可以，态度比能力更重要，知识都是可以来学的。</p></li>
<li><p>沟通：表现出专业和淡定，和善而温暖，原则上要坚持，果敢。</p></li>
<li><p>技术分享：有利于提升团队水平，凝聚力，尽可能放权，把些核心交给组员，让组员发挥能动性。</p></li>
<li><p>分配活：针对每个人的特点分配，这样可以最大发挥团队价值，也可以得到组员的认可。</p></li>
<li><p>凝聚力：和组员建立好关系，关心组员，放下身段，做好1对1沟通，一个月用公款一起吃个饭有利于队伍团结。</p></li>
<li><p>学习能力：后生可畏啊，不想被淘汰，就学无止境吧，闲暇可以尝试新的方向，比如：移动端，HTML5，响应式布局，利用好自己资源和优势。</p></li>
</ul>
<p>来自<a rel=""nofollow"" href=""http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=200176142&amp;idx=1&amp;sn=e4fc3cdb8a1142eb98266c91e093cbd6#rd"">前端早读课</a></p>

                ", 前端价值之所在,1531978009,257,1,448,1,1,https://segmentfault.com/a/1190000002456296
111,1,0,9,"
                    
<p>逛微博看到<a rel=""nofollow"" href=""http://weibo.com/u/5042408187?topnav=1&amp;wvr=6&amp;topsug=1#_rnd1420100656338"">梁杰_numbbbbb</a>的一点建议，值得学习。</p>

<p>今天是杭JS第二天，中午去吃饭的路上突然有点慌张，投入了时间精力金钱，这次大会我到底收获了什么？想了半天，终于找到了一些能让我心安的东西。思维一发散，就想写篇文章来分享下我对于技术大会的看法。</p>

<p>先来看看下面的描述：<br>
1、非常兴奋，很早就去会场排队<br>
2、拿了各种贴纸和赞助商的布娃娃<br>
3、喝着会场的矿泉水或者是赞助商的可乐，吃着免费的零食或者午饭，听着周围的人讨论自己熟悉或者不熟悉的技术，感叹氛围真好<br>
4、抽奖时候无比激动<br>
5、挤了半天和演讲嘉宾合了个影然后迅速发微博。<br>
6、听完之后，拍个合影，打道回府准备周一上班。</p>

<p>我不知道多少人是这样的状态，但是我第一次参加技术大会的时候，基本就是这样，热热闹闹却极度空虚。</p>

<p>回去之后，我突然觉得很不安，花费了一天甚至更多的时间，除了那些T恤贴纸照片，我到底收获了什么？</p>

<p>有一个很流行的段子：本人擅长Ai、Fw、Fl、Br、Ae、Pr、Id、Ps等软件的安装与卸载，精通CSS、JavaScript、PHP、ASP、C、C++、C#、Java、Ruby、Perl、Lisp、Python、ActionScript、Pascal等单词的拼写，熟悉Windows、Linux、Mac、Android、iOS、WP8等系统的开关机。<br>
大家感受一下，参加完大会是不是这种感受。</p>

<p>那么技术大会到底应该怎么听，到底应该听什么？</p>

<h3>一、听思想</h3>

<p>大会不是课堂，而是交流思想的地方。重要的是为什么，而不是是什么。比如芋头的演讲，重要的是他的框架采用类似Rails的“约定”以及类似JAVA的分层，而不是到底用get还是find来获取数据。</p>

<p>一个实用的办法就是把自己放到讲者的位置，思考一下如果这些内容是自己在讲，希望传达给听众什么信息。</p>

<h3>二、听过程</h3>

<p>有些讲者的内容是解决问题，比如如何优化angularjs的性能。对于这类内容，重点是听讲者是如何发现这些方法、解决过程中遇到了哪些问题以及如何在不同方法之间进行选择，而不是仅仅记住方法本身。解决问题的思路是“渔”，最终的解决方案是“鱼”。</p>

<p>三、听演讲</p>

<p>这里说的演讲是指演讲技巧。其实听别人演讲是有效提升自己演讲水平的一个方法，如果你能发现别人演讲中的问题，那你就更容易在自己演讲的时候避免这些问题。<br>
我之前也并不太重视这点，但是恰好上周在金山进行了分享，之后又看了《TED演讲的秘密》，所以这次大会我特意注意了一下每个讲者的演讲方式，发现了不少问题。最常见的几点：声音小，语气无起伏，PPT内容不恰当。最后一点稍微解释一下，PPT内容不恰当指的是文字太多，不利于听众理解。还是前面说到的，演讲要传播的是思想，一张直观的图远比一页代码容易理解。</p>

<h3>四、知识吸收</h3>

<p>记笔记，一定要记笔记，千万不要相信自己的记忆力。很有可能一觉醒来你连昨天有几个嘉宾都想不起来了，所以一定、一定要记笔记。</p>

<p>笔记不光要记大会的内容，还要记自己的想法和灵感。听大会的时候往往会产生很多灵感，一定要尽快记录下来，会后再进行深入思考。</p>

<p>会后需要整理笔记，一方面是分类和规范化记录的内容，另一方面是对笔记中记下的灵感进行进一步的思考和分析，将灵感的力量真正发挥出来。</p>

<p>如果能做到这四点，我相信你一定会有一些真正有价值的收获。</p>

                ", 技术大会到底该怎么听？,1531978011,297,1,135,1,1,https://segmentfault.com/a/1190000002456269
112,1,0,9,"
                    
<p><strong><em>英语真是硬伤，收藏一下前辈的经验学习学习</em></strong></p>

<p>对于咱们这些高端大气、时刻需要和国际接轨的码农，英语的重要性自然是毋庸置疑的。尤其是那些胸怀大志的潜在大牛们，想在码农行业闯出一片天地，秒杀身边的小弟们，熟练掌握英语更是实现其目标最关键的因素之一。否则，试想在你捧着某出版社刚刚翻译出来的《JSP 高效编程》苦苦学习JSP模板的时候，你旁边的小弟却是拿着原版的《AngularJS in Action》学习开发单页面应用，虽然你们都同样认真地学习了一个月，可做出来东西的效果能一样吗？</p>

<p>所以，英语好才能学到最新最炫的技术，否则只能拿着国内出的翻译版学习两三年前的老古董还把它当个宝。更何况国内的翻译书水平如何你不会不知道吧？多少坑爹的翻译啊！不提了！其实我十多年前还参加过一本Java开发指南的翻译，而当时我一直在IBM主机上做开发，压根就不会Java，所以误人子弟是肯定的了。回首往事，惭愧啊！请上帝宽恕我的罪恶，阿门……</p>

<p>好了，现在言归正传，说说码农应该如何学习英语，达到熟练掌握英语的水平。<strong>首先，我要明确一个概念：英语学习是不可能速成的。一心想速成的同学们可以不用往下看了，不然浪费了你们的时间我可担不起责任啊。</strong></p>

<p>作为码农的习惯，自然第一个重点是要准确定义”熟练掌握英语“的概念。</p>

<p>我的定义如下：</p>

<ul>
<li>阅读：能够直接阅读英文文档，比如《MongoDB: The Definitive Guide》，并且阅读速度和理解程度都能与母语相当；</li>
<li>写作：能够直接编写英文文档、邮件，达到英语母语人士能够无歧义理解的程度，学有余力的同学可以追求逻辑严密和用词严谨；</li>
<li>听说：能够顺畅地与英语母语人士进行有关技术方面的交流，达到双方沟通无歧义的程度，学有余力的同学还可以争取在对话中表现幽默感和个人品位。</li>
</ul>
<p>肯定有人要不服了：为啥学习的起点给俺整这么高呢？因为，只有达到这个标准，你才能充分发现学好英语的好处，也才能自觉地尽可能使用英语，形成良性循环。</p>

<p>那么，要达到这个标准需要多少时间呢？对于CET-4或者6级水平的同学（没错，4和6都是一个水平，几乎没啥差别），我的估计是需要1万小时以上。这也是我前面说英语不可能速成的原因。可能有人会抱怨说，老码农你不靠谱，1万小时也太多了，就算一天花5小时学英语，也需要6年时间，这不是太坑爹了么？对此我想说的是，每天5小时其实一点也不难，如果你一直在学新技术而不是重复做熟练工的话，平均每天看技术文档就能看3小时，另外写文档邮件注释再花1小时，上下班路上也别坐着发呆，至少可以练听力1小时，这样5小时不就出来了么？</p>

<p>最关键的是，这5小时并不是另外挤出来的，而只需要把以前的一些习惯改一改就好。遇到问题百度查中文文档改成Google查英文文档，把写中文注释的习惯改成写英文注释，拼音变量名改成英文短语变量名，尽量和国际接轨，做一个高端大气国际化的码农。除了这5小时之外，平时没事也可以听点外语歌，感受一下英语的韵律；有机会就经常去听一些国际性的行业大会；周末再去看看好莱坞原声版大片，不亦乐乎？这些都是你本来工作和生活中就有的内容，并不需要刻意地去挤很多时间苦学。只要有心，处处时时都是学习的机会。</p>

<p>至于6年时间有人觉得太长，如果是你喜欢做的事，谁会嫌时间长? 更何况你往后看就会发现，这1万个小时里在学英语的同时也是在学技术，而且是最基础或者最先进的技术，是不学好英语就很难及时掌握的技术。通过这个过程，你不仅英语水平提高了，技术上也能大有长进。这些都是潜移默化的，每天都在进步，而不是一定要突击到满1万小时产生一个突然的飞跃，这才是真正提高水平的真谛所在。所以我认为，<strong>学英语首先要去掉功利心理，通过一个努力的过程把英语变成你的一项爱好</strong>：看书就喜欢看英文版的书，看电影就喜欢看原声不带字幕的。如果能做到这一点，别说6年，就是60年你也能甘之如饴；反之如果你不喜欢英语，那么每天5个小时的煎熬即使是6个月恐怕都很难坚持下来吧？</p>

<p>写到这里，对于学习英语的心态，我想小结一下。有些同学会狠狠地下一个决心：我要开始学英语了！苦读一年练成英语神功！然后开始拿一本词典开始背单词，花了一个月时间把A打头的单词背得滚瓜烂熟，然后，就放弃了。。。我想说的是，不要把学英语看作一次磨练意志的马拉松赛跑，把它当做一次旅行，享受这个过程，享受途中的风景，不用急着赶路，这样你才能走得更远。</p>

<p>言归正传，1万个小时这个数据的估算方法是：阅读5000小时、听2000小时、 写2000小时、 说1000小时，下面具体说明：</p>

<p><strong>1. 大量阅读是提高英语水平的基础、核心、重中之重，要在大量阅读的基础上再开始练习听力和写作。</strong></p>

<p>为什么这么说？最有效的学习方式就是模仿，而听说读写四个要素里只有听和读有模仿条件。</p>

<p>那为什么不是先多听呢？有两个原因。一是口语比较随意，俚语方言比较多，在表达上不如书面内容严谨；二是听一次没能理解的内容不容易查找和重复。所以大量的阅读是提高英语水平的关键性基础性的工作。</p>

<p>有人又要问了，难道不要先背单词吗？这个嘛，我自己是最讨厌背单词的，又怎么会把你们往火坑里推呢？而且单纯地背单词用处不大，在阅读中记住的单词才是有用的。</p>

<p>比如在GRE单词表开头随便找个单词avalanche，释义是n.雪崩 vi.崩塌，你可以使劲地背，把它和其他几千个单词都记得滚瓜烂熟，然后当你某天在文档中看到一句话说：”… to handle an avalanche of client requests …“，你可能都想不起来背过avalanche这个单词，即使想起来也未必能准确理解它在这段话里的含义。</p>

<p>这是为什么呢？因为背单词是孤立地去记一个个单词，应试也许有用，但是事倍功半。最好的方法就是在阅读中去理解它，比如还是那一句，我压根不知道avalanche这个单词，但是从前后文去蒙，an avalanche of大概是说非常多的意思，如果你不确定理解得对不对就去查一下字典，就明白了这意思是”像雪崩一样滚滚而来的大量的什么东西“。</p>

<p>查词最好是查英-英辞典，比如Merriam-Webster的韦氏英英辞典。还有，查一个单词的时候，不要去记那几个中文释义。某些人背单词就喜欢像念经似的念叨：“capability，才能，能力，容量，性能，生产率，capability，才能，能力，容量，性能，生产率……”，旁观者都替他觉得累得慌对吧？其实你只要模糊地知道它的意思就行了，学英语尽量不要掺进来中文。老外不知道啥叫“才能，能力，容量，性能，生产率”，也没影响人家用capability这个词不是？</p>

<p>另外我觉得吧，单词和人一样，也是有眼缘的，记得住记不住都不要去强求。即使这一次看完又忘了也没关系，等你阅读量上去之后，遇到次数多了自然就记住了。有人说，万一有的词遇到次数很少，还是记不住咋办？对这种问题我就无语了。遇到次数很少的单词你记它干啥？有个著名单词中文意思是什么早期银版照相术的，我就偏不记它，它能把我怎么着啊？</p>

<p>通过这个过程，你不但记住了单词，还掌握了它的常见用法，这对于以后的写和说都是非常好的基础。现在很多人学英语的弊病在于应试思维，就仿佛孔乙己说的茴香豆的茴有四种写法，少记住一种就可能在考试里做错题被扣分，但是现实生活中你也许只需要会一种就行了，关键是知道它的意思而且能够准确地使用它。</p>

<p>矮马，一下子扯到背单词跑偏了。还是接着说阅读，怎么阅读呢？我推荐一种暴力方法，不管你基础如何，先找一两本和技术相关的白话书，而且是你最感兴趣的领域，比如经典的《Man Month Myth》（<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B0011C2P7W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011C2P7W"">人月神话</a>） 和《Joel on Software》（大神Joel谈软件开发）原版书，这样读起来好歹不那么苦闷，有助于你坚持下来。毕竟在这个起步阶段，坚持是第一位的。不然给你找本《advanced econometrics》试试，据说95%的码农读了三天之后都疯了。</p>

<p>就算是你感兴趣的书，也保不齐一开始读起来觉得很费劲。也许有的人翻开第一页一看，妈呀，一半单词不认识！这咋办？没事，像我前面说的，有把握蒙的就蒙，没把握的就查，查过的可以把中文意思写在单词旁边，能写英文理解更好，懒得写也没关系，总之原则就是把全部内容看懂吃透就行。</p>

<p>还有，句子太长里边有好多that….. which….. who….什么的从句？那也没关系，别人理解不了，可咱是码农啊，懂得嵌套结构的原理，不就是递归嘛！甭管他连了多少个，从最后面的那个往前一个一个处理，把从句用彩笔一个一个标出来，最后看清楚嵌套关系以后，句子也就容易看懂了。实际上，我觉得英语最妙的地方就在这里，它能在一个句子里用一个无限延展的树形结构来描述一个概念，直到把它定义得非常严谨无歧义为止。中文做不到这一点，必须拆成好多个句子才能做到通顺，但理解起来就困难多了。</p>

<p>在这个阶段一定不要求快，一天吭哧吭哧地只看了半页都没关系，也很正常，但一定要确保准确理解。在此我想特别提醒的是，如果你一开始不适应，一定要坚持下来。其实学习英语过程中最难的不是听说读写，而是英语思维。汉语是讲朦胧美的，所谓“道可道，非常道”，越深刻的东西往往越是“只可意会，不可言传”，文人写文章喜欢下结论而很少论证，结论的经验性主观性较大，例如“肉食者鄙，未能远谋”；而欧美文章则大多务求精确严谨，定义精确，论证充分，避免逻辑上的漏洞，下结论则往往比较谨慎，一般都是客观数据，尽量避免主观看法，例如“根据卫星云图，明天的降水概率为70%”。我年轻的时候买过《孙子兵法》和克劳塞维茨的《战争论》一起看，两者的风格差别真是泾渭分明。</p>

<p>此外对于人文方面也有很大差别。老外经过文艺复兴，对于人文关怀有了很好的基础，更强调个人自由和权利，所谓”风能进，雨能进，国王不能进”；我们从历史文化传承的角度看则是集体大于个人，更强调个人适应环境。再比如老外对于弱势群体的歧视嘲笑是非常忌讳的，但中国人往往习惯了小品里瘸子瞎子胖子出场摔一大跟头这样的笑料。</p>

<p>所以，这些思维上的差异才是学英语的最大障碍，而大量阅读有助于理解和养成这种思维习惯。特别是逻辑上的严密性和表达的客观性方面，由于文化传统和教师本身的原因，在中国现在的教育环境很难训练出来。但是通过大量阅读英语材料，就可以达到很好的洗脑效果，实为居家旅行、和平演变必备良药。</p>

<p>读完两三本白话书就算是热好身了，下面可以开始读一些更枯燥的东西，主要是专业教课书。如果上大学的时候学的《数据结构》、《离散数学》、《操作系统》这些都还给老师了，正好拿英文版的复习一下。找你专业相关的基础课原版教材，5本左右，开练。照着前面的要求，一样细细地看，不求快但求精，练习题也好好做一部分，不然你怎么知道自己确实理解透了？</p>

<p>等你看完这几本，阅读基本上就算入门了，可以开始练习写作和听力。具体做法后面再细说。</p>

<p>与此同时，要开始看一些行业里最新的技术文档。这些可能还没出书，也可能有一些免费的pdf，不管怎样，也找5本左右来看，什么MongoDB，Neo4j，<a rel=""nofollow"" href=""http://blog.jobbole.com/1254/"">Node.js</a>，AngularJS之类的，细细地看，边看边做个系统练手，因为这些新技术文档还比较少，社区里的东西也不多，所以免不了要去StackOverflow问，或者去<a rel=""nofollow"" href=""http://blog.jobbole.com/6492/"">GitHub</a>找些例子来看，别偷懒，这些都是很好的学习方式。</p>

<p>等你把这几本书也啃下来以后，按A4纸算，你的阅读量肯定会达到7000页以上，在SO, <a rel=""nofollow"" href=""http://blog.jobbole.com/25775/"">git</a>Hub, Google上查看过的英文资料也不会少于3000页，阅读总量肯定超过1万页了。现在恭喜你，你的阅读能力肯定没问题了。如果我没猜错的话，你这时候碰到翻译版的书都懒得瞟一眼，更别说花钱买和花时间读了。</p>

<p>另外，阅读能力达到这个水平以后，写作也基本有个基础了。所谓“熟读唐诗三百首，不会作诗也会吟”，看多了以后你会发现英语写作也有一些套路，和中文是一个道理，经过大量的阅读，很多句式其实已经在你的脑子里了，只要在写作过程中经常练习这些句式，自然就熟能生巧了。</p>

<p><strong>2. 写作要创造环境，每天都要写1000字以上。</strong></p>

<p>在互联网时代，这一点也不难。最简单直接的办法就是注册一个StackOverflow账号，起初是去问问题，把你搞不定的代码贴上去，会有大牛们帮你<a rel=""nofollow"" href=""http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS"">搞定</a>，顺带着阅读也练了；等你技术水平涨了以后，想想这么多人帮了你你才成了大牛，总不能只进不出吧，有余力了就应该报复社会，所以就经常去StackOverflow找一些你拿手的主题，帮其他菜鸟们解答一些问题，这样也就练了写作了，一举两得多好！</p>

<p>等你在SO上混出了点名堂，有点江湖地位的时候，就会有人来找你，比如帮忙干点活啊咨询点问题啊之类的，自然邮件联系就少不了了，这都是练习写作的机会，就算你不想帮他干活，也可以和他扯一扯。</p>

<p>另外，弄个FQ软件比如goagent，注册个Google Plus账号，上去看看热点文章，写点自己的体会之类的。实在闲得无聊也可以找Linus之类的大牛混，他每发一贴你就上去评论一番或者请教一下，先混个脸熟嘛！顺带也练习了写作。时间长了，说不定大牛还喜欢上你了，没准随便给你个肉身FQ的机会，这就是意外之喜了。</p>

<p>总之，写作是大量阅读之后水到渠成的产物，不过要注意一点，写出来的每个句子甚至每个单词都要务求精准地道，不知道的不要瞎写，要么改换自己熟悉的写法，要么查清楚了再写。要是养成随意乱写的习惯，写出来的句子都是中国人能看懂，外国人都看不懂，那前面的努力就付诸东流了。</p>

<p><strong>3. 听力要在阅读能力达到一定水平后再开始练习，和前面说的阅读给写作打基础的关系相似，练听力的同时其实就在为口语打基础。</strong></p>

<p>我首先要说的是，千万不要跟着美剧什么的练听力，你又不是打算偷渡去纽约皇后区卖毒品跟黑人大哥混，就算你听一耳朵就能熟练分辨出说WTF are you doing的是意大利人、爱尔兰人还是黑人，又有啥用呢？咱们做码农的一定不要忘了自己的本分，得跟着码农的大哥混才对。所以练习听力一定要多找IT圈的大牛的访谈来听。</p>

<p>最经典的自然是天妒英才英年早逝的乔帮主，多听听他的访谈你就知道他的成功绝非偶然。像这样一位逻辑严密，思维活跃，表达能力强，善于调动听众情绪，还很有幽默感，而且做事又非常有韧性的人，实在是百年难遇的天才人物。</p>

<p>比尔盖茨的访谈就差多了，他的表达能力真的是不敢恭维，有时候东拉西扯的听不明白重点，依稀有点韩乔生老师的风韵。政客系列也不推荐，像奥巴马的讲演听起来总有一种似曾相识的赶脚，细细一想，这不就是美国版的传销讲座嘛！</p>

<p>所以，多听乔大神的访谈绝对是没错的。为啥是访谈呢？因为都是对话，形式上和咱们的需求匹配，咱们工作中需要的英语对话就是类似于访谈式的，你想想是不是？而且他的访谈聊的都是咱们挨踢的事儿，背景知识都比较熟悉，你专心听他的表达和逻辑就好了。你要是不服，俺给你弄个生物系教授讲分子生物学课程的录音让你听，你听完还能找得到北吗？</p>

<p>这些访谈在网上都有，到iTunes里的podcast里大把大把的，不过别找带字幕的听，千万！</p>

<p>现在材料有了，怎么听呢？我先告诉你，每个访谈都要听100遍以上，头20遍就是稀里糊涂地听，能听懂多少听懂多少，听不懂的先蒙。但我敢保证，第20遍肯定比第1遍听懂的东西要多多了。到了20遍还在蒙的，基本你听到第100遍也还是在蒙，所以再蒙下去就没意义了，这时候找到文字版好好看一遍，就看一遍，然后收起来，再听20遍，这时候有些原来靠蒙的就听出来了，听完20遍再看一次，再听，如此反复，100遍之后基本应该都不用蒙了，然后再听下一个。听过100遍的，以后也要经常复习，反复听，再背几遍，很多句型就会自动进到你的脑子里，给你的口语打下一个很好的基础。</p>

<p>IT界的访谈每个大概都在1-2小时之间，就算1.5小时吧。一个听100遍就是150小时，精听10个就是1500小时。10个就够了，不用追求数量，关键是重复。当然平时还要有一些泛听，比如英文广播、看CNN新闻什么的，越多越好，这些就不求全听懂，听懂多少是多少，一遍就过去，权当是个消遣。</p>

<p>在这之后，再故意去找一些录音不是那么清晰的访谈来听，比如乔大神96年回到Apple时，在当年的WWDC上的访谈。这个访谈很有意思，因为他一回来就砍掉了好多正在做的产品，有很多利益受损的听众对他不服不忿的，带讽刺挖苦甚至攻击性的问题也不少，可乔大神应对自如，潇洒极了。这个访谈大概是因为年代久远，杂音比较多，音质也不太好，但仔细听也能听出来。很好，就是它了！就照着这个标准找那么三、四个略模糊的访谈，比如通过电话进行的一些访谈，再如法炮制，按100遍的方法听它500小时，这样听力基本也就过关了。</p>

<p>有人大概心里会嘀咕：故意找这种模糊的录音听有什么意义呢？这主要是让你适应不那么理想环境下的听力，比如在喧闹的餐厅里对话，或者是老外通过skype对你进行<a rel=""nofollow"" href=""http://forum.jobbole.com/showthread.php/3620"">电话面试</a>，而你只能听清专业录音设备录下来的访谈，那咋行？所以也需要在前面理想条件下1500小时听力练习完成的基础上，训练一下恶劣条件下的听力。</p>

<p><strong>4. 练习口语是最麻烦的，因为说的条件最难创造，这必须得有个大活人认真地跟你聊才行啊！</strong></p>

<p>当然了，要是你能找个英语母语的老外谈对象，那就又省事又高效了。不过，等口语练好了一定要一脚将其踹掉。要记住，你是一个中国人，肥水不流外国田！</p>

<p>好了，大晚上的不扯淡了。练习英语口语不外乎这么几个途径：交外国朋友，进外国公司，或者花钱雇外国人跟你聊。各人工作、经济情况不同，这就自己选择吧。反正现在改革开放了，一部分人也富起来了，跟谁聊也就丰俭由人了。</p>

<p>不过这里要提醒一点，别去什么英语角练口语，这种地方要么是一百多人围着一个老外，跟看猴似的，要么就是一堆中国人互相来几句好肚油肚，听着就想摸摸对方的肚子看看有多好有多油，纯粹浪费时间！我认为，练口语一定要找英语是母语的人士练习，这样才能事半功倍。</p>

<p>另外，有机会就多去美国英国澳大利亚加拿大什么的地方转转，现场体验一下自己的学习成果。不过我这里讲的主要是码农工作相关的东西，基本没涉及到生活类的英语，比如去麦当劳买个milk shake什么的，这些主要要靠现场体验现场学习，但有了前面阳春白雪的码农高端上流社会英语作为基础，这些下里巴人的生活英语上手很快，对你肯定不在话下。</p>

<blockquote>
  <p>【补充】有同学想让我推荐一些学习材料，我后来补充了一篇<a rel=""nofollow"" href=""http://blog.jobbole.com/45795/"">补充一些英语学习素材</a>，供大家参考。</p>
</blockquote>

<p>关于码农如何学好英语，我就先说这么多吧。最后再总结一下，英语学习是一个终身的事业，只有通过痛苦的起步阶段，慢慢把它变成你的一个爱好，才能持久下去。等到它真正成为你喜爱的东西了，你就会发现眼中的世界从此变得不同。它变大了，变得多样化了，也变得更美好了。这时，所有的努力和坚持都有了回报。</p>

<p>作者<a rel=""nofollow"" href=""http://www.cnblogs.com/aaronjs/p/3660105.html"">Aaron</a><br>
作者微博：<a rel=""nofollow"" href=""http://weibo.com/ned11"">@老码农的自留地</a></p>

                ", 老码农教你学英语,1531978012,109,1,302,1,1,https://segmentfault.com/a/1190000002453072
113,1,0,9,"
                    
<p>这是我在知乎上关于问题“<a rel=""nofollow"" href=""http://www.zhihu.com/question/20325677/answer/14764861"">只会 if, else, 数据库 CRUD 的 Java 程序员如何提升自己？</a>”给出的答案。其实，这应该就是一个关于早期技术人员怎样突破瓶颈的问题。</p>

<p>作为一个爱好技术的人，我们最常见的技术入门——或者说技术切入点——就是开发有实际可见结果的应用——因为这个够简单，够有成就感。而无论哪个平台、框架上面的应用开发在现阶段都逃不开楼主所说的，某个编程语言的学习（Java、Ruby、PHP 等），某个数据库（Mysql、Sqlite、Mongodb 等），再加上楼主未曾说的该框架、平台（Rails、Android、IOS 等）的知识的掌握。</p>

<p><strong>编程语言、数据库、应用开发框架——这三个部分构成了早期从事应用开发的程序员的全部。</strong></p>

<p>所以当进行了够多的应用开发后，我们就往往会产生这样的思考——我会写应用了，但是我觉得我学会的技术别人学了也会，我的优势在哪里？我想继续提高，我该怎么走？以及类似于楼主这样更为具体的问题：只会 if、else，数据库 CRUD 的 java 程序员如何提升自己？</p>

<p><strong>我觉得，一句话可以指点这个阶段的开发人员——向上走，向下走。</strong></p>

<p><strong>向上走，指的是进一步学习设计——没错，程序员的工作本质上也是设计</strong>（只是我们好多人都没有意识到）：代码设计、算法设计、架构设计等等。之所以觉得自己在重复地做事情，是因为你的每次设计都采用了同样的方案——排序？用快排吧；生成实例并且要解耦？嗯，用工厂吧；要提高系统性能、可用性？嗯，用 cache 吧。虽然说利用现有的设计方案是设计人员的必经之路，但是如果一次又一次的重复利用相同的方案，你就会觉得自己并没有提高——虽然对于项目本身来说是安全、可靠的。在学会了基础的应用开发之后，你就算是学会了最基础的设计方法。然后你要提高，就得继续去学习更为优秀的设计方法：代码设计上，我们去参考设计模式；算法设计上，我们去了解针对同一个问题的不同的解决方案的可用场景以及相应的优劣性；架构设计上，我们去探索最适合现在我们应用所处的环境最好的解决方案（听过腾讯一位技术总监的演讲，他们后台的用户数据、关系系统的架构就有自己的选择：例如数据库中的读取尽量没有用到锁）。总之，学会了基本的应用开发，就可以尝试向上走，走“形而上学”的路子。我想楼主应该已经看出来了，我的建议具体化下来的时候，就是去学习设计模式、算法设计、架构设计（现阶段仅仅了解一下就好，将来在实际情况中去实践的话体会更深）等一系列关于设计的知识。</p>

<p><strong>向下走，指的是去了解系统下面的世界</strong>——也就是说，去学习系统的运行机理，“知道机器在干什么”（我最敬佩的 C 语言老师所言）。一个应用程序运行起来，就得有各种支持它的系统——计算机硬件系统、计算机操作系统、编译系统、语言运行时系统。如果不去了解这些“土壤之下”的机制，你就会觉得自己写的程序有如空中楼阁，不得其中真谛——譬如，同样能达到目的两条语句哪个机器执行的效率最高？哪样的代码组织会导致最终程序执行的崩溃？怎样去避免代码中的内存泄漏？——所谓知其然，不知其所以然也。所以，代码要写的明白，咱就得往下走，去了解底层。我们可以去看看 linux 对于进程的内存、CPU 管理机制是怎样的，从而去优化我们程序的性能；我们可以去看看数据库的存储引擎，从而在深刻理解之后写出更为高效的 SQL 代码，并且进一步对自己的数据库进行设置、调优；我们可以去看看 JVM 是怎样进行垃圾回收的，从而避免 java 中恐怖的隐性内存泄漏。楼主向下走，可以去学习操作系统、计算机体系结构、编译原理以及运行时等知识——你会在学习的过程中对于自己曾经遇到的问题恍然大悟（我就经历过好多回了，每次都高兴不已哈哈）。</p>

<p>最后再提最重要的一点——<strong>不要把写代码本身作为终极目标，而应该把代码之上、之下的东西弄透</strong>。我想，这也是区别代码工人和研发工程师的界限之一吧！</p>

<p>via <a rel=""nofollow"" href=""http://bachiscoding.com/blog/2013/04/23/what-should-programmer-do-when-facing-bottleneck/"">巴赫在编码</a></p>

                ", 技术人员初入门，该如何突破早期瓶颈？,1531978013,353,1,374,1,1,https://segmentfault.com/a/1190000002443144
114,1,0,9,"
                    
<p>最近跳槽了，老板希望我留些心得体会。我想了几天，零散总结了一点东西。如果写的莫名其妙的，还望各位不要笑话。</p>

<h3>1</h3>

<p>首先说下软件行业在我看来是怎么回事。软件行业是个非常年轻的行业，大概只有四五十年吧。四五十年是很短的，一个只有四五十年历史的行业是很不成熟的。成熟的行业是个什么样子的呢，我们可以看看汽车、纺织和建筑等等存在了成百上千年的行业，它们在制作工艺、产品质量、从业资质、销售模式等等方面都有非常成熟的标准，符合标准的产品基本上都不会出现明显的质量问题，也就是说这些行业的产品具有稳定可控的质量。反观软件行业，在质量控制方面还在摸索之中，没人能保证软件项目或产品一定能达到什么水平。从瀑布模型到敏捷开发，从 CMM 到 Scrum 等等工具，人们都在摸索，在这个摸索过程中，没人能保证某个组织使用过的某个成功的软件开发方式，一定能适用于其他组织或其他项目。这是第一个方面，软件行业还没找到生成可靠的产品的方式。而另一方面，随着近几年智能手机日常化，软件开始爆发式的侵入人们的生活，每天都有新的应用出现——急剧扩张的势头也是年轻行业的一个典型特征。第三个方面，软件行业内部的职位也在不断变化，前端工程师在十年前大概还不存在，随着职位划分越来越多，全栈工程师的概念也被提出来探讨。最后，新的技术不断的出现并受到热烈追捧，比如大数据和云平台，它们甚至已经成了软件业中的一个小产业。总之，只要你关注下行业动态，就会发现这个行业每天都在变。这正是其年轻的象征。</p>

<h3>2</h3>

<p>研究如何让一个软件团队产生高质量的软件，这样的学问叫软件工程。软件工程是团队运作的基础，是公司运作的基础，更是整个行业运作的基础。不像技术那样日新月异的更新，这种基础性的东西发展是很慢的。三十多年前的<a rel=""nofollow"" href=""http://book.douban.com/subject/2230248/"">《人月神话》</a>每年都再版，到现在仍然是程序员的必读启蒙书。还有一本<a rel=""nofollow"" href=""http://book.douban.com/subject/1108725/"">《人件》</a>也是必读，前者告诉你软件开发是什么，后者告诉你程序员是什么。它们跟《Thinking in Java》的区别在于后者是初中生都能看懂的纯技术书，而前者只有成年人能看懂，它们是关于人的书。</p>

<h3>3</h3>

<p><a rel=""nofollow"" href=""http://book.douban.com/subject/1723351/"">有本书</a>上说，最好的程序员要比最差的程序员强 28 倍。而实际上，最好的程序员薪水也拿不到是最差的程序员的 28 倍那么高，所以老板喜欢好的程序员——效率高，单位薪水却相对低。好的程序员好在哪里？可能存在很多方面，但我觉得最重要的一点是：手段多。在这世上，不管哪个问题，解决的手段肯定都不止一种。解决问题的手段越多，遇到问题的时候就越得心应手，游刃有余，知道哪种手段最适合解决当前的问题。比方说，用什么数据库？唰的手一挥，各种数据库摆在面前来挑；用什么处理 JSON？jackson，gson，fastjson 都摆在你面前让你挑。怎么读 Excel？jxl，POI，随你挑。用户属性多变怎么办？横表，竖表，随你挑。是吧，镇定自若,临危不惧，指点江山，游刃有余，这个小小的程序员挥手言语间就不经意的<a rel=""nofollow"" href=""http://www.qidian.com/Book/3169902.aspx"">透露出一种王者霸气</a>。</p>

<p>嗯嗯，那么怎么积累这些手段？一方面是实际的工作经验，但这远远不够，更重要的是自己去找，凡是能帮助自己解决将来可能遇到的问题的框架，工具，类库，都去用下熟悉下，那么到了遇到问题的时候，就知道拿什么工具去处理了。关注业界的动态，你会看到每天都有很多新的工具出现。其中有的可以用来代替原有的工具，因为它们更好用，效率更高。</p>

<h3>4</h3>

<p>软件工程是跟人有关的学问，但软件开发本身还是跟电脑打交道的。不是每个人都适合跟电脑打交道，要跟它好好打交道的话，你得是一个冷静客观诚实的人，至少培养自己的这方面品质。</p>

<p>比方说冷静，有的人不冷静，不冷静的人遇到问题就是慌的，脑子里只想着一件事：</p>

<blockquote>
  <p>怎么会这样怎么会这样别这样别这样……</p>
</blockquote>

<p>他们甚至希望时间能帮他们解决问题。说实话，在生活当中，确实不少问题靠时间就能解决——晾在一边即可。但在软件行业行不通，电脑的耐性绝对比你强。所以遇到问题第一个反应就是要找原因，冷静（下来）与其说是一个动作，不如说是在整个解决问题的过程中都要始终保持的一种状态。</p>

<p>第二个客观是什么意思呢？在电脑看来，所有的运行结果都是正常的，不存在对错之分。如果你编写的代码行为与你的预期不一致，那么有两种可能：要么你写了错误的语句（比方该加的时候减），要么出现了你没有预料到的状况（比如参与计算的某个条件是空的）。软件运行的时候会遇到各种各样的状况，对计算机来说没有差别，成功和失败都是正常的结果。而对某种状况是否处理，决定权在你手里，你会根据自己的喜好来决定。</p>

<p>第三个诚实。计算机是最诚实的，这点本该毫无疑问，但不知道为什么我总看到有人怀疑计算机。当计算机报告一个错误发生时，他不相信，他不去看错误信息，而是尝试从别的地方找原因，到处找原因，就是不看错误信息。直到所有的尝试都徒劳无功，他才会看下到底哪里错了。我完全没办法理解这种人心里是怎么想的。</p>

<h3>5</h3>

<p>代码是什么，代码是软件开发的成果，是程序员心血的结晶。但它又是那么的捉摸不透，我敢保证，每当你写完一段代码，端起杯子喝口水的时候，你都会不由自主的思考两个问题：</p>

<ol>
<li>这段代码<strong>对</strong>吗？</li>
<li>这段代码<strong>牛逼</strong>吗？</li>
</ol>
<p>刚入行的程序员对“代码质量”是毫无概念的，但我还是想尝试说明一下什么是代码质量：</p>

<blockquote>
  <p><strong>一段代码，你假设它是一个故事。这个故事，有头，有尾，有经过，有分支。程序员就是讲故事的人。代码质量好不好，就是故事说的好不好。有的程序员讲出来的故事，别人半天看不懂，这样的代码就是低质量的。</strong></p>
</blockquote>

<p>高质量的代码，或者说牛逼的代码有什么样的标准呢？我介绍一个简单的检查方式，就是重新阅读你的代码，看能否做到：</p>

<ol>
<li>30 秒内看完并完全理解。</li>
<li>阅读的过程中只往下看，不会去重新看前面的内容。</li>
</ol>
<p>不说一定要达到这个标准，也要以它为努力的方向去写代码。关于代码质量的书，推荐下面几本：</p>

<ul>
<li>
<a rel=""nofollow"" href=""http://book.douban.com/subject/1229923/"">《重构：改善既有代码的设计》</a>这本书主要介绍糟糕的代码到底哪里糟糕，以及如何改进；</li>
<li>
<a rel=""nofollow"" href=""http://book.douban.com/subject/3324516/"">《实现模式》</a>这本书介绍代码表达能力；</li>
<li>
<a rel=""nofollow"" href=""http://book.douban.com/subject/5406042/"">《设计原本》</a>这本书介绍“设计”与“构思”本身是什么样的思维活动，设计风格是怎么回事，经验在设计当中起什么作用，一个已经完成的设计又会出现什么样的演化。</li>
</ul>
<p>最后一本书非常的抽象，非常的装逼，但你一旦理解了，就会发现它非常的有用！因为它帮助你审视自己的思考方式。一个程序员变得牛逼的过程，就是其思考方式不断进化的过程。牛逼的书是一下子看不懂的，只能每隔一段时间拿出来翻下，也许就能慢慢理解。</p>

<p>另外还有被称为 “<a rel=""nofollow"" href=""http://www.uml.org.cn/sjms/201211023.asp"">设计模式六大原则</a>” 的设计准则可以用作对代码质量的评价参考。</p>

<h3>6</h3>

<p>怎么用 logger 框架写日志。常用的框架有 log4j，commons-logging 和 slf4j，它们的作用就是在日志文件中<strong>记录某个业务处理过程的状态</strong>。日志是很重要的，如果日志记得好，我们就能清楚的看到业务处理怎么开始怎么结束，来龙去脉都清楚；一旦出现 BUG 或故障，光靠看日志就能得到足够的信息，定位问题出在哪里。日志记得不好，出了问题什么日志里面都看不出，只能用别的更耗时间的手段来处理了。</p>

<p>如何记好的日志，一个简单的原则就是：每次出现分支的时候都记一条日志，标明流程往哪个分支走了。遵守和不遵守这个原则，你会感受到天堂与地狱般的巨大的差别。</p>

<h3>7</h3>

<p>有两句话绝对不要相信：</p>

<ol>
<li>代码看不懂没关系，能用就行了。</li>
<li>所有的软件都不过是增删改查。</li>
</ol>
<p>如果开发团队中有成员坚定的抱有这样的态度，项目负责人应该尽早将这种人驱离开发团队。</p>

                ", 写给新入行的同事们,1531978015,449,1,816,1,1,https://segmentfault.com/a/1190000002435442
115,1,0,9,"
                    
<blockquote><p>赞助我以写出更好的文章</p></blockquote>
<p>如果您觉得文章对您有帮助，可以逐个点击以下链接，类似于Google ads，不需要您付出任何费用，每天都可以来点一次噢，费用将由广告商承担，give me a cup of coffee?</p>
<p><a href=""https://app.codesponsor.io/link/gWs9P5H4YpntyAR6x1qG5EkX/hawx1993/front-end-utils"" rel=""nofollow noreferrer"">https://app.codesponsor.io/li...</a></p>
<p><a href=""https://app.codesponsor.io/link/gWs9P5H4YpntyAR6x1qG5EkX/hawx1993/webpack-logplugin"" rel=""nofollow noreferrer"">https://app.codesponsor.io/li...</a></p>
<p><a href=""https://app.codesponsor.io/link/gWs9P5H4YpntyAR6x1qG5EkX/hawx1993/node-blog"" rel=""nofollow noreferrer"">https://app.codesponsor.io/li...</a></p>
<p><a href=""https://app.codesponsor.io/link/gWs9P5H4YpntyAR6x1qG5EkX/hawx1993/Front-end-Interview-Questions"" rel=""nofollow noreferrer"">https://app.codesponsor.io/li...</a></p>
<p><a href=""https://app.codesponsor.io/link/gWs9P5H4YpntyAR6x1qG5EkX/hawx1993/learning-js-well"" rel=""nofollow noreferrer"">https://app.codesponsor.io/li...</a></p>
<hr>
<p>“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本， 你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”<br>很多程序员响应，他们在推荐时也写下自己的评语。 以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。</p>
<p>其实除了前10本之外，推荐数前30左右的书籍都算经典，笔者整理编译这个问答贴，同时摘译部分推荐人的评语。</p>
<p>下面就按照各本书的推荐数排列。</p>
<pre><code>1、《代码大全》 史蒂夫·迈克康奈尔
</code></pre>
<p>推荐数：1684</p>
<blockquote><p>“优秀的编程实践的百科全书，《代码大全》注重个人技术，其中所有东西加起来，<br>就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky<br>对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac</p></blockquote>
<p>Steve McConnell的原作《代码大全》(第1版)是公认的关于编程的最佳实践指南之一， 在过去的十多年间，本书一直在帮助开发人员编写更好的软件。</p>
<p>现在，作者将这本经典著作全新演绎，融入了最前沿的实践技术，加入了上百个崭新的代码示例， 充分展示了软件构建的艺术性和科学性。 McConnell汇集了来自研究机构、学术界以及业界日常实践的主要知识， 把最高效的技术和最重要的原理交织融会为这本既清晰又实用的指南。</p>
<p>无论您的经验水平如何，也不管您在怎样的开发环境中工作，也无论项目是大是小， 本书都将激发您的思维并帮助您构建高品质的代码。</p>
<p>《代码大全（第2版）)》做了全面的更新，增加了很多与时俱进的内容，包括对新语言、新的开发过程与方法论的讨论等等。</p>
<pre><code>2、《程序员修炼之道》
</code></pre>
<p>推荐数：1504</p>
<p>对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。 或许他们还是在校生，但对要自己做什么，还感觉不是很安全。</p>
<blockquote><p>就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，<br>但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel</p></blockquote>
<p>《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成， 涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术， 利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比， 全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。</p>
<p>无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。</p>
<pre><code>3、《计算机程序的构造和解释》
</code></pre>
<p>推荐数：916</p>
<p>就个人而言，这本书目前为止对我影响醉倒的一本编程书。</p>
<p>《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。 其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。 其他书籍则处理算法。这些书都有自己所属的位置。</p>
<p>然而《计算机程序的构造和解释》与这些不同。 这是一本会启发你的书，它会燃起你编写出色程序的热情； 它还将教会你认识并欣赏美； 它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。</p>
<p>其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。</p>
<p>同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。</p>
<p>一些人认为此书不适合新手。 个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。 毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。 此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。</p>
<pre><code>4、《C程序设计语言》
</code></pre>
<p>推荐数：774</p>
<blockquote><p>这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。 （这对理解“底层”非常重要）—— Nathan</p></blockquote>
<p>《C程序设计语言》(第2版新版)讲述深入浅出，配合典型例证，通俗易懂，实用性强， 适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。</p>
<p>《C程序设计语言》(第2版新版)原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的 一本介绍C语言的权威经典著作。 我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。 原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。</p>
<p>人们熟知的“hello,world”程序就是由本书首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。</p>
<pre><code>5、《算法导论》
</code></pre>
<p>推荐数：671</p>
<p>《代码大全》教你如何正确编程； 《人月神话》教你如何正确管理； 《设计模式》教你如何正确设计……</p>
<p>在我看来，代码只是一个工具，并非精髓。 开发软件的主要部分是创建新算法或重新实现现有算法。 其他部分则像重新组装乐高砖块或创建“管理”层。</p>
<blockquote><p>我依然梦想这样的工作，我的大部分时间（&gt;50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron</p></blockquote>
<p>经典的算法书,被亚马逊网，《程序员》等评选为2006年最受读者喜爱的十大IT图书之一。<br>算法领域的标准教材，全球多所知名大学选用<br>MIT名师联手铸就，被誉为“计算机算法的圣经”<br>编写上采用了“五个一”，即一章介绍一个算法、一种设计技术、一个应用领域和一个相关话题。</p>
<pre><code>6、《重构：改善既有代码的设计》
</code></pre>
<p>推荐数：617</p>
<p>《重构:改善既有代码的设计》清晰地揭示了重构的过程，解释了重构的原理和最佳实践方式， 并给出了何时以及何地应该开始挖掘代码以求改善。 书中给出了70多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。</p>
<p>《重构:改善既有代码的设计》提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。</p>
<p>《重构:改善既有代码的设计》适合软件开发人员、项目管理人员等阅读， 也可作为高等院校计算机及相关专业师生的参考读物。</p>
<blockquote>
<p>我想我不得不推荐《重构》：改进现有代码的设计。—— Martin</p>
<p>我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，  而优秀的程序员却能写出别人能读得懂的程序。——Martin Fowler</p>
</blockquote>
<pre><code>7、《设计模式》
</code></pre>
<p>推荐数：617</p>
<p>自1995年出版以来，本书一直名列Amazon和各大书店销售榜前列。 近10年后，本书仍是Addison-Wesley公司2003年最畅销的图书之一。 中文版销售逾4万册。</p>
<blockquote><p>就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。<br>虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，<br>因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young</p></blockquote>
<pre><code>8、《人月神话》
</code></pre>
<p>推荐数：588</p>
<p>在软件领域，很少能有像《人月神话》一样具有深远影响力并且畅销不衰的著作。</p>
<p>Brooks博士为人们管理复杂项目提供了最具洞察力的见解。 既有很多发人深省的观点，又有大量软件工程的实践。 本书内容来自Brooks博士在IBM公司System/360家族和OS/360中的项目管理经验。</p>
<p>该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄中等多种语言，全球销量数百万册。 确立了其在行业内的经典地位。</p>
<pre><code>9、《计算机程序设计艺术》
</code></pre>
<p>推荐数：542</p>
<p>《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。 这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。</p>
<p>《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。 目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。</p>
<blockquote><p>这是高德纳倾注心血写的一本书。—— Peter Coulton</p></blockquote>
<pre><code>10、《编译原理》（龙书）
</code></pre>
<p>推荐数：462</p>
<p>我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。 我从没忘过此书的第一版封面。 此书让我知道了编译器是多么地神奇绝妙。- DB</p>
<pre><code>11、《深入浅出设计模式》
</code></pre>
<p>推荐数：445</p>
<p>强大的写作阵容。</p>
<p>《Head First设计模式》(中文版) 作者Eric Freeman；<br>ElElisabeth Freeman是作家、讲师和技术顾问。<br>Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。<br>Kathy Sierra(javaranch．com的创始人)FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。<br>本书的产品设计应用神经生物学、认知科学，以及学习理论，这使得这本书能够将这些知识深深地印在你的脑海里， 不容易被遗忘。</p>
<p>本书的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。 解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。</p>
<p>作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店， 书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。</p>
<p>作者还利用歪歪斜斜的手写字体，增加“现场感”。 精心设计许多爆笑的对白，让学习过程不会太枯燥。 还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。 每一章都有数目不等的测验题。 每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。</p>
<blockquote><p>我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。 一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。-<br>Calanus</p></blockquote>
<pre><code>12、《哥德尔、艾舍尔、巴赫书：集异璧之大成》
</code></pre>
<p>推荐数：437</p>
<blockquote><p>如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。<br>他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。<br>这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik</p></blockquote>
<pre><code>13、《代码整洁之道》
</code></pre>
<p>推荐数：329</p>
<p>细节之中自有天地，整洁成就卓越代码</p>
<p>尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷， 写得不好的代码每年都要耗费难以计数的时间和资源。 然而这种情况并非无法避免。</p>
<p>著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。 Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观， 以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。</p>
<p>阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。 《代码整洁之道》促使你思考代码中何谓正确，何谓错误。 更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。</p>
<p>从《代码整洁之道》中可以学到：</p>
<p>好代码和糟糕的代码之间的区别；<br>如何编写好代码，如何将糟糕的代码转化为好代码；<br>如何创建好名称、好函数、好对象和好类；<br>如何格式化代码以实现其可读性的最大化；<br>如何在不妨碍代码逻辑的前提下充分实现错误处理；<br>如何进行单元测试和测试驱动开发。</p>
<blockquote><p>虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin</p></blockquote>
<pre><code>14、《Effective C++》和《More Effective C++》
</code></pre>
<p>推荐数：297</p>
<p>在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。 正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。</p>
<blockquote><p>去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John<br>Channing</p></blockquote>
<pre><code>15、《编程珠玑》
</code></pre>
<p>推荐数：282</p>
<p>多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。 正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力， 从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”， 成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏， 最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。</p>
<p>本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。</p>
<blockquote><p>尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren</p></blockquote>
<pre><code>16、《修改代码的艺术》by Michael Feathers
</code></pre>
<p>本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作， 而且从涵盖面和深度上都超过了前两部经典。 书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。</p>
<p>作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等）， 与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。</p>
<p>书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。 通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。</p>
<blockquote><p>我认为没有任何一本书能向这本书一样影响了我的编程观点。 它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。-<br>Wolfbyte 同意。很多开发人员讨论用干净的石板来编写软件。 但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。–<br>Bernard Dy</p></blockquote>
<pre><code>17、《编码：隐匿在计算机软硬件背后的语言》
</code></pre>
<p>这是一本讲述计算机工作原理的书。</p>
<p>不过，你千万不要因为“工作原理”之类的字眼就武断地认为，它是晦涩而难懂的。 作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。 更重要的是，你会因此而获得对计算机工作原理较深刻的理解。 这种理解不是抽象层面上的，而是具有一定深度的，这种深度甚至不逊于“电气工程师”和“程序员”的理解。</p>
<p>不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟， 都不妨翻阅一下《编码:隐匿在计算机软硬件背后的语言》，读一读大师的经典作品，必然会有收获。</p>
<blockquote><p>我推荐Charles Petzold的《编码》。 在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。<br>– hemil</p></blockquote>
<pre><code>18、《禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance》
</code></pre>
<blockquote><p>对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。<br>不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是， 要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 –<br>akr</p></blockquote>
<pre><code>19、《Peopleware / 人件集:人性化的软件开发》
</code></pre>
<blockquote><p>Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。 他们的答案并不简单，只是令人难以置信的成功。<br>第二版新增加了八章内容。 – Eduardo Molteni</p></blockquote>
<pre><code>20、《Coders at Work / 编程人生》
</code></pre>
<p>这是一本访谈笔录，记录了当今最具个人魅力的15位软件先驱的编程生涯。 包括DonaldKnuth、Jamie Zawinski、Joshua Bloch、Ken Thompson等在内的业界传奇人物，为我们讲述了 他们是怎么学习编程的，在编程过程中发现了什么以及他们对未来的看法， 并对诸如应该如何设计软件等长久以来一直困扰很多程序员的问题谈了自己的观点。</p>
<p>一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq</p>
<pre><code>21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》
</code></pre>
<p>虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。 一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511</p>
<pre><code>22、《Effective Java 中文版》
</code></pre>
<p>此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar</p>
<pre><code>23、《Patterns of Enterprise Application Architecture / 企业应用架构模式》
</code></pre>
<blockquote><p>很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol</p></blockquote>
<pre><code>24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda
</code></pre>
<p>这两本是LISP的英文书，尚无中文版。 美国东北大学网站上也有电子版。</p>
<pre><code>25、《交互设计之路》
</code></pre>
<p>英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。<br>本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。 本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。</p>
<p>作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的， 而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。 “难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。</p>
<p>本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性， 证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。</p>
<p>本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士， 以及关心软件行业和高科技行业现状与发展的人士阅读。</p>
<p>他还有另一本中文版著作：《About Face 3 交互设计精髓》</p>
<pre><code>26、《Why’s (Poignant) Guide to Ruby 》
</code></pre>
<p>如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。</p>
<pre><code>27、《Unix编程艺术》
</code></pre>
<blockquote><p>It is useful regardless operating system you use. – J.F. Sebastian<br>不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian</p></blockquote>
<pre><code>28、《高效程序员的45个习惯：敏捷开发修炼之道》
</code></pre>
<p>45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。</p>
<p>每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。</p>
<pre><code>29、《测试驱动开发》
</code></pre>
<blockquote><p>前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。 它向我展示了单元测试和TDD的重要性，并让我很快上手。 –<br>Curro 我不关心你的代码有多好或优雅。 如果你没有测试，你或许就如同没有编写代码。 这本书得到的推荐数应该更高些。<br>人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent</p></blockquote>
<pre><code>30、《点石成金:访客至上的网页设计秘笈》
</code></pre>
<p>可用性设计是Web设计中最重要也是难度最大的一项任务。 《点石成金－访客至上的网页设计秘笈（原书第二版）》作者根据多年从业的经验，剖析用户的心理， 在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点， 并给出了大量简单、易行的可用性设计的建议。</p>
<p>本书短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表， 使枯燥的设计原理变得平易近人。</p>
<p>本书适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。 这是一本关于Web设计原则而不是Web设计技术的书。</p>
<p>本书作者是Web设计专家，具有丰富的实践经验。 他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时， 你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。</p>
<blockquote><p>取决于你所追求的目标。 我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard</p></blockquote>
<p>文章来源：<a href=""http://news.cnblogs.com/n/125826/"" rel=""nofollow noreferrer"">http://news.cnblogs.com/n/125...</a></p>

                ", 一个合格的程序员应该读过哪些书,1531978016,321,1,991,1,1,https://segmentfault.com/a/1190000000653370
116,1,0,9,"
                    
<p>本文出自 8/23 哪上班主办的「比代码更重要的事」程序员大会现场演讲</p>

<p><a rel=""nofollow"" href=""http://weibo.com/lazyseq"">江宏</a><br>
AVOS Cloud CEO&amp;Co-founder，耶鲁大学 PhD</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcTGa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>我其实没有什么成功的经验可以分享，只讲一讲过去个人职业选择方面相关的一些历史。我相信这里很多人都会上知乎，上面有很多关于职业选择的问题，比如说我是应该留学还是应该呆在国内，我是进创业公司还是大公司，我是应该去百度还是腾讯，其实这些问题对每个人都有不同的答案，只有自己给自己的答案是最好的，之所以有那么多的问题，因为有很多人没有花足够的时间了解自己，所以古希腊的哲人会说「人生最困难的一件事是了解自己」。</p>

<p>我本科毕业之后去了耶鲁大学学习，一段时间之后我看到别的的同学似乎都有着非常明确的兴趣和方向，很多人开始对某一个课题做深入的研究。而我好像对各个领域都很感兴趣，当时我们系有四大方向：科学计算、人工智能、程序设计语言、还有计算理论。我除了对科学计算以外的所有东西都非常感兴趣，所以我有一次发邮件给我的导师，我提到我一个很大的问题是不够专注，因为我现在还不知道我博士论文往哪个方面深入下去。后来我的导师给我回信说「我不觉得这是一个很大的问题，事实上很多人的问题是他们专注的太早」。后来回想起这句话觉得非常有道理。</p>

<p>我很小的时候开始学习计算机编程，我高中和大学的时候，很多同学羡慕我，因为我很早就找到了自己的兴趣，很早知道自己将来做什么，但这其实未必是一件好事。因为很多人花时间扩展知识面的同时，我把很多的时间花在某一个方面。我后来发现自己的知识结构有所欠缺的时候，需要花更多的努力去弥补，应该说在每个阶段应该做适合于那个阶段的事情，没有必要急着让自己进入下一阶段。</p>

<p>后来在耶鲁的五年大部分时间是很闲适的，对什么感兴趣就看那方面的书，做一些研究，看一些论文。每周只跟我的导师见一次面，在耶鲁的一个咖啡馆，两个人在那儿喝咖啡，讨论一些这一周以来比较有意思的一些问题，有的时候觉得需要在纸上做一些推导进行一些证明，就会密密麻麻地写在咖啡馆的餐巾纸，然后带回去。</p>

<p>后来我快毕业的时候，决定要回国，有两方面的原因，一个是家庭方面，因为我希望离父母家人近一点，另外当时觉得待在美国很无聊。我后来比较喜欢跟人打一个比方，如果在美国任何一个城市的一个十字路口，拍一张照片，十年以后回到那里还是一模一样，看不到任何变化。但是中国的变化很快，我个人更愿意生活这样的地方。所以我初步决定回国，但是不知道干什么。毕业以前的一个暑假我回国做了三个月的实习，实习完之后有点更迷茫，因为那段时间里没有在国内找到自己想要做的事。后来就回了耶鲁，收到了一个在 Google 的朋友的邮件向我索取简历，后来我知道谷歌的员工每推荐成功一个工程师会有四千美元的奖励。几周之后我通过了面试，拿到了 Google 的 offer，就决定去 Google 了。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcTGb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""3377-444a4873baf44057.jpg""></span></p>

<p>Google 是一家有着很好文化的公司，我在知乎回答过两个问题，一个是 <a rel=""nofollow"" href=""http://www.zhihu.com/question/24290336/answer/28695711"">在谷歌工作是怎样的一番体验？</a>，另外一个是 <a rel=""nofollow"" href=""http://www.zhihu.com/question/22039991/answer/28942373"">为什么从谷歌离职？</a> 如果大家到 <a rel=""nofollow"" href=""http://google.com/"">google.com</a> ，可以找到一个介绍企业文化页面是「Ten things we know to be true」，其中可能最有名的一条是「You can make money without doing evil.」，也就是通常说的「Don’t Be Evil」。这句话被写到了 Google IPO 提交的 S-1 文件中。很多互联网公司说要向谷歌学习文化，但很少有人真正学到的，我觉得文化应该是定义一个企业的东西，它应该会影响到企业的商业行为，影响到这个企业里面每一个人的工作方式和价值观。所以免费午餐、在办公室养狗养猫、放台球桌和桌面足球，这些都是好的福利，但不是文化。往头上浇冰水也不是文化。</p>

<p>虽然 Google 很好，但我在 Google 的时候已经有一万六千名员工，我在那么大的公司很难有归属感。Google 有很多非常优秀的人才，但是和其他大公司一样也有很多可以说在混日子的人 --- 据我所知，在 Google 很少有因为 performance 原因解雇人的。而 Google 内部团队之间也有很大的差别，我自己在工作中需要跟很多团队打交道。在一个公司中，个体的差异非常大。</p>

<p>另外大家可能觉得 Google 里面有很多非常新奇的项目，像自动驾驶汽车等等。其实这些只是一小部分。并且在我那个时候还没有这些项目，那时的新项目是 Chrome 和 Android。大部分支撑整个企业、能产生利润的项目：像搜索、广告等都是有很长历史的老项目。我所在团队负责的项目差不多有十年的历史，最早是一个 Python 程序，后来用 C 重写，再后来变成一个 C++ 的项目，最后我们为了让对 C++ 不是很熟的人可以加新功能而嵌入了 Python 解释器。当时 GCC 编译不了那个项目，会因为内存不够而崩溃，所以我们用的是修改过的 GCC。我们用全公司最好的 workstation 编译项目需要 30-40 分钟，后来使用分布式编译缩短到 5-10 分钟，但是效率依旧很低。可以想象一下，做完一些改动，按下回车，接下来就可以去茶水间吃点东西，喝杯果汁再来看结果。通常人们会说软件开发中要为人优化，而不是为机器优化，如果一个工程师花一整天的时间，把原来一毫秒的操作变成半毫秒，往往是不太值得的。但以 Google 的规模，这样的优化是很值得的。所以 Google 很愿意雇优秀的工程师负责做看起来很小的改进，因为每个优化都可以为公司节省很多钱。但是对于个人来说，生命就是那么长，愿意如何分配宝贵的时间，答案跟 Google 多半是不一致的，所以在谷歌工作三年以后，我就决定要么回国加入一家小公司，要么自己创业。</p>

<p>在美国这八年是我发现和了解自己的过程。我回国的时候，很多朋友挺惊讶的，很大的原因是我当时在美国再待几个月或一年就可以拿到绿卡。如果理性地去想这件事情，很多事情是对别人是有价值的，但对自己来说未必有价值。我认识很多朋友，已经长期生活在国内，但是为了维护美国绿卡的状态，每半年或者每年要飞回去一次，其实可能并不是明智的。还有个例子是北京户口，据说换算成钱可以值六七十万了，它对希望长期在北京生活的人有价值，对其他人是没有价值的。有朋友已经离开北京很多年，生活在其他城市，也没有计划回来，但还是不舍得放弃北京户口，每次办什么事情还要回来北京，并不值得。</p>

<p>回国之后也有很多有意思的经历可以分享，因为时间关系不讲了，只简单总结一下几点建议。第一是每一个人都要花足够的时间了解自己，因为在人生和职业选择上没有别人可以给更好的答案，人生不是一场竞赛，几十年之后大家的结局都是一样的，最重要的是做自己想做的事。第二是做选择应该基于独立思考，父母、同事、朋友都有可供参考的意见，但是最终需要自己判断。第三要把时间和精力投入到自己认为有价值的事情上，而不是别人认为有价值的事情上。最后，创造或加入一家好公司，我这里说的好公司跟商业上的成功没有直接关系，就像好人不一定有钱一样。但是我相信好的公司更容易取得长期的成功，并且做一家好的公司本身应该是一个目的而不是一个方法。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcTGc"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""3377-11d2563755f566dc.jpg""></span></p>

<p>最后，如果你还在寻找一家好的公司的话，我介绍一下我们自己，我们是 <a rel=""nofollow"" href=""https://cn.avoscloud.com/"">AVOS Cloud</a> ，我们的产品是为移动应用提供后端服务，如果你是移动应用开发者，只需要开发前端手机 app 部分，所有对后端的需求都可以由 <a rel=""nofollow"" href=""https://cn.avoscloud.com/"">AVOS Cloud</a>  满足，还有我们的 <a rel=""nofollow"" href=""https//blog.avoscloud.com/"">博客</a> ，及一个 <a rel=""nofollow"" href=""https//open.avoscloud.com/"">开放资源</a>  网站，我们开放了我们的很多内部信息，包括我们的薪酬。如果你要应聘一个职位，可以到这里直接算出薪酬会是多少。</p>

<p>谢谢大家。</p>

<p><strong>现场提问</strong></p>

<p><strong>提问：刚才也提到要创造或者加入一家好的公司，请问一下你是怎么定义一家好的公司的？</strong><br>
江宏：可以用一句话定义一家好的公司。如果你在一家好的公司工作的话，如果你很认真地很好地完成了工作，好的事情应该会发生在你自己、这个公司、这个公司的投资人、用户身上。如果少了任何一点这家公司都不是一家好公司，首先个人的贡献要得到承认和奖励，做的事情要是可以为公司和投资人创造收益的，公司的业务要是对社会有益的。</p>

<p><strong>提问：江老师您好，您刚才讲的这些基于个人选择的一些自己的建议，我相信您应该是在这方面遇到问题所以才有这方面的思考，刚才讲到发现和认识自己，根据您的经验有没有具体的一些方法和行动的实践过程？</strong></p>

<p>江宏：我觉得其实没有什么特别具体的方法，每个人比较年轻的时候都会有很多不同的想法，需要去做一些尝试。比如说我本科的时候没有想一定要创业，那个时候我有很多想法，其中包括想要在学术上面有所成就，想成为一个出色的计算机科学家，同时也想过要创业，成为 Bill Gates 那样的人。年轻的时候梦想很多，需要有足够的时间让自己去做一些尝试，才能更好认识自己。举个例子，之所以我后来没有做学术，是因为我在耶鲁的时候确实用了五年做学术研究，并且有一个很好的导师。这个过程中我感到自己并没有足够的兴趣长期坚持学术工作，另外我觉得在学术上要有所成就真的需要有一定天赋，我认为我达不到我导师那样的水平，所以后来追随自己的热情走了别的路。我觉得就是需要有足够的时间让自己做不同的尝试。</p>

                ", 去不去 Google ？Ex-Googler 讲述他的职业选择,1531978017,421,1,698,1,1,https://segmentfault.com/a/1190000000651661
117,1,0,9,"
                    
<p>草泥马语是马勒戈壁第一款拥有自主知识产权的，以马勒戈壁上顽强生存的草泥马们为主体的编程语言。草泥马语语法生动丰富，内容健康活泼，是一门老少皆宜，人人适用的编程语言。它的出现弥补了我戈壁在国际编程语言界中的一项空白。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcHQ4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""oreilly草泥马书""></span></p>

<p>草泥马语是用了先进的JOT（Just Out of Time）编译引擎，并且运行于爪哇虚拟机中，运行速度大幅度降低同时，还使用了戈壁内外各种先进技术，使的草泥马语不十分可靠。</p>

<p>《草泥马语》是一个基于堆和栈的编程语言，该语言的最大特点在于：所有操作全由“草”“泥”“马”“河蟹”这4个命令完成，文件内的其他字符都作为注释而不参与程序执行。</p>

<p>另外，由于草泥马语言形式过于震撼，所以为了调试，编写了草泥马语逆编译器：gmhd 可以吧草泥马语言代码反编译成比较好懂的伪代码。<br><br></p>

<h2>《草泥马语》的语言规范</h2>

<p>草泥马语是一款根据国外同类型语言“Whitespace”改编（替换关键字）而成的全新的编程语言，执行时使用“草泥马”的不同组合实现不同功能。</p>

<blockquote>
  <p>PS: 可以先看Whitespace语言入门，然后吧其中的[Space]替换成草；[Tab]替换成泥；[LF]替换成马就可以了解草泥马语的大致用法了。</p>
</blockquote>

<p>每个指令都有3部分组成，包括指令头，指令和可选的操作数</p>

<h3>指令头</h3>

<p>草泥马语的指令头说明了指令的类型，列表如下：</p>

<table>
<thead><tr>
<th>指令头</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草]</code></td>
  <td>栈操作</td>
  <td>Stack Manipulation</td>
</tr>
<tr>
<td><code>[泥][草]</code></td>
  <td>数学运算</td>
  <td>Arithmetic</td>
</tr>
<tr>
<td><code>[泥][泥]</code></td>
  <td>堆操作</td>
  <td>Heap access</td>
</tr>
<tr>
<td><code>[马]</code></td>
  <td>流程控制</td>
  <td>Flow Control</td>
</tr>
<tr>
<td><code>[泥][马]</code></td>
  <td>输入输出</td>
  <td>I/O</td>
</tr>
</tbody>
</table>
<h3>栈操作指令 <code>[指令头：草]</code>
</h3>

<p>栈用来存储指令调用的参数和结果，元素仅限整数，栈高度不限。</p>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草]</code></td>
  <td>Number</td>
  <td>把某个数压栈</td>
  <td>Push the number onto the stack</td>
</tr>
<tr>
<td><code>[马][草]</code></td>
  <td>-</td>
  <td>复制栈顶元素</td>
  <td>Duplicate the top item on the stack</td>
</tr>
<tr>
<td><code>[泥][草]</code></td>
  <td>Number</td>
  <td>复制第n个元素到栈顶</td>
  <td>Copy the nth item on the stack (given by the argument) onto the top of the stack</td>
</tr>
<tr>
<td><code>[马][泥]</code></td>
  <td>-</td>
  <td>交换栈顶两个元素的位置</td>
  <td>Swap the top two items on the stack</td>
</tr>
<tr>
<td><code>[马][马]</code></td>
  <td>-</td>
  <td>销毁栈顶元素</td>
  <td>Discard the top item on the stack</td>
</tr>
<tr>
<td><code>[泥][马]</code></td>
  <td>Number</td>
  <td>销毁栈顶的n个元素，但保持栈顶</td>
  <td>Slide n items off the stack, keeping the top item</td>
</tr>
</tbody>
</table>
<h3>数学运算指令 <code>[指令头：泥草]</code>
</h3>

<p>注意，草泥马语没有浮点运算，但是整数运算的精度是无限的。 操作规则：操作时先弹出一个栈元素为运算的右值，再弹出一个为左值，计算后将结果压栈。</p>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草][草]</code></td>
  <td>-</td>
  <td>加</td>
  <td>Addition</td>
</tr>
<tr>
<td><code>[草][泥]</code></td>
  <td>-</td>
  <td>减</td>
  <td>Subtraction</td>
</tr>
<tr>
<td><code>[草][马]</code></td>
  <td>-</td>
  <td>乘</td>
  <td>Multiplication</td>
</tr>
<tr>
<td><code>[泥][草]</code></td>
  <td>-</td>
  <td>除</td>
  <td>Integer Division</td>
</tr>
<tr>
<td><code>[泥][泥]</code></td>
  <td>-</td>
  <td>取模</td>
  <td>Modulo</td>
</tr>
</tbody>
</table>
<h3>堆操作 <code>[指令头：泥泥]</code>
</h3>

<p>与栈一样，堆也只能存储整数，草泥马虚拟机(AlpacaVM)最多支持65536个堆元素（0-65535），但是堆元素的大小不限制。</p>

<p>堆操作的规则：如果要存储，要先将要操作的堆地址压栈，再把要存储的数压栈，操作时弹出栈顶两元素，将栈顶元素存储到次栈顶指示的堆空间中；如果要取出，要先将地址压栈，操作时弹出栈顶元素，根据其指示的地址取出堆中元素压栈。</p>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草]</code></td>
  <td>-</td>
  <td>存储栈顶元素x到堆地址为y的空间中，y是次栈顶元素</td>
  <td>Store</td>
</tr>
<tr>
<td><code>[泥]</code></td>
  <td>-</td>
  <td>先把y压栈,然后获取堆中地址为y空间的元素到栈顶</td>
  <td>Retrieve</td>
</tr>
</tbody>
</table>
<h3>流程控制 <code>[指令头:马]</code>
</h3>

<p>标记一个程序点可以用来进行跳转或者函数调用，标记是一个任意长度的无符号整数，每个草泥马文件中，标记应该是唯一的，并且所有调用的标记应当存在。</p>

<p>注意:河蟹这个指令仅仅在河蟹这两个字连在一起时有效，分开是没有效果的。（注意更正一个歧义表达，河蟹这个指令是没有指令头的。）</p>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草][草]</code></td>
  <td>Label</td>
  <td>定义一个标记</td>
  <td>Mark a location in the program</td>
</tr>
<tr>
<td><code>[草][泥]</code></td>
  <td>Label</td>
  <td>调用标记指示的函数</td>
  <td>Call a subroutine</td>
</tr>
<tr>
<td><code>[草][马]</code></td>
  <td>Label</td>
  <td>无条件跳转到标记处</td>
  <td>Jump unconditionally to a label</td>
</tr>
<tr>
<td><code>[泥][草]</code></td>
  <td>Label</td>
  <td>如果栈顶元素等于0则跳转到标记指示处</td>
  <td>Jump to a label if the top of the stack is zero</td>
</tr>
<tr>
<td><code>[泥][泥]</code></td>
  <td>Label</td>
  <td>如果栈顶元素小于0则跳转到标记指示处</td>
  <td>Jump to a label if the top of the stack is negative</td>
</tr>
<tr>
<td><code>[泥][马]</code></td>
  <td>-</td>
  <td>函数结束，返回调用处</td>
  <td>End a subroutine and transfer control back to the caller</td>
</tr>
<tr>
<td><code>[马][马]或者[河蟹]</code></td>
  <td>-</td>
  <td>无条件结束程序运行</td>
  <td>End the program</td>
</tr>
</tbody>
</table>
<h3>IO 控制 <code>[指令头：泥马]</code>
</h3>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
  <th>鸟语说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>[草][草]</code></td>
  <td>-</td>
  <td>弹出栈顶数字作为字符输出到标准输出</td>
  <td>Output the character at the top of the stack</td>
</tr>
<tr>
<td><code>[草][泥]</code></td>
  <td>-</td>
  <td>弹出栈顶数字以数字形式输出到标准输出</td>
  <td>Output the number at the top of the stack</td>
</tr>
<tr>
<td><code>[泥][草]</code></td>
  <td>-</td>
  <td>从标准输入内读取一个字符（回车结束)并且放到栈顶(弹出)所对应的堆空间</td>
  <td>Read a character and place it in the location given by the top of the stack</td>
</tr>
<tr>
<td><code>[泥][泥]</code></td>
  <td>-</td>
  <td>从标准输入内读取一个数字并且放到栈顶(弹出)所对应的堆空间</td>
  <td>Read a number and place it in the location given by the top of the stack</td>
</tr>
</tbody>
</table>
<h3>如何定义操作数</h3>

<p>操作数的定义是二进制的整数，对于流程控制指令来说是无符号的，否则是有符号的，第一位为符号位。 定义方法是：草为0;泥为1;马代表定义结束。对于符号位，草为正，泥为负。</p>

<h3>举个例子吧</h3>

<p>这是个例子，输出1到10十个数，具体解释请看下面。</p>

<pre><code>草草草泥马 马草草草泥草草草草泥泥马 草马草 泥马草泥 草草草泥草泥草马 泥马草草 草草草泥马 泥草草草 草马草 草草草泥草泥泥马 泥草草泥 马泥草草泥草草草泥草泥马 马草马草泥草草草草泥泥马 马草草草泥草草草泥草泥马 草马马 马马马
</code></pre>

<p>写出来大概就是这个样子，下面是一个从1到10的循环：</p>

<table>
<thead><tr>
<th>指令</th>
  <th>操作数</th>
  <th>说明</th>
</tr></thead>
<tbody>
<tr>
<td><code>草-草 草泥马</code></td>
  <td>数字1压栈</td>
  <td>Put a 1 on the stack</td>
</tr>
<tr>
<td><code>马-草草 草泥草草草草泥泥马</code></td>
  <td>在这里设置一个循环开始的标识</td>
  <td>Set a Label at this point</td>
</tr>
<tr>
<td><code>草-马草</code></td>
  <td>复制栈顶元素</td>
  <td>Duplicate the top stack item</td>
</tr>
<tr>
<td><code>泥马-草泥</code></td>
  <td>输出当前值</td>
  <td>Output the current value</td>
</tr>
<tr>
<td><code>草草 草泥草泥草马</code></td>
  <td>换行(10)压栈</td>
  <td>Put 10 (newline) on the stack...</td>
</tr>
<tr>
<td><code>泥马-草草</code></td>
  <td>输出</td>
  <td>...and output the newline</td>
</tr>
<tr>
<td><code>草草 草泥马</code></td>
  <td>1压栈</td>
  <td>Put a 1 on the stack</td>
</tr>
<tr>
<td><code>泥草-草草</code></td>
  <td>相加栈内两个元素</td>
  <td>Addition. This increments our current value.</td>
</tr>
<tr>
<td><code>草-马草</code></td>
  <td>复制栈顶以便比较</td>
  <td>Duplicate that value so we can test it</td>
</tr>
<tr>
<td><code>草-草 草泥草泥泥马</code></td>
  <td>11压栈</td>
  <td>Push 11 onto the stack</td>
</tr>
<tr>
<td><code>泥草-草泥</code></td>
  <td>相减，如果我们已经循环到11了应该会得到一个0到栈顶</td>
  <td>Subtraction. So if we've reached the end, we have a zero on the stack.</td>
</tr>
<tr>
<td><code>马-泥草 草泥草草草泥草泥马</code></td>
  <td>如果是0，跳到最后</td>
  <td>If we have a zero, jump to the end</td>
</tr>
<tr>
<td><code>马-草马 草泥草草草草泥泥马</code></td>
  <td>跳到开始</td>
  <td>Jump to the start</td>
</tr>
<tr>
<td><code>马-草草 草泥草草草泥草泥马</code></td>
  <td>设置一个标签标识循环结束</td>
  <td>Set the end label</td>
</tr>
<tr>
<td><code>草-马马</code></td>
  <td>清空堆栈，打扫卫生，整理整顿</td>
  <td>Discard our accumulator, to be tidy</td>
</tr>
<tr>
<td><code>河蟹</code></td>
  <td>正如其言</td>
  <td>Just as it says.</td>
</tr>
</tbody>
</table>
<p><br></p>

<hr>
<p>via <a rel=""nofollow"" href=""http://code.google.com/p/grass-mud-horse/"">草泥马语</a></p>

                ", 编程语言中的精品——草泥马语,1531978019,268,1,586,1,1,https://segmentfault.com/a/1190000000606169
118,1,0,9,"
                    
<p><aside class=""aside""><br><span class=""img-wrap""><img data-src=""http://yedingding.com/images/write-the-code-change-the-world/WWDC14.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""WWDC 2014""></span><br></aside></p>

<p>""Write the Code. Change the world."", 这个标题是苹果这个月的 WWDC 上的宣传语，看得我很激动，也相信每一个耐不住寂寞的开发者内心里都会有这样的冲动。最近一两年间，越来越多的人开始把编码能力跟读写能力做比较，呼吁每个人都应该去学习编程序，认为这是以后每个人都需要掌握的基础技能。与之同时，黑客马拉松在国内也迅速的火起来，参加过几次，跟一群年轻人聚集在一起，交流想法并付诸于实践，在一个周末完成一个作品，每每想起都是段非常愉悦的经历。</p>

<p>六一应 <a rel=""nofollow"" href=""http://segementfault.com"">SegmentFault</a><sup><a href=""#fn:1"" rel=""nofollow noreferrer"" class=""footnote-ref"">1</a></sup> 高阳邀请，在其两周年黑客马拉松活动中作为技术创业者的代表，做一个分享。虽然作为创业者分享经验很不够格，不过这两年做风车下来也的确有一些想法，另外通过 <a rel=""nofollow"" href=""http://teahour.fm"">Teahour</a> 从不少创业者那里学到了很多，所以也就在活动上做了一次简短的即兴演讲，刚好跟 『Write the Code. Change the world』有点关联。</p>

<p>SegmentFault 的使命是『创造属于开发者的时代』，我个人很喜欢这个远景，很美好。作为开发者，处在现在这个时代，我们是幸运的。我记得我 06 年的时候第一次跟朋友创业做互联网产品，当时什么东西都要自己去管，比如要自己买服务器、找 IDC 托管、产品开发中如果需要用什么服务都要自己做，真的是很讨厌，既浪费时间又浪费精力。而现在呢，相比较起来我们去制作一个产品的成本已经很低了，一个团队，三个月时间迅速开发原型，云主机用 UCloud 之类，文件存储用又拍云，发邮件用 SendCloud，还有各种开放平台等等。所以，作为一个开发者，作为一个会写代码的人<sup><a href=""#fn:2"" rel=""nofollow noreferrer"" class=""footnote-ref"">2</a></sup>，我们有个很大的优势，就是就算整个世界抛弃了你，你还是能一个人去把产品开发出来，启动成本很低。</p>

<p>但是，是否启动成本低，我们就应该甩开膀子干呢？千万别，思考清楚了，宁愿在真正开始做事情前多花时间思考。我在去年曾经写过一篇文章<a rel=""nofollow"" href=""http://yedingding.com/2013/10/11/how-to-find-tech-cofounder.html"">『如何吸引技术合伙人』</a>，其中很关键的两点是看对方是否对 idea 有足够的认识以及是否有 traction 可以验证。换位思考，我们自己创业时，也应该如此，多思考，好的坏的都要思考。</p>

<p>去年中国 Ruby 大会上，Kevin Dewalt 曾经做过一次非常精彩的演讲 <a rel=""nofollow"" href=""http://www.infoq.com/cn/presentations/combination-ror-and-better-startup-strategy-in-business"">『How to Use Rails and Ruby to validate your Startup idea』</a>，他认为，一个产品的成功，在一开始就得思考这三个问题。</p>

<ol>
<li>
<strong>Problem - 问题？</strong>. 你是否在解决一个真正的问题？你需要从第一天开始就去验证你的假设，这需要你去做产品定位和采访潜在用户。在没有找到这个答案之前，做其它任何的都是徒劳的。</li>
<li>
<strong>Revenue - 会买？</strong>. 我们得考虑商业价值，也就是人们是否愿意花钱解决这个问题？不管你在解决多少实际的问题，但是如果多数用户还是宁愿忍受这个问题也不愿意花钱买解决方案，那还是不值得做，得慎重。</li>
<li>
<strong>Channel - 怎么卖</strong>. 你有没有一个有效的渠道去推到愿意花钱解决这个问题的人？问题就在那里，也有足够的人愿意付钱，最后就是问问你能否推广到这个群体去，同时还能有盈利。如果你的推广成本大于你的收入，那么还是没法做。</li>
</ol>
<p>所以，如果你要开始一个项目，问自己这三个问题。思考清楚后，追随你的内心，做出选择，奋力向前。</p>

<p><aside class=""aside""><br><span class=""img-wrap""><img data-src=""http://yedingding.com/images/write-the-code-change-the-world/maslow-hierarchy-of-needs.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Maslow 5 层需求模型""></span><br></aside></p>

<p>我那篇文章有个读者曾问过我，如果是我自己，创业最想得到的是什么。我的回答是，能自己主导做一些真正有社会价值的事，并且经济回报有盼头。我不是圣人，所以不否认是有物质的追求在，但是理想层面上的精神追求会更多点。马斯洛在其基本五层需求模型理论中指出，人类最底层的是衣食住行等生理需求，上一层是安全上的需求，第三层是作为社会群体在社交上的需求，第四层是尊重的需求，最上层是自我实现的需求，一种创造的需要。如果我们是工作的话，生理需求和安全需求会很容易满足。然后是社交需求、尊重需求的满足，最后我们才会考虑自我实现。但是创业不同，我认为创业是直接跳过了下面的四层，更多的是在追求自我实现的需求，去实现自己的理想和目标，所以愿意在一定时间内放弃自己的一些下层需求。</p>

<p>我们都知道，创业成功的几率是非常小的，100 个项目里面有 90 个是失败的，有 8 个不失败但是也就那样，只有 2 个是非常成功的。Scott Shane<sup><a href=""#fn:3"" rel=""nofollow noreferrer"" class=""footnote-ref"">3</a></sup> 在其著名畅销书 <a rel=""nofollow"" href=""http://www.amazon.com/The-Illusions-Entrepreneurship-Entrepreneurs-Investors/dp/0300158564"">『The Illusions of Entrepreneurship』</a> 就披露了很多关于创业者的黑暗事实，比如大多数创业公司会在 5 年内倒闭，大多数创业者比他工作的时候收入要低，大多数创业者收入不稳定，大多数创业者工作时间比工作要更长。理想很美好，现实很残酷，但是即使知道这些，我们是否就会失去创业的勇气？不！因为我们都有那么一点小理想，我们在追求自我实现，所以不如让我们姑且忘掉未来的成败，而是专注在成长和价值的提高上。而且，即使失败率如此之高，我们还是有办法来降低，比如更好的利用时间，更高效的做事，这也是我为啥坚持做风车的原因，风车本质上就是高效任务管理工具，让你们更好的成长，因为时间管理说白了到最后就是任务管理。</p>

<p><aside class=""aside""><br><span class=""img-wrap""><img data-src=""http://yedingding.com/images/write-the-code-change-the-world/feature-usage.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Feature Usage""></span><br><br><small>Source: Standish Group, Feature usage of software projects</small><br></aside></p>

<p>对于大多数技术创业者来说，也许基本只有时间成本，可是时间对我们来说是一个非常昂贵的东西，所以要学会合理地利用时间和资源。钱是赚不完的，但是时间过了就找不回来了，这也是为什么我们要时刻提醒自己要专注在核心价值的地方。这并不是说我们应该工作的更努力，工作的时间应该要更长，而是努力用最小的时间去换取最大的价值。如果不是自己的产品价值，那么就不需要做，勇于对用户说不，价值少的可以考虑让第三方来做等等。Standish Group<sup><a href=""#fn:4"" rel=""nofollow noreferrer"" class=""footnote-ref"">4</a></sup> 曾在 2002 年做过一次市场调查，对于一个软件产品，平均竟然有 64% 的功能是用户从来不用或者很少用到的，而经常用到的只有 20%。所以，不要浪费时间精力去做那 64%！同时，比起不停的埋头开发，要不停的去了解用户，与用户沟通，保持改进，提高客户满意度，这些都是可以让我们降低失败率的手段。</p>

<p>最后，以我自勉的几个字做结尾：『勿忘初心，但行好事，莫问前程』。</p>

<p>PS：本文发表于我的个人博客，<a rel=""nofollow"" href=""http://yedingding.com/2014/06/24/write-the-code-change-the-world.html"">http://yedingding.com/2014/06/24/write-the-code-change-the-world.html</a>。我会在博客分享技术、创业、团队协作和项目管理上的思考，欢迎订阅。</p>

<div class=""footnotes"">
<hr>
<ol>
<li>
<p>SegementFault 是国内最活跃的黑客马拉松组织者。 <a href=""#fnref:1"" rel=""nofollow noreferrer"" class=""footnote-backref"">↩</a></p>
</li>

<li>
<p>现在学编程的门槛已经很低了，只要愿意并且投入时间就可。Udemy 上有不少非常好的课程，一般人我不告诉他。 <a href=""#fnref:2"" rel=""nofollow noreferrer"" class=""footnote-backref"">↩</a></p>
</li>

<li>
<p>Scott Shane 是创业研究领域的著名学者、凯思西储大学管理学院教授，也是一位投资人。 <a href=""#fnref:3"" rel=""nofollow noreferrer"" class=""footnote-backref"">↩</a></p>
</li>

<li>
<p>Standish Group 是美国专门从事跟踪 IT 项目成功或失败的权威机构，它每年会发布一个 CHAOS Report，给出IT项目相关调查数据结果。 <a href=""#fnref:4"" rel=""nofollow noreferrer"" class=""footnote-backref"">↩</a></p>
</li>

</ol>
</div>

                ", Write the code. Change the world.,1531978021,282,1,389,1,1,https://segmentfault.com/a/1190000000587162
119,1,0,9,"
                    
<p>去年秋天我的<a rel=""nofollow"" href=""https://github.com/jeresig"">支线代码项目</a> 遇到了一些问题，项目进展不足，而且我没法找到一个完成更多代码的方法（在不影响我在<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469838"">Khan Academy</a>方面的工作的前提下）。</p>

<p>我主要在周末进行我的支线，当然有时候也在晚上进行。这个方法对我而言效果不佳。我的压力太重了，我需要在周末努力完成尽可能多的工作（如果没做到，我会为此感到挫败）。还有一个问题是我无法保证每个周末都有空，而且我也不想把周末所有的时间都花在编程上（失去一切放松娱乐的机会）。</p>

<p>此外，每隔一周进行编码的话，间隙太长了。太容易忘记你正在做什么，或者你还需要做什么了（即使你有笔记）。如果你错过了一个周末的话，问题就更严重了，间隔一下子变成两周了。多周的上下文切换可能是致命的（我有很多支线项目因为这类注意力缺乏而死亡了）。</p>

<p><a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469637"">Jennifer Dewalt</a> 去年通过在 180 天创建 180 个网站的方式来自学编程，她的做法启发了我。我决定采用一个简单的策略：每天编码。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/SsevWYY.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>我决定为自己定下一些规则：</p>

<ol>
<li>每天必须写代码。我可以写文档、写博客或者写其他东西，但是这些不能代替写代码。 </li>
<li>代码必须是实际起作用的。调整缩进、重新排版不算。如果有可能，重构也不算。（可以进行这些事情，但这些不能是一天唯一的编码。） </li>
<li>所有代码必须在午夜之前完成。 </li>
<li>代码必须是开源的，放在Github上。</li>
</ol>
<p>有些规则比较武断。比如代码其实不用在午夜前写完的。但我担心熬夜导致代码质量下降。同样，代码也不用开源，或者放在GitHub上。我这么做是想强迫自己写代码的时候上点心（考虑可读性，同时较早地考虑模块化）。</p>

<p>到目前为止这个策略很有效。我基本保持了20周的连续工作。我之所以写这篇博客，正是因为它完全改变了我编写代码的方式，更重要的是影响了我生活和心智。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb8mG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这个习惯的改变产生了一些有趣的结果：</p>

<p><strong>最小可行的编码。</strong> 我强迫自己每天花不少于半个小时来写代码（如果少于这个时间就很难写出有价值的代码了，特别是回忆前一天写了什么还要花一点时间）。工作日的时候我有时写得多一点（一般不超过一个小时），周末我有时整天写代码。</p>

<p><strong>写代码成为习惯。</strong> 值得一提的是我并不是特别在乎上面的Github图形。我觉得这是这个实验最值得借鉴的一点：这是你为自己做的一个改变，而不是为了满足别人对你工作的评价。节食和锻炼也是一个道理：如果你不在乎提升自己，那么你永远都不会取得成功。</p>

<p><strong>与焦虑作斗争。</strong> 在开始这个实验之前，我时常为没有完成足够的工作或取得足够进展而感到焦虑（工作和进展都难以量化，因为我的支线项目没有死限）。我意识到，感觉到进展和实际推进工作同样重要。这令我大开眼界。一旦我每天持续地推进项目，我的焦虑就开始消散了。我对自己的工作量很心安，我再也没有那种难以承受的渴望，想要疾风骤雨式地推进项目的渴望。</p>

<p><strong>周末。</strong> 以前，在周末完成工作绝对是前进的关键动力（因为通常而言这是我唯一大量推进支线项目工作的机会。）现在情况不一样了——这是件好事。期望在一个周末完成一周的所有工作只会让我失望。我极少很完成工作，因此为了完成更多工作而拒绝了其他喜欢的周末活动（例如吃 dim sum，参观博物馆，去公园游玩，陪伴我的伴侣等）。我深深地感到，虽然支线项目是非常重要的，但是它们不应该是生活的全部。</p>

<p><strong>后台处理。</strong> 每天编写支线项目代码的一个有趣的副作用是你当前的任务时常在你大脑的后台运行。因此当我去散步或沐浴的时候，或者进行其他不费脑的活动的时候，我在思考我接下来将做哪些编码，寻找解决问题的好方法。我以前一周或两周编码一次的时候可不是这样。当时时间被花费在思考其他一些事情上，通常是在为没法完成任何支线项目而感到焦虑。</p>

<p><strong>上下文切换。</strong> 拾起支线项目工作的时候总会有上下文开销的。很不幸，重拾整整一周前的思考是极其困难的。每天做一点对此很有帮助，因为间隔时间大大缩短了，让我很容易想起在做什么。</p>

<p><strong>平衡工作。</strong> 这个改变最重要的方面之一是我已经简单地学会了如何更好地平衡工作、生活和支线项目。我知道自己每天都要做支线项目，因此我需要更好地管理时间。如果我计划晚上出去，并且很晚才能回家，那么我需要在早上为支线项目工作，在开始为我主业Khan Academy工作之前。同样的，如果我在外面，而我还没有完成我的工作，时间已经很晚了，那么我需要尽快赶回家去完成工作（以免错过一天）。我需要指出的是我发现自己把更少的时间花在爱好上了（例如木版画），但是这是一个合理的代价，我得接受这个。</p>

<p><strong>对外沟通。</strong> 跟外界沟通自己的新习惯是很有好处的。我的伴侣理解每都必须完成工作，因此有活动安排有时需要据此作出调整。这样我就可以很方便地说：“是的，我们可以出去/看个电影/等等。但是我之后需要写代码。”我的伴侣会理解我，并在安排活动时考虑到这点。</p>

<p><strong>我写了多少代码？</strong> 我很难相信自己在过去的几个月写了这么多的代码。我新建了几个网站，重写了一些框架，并创建了大量node模块。我写了如此之多的代码以至于我有时我都忘记自己做了写什么——几周前的工作感觉是很久远的记忆。我非常非常高兴自己能写这么多代码。</p>

<p>我认为这个习惯的改变是一个巨大的成功。我希望自己能持续保持这个习惯。同时，我尽力向其他希望能完成大量的支线项目的人推荐这个策略。<a rel=""nofollow"" href=""http://ejohn.org/about/"">告诉我这个策略对你而言是有效还是无效</a>。我很希望能从你那里听到一些有意思的东西。</p>

<h2>关于作者</h2>

<p><a rel=""nofollow"" href=""http://ejohn.org/"">John Resig</a>， <a rel=""nofollow"" href=""http://jquery.com/"">jQuery</a>之父，同时也是<a rel=""nofollow"" href=""http://jspro.org/"">Pro Javascript Techniques</a>和<a rel=""nofollow"" href=""http://jsninja.com/"">Secrets of the JavaScript Ninja</a>的作者。他目前主持 <a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000469838"">Khan Academy</a> 的开发工作。</p>

<hr>
<p>原文 <a rel=""nofollow"" href=""http://ejohn.org/blog/write-code-every-day/"">Write Code Every Day</a><br>
翻译 <a rel=""nofollow"" href=""http://sf.gg"">SegmentFault</a></p>

                ", jQuery之父：每天写代码,1531978022,276,1,564,1,1,https://segmentfault.com/a/1190000000469890
120,1,0,9,"
                    
<p>最近在推了一波SF技术岗位招聘的小广告以后，收到了各位小伙伴的热烈回应。有时候一天就要面试三个人，因为有些话要重复说几遍，自己都有些疲惫了，所以如果让大家感到怠慢先说句抱歉。</p>

<p>今天要说的是简历的事情，以前在给别人打工的时候就开始处理各种简历，现在应该算是小有经验。虽然自己没写过什么像样的简历，但是从一个重视技术的用人单位角度可以给大家分享下看简历的经验。</p>

<p>虽然我知道，教人写简历的文章在网上多如牛毛，但我还是忍不住要码一篇，这样大家在了解了我的看简历习惯之后会减少不必要的误伤</p>

<h2>只扔一个附件过来的不要</h2>

<p>一句介绍都没有，满怀希望的打开附件，发现是xx招聘网站自动生成的，心凉了半截。内容基本上也没啥亮点，校运动会冠军也没用啊亲，我们这里的开发者不用兼职保安。。。</p>

<p>而且，扔一个附件我也忍了，但是我打不开你的doc文档啊。已经有好几个这种情况了，我试过google docs，office online都打不开。都21世纪了，大家能转一个pdf么，或者弄个jpg也行啊</p>

<h2>应届生实习生这一批暂时不招</h2>

<p>从效率上来讲，创业公司选择有工作经验的开发者是性价比最高的，可以省掉为初学者的一些低级错误买单的成本。这句话虽然说的很残酷，但是对创业公司来说就是这样。但是如果你在大学期间自己开发过一些比较流行的开源项目可以例外。</p>

<p>暂时不招，不代表以后不招，我们的第一批非正式员工就是实习生，大家工作的也很愉快，所以我希望等我们在有这个实力，而且有足够精力来培养人的时候，再来招收应届生实习生，这也是对大家负责任的一种做法。</p>

<h2>我喜欢极客，黑客</h2>

<p>注意，请正确理解黑客的含义 。如果你满足这一点，上面的都可以忽略。</p>

<h2>加分项特别重要</h2>

<p>脱颖而出就靠这些了，github项目，SF账号，个人博客啥的。能体现你与众不同的东西都要扔过来</p>

<h2>新技术，新技术!!</h2>

<p>为什么都到14年了，大家的简历里还写的是诸如熟练使用jQuery，熟悉Wordpress之类的。新的技术呢？对新技术的敏感度可以直接看出来你对这一行是不是真的热爱，是不是具有技术远见。</p>

<p>好了，吐槽了这么多，其实我还是很和蔼的。。。希望大家不要被打击走了，我列出我的观点是希望能吸引一群志趣相投的人，一群真正的聪明人，《非诚勿扰》电影里有句话，能不能看对眼那是凭着一种味道。所以，有味道的你请继续给我们投简历吧，jobs@segmentfault.com</p>

                ", 我是如何看简历的,1531978023,335,1,994,1,1,https://segmentfault.com/a/1190000000468908
121,1,0,9,"
                    
<p>键盘上各种符号，你都知道怎么读么？<a rel=""nofollow"" href=""http://weih.github.io/"">Hao Wei</a> 童鞋整理了键盘符号的中日英读法，妈妈再也不会担心我不会念键盘上的符号啦~</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbX1T"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<table class=""bordered"">
<thead><tr>
<th>Symbol</th>
    <th>English</th>
    <th>中文</th>
    <th>日本語</th>
</tr></thead>
<tbody>
<tr>
<td>~</td>
    <td>tilde</td>
    <td>波浪号</td>
    <td>チルダ</td>
</tr>
<tr>
<td>`</td>
    <td>grave accent, backquote, backtick</td>
    <td>反引号</td>
    <td>バッククォート、グレイヴ・アクセント</td>
</tr>
<tr>
<td>!</td>
    <td>exclamation mark, bang</td>
    <td>感叹号</td>
    <td>感嘆符、エクスクラメーションマーク</td>
</tr>
<tr>
<td>@</td>
    <td>at</td>
    <td>at</td>
    <td>アットマーク</td>
</tr>
<tr>
<td>#</td>
    <td>hash, hash tag, pound, octothorpe</td>
    <td>井号</td>
    <td>ハッシュマーク、ハッシュタグ</td>
</tr>
<tr>
<td>$</td>
    <td>dollar sign</td>
    <td>美元符号</td>
    <td>ドル</td>
</tr>
<tr>
<td>%</td>
    <td>percent, mod</td>
    <td>百分号</td>
    <td>パーセント</td>
</tr>
<tr>
<td>^</td>
    <td>caret, hat</td>
    <td>脱字符</td>
    <td>ハット</td>
</tr>
<tr>
<td>&amp;</td>
    <td>ampersand, and</td>
    <td>and</td>
    <td>アンド、アンパサンド</td>
</tr>
<tr>
<td>*</td>
    <td>star, wildcard, asterisk</td>
    <td>星号</td>
    <td>スター、アスタリスク</td>
</tr>
<tr>
<td>( )</td>
    <td>parentheses, brackets</td>
    <td>括号</td>
    <td>丸括弧、括弧</td>
</tr>
<tr>
<td>{ }</td>
    <td>curly brackets, braces</td>
    <td>大括号，花括号</td>
    <td>中括弧</td>
</tr>
<tr>
<td>[ ]</td>
    <td>square brackets</td>
    <td>中括号</td>
    <td>角括弧</td>
</tr>
<tr>
<td>-</td>
    <td>dash, hyphen, minus</td>
    <td>连字符</td>
    <td> ハイフン、マイナス</td>
</tr>
<tr>
<td>_</td>
    <td>underscore</td>
    <td>下划线</td>
    <td>アンダースコア</td>
</tr>
<tr>
<td>=</td>
    <td>equal</td>
    <td>等于号</td>
    <td>イコール</td>
</tr>
<tr>
<td>+</td>
    <td>plus, addition</td>
    <td>加号</td>
    <td>プラス</td>
</tr>
<tr>
<td>|</td>
    <td>pipe, vertical bar</td>
    <td>管道符，竖杠</td>
    <td>パイプ</td>
</tr>
<tr>
<td>/</td>
    <td>slash, over, forward slash</td>
    <td>正斜杠</td>
    <td>スラッシュ</td>
</tr>
<tr>
<td>\</td>
    <td>backslash</td>
    <td>反斜杠</td>
    <td>バックスラッシュ</td>
</tr>
<tr>
<td>:</td>
    <td>colon</td>
    <td>冒号</td>
    <td>コロン</td>
</tr>
<tr>
<td>;</td>
    <td>semicolon</td>
    <td>分号</td>
    <td>セミコロン</td>
</tr>
<tr>
<td>""</td>
    <td>quotation mark, quotes</td>
    <td>双引号</td>
    <td>ダブルクォート、ダブルクォーテーション</td>
</tr>
<tr>
<td>'</td>
    <td>single quotes, apostrophe</td>
    <td>单引号</td>
    <td>シングルクォート</td>
</tr>
<tr>
<td>.</td>
    <td>period, dot, full stop</td>
    <td>点</td>
    <td>ピリオド、ドット</td>
</tr>
<tr>
<td>,</td>
    <td>comma</td>
    <td>逗号</td>
    <td>カンマ、コンマ</td>
</tr>
<tr>
<td>&lt;</td>
    <td>angle bracket, less than</td>
    <td>尖括号</td>
    <td>不等号(より小)、始め山括弧、左アングルブラケット</td>
</tr>
<tr>
<td>&gt;</td>
  <td>angle bracket, more than, greater than</td>
  <td>尖括号</td>
    <td>不等号(より大)、終わり山括弧、右アングルブラケット</td>
</tr>
<tr>
<td>?</td>
    <td>question mark</td>
    <td>问号</td>
    <td>クエスチョンマーク、疑問符</td>
</tr>
</tbody>
</table>

                ", 中日英键盘符号读法大全,1531978024,293,1,880,1,1,https://segmentfault.com/a/1190000000430012
122,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbVws"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><strong>文：Gracia</strong>(本文为原创内容，部分或全文转载均需经过作者授权，并保留完整的作者信息和技术人攻略介绍。)</p>

<p><strong>导语：</strong>本期采访对象杨轩@<a rel=""nofollow"" href=""http://weibo.com/topiori"">浙杨轩</a>，传媒梦工场投资部负责人。无论从哪个角度看，杨轩都属于投资人群体中特别的那一类，在这个普遍低调的小圈子里，他高调地经营着一个名为“土匪投资日记”的公众账号，写行业观察、分析投融资趋势、讲创业故事，犀利的观点和独到的视角为他吸引来不少粉丝。另一个独特之处，是他良好的技术背景，早年玩ACM，算法功底了得，还是国内最早做SNS创业的一批人。技术的重要性在TMT领域愈发凸显，和那些投行、咨询、MBA背景，热衷于数字分析胜过技术创意的VC相比，杨轩显然更容易和技术创业者打成一片。第三个特别之处，源自于杨轩内心的理想主义情怀，投资并不单纯是为了赚取财务回报，而是站在社会资源层面上做出的价值取向选择，并且更看重和创业者之间的价值认同及情感联系。</p>

<p>在国内并不成熟的早期投资环境下，这种情怀尤为可贵和难得。硅谷创业教父Paul Graham曾告诫投资人：“你依然需要创业者的想象力和能量，但他们已不那么需要你的钱了。”在资本已不再是稀缺品的时代，投资人和创业者究竟应该保持一种什么关系？除了钱，投资人还能为创业者做什么？在杨轩心里，这个答案很清晰。做早期投资，遇到的是创业者最艰难的那段日子，天使投资人同样需要扛很大的风险和压力，但最起码大家在互相扶持中见证了彼此的成长。兄弟情、江湖义，和互相认同的一群人策马狂奔、呼啸山林，这是杨轩的理想，也是“土匪投资日记”背后的寓意。当新的一批创业者成长起来，当年的那些经历会成为传奇，那些情感则会常留心中。</p>

<ul>
<li><strong>技术人攻略：请简单介绍一下你的经历？为什么会走上做早期投资这条职业道路？</strong></li>
</ul>
<blockquote>
  <p>从小家里管得比较严，但我内心喜欢偏自由的东西。接触到电脑之后很兴奋，感觉可以利用它做一个属于自己的世界，入迷到没有电脑的时候每天晚上在纸上写Pascal代码。高中参加各种计算机编程比赛，当时信息学奥赛拿了全国一等奖，由于不是很重视错过了推荐时间，还是参加高考进了浙大。我担心爱好成为工作可能会变得无聊，所以没有选择计算机，最后学了生物资源。</p>
  
  <p>大学开始之初非常迷茫。许多同学很刻苦，早上6点起床，一直学到晚上10点睡觉。我不太喜欢这样的生活，而我擅长的东西他们也不知道。偶然在学校的BBS上发现有大学生程序设计大赛，感觉一下子找到了目标。ACM比赛考算法，参赛的同学主要来自计算机或数学相关专业，像我这样跨专业的很少。在参赛过程中认识了很多神奇的人，从那个时候起对算法高手有了更深入的认识：他们是一群特别有天分的人，只有通过解决ACM中那种特别难和诡异的问题，才能让他们展示出能力。</p>
  
  <p>通过比赛获奖，我拿到了保送研究生的机会，当时也是错过了保送的时间点。不过后来和参加ACM比赛的一些小伙伴经过内推，一起加入了杭州一家外企Trilogy。这家外企很神奇，面试纯考算法，待遇也很不错。业务主要是自己做孵化器，也为国外高端客户提供to B的解决方案，及业务模型中的算法优化。</p>
  
  <p>我在这家公司做的比较有趣的事情，是一个基于族谱的社交网站。那是07年，社交网络的发展处于早期，Facebook还不成气候，互联网上最火的网站是Myspace。国外基于族谱的社交网站有拿到上千万美金的风投，于是我和另外一个同事合作做族谱社交，他负责运营和商务，我负责技术和产品，并完成了族谱树的核心的算法。具体的开发工作通过外包完成，整个项目花了差不多几百万美金。</p>
  
  <p>当时浙报正好要做新媒体，并且打算做一个商人社交平台，把江浙地区众多企业老板的社交搬到线上。这个主意非常吸引我，于是就加入了。做了一两年发现，这个事情还是太早了，没有土壤，缺乏市场的早期教育，无法让想法得到很好的落实。但这段时间最大的收获是对商业模式及商业本质的理解，现在能看到的商业模式，在当时都已经接触并做了深入的思考。简单说对生意这个事情有感觉了。</p>
  
  <p>商人社交没做起来，我很不甘心，在很早期的时候就尝试过分类信息、团购等模式。虽然领导支持我做，很多时候都是利用自己的业余时间探索。我特别渴望能做自己喜欢的事情，验证自己对行业的理解和判断。非常巧的是，2011年底，浙报集团要成立早期投资和孵化器传媒梦工场，我觉得是个好机会，于是开始做面向TMT行业的早期投资。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：转型做投资之后，你投的第一个项目是什么？</strong></li>
</ul>
<blockquote>
  <p>刚转型做投资的时候真的啥也不懂，先是买了一堆书，看了一遍，然后请教做这个行业的前同事和朋友，初步有了了解。刚好我们跟创新工场有合作，于是去那里待了三四个月，就坐在开复老师的前边。</p>
  
  <p>接下来投了第一个项目，虎嗅。虎嗅刚开始来找我们的时候，行业里的专家我们问了一圈，大家都看不懂这种模式，所有的人都反对。但这种编辑精选内容的方式，跟我原来想的事情很吻合。我当时的判断是：从信息匮乏到信息泛滥，媒体发展到这个阶段，就一定会需要编辑精选的模式，帮助读者筛选有价值的内容。创始人李岷曾是《中国企业家》的执行总编，我很认可她的文风和她对媒体的理解。</p>
  
  <p>在所有人都反对的情况下，要真正扣动投资的扳机，压力非常大。我记得当时自己绕着中关村一圈一圈地走，不断问自己一些根本性的问题：这件事情到底是什么，解决了什么问题，还有哪些风险？在那道坎没有迈过去的时候，很多东西是想不清楚的，只是觉得这件事情如果不做非常可惜，内心非常纠结。最终在领导的支持下，还是决定投资。也做好了如果这个项目失败就引咎辞职的思想准备，我自己的手艺还在，还可以去做码农。</p>
  
  <p>虎嗅12年5月份上线后流量飞涨，一大堆投资马上找了过来。<strong>回想起来，如果通过教条式的东西就能判断一个公司在前期能不能起来，还要这么多资深的人干什么？</strong></p>
</blockquote>

<ul>
<li><strong>技术人攻略：你接触了大量技术创业者，他们身上普遍的问题是什么？</strong></li>
</ul>
<blockquote>
  <p>这个问题挺难回答。一方面，技术人普遍不太善于交流；另一方面，他们可能对一些关键性的点不太敏感。好的技术人员能不能成为好的CEO，关键看他能不能换位思考或跨界思考，如果仅仅从技术或产品本身去思考，是很有局限性的，毕竟做一个公司和做一个产品还是不太一样。</p>
  
  <p><strong>在我接触过的技术背景创业者中，很多技术和能力不错的人，到最后都变成了做外包。究其原因，他们知道大方向，但不知道怎么一步步去走。比如西瓜很好吃，但你不知道怎么咬下去，别人切给你就可以吃。技术人创业成为CEO，这是必经的一个点，如果跨不过去，就只能是一个外包公司，所谓的梦想，根本无从谈起。</strong></p>
  
  <p>这个点跨没跨过去，很多时候自己不知道，别人却一眼就能看出来。类似于上学，老师告诉你课前预习、课后复习、好好做作业就能取得好成绩，这个道理谁都知道，但是真正能做到的有几个人。而学霸已经跨过了这个点，你能明显感觉到他们身上的自驱力。</p>
  
  <p>我希望我投资的CEO能迈过去这道坎，或者在我投之前，他已经迈过去了。最关键是要重视这个事情，这是一种思考问题的方式，只能靠自己领悟。我会去引导他，让那个概率大一点，但也没有把握帮他们过这个点。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：要跨过这道坎看来不太容易，能不能给他们一些可行的建议呢？</strong></li>
</ul>
<blockquote>
  <p>我以前写过两篇文章，分别是关于创业者如何找小伙伴和导师。当时举了个例子，硅谷有个“PayPal黑手党”，Linkedin、Tesla和YouTube的老大，以及Facebook的早期投资人，都是PayPal背景。YouTube创始人陈士俊是一个极客，创业之初也不懂什么商业模式，另一位合作伙伴也来自PayPal，说要不做个视频网站，于是就做成了。<strong>人和人之间的认同感很重要，你只有找到小伙伴，进了这个圈子，才能做很多事情。跟着对的一群人，在正确的时间做正确的事情，几率会大一些。如果在圈子里，你不进步，肯定会被踢出去或者边缘化。</strong>国内也同样有很多这样的圈子，如果连小伙伴都找不到，那你就应该反思一下自己了。</p>
  
  <p>创业者还应该找一个导师，导师不一定每样都比你强，而是有某些特别值得你去尊敬和学习的地方。你感到困惑的地方，可能他的一两句话，或者关键性的提醒就能帮到你。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你在投资项目的时候有哪些偏好吗？</strong></li>
</ul>
<blockquote>
  <p>我个人倾向于技术驱动的项目，要有较好的可想象空间，最重要的，我会做我喜欢的事情。对于那种能赚钱，但是我自己不喜欢的，我不会投。现在很火的一款打车应用曾经找过我们，但恰恰是不会用这种软件的人更需要这些社会资源，这个应用会加剧社会资源的不平等，所以即使赚钱，我也不愿意投。</p>
  
  <p>投资项目的关键还是看人，一个人过去的经历能在一定程度上证明他是否能往前走，优秀的人不会从石头里蹦出来。我会看他的经历、看他的朋友、看他周围的人。当下产品的形态不是最重要的，创业者能否踩在关键的点上更重要。我投了一些大数据的项目，但大数据的爆发期根本还没到。回过头来看淘宝的发展，03年的淘宝做成什么样根本不是关键，因为真正爆发还没开始。经历了高速发展的10年，到第10年的时候，淘宝可以很自豪地宣布，电商的时代才刚开始。</p>
  
  <p><strong>你走了100步，别人走了10步，但没关系，这个路可能是上万步。只要能把真正优秀的人团结在你周围，并且一直在路上走。前面的积累都有用，每天比别人多1%，每年会比人多很多。但如果你离开这个行业，等起来了再进去，最后的果实跟你就没什么关系了。</strong></p>
</blockquote>

<ul>
<li><strong>技术人攻略：做早期投资这两年，你的成就感来源于什么地方？</strong></li>
</ul>
<blockquote>
  <p>成就感来源于自我的突破。特别是投资虎嗅的时候，算是扛了一些压力，把这个事情给做起来了。做投资这两年我自认为成长还是蛮快的，第一年就投了5个项目，到现在投了十几个。当然没有那种马上能变现的，因为投的项目还是偏保守。</p>
  
  <p><strong>我很少跟人去抢项目，我更愿意雪中送炭。对于投资的公司，将来可能有更好更合适的人帮助他们，但不管怎样，在最困难的那个时间点，大家最起码一起走过来了。所以我和投资的公司关系都非常好，不像财务投资，只是我给你钱，你帮我赚回报，仅仅是个生意。</strong></p>
</blockquote>

<ul>
<li><strong>技术人攻略：听说你利用业余时间在经营自己的微信公众账号，能不能分享一些经验？</strong></li>
</ul>
<blockquote>
  <p>虎嗅12年刚起来的时候，写过几篇支持了一下，好像流量还不错。我个人的写作风格，按照李岷的说法，是笔记型的，阅读的愉悦感差一些，不适合小白，但行业人士应该能看到一些独到的观点。</p>
  
  <p>微信推出早期的时候，蘑菇街、美丽说曾在朋友圈里做过病毒式分享，一夜之间被清理得干干净净，大家很哗然。对于微信公众账号的发展，我问了一圈做投资、做产品的朋友，大家都认为应该观望一下。后来发现没必要这么谨慎，对于新事物来说，我当时态度还是偏傲慢了一点。去年6月份我开通微信公众账号“土匪投资日记”，7月份觉得值得认真做，投机取巧没意义。</p>
  
  <p>我一般会在朋友圈推一推，有心情的时候也会抓时间点，转一些阅读率不错的文章。每篇文章最差有几千个阅读，好一点的达到几万，可能比一个小报纸的阅读量还大。通过公众账号推荐自己投的项目或产品，效果也不错，例如基于微信平台做汽车销售管理的车商通，推过之后马上有人联系他们。最近也想写一写我投过的公司，他们在创业过程中的一些小故事。对我来讲，不会用这个账号去赚钱，只希望能获得更多认同者的关注。创业产品的头1000个用户或粉丝很难拿到，有了这个账号，以后帮助别人推一些什么东西，说不定原始的用户或粉丝就有了。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：传媒梦工场投资的领域是新媒体，你对新媒体是如何理解的？</strong></li>
</ul>
<blockquote>
  <p>新媒体这东西变化太快了，我本来想写一写，但发现自己每天对它的理解都不一样。新媒体是一个变化的过程，和传统媒体并没有很深的隔阂和区分，可能你身在其中，但完全不知道。我现在不尝试总结，和我投资项目的原则类似，抓住基本的常识，然后顺着自己对这个事情的理解去做就行了。没必要去总结新媒体是什么？新媒体有什么优势？怎么拉粉丝？怎么变现？这些都是自然而然的事情。</p>
  
  <p>我比较认同用户就是朋友，你帮他，他帮你，没有一味的索取，也没有一味的付出。如果你们真的建立了朋友的关系，他们会信任你，像罗胖收200元会员费，大家会愿意给。第二中国现阶段是以经济利益或者变现为驱动，这个阶段必然绕不过去，必须等到一批人物质满足了，才能做一些更有意思的事情。现在追求后面一个阶段，也没啥意义。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你未来一到两年的目标是什么？</strong></li>
</ul>
<blockquote>
  <p>我希望自己对行业、对投资、对自己做的事情有更深入的理解。创业者每天钻在自己的领域里，我则要关注多个领域，这必然要求我不停学习，把自己知识面的圈做得更大更好，才能跟上他们的节奏。</p>
  
  <p>另外还是会尽量多帮助别人。我投的团队，有的原先很理想化，想做牛逼的东西，一上来就要改变世界和行业。但我会劝他们踏踏实实先赚钱，先养活自己，对得起自己、家里和团队的人，先把自己这群人照顾好再说。一个人在创造力和精力最好的年纪，如果因为一些很纠结的原因达不到自己的目标，是很可惜的。</p>
  
  <p><strong>创业者在跑一万米之前，先想想一千米怎么跑，要尽量找到方向一致，又能满足赚钱目的的事情。</strong>我会尽我所能，告诉他们一些行业里的规律、趋势，以及其它人是怎么工作、生活、创业的。但这些都只是引导，路要自己走，事情要自己做，想法也要他们自己想清楚。告诉他们怎么赚钱，如果他内心深处不认同这个事，肯定是没有意义的。100个有潜力的人创业，可能10个人能做成，很多人肯定做不成，但我希望他们最起码不要因为很纠结的原因做不成。</p>
</blockquote>

<hr>
<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com/"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @devlevelup，希望能成为技术人成长的精神家园。<br>
欢迎通过微信公众账号关注技术人攻略</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxHi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>感谢<a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a>提供<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup"">博客专栏</a>及推广支持。<br>
感谢<a rel=""nofollow"" href=""http://www.speedycloud.cn/"">迅达云成</a>提供云主机及技术支持。</p>

                ", 技术人攻略访谈二十二：天使投资人的江湖情怀,1531978026,530,1,958,1,1,https://segmentfault.com/a/1190000000420348
123,1,0,9,"
                    
<h2>SegmentFault 2014年招聘第一季：后端开发工程师</h2>

<pre><code class=""lang-php"">&lt;?php

/**
 * SF后端开发者招聘函数 
 * 
 * @param array $conditions 条件列表
 * @return boolean 是否合格
 */
function wanted_developer(array $conditions) {
    $score = 0;

    foreach ($conditions as $key =&gt; $condition) {
        switch ($key) {
            case 'skills':
                foreach ($condition as $name =&gt; $rank) {
                    switch ($name) {
                        case 'linux':
                        case 'nginx':
                        case 'apache':
                            $score += $rank * 1;
                            break;
                        case 'html':
                        case 'php':
                        case 'java':
                        case 'mysql':
                            $score += $rank * 2;
                            break;
                        case 'c/c++':
                        case 'redis':
                        case 'scala':
                        case 'nodejs':
                        case 'mongodb':
                            $score += $rank * 3;
                            break;
                        case 'dota':
                        case 'dota2':
                            $score += $rank * 4;
                            break;
                        case 'lol':
                            $score += $rank * 0;
                            break;
                        default:
                            break;
                    }
                }
                break;
            case 'networks':
                foreach ($condition as $name) {
                    switch ($name) {
                        case 'weibo':
                        case 'qq':
                        case 'weixin':
                        case 'douban':
                            $score += 1;
                            break;
                        case 'v2ex':
                        case 'zhihu':
                        case 'github':
                        case 'gmail':
                        case 'facebook':
                        case 'twitter':
                        case 'wordpress':
                        case 'stackoverflow':
                            $score += 2;
                            break;
                        case 'aws':
                        case 'gae':
                        case 'openshift':
                        case 'linode':
                        case 'azure':
                            $score += 3;
                            break;
                        case 'cl':
                        case 'segmentfault':
                        case 'typecho':
                            $score += 4;
                            break;
                        default:
                            break;
                    }
                }
                break;
            case 'softwares':
                foreach ($condition as $name) {
                    switch ($name) { 
                        case 'linux':
                        case 'macosx':
                        case 'git':
                        case 'chrome':
                        case 'firefox':
                        case 'opera':
                            $score += 1;
                            break;
                        case 'vim':
                        case 'emacs':
                        case 'sublime':
                            $score += 2;
                            break;
                        case 'brew':
                        case 'vagrant':
                        case 'shadowsocks':
                            $score += 3;
                            break;
                        case 'ie':
                            $score -= 1;
                            break;
                        case 'windows':
                            $score += 0;
                            break;
                        default:
                            break;
                    }
                }
                break;
            case 'equipments':
                foreach ($condition as $name) {
                    switch ($name) {
                        case 'mac':
                        case 'chromebook':
                        case 'iphone':
                        case 'nexus':
                            $score += 1;
                            break;
                        case 'hhkb':
                        case 'cherry':
                        case 'filco':
                        case 'kindle':
                            $score += 2;
                            break;
                        case 'miwifi':
                        case 'g-glass':
                        case 'raspberry-pi':
                        case 'leap-motion':
                            $score += 3;
                            break;
                        default:
                            break;
                    }
                }
                break;
            default:
                break;
        }
    }

    return $score &gt;= 70;
}

if (wanted_developer($your_conditions)) {
    mail('jobs@segmentfault.com', '0day', $your_resume);
}
</code></pre>

                ", SegmentFault.php,1531978028,311,1,717,1,1,https://segmentfault.com/a/1190000000407476
124,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbSZk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><strong>文：Gracia</strong>(本文为原创内容，部分或全文转载均需经过作者授权，并保留完整的作者信息和技术人攻略介绍。)</p>

<p><strong>导语：</strong>本期采访对象@<a rel=""nofollow"" href=""http://weibo.com/studentdeng"">邓宇光</a>，独立iOS开发者，创业3年。这正是移动互联网风起云涌的3年，作为新时代的造梦机器，一张App榜单，承载着无数弄潮儿的梦想，在成功故事和财富神话的背后，更有着诺干血泪教训和肆意的青春。宇光所在的团队，在移动创业大军中不算特别，他们经历了草根小团队创业要面临的典型失败，以及竭尽努力所能达到的成功：凭着一腔热血走到一起的一帮人，在超出自身能力的一个目标上错误地投入了一年时间后，及时调整了方向；拼命把一款应用从各位数的下载，发展成AppStore教育榜第一名；曾经风光一时地登上过《创业邦》的封面，却和投资人产生分歧以至决裂；团队分崩离析，为了维持生计开始做外包......</p>

<p>在这个并不离奇的故事里，是一位创业者真实的3年生活。创业对心智有着超乎想象的考验，推着人在波峰和波谷之间回旋，瞬间感觉飞上天，瞬间又打回原形。感到困惑的时候，宇光会一遍一遍地看哈佛大学的《幸福课》，通过这门积极心理学的课程，他平和了很多，学会了如何自处、如何认清自己、如何在不断地失败中寻找到新的路。2014新年伊始，宇光也正在重新规划新的生活，他正在等待一个重要的Offer，打算从自由职业者，回归“正常的”生活。成功是个小概率事件，藏在大时代背后的，是每个人自己的小时代。不管成功与否，获取幸福的能力，都是我们每个人必修的功课。</p>

<ul>
<li><strong>技术人攻略：你从什么时候开始接触移动开发？</strong></li>
</ul>
<blockquote>
  <p>我在山西读的大学，专业是计算机。大二的时候参加编程比赛，做手机上的理财软件开发，当时第一次接触到Windows Mobile，觉得这就是自己未来要做的东西。开发的过程中时常会遇到一些技术问题，周围没有人能解决，于是就通过网络去找一些有经验的牛人，在这些人的博客上和他们进行技术交流，就这样认识了一群做Windows Mobile的朋友。</p>
  
  <p>大三的时候，这群朋友发起了开源项目iToday，在博客园挺火的，我也参加了，和他们一起做了一年。大四的时候，这个项目的主要发起人打算创业，问我要不要加入，就这样开始了我的创业之路。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：当时创业做什么类型的产品？</strong></li>
</ul>
<blockquote>
  <p>当时选择是做即时通讯，类似于现在的微信。发起人个人投了一些钱，组了10个人的团队，其中6人全职，4人兼职，产品基于Windows Mobile和塞班。我那会儿还在学校，通过远程共享代码的方式参与开发，11年毕业的时候也没找工作，直接来北京继续做这个产品。</p>
  
  <p>包括创始人在内，大家都是第一次创业。许多人在大公司做得不错，但缺乏真正完全按照自己的想法去做一个产品的经验。摸爬滚打了一年，发现选择的方向严重超出了这个小团队能够掌控的范围，遇到很多问题，走了很多弯路：包括在当时2G的网络环境下，丢包非常严重；所有模块都是自己开发，没有用开源的产品，导致整个开发周期非常长；推广困难，运营成本也很高，投入成了无底洞。我们决定放弃的时候，米聊已经推出来了。</p>
  
  <p>当时一位同事曾经在广州移动，为了创业，从广州抛家舍业来了北京。大家为了梦想走在一起，一年以后，发现梦想终归要回到现实，因为还是需要挣钱。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你们做出了怎样的选择，是放弃还是继续？</strong></li>
</ul>
<blockquote>
  <p>最后我们还是想明白了，不能这样放弃，于是开始第二段创业。这一次选择了教育行业，产品是手机上的电子阅读器，并且和环球雅思达成了合作，通过这种方式帮助他们卖英语学习方面的教材和影像。</p>
  
  <p>产品开发只用了一个多月，一方面技术含量比之前的产品低很多，另一方面是吸取了第一次创业的教训，不再一开始就把产品规划得很庞大。运营过程中，发现这个领域仍然非常艰难。当时智能手机和APP不像现在这样普及，大部分人不习惯利用碎片时间学习，更别说愿意为之花钱了。</p>
  
  <p>我们迅速在产品和推广层面做了调整，产品设计上参考了网易新闻，除了卖书以外，增加了考试的资讯，包括真题、预测等；推广上搞定了一些合约机，通过内置应用的方式迅速在Android市场上铺开。这样用户量很快做到一百多万，但是产品粘性不大，没有办法留住用户。于是又在3.0版本中整合了很多社交元素，整个产品效果好多了，感觉一下子上了个台阶。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你从什么时候起转向iOS开发？</strong></li>
</ul>
<blockquote>
  <p>11年那会还有很多人看好Windows Mobile，但其实这个平台已经开始走下坡路了，在价格上没有竞争力，界面效果又非常差。我自己11年就开始做iOS开发，WindowsMobile开发用C++，再转到Objective-C跨度不大，而且开发过程比Windows Mobile更简单。</p>
  
  <p>可iOS推广很困难，没有钱刷榜，上线半年连200名都排不上，每周只有个位数的下载。当时做得特别寂寞，但没有别的办法，只能用心去做。心里想的是，就算失败，也不能败得这么惨。于是坚持每两周迭代一次，这样做了超过半年。到11年底，获得了苹果官方的推荐，上了AppStore的学习助手，像是坐上火箭冲破地球，下载量一下子到了每天上万，排到教育类的第一。被认可之后，大家就感觉有干劲了。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：后来拿投资是怎么回事？</strong></li>
</ul>
<blockquote>
  <p>被苹果推荐之后，产品开始往正规走，但仍然产生不了任何收入。创业两年，公司没有任何收入，一直靠创始人个人投钱，大家都只拿着基本的生活费，钱成了最大的问题。第一年大家可以只为梦想去做，第二年，大家也可以只为了梦想，但到第三年，就再也干不下去了。创始人也扛不住了，只好找投资。当时火的是社交，做教育类的人少，对于盈利模式都不清晰的项目，找投资非常困难。但我们仍然非常幸运，在12年开春的时候拿到了两百万天使投资。</p>
  
  <p>拿到投资之后，我们开始做更多相关的产品，但是收效都不大。整个团队、包括创始人在内都非常迷茫。之前一直愁没钱，有很多想法不能去做，当有了钱时候，发现还是做不成，也不知道做什么可以成。我明显感到脑袋上有天花板在撑着，不知道自己在哪里，也不知道要往哪里去。生活没有因为拿到投资发生明显的改善，唯一开心的事情是换到了一个离中关村比较近的地方办公。</p>
  
  <p>到年底的时候，我们的创始人在产品方向上和投资人产生了严重的分歧。投资人希望加入更多商业化的元素，但创始人认为这样做不仅挣不到钱，还会流失用户。最后谈崩了，产品留给了投资人，我们全部出局。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：投资谈崩之后这一年怎么过的？</strong></li>
</ul>
<blockquote>
  <p>和投资方谈崩之后，有的伙伴离开了，有的仍然留了下来。为了生存下去，我们开始接项目，2013年团队全部的精力都放在外包项目上，没有再做新的产品。</p>
  
  <p>待遇明显提高了，但精神上的压力仍然很大。对小公司来说，没有核心的竞争力，也没有稳定的销售团队，接项目的不确定性太大。一个单子跟下一个单子之间没有太大关联，项目和项目之间可能会有很长一段空档期。这种生活很考验人的心智，一段时间会非常忙碌，然后迅速切换到无所事事，再切换回非常忙碌。情绪也因此有很大的波动，会非常不安，不知道是要这样做一年，还是两年三年。从技术积累来说，这一年也是在倒退。外包对要求技术的面比较广，但不会有特别困难的问题。因为要应付各种各样的需求，精力很难扑在具体的某个领域。</p>
  
  <p><strong>难受的时候，我就看哈佛大学的公开课《幸福课》，讲的是积极心理学，给我很大启发。它提倡通过行动提升幸福感，包括承认自己的弱点，勇于面对自己的内心。</strong>在创业的过程中，很多时候你会自己骗自己，但实际上当你一个人，在夜深人静的时候，想想自己现实的处境，想想自己内心想要的东西，想想自己做的事情，都有一种想哭的感觉。</p>
  
  <p>积极心理学会教你如何克服这些心理，梦想和现实肯定是有很大的一段距离，难过完了明天你还得积极饱满地起来。这个课程并不能解决问题，只是教你如何调解精神，让你可以走下去。面对困难的时候，不会那么沮丧和无助。</p>
  
  <p>由于项目之间有很多空闲时间，我开始做一些有益的事情，例如跑马拉松，和拿到投资之前相比，我瘦了40斤。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：现在回过头来看那段创业，你有哪些反思？</strong></li>
</ul>
<blockquote>
  <p>创业想成功需要很强大的背景，或者你能提前踩到一趟即将上升的电梯。刚开始做的时候，整个移动市场就像一个很大的电梯，你把眼睛一闭往里一钻就行了。但是现在这个电梯人已经太多了，大公司投入了大量的人力物力占坑，小公司的生存环境越来越艰难。</p>
  
  <p>每天无数App往上冲，走到最后的能有多少？能拿到钱的又有多少？<strong>创业是条好长好长的路，并不是说拿到投资就能改变什么，只能相当于多走了一个台阶。</strong>拿A轮，再到B轮，都是继续往上走的过程。跟着一个产品快速成长的经历，无论是在大公司，还是创业公司都很难遇上。技术人在在小公司往往只能经历产品的初级阶段，大公司则只能接触到产品的维护阶段，除非你正好在微信这样的团队，看着它从小做到大，或者你正好在美团创始之初加入，一直留到最后。</p>
  
  <p>成功是个小概率事件，Youtube创始人的自传里说过一句很经典的话：硅谷每天都有许多公司创建和倒闭，成功的几率就和出车祸的概率差不多。你相信自己会出车祸吗？大部分人选择不相信，那你又凭什么相信自己会成功呢？</p>
  
  <p>反思创业整个过程，这三年来我们不知道如何才能成功，但是我们知道怎样会导致不成功。大公司背景的创业者很容易错误估计创业的难度，当脱离公司环境之后，没想到受制会这么大。另外就是对资本运作了解得太少，获得AppStore推荐之后，其实可以运用很多方式把自己往前推一步。当时投资方是传统的教育行业，在培训领域有丰富的资源，拿到投资之后，思维不应该停留在小功能的改进上，而应该利用投资方的资源找到更多合作机会，这会远远比纯凭个人努力带来的收益要高很多。我们自己的眼界不够高，没有意识到应该如何利用这些资源，很遗憾。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你理想中更想要什么样的生活？近期的打算是什么？</strong></li>
</ul>
<blockquote>
  <p>人生的路很长，我才25岁，还没有想清楚到底要干什么。刚开始创业的时候我并没有选择，只是觉得做移动开发的大方向是我喜欢的。三年中一起创业朋友大部分都提前结束了，我们能坚持下来，并不是因为确定自己要什么，而只能确定不想要什么。把剩下的选择划掉，这就是我能做的。</p>
  
  <p>小米刚开始做的时候，曾经找过我的Leader，他曾在微软做Windows Mobile开发。我们仍然决定干自己的事，尽管现在看来，去小米在收入上会好很多，但是不去也没有什么可遗憾的。<strong>从人生体验的角度，如果我的人生只看到25年，显然这三年是一个失败路线，但如果把人生看到50年，这三年带来的成长和经历是很有趣的，或许可以让我在以后的岁月中少一些迷盲。</strong>在移动互联网这波浪潮来的时候，我尝试过了，也失败了，而不是眼睁睁看着别人的故事，幻想着自己做得成做不成。</p>
  
  <p>之前的思维模式是一条道走到黑，我们运气比较好撞到投资，有的小伙伴直接撞到头破血流也没找到投资，只能散伙。创业焦虑的主要原因就在于选择太少，真正成功的人有N种活法，背水一战会有，但是赌性很大，绝大部分人会赌输。我想在接下来的一年中给自己更多一点选择的机会，这样能够离成功更近一点。</p>
  
  <p>最近一年体会到了自由职业者的生活，如果我感觉自己应该换一种方式，也还能去找一份稳定的工作，到了30岁的时候也不会有什么遗憾。在整个创业过程中，你需要尝试，不断地尝试，当再也尝试不动的时候，或许就该放弃了。认清自己的能力是一件很难的事情。</p>
  
  <p>我一直在想一个问题，如果哪天我不做IT了，还能干什么。我需要把自己人生的短板去补齐，除了技术以外，其它的人生功课也要补起来。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：创业这几年，你最大的收获是什么？</strong></li>
</ul>
<blockquote>
  <p>我这三年技术上有增长，心智上的成长更多。从非常单纯的程序员，变得能够去承担一些责任。最大的收获是学会了如何去面对困难，以及从多角度看待问题。创业对人的心态考验非常大，有时候你感觉自己在天上飞，像鸟一样，下一段时间你就迅速的掉到坑里面开始滚。在绝望的和希望之间的波动会非常大，很不稳定。你在开发一个版本的时候，在它真正上线之前，你不知道到底会有怎么样的一个回报给你。</p>
  
  <p>Youtube创始人写的书里，有一段我印象特别深刻：当时他兜里只有两块钱，下星期就要发工资，连跳楼都想过，最后还是找到一条出路。我们公司也遇到同样的情况，最后老大也想办法解决了。整个创业过程中，我从老大身上学到很多，最重要的就是承担问题的能力，他可以同时承担很多难以做到的事，而且合理安排它们。创业就是完成一件看似不可能完成的任务。</p>
  
  <p>我一直在追寻可复制的成功，但一些著名的例子很难帮到我，他们的成功很难在我身上复制。我不太看那种关于创业的XX条经验，这些内容已经被别人精炼过了，而往往细枝末节才是更重要的。创业有太多不确定性，那种放之四海皆准的规律没有太多借鉴作用，短平快的大道理让人瞬间得到共鸣，但其实没用。</p>
  
  <p>只要不是太差的人，天分和努力都不会差太多，<strong>人和人的差别更多还是在眼界上。我们创业的过程中曾经觉得没有机会的事情，别人在同样的情况下，就把它当成机会去做了，并且能够做成。</strong>这和创业者对市场的理解、所处的圈子都息息相关。去找一些方式去拓宽自己的眼界，增加自己的筹码，这才是最关键的。</p>
</blockquote>

<hr>
<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com/"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @<a rel=""nofollow"" href=""http://weibo.com/devlevelup"">devlevelup</a>，希望能成为技术人成长的精神家园。<br>
欢迎通过微信公众账号关注技术人攻略</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxHi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>感谢<a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a>提供<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup"">博客专栏</a>及推广支持。<br>
感谢<a rel=""nofollow"" href=""http://www.speedycloud.cn/"">迅达云成</a>提供云主机及技术支持。</p>

                ", 技术人攻略访谈二十一：关于幸福的创业课,1531978030,526,1,640,1,1,https://segmentfault.com/a/1190000000410637
125,1,0,9,"
                    
<p><a rel=""nofollow"" href=""http://terrytai.com/salary-from-50rmb-to100usd-3/"">此文来源于我的blog</a></p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/roushan.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""roushan.jpg""></span></p>

<p>接上篇: <a rel=""nofollow"" href=""http://blog.segmentfault.com/terry_tai/1190000000350329"">我如何把薪水从 50人民币/天 提升到 100美元/小时的 (2)</a></p>

<p>那之后的实习时间过得很充实，每天基本都会有新的挑战，然后再绞尽脑汁解决它们。每天都像在打boss，有大有小，理所当然经验值也在迅速的增长。这样的时光一直持续到这个项目快结束的时候。那时挑战感觉明显下降，一方面是技能上已经比较熟练，另一方面项目上也没有什么新的技术的引入，基本是 bug fix 和微调为主。不知是被虐惯了还是怎么的，突然的轻松下来让我非常不习惯。</p>

<p>于是我想利用那段时间把毕业设计搞了，其实毕业设计的东西我已经在学习 Ruby on Rails 的时候写的差不多了, 只是经过了这么久的实习觉得当时很多地方代码写的还不够好，所以想把它重构一下。因此也给老板提出每周只上三天班，其他时间就留在学校做毕业设计。</p>

<p>在学校准备毕业设计期间，一个偶然的机会遇到了以前教我Java的严老师。于是聊到了我实习期间一些情况，当时我对Rails大加赞赏，并和他讨论了不少细节，想说明这是一个真的不错的技术。他也听得津津有味，觉得很感兴趣，特别是对它的开发效率，所以他也在考虑是不是可以在自己的项目里用一用, 也会推荐他的学生看一看。</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/mala.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mala.jpg""></span></p>

<p>说来也巧那天刚聊完我回到寝室，就有几个同学和几个学弟来找我，听说我实习一直在做 Rails 开发，希望我能教教他们Rails。我当时很爽快的答应了，一方面是因为那段时间也相对轻松，另一方面，我倒是也想考验一下自己，是不是可以把一个自己知道的东西清楚的讲给他人听。何况能帮助到几个朋友了解一门我喜欢的技术那也算是一件不错的事情。当时我一直觉得自己从Rails社区索取太多，但是贡献不够。所以也把这一次的事情当成了一个回馈。谁知后来这事一传十，十传百，想要加入一起学习的同学越来越多，所以整个学习小组一起学习时看起来就像一个班在上课一样。</p>

<p>没过几天这事就传到了系主任耳边，然后请我去他办公室一趟，我当时还有点疑惑，心想这是聚众学习，又不是聚众其它，应该不违反什么学校规定吧？难道是因为偷偷用教室的投影仪播放视频？但是也都是播的正规的啊！脑子里冒着无数问号来到系主任办公室。</p>

<p>我： “张主任好。”</p>

<p>张主任：“坐！”</p>

<p>我： “张主任找我有什么事吗？”</p>

<p>张主任： “听说你在私下组织上课？” （怎么听都感觉我是个搞传销的）</p>

<p>我：“是的，但是其实也不能叫上课，是一个学习小组。我也是义务工作的，教大家学习一下 Ruby和Rails.”</p>

<p>张主任：“恩，你知道你上课的时间和四门选修课的时间都重了吗？导致你班上的人接近一半的人都是逃课去的？”</p>

<p>我霍然开朗，原来是因为这个事情来找我。</p>

<p>我立马解释道：“这个我还真没注意到，我们可以换时间的。”</p>

<p>张主任：“不用了...” （我擦，一听就是要解散我们秘密组织的节奏）</p>

<p>他停顿了一下十分从容的从旁边拿出一张纸，并递到我手上。（难道是要我写保证书？）</p>

<p>并接着说：“很多同学给我反应非常喜欢你这个课，说能学到很多实际的东西。以后你就把这个当课上吧，我可以提供给每个通过的学生两个选修学分。这是考勤表和成绩表，你还是要严格考情和考试，要及格的人才能获得这两个学分。还有你这样的实践课不要在普通的教室上了，我给你安排了机房，以后就在机房上课吧，多让大家操练操练，你选出一个班长，然后让他来负责安装机房的环境，并且关门开门就行了。还有，你以后在这个学校又是学生又是老师了，这在很多学校都是不可能的，也不要有太大的压力，我相信你能做好。”</p>

<p>我听了张主任这一席话，眼泪差点没掉下来，嘴里半天憋不出来一个字...</p>

<p>其实现在想想这个事情还觉得蛮不可思议的，特别是在中国...<br>
前不久还在 google docs里看到当时学生的名单，感慨万千。</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/facebook.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""facebook.png""></span></p>

<p>那之后生活又回归了以前的充实，努力的备课，努力的上课，努力的上班，努力搞毕业设计... 不同的是，脑子里不是只有一件事情了，而是每天都有三件事情需要我去做好。这个过程我还很花了一些时间来平衡。但是想想现在同时有三件事情都算是轻松的了，不得不说那次的锻炼还是挺有帮助的。</p>

<p>那段时间我发现一个非常有意思的现象，就是要把你已经懂的东西讲得让别人也懂并不是一件容易的事情。而把别人讲懂的过程实际上也是一种再次学习的过程，也是更加深入理解的过程。所以多分享一些知识给别人绝对也是对自己很有帮助的事情，分享在我看来是一个利己利人的行为，这也是为什么我后来<strong><a rel=""nofollow"" href=""http://terrytai.com/"">写文章</a></strong>，<strong><a rel=""nofollow"" href=""http://railscasts-china.com/"">录视频</a></strong>，<strong><a rel=""nofollow"" href=""http://teahour.fm/"">做podcast</a></strong> 分享我知道的知识。</p>

<p>等那个课程结束也差不多是毕业前夕了，我继续回到了以前的公司全职的上班。不久也被提升为了当时Ruby组的 leader，还要负责当时的技术面试和新人培养。工资也给开了 4000 人民币/月。 这在那时的成都可是一个相当不错的价格了，而且那也算是我的第一次晋升，按理我应该高兴才对。但我却怎么也高兴不起来，工作没有以前的那种基情，哦不，激情。当然依然是保质保量的完成，只是内心中总是觉得不满足，有种撞到天花板的感觉，还有对现实还有很多不满足，或者说觉得还有很多更好的空间。</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/wcg.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""wcg.jpg""></span></p>

<p>正巧那段时间第一届 RubyConf China 要在上海举行。我当几乎不假思索的就定了票，而且内心有一种说不出的兴奋，这种感觉犹如一个职业选手要去参加WCG一般，让人兴奋不已，我一直想看看中国其他Ruby玩家到底是如何玩的，每天是怎么训练的, 于是找老板请三天假去上海参加这次Rubyconf.</p>

<p>老板听后没有马上同意，并打开自己的outlook看了看，转身给我说：“非常不错，这样吧，你也不用请假了，我和你一起去，费用都由公司承担，票你帮我也定一张，我也去学习学习。这次我们过去可以多呆一段时间，我母亲在那边有一套房子，你可以和我住那里，我们可以和成都这边远程工作一段时间。”</p>

<p>Holy shit! 我已经不记得我当时的表情，但是我相信一定是非常惊讶的。 这不但是要一起旅游还是要睡在一起的节奏...</p>

<p>那次上海之行我特别想见的有4个人，Ruby语言的创始人 Matz, <strong><a rel=""nofollow"" href=""http://www.iteye.com/"">JavaEye</a></strong> 的创始人 <strong><a rel=""nofollow"" href=""http://robbinfan.com/"">Robbin Fan</a></strong> 和 <strong><a rel=""nofollow"" href=""http://www.caibangzi.com/"">财帮子</a></strong>的创始人 <strong><a rel=""nofollow"" href=""http://www.robinlu.com/"">Robin Lu</a></strong>, 以及大会的发起人 <strong><a rel=""nofollow"" href=""http://lvguoning.com/"">Daniel Lv</a></strong>.</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/matz.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""matz.jpg""></span><br>
Matz 就不说了， Ruby的开山鼻祖，必须是要围观的。而 Robbin Fan 和 Robin Lu 是当时中国Ruby社区里我最敬重的两位程序员 + 创业人。JavaEye 和 财帮子可谓是当时中国最大的两个用 Rails 写的网站（当时最有名的 Java 社区网站竟然是用 Ruby写的，是不是很有意思？），也是因为有这两个网站在中国才向很多人证明了，Rails 不只是玩具，它可以做大型的项目。（是的，那个年代，中国很多人的想法还停留在 Rails 就是玩具不能用于真实项目的年代。）</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/robbin.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""robbin.jpg""></span><br>
想见他们还有一个理由是我和这两位罗宾以前还有些交情, 我大一下期（或者是大二上期，具体有点记不得了）的时候特别迷恋互联网，而且当时正是 Web 2.0 兴起的时候，我那时写过一段时间 Blog，内容主要是我对互联网和 Web 2.0的一些看法，所以取名为 ""Terry 谈网""。 现在反过来看看以前自己写的内容，觉得很多想法其实挺幼稚的，不过我完全不后悔做了这事，因为至少我看到了自己以前的幼稚和后来的进步。 写了段时间后，发现自娱自乐已经不能满足我了，于是我想通过这个 Blog 认识更多志同道合的朋友（其实都应该算是前辈），和他们一起玩儿。所以我后来大多采用了采访的形式来写blog， 主要是采访业界一些不错的 Web 2.0网站的站长。 两位罗宾就是我采访过的对象，记得当时给这两位发邀请邮件之前心里都泛着嘀咕，“我一个屁学生，别人肯定都懒得搭理我。” ... 但是最终我还是说服自己去试试，毕竟如果失败了，我也没什么损失啊。（后来想想这个和追女生其实是一个道理嘛）</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/robin.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""robin.jpg""></span></p>

<p>关于 Robin Lu<br><figure><p>对于这个 Robin  Lu 可能很多社区里的新人都不认识他。因为他现在有点隐士的味道了，很少在社区里出现，连网上发言也少了，他最后发布的一个开源项目也大概是四年前了。当时他在网上那可以说是相当活跃的，无论是写文，发推还是开源项目。也是因为看了他很多东西，让我非常欣赏他。他曾今在 Sun 和微软都就职过，后来出来和朋友创业，开发了当时大名鼎鼎的财帮子并创立了他们自己的咨询公司。 总而言之我当时是非常敬重这个人，而这一次去有个很重要的任务是我要当面给他道歉。</p>
  
  <p>我和 Robin 不得不说的故事：</p>
</figure></p>

<p>那是一个月黑风高晚上，是我刚采访了 Robin Lu 的第二天晚上，而那几天正好是我将要和我的小伙伴去参加一个由成都信息工程学院组织的黑客大赛。那晚我正好在准备一些比赛要用的黑客工具，其中一个是我自己试着写的 SQL 注入侦测脚本。好不容易完工，还在学校教务网站试用了一把(登成绩的网站)，成功找到漏洞，并把自己加入到管理员里，然后又立即把自己的帐号删除了。我就是试试是否能提权成功，还真没打算干什么坏事。 当时我也在学习 Rails, 也特别好奇 Rails 这个框架的安全性如何，正好那天又采访了Robin Lu，所以想用“财帮子”一试究竟， 于是就用我的性感小脚本在上面跑了一跑。结果没发现任何注入漏洞，我心里还暗喜，觉得 Rails 安全性还是挺好的。（当然，这和写的人关系也很大。）</p>

<p>谁知道第二天一开电脑，就收到了 Robin Lu的来信，信的内容大概是说，从日志中看到了我的行为，并表示没想到我采访他是为了要黑掉他们的网站(俗称社会工程学)... 而且坚定把我认为是一个黑客。</p>

<p>毫不夸张的说我边看那封信，眼泪哗哗的流。这种感觉很委屈，而且比被女朋友栽赃和某某女性朋友有一腿来得更让我不痛快。我记得当时我回了一封很长的信做解释，但是对方并没有再回，而且把我从gtalk上删除了。（看来和这个小伙伴以后没有办法一起愉快的玩耍了！）这件事情一直困扰我很久，所以我想利用这次上海之行给他当面道歉并解释清楚。</p>

<p>从上面的合照你应该不难猜到，最终我还是做到了！:)</p>

<p><span class=""img-wrap""><img data-src=""http://terrytai.com/images/daniel.jpeg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""daniel.jpeg""></span></p>

<p>见 Daniel Lv 是因为我知道他是上海 Rails 社区的组织者，我想从他那里学习一下如何组织社区活动，想到成都来也组织组织活动，心想我们大成都当时虽然用 Rails 的少，但是组织一桌麻将的人总还是够的吧。</p>

<p>而 Daniel 同学后来成为我同事加超级好的基友（一起睡过那种），说起来那次在上海之行就是我们的初次见面，现在回想起来就如同昨天一般。</p>

<p>那次上海之行真可以说是亮瞎我的氪金狗眼，长这么大还是第一次见到这么多搞 Ruby/Rails 的人聚在一起。聊了很多有意思的话题，同时也找到自己很多的差距。我知道自己还有很长的路要走，而要变得更优秀，我必须要和这些优秀的人一起工作。</p>

<p>所以那次回成都不久我就决定要换工作了，我打算背起我的小书包，带上我的真钞，去上海找一个有更多优秀的人的地方工作(东莞去不了了)。决定那天我还在推上发了一贴。结果 Daniel 同学竟然看到了， 然后回复了我 “这种事情可不好在推特上说，你前雇主看到可不好，你gtalk是什么？我和你私聊一下...”<br>
(后面的精彩内容我们就下回分解啦)</p>

<h3>总结</h3>

<ol>
<li><p>多分享自己知道知识。 分享绝对是利人利己的行为，利人相信很容易理解，而利己主要是在于这是最好的建立你reputation的方式，并且也有助于巩固你已经学到的知识。<br>
关于形式我觉得都可以尝试，教别人也好，博客也好，视频也好，写书也好, 公众帐号也好， 微博也好。不要觉得自己还没有准备好，因为你不去做或许你永远都等不到准备好的那一天。我大一就敢写互联网观察相关的文章了，说实话我现在回忆起来都很佩服我当时的勇气，但是我真的做了，虽然很多观点现在想想都觉得稚嫩，但是我的确因此认识了很多对我很重要的朋友。</p></li>
<li><p>即使在你工作缺乏激情的情况，除非里选择马上离开，否则你依然要保质保量的完成你的工作, 这才是一个写软件的人应有的专业态度。</p></li>
<li><p>想尽一切办法和更优秀的人一起工作，即使你可能只能当凤尾。(蒜泥也好，清炒也罢)</p></li>
<li><p>找到你的社区，加入他们，参加他们的活动。同一个社区的人总是有某种程度的相似性，你很容易认识那些和你有 common sense 的人。相信我这些人将在你未来的职业生涯里起到举足轻重的作用。</p></li>
<li><p>安全这种东西，任何框架都只能帮到你一部分。烂程序员用最安全的框架也能写出最不安全的代码。</p></li>
<li><p>研究黑客技术的时候，千万别找认识的人下手，最好自己搭个站来玩，避免引起不必要的误会. &gt;.&lt;</p></li>
</ol>
<p>无耻小广告一枚： 我们的 Pragmatic.ly 更名为 <a rel=""nofollow"" href=""https://fengche.co/"">Fengche.co</a> 了，而且做了<a rel=""nofollow"" href=""https://fengche.co/blog/new-year-new-branding/"">全新的设计</a>，很高端大气上档次哟。</p>

                ", 我如何把薪水从 50人民币/天 提升到 100美元/小时的 (3),1531978031,441,1,745,1,1,https://segmentfault.com/a/1190000000407906
126,1,0,9,"
                    
<p>译自<a href=""http://ds9a.nl/lex-yacc/"" rel=""nofollow noreferrer"">Lex&amp;YACC HOWTO</a></p>
<p><a></a></p>
<h1>1. 简介</h1>
<p>如果你有Unix环境的编程经验，想必你肯定遇到过神秘的Lex和YACC工具，在GUN/Linux中，又分别称作Flex和Bison,其中Flex是由Vern Paxon实现的Lex版本，Bison是GUN版本的YACC.我们统一称他们为Lex和YACC，这些新版本是向上兼容的，因此你可以在我们的示例中使用Flex以及Bison.</p>
<p>这两个程序是非常有用的，但是跟C编译器一样，它的用户手册上即不会解释C语言,也不会告诉你如何使用C语言。YACC与Lex一起使用时非常有用,然而，Bison用户手册并没有介绍如何将Lex代码集成到Bison程序里。</p>
<p><a></a></p>
<h2>1.1 这篇文章不能做什么</h2>
<p>关于Lex&amp;YACC的巨作有很多。如果需要了解更多，你应该阅读它们。它们提供的信息比本文多的多。参考文章未尾""Further Reading""章节。本文的目的是通过实例引导你如何使用Lex&amp;YACC。</p>
<p>Flex及BISON自带的文档非常优秀，但并非教程。</p>
<p>我无意成为Lex&amp;YACC专家。当我开始写此文章时，不过接触它们两天而已。我所做的只是想让这两天对你而言会更轻松。</p>
<p>能力有限，不要期望文章能够恰如其份符合Lex&amp;YACC风格。示例保持的尽量简单，可能有更好的方法，你可以写在下面的评论里。</p>
<p><a></a></p>
<h2>1.2 下载示例</h2>
<p>请注意，你可以<a href=""http://ds9a.nl/lex-yacc"" rel=""nofollow noreferrer"">下载</a> 所有的示例文件。</p>
<p><a></a></p>
<h2>1.3 License</h2>
<p>Copyright (c) 2001 by bert hubert. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, vX.Y or later (the latest version is presently available at <a href=""http://www.opencontent.org/openpub/)."" rel=""nofollow noreferrer"">http://www.opencontent.org/openpub/).</a></p>
<p><a></a></p>
<h1>2. Lex&amp;YACC能做什么</h1>
<p>使用恰当的话，这两个程序能够让你更容易的解析复杂的语言。例如读取配置文件，或者为你自己发明的编程语言写一个编译器。</p>
<p>通过本文，你会发现，有了Lex&amp;YACC这两个工具，你永远不需要自己手工写一个解析程序。</p>
<p><a></a></p>
<h2>2.1 各司其职</h2>
<p>虽然这两个程序在一起使用时显得光耀夺目，但是它们的用途是不同的。接下来的章节会解释每个程序能做什么。</p>
<p><a></a></p>
<h1>3. Lex</h1>
<p>Lex 程序生成的的文件被称作分词器。它是一个函数，输入为字符流，只要发现一段字符能够匹配一个关键字，就会采取对应的动作。一个非常简单的示例:</p>
<pre><code>%{
#include &lt;stdio.h&gt;
%}
%%
stop    printf(""Stop command received\n"");
start   printf(""Start command received\n"");
%%</code></pre>
<p>位于<code>%{</code>和<code>%}</code>之间的第一个段原封不动的导出到输出程序。因为使用了<code>printf</code>，因此我们需要<code>stdio.h</code>。</p>
<p>段之间被<code>%%</code>分割了开来，第二段的第一行起于<code>stop</code>健值，表示当从输入流中读取到<code>stop</code>时就会执行后面的<code>printf(""Stop command received\n"");</code><br>除了<code>stop</code>,我们还定义了<code>start</code>，作用与<code>stop</code>一样。</p>
<p>段以<code>%%</code>结束。</p>
<p>为了编译Example1,执行</p>
<pre><code>$ lex example1.lt
cc lex.yy.c -o example -ll</code></pre>
<p><strong> 请注意：如果你使用Flex,请用Lex替代之，可能你还要将<code>-ll</code>替换成<code>-lfl</code>.至少RetHat 6.x以及SuSE需要。</strong></p>
<p>上面的命令会生成程序example1，如果你运行它，它会等待你的输入。只要你的输入内容与定义的键值(<code>stop</code>和<code>start</code>)不匹配，就会将它们输出。如果你输入stop，它会输出 <code>Stop command received</code>。</p>
<p>以EOF（^D）结束输入。</p>
<p>也许你想知道程序为什么能运行，因为我们压根没有定义main函数。其实main函数在libl(liblex)中被定义，通过 <code>-ll</code>被引入了进来。</p>
<p><a></a></p>
<h2>3.1 正则匹配</h2>
<p>上面的示例的实用效果不佳，接下来的亦然。不过它会在Lex中引用正则，这点将会在后面的示例中非常有用。</p>
<p>Example 2:</p>
<pre><code>%{
include &lt;stdio.h&gt;
%}
%%
0123456789]+           printf(""NUMBER\n"");
a−zA−Z][a−zA−Z0−9]*    printf(""WORD\n"");
%%</code></pre>
<p>上面这个Lex文件描述两种匹配的符号：<code>WORDs</code>和<code>NUMBERs</code>。学习正则表达式可能有一点困难，但只须花点功夫便可轻松的理解它们。来看下<code>NUMBER</code>的匹配：</p>
<pre><code>[0123456789]+</code></pre>
<p>意思是：一系列的一个或多个取自于0123456789中的字符。简便写法是：</p>
<pre><code>[0-9]+</code></pre>
<p><code>WORD</code>的匹配：</p>
<pre><code>[a-zA-Z][z-zA-Z0-9]*</code></pre>
<p>第一个部分（第一个方括号内）仅匹配一个介与'a'和'z'之间的字符，或者说，一个字母。这个初始的字母后面需要跟0个多更多的字符，这些字符即可以是字母也可以是数字。为何此处使用星号呢？</p>
<p><code>+</code>意思是1个或更多的匹配，但是一个<code>WORD</code>可以仅由一个字符组成，即已经匹配的第一个部分。因此第二人部分或许是0个匹配，因此用'*'。</p>
<p>这样我们就模仿了大部分编程语言中变量必须由一个字母开头，但是后面可以有数字。例如，'temperature1'是个合法的名字，但是'1temperature'不是。</p>
<p>尝试编译Example2,方法于Example1一样。输入一些文字，以下是一些样例：</p>
<pre><code>$ ./example2
foo
WORD

bar
WORD

123 
NUMBER

bar123 
WORD

123bar
NUMBER
WORD</code></pre>
<p>Flex的用户手册上关于正则表述式描述的很详细。perl用户手册（perler）关于正则部分也很有用，尽管Flex没有实现perl的全部。</p>
<p><strong> 确认你没有创建形如<code>[0-9]*</code>这样可以匹配模式，否则你的lexer会重复的匹配空字段串。</strong></p>
<p><a></a></p>
<h2>3.2 一个更复杂的类C语法示例</h2>
<p>假设下面是一个我们想解析的文件：</p>
<pre><code>logging {
    category lame−servers { null; };
    category cname { null; };
};

zone ""."" {
    type hint;
    file ""/etc/bind/db.root"";
};</code></pre>
<p>这个文件中有以下几类符号(<code>tokens</code>)</p>
<ol>
<li><p>WORDs ，如<code>zone</code>和<code>type</code></p></li>
<li><p>FILENAMEs ，如<code>/etc/bind/db.root</code></p></li>
<li><p>QUOTEs ，如包括文件名的符号</p></li>
<li><p>OBRACEs ，左花括号<code>{</code></p></li>
<li><p>EBRACEs ，右花括号<code>}</code></p></li>
<li><p>SEMICOLONs ，<code>;</code></p></li>
</ol>
<p>对应的Lex文件如下（Example 3）：</p>
<pre><code>%{
#include &lt;stdio.h&gt;
%}
%%
[a−zA−Z][a−zA−Z0−9]*    printf(""WORD "");
[a−zA−Z0−9\/.−]+        printf(""FILENAME "");
\""                      printf(""QUOTE "");
\{                      printf(""OBRACE "");
\}                      printf(""EBRACE "");
;                       printf(""SEMICOLON "");
\n                      printf(""\n"");
[ \t]+                  /* ignore whitespace */;
%%</code></pre>
<p>当我们将文件输入分词器时,得到：</p>
<pre><code>WORD OBRACE
WORD FILENAME OBRACE WORD SEMICOLON EBRACE SEMICOLON
WORD WORD OBRACE WORD　SEMICOLON EBRACE SEMICOLON
EBRACE SEMICOLON

WORD QUOTE FILENAME QUOTE OBRACE
WORD WORD SEMICOLON
WORD QUOTE FILENAME QUOTE SEMICOLON
EBRACE SEMICOLON</code></pre>
<p>与之前提到的配置文件相比，很明显我们对其进行了符号化。配置文件的每个部分都被匹配了并且转化成指定的符号。</p>
<p>这正是我们要给YACC使用的。</p>
<p><a></a></p>
<h2>3.3 我们看到了什么</h2>
<p>我们已经看到了Lex能够读取随机的输入并且检测输入的每部分是什么。我们将其称之为符号化。</p>
<p><a></a></p>
<h1>4. YACC</h1>
<p>YACC能够将输入的符号流解析成指定的值。这里清晰的描述了YACC与Lex之前的关系。YACC没有输入流的概念，它仅接受预处理过的符号集。你可以自己写符号生成器，不过本文全部将其交给Lex。</p>
<p>关于语法跟语法分析器的一点小注意：当<code>YACC</code>成熟时，它就被用作编译器的解析文析的工具。计算机语言不允许有二义性。因此，YACC在遇到有歧义时会抱怨<code>移进/归约</code>或者<code>归约/归约</code>冲突。更多关于YACC与歧义的问题参考<code>冲突</code>章节。</p>
<p><a></a></p>
<h2>4.1 一个简单的温度调节控制器</h2>
<p>我们想用一门简单的语言去控制一个温度调节器，例如：</p>
<pre><code>heat on
    Heater on!
heat off
    Heater off!
target temperature 22
    New temperature set!</code></pre>
<p>我们需要辨别的符号有：<code>heat</code>,<code>on/off(STATE)</code>,<code>target</code>,<code>temperature</code>,<code>NUMBER</code>。对应的Lex文件如下（Example 4）:</p>
<pre><code>%{
#include &lt;stdio.h&gt;
#include ""y.tab.h""
%}
%%
[0−9]+                    return NUMBER;
heat                     return TOKHEAT;
on|off                     return STATE;
target                     return TOKTARGET;
temperature                return TOKTEMPERATURE;
\n                         /* ignore end of line */;
[ \t]+                     /* ignore whitespace */;
%%</code></pre>
<p>注意两个重要的变化。第一，引入了头文件<code>y.tab.h</code>。第二，我们不再使用<code>print</code>函数，而是直接返回符号的名字。这样做的目的是为了接下来将它嵌入到YACC中，而后者对打印到屏幕的内容根本不关心。<code>Y.tab.h</code>定义了这些符号。</p>
<p>但是<code>y.tab.h</code>是从哪得到的呢？<strong>它是由YACC从语法文件中生成的。</strong> 我们的语言非常简单，以下是它的语法：</p>
<pre><code>commands: /* empty */
                | commands command
                ;

       command:
                heat_switch
                |
                target_set
                ;

       heat_switch:
                TOKHEAT STATE
                {
                    printf(""\tHeat turned on or off\n"");
                }
                ;
                target_set:
                TOKTARGET TOKTEMPERATURE NUMBER
                {
                    printf(""\tTemperature set\n"");
                } 
                ;</code></pre>
<p>第一个部分我称之为<code>根</code>，它告诉我们有命令集（<code>commands</code>）,并且这些命令集由一些独立的命令（<code>command</code>）组成。如你所见，这些规则是递归的，因为他本身又包含了<code>commands</code>.这就意味着通过递归可以将这一系列的命令集进行归约。阅读<code>Lex和YACC内部原理</code>获取更多递归的详细内容。</p>
<p>第二个部分规则定义了<code>command</code>具体是什么。我们只支持两种命令：<code>heat_switch</code>和<code>target_set</code>。这个是<code>|-</code>符号的意思：一个命令（command）包含了<code>heat_switch</code>或<code>target_set</code>。</p>
<p><code>heat_switch</code>包含了<code>HEAT</code>符号，即一个简单的单词<code>heat</code>以及后面跟一个状态（在Lex中定义的<code>on</code>或<code>off</code>）。</p>
<p><code>target_set</code>稍微有些复杂，它由<code>TARGET</code>符号（单词target），<code>TEMPERATURE</code>符号（单词）以及一个数字组成。</p>
<h3>完整的YACC文件</h3>
<p>前面一节仅列出了YACC文件的部分，以下是我们省略的开头部分：</p>
<pre><code>%{
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void yyerror(const char *str){
    fprintf(stderr,""error:%s\n"",str);
}

int yywrap(){
    return 1;
}
main()
{
    yyparse();
}

%}

%token NUMBER TOKHEAT STATE TOKTARET TOKTEMPERATURE</code></pre>
<p>函数<code>yyerror</code>在YACC发生错误时被调用 ，我们只是简单的将传入的信息打印了出来，实际有比这更巧妙的处理，参阅""<a>深度阅读</a>""一节。</p>
<p>函数<code>yywrap</code>能够用于是否继续读取其它的文件，当遇到<code>EOF</code>时，你可以打开其它文件并返回0。或者，返回1，意味着真正的结束。欲知更多，请参阅""<a>Lex和YACC内部工作原理</a>""章节。</p>
<p>函数<code>main</code>是程序的起点。</p>
<p>最后一行简单的定义了哪些符号将会被用到，如果调用YACC时启用了<code>-d</code>选项，会将这些符号会输出到<code>y.tab.h</code>文件。</p>
<h3>编译、运行温度调节控制器</h3>
<pre><code>lex example4.l
yacc -d example4.y
cc lex.yy.c y.tab.c -o example4</code></pre>
<p>有一点小变化。现在我们使用YACC编译我们的程序，它生成y.tab.c和y.tab.h文件.然后才是调用Lex。编译时，不再需要<code>-ll</code>,因为程序中我们定义了自己的main函数。</p>
<p><strong>注意：如果你得到一个编译器错误：<code>not being able to find 'yylval'</code>,将下面的内容加入到文件example4.l中的<code>#include &lt;y.tab.h&gt;</code>下面 </strong></p>
<pre><code>extern YYSTYPE yylval;</code></pre>
<p><code>Lex 和YACC工作内部原理</code>有相关的解释。</p>
<p>运行示例：</p>
<pre><code>$ ./example4
heat on
        Heat turned on or off
heat off
        Heat turned on or off
target temperature 10
        Temperature set
target humidity 20
       error: parse error</code></pre>
<p>以上并不是我们要完成的真正目标，而是通过此例循序渐进，控制学习曲线，使读者继续保持兴趣。并非所有酷的特性都能一次被展示。</p>
<p><a></a></p>
<h2>4.2 拓展温度调节器使其可处理参数</h2>
<p>上面的示例可以正确的解析温度调节器的命令，但是它并不知道应该做什么，它并不能取到你输入的温度值。</p>
<p>接下来工作就是向其中加一点功能使之可以读取出具体的温度值。为此我们需要学习如何将Lex中的数字（<code>NUMBER</code>）匹配转化成一个整数，使其可以在YACC中被读取。</p>
<p>当Lex匹配到一个目标时，它就会将匹配到的文字放到<code>yytext</code>中。YACC从变量<code>yylval</code>中取值。在下面的Example5中，是一种直接的方法：</p>
<pre><code>%{
#include &lt;stdio.h&gt;
#include ""y.tab.h""
%}
%%
[0−9]+            yylval=atoi(yytext); return NUMBER;
heat            return TOKHEAT;
on|off            yylval=!strcmp(yytext,""on""); return STATE;
target            return TOKTARGET;
temperature        return TOKTEMPERATURE;
\n                /* ignore end of line */;
[ \t]+            /* ignore whitespace */;
%%</code></pre>
<p>如你所见，以yytext作为参数调用atoi函数，并将其返回值赋给yylval变量，这样YACC就可以使用它。我们对STATE采用类似的处理方式：如果为on,yylval为1。<br>请注意，在Lex中分别对on和offf进行匹配可以得到更快的处理代码，但是我想展示一点更复杂的规则。</p>
<p>接下来我们学习YACC如何处理这些。Lex中我们称为<code>yylval</code>，在YACC有另外一个名字。下面检查设置温度目标的规则：</p>
<pre><code>target_set:
        TOKTARGET TOKTEMPERATURE NUMBER
        {
            printf(""\tTemperature set to %d\n"",$3d);
        }
        ;</code></pre>
<p>为了取到规则中的第三个部分的值，（例如，NUMBER）,我们需要使用<code>$3</code>，只要yylex返回，yylval的值就会被显示在终端中，其值经由$取得。</p>
<p>为了阐述这个特性，让我们观查新的<code>heat_switch</code>规则：</p>
<pre><code>heat_switch:
        TOKHEAT STATE
        {
            if($2)
                printf(""\Heat turned on\n"");
            else
                printf(""\tHeat turned off\n"");
        }
        ;</code></pre>
<p><a></a></p>
<h2>4.3 解析配置文件</h2>
<p>让我们继续讨论前面提到的配置文件：</p>
<pre><code>zone ""."" {
        type hint;
        file ""/etc/bind/db.root"";
}</code></pre>
<p>之前我们已经为其写过一个分词器。现在需要为其写一个YACC语法文件并且修改那个分词器以适应YACC。</p>
<p>Example 6:</p>
<pre><code>%{
#include &lt;stdio.h&gt;
#include ""y.tab.h""    
%}

%%

zone                return ZONETOK;
file                 return FILETOK;
[a-zA-Z][a-zA-Z0-9]    yylval=strdup(yytext);return WORD;
[a-zA-Z0-9\/.-]+    yylval=strdup(yytext);return FILENAME;
\""                    return QUOTE;
\{                    return OBRACE;
\}                    return EBRACE;
;                    return SEMICOLON;
\n                     /* ignore EOL */
[\t]+                /* ignore whitespace */
%%</code></pre>
<p>仔细看你会发现yylval有所不同！我们不再期望它是一个整数，而是假设它为一个字符串。为了使其保持简单，采用了strdup并且浪费了一些内存。<br>使用字符串是因为大多数时候我们处理的是名字：文件名和区域名。稍后我们会解释如何多类型数据。</p>
<p>为了告诉YACC中yylval的类型，将下面的一行添加到YACC语法中：</p>
<pre><code>#define YYSTYPE char *</code></pre>
<p>语法本身也变得更复杂了，为了使其更容易理解，我们将其分成几个部分来介绍。</p>
<pre><code>commands:
        |
        commands command SEMICOLON
        ;

        command:
                zone_set
                ;
        zone_set:
                ZONETOKE quotedname zonecontent
                {
                    printf(""Complete zone for '%s' found \n"",$2)
                }
                ;</code></pre>
<p>上面是个引子，包含了前面提到的递归<code>根</code>，请注意我们指明了命令集以<code>;</code>结束。我们定义了一个叫<code>zone_set</code>的命令，它包含<code>ZONE</code>符号（单词zone）,后面跟着一个带引号的名称和<code>zonecontent</code>。<code>zonecontent</code>很简单：</p>
<pre><code>zonecontent:
        OBRACE zonestatements EBRACE</code></pre>
<p>它以一个<code>OBRACE</code>（{）为开始，然后跟着<code>zonestatements</code>,再跟着一个<code>EBRACE</code>(})。</p>
<pre><code>qutedame:
    QUOTE FILENAME QUOTE
    {
        $$=$2
    }</code></pre>
<p>上面定义了<code>quotedname</code>：一个在引号中间的文件名。然后特别定义：<code>quotedname</code>符号的值是<code>FILENAME</code>，即<code>quotedname</code>的值是其本身文件名，但不包含包裹着它的引号。这就是命令<code>$$=$2</code>的含意。它指：我的值是我本身的第二个部分。当quotedname在其它规则中被引用时，可通过$取其值，实际得到的值是经由<code>$$=$2</code>指定的。</p>
<pre><code>zonestatements:
        |
        zonestatements zonestatement SEMICOLON
        ;
zonestatement:
        statements
        |
        FILETOK quotedname
        {
            printf(""A zonefile name '%s' was encountered\n"",$2);
        }
        ;</code></pre>
<p>以上是<code>zone</code>块里面所有申明的框架，我们又一次看到了递归。</p>
<pre><code>block:
        OBRACE zonestatements EBRACE SEMICOLON
        ;
statements:
        | statements statement
        ;
statement: WORD | block | quotedname</code></pre>
<p>上面定义了一个块，里面包含了申明语句。<br>执行它，得到如下结果：</p>
<pre><code>$ ./example6
zone ""."" {
        type hint;
        file ""/etc/bind/db.root"";
        type hint;
};
A zonefile name '/etc/bind/db.root' was encountered
Complete zone for '.' found</code></pre>
<p><a></a></p>
<h1>5. 用c++制作解析器</h1>
<p>尽管Lex和YACC比C++要出现的早，但也可以生成一个c++版的解析器。虽然Flex包含一个可以生成c++的分词器的参数 ，但我们不会使用它，因为YACC不知道如何直接使用它们。</p>
<p>我比较喜欢通过Lex生成一个c语言文件，然后再用YACC生成c++代码。不过当你使用链接器生成你程序时，可能会遇到一些问题，因为c++代码默认不能找到C语言中的函数。除非你用<code>extren</code>申明这些函数。为了这样做，在YACC中放入如下的C代码：</p>
<pre><code>extern ""C""
{
    int yyparse(void);
    int yylex(void);
    int yywrap()
    {
        return 1;
    }
}</code></pre>
<p>如果你想申明或者改变yydebug,你得这样做：</p>
<pre><code>extern int yydebug;
main()
{
    yydebug=1;
    yyparse();
}</code></pre>
<p>你也许已经发现需要将YYSTYPE的定义放到Lex文件中，因为C++是严格类型的检查。</p>
<p>用下以方式编译：</p>
<pre><code>lex bindconfig2.l
yacc −−verbose −−debug −d bindconfig2.y −o bindconfig2.cc
cc −c lex.yy.c −o lex.yy.o
c++ lex.yy.o bindconfig2.cc −o bindconfig2</code></pre>
<p>因为YACC使用了<code>-o</code>选项，y.tab.h现在被称作bindconfig2.cc.h。<br>总结：不要将分词器编译成c++。用c++生成语法解析器时需要用<code>exetern ""C""</code>语句告诉编译器C中的函数。</p>
<p><a></a></p>
<h1>6. Lex和YACC内部工作原理</h1>
<p>在YACC文件中，main函数调用了<code>yyparse()</code>，此函数由YACC替你生成的，在<code>y.tab.c</code>文件中。</p>
<p>函数<code>yyparse</code>从<code>yylex</code>中读取符号/值组成的流。你可以自己编码实现这点，或者让Lex帮你完成。在我们的示例中，我们选择将此任务交给Lex。</p>
<p>Lex中的<code>yylex</code>函数从一个称作yyin的文件指针所指的文件中读取字符。如果你没有设置yyin，默认是标准输入(stdin)。输出为<code>yyout</code>，默认为标准输出(stdout)。</p>
<p>你可以在<code>yywrap</code>函数中修改<code>yyin</code>，此函数在每一个输入文件被解析完毕时被调用，它允许你打开其它的文件继续解析，如果是这样，yywarp的返回值为0。如果想结束解析文件，返回1。</p>
<p>每次调用<code>yylex</code>函数用一个整数作为返回值，表示一种符号类型，告诉YACC当前读取到的符号类型，此符号是否有值是可选的，yylval即存放了其值。</p>
<p>默认yylval的类型是整型（int）,但是可以通过重定义YYSTYPE以对其进行重写。分词器需要取得yylval,为此必须将其定义为一个外部变量。原始YACC不会帮你做这些，因此你得将下面的内容添加到你的分词器中，就在<code>#include&lt;y.tab.h&gt;</code>下即可：</p>
<pre><code>extern YYSTYPE yylval;</code></pre>
<p><em>Bison会自动帮你做这些。</em></p>
<p><a></a></p>
<h2>6.1 符号值</h2>
<p>前面提到过，函数yylex需要返回它遇到的符号类型，并将其值放到yylval中。这些符号经由命令<code>%token</code>定义，并对其赋值了数字类型的id号，以256开始。</p>
<p>基于此，所有ascii字符都可以作为一个符号。比方说你要写一个计算器，到目前为止，我们可以写一个如下的分词器：</p>
<pre><code>[0-9]+            yylval=atoi(yytext);return NUMBER;
[ \n]+            /*eat whitespace */;
-                return MINUS;
\*                return MULT
\+                return PLUS;
...</code></pre>
<p>语法可以是这样：</p>
<pre><code>exp:    NUMBER
        |
        exp PLUS exp
        |
        exp MINUS exp
        |
        exp MULT exp</code></pre>
<p>其实没必要这样复杂。通过使用ascii字符为符号的id,分词器可以写成这样：</p>
<pre><code>[0-9]+            yylval=atoi(yytext);return NUMBER;
[ \n]+            /*eat whitespace */;
.                return (int)yytext[0];
...</code></pre>
<p><code>.</code>匹配所有匹配的单字符。对应的语法为：</p>
<pre><code>exp:    NUMBER
        |
        exp '+' exp
        |
        exp '-' exp
        |
        exp '*' exp</code></pre>
<p>这样看起来更直接也更短了，你不需要在头部使用<code>%</code>定义那些字符。</p>
<p>这样做还有一个优点，即对于所有的输入，Lex都会匹配，避免了默认不匹配时将其输出到标准输出。比方说用户在计算器中使用<code>^</code>,会产生一个解析错误，而非将其输出到标准输出。</p>
<p><a></a></p>
<h2>6.2 递归：'右即是错'</h2>
<p>递归是YACC必不可少的。没有它，你就不能指定一个文件包含一系列的独立命令或语句。根据规定，YACC仅对第一条规则感兴趣，或者使用<code>%start</code>符号指定的起始规则。</p>
<p>YACC中的递归分为两类：左递归和右递归。大部分时候你应该使用左递归，就像这样：</p>
<pre><code>commands:    /*empty*/
        |
        commands command</code></pre>
<p>它的意思是，一个命令集要么是空，要么它包含更多的命令集以及后面跟着一个命令。YACC的工作方式意味着它可以轻松的砍掉单独的命令块（从前面）并逐步归约它们。<br>与左递归相比，右递归迷惑了大部分人，觉得看起来更好：</p>
<pre><code>commands:    /*empty*/
        |
        command commands</code></pre>
<p>但这样代价太高了。如果使用<code>%start</code>规则，需要YACC将所有的命令放在栈上，消耗很多的内存。因此尽可能使用左递归解析长语句，比如解析整个文件。<br>有时则无可避免的使用右递归，如果你的语句不是太长，你不需要想尽一切方法使用左递归。</p>
<p>如果命令有终结符，右递归看起来更自然一些,但是仍然代价昂贵：</p>
<pre><code>commands:    /*empty*/
        |
        command SEMICOLON commands</code></pre>
<p>正确的代码是使用左递归（并非我自己发明的）：</p>
<pre><code>commands:    /* empty */
        |
        commands command SEMICOLON\</code></pre>
<p>本文较早的版本使用了右递归，Markus Triska 友情斧正。</p>
<p><a></a></p>
<h2>6.3 高级yylval:%union</h2>
<p>现在，我们需要定义yylval的类型，虽然这并不总是合适的。有时我们需要处理多类型的数据。回到早前的温度调节器示例，假设我们想要能够选择一个加热器进行控制，像这样：</p>
<pre><code>heater mainbuiling
        Selected 'mainbuilding' heater
target temperature 23
        'mainbuilding' heater target temperature now 23</code></pre>
<p>我们称这这种yylval是个联合体，它即可以处理字符串，也可以是整数，但不是同时处理这两种。</p>
<p>之前说过，YACC的<code>yylval</code>类型是取决于YYSTYPE，可以想象，我们可以通过定义YYSTYPE为联合体。不过YACC有一个更简单的方法：使用<code>%union</code>语句。</p>
<p>基于例4，现在我们写出如下的YACC语法（Example 7），刚开始为：</p>
<pre><code>%token TOKHEATER TOKHEAT TOKTARGET TOKTEMPERATURE

%union {
    int number;
    char *string;
}

%token &lt;number&gt; STATE
%token &lt;number&gt; NUMBER
%token &lt;string&gt; WORD</code></pre>
<p>定义了我们的联合体，它仅包含数字和字体串，然后使用一个扩展的<code>%token</code>语法，告诉YACC应该取联合体的哪一个部分。</p>
<p>这个例子中，我们定义STATE 为一个整数，这点跟前面一样，NUMBER符号用于读取温度值。</p>
<p>不过新的<code>WORD</code>被定义为一个字符串。</p>
<p>分词器文件也有很多改变：</p>
<pre><code>%{
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include ""y.tab.h""
%}
%%
[0−9]+             yylval.number=atoi(yytext); return NUMBER;
heater             return TOKHEATER;
heat             return TOKHEATER;
on|off             yylval.number=!strcmp(yytext,""on""); return STATE;
target             return TOKTARGET;
temperature     return TOKTEMPERATURE;
[a−z0−9]+         yylval.string=strdup(yytext);return WORD;
\n                 /* ignore end of line */;
[ \t]+             /* ignore whitespace */;
%%</code></pre>
<p>如你所见，我们不再直接获取yylval的值，而是添加一个后缀指示想取得哪个部分的值。不过在YACC语法中，我们无须这样做，因为YACC为我们做了神奇的这些：</p>
<pre><code>heater_select:
        TOKHEATER WORD
        {
            printf(""\tSelected heater '%s'\n"",$2);
            heater=$2;
        }
        ;</code></pre>
<p>由于上面的<code>%token</code>定义，YACC自动从联合体中挑选<code>string</code>成员。同时也请注意，我们保存了一份$2的副本，它在后面被用于告诉用户是哪一个加热器发出的命令：</p>
<pre><code>target_set:
        TOKTARGET TOKTEMPERATURE NUMBER
        {
            printf(""\tHeater '%s' temperature set to %d\n"",heater,$3);
        }
        ;</code></pre>
<p>更多详情请参考example7.y。</p>
<p><a></a></p>
<h1>7. 调试</h1>
<p>特别是刚学习时，调度工具非常重要。幸运的是，YACC能够给出许多反馈信息。这些反馈信息需要一定的开销，你需要一些开关参数来启用它们。</p>
<p>当你编译语法文件时，在YACC命令行中增加 <code>--debug</code>和<code>--verbose</code>。在语法的C语言的头部，添加如下：</p>
<pre><code>int yydebug=1;</code></pre>
<p>这样会生成文件<code>y.output</code>,里面解释了我们创建的状态机。</p>
<p>当你运行生成的二进制，它会输出很多信息，包含状态机目前的状态，以及哪些符号被读取了。</p>
<p>Peter Jinks 写了一篇关于<a href=""http://www.cs.man.ac.uk/~pjj/cs2121/debug.html"" rel=""nofollow noreferrer"">调式</a>方面的文章，包含一些常见的错误及其处理方法。</p>
<p><a></a></p>
<h2>7.1 状态机</h2>
<p>YACC解析器内部运行着一个叫状态机的东西。这个名字暗示着这个机器有多种状态。而规则控制着状态机从一个状态到另外一个状态的改变。所有的东西起始于之前我提到的<code>根</code>的规则。</p>
<p>引用示例7中y.output的输出内容:</p>
<pre><code>state 0
    ZONETOK     , and go to state 1
    $default    reduce using rule 1 (commands)
    commands    go to state 29
    command     go to state 2
    zone_set     go to state 3</code></pre>
<p>默认情况下，这个状态经由<code>commands</code>规则归约，这是前面提到的由多个单一命令语句建立起来的递归规则形成的命令集，后跟一个<code>;</code>，也许还有更多的命令集。</p>
<p>状态一直递减，直到遇到它能理解的东西，在这个例子里，比如一个<code>ZONETOKE</code>，单词<code>zone</code>。然后它转向状态1，它将处理一个<code>zone</code> 命令：</p>
<pre><code>state 1
    zone_set  −&gt;  ZONETOK . quotedname zonecontent   (rule 4)
    QUOTE       , and go to state 4
    quotedname  go to state 5</code></pre>
<p>上面的第一行有一个<code>.</code>在里面，它指示所处的位置：我们正好遇到一个<code>ZONETOK</code>,现在寻找<code>quotedname</code>。很明显，一个<code>quotedname</code>起始于一个<code>QUTOTE</code>,而它将我们转向状态4。</p>
<p>欲进一步了解，用调试一节提到的参数编译Example 7。</p>
<p><a></a></p>
<h2>7.2 冲突：'移进/归约'，'归约/归约'</h2>
<p>只要YACC发出关于冲突的警告，可能就有麻烦了。解决这些冲突似乎是门艺术，也许会让你对那门语言理解的更深刻，远比你想知道的多。</p>
<p>解决问题围绕着如何解释一系列的符号。假设我们定义了一门语言，它需要接收一系列的命令：</p>
<pre><code>delete heater all
delete heater number1</code></pre>
<p>为此，我们这样定义语法：</p>
<pre><code>delete_heaters:
        TOKDELETE TOKHEATER mode
        {
                deleteheaters($3);
        }
mode:    WORD
delete_a_heater:
        TOKDELETE TOKHEATER WORD
        {
                delete($3);
        }</code></pre>
<p>也许你已经感觉到了有问题。状态机开始读入单词'delete'，然后需要由接下来的符号决定转向哪。这个接下来的符号即可以是一个<code>mode</code>，指明了如何删除加热器，或者一个待删除的加热器。</p>
<p>但问题出自于这两个命令的下一个符号是WORD。YACC不知道应该要怎样做，这导致了一个'归约/归约'警告，以及一个更具体的警告：'delete_a_heater'永远不能被访问。</p>
<p>这个示例的冲突很容易解决（例如，将第一个命令重命名为'delete heaters all'，或者将'all'单独定义为一个符号），但是有时却非常困难。用--verbose标记生成的y.output文件能够起到很大的帮助。</p>
<p><a></a></p>
<h1>8. 深度阅读</h1>
<p>GUN YACC (Bison)带有一个很常不错的info文件（.info），它是非常好的YACC语法文档，除了里面仅提到了一次Lex,其它的都还好。可以使用Emacs阅读info文件，或者非常不错的工具pinfo。</p>
<p>Flex有一个不错的用户手册，如果你已经理解Flex是做什么的，它还是非常有用的。</p>
<p>读完了这个Lex和YACC介绍，你可能想找到更多的信息。虽然以下的书我一本都没看过，不过听说不错：</p>
<ol>
<li><p>Bision-The Yacc-Compatible Parser Generator</p></li>
<li><p>Lex&amp;Yacc</p></li>
<li><p>Compliers: Principles,Techiniques,and Tools</p></li>
</ol>
<p>Tohmas Niemann 写了一篇<a href=""http://epaperpress.com/y_man.html"" rel=""nofollow noreferrer"">文档</a>，讨论如何使用Lex和YACC写一个编译器和计算器。<br>usenet新闻组com.compilers也是非常有用的，不过请记住，那些人并非专门服务支持，在你发贴之前，阅读他们的感兴趣的<a href=""http://compilers.iecc.com/"" rel=""nofollow noreferrer"">页面</a>，特别是<a href=""http://compilers.iecc.com/faq.txt"" rel=""nofollow noreferrer"">FAQ</a></p>
<p><a href=""http://www.cs.utexas.edu/users/novak/lexpaper.htm"" rel=""nofollow noreferrer"">Lex-A Lexical Analyzer Generator</a>，M.E.Lesk and E.Schmidt，最原始的论文。<br><a href=""http://www.cs.utexas.edu/users/novak/yaccpaper.htm"" rel=""nofollow noreferrer"">Yacc: Yet Another Compiler</a></p>
<p><a></a></p>
<h1>9. 感谢</h1>
<ul>
<li><p>Pete Jinks &lt;pjj%cs.man.ac.uk&gt;</p></li>
<li><p>Chris Lattner &lt;sabre%nondot.org&gt;</p></li>
<li><p>John W. Millaway &lt;johnmillaway%yahoo.com&gt;</p></li>
<li><p>Martin Neitzel &lt;neitzel%gaertner.de&gt;</p></li>
<li><p>Esmond Pitt &lt;esmond.pitt%bigpond.com&gt;</p></li>
<li><p>Eric S. Raymond</p></li>
<li><p>Bob Schmertz &lt;schmertz%wam.umd.edu&gt;</p></li>
<li><p>Adam Sulmicki &lt;adam%cfar.umd.edu&gt;</p></li>
<li><p>Markus Triska &lt;triska%gmx.at&gt;</p></li>
<li><p>Erik Verbruggen &lt;erik%road−warrior.cs.kun.nl&gt;</p></li>
<li><p>Gary V. Vaughan &lt;gary%gnu.org&gt; (read his awesome Autobook) • Ivo van der Wijk ( Amaze Internet)</p></li>
</ul>

                ", 如何使用Lex/YACC,1531978033,311,1,709,1,1,https://segmentfault.com/a/1190000000396608
127,1,0,9,"
                    
<p>除了部分变态公司，大部分小伙伴们应该都已到家或是在回家的路上了。在惯常的生活中忙碌了一年，过年的这几天，应该放轻松些，回归我们本来的角色。去做一个好儿子，一个好女儿，陪父母买菜、做饭、打牌、聊天。攻略君打算求外婆亲手煮一碗醪糟鸡蛋，攻略君在刚刚学会爬的时候，就已经知道偷吃外婆做的醪糟啦！用自己家酿的醪糟，开极小的火慢慢煮，唯有外婆的爱，才能做出一颗完美至极的糖心蛋。</p>

<p>这样的美事，还有很多很多，在这个假期忘记一切，尽情沉浸在生活中吧。</p>

<p>攻略君要给大家送上一份特别的新年礼物，来自技术人攻略访谈的一号男嘉宾——<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup/1190000000326245"">水羽哲</a>。他在写程序之余还作画，而且在不经意间加入了很多大家熟悉的元素，你会发现HTML5, Java+Tomcat, Github，Linux，Hello world，BAT...... 非常有趣吧，祝大家来年继续加油，不忘初心，成为更好的自己！<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><strong>雨中的白猫</strong><br>
雨天来临，虽然无处栖身，但是终于却可把一身的泥垢冲掉！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>喝可乐的面具男</strong><br>
面具男，大家都会熟悉，角色来自于宫崎骏的动画《千与千寻》，用一句比较文邹邹的话来说：你看不见我的脸，但是你能看到我的心……奥，不，我的可口可乐！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>FishShop, No Fish!</strong><br>
人生中总有给你满满的希望却又落空的时候，拉起行囊，接着走！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>小伙伴们都惊呆了</strong><br>
小伙伴们都惊呆了，额……完全是为了体现这句话！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>Waiting…</strong><br>
与其无奈的站着，不如像那只猫那样开心的期待着！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQrZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>Hello World, Never Stop!</strong><br>
铃木峻隆说要有初心！用我们写代码的人来说就是总会倒腾新的Hello World，所以，探索新的世界，永不止步！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQr0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>Fly In Your Dream</strong><br>
入夜，趴在叶子上的瓢虫们也都睡了，但夜在飞……</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQr1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>Your Octocat Dream</strong><br>
Octocat，也就是Github的章鱼猫，希望章鱼猫入梦！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQr3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br><strong>Go With The Wind</strong><br>
随风摇曳，落在哪里，在哪里成长！</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbQr4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
这幅画专门送给技术人攻略的读者，技术人追求自由、藐视权威、热爱生活的精神，很像BAT man哦！用技术去创造更多奇迹吧！</p>

<p>想更多了解这些画的作者，请看这篇文章<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup/1190000000326245"">《技术人攻略访谈一：我不是程序员! Just coding for fun!》</a></p>

<hr>
<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @<a rel=""nofollow"" href=""http://weibo.com/devlevelup"">devlevelup</a>，希望能成为技术人成长的精神家园。<br>
欢迎通过微信公众账号关注技术人攻略<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxHi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>感谢<a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a>提供<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup"">博客专栏</a>及推广支持。<br>
感谢<a rel=""nofollow"" href=""http://www.speedycloud.cn"">迅达云成</a>提供云主机及技术支持。</p>

                ", 春节特刊——做自由的蝙蝠侠,1531978035,543,1,988,1,1,https://segmentfault.com/a/1190000000400887
128,1,0,9,"
                    
<p>以下所列出的链接均为在线文档，有志于信息安全的爱好者可由此作为入门指南。</p>

<h2>常规知识</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.mhprofessional.com/downloads/products/0072254238/0072254238_ch01.pdf"">Sun认证-Solaris 9&amp;10安全管理员学习指南</a></p></li>
<li><p><a rel=""nofollow"" href=""https://picoctf.com/learn"">PicoCTF资料</a></p></li>
</ul>
<h2>应用软件安全</h2>

<ul>
<li><a rel=""nofollow"" href=""https://www.owasp.org/index.php/Secure_Coding_Principles"">OWASP安全编码规范</a></li>
</ul>
<h2>漏洞挖掘</h2>

<ul>
<li><a rel=""nofollow"" href=""http://msdn.microsoft.com/en-us/library/bb430720.aspx"">Windows ISV软件安全防御</a></li>
</ul>
<h2>移动安全</h2>

<ul>
<li><a rel=""nofollow"" href=""https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks"">OWASP十大移动手机安全风险</a></li>
</ul>
<h2>网络安全</h2>

<ul>
<li><a rel=""nofollow"" href=""http://technet.microsoft.com/en-us/library/cc959354.aspx"">常规网络攻击类型</a></li>
</ul>
<h2>逆向工程</h2>

<ul>
<li><p><a rel=""nofollow"" href=""https://class.coursera.org/hwswinterface-001/class"">华盛顿大学：硬件/软件接口</a></p></li>
<li><p><a rel=""nofollow"" href=""https://class.coursera.org/malsoftware-001/class"">伦敦大学：恶意软件和地下产业——一个巴掌拍不响</a></p></li>
</ul>
<h2>Web安全</h2>

<ul>
<li><a rel=""nofollow"" href=""https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project"">OWASP十大Web应用安全风险</a></li>
</ul>
<h2>多学科课程</h2>

<ul>
<li>
<p><a rel=""nofollow"" href=""http://isislab.github.io/Hack-Night/"">ISIS实验室黑客之夜</a></p>

<p>涉及源码审计、Web安全、逆向工程、漏洞挖掘、Post-Exploitation、应用软件安全</p>
</li>
<li>
<p><a rel=""nofollow"" href=""http://www.opensecuritytraining.info/Training.html"">开放式安全训练</a></p>

<p>涉及逆向工程、漏洞挖掘、取证技术、恶意软件分析</p>
</li>
<li>
<p><a rel=""nofollow"" href=""http://www.cs.fsu.edu/~redwood/OffensiveSecurity/"">佛罗里达州立大学：安全攻击</a></p>

<p>涉及源码审计、应用软件安全、漏洞挖掘、网络安全、Web安全、Post-Exploitation</p>
</li>
<li>
<p><a rel=""nofollow"" href=""http://www.cis.syr.edu/~wedu/seed/all_labs.html"">雪域大学SEED：发展教学实验室计算机安全教育</a></p>

<p>涉及漏洞挖掘、网络安全、Web安全</p>
</li>
<li>
<p><a rel=""nofollow"" href=""https://www.coursera.org/course/security"">斯坦福大学：计算机安全</a></p>

<p>涉及漏洞挖掘、网络安全、移动安全、应用软件安全、Web安全、恶意软件分析</p>
</li>
<li>
<p><a rel=""nofollow"" href=""http://www.offensive-security.com/metasploit-unleashed/Main_Page"">Metasploit重磅出击</a></p>

<p>涉及网络安全、应用软件安全、漏洞挖掘、Post-Exploitation</p>
</li>
</ul>
<h2>密码学</h2>

<ul>
<li><p><a rel=""nofollow"" href=""https://www.coursera.org/course/crypto"">斯坦福大学密码学Ⅰ</a></p></li>
<li><p><a rel=""nofollow"" href=""https://www.coursera.org/course/crypto2"">斯坦福大学密码学Ⅱ</a></p></li>
</ul>
<h2>漏洞利用</h2>

<ul>
<li><a rel=""nofollow"" href=""http://www.corelan.be/index.php/articles/"">Corelan团队文章集</a></li>
</ul>
<h2>逆向工程</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.binary-auditing.com/"">Thorsten Schneider博士：二进制代码审计</a></p></li>
<li><p><a rel=""nofollow"" href=""http://tuts4you.com/download.php?list.17"">Lena的教程：恶意软件分析</a></p></li>
<li><p><a rel=""nofollow"" href=""http://mammon.github.com/tales/"">mammon's tales to his grandson</a></p></li>
</ul>
<h2>程序分析</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://www-i2.informatik.rwth-aachen.de/i2/spa12/"">亚琛工业大学：静态程序分析</a></p></li>
<li><p><a rel=""nofollow"" href=""https://wikis.mit.edu/confluence/display/satsmtschool11/SATSMT+Summer+School+2011"">麻省理工学院：SAT/SMT 2011年暑期大学</a></p></li>
</ul>
<h2>Web安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""https://pentesterlab.com/"">渗透测试实验室</a></p></li>
<li><p><a rel=""nofollow"" href=""https://www.owasp.org/index.php/OWASP_Appsec_Tutorial_Series"">OWASP应用安全系列教程</a></p></li>
</ul>
<h2>多学科资源</h2>

<ul>
<li><p><a rel=""nofollow"" href=""https://github.com/isislab/Project-Ideas/wiki"">ISIS实验室Wiki资源</a></p></li>
<li><p><a rel=""nofollow"" href=""http://blog.g0tmi1k.com/2011/11/blog-guides-links.html"">博客、订阅、指南和链接</a></p></li>
<li><p><a rel=""nofollow"" href=""http://vulnhub.com/"">VulnHub</a></p></li>
</ul>
<h2>应用软件安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://www.hpenterprisesecurity.com/vulncat/en/vulncat/index.html"">HP Fortify Taxonomy：软件安全错误</a></p></li>
<li><p><a rel=""nofollow"" href=""http://pentest.cryptocity.net/appsec-readings/"">应用软件安全读物</a></p></li>
<li><p><a rel=""nofollow"" href=""http://www.fuzzing.org/"">Fuzzing</a></p></li>
</ul>
<h2>CTF比赛</h2>

<ul>
<li><p><a rel=""nofollow"" href=""https://github.com/isislab/Project-Ideas/wiki/Capture-The-Flag-Competitions"">CTF比赛</a></p></li>
<li><p><a rel=""nofollow"" href=""http://captf.com/practice-ctf/"">WarGames</a></p></li>
<li><p><a rel=""nofollow"" href=""http://ctf.forgottensec.com/wiki/index.php?title=Main_Page"">Forgotten Security's CTF Wiki</a></p></li>
<li><p><a rel=""nofollow"" href=""https://ctftime.org/"">CTFtime</a></p></li>
</ul>
<h2>嵌入式设备安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://dontstuffbeansupyournose.com/2011/08/25/hardware-hacking-for-software-people/"">软件人员的硬件黑客技术</a></p></li>
<li><p><a rel=""nofollow"" href=""https://media.blackhat.com/us-13/US-13-Bathurst-Methodologies-for-Hacking-Embdded-Security-Appliances-Slides.pdf"">嵌入式安全设备的黑客方法</a></p></li>
<li><p><a rel=""nofollow"" href=""https://docs.google.com/viewer?a=v&amp;q=cache:tc9Kpqta3UYJ:cansecwest.com/csw07/csw07-jack.pdf+exploiting+embedded+systems&amp;hl=en&amp;pid=bl&amp;srcid=ADGEESgo-tNzjs6Hz_meted5Ni_V7FfIcXmI6nQidQcbE_5viPxWDop8zmrrCZWAin1RkzHcp9PciUUWL46MXnx7IKL_YogQDzSFW9rTI8kqwLjz-NKCjXW1bFgxPtLw3SCgpmiOVuJ-&amp;sig=AHIEtbQ-eLW-oDI_wmxdT5o5hGvmxqi8-A"">巴纳比.杰克：嵌入式系统的漏洞挖掘</a></p></li>
<li><p><a rel=""nofollow"" href=""http://vimeo.com/album/1632121"">斯蒂芬.雷德利：硬件黑客视频</a></p></li>
</ul>
<h2>漏洞挖掘</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://insecure.org/stf/smashstack.html"">Smashing The Stack For Fun And Profit</a></p></li>
<li><p><a rel=""nofollow"" href=""http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html"">返回指标程序设计（ROP）的介绍</a></p></li>
<li><p><a rel=""nofollow"" href=""http://myne-us.blogspot.com/2010/08/from-0x90-to-0x4c454554-journey-into.html"">漏洞挖掘之旅</a></p></li>
<li><p><a rel=""nofollow"" href=""http://pastebin.com/aqGvjhgB"">不同漏洞的资源列表</a></p></li>
</ul>
<h2>移动安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://vimeo.com/51270090"">自动动手攻击移动堆</a></p></li>
<li><p><a rel=""nofollow"" href=""http://intrepidusgroup.com/insight/2013/02/armor-for-your-android-apps-shmoocon-follow-up/"">IG初学者</a></p></li>
<li><p><a rel=""nofollow"" href=""https://code.google.com/p/owasp-igoat/"">OWASP igoat</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/jackMannino/OWASP-GoatDroid-Project"">OWASP GoatDroid</a></p></li>
</ul>
<h2>网络安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/OSI_model"">OSI模型</a></p></li>
<li><p><a rel=""nofollow"" href=""http://nmap.org/book/toc.html"">Nmap网络扫描</a></p></li>
</ul>
<h2>安全项目</h2>

<ul>
<li><a rel=""nofollow"" href=""https://github.com/isislab/Project-Ideas/issues"">ISIS实验室项目创意</a></li>
</ul>
<h2>逆向工程</h2>

<ul>
<li><a rel=""nofollow"" href=""http://en.wikibooks.org/wiki/X86_Assembly"">X86汇编</a></li>
</ul>
<h2>Web安全</h2>

<ul>
<li><p><a rel=""nofollow"" href=""http://google-gruyere.appspot.com/"">Google Gruyere</a></p></li>
<li><p><a rel=""nofollow"" href=""https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project"">OWASP代罪羔羊计划</a></p></li>
<li><p><a rel=""nofollow"" href=""http://www.dvwa.co.uk/"">Damn Vulnerable Web Application (DVWA)</a></p></li>
</ul>
<hr>
<p>原文 <a rel=""nofollow"" href=""http://www.reddit.com/r/netsec/wiki/start"">Getting Started in Information Security</a><br>
翻译 <a rel=""nofollow"" href=""http://blog.idf.cn/2013/09/getting-started-in-information-security/"">IDF实验室</a></p>

                ", 信息安全入门指南,1531978036,555,1,167,1,1,https://segmentfault.com/a/1190000000389864
129,1,0,9,"
                    <p>SF的用户粘性挺高的，总是有一群人活跃在这里，把这里当作奋斗之余一个安静的小小世界，这也算是SF团队对互联网思维很好的把握吧。其中Sunny在工作的时候，还不忘深入基层与QQ群里的水友们谈笑风生及时回答基友们的各种问题（搞得我们大家都不敢说他坏话生怕他突然间冒出来），这种对用户群体的重视很值得学习。还有各位如70，五花肉等小伙伴们在台前幕后的幸苦劳作也值得称道（据说有什么任务没有完成，sf办公室第二天门口就会出现三块肥皂不知道是不是真的）。</p>

<p>我一个同学曾经说过“情绪是可以蔓延的”，没错，其实我本来很不善于写文章，而且也很不愿意去写的，但是看过Fakefish和五花肉等等同学的年终总结之后感觉，嗯，我也是有过去的人，作为一个又过去的人我也应该写点什么。我捋了捋自己两个月没有打理过的刘海，扶了扶已经掉漆且略带灰尘的镜框，闭上眼睛不禁陷入沉思，脑海中的思绪好像海风吹着浪花拍打着暗礁一般，将我带回到2013年初（其实我本来是想从我小学二年级开始写的）。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJzs"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""veer 拍摄的照片""></span></p>

<p>二号的时候我的手机Lumia710在街上丢了。迫于经济压力，我只能选择1000圆以下的手机。这个价格对我的压力很大，并不是因为这个价位的机器少，而是因为1000圆以下的手机品质不行，拿出手不能凸显我的逼格。对于这个在新年奖金之前填补空缺手机的选择，我很是苦恼。最后，我决定用回曾经被我遗弃的手机（其实也是丢了）-- hp veer。这手机十分小巧，虽然用的语言是js，但运行速度出人意料的快，一个多月的使用时间里每次滑动都那么让我顺心，从来没有在我向小伙伴们炫耀的时候突然卡死而出现令人尴尬的局面。作为一个不到500圆的手机，Veer的种种优秀让我十分惊奇，就连它的成像水平都那么让我感动，（上图就是用veer拍摄的，注:那不是我家）。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJzl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enyo""></span></p>

<p>随着我对它的迷恋一步步加深，我经不住诱惑，剥开了它的外壳，进入了它的内心。。。</p>

<p>进入手机开发者模式之后就能查看系统文件了。软件包安装的方式一目了然，而且各种程序都是Js写的，自带的程序甚至都没有经过压缩，底层的库也都是将空格回车进行删减而已，系统非常容易修改。当时自己每晚都沉溺于修改系统之中，也是在那个时候第一次接触到了diff这个命令，还有web框架。在每晚搞机之余，我还不忘向初学者们传道授业解惑，记得那时候我跟一个基本不懂编程的小白，讲了一晚上的命令行，管道，标准输入，标准输入这些概念。那天晚上我又不禁的捋了捋头发，回想到5、6年前的我，自己一个人学编程，遇到问题只能去ubuntu form求救，而且经常还找不到答案，没有人帮，没有人指导，真是件痛苦的事情。</p>

<p>后来的时间我又学习了enyo框架，nodejs等技术。突然之间感觉视野开阔了许多，原来网页还可以这么写，js还可以这么用。我用enyo配合nodejs写了一个基于web的文件管理器，假设在Raspberry Pi上，明显感觉逼格又上了一个档次。从那之后我基本就专注于js了，其它的语言虽然也学，但心底里已经成为一个js的死忠了。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJzk"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""桌子上的书""></span></p>

<p>那时候我一个人住在宿舍，自己打扫房子，自己给自己做饭。我这个超级大懒虫把自己的书整理了一下，还特意拍了个照片留作纪念（其实是发到qq上装逼用的）。看到这么多书心中不禁感叹，知识真是个很神奇的东西，越学越觉得少，觉得自己很无知。以前的读书人总是说自己“不才”，别人都是以为他是在谦虚，其实我觉得吧，谦虚就是个托词，他那是真的觉得自己懂得太少了。就好象我们以前只知道编程这个概念，不会也只是不会编程罢了，但当我们学习了之后才认识到这里还有前段后端，服务器维护，数据分析等等一大堆的分支，了解之后才不寒而栗。知识就是个三角形的坑，而我们学习就好比从上面向下挖，越挖这个坑越大，到最后我们都看不到边在哪了，我们需要重新审视自己和世界，重新定位自己。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJzD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""angularjs""></span></p>

<p>中间这大半年我都不知道自己在干嘛，可能应为工作太忙了（我会告诉你我的工作其实是外贸公司业务员而不是程序员吗），期间连续上班四个月没放过假，都没怎么碰过代码。后来我接手了一些关于产品管理的工作，但用excel整理资料这件事却让我难以接受，我决定用我的智慧改变这一切。</p>

<p>当时国内好像只有新浪有类似GAE的服务，而且好像只支持PHP和JAVA，于是我用PHP写了一个用于管理产品信息的Webapp，我还给这类程序起了个高端大气上档次的名字：Product Management System (PMS)。因为时间比较短，只花了一个星期，而且我也不怎么懂PHP，所以写出来的Webapp满身都是BUG，但勉强还能用，而且也只有我自己会用。PHP每个变量使用的时候前面都要加上一个’$‘,而且驼峰式命名与下划线式并用，这叫我一个恨啊。还有各种对PHP不熟悉导致出乎意料的后果，真是数不尽道不完啊。</p>

<p>我深刻反思了这件事，最后我想起一句话：”既然不爱，为什么还要在一起呢？“，于是我一拍桌子一跺脚，重写！在吸取过上次PHP失败的教训之后，这次在开始写代码之前我就对项目做了细致的规划，前端MV*,后端MVC都要有，而且要RESTful风格，对移动终端支持要友好，压缩JS代码，自动构建什么玩意儿的都要有。从那时到现在，大概有2－3个月了吧，我依然在做这个项目。大体上已经完成了，但还有几个功能没有完成，正在做。当然了，现在代码的增长速度很慢，考虑架构的更多了，考虑具体实现自然就少了。同时这个时候也开始意识到自己功底的薄弱，尤其是数学。</p>

<hr>

<p>其实我一直有个心愿，而在2014年我很想去实现它，那就是我要当程序猿（别吐槽我）。<br>
我有一条座右铭：“有些事情你做了不一定成功，但如果不做的话肯定会后悔”。<br>
我觉得如果我不当程序猿，而安心于现在工作的话，我将来肯定会后悔，就好像我今年年初没有买比特币，而到11月份看到它突破黄金价格时的感觉一样。这种感觉不是没有得到什么，而是失去了什么，失去了机会，甚至是难得的机会。</p>

<p>我希望今年我能离开现在工作的岗位，去到另一个城市，找到一份写代码的工作，开始我的新生活。</p>

                ", 2014，我有话说,1531978037,542,1,774,1,1,https://segmentfault.com/a/1190000000374471
130,1,0,9,"
                    
<p>以GitHub为代表的新一代代码协作平台开创了协同开发的新时代。开发者之间基于代码的协作从来没有像今天这样顺畅。GitHub上向你发送合并请求的开发者，可能和你分处大洋两岸，也可能和你同在一间办公室。上个礼拜，GitHub<a rel=""nofollow"" href=""https://github.com/blog/1724-10-million-repositories"">宣布其上托管的git仓库已经突破一千万大关</a>！</p>

<p>国内也有不少代码协作平台，本文介绍国内几个主要的代码协作平台，一起来看看吧。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJut"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""git""></span></p>

<h2>GitCafe</h2>

<p><a rel=""nofollow"" href=""http://gitcafe.com"">GitCafe</a>是一个基于代码托管服务打造的技术协作与分享平台，最近刚刚获得景林资产300万人民币天使轮投资。</p>

<p>Git是目前世界上最流行最优秀的项目版本控制系统之一，Cafe的意思为咖啡馆，象征着程序员文化。</p>

<p>GitCafe界面十分简洁清爽，左右分栏的设计，使得浏览仓库代码十分便利。提供工单、wiki和页面服务。支持在线编辑功能，代码的修改、提交和合并请求，都可以在浏览器中完成。GitCafe的公有仓库免费，私有仓库需付费。付费功能使用极特币(gitcoin)，是一个很有趣的设计。</p>

<p>GitCafe目前还缺乏Webhook和API功能，因此其他应用或服务要支持GitCafe非常困难。</p>

<h2>gitshell</h2>

<p><a rel=""nofollow"" href=""https://gitshell.com/"">gitshell</a>是基于django开发的git代码协作平台。</p>

<p>GitShell的设计，有一个显著的特点，就是专注于git代码仓库本身，也就是UNIX哲学的“只做一件事，并且把它做好”。虽然GitShell自身不提供维基、工单等项目协作常用的功能，但是GitShell支持webhook，可以与第三方的代码协作应用服务（包括维基、工单等）无缝结合。</p>

<p>GitShell可以直接使用GitHub账号登录，新建项目的时候可以导入其他git仓库，其webhook服务也与GitHub兼容，方便新用户使用和旧项目的迁移。</p>

<p>代码是程序员最宝贵的资产，因此GitShell还提供Dropbox备份。</p>

<p>GitShell上可以免费创建公有和私有项目。</p>

<h2>CSDN</h2>

<p><a rel=""nofollow"" href=""http://code.csdn.net"">code.csdn</a>是CSDN推出的代码协作平台。基于Gitlab搭建，支持维基、工单等功能。</p>

<p>CSDN是国内最大的程序员社区，然而却常常给人老旧、笨重的感觉，总之就是和酷字不沾边。不过code.csdn的设计还不错，特别是它提供了代码片段功能，而且代码片段与CSDN的博客实现了双向绑定，在CSDN的博客中可以很方便地引用code.csdn中的代码片段，同时，在CSDN博客中插入的代码片段也会自动保存到code.csdn。</p>

<h2>京东</h2>

<p><a rel=""nofollow"" href=""https://code.jd.com"">code.jd</a>是京东（是的，你没看错，就是那个卖东西的京东，他们也开始提供代码托管了……）提供的代码协作平台，功能和界面和CSDN比较接近，应该也是基于Gitlab搭建的。由于功能、设计和CSDN大同小异，这里就不重复介绍了。</p>

<p>CSDN和京东都可以免费创建公开和私有项目。</p>

<h2>oschina</h2>

<p><a rel=""nofollow"" href=""http://git.oschina.net"">oschina的git代码托管服务</a>公开、私有项目均免费，功能也比较全面。oschina支持GitHub、Google、weibo、Windows Live账户登录，比较方便。</p>

<p>oschina刚上线的时候，直接用了GitHub的样式——不是模仿，也不是像素级拷贝，而是字面意义上的“直接用了”，甚至连css中的<code>github</code>字样也没有修改。</p>

<p>即使是现在，整个oschina的用户界面设计布局也和GitHub十分相像——GitHub用户使用git.oschina，会有强烈的既视感。</p>

<p>除了细节处理没有GitHub精美外，GitHub的各种酷炫的交互设计，比如键盘快捷键操作工单、唤出命令接口等功能oschina都没有采用。</p>

<p>毕加索有一句名言：”Bad artists copy, great artists steal.“（劣工摹其形，巧匠摄其魂。）虽然git.oschina样式布局方面大量拷贝GitHub，但显然没有偷到GitHub界面设计的精髓。</p>

<h2>gitcd</h2>

<p><a rel=""nofollow"" href=""http://www.gitcd.com"">gitcd.com</a>是基于gitc的代码协作平台。gitc使用Java开发，技术设计上有一些值得关注的特性，例如：</p>

<ul>
<li>gitc的ssh服务使用apache sshd，自行解析upload-pack和receive-pack的报文格式。</li>
<li>使用jgit读取git仓库信息。</li>
<li>页面展示部分使用了lucene搜索引擎，对每个分支最近一次RevCommit进行索引，该技术的应用，使得gitcd.com上仓库各个分支树在网页上浏览速度平均&lt;200毫秒(实际一般是80毫秒左右)。</li>
</ul>
<p>gitcd同样支持webhook，还可以设置SMS提醒。gitcd的权限控制粒度较细，可以限制分支提交，对某些流程严格的企业而言十分有用。</p>

<p>gitcd的界面比较简陋，用户注册的流程也很麻烦，注册成功的邮件给出的链接无法访问，而且需要绑定手机才能创建项目。</p>

<p>目前支付宝的团队使用gitcd托管代码，除此以外，gitcd.com上其他的公开项目很少，活跃用户也很少。</p>

<h2>svnchina</h2>

<p><a rel=""nofollow"" href=""http://www.svnchina.com"">svnchina</a>于2006年成立，是国内第一家支持私有项目的SVN源代码托管平台。</p>

<p>svnchina的收费策略为项目创建者需交纳年费，项目协作者免费。项目创建者交纳99元的年费后，可创建任意数量的项目，但空间使用不能超过1G.如果需要更多的空间，可以选择更高的年费。</p>

<p>svnchina最初的创始人为冯华君，其开发的FIT输入法曾是中国市场占有率最高的Mac系统第三方中文输入法。</p>

<h2>geakit</h2>

<p><a rel=""nofollow"" href=""https://geakit.com"">集盒</a>是2012年推出的基于git的代码协作平台。提供项目、工单等功能。集盒有一个非常方便、有用的特性——项目分组功能，可以通过分组功能对自己创建、参与、关注的项目进行分类。这个分类功能对于组织仓库非常方便。CSDN的代码协作平台在2013年11月底也加上了这个功能。</p>

<p>可惜的是2013年以来集盒的开发趋于停滞。目前，网站引用的css等静态资源已经无法访问，https的证书也已经过期。</p>

<h2>TaoCode</h2>

<p><a rel=""nofollow"" href=""http://code.taobao.org"">TaoCode</a>是淘宝推出的开源项目协作平台。目前bug不少，注册、创建、删除项目常出问题。其上的活跃用户主要是阿里内部人员。</p>

<h2>灰狐</h2>

<p>2011年，盛大创新院推出免费开源代码托管平台TeamHost，该平台基于Redmine进行二次开发。最初有很多计划，除了常见的代码托管功能外，还希望集成测试、持续构建、freelancer、招聘、IM、微博、P2P等功能。</p>

<p>后来Teamhost项目的所有成员都离开了盛大创新院，于是站点搬到了灰狐社区赞助的服务器上。然而随着团队成员工作的日益繁忙，Teamhost的开发趋于停滞状态，在2013年7月11日正式宣布关闭。</p>

<p>关闭之后，灰狐接手了Teamhost的代码和用户，继续运作。由于teamhost.org域名为盛大所有，而盛大DNS已经停止解析这个域名，所以启用了新域名 <a rel=""nofollow"" href=""http://code.huihoo.com"">code.huihoo.com</a>。</p>

<p>然而灰狐的开发也并不活跃，甚至连注册页面也仍然引用了teamhost旧域名的邮件地址。</p>

<p><strong>Update</strong> 后起之秀 <a rel=""nofollow"" href=""https://coding.net"">Coding.net</a> 值得一试，我的印象是它的迭代速度十分迅猛，有<a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform/1190000002389696"">演示平台</a>和代码质量分析（虽然我试下来对 Ruby 的效果很一般），私有仓库免费，有 <a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform/1190000002429065"">Android 和 iOS 的客户端</a>（开源的哦！）。以后有时间我会补上相关的评测，目前可以看 <a rel=""nofollow"" href=""http://segmentfault.com/blog/codingcloudplatform"">Coding.net 在此开的博客</a> 了解详情。</p>

<hr>
<p>欢迎分享使用这些平台的体验！你可以直接在下面评论。</p>

<p>撰文 <a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a></p>

                ", 细数国内代码协作平台,1531978039,444,1,650,1,1,https://segmentfault.com/a/1190000000374128
131,1,0,9,"
                    <p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJxv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在长城""></span><br>
  伴随着成长的总是泪水。</p>

<p>今年，从年初开始吧，生日是二月十号，那一天，宁波下着小雪，听着街上的烟花声，2012年就这么偷偷地离去。</p>

<p>三四月的时候，想着早些去实习，去了CC他们住的地方，想写个网站练练手，顺便用来面试。当时就知道点php，看完犀牛书，然后用原生js和原生php写了个类似微博的纯ajax的系统，当时自己想了个前后台连接方式，就是有一个edit文件同时处理CURD操作，后来才知道RESTfull就是类似这样的方式。不过，后来觉得基础不行，就没去投简历，回到学校开始看js高级程序设计。</p>

<p>然后就是找实习的五月了，那个时候参加了一次杭州的GDG，虽然主题是程序猿。然后认识了郑洋飞。后来他暑假去了淘宝实习系统工程师。那个时候，阿里暑假实习的校招简历没过。然后面了百姓，被小鱼拒了，被简书以距离远而被拒，问高阳要不要实习生。那个时候tree在知乎问说找实习被拒3次了，不知道怎么办，我回答了，就被tree勾搭了。同时也认识了linkgod。之后就面了云适配，不久就收到offer。那个时候其实蛮纠结的，北京这么远，心里有些害怕。但是家里挺支持，tree说去北京多好的经历，老婆婆说欢迎来北京。就决定暑假先去北京看看。</p>

<p>然后便是六月，弄完学校里的事，去了趟ADC，见了tree，芋头，见到了很多曾经只知道id的人。回去之后第三天就坐了高铁去了北京。</p>

<p>原本以为邻居的亲戚会很靠谱的，在北京的第二天就发烧了，可是还要等他，限号急事，在宾馆住了好几天，带我找了一次房子之后。我就跑去找老婆婆了，然后第二天在他旁边的小区找了个房子住下。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbJxw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""与老婆婆""></span></p>

<p>在北京开始工作生活之后才发觉北京真的好大，光坐地铁都要坐好久。有段时间天天在微软食堂吃饭，看里面的那些人，觉得自己和他们吃的同样的食物，却做不出同样的贡献。tree叫我不要这么想，不然她怎么活。</p>

<p>然后和同事逛了很多地方，有一次大家在一个公园（忘了叫什么TAT）的草地上打了一下午的牌。</p>

<p>离开前最后一晚，和同事去中关村那里的一家烧烤城吃了烧烤，路过新东方的时候，看到有位流浪歌手，吉他盒里贴着一张纸，上面写着“为梦想而歌唱”。回公司拿东西，看着窗外的微软大厦新东方大厦，不知道怎么描述那个时候的心情。</p>

<p>回浙江。提前买了三折的机票，估摸着时间不够，就提前跑过去机场过夜，去机场的地铁上和一个同龄的中东帅哥聊天，他说他来北京一年了，学的法学。</p>

<p>然后去了阿里校招的面试，那天最后一个，面完外面等了一会，说回去等通知，那个时候不自觉地苦笑了。</p>

<p>之后就是学校一堆事。</p>

<p>那天晚上，突然看到SF发了一个招聘帖，看完想了会，高阳就发qq过来问我要来试试么。那就试试吧。那个时候，问tree来不来，推荐投市场，然后她就来了。</p>

<p>中途了去了携程UED大会，认识了小鱼大漠小志，和小鱼聊了会，他说其实我已经不错了，他刚毕业那会真什么都不会。</p>

<p>前几天在学校里，看到大城小胖录了个视频，聊梦想。那个时候我已经决定毕设做canvas页游，大一的时候梦想着毕设一定要做个牛逼的东西。回想起暑假回家的时候，翻到初中时候的本子，上面写着“我将来要当游戏工程师，改变中国游戏界”。现在觉得，后者可能做不到，前者可以做个牛逼的游戏证明一下。</p>

<p>很多时候，讲梦想这东西真矫情。</p>

<p>大一的时候，自己规划了一个毕业后约十年计划，去工作三年五年，然后旅游一年半年，再创业三年，没成功就找个大公司或者回宁波开个什么店养老。</p>

<p>梦想像是一种推动器，同时也是一种枷锁。</p>

<p>23点41分，写于阳光花园，@segmentfault。</p>

<hr>

<h2>后续</h2>

<p>其实回想起来，在北京的那段时间收获蛮大的，成长也很大，以至于后来回见老朋友，外貌评价已经不是12年的正太，而是<del>大叔</del>了。认识了几位好友。跟本峰一起吃饭的时候听他讲他的想法，见识到微软，中关村，大家都很努力地在北京这个地方生活。</p>

<h2><del>计划</del></h2>

<p>不写计划了。有些习惯会坚持一年。</p>

                ", 2013年。结束。开始。,1531978040,494,1,724,1,1,https://segmentfault.com/a/1190000000374014
132,1,0,9,"
                    <p>国内云服务环境日趋完善，各种云服务，能帮助开发者快速实现创意，将精力集中在自己的核心业务上。</p>

<p><a rel=""nofollow"" href=""http://www.ucloud.cn/"">UCloud云计算</a>就是云服务商中值得关注的一家。UCloud 长期专注于移动互联网领域，深度了解移动互联网业务场景和用户需求。UCloud提供UHost（云主机）、UDisk（云硬盘）、UMem（云内存存储)、ULB（负载均衡）、CDN等服务，可以满足开发者在不同场景下的各类需求。</p>

<p>目前，已有数千家移动互联网团队将其核心业务迁移至UCloud云计算平台。特别是很多游戏公司都选择了UCloud的产品，大家熟知的蝉游记、暴走漫画也使用了UCloud的服务。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbImL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Ucloud""></span><br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbImO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Ucloud""></span></p>

<h3>获取代金券福利</h3>

<p>为了感谢大家一直以来对SegmentFault 的关注，这一次联合发放的福利是UCloud的1500元代金券，共6张。</p>

<p>活动规则，只要转发微博（<a rel=""nofollow"" href=""http://e.weibo.com/2036070420/Ap3edkfD5"">微博地址请戳这里</a>），@ 一位你认识的开发者，就有机会获得！我们活动开始后次日抽取2名获奖用户，持续三天！</p>

<p>代金券使用规则如下：</p>

<ul>
<li>每张可购买主机6个月使用时间</li>
<li>主机规格：1核CPU/2G内存/100G硬盘/双线2Mbps带宽</li>
<li>UCloud暂不提供个人网站的接入</li>
<li>有任何疑问可邮件至 libin@ucloud.cn</li>
</ul>

<p>除了代金券之外，UCloud还将联合七牛云存储、监控宝、QTestin云监测、极光推送于12月27日至12月31日举办“联合赠送，五重优惠”活动。12月31日起还会为游戏开发者提供<a rel=""nofollow"" href=""http://www.ucloud.cn/act/index/gamedeve"">超过1万5千元的开发者认证大礼包</a>！</p>

<h3>联合SegmentFault 打造开发者问答专区</h3>

<p>开发者在使用UCloud的过程中，如果遇到技术问题，可以在<a rel=""nofollow"" href=""http://segmentfault.com/ucloud"">SegmentFault上的UCloud问答专区</a>上提问。在这里，你将直接获得 Ucloud 工程师们的帮助，并同像你一样的开发者交流。</p>

                ", 年底开发者福利计划：SegmentFault 联合 UCloud 赠送近万元代金券,1531978042,468,1,441,1,1,https://segmentfault.com/a/1190000000369317
133,1,0,9,"
                    <p>人们通常觉得计算机编程有点麻烦，但是有些人却从中发现了乐趣。每一个程序员都需要跟随计算机编程语言的潮流。大多数程序员开始编程的时候选择C语言，因为C语言是在编写操作系统和应用程序中用的最为普遍的语言。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbIme"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""k&amp;r""></span></p>

<p>如果你正在读这篇文章，很有可能你已经是一名程序员或者想成为一名程序员。你很幸运，这里正是你该来的地方，我收集了一些C编程的网址或者教程可以帮助你成为一名好的C程序员。</p>

<ol>
<li><p><a rel=""nofollow"" href=""http://www.eskimo.com/~scs/cclass/notes/top.html"">C Programming Notes</a></p>

<p>这些笔记来自<a rel=""nofollow"" href=""http://www.eskimo.com/~scs/expcoll/"">UW Experimental College</a>关于C编程介绍课程。这些笔记基于《The C Programming Language》的增补部分。大家都知道，这部书的作者是大名鼎鼎的Brian Kernighan 和Dennis Ritchie，或称为K&amp;R。</p></li>
<li><p><a rel=""nofollow"" href=""http://www.cs.cf.ac.uk/Dave/C/"">Programming in C – UNIX System Calls and Subroutines using C.</a></p>

<p>David Marshall的Programming in C教程覆盖了用C语言进行应用程序设计，UNIX系统调用和子程序。</p></li>
<li><p><a rel=""nofollow"" href=""http://gd.tuwien.ac.at/languages/c/cref-mleslie/CONTRIB/SAWTELL/intro.html"">C Lesson by Chris Sawtell</a></p>

<p>这里有自学“C”这个计算机语言的完整教程。该教程使用对话式的风格，有面对面教授的感觉。</p></li>
<li><p><a rel=""nofollow"" href=""http://c-faq.com/"">comp.lang.c Frequently Asked Questions</a></p>

<p>Steve Summit维护了这个常见问题列表，还出了书——“C语言FAQs”（Addison-Wesley, 1995, ISBN 0-201-84519-9出版）</p></li>
<li><p><a rel=""nofollow"" href=""http://www.lysator.liu.se/c/index.html"">Collection of C programming material at Lysator Society</a></p>

<p>Lysator Society网站上有一些关于C语言编程的电子读物。Lysator是一个学术性的计算机社团，位于瑞典Linköping大学。</p></li>
<li><p><a rel=""nofollow"" href=""http://directory.fsf.org/category/clibs/"">A collection of useful libraries written in C</a></p>

<p>收集了运行在自由的操作系统上（特别是GNU和GNU/Linux）的用C编写的自由软件和库。</p></li>
<li><p><a rel=""nofollow"" href=""http://www.open-std.org/JTC1/SC22/WG14/"">The C Programming Language Standard</a></p>

<p>ISO/IEC JTC1/SC22/WG14 一个针对C编程语言的国际标准工作组。</p></li>
<li><p><a rel=""nofollow"" href=""http://www.jetcafe.org/jim/highlowc.html"">High-level and Low-level Programming in C</a></p>

<p>你可以用特定的工具或者惯用法来扩展C语言，使它成为一个“高级的”编程语言，同时，你也可以绕开某些C语言的常规特性，直接使用它的底层功能。</p></li>
<li><p><a rel=""nofollow"" href=""http://msdn.microsoft.com/en-us/library/fw5abdx6.aspx"">Microsoft C Language Reference</a></p>

<p>“C语言参考“描述微软的C实现。本书的组织依据ANSI C，加上了微软对ANSI C标准的扩展。</p></li>
<li><p><a rel=""nofollow"" href=""http://www.thefreecountry.com/documentation/onlinecpp.shtml"">Online C/C++ Tutorials and Documentation</a></p>

<p>这个页面收集了一些免费的电子文档、指南、教程、参考、FAQs和书籍，都是关于C和C++的。</p></li>
</ol>

<hr>

<p>原文 <a rel=""nofollow"" href=""http://www.mycplus.com/featured-articles/top-ten-c-language-resources/"">Top 10 C Language resources that will turn you into a better programmer</a><br>
翻译 <a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a></p>

                ", C语言学习资料汇集 助你成为更好的程序员,1531978043,108,1,806,1,1,https://segmentfault.com/a/1190000000369774
134,1,0,9,"
                    
<p>本文是我借助 Google 从网上拼凑的文章，可能条理不是很清晰，希望对广大程序员们有些帮助。</p>
<h2>一、成长的寓言：做一棵永远成长的苹果树</h2>
<p>一棵苹果树，终于结果了。</p>
<p>第一年，它结了10个苹果，9个被拿走，自己得到1个。<br>对此，苹果树愤愤不平，于是自断经脉，拒绝成长。</p>
<p>第二年，它结了5个苹果，4个被拿走，自己得到1个。<br>「哈哈，去年我得到了10%，今年得到20%! 翻了一番」。</p>
<p>这棵苹果树心理平衡了。</p>
<p>但是，它还可以这样：<strong>继续成长</strong>。</p>
<p>譬如，第二年，它结了100个果子，被拿走90个，自己得到10个。<br>很可能，它被拿走99个，自己得到1个。</p>
<p>但没关系，它还可以继续成长，第三年结1000个果子……</p>
<p>其实，得到多少果子不是最重要的。<br>最重要的是，苹果树在成长!<br>等苹果树长成参天大树的时候，那些曾阻碍它成长的力量都会微弱到可以忽略。<br>真的，<strong>不要太在乎果子，成长是最重要的</strong>。</p>
<p><strong>切记</strong>：</p>
<p>如果你是一个打工族，遇到了不懂管理、野蛮管理或错误管理的上司或企业文化，<br>那么，提醒自己一下，<strong>千万不要因为激愤和满腹牢骚而自断经脉</strong>。<br>不论遇到什么事情，都要做一棵永远成长的苹果树，因为你的成长永远比每个月拿多少钱重要。</p>
<h2>二、人人都需要时间管理</h2>
<p>一项国际查表明：<strong>一个效率糟糕的人与一个高效的人工作效率相差可达10倍以上</strong>。</p>
<p>哈佛有一个著名的理论：<strong>人的差别在于业余时间，而一个人的命运决定于晚上8点到10点之间</strong>。<br>每晚抽出2个小时的时间用来阅读、进修、思考或参加有意的演讲、讨论，你会发现，<br>你的人生正在发生改变，坚持数年之后，成功会向你招手。</p>
<p>我曾整理了一份『免费的编程中文书籍索引』（去<a href=""https://github.com/justjavac/free-programming-books-zh_CN"" rel=""nofollow noreferrer"">github</a>查看，也可以到<a href=""https://code.csdn.net/JustJavaC/free-programming-books-zh_cn"" rel=""nofollow noreferrer"">CSDN CODE</a>），每天抽出半个小时来读一读。</p>
<p>时间管理可以帮助您把每一天、每一周甚至每个月的时间进行有效的合理安排。<br>运用这些时间管理技巧帮您统筹时间，对于每个人来说都是非常重要的。</p>
<p>在时间管理中，<strong>计划组织</strong>相对于其他技巧来说是最简单的一种。<br>比如，所有的时间管理建议都包括在一些表格当中，在表格中把您想要完成的任务填进去。<br>对很多人来说，这是最简单和普通的了。</p>
<h2>三、别人能成功的事，未必自己就能成功</h2>
<p>飞机上，乌鸦对乘务员说：给爷来杯水！</p>
<p>猪听后也学道：给爷也来杯水！</p>
<p>乘务员把猪和乌鸦扔出机舱，乌鸦笑着对猪说：傻了吧？爷会飞！</p>
<p>**外界因素是一种约束条件，自身能力也是一种约束条件, 往往更重要。<br>所以，别人能成功的事，未必自己就能成功。**</p>
<h2>四、你搜索到的只是网页，不是知识</h2>
<p><strong>知识的类型及它在程序员大脑中如何成长。</strong></p>
<p>有三类知识：</p>
<p><strong>概念知识</strong>（为什么、是什么、如果——语义上的）——理解软件系统构建过程中的概念、原理、关系及主要方法。</p>
<p><strong>实践性知识</strong>（如何做——过程中的）—— 关于如何解决特定编程问题的知识。<br>这类知识不需要深入理解实现方法选择过程中隐含的概念及基本原理。</p>
<p><strong>隐性知识</strong>（专业知识、经验及直觉）——基于软件系统实现过程中所积累的个人经验，在大脑中形成的内在知识。<br>这类知识很难传授，因为它的大部分都存储在我们的潜意识中。</p>
<p><strong>可解决实际问题的高效搜索</strong></p>
<p>A. <strong>查找Seek</strong></p>
<ol>
<li><p><strong>定义Definition</strong>——弄清楚要解决什么问题，并以要查找的内容为焦点。</p></li>
<li><p><strong>检索Retrieval</strong>（使用标准的Google、代码搜索或其他的检索引擎）—有很多关于如何高效的使用检索引擎的建议。</p></li>
<li><p><strong>浏览结果Browse</strong>（内容的质量、可信度及专业技术的水平；如果资料的可信度过低，无须再看）-&gt; 阅读 -&gt; 评估（人力物力、所需工具及函数库）</p></li>
</ol>
<p>B. <strong>使用 Use</strong></p>
<ol>
<li><p>复制代码 - 单独复制（针对这一目的，带有长钉技术的显式单元测试最适合）。</p></li>
<li><p>清除代码 - 仅保留最小限度、相关性代码，清除解决方案中的其它代码。</p></li>
<li><p>应用代码 - 在系统中应用代码。</p></li>
</ol>
<p>C. <strong>学习Learn</strong></p>
<ol>
<li><p><strong>理解Understand</strong>——你做了什么及你为什么那样做——从代码和实现中学习。</p></li>
<li>
<p><strong>扩充知识Expand</strong>——</p>
<ul>
<li><p>实践性知识Practical：解决问题的特定方法、技巧及风格；</p></li>
<li><p>概念知识Concept：学习新概念、提炼现有的并构建自己的概念；</p></li>
<li><p>隐性知识Recessive：明智地使用并学习搜索到的解决方案，经验会自然而然地得到增长。</p></li>
</ul>
</li>
<li><p><strong>收集Collect</strong>（链接、意见、参考文献、阅读清单）—任何对你今后搜索、发现及学习有用的有趣信息。为这些目标积累知识。</p></li>
</ol>
<p>还有一点也很重要: <strong>分享与交流</strong>。</p>
<p>最后还是我在博客中经常写道的那句话（不要嫌我罗嗦，再写一遍），<strong>学历代表过去，能力代表现在，学习能力代表未来</strong>。</p>
<p><span class=""img-wrap""><img data-src=""http://justjavac.com/assets/images/weixin-justjavac.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""justjavac微信公众号"" title=""justjavac微信公众号""></span></p>

                ", 告别码农，成为真正的程序员,1531978045,286,1,588,1,1,https://segmentfault.com/a/1190000000364902
135,1,0,9,"
                    
<p>下午面试了一个程序员，78年，未婚，从事技术三年。</p>
<p>他穿了深色外套，里面是一件深色线衫，款式都不流行，衣服看得出来都有了一定年头。半边身体紧靠着椅背，怀中抱着背包，手不停的纠缠着背包带子，陈述问题的时候会不断有摸耳朵，抬眼镜，抹鼻子的小动作。</p>
<p>感觉到他的紧张，谈话中我面带微笑，尽量放松气氛，先做了自我介绍，然后希望他介绍一下在北京的经历开头。</p>
<p>他开始讲，之前中专毕业在家乡小城市做会计行政类工作，后来想转行技术，有了个机会然后就开始学习，10年来了北京，经历了三家公司。</p>
<p>上述是我根据他断断续续的陈述，加上我问的问题整理出来的。坦率的说，他的表达能力和逻辑能力有点儿差。</p>
<p>讲离职原因的时候，他说希望能去大公司深造，认为大公司和互联网公司所用的技术比较先进，在这样的公司做基本工作也愿意。然后话题一转，他开始谈在北京找工作的经历，我很有兴趣就没打断他。鉴于他从10年来北京已经工作了三家公司，面试经历自然也不少，从他的陈述，基本有两种情况：</p>
<p>一、理想的大公司，刚开始不太了解，但后来知道公司规模很大，基本上复试两次后就没后续，这样的公司数量4+<br>二、一般的公司，去之前不太了解公司业务，但好像也不错，遂入职，后来发现某些问题不太如意，这样的公司数量3</p>
<p>考虑到他的年龄，以及在北京的生活压力，我继续问他是否有三至五年的规划，无论是工作还是生活。</p>
<p>他说没有制定这么久的计划，原因是未来有太多不确定性的因素，之前定过一次，但是因为种种原因无法实现，现在对他来说，进大公司的机会也越来越少，所以未来的不确定性太大，没办法计划。</p>
<p>这时我表述了我认为制定计划的原因，虽然未来有很多不确定，但只有定了计划才能一步步实现，他仍坚持自己的看法。我们在这个问题上未达成一致，好在我不是强迫别人一定要接受的人，面试继续。</p>
<p>在我看来，不了解公司情况就贸然参加面试，是个很严重的问题，容易浪费机会，但从他的陈述，虽然曾出现过这种情况让他未能去他理想的大公司，他仍未做出改善。遂问他之前工作中有没有出现过错误，有的话是如何做改进的。</p>
<p>他开始讲之前公司的工作流程，提交代码自己先检查，然后提交运行，测试发现问题会反馈给项目经理，项目经理再找BUG，或者联系到某个人确认问题。</p>
<p>我重复了一遍自己的问题。</p>
<p>他才正式回答，之前没出现过错误。</p>
<p>聊到这个时候，我觉得可以结束面试了。最后随口问了一下他在北京的朋友圈和平时活动，他似乎对我的问题有点诧异，但也回答说在北京朋友很少，周末（犹豫了一会儿）有时候会上网，或者去书店看看书。</p>
<p>结束时，我个人给了他建议，以后面试的时候先了解下公司的情况，有准备会更好。但根据之前聊天得到的信息，我觉得他改变这点很难。</p>
<p>跟技术部门面试官聊了一下，大家共同的意见是沟通能力不好，容易跑题。我觉得他的问题并不仅仅存在于我得到的信息: 78年、没规划、没信心、没理想、没朋友（当然肯定也没女朋友）、没娱乐活动，而是一种对待生活和对待自己的态度。</p>
<p>也许如他所说，很多的机会都已经失去，他没办法像二十出头的年轻人一样考虑问题。但，现在的生活仍然是无法再追回的，他未来永远不会比现在更年轻。如何把握现在的生活，做的比过去的自己更好，在这个过程中建立对自己和生活的信心，不盲目不人云亦云，不狂妄而是脚踏实地，未来才有希望。</p>
<hr>
<p>原文章发表后，有朋友对我问个人规划提出质疑，关于规划，我后来写的时候也有考虑过，也许他只是讲了真话而已，没有规划也并没有错，每个人都有选择自己怎么生活的权力。 </p>
<p>大多数时候，我并不在意他们所说的规划是不是最终能够实现，那是他们的事情，有时候我会追问细节，但不管怎么样，选择时我偏向于有条理有计划的人，这是事实。对个人有规划会让我觉得这个人有想要达成的目标，内心的驱动力才是促使人前进的最有效方式。 </p>
<p>78年出生并不是原罪，对他这种情况来说只是罪上加罪。如果他是一把年纪糊里糊涂但很坦然很幸福，我觉得招这样一个人过来应该很稳定。但那些一把年纪，没能力改变现状，无法批判性的认识事物，只是为了活着而活着，不知道什么是幸福的人，我不可避免的觉得他们很可悲。 </p>
<p>对待招聘这件事，我很早之前就意识到我有自己的喜好和偏见，所以过程中我尽量客观。但无奈这就是一件很主观的事情，我必须有自己的态度和主见。 </p>
<p>每当给一个人投了否定的票， 我都会反省是否有自己的偏见存在，我也曾忧虑是否会因为自己的原因错过了某个合适的人，无奈并没有人告诉我有这样的事情。我明白世界上并不存在完美的人，我自己亦然。</p>

                ", 记录一场HR和程序员的面试,1531978046,188,1,825,1,1,https://segmentfault.com/a/1190000000363132
136,1,0,9,"
                    <p>最近，有人在知乎上提了个问题，<a rel=""nofollow"" href=""http://www.zhihu.com/question/21333711/answer/20911757?group_id=133264687#answer-3560468"">《程序员转行烧烤需要做哪些准备，有哪些优势和劣势？》</a>于是我觉得特有意思，而且看到答案也很欢乐。其中有很多产经、UI、UX纷纷跑来吐槽来着，但是似乎还真的没有看到什么程序猿在回答这个问题。所以特地跑到SF来招募大家一起写段子《程序猿的烧烤那些事儿》，当然我的理想状态是，我们大家能写出一本非常吐槽的小说。</p>

<p><strong>如果作为程序猿的您有兴趣来一起自娱自乐的话，十分欢迎哦！大家一起把想法和小故事直接在评论里写起来吧！<br>
争取我们能一起创造属于我们程序猿自己的小说哈~ 哈哈哈~</strong></p>

<p>根据整理，目前整理了一些大致的思路供参考：</p>

<h2>优势</h2>

<ul>
<li>程序猿对于熬夜工作习以为常</li>
<li>程序猿拥有着比较丰富的“互联网思维”</li>
<li>程序猿拥有比较清晰的逻辑关系</li>
<li>程序猿擅长很多关于IT方面的知识</li>
<li>程序猿有着找BUG的疯狂劲道</li>
</ul>

<h2>准备</h2>

<h3>想店名</h3>

<ul>
<li>一般性会用一个喜欢的语言作为店名</li>
<li>或者会使用一个喜欢的开发工具作为店名</li>
<li>或者非常奇怪的名字</li>
</ul>

<h3>选位置</h3>

<ul>
<li>打开Google Map，根据流量选择了开搞的地方</li>
<li>一般性都会在IT民工工作场所附近</li>
</ul>

<h3>进货</h3>

<ul>
<li>整理了一份非常详细的购物清单</li>
<li>规划了超市（而不是菜市场，因为不会砍价）的内部购物流程</li>
<li>根据规划购买了当晚需要烧烤的材料</li>
<li>支付的时候郁闷的发现竟然不支持比特币</li>
</ul>

<h3>选桌椅</h3>

<ul>
<li>桌椅一定得选择可以节约空间的折叠</li>
<li>一定是黑色和绿色的搭配，表示看起来清晰</li>
<li>而且桌子可以各种拼接，保证可扩展性</li>
</ul>

<h3>搞关系</h3>

<ul>
<li>由于不会和城管、土豪、土地主搞关系，只能塞钱</li>
</ul>

<h3>烧烤工具</h3>

<h4>烧烤架</h4>

<ul>
<li>发热设备选用了自己的极其高配的服务器及投影仪</li>
<li>底座选用了全铝散热的航空材料定制而成</li>
<li>另外还有个配件，烧烤完成会提醒发送PUSH消息给客户</li>
</ul>

<h4>散热设备</h4>

<ul>
<li>服务器机箱上的风扇拆下来用来吹风，效果贼好</li>
</ul>

<h4>提示设备</h4>

<ul>
<li>提示设备选择了一款Android智能电视，开发了自己的工具，用于提醒用户的队列</li>
</ul>

<h4>等候设备</h4>

<ul>
<li>准备了非常多的三防Android设备（iPad太贵），并且内置了大量CPA、CPS应用</li>
</ul>

<h4>监控设备</h4>

<ul>
<li>准备了红外探测仪，每天记录客流量、成交量等，为了未来建立数据分析做准备</li>
</ul>

<h2>烧烤</h2>

<h3>吆喝</h3>

<ul>
<li>由于程序猿过分羞射，用了Apple语音录制了机器发音</li>
</ul>

<h3>过程</h3>

<ul>
<li>由于没有产品经理。可能对烧烤流程不了解，比如先洒胡椒、还是先弄熟</li>
<li>由于没有运营经理。不知道用户属性和口味</li>
<li>由于没有交互设计师。不知道如何优雅地递给用户、用什么袋子、什么盘子</li>
<li>由于没有界面设计师。有些东西烤太黑了，有些东西烤太红了</li>
<li>由于没有测试工程师。烧烤过程中会出现意外</li>
</ul>

<h3>由于是程序猿经常会发生</h3>

<ul>
<li>数串数的时候从“零”开始</li>
<li>烧烤的肉异常整齐摆放，生怕不对齐</li>
<li>整数用1024串来计算</li>
<li>来**串肉串，如果有*玉米，来一串。结果只提供一串。</li>
</ul>

<h3>其他</h3>

<ul>
<li>由于烧烤是一个重复劳动，所以程序猿觉得应该开发一个软件或者机器人</li>
<li>烧烤摊前必须放一个微信公众号，让来的客人关注，并自己开发了服务号后台加强用户体验，比如预订什么的</li>
</ul>

<h2>交易</h2>

<ul>
<li>无条件支持比特币</li>
<li>无条件支持支付宝</li>
<li>无条件支持财付通</li>
<li>无条件支持第三方交易平台</li>
</ul>

<h2>售后</h2>

<ul>
<li>满1024串提供增值服务</li>
<li>维修电脑一次</li>
<li>刷机一次</li>
<li>PS图片若干张</li>
<li>网站制作</li>
<li>应用开发</li>
<li>等等</li>
</ul>

<p>整理的思维导图如下：<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGut"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""程序猿卖烧烤""></span></p>

<p><strong>如果作为程序猿的您有兴趣来一起自娱自乐的话，十分欢迎哦！大家一起把想法和小故事直接在评论里写起来吧！<br>
争取我们能一起创造属于我们程序猿自己的小说哈~ 哈哈哈~</strong></p>

                ", 招募大家一起来写《程序猿的烧烤那些事儿》,1531978047,130,1,933,1,1,https://segmentfault.com/a/1190000000362650
137,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbFuM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>文：Gracia</p>

<p><strong>导语：</strong>本期采访对象王行舟@<a rel=""nofollow"" href=""http://weibo.com/xingzhoucom"">行舟com</a>，是一位从业20年的老程序员。他的名字，并不像他曾经做过的产品那样知名，那是一款在Windows上非常流行的优化软件——超级兔子。王行舟并不是超级兔子之父，但却是那个为超级兔子真正赋予了生命的人，他主导着超级兔子旗下所有产品的开发，尽管面对360和优化大师这样强大的竞争对手，超级兔子鼎盛时期的市场占有率仍高达90%。</p>

<p>在王行舟口述的经历里，你会发现一种强烈的落差感。很难想象，做出过这样一款成功软件的人，多年来一直拿着与能力不相衬的微薄收入；这个士为知己者死的性情中人，在卖命付出的同时，“知己”却瞒着他早赚了个盆满钵满；在赢得官司之后，他却要让这款浸透了心血的产品慢慢死掉，你能体会这会是一种什么样的心情……</p>

<p>这种落差感让人感到不可思议，甚至于不可信，许多人听到这个故事的第一反应是不可能，怎么会有人笨到如此。或许是性格决定命运，又或许是造化弄人，王行舟的背后，是一个时代的远去。翻看刘韧98年出版的《知识英雄——影响中关村的50个人》，求伯君说过的一段话里，似乎依稀能找到答案：</p>

<blockquote>
  <p>“事业和金钱无关，当你全身心投入开发的时候，不给你钱你也要干，开发时，根本没有心思考虑报酬。只有先成就了事业，才有资格谈报酬”。</p>
</blockquote>

<p>这话听起来有点远，但或许代表了老一辈程序员的心声。王行舟正在重新出发，做一款移动端的工具类软件，这是他擅长的领域。项目还在保密阶段，后续会怎样也不得而知，但他仍然遵循着自己的初心：程序员靠着自己的本事好好做事，一定会得到回报。他一直试图用自己的方式证明这一点，我们拭目以待。</p>

<ul>
<li><strong>技术人攻略：做超级兔子之前，你有过什么样的工作经历？</strong></li>
</ul>
<blockquote>
  <p>我大学就读于西安工业学院，93年毕业分配到株洲一家国企，用PLC编程做自动生产线的设计。很喜欢编程，当时给单位做过管理系统，也给网友做一些实用小工具。5年后离开国企，在当地的电大教了两年书。2000年的时候非常顺利地获得了去深圳华为工作的机会，可在即将入职的时候认识了CSDN的创始人蒋涛，改变了我的整个职业轨迹。</p>
  
  <p>2000年的时候互联网不像现在这么发达，找一些程序员相关的资料并不容易，CSDN做了张程序员大本营的光盘，搜集了大量实用的技术文档、源代码、开发技巧、控件、开发工具，一下子在全国畅销有了名气。我当时觉得搜集资料的这些人都很牛，在网上看了蒋涛的简历，他在巨人、金山、豪杰工作过，做过中文手写系统、《金山词霸》、《金山游侠》等非常有名的产品，看过之后觉得非常崇拜，萌生了想要加入CSDN的念头。</p>
  
  <p>我放弃了去华为的机会，转而北上。到北京之后，事情发生了变化，来之前说好要做的项目临时不做了。蒋涛跟我说打算做《程序员》杂志，问我是否愿意做技术编辑。我当时心里非常气愤，但都已经来北京了，既来之则安之，怎么也得过年再回去吧，没想到一干就是3年。</p>
  
  <p>3年里通过CSDN这个平台认识了很多人，并且从一个绿林式的程序员，变成了一个比较全面的从业人员。虽然收入与华为相去甚远，但这份工作让我很开心，蒋涛对我很尊重，并且也一直很佩服他的产品眼光和技术洞察力。这是我工作以来最放松，最享受的3年。离开之后，人生轨迹发生巨大变化，进入非常紧张的创业阶段。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你是如何走上创业之路的？为什么会做超级兔子？</strong></li>
</ul>
<blockquote>
  <p>我一直认为自己不是一个适合创业的人，我是一个林冲式的人，很少会自己去打天下，但如果有朋友邀请我去，我可能也会去。</p>
  
  <p>超级兔子是蔡旋98年做的，我04年受邀正式加入，之后我们决定用超级兔子这个名字做更多的产品。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：做超级兔子的过程中，你和合伙人的矛盾是怎么回事？</strong></li>
</ul>
<blockquote>
  <p>04年正式开始做超级兔子，产品和技术由我负责，在湖南株洲进行开发。蔡旋在广州，负责所有出面和对外合作的事情。蔡旋独立做超级兔子的时候，通过软件注册费能获取一部分收入，在我加入之后，我们把超级兔子做成免费的了，因为看到未来趋势肯定是免费。从04年到06年，软件没有收入，我一直是个低薪程序员。</p>
  
  <p>直到后来我才发现原来超级兔子已经有很多收入来源，包括软件的推广、导航站haokan123的广告位、以及给电脑厂商做的OEM版，但是蔡旋从来没有跟我说。只有百度联盟来的收入进了公司账，其它渠道的收入都进了蔡旋私人腰包。</p>
  
  <p>从04年开始合作，我和蔡旋一直没有签订任何协议。我在人际事物这块确实欠考虑，当时全心全意扑在产品和技术上，不想因为协议的事情破坏我和蔡旋之间合作的这份诚意。考虑到公司未来的发展，08年我再次北上并在北京注册了公司。可直到09年公司引入新合伙人，我们才第一次签订了协议。协议中明确规定，所有的产品都归北京这家公司，也就是说，所有的产品都在我名下。后来蔡旋背着我注册了超级兔子商标，打官司不让我们用。也是这个协议救了我，蔡旋没有任何有利的证据，打官司输了。<strong>虽然我赢了官司，可是从11年起就没有更新过产品，我想让大家忘记超级兔子，一个我花了很多努力，却没有得到很多的东西。</strong></p>
  
  <p>公司闹到这一步也是必然，很多人说我最大的错误在于找错了合伙人。其实我最气愤的不是合伙人背着我拿了多少钱，而是那种被辜负的感觉。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：超级兔子是优化软件中做得最早也是最有影响力的，到现在已经默默无闻，有哪些原因导致了这个产品的失败？</strong></li>
</ul>
<blockquote>
  <p>超级兔子失败有多方面的原因，首先，从合伙人那里得到的信息不全面，由于蔡旋向我隐瞒收入，我并不知道某些功能其实存在着巨大的商业价值。我只看到技术在变化，没看到用户的习惯也在变化，因此损失了很多机会。</p>
  
  <p>其次来自竞争对手的冲击。07年根据第三方调查，超级兔子还有90%的占有率，虽然市场上出现了360和优化大师这样的竞争对手。360是我最关心的一个团队，因为他们确实很可怕。一方面360背了流氓的名声，另一方面，他们在产品和技术上的进步很快。超级兔子的产品是10人以内的团队做出来的，而360相当有钱，可以养一个竞争力强大的团队来打败我们。</p>
  
  <p>最后投资引进受阻。要跟竞争对手对抗必须要建立更大的团队，没有足够的钱就无法支撑越来越大的开发队伍。<strong>整个软件的外部环境已经发生了巨变，在资本冲击下，小团队注定成不了大气。</strong>09年，我认为应该马上引进投资，把公司的规模做大。投资带来的好处不仅仅是钱，利用投资方的资源，可以获得更多的合作和推广机会，这才是投资最大的价值。一方面是基于市场环境的变化，另一方面，我想融资的最大目的，是认为蔡旋的眼光和能力都不适合做CEO，希望能够通过融资让他出局。蔡旋害怕失去控制权，所以融资一直没有谈成。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你怎么看待竞争对手360这家公司？怎么看待周鸿祎这个有争议的人？</strong></li>
</ul>
<blockquote>
  <p>一个打败我的人，不一定是我的敌人，也不是我要恨的人，不管他用什么方式，他们做到了这一点。在当下这种社会环境下，我认为值得尊重。而且超级兔子之所以失败，并不是他们的原因，如果我们当时接受融资，占个2-3成的市场份额我还是有信心的。</p>
  
  <p>互联网的大V中，很多人是没有节操的。这就是为什么我对周鸿祎还是很尊重，就算他是个流氓，也是个讲道义的流氓，是个绿林好汉式的枭雄人物。</p>
</blockquote>

<ul>
<li><strong>技术人攻略：你怎么看待大公司抄袭小公司产品的情况？</strong></li>
</ul>
<blockquote>
  <p>我做产品的时候遵循一个三步法，当想到3.0，并且已经开始做2.0的时候，才发布1.0的产品，只有这样，大公司才无法抄袭。最了解360产品的除了周鸿祎可能就是我，我做超级兔子的时候，360每次发布的产品，我都能比较准确的预测到它下一步该做什么。</p>
  
  <p><strong>整个大环境来看，口碑时代已经过去了，随之而来的是一个没有节操的时代。</strong>中国用户大部分是小白，给他什么产品他就用什么，这就是盗版流氓为什么这么强的原因。产品好不好不重要，强行塞给用户他们就会用，在这种情况下很多公司也就不会把精力放在做好产品上。公司高层考虑的是怎么用产品占领用户的电脑和手机，用什么方法是另一回事，产品好不好也是另一回事，到这个层面，节操都很有限。<strong>做了这么长时间产品之后，发现想把软件做好，看上去像是个美梦。</strong></p>
</blockquote>

<ul>
<li><strong>技术人攻略：从做超级兔子的这段经历中你得到了些什么？失去了什么？</strong></li>
</ul>
<blockquote>
  <p><strong>虽然失去了很多，可我也得到了想得到的一些东西。得到了在软件或者互联网行业，一心一意地做一个产品，并且有一段时间产品做得还可以。从做免费共享软件到成立公司、到运营，从没有收入到有收入，并且后来发现有机会做大，经历了创业比较完整的一个过程，和软件从小到大的每一个阶段。没有得到的，是收入和肯定。</strong></p>
</blockquote>

<ul>
<li><strong>技术人攻略：你现在在做什么新的项目？期望达到什么目标？</strong></li>
</ul>
<blockquote>
  <p>现在做的项目还在保密阶段，是Android上的工具类应用。我和新项目合伙人认识的时间比较长，认为他在人品和能力方面都不错，投资方也很有诚意。对于未来个人的发展方向，我还是倾向于到一个小公司，在产品还没有做起来的时候我努力把它做起来。</p>
  
  <p><strong>国内互联网软件圈的环境决定了很多公司的产品和技术并不是那么无懈可击，就算是同样的产品，如果能做到更多的新意，还是有机会。另外，工作这么多年，我很想证明一件事情，那就是：程序员好好做事，一定能得到回报。有机会的话，希望让大家看到这一点。</strong></p>
</blockquote>

<hr>
<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com/"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @<a rel=""nofollow"" href=""http://weibo.com/devlevelup"">devlevelup</a>，希望能成为技术人成长的精神家园。<br>
欢迎通过微信公众账号关注技术人攻略<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxHi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>感谢：</p>

<p>感谢<a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a>提供<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup"">博客专栏</a>及推广支持。<br>
感谢<a rel=""nofollow"" href=""http://www.speedycloud.cn/"">迅达云成</a>提供云主机及技术支持。</p>

                ", 技术人攻略访谈十七：低薪程序员王行舟,1531978049,422,1,111,1,1,https://segmentfault.com/a/1190000000358802
138,1,0,9,"
                    <h3>又拍云全新改版</h3>

<p>近年来，云计算行业风云变幻，形形色色的云服务层出不穷，国内环境也日趋成熟完善，值得大家放下旁观之心好好试一试。特别是部分根基比较稳固的创业公司，在大而全的业态内起到了独树一帜的补充作用。</p>

<p>今天要特别介绍的“又拍云”，8年来一直专注于海量小文件的存储分发及图片云计算领域，近期更是把业务范围确定在非结构化数据云存储、云处理、云分发的三方面服务上，并于12月初推出新版官网和开发者平台。建议试用新平台(www.upyun.com)，在可操作性上有了很大改善。</p>

<p>了解更多：《<a rel=""nofollow"" href=""http://segmentfault.com/upyun-special-subject"">又拍云使用技巧专题</a>》《<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000350606"">从又拍云看云存储服务的可用性</a>》《<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000350631"">又拍云存储自建CDN技术探秘</a>》</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbEBg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3>获取代金券福利</h3>

<p>为了感谢读者们一直以来对SegmentFault 的关注，这一次联合发放的福利就是又拍云的1000元代金券，共10张。</p>

<p>活动规则，只要转发此条微博（<a rel=""nofollow"" href=""http://e.weibo.com/2036070420/Amu8Johgn"">微博地址请戳</a>），@ 一位你认识的开发者，就有机会获得！我们活动开始后次日抽取3-4名获奖用户，持续三天！</p>

<p>代金券使用规则如下：</p>

<ol>
<li>一次性等值兑换服务套餐。并请谅解代金券不支持开具发票；</li>
<li>请在三个月的有效期截止之前使用；</li>
<li>每个账号限使用一张代金券</li>
<li>有任何疑问可邮件至shichang@upai.com</li>
</ol>

<h3>联合SegmentFault 打造开发者问答专区</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbEBh"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>开发者在使用又拍云存储的过程中，会遇到一些技术问题，通过传统的QQ等渠道可能不便于解决这些问题。</p>

<p>为了给予开发者最好的支持与帮助，又拍云存储联合SegmentFault共同推出<a rel=""nofollow"" href=""http://segmentfault.com/upyun"">技术问答专区</a>。为开发者们提供社区支持和帮助。在这里，你将直接获得又拍云存储工程师们的帮助，并同像你一样的开发者交流。</p>

                ", 年底开发者福利计划：SegmentFault 联合 UPYUN 赠送近万元代金券,1531978050,105,1,802,1,1,https://segmentfault.com/a/1190000000355318
139,1,0,9,"
                    <p>在云计算时代，开发和运维的结合变得越来越重要。在<a rel=""nofollow"" href=""http://blog.segmentfault.com/sunny/1190000000347177"">DIFF论坛第一期</a>，前新浪SAE运维主管，<a rel=""nofollow"" href=""http://blog.segmentfault.com/devlevelup/1190000000326241"">郑志勇</a>，分享了《一个开发眼中的运维》根据自己从开发人员转型运维之后的心得，谈如何把在开发上的运用抽象思维方式运用到运维领域。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbCSv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><br></p>

<h3>1. 运维不是什么？</h3>

<p>运维不是打杂的，运维不是客服，运维也不是服务开发的，但要做好合作。</p>

<h3>2. 运维是什么？</h3>

<p>运维服务于整个产品，保证架构合理，系统稳定。运维只对业务稳定负责，所有的工作都是奔着这个去的。</p>

<h3>3. 你如何写程序，写程序的目的是什么？</h3>

<p>程序是为了完成特定的功能。为了完成特定的功能，程序需要申请资源、使用资源、管理资源，功能完成后，还要释放资源。说到底，就是跟资源打交道，和资源打交道的工具是“编程语言”。<br>
资源包括什么？内存、CPU、磁盘、网络、文件描述符、外部API、缓存、数据库等，编程语言是如何管理资源的、合理的算法/架构保证了资源的合理使用，malloc/free分配内存、connec、close使用网络等等。</p>

<h3>4. 什么样的程序算好程序？</h3>

<p>正确的程序算好程序。</p>

<ul>
<li>逻辑正确，使用资源尽可能的少； </li>
<li>没有bug，没有把机器资源耗尽； </li>
<li>稳定性好，不会异常退出；</li>
<li>可用性高，有HA方案，不会因为一台机器（或一个进程）无法提供服务，而影响整个系统的服务； </li>
<li>没有单点是基本要求；</li>
<li>容易扩展，只需要简单的增加资源（CPU、内存、磁盘、机器等）就行，不需要太多人工迁数据、修改配置等；</li>
<li>容易维护，包括容易配置、容易部署、容易监控等。</li>
</ul>

<h3>5. 如何写出好程序？</h3>

<p>什么样的程序不出错？代码少的程序错误少，逻辑简单的程序错误少，需要管理的资源少的程序错误少。要复用代码，减少代码的数量。</p>

<ul>
<li>要抽象，分层，内聚，解藕，简化逻辑，隔离资源，才能简化逻辑，隔离资源，限制错误。</li>
<li>没有持久状态的程序好扩展，没有持久状态意味着上下线机器不需要迁移数据。没有状态的程序也很容易做HA方案。</li>
<li>配置简单，日志丰富，能提供程序状态查询的程序好运维。</li>
<li>但程序不可能没有数据，通过集中管理数据库，让数据尽量只读，预加载数据等手段隔离逻辑和数据，也能让扩展变的容易。</li>
</ul>

<h3>6. 系统是什么？</h3>

<ul>
<li>系统是我们运维的目标，不了解系统是什么，就不知道如何运维。</li>
<li>系统是网络，是机器，是程序。是把网络，机器，程序组织起来的架构。</li>
<li>机器角色应该是尽量单一的，架构应该是数据流简单的，基础业务服务化的。</li>
<li>系统是动态的，运维系统首先考虑的不是当下成本，而是系统变更（扩容，上下线机器）的成本。</li>
<li>运维必需是简单的，要考虑的一个新手，如何能尽快上手工作，而不是冗长的文档和复杂的培训。</li>
</ul>

<h3>7. 写程序和做运维是类似的，甚至一样的！程序提供单一功能，而运维搭建，维护的系统提供全部的功能，开发人员开发的程序只是整个系统的一个部分。</h3>

<ul>
<li>从某个角度说，开发人员做的事情越少，系统越容易稳定，因为开源的总是更靠谱。这是减少代码，也是复用。</li>
<li>但运维却理应比开发更不容易犯错，因为运维只需要管理资源，而不需要应对复杂的业务逻辑。</li>
<li>这是个矛盾，因为开发负责的复杂业务逻辑，是运维负责的系统的一部分，前者不稳定，后者也别想消停。</li>
</ul>

<p>所以运维不懂开发，至少要懂如何控制复杂度，如何隔离故障，如何服务降级。出色的运维人员，只要精通一门语言，必然也是出色的开发（反之亦然）。但什么是出色的运维呢？大部分运维人员，只是一个熟练的操作工人。出色的运维必然更了解系统（原理），这要读很多书，做很多思考，有很多实践。<br>
只看这个<code>cat bigfile.txt | parallel --pipe wc -l | awk '{s+=$1} END {print s}'</code>你能不能想出parallel加速的原理是什么？</p>

<h3>8. 你是否了解你运维的资源？</h3>

<ul>
<li>CPU高意味着什么？你是不是应该先问问是sys，user，iowait这三个的哪个高？是单个CPU高，还是整体都搞？</li>
<li>你是否了解有的程序CPU使用率90%就有问题了，而有的350%了还没问题？</li>
<li>load高意味着cpu高吗？内存耗尽导致load高的原理是什么？内存耗尽回导致io高吗？</li>
</ul>

<h3>9. 是否正确的监控了资源？</h3>

<p>监控了磁盘使用率，是不是也监控了磁盘的io能力，raid卡呢？磁盘损坏呢？监控了网卡使用率，是不是也监控了丢包率？</p>

<h3>10. 资源是否一定对应硬件？</h3>

<ul>
<li>CPU，内存，磁盘，带宽都有对应的硬件，那些没有硬件对应的资源呢？文件描述符，端口数，进程数是不是资源？</li>
<li>路由表，iptables，cron是不是资源？</li>
<li>MySQL主从，第三方REST接口是不是资源？</li>
</ul>

<h3>11. 为什么要尽量把一切抽象为资源？</h3>

<p>还记得刚才说程序要讲抽象么，为什么linux一切皆文件？一切运维对象都抽象为资源后，就可以用尽量统一的方法来管理（配置，监控）。<br>
如果新上线一台机器无比容易，为什么还要费尽修复删除的/usr目录呢，把它当成新机器重做上线就行了。</p>

<h3>12. 运维原则:</h3>

<ol>
<li>线上变更必需走配置管理。线上系统对任何人应该是只读的，只有配置管理程序有权写。这样保证了，变更是可重复的，可复制的。手工加路由，手工修改文件权限，手工配置ip，手工配置nfs，手工起虚拟机等等。一切在线上手工做的操作，于团队都是无益的，因为团队失去了一次改进配置管理的机会。任何操作不是想我就这一台机器，而是想我有1000台机器怎么办。</li>
<li>上线业务必需先问，如何保证HA，如何扩展，如何运维/监控。这三个问题不解决，谨慎上线，当然上线必需使用配置管理上线。</li>
<li>隔离复杂度，要简化，抽象。抽象指角色抽象。运维眼中没有计数用的mc，和缓存用的mc，运维眼中只有mc，于是所有的mc都来自mc池，mc池通过puppet配置，创建mc的过程编程了简单的<br>
puppet配置。一旦把自己管理的所有业务抽象/分拆为几种有限的“业务”，缓存、mysql、httpd等，一切就简单了。例如我们有缓存池、数据库池、redis池、httpd池。（参考:4、5）</li>
<li>先解决问题，然后是以后如何避免此类问题，后者更重要。</li>
<li>不犯第三次错误（重复的问题不出现第三次）。第一次算不知道，第二次算不小心，第三次特么是故意的吧。如果每个问题都能彻底有效解决（最终落实到配置变更和监控），问题就会越来越少。</li>
<li>时刻思考如何“偷懒”，运维越清闲，系统越稳定。</li>
</ol>

<h3>13. 配置管理是如何管理资源的？</h3>

<ol>
<li>包，所有线上的软件/脚本都是通过(rpm)包管理的。</li>
<li>文件，所有的变更“持久化”都是通过文件。程序的配置文件，sysctl，iptables，route，cron等凡是能用配置文件控制的一切。</li>
<li>进程，所有的进程都是用配置管理启动的，或者通过配置管理写文件到系统启动目录，例如rc3.d。</li>
</ol>

<p>你能相到的一切，无论是配置keepalived，还是添加用户，都抽象为这三个。如果不能抽象为这三个，请再思考两个小时。<br>
如果系统可以由这三者全部控制，而这三者又全部写入了配置管理，这意味着按照配置管理配置出来的系统就一定是对的。扩容，升级，机器的上线，下线从此该有多容易。而运维人员，可以通过配置管理，一览整个系统，通过持续改进的模板，配置更容易学习，不容易出错。</p>

<h3>监控</h3>

<ol>
<li>的正确性，业务响应时间也要同等关注的。</li>
<li>基础监控要全面，但不一定实时报警。如果业务不受影响，又何必半夜起来处理宕机呢？如果业务有问题，全面的监控会帮你发现问题的蛛丝马迹。</li>
</ol>

<p>如果memcache偶尔响应慢，你怎么能想到是swap导致的呢？全面的监控可以帮你发现这一点。把业务逻辑抽象为资源，可以统一业务监控和基础监控。（监控如何算全面，参考8、9）</p>

<h3>运维技巧</h3>

<ol>
<li>重装操作系统，使用puppet重新配置，是系统恢复到正确状态的最佳途径。理论上，新装的机器使用puppet配置后一定是能用的，否则，就是puppet写的有问题。</li>
<li>区分无状态的机器和有状态的机器，尽量把状态集中，然后集中精力运维这些有状态的机器。<br>
宁可通过网络把状态集中也要尽量让机器避免有状态，无状态的机器非常好运维。</li>
</ol>

                ", 一个开发眼中的运维,1531978051,362,1,162,1,1,https://segmentfault.com/a/1190000000348370
140,1,0,9,"
                    
<p><a rel=""nofollow"" href=""http://terrytai.com/salary-from-50rmb-to-100usd/"">此文来源于我的blog</a></p>

<p>这个标题看起来有点像标题党? 好吧, 我必须在全文开始之前就澄清一下这一点, 这是千真万确的事实. 我本可以只把一些结论贴在这里供大家参考, 但是那样显得太生硬且没有说服力. 所以我决定把整个故事告诉你, 并在每一篇的最后总结出结论, 这样会更轻松愉快一些. 我不敢说这个经历是否可复制, 但是我相信如果你的目标是做一个优秀的软件工程师, 软件咨询师, 或者是 freelancer的话. 它应该会对你有一些启发, 或者说借鉴的意义. 好了, 就让我们开始吧.</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848944"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""zealot.jpg""></span></p>

<p>故事开始是在差不多六年前, 那时我还在大学, 和大多的学生一样, 每天玩玩星际, 打打篮球, 看看妹纸, 当然也帮系里写写程序(Java). 同样和大多数无知的学生一样, 都会犯一些认识上的错误, 比如, 我当时真的认为 Java 很酷。</p>

<p>直到有一天，不经意的看到一个视频 是 <a rel=""nofollow"" href=""http://www.youtube.com/watch?v=Gzj723LkRJY"">DHH 用 Ruby on Rails 15分钟建立Blog的视频</a> （不能访问youtube的朋友可以看 <a rel=""nofollow"" href=""http://v.youku.com/v_show/id_XMzA5MTYxNTY=.html"">youku 上的版本</a> ), 我被这个视频深深的震撼了, 实在是太cool了, 连续播放了5, 6次, 注意观察着每一个细节, 从操作系统, 到编辑器, 到每一行代码和命令, 一切都是那么陌生而又新奇...（如果我没记错，我第一次看爱情动作片的时候都没有这么仔细和认真）。</p>

<p>接着立马下载了Rails(on Windows，当时还是1点几的版本)，并在当当订购了上面唯二的两本关于 Ruby 和 Rails 的书 <a rel=""nofollow"" href=""http://book.douban.com/subject/2032343/"">""Programming Ruby中文版""</a> 和 <a rel=""nofollow"" href=""http://book.douban.com/subject/1839273/"">""应用Rails进行敏捷Web开发""</a></p>

<p>接下来的好几个月, 非常单纯, 看书, 敲代码(书里的代码我来回敲了至少有5遍，我几乎可以把那个“书店”的程序背着敲下来), 除了看书, 我还订阅了几个不多的Ruby/Rails Blog, 学习一些关于 Ruby/Rails 好的实践. 这个过程是痛并快乐的，那时我几乎没法请教任何人（我严重怀疑我是学校第一个学Rails的), 除了问人, 那时连搜索的资料都没多少. 现在回想一下，其实我走了很多的弯路，如果换作现在，我相信这个学习的时间可以再大大的缩短的.</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848654"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""hardworking.gif""></span></p>

<p>差不多自学了有5-6个月, 并自己敲了个论坛和博客程序后, 我决定出门去找个实习的机会. 看看真正世界的工程师是怎么玩的. 这种感觉很强烈, 就像我初中玩星际时, 除了和同学玩局域网, 总是想上战网上看看别的高手是怎么玩的. 如果记得没错, 那时我才刚刚上大三, 决定这么早出去实习实际上和家庭也有一定关系, 我迫切的想要自立. (具体的原因 is a secret)</p>

<p>我所在的城市只有两家用 Rails 的公司, 我投了其中一家。没想到直接就中了, 原因也很简单. 他们从来没有期待过能找到一个懂 Rails 的人, 他们都只是想的招进来再培养. 既然有个现成的, 那肯定得要了. (至今这种情况在很多地方都很普遍)</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004852419"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""50.jpg""></span></p>

<p>那个美女HR给我说得很清楚，我还没毕业, 所以只能按照实习生的标准给我发工资, 算下来也就是50人民币一天. 07年成都的物价还是蛮低的, 50一天基本可以吃饱喝足了.  记得当时还签了不少文件, 我也没太注意细节, 只是不断的确认工作内容是写代码，不是援交什么的就好。现在想起来，我当时确实想多了, 50人名币一天做援交, TM会有人会做吗? 
至少应该60嘛.</p>

<p>办好入职, 来到办公桌, 下载我要做的第一个项目, 这个项目是一个社交应用,一个同事, 让我看看代码, 不懂的地方问他. 下载代码的时候内心非常紧张和激动, 希望看看运行在真实世界的代码到底长什么样.</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848937"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jy.jpg""></span></p>

<p>结果当我仔细翻看代码后, 大失所望, 这个代码基本违反了所有我在先前学习到的最佳实践. 我觉得这个是有难度的, 不亚于用枪兵甩地刺, 不亚于甩狙爆3个头, 不亚于蓝胖子连续10次出四倍.... 我沉默了很久, 在思考是保持沉没，还是去找同事问个明白，最终，我还是鼓起勇气，决定去和同事表白 ... oh, 不是，是说出我真实的想法。</p>

<p>轻声的走到同事旁边,  低声的说道: ""你好, 有几个问题不太明白想请教一下. 请问为什么model不申明 <code>has_many</code> 和 <code>belongs_to</code> 的关系呢, 这样就可以用 user.posts 而不用自己写SQL来找了啊? ""</p>

<p>同事: ""哦, <code>has_many</code> 和 <code>belongs_to</code> 这种东西没什么用, 影响性能, 你不知道吗? 你没用过 Hibernate 吗? ”</p>

<p>两个反问句直接塞住了我的喉咙, 我保持沉默无言以对, 少时缓和后又接着问下一个问题...</p>

<p>我: ""那我想再请问一下, 为什么这个地方所有的逻辑都放在 controller 里呢？ 而 model 完全是空的, 这个地方的逻辑是不是可以移动到model里去会更好一些?” 
其实我略微有夸张, 严格来讲, model还是有两行代码, 并不完全是空的:</p>

<pre><code> class User &lt; ActiveRecord::Base
 end
</code></pre>

<p>同事变的很不耐烦道: ""这个你不懂，等你工作几年有经验就懂了.""
...</p>

<p>这回答让我愣在那里久久回不过神来, 第一次感受到, 原来真实的社会这么恐怖. 当我意识到我的问题不受欢迎时, 我比较自觉的回到了自己的座位. 心想以后和他当不了朋友了, 至少基友是肯定当不了了.</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848403"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""boss.jpg""></span></p>

<p>接着, 我把项目的几乎所有功能都跑了一遍, 惊奇的发现, 它尽然能跑, 而且基本的功能也都实现了. 内心突然开始纠结一个问题, 到底是能跑就够了? 还是只能跑还远远不够呢? 还没等我想清楚, 公司的老板（男）突然叫去旁边的小房间：</p>

<p>问道: ""代码都看了吧？ 你觉得代码写得如何?""</p>

<p>我心里犯着嘀咕, 我是应该吸取刚刚说实话的教训呢, 还是应该继续不撞南墙不回头呢? 我猜如果得罪了他, 可能明天就不用来上班了, 短暂的纠结后, 我还是决定说实话, 如果在一个不能说实话的地方呆着工作, 还不如早早回家洗洗睡了.</p>

<p>我硬着头皮说: ""我觉得这个代码写得不是太好, 还有很多地方可以改进的空间, 比如 ... 比如..."" 我不停的在屏幕上比划着。“我在想, 如果我是客户可能不太能接受目前的这个代码."" (我承认, 我当时说话很委婉, 其实我当时是想说 ""The code is shit!"" . 但, 即使是说真话, 也要用正确的方式. 不然我估计我真可以卷铺盖回家了.)</p>

<p>老板听了以后非常吃惊的看着我. 眉头略微锁紧, 还直视着我的双眼. 你没猜错, 就和青春基友偶像片里演得差不多. 我当时非常紧张, 随时准备""落荒而逃""...</p>

<p>突然, 他大声道: ""你说的太对了，客户目前就是对代码的质量非常不满意. 在这个代码的基础上改 bug 和加功能已经显得非常的吃力和缓慢. 虽然它现在能跑, 但是维护性已经极差了.""</p>

<p>听了这番话, 心中大石落地, 原来他不是要和我搞基, 我自作多情了...
但同时刚刚心里的疑问也得到了答案. ""代码只是能跑是远远不够的, 它必须要容易维护 (结构清晰，易读，易改).""</p>

<p>他接着说: ""正好客户现在刚刚 hire 了一个在美国的独立咨询师叫 Tim, 远程参与到这个项目来对项目做大规模的重构. 这个工程师非常有经验, 他现在已经50多岁了, 你愿意和他一起参与到这个项目的重构中吗?""</p>

<p>我一听非常惊讶, 能和这样优秀的且有经验的人一起工作是我梦寐以求的. 而且 50 多岁应该不会有被潜规则的风险吧, 何况他还在美国.
其实当时内心还是很有一些不安，觉得自己经验还不足，不知能不能和这样的牛人一起工作，但最终还是硬着头皮答应了。</p>

<p>接下来的时光
....</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006779725"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""working.png""></span></p>

<p>可能是我这辈子学习效率最高的时光, 接触了一大堆以前都没怎么听过的概念, TDD, Continuous integration, Pair, Scrum, Refactor, Deployment...
这里面任何一个单独的概念都足以写好几本书, 并够我研究上好一整子. 但可惜的是没有这么多时间让我先看完所有相关的书, 再开始干活, 于是边干边学成了我唯一选择. 先知道一些粗浅的概念, 然后开始干, 通过 Tim 的反馈再结合自己遇到的问题, 然后针对性的看书和 google 资料. </p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848840"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""100.jpg""></span></p>

<p>如此反复, 慢慢我已经可以基本跟上 Tim 的节奏了, 他也越来越喜欢我(不是那种喜欢). 并给了我非常不错的评价, 客户也因此非常开心. 这让老板对我刮目相看. 几乎快丢掉的一个项目尽然被挽回了.
于是我很快得到了加薪. 如果我没记错, 是增长了一倍, 达到了100人民币一天. 据说这已经是公司给我破例了, 因为实习生是拿不到这个数字的. 我当时真的非常开心, 我可以不需要老妈给我一分生活费了, 这意味着我某种程度上自立了, 最重要的是我觉得我真的学到好多东西, 我做出的贡献得到了认同.</p>

<h4>这里让我简单的总结一下第一次加薪的原因吧:</h4>

<ol>
<li><p>代码仅仅能工作是远远不够的, 它必须优雅易读且易维护.
能让代码工作的人这个世界上太多了, 你放心吧. 绝对不缺少你一个, 就连 model 里只有两行代码的项目, 它不也可以工作吗? 你要想变得更有价值, 那么你必须要做到, 不仅让代码工作, 而且要写出优雅易读且易维护的代码.</p></li>
<li><p>在工作中和同事一定要说实话, 但是说实话一定要注意方式
很多人以自己不撒谎为""借口"", 就常常赤裸裸的说出一些很让人难以接受的话, 伤人无数, 还自以为觉得这是正义的. 其实你错了, 说实话也需要正确的方式, 特别是在你和其他人合作完成项目的时候.</p></li>
<li><p>不要期望看完了书再开始做事, 边学边干才是高效的学习方式
我越来越觉得这是唯一的学习方式了. :p</p></li>
<li><p>工作方式和流程非常重要, 特别是当你和其他人合作的时候
很多程序员一提到流程二字就不削一顾, 认为自己是 geek 是hack 怎么需要谈论这种东西. 再加之众多咨询公司近几年狂炒这个话题, 确实让人听着就有点反感. 抛开这些让人不愉快的表面, 本质上, 一个团队要想做好事情,好的流程就是必须的. 除非你永远都一个人工作.</p></li>
<li><p>掌握一门相对小众而又不那么太小众的技术, 对薪资是有一定的帮助的
虽然追求小众不是我当时学习Ruby/Rails的原因, 但是不得不承认, 它是一个结果.
我的确也因此收益, 这是一个客观事实. 
如果以我当时的水平, 我是写php或者java, 那么我根本不一定能拿到这个实习的机会.</p></li>
</ol>
<p>好了, 第一次提薪就讲到这里, 100人民币/天 不算多, 但是对于07年的成都,和一个实习生来讲已经是很让人满足了. 什么? 还不够? 别急, 我们下回接着讲. 看看我们怎么到 100美元/小时的.</p>

<p>你可以订阅我的<a rel=""nofollow"" href=""http://terrytai.com/rss.xml"">blog feed</a> 最快获取推送,
或关注我的 <a rel=""nofollow"" href=""http://weibo.com/poshboytl"">weibo</a> 和我更多的交流.</p>

                ", 我如何把薪水从 50人民币/天 提升到 100美元/小时的 (1),1531978053,110,1,439,1,1,https://segmentfault.com/a/1190000000338364
141,1,0,9,"
                    
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbzUl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>文：Gracia</p>

<p><strong>导语：</strong>本期采访对象Dave Thomas，是一位从业近40年的大神级人物，他和Andy Hunt于1999年合著的《The Pragmatic Programmer》（中文译名《程序员修炼之道》），是历史上最畅销的开发指南书籍，曾获得Jolt大奖，影响深远。Dave是敏捷宣言的17位发起人之一，Ruby语言的支持者和传播者，正是他对Ruby语言的传播，使Ruby逐渐成为与Perl，Python齐名的语言。2003年，他和Andy Hunt 成立了The Pragmatic Bookshelf出版公司，致力于出版软件开发相关书籍，并用开发软件的方式实现了图书出版业的重大突破。</p>

<p>Dave Thoma是一位令人尊敬的大师，更是一位伟大的程序员。在近40年的从业生涯中，他从未间断过编程，并时刻保持旺盛的好奇心和探索新技术的热情。在Ruby Conf China 2013大会上，Dave接受了技术人攻略的访谈邀请，并在回信中100%地肯定了技术人攻略“传递技术热情”的理念：</p>

<blockquote>
  <p>“I think your ideas about spreading passion are 100% correct. I would<br>
  love to help spread this message.”</p>
</blockquote>

<p>希望大师的访谈可以鼓励更多还在奋斗的程序员，技术人攻略也会继续把这种对技术的热爱传递给更多的人。</p>

<h3>1. 技术人攻略：您从什么时候开始接触编程？编程带给了您什么样的乐趣？在不断超越自我的过程中，是否遇到过什么困难，是否曾有过想放弃的时刻呢？</h3>

<blockquote>
  <p>我初次接触编程是在1972年，那时我还在英国上高中。有一部分人提前完成了考试，在学校没有别的事情可做。正巧校园对面的科技学院开设了编程课，于是我们申请了参加这个一周两次的课程。</p>
  
  <p>我最初打算学数学专业，但当我开始编程，我慢慢爱上了它。</p>
  
  <p>那时候我用Basic语言，将代码敲到纸带上，通过一台110波特的调解器将数据传到大型机上运行。虽然如此麻烦，但我发现编程十分符合我的大脑的运作方式——我喜欢这种创造性和精确性兼备的体验。</p>
  
  <p>从那时开始，我从未间断过编程。我十分确定——除非是在度假的时候，我生命中的每一天都离不开写代码。</p>
  
  <p><strong>我也常常会有感到艰难的时候，但每次考验过去之后，你的技艺都将更上一层楼。所有值得做的事情都是困难的，但克服这些挑战不仅会让你更强大，还会让你变得更加投入。</strong></p>
</blockquote>

<h3>2. 技术人攻略：我们处在一个快速变化的时代，新的技术层出不穷，程序员应该如何保持和这个世界同步，持续提升自己的竞争力？</h3>

<blockquote>
  <p>想要跟上技术更新的速度越来越难。当我开始编程的时候，主要通过阅读书籍和杂志了解进展，但现在几乎每天都有新概念出现。</p>
  
  <p>但事实上很多的新事物只是人们对旧东西的再发明。我们行业里的许多人，眼光只看向将来，对计算机的历史却知之甚少。这些人想要创造东西（当然是好的），但他们并不知道自己想做的东西在20或30年前已经实现了。</p>
  
  <p>正因为如此，许多新生成的事物其实并没有那么新。对我来说，要跟上潮流就变得简单了，因为看到它们就会让我想起“啊，这和X很像呢”。</p>
  
  <p>但同时，也确实有一些不错的创新。我每个月总有那么一到两次，会遇到很有意思的东西，让我有兴趣去尝试一下。<strong>阅读技术内容是有趣的，但只有通过尝试才能认识得更加深入。</strong></p>
  
  <p>这很花时间，但对于程序员来说这种投入非常重要。如果不这么做，很快我们就会被淘汰。</p>
</blockquote>

<h3>3. 技术人攻略：在大公司里，职位被划分得很细，例如前端、后端、运维、数据库等，程序员被固定在了公司设定的职位上，您认为程序员应如何提升技术的广度和深度？</h3>

<blockquote>
  <p>专业化分工属于昆虫世界。真正能够改变世界的人：他们具备更加广泛的能力，并能将不同的技术结合起来创造价值。</p>
  
  <p>我认为很多公司并没有意识到这点，他们更乐于创造层级制度和把员工限制在某个职位上。</p>
  
  <p>但是也有些不一样的公司，懂得通过制定目标和提供指导让程序员有最好的产出，而不是监督所有的细节。这些公司理解一个优秀的程序员可以同时胜任数据库设计、规划应用部署，也许还喜欢解决技术支持方面的问题。</p>
  
  <p><strong>我鼓励年轻程序员获取一些在不同的公司工作的经验，以寻找适合自己的工作方式。</strong>例如试试在大公司和在创业团队工作有什么不同，甚至尝试下独自工作。一旦你了解了自己适合的方式，就可以找到或者创造出合适的职位，让自己做得更好。</p>
  
  <p>作为一名员工，很容易抱怨自己的公司，或者怀有这样的想法“我就是一个普通人，没有能力改变什么”。<strong>但事实上，你有责任作出改变——让事情变得更好。这种责任不仅是对公司的，而且也是对自己的。</strong>看看你是否能让公司有所改变，如果无法改变现状，那么你应该换一个更适合自己的环境。</p>
</blockquote>

<h3>4. 技术人攻略：《The Pragmatic Programmer》影响了非常多的人，如果这本书出修订版，您打算做哪些改变？今天，一个讲求实效的程序员正在做些什么？</h3>

<blockquote>
  <p>我和Andy Hunt常常会讨论这件事。实际情况是，虽然书上的案例看上去古老了一点，但背后的概念仍然很适用。无论你是做C++还是Javascript编程，DRY（注：DRY即Don’t Repeat Yourself，不要重复自己）原则仍然适用:)</p>
  
  <p>我个人认为可以修改或者去掉一些小的tips，但没什么大问题。</p>
  
  <p>如何做一个高效的程序员：do what works, and work at what to do。“do what works”意味着你应该不断问自己“我正在做的事情有什么样的价值？”，每天都尝试寻找提升所做事情价值的方法。“work at what to do”意味着要时常回顾，从全局角度看问题，并且寻找改进工作的新方法。</p>
</blockquote>

<h3>5. 技术人攻略：您是一名技术高手，又拥有自己的软件公司，您觉得程序员应该创业吗？程序员创业有哪些优势和劣势？</h3>

<blockquote>
  <p>这是一个很棒的问题，但我也还不知道答案。</p>
  
  <p>我的一个弱点在于我喜欢让事情保持简单——我认为大多数程序员都喜欢这点。但现实世界——公司运作的世界，并不简单。我不得不克服把事情过度简单化的诱惑，因为我知道这样会让自己错失机会。</p>
  
  <p><strong>我认为程序员从事商业，最重要的强项在于我们懂得事物的关系如何。管理代码的原则，同样可以用在管理公司上，</strong>这也是The Pragmatic Bookshelf这家出版公司成功经营的原因之一。我们在一开始的时候，并不知道图书出版公司该如何运行，所以我们采用了管理软件公司的方式去产出图书，而不是产出代码。结果，我们将版本控制、持续系统构建，以及全自动化等方式运用在了商业运营的方方面面。其它出版商无法做到这些，我们对于出版行业的无知成为了最大的优势。</p>
</blockquote>

<h3>6. 技术人攻略：在Ruby大会上听说您最近在关注一门新语言Elixir，它为什么吸引您？您会像推广Ruby一样去推广这门语言吗？它是否代表了接下来的技术流行趋势？</h3>

<blockquote>
  <p>我非常确信未来的世界属于并行和分布式，五年之内，还要编写一个从头到尾顺序化执行的程序，这将是一个笑话。</p>
  
  <p>但同时我们并没有拥有真正可以让我们创建分布式和并行系统的工具，用Ruby或Java写并行代码很容易出错，用Javascript也同样痛苦。</p>
  
  <p>Erlang诞生差不多25年了，这种语言的目的就是要进行分布式和并行编程，就是解决大规模和可靠性问题——在后者的环境中，要保持代码一直处于运行状态，即使代码在升级时也是如此。</p>
  
  <p>Elixir则没有这个问题，这种语言看上去跟Ruby很像，非常易于理解和编写。但是它运行在Erlang虚拟机上，这意味着它可以获得Erlang的一切好处。同时又可以胜任Erlang完成不了的任务，它有很强的元编程能力、宏和协议等方面也不错。</p>
  
  <p>Elixir会统治世界吗？可能不会。但我认为它代表了未来的方向。学习Elixir的过程可以让我理解未来的编码方式。五年后我可能不会用Elixir，但我十分确信我会用一些类似的语言，我通过Elixir学到的东西仍然可以帮助我。</p>
  
  <p>这听上去好像是我认为Elixir不会流行，但其实我不这么想。到目前为止，Elixir是我们所拥有的最好的语言和运行时之一。当我没有为（由Ruby编写的）已有系统写代码的时候，我会用Elixir开发，我十分喜欢它。</p>
  
  <p>我鼓励其他程序员试试Elixir(或者其它类似的语言)，我总是鼓励程序员去学习更多的东西。</p>
</blockquote>

<h3>7. 技术人攻略：在移动互联网时代，产品的开发模式和以前互联网时代相比，有哪些新特点？</h3>

<blockquote>
  <p>我认为程序员面对的世界和五年前相比有了显著的变化。浏览器基本上还和IBM将老式3270终端连到主机上的应用一样——你向它发送数据，用户输入一些东西，然后浏览器给出回应。还是以服务器为主。我知道：客户端在不断加入很多令人头痛的东西，比如JavaScript应用什么的，但是整体架构仍然一样。我认为浏览器技术基本上已经进入死胡同。我观察身边的人——他们在手机和平板上使用App，只有在必须用到浏览器的时候才会用一下，移动世界是以用户为核心，而非以服务器为核心的。</p>
  
  <p>在移动App上，客户端掌管一切，服务器仅仅作为资源提供方。这要求程序员掌握一些新的技能和技术支持这种结构。在客户端，我们需要通过编写复杂的，异步的应用，并且将这些应用运行在一系列不同的设备上（不仅是手机和平板）。在服务器端，我们需要从Rail风格的应用转向更灵活、更多以联合方式运行的架构。（这正是Elixir令人兴奋的原因之一。）</p>
</blockquote>

<h3>8. 技术人攻略：去年的Qcon China上，您谈到了敏捷的腐化和到底什么是敏捷，有没有哪些软件项目领域，是敏捷开发模式不适用的？</h3>

<blockquote>
  <p>你的问题认为，“敏捷”是一种东西。</p>
  
  <p><strong>真相是，“敏捷”并不存在。它不是一种“东西”，不是一个名词。</strong>人们是把它当成一个名词开始用起来的，但是他们并不理解背后的含义。</p>
  
  <p><strong>“敏捷”不是一种东西，敏捷是一个形容词——它描述了一种东西。你可能有一个敏捷的团队，或者一种敏捷的过程，但你却从来不是“敏捷”。</strong></p>
  
  <p>这是什么意思？这意味着那些向你硬推“敏捷”这个名词的人在撒谎，因为“敏捷”是买不来的。</p>
  
  <p>相反，敏捷是因人而起的——它来自于那些希望把事情做得更好的个体。这些个体观察如何做事，并寻找改进事情的方法。Kent Beck说这需要勇气，他说得没错。每当你尝试做出改进，你都在尝试改变现状，你将直面风险，你挑战了那些和你共事的人，他们也会用挑战来回敬你。</p>
  
  <p>但是，我认为：在任何环境下，这些挑战和相关的讨论都是合适的。</p>
</blockquote>

<h3>9. 技术人攻略：您接触过中国的程序员吗？您觉得他们和西方的程序员有哪些区别？</h3>

<blockquote>
  <p>我喜欢来中国的原因之一，就是可以和这里的程序员交流。</p>
  
  <p>这次的中国之行，我们在一家创业孵化咖啡馆（注：车库咖啡）渡过了非常愉快的一段时光。大家的活力和热情让我和我的妻子非常震惊，她甚至还为此写了一一篇博客：<a rel=""nofollow"" href=""http://myasiafix.weebly.com/1/post/2013/10/the-future.html"">http://myasiafix.weebly.com/1/post/2013/10/the-future.html</a></p>
  
  <p>西方的程序员也拥有这样的热情，但我在中国遇到的程序员表现出更多东西。或许是因为中国程序员要在更困难的环境下工作，又或许是因为中国的市场正开始爆发。不管是因为什么，我总能从中国程序员身上感到更多能量。</p>
  
  <p>中国同时还有另外一类程序员，我在和他们谈话的过程中注意到，他们把工作当成任务。或许在家庭的推动下进入这个可以获得一份“好”工作的行业，或许想在一个大型机构里寻求安全感。不管是出于什么原因，这类程序员身上都缺乏激情，缺少一份对他们所作事情的热爱。这令人伤心，因为写程序真的是一件非常有成就感，非常让人满足的事。我建议这些程序员们看看我妻子的那篇博客上的照片，问问自己是否也愿意加入其中，是否愿意向桌子对面的人分享自己的新想法？</p>
  
  <p>他们可以做到——任何人都可以做到。</p>
</blockquote>

<p><strong>附：Dave Thomas妻子的博客文章——<a rel=""nofollow"" href=""http://myasiafix.weebly.com/1/post/2013/10/the-future.html"">The Future</a></strong></p>

<p>晚餐过后，大会组织者将我们带到了一个创业孵化器——一家大型的互联网咖啡馆，年轻的中国技术创业者们在这里工作、和投资人会面、推销想法、编写代码——这些事情都同时进行。这一切简直是太赞了！星期天晚上的11点，我们走进了这个灯光昏暗、大堂几乎没有家具的路边办公室。穿过后门，上了楼梯，直接加入了充满创业热情的人群。我们比房间里的人年长得多，他们有着令人惊叹的能量，几乎所有的人都在参与创业项目。他们出来聊天，碰撞想法，并马上付诸实践。Dave被包围了，起先，我以为他们是在寻求某种投资。但并不是——我彻底错了。我们听到，并不断听到，想投资他们的人比他们需要的多得多。他们想了解Dave对自己创业项目的看法，他的祝福和他的批评——他们十分投入，期待成功。他们想有所成就，而且他们每个人都有非常棒的，独特的事业。</p>

<p>在一个角落里有一台3D打印机——正在做一个脊椎。另一个大的角落作为演示区域，配置好了笔记本的投影。后面的墙上是一组技术书架（他们向我们保证，有许多Pragmatic出版的书）。这里的环境是随性而自然的——桌椅随意摆放，人们可以根据讨论需求随意组合。</p>

<p>这些年轻人了解各个层面的知识，不仅仅是技术上的。他们理解在开曼群岛上注册公司、天使投资以及IPO，3D打印机旁的电脑连着Kickstarter。这些人聪明、热情，并且很努力，一点也看不到懒惰、傲慢以及理所当然的态度。</p>

<p>还有来自香港和台湾的年轻人，他们认为中国大陆才是做事的地方。</p>

<p>我对此毫不怀疑——他们说得很对。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbzUm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<hr>
<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com/"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @<a rel=""nofollow"" href=""http://weibo.com/devlevelup"">devlevelup</a>，希望能成为技术人成长的精神家园。<br>
欢迎通过微信公众账号关注技术人攻略</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxHi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

                ", 技术人攻略访谈十四：Dave Thomas——生命不息，编程不止,1531978054,373,1,241,1,1,https://segmentfault.com/a/1190000000337294
142,1,0,9,"
                    <p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVby4L"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3>1、慎重选择第1门语言</h3>

<p>编程语言各有不同，不过区别不大。但用语言的人区别就大了。选择了一门语言你就选择了一个群落。</p>

<p>– Sam Kaufman，自由职业者，iOS 开发者，10x management</p>

<p>如果你想快速建立原型（尤其对于希望对产品进行迭代升级的创始人来说），那就用 Ruby 或者 Javascript</p>

<p>– Erin Parker，Spitfire Athlete 创始人兼首席开发者</p>

<h3>2、你不是程序猿！</h3>

<p>伟大的开发者能够建构并开发应用。惊艳的开发者能够在关注业务的同时做这件事。业务端的人大都不懂编码，但是肯定能够理解特定功能背后的动机。</p>

<p>别人说什么开发者就做什么，没有去理解为什么要这么做，导致双方均错失了机会，这样的事情太常见了。</p>

<p>– John Coggeshall，自由职业者，web 开发者，10x Management，PHP 核心贡献者</p>

<p>精通编程是一个崇高的职业目标。一旦实现了这个目标，别忘了考虑一下你自己。不要成为任何公司的奴隶或者在毫无价值的东西上浪费你的时间。</p>

<p>— Greg Sadetsky， Python 及 Javascript 专家，10x Managemen；协同办公空间 Abri.co 创始人</p>

<p>要想按期完成，得在开始技术工作之前事先进行项目沟通（哪怕这并非先决条件），因为其他人的响应速度千变万化。</p>

<p>– Andrew Wilcox ，web 应用开发者，Meteor 核心贡献者，10x Management</p>

<h3>3、保持敏捷，不断交付</h3>

<p>早发布，不断发布，边说唱边发布。</p>

<p>– Max Nanis ，自由职业者，web 开发者，生物信息学专家，10x Management</p>

<p>不断测试。好的测试包如保单和煤矿里的金丝雀之结合。它能帮助你在生产周期中更早地找出错误，而错误越早发现越容易解决。</p>

<p>– Jeremy Green，自由职业者，web 开发者，专长 Ruby on Rails，10x Management</p>

<p>快速失败。编码（及生活）时我希望尽早知道什么地方不能工作，而不是放任不管让它增殖扩散。全面放开，快速失败，修补缺陷，不断继续。</p>

<p>– Stephanie Volftsun，Knotch 联合创始人兼 CTO</p>

<p>为所有代码编写自动测试！尽可能践行测试驱动的开发。</p>

<p>– Zoran Kacic-Alesic，Industrial Light &amp; Magic 研发主管</p>

<h3>4、保持对测试流程的控制</h3>

<p>许多项目深受多测试周期之苦。这会拖累项目，导致组织整体出现高级别的问题。</p>

<p>程序员应该专注于对自己的代码进行单元测试及半回归测试。他们比其他任何人更了解代码库，也知道自己会影响到哪些变更。有时此类变更会由于 QA 测试范围有限而缺失，因此导致生产环节出现重大问题。</p>

<p>– Sanjib Sahoo，tradeMONSTER CTO</p>

<p>要想在力所能及的情况下尽快开发出无缺陷代码，永远永远也不要把写测试放到后面。我们更清楚这一点。要检查一下测试的覆盖率，确保 100% 无死角。</p>

<p>– Seth Purcell，Signpost 工程副总裁</p>

<h3>5、如果你是自由职业者，要学会说不，哪怕面对的是金钱</h3>

<p>要对时间和成本有一个合理的评估，然后把它加倍。如果大家都说“这应该很简单，”那就做</p>

<p>– Ryan Waggoner ，自由职业者，web 及移动应用开发者，10x Management</p>

<h3>6、荣誉属于过去—理论是一回事，但实践更重要</h3>

<p>改进软件开发质量的最好方式就是去开发软件。许多雄心勃勃的刚入门的工程师花了很多的业务时间去读书，关于最新工具的、关于开放流程的，诸如此类的东西。</p>

<p>很多人都是这么消磨自己的闲暇时间的，但这样很容易就把你给耽搁了。别这样，通过尽可能用脑来强化大脑负责开发软件的那部分。</p>

<p>–James Cropcho，General Assembly 的 Ruby on Rails 专家及讲师</p>

<p>不断探索。我见过的许多编码者手上都有几个在进行的业务项目。做业务项目迫使你要探索新技术然后学习创建应用的方方面面。你可能需要做前端的 HTML/CSS，后端的 API 集成，数据库优化，做移动 app，还得设置自己的服务器。</p>

<p>– Andrew Waage，Retention Science CTO 及联合创始人</p>

<h3>7、结对评审是你的秘密武器</h3>

<p>结对编程非常必要。两个程序员联合开发同一个模块可以相互审查对方的代码。开发团队每周也要召开代码审查会议，让每一个开发者给其他人的代码提供反馈意见，解释如何更好地改进代码。这能够形成一种协作文化，把开发者的自负抛开！</p>

<p>– Sanjib Sahoo</p>

<h3>8、像躲瘟疫一样避免过早优化</h3>

<p>只有在问题和解决方案都出现在你面前时才进行重构—过早重构是时间上的巨大浪费。不要投入半年后可能被扔掉的任何东西的完善上。过早优化是罪恶之源。</p>

<p>–Seth Purcell</p>

<p>不要过早优化！我不断看到工程师在用户还没有到 1000 的时候一再对扩充到 100 万的用户规模担心。</p>

<p>– Mariya Yao，Xanadu Mobile 创始人兼创意总监，移动开发者及设计师</p>

<h3>9、你的代码只写一次，可别人会读它千万遍</h3>

<p>你写的代码机器会解析执行，可其他人却需要读你的代码，理解它，摆弄它。你必须明白，你的代码会有未来的观众。代码也是一种书写形式的沟通。</p>

<p>– Tracy Chou，Pinterest 软件工程师</p>

<p>听起来很奇怪，但是你永远都得替自己的未来着想。问问自己：如果你有健忘症的话，你还能不能理解自己写过的代码？</p>

<p>– Wai Ching Jessica Lam，Sugarbox 联合创始人兼 CTO</p>

<p>通读你的文档。设计改动很多，有时候代码更新的时候注释不一定会跟进。保持文档的更新，未来的人（包括你自己）理解起来就更容易。我说不清有多少次我看回自己代码时总在想：“我到底在干什么？”只要我写出了好的注释，未来头疼就少很多。</p>

<p>– Kitt Vanderwater，Google 软件工程师</p>

<h3>10、这是一个崇高的职业。把你的技能用到好的地方。</h3>

<p>帮助他人是深层次的人类需求。想办法用你的工作来改善人类，你就会有成功的把握。</p>

<p>– Greg Sadetsky</p>

<p>via @<a rel=""nofollow"" href=""http://www.36kr.com/p/207585.html"">36kr</a></p>

                "," 来自Google, Pinterest 等公司顶级程序员的10条最佳实践",1531978056,188,1,754,1,1,https://segmentfault.com/a/1190000000334094
143,1,0,9,"
                    <p>点此查看<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000313451"">上一篇</a>。</p>

<h2>0 分手篇</h2>

<p>程序员问禅师：“我和在一起 7 年的女友分手了，程序员是否诸多和爱情无缘？”</p>

<p>禅师笑而不语，把程序员带到正在比赛的球场。</p>

<p>程序员大悟：“大师的意思是否是说：爱情的意义就像一场比赛，只要过程努力过，结果如何并不重要？”</p>

<p>大师闭上眼睛道：“你分手关我球事？”</p>

<h2>1 相貌篇</h2>

<p>程序员问禅师：“我天天对着电脑，熬夜到凌晨。大家都说我丑，我真的很丑吗？”</p>

<p>禅师笑而不语，端起一杯水，浇到程序员脑袋上。</p>

<p>程序员不解：“你的意思是，我每天都洗头就不那么丑了？”</p>

<p>禅师回答说：“丑到端水水更流，举杯浇丑丑更丑。”（抽刀断水水更流，举杯浇愁愁更愁——李白）</p>

<h2>2 财富篇</h2>

<p>程序员问禅师：“大师，我天天加班，独立完成了一个大项目，我现在很富有，但是我却一点也不快乐，您能指点我该怎么做吗？”</p>

<p>禅师问道：“何谓富有？”</p>

<p>程序员回道：“银行卡里 8 位数，五道口有 3 套房不算富有吗？”</p>

<p>禅师没说话，只伸出右手，青年恍然大悟：“禅师是让我懂得感恩与回报？”</p>

<p>“不，—— 土豪，我们可以做朋友吗？”</p>

<h2>3 单身女程序员篇</h2>

<p>女程序员问禅师：“为什么我年轻漂亮，楚楚动人，可没有男人喜欢我？因为我是一名女程序员吗？”</p>

<p>禅师问：“你知道男人为什么喜欢大海，而不喜欢湖吗？”</p>

<p>女程序员想了想：“我知道了，因为大海挑战大，男人都喜欢挑战，所以喜欢大海，对吗？”</p>

<p>禅师：“挑战个屁啊，因为大海波大！”</p>

<h2>4 单身男程序员篇</h2>

<p>程序员问禅师：“我一直追不到我心仪的女孩，我该怎么办才好？因为我是一名程序员吗？”</p>

<p>禅师笑而不语，指了指旁边树杆上正在艰难爬行的蜗牛。 </p>

<p>程序员顿悟道：“禅师，您是说只要像这蜗牛一样坚持不懈，总会成功是么？ ”</p>

<p>禅师抡起木鱼狠砸：“傻X，你得像它一样先有套像样的房子!”</p>

<h2>5 资金篇</h2>

<p>程序员问禅师：“我有很大的梦想，如果实现了，这个世界将再也没有纷争。因此我需要很多钱，大师您能帮我吗？”</p>

<p>禅师拿出一个小孩的帽子和一双小孩的手套让青年穿上，然后问：”你有什么感觉？”</p>

<p>“手，头有点紧。”</p>

<p>“我也是。”</p>

<h2>6 休息篇</h2>

<p>程序员半夜睡不着，于是问禅师：“大师我经常失眠，应该怎么办呢？”</p>

<p>禅师笑而不语，手指指向禅房的墙壁。</p>

<p>程序员循指望去，一面白墙映入眼帘，墙体空白一片别无它物。程序员沉思良久后恍然大悟：“大师是说要摒弃心中杂念，心无所想才能入睡？”</p>

<p>禅师摇摇头，大怒：“我意思是TM给我滚！都凌晨一点了还让不让人睡啊！”</p>

<h2>7 生活篇</h2>

<p>程序员问老禅师：“我是一名苦B程序员，活得没有一点安全感，该怎么办呢？”</p>

<p>禅师笑而不语，用手指了指自己的胸口。</p>

<p>程序员恍然大悟：“我明白了。只有像您这样心无所系，才能无忧无虑，对吗？”</p>

<p>“不” 老禅师缓缓的从胸口掏出一个小本本，上面写着：“The Secretary of State of the United States of America hereby requests ……”</p>

<h2>8 感情篇</h2>

<p>程序员问禅师：“大师，我收入不高，没有对象。因此心情烦躁，静不下来，我觉得心堵很痛苦。” </p>

<p>禅师笑笑抬手向南方一指，悠悠说道：“去看看大海吧。”</p>

<p>程序员若有所思的问：“这是要我陶冶情操，感受海的博大胸怀吗？”</p>

<p>禅师摇摇头：“如果大海能够，带走你的矮丑。”</p>

                ", 据说，年薪百万的程序员，都是这么开悟的（续篇）,1531978057,354,1,880,1,1,https://segmentfault.com/a/1190000000320824
144,1,0,9,"
                    <p>每当我说起「每月大概在亚马逊买100块钱的书」，别人都会问我：</p>

<blockquote>
  <p>天天这么忙，哪有时间读书？</p>
</blockquote>

<p>我都会给他讲如下的段子：</p>

<hr>

<p>女：你抽烟吗？<br>
男：抽。 </p>

<p>女：每天多少包？<br>
男：三包。</p>

<p>女：每包多少钱？<br>
男：10英镑。</p>

<p>女：你抽烟多久了？<br>
男：15年。</p>

<p>女：所以这些年来每年你抽烟就花了10800英镑。<br>
男：正确。 </p>

<p>女：1年10800英镑，不考虑通货的话，过去的15年里你抽烟总共花了162000英镑对吗？<br>
男：嗯。 </p>

<p>女：你知道吗？如果你没有抽烟，把这些钱放在一个高利息的储蓄账户里，按复合利率来算。你现在能买一辆法拉利了。 </p>

<p>女：那你戒烟吗？
男：不戒。</p>

<p>女：为什么？</p>

<hr>

<p>男：你抽烟吗？<br>
女：不。 </p>

<p>男：那麻痹你的法拉利呢？</p>

                ", 苦B程序员们，你的法拉利呢？,1531978059,599,1,310,1,1,https://segmentfault.com/a/1190000000317937
145,1,0,9,"
                    
<p>《<a href=""http://book.douban.com/subject/1899158/"" rel=""nofollow noreferrer"">编程之道</a>》出自美国一位资深的程序设计师 Geoffrey James 之手。</p>
<p>相传作者早起打太极拳的时候，突然开悟，悟到了编程之道。</p>
<p>本文章我自己整理的番外篇，哈哈哈，有点儿无节操。</p>
<h3>1.1</h3>
<p>程序员见禅师：我学了 hello world 和水仙花数，想自己开发个操作系统，希望大师指点。</p>
<p>禅师笑而不语，抓来一只鸡，在鸡腿上缠根线，他一拉线，鸡立即跌倒，鸡挣扎起来继续走，禅师又一拉，鸡又跌倒，如此反复八次之多。</p>
<p>程序员若有所悟：“大师您是让百折不挠，再接再厉？”</p>
<p>禅师一笑：“小伙子，我是让你拉鸡八倒。”</p>
<h3>1.2</h3>
<p>程序员问禅师：我总是和我的同事们合不来，他们使用 Java，我使用 PHP。</p>
<p>禅师笑而不语，拿出一根筷子，递给青年：来，折断它。</p>
<p>青年接过筷子，很轻松地就折断了。 </p>
<p>禅师又拿出四十七根筷子，青年抢过来，抄出把斧头全砍断了。</p>
<p>禅师沉吟片刻，摆出架式，双手合十：你们应该使用 Python 语言。</p>
<h3>1.3</h3>
<p>程序员对禅师说：“禅师，有些东西我放不下。” </p>
<p>禅师说：“没有什么东西是放不下的。” </p>
<p>程序员摇了摇头，打开电脑。</p>
<p>禅师说：“还是买个大点儿的硬盘吧。”</p>
<h3>1.4</h3>
<p>一程序员请教禅师：我最喜欢 java 语言，但是别人总说 java 不好，java 将死，我该如何？</p>
<p>禅师拿起一把斧子抛向天空，然后问：听到天空喊疼的声音了吗？</p>
<p>该程序员摇头：斧子又没伤到天空，天空怎么会喊疼呢？</p>
<p>禅师点头：天空那么高远辽阔，何事不能容。做名合格程序员，要像天空一样。斧子扔得再… 啊呀我操…</p>
<h3>1.5</h3>
<p>程序员去拜访禅师：每次遇到程序 bug，我都心急如焚，特向大师求心灵平静之道。</p>
<p>禅师一言不发，先去劈柴，然后打水，把柴放入灶中点燃，用大壶烧水，细细地一个个擦拭茶杯。</p>
<p>程序员恍然大悟：“您的意思是，要善于从生活的细处去体验人生！”</p>
<p>禅师放下手里的活计，淡然道：“我这刚上班，正忙着呢，别他妈烦我！！”</p>
<h3>1.6</h3>
<p>程序员问禅师：“我想开发一个网站，其中包罗万象，汇集人人、QQ、facebook、淘宝的所有特长，大师觉得如何？”</p>
<p>禅师一言不发带他来到院子里，几棵梅树正默默地吐露着芬芳。</p>
<p>“梅花香自苦寒来...” </p>
<p>程序员很受感动：“大师！您是想告诉我只要不断努力就能得偿所愿吗？”</p>
<p>禅师摇了摇头：“梅前你说个屁。”</p>
<p><strong>欢迎补充</strong></p>
<p><span class=""img-wrap""><img data-src=""http://justjavac.com/assets/images/weixin-justjavac.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""justjavac微信公众号"" title=""justjavac微信公众号""></span></p>

                ", 据说，年薪百万的程序员，都是这么开悟的～,1531978060,101,1,724,1,1,https://segmentfault.com/a/1190000000313451
146,1,0,9,"
                    <p>前几天在 iteye 看到一篇文章，里面写了一句话：</p>

<blockquote>
  <p>谭浩强说过：程序 = 算法 + 数据结构</p>
</blockquote>

<p>当时我和我的小伙伴都惊呆了。于是，发到群里，准备嘲讽一下，却</p>

<blockquote>
  <p>难道不是吗？<br>
  难道不是吗？+1<br>
  难道少了分号： 程序 = 算法 + 数据结构;<br>
  应该是 ""程序 == 算法 + 数据结构"" 吧。<br>
  我记得书上就是这么写的啊！</p>
</blockquote>

<p>可见谭浩强在中国大学生中已经深入人心。其实也怪老谭，引用完了却不注明来源，这句话的原创者是 Pascal 之父——Nicklaus Wirth，如果说有一个人因为一句话而得到了图灵奖，那么这个人应该就是Nicklaus Wirth。</p>

<p>因此我也来挖坟，找了一篇老文章。依稀记得 09 年初发表在了 javaeye，貌似刚刚辍学，正在读《Borland传奇》。好了，废话少说，言归正传。</p>

<h2>Bill Joy</h2>

<p>计算机界的爱迪生，我最崇拜的人之一。</p>

<p>Bill Joy, 前任Sun 的首席科学家，当年在 Berkeley（伯克利）时主持开发了最早版本的BSD 。他还是 vi 和 csh 的作者。当然，Csh Programming Considered Harmful 是另一个话题乐。</p>

<p>据说他想看看自己能不能写个操作系统，就在三天里写了个自己的 Unix, 也就是 BSD 的前身。当然是传说了，但足见他的功力。</p>

<p>另一个传说是，1980 年初的时候，DARPA 让 BBN 在 Berkley Unix 里加上 BBN 开发的 TCP/IP 代码。但当时还是研究生的 B 伯伯怒了，拒绝把 BBN TCP/IP 加入 BSD ，因为他觉得 BBN 的TCP/IP 写得不好。于是 B 伯伯出手了，端的是一箭封喉，很快就写出了高性能的伯克利版 TCP/IP 。当时 BBN 和DARPA 签了巨额合同开发 TCP/IP Stack，谁知他们的代码还不如一个研究生的好。于是他们开会。只见当时 B 伯伯穿个 T-shirt 出现在会议室( 当时穿T-shirt 不象现在，还是相当散漫的哈) 。只见BBN 问：你怎么写出来的？而B 伯伯答：简单，你读协议，然后编程就行了。</p>

<p>最令偶晕倒的是，B 伯伯硕士毕业后决定到工业界发展，于是就到了当时只有一间办公室的 Sun, 然后他就把 Sparc 设计出来乐。。。象这种软硬通吃的牛人，想不佩服都不行的说。据 Bill Joy 的同事说，一般开会的时候 B 伯伯总是拿一堆杂志漫不经心地读。但往往在关键之处，B 伯伯发言，直切要害，提出漂亮的构想，让同事们彻底崩溃。对了，他还是 Java Spec 和 JINI 的主要作者之一。</p>

<h2>John Carmack</h2>

<p>John Carmack ，ID Software 的 founder 和 Lead Programmer 。上个月和一个搞图形的师兄聊天，他竟然不知道 John Carmack, 也让偶大大地晕了一把。不过也许搞研究的和搞实战的多少有些隔吧。想必喜欢第一人称射击游戏的都知道 J 哥哥。90 年代初只要能在 PC 上搞个小动画都能让人惊叹一番的时候，J 哥哥就推出了石破天惊的 Castle Wolfstein, 然后再接再励，doom, doomII, Quake... 每次都把 3-D 技术推到极限。J 哥哥的简历上说自己的专长是""Exhaust 3-D technology"" ，真是牛人之言不我欺的说。</p>

<p>做 J 哥哥这样的人是很幸福的，因为各大图形卡厂家一有了新产品就要向他“ 进贡"" ，不然如果他的游戏不支持哪种卡，哪种卡基本就会夭折乐。当初 MS 的 Direct3D 也得听取他的意见，修改了不少 API 。当然，J 哥哥在结婚前十数年如一日地每天编程 14 小时以上，也是偶们凡人望尘莫及的。</p>

<p>对了，J 哥哥高中肆业(?) ，可以说是自学成才。不过呢，谁要用这个例子来为自己学习不好辩护，就大错特错了。那 Leonardo Da Vinci 还是自学成才呢(人是私生子，不能上学) 。普通人和天才还是有区别的。</p>

<h2>David Cutler</h2>

<p>David Cutler ，VMS 和Windows NT 的首席设计师，去微软前号称硅谷最牛的 kernel 开发员。当初他和他的手下在微软一周内把一个具备基本功能的 bootable kernel 写出来，然后说：“who can't write an OS in a week?"" ，也是牛气冲天的说。顺便说一句，D 爷爷到NT3.5 时，管理1500 名开发员，自己还兼做设计和编程，不改coder 本色啊。</p>

<p>D 爷爷天生脾气火爆，和人争论时喜欢双手猛击桌子以壮声势。日常交谈 fuck 不离口。他面试秘书时必问：""what do you think of the word 'fuck'?"" ，让无数美女刹羽而归。终于有一天，一个同样火爆的女面对这个问题脱口而出：""That's my favoriteword"" 。于是她被录取乐，为 D 爷爷工作到 NT3.5 发布。（PS：不知道期间有没有因此其它故事。）</p>

<h2>Don Knuth</h2>

<p>Don Knuth 。高爷爷其实用不着偶多说。学编程的不知道他就好像学物理的不知道牛顿，学数学的不知道欧拉，学音乐的不知道莫扎特，学Delphi 的不知到 Anders Hejlsberg ，或者学Linux 不知道Linus Torvalds 一样，不可原谅啊。</p>

<p>为了让文章完整，就再罗唆几句吧。高爷爷本科时就开始给行行色色的公司写各种稀奇古怪的编译器挣外快了。他卖给别人时收一两千美元，那些公司拿了 code ，加工一下卖出去就是上万上十万。不过也没见高爷爷不爽过，学者本色的说。想想那可是 60 年代初啊，高爷爷写编译器写多了，顺带就搞出了个 Attribute Grammar 和 LR(k) ，大大地造福后人啊。至于高爷爷在CalTech 的编程比赛( 有Alan Kay 得众多高高手参加) 总是第一，写的 Tex 到 86 年就 code freeze ，还附带 2^n 美分奖励等等都是耳熟能详的，偶就不饶舌乐。</p>

<p>顺便说一下，高老大爷是无可争议的写作高手。他给 Concrete Mathematics 写的前言可谓字字铿锵，堪为前言的典范。他的技术文章也是一绝，文风细致，解释精当，而且没有学究气，不失轻快跳脱。记得几年前读 Concrete Mathemathics ，时不时开怀大笑，让老妈极其郁闷，觉得我 nerdy 到家，不可救药。其实呢，子非鱼，安知鱼之乐，更不知那完全是高爷爷的功劳。说到写作高手，不能不提 Stephen A. Cook 。他的文章当年就被我们的写作老师极力推荐，号称典雅文风的样本。库爷爷一头银发，身材颀长，总是面带谦和的微笑，颇有仙风道骨，正好和他的仙文相配的说。</p>

<p>高爷爷其实还是开源运动的先驱。虽然他没有象 Richard Stallman 那样八方奔走，但他捐献了好多作品，都可以在网上看到，比如著名的 Mathematical Writing ，MMIXWare ，The Tex Book 等，更不用说足以让他流芳百世的 Tex 乐。</p>

<h2>Ken Thompson</h2>

<p>Ken Thompson ，C 语言前身 B 语言的作者，Unix 的发明人之一( 另一个是 Dennis M. Riche 老大，被尊为 DMR) ，Belle (一个厉害的国际象棋程序) 的作者之一, 操作系统 Plan 9 的主要作者(另一个是大牛人 Rob Pike, 前不久被 google 挖走了) 。</p>

<p>Ken 爷爷也算是计算机历史上开天辟地的人物了。1969 年还是计算机史前时代，普通人都认为只有大型机才能运行通用的操作系统，小型机只有高山仰止的份儿。至于用高级语言来写操作系统，更是笑谈。Ken 爷爷自然不是池中物，于是他和 DMR 怒了，在 1969 年到 1970 间用汇编在 PDP-7 上写出了 UNIX 的第一个版本。他们并不知道，一场轰轰烈烈的 UNIX 传奇由此拉开了序幕。Ken 爷爷在 1971 年又把 Unix 用 C 重写，于是 C 在随后 20 年成就了不知多少豪杰的梦想和光荣。</p>

<p>Ken 爷爷还有段佳话：装了 UNIX 的 PDP-11 最早被安装在 Bell Lab 里供大家日常使用。很快大家就发现 Ken 爷爷总能进入他们的帐户，获得最高权限。Bell Lab 里的科学家都心比天高，当然被搞得郁闷无比。于是有高手怒了，跳出来分析了 UNIX 代码，找到后门，修改代码，然后重新编译了整个 UNIX 。就在大家都以为“这个世界清净了”的时候，他们发现 Ken 爷爷还是轻而易举地拿到他们的帐户权限，百思不解后，只好继续郁闷。谁知道这一郁闷，就郁闷了 14 年， 直到 Ken 爷爷道出个中缘由。原来，代码里的确有后门，但后门不在 Unix 代码里，而在编译Unix 代码的 C 编译器里。每次 C 编译器编译 UNIX 的代码，就自动生成后门代码。而整个 Bell Lab 的人，都是用 Ken 爷爷的C 编译器。</p>

<h2>Rob Pike</h2>

<p>Rob Pike, AT&amp;T Bell Lab 前 Member of Technical Staff ，现在 google 研究操作系统 。罗伯伯是 Unix 的先驱，是贝尔实验室最早和 Ken Thompson 以及 Dennis M. Ritche 开发 Unix 的猛人，UTF-8 的设计人。</p>

<p>他还在美国名嘴 DavidLetterman 的晚间节目上露了一小脸，一脸憨厚地帮一胖子吹牛搞怪。让偶佩服不已的是，罗伯伯还是1980 年奥运会射箭的银牌得主。他还是个颇为厉害的业余天文学家，设计的珈玛射线望远镜差点被 NASA 用在航天飞机上。他还是两本经典， The Unix Programming Environment 和 The Practice of Programming 的作者之一。如果初学者想在编程方面精益求精，实在该好好读读这两本书。它们都有中文版的说。</p>

<p>罗伯伯还写出了 Unix 下第一个基于位图的窗口系统，并且是著名的 blit 终端的作者。当然了，罗伯伯还是号称锐意革新的操作系统，Plan9 ，的主要作者。可惜的是，Plan9 并没有引起多少人的注意。罗伯伯一怒之下，写出了振聋发聩的雄文 Systems Software Research is Irrelevant ，痛斥当下系统开发的不思进取，固步自封的弊病。虽然这篇文章是罗伯伯含忿出手，颇有偏激之词，但确实道出了系统开发的无奈：开发周期越来越长，代价越来越大，用户被统一到少数几个系统上，结果越来越多的活动是测量和修补，而真正的革新越来越少。</p>

<p>就在罗伯伯郁闷之极的时候，google 登门求贤来乐。如果说现在还有一家大众公司在不遗余力地把系统开发推向极致的话，也就是 google 乐。随便看看 google 的成果就知道了。具有超强容错和负载平衡能力的分布式文件系统 GFS(现在能够用 100,000 台廉价 PC 搭起一个巨型分布系统，并且高效便宜地进行管理的系统也不多哈) ，大规模机器学习系统( 拼写检查，广告匹配，拼音搜寻。。。哪个都很牛的说) ，更不用说处理海量并行计算的各式 google 服务了。Rob 在 System Software Research is Irrelevant 里萧瑟地说现在没有人再关心系统研究的前沿成果了。想不到他错了，应为 google 关心。google 网络了大批功成总是试图吸取系统研究的最新成果。想必 Rob Pike 在 google 很幸福。愿他做出更棒的系统。</p>

<h2>Dennis M. Ritchie</h2>

<p>Dennis M. Ritchie, 既然Ken Thompson 是我的偶像，新闻组上人称 DMR 的 Dennis M.Ritchie 自然也是，毕竟两人共同缔造了 UNIX ，而 Dennis 几乎独力把 C 搞大(当然，C 的前身是 B ，而 B 是Ken Thompson 一手做出来的) 。两人 1983 年分享图灵奖，是有史以来少数几个因工程项目得奖的工程师(本来是唯一的一对儿，但 Alan Kay 才因为 SmallTalk 得奖，所以就成了唯二的乐)一个人一生能做出一个卓越的系统已经不易，DMR 的C 和UNIX 长盛不衰近30 年，至今生机勃勃，DMR 此生可以无憾的说。</p>

<p>D 爷爷也算有家学渊源：他老爸在 AT&amp;T 贝尔实验室工作了一辈子，并在电路设计方面卓有成就，还出了本颇有影响的书 The Design of Switching Circuits ，据说在交换理论和逻辑设计方面有独到的论述。当然，D 爷爷和他老爸是不同时代的人：他老爸的研究成形于晶体管发明之前，而 D 爷爷的工作离了晶体管就玩儿不转乐。:-D</p>

<p>不要看 D 爷爷搞出了C ，其实他最爱的编程语言是 Alef ，在 Plan9 上运行，支持并行编程。 Alef 的 语法和 C 相似，但数据类型和执行方式都和 C 大大不同。说到语言，D 爷爷对后来人有非常中肯的建议：抱着学习的目的来开发你自己的语言，不要冀望于它被众人接受。这个建议不光对语言开发有用，也适用于其它大型系统的开发。别的不说，DMR 后来领导自己的团队在 1995 年和 1996 分别推出了 Plan9 和 Inferno 操作系统，又用多少人知道呢？其实，D 爷爷当初也没想过 C 会风行世界。他开发 C 的初衷和 Eric S. Raymond 在 Cathedral and Bazaar 里阐述的一样，就是要消除自己对现有工具的不爽之处。谁知 D 爷爷无心插柳，C 竟然受到众多程序员的狂热拥戴，连 D 爷爷自己都大惑不解。在一次采访中 D 爷爷说大概那是因为 C 的抽象程度碰巧既满足了程序员的要求, 又容易实现。当然 C 一度是 Unix 上的通用语言也是原因。但不管怎么说，D 爷爷对编程语言出色的审美意识奠定了 C 广为流传的基础。</p>

<p>最后八卦一下。D 爷爷的业余爱好和 NBA 大牛 Karl Malone 一样：开卡车。不过 D 爷爷更喜欢开 NASCAR ，而 KM 独爱巨无霸。D 爷爷自称心中不供偶像，如果一定要说一个，那就是 Ken Thompson 了。现在 Ken 爷爷退休当飞机教练去了，而 D 爷爷当了贝尔实验室系统开发部的头，整日忙于开支票。他俩合作 20 年，屡屡创造历史。这段令人神往的佳话，也就长留你我心中乐。</p>

<p>P.S., 很多人都以为 Brian W. Kernighan 是 C 的作者。其实 BWK 只是写了那本经典 K&amp;R C 。据 D 爷爷说，他，Ken, 和 Kernighan 三人中，Kernighan 最能写文章，他次之，而 Ken 写得最少；但说到编程，Ken 爷爷才是当之无愧的老大。</p>

<h2>Edsger Wybe Dijkstra</h2>

<p>Edsger Wybe Dijkstra, 对，就是 E.W. Dijkstra. 一提到 EWD ，很多人就会想起找最短路径的 Dijkstra Algorithm ，就好像一提到 Sir. Tony Hoare ，就想起 Quick Sort 一样。</p>

<p>其实这些个算法不过是两个牛人在他们职业生涯中最琐碎的贡献。比如 Dijkstra 算法，无非是戴爷爷在 1956 年为了展示新计算机 ARMAC 的计算能力，初试身手的成果，属于他的算法处女作。据戴爷爷自述，他搞出最短路径算法的时候连纸笔都没用。当时他和他老婆在阿姆斯特丹一家咖啡厅的阳台上晒太阳喝咖啡，突然就把这个算法想出来乐。而且当时的算法研究还比较原始，牛人们忙着用计算机搞数值计算，对离散算法不屑一顾。那时连一个象样的专注于离散算法的专业期刊都没有。戴爷爷于是推迟发表这个算法。直到 1959 年，他才把这个算法发表在 Numerische Mathematik 的创刊号上，权为捧场。:-)</p>

<p>EWD 在多个领域牛气冲天，端的是理论和编程两手硬的高手 。只不过他的很多工作比较深刻，学校的老先生们觉得本科生接受不了，不给本科生讲而已。</p>

<p>戴爷爷大概因为最短路径算法一战成名，于是有人请他参加另一台计算机 X1 的设计工作，并且把设计实时中断系统的任务派给了他。现在看来实时中断也许不算什么，但要知到，X1 前根本就没有实时中断的概念。实现它简直就是一场豪赌。戴爷爷起初还不情愿，但经不住项目负责人 Bram 和 Carel 的轮番 “ 吹捧” ：我们知道实时中断让您工作变得非常困难，但象您这样的牛人肯定能做出来的说。结果戴爷爷被糖衣炮弹彻底击穿，接下了这个烫手山芋。两三年后，他不仅搞出了实时中断，还围绕这个写出了自己的博士论文，顺利戴上博士帽。</p>

<p>让戴爷爷真正成名立万的还是在 X1 上开发的 Algo60 ，最早的高级语言之一。戴爷爷没日没夜地工作了 8 个月，就搞出了 Algo60 ，也因此获得了 1972 年的图灵奖。因为 Algo60 ，戴爷爷发表了一篇石破天惊的文章：Recursive Programming ，于是人们才知道，原来高级语言也可以高效地实现递归，原来从此以后，所有程序员都不可避免地和戴爷爷发明的一个词( 应该说是概 念) 打交道：堆栈。而且 Algo60 还让戴爷爷深入地思考多道程序设计的问题，最终发明了每个系统程序员都绕不开的概念：semaphore 。当然，戴爷爷总是把他发明的概念严格形式化，极具科学家本色的说。和这些成就想比，他提出的吃饭的哲学家问题，也就没什么好说的了。</p>

<p>说来好笑，当时的大学(忘了哪所了) 还是觉得戴爷爷没有受过正统的数学训练，也不是专门搞数值分析的，所以最后不太情愿地给了他一个教职。这种小挫折并不能妨碍象戴爷爷这样的牛人创造历史。他一边教数值分析(:-D) ，一边开始开发一个新的操作系统，并培养计算机科学家。几年后，THE Multiprogramming System 横空出世。THE 是第一个支持松散耦合，显式同步的进程并由此使得严格证明系统没有死锁变得容易的操作系统。可惜戴爷爷任职的系不识货，还强行解散了他的研究小组(1972 年戴爷爷给他的系主任说他得了图灵奖，系主任的第一反应是你们搞计算机就喜欢乱发奖) 。这让戴爷爷相当郁闷，得了抑郁症。在极度郁闷之中，戴爷爷决定用写作来治疗自己的抑郁症。于是经典就诞生乐：Notes on Structured Programming 。戴爷爷从此被尊为结构化编程的奠基人，而且他的抑郁症也被治好乐。</p>

<h2>Anders Hejlsberg</h2>

<p>Anders Hejlsberg ，微软 .NET 的首席架构师，编程语言设计和实现的顶尖高手。他一手做出了 Turbo Pascal, 也是 Delphi, J++(尤其是WFC) ，C#, 和 .NET 的主要作者。这些作品的名字足以为他立传。作为一个程序员，我在这样的大师面前实在无语。生子当如 Anders 的说。</p>

<p>关于 Anders 的故事，可以读读李维的《Borland传奇》。</p>

<p>对于 Anders，如果再多写的话，恐怕会暴露我的年龄 OMG。因为我也是沐浴着 Borland 成长起来的一代程序员。</p>

<p>提到过去的 borland，想到的是：Turbo Pascal、Turbo C 、Borland C++、Dephi、Jbuilder 这些如雷贯耳、耳熟能详的伟大产品。</p>

<p>当年 borland 的创始人 philippe 和 Anders 两个人联手创业时，philippe 在西餐厅打工赚钱，而 Anders 则在开发后来的旗舰产品：Turbo Pascal。两个人因为本钱不够，决定到偏远的地方开始创业，他们开着 philippe 的破车，走到了 Scott Valley 的时候，刚好没油了，他们看着四周的美景，决定留下来开始自己的事业。若干年后，此地成为了高科技的盛地。</p>

<p>Anders 使用汇编语言撰写编译器，其功力无人能出其右。创造出了全世界速度最快、品质也是一流的 Pascal 编译器。在 Anders 离开了 Borland 之后，几乎没有人能够修改 Anders 的编译器。</p>

<p>后来推出了神级的开发工具 Delphi，当时别成为 VB killer（VB杀手），Borland 独占几乎所有的编译器市场。当 Java 在 1996 年逐渐快速发展之后，睿智的 Anders 也看到了 Java 成功的未来。因此在他不再积极参与 Delphi 2/3 的开发工作之后，便非常希望能够主导 Borland Java 开发工具的开发，期望能够像当初的 Delphi 1.0 一样，为 Borland 再次开发出全世界一级的 Java 开发工具。</p>

<p>不过，由于当时 Delphi 是 Borland 最重要的收入来源，高层仍然希望 Anders 继续在 Delphi 产品线上投入全力，因此当时 Delbert 并没批准 Anders 的请求。Borland 的下一个重要的开发工具 JBuilder（当时的产品开发名称为 Latte），仍然交由其他小组负责。（每想到此，痛哭流涕啊）</p>

<p>也许是 Anders 注定和 Borland 的缘分已经到了尽头，正好这个时候 Microsoft 展开了有史以来对 Borland 最大的挖角行动。在 Anders 无法在 Borland 取得满意的支持之后， Microsoft 提供的优厚条件顿时对 Anders 产生了致命的吸引力，从而造成了 Borland 无法挽回的遗憾。</p>

<p>Bill Gates 亲自三顾茅庐，最后答应 Anders 来微软开发 “Delphi for Java”。于是便有当时最快的 java 开发工具和最棒的 java 虚拟机 —— Visual J++。这也导致了后来 sun 和 微软的官司，已经 Borland 和微软的官司。（感觉微软和360挺像的）</p>

<p>由于微软不能在继续开发 java，于是 Anders 便开发了可以和 java 抗衡的语言，以及可以和 jvm 抗衡的平台，那就是 C# 以及 .net。</p>

<p>关于 Anders，就不再多说了。</p>

<p>致敬！</p>

<p>附赠一个番外篇：<a rel=""nofollow"" href=""http://justjavac.com/other/2012/10/21/three-eye-popping-world-class-computer-masters.html"">让人目瞪口呆的三位世界级电脑大师</a></p>

                ", IT 大牛们的小传，有点academic风格的说^_^,1531978062,505,1,868,1,1,https://segmentfault.com/a/1190000000313378
147,1,0,9,"
                    <p>Fen (@<a rel=""nofollow"" href=""http://weibo.com/fenbox"">fenbox</a>)，性格安静，理想主义者，爱自由。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbq52"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""董锋""></span></p>

<p><strong>导语：</strong>本期采访对象董锋，87年生人，是程序员问答社区SegmentFault的设计师、前端工程师及联合创始人，也是开源项目 Typecho 的成员之一。由于董锋常驻杭州，所以采用了邮件采访的方式。初次见他是在北京黑客马拉松现场，安静、清瘦，是典型的技术宅，但谈起技术和设计却充满了热情。让我联想到格雷厄姆的《黑客与画家》，由于横跨设计和编程两个领域，前端工程师更像是黑客与画家两者的结合体。也正是这个灵光闪现的瞬间，让我决定启动技术人攻略的人物访谈，通过采访一线工程师，真实的记录他们的成长经历，并将他们对技术的热爱传递给更多的人。星星之火，可以燎原，相信读者可以从中获取力量、找到共鸣。</p>

<h2>寻找平衡点</h2>

<blockquote>
  <p>开发和设计之间存在一种平衡，当我们拨到这个平衡点的时候，整个产出过程都变得秩序井然。就好像万物在共同呼吸，共同生长一样。</p>
</blockquote>

<ul>
<li>技术人攻略：请介绍你一下你自己？当初为什么会选择进入前端开发这个领域？</li>
</ul>

<p>过去带了几道光环，算是半个画家。高中后目睹绘画成为考大学捷径的风气蔓延后三观尽毁，弃笔从文，成了名普通考生。也因痴迷电脑成了名计算机科班的学生。这个专业，人人都会编程。面对清一色的作品，都觉得乏味。为了让自己的作品与众不同，又不耽误打 DOTA 的时间，就发挥了自己的特长把界面做得好看点，博得眼前一亮。
紧接着搭了 Blog 的顺风车，做的几个模板在 WordPress 社区反响还不错，也上了 Smashing Magazine 的推荐，那时 XHTML 和 CSS 概念刚刚兴起，我就这么走进了“前端开发”领域了，并没有“选择”这一说，只是相对其他类型的开发我多学了点，而且那时候还没有“前端”这个概念。
我的第一份工作不是开发，也不是设计。而是自己一无所知的领域：产品。选择的理由仅仅是因为这职位只招 1 人，听起来可笑，毫无逻辑。我很感谢 HR 和面试官，能给我这个机会，进了这个遍布地雷、前有埋伏后有追兵的战场。从跟客户、用户交流，挖掘需求，到跟开发、设计和上级的磋商实现。自身的开发和设计经验，使自己在整个交流过程做到心中有数。
这份工作，让我领悟到开发和设计之间存在一种平衡，当我们拨到这个平衡点的时候，整个产出过程都变得秩序井然。就好像万物在共同呼吸，共同生长一样。</p>

<ul>
<li>技术人攻略：投资人Chris
Dixon在Twitter上把能同时做设计和编程的人称作""desingineer""，称他们是创业公司努力寻找的传奇人物。在你看来，想成为一个优秀的
Desingineer，哪些是最重要的技能，有哪些难点？</li>
</ul>

<p>我还在成长的路上，只能分享些自己的体会。设计和开发都是很重要的技能，没什么技巧，关键就是坚持练习，练内功。与纯设计或纯开发相比，我们练的是小无相功，以此功催动各种招式，是最强最快的方法。当二者的平衡发挥到极致时，在创业公司中将威力无穷。但也要清楚的知道自身硬伤，并不能完全替代任何一个。</p>

<ul>
<li>技术人攻略：你遇到过的较大的技术或设计上的挑战是什么？带给你很强成就感的项目有哪些？</li>
</ul>

<p>技术上最大的挑战是让我装机修电脑，学计算机真不是学这个的啊。
设计上最大的挑战是让我做平面设计，平面设计和 UI 设计完全是两种思路，让我很分裂。我很喜欢这些挑战，每次战胜后都觉得自己更强大了。</p>

<h2>爱开源，更爱脚踏实地</h2>

<blockquote>
  <p>我们从开源世界里获益匪浅，而对开源社区的最好回报，就是参与开源项目，分享我们的成长，这就是项目的初衷。</p>
</blockquote>

<ul>
<li>技术人攻略：你平时参与开源社区吗，以什么方式参与？有哪些关注的开源项目？</li>
</ul>

<p>我是开源项目 Typecho 的成员之一，主要负责设计。这是我最自豪的的项目之一。我们从开源世界里获益匪浅，而对开源社区的最好回报，就是参与开源项目，分享我们的成长，这就是项目的初衷。
Typecho 最近的版本是 3 年前发布的，界面是 5 年前设计的，在没有任何运营的情况下用户一直在源源不断地增长，而且抗议呼声越来越高。不论走到哪里，都会有用户问我什么时候发布新版。这些年，我们都有了很大的成长，却没有将成长回馈给社区。不管是什么理由，都让我非常愧疚。</p>

<ul>
<li>技术人攻略：Github上JavaScript语言排在第一，感觉前端技术社区感觉活跃，实际情况如何？社区里有人质疑前端工程师的技术能力，你对这个问题怎么看？</li>
</ul>

<p>前端是个很折腾的职业，所以前端社区看起来很活跃，但很多氛围并不好，总流露着一股咄咄逼人的气势或是孤芳自赏的姿态。只有务实地改进生产力的前端项目，才会产生沉淀，才能得到认同。</p>

<h2>创业是在巨浪中前进</h2>

<blockquote>
  <p>岿然不动的富士山是目标，船员是创业者，在巨浪中前进就是创业的过程。</p>
</blockquote>

<ul>
<li>技术人攻略：为什么加入 SegmentFault ？</li>
</ul>

<p>也许我今后很难再遇到这么优秀的团队了，这是个机会；
我在 SegmentFault 上提升了自己后端开发的技能，说明这个社区有价值； 
我再也不用痛苦的调试浏览器的兼容问题了，还在用的 IE 8 以下的开发者都将被拒之门外。</p>

<ul>
<li>技术人攻略：你怎么看待创业？</li>
</ul>

<p>用一幅画来描述创业吧：《神奈川冲浪里》 。
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbq54"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""神奈川冲浪里""></span></p>

<p>这是我很喜欢的一幅画，最近我才领悟其含义：岿然不动的富士山是目标，船员是创业者，在巨浪中前进就是创业的过程。</p>

<ul>
<li>技术人攻略：你未来1-2年的目标是什么？</li>
</ul>

<p>打通 SegmentFault 的各路经脉，跟我的合伙人们一起把公司经营好；
回馈开源社区，改进 Typecho；
再开发 2~3 个有价值的产品，顺便提升下自己；
还有好多，这儿写不下了。</p>

<ul>
<li>技术人攻略：你欣赏的技术人有哪些？</li>
</ul>

<p>佩奇和小扎这些众人耳熟的是我欣赏的，Blake Ross 和 Aaron Swartz 也是我很欣赏的的技术人，他们都为建立更加开放的互联网做出了不可磨灭的贡献。</p>

<ul>
<li>技术人攻略：你最欣赏什么公司？</li>
</ul>

<p>37signals - 创造了一系列改进生产力的产品，创造了 Ruby on Rails，还顺手写了两本影响了全行业的书，公司员工分布全球，生活办公都自由支配。而且一直在印钞票，有众多的设计师、开发者、创业者们用户，这实在是太酷了，简直是梦想的公司。</p>

<ul>
<li>技术人攻略：你平时的兴趣爱好是什么？</li>
</ul>

<p>创业后，我的兴趣爱好变成了做饭，吃到好吃的脑中就会闪过各种配料，放假时间买一堆食材回来慢慢研究各类美食的做法。反正是自己吃，怎么尝试都行。为了研制绝世好粥，我吃了一星期的粥……</p>

<p><strong>可能我没有谈太多的设计，也没有谈太多技术。设计和技术都应留给各自的大牛谈，班门弄斧可不敬。游走在设计和开发间，靠双手实现我们想做的东西，这才是存在的价值。</strong></p>

<hr>

<p>技术人攻略访谈是关于技术人生活和成长的系列访问，欢迎和我们有共同价值观的你关注“<a rel=""nofollow"" href=""http://www.devlevelup.com"">技术人攻略</a>”，邮箱 devlevelup@gmail.com，新浪微博 @<a rel=""nofollow"" href=""http://weibo.com/devlevelup"">devlevelup</a>，希望能成为技术人成长的精神家园。</p>

<p>欢迎通过微信公众账号关注技术人攻略</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbq6f"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""技术人攻略微信公众账号""></span></p>

                ", 技术人攻略访谈二：游走于开发与设计之间的黑客画家,1531978064,430,1,791,1,1,https://segmentfault.com/a/1190000000303429
148,1,0,9,"
                    <h1>如何开始你的 SOHO 之旅  (1)</h1>

<p><span class=""img-wrap""><img data-src=""https://writingsio.s3.amazonaws.com/attachments/520d633ea6376c380e000079/32d3e1f754ddee9f7b02883a3667b530/soho.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>仔细算算自己在家上班已经有差不多4年了，所以回想起整个过程，只有一种感受，那就是再也回不去了。我相信很多在家工作多年的朋友也会有同样的感受，“自由”这东西一旦拥有就太难再放弃掉。</p>

<p>我现在无法想象我每天要在上下班的路上耽搁1-2个小时，每天要准时一大早起床，每周无论有事没事都必须工作5天，不能每天坐在我最舒适的椅子和桌子面前工作... 最关键的是，我不能放弃这一份已经拥有的 “自由” --- 嗯？问题搞深沉了.. 这篇文章我并不是想介绍在家 SOHO如何如何好，我想谈的是如果你也想成为一名在家 SOHO 的程序员你应该怎么做。</p>

<h2>程序员在家工作的几种选择：</h2>

<ol>
<li>做一名 freelancer, 自己接项目</li>
<li>加入一个允许在家工作的公司</li>
<li>争取成为你现在公司第一个在家工作的员工</li>
<li>创业，并让你的公司允许远程办公</li>
<li>成为一名独立开发者(开发应用, 或者是独立咨询)</li>
</ol>

<p>如果在家办公是一个你很重要的诉求，那么你不妨考虑一下上面 5 种选择，看看哪种更加适合你。然后制定一个清晰的计划并为此努力。 当然，其中 1, 2, 3 相对要容易一些（要做好其实也不容易，更合适的说法或许是风险要低一些吧。），4, 5相对要难一些。如果 4, 5是你想要做的，不妨从 1, 2, 3里选一个作为过度，有一定积累后再完成你的最终目标。</p>

<p>本文将介绍第一点，后续文章会逐步介绍其他几点。</p>

<h3>做一名 Freelancer, 自己接项目</h3>

<p><span class=""img-wrap""><img data-src=""https://writingsio.s3.amazonaws.com/attachments/520d604da6376c380e000076/2eeb3fee2ac3b078a67ec8c78443cecb/freelance.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<blockquote>
  <p>Freelance这个词最早出现时是用来指称“中世纪的雇佣军骑士”，即“free-lance”; 随着时间推移，它慢慢被用于指称自由撰稿人(应该算自由职业中非常流行的行当，特别是在西方国家)，进而扩大至指称所有自由职业者们。</p>
  
  <p>因为自由职业者们通常是脑力劳动者或服务提供者，并且大多是自己所在领域的专家或资历丰富者，加上又不要求签订长期的工作协议或合同，许多企业或个人愿意将自己的项目外包(Outsourcing)给他们。</p>
  
  <p>-- Freelancer专属™ 博客</p>
</blockquote>

<p>做 Freelancer 最需要解决的是项目来源问题，而项目来源最主要的途径通常是有四种：</p>

<h4>通过在线 Freelance 平台接项目</h4>

<p>类似的平台有很多，相对传统且做的较大的有：</p>

<ol>
<li><a rel=""nofollow"" href=""http://www.freelancer.com/"">freelancer.com</a></li>
</ol>

<p>freelancer.com 可以算是资格最老的 freelance 平台了，以前也曾是那么的辉煌。但是，现在这里已经慢慢变成了一个几乎所有项目都会有一堆印度人以极低的价格和你血拼的地方。我个人认为要想做 Freelancer， 一定不能拼价格，特别是和印度人拼价格。 最主要还是能提供更好的服务，更好的完成任务，写出更易维护的代码...  但是如果你是初出茅庐，最难的或许是如何证明你有这样的实力，为什么要收比那些印度人更高的价格。是的，你必须收比他们更高的价格，因为经过我的计算，大多情况下如果你和他们收一样的价格，你几乎不太可能养活你自己。毕竟，你夏天还得吹吹空调吧... :p</p>

<p>所以， 如果你有一些开源的项目或者在线运行的项目能证明你的实力的，千万不要羞于拿出来，否则你或许前几单真要和他们拼价格了。</p>

<p>freelancer.com 里的优质项目的比例真的已经比以前低很多，或许花时间在里面找到优质项目就够你麻烦的了。所以我个人现在并不推荐你来这里接货儿。</p>

<ol>
<li><a rel=""nofollow"" href=""https://www.odesk.com/"">oDesk</a></li>
</ol>

<p>oDesk 相对于 freelancer.com 最大的特点是。它更支持客户给 freelancers 按小时结算。在我看来在此类似平台接项目，按小时计费是很重要的。因为这类平台客户要把需求写得十分精准几乎是很难的，你的程序需要来回修改几乎是家常便饭。如果按小时收费，那么这个来回修改的费用将由客户来承担，这也从另一方面促使他们把问题想清楚，把需求写得更加清楚。</p>

<p>另外 oDesk 要通过视频来和屏幕截图来监视你是不是认真的工作了你说的那么多小时... WTF... 我们干 freelancer 不是为了自由吗？ 这么搞是要闹哪样？</p>

<p>就因为这一点，我真的不推荐这个平台。不过这个平台的 rate 相对 freelancer.com 高一些。你是不是要暂时放下你的自由？还是你自己决定吧!! &#62;.\&lt;</p>

<ol>
<li><a rel=""nofollow"" href=""https://www.elance.com/"">Elance</a></li>
</ol>

<p>Elance 在我看来相对于上两个要好一些。一方面它项目的平均 rate 要高一些。另一方面他也没有恶心的视频监控之类的东西。但是你需要填写你每天工作花了多少时间，具体做了什么事情。相信我，这要求真不过分。即使客户不做这种要求，我自己也会写的。</p>

<p>​4. <a rel=""nofollow"" href=""http://www.topcoder.com/"">TopCoder</a></p>

<p>TopCoder 看似是比赛，实际上他是通过比赛的形式来做外包，这个平台和其它平台比起来非常特别。要注意的是，你做好的东西，会有人 review, 选出前三名。而只有前三名有钱拿（相对较高），后面的名次是没有钱拿的。所以有可能你会白劳动。如果你做出一些成绩后，你可以做那些 review 别人代码的人，而 review 本身也是收费的。</p>

<p>这里要特别注意，这个平台 .NET 和 Java 的人特别多，竞争非常激烈。反儿，做前端的人特别少，相对没什么竞争。所以如果你是个不错的前端，别忘了考虑考虑哦。:)</p>

<h4>Job Board</h4>

<p>除了传统的接项目平台，去一些不错的 Job Board 找项目是<strong>非常不错的选择</strong>。虽然大多可能是全职的工作居多，但是招募 freelancer 的其实也不少，需要自己细心去挖掘。在这里推荐一些不错的：</p>

<p><a rel=""nofollow"" href=""https://jobs.github.com/"">jobs.github.com</a></p>

<p><a rel=""nofollow"" href=""http://careers.stackoverflow.com/jobs"">stackoverflow jobs</a></p>

<p><a rel=""nofollow"" href=""https://news.ycombinator.com/jobs"">ycombinator jobs</a></p>

<p><a rel=""nofollow"" href=""http://jobs.37signals.com/"">37signals jobs</a></p>

<p><a rel=""nofollow"" href=""http://gun.io/"">gun.io</a></p>

<p>这种方式拿到的项目，普遍 rate 要高一些并且靠谱率也要高一些（靠谱率 lol...）。 如果你初来乍到，这种途径对于你自己的实力以及和客户的沟通能力都是非常大的挑战...</p>

<h4>通过朋友介绍</h4>

<p>其实最好的接活儿的方式还是通过朋友介绍，可以是你的前同事，前客户，你同行的朋友。朋友介绍通常的好处是，客户相对更加容易信任你，而且你朋友通常会做一些筛选，那么项目也相对更靠谱一些。所以和你以前的同事保持良好的关系，经常的沟通是非常重要的。</p>

<p>如果没有相关资源怎么办？ 去认识那些你优秀的同行朋友。相信我，勇敢的走出这一步，参加各种活动，想办法去认识那些靠谱的人，并想办法证明你自己也非常靠谱。这样当他们有了项目需要找人，或许脑海里你就在那个“靠谱开发人员”的list里。</p>

<h4>让客户自己找上门来</h4>

<p>这一点真的很难，但是绝不是做不到。要想让客户找上门来，你必须要有一定知名度。而积累知名度不外乎以下几种方法：</p>

<ol>
<li>写优秀技术博客，并且坚持 ( 比如 XDite 同学的 <a rel=""nofollow"" href=""http://blog.xdite.net/"">Blog</a>)</li>
<li>做客户能访问甚至正在使用的优秀的项目 (比如咱们的 <a rel=""nofollow"" href=""https://pragmatic.ly"">Pragmatic.ly</a> :D )</li>
<li>参与或创建一些优秀的开源项目 (比如 <a rel=""nofollow"" href=""http://blog.huangzhimin.com/"">Richard</a> 同学的 <a rel=""nofollow"" href=""https://github.com/railsbp/rails_best_practices"">rails best practices</a>)</li>
<li>去技术会议上演讲 (比如赶快报名 <a rel=""nofollow"" href=""http://rubyconfchina.org/"">Rubyconf China 2013</a>)</li>
</ol>

<p>做好这几点都不是那么容易的事情，而且效果也绝不是立竿见影，且需要你坚持不懈的努力。但是一旦成功那么效果也将是极好的，rate 也将是极高的. 你懂的... :D</p>

<h3>总结一下，我觉得做 freelancer 几个重要的点</h3>

<ol>
<li>以上四种途径并不矛盾，而最终一定要向第四种努力</li>
<li>不要打价格战，一定要提供更好的服务</li>
<li>尽量接欧美的项目，相信我，相比而言 rate 比国内要高不少</li>
<li>英语对于一个 freelancer 来讲真的非常重要，特别是读和写</li>
<li>做事情一定要专业，避免情绪化</li>
<li>学会对客户 Say no!!</li>
<li>建立 reputation 极为重要，且一定要坚持不懈</li>
</ol>

<p>这个系列的第一篇就结束了，希望对你有所帮助，以后还会继续介绍 SOHO 相关的话题。</p>

<p>你可以 <a rel=""nofollow"" href=""http://weibo.com/poshboytl"">加我微博</a> 或 <a rel=""nofollow"" href=""https://twitter.com/poshboytl"">加我推特</a>，里面会有更多我 SOHO 相关的经验和心得。希望能和你多多交流和互动。</p>

                ", 如何开始你的 SOHO 之旅 (1),1531978066,490,1,809,1,1,https://segmentfault.com/a/1190000000269342
